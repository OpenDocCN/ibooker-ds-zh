- en: Level 3\. Experience
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3级\. 经验
- en: '![](pg_255.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_255.jpg)'
- en: '*The alpine chough lives and breeds in the thin air of high altitudes and has
    been seen above 8000 m in the Himalayas.*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*高山乌鸦生活在高海拔的稀薄空气中，并在喜马拉雅山脉8000米以上被观察到*。'
- en: In this level, we go more deeply into details about specific topics. The first,
    performance, is one of the primary reasons C is chosen over other programming
    languages. Therefore, [chapter 15](kindle_split_026.html#ch15) is a mandatory
    read for all C software designers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一级，我们将更深入地探讨特定主题的细节。第一个，性能，是选择C语言而不是其他编程语言的主要原因之一。因此，[第15章](kindle_split_026.html#ch15)对所有C软件设计师来说是必读的。
- en: 'The second topic is a feature that is quite specific to C: function-like macros.
    Because of their complexity and obvious ugliness, they are much frowned upon by
    other programming communities. Nevertheless, it is important to master them to
    a certain extent, because they allow us to provide easy-to-use interfaces: for
    example, for type-generic programming and more sophisticated parameter checking.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主题是C语言特有的一个特性：函数式宏。由于它们的复杂性和明显的丑陋，其他编程社区对此非常反感。尽管如此，在一定程度上掌握它们是很重要的，因为它们允许我们提供易于使用的接口：例如，用于泛型编程和更复杂的参数检查。
- en: '[Chapters 17](kindle_split_028.html#ch17) and [18](kindle_split_029.html#ch18)
    then show how the usual assumption of sequential program execution can be weakened
    to allow for asynchronous problem handling (with long jumps or signal handlers)
    or the parallel execution of threads. These come with specific problems related
    to guaranteeing data consistency, so we conclude with [chapter 19](kindle_split_030.html#ch19),
    which dives more deeply into the handling of atomic data and synchronization in
    general.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](kindle_split_028.html#ch17)和[第18章](kindle_split_029.html#ch18)展示了如何减弱通常的顺序程序执行假设，以允许异步问题处理（使用长跳转或信号处理程序）或线程的并行执行。这些带来了与保证数据一致性相关的问题，因此我们以[第19章](kindle_split_030.html#ch19)结束，该章更深入地探讨了原子数据和同步的一般处理。'
- en: Chapter 15\. Performance
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章\. 性能
- en: This chapter covers
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Writing inline functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写内联函数
- en: Restricting pointers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制指针
- en: Measuring and inspecting performance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量和检查性能
- en: 'Once you feel more comfortable when coding in C, you will perhaps be tempted
    to do complicated things to “optimize” your code. Whatever you think you are optimizing,
    there is a good chance you will get it wrong: premature optimization can do a
    great deal of harm in terms of readability, soundness, maintainability, and so
    on. Knuth [[1974](kindle_split_036.html#bib9)] coined the following phrase that
    should be your motto for this whole level:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在C语言编程中感到更加自在，你可能会被诱惑去做一些复杂的事情来“优化”你的代码。无论你认为你在优化什么，你很可能做错：过早优化可能会在可读性、稳定性、可维护性等方面造成很大的损害。Knuth
    [[1974](kindle_split_036.html#bib9)] 提出了以下应该成为你整个这一级水平的座右铭的短语：
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway D
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 吸收点D
- en: '*Premature optimization is the root of all evil.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*过早优化是万恶之源*。'
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Its good performance is often cited as one of the main reasons C is used so
    widely. While there is some truth to the idea that many C programs outperform
    code of similar complexity written in other programming languages, this aspect
    of C may come with a substantial cost, especially concerning safety. This is because
    C, in many places, doesn’t enforce rules, but places the burden of verifying them
    on the programmer. Important examples for such cases are
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它的良好性能经常被引用为C语言被广泛使用的主要原因之一。虽然许多C程序在类似复杂性的代码中确实优于其他编程语言，但这种C语言的特点可能伴随着相当大的代价，尤其是在安全性方面。这是因为C语言在很多地方并不强制执行规则，而是将验证它们的负担放在程序员身上。这类情况的重要例子包括
- en: Out-of-bounds access of arrays
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组越界访问
- en: Accessing uninitialized objects
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问未初始化的对象
- en: Accessing objects after their lifetime has ended
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象生命周期结束后访问对象
- en: Integer overflow
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数溢出
- en: These can result in program crashes, loss of data, incorrect results, exposure
    of sensitive information, and even loss of money or lives.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能导致程序崩溃、数据丢失、结果不正确、敏感信息泄露，甚至金钱或生命的损失。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.1
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 吸收点15.1
- en: '*Do not trade off safety for performance.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要为了性能而牺牲安全*。'
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'C compilers have become much better in recent years; basically, they complain
    about all problems that are detectable at compile time. But severe problems in
    code can still remain undetected in code that tries to be clever. Many of these
    problems are avoidable, or at least detectable, by very simple means:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，C编译器已经变得越来越好；基本上，它们会抱怨所有在编译时可以检测到的问题。但代码中的严重问题仍然可能在试图变得聪明的情况下未被检测到。许多这些问题可以通过非常简单的方法避免，或者至少可以检测到：
- en: All block-scope variables should be initialized, thereby eliminating half the
    problems with uninitialized objects.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有块作用域变量都应初始化，从而消除未初始化对象问题的一半。
- en: Dynamical allocation should be done with **calloc** instead of **malloc** wherever
    that is suitable. This avoids another quarter of the problems with uninitialized
    objects.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适合的地方，应使用**calloc**而不是**malloc**进行动态分配。这避免了未初始化对象问题的另一部分。
- en: A specific initialization function should be implemented for more-complicated
    data structures that are allocated dynamically. That eliminates the rest of the
    problems with uninitialized objects.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应为更复杂且动态分配的数据结构实现特定的初始化函数。这消除了未初始化对象问题的其余部分。
- en: 'Functions that receive pointers should use array syntax and distinguish different
    cases:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收指针的函数应使用数组语法并区分不同的情况：
- en: '*A pointer to a single object of the type* – These functions should use the
    **`static`** `1` notation and thus indicate that they expect a pointer that is
    non-null:'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指向单个对象的指针* – 这些函数应使用**`static`** `1`表示法，从而表明它们期望一个非空指针：'
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*A pointer to a collection of objects of known number* – These functions should
    use the **`static`** N notation and thus indicate that they expect a pointer that
    points to at least that number of elements:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指向已知数量对象的集合的指针* – 这些函数应使用**`static`** N表示法，从而表明它们期望一个指向至少该数量元素的指针：'
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*A pointer to a collection of objects of unknown number* – These functions
    should use the VLA notation:'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指向未知数量对象的集合的指针* – 这些函数应使用VLA表示法：'
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*A pointer to a single object of the type or a null pointer* – Such a function
    must guarantee that even when it receives a null pointer, the execution remains
    in a defined state:'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指向单个对象或空指针的指针* – 这样的函数必须保证即使在它接收到空指针时，执行仍然处于定义状态：'
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compiler builders only start to implement checks for these cases, so your compiler
    probably will not yet detect such errors. Nevertheless, writing these down and
    make them clear for yourself will help you to avoid out-of-bounds errors.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编译器构建者才开始实现对这些情况的检查，因此您的编译器可能还无法检测到这些错误。尽管如此，将这些错误记录下来并使它们对自己清晰，将有助于您避免越界错误。
- en: Taking addresses of block-scope (local) variables should be avoided, if possible.
    Therefore, it is good practice to mark all variables in complex code with **`register`**.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，应避免获取块作用域（局部）变量的地址。因此，在复杂代码中标记所有变量为**`register`**是一个好习惯。
- en: Use unsigned integer types for loop indices, and handle wrap-around explicitly.
    The latter can, for example, be achieved by comparing the loop variable to the
    maximum value of the type before the increment operation.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无符号整数类型作为循环索引，并显式处理溢出。例如，可以通过在增量操作之前将循环变量与类型的最大值进行比较来实现。
- en: Despite what some urban myths suggest, applying these rules usually will not
    negatively impact the performance of your code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些城市传说可能暗示，但通常应用这些规则不会对您的代码性能产生负面影响。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 15.2
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要15.2
- en: '*Optimizers are clever enough to eliminate unused initializations.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化器足够聪明，可以消除未使用的初始化。*'
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 15.3
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要15.3
- en: '*The different notations of pointer arguments to functions result in the same
    binary code.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数指针参数的不同表示法会产生相同的二进制代码。*'
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 15.4
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要15.4
- en: '*Not taking addresses of local variables helps the optimizer because it inhibits
    aliasing.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*不获取局部变量的地址有助于优化器，因为它抑制了别名化。*'
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Once we have applied these rules and have ensured that our implementation is
    safe, we may have a look at the performance of the program. What constitutes good
    performance and how we measure it is a difficult subject by itself. A first question
    concerning performance should always be relevance: for example, improving the
    runtime of an interactive program from 1 *ms* to 0.9 *ms* usually makes no sense
    at all, and any effort spent making such an improvement is probably better invested
    elsewhere.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了这些规则并确保了我们的实现是安全的，我们就可以看看程序的性能了。什么构成了良好的性能以及我们如何衡量它，本身就是一个难题。关于性能的第一个问题始终是相关性：例如，将交互式程序的运行时间从1
    *ms* 提高到0.9 *ms* 通常毫无意义，而且花费在这种改进上的任何努力可能都更适合投资在其他地方。
- en: To equip us with the necessary tools to assess performance bottlenecks, we will
    discuss how to measure performance ([section 15.3](#ch15lev1sec3)). This discussion
    comes at the end of this chapter because before we can fully understand measuring
    performance, we have to better understand the tools for making performance improvements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们具备评估性能瓶颈所必需的工具，我们将讨论如何衡量性能 ([第15.3节](#ch15lev1sec3))。这次讨论位于本章的末尾，因为在我们完全理解衡量性能之前，我们必须更好地理解用于提高性能的工具。
- en: 'There are many situations in which we can help our compiler (and future versions
    of it) to optimize code better, because we can specify certain properties of our
    code that it can’t deduce automatically. C introduces keywords for this purpose
    that are quite special in the sense that they constrain not the compiler but the
    programmer. They all have the property that *removing them* from valid code where
    they are present should not change the semantics. Because of that property, they
    are sometimes presented as useless or even obsolete features. Be careful when
    you encounter such statements: people who make such claims tend not to have a
    deep understanding of C, its memory model, or its optimization possibilities.
    And, in particular, they don’t seem to have a deep understanding of cause and
    effect, either.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况，我们可以帮助我们的编译器（及其未来的版本）更好地优化代码，因为我们能够指定代码的某些属性，这些属性它无法自动推导。C为此引入了一些关键字，它们在意义上非常特殊，因为它们约束的不是编译器而是程序员。它们都具有这样的属性：*从有效代码中移除它们*，即使它们存在，也不应该改变语义。正因为这个属性，它们有时被呈现为无用的甚至过时的特性。当你遇到这样的声明时，要小心：提出这种主张的人往往对C、其内存模型或其优化可能性缺乏深刻的理解。特别是，他们似乎对因果关系也没有深刻的理解。
- en: The keywords that introduce these optimization opportunities are **`register`**
    (C90), **`inline`**, **`restrict`** (both from C99), and **`alignas`** (respectively
    **`_Alignas`**, C11). As indicated, all four have the property that they could
    be omitted from a valid program without changing its semantics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 引入这些优化机会的关键字是 **`register`**（C90）、**`inline`**、**`restrict`**（均来自C99）和 **`alignas`**（分别对应
    **`_Alignas`**，C11）。正如所示，它们都具有这样的属性：在有效的程序中，即使省略它们也不会改变其语义。
- en: In [section 13.2](kindle_split_023.html#ch13lev1sec2), we spoken to some extent
    about **`register`**, so we will not go into more detail than that. Just remember
    that it can help to avoid aliasing between objects that are defined locally in
    a function. As stated there, I think this is a feature that is much underestimated
    in the C community. I have even proposed ideas to the C committee (Gustedt [[2016](kindle_split_036.html#bib5)])
    about how this feature could be at the heart of a future improvement of C that
    would include global constants of any object type and even more optimization opportunities
    for small pure functions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第13.2节](kindle_split_023.html#ch13lev1sec2) 中，我们多少讨论了 **`register`**，所以我们将不会深入探讨。只需记住，它可以帮助避免在函数中局部定义的对象之间的别名。正如那里所述，我认为这是C社区中一个被大大低估的特性。我甚至向C委员会（Gustedt
    [[2016](kindle_split_036.html#bib5)]) 提出了关于如何使这个特性成为C未来改进核心的想法，这将包括任何对象类型的全局常量以及更多针对小型纯函数的优化机会。
- en: In [section 12.7](kindle_split_022.html#ch12lev1sec7), we also discussed C11’s
    **`alignas`** and the related **`alignof`**. They can help to position objects
    on cache boundaries and thus improve memory access. We will not go into more detail
    about this specialized feature.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第12.7节](kindle_split_022.html#ch12lev1sec7) 中，我们也讨论了C11的 **`alignas`** 和相关的
    **`alignof`**。它们可以帮助将对象定位在缓存边界上，从而提高内存访问。我们不会深入探讨这个专门特性。
- en: The remaining two features, C99’s **`inline`** ([section 15.1](#ch15lev1sec1))
    and **`restrict`** ([section 15.2](#ch15lev1sec2)), have very different usability.
    The first is relatively easy to use and presents no danger. It is a tool that
    is quite widely used and may ensure that the code for short functions can be directly
    integrated and optimized at the caller side of the function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个特性，C99的**`inline`** ([第15.1节](#ch15lev1sec1)) 和 **`restrict`** ([第15.2节](#ch15lev1sec2))，具有非常不同的可用性。第一个相对容易使用，没有危险。这是一个相当广泛使用的工具，可以确保短函数的代码可以直接集成并在函数的调用方进行优化。
- en: The latter, **`restrict`**, relaxes the type-based aliasing considerations to
    allow for better optimization. Thus it is subtle to use and can do considerable
    harm if used badly. It is often found in library interfaces, but much less in
    user code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 后者，**`restrict`**，放宽了基于类型的别名考虑，以允许更好的优化。因此，它的使用很微妙，如果使用不当可能会造成相当大的损害。它通常出现在库接口中，但在用户代码中则很少见。
- en: The remainder of this chapter ([section 15.3](#ch15lev1sec3)) dives into performance
    measurement and code inspection, to enables us to asses performance by itself
    and the reasons that lead to good or bad performance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分（[第15.3节](#ch15lev1sec3)）深入探讨了性能测量和代码检查，使我们能够单独评估性能以及导致性能好或坏的原因。
- en: 15.1\. Inline functions
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1. 内联函数
- en: 'For C programs, the standard tool to write modular code is functions. As we
    have seen, they have several advantages:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C程序来说，编写模块化代码的标准工具是函数。正如我们所见，它们有几个优点：
- en: They clearly separate interface and implementation. Thereby they allow us to
    improve code incrementally, from revision to revision, or to rewrite functionality
    from scratch if deemed necessary.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们清楚地分离了接口和实现。因此，它们允许我们逐步改进代码，从修订到修订，或者如果认为有必要，从头开始重写功能。
- en: If we avoid communicating with the rest of the code via global variables, we
    ensure that the state a function accesses is local. That way, the state is present
    in the parameters of the call and local variables only. Optimization opportunities
    may thus be detected much more easily.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们避免通过全局变量与代码的其他部分进行通信，我们就能确保函数访问的状态是局部的。这样，状态就只存在于调用的参数和局部变量中。因此，可以更容易地检测到优化机会。
- en: 'Unfortunately, functions also have some downsides from a performance point
    of view:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，从性能的角度来看，函数也有一些缺点：
- en: Even on modern platforms, a function call has a certain overhead. Usually, when
    calling a function, some stack space is put aside, and local variables are initialized
    or copied. Control flow jumps to a different point in the executable, which might
    or might not be in the execution cache.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在现代平台上，函数调用也有一定的开销。通常，在调用函数时，会留出一些栈空间，并初始化或复制局部变量。控制流跳转到可执行文件中的不同点，这可能在或不在执行缓存中。
- en: Depending on the calling convention of the platform, if the return value of
    a function is a **`struct`**, the whole return value may have to be copied where
    the caller of the function expects the result.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据平台的调用约定，如果函数的返回值是一个**`struct`**，整个返回值可能必须复制到函数调用者期望结果的地方。
- en: If, by coincidence, the code of the caller (say, fcaller) and the callee (say,
    fsmall) are present inside the same translation unit (TU), a good compiler may
    avoid these downsides by *inlining*. Here, the compiler does something equivalent
    to replacing the call to fsmall with the code of fsmall itself. Then there is
    no call, and so there is no call overhead.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，出于巧合，调用者（例如，fcaller）和被调用者（例如，fsmall）的代码都位于同一个翻译单元（TU）内，一个好的编译器可以通过内联来避免这些缺点。在这里，编译器做的是用fsmall本身的代码替换对fsmall的调用。这样就没有调用，因此也就没有调用开销。
- en: Even better, since the code of fsmall is now inlined, all instructions of fsmall
    are seen in that new context. The compiler can detect, for example,
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，由于fsmall的代码现在被内联了，fsmall的所有指令都可以在这个新的上下文中看到。编译器可以检测到，例如，
- en: Dead branches that are never executed
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不会执行的死分支
- en: Repeated computation of an expression where the result is already known
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复计算已知结果的表达式
- en: That the function (as called) may only return a certain type of value
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数（如调用）可能只能返回某种类型的值
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.5
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 15.5节要点
- en: '*Inlining can open up a lot of optimization opportunities.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*内联可以打开许多优化机会*。'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'A traditional C compiler can only inline functions for which it also knows
    the definition: only knowing the declaration is not enough. Therefore, programmers
    and compiler builders have studied the possibilities to increase inlining by making
    function definitions visible. Without additional support from the language, there
    are two strategies to do so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的C编译器只能内联它也了解定义的函数：只知道声明是不够的。因此，程序员和编译器构建者研究了通过使函数定义可见来增加内联的可能性。如果没有语言提供的额外支持，有两种策略可以实现这一点：
- en: 'Concatenate all code of a project into a single large file, and then compile
    all that code in one giant TU. Doing such a thing systematically is not as easy
    as it sounds: we have to ensure that the concatenation order of the source files
    doesn’t produce definition cycles and that we don’t have naming conflicts (for
    example, two TUs, each with a **`static`** function init).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个项目的所有代码连接成一个单独的大文件，然后在一个巨大的TU中编译所有这些代码。系统地做这样的事情并不像听起来那么简单：我们必须确保源文件的连接顺序不会产生定义循环，并且我们不会遇到命名冲突（例如，两个TU，每个都有一个**`static`**函数init）。
- en: Functions that should be inlined are placed in header files and then included
    by all TUs that need them. To avoid the multiple definitions of the function symbol
    in each TU, such functions must be declared **`static`**.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该内联的函数被放置在头文件中，然后由所有需要它们的TU包含。为了避免在每个TU中函数符号的多重定义，这些函数必须被声明为**`static`**。
- en: 'Where the first approach is infeasible for large projects, the second approach
    is relatively easy to put in place. Nevertheless, it has drawbacks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一种方法对于大型项目不可行时，第二种方法相对容易实施。尽管如此，它也有缺点：
- en: If the function is too big to be inlined by the compiler, it is instantiated
    separately in every TU. That is, a function that big will potentially have a lot
    of copies and increase the size of the final executable.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数太大，编译器无法内联，它将在每个TU中单独实例化。也就是说，如此大的函数可能会有很多副本，从而增加最终可执行文件的大小。
- en: Taking a pointer of such a function will give the address of the particular
    instance in the current TU. Comparison of two such pointers that have been obtained
    in different TUs will not compare as equal.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取此类函数的指针将给出当前TU中特定实例的地址。在不同TU中获得的此类指针的比较不会视为相等。
- en: If such a **`static`** function that is declared in a header file is not used
    in a TU, the compiler will usually warn about that non-use. So if we have a lot
    of such small functions in header files, we will see a lot of warnings, producing
    a lot of false alarms.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在头文件中声明的此类**`static`**函数在TU中没有使用，编译器通常会警告这种未使用的情况。因此，如果我们头文件中有许多这样的小函数，我们会看到很多警告，产生很多误报。
- en: To avoid these drawbacks, C99 has introduced the **`inline`** keyword. Unlike
    what the naming might suggest, this does not force a function to be inlined, but
    only provides a way that it *may* be.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些缺点，C99引入了**`inline`**关键字。与名称可能暗示的相反，这并不强制函数内联，而只是提供了一种它*可能*内联的方式。
- en: A function definition that is declared with **`inline`** can be used in several
    TUs without causing a multiple-symbol-definition error.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明为**`inline`**的函数定义可以在多个TU中使用，而不会引起多重符号定义错误。
- en: All pointers to the same **`inline`** function will compare as equal, even if
    obtained in different TUs.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有指向同一**`inline`**函数的指针都将视为相等，即使它们是在不同的TU中获得的。
- en: An **`inline`** function that is not used in a specific TU will be completely
    absent from the binary of that TU and, in particular, will not contribute to its
    size.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定TU中未使用的**`inline`**函数将完全从该TU的二进制文件中消失，并且特别是不会对其大小做出贡献。
- en: 'The latter point is generally an advantage, but it has one simple problem:
    no symbol for the function would ever be emitted, even for programs that might
    need such a symbol. There are several common situations in which a symbol is needed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 后者通常是一个优点，但它有一个简单的问题：即使对于可能需要此类符号的程序，也不会发出函数的任何符号。有几个常见的情况需要符号：
- en: The program directly uses or stores a pointer to the function.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序直接使用或存储函数的指针。
- en: 'The compiler decides that the function is too big or too complicated to inline.
    This situation varies and depends on several factors:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器决定该函数太大或太复杂，无法内联。这种情况因多种因素而异，具体如下：
- en: The optimization level that is used for the compilation
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编译的优化级别
- en: Whether debugging options are on or off
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试选项是开启还是关闭
- en: The use of certain C library function by the function itself
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数本身使用某些C库函数
- en: The function is part of a library that is shipped and linked with unknown programs.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数是包含在库中的，该库与未知程序一起分发和链接。
- en: To provide such a symbol, C99 has introduced a special rule for **`inline`**
    functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这样的符号，C99为**`inline`**函数引入了一条特殊的规则。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.6
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.6
- en: '*Adding a compatible declaration without the* **`inline`***keyword ensures
    the emission of the function symbol in the current TU.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*添加一个不带**`inline`***关键字的兼容声明确保了函数符号在当前TU中的发出。'
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As an example, suppose we have an **`inline`** function like this in a header
    file: say `toto.h`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在一个头文件中有一个**`inline`**函数，比如`say `toto.h`：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Such a function is a perfect candidate for inlining. It is really small, and
    the initialization of any variable of type toto is probably best made in place.
    The call overhead is of the same order as the inner part of the function, and
    in many cases the caller of the function may even omit the test for the **`if`**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数是内联的完美候选者。它真的非常小，任何类型为toto的变量的初始化可能最好是在原地完成。调用开销与函数的内部部分相同，在许多情况下，函数的调用者甚至可以省略对**`if`**的测试。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.7
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.7
- en: '*An* **`inline`***function definition is visible in all TUs.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**`inline`**函数定义在所有TUs中都是可见的。'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This function *may* be inlined by the compiler in all TUs that see this code,
    but none of them would effectively emit the symbol toto_init. But we can (and
    should) enforce the emission in one TU, `toto.c`, say, by adding a line like the
    following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数*可能*会被编译器在内所有看到此代码的TUs中内联，但它们中没有一个会有效地发出toto_init符号。但我们可以（并且应该）通过添加如下一行代码，在其中一个TU，例如`toto.c`中强制发出：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.8
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.8
- en: '*An* **`inline`** definition *goes in a header file.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**`inline`**定义*放在头文件中*。'
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.9
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.9
- en: '*An additional* declaration *without* **`inline`***goes in exactly one TU.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*额外的*声明*不包含**`inline`***的，将正好放入一个TU中。'
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As we said, that mechanism of **`inline`** functions is there to help the compiler
    make the decision whether to effectively inline a function. In most cases, the
    heuristics that compiler builders have implemented to make that decision are completely
    appropriate, and you can’t do better. They know the particular platform for which
    the compilation is done much better than you: maybe this platform didn’t even
    exist when you wrote your code. So they are in a much better position to compare
    the trade-offs between the different possibilities.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所言，**`inline`**函数的机制是为了帮助编译器做出决定是否有效地内联一个函数。在大多数情况下，编译器构建者为实现这一决定而实施的启发式方法是完全合适的，你无法做得更好。他们对你正在编译的平台了解得比你更好：也许当你编写代码时，这个平台甚至还不存在。因此，他们在比较不同可能性之间的权衡方面处于更好的位置。
- en: An important family of functions that may benefit from **`inline`** definitions
    is *pure functions*, which we met in [section 10.2.2](kindle_split_020.html#ch10lev2sec2).
    If we look at the example of the rat structure ([listing 10.1](kindle_split_020.html#ch10ex08)),
    we see that all the functions implicitly copy the function arguments and the return
    value. If we rewrite all these functions as **`inline`** in the header file, all
    these copies can be avoided using an optimizing compiler.^([[[Exs 1]](#ch15fn-ex01)])
    ^([[[Exs 2]](#ch15fn-ex02)])
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一组可能从**`inline`**定义中受益的重要函数是*纯函数*，我们在[第10.2.2节](kindle_split_020.html#ch10lev2sec2)中遇到过。如果我们看一下鼠结构体的示例（[列表10.1](kindle_split_020.html#ch10ex08)），我们会看到所有这些函数隐式地复制函数参数和返回值。如果我们将这些函数作为**`inline`**在头文件中重写，所有这些复制都可以通过优化编译器避免。^([[[Exs
    1]](#ch15fn-ex01)]) ^([[[Exs 2]](#ch15fn-ex02)])
- en: ^([Exs 1])
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rewrite the examples from [section 10.2.2](kindle_split_020.html#ch10lev2sec2)
    with **`inline`**.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将[第10.2.2节](kindle_split_020.html#ch10lev2sec2)的示例重写为**`inline`**。
- en: ^([Exs 2])
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Revisit the function examples in section 7, and argue for each of them whether
    they should be defined **`inline`**.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回顾第7节中的函数示例，并为每个示例争论它们是否应该定义为**`inline`**。
- en: So **`inline`** functions can be a precious tool to build portable code that
    shows good performance; we just help the compiler(s) to make the appropriate decision.
    Unfortunately, using **`inline`** functions also has drawbacks that should be
    taken into account for our design.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**`inline`**函数可以成为构建可移植代码的宝贵工具，该代码表现出良好的性能；我们只是帮助编译器（们）做出适当的决定。不幸的是，使用**`inline`**函数也有缺点，这些缺点应该在我们的设计中加以考虑。
- en: First, 15.7 implies that any change you make to an **`inline`** function will
    trigger a complete rebuild of your project and all of its users.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，15.7意味着你对**`inline`**函数所做的任何更改都将触发你的项目及其所有用户的完整重建。
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.10
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.10
- en: '*Only expose functions as* **`inline`***if you consider them to be stable.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*Only expose functions as* **`inline`***if you consider them to be stable.*'
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Second, the global visibility of the function definition also has the effect
    that local identifiers of the function (parameters or local variables) may be
    subject to macro expansion for macros that we don’t even know about. In the example,
    we used the toto_ prefix to protect the function parameters from expansion by
    macros from other include files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，函数定义的全局可见性也有这样的效果，即函数的局部标识符（参数或局部变量）可能受到我们甚至不知道的宏的宏展开的影响。在示例中，我们使用了 toto_
    前缀来保护函数参数免受其他包含文件中宏的展开。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.11
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.11
- en: '*All identifiers that are local to an* **`inline`***function should be protected
    by a convenient naming convention.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*All identifiers that are local to an* **`inline`***function should be protected
    by a convenient naming convention.*'
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Third, other than conventional function definitions, **`inline`** functions
    have no particular TU with which they are associated. Whereas a conventional function
    can access state and functions that are local to the TU (**`static`** variables
    and functions), for an **`inline`** function, it would not be clear which copy
    of which TU these refer to.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，除了传统的函数定义之外，**`inline`** 函数没有特定的 TU 与之关联。而一个传统的函数可以访问 TU 本地（**`static`**
    变量和函数）的状态和函数，对于一个 **`inline`** 函数，则不清楚这些引用指的是哪个 TU 的哪个副本。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.12
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.12
- en: '**`inline`***functions can’t access* identifiers *of* **`static`***functions.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**`inline`***functions can’t access* identifiers *of* **`static`***functions.*'
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.13
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.13
- en: '**`inline`***functions can’t define or access* identifiers *of modifiable*
    **`static`** *objects.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**`inline`***functions can’t define or access* identifiers *of modifiable*
    **`static`** *objects.*'
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Here, the emphasis is on the fact that access is restricted to the *identifiers*
    and not the objects or functions themselves. There is no problem with passing
    a pointer to a **`static`** object or a function to an **`inline`** function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，重点是访问限制在 *标识符* 上，而不是对象或函数本身。将指向 **`static`** 对象的指针或函数传递给 **`inline`** 函数没有问题。
- en: 15.2\. Using restrict qualifiers
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2\. 使用 restrict 指定符
- en: 'We have seen many examples of C library functions that use the keyword **`restrict`**
    to qualify pointers, and we also have used this qualification for our own functions.
    The basic idea of **`restrict`** is relatively simple: it tells the compiler that
    the pointer in question is the only access to the object it points to. Thus the
    compiler can make the assumption that changes to the object can only occur through
    that same pointer, and the object cannot change inadvertently. In other words,
    with **`restrict`**, we are telling the compiler that the object does not alias
    any other object the compiler handles in this part of the code.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多使用关键字 **`restrict`** 来指定指针的 C 库函数的例子，我们也为我们的函数使用了这种指定。**`restrict`**
    的基本思想相对简单：它告诉编译器，所讨论的指针是它指向的对象的唯一访问方式。因此，编译器可以做出假设，对象的变化只能通过相同的指针发生，对象不能意外地改变。换句话说，使用
    **`restrict`**，我们是在告诉编译器，该对象不与编译器在此代码部分处理的任何其他对象别名。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.14
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.14
- en: '*A* **`restrict`***-qualified pointer has to provide exclusive access.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* **`restrict`***-qualified pointer has to provide exclusive access.*'
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As is often the case in C, such a declaration places the burden of verifying
    this property on the caller.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，这种情况很常见，这样的声明将验证此属性的负担放在了调用者身上。
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.15
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 15.15
- en: '*A* **`restrict`***-qualification constrains the caller of a function.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* **`restrict`***-qualification constrains the caller of a function.*'
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Consider, for example, the differences between **memcpy** and **memmove**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 **memcpy** 和 **memmove** 之间的差异：
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For **memcpy**, both pointers are **`restrict`**-qualified. So for the execution
    of this function, the access through both pointers has to be exclusive. Not only
    that, s1 and s2 must have different values, and neither of them can provide access
    to parts of the object of the other. In other words, the two objects that **memcpy**
    “sees” through the two pointers must not overlap. Assuming this can help to optimize
    the function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **memcpy**，两个指针都是 **`restrict`**-qualified。因此，为了执行此函数，必须通过两个指针进行独占访问。不仅如此，s1
    和 s2 必须有不同的值，并且它们都不能提供对另一个对象部分的访问。换句话说，通过两个指针 **memcpy** “看到”的两个对象不能重叠。假设这有助于优化函数。
- en: In contrast, **memmove** does not make such an assumption. So s1 and s2 may
    be equal, or the objects may overlap. The function must be able to cope with that
    situation. Therefore it might be less efficient, but it is more general.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**memmove** 并不做出这样的假设。因此，s1 和 s2 可能相等，或者对象可能重叠。函数必须能够处理这种情况。因此，它可能效率较低，但更通用。
- en: We saw in [section 12.3](kindle_split_022.html#ch12lev1sec3) that it might be
    important for the compiler to decide whether two pointers may in fact point to
    the same object (aliasing). Pointers to different base types are not supposed
    to alias, unless one of them is a character type. So both parameters of **fputs**
    are declared with **`restrict`**
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 12.3 节](kindle_split_022.html#ch12lev1sec3) 中看到，编译器决定两个指针是否实际上指向同一对象（关联）可能很重要。不同基类型的指针不应该关联，除非其中一个是字符类型。因此，**fputs**
    的两个参数都声明为 **`restrict`**。
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: although it might seem very unlikely that anyone might call **fputs** with the
    same pointer value for both parameters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来不太可能有人会使用相同的指针值调用 **fputs** 的两个参数。
- en: 'This specification is more important for functions like **printf** and friends:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种规范对于像 **printf** 和朋友这样的函数更重要：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The format parameter shouldn’t alias *any* of the arguments that might be passed
    to the `...` part. For example, the following code has undefined behavior:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 格式参数不应与传递给 `...` 部分的任何参数发生关联。例如，以下代码具有未定义的行为：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This example will probably still do what you think it does. If you abuse the
    stream parameter, your program might explode:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能仍然会做你想象中的事情。如果你滥用流参数，你的程序可能会崩溃：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sure, code like this is not very likely to occur in real life. But keep in mind
    that character types have special rules concerning aliasing, and therefore all
    string-processing functions may be subject to missed optimization. You could add
    **`restrict`**-qualifications in many places where string parameters are involved,
    and which you know are accessed exclusively through the pointer in question.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样的代码在现实生活中不太可能发生。但请记住，字符类型有关联的特殊规则，因此所有字符串处理函数都可能受到未优化的影响。你可以在许多涉及字符串参数的地方添加
    **`restrict`**-限定符，并且你知道它们仅通过相关指针访问。
- en: 15.3\. Measurement and inspection
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3. 测量和检查
- en: 'We have several times spoken about the performance of programs without yet
    talking about methods to assess it. And indeed, we humans are notoriously bad
    at predicting the performance of code. So, our prime directive for questions concerning
    performance should be:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多次讨论了程序的性能，但还没有讨论评估它的方法。确实，我们人类在预测代码性能方面臭名昭著。因此，关于性能的问题，我们的首要指令应该是：
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway E
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 吸收点 E
- en: '*Don’t speculate about the performance of code; verify it rigorously.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要对代码的性能进行推测；要严格验证。*'
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The first step when we dive into a code project that may be performance-critical
    will always be to choose the best algorithms that solve the problem(s) at hand.
    This should be done even before coding starts, so we have to make a first complexity
    assessment by arguing (but not speculating!) about the behavior of such an algorithm.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入一个可能对性能至关重要的代码项目时，第一步始终是选择解决当前问题的最佳算法。这应该在编码开始之前完成，因此我们必须通过争论（但不是推测！）这种算法的行为来进行第一次复杂度评估。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 15.16
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 吸收点 15.16
- en: '*Complexity assessment of algorithms requires proofs.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法的复杂度评估需要证明。*'
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Unfortunately, a discussion of complexity proofs is far beyond the scope of
    this book, so we will not be able to go into it. But, fortunately, many other
    books have been written about it. The interested reader may refer to the textbook
    of Cormen et al. [[2001](kindle_split_036.html#bib2)] or to Knuth’s treasure trove.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，关于复杂度证明的讨论远远超出了本书的范围，所以我们无法深入探讨。但幸运的是，已经有许多其他书籍对此进行了讨论。感兴趣的读者可以参考 Cormen
    等人的教科书 [[2001](kindle_split_036.html#bib2)] 或 Knuth 的宝藏。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 15.17
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 吸收点 15.17
- en: '*Performance assessment of code requires measurement.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码的性能评估需要测量。*'
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Measurement in experimental sciences is a difficult subject, and obviously we
    can’t tackle it here in full detail. But we should first be aware that the act
    of measuring modifies the observed. This holds in physics, where measuring the
    mass of an object necessarily displaces it; in biology, where collecting samples
    of species actually kills animals or plants; and in sociology, where asking for
    gender or immigration background before a test changes the behavior of the test
    subjects. Not surprisingly it also holds in computer science and, in particular,
    for time measurement, since all such time measurements need time themselves to
    be accomplished.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 实验科学中的测量是一个困难的话题，显然我们在这里不能详细讨论。但我们应该首先意识到，测量的行为会改变被观察到的对象。这在物理学中成立，因为测量物体的质量必然会使物体移动；在生物学中成立，因为收集物种样本实际上会杀死动物或植物；在社会学中成立，因为在测试之前询问性别或移民背景会改变测试对象的行为。不出所料，在计算机科学中也是如此，特别是在时间测量方面，因为所有这些时间测量都需要时间来完成。
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 15.18
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取舍15.18
- en: '*All measurements introduce bias.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有测量都会引入偏差*。'
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: At the worst, the impact of time measurements can go beyond the additional time
    spent making the measurement. In the first place, a call to **timespec_get**,
    for example, is a call to a function that wouldn’t be there if we didn’t measure.
    The compiler has to take some precautions before any such call, in particular
    saving hardware registers, and has to drop some assumptions about the state of
    the execution. So time measurement can suppress optimization opportunities. Also,
    such a function call usually translates into a *system call* (a call into the
    operating system), and this can have effects on many properties of the program
    execution, such as on the process or task scheduling, or can invalidate data caches.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况下，时间测量的影响可能超过进行测量的额外时间。首先，例如对**timespec_get**的调用是一个对函数的调用，如果没有测量，这个函数就不会存在。编译器在执行此类调用之前必须采取一些预防措施，特别是保存硬件寄存器，并且必须放弃一些关于执行状态的假设。因此，时间测量可能会抑制优化机会。此外，此类函数调用通常转换为*系统调用*（对操作系统的调用），这可能会影响程序执行的许多属性，例如进程或任务调度，或者使数据缓存失效。
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 15.19
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取舍15.19
- en: '*Instrumentation changes compile-time and runtime properties.*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*仪器改变编译时间和运行时属性*。'
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The art of experimental sciences is to address these issues and to ensure that
    the bias introduced by the measurement is small and so the result of an experiment
    can be assessed qualitatively. Concretely, before we can do any time measurements
    on code that interests us, we have to assess the bias that time measurements themselves
    introduce. A general strategy to reduce the bias of measurement is to repeat an
    experiment several times and collect statistics about the outcomes. Most commonly
    used statistics in this context are simple. They concern the number of experiments
    and their *mean value* (or *average*), and also their standard deviation and sometimes
    their skew.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 实验科学的艺术在于解决这些问题，并确保测量引入的偏差很小，从而使实验结果可以定性评估。具体来说，在我们能够对我们感兴趣的代码进行任何时间测量之前，我们必须评估时间测量本身引入的偏差。减少测量偏差的一般策略是重复进行实验几次，并收集关于结果的数据统计。在此背景下最常用的统计数据很简单。它们涉及实验的数量和它们的*平均值*（或*平均数*），以及它们的方差和有时它们的偏度。
- en: 'Let us look at the following *sample* *S* that consists of 20 timings, in seconds
    *s*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下*样本* *S*，它由20个时间测量组成，单位为秒 *s*：
- en: '`0.7`, `1.0`, `1.2`, `0.6`, `1.3`, `0.1`, `0.8`, `0.3`, `0.4`, `0.9`, `0.5`,
    `0.2`, `0.6`, `0.4`, `0.4`, `0.5`, `0.5`, `0.4`, `0.6`, `0.6`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.7`, `1.0`, `1.2`, `0.6`, `1.3`, `0.1`, `0.8`, `0.3`, `0.4`, `0.9`, `0.5`,
    `0.2`, `0.6`, `0.4`, `0.4`, `0.5`, `0.5`, `0.4`, `0.6`, `0.6`'
- en: See [figure 15.1](#ch15fig01) for a frequency histogram of this sample. The
    values show quite a variation
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 见[图15.1](#ch15fig01)中的该样本的频率直方图。这些值显示出相当大的变化
- en: Figure 15.1\. Frequency histogram for our sample, showing the frequency with
    which each of the measured values was obtained
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.1\. 我们样本的频率直方图，显示了每个测量值被获得频率
- en: '![](15fig01_alt.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](15fig01_alt.jpg)'
- en: around `0.6` (μ(*S*), mean value), from `0.1` (minimum) to `1.3` (maximum).
    In fact, this variation is so important that I personally would not dare to claim
    much about the relevance of such a sample. These fictive measurements are bad,
    but how bad are they?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在`0.6`（μ(*S*), 平均值），从`0.1`（最小值）到`1.3`（最大值）。事实上，这种变化非常重要，以至于我个人不敢断言关于这样一个样本的相关性。这些虚构的测量是糟糕的，但它们有多糟糕？
- en: The *standard deviation* σ(*S*) measures (again, in seconds) how an observed
    sample deviates from an ideal world where all timings have exactly the same result.
    A small standard deviation indicates that there is a good chance the phenomenon
    that we are observing follows that ideal. Conversely, if the standard deviation
    is too high, the phenomenon may not have that ideal property (there is something
    that perturbs our computation), or our measurements might by unreliable (there
    is something that perturbs our measurement), or both.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准差* σ(*S*)衡量（再次，以秒为单位）观察到的样本与所有时间都恰好有相同结果的理想世界之间的偏差。标准差小表示我们观察到的现象很可能遵循那个理想。相反，如果标准差太高，现象可能不具有那个理想属性（有东西干扰了我们的计算），或者我们的测量可能不可靠（有东西干扰了我们的测量），或者两者兼而有之。'
- en: 'For our example, the standard deviation is `0.31`, which is substantial compared
    to the mean value of `0.6`: the *relative standard deviation* σ(*S*)/μ(*S*) here
    is `0.52` (or `52%`). Only a value in a low percentage range can be considered
    *good*.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，标准差是 `0.31`，与均值 `0.6` 相比是相当大的：这里的*相对标准差* σ(*S*)/μ(*S*) 是 `0.52`（或 `52%`）。只有低百分比范围内的值才能被认为是*好的*。
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 15.20
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 15.20
- en: '*The relative standard deviation of run times must be in a low percentage range.*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时间的相对标准偏差必须在低百分比范围内。*'
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The last statistical quantity that we might be interested in is the *skew*
    (`0.79` for our sample *S*). It measures the lopsidedness (or asymmetry) of the
    sample. A sample that is distributed symmetrically around the mean would have
    a skew of 0, and a positive value indicates that there is a “tail” to the right.
    Time measurements usually are not symmetric. We can easily see that in our sample:
    the maximum value `1.3` is at distance `0.7` from the mean. So for the sample
    to be symmetric around the mean of `0.6`, we would need one value of `-0.1`, which
    is not possible.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能感兴趣的最后一个统计量是*偏度*（对于我们的样本 *S* 为 `0.79`）。它衡量样本的倾斜度（或不对称性）。一个围绕均值对称分布的样本将有一个偏度为
    0，正值表示存在向右的“尾巴”。时间测量通常不是对称的。我们很容易在我们的样本中看到这一点：最大值 `1.3` 距离均值 `0.7`。因此，为了使样本围绕
    `0.6` 的均值对称，我们需要一个 `-0.1` 的值，这是不可能的。
- en: 'If you are not familiar with these very basic statistical concepts, you should
    probably revisit them a bit, now. In this chapter, we will see that all these
    statistical quantities that interest us can be computed with the *raw moments*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些非常基本的统计概念不熟悉，你可能现在需要重新审视它们一下。在本章中，我们将看到所有这些我们感兴趣的统计量都可以用*原点矩*来计算：
- en: '![](pg_267-1.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_267-1.jpg)'
- en: So, the zeroth raw moment counts the number of samples, the first adds up the
    total number of values, the second is the sum of the squares of the values, and
    so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，零阶原点矩计算样本数量，第一阶是所有值的总和，第二阶是值的平方和，依此类推。
- en: For computer science, the repetition of an experiment can easily be automated
    by putting the code that is to be sampled inside a **`for`** loop and placing
    the measurements before and after this loop. Thereby, we can execute the sample
    code thousands or millions of times and compute the average time spent for a loop
    iteration. The hope then is that the time measurement can be neglected because
    the overall time spent in the experiment is maybe several seconds, whereas the
    time measurement itself may take just several milliseconds.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算机科学，通过将待测量的代码放入**`for`**循环中，并在该循环前后放置测量，可以很容易地通过重复实验来自动化。因此，我们可以执行样本代码成千上万次，并计算循环迭代的平均时间。然后，我们希望时间测量可以忽略，因为实验的整体时间可能只有几秒钟，而时间测量本身可能只需要几毫秒。
- en: 'In this chapter’s example code, we will try to assess the performance of calls
    to timespec_get and also of a small utility that collects statistics of measurements.
    [Listing 15.1](#ch15ex01) contains several **`for`** loops around different versions
    of code that we want to investigate. The time measurements are collected in a
    statistic and use a **`tv_nsec`** value obtained from **timespec_get**. In this
    approach, the experimental bias that we introduce is obvious: we use a call to
    **timespec_get** to measure its own performance. But this bias is easily mastered:
    augmenting the number of iterations reduces the bias. The experiments that we
    report here were performed with a value of iterations of 2^(24) – 1.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例代码中，我们将尝试评估对 timespec_get 的调用性能，以及收集测量统计信息的小工具的性能。[列表 15.1](#ch15ex01)
    包含了我们想要调查的不同代码版本的几个 **`for`** 循环。时间测量收集在统计信息中，并使用从 **timespec_get** 获得的 **`tv_nsec`**
    值。在这种方法中，我们引入的实验偏差是明显的：我们使用对 **timespec_get** 的调用来测量其自身的性能。但这种偏差很容易掌握：增加迭代次数可以减少偏差。我们在这里报告的实验是在迭代次数为
    2^(24) – 1 的值下进行的。
- en: Listing 15.1\. Measuring several code snippets repeatedly
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.1\. 重复测量几个代码片段
- en: '[PRE11]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But this mostly trivial observation is not the goal; it only serves as an example
    of some code that we want to measure. The **`for`** loops in [listing 15.1](#ch15ex01)
    contain code that does the statistics collection with more sophistication. The
    goal is to be able to assert, step by step, how this increasing sophistication
    influences the timing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个主要平凡的观察并不是目标；它只是作为我们想要测量的某些代码的例子。列表 15.1 中的 **`for`** 循环包含进行更复杂统计收集的代码。目标是能够逐步断言这种不断增加的复杂性如何影响计时。
- en: '`timespec.c`'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`timespec.c`'
- en: '[PRE12]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The loop starting on line 70 just accumulates the values, so we may determine
    their average. The next loop (line 77) uses a function stats_collect1 that maintains
    a *running mean*: that is, it implements a formula that computes a new average
    *μ[n]* by modifying the previous one by δ(*x**[n],* *μ*[*n*–1]), where *x**[n]*
    is the new measurement and *μ*[*n*–1] is the previous average. The other two loops
    (lines 82 and 87) then use the functions stats_collect2 and stats_collect3, respectively,
    which use similar formulas for the *second* and *third moment*, respectively,
    to compute variance and skew. We will discuss these functions shortly.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 70 行开始的循环只是累积值，因此我们可以确定它们的平均值。下一个循环（第 77 行）使用 stats_collect1 函数，该函数维护一个 *运行平均值*：即，它通过修改前一个平均值
    δ(*x**[n],* *μ*[*n*–1]) 来计算一个新的平均值 *μ[n]*，其中 *x**[n]* 是新的测量值，*μ*[*n*–1] 是前一个平均值。其他两个循环（第
    82 行和第 87 行）分别使用 stats_collect2 和 stats_collect3 函数，它们分别使用类似公式来计算 *第二* 和 *第三*
    阶矩，从而计算方差和偏度。我们将在稍后讨论这些函数。
- en: But first, let us have a look at the tools we use for the instrumentation of
    the code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看我们用于代码仪表化的工具。
- en: Listing 15.2\. Collecting time statistics with timespec_diff and stats_collect2
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.2\. 使用 timespec_diff 和 stats_collect2 收集时间统计信息
- en: '[PRE13]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use timespec_diff from [section 11.2](kindle_split_021.html#ch11lev1sec2)
    to compute the time difference between two measurements and stats_collect2 to
    sum up the statistics. The whole is then wrapped in another loop (not shown) that
    repeats that experiment 10 times. After finishing that loop, we use functions
    for the stats type to print out the result.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 [第 11.2 节](kindle_split_021.html#ch11lev1sec2) 中的 timespec_diff 来计算两次测量之间的时间差，并使用
    stats_collect2 来汇总统计信息。然后，整个操作被另一个循环（未显示）包裹，该循环重复该实验 10 次。完成该循环后，我们使用 stats 类型的函数来打印结果。
- en: Listing 15.3\. Printing time statistics with stats_mean and stats_rsdev_unbiased
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.3\. 使用 stats_mean 和 stats_rsdev_unbiased 打印时间统计信息
- en: '[PRE14]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, obviously, stats_mean gives access to the mean value of the measurements.
    The function stats_rsdev_unbiased returns the *unbiased relative standard deviation*:
    that is, a standard deviation that is unbiased^([[1](#ch15fn01)]) and that is
    normalized with the mean value.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，stats_mean 提供了对测量平均值访问的途径。函数 stats_rsdev_unbiased 返回 *无偏相对标准差*：即，一个无偏且与平均值归一化的标准差。
- en: ¹
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Such that it is a true estimation of the standard deviation of the expected
    time, not only of our arbitrary sample.
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样，它是对预期时间标准差的真正估计，而不仅仅是我们的任意样本。
- en: 'A typical output of that on my laptop looks like the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本电脑上，典型的输出如下所示：
- en: '`Terminal`'
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE15]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, lines 0, 1, and 2 correspond to loops that we have not discussed yet,
    and lines 3 to 6 correspond to the loops we have discussed. Their relative standard
    deviations are less than 1%, so we can assert that we have a good statistic and
    that the times on the right are good estimates of the cost per iteration. For
    example, on my 2.1 GHz laptop, this means the execution of one loop iteration
    of loops 3, 4, 5, or 6 takes about 36, 55, 61, and 67 clock cycles, respectively.
    So the extra cost when replacing the simple sum by stats_collect1 is 19 cycles,
    from there to stats_collect2 is 6, and yet another 6 cycles are needed if we use
    stats_collect3 instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，行 0、1 和 2 对应于我们尚未讨论的循环，而行 3 到 6 对应于我们已讨论的循环。它们的相对标准偏差小于 1%，因此我们可以断言我们有一个好的统计量，并且右侧的时间是每次迭代的成本的较好估计。例如，在我的
    2.1 GHz 笔记本电脑上，这意味着循环 3、4、5 或 6 的一次迭代执行分别需要大约 36、55、61 和 67 个时钟周期。因此，将简单的求和替换为
    stats_collect1 的额外成本是 19 个周期，从那里到 stats_collect2 是 6 个周期，如果我们使用 stats_collect3，还需要额外的
    6 个周期。
- en: 'To see that this is plausible, let us look at the stats type:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这是合理的，让我们看看 stats 类型：
- en: '[PRE16]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we reserve one **`double`** for all statistical *moments*. Function stats_collect
    in the following listing then shows how these are updated when we collect a new
    value that we insert.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为所有统计 *矩* 预留一个 **`double`**。以下列表中的 stats_collect 函数展示了当我们收集一个新值并将其插入时，这些值是如何更新的。
- en: Listing 15.4\. Collecting statistics up to the third moment
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.4\. 收集到三阶矩的统计信息
- en: '[PRE17]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As previously mentioned, we see that this is a relatively simple algorithm to
    update the moments incrementally. Important features compared to a naive approach
    are that we avoid numerical imprecision by using the difference from the current
    estimation of the mean value, and that this can be done without storing all the
    samples. This approach was first described for mean and variance (first and second
    moments) by Welford [[1962](kindle_split_036.html#bib21)] and was then generalized
    to higher moments; see Pébay [[2008](kindle_split_036.html#bib14)]. In fact, our
    functions stats_collect1 and so on are just instantiations of that for the chosen
    number of moments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们看到这是一个相对简单的算法，可以增量地更新矩。与原始方法相比，重要特性是我们通过使用当前均值估计的差异来避免数值不精确，并且可以不存储所有样本来完成此操作。这种方法最初由
    Welford [[1962](kindle_split_036.html#bib21)] 描述，后来推广到更高阶矩；参见 Pébay [[2008](kindle_split_036.html#bib14)]。实际上，我们的
    stats_collect1 等函数只是对该选择的矩数的一个实例化。
- en: '`stats.h`'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`stats.h`'
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The assembler listing in stats_collect2 shows that our finding of using 25 cycles
    for this functions seems plausible. It corresponds to a handful of arithmetic
    instructions, loads, and stores.^([[2](#ch15fn02)])
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: stats_collect2 的汇编列表显示，我们使用 25 个周期来执行此函数的发现似乎是合理的。它对应于一小部分算术指令、加载和存储操作.^([[2](#ch15fn02)])
- en: ²
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This assembler shows `x86_64` assembler features that we have not yet seen:
    floating-point hardware registers and instructions, and *SSE* registers and instructions.
    Here, memory locations `(`**`%`****`rdi`**`)`, `8(`**`%`****`rdi`**`)`, and `16(`**`%`****`rdi`**`)`
    correspond to c->moment[`i]`, for *i* = 0, 1, 2, the name of the instruction minus
    the v-prefix; sd-postfix shows the operation that is performed; and **`vfmadd213sd`**
    is a floating-point multiply add instruction.'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此汇编器显示了 `x86_64` 汇编器的一些我们尚未见过的特性：浮点硬件寄存器和指令，以及 *SSE* 寄存器和指令。在这里，内存位置 `(`**`%`****`rdi`**`)`、`8(`**`%`****`rdi`**`)`
    和 `16(`**`%`****`rdi`**`)` 对应于 c->moment[`i`]，其中 *i* = 0、1、2，指令名称减去 v-前缀；sd-后缀显示执行的操作；**`vfmadd213sd`**
    是一个浮点乘加指令。
- en: Listing 15.5\. GCC’s assembler for stats_collect2(c)
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.5\. GCC 的 stats_collect2(c) 汇编器
- en: '[PRE19]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, by using the example measurements, we still made one systematic error.
    We took the points of measure *outside* the **`for`** loops. By doing so, our
    measurements also form the instructions that correspond to the loops themselves.
    [Listing 15.6](#ch15ex06) shows the three loops that we skipped in the earlier
    discussion. These are basically empty, in an attempt to measure the contribution
    of such a loop.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使用示例测量，我们仍然犯了一个系统性错误。我们将测量点放在 **`for`** 循环之外。这样做，我们的测量也形成了对应于循环本身的指令。[列表
    15.6](#ch15ex06) 显示了我们之前讨论中跳过的三个循环。这些基本上是空的，试图测量这种循环的贡献。
- en: Listing 15.6\. Instrumenting three `for` loops with `struct` **`timespec`**
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.6\. 使用 `struct` **`timespec`** 仪器化三个 `for` 循环
- en: '[PRE20]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In fact, when trying to measure **`for`** loops with no inner statement, we
    face a severe problem: an empty loop with no effect can and will be eliminated
    at compile time by the optimizer. Under normal production conditions, this is
    a good thing; but here, when we want to measure, this is annoying. Therefore,
    we show three variants of loops that should not be optimized out. The first declares
    the loop variable as **`volatile`** such that all operations on the variable must
    be emitted by the compiler. [Listings 15.7](#ch15ex07) and [15.8](#ch15ex08) show
    GCC’s and Clang’s versions of this loop. We see that to comply with the **`volatile`**
    qualification of the loop variable, both have to issue several load and store
    instructions.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当我们试图测量没有内部语句的 **`for`** 循环时，我们面临一个严重的问题：一个没有效果的空循环可以在编译时被优化器消除。在正常的生产条件下，这是一件好事；但在这里，当我们想要测量时，这很烦人。因此，我们展示了三种不应该被优化掉的循环变体。第一个将循环变量声明为
    **`volatile`**，这样所有对该变量的操作都必须由编译器发出。[列表 15.7](#ch15ex07) 和 [15.8](#ch15ex08) 展示了
    GCC 和 Clang 的这个循环版本。我们看到，为了符合循环变量的 **`volatile`** 特性，两者都必须发出多个加载和存储指令。
- en: Listing 15.7\. GCC’s version of the first loop from [Listing 15.6](#ch15ex06)
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.7\. GCC 版本的 [列表 15.6](#ch15ex06) 中的第一个循环
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 15.8\. Clang’s version of the first loop from [listing 15.6](#ch15ex06)
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.8\. Clang 版本的 [列表 15.6](#ch15ex06) 中的第一个循环
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the next loop, we try to be a bit more economical by only forcing one **`volatile`**
    store to an auxiliary variable s. As we can see in [listings 15.9](#ch15ex09),
    the result is assembler code that looks quite efficient: it consists of four instructions,
    an addition, a comparison, a jump, and a store.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个循环，我们试图更加节省，只强制将一个 **`volatile`** 存储到一个辅助变量 s。正如我们在 [列表 15.9](#ch15ex09)
    中可以看到的，结果是看起来相当高效的汇编代码：它由四个指令组成，一个加法、一个比较、一个跳转和一个存储。
- en: Listing 15.9\. GCC’s version of the second loop from [listing 15.6](#ch15ex06)
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.9\. GCC 版本的 [列表 15.6](#ch15ex06) 中的第二个循环
- en: '[PRE23]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To come even closer to the loop of the real measurements, in the next loop
    we use a trick: we perform index computations and comparisons for which the result
    is meant to be opaque to the compiler. [Listing 15.10](#ch15ex10) shows that this
    results in assembler code similar to the previous, only now we have a second addition
    instead of the store operation.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更接近真实测量的循环，在下一个循环中我们使用了一个技巧：我们执行索引计算和比较，其结果应该是对编译器透明的。[列表 15.10](#ch15ex10)
    显示，这导致汇编代码类似于之前，但现在我们有一个额外的加法操作而不是存储操作。
- en: Listing 15.10\. GCC’s version of the third loop from [listing 15.6](#ch15ex06)
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.10\. GCC 版本的 [列表 15.6](#ch15ex06) 中的第三个循环
- en: '[PRE24]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Table 15.1](#ch15table01) summarizes the results we collected here and relates
    the differences between the various measurements. As we might expect, we see that
    loop 1 with the **`volatile`** store is 80% faster than the loop with a **`volatile`**
    loop counter. So, using a **`volatile`** loop counter is not a good idea, because
    it can deteriorate the measurement.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15.1](#ch15table01) 总结了我们在本节收集的结果，并比较了各种测量的差异。正如我们所预期的，我们看到使用 **`volatile`**
    存储的循环 1 比使用 **`volatile`** 循环计数器的循环快 80%。因此，使用 **`volatile`** 循环计数器不是一个好主意，因为它可能会降低测量的准确性。'
- en: On the other hand, moving from loop 1 to loop 2 has a not-very-pronounced impact.
    The 6% gain that we see is smaller than the standard deviation of the test, so
    we can’t even be sure there is a gain at all. If we would really like to know
    whether there is a difference, we would have to do more tests and hope that the
    standard deviation was narrowed down.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，从循环 1 转到循环 2 的影响并不明显。我们看到的 6% 的提升小于测试的标准差，所以我们甚至不能确定是否有提升。如果我们真的想了解是否存在差异，我们就需要进行更多的测试，并希望标准差能够缩小。
- en: But for our goal to assess the time implications of our observation, the measurements
    are quite conclusive. Versions 1 and 2 of the **`for`** loop have an impact that
    is about one to two orders of magnitude below the impact of calls to **timespec_get**
    or stats_collect. So we can assume that the values we see for loops 3 to 6 are
    good estimators for the expected time of the measured functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了评估我们观察的时间影响，测量结果非常明确。**`for`** 循环的版本 1 和 2 的影响大约比调用 **timespec_get** 或 stats_collect
    的影响低一到两个数量级。因此，我们可以假设对于循环 3 到 6 的值是测量函数预期时间的良好估计。
- en: 'There is a strong platform-dependent component in these measurements: time
    measurement with **timespec_get**. In fact, we learned from this experience that
    on my machine,^([[3](#ch15fn03)]) time measurement and statistics collection have
    a cost that is of the same order of magnitude. For me, personally, this was a
    surprising discovery: when I wrote this chapter, I thought time measurement would
    be much more expensive.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测量中存在一个强烈的平台依赖性成分：使用 **timespec_get** 进行时间测量。实际上，我们从这次经验中了解到，在我的机器上，时间测量和统计收集的成本具有相同的数量级。对我个人来说，这是一个令人惊讶的发现：当我写这一章时，我以为时间测量会花费更多。
- en: ³
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A commodity Linux laptop with a recent system and modern compilers as of 2016.
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2016年配备最新系统和现代编译器的普通Linux笔记本电脑。
- en: We also learned that simple statistics such as the standard deviation are easy
    to obtain and can help to assert claims about performance differences.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，像标准差这样的简单统计很容易获得，并且可以帮助我们断言性能差异。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.21
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取走 15.21
- en: '*Collecting higher-order moments of measurements to compute variance and skew
    is simple and cheap.*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*收集测量值的高阶矩以计算方差和偏度既简单又便宜。*'
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So, whenever you make performance claims in the future or see such claims made
    by others, be sure the variability of the results has at least been addressed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论你将来在性能方面提出何种主张，或者看到他人提出此类主张，都要确保结果的可变性至少已经得到解决。
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 15.22
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取走 15.22
- en: '*Runtime measurements must be hardened with statistics.*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时测量必须用统计方法加固。*'
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Performance should not be traded for correctness.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能不应以正确性为代价。
- en: '**`inline`** is an adequate tool to optimize small, pure, functions in place.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`inline`** 是优化小型、纯函数的合适工具。'
- en: Table 15.1\. Comparison of measurements
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 15.1\. 测量值比较
- en: '| Loop |   | Sec per iteration | Difference | Gain/loss | Conclusive |'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 循环 |   | 每次迭代的秒数 | 差异 | 增减 | 结论性 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | **volatile** loop | 1.97 10^(–09) |   |   |   |'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | **volatile** 循环 | 1.97 10^(–09) |   |   |   |'
- en: '| 1 | **volatile** store | 3.66 10^(–10) | -1.60 10 ^(–09) | -81% | Yes |'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | **volatile** 存储 | 3.66 10^(–10) | -1.60 10 ^(–09) | -81% | 是 |'
- en: '| 2 | Opaque addition | 3.45 10^(–10) | -2.10 10^(–11) | -6% | No |'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 2 | 不透明加法 | 3.45 10^(–10) | -2.10 10^(–11) | -6% | 否 |'
- en: '| 3 | Plus **timespec_get** | 1.77 10^(–08) | 1.74 10^(–08) | +5043% | Yes
    |'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 3 | 加 **timespec_get** | 1.77 10^(–08) | 1.74 10^(–08) | +5043% | 是 |'
- en: '| 4 | Plus mean | 2.62 10^(–08) | 8.5 10^(–09) | +48% | Yes |'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 4 | 加均值 | 2.62 10^(–08) | 8.5 10^(–09) | +48% | 是 |'
- en: '| 5 | Plus variance | 2.90 10^(–08) | 2.8 10^(–09) | +11% | Yes |'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 5 | 加方差 | 2.90 10^(–08) | 2.8 10^(–09) | +11% | 是 |'
- en: '| 6 | Plus skew | 3.17 10^(–08) | 2.7 10^(–09) | +9% | Yes |'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 6 | 加偏度 | 3.17 10^(–08) | 2.7 10^(–09) | +9% | 是 |'
- en: '**`restrict`** helps to deal with aliasing properties of function parameters.
    It has to be used with care, because it imposes restrictions on the calling side
    of the function that may not be enforceable at compile time.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`restrict`** 有助于处理函数参数的别名属性。它必须谨慎使用，因为它对函数的调用方施加了可能在编译时无法强制执行的约束。'
- en: Claims of performance improvements must be accompanied by thorough measurements
    and statistics.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能改进的主张必须伴随着彻底的测量和统计。
- en: Chapter 16\. Function-like macros
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 16 章\. 函数式宏
- en: This chapter covers
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Checking arguments
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查参数
- en: Accessing the calling context
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问调用上下文
- en: Working with variadic macros
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与可变参数宏一起工作
- en: Type-generic programming
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型通用编程
- en: We have encountered *function-like* macros explicitly in [section 10.2.1](kindle_split_020.html#ch10lev2sec1)
    and also implicitly. Some interfaces in the C standard library are typically implemented
    by using them, such as the type-generic interfaces in `tgmath.h`. We also have
    seen that function-like macros can easily obfuscate our code and require a certain
    restrictive set of rules. The easiest strategy to avoid many of the problems that
    come with function-like macros is to only use them where they are irreplaceable,
    and to use appropriate means where they are replaceable.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 10.2.1 节](kindle_split_020.html#ch10lev2sec1) 明确遇到了 *函数式* 宏，也隐式地遇到了。C标准库中的某些接口通常通过使用它们来实现，例如
    `tgmath.h` 中的类型通用接口。我们还看到，函数式宏可以轻易地使我们的代码变得晦涩，并需要一套特定的限制性规则。避免函数式宏带来的许多问题的最简单策略是仅在它们不可替代的地方使用它们，并在它们可替代的地方使用适当的手段。
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<tgmath.h>`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tgmath.h>`'
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.1
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取走 16.1
- en: '*Whenever possible, prefer an* **`inline`** *function to a functional macro.*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能，优先选择函数式宏而不是函数。*'
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'That is, in situations where we have a fixed number of arguments with a known
    type, we should provide a proper type-safe interface in the form of a function
    prototype. Let us suppose we have a simple function with side effects:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 即，在具有已知类型的固定数量参数的情况下，我们应该以函数原型形式提供适当的安全类型接口。让我们假设我们有一个简单的具有副作用的功能：
- en: '[PRE25]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now consider that this function is used with a macro to square a value:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这个函数与宏一起使用来平方一个值：
- en: '[PRE26]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, the use of square_macro`(`count`())` is replaced by count`()*`count`()`,
    two executions of count:^([[[Exs 1]](#ch16fn-ex01)]) That is probably not what
    a naive reader expects at that point.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，square_macro`(`count`())`的使用被替换为count`()*`count`()`，两次执行count:^([[[Exs 1]](#ch16fn-ex01)])。这可能是初学者在那个时刻所期望的。
- en: ^([Exs 1])
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that b `==` a`*`a `+ 3*`a `+ 2`.
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 b `==` a`*`a `+ 3*`a `+ 2`。
- en: 'To achieve the same performance as with a function-like macro, it is completely
    sufficient to provide an **`inline`** definition in a header file:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到与函数式宏相同的表现，在头文件中提供一个**`inline`**定义就完全足够了：
- en: '[PRE27]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, square_unsigned`(`count`())` leads to only one execution of count.^([[[Exs
    2]](#ch16fn-ex02)])
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，square_unsigned`(`count`())`导致count只执行一次.^([[[Exs 2]](#ch16fn-ex02)])
- en: ^([Exs 2])
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that d `==` c`*`c `+ 2*`c `+ 1`.
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 d `==` c`*`c `+ 2*`c `+ 1`。
- en: But there are many situations where function-like macros can do more than a
    function. They can
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 但有许多情况下，函数式宏可以做得比函数更多。它们可以
- en: Force certain type mapping and argument checking
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制类型映射和参数检查
- en: Trace execution
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪执行
- en: Provide interfaces with a variable number of arguments
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供具有可变参数数量的接口
- en: Provide type-generic interfaces
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供类型通用的接口
- en: Provide default arguments to functions
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数提供默认参数
- en: 'In this chapter, I will try to explain how such features can be implemented.
    We will also discuss two other features of C that are clearly to be distinguished:
    one, **`_Generic`**, because it is useful in macros and would be very tedious
    to use without them; and the other, *variadic functions*, because they are now
    mostly obsolete and should *not* be used in new code.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将尝试解释如何实现这些功能。我们还将讨论C的另外两个明显可区分的特性：一个是**`_Generic`**，因为它在宏中很有用，没有它们使用起来会非常繁琐；另一个是*可变参数函数*，因为它们现在大多已经过时，不应该在新代码中使用。
- en: 'A warning about this chapter is also in order. Macro *programming* quickly
    becomes ugly and barely readable, so you will need patience and good will to understand
    some of the code here. Let us take an example:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个警告是，宏*编程*很快就会变得丑陋且几乎无法阅读，所以你需要耐心和善意来理解这里的一些代码。让我们举一个例子：
- en: '[PRE28]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The right side, the replacement string, is quite complex. It has four **`sizeof`**
    evaluations and some operators that combine them. But the *usage* of this macro
    shouldn’t be difficult: it simply computes the minimum size of the arguments.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧，替换字符串，相当复杂。它有四个**`sizeof`**评估和一些组合它们的运算符。但这个宏的*使用*不应该很难：它只是计算参数的最小大小。
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.2
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.2节要点
- en: '*A functional macro shall provide a simple interface to a complex task.*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能宏应提供一个简单的接口来执行复杂任务。*'
- en: '|  |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.1\. How function-like macros work
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1\. 函数式宏的工作原理
- en: 'To provide the features that we listed, C has chosen a path that is quite different
    from other popular programming languages: textual replacement. As we have seen,
    macros are replaced in a very early stage of compilation, called *preprocessing*.
    This replacement follows a strict set of rules that are specified in the C standard,
    and all compilers (on the same platform) should preprocess any source code to
    exactly the same intermediate code.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供我们列出的特性，C选择了与其他流行编程语言截然不同的路径：文本替换。正如我们所见，宏在编译的早期阶段被替换，称为*预处理器处理*。这种替换遵循C标准中指定的一系列严格规则，并且所有编译器（在同一平台上）都应该将任何源代码预处理成完全相同的中间代码。
- en: 'Let us add the following to our example:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下内容添加到我们的示例中：
- en: '[PRE29]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we have two macro definitions for macros MINSIZE and BYTECOPY. The first
    has a *parameter list* `(`X`,` Y`)` that defines two parameters X and Y, and *replacement
    text*
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个宏定义：MINSIZE和BYTECOPY。第一个有一个*参数列表* `(`X`,` Y`)`，它定义了两个参数X和Y，以及*替换文本*
- en: '[PRE30]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: that refers to X and Y. Similarly, BYTECOPY also has two parameters T and S
    and replacement text starting with **memcpy**.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 指向X和Y。同样，BYTECOPY也有两个参数T和S，替换文本从**memcpy**开始。
- en: 'These macros fulfill our requirements about function-like macros: they evaluate
    each argument only once,^([[[Exs 3]](#ch16fn-ex03)]) parenthesize all arguments
    with `()`, and have no hidden effects such as unexpected control flow. The parameters
    of a macro must be identifiers. A special scope rule restricts the validity of
    these identifiers to use inside the replacement text.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏满足了我们对函数式宏的要求：它们只对每个参数评估一次，^([[[Exs 3]](#ch16fn-ex03)]) 使用`()`括号包围所有参数，并且没有隐藏的影响，如意外的控制流。宏的参数必须是标识符。一个特殊的范围规则限制了这些标识符在替换文本中的有效性。
- en: ^([Exs 3])
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is this so?
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么会这样？
- en: 'When the compiler encounters the name of a functional macro followed by a closing
    pair of `()`, such as in BYTECOPY`(`A`,` B`)`, it considers this a *macro call*
    and replaces it textually according to the following rules:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到一个函数宏的名称后跟一个闭括号对，例如在`BYTECOPY(`A`,` B`)`中，它认为这是一个*宏调用*，并根据以下规则进行文本替换：
- en: The definition of the macro is temporarily disabled to avoid infinite recursion.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免无限递归，宏的定义暂时被禁用。
- en: The text inside the `()`, the *argument list*, is scanned for parentheses and
    commas. Each opening parenthesis `(` must match a `)`. A comma that is not inside
    such additional `()` is used to separate the argument list into the arguments.
    For the case that we handle here, the number of arguments must match the number
    of parameters in the definition of the macro.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`()`内的文本，即*参数列表*，会被扫描以查找括号和逗号。每个开括号`(`必须与一个闭括号`)`匹配。不在这样的额外`()`内的逗号用于将参数列表分隔成各个参数。对于这里处理的情形，参数的数量必须与宏定义中参数的数量相匹配。
- en: Each argument is recursively expanded for macros that might appear in them.
    In our example, A could be yet another macro and expand to some variable name
    such as redA.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个参数都会递归展开，以处理可能出现在其中的宏。在我们的例子中，A可能又是另一个宏，展开为某个变量名，例如redA。
- en: The resulting text fragments from the expansion of the arguments are assigned
    to the parameters.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数展开的结果文本片段被分配给参数。
- en: A copy of the replacement text is made, and all occurrences of the parameters
    are replaced with their respective definitions.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换文本的副本被创建，并将所有参数替换为它们的相应定义。
- en: The resulting replacement text is subject to macro replacement, again.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果替换文本再次受到宏替换的影响。
- en: This final replacement text is inserted in the source instead of the macro call.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个最终的替换文本被插入到源代码中，代替宏调用。
- en: The definition of the macro is re-enabled.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏的定义被重新启用。
- en: This procedure looks a bit complicated at first glance but is effectively quite
    easy to implement and provides a reliable sequence of replacements. It is guaranteed
    to avoid infinite recursion and complicated local variable assignments. In our
    case, the result of the expansion of BYTECOPY`(`A`,` B`)` would be
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程乍一看可能有些复杂，但实际上很容易实现，并提供了一个可靠的替换序列。它保证了避免无限递归和复杂的局部变量赋值。在我们的例子中，`BYTECOPY(`A`,`
    B`)`的展开结果将是
- en: '[PRE31]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We already know that identifiers of macros (function-like or not) live in a
    namespace of their own. This is for a very simple reason:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道宏（函数式或非函数式）的标识符存在于它们自己的命名空间中。这是出于一个非常简单的理由：
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 16.3
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 16.3
- en: '*Macro replacement is done in an early translation phase, before any other
    interpretation is given to the tokens that compose the program.*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏替换在早期翻译阶段完成，在给组成程序的标记赋予任何其他解释之前。*'
- en: '|  |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: So the preprocessing phase knows nothing about keywords, types, variables, or
    other constructs of later translation phases.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，预处理阶段对关键字、类型、变量或后续翻译阶段的其它构造一无所知。
- en: 'Since recursion is explicitly disabled for macro expansion, there can even
    be functions that use the same identifier as a function-like macro. For example,
    the following is valid C:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宏展开显式禁用了递归，甚至可以有使用与函数式宏相同标识符的函数。例如，以下有效的C代码：
- en: '[PRE32]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It defines a function string_literal that receives a character array as an argument,
    and a macro of the same name that calls the function with a weird arrangement
    of the argument, the reason for which we will see shortly. There is a more specialized
    rule that helps to deal with situations where we have a macro and a function with
    the same name. It is analogous to function decay ([takeaway 11.22](kindle_split_021.html#ch11note22)).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个接收字符数组作为参数的函数 `string_literal`，以及一个同名的宏，该宏以奇怪的参数排列调用函数，其理由我们很快就会看到。有一个更专门的规则有助于处理我们有一个宏和一个同名函数的情况。它与函数衰减
    ([takeaway 11.22](kindle_split_021.html#ch11note22)) 类似。
- en: '|  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.4 (macro retention)
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 16.4 (宏保留)
- en: '*If a functional macro is not followed by* *`()`**, it is not expanded.*'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果一个功能宏后面没有跟* *`()`**，则不会展开。'
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the previous example, the definition of the function and of the macro depend
    on their order of appearance. If the macro definition was given first, it would
    immediately expand to something like
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，函数和宏的定义取决于它们出现的顺序。如果宏定义首先给出，它将立即展开成类似
- en: '[PRE33]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'which is erroneous. But if we surround the name string_literal with parentheses,
    it is not expanded and remains a valid definition. A complete example could look
    like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有误的。但如果我们将 `string_literal` 名称用括号括起来，它就不会展开，并保持为一个有效的定义。一个完整的例子可能如下所示：
- en: '[PRE34]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That is, both the inline definition and the instantiating declaration of the
    function are protected by surrounding `()` and don’t expand the functional macro.
    The last line shows another common usage of this feature. Here string_literal
    is not followed by `()`, so both rules are applied. First macro retention inhibits
    the expansion of the macro, and then function decay ([takeaway 11.22](kindle_split_021.html#ch11note22))
    evaluates the use of the function to a pointer to that function.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 即，函数的内联定义和实例化声明都受到周围括号的保护，并且不会展开功能宏。最后一行显示了该功能的另一种常见用法。这里 `string_literal` 后面没有跟
    `()`, 因此应用了两个规则。首先，宏保留阻止了宏的展开，然后函数衰减 ([takeaway 11.22](kindle_split_021.html#ch11note22))
    将函数的使用评估为指向该函数的指针。
- en: 16.2\. Argument checking
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2\. 参数检查
- en: As we said earlier, in cases where we have a fixed number of arguments with
    types that are well-modeled by C’s type system, we should use functions and not
    function-like macros. Unfortunately, C’s type system doesn’t cover all special
    cases that we might want to distinguish.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，在具有固定数量且类型由C的类型系统良好建模的参数的情况下，我们应该使用函数而不是函数式宏。不幸的是，C的类型系统并没有涵盖我们可能想要区分的所有特殊情况。
- en: 'An interesting such case is string literals that we want to pass to a potentially
    dangerous function such as **printf**. As we saw in [section 5.6.1](kindle_split_013.html#ch05lev2sec6),
    string literals are read-only but are not even **`const`** qualified. Also, an
    interface with `[`**`static`** `1]`, like the earlier *function* string_literal,
    is not enforced by the language, because prototypes without `[`**`static`** `1]`
    are equivalent. In C, there is no way to prescribe for a parameter str of a function
    interface that it should fulfill the following constraints:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的例子是我们想要传递给可能危险的函数（如 **printf**）的字符串字面量。正如我们在 [第 5.6.1 节](kindle_split_013.html#ch05lev2sec6)
    中看到的，字符串字面量是只读的，但甚至没有 **`const`** 修饰。此外，像之前的 *函数* `string_literal` 一样，具有 `[`**`static`**
    `1]` 的接口并没有被语言强制执行，因为没有 `[`**`static`** `1]` 的原型是等效的。在C中，没有方法可以规定函数接口的参数 `str`
    应该满足以下约束：
- en: Is a character pointer
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是一个字符指针
- en: Must be non-null
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须非空
- en: Must be immutable^([[1](#ch16fn01)])
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须不可变^([[1](#ch16fn01)])
- en: ¹
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`const`** only constrains the called function, not the caller.'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`const`** 只约束被调用的函数，而不是调用者。'
- en: Must be `0`-terminated
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须以 `0` 结尾
- en: All these properties could be particularly useful to check at compile time,
    but we simply have no way to specify them in a function interface.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性在编译时检查可能特别有用，但我们没有方法在函数接口中指定它们。
- en: 'The *macro* string_literal fills that gap in the language specification. The
    weird empty string literals in its expansion "" X "" ensure that string_literal
    can only be called with a string literal:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏* `string_literal` 填补了语言规范中的这一空白。在其展开中出现的奇怪空字符串字面量 `"" X ""` 确保字符串字面量只能用字符串字面量调用：'
- en: '[PRE35]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The macro and function string_literal are just a simple example of this strategy.
    A more useful example would be
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 宏和函数 `string_literal` 只是这种策略的一个简单例子。一个更有用的例子会是
- en: '**`macro_trace.h`**'
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE36]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'a macro that could be used in the context of a debug build of a program to
    insert debugging output:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以在程序的调试构建上下文中使用的宏，用于插入调试输出：
- en: '**`macro_trace.c`**'
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.c`**'
- en: '[PRE37]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This looks harmless and efficient, but it has a pitfall: the argument F can
    be any pointer to **`char`**. In particular, it could be a format string that
    sits in a modifiable memory region. This may have the effect that an erroneous
    or malicious modification of that string leads to an invalid format, and thus
    to a crash of the program, or could divulge secrets. In [section 16.5](#ch16lev1sec5),
    we will see more in detail why this is particularly dangerous for functions like
    **fprintf**.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来无害且高效，但它有一个陷阱：参数 F 可以是任何指向 **`char`** 的指针。特别是，它可能是一个位于可修改内存区域的格式字符串。这可能会导致错误或恶意的字符串修改导致格式无效，从而引发程序崩溃，或者可能泄露秘密。在
    [第 16.5 节](#ch16lev1sec5) 中，我们将更详细地了解为什么这对像 **fprintf** 这样的函数尤其危险。
- en: In simple code as in the example, where we pass simple string literals to **fprintf**,
    these problems should not occur. Modern compiler implementations are able to trace
    arguments to **fprintf** (and similar) to check whether format specifiers and
    other arguments match.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在像示例中那样简单的代码中，我们向 **fprintf** 传递简单的字符串字面量，这些问题不应该发生。现代编译器实现能够追踪 **fprintf**（和类似函数）的参数，以检查格式说明符和其他参数是否匹配。
- en: 'This check doesn’t work if the format that is passed to **fprintf** is not
    a string literal but just any pointer to **`char`**. To inhibit that, we can enforce
    the use of a string literal here:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给 **fprintf** 的格式不是字符串字面量而是任何指向 **`char`** 的指针，则此检查将不起作用。为了抑制这种情况，我们可以强制在此处使用字符串字面量：
- en: '**`macro_trace.h`**'
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE38]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, F must receive a string literal, and the compiler then can do the work
    and warn us about a mismatch.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，F 必须接收一个字符串字面量，然后编译器就可以进行工作并警告我们是否存在不匹配。
- en: The macro TRACE_PRINT1 still has a weak point. If it is used with **`NDEBUG`**
    set, the arguments are ignored and thus not checked for consistency. This can
    have the long-term effect that a mismatch remains undetected for a long time and
    all of a sudden appears when debugging.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 宏 TRACE_PRINT1 仍然存在弱点。如果它与 **`NDEBUG`** 设置一起使用，则参数将被忽略，因此不会检查一致性。这可能会导致长期效果，即不匹配在长时间内未被检测到，而在调试时突然出现。
- en: 'So the next version of our macro is defined in two steps. The first uses a
    similar **`#if`**`/#`**`else`** idea to define a new macro: TRACE_ON.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们宏的下一个版本定义分为两个步骤。第一步使用类似的 **`#if`**`/#`**`else`** 概念来定义一个新的宏：TRACE_ON。
- en: '**`macro_trace.h`**'
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE39]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In contrast to the **`NDEBUG`** macro, which could be set to any value by the
    programmer, this new macro is guaranteed to hold either `1` or `0`. Second, TRACE_PRINT2
    is defined with a regular **`if`** conditional:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序员可以将其设置为任何值的 **`NDEBUG`** 宏相反，这个新宏保证要么是 `1` 要么是 `0`。其次，TRACE_PRINT2 使用常规的
    **`if`** 条件定义：
- en: '**`macro_trace.h`**'
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE40]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Whenever its argument is `0`, any modern compiler should be able to optimize
    out the call to **fprintf**. What it shouldn’t omit is the argument check for
    the parameters F and X. So regardless of whether we are debugging, the arguments
    to the macro must always be matching, because **fprintf** expects it.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当其参数为 `0` 时，任何现代编译器都应该能够优化掉对 **fprintf** 的调用。它不应该省略对参数 F 和 X 的检查。因此，无论我们是在调试还是不是，宏的参数必须始终匹配，因为
    **fprintf** 需要这样。
- en: 'Similar to the use of the empty string literal "" earlier, there are other
    tricks to force a macro argument to be a particular type. One of these tricks
    consists of adding an appropriate `0`: `+0` forces the argument to be any arithmetic
    type (integer, float, or pointer). Something like `+0.`0F promotes to a floating
    type. For example, if we want to have a simpler variant to just print a value
    for debugging, without keeping track of the type of the value, this could be sufficient
    for our needs:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前使用空字符串字面量 "" 类似，还有其他技巧可以强制宏参数具有特定类型。其中一种技巧是添加适当的 `0`：`+0` 强制参数为任何算术类型（整数、浮点或指针）。类似
    `+0.`0F 的东西提升为浮点类型。例如，如果我们只想为调试打印一个值，而不跟踪值的类型，这可能就足够了：
- en: '**`macro_trace.h`**'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE41]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It works for any value X that is either an integer or a floating point. The
    format "%Lg" for a **`long double`** ensures that any value is presented in a
    suitable way. Evidently, the HEAD argument now must not contain any **fprintf**
    format, but the compiler will tell us if the there is a mismatch.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 它适用于任何整数或浮点数 X。对于 **`long double`** 的格式 "%Lg" 确保任何值都以合适的方式呈现。显然，HEAD 参数现在不能包含任何
    **fprintf** 格式，但编译器会告诉我们是否有不匹配。
- en: 'Then, compound literals can be a convenient way to check whether the value
    of a parameter X is assignment-compatible to a type T. Consider the following
    first attempt to print a pointer value:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，复合字面量可以是一种方便的方式来检查参数 X 的值是否可以赋值给类型 T。考虑以下尝试打印指针值的第一个尝试：
- en: '**`macro_trace.h`**'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE42]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It tries to print a pointer value with a "%p" format, which expects a generic
    pointer of type **`void`**`*`. Therefore, the macro uses a *cast* to convert the
    value and type of X to **`void`**`*`. Like most casts, a cast here can go wrong
    if X isn’t a pointer: because the cast tells the compiler that we know what we
    are doing, all type checks are actually switched off.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 它尝试使用 "%p" 格式打印指针值，该格式期望一个通用的 **`void`**`*` 类型指针。因此，宏使用 *类型转换* 将 X 的值和类型转换为
    **`void`**`*`。像大多数类型转换一样，如果 X 不是一个指针，这里的类型转换可能会出错：因为类型转换告诉编译器我们知道我们在做什么，实际上所有的类型检查都被关闭了。
- en: 'This can be avoided by assigning X first to an object of type **`void`**`*`.
    Assignment only allows a restricted set of *implicit conversions*, here the conversion
    of any pointer to an object type to **`void`**`*`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过首先将 X 赋值给 **`void`**`*` 类型的对象来避免。赋值只允许一组受限的 *隐式转换*，这里是将任何指针转换为 **`void`**`*`
    的转换：
- en: '**`macro_trace.h`**'
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE43]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The trick is to use something like `((`T`){ 0 } = (`X`))` to check whether X
    is assignment-compatible to type T. Here, the compound literal `((`T`){ 0 }` first
    creates a temporary object of type T to which we then assign X. Again, a modern
    optimizing compiler should optimize away the use of the temporary object and only
    do the type checking for us.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧是使用类似于 `((`T`){ 0 } = (`X`))` 的方法来检查 X 是否可以赋值给类型 T。在这里，复合字面量 `((`T`){ 0 }`
    首先创建了一个类型 T 的临时对象，然后我们将 X 赋值给它。再次，现代优化编译器应该会优化掉临时对象的使用，并为我们进行类型检查。
- en: 16.3\. Accessing the calling context
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3. 访问调用上下文
- en: Since macros are just textual replacements, they can interact much more closely
    with the context of their caller. In general, for usual functionality, this isn’t
    desirable, and we are better off with the clear separation between the context
    of the caller (evaluation of function arguments) and that of the callee (use of
    function parameters).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宏只是文本替换，它们可以与其调用者的上下文更紧密地交互。一般来说，对于常规功能，这不是所希望的，我们更希望调用者（函数参数的评估）和被调用者（函数参数的使用）之间的上下文有明确的分离。
- en: 'In the context of debugging, though, we usually want to break that strict separation
    to observe part of the state at a specific point in our code. In principle, we
    could access any variable inside a macro, but generally we want some more specific
    information about the calling environment: a trace of the position from which
    particular debugging output originates.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在调试的上下文中，我们通常希望打破这种严格的分离，以观察代码中特定点的部分状态。原则上，我们可以在宏内部访问任何变量，但通常我们想要有关调用环境的更多具体信息：特定调试输出来源的位置跟踪。
- en: 'C offers several constructs for that purpose. It has a special macro **`__LINE__`**
    that always expands to a decimal integer constant for the number of the actual
    line in the source:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: C 提供了几个用于此目的的构造。它有一个特殊的宏 **`__LINE__`**，它始终展开为源文件中实际行的十进制整数常量：
- en: '**`macro_trace.h`**'
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE44]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Likewise, the macros **`__DATE__`**, **`__TIME__`**, and **`__FILE__`** contain
    string literals with the date and time of compilation and the name of the current
    TU. Another construct, **`__func__`**, is a local **`static`** variable that holds
    the name of the current function:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，宏 **`__DATE__`**、**`__TIME__`** 和 **`__FILE__`** 包含包含编译日期和时间以及当前 TU 名称的字符串字面量。另一个构造，**`__func__`**，是一个包含当前函数名称的局部
    **`static`** 变量：
- en: '**`macro_trace.h`**'
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE45]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the following invocation
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下调用
- en: '**`macro_trace.c`**'
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.c`**'
- en: '[PRE46]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'is at line 24 of the source file and **main** is its surrounding function,
    the corresponding output looks similar to this:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件的第 24 行，并且 **main** 是其周围函数，则相应的输出看起来类似于以下内容：
- en: '`Terminal`'
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE47]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Another pitfall that we should have in mind if we are using **fprintf** automatically
    as in this example is that *all* arguments in its list must have the correct type
    as given in the specifier. For **`__func__`**, this is no problem: by its definition
    we know that this is a **`char`** array, so the "%s" specifier is fine. **`__LINE__`**
    is different. We know that it is a decimal constant representing the line number.
    So if we revisit the rules for the types of decimal constants in [section 5.3](kindle_split_013.html#ch05lev1sec3),
    we see that the type depends on the value. On embedded platforms, **`INT_MAX`**
    might be as small as 32767, and very large sources (perhaps automatically produced)
    may have more lines than that. A good compiler should warn us when such a situation
    arises.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像这个例子中那样自动使用 **fprintf**，我们应该注意的一个潜在陷阱是，其列表中的所有参数都必须与指定符中给出的类型正确匹配。对于 **`__func__`**，这没有问题：根据其定义，我们知道这是一个
    **`char`** 数组，所以 "%s" 指定符是合适的。**`__LINE__`** 则不同。我们知道它是一个表示行号的十进制常量。因此，如果我们回顾
    [第 5.3 节](kindle_split_013.html#ch05lev1sec3) 中十进制常量类型的规则，我们会看到类型取决于值。在嵌入式平台上，**`INT_MAX`**
    可能小到 32767，而非常大的源代码（可能是自动生成的）可能有超过这个数量的行。一个好的编译器应该在出现这种情况时警告我们。
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.5
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 16.5
- en: '*The line number in* **`__LINE__`** *may not fit into an* **`int`***.*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*在* **`__LINE__`** *中的行号可能不适合放入一个* **`int`***.*'
- en: '|  |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.6
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 16.6
- en: '*Using* **`__LINE__`** *is inherently dangerous.*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **`__LINE__`** *固有的很危险。*'
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In our macros, we avoid the problem by either fixing the type to **`unsigned
    long`**^([[2](#ch16fn02)]) or by transforming the number to a string during compilation.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的宏中，我们通过将类型固定为 **`unsigned long`**^([[2](#ch16fn02)]) 或在编译期间将数字转换为字符串来避免这个问题。
- en: ²
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hoping that no source will have more than 4 billion lines.
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 希望没有源代码会超过 40 亿行。
- en: 'There is another type of information from the calling context that is often
    quite helpful for traces: the actual expressions that we passed to the macro as
    arguments. As this is often used for debugging purposes, C has a special operator
    for it: **`#`**. If such a **`#`** appears before a macro parameter in the expansion,
    the actual argument to this parameter is *stringified*: that is, all its textual
    content is placed into a string literal. The following variant of our trace macro
    has a **`#`**`X`'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种来自调用上下文的信息类型对于跟踪通常非常有用：我们传递给宏作为参数的实际表达式。由于这通常用于调试目的，C 语言有一个特殊的操作符用于它：**`#`**。如果这样的
    **`#`** 出现在宏参数的展开中，这个参数的实际参数将被 *字符串化*：也就是说，它的所有文本内容都被放入一个字符串字面量中。以下我们跟踪宏的变体有一个
    **`#`**`X`
- en: '**`macro_trace.h`**'
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE48]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: that is replaced by the text of the second argument at each call of the macro.
    For the following invocations
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次宏调用时，它被替换为第二个参数的文本。对于以下调用
- en: '**`macro_trace.c`**'
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.c`**'
- en: '[PRE49]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: the corresponding output looks similar to
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的输出看起来类似
- en: '`Terminal`'
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE50]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Because the preprocessing phase knows nothing about the interpretation of these
    arguments, this replacement is purely textual and should appear as in the source,
    with some possible adjustments for whitespace.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 因为预处理阶段对这些参数的解释一无所知，这种替换完全是文本性的，并且应该像在源代码中一样出现，可能还有一些对空白的调整。
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.7
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 16.7
- en: '*Stringification with the operator* **`#`** *does not expand macros in its
    argument.*'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用操作符* **`#`** *进行字符串化不会在其参数中展开宏。*'
- en: '|  |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In view of the potential problems with **`__LINE__`** mentioned earlier, we
    also would like to convert the line number directly into a string. This has a
    double advantage: it avoids the type problem, and stringification is done entirely
    at compile time. As we said, the **`#`** operator only applies to macro arguments,
    so a simple use like **`#`** **`__LINE__`** does not have the desired effect.
    Now consider the following macro definition:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面提到的 **`__LINE__`** 可能存在的问题，我们还想直接将行号转换为字符串。这有两个优点：它避免了类型问题，并且字符串化完全在编译时完成。正如我们所说的，**`#`**
    操作符仅适用于宏参数，所以像 **`#`** **`__LINE__`** 这样的简单使用不会产生预期的效果。现在考虑以下宏定义：
- en: '**`macro_trace.h`**'
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE51]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Stringification kicks in before argument replacement, and the result of STRINGIFY`(`**`__LINE__`**`)`
    is "__LINE__"; the macro **`__LINE__`** is not expanded. So this macro still is
    not sufficient for our needs.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串化在参数替换之前进行，`STRINGIFY`(`**__LINE__`**) 的结果是 "__LINE__"；宏 **`__LINE__`** 不会被展开。所以这个宏仍然不足以满足我们的需求。
- en: 'Now, STRGY`(`**`__LINE__`**`)` first expands to STRINGIFY`(25)` (if we are
    on line 25). This then expands to "25", the stringified line number:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，STRGY`(`**`__LINE__`**`)` 首先扩展为 STRINGIFY`(25)`（如果我们处于第 25 行）。然后它扩展为 "25"，即字符串化的行号：
- en: '**`macro_trace.h`**'
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE52]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For completeness, we will also mention another operator that is only valid
    in the preprocessing phase: the *`##`* operator. It is for even more specialized
    use: it is a *token concatenation operator*. It can be useful when writing entire
    macro libraries where we have to generate names for types or functions automatically.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们还将提及另一个仅在预处理阶段有效的运算符：*`##`* 运算符。它用于更加专业的用途：它是一个 *标记连接运算符*。当编写整个宏库，并且需要自动生成类型或函数名称时，它可能很有用。
- en: 16.4\. Default arguments
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4\. 默认参数
- en: 'Some functions of the C library have parameters that receive the same boring
    arguments most of the time. This is the case for **strtoul** and relatives. Remember
    that these receive three arguments:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: C 库的一些函数有参数，这些参数大多数时候接收相同的无聊参数。对于 **strtoul** 和其相关函数来说就是这样。记住，这些函数接收三个参数：
- en: '[PRE53]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first is the string that we want to convert into an **`unsigned long`**.
    endptr will point to the end of the number in the string, and base is the integer
    base for which the string is interpreted. Two special conventions apply: if endptr
    may be a null pointer and if base is `0`, the string is interpreted as hexadecimal
    (leading "0x"), octal (leading "0"), or decimal otherwise.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是我们要将其转换为 **`unsigned long`** 的字符串。endptr 将指向字符串中数字的末尾，base 是解释字符串的整数基数。有两个特殊约定适用：如果
    endptr 可能是空指针，并且 base 是 `0`，则字符串被解释为十六进制（以 "0x" 开头）、八进制（以 "0" 开头）或十进制否则。
- en: Most of the time, **strtoul** is used without the endptr feature and with the
    symbolic base set to `0`, for example in something like
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，**strtoul** 都不带 endptr 功能，并且将符号基数设置为 `0`，例如在类似以下内容中
- en: '[PRE54]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'to convert the first command-line argument of a program to a length value.
    To avoid this repetition and to have the reader of the code concentrate on the
    important things, we can introduce an intermediate level of macros that provide
    these `0` arguments if they are omitted:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序的第一个命令行参数转换为长度值。为了避免这种重复，并让代码的读者专注于重要的事情，我们可以引入一个中间级别的宏，如果省略这些 `0` 参数，则提供这些参数：
- en: '**`generic.h`**'
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`generic.h`**'
- en: '[PRE55]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, the macro ZERO_DEFAULT3 works by subsequent addition and removal of arguments.
    It is supposed to receive a function name and at least one argument that is to
    be passed to that function. First, two zeros are appended to the argument list;
    then, if this results in more than three combined arguments, the excess is omitted.
    So for a call with just one argument, the sequence of replacements looks as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，宏 ZERO_DEFAULT3 通过后续添加和删除参数来工作。它应该接收一个函数名称和至少一个要传递给该函数的参数。首先，将两个零添加到参数列表中；然后，如果这导致超过三个组合参数，则省略多余的参数。因此，对于只有一个参数的调用，替换序列如下所示：
- en: '[PRE56]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Because of the special rule that inhibits recursion in macro expansion, the
    final function call to **strtoul** will not be expanded further and is passed
    on to the next compilation phases.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宏扩展中抑制递归的特殊规则，对 **strtoul** 的最终函数调用将不会进一步扩展，并将传递到下一个编译阶段。
- en: If instead we call **strtoul** with three arguments
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用三个参数调用 **strtoul**
- en: '[PRE57]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: the sequence of replacements effectively results in exactly the same tokens
    with which we started.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 替换序列实际上产生了与开始时完全相同的标记。
- en: 16.5\. Variable-length argument lists
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5\. 可变长度参数列表
- en: 'We have looked at functions that accept argument lists of variable length:
    **printf**, **scanf**, and friends. Their declarations have the token `...` at
    the end of the parameter list to indicate that feature: after an initial number
    of known arguments (such as the format for **printf**), a list of arbitrary length
    of additional arguments can be provided. Later, in [section 16.5.2](#ch16lev2sec2),
    we will briefly discuss how such functions can be defined. Because it is not type
    safe, this feature is dangerous and almost obsolete, so we will not insist on
    it. Alternatively, we will present a similar feature, *variadic macros*, that
    can mostly be used to replace the feature for functions.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了接受可变长度参数列表的函数：**printf**、**scanf**及其朋友。它们的声明在参数列表的末尾有`...`标记来指示这个特性：在已知参数的初始数量（例如**printf**的格式）之后，可以提供一个任意长度的额外参数列表。稍后，在[第16.5.2节](#ch16lev2sec2)中，我们将简要讨论如何定义这样的函数。因为这个特性不安全，所以它是危险的，几乎已经过时，所以我们不会坚持这个特性。作为替代，我们将介绍一个类似的功能，即*可变参数宏*，这可以主要用于替换函数的特性。
- en: 16.5.1\. Variadic macros
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.1\. 可变参数宏
- en: 'Variable-length argument macros, *variadic macros* for short, use the same
    token *`...`* to indicate the feature. As with functions, this token must appear
    at the end of the parameter list:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 可变长度参数宏，简称为*可变参数宏*，使用相同的标记*`...`*来指示这个特性。与函数一样，这个标记必须出现在参数列表的末尾：
- en: '**`macro_trace.h`**'
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE58]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, in TRACE_PRINT6, this indicates that after the format argument F, any
    non-empty list of additional arguments may be provided in a call. This list of
    expanded arguments is accessible in the expansion through the identifier **`__VA_ARGS__`**.
    Thus a call such as
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在TRACE_PRINT6中，这表示在格式参数F之后，可以提供一个非空的可选参数列表。这个展开的参数列表可以通过标识符**`__VA_ARGS__`**在展开中访问。因此，一个如下的调用
- en: '**`macro_trace.c`**'
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.c`**'
- en: '[PRE59]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: just passes the arguments through to **fprintf** and results in the output
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 只是传递参数到**fprintf**并产生输出
- en: '`Terminal`'
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Terminal`'
- en: '[PRE60]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Unfortunately, as it is written, the list in **`__VA_ARGS__`** cannot be empty
    or absent. So for what we have seen so far, we’d have to write a separate macro
    for the case where the list is absent:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，按照目前的写法，**`__VA_ARGS__`**中的列表不能为空或不存在。所以对于我们迄今为止所看到的，我们不得不为列表不存在的情况编写一个单独的宏：
- en: '`macro_trace.h`'
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`macro_trace.h`'
- en: '[PRE61]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'But with more effort, these two functionalities can be united into a single
    macro:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过更多的努力，这两个功能可以被合并成一个宏：
- en: '`macro_trace.h`'
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`macro_trace.h`'
- en: '[PRE62]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, TRACE_FIRST and TRACE_LAST are macros that give access to the first and
    remaining arguments in the list, respectively. Both are relatively simple. They
    use auxiliary macros that enable us to distinguish a first parameter _0 from the
    remainder **`__VA_ARGS__`**. Since we want to be able to call both with one or
    more arguments, they add a new argument `0` to the list. For TRACE_FIRST, this
    goes well. This additional `0` is just ignored as are the rest of the arguments:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，TRACE_FIRST和TRACE_LAST是宏，分别提供对列表中第一个和剩余参数的访问。它们相对简单。它们使用辅助宏，使我们能够区分第一个参数_0和其余的**`__VA_ARGS__`**。由于我们希望能够用一个或多个参数调用它们，它们向列表中添加了一个新的参数`0`。对于TRACE_FIRST来说，这很顺利。这个额外的`0`就像其余的参数一样被忽略：
- en: '**`macro_trace.h`**'
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE63]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For TRACE_LAST, this is a bit more problematic, since it extends the list in
    which we are interested by an additional value:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TRACE_LAST来说，这有点问题，因为它通过一个额外的值扩展了我们感兴趣的列表：
- en: '**`macro_trace.h`**'
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE64]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Therefore, TRACE_PRINT6 compensates for this with an additional format specifier,
    "%.0d", that prints an **`int`** of width `0`: that is, nothing. Testing it for
    the two different use cases'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TRACE_PRINT6通过一个额外的格式说明符`%.0d`来补偿这一点，该说明符打印一个宽度为`0`的**`int`**：即，什么也不打印。测试它在两种不同的使用情况
- en: '**`macro_trace.c`**'
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.c`**'
- en: '[PRE65]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'gives us exactly what we want:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '给我们我们想要的 exactly what we want:'
- en: '`Terminal`'
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Terminal`'
- en: '[PRE66]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The **`__VA_ARGS__`** part of the argument list also can be stringified just
    like any other macro parameter:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表中的**`__VA_ARGS__`**部分也可以像任何其他宏参数一样进行字符串化：
- en: '**`macro_trace.h`**'
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE67]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The textual representation of the arguments
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的文本表示
- en: '**`macro_trace.c`**'
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.c`**'
- en: '[PRE68]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'is inserted, including the commas that separate them:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 被插入，包括分隔它们的逗号：
- en: '`Terminal`'
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Terminal`'
- en: '[PRE69]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'So far, our variants of the trace macro that have a variable number of arguments
    must also receive the correct format specifiers in the format argument F. This
    can be a tedious exercise, since it forces us to always keep track of the type
    of each argument in the list that is to be printed. A combination of an **`inline`**
    function and a macro can help us here. First let us look at the function:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们具有可变数量参数的迹宏变体也必须在格式参数 F 中接收正确的格式说明符。这可能会是一项繁琐的工作，因为它迫使我们始终跟踪要打印的列表中每个参数的类型。一个内联函数和宏的组合可以在这里帮助我们。首先让我们看看这个函数：
- en: '**`macro_trace.h`**'
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE70]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: It prints a list of **`long double`** values after preceding them with the same
    header information, as we have done before. Only this time, the function receives
    the list of values through an array of **`long double`** s of known length len.
    For reasons that we will see shortly, the function actually always skips the last
    element of the array. Using a function trace_skip, it also skips an initial part
    of the parameter expr.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 它在前面加上相同的标题信息后打印一系列 **`long double`** 值，就像我们之前所做的那样。但这次，函数通过一个已知长度为 len 的 **`long
    double`** 数组接收值列表。由于我们将很快看到的原因，该函数实际上总是跳过数组的最后一个元素。使用 trace_skip 函数，它还跳过参数 expr
    的初始部分。
- en: 'The macro that passes the contextual information to the function comes in two
    levels. The first is just massaging the argument list in different ways:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 将上下文信息传递给函数的宏有两个级别。第一个只是以不同的方式按摩参数列表：
- en: '**`macro_trace.h`**'
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE71]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'First, with the help of ALEN, which we will see in a moment, it evaluates the
    number of elements in the list. Then it stringifies the list and finally appends
    the list itself plus an additional `0`. All this is fed into TRACE_VALUES0:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，借助我们即将看到的 ALEN，它评估列表中的元素数量。然后它将列表字符串化，并最终将列表本身以及一个额外的 `0` 附加到列表上。所有这些都被输入到
    TRACE_VALUES0：
- en: '**`macro_trace.h`**'
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE72]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, the list without HEAD is used as an initializer of a compound literal
    of type **`long double const`**`[`NARG`]`. The `0` that we added earlier ensures
    that the initializer is never empty. With the information on the length of the
    argument list, we are also able to make a case distinction, if the only argument
    is just the format string.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，没有 HEAD 的列表用作类型为 **`long double const`**`[`NARG`]` 的复合字面量的初始化器。我们之前添加的 `0`
    确保初始化器永远不会为空。有了关于参数列表长度的信息，我们也能够进行情况区分，如果唯一的参数只是格式字符串。
- en: 'We also need to show ALEN:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要展示 ALEN：
- en: '**`macro_trace.h`**'
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE73]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The idea is to take the **`__VA_ARGS__`** list and append a list of decreasing
    numbers `31`, `30`, . . . , `0`. Then, by using ALEN0, we return the 31^(st) element
    of that new list. Depending on the length of the original list, this element will
    be one of the numbers. In fact, it is easy to see that the returned number is
    exactly the length of the original list, provided it contains at least one element.
    In our use case, there is always at least the format string, so the border case
    of an empty list cannot occur.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是取 **`__VA_ARGS__`** 列表并附加一个递减数字列表 `31`，`30`，...，`0`。然后，通过使用 ALEN0，我们返回该新列表的第
    31 个元素。根据原始列表的长度，这个元素将是其中一个数字。实际上，很容易看出返回的数字正是原始列表的长度，前提是它至少包含一个元素。在我们的用例中，总是至少有一个格式字符串，因此空列表的边界情况不会发生。
- en: '16.5.2\. A detour: variadic functions'
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.2\. 一个小插曲：可变参数函数
- en: 'Let us now have a brief look at *variadic functions*: functions with variable-length
    argument lists. As already mentioned, these are specified by using the *`...`*
    operator in the function declaration, such as in'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简要地看看 *可变参数函数*：具有可变长度参数列表的函数。如前所述，这些函数通过在函数声明中使用 *`...`* 操作符来指定，例如
- en: '[PRE74]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Such functions have a fundamental problem in their interface definition. Unlike
    normal functions, at the call side it is not clear to which parameter type an
    argument should be converted. For example, if we call **printf**`(`"%d"`, 0)`,
    it is not immediately clear to the compiler what kind of `0` the called function
    is expecting. For such cases, C has a set of rules to determine the type to which
    an argument is converted. These are almost identical to the rules for arithmetic:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数在其接口定义中存在一个基本问题。与普通函数不同，在调用方面，不清楚应该将参数转换为哪种类型。例如，如果我们调用 **printf**`(`"%d"`,
    0)`，编译器不会立即清楚调用函数期望哪种类型的 `0`。对于这种情况，C 语言有一套规则来确定参数转换的类型。这些规则几乎与算术规则相同：
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.8
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得 16.8 的要点
- en: '*When passed to a variadic parameter, all arithmetic types are converted as
    for arithmetic operations, with the exception of* **`float`** *arguments, which
    are converted to* **`double`***.*'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '*当传递给可变参数时，所有算术类型都像算术运算一样进行转换，除了* **`float`** *参数，它们会被转换为**`double`***。'
- en: '|  |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So in particular when they are passed to a variadic parameter, types such as
    **`char`** and **`short`** are converted to a wider type, usually **`int`**.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 所以特别地，当它们被传递给可变参数时，例如**`char`**和**`short`**这样的类型会被转换为更宽的类型，通常是**`int`**。
- en: 'So far, so good: now we know how such functions get called. But unfortunately,
    these rules tell us nothing about the type that the called function should expect
    to receive.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利：现在我们知道了如何调用这样的函数。但不幸的是，这些规则并没有告诉我们被调用函数应该期望接收哪种类型。
- en: '|  |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.9
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结 16.9
- en: '*A variadic function has to receive valid information about the type of each
    argument in the variadic list.*'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变函数必须接收关于可变列表中每个参数类型的有效信息。*'
- en: '|  |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The **printf** functions get away with this difficulty by imposing a specification
    for the types inside the format argument. Let us look at the following short code
    snippet:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**printf**函数通过在格式参数内部指定类型来规避这个困难。让我们看看以下简短的代码片段：'
- en: '[PRE75]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This has the effect that zChar is evaluated, promoted to **`int`**, and passed
    as an argument to **printf**, which then reads this **`int`** and re-interprets
    the value as **`unsigned char`**. This mechanism is
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致zChar被评估，提升为**`int`**类型，并作为参数传递给**printf**，然后它读取这个**`int`**并将其重新解释为**`unsigned
    char`**。这种机制是
- en: '*Complicated:* because the implementation of the function must provide specialized
    code for all the basic types'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复杂：* 因为函数的实现必须为所有基本类型提供专门的代码'
- en: '*Error-prone:* because each call depends on the fact that the argument types
    are correctly transmitted to the function'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*易出错：* 因为每个调用都依赖于参数类型被正确传递给函数'
- en: '*Exigent:* because the programmer has to check the type of each argument'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*紧迫：* 因为程序员必须检查每个参数的类型'
- en: In particular, the latter can cause serious portability bugs, because constants
    can have different types from platform to platform. For example, the innocent
    call
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是后者可能导致严重的可移植性问题，因为常量在不同的平台上可能有不同的类型。例如，一个看似无害的调用
- en: '[PRE76]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'will work well on most platforms: those that have an **`int`** type with more
    than 16 bits. But on some platforms, it may fail at runtime because `65536` is
    **`long`**. The worst example for such a potential failure is the macro **`NULL`**:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数平台上都能正常工作：那些具有超过16位**`int`**类型的平台。但在某些平台上，它可能在运行时失败，因为`65536`是**`long`**。这种潜在失败的最坏例子是宏**`NULL`**：
- en: '[PRE77]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As we saw in [section 11.1.5](kindle_split_021.html#ch11lev2sec5), **`NULL`**
    is only guaranteed to be a null pointer constant. Compiler implementors are free
    to choose which variant they provide: some choose `(`**`void`**`*)0`, with a type
    of **`void`**`*`; most choose `0`, with a type of **`int`**. On platforms that
    have different widths for pointers and **`int`**, such as all modern 64-bit platforms,
    the result is a program crash.^([[3](#ch16fn03)])'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第11.1.5节](kindle_split_021.html#ch11lev2sec5)中看到的，**`NULL`**仅保证是一个空指针常量。编译器实现者可以自由选择他们提供的变体：有些人选择`(`**`void`**`)0`，其类型为**`void`**`*`；大多数人选择`0`，其类型为**`int`**。在指针和**`int`**宽度不同的平台上，例如所有现代64位平台，这可能导致程序崩溃.^([[3](#ch16fn03)])
- en: ³
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That is one of the reasons we should not use **`NULL`** at all ([takeaway 11.14](kindle_split_021.html#ch11note14)).
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是我们不应该使用**`NULL`**的原因之一 ([总结 11.14](kindle_split_021.html#ch11note14))。
- en: '|  |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.10
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结 16.10
- en: '*Using variadic functions is not portable unless each argument is forced to
    a specific type.*'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用可变函数不可移植，除非每个参数都被强制转换为特定类型。*'
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is quite different from the use of variadic macros as we saw in the example
    of TRACE_VALUES. There we used the variadic list as an initializer to an array,
    so all elements were automatically converted to the correct target type.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前在TRACE_VALUES示例中看到的可变宏的使用大不相同。在那里，我们将可变列表用作数组的初始化器，因此所有元素都会自动转换为正确的目标类型。
- en: '|  |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.11
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结 16.11
- en: '*Avoid variadic functions for new interfaces.*'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免在新接口中使用可变函数。*'
- en: '|  |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'They are just not worth the pain. But if you have to implement a variadic function,
    you need the C library header `stdarg.h`. It defines one type, **`va_list`**,
    and four function-like macros that can be used as the different arguments behind
    a **`va_list`**. Their pseudo interfaces look like this:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数根本不值得麻烦。但是如果你必须实现一个可变参数函数，你需要 C 库头文件 `stdarg.h`。它定义了一个类型，**`va_list`**，以及四个可以作为
    **`va_list`** 后面不同参数使用的函数式宏。它们的伪接口看起来像这样：
- en: '|  |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdarg.h>`'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdarg.h>`'
- en: '|  |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE78]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The first example shows how to actually avoid programming the core part of
    a variadic function. For anything that concerns formatted printing, there are
    existing functions we should use:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例展示了如何实际上避免编写可变参数函数的核心部分。对于任何涉及格式化打印的事情，我们应该使用现有的函数：
- en: '**`va_arg.c`**'
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`va_arg.c`**'
- en: '[PRE79]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The only thing we do with **va_start** and **va_end** is to create a **`va_list`**
    argument list and pass this information on to the C library function **vfprintf**.
    This completely spares us from doing the case analysis and tracking the arguments.
    The conditional __attribute__ is compiler specific (here, for `GCC` and friends).
    Such an add-on may be very helpful in situations where a known parameter convention
    is applied and where the compiler can do some good diagnostics to ensure the validity
    of the arguments.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **`va_start`** 和 **`va_end`** 做的唯一事情是创建一个 **`va_list`** 参数列表，并将此信息传递给 C
    库函数 **`vfprintf`**。这完全免除了我们进行情况分析和跟踪参数的需要。条件 __attribute__ 是编译器特定的（这里，对于 `GCC`
    和其同类）。这种附加功能在应用已知参数约定并且编译器可以进行一些良好的诊断以确保参数有效性的情况下可能非常有用。
- en: Now we will look at a variadic function that receives n **`double`** values
    and that sums them up:^([[[Exs 4]](#ch16fn-ex04)])
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看一个接收 n 个 **`double`** 值并求和的可变参数函数：^([[[Exs 4]](#ch16fn-ex04)])
- en: ^([Exs 4])
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 4])
- en: ''
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Variadic functions that only receive arguments that are all the same type can
    be replaced by a variadic macro and an **`inline`** function that takes an array.
    Do it.
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只接收所有参数都是同一类型的可变参数函数可以被一个可变参数宏和一个接受数组的 **`inline`** 函数所替代。这样做吧。
- en: '**`va_arg.c`**'
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`va_arg.c`**'
- en: '[PRE80]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The **`va_list`** is initialized by using the last argument before the list.
    Observe that by some magic, **va_start** receives va as such and not with an address
    operator `&`. Then, inside the loop, every value in the list is received through
    the use of the **va_arg** macro, which needs an explicit specification (here,
    **`double`**) of its *type* argument. Also, we have to maintain the length of
    the list ourselves, here by passing the length as an argument to the function.
    The encoding of the argument type (here, implicit) and the detection of the end
    of the list are left up to the programmer of the function.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**`va_list`** 通过使用列表之前的最后一个参数进行初始化。注意，通过某种魔法，**va_start** 接收 va 如此，而不是使用地址运算符
    `&`。然后，在循环内部，列表中的每个值都通过使用 **va_arg** 宏来接收，该宏需要对其 *类型* 参数进行显式指定（这里，**`double`**）。此外，我们必须自己维护列表的长度，这里是通过将长度作为参数传递给函数来实现的。参数类型的编码（这里，隐式）和列表末尾的检测留给函数的程序员。'
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.12
  id: totrans-599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 16.12
- en: '*The* **va_arg** *mechanism doesn’t give access to the length of the* **`va_list`***.*'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**`va_arg`** 机制不提供对 **`va_list`** 长度的访问。'
- en: '|  |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.13
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 16.13
- en: '*A variadic function needs a specific convention for the length of the list.*'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变参数函数需要一个特定的列表长度约定*。'
- en: '|  |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.6\. Type-generic programming
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.6\. 类型通用的编程
- en: 'One of the genuine additions of C11 to the C language has been direct language
    support for type-generic programming. C99 had `tgmath.h` (see [section 8.2](kindle_split_016.html#ch08lev1sec2))
    for type-generic mathematical functions, but it didn’t offer much to program such
    interfaces yourself. The specific add-on is the keyword **`_Generic`**, which
    introduces a primary expression of the following form:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: C11 对 C 语言的一个真正的贡献是直接语言支持类型通用的编程。C99 有 `tgmath.h`（见 [第 8.2 节](kindle_split_016.html#ch08lev1sec2)）用于类型通用的数学函数，但它没有提供很多来自己编写这样的接口。特定的附加功能是关键字
    **`_Generic`**，它引入了以下形式的初等表达式：
- en: '|  |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<tgmath.h>`'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tgmath.h>`'
- en: '|  |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE81]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This is very similar to a **`switch`** statement. But the *controlling expression*
    is only taken for its type (but see shortly), and the result is one of the expressions
    *expression1* . . . *expressionN* chosen by the corresponding type-specific *type1*
    . . . *typeN*, of which one may be simply the keyword **`default`**.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常类似于一个 **`switch`** 语句。但是，*控制表达式*只取其类型（但请稍后查看），结果是 *expression1* . . . *expressionN*
    中的一个表达式，这些表达式由相应的类型特定的 *type1* . . . *typeN* 选择，其中之一可能只是关键字 **`default`**。
- en: 'One of the simplest use cases, and primarily what the C committee had in mind,
    is to use **`_Generic`** for a type-generic macro interface by providing a choice
    between function pointers. A basic example for this is the the `tgmath.h` interfaces,
    such as **`fabs`**. **`_Generic`** is not a macro feature itself but can conveniently
    be used in a macro expansion. By ignoring complex floating-point types, such a
    macro for **`fabs`** could look like this:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的用例之一，也是C委员会主要考虑的，是使用**`_Generic`**通过提供函数指针之间的选择来实现类型通用宏接口。一个基本例子是`tgmath.h`接口，如**`fabs`**。**`_Generic`**本身不是一个宏特性，但可以方便地在宏展开中使用。通过忽略复数浮点类型，这样的**`fabs`**宏可能看起来像这样：
- en: '[PRE82]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This macro distinguishes two specific types, **`float`** and **`long double`**,
    which choose the corresponding functions **fabsf** and **fabsl**, respectively.
    If the argument X is of any other type, it is mapped to the **`default`** case
    of **`fabs`**. That is, other arithmetic types such as **`double`** and integer
    types are mapped to **`fabs`**.^([[[Exs 5]](#ch16fn-ex05)])^([[[Exs 6]](#ch16fn-ex06)])
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏区分了两种特定类型，**`float`**和**`long double`**，分别选择对应的函数**fabsf**和**fabsl**。如果参数X是任何其他类型，它将被映射到**`fabs`**的**`default`**情况。也就是说，其他算术类型，如**`double`**和整数类型，被映射到**`fabs`**.^([[[Exs
    5]](#ch16fn-ex05)])^([[[Exs 6]](#ch16fn-ex06)])
- en: ^([Exs 5])
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 5])
- en: ''
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Find the two reasons why this occurrence of **`fabs`** in the macro expansion
    is not itself expanded.
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 找出两个原因，说明这个宏展开中**`fabs`**的出现本身没有被展开。
- en: ^([Exs 6])
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 6])
- en: ''
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the **`fabs`** macro to cover complex floating-point types.
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将**`fabs`**宏扩展到涵盖复数浮点类型。
- en: Now, once the resulting function pointer is determined, it is applied to the
    argument list `(`X`)` that follows the **`_Generic`** primary expression.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦确定了结果函数指针，它就被应用于**`_Generic`**主要表达式后面的参数列表`(`X`)`。
- en: 'Here comes a more complete example:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个更完整的例子：
- en: '**`generic.h`**'
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`generic.h`**'
- en: '[PRE83]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It implements a type-generic interface for the minimum of two real values. Three
    different **`inline`** functions for the three floating-point types are defined
    and then used in a similar way as for **`fabs`**. The difference is that these
    functions need two arguments, not only one, so the **`_Generic`** expression must
    decide on a combination of the two types. This in done by using the sum of the
    two arguments as a *controlling expression*. As a consequence, argument promotions
    and conversion are effected to the arguments of that plus operation, and so the
    **`_Generic`** expression chooses the function for the wider of the two types,
    or **`double`** if both arguments are integers.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了两个实数值最小值的类型通用接口。定义了三个针对三种浮点类型的**`inline`**函数，并按与**`fabs`**类似的方式使用。不同之处在于，这些函数需要两个参数，而不仅仅是其中一个，因此**`_Generic`**表达式必须决定两种类型的组合。这是通过使用两个参数之和作为*控制表达式*来实现的。因此，参数提升和转换作用于加法操作中的参数，因此**`_Generic`**表达式选择两种类型中较宽的函数，或者如果两个参数都是整数，则选择**`double`**。
- en: The difference from just having one function for **`long double`**, say, is
    that the information about the type of the concrete arguments is not lost.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 与只有一个函数，比如**`long double`**相比，区别在于具体参数的类型信息没有丢失。
- en: '|  |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.14
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得第16.14点
- en: '*The result type of a* **`_Generic`** *expression is the type of the chosen
    expression.*'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '*`_Generic`**表达式的结果类型是所选表达式的类型*。'
- en: '|  |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is in contrast to what is happening, for example, for the ternary operator
    `a`?`b`:c. Here, the return type is computed by combining the two types b and
    c. For the ternary operator, this must be done like that because a may be different
    from run to run, so either b or c may be selected. Since **`_Generic`** makes
    its choice based upon the type, this choice is fixed at compile time. So, the
    compiler can know the resulting type of the choice in advance.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这与例如三元运算符`a`?`b`:c的情况形成对比。在这里，返回类型是通过结合类型b和c来计算的。对于三元运算符，必须这样做，因为a可能在不同的运行中不同，所以b或c可能被选中。由于**`_Generic`**根据类型做出选择，因此这个选择在编译时是固定的。因此，编译器可以提前知道选择的结果类型。
- en: In our example, we can be sure that all generated code that uses our interface
    will never use wider types than the programmer has foreseen. In particular, our
    min macro should always result in the compiler inlining the appropriate code for
    the types in question.^([[[Exs 7]](#ch16fn-ex07)])^([[[Exs 8]](#ch16fn-ex08)])
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以确信，所有使用我们的接口生成的代码永远不会使用比程序员预见的更宽的类型。特别是，我们的min宏应该始终导致编译器为相关类型内联适当的代码.^([[[Exs
    7]](#ch16fn-ex07)])^([[[Exs 8]](#ch16fn-ex08)])
- en: ^([Exs 7])
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 7])
- en: ''
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the min macro to cover all wide integer types.
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 min 宏扩展以涵盖所有宽整数类型。
- en: ^([Exs 8])
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 8])
- en: ''
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend min to cover pointer types, as well.
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 min 扩展以涵盖指针类型，同样。
- en: '|  |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.15
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 16.15
- en: '*Using* **`_Generic`** *with* **`inline`** *functions adds optimization opportunities.*'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **`_Generic`** 与 **`inline`** 函数一起使用增加了优化机会。
- en: '|  |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The interpretation of what it means to talk about the *type of the controlling
    expression* is a bit ambiguous, so C17 clarifies this in comparison to C11\. In
    fact, as the previous examples imply, this type is the type of the expression
    *as if* it were passed to a function. This means in particular:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 对“控制表达式的类型”这一说法的解释有点模糊，因此 C17 与 C11 相比对此进行了澄清。事实上，正如前面的例子所暗示的，这种类型是如果将其传递给函数的表达式的类型。这意味着特别是：
- en: If there are any, type qualifiers are dropped from the type of the controlling
    expression.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，类型限定符将从控制表达式的类型中删除。
- en: An array type is converted to a pointer type to the base type.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组类型被转换为基类型的指针类型。
- en: A function type is converted to a pointer to a function.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型被转换为函数指针。
- en: '|  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.16
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 16.16
- en: '*The type expressions in a* **`_Generic`** *expression should only be unqualified
    types: no array types, and no function types.*'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **`_Generic`** 表达式中的类型表达式应该是无资格的类型：没有数组类型，也没有函数类型。
- en: '|  |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'That doesn’t mean the type expressions can’t be pointers to one of those: a
    pointer to a qualified type, a pointer to an array, or a pointer to a function.
    But generally, this rules makes the task of writing a type-generic macro easier,
    since we do not have to take all combinations of qualifiers into account. There
    are 3 qualifiers (4 for pointer types), so otherwise all different combinations
    would lead to 8 (or even 16) different type expressions per base type. The following
    example MAXVAL is already relatively long: it has a special case for all 15 orderable
    types. If we also had to track qualifications, we would have to specialize 120
    cases!'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着类型表达式不能是指向这些之一：有资格类型的指针、数组的指针或函数的指针。但一般来说，这个规则使得编写类型通用的宏更容易，因为我们不需要考虑所有限定符的组合。有
    3 个限定符（指针类型有 4 个），所以否则每个基类型都会有 8（甚至 16）个不同的类型表达式。以下示例 MAXVAL 已经相对较长：它为所有 15 个可排序类型都有一个特殊案例。如果我们还必须跟踪资格，我们就必须专门化
    120 个案例！
- en: '`generic.h`'
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`generic.h`'
- en: '[PRE84]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This is an example where a **`_Generic`** expression is used differently than
    earlier, where we “just” chose a function pointer and then called the function.
    Here the resulting value is an integer constant expression. This never could be
    realized by function calls, and it would be very tedious to implement just with
    macros.^([[[Exs 9]](#ch16fn-ex09)]) Again, with a conversion trick, we can get
    rid of some cases we might not be interested in:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，其中 `_Generic` 表达式被用于与之前不同的方式，当时我们“只是”选择了一个函数指针然后调用该函数。这里的结果是一个整数常量表达式。这永远不能通过函数调用实现，而且仅用宏来实现会非常繁琐。^([[[Exs
    9]](#ch16fn-ex09)]) 再次，通过转换技巧，我们可以消除我们可能不感兴趣的某些情况：
- en: ^([Exs 9])
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 9])
- en: ''
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write an analogous macro for the minimum value.
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为最小值编写一个类似的宏。
- en: '**`generic.h`**'
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`generic.h`**'
- en: '[PRE85]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, the special form of the controlling expression adds an additional feature.
    The expression `0+`(identifier`)+0` is valid if identifier is a variable or if
    it is a type. If it is a variable, the type of the variable is used, and it is
    interpreted just like any other expression. Then integer promotion is applied
    to it, and the resulting type is deduced.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，控制表达式的特殊形式添加了一个额外的功能。表达式 `0+`(标识符)+0 在标识符是变量或它是类型时是有效的。如果是变量，则使用变量的类型，并且它被解释得就像任何其他表达式一样。然后对其应用整数提升，并推导出结果类型。
- en: If it is a type, (identifier`)+0` is read as a cast of `+0` to type identifier.
    Adding `0+` from the left then still ensures that integer promotion is performed
    if necessary, so the result is the same if XT is a type T or an expression X of
    type T.^([[[Exs 10]](#ch16fn-ex10)])^([[[Exs 11]](#ch16fn-ex11)])^([[[Exs 12]](#ch16fn-ex12)])
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个类型，`(标识符)+0` 被读取为将 `+0` 转换为类型标识符的转换。从左侧添加 `0+` 仍然确保如果需要，执行整数提升，因此如果 XT
    是类型 T 或类型 T 的表达式 X，结果相同。^([[[Exs 10]](#ch16fn-ex10)])^([[[Exs 11]](#ch16fn-ex11)])^([[[Exs
    12]](#ch16fn-ex12)])
- en: ^([Exs 10])
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 10])
- en: ''
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a macro PROMOTE`(`XT`,` A`)` that returns the value of A as type XT. For
    example, PROMOTE`(1`u`, 3)` would be `3`u.
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个宏 PROMOTE`(XT, A)`，它返回 A 的类型为 XT 的值。例如，PROMOTE`(1`u`, 3)` 将是 `3`u。
- en: ^([Exs 11])
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 11])
- en: ''
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a macro SIGNEDNESS`(`XT`)` that returns **`false`** or **`true`** according
    to the signedness of the type of XT. For example, SIGNEDNESS`(1`l`)` would be
    **`true`**.
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个宏SIGNEDNESS`(`XT`)`，根据XT类型的符号返回**`false`**或**`true`**。例如，SIGNEDNESS`(1`l`)`将是**`true`**。
- en: ^([Exs 12])
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 12])
- en: ''
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a macro mix`(`A`,` B`)` that computes the maximum value of A and B. If
    both have the same signedness, the result type should be the wider type of the
    two. If both have different signedness, the return type should be an unsigned
    type that fits all positive values of both types.
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个宏mix`(`A`,` B`)`，计算A和B的最大值。如果两者具有相同的符号，则结果类型应该是两个中较宽的类型。如果两者具有不同的符号，则返回类型应该是一个可以容纳两种类型所有正值的无符号类型。
- en: Another requirement for the type expressions in a **`_Generic`** expression
    is that the choice must be unambiguous at compile time.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**`_Generic`**表达式中的类型表达式还有一个要求，即选择必须在编译时明确无误。'
- en: '|  |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.17
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要16.17
- en: '*The type expressions in a* **`_Generic`** *expression must refer to mutually
    incompatible types.*'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '**`_Generic`**表达式中的类型表达式必须引用相互不兼容的类型。'
- en: '|  |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.18
  id: totrans-678
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要16.18
- en: '*The type expressions in a* **`_Generic`** *expression cannot be a pointer
    to a VLA.*'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**`_Generic`**表达式中的类型表达式不能是一个VLA的指针。'
- en: '|  |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'A different model than the *function-pointer-call* variant can be convenient,
    but it also has some pitfalls. Let us try to use **`_Generic`** to implement the
    two macros TRACE_FORMAT and TRACE_CONVERT, which are used in the following:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数指针调用变体不同的模型可能更方便，但它也有一些陷阱。让我们尝试使用**`_Generic`**来实现两个宏TRACE_FORMAT和TRACE_CONVERT，它们在以下内容中使用：
- en: '**`macro_trace.h`**'
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE86]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'TRACE_FORMAT is straightforward. We distinguish six different cases:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: TRACE_FORMAT很简单。我们区分了六个不同的情况：
- en: '**`macro_trace.h`**'
  id: totrans-685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE87]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The **`default`** case, when no arithmetic type is matched, supposes that the
    argument has a pointer type. In that case, to be a correct parameter for **fprintf**,
    the pointer must be converted to **`void`**`*`. Our goal is to implement such
    a conversion through TRACE_CONVERT.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '**`default`**情况，当没有匹配算术类型时，假设参数具有指针类型。在这种情况下，为了成为fprintf的正确参数，指针必须转换为**`void`**`*`。我们的目标是通过TRACE_CONVERT实现这种转换。'
- en: 'A first try could look like the following:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 首次尝试可能看起来像以下这样：
- en: '[PRE88]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This uses the same trick as for TRACE_PTR1 to convert the pointer to **`void`**`*`.
    Unfortunately, this implementation is wrong.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这与TRACE_PTR1的技巧相同，用于将指针转换为**`void`**`*`。不幸的是，这个实现是错误的。
- en: '|  |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 16.19
  id: totrans-692
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要16.19
- en: '*All choices* expression1 *...* expressionN *in a* **`_Generic`** *must be
    valid.*'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**`_Generic`**中的所有选择表达式1 *...* 表达式N *必须有效*。'
- en: '|  |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If, for example, X is an **`unsigned long long`**, say 1LL, the **`default`**
    case would read
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果X是一个**`unsigned long long`**，比如1LL，那么**`default`**情况下的代码将是
- en: '[PRE89]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: which would be assigning a non-zero integer to a pointer, which is erroneous.^([[4](#ch16fn04)])
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是将非零整数赋值给指针，这是错误的.^([[4](#ch16fn04)])
- en: ⁴
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember that conversion from non-zero integers to pointers must be made explicit
    through a cast.
  id: totrans-700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，从非零整数到指针的转换必须通过强制类型转换来明确。
- en: 'We tackle this in two steps. First we have a macro that returns either its
    argument, the **`default`**, or a literal zero:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分两步解决这个问题。首先，我们有一个宏，它返回其参数、**`default`**或一个字面量零：
- en: '**`macro_trace.h`**'
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE90]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This has the advantage that a call to TRACE_POINTER`(`X`)` can always be assigned
    to a **`void`**`*`. Either X itself is a pointer, and so is assignable to **`void*`**,
    or it is of another arithmetic type, and the result of the macro invocation is
    `0`. Put all together, TRACE_CONVERT looks as follows:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点，即对TRACE_POINTER`(`X`)`的调用始终可以赋值给**`void`**`*`。要么X本身是一个指针，可以赋值给**`void*`**，要么它是一种其他算术类型，宏调用的结果是`0`。综合起来，TRACE_CONVERT看起来如下：
- en: '**`macro_trace.h`**'
  id: totrans-705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`macro_trace.h`**'
- en: '[PRE91]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Summary
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Function-like macros are more flexible than inline functions.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式宏比内联函数更灵活。
- en: They can be used to complement function interfaces with compile-time argument
    checks and to provide information from the calling environment or default arguments.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用来自动检查编译时参数，以补充函数接口，并从调用环境或默认参数提供信息。
- en: They allow us to implement type-safe features with variable argument lists.
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许我们使用可变参数列表实现类型安全的功能。
- en: In combination with **`_Generic`**, they can be used to implement type-generic
    interfaces.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与**`_Generic`**结合使用，它们可以用来实现类型泛型接口。
- en: Chapter 17\. Variations in control flow
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17章\. 控制流的变化
- en: This chapter covers
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding normal sequencing of statements in C
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 C 中语句的正常顺序
- en: Making short and long jumps through code
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代码进行短跳和长跳
- en: Function control flow
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数控制流
- en: Handling signals
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理信号
- en: 'The *control flow* (see [figure 2.1](kindle_split_009.html#ch02fig01)) of program
    execution describes how the individual statements of the program code are *sequenced*:
    that is, which statement is executed after another. Up to now, we have mostly
    looked at code that let us deduce this control flow from syntax and a controlling
    expression. That way, each function can be described using a hierarchical composition
    of *basic blocks*. A basic block is a maximum sequence of statements such that
    once execution starts at the first of these statements, it continues unconditionally
    until the last, and such that all execution of any statement in the sequence starts
    with the first.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行的 **`control flow`**（见图 2.1 [kindle_split_009.html#ch02fig01]）描述了程序代码中各个语句的
    *顺序*：即，哪个语句在另一个语句之后执行。到目前为止，我们主要查看的是让我们可以从语法和控制表达式推导出这种控制流的代码。这样，每个函数都可以使用 *基本块*
    的分层组合来描述。基本块是一系列语句的最大序列，一旦执行从这些语句中的第一个开始，就会无条件地继续到最后的语句，并且所有语句的执行都从第一个开始。
- en: If we are supposing that all conditionals and loop statements use `{}` blocks,
    in a simplified view such a basic block
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设所有条件语句和循环语句都使用 `{}` 块，在简化的观点中，这样的基本块
- en: Starts either at the beginning of a `{}`-block or a **`case`** or jump label
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始于 `{}`-块的开始或一个**`case`**或跳转标签
- en: Ends either at the end of the corresponding `{}` block or at the next
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束于相应的 `{}` 块的末尾或下一个
- en: Statement that is the target of a **`case`** or jump label
  id: totrans-722
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 **`case`** 或跳转标签目标的语句
- en: Body of a conditional or loop statement
  id: totrans-723
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件或循环语句的主体
- en: '**`return`** statement'
  id: totrans-724
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`return`** 语句'
- en: '**`goto`** statement'
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`goto`** 语句'
- en: Call to a function with special control flow
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用具有特殊控制流的函数
- en: 'Observe that in this definition, no exception is made for general function
    calls: these are seen to temporarily suspend execution of a basic block but not
    to end it. Among the functions with special control flow that end a basic block
    are some we know: those marked with the keyword **`_Noreturn`**, such as **exit**
    and **abort**. Another such function is **setjmp**, which may return more than
    once, as discussed later.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个定义中，没有对一般函数调用做出例外：这些函数被视为暂时挂起基本块的执行，但不会结束它。在那些具有特殊控制流并结束基本块的函数中，有一些是我们所熟知的：那些带有关键字
    **`_Noreturn`** 的函数，例如 **exit** 和 **abort**。另一个这样的函数是 **setjmp**，它可能多次返回，如后文所述。
- en: Code that is just composed of basic blocks that are stitched together by **`if`**`/`**`else`**^([[1](#ch17fn01)])
    or loop statements has the double advantage of being easily readable for us humans,
    and leads to better optimization opportunities for the compiler. Both can directly
    deduce the lifetime and access pattern of variables and compound literals in basic
    blocks, and then capture how these are melded by the hierarchical composition
    of the basic blocks into their function.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 仅由通过 **`if`**`/`**`else`**^([[1](#ch17fn01)]) 或循环语句拼接的基本块组成的代码，具有双重优势：对我们人类来说易于阅读，并且为编译器提供了更好的优化机会。两者都可以直接推导出基本块中变量和复合字面量的生命周期和访问模式，然后捕捉这些是如何通过基本块的分层组合融入其函数中的。
- en: ¹
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`switch`**`/`**`case`** statements complicate the view a bit.'
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`switch`**`/`**`case`** 语句稍微复杂了一些。'
- en: A theoretical foundation of this structured approach was given quite early for
    Pascal programs by Nishizeki et al. [[1977](kindle_split_036.html#bib12)] and
    extended to C and other imperative languages by Thorup [[1995](kindle_split_036.html#bib17)].
    They prove that structured programs (that is, programs without **`goto`** or other
    arbitrary jump constructs) have a control flow that matches nicely into a tree-like
    structure that can be deduced from the syntactical nesting of the program. Unless
    you have to do otherwise, you should stick to that programming model.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构化方法的理论基础很早就由 Nishizeki 等人给出了，用于 Pascal 程序 [[1977](kindle_split_036.html#bib12)]，并由
    Thorup [[1995](kindle_split_036.html#bib17)] 扩展到 C 和其他命令式语言。他们证明结构化程序（即，没有 **`goto`**
    或其他任意跳转结构的程序）具有与程序语法的嵌套层次结构相匹配的控制流，可以从程序语法嵌套中推导出来。除非你不得不这样做，否则你应该坚持这种编程模型。
- en: '![](193fig01.jpg)'
  id: totrans-733
  prefs: []
  type: TYPE_IMG
  zh: '![](193fig01.jpg)'
- en: Nevertheless, some exceptional situations require exceptional measures. Generally,
    changes to the control flow of a program can originate from
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些特殊情况需要特殊措施。通常，程序控制流的更改可以来自
- en: '*Conditional statements:* **`if`**`/`**`else`**, **`switch`**`/`**`case`**'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*条件语句:* **`if`**`/`**`else`**, **`switch`**`/`**`case`**'
- en: '*Loop statements:* **`do`**`{}`**`while`**`()`, **`while`**`()`, **`for`**`()`'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*循环语句:* **`do`**`{}`**`while`**`()`, **`while`**`()`, **`for`**`()`'
- en: '*Functions:* Function calls, **`return`** statements, or **`_Noreturn`** specifications'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数:* 函数调用，**`return`** 语句，或 **`_Noreturn`** 规范'
- en: '*Short jumps:* **`goto`** and labels'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*短跳转:* **`goto`** 和标签'
- en: '*Long jumps:* **setjmp**`/`**longjmp**, getcontex`t`/setcontext^([[2](#ch17fn02)])'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*长跳转:* **setjmp**`/`**longjmp**, getcontex`t`/setcontext^([[2](#ch17fn02)])'
- en: ²
  id: totrans-740
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-741
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Defined in POSIX systems.
  id: totrans-742
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义在 POSIX 系统。
- en: '*Interrupts:* signals and **signal** handlers'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中断:* 信号和**信号处理器**'
- en: '*Threads:* **thrd_create**, **thrd_exit**'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线程:* **thrd_create**, **thrd_exit**'
- en: These changes in control flow can mix up the knowledge the compiler has about
    the abstract state of the execution. Roughly, the complexity of the knowledge
    that a human or mechanical reader has to track increases from top to bottom in
    that list. Up to now, we have only seen the first four constructs. These correspond
    to *language* features, which are determined by syntax (such as keywords) or by
    operators (such as the `()` of a function call). The latter three are introduced
    by *C library* interfaces. They provide changes in the control flow of a program
    that can jump across function boundaries (**longjmp**), can be triggered by events
    that are external to the program (interrupts), or can even establish a concurrent
    control flow, another *thread of execution*.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制流的变化可能会混淆编译器对执行抽象状态的了解。大致来说，一个人类或机械读者需要跟踪的知识复杂性从上到下增加。到目前为止，我们只看到了前四个结构。这些对应于
    *语言* 功能，这些功能由语法（如关键字）或运算符（如函数调用的 `()`）确定。后三个是由 *C 库* 接口引入的。它们提供了可以跨越函数边界的程序控制流的变化（**longjmp**），可以由程序外的事件（中断）触发，甚至可以建立并发控制流，另一个
    *执行线程*。
- en: 'Various difficulties may arise when objects are under the effect of unexpected
    control flow:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象受到意外控制流的影响时，可能会出现各种困难：
- en: Objects could be used outside their lifetime.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可能在其生命周期外被使用。
- en: Objects could be used uninitialized.
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可能在使用前未被初始化。
- en: Values of objects could be misinterpreted by optimizing (**`volatile`**).
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的值可能被优化（**`volatile`**）错误解释。
- en: Objects could be partially modified (**`sig_atomic_t`**, **`atomic_flag`**,
    or **`_Atomic`** with the lock-free property and relaxed consistency).
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可能被部分修改（**`sig_atomic_t`**, **`atomic_flag`**, 或 **`_Atomic`** 具有无锁属性和松散一致性）。
- en: Updates to objects could be sequenced unexpectedly (all **`_Atomic`**).
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的更新可能意外地排序（所有 **`_Atomic`**）。
- en: Execution must be guaranteed to be exclusive inside a *critical section* (**`mtx_t`**).
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *关键部分*（**`mtx_t`**）内必须保证执行是独占的。
- en: Because access to the objects that constitute the state of a program becomes
    complicated, C provides features that help to cope with the difficulties. In this
    list, they are noted in parentheses, and we will discuss them in detail in the
    following sections.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访问构成程序状态的那些对象的访问变得复杂，C 语言提供了帮助处理这些困难的功能。在这个列表中，它们在括号中注明，我们将在以下章节中详细讨论。
- en: 17.1\. A complicated example
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1. 一个复杂的例子
- en: 'To illustrate most of these concepts, we will discuss some central example
    code: a *recursive descent parser* called basic_blocks. The central function descend
    is presented in the following listing.'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些概念中的大多数，我们将讨论一些核心示例代码：一个名为 *basic_blocks* 的 *递归下降解析器*。以下列表展示了核心函数 descend。
- en: Listing 17.1\. A recursive descent parser for code indentation
  id: totrans-756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.1. 代码缩进的递归下降解析器
- en: '[PRE92]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This code serves several purposes. First, it obviously presents several features
    that we discuss later: recursion, short jumps (**`goto`**), long jumps (**longjmp**),
    and interrupt handling.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有几个用途。首先，它显然展示了我们稍后讨论的几个特性：递归，短跳转（**`goto`**），长跳转（**longjmp**），以及中断处理。
- en: But at least as important, it is probably the most difficult code we have handled
    so far in this book, and for some of you it might even be the most complicated
    code you have ever seen. Yet, with its 36 lines, it still fit on one screen, and
    it is by itself an affirmation that C code can be very compact and efficient.
    It might take you hours to understand, but please do not despair; you might not
    know it yet, but if you have worked thoroughly through this book, you are ready
    for this.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 但至少同样重要的是，这可能是我们在这本书中处理过的最困难的代码，对于一些人来说，这甚至可能是你见过的最复杂的代码。然而，尽管它有36行，它仍然可以放在一屏上，这本身就是C代码可以非常紧凑和高效的证明。理解它可能需要几个小时，但请不要绝望；你可能还没有意识到，但如果你已经彻底阅读了这本书，你已经为这个做好了准备。
- en: The function implements a *recursive descent parser* that recognizes `{}` constructs
    in text given on **`stdin`** and indents this text on output, according to the
    nesting of the `{}`. More formally, written in *Backus-Nauer-form* (BNF)^([[3](#ch17fn03)])
    this function detects text as of the following recursive definition
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数实现了一个 *递归下降解析器*，它识别在 **`stdin`** 上给出的文本中的 `{}` 构造，并根据 `{}` 的嵌套在输出中缩进文本。更正式地说，用
    *Backus-Nauer形式*（BNF）编写，此函数检测文本如下递归定义
- en: ³
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a formalized description of computer-readable languages. Here, *program*
    is recursively defined to be a sequence of text, optionally followed by another
    sequence of programs that are inside curly braces.
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是计算机可读语言的规范化描述。在这里，*程序*递归定义为文本序列，可选地后跟另一个序列的程序，这些程序位于大括号内。
- en: '**program** := some-text*[⋆]* [**`''{''`***program***`''}''`**some-text*[⋆]*]*[⋆]*'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序** := some-text*[⋆]* [**`''{''`***程序***`''}''`**some-text*[⋆]*]*[⋆]*'
- en: and prints such a program conveniently by changing the line structure and indentation.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 并且通过改变行结构和缩进来方便地打印出这样的程序。
- en: 'The operational description of the program is to handle text, in particular
    to indent C code or similar in a special way. If we feed the program *text* from
    [listing 3.1](kindle_split_011.html#ch03ex02) into this, we see the following
    output:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的操作描述是处理文本，特别是以特殊方式缩进C代码或类似代码。如果我们从 [列表3.1](kindle_split_011.html#ch03ex02)
    中将 *文本* 输入到这个程序中，我们会看到以下输出：
- en: '`Terminal`'
  id: totrans-767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE93]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'So **`basic_blocks`** “eats” curly braces `{}` and instead indents the code
    with a series of `>` characters: each level of nesting `{}` adds a `>`.'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 **`basic_blocks`** “吞噬”大括号 `{}` 并使用一系列 `>` 字符缩进代码：每个嵌套级别的大括号 `{}` 添加一个 `>`。
- en: 'For a high-level view of how this function achieves this, and abstracting away
    all the functions and variables you do not know yet, have a look at the **`switch`**
    statement that starts on line 79 and the **`for`** loop that surrounds it. It
    switches according to the current character. Three different cases are distinguished.
    The simplest is the **`default`** case: a normal character is printed, the character
    is advanced, and the next iteration starts.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从高层次了解这个函数是如何实现这一点的，并且抽象掉你还不了解的所有函数和变量，请查看从第79行开始的 **`switch`** 语句以及围绕它的 **`for`**
    循环。它根据当前字符进行切换。区分了三种不同的情况。最简单的是 **`default`** 情况：打印一个普通字符，字符前进，并开始下一次迭代。
- en: The two other cases handle `{` and `}` characters. If we encounter an opening
    brace, we know that we have to indent the text with one more `>`. Therefore, we
    recurse into the same function **`descend`** again; see line 82\. If, on the other
    hand, a closing brace is encountered, we go to **`ASCEND`** and terminate this
    recursion level. The recursion depth itself is handled with the variable dp`[0]`,
    which is incremented on entry (line 66) and decremented on exit (line 94).
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两种情况处理 `{` 和 `}` 字符。如果我们遇到一个开括号，我们知道我们必须使用一个额外的 `>` 来缩进文本。因此，我们再次递归调用相同的函数
    **`descend`**；见第82行。另一方面，如果遇到一个闭括号，我们转到 **`ASCEND`** 并终止这个递归级别。递归深度本身由变量 dp`[0]`
    处理，它在进入时（第66行）增加，在退出时（第94行）减少。
- en: If you are trying to understand this program for the first time, the rest is
    noise. This noise helps to handle exceptional cases, such as an end of line or
    a surplus of left or right braces. We will see how all this works in much more
    detail later.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次尝试理解这个程序，其余的都是噪音。这些噪音有助于处理异常情况，例如行尾或左右括号的过剩。我们将在稍后更详细地看到这一切是如何工作的。
- en: 17.2\. Sequencing
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2. 排序
- en: Before we can look at the details of how the control flow of a program can change
    in unexpected ways, we must better understand what the normal sequence of C statements
    guarantees and what it does not. We saw in [section 4.5](kindle_split_012.html#ch04lev1sec5)
    that the evaluation of C *expressions* does not necessarily follow the lexicographical
    order as they are written. For example, the evaluation of function arguments can
    occur in any order. The different expressions that constitute the arguments can
    even be interleaved to the discretion of the compiler, or depending on the availability
    of resources at execution time. We say that function argument expressions are
    *unsequenced*.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够查看程序控制流如何以意想不到的方式改变细节之前，我们必须更好地理解C语句的正常顺序保证了什么，以及它没有保证什么。我们在[第4.5节](kindle_split_012.html#ch04lev1sec5)中看到，C
    *表达式*的评估不一定遵循它们书写的字典顺序。例如，函数参数的评估可以按任何顺序发生。构成参数的不同表达式甚至可以根据编译器的自由裁量权或根据执行时的资源可用性交错。我们说函数参数表达式是*非序列化的*。
- en: There are several reasons for establishing only relaxed rules for evaluation.
    One is to allow for the easy implementation of optimizing compilers. Efficiency
    of the compiled code has always been a strong point of C compared to other programming
    languages.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 建立仅适用于评估的宽松规则有几个原因。其中之一是允许轻松实现优化编译器。与其它编程语言相比，编译代码的效率一直是C语言的一个强项。
- en: But another reason is that C does not add arbitrary restrictions when they don’t
    have a convincing mathematical or technical foundation. Mathematically, the two
    operands a and b in a`+`b are freely exchangeable. Imposing an evaluation order
    would break this rule, and arguing about a C program would become more complicated.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一个原因是，C语言在缺乏令人信服的数学或技术基础时不会添加任意限制。在数学上，`+`运算符中的两个操作数a和b是可以自由交换的。强加一个评估顺序将破坏这一规则，并且关于C程序的讨论将变得更加复杂。
- en: In the absence of threads, most of C’s formalization of this is done with *sequence
    points*. These are points in the syntactical specification of the program that
    impose a serialization of the execution. But we will also later see additional
    rules that force sequencing between the evaluation of certain expressions that
    don’t imply sequence points.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有线程的情况下，C语言对这一点的形式化大部分是通过*序列点*来完成的。这些是程序语法规范中的点，它们强加了执行的序列化。但我们也将在后面看到一些额外的规则，这些规则强制某些表达式评估之间的顺序，而这些表达式并不暗示序列点。
- en: On a high level, a C program can be seen as a series of sequence points that
    are reached one after the other, and the code between such sequence points may
    be executed in any order, be interleaved, or obey certain other sequencing constraints.
    In the simplest case, for example, when two statements are separated by a `;`,
    a statement before a sequence point is *sequenced* before the statement after
    the sequence point.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，一个C程序可以看作是一系列一个接一个达到的序列点，而这样的序列点之间的代码可以按任何顺序执行，可以交错，或者遵守某些其他顺序约束。例如，在最简单的情况下，当两个语句由一个`;`分隔时，序列点之前的语句是*序列化的*，在序列点之后的语句之前。
- en: 'But even the existence of sequence points may not impose a particular order
    between two expressions: it only imposes that there is *some* order. To see that,
    consider the following code, which is *well defined*:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使序列点的存在也可能不会在两个表达式之间强加特定的顺序：它只强加存在某种顺序。为了说明这一点，考虑以下代码，它是*定义良好的*：
- en: '`sequence_point.c`'
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`sequence_point.c`'
- en: '[PRE94]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: From [section 4.5](kindle_split_012.html#ch04lev1sec5), remember that the two
    arguments to **printf** can be evaluated in any order, and the rules for sequence
    points that we will see shortly will tell us that the function calls to add impose
    sequence points. As a result, we have two possible outcomes for this code. Either
    the first add is executed first, entirely, and then the second, or the other way
    around. For the first possibility, we have
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第4.5节](kindle_split_012.html#ch04lev1sec5)中记住，**printf**的两个参数可以按任何顺序评估，我们很快就会看到的序列点规则将告诉我们，对添加函数的调用强加序列点。因此，对于这段代码，我们有两种可能的输出。要么第一个加法操作完全执行，然后是第二个，要么反过来。对于第一种可能性，我们有
- en: a is changed to `8`, and that value is returned.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a被改为`8`，并返回该值。
- en: b is changed to `13`, and that value is returned.
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: b被改为`13`，并返回该值。
- en: The output of such an execution is
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的执行输出是
- en: '`Terminal`'
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Terminal`'
- en: '[PRE95]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: For the second, we get
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种，我们得到
- en: b is changed to `8`, and that value is returned.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: b被改为`8`，并返回该值。
- en: a is changed to `11`, and that value is returned.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a被改为`11`，并返回该值。
- en: And the output is
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下
- en: '`Terminal`'
  id: totrans-792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE96]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'That is, although the behavior of this program is defined, its outcome is not
    completely determined by the C standard. The specific terminology that the C standard
    applies to such a situation is that the two calls are *indeterminately sequenced*.
    This is not just a theoretical discussion; the two commonly used open source C
    compilers `GCC` and `Clang` differ on this simple code. Let me stress this again:
    all of this is defined behavior. Don’t expect a compiler to warn you about such
    problems.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 即，尽管此程序的行为是定义的，但其结果并不完全由C标准确定。C标准应用于此类情况的具体术语是这两个调用是*有序不确定的*。这不仅仅是一个理论讨论；两个常用的开源C编译器`GCC`和`Clang`在这个简单的代码上有所不同。让我再次强调：所有这些都是定义良好的行为。不要期望编译器会警告你这样的问题。
- en: '|  |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.1
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.1
- en: '*Side effects in functions can lead to indeterminate results.*'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数中的副作用可能导致不确定的结果*。'
- en: '|  |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Here is a list of all sequence points that are defined in terms of C’s grammar:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个所有用C语法定义的序列点的列表：
- en: The end of a statement, with either a semicolon (`;`) or a closing brace (`}`)
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句的结束，无论是分号（`;`）还是闭合花括号（`}`）
- en: The end of an expression before the comma operator (`,`)^([[4](#ch17fn04)])
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在逗号运算符（`,`）之前的表达式结束^([[4](#ch17fn04)])
- en: ⁴
  id: totrans-802
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-803
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Be careful: commas that separate function arguments are not in this category.'
  id: totrans-804
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小心：分隔函数参数的逗号不属于此类。
- en: The end of a declaration, with either a semicolon (`;`) or a comma (`,`)^([[5](#ch17fn05)])
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的结束，无论是分号（`;`）还是逗号（`,`）^([[5](#ch17fn05)])
- en: ⁵
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This also holds for a comma that ends the declaration of an enumeration constant.
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这也适用于结束枚举常量声明的逗号。
- en: The end of the controlling expressions of **`if`**, **`switch`**, **`for`**,
    **`while`**, conditional evaluation (`?:`), and short-circuit evaluation (`||`
    and `&&`)
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`if`**、**`switch`**、**`for`**、**`while`**、条件评估（`?:`）和短路评估（`||`和`&&`）的控制表达式的结束'
- en: After the evaluations of the function designator (usually a function name) and
    the function arguments of a function call^([[6](#ch17fn06)]) but before the actual
    call
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在评估函数标识符（通常是函数名）和函数调用的函数参数之后^([[6](#ch17fn06)])但在实际调用之前
- en: ⁶
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This sees the function designator on the same level as the function arguments.
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将函数标识符与函数参数放在同一级别。
- en: The end of a **`return`** statement
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`return`**语句的结束'
- en: 'There are other sequencing restrictions besides those implied by sequence points.
    The first two are more or less obvious but should be stated nevertheless:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 除了序列点隐含的顺序限制之外，还有其他顺序限制。前两个或多或少是明显的，但仍然应该声明：
- en: '|  |'
  id: totrans-816
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.2
  id: totrans-817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.2
- en: '*The specific operation of any operator is sequenced after the evaluation of
    all its operands.*'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何操作符的具体操作是在其所有操作数评估之后有序的*。'
- en: '|  |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-820
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.3
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.3
- en: '*The effect of updating an object with any of the assignment, increment, or
    decrement operators is sequenced after the evaluation of its operands.*'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用任何赋值、增量或减量运算符更新对象的效果是在其操作数评估之后有序的*。'
- en: '|  |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For function calls, there also is an additional rule that says the execution
    of a function is always completed before any other expression.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数调用，还有一个额外的规则，即函数的执行总是在任何其他表达式之前完成。
- en: '|  |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.4
  id: totrans-826
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.4
- en: '*A function call is sequenced with respect to all evaluations of the caller.*'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数调用相对于调用者的所有评估是有序的*。'
- en: '|  |'
  id: totrans-828
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As we have seen, this might be indeterminately sequenced, but sequenced nevertheless.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这可能是有序不确定的，但仍然是有序的。
- en: Another source of indeterminately sequenced expressions originates from initializers.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个导致有序不确定表达式的原因来自初始化器。
- en: '|  |'
  id: totrans-831
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.5
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.5
- en: '*Initialization-list expressions for array or structure types are indeterminately
    sequenced.*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组或结构类型初始化列表表达式是有序不确定的*。'
- en: '|  |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Last but not least, some sequence points are also defined for the C library:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，一些序列点也适用于C库：
- en: After the actions of format specifiers of the IO functions
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IO函数的格式说明符动作之后
- en: Before any C library function returns^([[7](#ch17fn07)])
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何C库函数返回之前^([[7](#ch17fn07)])
- en: ⁷
  id: totrans-838
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-839
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be aware that library functions that are implemented as macros may not define
    a sequence point.
  id: totrans-840
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，作为宏实现的库函数可能不会定义一个序列点。
- en: Before and after calls to the comparison functions used for searching and sorting
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用用于搜索和排序的比较函数之前和之后
- en: The latter two impose rules for C library functions that are similar to those
    for ordinary functions. This is needed because the C library itself might not
    necessarily be implemented in C.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 后两个代码片段为C库函数施加了类似于普通函数的规则。这是必要的，因为C库本身可能不一定是用C实现的。
- en: 17.3\. Short jumps
  id: totrans-843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3. 短跳转
- en: 'We have seen a feature that interrupts the common control flow of a C program:
    **`goto`**. As you hopefully remember from [section 14.5](kindle_split_024.html#ch14lev1sec5),
    this is implemented with two constructs: *labels* mark positions in the code,
    and **`goto`** statements *jump* to these marked positions *inside the same function*.'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个会中断C程序常见控制流特性的功能：**`goto`**。正如你希望从[第14.5节](kindle_split_024.html#ch14lev1sec5)中记得的那样，这是通过两个构造实现的：*labels*标记代码中的位置，**`goto`**语句*跳转到*这些标记的位置*在同一函数内*。
- en: 'We also have seen that such jumps have complicated implications for the lifetime
    and visibility of local objects. In particular, there is a difference in the lifetime
    of objects that are defined inside loops and inside a set of statements that is
    repeated by **`goto`**.^([[8](#ch17fn08)]) Consider the following two snippets:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，这样的跳转对局部对象的生存期和可见性有复杂的含义。特别是，在循环内部和由**`goto`**重复的一组语句内部定义的对象的生存期存在差异。考虑以下两个代码片段：
- en: ⁸
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-847
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: see ISO 9899:2011 6.5.2.5 p16
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: see ISO 9899:2011 6.5.2.5 p16
- en: '[PRE97]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: versus
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 与
- en: '[PRE98]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Both define a local object in a loop by using a compound literal. The address
    of that compound literal is assigned to a pointer, so the object remains accessible
    outside the loop and can, for example, be used in a **printf** statement.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都是通过使用复合字面量在循环中定义局部对象。复合字面量的地址被分配给指针，因此对象可以在循环外部保持可访问，例如，可以在**printf**语句中使用。
- en: It looks as if they both are semantically equivalent, but they are not. For
    the first, the object that corresponds to the compound literal only lives in the
    scope of the **`while`** statement.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来在语义上是等价的，但实际上并非如此。对于第一种情况，与复合字面量对应的对象仅存在于**`while`**语句的作用域内。
- en: '|  |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 17.6
  id: totrans-855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要點17.6
- en: '*Each iteration defines a new instance of a local object.*'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '*每次迭代都会定义局部对象的一个新实例*。'
- en: '|  |'
  id: totrans-857
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Therefore, the access to the object in the `*`ip expression is invalid. When
    omitting the **printf** in the example, the **`while`** loop has the advantage
    that the resources that are occupied by the compound literal can be reused.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对**`*ip`**表达式中的对象的访问是无效的。在示例中省略**printf**时，**`while`**循环的优势在于可以重用复合字面量占用的资源。
- en: 'For the second example, there is no such restriction: the scope of the definition
    of the compound literal is the whole surrounding block. So the object is alive
    until that block is left ([takeaway 13.22](kindle_split_023.html#ch13note24)).
    This is not necessarily good: the object occupies resources that could otherwise
    be reassigned.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个示例，没有这样的限制：复合字面量定义的作用域是整个周围的块。因此，对象在离开该块之前是活跃的（[要点13.22](kindle_split_023.html#ch13note24)）。这并不一定是好事：对象占用了本可以重新分配的资源。
- en: In cases where there is no need for the **printf** statement (or similar access),
    the first snippet is clearer and has better optimization opportunities. Therefore,
    under most circumstances, it is preferable.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要**printf**语句（或类似访问）的情况下，第一个代码片段更清晰，并且有更好的优化机会。因此，在大多数情况下，它更可取。
- en: '|  |'
  id: totrans-861
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 17.7
  id: totrans-862
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点17.7
- en: '**`goto`** *should only be used for exceptional changes in control flow.*'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '**`goto`***应仅用于控制流的异常变化*。'
- en: '|  |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Here, *exceptional* usually means we encounter a transitional error condition
    that requires local cleanup, such as we showed in [section 14.5](kindle_split_024.html#ch14lev1sec5).
    But it could also mean specific algorithmic conditions, as we can see in [listing
    17.1](#ch17ex01).
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*exceptional*通常意味着我们遇到了需要局部清理的过渡性错误条件，例如我们在[第14.5节](kindle_split_024.html#ch14lev1sec5)中展示的那样。但它也可能意味着特定的算法条件，正如我们在[列表17.1](#ch17ex01)中看到的那样。
- en: Here, two labels, **`NEW_LINE`** and **`ASCEND`**, and two macros, **`LEFT`**
    and **`RIGHT`**, reflect the actual state of the parsing. **`NEW_LINE`** is a
    jump target when a new line is to be printed, and **`ASCEND`** is used if a `}`
    is encountered or if the stream ended. **`LEFT`** and **`RIGHT`** are used as
    **`case`** labels if left or right curly braces are detected.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个标签**`NEW_LINE`**和**`ASCEND`**，以及两个宏**`LEFT`**和**`RIGHT`**反映了解析的实际状态。**`NEW_LINE`**是打印新行时的跳转目标，而**`ASCEND`**在遇到`}`或流结束时使用。**`LEFT`**和**`RIGHT`**在检测到左或右花括号时用作**`case`**标签。
- en: The reason to have **`goto`** and labels here is that both states are detected
    in two different places in the function, and at different levels of nesting. In
    addition, the names of the labels reflect their purpose and thereby provide additional
    information about the structure.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用**`goto`**和标签的原因是，两种状态在函数中的两个不同位置被检测到，并且在不同级别的嵌套中。此外，标签的名称反映了它们的目的，从而提供了有关结构的信息。
- en: 17.4\. Functions
  id: totrans-868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4\. 函数
- en: 'The function **`descend`** has more complications than the twisted local jump
    structure: it also is recursive. As we have seen, C handles recursive functions
    quite simply.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 函数**`descend`**比扭曲的局部跳转结构更复杂：它也是递归的。正如我们所见，C处理递归函数相当简单。
- en: '|  |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 17.8
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.8小结
- en: '*Each function call defines a new instance of a local object.*'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个函数调用定义了一个局部对象的实例。*'
- en: '|  |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: So usually, different recursive calls to the same function that are active simultaneously
    don’t interact; everybody has their own copy of the program state.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 所以通常情况下，同时活跃的同函数的不同递归调用不会相互影响；每个人都拥有自己的程序状态副本。
- en: 'Figure 17.1\. Control flow of function calls: `return` jumps to the next instruction
    after the call.'
  id: totrans-875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图17.1\. 函数调用的控制流：`return`跳转到调用后的下一个指令。
- en: '![](17fig01_alt.jpg)'
  id: totrans-876
  prefs: []
  type: TYPE_IMG
  zh: '![](17fig01_alt.jpg)'
- en: 'But here, because of the pointers, this principle is weakened. The data to
    which buffer and dp point is modified. For buffer, this is probably unavoidable:
    it will contain the data that we are reading. But dp could (and should) be replaced
    by a simple **`unsigned`** argument.^([[[Exs 1]](#ch17fn-ex01)]) Our implementation
    only has dp as a pointer because we want to be able to track the depth of the
    nesting in case an error occurs. So if we abstract out the calls to **longjmp**
    that we did not yet explain, using such a pointer is bad. The state of the program
    is more difficult to follow, and we miss optimization opportunities.^([[[Exs 2]](#ch17fn-ex02)])'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，由于指针的存在，这个原则被削弱了。buffer和dp指向的数据被修改了。对于buffer来说，这可能是不可避免的：它将包含我们正在读取的数据。但dp可以（并且应该）被一个简单的**`unsigned`**参数替换.^([[[Exs
    1]](#ch17fn-ex01)])我们的实现只有dp作为指针，因为我们想能够在发生错误时跟踪嵌套的深度。所以如果我们抽象出我们尚未解释的**longjmp**调用，使用这样的指针是糟糕的。程序的状态更难以跟踪，我们错过了优化机会.^([[[Exs
    2]](#ch17fn-ex02)])
- en: ^([Exs 1])
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Change **`descend`** such that it receives an **`unsigned`** depth instead of
    a pointer.
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将**`descend`**修改为接收一个**`unsigned`**深度而不是指针。
- en: ^([Exs 2])
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compare the assembler output of the initial version against your version without
    dp pointer.
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将初始版本的汇编输出与你的没有dp指针的版本进行比较。
- en: In our particular example, because dp is **`restrict`** qualified and not passed
    to the calls to longjump (discussed shortly) and it is only incremented at the
    beginning and decremented at the end, dp`[0]` is restored to its original value
    just before the return from the function. So, seen from the outside, it appears
    that **`descend`** doesn’t change that value at all.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定例子中，因为dp是**`restrict`**修饰的，并且没有传递给longjump的调用（稍后讨论），它只在开始时增加，在结束时减少，所以dp`[0]`在函数返回之前恢复到其原始值。因此，从外部看，似乎**`descend`**根本没有改变这个值。
- en: If the function code of **`descend`** is visible on the call side, a good optimizing
    compiler can deduce that dp`[0]` did not change through the call. If **longjmp**
    weren’t special, this would be a nice optimization opportunity. Shortly we will
    see how the presence of **longjmp** invalidates this optimization and leads to
    a subtle bug.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**`descend`**的函数代码在调用侧可见，一个好的优化编译器可以推断出dp`[0]`在调用过程中没有改变。如果**longjmp**不是特殊的，这将是一个很好的优化机会。我们很快就会看到**longjmp**的存在如何使这种优化无效，并导致一个微妙的错误。
- en: 17.5\. Long jumps
  id: totrans-886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5\. 长跳转
- en: 'Figure 17.2\. Control flow with **setjmp** and **longjmp**: **longjmp** jumps
    to the position marked by **setjmp**.'
  id: totrans-887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图17.2\. 使用**setjmp**和**longjmp**的控制流：**longjmp**跳转到由**setjmp**标记的位置。
- en: '![](17fig02_alt.jpg)'
  id: totrans-888
  prefs: []
  type: TYPE_IMG
  zh: '![](17fig02_alt.jpg)'
- en: 'Our function **`descend`** may also encounter exceptional conditions that cannot
    be repaired. We use an enumeration type to name them. Here, **`eofOut`** is reached
    if **`stdout`** can’t be written, and **`interrupted`** refers to an *asynchronous
    signal* that our running program received. We will discuss this concept later:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数**`descend`**也可能遇到无法修复的异常情况。我们使用枚举类型来命名它们。在这里，如果**`stdout`**无法写入，则达到**`eofOut`**；**`interrupted`**指的是程序运行时接收到的**异步信号**。我们将在后面讨论这个概念：
- en: '`basic_blocks.c`'
  id: totrans-890
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`basic_blocks.c`'
- en: '[PRE99]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We use the function **longjmp** to deal with these situations, and we put the
    corresponding calls directly at the place in the code where we recognize that
    such a condition is reached:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用函数 **longjmp** 来处理这些情况，并将相应的调用直接放在代码中我们认识到达到这种条件的地方：
- en: '**`tooDeep`** is easily recognized at the beginning of the function.'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`tooDeep`** 在函数的开始很容易被识别。'
- en: '**`plusL`** can be detected when we encounter the end of the input stream while
    we are not at the first recursion level.'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`plusL`** 在我们遇到输入流末尾而我们不在第一次递归级别时可以被检测到。'
- en: '**`plusR`** occurs when we encounter a closing `}` while we are at the first
    recursion level.'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在第一次递归级别遇到关闭的 `}` 时，会发生 **`plusR`**。
- en: '**`eofOut`** is reached if a write to **`stdout`** returned an end of file
    (**`EOF`**) condition.'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对 **`stdout`** 的写入返回了文件结束（**`EOF`**）条件，则会到达 **`eofOut`**。
- en: and **`interrupted`** is checked before each new line that is read from **`stdin`**.
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从 **`stdin`** 读取每一行新内容之前都会检查 **`interrupted`**。
- en: 'Since **`stdout`** is line-buffered, we only check for **`eofOut`** when we
    write the ''\n'' character. This happens inside the short function **`end_line`**:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **`stdout`** 是按行缓冲的，所以我们只在写入 '\n' 字符时检查 **`eofOut`**。这发生在短函数 **`end_line`**
    内部：
- en: '`basic_blocks.c`'
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`basic_blocks.c`'
- en: '[PRE100]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The function **longjmp** comes with a companion macro **setjmp** that is used
    to establish a jump target to which a call of **longjmp** may refer. The header
    `setjmp.h` provides the following prototypes:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 **longjmp** 伴随一个宏 **setjmp**，它用于建立 **longjmp** 调用可能引用的跳转目标。头文件 `setjmp.h`
    提供以下原型：
- en: '|  |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<setjmp.h>`'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '`<setjmp.h>`'
- en: '|  |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE101]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The function **longjmp** also has the **`_Noreturn`** property, so we are assured
    that once we detect one of the exceptional conditions, execution of the current
    call to **`descend`** will never continue.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 **longjmp** 也有 **`_Noreturn`** 属性，因此我们可以确信，一旦我们检测到其中一个异常条件，当前对 **`descend`**
    的调用将永远不会继续。
- en: '|  |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.9
  id: totrans-908
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 17.9
- en: '**longjmp** *never returns to the caller.*'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '**longjmp** *永远不会返回到调用者*。'
- en: '|  |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is valuable information for the optimizer. In **`descend`**, **longjmp**
    is called in five different places, and the compiler can substantially simplify
    the analysis of the branches. For example, after the `!`act tests, it can be assumed
    that act is non-null on entry to the **`for`** loop.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 这对优化器来说是非常有价值的信息。在 **`descend`** 中，**longjmp** 在五个不同的地方被调用，编译器可以大大简化分支的分析。例如，在
    `!`act 测试之后，可以假设在进入 **`for`** 循环时 act 是非空的。
- en: Normal syntactical labels are only valid **`goto`** targets within the same
    function as they are declared. In contrast to that, a **`jmp_buf`** is an opaque
    object that can be declared anywhere and that can be used as long as it is alive
    and its contents are valid. In **`descend`**, we use just one *jump target* of
    type **`jmp_buf`**, which we declare as a local variable. This jump target is
    set up in the base function **`basic_blocks`** that serves as an interface to
    **`descend`**; see [listing 17.2](#ch17ex08). This function mainly consists of
    one big **`switch`** statement that handles all the different conditions.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的语法标签仅在它们声明的函数内作为 **`goto`** 目标有效。相比之下，一个 **`jmp_buf`** 是一个不透明的对象，可以在任何地方声明，只要它存在且其内容有效，就可以使用。在
    **`descend`** 中，我们只使用一个类型的 *跳转目标* **`jmp_buf`**，我们将其声明为一个局部变量。这个跳转目标是在作为 **`descend`**
    接口的基函数 **`basic_blocks`** 中设置的；参见 [列表 17.2](#ch17ex08)。这个函数主要由一个处理所有不同条件的巨大 **`switch`**
    语句组成。
- en: Listing 17.2\. The user interface for the recursive descent parser
  id: totrans-913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.2\. 递归下降解析器的用户界面
- en: '[PRE102]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `0` branch of that **`switch`** is taken when we come here through the normal
    control flow. This is one of the basic principles for **setjmp**.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过正常控制流程来到这里时，会采取那个 **`switch`** 的 **`0`** 分支。这是 **setjmp** 的一个基本原理。
- en: '|  |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.10
  id: totrans-917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 17.10
- en: '*When reached through normal control flow, a call to* **setjmp** *marks the
    call location as a jump target and returns* *`0`**.*'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '*当通过正常控制流程到达时，对 * **setjmp** * 的调用会将调用位置标记为跳转目标并返回 * **`0`** *。'
- en: '|  |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As we said, jmpTarget must be alive and valid when we call **longjmp**. So for
    an **`auto`** variable, the scope of the declaration of the variable must not
    have been left; otherwise it would be dead. For validity, all of the context of
    the **setjmp** must still be active when we call **longjmp**. Here, we avoid complications
    by having jmpTarget declared in the same scope as the call to **setjmp**.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，当调用**longjmp**时，jmpTarget必须处于活动状态且有效。因此，对于**`auto`**变量，变量的声明范围不得被离开；否则它将是无效的。对于有效性，当我们调用**longjmp**时，**setjmp**的所有上下文都必须仍然处于活动状态。在这里，我们通过将jmpTarget声明在与**setjmp**调用相同的范围内来避免复杂性。
- en: '|  |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.11
  id: totrans-922
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要17.11
- en: '*Leaving the scope of a call to* **setjmp** *invalidates the jump target.*'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '*离开对* **setjmp** *的调用范围会使跳转目标无效。*'
- en: '|  |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once we enter **`case`** `0` and call **`descend`**, we may end up in one of
    the exceptional conditions and call **longjmp** to terminate the parse algorithm.
    This passes control back to the call location that was marked in jmpTarget, as
    if we just returned from the call to **setjmp**. The only visible difference is
    that now the return value is the condition that we passed as a second argument
    to **longjmp**. If, for example, we encountered the **`tooDeep`** condition at
    the beginning of a recursive call to **`descend`** and called **longjmp**`(`jmpTarget`,`
    **`tooDeep`**`)`, we jump back to the controlling expression of the **`switch`**
    and receive the return value of **`tooDeep`**. Execution then continues at the
    corresponding **`case`** label.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入**`case`** `0`并调用**`descend`**，我们可能会遇到一些异常条件，并调用**longjmp**来终止解析算法。这将控制权交回jmpTarget中标记的调用位置，就像我们从**setjmp**的调用中返回一样。唯一的可见差异是，现在返回值是我们传递给**longjmp**的第二个参数的条件。例如，如果我们在一个对**`descend`**的递归调用开始时遇到了**`tooDeep`**条件，并调用了**longjmp**(`jmpTarget`,`
    **`tooDeep`**`)，我们会跳回到**`switch`**的控制表达式，并接收**`tooDeep`**的返回值。然后执行将继续在相应的**`case`**标签处继续。
- en: '|  |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.12
  id: totrans-927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要17.12
- en: '*A call to* **longjmp** *transfers control directly to the position that was
    set by* **setjmp** *as if that had returned the condition argument.*'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '*对* **longjmp** *的调用会直接将控制权转移到由* **setjmp** *设置的**位置**，就像它返回了条件参数一样。*'
- en: '|  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Be aware, though, that precautions have been taken to make it impossible to
    cheat and to retake the normal path a second time.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，已经采取了预防措施，以确保无法作弊并第二次重新采取正常路径。
- en: '|  |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.13
  id: totrans-932
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要17.13
- en: '*A* *`0`* *as a* *`condition`* *parameter to* **longjmp** *is replaced by*
    *`1`**.*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '*将* *`0`* *作为* *`condition`* *参数传递给* **longjmp** *会被替换为* *`1`**.*'
- en: '|  |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The **setjmp**`/`**longjmp** mechanism is very powerful and can avoid a whole
    cascade of returns from functions calls. In our example, if we allow the maximal
    depth of nesting of the input program of 30, say, the detection of the **`tooDeep`**
    condition will happen when there are 30 active recursive calls to **`descend`**.
    A regular error-return strategy would **`return`** to each of these and do some
    work on each level. A call to **longjmp** allows us to shorten all these returns
    and proceed the execution directly in the **`switch`** of **`basic_blocks`**.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '**setjmp**`/`**longjmp**机制非常强大，可以避免从函数调用中返回的整个级联。在我们的例子中，如果我们允许输入程序的嵌套深度最大为30，那么当有30个对**`descend`**的活跃递归调用时，就会检测到**`tooDeep`**条件。常规的错误返回策略会**`return`**到这些调用中的每一个，并在每个级别上做一些工作。对**longjmp**的调用允许我们缩短所有这些返回，并直接在**`switch`**的**`basic_blocks`**中继续执行。'
- en: 'Because **setjmp**`/`**longjmp** is allowed to make some simplifying assumptions,
    this mechanism is surprisingly efficient. Depending on the processor architecture,
    it usually needs no more than 10 to 20 assembler instructions. The strategy followed
    by the library implementation is usually quite simple: **setjmp** saves the essential
    hardware registers, including stack and instruction pointers, in the **`jmp_buf`**
    object, and **longjmp** restores them from there and passes control back to the
    stored instruction pointer.^([[9](#ch17fn09)])'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**setjmp**`/`**longjmp**允许做出一些简化的假设，这个机制出奇地高效。根据处理器架构的不同，它通常不需要超过10到20条汇编指令。库实现所遵循的策略通常很简单：**setjmp**将必要的硬件寄存器（包括栈和指令指针）保存在**`jmp_buf`**对象中，而**longjmp**则从那里恢复它们，并将控制权交回存储的指令指针.^([[9](#ch17fn09)])
- en: ⁹
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the vocabulary of this you might want to read or re-read [section 13.5](kindle_split_023.html#ch13lev1sec5).
  id: totrans-939
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于这个词汇，你可能需要阅读或重新阅读[第13.5节](kindle_split_023.html#ch13lev1sec5)。
- en: One of the simplifications **setjmp** makes is about its return. Its specification
    says it returns an **`int`** value, but this value cannot be used inside arbitrary
    expressions.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '**setjmp** 在其返回方面所做的简化之一是。它的规范说明它返回一个 **`int`** 值，但这个值不能在任意表达式中使用。'
- en: '|  |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.14
  id: totrans-942
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.14
- en: '**setjmp** *may be used only in simple comparisons inside controlling expression
    of conditionals.*'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '**setjmp** 只能在条件表达式的简单比较中使用。'
- en: '|  |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So it can be used directly in a **`switch`** statement, as in our example, and
    it can be tested for `==`, `<`, and so on, but the return value of **setjmp**
    may not be used in an assignment. This guarantees that the **setjmp** value is
    only compared to a known set of values, and the change in the environment when
    returning from **longjmp** may just be a special hardware register that controls
    the effect of conditionals.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它可以直接用在 **`switch`** 语句中，就像我们的例子一样，并且可以测试其 `==`、`<` 等等，但 **setjmp** 的返回值不能用于赋值。这保证了
    **setjmp** 的值只与一组已知的值进行比较，并且从 **longjmp** 返回时环境的变化可能只是一个控制条件效果的特定硬件寄存器。
- en: As we said, this saving and restoring of the execution environment by the **setjmp**
    call is minimal. Only a minimal necessary set of hardware registers is saved and
    restored. No precautions are taken to get local optimizations in line or even
    to take into account that the call location may be visited a second time.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，**setjmp** 调用通过保存和恢复执行环境所做的保存是最小的。只保存和恢复了一组必要的硬件寄存器。没有采取预防措施来使局部优化保持一致，甚至没有考虑到调用位置可能被第二次访问。
- en: '|  |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.15
  id: totrans-948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.15
- en: '*Optimization interacts badly with calls to* **setjmp***.*'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化与* **setjmp** *的调用相互作用不好*。'
- en: '|  |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you execute and test the code in the example, you will see that there actually
    is a problem in our simple usage of **setjmp**. If we trigger the **`plusL`**
    condition by feeding a partial program with a missing closing `}`, we would expect
    the diagnostic to read something like
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行并测试示例中的代码，你会看到我们简单使用 **setjmp** 的确存在一个问题。如果我们通过提供一个缺少闭合 `}` 的部分程序来触发 **`plusL`**
    条件，我们预计诊断信息将类似于
- en: '`Terminal`'
  id: totrans-952
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE103]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Depending on the optimization level of your compilation, instead of the `3`,
    you will most probably see a `0`, independent of the input program. This is because
    the optimizer does an analysis based on the assumption that the **`switch`** cases
    are mutually exclusive. It only expects the value of depth to change if execution
    goes through **`case`** `0` and thus the call of **`descend`**. From inspection
    of **`descend`** (see [section 17.4](#ch17lev1sec4)), we know that the value of
    depth is always restored to its original value before return, so the compiler
    may assume that the value doesn’t change through this code path. Then, none of
    the other cases changes depth, so the compiler can assume that depth is always
    `0` for the **fprintf** call.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的编译优化级别，你可能会看到 `3`，而不是 `0`，无论输入程序如何。这是因为优化器基于假设 **`switch`** 情况是互斥的进行分析。它只期望深度值在执行通过
    **`case`** `0` 和 **`descend`** 调用时发生变化。通过检查 **`descend`**（见[第17.4节](#ch17lev1sec4)），我们知道深度值总是在返回之前恢复到其原始值，因此编译器可能假设该值不会通过此代码路径改变。然后，其他情况都不会改变深度，因此编译器可以假设深度对于
    **fprintf** 调用始终是 `0`。
- en: As a consequence, optimization can’t make correct assumptions about objects
    that are changed in the normal code path of **setjmp** and referred to in one
    of the exceptional paths. There is only one recipe against that.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，优化不能对在 **setjmp** 的正常代码路径中更改并在其中一个异常路径中引用的对象做出正确的假设。对此只有一个对策。
- en: '|  |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.16
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.16
- en: '*Objects that are modified across* **longjmp** *must be* **`volatile`***.*'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '*在* **longjmp** *期间修改的对象必须是* **`volatile`***。'
- en: '|  |'
  id: totrans-959
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Syntactically, the qualifier **`volatile`** applies similar to the other qualifiers
    **`const`** and **`restrict`** that we have encountered. If we declare depth with
    that qualifier
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 语法上，**`volatile`** 修饰符的作用类似于我们遇到的其它修饰符 **`const`** 和 **`restrict`**。如果我们用那个修饰符声明深度
- en: '[PRE104]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: and amend the prototype of **`descend`** accordingly, all accesses to this object
    will use the value that is stored in memory. Optimizations that try to make assumptions
    about its value are blocked out.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 并相应地修改 **`descend`** 的原型，所有对这个对象的访问都将使用存储在内存中的值。试图对其值做出假设的优化将被阻止。
- en: '|  |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.17
  id: totrans-964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.17
- en: '**`volatile`** *objects are reloaded from memory each time they are accessed.*'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '**`volatile`** 对象每次访问时都会从内存中重新加载。'
- en: '|  |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.18
  id: totrans-968
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.18
- en: '**`volatile`** *objects are stored to memory each time they are modified.*'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '**`volatile`** 对象在每次修改时都会存储到内存中。'
- en: '|  |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So **`volatile`** objects are protected from optimization, or, if we look at
    it negatively, they inhibit optimization. Therefore, you should only make objects
    **`volatile`** if you really need them to be.^([[[Exs 3]](#ch17fn-ex03)])
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**`volatile`** 对象受到优化的保护，或者，如果我们从负面来看，它们会抑制优化。因此，只有在你确实需要它们时才应该将对象设置为 **`volatile`**.^([[[Exs
    3]](#ch17fn-ex03)])
- en: ^([Exs 3])
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Your version of **`descend`** that passes depth as a value might not propagate
    the depth correctly if it encounters the **`plusL`** condition. Ensure that it
    copies that value to an object that can be used by the **fprintf** call in **`basic_blocks`**.
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你的 **`descend`** 版本将深度作为值传递，并且遇到 **`plusL`** 条件，可能无法正确传播深度。确保它将该值复制到可以被 **`basic_blocks`**
    中的 **fprintf** 调用使用的对象中。
- en: 'Finally, note some subtleties of the **`jmp_buf`** type. Remember that it is
    an opaque type: you should never make assumptions about its structure or its individual
    fields.'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意 **`jmp_buf`** 类型的某些细微差别。记住，它是一个不透明类型：你不应该对其结构或其单个字段做出任何假设。
- en: '|  |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.19
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.19 总结
- en: '*The* **`typedef`** *for* **`jmp_buf`** *hides an array type.*'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '*`jmp_buf`* 的 **`typedef`** 隐藏了一个数组类型。'
- en: '|  |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'And because it is an opaque type, we don’t know anything about the base type,
    jmp_buf_base, say, of the array. Thus:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个不透明类型，我们不知道关于数组的基础类型，例如 jmp_buf_base。因此：
- en: An object of type **`jmp_buf`** cannot be assigned to.
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为 **`jmp_buf`** 的对象不能被赋值。
- en: A **`jmp_buf`** function parameter is rewritten to a pointer to jmp_buf_base.
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`jmp_buf`** 函数参数被重写为指向 jmp_buf_base 的指针。'
- en: Such a function always refers to the original object and not to a copy.
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的函数总是引用原始对象，而不是副本。
- en: 'In a way, this emulates a pass-by-reference mechanism, for which other programming
    languages such as C++ have explicit syntax. Generally, using this trick is not
    a good idea: the semantics of a **`jmp_buf`** variable depend on being locally
    declared or on being a function parameter; for example, in **`basic_blocks`**,
    that variable it is not assignable, whereas in **`descend`**, the analogous function
    parameter is modifiable because it is rewritten to a pointer. Also, we cannot
    use the more-specific declarations from Modern C for the function parameter that
    would be adequate, something like'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这模拟了一个按引用传递机制，对于像 C++ 这样的其他编程语言，有显式的语法。通常，使用这个技巧不是一个好主意：**`jmp_buf`**
    变量的语义取决于它是局部声明的还是作为函数参数；例如，在 **`basic_blocks`** 中，该变量不可赋值，而在 **`descend`** 中，类似的功能参数是可修改的，因为它被重写为指针。此外，我们不能为函数参数使用现代
    C 的更具体的声明，例如
- en: '![](193fig01.jpg)'
  id: totrans-985
  prefs: []
  type: TYPE_IMG
  zh: '![](193fig01.jpg)'
- en: '[PRE105]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: to insist that the pointer shouldn’t be changed inside the function, that it
    must not be `0`, and that access to it can be considered unique for the function.
    As of today, we would not design this type like this, and you should not try to
    copy this trick for the definition of your own types.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 为了坚持指针在函数内部不应更改，它不能为 `0`，并且对其访问可以被认为是函数的唯一访问。截至今天，我们不会这样设计这个类型，你不应该尝试将这个技巧用于你自己的类型的定义。
- en: 17.6\. Signal handlers
  id: totrans-988
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.6. 信号处理程序
- en: 'As we have seen, **setjmp**`/`**longjmp** can be used to handle exceptional
    conditions that we detect ourselves during the execution of our code. A *signal
    handler* is a tool that handles exceptional conditions that arise differently:
    that are triggered by some event that is external to the program. Technically,
    there are two types of such external events: *hardware interrupts*, also referred
    to as *traps* or *synchronous signals*, and *software interrupts* or *asynchronous
    signals*.'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**setjmp**`/`**longjmp** 可以用来处理我们在代码执行过程中自己检测到的异常条件。一个 *信号处理程序* 是一种处理不同异常条件的工具：这些条件是由程序外部的事件触发的。技术上，这类外部事件有两种类型：*硬件中断*，也称为
    *陷阱* 或 *同步信号*，以及 *软件中断* 或 *异步信号*。
- en: 'The first occurs when the processing device encounters a severe fault that
    it cannot deal with: for example, a division by zero, addressing a non-existent
    memory bank, or using a misaligned address in an instruction that operates on
    a wider integer type. Such an event is *synchronous* with the program execution.
    It is directly caused by a faulting instruction, so it can always be known at
    which particular instruction the interrupt was raised.'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况发生在处理设备遇到它无法处理的严重故障时：例如，除以零，访问不存在的内存区，或在操作更宽整数类型的指令中使用未对齐的地址。此类事件是与程序执行
    *同步* 的。它直接由故障指令引起，因此可以始终知道中断是在哪个特定指令中引发的。
- en: The second arises when the operating or runtime system decides that our program
    should terminate, because some deadline is exceeded, a user has issued a termination
    request, or the world as we know it is going to end. Such an event is *asynchronous*,
    because it can fall in the middle of a multistage instruction, leaving the execution
    environment in an intermediate state.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况发生在操作系统或运行时系统决定我们的程序应该终止，因为某个截止日期已过，用户已发出终止请求，或者我们所知的世界即将结束。此类事件是 *异步*
    的，因为它可能发生在多阶段指令的中间，使执行环境处于中间状态。
- en: 'Most modern processors have a built-in feature to handle hardware interrupts:
    an *interrupt vector table*. This table is indexed by the different hardware faults
    that the platform knows about. Its entries are pointers to procedures, *interrupt
    handlers*, that are executed when the specific fault occurs. So if the processor
    detects such a fault, execution is automatically switched away from the user code,
    and an interrupt handler is executed. Such a mechanism is not portable, because
    the names and locations of the faults are different from platform to platform.
    It is tedious to handle, because to program a simple application, we’d have to
    provide all handlers for all interrupts.'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代处理器都内置了一个处理硬件中断的功能：一个 *中断向量表*。该表由平台所知的不同硬件故障进行索引。其条目是指向过程，*中断处理程序* 的指针，当特定故障发生时执行。因此，如果处理器检测到此类故障，执行将自动从用户代码切换，并执行中断处理程序。这种机制是不可移植的，因为故障的名称和位置在不同平台之间是不同的。处理起来很繁琐，因为要编写一个简单的应用程序，我们必须为所有中断提供所有处理程序。
- en: C’s signal handlers provide us with an abstraction to deal with both types of
    interrupts, hardware and software, in a portable way. They work similarly to what
    we describe for hardware interrupts, but
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: C 的信号处理程序为我们提供了一个抽象，以可移植的方式处理硬件和软件两种类型的中断。它们的工作方式与我们描述的硬件中断类似，但
- en: The names of (some of) the faults are standardized.
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （一些）故障的名称是标准化的。
- en: All faults have a default handler (which is mostly implementation defined).
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有故障都有一个默认处理程序（这通常是实现定义的）。
- en: And (most) handlers can be specialized.
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且（大多数）处理程序可以专门化。
- en: In each item of that list, there are parenthetical *reservations*, because upon
    a closer look it appears that C’s interface for signal handlers is quite rudimentary;
    all platforms have their extensions and special rules.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 在该列表的每一项中，都有括号内的 *保留意见*，因为仔细观察后，似乎 C 的信号处理程序接口相当基础；所有平台都有自己的扩展和特殊规则。
- en: '|  |'
  id: totrans-998
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.20
  id: totrans-999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取走 17.20
- en: '*C’s signal-handling interface is minimal and should only be used for elementary
    situations.*'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '*C 的信号处理接口是最小的，并且仅应用于基本情况*。'
- en: '|  |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The control flow of a handled signal is shown in [figure 17.3](#ch17fig03).
    The normal control flow is interrupted at a place that is not foreseeable by the
    application, a signal handler function kicks in and performs some tasks, and after
    that the control resumes at exactly the same place and state as when it was interrupted.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的信号的控制流在 [图 17.3](#ch17fig03) 中显示。正常控制流在应用程序不可预见的地方被中断，信号处理程序函数介入并执行一些任务，然后控制恢复到中断时的确切位置和状态。
- en: Figure 17.3\. Control flow after an interrupt `return` jumps to the position
    where the interrupt occurred.
  id: totrans-1003
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 17.3\. 中断 `return` 跳转到的位置是中断发生的位置。
- en: '![](17fig03_alt.jpg)'
  id: totrans-1004
  prefs: []
  type: TYPE_IMG
  zh: '![](17fig03_alt.jpg)'
- en: 'The interface is defined in the header `signal.h`. The C standard distinguishes
    six different values, called *signal numbers*. The following are the exact definitions
    as given there. Three of these values are typically caused by hardware interrupts^([[10](#ch17fn010)]):'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义在头文件 `signal.h` 中。C 标准区分了六个不同的值，称为 *信号编号*。以下是在那里给出的确切定义。其中三个值通常由硬件中断^([[10](#ch17fn010))]
    引起：
- en: ^(10)
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Called computational exceptions by the standard.
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标准称为计算异常。
- en: '|  |'
  id: totrans-1009
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<signal.h>`'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '`<signal.h>`'
- en: '|  |'
  id: totrans-1011
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**`SIGFPE`** `an erroneous arithmetic operation, such as zero divide or an
    operation resulting in overflow`'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SIGFPE`** 错误的算术运算，例如零除或导致溢出的操作'
- en: '**`SIGILL`** `detection of an invalid function image, such as an invalid instruction`'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SIGILL`** 检测到无效的功能映像，例如无效的指令'
- en: '**`SIGSEGV`** `an invalid access to storage`'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SIGSEGV`** 对存储的无效访问'
- en: '|  |'
  id: totrans-1016
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The other three are usually triggered by software or users:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个通常由软件或用户触发：
- en: '|  |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**`SIGABRT`** `abnormal termination, such as is initiated by the` **abort**
    `function`'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SIGABRT`** 非正常终止，例如由`**abort**`函数发起'
- en: '**`SIGINT`** `receipt of an interactive attention signal`'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SIGINT`** 接收到交互式注意信号'
- en: '**`SIGTERM`** `a termination request sent to the program`'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SIGTERM`** 发送给程序的终止请求'
- en: '|  |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'A specific platform will have other signal numbers; the standard reserves all
    identifiers starting with **`SIG`** for that purpose. Their use is undefined as
    of the C standard, but as such there is nothing bad about it. *Undefined* here
    really means what it says: if you use it, it has to be defined by some other authority
    than the C standard, such as your platform provider. Your code becomes less portable
    as a consequence.'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的平台将会有其他的信号编号；标准为该目的保留了所有以**`SIG`**开头的标识符。它们的使用在C标准中是未定义的，但因此并没有什么不好。这里的**未定义**确实意味着它所说的那样：如果你使用它，它必须由C标准以外的其他权威机构定义，例如你的平台提供商。因此，你的代码的可移植性会降低。
- en: 'There are two standard dispositions for handling signals, both also represented
    by symbolic constants. **`SIG_DFL`** restores the platform’s default handler for
    the specific signal, and **`SIG_IGN`** indicates that the signal is to be ignored.
    Then, the programmer may write their own signal handlers. The handler for our
    parser looks quite simple:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 处理信号有两种标准方式，这两种方式也由符号常量表示。**`SIG_DFL`** 恢复特定信号的平台的默认处理程序，而**`SIG_IGN`** 表示要忽略该信号。然后，程序员可以编写自己的信号处理程序。我们解析器的处理程序看起来相当简单：
- en: '`basic_blocks.c`'
  id: totrans-1025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`basic_blocks.c`'
- en: '[PRE106]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As you can see, such a signal handler receives the signal number sig as an argument
    and **`switch`**es according to that number. Here we have provisions for signal
    numbers **`SIGTERM`** and **`SIGABRT`**. All other signals are just handled by
    resetting the handler for that number to its default, storing the number in our
    global variable interrupt, and then returning to the point where the interrupt
    occurred.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这样的信号处理程序接收信号编号sig作为参数，并根据该编号**switch**。这里我们为信号编号**`SIGTERM`**和**`SIGABRT`**提供了处理措施。所有其他信号都只是通过将那个编号的处理程序重置为其默认状态，将编号存储在我们的全局变量interrupt中，然后返回到中断发生的位置。
- en: The type of a signal handler has to be compatible with the following:^([[11](#ch17fn011)])
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序的类型必须与以下兼容：^([[11](#ch17fn011)])
- en: ^(11)
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-1030
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is no such *type* defined by the standard, though.
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如此，标准并没有定义这样的**类型**。
- en: '`sighandler.h`'
  id: totrans-1032
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`sighandler.h`'
- en: '[PRE107]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: That is, it receives a signal number as an argument and doesn’t return anything.
    As such, this interface is quite limited and does not allow us to pass enough
    information, in particular none about the location and circumstances for which
    the signal occurred.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，它接收一个信号编号作为参数，并且不返回任何内容。因此，这个接口相当有限，不允许我们传递足够的信息，特别是关于信号发生的位置和情况的信息。
- en: 'Signal handlers are established by a call to **signal**, as we saw in our function
    **`signal_handler`**. Here, it is just used to reset the signal disposition to
    the default. **signal** is one of the two function interfaces that are provided
    by `signal.h`:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序是通过调用**signal**建立的，正如我们在函数**`signal_handler`**中看到的那样。在这里，它只是用来将信号处理程序的状态重置为默认状态。**signal**是`signal.h`提供的两个函数接口之一：
- en: '|  |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<signal.h>`'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '`<signal.h>`'
- en: '|  |'
  id: totrans-1038
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE108]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The return value of **signal** is the handler that was previously active for
    the signal, or the special value **`SIG_ERR`** if an error occurred. Inside a
    signal handler, **signal** should only be used to change the disposition of the
    same signal number that was received by the call. The following function has the
    same interface as **signal** but provides a bit more information about the success
    of the call:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '**signal**的返回值是信号之前活动的处理程序，或者在发生错误时返回特殊值**`SIG_ERR`**。在信号处理程序内部，**signal**应该只用于更改接收到的相同信号编号的处理程序的状态。以下函数与**signal**具有相同的接口，但提供了关于调用成功程度的更多信息：'
- en: '`sighandler.c`'
  id: totrans-1041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`sighandler.c`'
- en: '[PRE109]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The **main** function for our parser uses this in a loop to establish signal
    handlers for all signal numbers that it can:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析器的 **main** 函数使用这个循环来为它能够处理的全部信号号建立信号处理程序：
- en: '`basic_blocks.c`'
  id: totrans-1044
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`basic_blocks.c`'
- en: '[PRE110]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'As an example, on my machine this provides the following information at the
    startup of the program:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的机器上，程序启动时提供以下信息：
- en: '`Terminal`'
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Terminal`'
- en: '[PRE111]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The second function **raise** can be used to deliver the specified signal to
    the current execution. We already used it at the end of **`basic_blocks`** to
    deliver the signal that we had caught to the preinstalled handler.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数 **raise** 可以用来将指定的信号发送到当前执行。我们已经在 **`basic_blocks`** 的末尾使用过它，将我们捕获的信号发送到预安装的处理程序。
- en: 'The mechanism of signals is similar to **setjmp**`/`**longjmp**: the current
    state of execution is memorized, control flow is passed to the signal handler,
    and a return from there restores the original execution environment and continues
    execution. The difference is that there is no special point of execution that
    is marked by a call to **setjmp**.'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 信号机制类似于 **setjmp**`/`**longjmp**：当前执行状态被记住，控制流传递给信号处理程序，从那里返回则恢复原始执行环境并继续执行。不同之处在于没有通过调用
    **setjmp** 标记的特殊执行点。
- en: '|  |'
  id: totrans-1051
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.21
  id: totrans-1052
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.21
- en: '*Signal handlers can kick in at any point of execution.*'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号处理程序可以在执行的任何点介入。*'
- en: '|  |'
  id: totrans-1054
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Interesting signal numbers in our case are the software interrupts **`SIGABRT`**,
    **`SIGTERM`**, and **`SIGINT`**, which usually can be sent to the application
    with a magic keystroke such as `Ctrl-C`. The first two will call **_Exit** and
    **quick_exit**, respectively. So if the program receives these signals, execution
    will be terminated: for the first, without calling any cleanup handlers; and for
    the second, by going through the list of cleanup handlers that were registered
    with **at_quick_exit**.'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，有趣的信号号是软件中断 **`SIGABRT`**、**`SIGTERM`** 和 **`SIGINT`**，通常可以通过像 `Ctrl-C`
    这样的魔法键组合发送给应用程序。前两个将调用 **_Exit** 和 **quick_exit**。因此，如果程序收到这些信号，执行将被终止：第一个不会调用任何清理处理程序；第二个将通过与
    **at_quick_exit** 注册的清理处理程序列表进行。
- en: '**`SIGINT`** will choose the **`default`** case of the signal handler, so it
    will eventually return to the point where the interrupt occurred.'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SIGINT`** 将选择信号处理程序的 **`default`** 情况，因此最终将返回到中断点。'
- en: '|  |'
  id: totrans-1057
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.22
  id: totrans-1058
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.22
- en: '*After return from a signal handler, execution resumes exactly where it was
    interrupted.*'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '*从信号处理程序返回后，执行将精确地恢复到中断点。*'
- en: '|  |'
  id: totrans-1060
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If that interrupt had occurred in function **`descend`**, it would first continue
    execution as if nothing had happened. Only when the current input line is processed
    and and a new one is needed will the variable interrupt be checked and execution
    wound down by calling **longjmp**. Effectively, the only difference between the
    situation before the interrupt and after is that the variable interrupt has changed
    its value.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中断发生在函数 **`descend`** 中，它将首先继续执行，就像什么都没发生一样。只有当处理完当前输入行并需要新的一行时，才会检查变量中断并调用
    **longjmp** 来降低执行。实际上，中断前后唯一的不同之处在于变量中断的值已改变。
- en: 'We also have a special treatment of a signal number that is not described by
    the C standard, SIGCONT, but on my operating system, `POSIX`. To remain portable,
    the use of this signal number is protected by guards. This signal is meant to
    continue execution of a program that was previously stopped: that is, for which
    execution had been suspended. In that case, the only thing to do is to return.
    By definition, we don’t want any modification of the program state whatsoever.'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还对C标准未描述的信号号进行了特殊处理，即SIGCONT，但在我的操作系统`POSIX`中。为了保持可移植性，使用此信号号受到保护。此信号旨在继续执行之前已停止的程序：即执行已被挂起的情况。在这种情况下，唯一要做的就是返回。根据定义，我们不希望程序状态有任何修改。
- en: 'So another difference from the **setjmp**`/`**longjmp** mechanism is that for
    it, the return value of **setjmp** changed the execution path. A signal handler,
    on the other hand, is not supposed to change the state of execution. We have to
    invent a suitable convention to transfer information from the signal handler to
    the normal program. As for **longjmp**, objects that are potentially changed by
    a signal handler must be **`volatile`** qualified: the compiler cannot know where
    interrupt handlers may kick in, and thus all its assumptions about variables that
    change through signal handling can be false.'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与**setjmp**`/`**longjmp**机制相比，另一个区别是对于它，**setjmp**的返回值改变了执行路径。另一方面，信号处理程序不应该改变执行状态。我们必须发明一个合适的约定来从信号处理程序传递信息到正常程序。至于**longjmp**，可能被信号处理程序更改的对象必须具有**`volatile`**属性：编译器无法知道中断处理程序可能在何处介入，因此它关于通过信号处理改变变量的所有假设都可能是不正确的。
- en: 'But signal handlers face another difficulty:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 但是信号处理程序还面临另一个困难：
- en: '|  |'
  id: totrans-1065
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.23
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.23
- en: '*A C statement may correspond to several processor instructions.*'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '*C语句可能对应于多个处理器指令。*'
- en: '|  |'
  id: totrans-1068
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For example, a **`double`** x could be stored in two usual machine words, and
    a write (assignment) of x to memory could need two separate assembler statements
    to write both halves.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个**`double`** x可以存储在两个常规机器字中，将x写入内存的赋值可能需要两个单独的汇编语句来写入两个 halves。
- en: When considering normal program execution as we have discussed so far, splitting
    a C statement into several machine statements is no problem. Such subtleties are
    not directly observable.^([[12](#ch17fn012)]) With signals, the picture changes.
    If such an assignment is split in the middle by the occurrence of a signal, only
    half of x is written, and the signal handler will see an inconsistent version
    of it. One half corresponds to the previous value, the other to the new one. Such
    a zombie representation (half here, half there) may not even be a valid value
    for **`double`**.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑我们迄今为止讨论的正常程序执行时，将C语句拆分成多个机器语句没有问题。这样的细微之处不能直接观察到.^([[12](#ch17fn012)]) 使用信号时，情况就不同了。如果这样的赋值在信号发生时被拆分在中间，那么只有x的一半被写入，信号处理程序将看到它的不一致版本。一半对应于之前的值，另一半对应于新的值。这种僵尸表示（一半在这里，一半在那里）甚至可能不是**`double`**的有效值。
- en: ^(12)
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-1072
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: They are only observable from outside the program because such a program may
    take more time than expected.
  id: totrans-1073
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们只能从程序外部观察到，因为这样的程序可能需要比预期更长的时间。
- en: '|  |'
  id: totrans-1074
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.24
  id: totrans-1075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.24
- en: '*Signal handlers need types with uninterruptible operations.*'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号处理程序需要具有不可中断操作的类型。*'
- en: '|  |'
  id: totrans-1077
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Here, the term *uninterruptible operation* refers to an operation that always
    appears to be *indivisible* in the context of signal handlers: either it appears
    not to have started or it appears to be completed. This doesn’t generally mean
    that it is undivided, just that we will not be able to observe such a division.
    The runtime system might have to force that property when a signal handler kicks
    in.'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，术语*不可中断操作*指的是在信号处理程序上下文中始终看起来是*不可分割的*操作：要么看起来没有开始，要么看起来已经完成。这通常并不意味着它是不可分割的，只是我们无法观察到这样的分割。运行时系统可能需要在信号处理程序介入时强制该属性。
- en: 'C has three different classes of types that provide uninterruptible operations:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: C有三种不同类别的类型提供不可中断操作：
- en: The type **`sig_atomic_t`**, an integer type with a minimal width of 8 bits
  id: totrans-1080
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型**`sig_atomic_t`**，一个最小宽度为8位的整型
- en: The type **`atomic_flag`**
  id: totrans-1081
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型**`atomic_flag`**
- en: All other atomic types that have the lock-free property
  id: totrans-1082
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有其他具有无锁属性的原子类型
- en: The first is present on all historical C platforms. Its use to store a signal
    number as in our example for variable interrupt is fine, but otherwise its guarantees
    are quite restricted. Only memory-load (evaluation) and store (assignment) operations
    are known to be uninterruptible; other operations aren’t, and the width may be
    quite limited.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是所有历史C平台都有的。将其用作存储信号编号，如我们示例中的变量中断，是合适的，但除此之外，其保证相当有限。只有内存加载（评估）和存储（赋值）操作被认为是不可中断的；其他操作不是，并且宽度可能相当有限。
- en: '|  |'
  id: totrans-1084
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.25
  id: totrans-1085
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 17.25
- en: '*Objects of type* **`sig_atomic_t`** *should not be used as counters.*'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型为**`sig_atomic_t`**的对象不应用作计数器。*'
- en: '|  |'
  id: totrans-1087
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is because a simple `++` operation might effectively be divided in three
    (load, increment, and store) and because it might easily overflow. The latter
    could trigger a hardware interrupt, which is really bad if we already are inside
    a signal handler.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为简单的 `++` 操作实际上可能被分成三个步骤（加载、增加和存储），并且它可能很容易溢出。后者可能会触发硬件中断，如果我们已经在信号处理程序内部，这将是真的非常糟糕。
- en: The latter two classes were only introduced by C11 for the prospect of threads
    (see section 18) and are only present if the feature test macro **`__STDC_NO_ATOMICS__`**
    has not been defined by the platform and if the header `stdatomic.h` has been
    included. The function **`sh_count`** uses these features, and we will see an
    example for this later.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 后两类仅在 C11 中引入，以展望线程（见第 18 节），并且仅在平台未定义特征测试宏 **`__STDC_NO_ATOMICS__`** 并且已包含头文件
    `stdatomic.h` 时存在。函数 **`sh_count`** 使用这些功能，我们将在稍后看到示例。
- en: '|  |'
  id: totrans-1090
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdatomic.h>`'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdatomic.h>`'
- en: '|  |'
  id: totrans-1092
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Because signal handlers for asynchronous signals should not access or change
    the program state in an uncontrolled way, they cannot call other functions that
    would do so. Functions that *can* be used in such a context are called *asynchronous
    signal safe*. Generally, it is difficult to know from an interface specification
    whether a function has this property, and the C standard guarantees it for only
    a handful of functions:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异步信号的信号处理程序不应以不受控制的方式访问或更改程序状态，因此它们不能调用会这样做其他函数。可以在这种环境中使用的函数被称为 *异步信号安全*。通常，从接口规范中很难知道一个函数是否具有此属性，而
    C 标准只为少数几个函数保证了这一点：
- en: The **`_Noreturn`** functions **abort**, **_Exit**, and **quick_exit** that
    terminate the program;
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止程序的 **`_Noreturn`** 函数 **abort**、**_Exit** 和 **quick_exit**；
- en: '**signal** for the same signal number for which the signal handler was called'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**signal** 对于调用信号处理程序的相同信号号'
- en: Some functions that act on atomic objects (discussed shortly)
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些作用于原子对象的函数（将在稍后讨论）
- en: '|  |'
  id: totrans-1097
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 17.26
  id: totrans-1098
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 吸收要点 17.26
- en: '*Unless specified otherwise, C library functions are not asynchronous signal
    safe.*'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非另有说明，否则 C 库函数不是异步信号安全*。'
- en: '|  |'
  id: totrans-1100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So by the C standard itself, a signal handler cannot call **exit** or do any
    form of IO, but it can use **quick_exit** and the **at_quick_exit** handlers to
    execute some cleanup code.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据 C 标准本身，信号处理程序不能调用 **exit** 或执行任何形式的 I/O，但它可以使用 **quick_exit** 和 **at_quick_exit**
    处理程序来执行一些清理代码。
- en: 'As already noted, C’s specifications for signal handlers are minimal, and often
    a specific platform will allow for more. Therefore, portable programming with
    signals is tedious, and exceptional conditions should generally be dealt with
    in a cascade, as we have seen in our examples:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C 对信号处理程序的规范是最小的，并且通常特定平台会允许更多。因此，使用信号的便携式编程是繁琐的，并且通常应按级联方式处理特殊条件，就像我们在示例中看到的那样：
- en: Exceptional conditions that can be detected and handled locally can be dealt
    with by using **`goto`** for a limited number of labels.
  id: totrans-1103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在本地检测和处理特殊条件可以通过使用 **`goto`** 对有限数量的标签进行处理。
- en: Exceptional conditions that need not or cannot be handled locally should be
    returned as a special value from functions whenever this is possible, such as
    returning a null pointer instead of a pointer to an object.
  id: totrans-1104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当不需要或无法在本地处理特殊条件时，应从函数返回特殊值，例如返回空指针而不是对象的指针。
- en: Exceptional conditions that change the global program state can be handled with
    **setjmp**`/`**longjmp** if an exceptional return would be expensive or complex.
  id: totrans-1105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当异常返回会非常昂贵或复杂时，可以使用 **setjmp**`/`**longjmp** 来处理改变全局程序状态的特殊条件。
- en: Exceptional conditions that result in a signal being raised can be caught by
    a signal handler, but should be handled after the return of the handler in the
    normal flow of execution.
  id: totrans-1106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导致发出信号的异常条件可以由信号处理程序捕获，但应在处理程序的正常执行流程返回后处理。
- en: 'Since even the list of signals that the C standard specifies is minimal, dealing
    with the different possible conditions becomes complicated. The following shows
    how we can handle a collection of signal numbers that goes beyond those that are
    specified in the C standard:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C 标准指定的信号列表本身是最小的，处理不同的可能条件变得复杂。以下显示了我们可以如何处理一组超出 C 标准指定的信号号的信号：
- en: '`sighandler.c`'
  id: totrans-1108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`sighandler.c`'
- en: '[PRE112]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'where the macro just initializes an object of type sh_pair:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，宏只是初始化了一个类型为 sh_pair 的对象：
- en: '`sighandler.h`'
  id: totrans-1111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`sighandler.h`'
- en: '[PRE113]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The use of **`#ifdef`** conditionals ensures that signal names that are not
    standard can be used, and the designated initializer within SH_PAIR allows us
    to specify them in any order. Then the size of the array can be used to compute
    the number of known signal numbers for sh_known:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **`#ifdef`** 条件确保可以使用非标准的信号名称，并且 SH_PAIR 中的指定初始化器允许我们以任何顺序指定它们。然后可以使用数组的大小来计算
    sh_known 已知的信号数量：
- en: '`sighandler.c`'
  id: totrans-1114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`sighandler.c`'
- en: '[PRE114]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If the platform has sufficient support for atomics, this information can also
    be used to define an array of atomic counters so we can keep track of the number
    of times a particular signal was raised:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果平台对原子操作有足够的支持，此信息也可以用来定义一个原子计数器数组，以便我们可以跟踪特定信号被提升的次数：
- en: '`sighandler.h`'
  id: totrans-1117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`sighandler.h`'
- en: '[PRE115]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: An object that is specified with **`_Atomic`** can be used with the same operators
    as other objects with the same base type, here the `++` operator. In general,
    such objects are then guaranteed to avoid race conditions with other threads (discussed
    shortly), and they are uninterruptible if the type has the *lock-free* property.
    The latter here is tested with the feature-test macro **`ATOMIC_LONG_LOCK_FREE`**.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **`_Atomic`** 指定的对象可以使用与具有相同基类型的其他对象相同的运算符，这里是指 `++` 运算符。通常，这样的对象可以保证避免与其他线程（稍后讨论）的竞争条件，并且如果类型具有
    *lock-free* 属性，则不可中断。后者在这里通过特征测试宏 **`ATOMIC_LONG_LOCK_FREE`** 进行测试。
- en: 'The user interfaces here are **`sh_count`** and **`sh_counted`**. They use
    the array of counters if available and are otherwise replaced by trivial functions:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的用户界面是 **`sh_count`** 和 **`sh_counted`**。如果可用，它们将使用计数器数组，否则将用平凡函数替换：
- en: '`sighandler.h`'
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`sighandler.h`'
- en: '[PRE116]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Summary
  id: totrans-1123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The execution of C code is not always linearly sequenced, even if there are
    no parallel threads or asynchronous signals. As a consequence, some evaluations
    may have results that depend on ordering choices by the compiler.
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使没有并行线程或异步信号，C代码的执行也不总是线性序列的。因此，某些评估的结果可能取决于编译器的排序选择。
- en: '**setjmp**`/`**longjmp** are powerful tools to handle exceptional conditions
    across a whole series of nested function calls. They may interact with optimization
    and require that some variables be protected with a **`volatile`** qualification.'
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setjmp**`/`**longjmp** 是处理一系列嵌套函数调用中异常条件的强大工具。它们可能与优化交互，并要求某些变量使用 **`volatile`**
    修饰符进行保护。'
- en: C’s interface of handling synchronous and asynchronous signals is rudimentary.
    Therefore, signal handlers should do as little work as possible and just mark
    the type of the interrupt condition in a global flag. They should then switch
    back to the interrupted context and handle the interrupt condition there.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C处理同步和异步信号的方式是基本的。因此，信号处理器应该尽可能少做工作，只需在全局标志中标记中断条件类型。然后它们应该切换回中断上下文并处理中断条件。
- en: Information can only be passed to and from signal handlers by using **`volatile`**
    **`sig_atomic_t`**, **`atomic_flag`**, or other lock-free atomic data types.
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息只能通过使用 **`volatile`** **`sig_atomic_t`**、**`atomic_flag`** 或其他无锁原子数据类型传递到和从信号处理器。
- en: Chapter 18\. Threads
  id: totrans-1128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18章。线程
- en: This chapter covers
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Inter-thread control
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程间控制
- en: Initializing and destroying threads
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化和销毁线程
- en: Working with thread-local data
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程局部数据
- en: Critical data and critical sections
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键数据和关键部分
- en: Communicating through condition variables
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过条件变量进行通信
- en: Threads are another variation of control flow that allow us to pursue several
    *tasks* concurrently. Here, a task is a part of the job that is to be executed
    by a program such that different tasks can be done with no or little interaction
    between each other.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是控制流的一种变体，允许我们并发地执行多个 *任务*。在这里，一个任务是指程序要执行的工作的一部分，不同的任务之间可以没有或只有很少的交互。
- en: Our main example for this will be a primitive game that we call `B9` that is
    a variant of Conway’s game of life (see Gardner [[1970](kindle_split_036.html#bib4)]).
    It models a matrix of primitive “cells” that are born, live, and die according
    to very simple rules. We divide the game into four different tasks, each of which
    proceeds iteratively. The cells go through *life cycles* that compute birth or
    death events for all cells. The graphical presentation in the terminal goes through
    drawing cycles, which are updated as fast as the terminal allows. Spread between
    these are user keystrokes that occur irregularly and that allow the user to add
    cells at chosen positions. [Figure 18.1](#ch18fig01) shows a schematic view of
    these tasks for B9.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要例子将是一个我们称之为`B9`的原始游戏，它是康威生命游戏的变体（参见Gardner [[1970](kindle_split_036.html#bib4)]）。它模拟了一个原始“细胞”矩阵，这些细胞根据非常简单的规则出生、生活和死亡。我们将游戏分为四个不同的任务，每个任务都迭代进行。单元格通过*生命周期*计算所有单元格的出生或死亡事件。终端中的图形表示通过绘图周期进行，这些周期更新得尽可能快。在这些周期之间是用户不规则的按键，允许用户在选定的位置添加单元格。[图18.1](#ch18fig01)显示了B9这些任务的示意图。
- en: 'The four tasks are:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 四个任务包括：
- en: '***Draw:*** Draws a pictures of cell matrix to the terminal; see [Fig 18.2](#ch18fig02).'
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***绘制：*** 将细胞矩阵的图片绘制到终端；参见[图18.2](#ch18fig02)。'
- en: '***Input:*** Captures the keystrokes, updates the cursor position, and creates
    cells'
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***输入：*** 捕获按键，更新光标位置，并创建单元格'
- en: '***Update:*** Updates the state of the game from one life cycle to the next'
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***更新：*** 将游戏的状态从生命周期更新到下一个生命周期'
- en: '***Account:*** Is tightly coupled with the *update* task and counts the number
    of living neighboring cells of each cell'
  id: totrans-1141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***账户：*** 与*更新*任务紧密耦合，并计算每个单元格的活着的邻近单元格数量'
- en: Figure 18.1\. Control flow of the five threads of `B9`
  id: totrans-1142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.1\. `B9`五个线程的控制流程
- en: '![](18fig01_alt.jpg)'
  id: totrans-1143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](18fig01_alt.jpg)'
- en: Figure 18.2\. A screenshot of B9 showing several cells and the cursor position
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.2\. B9的截图，显示了几个单元格和光标位置
- en: '![](18fig02_alt.jpg)'
  id: totrans-1145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](18fig02_alt.jpg)'
- en: Each such task is executed by a *thread* that follows its own control flow,
    much like a simple program of its own. If the platform has several processors
    or cores, these threads may be executed simultaneously. But even if the platform
    does not have this capacity, the system will interleave the execution of the threads.
    The execution as a whole will appear to the user *as if* the events that are handled
    by the tasks are concurrent. This is crucial for our example, since we want the
    game to appear to continue constantly whether the player presses keys on the keyboard
    or not.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这样的任务都是由一个*线程*执行的，该线程遵循自己的控制流程，就像它自己的一个简单程序。如果平台有多个处理器或核心，这些线程可以同时执行。即使平台没有这种能力，系统也会交错执行线程。整体执行对用户来说将*看起来*像是任务处理的事件是并发的。这对于我们的例子至关重要，因为我们希望游戏无论玩家是否按键盘上的键都能看起来持续进行。
- en: 'Threads in C are dealt with through two principal function interfaces that
    can be used to start a new thread and then wait for the termination of such a
    thread: Here the second argument of **thrd_create** is a function pointer of type
    **`thrd_start_t`**. This function is executed'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中处理线程通过两个主要函数接口进行，可以用来启动一个新线程然后等待该线程的终止：这里**thrd_create**的第二个参数是类型为**`thrd_start_t`**的函数指针。这个函数被执行
- en: '[PRE117]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: at the start of the new thread. As we can see from the **`typedef`** the function
    receives a **`void*`** pointer and returns an **`int`**. The type **`thrd_t`**
    is an opaque type, which will identify the newly created thread.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 在新线程的开始时。正如我们从**`typedef`**中可以看到的，该函数接收一个**`void*`**指针并返回一个**`int`**。类型**`thrd_t`**是一个不透明类型，它将标识新创建的线程。
- en: In our example, four calls in **main** to **thrd_create** create the four threads
    that correspond to the different tasks. These execute concurrently to the original
    thread of **main**. At the end, **main** waits for the four threads to terminate;
    it *joins* them. The four threads reach their termination simply when they **`return`**
    from the initial function with which they were started. Accordingly, our four
    functions are declared as
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，**main**中的四个**thrd_create**调用创建了四个线程，这些线程对应于不同的任务。这些线程与**main**的原始线程并发执行。最后，**main**等待四个线程终止；它*连接*它们。四个线程简单地通过从它们启动的初始函数返回来达到终止。因此，我们的四个函数被声明为
- en: '[PRE118]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'These four functions are launched in threads of their own by our **main**,
    and all four receive a pointer to an object of type life that holds the state
    of the game:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个函数由我们的**主函数**分别以线程的形式启动，并且所有四个线程都接收一个指向类型为life的对象的指针，该对象持有游戏的状态：
- en: '`B9.c`'
  id: totrans-1153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE119]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The simplest of the four thread functions is account_thread. As its interface
    only receives a **`void*`**, its first action is to reinterpret it as a life pointer
    and then to enter a **`while`** loop until its work is finished:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 四个线程函数中最简单的是account_thread。由于其接口只接收**`void*`**，它的第一个动作是将它重新解释为life指针，然后进入一个**`while`**循环，直到其工作完成：
- en: '`B9.c`'
  id: totrans-1156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE120]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '`B9.c`'
  id: totrans-1158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE121]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The core of that loop calls a specific function for the task, life_account,
    and then checks whether, from its point of view, the game should be finished:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 那个循环的核心调用一个特定的任务函数，life_account，然后检查从它的角度来看，游戏是否应该结束：
- en: '`B9.c`'
  id: totrans-1161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE122]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Here the condition for termination is whether the game had previously entered
    the same sequence of repetition game configurations.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里终止的条件是游戏是否之前进入了相同的重复游戏配置序列。
- en: 'The implementations of the other three functions are similar. All reinterpret
    their argument to be a pointer to life and enter a processing loop until they
    detect that the game has finished. Then, inside the loop, they have relatively
    simple logic to fulfill their specific task for this specific iteration. For example,
    draw_thread’s inner part looks like this:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个函数的实现类似。它们都将它们的参数重新解释为指向life的指针，并进入一个处理循环，直到它们检测到游戏已经结束。然后，在循环内部，它们有相对简单的逻辑来完成它们在这个特定迭代中的特定任务。例如，draw_thread的内部部分看起来像这样：
- en: '`B9.c`'
  id: totrans-1165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE123]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 18.1\. Simple inter-thread control
  id: totrans-1167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1. 简单的线程间控制
- en: We already have seen two different tools for a control between threads. First,
    **thrd_join** allows a thread to wait until another one is finished. We saw this
    when our **main** joined the four other threads. This ensures that this **main**
    thread effectively only terminates when all other threads have done so, and so
    the program execution stays alive and consistent until the last thread is gone.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种不同的线程控制工具。首先，**thrd_join**允许一个线程等待另一个线程完成。我们在**main**线程连接到其他四个线程时看到了这一点。这确保了这个**main**线程只有在所有其他线程都完成时才会终止，因此程序执行保持活跃和一致，直到最后一个线程消失。
- en: The other tool was the member finished of life. This member holds a bool that
    has a value that is **`true`** whenever one of the threads detects a condition
    that terminates the game.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个工具是life的成员finished。这个成员包含一个bool值，当任何一个线程检测到终止游戏的条件时，该值都为**`true`**。
- en: Similar to signal handlers, the simultaneous conflicting action of several threads
    on *shared* variables must be handled very carefully.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 与信号处理程序类似，几个线程对**共享**变量的同时冲突操作必须非常小心地处理。
- en: '|  |'
  id: totrans-1171
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.1
  id: totrans-1172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取舍18.1
- en: '*If a thread T*[0] *writes a non-atomic object that is simultaneously read
    or written by another thread T*[1]*, the behavior of the execution becomes undefined.*'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果线程T*[0] *写入一个同时被另一个线程T*[1] *读取或写入的非原子对象，执行的行为将变得未定义。*'
- en: '|  |'
  id: totrans-1174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In general, it will even be difficult to establish what *simultaneously* should
    mean when we talk about different threads (as discussed shortly). Our only chance
    to avoid such situations is to rule out all *potential* conflicting accesses.
    If there is such a potential simultaneous unprotected access, we speak of a *race
    condition*.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们谈论不同的线程时，甚至很难确定**同时**意味着什么（如稍后所讨论的）。我们避免这种情况的唯一机会是排除所有**潜在的**冲突访问。如果存在这种潜在的并发未受保护访问，我们称之为**竞争条件**。
- en: 'In our example, unless we take specific precautions, even an update of a bool
    such as finished can be divisible between different threads. If two threads access
    it in an interleaved way, an update may mix things up and lead to an undefined
    program state. The compiler cannot know whether a specific object can be subject
    to a race condition, and therefore we have to tell it explicitly. The simplest
    way to do so is by using a tool that we also saw with signal handlers: atomics.
    Here, our life structure has several members that are specified with **`_Atomic`**:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，除非我们采取特定的预防措施，否则即使是更新一个如finished这样的bool值也可能在不同线程之间被分割。如果两个线程以交错的方式访问它，更新可能会搞混事情，导致程序状态未定义。编译器无法知道一个特定的对象是否可能受到竞争条件的影响，因此我们必须明确地告诉它。这样做最简单的方法是使用我们之前也看到过的信号处理工具：原子操作。在这里，我们的life结构有几个成员被指定为**`_Atomic`**：
- en: '`life.h`'
  id: totrans-1177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`life.h`'
- en: '[PRE124]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Access to these members is guaranteed to be *atomic*. Here, this is the member
    finished that we already know, and some other members that we use to communicate
    between *input* and *draw*, in particular the current position of the cursor.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员的访问保证是*原子的*。在这里，这是我们已经知道的成员finished，以及一些我们用来在*输入*和*绘制*之间通信的其他成员，特别是光标的当前位置。
- en: '|  |'
  id: totrans-1180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.2
  id: totrans-1181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 18.2
- en: '*In view of execution in different threads, standard operations on atomic objects
    are indivisible and linearizable.*'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '*考虑到不同线程的执行，原子对象的标准操作是不可分割和可线性化的*。'
- en: '|  |'
  id: totrans-1183
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Here, *linearizability* ensures that we can also argue with respect to the ordering
    of computations in two different threads. For our example, if a thread sees that
    finished is modified (set to **`true`**), it knows that the thread setting it
    has performed all the actions that it is supposed to do. In that sense, linearizability
    extends the merely syntactical properties of sequencing ([section 17.2](kindle_split_028.html#ch17lev1sec2))
    to threads.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*线性化*确保我们还可以就两个不同线程中计算的顺序进行论证。对于我们的例子，如果一个线程看到finished被修改（设置为**`true`**），它就知道设置它的线程已经执行了它应该做的所有操作。从这个意义上说，线性化将序列的纯粹语法属性扩展到了线程。
- en: So operations on atomic objects also help us to determine which parts of our
    threads are *not* executed simultaneously, such that no race conditions may occur
    between them. Later, in [section 19.1](kindle_split_030.html#ch19lev1sec1), we
    will see how this can be formalized into the happened-before relation.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对原子对象的操作也有助于我们确定哪些线程的部分*不是*同时执行的，这样它们之间就不会发生竞争条件。稍后，在[第19.1节](kindle_split_030.html#ch19lev1sec1)中，我们将看到如何将这一点形式化为“发生之前”关系。
- en: 'Because atomic objects differ semantically from normal objects, the primary
    syntax to declare them is an *atomic specifier*: as we have seen, the keyword
    **`_Atomic`** followed by parentheses containing the type from which the atomic
    is derived. There is also another syntax that uses **`_Atomic`** as an *atomic
    qualifier* similar to the other qualifiers **`const`**, **`volatile`**, and **`restrict`**.
    In the following specifications, the two different declarations of A and B are
    equivalent:'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为原子对象在语义上与普通对象不同，声明它们的语法主要是*原子指定符*：正如我们所看到的，关键字**`_Atomic`**后跟包含原子从中派生的类型的括号。还有一种使用**`_Atomic`**作为*原子修饰符*的语法，类似于其他修饰符**`const`**、**`volatile`**和**`restrict`**。在下面的规范中，A和B的两种不同声明是等效的：
- en: '[PRE125]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: They refer to the same objects A, an atomic pointer to an array of `45` **`double`**
    elements, and B, a pointer to an array of `45` atomic **`double`** elements.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 它们指的是相同的对象A，一个指向`45`个**`double`**元素数组的原子指针，以及B，一个指向`45`个原子**`double`**元素数组的指针。
- en: 'The qualifier notation has a pitfall: it might suggest similarities between
    **`_Atomic`** qualifiers and other qualifiers, but in fact these do not go very
    far. Consider the following example with three different “qualifiers”:'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符记法有一个陷阱：它可能会暗示**`_Atomic`**修饰符与其他修饰符之间的相似性，但实际上它们并没有走得很远。考虑以下具有三个不同“修饰符”的例子：
- en: '[PRE126]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: So it is preferable not to fall into the habit of seeing atomics as qualifiers.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好不要养成将原子视为修饰符的习惯。
- en: '|  |'
  id: totrans-1192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.3
  id: totrans-1193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 18.3
- en: '*Use the specifier syntax* **`_Atomic`***`(`**`T`**`)`* *for atomic declarations.*'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用指定符语法* **`_Atomic`***`(`**`T`**`)`* *进行原子声明*。'
- en: '|  |'
  id: totrans-1195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Another restriction for **`_Atomic`** is that it cannot be applied to array
    types:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**`_Atomic`**的另一个限制是它不能应用于数组类型：
- en: '[PRE127]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Again, this differs from similarly “qualified” types:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与类似“修饰”的类型不同：
- en: '[PRE128]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '|  |'
  id: totrans-1200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.4
  id: totrans-1201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 18.4
- en: '*There are no atomic array types.*'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有原子数组类型*。'
- en: '|  |'
  id: totrans-1203
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Later on in this chapter, we will also see another tool that ensures linearizability:
    **`mtx_t`**. But atomic objects are by far the most efficient and easy to use.'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们还将看到另一个确保线性化的工具：**`mtx_t`**。但原子对象迄今为止是最有效率和易于使用的。
- en: '|  |'
  id: totrans-1205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.5
  id: totrans-1206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 18.5
- en: '*Atomic objects are the privileged tool to force the absence of race conditions.*'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子对象是强制消除竞争条件的特权工具*。'
- en: '|  |'
  id: totrans-1208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.2\. Race-free initialization and destruction
  id: totrans-1209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2\. 无竞争初始化和销毁
- en: 'For any data that is shared by threads, it is important that it is initially
    set into a well-controlled state before any concurrent access is made, and that
    it is never accessed after it eventually has been destroyed. For initialization,
    there are several possibilities, presented here in order of preference:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何由线程共享的数据，在并发访问之前将其初始化到一个良好控制的状态非常重要，并且在最终销毁后永远不应访问。对于初始化，有几种可能性，按优先顺序在此列出：
- en: Shared objects with static storage duration are initialized before any execution.
  id: totrans-1211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有静态存储持续时间的共享对象在执行任何操作之前都会被初始化。
- en: Shared objects with automatic or allocated storage duration can be properly
    initialized by the thread that creates them *before* any shared access occurs.
  id: totrans-1212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有自动或分配存储持续时间的共享对象可以由创建它们的线程在发生任何共享访问之前正确初始化。
- en: Shared objects with static storage duration where the information for dynamic
    initialization is
  id: totrans-1213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有静态存储持续时间的共享对象，其中包含动态初始化的信息
- en: Available at startup time should be initialized by **main** before any other
    thread is created.
  id: totrans-1214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建任何其他线程之前，应在启动时通过**main**初始化应可用的内容。
- en: Not available at startup time *must* be initialized with **call_once**.
  id: totrans-1215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动时不可用*必须*使用**call_once**进行初始化。
- en: 'So the latter, **call_once**, is only needed under very special circumstances:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，后者，**call_once**，仅在非常特殊的情况下才是必需的：
- en: '[PRE129]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Similar to **atexit**, **call_once** registers a callback function cb that
    should be called at exactly one point of the execution. The following gives a
    basic example of how this is supposed to be used:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 与**atexit**类似，**call_once**注册了一个回调函数cb，该函数应在执行中的确切一点被调用。以下是一个基本示例，说明如何使用它：
- en: '[PRE130]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Here we have a global variable (errlog) that needs dynamic initialization (calls
    to **time**, **srand**, **rand**, **snprintf**, **fopen**, and **setvbuf**) for
    its initialization. Any usage of that variable should be prefixed with a call
    to **call_once** that uses the same **`once_flag`** (here, errlog_flag) and the
    same callback function (here, errlog_fopen).
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个全局变量（errlog），它需要动态初始化（调用**time**、**srand**、**rand**、**snprintf**、**fopen**和**setvbuf**）以进行初始化。使用该变量的任何操作都应该以调用**call_once**开始，该调用使用相同的**`once_flag`**（在此处，errlog_flag）和相同的回调函数（在此处，errlog_fopen）。
- en: So in contrast to **atexit**, the callback is registered with a specific object,
    namely one of type **`once_flag`**. This opaque type guarantees enough state to
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与**atexit**相反，回调是与特定对象一起注册的，即**`once_flag`**类型之一。这种不透明类型保证了足够的状态来
- en: Determine whether a specific call to **call_once** is the very first among all
    threads
  id: totrans-1222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定特定的**call_once**调用是否是所有线程中的第一个
- en: Only call the callback then
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有那时才调用回调
- en: Never call the callback again
  id: totrans-1224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要再调用回调
- en: Hold back all other threads until the one-and-only call to the callback has
    terminated
  id: totrans-1225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待所有其他线程，直到唯一的回调调用完成
- en: Thus, any using thread can be sure that the object is correctly initialized
    without overwriting an initialization that another thread might have effected.
    All stream functions (but **fopen** and **fclose**) are race-free.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何使用线程都可以确信对象已正确初始化，而不会覆盖其他线程可能已执行过的初始化。所有流函数（但**fopen**和**fclose**）都是无竞争的。
- en: '|  |'
  id: totrans-1227
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.6
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 18.6
- en: '*A properly initialized* **`FILE*`** *can be used race-free by several threads.*'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '*正确初始化的* **`FILE*`** 可以被多个线程无竞争地使用。'
- en: '|  |'
  id: totrans-1230
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Here, *race-free* only means your program will always be in a well-defined state;
    it does not mean your file may not contain garbled output lines originating from
    different threads. To avoid that, you’d have to make sure a call to **fprintf**
    or similar always prints an entire line.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*无竞争*仅意味着你的程序将始终处于一个良好定义的状态；它并不意味着你的文件可能不包含来自不同线程的混乱输出行。为了避免这种情况，你必须确保**fprintf**或类似的调用始终打印整个行。
- en: '|  |'
  id: totrans-1232
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.7
  id: totrans-1233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 18.7
- en: '*Concurrent write operations should print entire lines at once.*'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发写操作应一次打印整个行。*'
- en: '|  |'
  id: totrans-1235
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Race-free destruction of objects can be much more subtle to organize, because
    the access to data for initialization and destruction is not symmetric. Whereas
    it often is easy to determine at the beginning of the lifetime of an object that
    (and when) there is a single user, seeing whether there are still other threads
    that use an object is difficult if we do not keep track of it.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的无竞争销毁可能更难以组织，因为初始化和销毁数据访问并不对称。虽然通常在对象的生存期开始时很容易确定只有一个用户（以及何时只有一个用户），但如果我们没有跟踪它，那么检查是否有其他线程使用该对象就变得困难。
- en: '|  |'
  id: totrans-1237
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.8
  id: totrans-1238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 18.8
- en: '*Destruction and deallocation of shared dynamic objects needs a lot of care.*'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '*共享动态对象的销毁和分配需要很多注意。*'
- en: '|  |'
  id: totrans-1240
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Imagine your precious hour-long execution that crashes just before the end,
    when it tries to write its findings into a file.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你宝贵的长达一小时的执行，就在结束时崩溃，试图将它的发现写入文件。
- en: In our B9 example, we had a simple strategy to ensure that the variable L could
    be safely used by all created threads. It was initialized before all threads were
    created, and it only ceased to exist after all created threads were joined.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 B9 示例中，我们有一个简单的策略来确保变量 L 可以安全地被所有创建的线程使用。它在所有线程创建之前初始化，并且在所有创建的线程都连接后才会停止存在。
- en: 'For the **`once_flag`** example, variable errlog, it is not so easy to see
    when we should close the stream from within one of our threads. The easiest way
    is to wait until we are sure there are no other threads around, when we are exiting
    the entire program execution:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **`once_flag`** 示例，变量 errlog，在从我们的线程之一关闭流时并不容易看到何时应该关闭。最简单的方法是等待我们确定没有其他线程存在，当我们退出整个程序执行时：
- en: '[PRE131]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This introduces another callback (errlog_fclose) that ensures that a last message
    is printed to the file before closing it. To ensure that this function is executed
    on program exit, it is registered with **atexit** as soon as the initializing
    function errlog_fopen is entered.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了另一个回调（errlog_fclose），确保在关闭文件之前打印最后一条消息。为了确保在初始化函数 errlog_fopen 进入时，该函数被注册到
    **atexit**，以确保在程序退出时执行此函数。
- en: 18.3\. Thread-local data
  id: totrans-1246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3\. 线程局部数据
- en: 'The easiest way to avoid race conditions is to strictly separate the data that
    our threads access. All other solutions, such as the atomics we have seen previously
    and the mutexes and condition variables that we will see later, are much more
    complex and much more expensive. The best way to access data local to threads
    is to use local variables:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 避免竞态条件的最简单方法是严格分离线程访问的数据。所有其他解决方案，例如我们之前看到的原子操作以及我们稍后将要看到的互斥锁和条件变量，都要复杂得多，成本也高得多。访问线程局部数据的最佳方式是使用局部变量：
- en: '|  |'
  id: totrans-1248
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.9
  id: totrans-1249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 18.9
- en: '*Pass thread-specific data through function arguments.*'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过函数参数传递线程特定数据。*'
- en: '|  |'
  id: totrans-1251
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1252
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.10
  id: totrans-1253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 18.10
- en: '*Keep thread-specific state in local variables.*'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '*将线程特定状态保存在局部变量中。*'
- en: '|  |'
  id: totrans-1255
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In case this is not possible (or maybe too complicated), a special storage class
    and a dedicated data type allow us to handle thread-local data. **`_Thread_local`**
    is a storage class specifier that forces a thread-specific copy of the variable
    that is declared as such. The header `threads.h` also provides a macro **`thread_local`**,
    which expands to the keyword.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不可能实现（或者可能过于复杂），特殊的存储类和专用数据类型允许我们处理线程局部数据。**`_Thread_local`** 是一个存储类指定符，它强制为声明为该类的变量创建一个线程特定的副本。头文件
    `threads.h` 也提供了一个宏 **`thread_local`**，它扩展为关键字。
- en: '|  |'
  id: totrans-1257
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<threads.h>`'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '`<threads.h>`'
- en: '|  |'
  id: totrans-1259
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1260
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.11
  id: totrans-1261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 18.11
- en: '*A* **`thread_local`** *variable has one separate instance for each thread.*'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个* **`thread_local`** *变量为每个线程都有一个单独的实例。*'
- en: '|  |'
  id: totrans-1263
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'That is, **`thread_local`** variables must be declared similar to variables
    with static storage duration: they are declared in file scope, or, if not, they
    must additionally be declared **`static`** (see [section 13.2](kindle_split_023.html#ch13lev1sec2),
    [table 13.1](kindle_split_023.html#ch13table01)). As a consequence, they cannot
    be initialized dynamically.'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 即，**`thread_local`** 变量必须像具有静态存储期的变量一样声明：它们在文件作用域中声明，或者如果不这样做，它们还必须额外声明 **`static`**（参见
    [第 13.2 节](kindle_split_023.html#ch13lev1sec2)，[表 13.1](kindle_split_023.html#ch13table01)）。因此，它们不能动态初始化。
- en: '|  |'
  id: totrans-1265
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.12
  id: totrans-1266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 18.12
- en: '*Use* **`thread_local`** *if initialization can be determined at compile time.*'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果初始化可以在编译时确定，请使用 **`thread_local`**。*'
- en: '|  |'
  id: totrans-1268
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If a storage class specifier is not sufficient because we have to do dynamic
    initialization and destruction, we can use *thread-specific storage*, **`tss_t`**.
    It abstracts the identification of thread-specific data into an opaque ID, referred
    to as key, and accessor functions to set or get the data:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储类指定符不足以进行动态初始化和销毁，我们可以使用 *线程特定存储*，**`tss_t`**。它将线程特定数据的标识抽象为一个不透明的ID，称为键，以及设置或获取数据的访问器函数：
- en: '[PRE132]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The function that is called at the end of a thread to destroy the thread-specific
    data is specified as a function pointer of type **`tss_dtor_t`** when the key
    is created:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建键时，指定在线程结束时调用以销毁线程特定数据的函数为类型 **`tss_dtor_t`** 的函数指针：
- en: '[PRE133]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 18.4\. Critical data and critical sections
  id: totrans-1273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4\. 关键数据和关键部分
- en: 'Other parts of the life structure cannot be protected as easily. They correspond
    to larger data, such as the board positions of the game. Perhaps you remember
    that arrays may not be specified with **`_Atomic`**; and even if we were able
    to do so using some tricks, the result would not be very efficient. Therefore,
    we not only declare the members Mv (for the game matrix) and visited (to hash
    already-visited constellations) but also a special member mtx:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 生命结构的其他部分不能轻易受到保护。它们对应于更大的数据，例如游戏的棋盘位置。你可能记得，数组不能使用**`_Atomic`**指定；即使我们能够使用一些技巧做到这一点，结果也不会很高效。因此，我们不仅声明了成员Mv（用于游戏矩阵）和visited（用于散列已访问的配置），还声明了一个特殊的成员mtx：
- en: '`life.h`'
  id: totrans-1275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`life.h`'
- en: '[PRE134]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This member mtx has the special type **`mtx_t`**, a *mutex* type (for *mutual
    exclusion*) that also comes with `threads.h`. It is meant to protect the *critical
    data*: Mv, while it is accessed in a well-identified part of the code, a *critical
    section*.'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个成员mtx具有特殊的类型**`mtx_t`**，一种*互斥锁*类型（用于*互斥排他*），它也包含在`threads.h`中。它的目的是保护*关键数据*：Mv，当它在代码的一个明确部分被访问时，一个*临界区*。
- en: '|  |'
  id: totrans-1278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<threads.h>`'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '`<threads.h>`'
- en: '|  |'
  id: totrans-1280
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The most simple use case for this mutex is in the center of the input thread,
    [listing 18.1](#ch18ex08) line 145, where two calls, **mtx_lock** and **mtx_unlock**,
    protect the access to the life data structure L.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 这种互斥锁最简单的用法是在输入线程的中心，[列表 18.1](#ch18ex08) 第145行，其中两个调用，**mtx_lock**和**mtx_unlock**，保护了对生命数据结构L的访问。
- en: Listing 18.1\. The input thread function of B9
  id: totrans-1282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.1\. B9的输入线程函数
- en: '[PRE135]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'This routine is mainly composed of the input loop, which, in turn, contains
    a big switch to dispatch on different characters that the user typed into the
    keyboard. Only two of the **`case`**s need this kind of protection: ''b'' and
    ''B'', which trigger the forced “birth” of a 3 3 cluster of cells around the current
    cursor position. In all other cases, we only interact with atomic objects, and
    so we can safely modify these.'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程主要由输入循环组成，它反过来包含一个大switch，用于处理用户键入键盘的不同字符。只有两个**`case`**需要这种保护：'b'和'B'，它们触发在当前光标位置周围的3
    3细胞群的强制“出生”。在所有其他情况下，我们只与原子对象交互，因此我们可以安全地修改这些。
- en: The effect of locking and unlocking the mutex is simple. The call to **mtx_lock**
    blocks execution of the calling thread until it can be guaranteed that no other
    thread is inside a critical section that is protected by the same mutex. We say
    that **mtx_lock** *acquires* the lock on the mutex and *holds* it, and that then
    **mtx_unlock** *releases* it. The use of mtx also provides linearizability similar
    to the use of atomic objects, as we saw earlier. A thread that has acquired a
    mutex M can rely on the fact that all operations that were done before other threads
    released the same mutex M have been effected.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定和解锁互斥锁的效果很简单。对**mtx_lock**的调用会阻塞调用线程的执行，直到可以保证没有其他线程处于由同一互斥锁保护的临界区中。我们说**mtx_lock***获取*互斥锁并*保持*它，然后**mtx_unlock***释放*它。使用mtx也提供了类似于使用原子对象的线性化，正如我们之前所看到的。一个获取了互斥锁M的线程可以依赖这样一个事实，即所有在其他线程释放相同的互斥锁M之前完成的操作都已经生效。
- en: '|  |'
  id: totrans-1286
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.13
  id: totrans-1287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 18.13
- en: '*Mutex operations provide linearizability.*'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '*互斥锁操作提供线性化。*'
- en: '|  |'
  id: totrans-1289
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'C’s mutex lock interfaces are defined as follows:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的互斥锁接口定义如下：
- en: '[PRE136]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The two other calls enable us to test (**mtx_trylock**) whether another thread
    already holds a lock (and thus we may avoid waiting) or to wait (**mtx_timedlock**)
    for a maximal period (and thus we may avoid blocking forever). The latter is allowed
    only if the mutex had been initialized as of being of the **`mtx_timed`** “type,”
    as discussed shortly.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个调用使我们能够测试（**mtx_trylock**）是否有其他线程已经持有锁（因此我们可以避免等待）或等待（**mtx_timedlock**）最长的时间（因此我们可以避免永远阻塞）。后者只有在互斥锁被初始化为**`mtx_timed`**“类型”时才允许，如稍后所述。
- en: 'There are two other calls for dynamic initialization and destruction:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个其他用于动态初始化和销毁的调用：
- en: '[PRE137]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Other than for more-sophisticated thread interfaces, the use of **mtx_init**
    is mandatory; there is no static initialization defined for **`mtx_t`**.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更复杂的线程接口外，使用**mtx_init**是强制性的；没有为**`mtx_t`**定义静态初始化。
- en: '|  |'
  id: totrans-1296
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 18.14
  id: totrans-1297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 18.14
- en: '*Every mutex must be initialized with* **mtx_init***.*'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个互斥锁都必须使用**mtx_init**进行初始化。*'
- en: '|  |'
  id: totrans-1299
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The second parameter of **mtx_init** specifies the “type” of the mutex. It
    must be one of these four values:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '**mtx_init**的第二个参数指定了互斥锁的“类型”。它必须是以下四个值之一：'
- en: '**`mtx_plain`**'
  id: totrans-1301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`mtx_plain`**'
- en: '**`mtx_timed`**'
  id: totrans-1302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`mtx_timed`**'
- en: '**`mtx_plain`**`|`**`mtx_recursive`**'
  id: totrans-1303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`mtx_plain`**`|`**`mtx_recursive`**'
- en: '**`mtx_timed`**`|`**`mtx_recursive`**'
  id: totrans-1304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`mtx_timed`**`|`**`mtx_recursive`**'
- en: As you probably have guessed, using **`mtx_plain`** versus **`mtx_timed`** controls
    the possibility to use **mtx_timedlock**. The additional property **`mtx_recursive`**
    enables us to call **mtx_lock** and similar functions successively several times
    for the same thread, without unlocking it beforehand.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，使用**`mtx_plain`**与**`mtx_timed`**控制了使用**mtx_timedlock**的可能性。额外的属性**`mtx_recursive`**使我们能够对同一线程连续多次调用**mtx_lock**和类似函数，而无需事先解锁。
- en: '|  |'
  id: totrans-1306
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.15
  id: totrans-1307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获18.15
- en: '*A thread that holds a nonrecursive mutex must not call any of the mutex lock
    functions for it.*'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '*持有非递归互斥锁的线程不得调用任何针对该互斥锁的互斥锁函数。*'
- en: '|  |'
  id: totrans-1309
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The name **`mtx_recursive`** indicates that it is mostly used for recursive
    functions that call **mtx_lock** on entry of a critical section and **mtx_unlock**
    on exit.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 名称**`mtx_recursive`**表明它主要用于在临界区入口调用**mtx_lock**并在退出时调用**mtx_unlock**的递归函数。
- en: '|  |'
  id: totrans-1311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.16
  id: totrans-1312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获18.16
- en: '*A recursive mutex is only released after the holding thread issues as many
    calls to* **mtx_unlock** *as it has acquired locks.*'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归互斥锁仅在持有线程对* **mtx_unlock** *的调用次数与其获取的锁的数量相同时才会释放。*'
- en: '|  |'
  id: totrans-1314
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1315
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.17
  id: totrans-1316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获18.17
- en: '*A locked mutex must be released before the termination of the thread.*'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '*在线程终止之前必须释放已锁定的互斥锁。*'
- en: '|  |'
  id: totrans-1318
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1319
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.18
  id: totrans-1320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获18.18
- en: '*A thread must only call* **mtx_unlock** *on a mutex that it holds.*'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程必须只在其持有的互斥锁上调用* **mtx_unlock** *。*'
- en: '|  |'
  id: totrans-1322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'From all of this, we can deduce a simple rule of thumb:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些中，我们可以得出一个简单的经验法则：
- en: '|  |'
  id: totrans-1324
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.19
  id: totrans-1325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获18.19
- en: '*Each successful mutex lock corresponds to exactly one call to* **mtx_unlock***.*'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个成功的互斥锁锁定对应于对* **mtx_unlock** *的精确一次调用。*'
- en: '|  |'
  id: totrans-1327
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Depending on the platform, a mutex may bind a system resource that is attributed
    each time **mtx_init** is called. Such a resource can be additional memory (such
    as a call to **malloc**) or some special hardware. Therefore, it is important
    to release such resources once a mutex reaches the end of its lifetime.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台的不同，互斥锁可能会绑定系统资源，每次调用**mtx_init**时都会分配该资源。这种资源可以是额外的内存（例如对**malloc**的调用）或某些特殊硬件。因此，一旦互斥锁达到其生命周期的末尾，释放这些资源就很重要。
- en: '|  |'
  id: totrans-1329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.20
  id: totrans-1330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获18.20
- en: '*A mutex must be destroyed at the end of its lifetime.*'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '*互斥锁必须在其生命周期的末尾被销毁。*'
- en: '|  |'
  id: totrans-1332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So in particular, **mtx_destroy** must be called
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，特别是，必须调用**mtx_destroy**。
- en: Before the scope of a mutex with automatic storage duration ends
  id: totrans-1334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有自动存储期的互斥锁的作用域结束之前
- en: And before the memory of a dynamically allocated mutex is freed
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在释放动态分配的互斥锁的内存之前
- en: 18.5\. Communicating through condition variables
  id: totrans-1336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.5. 通过条件变量进行通信
- en: While we have seen that the input didn’t need much protection against races,
    the opposite holds for the account task (see [listing 18.2](#ch18ex09)). Its whole
    job (carried out by the call to life_account) is to scan through the entire position
    matrix and to account for the number of life neighbors every position has.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经看到输入不需要太多的保护来防止竞态条件，但对于会计任务来说情况相反（参见[列表18.2](#ch18ex09)）。它的整个工作（通过调用life_account执行）是扫描整个位置矩阵，并为每个位置计算生命邻居的数量。
- en: Listing 18.2\. The account thread function of B9
  id: totrans-1338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.2. B9的会计线程函数
- en: '[PRE138]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Similarly, the update and draw threads mainly consist of one critical section
    inside an outer loop: see [listings 18.3](#ch18ex10) and [18.4](#ch18ex11), which
    perform the action. After that critical section, we also have a call to life_sleep
    that suspends the execution for a certain amount of time. This ensures that these
    threads are only run with a frequency that corresponds to the frame rate of our
    graphics.'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，更新和绘图线程主要包含一个外层循环内的一个临界区：参见[列表18.3](#ch18ex10)和[18.4](#ch18ex11)，它们执行操作。在那之后，我们还有一个调用life_sleep的调用，它暂停执行一段时间。这确保了这些线程只以与我们的图形帧率相对应的频率运行。
- en: Listing 18.3\. The update thread function of B9
  id: totrans-1341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.3. B9的更新线程函数
- en: '[PRE139]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Listing 18.4\. The draw thread function of B9
  id: totrans-1343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.4. B9的绘图线程函数
- en: '[PRE140]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: In all three threads, the critical section mostly covers the loop body. In addition
    to the proper computation, there is first a phase in these critical sections where
    the thread is actually paused until new computing is necessary. More precisely,
    for the accounting thread, there is a conditional loop that can only be left once
    either
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个线程中，临界区主要覆盖循环体。除了适当的计算外，在这些临界区中，线程实际上会暂停，直到需要新的计算。更确切地说，对于会计线程，有一个条件循环，只能在一次满足以下条件后离开：
- en: The game is finished, or
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束，或者
- en: Another thread has advanced an iteration count
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个线程已经增加了一个迭代计数
- en: 'The body of that loop is a call to life_wait, a function that suspends the
    calling thread for one second or until a specific event occurs:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 那个循环体的内容是对 life_wait 的调用，这是一个使调用线程暂停一秒钟或直到特定事件发生的函数：
- en: '`life.c`'
  id: totrans-1349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`life.c`'
- en: '[PRE141]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Its main ingredient is a call to **cnd_timedwait** that takes a *condition variable*
    of type **`cnd_t`**, a mutex, and an absolute time limit.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要成分是对 **cnd_timedwait** 的调用，该调用接受一个 *条件变量* 类型为 **`cnd_t`**、一个互斥锁和一个绝对时间限制。
- en: 'Such condition variables are used to identify a condition for which a thread
    might want to wait. Here, in our example, you have seen declarations for three
    such condition variable members of life: draw, acco, and upda. Each of these corresponds
    to test conditions that the drawing, the accounting, and the update need in order
    to proceed to perform their proper tasks. As we have seen, accounting has'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的条件变量用于标识线程可能想要等待的条件。在这里，在我们的例子中，你看到了 life 的三个此类条件变量成员的声明：draw、acco 和 upda。这些中的每一个都对应于绘图、会计和更新在执行其适当任务之前需要的测试条件。正如我们所看到的，会计有
- en: '`B9.c`'
  id: totrans-1353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE142]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Similarly, update and draw have
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，更新和绘制都有
- en: '`B9.c`'
  id: totrans-1356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE143]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: and
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '`B9.c`'
  id: totrans-1359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE144]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The conditions in each of these loops reflect the cases when there is work to
    do for the tasks. Most importantly, we have to be sure not to confound the *condition
    variable*, which serves as a sort of identification of the condition, and the
    *condition expression*. A call to a wait function for **`cnd_t`** may return although
    nothing concerning the condition expression has changed.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 这些循环中的条件反映了有工作要做的情况。最重要的是，我们必须确保不要混淆 *条件变量*，它作为条件的一种标识，以及 *条件表达式*。对 **`cnd_t`**
    的等待函数的调用可能会返回，尽管与条件表达式无关的内容没有改变。
- en: '|  |'
  id: totrans-1362
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.21
  id: totrans-1363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得第 18.21 条经验
- en: '*On return from a* **`cnd_t`** *wait, the expression must be checked again.*'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '*从 *`cnd_t`* *等待返回后，必须再次检查该表达式。*'
- en: '|  |'
  id: totrans-1365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Therefore, all our calls to life_wait are placed inside loops that check the
    condition expression.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们所有的 life_wait 调用都放在检查条件表达式的循环中。
- en: This may be obvious in our example, since we are using **cnd_timedwait** under
    the hood, and the return might just be because the call timed out. But even if
    we use the untimed interface for the wait condition, the call might return early.
    In our example code, the call might eventually return when the game is over, so
    our condition expression always contains a test for L`->`finished.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这可能是显而易见的，因为我们底层使用的是 **cnd_timedwait**，返回可能只是因为调用超时。但即使我们使用无计时等待条件的接口，调用也可能提前返回。在我们的示例代码中，当游戏结束时，调用可能会最终返回，因此我们的条件表达式始终包含对
    L`->`finished 的测试。
- en: '**`cnd_t`** comes with four principal control interfaces:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '**`cnd_t`** 提供了四个主要控制接口：'
- en: '[PRE145]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The first works analogously to the second, but there is no timeout, and a thread
    might never come back from the call if the **`cnd_t`** parameter is never signaled.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个与第二个类似，但没有超时，如果 **`cnd_t`** 参数从未被信号，线程可能永远不会从调用中返回。
- en: '**cnd_signal** and **cnd_broadcast** are on the other end of the control. We
    saw the first applied in input_thread and account_thread. They ensure that a thread
    (**cnd_signal**) or all threads (**cnd_broadcast**) that are waiting for the corresponding
    condition variable are woken up and return from the call to **cnd_wait** or **cnd_timedwait**.
    For example, the input task *signals* the drawing task that something in the game
    constellation has changed and the board should be redrawn:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '**cnd_signal** 和 **cnd_broadcast** 在控制的另一端。我们在 input_thread 和 account_thread
    中看到了第一个的应用。它们确保等待相应条件变量的线程（**cnd_signal**）或所有线程（**cnd_broadcast**）被唤醒并从 **cnd_wait**
    或 **cnd_timedwait** 的调用中返回。例如，输入任务 *signal* 绘图任务，表明游戏配置中有变化，应该重新绘制棋盘：'
- en: '`B9.c`'
  id: totrans-1372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9.c`'
- en: '[PRE146]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The **`mtx_t`** parameter to the wait-condition functions has an important role.
    The mutex must be held by the calling thread to the wait function. It is temporarily
    released during the wait, so other threads can do their job to assert the condition
    expression. The lock is reacquired just before returning from the wait call so
    then the critical data can safely be accessed without races.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 等待条件函数的 **`mtx_t`** 参数在循环体中扮演着重要的角色。互斥锁必须由调用等待函数的线程持有。在等待期间，锁被临时释放，这样其他线程就可以执行它们的工作以断言条件表达式。在等待调用返回之前，锁被重新获取，这样就可以安全地访问关键数据，而不会发生竞争。
- en: '[Figure 18.3](#ch18fig03) shows a typical interaction between the input and
    draw threads, the mutex and the corresponding condition variable. It shows that
    six function calls are involved in the interaction: four for the respective critical
    sections and the mutex, and two for the condition variable.'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18.3](#ch18fig03)展示了输入线程和绘制线程、互斥锁以及相应的条件变量之间的典型交互。它显示在交互中涉及了六个函数调用：四个用于各自的临界区和互斥锁，两个用于条件变量。'
- en: Figure 18.3\. Control flow managed by mutex L->mtx and condition variable L->draw
    between the input and draw threads. Critical sections are shaded with grey. The
    condition variable is associated with the mutex until the waiter has reacquired
    the mutex.
  id: totrans-1376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.3. 由互斥锁L->mtx和条件变量L->draw管理的输入和绘制线程之间的控制流程。临界区用灰色阴影表示。条件变量与互斥锁关联，直到等待者重新获取互斥锁。
- en: '![](18fig03_alt.jpg)'
  id: totrans-1377
  prefs: []
  type: TYPE_IMG
  zh: '![](18fig03_alt.jpg)'
- en: The coupling between a condition variable and the mutex in the wait call should
    be handled with care.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待调用中，条件变量与互斥锁之间的耦合应该小心处理。
- en: '|  |'
  id: totrans-1379
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.22
  id: totrans-1380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结18.22
- en: '*A condition variable can only be used simultaneously with one mutex.*'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件变量只能与一个互斥锁同时使用*。'
- en: '|  |'
  id: totrans-1382
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: But it is probably best practice to never change the mutex that is used with
    a condition variable.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 但最好的做法可能是永远不要更改与条件变量一起使用的互斥锁。
- en: 'Our example also shows that there can be many condition variables for the same
    mutex: we use our mutex with three different condition variables at the same time.
    This will be imperative in many applications, since the condition expressions
    under which threads will be accessing the same resource depend on their respective
    roles.'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子还表明，对于同一个互斥锁可以有多个条件变量：我们同时使用三个不同的条件变量与我们的互斥锁。这在许多应用中将是强制性的，因为线程将访问相同资源的条件表达式取决于它们各自的角色。
- en: In situations where several threads are waiting for the same condition variable
    and are woken up with a call to **cnd_broadcast**, they will not wake up all at
    once, but one after another as they reacquire the mutex.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程等待同一个条件变量并被**cnd_broadcast**调用唤醒的情况下，它们不会同时醒来，而是一个接一个地，随着它们重新获取互斥锁。
- en: Similar to a mutex’s, C’s condition variables may bind precious system resources.
    So they must be initialized dynamically, and they should be destroyed at the end
    of their lifetime.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 与互斥锁类似，C的条件变量可能会绑定宝贵的系统资源。因此，它们必须动态初始化，并在其生命周期结束时销毁。
- en: '|  |'
  id: totrans-1387
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.23
  id: totrans-1388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结18.23
- en: '*A* **`cnd_t`** *must be initialized dynamically.*'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '*`cnd_t`* 必须动态初始化。'
- en: '|  |'
  id: totrans-1390
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1391
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.24
  id: totrans-1392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结18.24
- en: '*A* **`cnd_t`** *must be destroyed at the end of its lifetime.*'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '*`cnd_t`* 必须在其生命周期结束时销毁。'
- en: '|  |'
  id: totrans-1394
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The interfaces for these are straightforward:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口很简单：
- en: '[PRE147]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 18.6\. More sophisticated thread management
  id: totrans-1397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.6. 更复杂的线程管理
- en: 'Having just seen thread creation and joining in **main**, we may have the impression
    that threads are somehow hierarchically organized. But actually they are not:
    just knowing the ID of a thread, its **`thrd_t`**, is sufficient to deal with
    it. There is only one thread with exactly one special property.'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚刚看到在**main**中创建和连接线程之后，我们可能会产生这样的印象，即线程以某种方式是有层次组织的。但实际上并非如此：仅仅知道线程的ID，即其**`thrd_t`**，就足以处理它。只有一个线程具有一个特殊属性。
- en: '|  |'
  id: totrans-1399
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.25
  id: totrans-1400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结18.25
- en: '*Returning from* **main** *or calling* **exit** *terminates all threads.*'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* **main** *返回* 或 *调用* **exit** *将终止所有线程*。'
- en: '|  |'
  id: totrans-1402
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If we want to terminate **main** after we have created other threads, we have
    to take some precautions so we do not terminate the other threads preliminarily.
    An example of such a strategy is given in the following modified version of B9’s
    **main**:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在创建其他线程之后想要终止**main**，我们必须采取一些预防措施，以确保我们不提前终止其他线程。以下是对B9的**main**修改后的示例，展示了这种策略：
- en: '`B9-detach.c`'
  id: totrans-1404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9-detach.c`'
- en: '[PRE148]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: First, we have to use the function **thrd_exit** to terminate **main**. Other
    than a **`return`**, this ensures that the corresponding thread just terminates
    without impacting the other threads. Then, we have to make L a global variable,
    because we don’t want its life to end when **main** terminates. To arrange for
    the necessary cleanup, we also install an **atexit** handler. The modified control
    flow is shown in [figure 18.4](#ch18fig04).
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用函数**thrd_exit**来终止**main**。除了**`return`**之外，这确保了相应的线程仅终止，而不会影响其他线程。然后，我们必须将L设为全局变量，因为我们不希望它的生命周期随着**main**的终止而结束。为了安排必要的清理，我们还安装了一个**atexit**处理程序。修改后的控制流程如图[18.4](#ch18fig04)所示。
- en: Figure 18.4\. Control flow of the five threads of `B9-detach`. The thread that
    returns last executes the atexit handlers.
  id: totrans-1407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 18.4\. `B9-detach` 的五个线程的控制流程。最后返回的线程执行 atexit 处理程序。
- en: '![](18fig04_alt.jpg)'
  id: totrans-1408
  prefs: []
  type: TYPE_IMG
  zh: '![](18fig04_alt.jpg)'
- en: 'As a consequence of this different management, the four threads that are created
    are never actually joined. Each thread that is dead but is never joined eats up
    some resources that are kept until the end of the execution. Therefore, it is
    good coding style to tell the system that a thread will never be joined: we say
    that we *detach* the corresponding thread. We do that by inserting a call to **thrd_detach**
    at the beginning of the thread functions. We also start the account thread from
    there, and not from **main** as we did previously.'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种不同的管理方式，创建的四个线程实际上从未真正连接。每个已经死亡但从未连接的线程都会消耗一些资源，这些资源会保留到执行结束。因此，一个好的编码风格是告诉系统一个线程永远不会连接：我们说我们
    *分离* 相应的线程。我们通过在线程函数的开始处插入对 **thrd_detach** 的调用来实现这一点。我们也在那里启动账户线程，而不是像以前那样从 **main**
    中启动。
- en: '`B9-detach.c`'
  id: totrans-1410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`B9-detach.c`'
- en: '[PRE149]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'There are six more functions that can be used to manage threads, of which we
    already met **thrd_current**, **thrd_exit**, and **thrd_detach**:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个更多函数可以用来管理线程，其中我们已经遇到了 **thrd_current**、**thrd_exit** 和 **thrd_detach**：
- en: '[PRE150]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: A running C program may have many more threads than it has processing elements
    at its disposal. Nevertheless, a runtime system should be able to *schedule* the
    threads smoothly by attributing time slices on a processor. If a thread actually
    has no work to do, it should not demand a time slice and should leave the processing
    resources to other threads that might need them. This is one of the main features
    of the control data structures **`mtx_t`** and **`cnd_t`**.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正在运行的 C 程序可能拥有的线程比它可用的处理元素要多得多。尽管如此，运行时系统应该能够通过在处理器上分配时间片来平滑地调度线程。如果一个线程实际上没有工作要做，它不应该要求时间片，而应该将处理资源留给可能需要它们的其他线程。这是控制数据结构
    **`mtx_t`** 和 **`cnd_t`** 的主要特性之一。
- en: '|  |'
  id: totrans-1415
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 18.26
  id: totrans-1416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取走 18.26
- en: '*While blocking on* **`mtx_t`** *or* **`cnd_t`***, a thread frees processing
    resources.*'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '*在阻塞于* **`mtx_t`** *或* **`cnd_t`*** 时，一个线程会释放处理资源。'
- en: '|  |'
  id: totrans-1418
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If this is not enough, there are two other functions that can suspend execution:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，还有两个其他函数可以挂起执行：
- en: '**thrd_sleep** allows a thread to suspend its execution for a certain time,
    such that hardware resources of the platform can be used by other threads in the
    meantime.'
  id: totrans-1420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**thrd_sleep** 允许一个线程暂停其执行一段时间，这样平台的其他线程可以在其间使用硬件资源。'
- en: '**thrd_yield** just terminates the current time slice and waits for the next
    processing opportunity.'
  id: totrans-1421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**thrd_yield** 只终止当前时间片并等待下一个处理机会。'
- en: '|  |'
  id: totrans-1422
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Parallel sorting with threads**'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用线程进行并行排序**'
- en: Can you implement a parallel algorithm for sorting using two threads that builds
    on your merge sort implementation ([challenges 1](kindle_split_011.html#ch03sb01)
    and [14](kindle_split_021.html#ch11sb03))?
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否实现一个基于你的归并排序实现（[挑战 1](kindle_split_011.html#ch03sb01) 和 [14](kindle_split_021.html#ch11sb03)）的并行排序算法，使用两个线程？
- en: That is, a merge sort that cuts the input array in half and sorts each half
    in its own thread, and then merges the two halves sequentially as before. Use
    different sequential sorting algorithms as a base inside each of the two threads.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，一个归并排序，它将输入数组分成两半，并在各自的线程中排序每一半，然后像以前一样按顺序合并这两个半部分。在每个线程内部使用不同的顺序排序算法作为基础。
- en: Can you generalize this parallel sorting to *P* threads, where *P* = 2*^k* for
    *k* = 1, 2, 3, 4, where *k* is given on the command line?
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否将这个并行排序推广到 *P* 线程，其中 *P* = 2^k，对于 *k* = 1, 2, 3, 4，其中 *k* 在命令行上给出？
- en: Can you measure the speedup that you obtained as a result of your parallelization?
    Does it match the number of cores that your test platform has?
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否测量你并行化所获得的速度提升？它是否与你的测试平台的核心数相匹配？
- en: '|  |'
  id: totrans-1428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-1429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: It is important to ensure that shared data is properly initialized before it
    is accessed concurrently. This is best done at compile time or from **main**.
    As a last resort, **call_once** can be used to trigger the execution of an initializing
    function exactly once.
  id: totrans-1430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并发访问之前确保共享数据被正确初始化是很重要的。这最好在编译时或在 **main** 中完成。作为最后的手段，可以使用 **call_once** 来触发初始化函数的执行，确保只执行一次。
- en: Threads should preferably only operate on data that is local, through function
    arguments and automatic variables. If unavoidable, thread-specific data can also
    be created as **`thread_local`** objects or via **tss_create**. Use the latter
    only when you need dynamic construction and destruction of the variable.
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程应优先只操作本地数据，通过函数参数和自动变量。如果不可避免，也可以创建**`thread_local`**对象或通过**tss_create**来创建线程特定的数据。只有在需要变量的动态构建和销毁时才使用后者。
- en: Small critical data that is shared between threads should be specified as **`_Atomic`**.
  id: totrans-1432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程之间共享的小关键数据应指定为**`_Atomic`**。
- en: Critical sections (code paths that operate on unprotected shared data) must
    be protected, usually by using a **`mtx_t`** mutex.
  id: totrans-1433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临界区（操作未受保护共享数据的代码路径）必须受到保护，通常是通过使用**`mtx_t`**互斥锁。
- en: Conditional processing dependencies between threads are modeled with **`cnd_t`**
    condition variables.
  id: totrans-1434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程之间的条件处理依赖通过**`cnd_t`**条件变量进行建模。
- en: Thread code that does not have the ability to rely on a post mortem cleanup
    by **main** should use **thrd_detach** and place all its cleanup code in **atexit**
    and/or **at_quick_exit** handlers.
  id: totrans-1435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有能力依赖**main**进行事后清理的线程代码应使用**thrd_detach**，并将所有清理代码放在**atexit**和/或**at_quick_exit**处理程序中。
- en: Chapter 19\. Atomic access and memory consistency
  id: totrans-1436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第19章。原子访问和内存一致性
- en: This chapter covers
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding the “happened before” relation
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解“发生之前”关系
- en: C library calls that provide synchronization
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供同步的C库调用
- en: Maintaining sequential consistency
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护顺序一致性
- en: Working with other consistency models
  id: totrans-1441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他一致性模型一起工作
- en: 'We will complete this level with a description of concepts that form an important
    part of the C architecture model and are therefore a must for experienced programmers.
    Try to comprehend this last chapter to increase your understanding of how things
    work, not necessarily to improve your operational skills. Even though we will
    not go into all the glorious details,^([[1](#ch19fn01)]) things can get a bit
    bumpy: please remain seated and buckle up.'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过描述构成C架构模型重要部分的概念来完成这一级，因此对于经验丰富的程序员来说是必须的。尝试理解最后一章，以增加你对事物工作方式的理解，而不仅仅是提高你的操作技能。即使我们不会深入所有辉煌的细节，^([[1](#ch19fn01)])事情可能会变得有点颠簸：请坐好并系好安全带。
- en: ¹
  id: totrans-1443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will put aside **`memory_order_consume`** consistency and thus the dependency-ordered
    before relation.
  id: totrans-1445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将把**`memory_order_consume`**一致性以及依赖顺序关系放在一边。
- en: 'If you review the pictures of control flow that we have seen throughout the
    previous chapters, you see that the interaction of different parts of a program
    execution can get quite complicated. We have different levels of concurrent access
    to data:'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾我们在前几章中看到的控制流图，你会发现程序执行不同部分的交互可能会相当复杂。我们具有不同级别的数据并发访问：
- en: Plain old straightforward C code is only apparently sequential. Visibility of
    changes is only guaranteed between very specific points of the execution, sequence
    points, for direct data dependencies, and for the completion of function calls.
    Modern platforms take more and more advantage of the provided slack and perform
    unsequenced operations intermixed or in parallel in multiple execution pipelines.
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单直接的C代码表面上似乎是顺序的。变化的可见性仅在执行中的非常具体的点、序列点、直接数据依赖以及函数调用完成时得到保证。现代平台越来越多地利用提供的灵活性，在多个执行管道中混合或并行执行非顺序操作。
- en: Long jumps and signal handlers are executed sequentially, but effects of stores
    may get lost on the way.
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长跳转和信号处理程序是顺序执行的，但存储的效果可能会在途中丢失。
- en: Those accesses to atomic objects that we have seen so far warrant visibility
    of their changes everywhere and consistently.
  id: totrans-1449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的对原子对象的访问要求其变化在所有地方和始终可见。
- en: Threads run concurrently side by side and jeopardize data consistency if they
    don’t regulate their shared access to data. In addition to access to atomic objects,
    they can also be synchronized through calls to functions, such as **thrd_join**
    or **mtx_lock**.
  id: totrans-1450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程并排同时运行，如果它们不调节对数据的共享访问，就会危及数据一致性。除了对原子对象的访问外，它们还可以通过调用函数（如**thrd_join**或**mtx_lock**）进行同步。
- en: 'But access to memory is not the only thing a program does. In fact, the abstract
    state of a program execution consists of the following:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 但程序所做的不仅仅是访问内存。事实上，程序执行的抽象状态由以下内容组成：
- en: '*Points of execution* (one per thread)'
  id: totrans-1452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行点*（每个线程一个）'
- en: '*Intermediate values* (of computed expressions or evaluated objects)'
  id: totrans-1453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中间值*（计算表达式或评估对象的值）'
- en: '*Stored values*'
  id: totrans-1454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储值*'
- en: '*Hidden state*'
  id: totrans-1455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隐藏状态*'
- en: Changes to this state are usually described as
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 对此状态的更改通常描述为
- en: '***Jumps:*** Change the point of execution (short jumps, long jumps, and function
    calls)'
  id: totrans-1457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***跳转：*** 改变执行点（短跳转、长跳转和函数调用）'
- en: '***Value computation:*** Changes intermediate values'
  id: totrans-1458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***值计算：*** 改变中间值'
- en: '***Side effects:*** Store values or do IO'
  id: totrans-1459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***副作用：*** 存储值或进行 I/O 操作'
- en: Or they can affect hidden state such as the lock state of a **`mtx_t`** or the
    initialization state of a **`once_flag`**, or set or clear operations on an **`atomic_flag`**.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以影响隐藏状态，如 **`mtx_t`** 的锁状态或 **`once_flag`** 的初始化状态，或者对 **`atomic_flag`**
    的设置或清除操作。
- en: We summarize all these possible changes of the abstract state with the term
    of *effect*.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 *效果* 这个术语来总结所有这些可能的抽象状态的改变。
- en: '|  |'
  id: totrans-1462
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.1
  id: totrans-1463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 19.1
- en: '*Every evaluation has an effect.*'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: '*每次评估都有一个效果*。'
- en: '|  |'
  id: totrans-1465
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This is because any evaluation has the concept of a next such evaluation that
    will be performed after it. Even an expression like
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为任何评估都有一个概念，即在其之后将执行的下一次评估。即使是像
- en: '[PRE151]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: that drops the intermediate value sets the point of execution to the next statement,
    and thus the abstract state has changed.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表达式，丢弃了中间值，将执行点设置到下一个语句，因此抽象状态已经改变。
- en: In a complicated context, it will be difficult to argue about the actual abstract
    state of an execution in a given moment. Generally, the entire abstract state
    of a program execution is not even observable; and in many cases, the concept
    of an overall abstract state is not well defined. This is because we actually
    don’t know what *moment* means in this context. In a multithreaded execution that
    is performed on several physical compute cores, there is no real notion of a reference
    time between them. So generally, C does not even make the assumption that an overall
    fine-grained notion of time exists between different threads.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的环境中，将很难争论给定时刻执行的真正抽象状态。通常，整个程序执行的抽象状态甚至不可观察；在许多情况下，整体抽象状态的概念定义得并不好。这是因为我们实际上不知道在这个上下文中
    *时刻* 的含义。在多个物理计算核心上执行的多线程执行中，它们之间没有真正的参考时间概念。因此，C 甚至不假设不同线程之间存在整体细粒度的时间概念。
- en: As an analogy, think of two threads A and B as events that happen on two different
    planets that are orbiting with different speeds around a star. Times on these
    planets (threads) are relative, and synchronization between them takes place only
    when a signal that is issued from one planet (thread) reaches the other. The transmission
    of the signal takes time by itself, and when the signal reaches its destination,
    its source has moved on. So the mutual knowledge of the two planets (threads)
    is always partial.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个类比，想象两个线程 A 和 B 是发生在两个不同行星上的事件，这两个行星以不同的速度围绕一颗恒星运行。这些行星（线程）上的时间（时间）是相对的，它们之间的同步只有在来自一个行星（线程）发出的信号到达另一个行星时才会发生。信号的传输本身就需要时间，当信号到达目的地时，其来源已经移动。因此，两个行星（线程）之间的相互知识总是部分的。
- en: Figure 19.1\. Two threads that synchronize via an atomic. The circles present
    the modifications of object x. The bars below the threads represent information
    about the state of *A*, and those above represent information about the state
    of *B*.
  id: totrans-1471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 19.1. 通过原子同步的两个线程。圆圈表示对象 x 的修改。线程下面的条形表示 *A* 的状态信息，上面的表示 *B* 的状态信息。
- en: '![](19fig01_alt.jpg)'
  id: totrans-1472
  prefs: []
  type: TYPE_IMG
  zh: '![](19fig01_alt.jpg)'
- en: 19.1\. The “happened before” relation
  id: totrans-1473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1. “发生之前”关系
- en: If we want to argue about a program’s execution (its correctness, its performance,
    and so on), we need to have enough of that *partial knowledge* about the state
    of all threads, *and* we have to know how we can stitch that partial knowledge
    together to get a coherent view of the whole.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要争论一个程序的执行（其正确性、性能等），我们需要足够了解所有线程的状态的*部分知识*，*并且*我们必须知道如何将这些部分知识拼接起来，以获得对整个程序的一致视图。
- en: Therefore, we will investigate a relation that was introduced by Lamport [[1978](kindle_split_036.html#bib11)].
    In C standard terms, it is the *happened before* relation between two evaluations
    *E* and *F* , denoted by *F → E*. This is a property between events that we observe
    *a posteriori*. Fully spelled out, it would perhaps be better called the *knowingly
    happened before* relation, instead.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将研究Lamport [[1978](kindle_split_036.html#bib11)] 提出的一个关系。在C标准术语中，它是两个评估
    *E* 和 *F* 之间的 *发生之前* 关系，表示为 *F → E*。这是我们观察到的 *事后* 事件之间的属性。完全展开，它可能更准确地被称为 *已知发生之前*
    关系。
- en: 'One part of it consists of evaluations in the same thread that are related
    by the already-introduced sequenced-before relation:'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一部分包括同一线程中相关的评估，这些评估通过已经引入的 sequenced-before 关系相关联：
- en: '|  |'
  id: totrans-1477
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 19.2
  id: totrans-1478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 19.2
- en: '*If F is sequenced before E, then F → E.*'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果 F 在 E 之前进行排序，则 F → E*。'
- en: '|  |'
  id: totrans-1480
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To see that, let us revisit [listing 18.1](kindle_split_029.html#ch18ex08) from
    our input thread. Here, the assignment to comman`d[0]` is sequenced before the
    **`switch`** statement. Therefore, we are sure that all cases in the **`switch`**
    statement are executed *after* the assignment, or at least that they will be *perceived*
    as happening later. For example, when passing command to the nested function calls
    below **ungetc**, we are sure this will provide the modified value. All of this
    can be deduced from C’s grammar.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们重新审视我们的输入线程中的 [列表 18.1](kindle_split_029.html#ch18ex08)。在这里，对 `command[0]`
    的赋值在 `switch` 语句之前进行排序。因此，我们可以确定 `switch` 语句中的所有情况都是在赋值之后执行的，或者至少它们会被 *感知* 为在之后发生。例如，当将命令传递给
    **ungetc** 下的嵌套函数调用时，我们可以确定这将提供修改后的值。所有这些都可以从 C 的语法中推断出来。
- en: 'Between threads, the ordering of events is provided by *synchronization*. There
    are two types of synchronization: the first is implied by operations on atomics,
    and the second by certain C library calls. Let us first look into the case of
    atomics. An atomic object can be used to synchronize two threads, if one thread
    writes a value and another thread reads the value that was written.'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程之间，事件的排序由 *同步* 提供。有两种类型的同步：第一种是由原子操作隐含的，第二种是由某些 C 库调用提供的。让我们首先看看原子的情况。如果一个线程写入一个值，另一个线程读取被写入的值，那么原子对象可以用来同步两个线程。
- en: Operations on atomics are guaranteed to be locally consistent; see [figure 19.1](#ch19fig01).
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作保证局部一致性；参见 [图 19.1](#ch19fig01)。
- en: '|  |'
  id: totrans-1484
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 19.3
  id: totrans-1485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 19.3
- en: '*The set of modifications of an atomic object* *`X`* *are performed in an order
    that is consistent with the sequenced-before relation of any thread that deals
    with* *`X`**.*'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子对象 *`X`* 的修改集 *`X`* 是按照处理 *`X`* 的任何线程的 sequenced-before 关系进行的，顺序是一致的。'
- en: '|  |'
  id: totrans-1487
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This sequence is called the *modification order* of X. For example, for the
    atomic x in the figure, we have six modifications: the initialization (value `11`),
    two increments, and three assignments. The C standard guarantees that each of
    the two threads A and B perceives all changes to x in an order that is consistent
    with this modification order.'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列被称为 X 的 *修改顺序*。例如，对于图中的原子 x，我们有六个修改：初始化（值 `11`）、两次增加和三次赋值。C 标准保证两个线程 A 和
    B 都以与这种修改顺序一致的方式感知 x 的所有更改。
- en: In the example in the figure, we have only two synchronizations. First, thread
    B synchronizes with A at the end of its `-`-x operation, because here it has read
    (and modified) the value `31` that A wrote. The second synchronization occurs
    when A reads the value `5` that B wrote and stores it into y.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 在图例的例子中，我们只有两个同步点。首先，线程 B 在其 `-`-x 操作结束时与线程 A 同步，因为在这里它读取（并修改）了 A 写入的值 `31`。第二个同步发生在
    A 读取 B 写入的值 `5`并将其存储到 y 中时。
- en: As another example, let us investigate the interplay between the input thread
    ([Listing 18.1](kindle_split_029.html#ch18ex08)) and the account thread ([Listing
    18.2](kindle_split_029.html#ch18ex09)). Both read and modify the field finished
    in different places. For the simplicity of the argument, let us assume that there
    is no other place than in these two functions where finished is modified.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们研究输入线程（[列表 18.1](kindle_split_029.html#ch18ex08)）和账户线程（[列表 18.2](kindle_split_029.html#ch18ex09)）之间的相互作用。它们在不同的地方读取和修改字段
    finished。为了论证的简单性，让我们假设 finished 只在这两个函数中被修改，没有其他地方。
- en: 'The two threads will only synchronize via this atomic object if either of them
    modifies it: that is, writes the value **`true`** into it. This can happen under
    two circumstances:'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程只有在其中之一修改它的情况下才会通过这个原子对象进行同步：也就是说，将值 **`true`** 写入其中。这可以在两种情况下发生：
- en: The input thread encounters an end-of-file condition, either when **feof**`(`**`stdin`**`)`
    returns **`true`** or if the case **`EOF`** is encountered. In both cases, the
    **`do`** loop terminates, and the code after the label FINISH is executed.
  id: totrans-1492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入线程遇到文件结束条件，无论是当 **feof**`(`**`stdin`**`)` 返回 **`true`**，还是遇到 **`EOF`** 情况。在这两种情况下，**`do`**
    循环终止，并执行标签 FINISH 之后的代码。
- en: The account thread detects that the number of permitted repetitions is exceeded
    and sets finished to **`true`**.
  id: totrans-1493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户线程检测到允许重复的次数超过限制，并将 finished 设置为 **`true`**。
- en: These events are not exclusive, but using an atomic object guarantees that one
    of the two threads will succeed first in writing to finished.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件不是互斥的，但使用原子对象可以保证两个线程中有一个会首先成功写入到已完成的变量。
- en: 'If the input thread writes first, the account thread may read the modified
    value of finished in the evaluations of one of its **`while`** loops. This read
    synchronizes: that is, the write event in the input thread is known to have happened
    before such a read. Any modifications the input thread made before the write operation
    are now visible to the account thread.'
  id: totrans-1495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入线程先写入，账户线程可能会在其一个**`while`**循环的评估中读取已完成的修改值。这次读取是同步的：也就是说，输入线程中的写入事件已知在这次读取之前已经发生。输入线程在写入操作之前所做的任何修改现在都对账户线程可见。
- en: If the account thread writes first, the input thread may read the modified value
    in the **`while`** of its **`do`** loop. Again, this read synchronizes with the
    write and establishes a “happened before” relation, and all modifications made
    by the account thread are visible to the input thread.
  id: totrans-1496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果账户线程先写入，输入线程可能会在其**`do`**循环的**`while`**中读取修改后的值。再次强调，这次读取与写入同步，并建立了一个“先发生”的关系，账户线程所做的所有修改都对输入线程可见。
- en: 'Observe that these synchronizations are oriented: each synchronization between
    threads has a “writer” and a “reader” side. We attach two abstract properties
    to operations on atomics and to certain C library calls that are called *release*
    semantics (on the writer side), *acquire* semantics (for a reader), or *acquire-release*
    semantics (for a reader-writer). C library calls with such synchronization properties
    will be discussed a bit later.'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些同步是有方向的：线程之间的每个同步都有一个“写入方”和“读取方”。我们将两个抽象属性附加到原子操作和某些称为释放语义（在写入方）、获取语义（在读取方）或获取-释放语义（在读取-写入方）的C库调用上。稍后我们将讨论具有这种同步属性的C库调用。
- en: All operations on atomics that we have seen so far and that modify the object
    are required to have release semantics, and all that read have acquire semantics.
    Later we will see other atomic operations that have relaxed properties.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的、修改对象的原子操作都必须具有释放语义，而所有读取操作都具有获取语义。稍后我们将看到具有放松属性的其它原子操作。
- en: '|  |'
  id: totrans-1499
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 19.4
  id: totrans-1500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 19.4
- en: '*An acquire operation E in a thread T[E] synchronizes with a release operation
    F if another thread T[F] if E reads the value that F has written.*'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果线程T[E]中的获取操作E与另一个线程T[F]中的释放操作F同步，那么如果E读取了F写入的值。*'
- en: '|  |'
  id: totrans-1502
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The idea of the special construction with acquire and release semantics is to
    force the visibility of effects across such operations. We say that an effect
    *X* is *visible* at evaluation *E* if we can consistently replace *E* with any
    appropriate read operation or function call that uses the state affected by *X*.
    For example, in [figure 19.1](#ch19fig01) the effects that A produces before its
    x `= 31` operation are symbolized by the bar below the thread. They are visible
    to B once B has completed the `-`-x operation.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 使用获取和释放语义的特殊构造的目的是强制这些操作之间的效应可见性。我们说，如果我们可以一致地用任何适当的读取操作或使用受效应X影响的状态的函数调用替换评估E，那么效应X在评估E时是可见的。例如，在[图19.1](#ch19fig01)中，A在x
    `= 31`操作之前产生的效应用线程下方的横线表示。一旦B完成`-`x操作，这些效应对B就是可见的。
- en: '|  |'
  id: totrans-1504
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 19.5
  id: totrans-1505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 19.5
- en: '*If F synchronizes with E, all effects X that happened before* *`F`* *must
    be visible at all evaluations* *`G`* *that happen after* *`E`**.*'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果F与E同步，那么在E之后发生的所有在F之前发生的效应X都必须在所有G评估中可见**.*'
- en: '|  |'
  id: totrans-1507
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As we saw in the example, there are atomic operations that can read *and* write
    atomically in one step. These are called *read-modify-write* operations:'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中看到的，有一些原子操作可以在一步中读取和写入。这些被称为**读取-修改-写入**操作：
- en: Calls to **atomic_exchange** and **atomic_compare_exchange_weak** for any **`_Atomic`**
    objects
  id: totrans-1509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对任何**`_Atomic`**对象的**atomic_exchange**和**atomic_compare_exchange_weak**调用
- en: Compound assignments or their functional equivalents; increment and decrement
    operators for any **`_Atomic`** objects of arithmetic type
  id: totrans-1510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合赋值或其功能等价物；任何算术类型**`_Atomic`**对象的递增和递减运算符
- en: Calls to **atomic_flag_test_and_set** for **`atomic_flag`**
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对**`atomic_flag`**的**atomic_flag_test_and_set**调用
- en: Such an operation can synchronize on the read side with one thread and on the
    write side with others. All such read-modify-write operations that we have seen
    so far have both acquire and release semantics.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作可以在读取方面与一个线程同步，在写入方面与其它线程同步。我们迄今为止看到的所有这样的读取-修改-写入操作都具有获取和释放语义。
- en: The happened-before relation closes the combination of the sequenced-before
    and synchronizes-with relations transitively. We say that *F* knowingly happened
    before *E*, if there are *n* and *E*[0] = *F, E*[1]*, ..., E*[*n*–1], *E[n]* =
    *E* such that *E[i]* is sequenced before *E[i]*[+1] or synchronizes with it, for
    all 0 *≤ i < n*.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 发生之前的关系通过传递性地关闭有序之前和同步于的关系。我们说*F*有意识地发生在*E*之前，如果存在*n*和*E*[0] = *F, E*[1]*, ...,
    E*[*n*–1], *E[n]* = *E*，其中*E[i]*是有序于*E[i]*[+1]或与其同步的，对于所有0 *≤ i < n*。
- en: '|  |'
  id: totrans-1514
  prefs: []
  type: TYPE_TB
  zh: 19.2\. 提供同步的C库调用
- en: Takeaway 19.6
  id: totrans-1515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 具有同步特性的C库函数成对出现：释放方和获取方。它们总结在[表19.1](#ch19table01)中。
- en: '*We only can conclude that one evaluation happened before another if we have
    a sequenced chain of synchronizations that links them.*'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 19.6要点
- en: '|  |'
  id: totrans-1517
  prefs: []
  type: TYPE_TB
  zh: 19.7要点
- en: 'Observe that this happened-before relation is a combination of very different
    concepts. The sequenced-before relation can in many places be deduced from syntax,
    in particular if two statements are members of the same basic block. Synchronization
    is different: besides the two exceptions of thread startup and end, it is deduced
    through a data dependency on a specific object, such as an atomic or a mutex.'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到这个发生之前的关系是不同概念的组合。有序之前的关系可以在许多地方从语法中推断出来，特别是如果两个语句是同一个基本块中的成员。同步不同：除了线程启动和结束的两个例外，它是通过特定对象（如原子或互斥量）的数据依赖来推断的。
- en: The desired result of all this is that effects in one thread become visible
    in another.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: '**thrd_create**和**thrd_join**的这些同步特性使我们能够在[图18.1](kindle_split_029.html#ch18fig01)中画出线条。在这里，我们不知道我们启动的线程之间事件的任何时间顺序，但在**main**中我们知道我们创建线程的顺序和我们将它们连接的顺序正好如图所示。我们还知道，在我们连接最后一个线程（账户线程）之后，任何这些线程对数据对象的影响都对**main**可见。所有这一切的预期结果是，一个线程中的效果在另一个线程中变得可见。'
- en: '|  |'
  id: totrans-1520
  prefs: []
  type: TYPE_TB
  zh: '| 互斥量释放 | 互斥量获取 |'
- en: Takeaway 19.7
  id: totrans-1521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '|  |'
- en: '*If an evaluation F happened before E, all effects that are known to have happened
    before F are also known to have happened before E.*'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '|  |'
- en: '|  |'
  id: totrans-1523
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 19.2\. C library calls that provide synchronization
  id: totrans-1524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '|  |'
- en: 'C library functions with synchronizing properties come in pairs: a releasing
    side and an acquiring side. They are summarized in [table 19.1](#ch19table01).'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '| **thrd_create**(.., f, x) | f(x)的入口 |'
- en: Note that for the first three entries, we know which events synchronize with
    which, namely the synchronization is mainly limited to effects done by thread
    id. In particular, by transitivity we see that **thrd_exit** or **`return`** always
    synchronize with **thrd_join** for the corresponding thread id.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 表19.1\. 形成同步对的C库函数
- en: 'These synchronization features of **thrd_create** and **thrd_join** allowed
    us to draw the lines in [figure 18.1](kindle_split_029.html#ch18fig01). Here,
    we do not know about any timing of events between the threads that we launched,
    but within **main** we know that the order in which we created the threads and
    the order in which we joined them is exactly as shown. We also know that all effects
    of any of these threads on data objects are visible to **main** after we join
    the last thread: the account thread.'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '| 通过线程id的**thrd_exit**或从f的**return** | id的**tss_t**析构函数的开始 |'
- en: Table 19.1\. C library functions that form synchronization pairs
  id: totrans-1528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '| **call_once**(&obj, g), 首次调用 | **call_once**(&obj, h), 所有后续调用 |'
- en: '| Release | Acquire |'
  id: totrans-1529
  prefs: []
  type: TYPE_TB
  zh: '*如果评估F发生在E之前，那么已知在F之前发生的所有效果也都是在E之前发生的。*'
- en: '| --- | --- |'
  id: totrans-1530
  prefs: []
  type: TYPE_TB
  zh: 如果我们断开线程并不用**thrd_join**同步，则同步只能在线程的结束和**atexit**或**at_quick_exit**处理器的开始之间发生。
- en: '| **thrd_create**(.., f, x) | Entry to f(x) |'
  id: totrans-1531
  prefs: []
  type: TYPE_TB
  zh: '| 释放 | 获取 |'
- en: '| **thrd_exit** by thread id or **return** from f | Start of **tss_t** destructors
    for id |'
  id: totrans-1532
  prefs: []
  type: TYPE_TB
  zh: '*我们只能得出一个评估发生在另一个评估之前的结论，如果我们有一个将它们链接起来的有序同步链。*'
- en: '| End of **tss_t** destructors for id | **thrd_join**(id) or **atexit**/**at_quick_exit**
    handlers |'
  id: totrans-1533
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **call_once**(&obj, g), first call | **call_once**(&obj, h), all subsequent
    calls |'
  id: totrans-1534
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '| Mutex release | Mutex acquisition |'
  id: totrans-1535
  prefs: []
  type: TYPE_TB
  zh: '| id的**tss_t**析构函数的结束 | **thrd_join**(id)或**atexit**/**at_quick_exit**处理器 |'
- en: If we detach our threads and don’t use **thrd_join** synchronization can only
    take place between the end of a thread and the start of an **atexit** or **at_quick_exit**
    handler.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于前三个条目，我们知道哪些事件与哪些事件同步，即同步主要限于线程id执行的效果。特别是，通过传递性，我们可以看到**thrd_exit**或**`return`**总是与对应线程id的**thrd_join**同步。
- en: The other library functions are a bit more complicated. For the initialization
    utility **call_once**, the return from the very first call **call_once**`(&`obj`,`
    `g)`, the one that succeeds in calling its function g, is a release operation
    for all subsequent calls with the same object obj. This ensures that all write
    operations that are performed during the call to `g()` are known to happen before
    any other call with obj. Thereby all other such calls also know that the write
    operations (the initializations) have been performed.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 其他库函数稍微复杂一些。对于初始化实用工具**call_once**，第一次调用**call_once**`(&`obj`,` `g)`，成功调用其函数g的返回，是对所有后续调用相同对象obj的释放操作。这确保了在调用`g()`期间执行的所有写操作都发生在任何其他调用obj之前。因此，所有其他此类调用也知道写操作（初始化）已经执行。
- en: For our example in [section 18.2](kindle_split_029.html#ch18lev1sec2), this
    means the function errlog_fopen is executed exactly once, and all other threads
    that might execute the **call_once** line will synchronize with that first call.
    So when any of the threads return from the call, they know that the call has been
    performed (either by themselves or by another thread that was faster) and that
    all effects such as computing the filename and opening the stream are visible
    now. Thus all threads that executed the call may use errlog and can be sure it
    is properly initialized.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子（[第18.2节](kindle_split_029.html#ch18lev1sec2)），这意味着函数errlog_fopen只执行一次，所有可能执行**call_once**行的其他线程都将与第一次调用同步。因此，当任何线程从调用返回时，它们知道调用已经执行（要么是自己执行的，要么是比它快的另一个线程执行的）并且所有效果，如计算文件名和打开流，现在都是可见的。因此，执行调用的所有线程都可以使用errlog，并且可以确信它已正确初始化。
- en: For a mutex, a release operation can be a call to a mutex function, **mtx_unlock**,
    or the entry into the wait functions for condition variables, **cnd_wait** and
    **cnd_timedwait**. An acquire operation on a mutex is the successful acquisition
    of the mutex via any of the three mutex calls **mtx_lock**, **mtx_trylock**, and
    **mtx_timedlock**, or the return from the the wait function **cnd_wait** or **cnd_timedwait**.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 对于互斥锁，释放操作可以是调用互斥锁函数**mtx_unlock**，或者进入条件变量的等待函数**cnd_wait**和**cnd_timedwait**。互斥锁的获取操作是通过任何三个互斥锁调用**mtx_lock**、**mtx_trylock**和**mtx_timedlock**成功获取互斥锁，或者从等待函数**cnd_wait**或**cnd_timedwait**返回。
- en: '|  |'
  id: totrans-1540
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.8
  id: totrans-1541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获19.8
- en: '*Critical sections that are protected by the same mutex occur sequentially.*'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 由相同互斥锁保护的关键节发生顺序。
- en: '|  |'
  id: totrans-1543
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Our input and accounting threads from the example ([listings 18.1](kindle_split_029.html#ch18ex08)
    and [18.2](kindle_split_029.html#ch18ex09)) access the same mutex `L-`>mtx. In
    the first, it is used to protect the birth of a new set of cells if the user types
    a ' ', 'b', or 'B'. In the second, the entire inner block of the *while* loop
    is protected by the mutex.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入和会计线程（[示例18.1](kindle_split_029.html#ch18ex08)和[18.2](kindle_split_029.html#ch18ex09)）访问相同的互斥锁`L-`>mtx。在前一个示例中，它用于保护当用户输入空格、'b'或'B'时新细胞组的出生。在第二个示例中，整个while循环的内部块由互斥锁保护。
- en: '[Figure 19.2](#ch19fig02) schematizes a sequence of three critical sections
    that are protected by the mutex. The synchronization between the unlock operations
    (release) and the return from the lock operation (acquire) synchronizes the two
    threads. This guarantees that the changes applied to `*`L by the account thread
    in the first call to life_account are visible in the input thread when it calls
    life_birth9. Equally, the second call to life_account sees all changes to `*`L
    that occur during the call to life_birth9.'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '[图19.2](#ch19fig02)概述了由互斥锁保护的三个关键节点的序列。解锁操作（释放）与锁定操作（获取）之间的同步同步了两个线程。这保证了在第一次调用life_account时，账户线程对`*`L所做的更改在输入线程调用life_birth9时可见。同样，第二次调用life_account可以看到在调用life_birth9期间发生的所有对`*`L的更改。'
- en: Figure 19.2\. Two threads with three critical sections that synchronize via
    a mutex. The circles present the modifications of object mtx.
  id: totrans-1546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.2\. 两个线程通过互斥锁同步三个关键节点。圆圈表示对象mtx的修改。
- en: '![](19fig02_alt.jpg)'
  id: totrans-1547
  prefs: []
  type: TYPE_IMG
  zh: '![](19fig02_alt.jpg)'
- en: '|  |'
  id: totrans-1548
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.9
  id: totrans-1549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获19.9
- en: '*In a critical section that is protected by the mutex* *`mut`**, all effects
    of previous critical sections protected by* *`mut`* *are visible.*'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 在由互斥锁**`mut`**保护的关键节中，所有由**`mut`**保护的前一个关键节的效果都是可见的。
- en: '|  |'
  id: totrans-1551
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: One of these known effects is always the advancement of the point of execution.
    In particular, on return from **mtx_unlock**, the execution point is outside the
    critical section, and this effect is known to the next thread that newly acquires
    the lock.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 这些已知效果之一是执行点的推进。特别是，在从**mtx_unlock**返回时，执行点位于临界区之外，并且这种效果为下一个新获取锁的线程所知。
- en: The wait functions for condition variables differ from acquire-release semantics;
    in fact, they work exactly the other way around.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量的等待函数与获取-释放语义不同；实际上，它们正好相反。
- en: '|  |'
  id: totrans-1554
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.10
  id: totrans-1555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 19.10
- en: '**`cnd_wait`** *and* **cnd_timedwait** *have release-acquire semantics for
    the mutex.*'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: '**`cnd_wait`** *和* **cnd_timedwait** *对互斥锁具有释放-获取语义。*'
- en: '|  |'
  id: totrans-1557
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That is, before suspending the calling thread, they perform a release operation
    and then, when returning, an acquire operation. The other peculiarity is that
    the synchronization goes through the mutex, *not* through the condition variable
    itself.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 即，在挂起调用线程之前，它们执行释放操作，然后，在返回时执行获取操作。另一个特殊性是同步是通过互斥锁进行的，**不是**通过条件变量本身。
- en: '|  |'
  id: totrans-1559
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.11
  id: totrans-1560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 19.11
- en: '*Calls to* **cnd_signal** *and* **cnd_broadcast** *synchronize via the mutex.*'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: '*对* **cnd_signal** *和* **cnd_broadcast** *的调用通过互斥锁进行同步。'
- en: '|  |'
  id: totrans-1562
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The signaling thread will not necessarily synchronize with the waiting thread
    if it does not place a call to **cnd_signal** or **cnd_broadcast** into a critical
    section that is protected by the same mutex as the waiter. In particular, non-atomic
    modifications of objects that constitute the *condition expression* may not become
    visible to a thread that is woken up by a signal if the modification is not protected
    by the mutex. There is a simple rule of thumb to ensure synchronization:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信号线程没有将**cnd_signal**或**cnd_broadcast**的调用放入由等待者相同的互斥锁保护的临界区，那么它不一定与等待线程同步。特别是，如果修改不是由互斥锁保护的，那么构成**条件表达式**的对象的非原子修改可能不会对被信号唤醒的线程可见。有一个简单的经验法则可以确保同步：
- en: Figure 19.3\. Sequential consistency for three different atomic objects
  id: totrans-1564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.3\. 三个不同原子对象的顺序一致性
- en: '![](19fig03_alt.jpg)'
  id: totrans-1565
  prefs: []
  type: TYPE_IMG
  zh: '![19fig03_alt.jpg](19fig03_alt.jpg)'
- en: '|  |'
  id: totrans-1566
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.12
  id: totrans-1567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 19.12
- en: '*Calls to* **cnd_signal** *and* **cnd_broadcast** *should occur inside a critical
    section that is protected by the same mutex as the waiters.*'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '*对* **cnd_signal** *和* **cnd_broadcast** *的调用应该发生在由相同的互斥锁保护的临界区内部。'
- en: '|  |'
  id: totrans-1569
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This is what we saw around line 145 in [listing 18.1](kindle_split_029.html#ch18ex08).
    Here, the function life_birth modifies larger, non-atomic parts of `*`L, so we
    must make sure these modifications are properly visible to all other threads that
    work with `*`L.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们大约在第145行看到的[列表18.1](kindle_split_029.html#ch18ex08)中的内容。在这里，函数life_birth修改了`*`L的较大、非原子部分，因此我们必须确保这些修改对所有其他与`*`L一起工作的线程都是适当可见的。
- en: Line 154 shows a use of **cnd_signal** that is not protected by the mutex. This
    is only possible here because all data that is modified in the other **`switch`**
    cases is atomic. Thus other threads that read this data, such as `L-`>frames,
    can synchronize through these atomics and do not rely on acquiring the mutex.
    Be careful if you use conditional variables like that.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 第154行显示了**cnd_signal**的使用，它没有被互斥锁保护。这在这里是可能的，因为所有在其他**`switch`**情况中修改的数据都是原子的。因此，读取这些数据的其他线程，如`L-`>frames，可以通过这些原子来同步，而不依赖于获取互斥锁。如果你使用这样的条件变量，请小心。
- en: 19.3\. Sequential consistency
  id: totrans-1572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3\. 顺序一致性
- en: The data consistency for atomic objects that we described earlier, guaranteed
    by the *happened-before* relation, is called *acquire-release consistency*. Whereas
    the C library calls we have seen always synchronize with that kind of consistency,
    no more and no less, accesses to atomics can be specified with different consistency
    models.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前描述的原子对象的**一致性**，由**发生之前**关系保证，被称为**获取-释放一致性**。而我们所看到的C库调用总是与这种一致性同步，不多也不少，对原子对象的访问可以使用不同的一致性模型。
- en: As you remember, all atomic objects have a *modification order* that is consistent
    with all sequenced-before relations that see these modifications *on the same*
    object. *Sequential consistency* has even more requirements than that; see [figure
    19.3](#ch19fig03). Here we illustrate the common timeline of all sequentially
    consistent operations on top. Even if these operations are performed on different
    processors and the atomic objects are realized in different memory banks, the
    platform has to ensure that all threads perceive all these operations as being
    consistent with this one global linearization.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，所有原子对象都有一个与所有在相同对象上看到这些修改的**修改顺序**相一致的**顺序一致性**关系。**顺序一致性**的要求甚至比这更多；参见[图19.3](#ch19fig03)。在这里，我们展示了所有顺序一致性操作的常见时间线。即使这些操作在不同的处理器上执行，原子对象在不同的内存银行中实现，平台也必须确保所有线程将这些操作视为与这个全局线性化一致。
- en: '|  |'
  id: totrans-1575
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.13
  id: totrans-1576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 19.13
- en: '*All atomic operations with sequential consistency occur in one global modification
    order, regardless of the atomic object they are applied to.*'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有具有顺序一致性的原子操作都发生在单个全局修改顺序中，无论它们应用于哪个原子对象。*'
- en: '|  |'
  id: totrans-1578
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: So, sequential consistency is a very strong requirement. Not only that, it enforces
    acquire-release semantics (a causal partial ordering between events), but it rolls
    out this partial ordering to a total ordering. If you are interested in parallelizing
    the execution of your program, sequential consistency may not be the right choice,
    because it may force sequential execution of the atomic accesses.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，顺序一致性是一个非常严格的要求。不仅如此，它强制执行获取-释放语义（事件之间的因果部分排序），而且还把这个部分排序扩展到总排序。如果你对并行化程序的执行感兴趣，顺序一致性可能不是正确的选择，因为它可能会强制原子访问的顺序执行。
- en: 'The standard provides the following functional interfaces for atomic types.
    They should conform to the description given by their name and also perform synchronization:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 标准为原子类型提供了以下功能接口。它们应遵守其名称所给出的描述，并执行同步：
- en: '[PRE152]'
  id: totrans-1581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Here C is any appropriate data type, A is the corresponding atomic type, and
    M is a type that is compatible with the arithmetic of C. As the names suggest,
    for the fetch and operator interfaces the call returns the value that `*`obj had
    before the modification of the object. So these interfaces are *not* equivalent
    to the corresponding compound assignment operator (`+=`), since that would return
    the result *after* the modification.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 这里C是任何适当的数据类型，A是对应的原子类型，M是与C的算术兼容的类型。正如其名称所暗示的，对于获取和运算符接口，调用返回对象修改之前`*`obj的值。因此，这些接口与相应的复合赋值运算符（`+=`）不等价，因为那会返回修改后的结果。
- en: All these functional interfaces provide *sequential consistency*.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能接口都提供**顺序一致性**。
- en: '|  |'
  id: totrans-1584
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.14
  id: totrans-1585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 19.14
- en: '*All operators and functional interfaces on atomics that don’t specify otherwise
    have sequential consistency.*'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子上的所有未指定其他操作的运算符和功能接口都具有顺序一致性。*'
- en: '|  |'
  id: totrans-1587
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Observe also that the functional interfaces differ from the operator forms,
    because their arguments are **`volatile`** qualified.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，功能接口与运算符形式不同，因为它们的参数被**`volatile`**修饰。
- en: 'There is another function call for atomic objects that *does not* imply synchronization:'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原子对象还有一个不暗示同步的函数调用：
- en: '[PRE153]'
  id: totrans-1590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Its effect is the same as a call to **atomic_store** or an assignment operation,
    but concurrent calls from different threads can produce a race. View **atomic_init**
    as a cheap form of assignment.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 它的效果与调用**atomic_store**或赋值操作相同，但来自不同线程的并发调用可能会产生竞态条件。将**atomic_init**视为一种廉价的赋值形式。
- en: 19.4\. Other consistency models
  id: totrans-1592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4. 其他一致性模型
- en: A different consistency model can be requested with a complementary set of functional
    interfaces. For example, an equivalent to the postfix `++` operator with just
    acquire-release consistency could be specified with
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过一组互补的功能接口请求不同的一致性模型。例如，可以通过以下方式指定与后缀`++`运算符等效的仅具有获取-释放一致性的操作：
- en: '[PRE154]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '|  |'
  id: totrans-1595
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 19.15
  id: totrans-1596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 19.15
- en: '*Synchronizing functional interfaces for atomic objects have a form with* **`_explicit`**
    *appended that allows us to specify their consistency model.*'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子对象的同步功能接口具有附加**`_explicit`**的形式，允许我们指定它们的顺序一致性模型。*'
- en: '|  |'
  id: totrans-1598
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'These interfaces accept additional arguments in the form of symbolic constants
    of type **`memory_order`** that specify the memory semantics of the operation:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口接受形式为**`memory_order`**类型符号常量的额外参数，该参数指定了操作的内存语义：
- en: '**`memory_order_seq_cst`** requests sequential consistency. Using this is equivalent
    to the forms without **`_explicit`**.'
  id: totrans-1600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`memory_order_seq_cst`** 请求顺序一致性。使用此选项等同于没有 **`_explicit`** 的形式。'
- en: '**`memory_order_acq_rel`** is for an operation that has acquire-release consistency.
    Typically, for general atomic types, you’d use it for a read-modify-write operation
    such as **atomic_fetch_add** or **atomic_compare_exchange_weak**, or for **`atomic_flag`**
    with **atomic_flag_test_and_set**.'
  id: totrans-1601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`memory_order_acq_rel`** 用于具有获取-释放一致性的操作。对于一般的原子类型，你通常会在读-改-写操作中使用它，例如 **atomic_fetch_add**
    或 **atomic_compare_exchange_weak**，或者对于 **`atomic_flag`** 与 **atomic_flag_test_and_set**。'
- en: '**`memory_order_release`** is for an operation that has only release semantics.
    Typically this would be **atomic_store** or **atomic_flag_clear**.'
  id: totrans-1602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`memory_order_release`** 用于只有释放语义的操作。通常这会是 **atomic_store** 或 **atomic_flag_clear**。'
- en: '**`memory_order_acquire`** is for an operation that has only acquire semantics.
    Typically this would be **atomic_load**.'
  id: totrans-1603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`memory_order_acquire`** 用于只有获取语义的操作。通常这会是 **atomic_load**。'
- en: '**`memory_order_consume`** is for an operation that has a weaker form of causal
    dependency than acquire consistency. Typically this would also be **atomic_load**.'
  id: totrans-1604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`memory_order_consume`** 用于具有比获取一致性更弱因果依赖性的操作。通常这也会是 **atomic_load**。'
- en: '**`memory_order_relaxed`** is for an operation that adds no synchronization
    requirements. The only guarantee for such an operation is that it is indivisible.
    A typical use case for such an operation is a performance counter that is used
    by different threads, but for which we are only interested in a final accumulated
    count.'
  id: totrans-1605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`memory_order_relaxed`** 用于不添加任何同步要求的操作。此类操作的唯一保证是它是不可分割的。此类操作的典型用例是用于不同线程的性能计数器，但我们只对最终累计计数感兴趣。'
- en: The consistency models can be compared with respect to the restrictions they
    impose to the platform. [Figure 19.4](#ch19fig04) shows the implication order
    of the **`memory_order`** models.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据它们对平台施加的限制来比较一致性模型。[图19.4](#ch19fig04)显示了 **`memory_order`** 模型的含义顺序。
- en: Figure 19.4\. Hierarchy of consistency models, from least to most constraining
  id: totrans-1607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.4\. 一致性模型层次结构，从最少约束到最多约束
- en: '![](19fig04.jpg)'
  id: totrans-1608
  prefs: []
  type: TYPE_IMG
  zh: '![图片](19fig04.jpg)'
- en: 'Whereas **`memory_order_seq_cst`** and **`memory_order_relaxed`** are admissible
    for all operations, there are some restrictions for other **`memory_order`**s.
    Operations that can only occur on one side of a synchronization can only specify
    an order for that side. Therefore, the two operations that only store (**atomic_store**
    or **atomic_flag_clear**) may not specify acquire semantics. Three operations
    only perform a load and may not specify release or consume semantics: besides
    **atomic_load**, these are **atomic_compare_exchange_weak** and **atomic_compare_exchange_strong**
    in case of failure. Thus, the latter two need two **`memory_order`** arguments
    for their **`_explicit`** form, such that they can distinguish the requirements
    for the success and failure cases:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 而 **`memory_order_seq_cst`** 和 **`memory_order_relaxed`** 对所有操作都是可接受的，但其他 **`memory_order`**
    有一些限制。只能在同步的一侧发生的操作只能指定那一侧的顺序。因此，仅存储（**atomic_store** 或 **atomic_flag_clear**）的两个操作可能不会指定获取语义。只有三个操作只执行加载，可能不会指定释放或消费语义：除了
    **atomic_load**，这些是失败情况下的 **atomic_compare_exchange_weak** 和 **atomic_compare_exchange_strong**。因此，后两个操作需要两个
    **`memory_order`** 参数来指定它们的 **`_explicit`** 形式，以便它们可以区分成功和失败情况的要求：
- en: '[PRE155]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Here, the success consistency must be at least as strong as the failure consistency;
    see [figure 19.4](#ch19fig04).
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，成功一致性必须至少与失败一致性一样强；参见[图19.4](#ch19fig04)。
- en: 'Up to now, we have implicitly assumed that the acquire and release sides of
    a synchronization are symmetric, but they aren’t: whereas there always is just
    one writer of a modification, there can be several readers. Because moving new
    data to several processors or cores is expensive, some platforms allow us to avoid
    the propagation of all visible effects that happened before an atomic operation
    to all threads that read the new value. C’s *consume consistency* is designed
    to map this behavior. We will not go into the details of this model, and you should
    use it only when you are certain that some effects prior to an atomic read will
    not affect the reading thread.'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们隐含地假设同步的获取和释放方面是对称的，但实际上并非如此：虽然修改只有一个写者，但可以有多个读者。因为将新数据移动到多个处理器或核心是昂贵的，一些平台允许我们避免将原子操作之前发生的所有可见效果传播到所有读取新值的线程。C语言的*消费一致性*就是为了映射这种行为设计的。我们不会深入探讨这个模型，你应该只在确定原子读取之前的一些效果不会影响读取线程时才使用它。
- en: Summary
  id: totrans-1613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The “happens before” relation is the only possible way to reason about timing
    between different threads. It is only established through synchronization that
    uses either atomic objects or very specific C library functions.
  id: totrans-1614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “发生之前”关系是推理不同线程之间时间顺序的唯一可能方式。它只能通过使用原子对象或非常具体的C库函数的同步来建立。
- en: Sequential consistency is the default consistency model for atomics, but not
    for other C library functions. It additionally assumes that all corresponding
    synchronization events are totally ordered. This is an assumption that can be
    expensive.
  id: totrans-1615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序一致性是原子的一致性模型默认值，但不是其他C库函数的默认值。它还假设所有相应的同步事件都是完全有序的。这是一个可能代价高昂的假设。
- en: Explicitly using acquire-release consistency can lead to more efficient code,
    but it needs a careful design to supply the correct arguments to the atomic functions
    with a **`_explicit`** suffix.
  id: totrans-1616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式使用获取-释放一致性可能会导致更高效的代码，但需要对原子函数使用带有**`_explicit`**后缀的正确参数进行仔细设计。
