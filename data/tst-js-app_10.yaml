- en: 8 Testing React applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 测试 React 应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How to test components that interact with each other
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试相互交互的组件
- en: Snapshot testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照测试
- en: Testing component’s styles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试组件的样式
- en: Stories and component-level acceptance testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事和组件级验收测试
- en: After finding their way around a professional kitchen and learning a trick or
    two with the pastry bag, at some point, a *pâtissier* must crack a few eggs, prepare
    a bit of dough, and do some *real* baking.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了专业厨房的操作并学会了一些技巧，比如使用裱花袋后，某个时候，一位 *糕点师* 必须敲碎几个鸡蛋，准备一些面团，并进行一些 *真正的* 烘焙。
- en: In this chapter, we’ll take a similar approach to testing React applications.
    Now that you’ve learned your way around the React testing ecosystem and understood
    its tools’ roles, we’ll dig deeper into how to write effective, robust, and maintainable
    tests for your React applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采用与测试 React 应用程序相似的方法。现在你已经熟悉了 React 测试生态系统，并理解了其工具的作用，我们将更深入地探讨如何编写有效、健壮和可维护的测试来测试你的
    React 应用程序。
- en: To learn how to write these kinds of tests, you’ll extend the application you’ve
    built in the previous chapter and learn how to use advanced techniques to test
    it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何编写这类测试，你需要扩展上一章中构建的应用程序，并学习如何使用高级技术对其进行测试。
- en: First, you’ll learn, at multiple levels of isolation, how to validate components
    that interact with each other. Throughout the process, I’ll explain how to do
    it in a comprehensible and maintainable way. For that, you’ll learn how to stub
    components, how these stubs impact your tests, and how to apply the testing pyramid
    concept when testing React applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将在多个隔离级别上学习如何验证相互交互的组件。在整个过程中，我会解释如何以易于理解和维护的方式进行。为此，你将学习如何模拟组件，这些模拟如何影响你的测试，以及如何在测试
    React 应用程序时应用测试金字塔概念。
- en: In this chapter’s second section, I’ll explain what snapshot testing is, how
    to do it, and, most importantly, *when* to do it. In this section, you’ll learn
    which factors to consider when deciding whether you should use snapshot testing
    to test specific parts of your application. As I explain the pros and cons of
    snapshot testing, I’ll stick to this book’s value-driven approach so that you’ll
    be empowered to make your own decisions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我将解释快照测试是什么，如何进行，最重要的是，*何时* 进行。在本节中，你将学习在决定是否应该使用快照测试来测试应用程序的特定部分时需要考虑哪些因素。当我解释快照测试的优缺点时，我会坚持本书的价值驱动方法，这样你将能够做出自己的决定。
- en: Then, given the integral part that CSS plays in the development of your software,
    and how important it is for a client-side application not only to *behave* adequately
    but also to *look* good, you’ll understand how to test your application’s style
    rules. You’ll learn which aspects of your component’s styles are worth testing
    and what you can, and can’t, achieve.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，鉴于 CSS 在你的软件开发中的重要作用，以及对于客户端应用程序不仅需要 *表现* 良好，而且还需要 *外观* 优美的重要性，你将了解如何测试你的应用程序的样式规则。你将学习哪些组件样式的方面值得测试，以及你可以和不能实现什么。
- en: In the final section of this chapter, I’ll explain what component stories are
    and how to write them. As you write stories using Storybook, I’ll elucidate how
    they can improve your development process and help you produce reliable and well-documented
    components.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我将解释组件故事是什么以及如何编写它们。当你使用 Storybook 编写故事时，我会阐明它们如何改进你的开发过程，并帮助你生产可靠且文档齐全的组件。
- en: You’ll understand the impact that stories have on the feedback loop’s speed
    and in streamlining UI development, improving communication among different teams,
    and enabling you and your colleagues to perform acceptance testing at a component
    level.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将理解故事对反馈循环速度的影响，以及它们如何简化 UI 开发，改善不同团队之间的沟通，并使你和你同事能够在组件级别进行验收测试。
- en: 8.1 Testing component integration
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 测试组件集成
- en: When dealing with expensive equipment, like industrial ovens, it’s crucial to
    check that every piece is where the manual says it should be. But doing only that
    is not enough. The earlier bakers turn the oven’s knobs, press its buttons, and
    flip its switches, the earlier they can activate the warranty and order a replacement
    if anything goes wrong. Still, Louis never considers an oven to be faultless without
    having tasted a batch of sourdough bread baked in it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理像工业烤箱这样的昂贵设备时，至关重要的是要检查每一件设备是否都位于手册所说的位置。但仅仅这样做是不够的。面包师越早转动烤箱的旋钮、按下按钮和翻转开关，就越早能够激活保修并订购替换品，如果发生任何问题。然而，路易斯从未在没有尝过在烤箱中烤制的一批酸面包之前认为烤箱是完美的。
- en: Similarly, when testing components, you can check that all elements are in the
    correct place. Yet, without filling a few fields and pressing a few buttons, you
    can’t tell whether a component will adequately respond to your users’ input. Additionally,
    without testing your components in integration, it’s difficult to create reliable
    guarantees.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在测试组件时，你可以检查所有元素是否都位于正确的位置。然而，如果不填写一些字段并按下几个按钮，你无法判断组件是否能够充分响应用户的输入。此外，如果不测试组件的集成，很难创建可靠的保证。
- en: In this section, you’ll learn how to test components that interact with one
    another. First, you’ll make the application update the list of items whenever
    an operator adds products to the inventory. Then, you’ll write different kinds
    of tests for that functionality, at multiple different levels of integration.
    I’ll explain the pros and cons of each approach.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何测试相互交互的组件。首先，你将使应用程序在操作员向库存中添加产品时更新项目列表。然后，你将编写不同类型的测试来测试该功能，在多个不同级别的集成中进行。我将解释每种方法的优缺点。
- en: NOTE This chapter builds on the application you wrote in the previous chapter
    as well as the server we had been using then.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章基于上一章中编写的应用程序以及当时使用的服务器。
- en: You can find the code for both the client and the server used for this chapter’s
    examples at this book’s repository on GitHub, at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书GitHub仓库中找到本章示例中使用的客户端和服务器代码，网址为[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: In the folder for chapter 8, you’ll find a directory named `server`, which contains
    an HTTP server capable of handling the requests your React application will make.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章的文件夹中，你会找到一个名为`server`的目录，其中包含一个能够处理你的React应用程序将发出的请求的HTTP服务器。
- en: As you’ve done previously, to run that server, navigate into its folder, install
    its dependencies with `npm install`, and ensure that your database schema is up-to-date
    with `npm run migrate:dev`. After installing dependencies and preparing your database,
    spin up the server with `npm start`. By default, your HTTP server will be bound
    to port `3000`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前所做的那样，要运行该服务器，导航到其文件夹，使用`npm install`安装其依赖项，并确保你的数据库模式与`npm run migrate:dev`保持最新。在安装依赖项并准备数据库后，使用`npm
    start`启动服务器。默认情况下，你的HTTP服务器将绑定到端口`3000`。
- en: For `App` to be able to update its state and, therefore, its children, it will
    create a callback function for `ItemForm` to call when users add items. This callback
    function should take the item’s name, the quantity added, and update the state
    within `App`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`App`能够更新其状态以及因此其子组件的状态，它将为`ItemForm`创建一个回调函数，当用户添加项目时调用。这个回调函数应该接受项目的名称、添加的数量，并在`App`内部更新状态。
- en: Before you start changing `App`, update `ItemForm` as shown in the next listing
    so that it takes an `onItemAdded` function as a `prop`. If this `prop` is defined,
    `ItemForm` should call it whenever the form is submitted, passing the item’s name
    and the quantity added as arguments.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始修改`App`之前，按照下一个列表所示更新`ItemForm`，使其接受一个`onItemAdded`函数作为`prop`。如果这个`prop`被定义，`ItemForm`应该在表单提交时调用它，并将项目的名称和添加的数量作为参数传递。
- en: Listing 8.1 ItemForm.jsx
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 ItemForm.jsx
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Calls the passed onItemAdded callback when the form is submitted
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当表单提交时调用传递的onItemAdded回调
- en: Now, to validate whether the `ItemForm` component calls the passed `onItemAdded`
    function when it exists, you’ll create a unit test, shown next. Your test should
    render `ItemForm`, pass it a stub through the `onItemAdded` property, submit the
    form, wait for the request to resolve, and check whether this component called
    the passed stub.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了验证 `ItemForm` 组件在存在时是否调用传递的 `onItemAdded` 函数，你将创建一个单元测试，如以下所示。你的测试应该渲染
    `ItemForm`，通过 `onItemAdded` 属性传递一个占位符，提交表单，等待请求解决，并检查这个组件是否调用了传递的占位符。
- en: Listing 8.2 ItemForm.test.jsx
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 ItemForm.test.jsx
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Renders an ItemForm component whose onItem-Added prop is a dummy stub created
    using Jest
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 渲染一个 `ItemForm` 组件，其 `onItem-Added` 属性是一个使用 Jest 创建的占位符
- en: ❷ Creates an interceptor to respond to the POST request the form will send when
    submitted
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个拦截器来响应表单提交时发送的 POST 请求
- en: ❸ Updates with “cheesecake,” the form field for the item name
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用“cheesecake”更新项目名称的表单字段
- en: ❹ Updates with “2,” the form field for the item’s quantity
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用“2”更新项目数量的表单字段
- en: ❺ Clicks the button that submits the form
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 点击提交表单的按钮
- en: ❻ Waits for the interceptor to be reached
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 等待拦截器到达
- en: ❼ Expects the onItemAdded callback to have been called once
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 期望 `onItemAdded` 回调只被调用一次
- en: ❽ Expects the onItemAdded callback to have been called with “cheesecake” as
    its first argument and “2” as its second
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 期望 `onItemAdded` 回调以“cheesecake”作为其第一个参数和“2”作为其第二个参数被调用
- en: This test, whose coverage and interactions are shown in figure 8.1, can validate
    whether `ItemForm` would call a function passed by `App`, but it *can’t* check
    whether `App` passes a function to `ItemForm`, nor that the passed function is
    correct.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试，其覆盖范围和交互显示在图8.1中，可以验证 `ItemForm` 是否会调用通过 `App` 传递的函数，但它*不能*检查 `App` 是否将函数传递给
    `ItemForm`，或者传递的函数是否正确。
- en: '![](../Images/CH08_F01_DaCosta.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F01_DaCosta.png)'
- en: Figure 8.1 This test for `ItemForm` can validate only the component itself.
    It can’t check whether its parent or sibling components give it the correct `props`
    or that they update adequately.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 这个针对 `ItemForm` 的测试只能验证组件本身。它不能检查其父组件或兄弟组件是否给它提供了正确的 `props`，或者它们是否适当地更新。
- en: To guarantee that `App` updates its state adequately when users add new items,
    you’d need a separate test that validates `App` and its integration with `ItemForm`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保当用户添加新项目时 `App` 能够充分更新其状态，你需要一个单独的测试来验证 `App` 及其与 `ItemForm` 的集成。
- en: Go ahead and update your `App` component in such a way that the list of items
    will update as users submit new items through the form.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，更新你的 `App` 组件，以便当用户通过表单提交新项目时，项目列表会更新。
- en: To implement that feature, you’ll write a function capable of taking an item’s
    name and quantity and updating the state within `App`. Then, you’ll pass this
    function to `ItemForm` through the `onItemAddedprop`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，你需要编写一个函数，该函数能够接受项目的名称和数量，并更新 `App` 中的状态。然后，你将通过 `onItemAddedprop`
    将这个函数传递给 `ItemForm`。
- en: Listing 8.3 ItemForm.test.jsx
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 ItemForm.test.jsx
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creates a piece of state that represents the list of inventory items
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个表示库存项目列表的状态
- en: ❷ Creates a function that merges the name of the item added and the quantity
    added to the piece of state that represents the list of inventory items
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个函数，该函数将添加的项目名称和数量合并到表示库存项目列表的状态中
- en: ❸ Renders a list of items whose itemList property is the items piece of state
    within App
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 渲染一个项目列表，其 `itemList` 属性是 `App` 中的 `items` 状态
- en: The `ItemForm` component will call `updateItems` whenever users submit new items.
    This function will receive the name of the item and quantity added and will use
    that information to update the state within `App`, which is passed to `ItemList`.
    Because submitting the form will update the piece of state used by `ItemList`,
    it will cause the list of items to update, reflecting the items added.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemForm` 组件会在用户提交新项目时调用 `updateItems` 方法。这个方法将接收项目名称和增加的数量，并使用这些信息来更新 `App`
    中的状态，该状态被传递给 `ItemList`。因为提交表单会更新 `ItemList` 所使用的状态，所以会导致项目列表更新，反映所添加的项目。'
- en: Before writing a test for this behavior, give it a quick try. Build your application
    with `npm run build`, serve it with `npx http-server ./`, and visit `localhost:8080`.
    As you add items to the inventory, you’ll see that the item list updates automatically.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在为这种行为编写测试之前，先快速尝试一下。使用 `npm run build` 构建你的应用程序，用 `npx http-server ./` 提供服务，并访问
    `localhost:8080`。当你向库存中添加项目时，你会看到项目列表会自动更新。
- en: Because you haven’t yet added tests to check the integration between `App` and
    its children, your tests might pass, even though your application doesn’t work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你还未添加测试来检查`App`及其子组件之间的集成，所以即使你的应用程序不工作，测试也可能通过。
- en: Your current tests check whether the list correctly displays what’s in stock
    and whether the item form calls the passed `onItemAdded` function. Still, they
    don’t verify whether `App` integrates adequately with those components. Currently,
    your tests would pass if, for example, you had forgotten to provide `ItemForm`
    with an `updateItems` function, or if that function was incorrect.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你当前的测试检查列表是否正确显示库存中的内容，以及项目表单是否调用了传递的`onItemAdded`函数。然而，它们并没有验证`App`是否与这些组件充分集成。目前，如果你的测试通过，例如，你忘记了为`ItemForm`提供`updateItems`函数，或者该函数不正确，那么测试仍然会通过。
- en: Testing components in isolation is an excellent way to get quick feedback as
    you develop them, but it’s not as valuable when it comes to creating reliable
    guarantees.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，单独测试组件是一种快速获得反馈的好方法，但它在创建可靠保证方面并不那么有价值。
- en: To validate whether `App` updates itself adequately when users add new items,
    you’ll write a test that renders `App`, submits the form, and expects the `ItemList`
    to be updated.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证当用户添加新项目时`App`是否能够适当地更新自身，你将编写一个渲染`App`、提交表单并期望`ItemList`更新的测试。
- en: In this test, it’s essential to take into account that `ItemForm` will send
    a request to `POST` when adding items and that it will call the passed `onItemAdded`
    function only after that request resolves. Therefore, for you to be able to write
    a passing test, you must cause the request to succeed and the test to wait until
    the request has resolved before running assertions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，必须考虑到`ItemForm`在添加项目时会向`POST`发送请求，并且它只有在那个请求解决后才会调用传递的`onItemAdded`函数。因此，为了能够编写一个通过测试，你必须使请求成功，并在运行断言之前使测试等待请求解决。
- en: For the test to succeed, you’ll create an interceptor for the route that adds
    items to the inventory. Then, you’ll make the test wait until the request has
    resolved by wrapping your assertion into `waitFor`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试成功，你将为添加项目到库存的路由创建一个拦截器。然后，你将使测试等待请求解决，通过将断言包装在`waitFor`中来实现。
- en: Listing 8.4 App.test.jsx
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 App.test.jsx
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates an interceptor that will respond to the request the form will send
    when adding 6 cheesecakes
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个拦截器，当表单添加6个cheesecakes时将响应请求
- en: ❷ Renders an instance of App
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 渲染`App`的一个实例
- en: ❸ Waits for the item list to have three children
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 等待项目列表有三个子元素
- en: ❹ Updates with “cheesecake” the form field for the item’s name
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 更新项目名称表单字段为“cheesecake”
- en: ❺ Updates with “6” the form field for the item’s quantity
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 更新项目数量表单字段为“6”
- en: ❻ Waits for an element indicating that the inventory contains 8 cheesecakes
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 等待一个元素指示库存包含8个cheesecakes
- en: ❼ Asserts that the list of items has three children
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 断言项目列表有三个子元素
- en: ❽ Waits for an element indicating that the inventory contains 5 croissants
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 等待一个元素指示库存包含5个羊角面包
- en: ❾ Waits for an element indicating that the inventory contains 96 macaroons
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 等待一个元素指示库存包含96个macarons
- en: The test you’ve just written provides you with reliable guarantees that your
    components work in integration because it covers the `App` component and all of
    its children. It covers `ItemForm` by using it to add products to the inventory
    and covers `ItemList` by checking whether the list of items contains elements
    with the expected text.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚编写的测试为你提供了可靠的保证，表明你的组件在集成中可以正常工作，因为它涵盖了`App`组件及其所有子组件。它通过使用`ItemForm`添加产品到库存来涵盖`ItemForm`，并通过检查项目列表是否包含具有预期文本的元素来涵盖`ItemList`。
- en: This test also covers `App`, as shown in figure 8.2, because it will pass only
    if `App` provides `ItemForm` with a callback that adequately updates the state
    passed to `ItemList`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如图8.2所示，此测试也涵盖了`App`，因为它只有在`App`向`ItemForm`提供足够更新传递给`ItemList`的状态的回调时才会通过。
- en: '![](../Images/CH08_F02_DaCosta.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F02_DaCosta.png)'
- en: Figure 8.2 The coverage of a test that renders `App`, interacts with its child
    form, and verifies the item list’s elements
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 渲染`App`、与其子表单交互并验证项目列表元素的测试覆盖率
- en: The only downside of having this test is that you’ll have one extra test to
    fix if you change any of the underlying components. For example, if you alter
    the format of the text rendered by `ItemList`, you will have to update both the
    tests for `ItemList` and the test you’ve just written for the `App` component,
    as figure 8.3 illustrates.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的唯一缺点是，如果您更改任何底层组件，您将多一个测试需要修复。例如，如果您更改`ItemList`渲染的文本格式，您将不得不更新`ItemList`的测试以及您刚刚为`App`组件编写的测试，如图
    8.3 所示。
- en: '![](../Images/CH08_F03_DaCosta.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F03_DaCosta.png)'
- en: Figure 8.3 The tests that break if you decide to change the format of the text
    rendered by `ItemList`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 如果您决定更改`ItemList`渲染的文本格式，则会中断的测试
- en: The more tests you have to update when you make a change, the more expensive
    changes become because you will take more time to make your test suite pass again.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进行更改时，需要更新的测试越多，更改的成本就越高，因为您需要更多的时间来使测试套件通过。
- en: On the other hand, by verifying the list’s items within `App`, you create a
    reliable guarantee that your application will render the correct elements once
    it gets a response from the server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过在`App`中验证列表项，您为您的应用程序创建了一个可靠的保证，即一旦它从服务器收到响应，它将渲染正确的元素。
- en: In regard to deciding at which level of integration to test components, my personal
    opinion goes in line with the recommendations from the `react-testing-library`
    docs, which indicate that you should write your test as high up in the component
    tree as you need to obtain reliable guarantees. The higher in the component tree
    your test’s target is, the more reliable your guarantees are because they resemble
    your application’s run-time scenario more closely.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于决定在哪个集成级别测试组件，我的个人观点与`react-testing-library`文档中的建议一致，该文档建议您将测试编写得尽可能高，以获得可靠的保证。您的测试目标在组件树中的位置越高，您的保证就越可靠，因为它们与您的应用程序的运行时场景更接近。
- en: Even though rendering multiple components produces more reliable quality guarantees,
    in the real world, that’s not always going to be possible and may generate significant
    overlap between your tests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管渲染多个组件会产生更可靠的质量保证，但在现实世界中，这并不总是可能的，并且可能会在您的测试之间产生显著的重复。
- en: One alternative to making your tests more maintainable while preserving their
    reliability is to centralize the text generation for each of the list’s elements
    into a separate function with separate tests. You could then use that function
    both in the tests for app `App` and in the ones for `ItemList`. By doing this,
    when you change the text’s format, you have to update only your text-generation
    function and its own tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持测试可靠性的同时，使测试更易于维护的一个替代方案是将列表每个元素的文本生成集中到一个单独的函数中，并为该函数编写单独的测试。然后，您可以在`App`应用的测试和`ItemList`的测试中使用该函数。通过这样做，当您更改文本格式时，您只需更新您的文本生成函数及其自身的测试。
- en: Experiment with centralizing this dependency by creating a new function within
    `ItemList`, which you’ll export as `generateItemText`. This function takes an
    item’s name and quantity and returns the adequate piece of text that each element
    should display.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`ItemList`中创建一个新函数并将该函数导出为`generateItemText`来集中这个依赖项。这个函数接受一个项目的名称和数量，并返回每个元素应显示的适当文本片段。
- en: Listing 8.5 ItemList.jsx
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 ItemList.jsx
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have implemented this function, write a test for it. To better organize
    your tests within `ItemList.test.jsx`, I recommend you separate the tests for
    the text-generation function and the tests for `ItemList` itself into two separate
    `describe` blocks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您实现了这个函数，就为它编写一个测试。为了更好地在`ItemList.test.jsx`中组织您的测试，我建议您将文本生成函数的测试和`ItemList`本身的测试分别放入两个独立的`describe`块中。
- en: Listing 8.6 ItemList.test.jsx
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 ItemList.test.jsx
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Passes item names and quantities to the generateItemText function and checks
    whether it produces the correct results
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将项目名称和数量传递给`generateItemText`函数，并检查它是否产生正确的结果
- en: Now that you have tested `generateItemText`, update the `ItemList` component
    itself so that it uses this new function to create the text for each of the list’s
    items.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经测试了`generateItemText`，更新`ItemList`组件本身，使其使用这个新函数为列表的每个项创建文本。
- en: Listing 8.7 ItemList.jsx
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 ItemList.jsx
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Uses the generateItemText to generate the text for each item within ItemList
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用`generateItemText`生成`ItemList`中每个项目的文本
- en: Because you have created reliable guarantees by testing the `generateItemText`
    function, you can then use it confidently throughout your test suite. If the `generateItemText`
    function fails, even though the tests using it will pass, the tests for `generateItemText`
    itself will fail. Tests like these are an excellent example of how you can take
    advantage of transitive guarantees.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经通过测试 `generateItemText` 函数创建了可靠的保证，因此你可以在整个测试套件中自信地使用它。如果 `generateItemText`
    函数失败，即使使用它的测试会通过，`generateItemText` 本身的测试也会失败。这样的测试是你可以如何利用传递性保证的一个极好例子。
- en: Go ahead and update the tests for `ItemList` and `App` so that they use this
    new function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续更新 `ItemList` 和 `App` 的测试，以便它们使用这个新函数。
- en: Listing 8.8 ItemList.test.jsx
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 ItemList.test.jsx
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Uses the generateItemText function to create the string by which the test
    will find an element indicating that the inventory has 2 cheesecakes
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 generateItemText 函数创建字符串，以便测试可以找到表示库存有 2 个芝士蛋糕的元素
- en: ❷ Uses the generateItemText function to create the string by which the test
    will find an element indicating that the inventory has 5 croissants
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 generateItemText 函数创建字符串，以便测试可以找到表示库存有 5 个羊角面包的元素
- en: ❸ Uses the generateItemText function to create the string by which the test
    will find an element indicating that the inventory has 96 macaroons
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 generateItemText 函数创建字符串，以便测试可以找到表示库存有 96 个马卡龙的元素
- en: Listing 8.9 App.test.jsx
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 App.test.jsx
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run your tests after these changes, you’ll see that they still pass.
    The only difference is that they’re now much more economical.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这之后运行测试，你会看到它们仍然通过。唯一的区别是它们现在更加经济。
- en: By creating a separate test for `generateItemText` and using this function within
    other tests, you have created a transitive guarantee. The two tests for your components
    trust that `generateItemText` works adequately, but there’s an additional test
    exclusively for `generateItemText` to ensure that this particular function works
    (figure 8.4).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为 `generateItemText` 创建单独的测试并在其他测试中使用此函数，你已经创建了一个传递性保证。你的组件的两个测试都信任 `generateItemText`
    工作得当，但还有一个专门针对 `generateItemText` 的测试来确保这个特定函数工作（图 8.4）。
- en: '![](../Images/CH08_F04_DaCosta.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_DaCosta.png)'
- en: Figure 8.4 How centralizing the dependency on `generateItemText` creates a transitive
    guarantee
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 集中依赖 `generateItemText` 如何创建传递性保证
- en: To see how much less maintenance overhead your tests generate, try changing
    the format of the text within `ItemList` so that the first letter of each item’s
    name is always capitalized and rerun your tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到你的测试生成的维护开销减少了多少，尝试更改 `ItemList` 中文本的格式，使得每个项目的名称的首字母总是大写，然后重新运行你的测试。
- en: Listing 8.10 ItemList.test.jsx
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 ItemList.test.jsx
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Capitalizes the first character of the item’s name
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将项目名称的首字符大写
- en: 'After rerunning your tests, you should see that only the tests for `generateItemText`
    itself will fail, but all the others have passed. To make all of your tests pass
    again, you have to update only one test: the test for `generateItemText`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试后，你应该看到只有 `generateItemText` 本身的测试会失败，但所有其他测试都通过了。要使所有测试再次通过，你只需要更新一个测试：`generateItemText`
    的测试。
- en: Listing 8.11 ItemList.test.jsx
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 ItemList.test.jsx
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Calls generateItemText with a few item names and quantities, and checks whether
    the result is correct, including whether the item’s first character has been capitalized
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用几个项目名称和数量调用 generateItemText，并检查结果是否正确，包括项目名称的首字符是否已大写
- en: '**When you have too many tests that depend on a single point of failure, centralize
    that point of failure into a single piece that you will use throughout your tests**,
    as you’ve done with `generateItemText`. Modularity can make both your application’s
    code and your tests more robust.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你有太多依赖于单一故障点的测试时，将这个故障点集中到一个你将在整个测试中使用的单一组件中**，就像你为 `generateItemText` 所做的那样。模块化可以使你的应用程序代码和测试更加健壮。'
- en: 8.1.1 Stubbing components
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 组件模拟
- en: You won’t always be able to test multiple components by rendering them to the
    DOM. Sometimes, you’ll have to wrap your components into others that have undesirable
    side effects or into components provided by third-party libraries, which, as I’ve
    previously mentioned, you shouldn’t test yourself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是能够通过将组件渲染到 DOM 中来测试多个组件。有时，你将不得不将你的组件包裹在其他具有不良副作用或第三方库提供的组件中，正如我之前提到的，你不应该自己测试这些组件。
- en: In this section, you will integrate `react-spring` into your application so
    that you can add animations to highlight new kinds of items entering or leaving
    the inventory. Then, you’ll learn how to use stubs to test your components without
    having to test `react-spring` itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将集成`react-spring`到你的应用程序中，以便你可以添加动画来突出显示进入或离开库存的新类型的项目。然后，你将学习如何使用存根来测试你的组件，而无需测试`react-spring`本身。
- en: First, install `react-spring` with `npm` `install` `react-spring` so that you
    can use it within `ItemList.jsx`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`npm install react-spring`安装`react-spring`，以便你可以在`ItemList.jsx`中使用它。
- en: NOTE Because of the type of exports `react-spring` uses, you will have to use
    a Browserify plugin called `esmify` when bundling your application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于`react-spring`使用的导出类型，在打包应用程序时，你将不得不使用一个名为`esmify`的Browserify插件。
- en: To use `esmify`, install it with `npm` `install` `--save-dev` `esmify`, and
    then update the `build` script in your `package.json` so that it uses `esmify`
    as a plugin.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`esmify`，使用`npm install --save-dev esmify`安装它，然后更新`package.json`中的`build`脚本，使其使用`esmify`作为插件。
- en: Listing 8.12 package.json
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 package.json
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Configures Browserify to use esmify when generating your bundle
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置Browserify在生成你的包时使用esmify
- en: Once you have installed `react-spring`, use the `Transition` component from
    `react-spring` to animate each item that enters or leaves the list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`react-spring`，使用`react-spring`中的`Transition`组件来动画化列表中进入或离开的每个项目。
- en: Listing 8.13 ItemList.jsx
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 ItemList.jsx
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ A Transition component that will animate each item entering or leaving the
    item list
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个将动画化进入或离开项目列表的每个项目的`Transition`组件
- en: ❷ A function that will be called with each one of the list’s items and return
    another function that takes a property representing the styles corresponding to
    the current state of the animation
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个将被列表的每个项目调用并返回另一个函数的函数，该函数接受一个表示动画当前状态的样式的属性
- en: ❸ A li element whose styles will correspond to the current state of the animation,
    causing each item to be animated
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个`li`元素，其样式将与动画的当前状态相对应，使每个项目都能进行动画
- en: NOTE You can find the complete documentation for `react-spring` at [https://www.react-spring.io/docs](https://www.react-spring.io/docs).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在[https://www.react-spring.io/docs](https://www.react-spring.io/docs)找到`react-spring`的完整文档。
- en: To try your application and see it animating the item list’s elements, run your
    application with `npm` `run build`, and, once you’ve served it with `npx` `http-server
    ./`, access `localhost:8080`. When testing your application, your backend must
    be available and running on port `3000`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试你的应用程序并查看它如何动画化项目列表的元素，使用`npm run build`运行你的应用程序，然后使用`npx http-server ./`提供服务，访问`localhost:8080`。在测试你的应用程序时，你的后端必须在端口`3000`上可用并正在运行。
- en: Now, when testing `ItemList`, you should be careful to *not* test the `Transition`
    component itself. Testing the `react-spring` library is a responsibility of its
    maintainers, and it can add extra complexity to your tests. If you think that
    the added complexity would not affect your tests significantly, you can always
    choose not to use any test doubles. Nevertheless, given that you’ll eventually
    have to do it, it will be useful for you to learn how to do so with the examples
    in this section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当测试`ItemList`时，你应该小心不要测试`Transition`组件本身。测试`react-spring`库是维护者的责任，并且可能会给你的测试增加额外的复杂性。如果你认为增加的复杂性不会显著影响你的测试，你始终可以选择不使用任何测试替身。然而，鉴于你最终必须这样做，学习如何使用本节中的示例来这样做将是有用的。
- en: The first thing you need to do to stub `Transition` adequately is to observe
    how it works so that you can reproduce its behavior accurately. In this case,
    the `Transition` component will call its child with each item passed to it through
    the `items` property and then call the resulting function with styles representing
    the transition’s state. This last function call will then return a `li` element
    containing the item’s text, which includes the generated `styles`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分模拟`Transition`组件，你需要首先观察其工作方式，以便能够准确地重现其行为。在这种情况下，`Transition`组件将使用`items`属性接收到的每个项目调用其子组件，然后使用表示转换状态的样式调用生成的函数。这个最后的函数调用将返回一个包含项目文本的`li`元素，其中包含生成的`styles`。
- en: To mock the `Transition` component consistently throughout your tests, start
    by creating a `*mocks*` folder in your project’s root, and inside that folder,
    create another one named `react-spring`. In that folder, you’ll create a file
    named `renderprops.jsx`, which will contain your mocks for the `renderprops` namespace
    of the `react-spring` library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要在测试中一致地模拟 `Transition` 组件，首先在项目根目录中创建一个 `*mocks*` 文件夹，然后在那个文件夹中创建一个名为 `react-spring`
    的另一个文件夹。在那个文件夹中，您将创建一个名为 `renderprops.jsx` 的文件，该文件将包含 `react-spring` 库的 `renderprops`
    命名空间中的模拟。
- en: Inside the `react-spring.jsx` file, create a `FakeReactSpringTransition` component
    and export it as `Transition`. This component should take `items` and `children`
    as properties. It will map over its items calling the function passed through
    `children`. Each of those calls will return a function that takes styles and returns
    a component instance. That function will then be called with an object representing
    a fake set of styles, causing child components to render.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `react-spring.jsx` 文件中，创建一个 `FakeReactSpringTransition` 组件并将其导出为 `Transition`。这个组件应该接受
    `items` 和 `children` 作为属性。它将遍历其项目，通过 `children` 传递的函数调用。每个这样的调用将返回一个函数，该函数接受样式并返回一个组件实例。然后，该函数将使用表示假样式集的对象调用，导致子组件渲染。
- en: Listing 8.14 renderprops.jsx
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 renderprops.jsx
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ A fake Transition component that calls each of its children with a list item
    and then calls the returned function with an object representing a fake set of
    styles. This final call causes the children that were supposed to be animated
    to render.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个假的 Transition 组件，它将列表项传递给每个子组件，然后使用表示假样式集的对象调用返回的函数。这个最后的调用导致应该被动画化的子组件渲染。
- en: Replacing the `Transition` component from `react-spring` with this test double
    will cause it to merely render each child as if there was no `Transition` component
    wrapping them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `react-spring` 中的 `Transition` 组件替换为这个测试双胞胎将导致它仅仅渲染每个子组件，就像没有 `Transition`
    组件包裹它们一样。
- en: To use this stub in your tests, call `jest.mock("react-spring/renderprops")`
    at the top of every test file in which you’d like to use the `FakeReactSpringTransition`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要在测试中使用这个存根，请在每个您想使用 `FakeReactSpringTransition` 的测试文件顶部调用 `jest.mock("react-spring/renderprops")`。
- en: Currently, you’re using `ItemList`, which depends on `Transition` in both `App.test.jsx`
    and `ItemList.test.jsx`, so go ahead and add a call to mock `react-spring/renderprops`
    to the top of each one of these files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您正在使用 `ItemList`，它在 `App.test.jsx` 和 `ItemList.test.jsx` 中都依赖于 `Transition`，所以请继续在每个这些文件顶部添加对
    mock `react-spring/renderprops` 的调用。
- en: Listing 8.15 App.test.jsx
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15 App.test.jsx
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Causes react-spring/renderprops to resolve to the stub you have created within
    mocks/react-spring
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致 react-spring/renderprops 解析到在 mocks/react-spring 中创建的存根
- en: Listing 8.16 ItemList.test.jsx
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 ItemList.test.jsx
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Causes react-spring/renderprops to resolve to the stub you have created within
    mocks/react-spring
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致 react-spring/renderprops 解析到在 mocks/react-spring 中创建的存根
- en: By creating a test double within the `*mocks*` folder and calling `jest.mock`,
    you’ll cause the import for `react-spring/renderprops` within `ItemList` to resolve
    to your mock, as shown in figure 8.5.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `*mocks*` 文件夹中创建一个测试双胞胎并调用 `jest.mock`，您将导致 `ItemList` 中对 `react-spring/renderprops`
    的导入解析到您的模拟，如图 8.5 所示。
- en: '![](../Images/CH08_F05_DaCosta.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F05_DaCosta.png)'
- en: Figure 8.5 How your test double is used by `ItemList` when running tests
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 当运行测试时，`ItemList` 如何使用您的测试双胞胎
- en: After using this test double, your components will behave similarly to how they
    were acting *before* the introduction of `react-spring`, so all your tests should
    still be passing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个测试双胞胎后，您的组件将表现得与引入 `react-spring` 之前的行为相似，因此所有测试都应该仍然通过。
- en: Thanks to this test double, you were able to avoid all the possible complexities
    involved with testing `react-spring`. Instead of testing `react-spring` yourself,
    you rely on the fact that its maintainers have already done so, and, therefore,
    you avoid testing third-party code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个测试双胞胎，您能够避免与测试 `react-spring` 相关的所有可能的复杂性。您不需要自己测试 `react-spring`，而是依赖于其维护者已经这样做的事实，因此避免了测试第三方代码。
- en: If you wanted to check the properties passed to `Transition`, you could also
    inspect your test double’s calls because you’ve used `jest.fn` to wrap your fake
    component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查传递给 `Transition` 的属性，您也可以检查您的测试双胞胎的调用，因为您已经使用 `jest.fn` 包装了您的假组件。
- en: When deciding whether you should mock components, think about whether you’ll
    be testing third-party code, how much complexity it will add to your test, and
    which aspects of the integrations between components you’d like to validate.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否要模拟组件时，考虑你是否将测试第三方代码，这将增加多少测试复杂性，以及你希望验证组件之间集成哪些方面。
- en: When testing my React applications, I try to avoid replacing components with
    test doubles as much as possible. If I have control over components, I’ll opt
    for extending `react-testing-library` or creating testing utilities which help
    me make my tests more maintainable. I only stub components which trigger undesirable
    side-effects that I can’t control, like, for example, animations. Using test doubles
    is also a good idea for when tests would become too long or convoluted without
    a stub.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我的 React 应用程序时，我尽量避免尽可能多地用测试替身替换组件。如果我能控制组件，我会选择扩展 `react-testing-library`
    或创建测试工具，这些工具可以帮助我使我的测试更具可维护性。我只对触发我无法控制的副作用（例如，动画）的组件进行存根。在没有存根的情况下，测试会变得太长或太复杂时，使用测试替身也是一个好主意。
- en: NOTE Enzyme, the alternative to `react-testing-library` that I mentioned in
    the previous chapter, makes it a bit easier to test components without having
    to stub their children. When using Enzyme, instead of manually creating test doubles,
    you can use its `shallow` method to avoid rendering child components.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在上一章中提到的 Enzyme，作为 `react-testing-library` 的替代品，使得在不存根子组件的情况下测试组件变得更容易。当使用
    Enzyme 时，你不需要手动创建测试替身，可以使用它的 `shallow` 方法来避免渲染子组件。
- en: The downside of `shallow` rendering components is that they decrease the resemblance
    between your run-time environment and your tests, as stubs do. Therefore, `shallow`
    rendering causes your tests’ guarantees to be weaker.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`浅渲染` 组件的缺点是，它们减少了你的运行时环境与测试之间的相似性，就像存根一样。因此，`浅渲染` 使得你的测试保证更弱。'
- en: As I’ve said many times throughout the book, it’s dangerous to say “*always*
    do this” or “*never* do that.” Instead, it’s more salutary to understand the pros
    and cons of each approach before deciding which one to adopt.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在书中多次提到的，说“*总是*这样做”或“*永远*不要这样做”是危险的。相反，在决定采用哪种方法之前，了解每种方法的优缺点更为有益。
- en: 8.2 Snapshot testing
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 快照测试
- en: To this day, Louis prefers to learn recipes by watching others bake than by
    reading recipes. It’s way easier to bake a delectable cake when you can compare
    the consistency of your batter and the look of your chocolate frosting to someone
    else’s.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到今天为止，路易斯更喜欢通过观看他人烘焙来学习食谱，而不是阅读食谱。当你能够将你的面糊的稠度和你的巧克力奶油霜的外观与他人进行比较时，烘焙美味的蛋糕要容易得多。
- en: As you test components, you can follow a similar approach. Whenever a component’s
    markup matches what you expect, you can take a snapshot of it. Then, as you iterate
    on your component, you can compare it to the snapshot you’ve taken to check if
    still renders the correct contents.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试组件时，你可以遵循类似的方法。每当一个组件的标记与你的预期相匹配时，你可以对其进行快照。然后，随着你对组件进行迭代，你可以将其与所拍摄的快照进行比较，以检查它是否仍然渲染了正确的内容。
- en: In this section, you’ll implement a component that logs everything that happens
    in a session and test that component using Jest’s snapshots. Throughout the process,
    I’ll explain the advantages and disadvantages of using snapshots and how to decide
    when to use it. Then, I’ll explain use cases for snapshots that go beyond testing
    React components.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将实现一个记录会话中发生的所有事件的组件，并使用 Jest 的快照来测试该组件。在整个过程中，我将解释使用快照的优势和劣势，以及何时决定使用它。然后，我将解释快照在测试
    React 组件之外的用例。
- en: Before you get to write any tests that involve snapshots, create a new component
    called `ActionLog`. This component will take an array of objects and render a
    list of actions. Each of the objects in the array will contain a `message` property
    informing *what* happened and a `time` property informing *when* it happened.
    Additionally, each of these objects can have a `data` property containing any
    other arbitrary information that can be useful, such as the response your application
    got from the server when loading items for the first time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写涉及快照的测试之前，创建一个新的组件名为 `ActionLog`。这个组件将接受一个对象数组并渲染一个动作列表。数组中的每个对象都将包含一个
    `message` 属性，告知发生了什么，以及一个 `time` 属性，告知发生的时间。此外，这些对象中的每一个都可以有一个 `data` 属性，包含任何其他可能有用的任意信息，例如，当加载第一次的项目时，你的应用程序从服务器收到的响应。
- en: Listing 8.17 ActionLog.jsx
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 ActionLog.jsx
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ An ActionLog component that takes an actions prop representing what happened
    within the application
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个 ActionLog 组件，它接受一个 actions 属性，表示应用程序内部发生的事情
- en: ❷ Iterates through each item within actions and generates a li element that
    informs the user what happened and when
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历 actions 中的每个项目并生成一个 li 元素，告知用户发生了什么以及何时发生
- en: Now, create a file called `ActionLog.test.jsx` in which you’ll write tests for
    the `ActionLog` component.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `ActionLog.test.jsx` 的文件，您将在其中编写 `ActionLog` 组件的测试。
- en: In this file, you’ll write your first snapshot test by using Jest’s `toMatchSnapshot`
    matcher.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，您将使用 Jest 的 `toMatchSnapshot` 匹配器编写您的第一个快照测试。
- en: This test will render `ActionLog` and check whether the rendered component matches
    a particular snapshot. To obtain the rendered component and compare it to a snapshot,
    you’ll use the `container` property from the `render` result and the `toMatchSnapshot`
    matcher.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试将渲染 `ActionLog` 并检查渲染的组件是否与特定的快照匹配。为了获取渲染的组件并将其与快照进行比较，您将使用 `render` 结果中的
    `container` 属性和 `toMatchSnapshot` 匹配器。
- en: Listing 8.18 ActionLog.test.jsx
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 ActionLog.test.jsx
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Converts a quantity of days to milliseconds
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将天数数量转换为毫秒
- en: ❷ Creates a static list of actions
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个静态操作列表
- en: ❸ Renders an instance of ActionLog with the static list of actions created within
    the test
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在测试中创建一个包含静态操作的 ActionLog 实例
- en: ❹ Expects the rendered elements to match a snapshot
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 期望渲染的元素与快照匹配
- en: When you execute this test for the first time, you’ll see that, in addition
    to the test passing, Jest also tells you that it has written one snapshot.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次执行此测试时，您会看到，除了测试通过之外，Jest 还会告诉您它已写入一个快照。
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Jest creates this file because the first time you run a test that uses snapshots,
    Jest has no previous snapshots to which it will compare your component. Therefore,
    it takes a snapshot of the component to use the next time you run the test, as
    shown in figure 8.6\. After Jest has saved a snapshot, in every subsequent execution
    of your test, Jest will compare the assertion’s target to the stored snapshot.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 创建此文件是因为您第一次运行使用快照的测试时，Jest 没有之前的快照可以与之比较。因此，它会对组件进行快照，以便在您下次运行测试时使用，如图
    8.6 所示。在 Jest 保存快照后，在您测试的每次后续执行中，Jest 都会将断言目标与存储的快照进行比较。
- en: '![](../Images/CH08_F06_DaCosta.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F06_DaCosta.png)'
- en: Figure 8.6 When Jest can’t find a snapshot for a test, it creates one using
    the content of the assertion’s target.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 当 Jest 找不到测试的快照时，它会使用断言目标的内 容创建一个快照。
- en: If you rerun your tests, you’ll see that Jest won’t say that it’s written a
    snapshot. Instead, it compares the existing snapshot to the assertion’s target
    and checks whether they match, as shown in figure 8.7\. If they do, the assertion
    passes. Otherwise, it throws an error.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新运行测试，您会看到 Jest 不会说它已写入快照。相反，它将现有的快照与断言目标进行比较，并检查它们是否匹配，如图 8.7 所示。如果它们匹配，则断言通过。否则，它会抛出一个错误。
- en: '![](../Images/CH08_F07_DaCosta.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F07_DaCosta.png)'
- en: Figure 8.7 When a snapshot exists, Jest compares the content of the assertion’s
    target with the snapshot’s content.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 当存在快照时，Jest 将断言目标的内 容与快照的内 容进行比较。
- en: Jest writes these snapshots to a folder adjacent to the test file in which it’s
    used. This folder is called *snapshots*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 将这些快照写入与测试文件相邻的文件夹中。这个文件夹被称为 *snapshots*。
- en: Now, open the *snapshots* folder in the root directory of your project, and
    take a look at the `ActionLog.test.jsx.snap` that’s inside.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您项目根目录下的 *snapshots* 文件夹，查看其中的 `ActionLog.test.jsx.snap` 文件。
- en: You’ll see that this file contains the name of your test and the markup that
    the `ActionLog` component rendered during the test.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到这个文件包含您的测试名称和 `ActionLog` 组件在测试期间渲染的标记。
- en: Listing 8.19 ActionLog.test.jsx.snap
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19 ActionLog.test.jsx.snap
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: NOTE This extra `div` in your snapshot is the div to which `react-testing-library`
    renders your component. To avoid having this extra `div` in your snapshots, instead
    of using `container` as your assertion’s target, use `container.firstChild`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您快照中的这个额外的 `div` 是 `react-testing-library` 渲染您的组件的 `div`。为了避免在快照中包含这个额外的
    `div`，请使用 `container.firstChild` 而不是 `container` 作为您的断言目标。
- en: If you pay close attention, you’ll notice that this file is just a JavaScript
    file that exports a string with your test’s name followed by a number that represents
    the `toMatchSnapshot` assertion to which it’s linked.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会注意到这个文件只是一个导出包含测试名称后跟一个数字的 JavaScript 文件，该数字代表与它关联的 `toMatchSnapshot`
    断言。
- en: When running your tests, Jest uses the test’s name and the order of the `toMatchSnapshot`
    assertion to obtain from the `.snap` file the string against which it will compare
    the assertion’s target.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，Jest 使用测试的名称和 `toMatchSnapshot` 断言的顺序从 `.snap` 文件中获取字符串，该字符串将用于与断言的目标进行比较。
- en: Important Be careful when generating snapshots. If your component renders incorrect
    contents, the markup against which Jest will compare your components is going
    to be incorrect, too.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：生成快照时要小心。如果你的组件渲染了错误的内容，Jest 将比较你的组件的标记也将是错误的。
- en: You should generate snapshots only once you’re sure your assertion’s target
    is correct. Alternatively, after running your test for the first time, you can
    also read the snapshot file’s contents to make sure that its contents are right.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在确定断言的目标正确后生成快照。或者，在第一次运行测试后，你也可以阅读快照文件的內容，以确保其正确性。
- en: In the same test, try creating a new log of actions, rendering another `ActionLog`
    component, and using `toMatchSnapshot` again.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的测试中，尝试创建一个新的动作日志，渲染另一个 `ActionLog` 组件，并再次使用 `toMatchSnapshot`。
- en: Listing 8.20 ActionLog.test.jsx
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 ActionLog.test.jsx
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Renders an ActionLog component with a static list of items
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 渲染一个带有静态项目列表的 ActionLog 组件
- en: ❷ Expects the ActionLog to match a snapshot
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 期望 ActionLog 匹配一个快照
- en: ❸ Creates a new list of items with an extra item
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个带有额外项目的项目列表
- en: ❹ Renders another ActionLog component with the new action list
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 渲染另一个带有新动作列表的 ActionLog 组件
- en: ❺ Expects the second ActionLog to match another snapshot
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 期望第二个 ActionLog 匹配另一个快照
- en: Once again, when you run this test, you’ll see that Jest will tell you that
    it’s written a snapshot.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行此测试时，你会看到 Jest 会告诉你它已经编写了一个快照。
- en: Jest had to write a new snapshot for this test because it couldn’t find a string
    in `ActionLog.test.jsx.snap` against which to compare the assertion’s target.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 必须为这个测试编写一个新的快照，因为它在 `ActionLog.test.jsx.snap` 中找不到与断言的目标进行比较的字符串。
- en: If you open the `ActionLog.test.jsx.snap` file again, you’ll see that it now
    exports two different strings, one for each `toMatchSnapshot` assertion.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次打开 `ActionLog.test.jsx.snap` 文件，你会看到它现在导出两个不同的字符串，每个 `toMatchSnapshot`
    断言一个。
- en: Listing 8.21 ActionLog.test.jsx.snap
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.21 ActionLog.test.jsx.snap
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now try changing the format of each log entry, and rerun your tests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试更改每个日志条目的格式，并重新运行你的测试。
- en: Listing 8.22 ActionLog.jsx
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.22 ActionLog.jsx
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After this change, because the rendered component won’t match the snapshot’s
    content anymore, your tests will fail.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，因为渲染的组件将不再匹配快照的内容，你的测试将失败。
- en: To make your tests pass again, run your tests with the `-u` option, which is
    short for `--updateSnapshot`. This option will cause Jest to update the snapshots
    for which the `toMatchSnapshot` matcher fails.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让测试再次通过，使用带有 `-u` 选项的测试运行，该选项是 `--updateSnapshot` 的简称。此选项将导致 Jest 更新那些 `toMatchSnapshot`
    匹配器失败的快照。
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: TIP If you’re using an NPM script to run your tests, append `--` to it to add
    options to the script. If you use an NPM `test` script to run tests, you can try
    using `npm` `run` `test` `--` `--updateSnapshot`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 如果你使用 NPM 脚本来运行测试，请向其追加 `--` 以添加选项到脚本中。如果你使用 NPM 的 `test` 脚本来运行测试，你可以尝试使用
    `npm run test -- --updateSnapshot`。
- en: Important Update snapshots only when you’re sure that your assertion’s target
    is correct. When you use the `--updateSnapshot` option, similar to when you generate
    snapshots for the first time, Jest will *not* cause any tests to fail if they
    don’t match a snapshot.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：只有当你确定断言的目标是正确的时才更新快照。当你使用 `--updateSnapshot` 选项时，与第一次生成快照时类似，如果测试不匹配快照，Jest
    不会导致任何测试失败。
- en: Once you’re done developing your component, if you’re using a version control
    system like `git`, **make sure to include snapshots in your commits**. Otherwise,
    your tests will *always* pass in others’ machines, because Jest will write new
    snapshot files, even if the component renders incorrect contents.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成组件的开发后，如果你使用像 `git` 这样的版本控制系统，**确保将快照包含在你的提交中**。否则，在其他机器上，你的测试将 *总是* 通过，因为
    Jest 将编写新的快照文件，即使组件渲染了错误的内容。
- en: Thanks to Jest’s snapshots, you were able to test your `ActionLog` component
    with tests that are much more concise. Instead of having to write multiple assertions
    containing long strings, you wrote a single assertion that is capable of validating
    your component’s entire content.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 Jest 的快照功能，你能够用更简洁的测试来测试你的 `ActionLog` 组件。你不需要编写包含长字符串的多个断言，只需编写一个能够验证组件整个内容的单个断言。
- en: Snapshots can be especially useful to replace a long set of complex assertions.
    Logs—long pieces of text—of complex components with fixed markup are examples
    of use cases in which Jest’s snapshots shine the brightest.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 快照可以特别有用，用于替换一组复杂的断言。具有固定标记的复杂组件的日志——长文本片段——是 Jest 快照最闪耀的使用案例之一。
- en: Because it’s so easy to create and update snapshots, you don’t need to update
    the assertions in your tests frequently. Avoiding having to update tests manually
    is especially useful when they involve multiple low-value, expensive changes,
    such as updating a bunch of similar strings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建和更新快照非常容易，你不需要频繁地更新测试中的断言。当测试涉及多个低价值、昂贵的更改时，避免手动更新测试特别有用，例如更新大量相似的字符串。
- en: By now, given how quick and easy it is to write and update tests that involve
    snapshots, they might seem like a unit-testing panacea, but they’re not always
    adequate for all kinds of tests.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，鉴于编写和更新涉及快照的测试既快又简单，它们可能看起来像是单元测试的万能药，但它们并不总是适用于所有类型的测试。
- en: One of the most apparent problems with snapshots is that it’s way too easy for
    mistakes to go unnoticed. Because snapshots are automatically generated, you might
    end up updating snapshots incorrectly, causing your tests to pass, even though
    the assertion’s target is incorrect.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 快照的一个最明显的问题是错误很容易被忽视。由于快照是自动生成的，你可能会错误地更新快照，导致测试通过，尽管断言的目标是不正确的。
- en: Even if you have a code-review process, when updating multiple snapshots at
    once, it’s easy to miss changes, especially if your snapshots are too big or if
    you change too much code at once.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你有代码审查流程，在一次性更新多个快照时，很容易错过更改，尤其是如果你的快照太大，或者你一次性更改了太多代码。
- en: NOTE In chapter 13, I’ll talk in more detail about how to perform useful code
    reviews.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在第13章中，我将更详细地讨论如何进行有用的代码审查。'
- en: To avoid updating snapshots unintendedly, avoid using the `--updateSnapshot`
    flag when running multiple tests. Use it sparingly, and only when running a single
    test file at a time, so that you know exactly which snapshots Jest updated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免意外更新快照，在运行多个测试时，请避免使用 `--updateSnapshot` 标志。要谨慎使用，并且仅在每次运行单个测试文件时使用，这样你才能确切知道
    Jest 更新了哪些快照。
- en: TIP Jest has a usage mode that allows you to update snapshots interactively.
    In the interactive snapshot mode, Jest will show you the diff for each snapshot
    that changed during the execution of your test and allow you to choose whether
    the new snapshot is correct.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：Jest 有一种交互式使用模式，允许你交互式地更新快照。在交互式快照模式下，Jest 将显示你测试执行期间每个更改的快照的 diff，并允许你选择新的快照是否正确。'
- en: To enter the interactive snapshot mode, run Jest with the `--watch` option,
    and press the `i` key.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入交互式快照模式，使用 `--watch` 选项运行 Jest，并按 `i` 键。
- en: Additionally, to make it easier for your colleagues to spot incorrect snapshots,
    avoid generating snapshots that are too long.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使你的同事更容易发现错误的快照，避免生成过长的快照。
- en: TIP If you’re using `eslint`, you can disallow large snapshots using the `no-large-snapshots`
    option from `eslint-plugin-jest`, about which you can find more details at [https://github.com/jest-community/eslint-plugin-jest](https://github.com/jest-community/eslint-plugin-jest).
    I’ll cover linters like `eslint` in depth in chapter 13.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：如果你正在使用 `eslint`，你可以通过 `eslint-plugin-jest` 中的 `no-large-snapshots`
    选项来禁止使用大快照，关于这个选项的更多详细信息，你可以在[https://github.com/jest-community/eslint-plugin-jest](https://github.com/jest-community/eslint-plugin-jest)找到。我将在第13章深入探讨像
    `eslint` 这样的代码检查器。'
- en: Another disadvantage of using snapshots is locking your test’s behavior to a
    specific output.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快照的另一个缺点是它会锁定测试的行为到特定的输出。
- en: If, for example, you have multiple tests for `ActionLog` and all of them use
    snapshots, all of them would fail if you decided to change the action log’s header.
    In contrast, with multiple small tests for different parts of your `ActionLog`
    component, you would have feedback that’s much more granular.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你为 `ActionLog` 有多个测试，并且所有这些测试都使用快照，那么如果你决定更改操作日志的标题，所有这些测试都会失败。相比之下，如果你为
    `ActionLog` 组件的不同部分编写多个小型测试，你会得到更细粒度的反馈。
- en: To avoid coarse feedback, while still reaping the benefits of snapshot testing,
    you can narrow which parts of your components you want to snapshot test. Besides
    making your tests more granular, this technique can also reduce the size of your
    snapshots.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免粗略的反馈，同时仍然获得快照测试的好处，你可以缩小你想要快照测试的组件部分。除了使你的测试更细粒度外，这种技术还可以减小快照的大小。
- en: If you wanted the test you’ve just written to check *only* the contents of the
    list in `ActionLog`, you could, for example, use only the `ul` element as the
    assertion target in your assertion that uses `toMatchSnapshot`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想检查你刚刚编写的测试中的 `ActionLog` 列表内容，例如，你可以在使用 `toMatchSnapshot` 的断言中仅使用 `ul`
    元素作为断言目标。
- en: Listing 8.23 ActionLog.test.jsx
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.23 ActionLog.test.jsx
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that you know how to do snapshot testing, you’ll update `App` so that it
    passes a list of actions to `ActionLog`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何进行快照测试，你将更新 `App` 以使其向 `ActionLog` 传递一个动作列表。
- en: First, update `App.jsx` so that it has a piece of state in which it will store
    an array of actions. The `App` component will then pass this piece of state to
    the `ActionLog` component it will render as one of its children.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新 `App.jsx` 以使其包含一个状态，它将存储一个动作数组。然后，`App` 组件将把这个状态传递给它将要渲染的 `ActionLog`
    组件作为其子项之一。
- en: Listing 8.24 App.jsx
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.24 App.jsx
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For the `ActionLog` component to have some initial content to display, make
    `App` update `actions` when it receives the server’s response containing the initial
    inventory items, as shown next.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `ActionLog` 组件有一些初始内容来显示，当 `App` 收到包含初始库存项目的服务器响应时，它应该更新 `actions`，如下所示。
- en: Listing 8.25 App.jsx
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.25 App.jsx
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Creates a piece of state to represent the application’s actions
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个状态片段来表示应用程序的动作
- en: ❷ Updates the state within App so that its list of actions includes an action
    informing that it has loaded a list of items from the server
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新 App 中的状态，使其动作列表包括一个通知从服务器加载项目列表的动作
- en: Now that you’ve written the markup for the `ActionLog` component and given it
    some data, build your application, serve it, and check the action log’s content.
    Once the client receives the initial items from the server, your action log should
    contain the response’s body and status.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了 `ActionLog` 组件的标记，并给它提供了一些数据，构建你的应用程序，提供服务，并检查动作日志的内容。一旦客户端从服务器接收到初始项目，你的动作日志应该包含响应体和状态。
- en: To test the `ActionLog` rendered by `App`, once again, you can use snapshot
    tests.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试由 `App` 渲染的 `ActionLog`，再次使用快照测试。
- en: First, to limit the snapshot tests to the `ActionLog` component, add a `data-testid`
    attribute to its outermost `div`, so that you can find it in your tests.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了将快照测试限制在 `ActionLog` 组件上，给其最外层的 `div` 添加一个 `data-testid` 属性，这样你就可以在测试中找到它。
- en: Listing 8.26 ActionLog.jsx
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.26 ActionLog.jsx
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this attribute in place, write a test that renders `App` and waits for
    the request to load items to resolve, and then use `toMatchSnapshot` to generate
    a snapshot for the contents of `ActionLog`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了这个属性之后，编写一个测试，渲染 `App` 并等待加载项目的请求解决，然后使用 `toMatchSnapshot` 为 `ActionLog`
    的内容生成一个快照。
- en: Listing 8.27 App.test.jsx
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.27 App.test.jsx
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Renders an instance of App
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 渲染 App 实例
- en: ❷ Waits for the rendered list of items to have three children
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待渲染的项目列表有三个子项
- en: ❸ Finds the action log container
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找动作日志容器
- en: ❹ Expects the action log to match a snapshot
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 期望动作日志匹配快照
- en: This test will pass the first time you run it, but it will fail in all subsequent
    executions. These failures happen because the snapshot that Jest generated for
    the action list includes the current time, which will change every time you rerun
    your test.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试第一次运行时会通过，但在所有后续执行中都会失败。这些失败发生是因为 Jest 为动作列表生成的快照包括了当前时间，这会每次你重新运行测试时都会改变。
- en: To make that test deterministic, you can use a fake timer, as you did in chapter
    5, or you can directly stub `toISOString` so that it always returns the same value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使那个测试具有确定性，你可以使用一个模拟计时器，就像你在第 5 章中所做的那样，或者你可以直接模拟 `toISOString`，使其始终返回相同的值。
- en: Listing 8.28 App.test.jsx
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.28 App.test.jsx
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Stubs the toIsoString in Date.prototype so that it always returns the same
    date
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Date.prototype 中模拟 toIsoString 方法，使其始终返回相同的日期
- en: ❷ Renders an instance of App
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 渲染 App 实例
- en: ❸ Waits for the rendered list of items to have three children
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 等待渲染的项目列表有三个子项
- en: ❹ Finds the action log container
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找动作日志容器
- en: ❺ Expects the action log to match a snapshot
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 期望动作日志匹配快照
- en: After this change, rerun your tests using the `--updateSnapshot` option. Then,
    after Jest updates the snapshot for this test, rerun your tests multiple times,
    and you’ll see that they’ll always pass.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改后，使用 `--updateSnapshot` 选项重新运行你的测试。然后，在 Jest 更新此测试的快照之后，多次重新运行你的测试，你会发现它们总是会通过。
- en: When using snapshots in your tests, make sure that your tests are deterministic.
    Otherwise, they will always fail after the first execution.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当在测试中使用快照时，请确保您的测试是确定的。否则，它们在第一次执行后总是会失败。
- en: As an exercise, update `App` so that it adds a new entry to the action log every
    time a user adds an item to the inventory. Then, test it using `toMatchSnapshot`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，更新 `App` 以便每次用户向库存添加项目时，它都会在操作日志中添加一个新条目。然后，使用 `toMatchSnapshot` 测试它。
- en: NOTE You can find this exercise’s solution at the `chapter8/2_snapshot _testing/1_component_snapshots`
    directory in this book’s repository on GitHub at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在本书 GitHub 仓库的 `chapter8/2_snapshot _testing/1_component_snapshots` 目录中找到此练习的解决方案：[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: 8.2.1 Snapshots beyond components
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 组件之外的快照
- en: Snapshot testing is not limited to testing React components. You can use it
    to test any kind of data, from React components to simple objects, or primitive
    values, like strings.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试不仅限于测试 React 组件。您可以使用它来测试任何类型的数据，从 React 组件到简单的对象，或原始值，如字符串。
- en: Imagine that you’ve built a small utility, shown next, that, given a list of
    items, quantities, and prices, writes a report to a `.txt` file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你已经构建了一个小工具，如下所示，它接受一个包含项目、数量和价格的列表，并将报告写入一个 `.txt` 文件。
- en: Listing 8.29 generate_report.js
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.29 generate_report.js
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Generates lines that inform each item’s quantity and the total value for each
    kind of item
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成每项数量的行以及每种物品的总价值
- en: ❷ Calculates the inventory’s total value
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算库存的总价值
- en: ❸ Generates the file’s final content
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成文件的最终内容
- en: ❹ Synchronously writes the report to a file
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 同步将报告写入文件
- en: To test this utility, instead of writing a long piece of text in your assertion,
    you could use Jest’s snapshot testing features to compare the generated value
    to a snapshot.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此实用程序，您可以在断言中而不是写一段长文本，使用 Jest 的快照测试功能将生成的值与快照进行比较。
- en: Try doing that by creating a file called `generate_report.test.js`, and write
    a test that calls `generateReport` with a list of items, reads from `/tmp/report.txt`,
    and compares the contents of that file to a snapshot.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个名为 `generate_report.test.js` 的文件，并编写一个调用 `generateReport` 并带有项目列表的测试，从
    `/tmp/report.txt` 读取，并将该文件的内容与快照进行比较。
- en: Listing 8.30 generate_report.test.js
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.30 generate_report.test.js
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '❶ Arrange: creates a static list of items'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：创建一个静态的项目列表
- en: '❷ Act: exercises the generateReport function'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行：调用 generateReport 函数
- en: ❸ Reads the generated file
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 读取生成的文件
- en: '❹ Assert: expects the file’s contents to match a snapshot'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：期望文件内容与快照匹配
- en: Once you’ve written this test, run it and check the contents of the `generate_report.test.js.snap`
    file within the `*snapshots*` folder. Inside that file, you’ll find a string containing
    the file’s content.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了此测试，运行它并检查 `snapshots` 文件夹中的 `generate_report.test.js.snap` 文件的内容。在该文件中，您将找到一个包含文件内容的字符串。
- en: Listing 8.31 generate_report.test.js.snap
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.31 generate_report.test.js.snap
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, whenever you rerun your tests, Jest will compare the contents of the `/tmp/report.txt`
    file with the contents in your snapshot, just like it did when testing React components,
    as shown in figure 8.8.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你重新运行测试时，Jest 都会将 `/tmp/report.txt` 文件的内容与快照中的内容进行比较，就像在测试 React 组件时一样，如图
    8.8 所示。
- en: '![](../Images/CH08_F08_DaCosta.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8](../Images/CH08_F08_DaCosta.png)'
- en: Figure 8.8 Jest creates a snapshot with the report’s contents the first time
    it runs. The second time it runs, it will compare the report’s actual content
    with what it had saved in the snapshot file.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 Jest 首次运行时创建包含报告内容的快照。第二次运行时，它将比较报告的实际内容与它保存在快照文件中的内容。
- en: This technique is handy for testing programs that transform code or that write
    to the terminal.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在测试转换代码或写入终端的程序时很有用。
- en: The Jest project, for example, uses itself and its snapshot testing features
    to validate the test summaries it generates. When Jest’s contributors write a
    new feature, they write tests that execute Jest and compare the contents that
    were written to the terminal through the `stdout` to snapshots.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Jest 项目使用它自己和其快照测试功能来验证它生成的测试摘要。当 Jest 的贡献者编写一个新功能时，他们会编写执行 Jest 并将写入终端的
    `stdout` 内容与快照进行比较的测试。
- en: 8.2.2 Serializers
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 序列化器
- en: For Jest to be able to write data to a snapshot, it needs to know how to serialize
    it properly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Jest 能够将数据写入快照，它需要知道如何正确地序列化它。
- en: When you were testing React components, for example, Jest knew how to serialize
    those components in such a way that makes your snapshots readable. This specialized
    serializer for React components, which appears in figure 8.9, is why you see beautiful
    HTML tags instead of a bunch of confusing objects in your snapshots.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在测试 React 组件时，例如，Jest 知道如何以使快照可读的方式序列化这些组件。如图 8.9 所示的这种专门用于 React 组件的序列化器，是为什么你在快照中看到的是漂亮的
    HTML 标签，而不是一大堆令人困惑的对象。
- en: '![](../Images/CH08_F09_DaCosta.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F09_DaCosta.png)'
- en: Figure 8.9 Jest’s serializers determine how to serialize the data it will save
    to a snapshot file.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 Jest 的序列化器决定了如何将数据序列化到快照文件中。
- en: Understandable snapshots improve the quality of your tests by making it easier
    for you to spot mistakes and for others to review your snapshots once you push
    your code to a remote repository.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 可理解的快照通过使你更容易发现错误，以及其他人一旦将代码推送到远程仓库后更容易审查你的快照，从而提高了测试的质量。
- en: At the time of this writing, the current version of Jest (26.6) already ships
    with serializers for all of JavaScript’s primitive types, HTML elements, React
    components, and ImmutableJS data structures, but you can also build your own.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Jest（26.6）的当前版本已经包含了所有 JavaScript 原始类型、HTML 元素、React 组件和 ImmutableJS
    数据结构的序列化器，但你也可以构建自己的。
- en: For example, you can use custom serializers to compare a component’s styles,
    as you’ll see in the next section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用自定义序列化器来比较组件的样式，正如你将在下一节中看到的。
- en: 8.3 Testing styles
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 测试样式
- en: Louis knows that most times the cherry on the cake isn’t just a detail. It’s
    actually what makes a customer decide whether they’ll bring home that sweet piece
    of dessert. When a cheesecake looks good, it definitely sells better.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯知道，大多数时候，蛋糕上的樱桃不仅仅是细节。它实际上是顾客决定是否带回家那块甜美甜点的关键。当芝士蛋糕看起来很棒时，它肯定能卖得更好。
- en: 'Similarly, a component’s style is an integral part of what determines whether
    you can ship it. If, for example, your component’s root element has a permanent
    `visibility: hidden` rule, it’s probably not going to be very useful to your users.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，组件的样式是决定你是否可以发布它的一个重要部分。例如，如果你的组件的根元素有一个永久的 `visibility: hidden` 规则，那么它可能对你的用户来说并不太有用。'
- en: In this section, you’ll learn how to test your component’s styles and what you
    can and can’t achieve with your tests.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何测试组件的样式，以及你可以和不能通过测试实现什么。
- en: To learn about how to test your component’s styles, you’ll make your application
    animate and highlight in `red` the items that are about to go out of stock. After
    implementing these changes, I’ll go through the testing process and explain what
    you can and can’t test, as well as which tools can help you produce better automated
    tests.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何测试组件的样式，你将使应用程序动画化，并将即将售罄的物品以 `红色` 突出显示。在实现这些更改后，我将介绍测试过程，并解释你可以和不能测试的内容，以及哪些工具可以帮助你产生更好的自动化测试。
- en: First, create a `styles.css` file in which you’ll write a class to style items
    that are about to go out of stock.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个 `styles.css` 文件，在其中编写一个类来样式化即将售罄的物品。
- en: Listing 8.32 styles.css
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.32 styles.css
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once you have created that file, add a `style` tag to your `index.html` to load
    it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了该文件，请向 `index.html` 添加一个 `style` 标签以加载它。
- en: Listing 8.33 index.html
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.33 index.html
- en: '[PRE34]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Loads styles.css
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载 styles.css
- en: Now that you can apply the rules in this class to the elements in your page,
    update `ItemList` so that it uses the `almost-out-of-stock` to style elements
    whose quantity is less than five.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将这个类的规则应用到页面中的元素上，更新 `ItemList` 以使用 `almost-out-of-stock` 来样式化数量少于五的元素。
- en: Listing 8.34 ItemList.jsx
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.34 ItemList.jsx
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Applies the almost-out-of-stock class to li elements representing items whose
    quantity is less than 5
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 `almost-out-of-stock` 类应用到代表数量少于 5 的物品的 li 元素上
- en: To see items whose quantity is less than five highlighted in red, rebuild your
    application, and manually try it out in your browser.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到数量少于五的物品以红色突出显示，重新构建你的应用程序，并在浏览器中手动尝试。
- en: Finally, it’s time to write an automated test for it. The test you’ll write
    should pass an `itemListprop` to the `ItemList` component and check whether the
    items whose quantity is less than five have the `almost-out-of-stock` class applied
    to them.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候为它编写自动化测试了。你将要编写的测试应该将 `itemListprop` 传递给 `ItemList` 组件，并检查数量少于五的物品是否应用了
    `almost-out-of-stock` 类。
- en: Listing 8.35 ItemList.test.jsx
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.35 ItemList.test.jsx
- en: '[PRE36]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '❶ Arrange: creates a static item list'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：创建静态项目列表
- en: '❷ Act: renders an instance of ItemList with the static list of items'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：渲染一个包含静态项目列表的ItemList实例
- en: ❸ Finds an element indicating that the inventory contains 2 cheesecakes
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到一个表示库存中有2个芝士蛋糕的元素
- en: '❹ Assert: expects the rendered li to have the almost-out-of-stock class'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：期望渲染的li元素具有almost-out-of-stock类
- en: Once you run your tests, they should all pass, but that doesn’t necessarily
    mean that they’re reliable. For example, the test you’ve just written will *not*
    fail if you change the name of the `almost-out-of-stock` class or any of its rules
    so that they don’t highlight items anymore.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了你的测试，它们都应该通过，但这并不一定意味着它们是可靠的。例如，你刚刚编写的测试在更改`almost-out-of-stock`类的名称或其规则，以便不再突出显示项目时，将不会失败。
- en: Try, for example, removing from `almost-out-of-stock` the CSS rule that sets
    `color` to `red`. If you do that and rerun your test, you’ll see that it will
    still pass, even though the application doesn’t highlight in `red` items that
    are about to become unavailable.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试从`almost-out-of-stock`中移除将`color`设置为`red`的CSS规则。如果你这样做并重新运行测试，你会发现它仍然会通过，即使应用程序不会用红色突出显示即将变得不可用的项目。
- en: When testing your styles, if you’re using an external CSS file, you will not
    be able to check whether the specific style rules within a class are applied.
    You will be able to check only whether a component’s `classname` property is correct.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试你的样式时，如果你使用外部CSS文件，你将无法检查类中特定的样式规则是否应用。你只能检查组件的`classname`属性是否正确。
- en: If you’re using external CSS files, I’d go as far as recommending you *not*
    assert on classes that don’t change. If, for example, you always apply a class
    called `item-list` to the `ul` element within `ItemList`, testing whether `ul`
    has a certain `className` will *not* be of much value. A test like that won’t
    ensure the component has the correct style rules applied to it, or that it looks
    the way it should. Instead, this test will generate more work because it will
    frequently break due to a completely arbitrary string, which doesn’t mean much
    in the context of your tests. If anything, you should write a snapshot test in
    this case.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用外部CSS文件，我甚至会建议你*不要*断言那些不会改变的类。例如，如果你总是将一个名为`item-list`的类应用到`ItemList`中的`ul`元素上，测试`ul`是否有特定的`className`将*不会*有很大的价值。这样的测试不会确保组件应用了正确的样式规则，或者它看起来应该是怎样的。相反，这个测试会产生更多的工作，因为它会频繁地因为一个完全随机的字符串而中断，这在你的测试上下文中并没有什么意义。在这种情况下，你最好写一个快照测试。
- en: One alternative to make your styling tests more valuable is to write inline
    styles within your components. Because these styles will contain rules that enforce
    that a component will look a certain way, you can write more specific assertions,
    which provide more reliable guarantees.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的样式测试更有价值的一个替代方案是在你的组件中编写内联样式。因为这些样式将包含强制组件以某种方式显示的规则，你可以编写更具体的断言，这提供了更可靠的保证。
- en: Try, for example, encapsulating the rules within `almost-out-of-stock` into
    a separate object in `ItemList.jsx`. Then, instead of using a class, use that
    object when rendering your `li` elements.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试将`almost-out-of-stock`中的规则封装到`ItemList.jsx`中的单独对象中。然后，在渲染你的`li`元素时，使用该对象而不是类。
- en: Listing 8.36 ItemList.jsx
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.36 ItemList.jsx
- en: '[PRE37]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ An object representing a set of styles to apply to items that are almost out
    of stock
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示要应用于即将缺货的项目的一组样式的对象
- en: ❷ If an item’s quantity is less than 5, merges the styles in the almostOutOfStock
    object with the styles generated by the animation provided by Transition; otherwise,
    just uses the animation’s styles
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果一个项目的数量少于5，则将almostOutOfStock对象中的样式与Transition提供的动画生成的样式合并；否则，只需使用动画的样式
- en: After this change, you’ll be able to assert on specific styles within your tests
    using the `toHaveStyle` assertion.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，你将能够在测试中使用`toHaveStyle`断言对特定的样式进行断言。
- en: Listing 8.37 ItemList.test.jsx
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.37 ItemList.test.jsx
- en: '[PRE38]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '❶ Arrange: creates a static item list'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：创建一个静态项目列表
- en: '❷ Act: renders an instance of ItemList with the static list of items'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：渲染一个包含静态项目列表的ItemList实例
- en: ❸ Finds an element indicating that the inventory contains 2 cheesecakes
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到一个表示库存中有2个芝士蛋糕的元素
- en: '❹ Assert: expects the rendered li to have a color property in its styles whose
    value is red'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：期望渲染的li元素在其样式中具有值为红色的颜色属性
- en: Thanks to this assertion, you’ll validate that your list renders items in red
    when they’re about to become unavailable.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个断言，你可以验证当项目即将变得不可用时，你的列表会以红色渲染项目。
- en: This strategy works well enough in most cases, but it has limitations. Even
    though you can assert individual style rule, you can’t ensure that your application
    will look like it should. It’s possible, for example, for components to appear
    on top of each other, for a particilar rule not to be supported on a certain browser,
    or for another stylesheet to interefere with your component’s styles.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略在大多数情况下效果不错，但它有局限性。尽管你可以断言单个样式规则，但你不能确保你的应用程序看起来应该是那样的。例如，组件可能会相互重叠，某个特定的规则可能不支持在某个浏览器上，或者另一个样式表可能会干扰你的组件样式。
- en: The only way to validate your application’s actual appearance is to use tools
    that use images to compare a browser’s render results to previous snapshots. This
    technique is known as visual regression testing, and you’ll learn more about it
    in chapter 10.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 验证应用程序实际外观的唯一方法是通过使用将浏览器渲染结果与之前的快照进行比较的图像的工具。这种技术被称为视觉回归测试，你将在第 10 章中了解更多关于它的内容。
- en: If you’re using inline styles, it may become repetitive to assert on multiple
    styles at a time or even impossible to perform animations. For example, what if
    you want items that are about to become unavailable to pulsate to make them even
    more noticeable?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用内联样式，同时断言多个样式可能会变得重复，甚至可能无法执行动画。例如，如果你想使即将变得不可用的项目产生脉冲效果，使其更加显眼怎么办？
- en: To address those cases more easily, you’ll now adopt my favorite strategies
    to style React components. You’ll use `css-in-js—`that is, you’ll use tools that
    allow you to use `CSS` syntax within your component’s files.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地处理这些情况，你现在将采用我最喜欢的策略来设置 React 组件的样式。你将使用 `css-in-js`——也就是说，你将使用允许你在组件文件中使用
    CSS 语法的工具。
- en: Besides making it easier to manage styles within your components, many CSS-in-JS
    libraries also enable you to extend tools like linters to make your automated
    quality assurance process even more reliable.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使你在组件内管理样式更加容易外，许多 CSS-in-JS 库还允许你扩展工具，如 linters，以使你的自动化质量保证过程更加可靠。
- en: I consider CSS-in-JS to be the best way to style React components because it
    solves many of the scoping problems that come with managing CSS in a way that’s
    compatible with the philosophy adopted by React. It makes your components encapsulate
    everything that they need to work correctly.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 CSS-in-JS 是设置 React 组件的最佳方式，因为它解决了与在兼容 React 采用的哲学的方式管理 CSS 相关的许多作用域问题。它使你的组件封装了它们正确工作所需的一切。
- en: To use CSS-in-JS, you’ll install a library made specifically for that. The library
    you’ll use is called `emotion`, and you can install it with `npm install @emotion/core`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 CSS-in-JS，你需要安装专门为此目的制作的库。你将使用的库名为 `emotion`，你可以使用 `npm install @emotion/core`
    来安装它。
- en: NOTE Because you’re using React, the `emotion` library documentation recommends
    you to use the `@emotion/core` package.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于你使用 React，`emotion` 库的文档建议你使用 `@emotion/core` 包。
- en: After installing `emotion`, before you implement the animation I mentioned,
    update the `ItemList` component so that it uses `emotion` to define the styles
    for list items that are about to become unavailable.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现我提到的动画之前，安装 `emotion` 后，更新 `ItemList` 组件，使其使用 `emotion` 定义即将变得不可用的列表项的样式。
- en: Listing 8.38 ItemList.jsx
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.38 ItemList.jsx
- en: '[PRE39]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Uses css from @emotion/core to create a set of styles that will be applied
    to items whose quantity is less than 5
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 @emotion/core 中的 css 创建一组应用于数量少于 5 的项目的样式
- en: ❷ Applies the styles created using emotion to the li elements that represent
    items whose quantity is less than 5
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将使用 emotion 创建的样式应用于表示数量少于 5 的 li 元素
- en: Before you run or update any tests, rebuild the application, and manually test
    it to see that your item list can still highlight in red the items that are almost
    out of stock.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行或更新任何测试之前，重新构建应用程序，并手动测试以确保你的项目列表仍然可以突出显示即将缺货的项目。
- en: Even though your application works, your tests will now fail, because your component
    does *not* use inline style properties to highlight items in red anymore. Instead,
    because of how `emotion` works, your application will have automatically generated
    classes for the rules you created with `emotion` and apply those classes to your
    elements.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的应用程序运行正常，你的测试现在也会失败，因为你的组件不再使用内联样式属性以红色突出显示项目。相反，由于`emotion`的工作方式，你的应用程序将自动生成你使用`emotion`创建的规则对应的类，并将这些类应用到你的元素上。
- en: TIP To see the classes that `emotion` generates when viewing your application
    in a browser, you can use the inspector to check which class names and rules are
    applied to each list item.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要查看在浏览器中查看您的应用程序时 `emotion` 生成的类，您可以使用检查器检查每个列表项应用了哪些类名和规则。
- en: To get around the fact that class names are automatically generated and still
    keep your assertions concise, rigorous, and precise, you’ll use the `jest-emotion`
    package. This package allows you to extend Jest with a `toHaveStyleRule` matcher
    that verifies the style rules applied by `emotion`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决类名自动生成的事实，同时保持您的断言简洁、严格和精确，您将使用 `jest-emotion` 包。此包允许您通过 `toHaveStyleRule`
    匹配器扩展 Jest，以验证 `emotion` 应用了哪些样式规则。
- en: Install `jest-emotion` as a dev dependency with `npm install --save-dev jest-emotion`,
    and then create a file called `setupJestEmotion.js`, which extends `jest` with
    the matchers from `jest-emotion`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm install --save-dev jest-emotion` 将 `jest-emotion` 作为开发依赖项安装，然后创建一个名为
    `setupJestEmotion.js` 的文件，该文件通过 `jest-emotion` 的匹配器扩展 `jest`。
- en: Listing 8.39 setupJestEmotion.js
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.39 setupJestEmotion.js
- en: '[PRE40]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Extends Jest with the matchers from jest-emotion
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `jest-emotion` 的匹配器扩展 Jest
- en: To cause `setupJestEmotion.js` to run before each test file, add it to the list
    of scripts in the `setupFilesAfterEnv` property in your `jest.config.js`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `setupJestEmotion.js` 在每个测试文件之前运行，将其添加到 `jest.config.js` 中 `setupFilesAfterEnv`
    属性的脚本列表中。
- en: Listing 8.40 jest.config.js
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.40 jest.config.js
- en: '[PRE41]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Before each test file, causes Jest to execute setupJestEmotion.js, which will
    extend Jest with the assertions from jest-emotion
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试文件之前，使 Jest 执行 `setupJestEmotion.js`，这将使用 `jest-emotion` 的断言扩展 Jest
- en: Finally, use the `toHaveStyleRule` matcher in the tests for `ItemList`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `ItemList` 的测试中使用 `toHaveStyleRule` 匹配器。
- en: Listing 8.41 ItemList.test.jsx
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.41 ItemList.test.jsx
- en: '[PRE42]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '❶ Arrange: creates a static item list'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：创建一个静态项目列表
- en: '❷ Act: renders an instance of ItemList with the static list of items'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：渲染一个包含静态项目列表的 ItemList 实例
- en: ❸ Finds an element indicating that the inventory contains 2 cheesecakes
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找一个元素，表示库存中有 2 个芝士蛋糕
- en: '❹ Assert: uses an assertion from jest-emotion to assert that the found li has
    a style rule called color whose value is red'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：使用 `jest-emotion` 的断言断言找到的 li 具有名为 color 的样式规则，其值为红色
- en: Once again, all your tests should pass.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，所有测试都应该通过。
- en: Now that you’re using `jest-emotion`, you still have the benefit of asserting
    on specific styling rules applied to your components, and you can also perform
    more complex tasks, such as animations.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您正在使用 `jest-emotion`，您仍然可以断言特定于组件的样式规则，并且您还可以执行更复杂的任务，例如动画。
- en: Go ahead and add an animation to the styles applied to items that are about
    to become unavailable.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以添加一个动画到即将变得不可用的项目应用的样式。
- en: Listing 8.42 ItemList.jsx
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.42 ItemList.jsx
- en: '[PRE43]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Creates an animation that will cause items whose quantity is less than 5 to
    pulsate
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个动画，使数量小于 5 的项目产生脉冲效果
- en: ❷ Creates styles to apply to li elements representing items whose quantity is
    less than 5\. These styles include the pulsate animation.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为表示数量小于 5 的项目的 li 元素创建应用样式。这些样式包括脉冲动画。
- en: ❸ Applies the styles created using emotion to the li elements that represent
    items whose quantity is less than 5
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将使用 emotion 创建的样式应用于表示数量小于 5 的项目的 li 元素
- en: Thanks to `emotion`, the items that are about to go out of stock should now
    include a pulsating animation.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `emotion`，即将售罄的项目现在应该包含一个脉冲动画。
- en: After this change, I’d highly recommend you to use Jest’s snapshot features
    so that you can avoid writing any long and complicated strings in your assertions.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，我强烈建议您使用 Jest 的快照功能，这样您就可以避免在断言中编写任何长而复杂的字符串。
- en: Update your tests so that they match the list’s element style to a snapshot.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 更新您的测试，以便它们将列表元素的样式匹配到快照。
- en: Listing 8.43 ItemList.test.jsx
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.43 ItemList.test.jsx
- en: '[PRE44]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Creates a static item list
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个静态项目列表
- en: ❷ Renders an instance of ItemList with the static list of items
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 渲染一个包含静态项目列表的 ItemList 实例
- en: ❸ Finds an element indicating that the inventory contains 2 cheesecakes
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找一个元素，表示库存中有 2 个芝士蛋糕
- en: ❹ Expects the found li to match a snapshot
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 期望找到的 li 与快照匹配
- en: After running this test for the first time so that Jest can create a snapshot,
    rerun it a couple more to see that it always passes.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此测试第一次以使 Jest 可以创建快照之后，再运行几次以查看它总是通过。
- en: The problem with this test is that its snapshot isn’t very informative or easy
    to review. If you open the snapshot created for this test, you’ll see that it
    contains a cryptic class name instead of the component’s actual style.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的问题在于其快照信息量不大，也不容易审查。如果您打开为这个测试创建的快照，您会看到它包含一个神秘的类名，而不是组件的实际样式。
- en: Listing 8.44 ItemList.test.jsx.snap
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.44 ItemList.test.jsx.snap
- en: '[PRE45]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you recall what I said in the previous section, snapshots that aren’t informative
    make it easy for you and for the people reviewing your code to miss important
    changes and for mistakes to go unnoticed.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我在上一节中提到的话，没有信息量的快照会让您和审查您代码的人很容易错过重要的更改，错误也可能被忽视。
- en: To solve this problem, extend Jest with a custom serializer provided to you
    by `jest-emotion`. As illustrated in figure 8.10, this serializer will tell Jest
    how to serialize `emotion` styles properly so that your snapshots are readable
    and understandable. Thanks to the serializer included in `jest-emotion`, your
    snapshots will contain actual CSS rules instead of cryptic class names.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，使用`jest-emotion`提供的自定义序列化器扩展Jest。如图8.10所示，这个序列化器将告诉Jest如何正确地序列化`emotion`样式，以便您的快照可读且易于理解。感谢`jest-emotion`中包含的序列化器，您的快照将包含实际的CSS规则，而不是神秘的类名。
- en: '![](../Images/CH08_F10_DaCosta.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F10_DaCosta.png)'
- en: Figure 8.10 The serializer included in `jest-emotion` causes Jest to write snapshots
    that include actual CSS rules instead of cryptic class names.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 `jest-emotion`中包含的序列化器导致Jest写入包含实际CSS规则而不是神秘类名的快照。
- en: Update `jest.config.js`, and assign an array containing `jest-emotion` to the
    `snapshotSerializers` property.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`jest.config.js`，并将包含`jest-emotion`的数组分配给`snapshotSerializers`属性。
- en: Listing 8.45 jest.config.js
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.45 jest.config.js
- en: '[PRE46]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Extends Jest with a serializer from jest-emotion so that it knows how to serialize
    styles properly, including all rules within snapshots instead of including only
    cryptic class names
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用来自jest-emotion的序列化器扩展Jest，以便它知道如何正确地序列化样式，包括快照中的所有规则，而不是只包含神秘的类名
- en: Now that Jest knows how to serialize styles created by `emotion`, rerun your
    tests with the `--updateSnapshot` flag, and check that snapshot file again.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Jest知道如何序列化`emotion`创建的样式后，使用`--updateSnapshot`标志重新运行测试，并再次检查快照文件。
- en: Listing 8.46 ItemList.test.jsx.snap
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.46 ItemList.test.jsx.snap
- en: '[PRE47]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Because the snapshot file now contains readable information about the styles
    applied to your component, your snapshots are much easier to review, making it
    much quicker to spot mistakes.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 由于快照文件现在包含关于应用于您组件的样式的可读信息，您的快照更容易审查，这使得快速发现错误变得更快。
- en: Whenever you’re dealing with complex styles, try using a snapshot instead of
    manually writing multiple cumbersome and repetitive assertions.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理复杂样式时，尝试使用快照而不是手动编写多个繁琐且重复的断言。
- en: As an exercise, try applying a different style and animation to the items of
    which you have too many in the inventory, and then, test them using the techniques
    you’ve learned in this section.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试将不同的样式和动画应用到库存中过多的项目上，然后，使用您在本节中学到的技术测试它们。
- en: Styling is one case in which your choice of tooling can have a profound impact
    on how you write your tests. Therefore, it’s an excellent example to demonstrate
    that you should also take testing into account when choosing what kinds of libraries
    and frameworks you’ll use to build your application.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 样式是一个例子，您的工具选择可以深刻影响您编写测试的方式。因此，它是一个很好的例子，说明在选择构建应用程序时使用的库和框架时，也应该考虑测试。
- en: 8.4 Component-level acceptance tests and component stories
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 组件级验收测试和组件故事
- en: Before couples hire Louis for their wedding’s dessert buffet, they always schedule
    a tasting session first. In these sessions, Louis prepares many different desserts,
    from éclairs and pralines to cakes and pies, so that his clients can see and taste
    each of his heavenly dishes.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在夫妇聘请路易斯为他们婚礼的甜点自助餐之前，他们总是会先安排一个品鉴会。在这些会上，路易斯准备了多种不同的甜点，从羊角面包和杏仁糖到蛋糕和派，以便他的客户可以看到并品尝他每一道天赐佳肴。
- en: Writing stories is similar to preparing a tasting buffet of components. **A
    story is a demonstration of a component’s particular use case or visual state**.
    A story showcases the functionalities of an individual component so that you and
    your team can visualize and interact with the component without having to run
    an entire application.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 编写故事类似于准备一个组件的品尝自助餐。**故事是组件特定用例或视觉状态的演示**。故事展示了单个组件的功能，以便你和你的团队能够可视化并与之交互，而无需运行整个应用程序。
- en: Think about what you had to do to see `ItemList` working, for example. To see
    `ItemList`, you had to write the component itself, use it within `App`, add a
    few items to the database, and make your application fetch the inventory items
    from your server. Additionally, you also had to build your frontend application,
    build a backend, and migrate and seed databases.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你需要做什么才能看到 `ItemList` 工作，例如。要看到 `ItemList`，你必须编写组件本身，在 `App` 中使用它，向数据库添加一些项目，并让应用程序从你的服务器获取库存项目。此外，你还必须构建你的前端应用程序，构建后端，迁移和初始化数据库。
- en: With a story, you can write pages that include various instances of `ItemList`,
    with different sets of static data. The first advantage of this technique is that
    you will be able to see and interact with `ItemList` much earlier in the development
    process, even before you start using it in your actual application.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用故事，你可以编写包含 `ItemList` 不同实例和不同静态数据集的页面。这种技术的第一个优点是，你将能够在开发过程中更早地看到并交互 `ItemList`，甚至在开始在实际应用程序中使用它之前。
- en: Besides accelerating the feedback loop, stories facilitate the collaboration
    among teams, because they allow anyone, at any moment, to experiment with components
    and see how they look.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加速反馈循环外，故事还促进了团队之间的协作，因为它们允许任何人在任何时候实验组件并查看它们的样式。
- en: By writing stories, you enable others to perform acceptance testing at the component
    level. Instead of having to create a separate environment for QA or product teams
    to validate whether your UI is acceptable, with stories, these teams can test
    each component individually and much more quickly.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写故事，你使其他人能够在组件级别执行验收测试。而不是为 QA 或产品团队创建一个单独的环境来验证你的 UI 是否可接受，有了故事，这些团队可以单独测试每个组件，并且速度更快。
- en: In this section, you’ll learn how to write component stories and document your
    components using Storybook. You’ll start with `ItemList` and then proceed to write
    stories for all components other than `App`. Once you’ve written multiple stories,
    I’ll dig deeper into the role that they play in streamlining your development
    process, fostering collaboration, and improving quality.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 Storybook 编写组件故事并记录你的组件。你将从 `ItemList` 开始，然后继续编写除 `App` 之外的所有组件的故事。一旦你编写了多个故事，我将深入探讨它们在简化开发过程、促进协作和提高质量方面所起的作用。
- en: After writing stories, I’ll teach you how to document your components and why
    it’s helpful to do so.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 编写故事后，我将教你如何记录你的组件，以及为什么这样做是有益的。
- en: 8.4.1 Writing stories
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 编写故事
- en: To write your component stories, you’ll use a tool called Storybook. Storybook
    is capable of loading your stories and displaying them through an organized and
    understandable UI.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写你的组件故事，你将使用一个名为 Storybook 的工具。Storybook 能够加载你的故事并通过一个有组织且易于理解的 UI 显示它们。
- en: First, install Storybook for React as a dev dependency with `npm install --save-dev
    @storybook/react`. Then, for Storybook to be able to bundle the application that
    you’ll use to navigate stories, you must install `babel-loader` using `npm install
    --save-dev babel-loader`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `npm install --save-dev @storybook/react` 将 Storybook for React 作为开发依赖项安装。然后，为了让
    Storybook 能够打包你将用于导航故事的应用程序，你必须使用 `npm install --save-dev babel-loader` 安装 `babel-loader`。
- en: Once you’ve installed these two packages, you’ll have to configure Storybook
    by creating a `.storybook` folder in your project’s root directory. Within that
    folder, you’ll place a `main.js` configuration file that determines which files
    Storybook will load as stories.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这两个包后，你需要在项目的根目录中创建一个 `.storybook` 文件夹来配置 Storybook。在该文件夹内，你将放置一个 `main.js`
    配置文件，该文件确定 Storybook 将加载哪些文件作为故事。
- en: Listing 8.47 main.js
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.47 main.js
- en: '[PRE48]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Informs Storybook which files contain your stories
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通知 Storybook 哪些文件包含你的故事
- en: 'NOTE At the moment of this writing, I’m using the latest available version
    of Storybook: version 6\. In this version, there’s a problem in the Storybook
    toolchain that causes it not to find some of the files it needs during the build
    process.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在撰写本文时，我正在使用 Storybook 的最新可用版本：版本 6。在这个版本中，Storybook 工具链中存在一个问题，导致它在构建过程中找不到它需要的某些文件。
- en: If you wish to use version 6 of Storybook, you may need to update your Storybook
    configuration so that it tells Webpack where to find the files it needs during
    the build process, as shown next.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用 Storybook 的版本 6，您可能需要更新您的 Storybook 配置，以便它告诉 Webpack 在构建过程中在哪里找到所需的文件，如下所示。
- en: Listing 8.48 main.js
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.48 main.js
- en: '[PRE49]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After creating this file, you can start Storybook by running `./node_modules/.bin/start-storybook`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此文件后，您可以通过运行 `./node_modules/.bin/start-storybook` 来启动 Storybook。
- en: TIP To avoid having to type the full path to the Storybook executable whenever
    you want to run it, add to your `package.json` file a script called `storybook`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了避免每次运行 Storybook 时都不得不输入完整的 Storybook 可执行文件路径，请将名为 `storybook` 的脚本添加到您的
    `package.json` 文件中。
- en: Listing 8.49 package.json
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.49 package.json
- en: '[PRE50]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Creates an NPM script that will start Storybook when you execute npm run storybook
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 NPM 脚本，当您执行 npm run storybook 时启动 Storybook
- en: Now you can run Storybook with `npm run storybook` instead of typing the full
    path to the `start-storybook` executable.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 `npm run storybook` 运行 Storybook，而不是输入 `start-storybook` 可执行文件的完整路径。
- en: When you start Storybook, it will create a web application that allows you to
    navigate through your component stories. Once it bundles this web application,
    Storybook will serve it and open it in a new browser tab.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动 Storybook 时，它将创建一个允许您浏览组件故事的 Web 应用程序。一旦它打包了这个 Web 应用程序，Storybook 将提供它并在新浏览器标签页中打开。
- en: TIP To facilitate the exchange of information among your development, design,
    and product teams, you can deploy the application generated by Storybook to a
    place where every member of these teams has access.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了促进开发、设计和产品团队之间的信息交流，您可以将 Storybook 生成的应用程序部署到每个团队成员都可以访问的地方。
- en: To create your first story for the `ItemList` component, add a file called `ItemList.stories.jsx`.
    Within this file, you’ll export an object with the metadata for the group of stories
    you’ll write and the name of each story you want Storybook to display.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `ItemList` 组件创建第一个故事，添加一个名为 `ItemList.stories.jsx` 的文件。在这个文件中，您将导出一个对象，其中包含您将要编写的故事的组元数据以及
    Storybook 要显示的每个故事的名称。
- en: To write an individual story, create a named export whose value is a function
    that returns the component you want to showcase.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个单独的故事，创建一个具有值的命名导出，该值是一个返回您想要展示的组件的函数。
- en: Listing 8.50 ItemList.stories.jsx
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.50 ItemList.stories.jsx
- en: '[PRE51]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Configures the set of stories for ItemList, informing the title for those
    stories, the component to which they relate, and which stories to include
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 ItemList 的故事集，告知这些故事的标题、相关组件以及要包含的故事
- en: ❷ Creates a story that renders an instance of ItemList with a static list of
    items
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个渲染静态项目列表的 ItemList 实例的故事
- en: Once you’ve written this story, you’ll see that your Storybook instance renders
    an `ItemList`, just like `App` does. Because you’ve written static data to populate
    `ItemList`, you don’t need any servers running or any data that comes from the
    rest of your application.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您编写了这个故事，您会看到您的 Storybook 实例渲染了一个 `ItemList`，就像 `App` 一样。因为您已经将静态数据写入 `ItemList`，所以您不需要运行任何服务器或从应用程序的其他部分获取数据。
- en: As soon as your component can be rendered, you can see and interact with it
    through a story.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的组件可以渲染，您就可以通过故事查看并与之交互。
- en: Now that you have a story for `ItemList`, everyone in your team will be able
    to see how it looks and interact with it atomically. Whenever they need to change
    `ItemList`, they can quickly iterate by using your story, instead of having to
    deal with your entire application.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您为 `ItemList` 创建了故事，您团队中的每个人都可以看到它的外观并原子化地与之交互。每当他们需要更改 `ItemList` 时，他们可以通过使用您的这个故事快速迭代，而不是处理整个应用程序。
- en: Despite this story making it quicker and more accessible for people to change
    and interact with `ItemList`, it doesn’t yet demonstrate all the functionality
    of this component.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个故事使人们更改和与 `ItemList` 交互更快、更便捷，但它尚未展示该组件的所有功能。
- en: To show how `ItemList` will animate items entering or leaving the inventory
    and, therefore, cover the full range of this component’s capabilities, you’ll
    write a new story. This story should return a stateful component that includes
    `ItemList` and two buttons that update the outer component’s state. One of the
    buttons will add an item to the list, and the other will reset `ItemList` to its
    original state.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `ItemList` 将如何动画化项目进入或离开库存，并因此覆盖该组件功能的全部范围，你需要编写一个新的故事。这个故事应该返回一个包含 `ItemList`
    和两个按钮的有状态组件，这两个按钮会更新外部组件的状态。其中一个按钮将向列表添加项目，另一个将 `ItemList` 重置到其原始状态。
- en: Listing 8.51 ItemList.stories.jsx
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.51 ItemList.stories.jsx
- en: '[PRE52]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ❶ A story to demonstrate how ItemList animates items entering or leaving it
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个演示 ItemList 如何动画化进入或离开它的故事
- en: ❷ Creates a static list of items
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个静态的项目列表
- en: ❸ The stateful component that the story will render
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 故事将渲染的有状态组件
- en: ❹ A piece of state containing an item list
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 包含项目列表的状态对象
- en: ❺ A function that adds 96 macaroons to the list
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一个向列表添加 96 个马卡龙的函数
- en: ❻ A function that resets the list to its initial state
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 一个将列表重置为其初始状态的功能
- en: ❼ Causes the stateful component to return buttons to add items and reset the
    list of items and a div with an instance of ItemList whose itemList prop is the
    list of items in the stateful component’s state
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 导致有状态的组件返回添加项目和重置项目列表的按钮，以及一个包含 `ItemList` 实例的 div，其 `itemList` prop 是有状态组件状态中的项目列表
- en: ❽ Renders an instance of the stateful component
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 渲染有状态组件的一个实例
- en: Whenever you need to make it possible to interact with your components, you
    can create a stateful wrapper, as you’ve just done. The problem with these wrappers
    is that they add an extra layer of complexity to your stories and constrain the
    viewer’s interactions to what you’ve initially thought they’d want to do.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要使你的组件能够进行交互时，你可以创建一个有状态的包装器，就像你刚刚做的那样。这些包装器的问题在于，它们为你的故事添加了一个额外的复杂层，并限制了观众的交互，使其仅限于你最初认为他们可能想要做的事情。
- en: Instead of using stateful wrappers, you can use a package called `@storybook/addon-knobs`
    to allow viewers to manipulate the `props` passed to your components in whichever
    way they want.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用有状态的包装器不同，你可以使用一个名为 `@storybook/addon-knobs` 的包来允许观众以他们想要的方式操纵传递给组件的 `props`。
- en: The `@storybook/addon-knobs` add-on adds a new tab to Storybook’s bottom panel
    in which viewers can change, on the fly, the values of any `props` associated
    with your stories.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`@storybook/addon-knobs` 插件向 Storybook 底部面板添加了一个新标签页，观众可以在其中实时更改与你的故事相关联的任何
    `props` 的值。'
- en: Go ahead and install `@storybook/addon-knobs` as a dev dependency with `npm
    install --save-dev @storybook/addon-knobs`. Then, update your `.storybook/main.js`
    file, and add an `addons` property to it. This property’s value will be an array
    containing the list of add-ons that Storybook should load.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm install --save-dev @storybook/addon-knobs` 将 `@storybook/addon-knobs`
    作为开发依赖项安装。然后，更新你的 `.storybook/main.js` 文件，并向其中添加一个 `addons` 属性。此属性的值将是一个数组，包含
    Storybook 应加载的插件列表。
- en: Listing 8.52 main.js
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.52 main.js
- en: '[PRE53]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Configures Storybook to use the @storybook/addon-knobs add-on
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Storybook 使用 @storybook/addon-knobs 插件
- en: With this add-on, you can update your stories so that `@storybook/addon-knobs`
    will manage the `props` passed to your components.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个插件，你可以更新你的故事，以便 `@storybook/addon-knobs` 将管理传递给组件的 `props`。
- en: Listing 8.53 ItemList.stories.jsx
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.53 ItemList.stories.jsx
- en: '[PRE54]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ Configures the stories for ItemList so that they can use the knobs add-on
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 ItemList 的故事，以便它们可以使用 knobs 插件
- en: ❷ Creates an itemList object that will be managed by the knobs add-on
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个将由 knobs 插件管理的 `itemList` 对象
- en: ❸ Renders an instance of ItemList whose itemList prop is the object managed
    by knobs
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 渲染一个 `ItemList` 的实例，其 `itemList` prop 是由 knobs 管理的对象
- en: Once you’ve used your new add-on to pass a managed property to `ItemList`, open
    Storybook and try to change the `itemListprop` through the Knobs tab on the bottom
    of the story called “animated items.” As you change these properties, you’ll see
    that the component updates, animating the items entering or leaving the list.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用你的新插件将管理的属性传递给 `ItemList`，打开 Storybook 并尝试通过故事底部的“动态项目”标签页更改 `itemListprop`。当你更改这些属性时，你会看到组件更新，动画化项目进入或离开列表。
- en: The flexibility provided by `@storybook/addon-knobs` makes it easier for testers
    to scrutinize your components, simulate edge cases, and perform exploratory testing.
    For product teams, this flexibility will result in a better insight into your
    component’s capabilities.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`@storybook/addon-knobs` 提供的灵活性使得测试人员更容易审查你的组件，模拟边缘情况，并执行探索性测试。对于产品团队来说，这种灵活性将导致对你组件功能的更深入了解。'
- en: Now that you’ve written stories for `ItemList`, you’ll write one for `ItemForm`,
    too. Within your project’s root directory, create a file called `ItemForm.stories.jsx`,
    and write a story that renders your form and shows an alert when users submit
    it.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为 `ItemList` 编写了故事，你也将为 `ItemForm` 编写一个。在你的项目根目录中创建一个名为 `ItemForm.stories.jsx`
    的文件，并编写一个故事，渲染你的表单并在用户提交时显示警告。
- en: Listing 8.54 ItemForm.stories.jsx
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.54 ItemForm.stories.jsx
- en: '[PRE55]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Configures the set of stories for ItemForm, informing their title, the component
    to which they relate, and which stories to include
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 ItemForm 的故事集，包括它们的标题、相关的组件以及要包含的故事
- en: ❷ A story for ItemForm that displays an alert when an item is added
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个显示当添加项目时发出警告的 ItemForm 故事
- en: Even though this story renders your component and shows an alert with the submitted
    data, `ItemForm` is still sending requests to your backend. If you’re running
    your server while interacting with this component’s this story, you’ll see that
    your database does get updated when you submit `ItemForm`. To avoid `ItemForm`
    sending any requests to your backend, you must stub that functionality.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个故事渲染了你的组件并显示了一个包含提交数据的警告，但 `ItemForm` 仍然在向你的后端发送请求。如果你在交互这个组件的故事时运行服务器，你会看到当提交
    `ItemForm` 时，你的数据库确实被更新了。为了避免 `ItemForm` 向后端发送任何请求，你必须模拟该功能。
- en: Previously you have used `nock` to create interceptors that would respond to
    HTTP requests, but you won’t be able to use it in Storybook. Because `nock` depends
    on Node.js-specific modules, like `fs`, it can’t run on your browser.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 之前你使用 `nock` 来创建响应 HTTP 请求的拦截器，但在 Storybook 中你将无法使用它。因为 `nock` 依赖于 Node.js 特定的模块，如
    `fs`，所以它不能在浏览器上运行。
- en: Instead of using `nock` to intercept and respond to HTTP requests, you’ll use
    a package called `fetch-mock` instead. Its API is similar to `nock`’s, and it
    works in a browser.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不再使用 `nock` 来拦截和响应 HTTP 请求，而是使用一个名为 `fetch-mock` 的包。它的 API 与 `nock` 类似，并且可以在浏览器中工作。
- en: Install `fetch-mock` as a dev dependency with `npm install --save-dev fetch-mock`,
    and update `ItemForm.stories.jsx` so that you have an interceptor for the `POST`
    request that `ItemForm` performs.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm install --save-dev fetch-mock` 安装 `fetch-mock` 作为开发依赖项，并更新 `ItemForm.stories.jsx`
    以便你有一个拦截器来处理 `ItemForm` 执行的 `POST` 请求。
- en: Listing 8.55 ItemForm.stories.jsx
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.55 ItemForm.stories.jsx
- en: '[PRE56]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Creates an interceptor that responds to any POST requests to /inventory/*
    with a 200 status
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个响应任何对 /inventory/* 的 POST 请求并返回 200 状态的拦截器
- en: After using `fetch-mock` to intercept requests, `ItemForm` will never reach
    your backend, and you will always get successful responses. To confirm that `ItemForm`
    doesn’t dispatch any HTTP requests, try interacting with your form’s story and
    submitting a few items while having your developer tool’s Network tab open.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `fetch-mock` 拦截请求后，`ItemForm` 将永远不会到达你的后端，你将始终得到成功的响应。为了确认 `ItemForm` 不会发出任何
    HTTP 请求，尝试与你的表单故事进行交互，并在你的开发者工具的网络标签打开的情况下提交几个项目。
- en: Now, the last step to make this story complete is to clear the interceptor you’ve
    written so that it won’t interfere in other stories. Currently, when you open
    your form’s story, it will create an interceptor that will persist until the user
    refreshes the story viewer. That interceptor could affect other stories, if, for
    example, you had another story that sent requests to the same URL as `ItemForm`
    does.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使这个故事完整化的最后一步是清除你编写的拦截器，这样它就不会干扰其他故事。目前，当你打开你表单的故事时，它将创建一个拦截器，这个拦截器将一直持续到用户刷新故事查看器。如果，例如，你还有一个故事向与
    `ItemForm` 相同的 URL 发送请求，这个拦截器可能会影响其他故事。
- en: To clear your interceptors when users navigate away from this story, you’ll
    wrap `ItemForm` into another component, which creates an interceptor when it mounts
    and eliminates the interceptor when it unmounts.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户离开这个故事时清除你的拦截器，你需要将 `ItemForm` 包裹在另一个组件中，这个组件在挂载时创建拦截器，在卸载时消除拦截器。
- en: Listing 8.56 ItemForm.stories.jsx
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.56 ItemForm.stories.jsx
- en: '[PRE57]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ When the ItemFormStory mounts, creates an interceptor whthatich responds to
    any POST requests to /inventory/* with a 200 status
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当 ItemFormStory 挂载时，创建一个响应任何对 /inventory/* 的 POST 请求并返回 200 状态的拦截器
- en: ❷ Causes the story to destroy the interceptor when it unmounts
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当故事卸载时导致销毁拦截器
- en: When using stubs within your stories, remember to clear any hanging stubs or
    spies that you have created, as you’ve just done when restoring your interceptor.
    To perform both the stubbing and the cleanup, you can use wrapper components with
    hooks or life-cycle methods.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的故事中使用存根时，记得清除任何悬挂的存根或间谍，就像你恢复拦截器时做的那样。为了执行存根和清理，你可以使用带有 hooks 或生命周期方法的包装组件。
- en: At last, you’ll get rid of the alert triggered by `ItemForm`. Instead of showing
    a disruptive pop-up, you’ll use the `@storybook/addon-actions` package to log
    actions to a separate tab in the Storybook UI.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将摆脱由 `ItemForm` 触发的警报。而不是显示一个干扰性的弹出窗口，你将使用 `@storybook/addon-actions` 包将操作记录到
    Storybook UI 的单独标签页中。
- en: To use this add-on, install it as a dev dependency with `npm install --save-dev
    @storybook/addon-actions`, and update your Storybook configuration file. Within
    `.storybook/main.js`, add an `addons` property to the exported object, and assign
    to it an array containing the add-on’s registration namespace.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此插件，将其作为开发依赖项安装，使用 `npm install --save-dev @storybook/addon-actions`，并更新你的
    Storybook 配置文件。在 `.storybook/main.js` 中，向导出对象添加一个 `addons` 属性，并将其分配给包含插件注册命名空间的数组。
- en: Listing 8.57 main.js
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.57 main.js
- en: '[PRE58]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ❶ Configures Storybook to use the @storybook/addon-actions addon
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Storybook 使用 @storybook/addon-actions 插件
- en: After installing this add-on and rerunning Storybook, you’ll see an Actions
    tab at the bottom of each story. Within this tab, Storybook will log each call
    to the actions created by `addon-actions`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 安装此插件并重新运行 Storybook 后，你将在每个故事的底部看到一个“操作”标签页。在此标签页中，Storybook 将记录由 `addon-actions`
    创建的每个操作调用。
- en: To start logging actions, you’ll update `ItemForm.stories.js`. In this file,
    you’ll import `action` from `@storybook/addon-actions` and use this function to
    create the callback you’ll pass to the `ItemForm` instance in your story.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始记录操作，你需要更新 `ItemForm.stories.js`。在这个文件中，你将导入 `action` 从 `@storybook/addon-actions`，并使用此函数创建你将传递给故事中
    `ItemForm` 实例的回调函数。
- en: Listing 8.58 ItemForm.stories.jsx
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.58 ItemForm.stories.jsx
- en: '[PRE59]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Causes the Form to log actions to the Actions tab within Storybook when submitted
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当提交表单时导致表单在 Storybook 的“操作”标签页中记录操作
- en: Once you’ve updated your form’s story, open Storybook and try submitting the
    form a few times. Every time you submit it, Storybook should log a new action
    to the story’s Actions tab.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了表单的故事，打开 Storybook 并尝试提交表单几次。每次提交时，Storybook 应该将新的操作记录到故事的“操作”标签页。
- en: Using actions instead of alerts makes it much easier to understand what your
    component is doing and inspect the arguments with which it’s invoking the passed
    callbacks.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 使用操作而不是警报，可以更容易地理解你的组件正在做什么，并检查它调用传递的回调函数时使用的参数。
- en: Now that you know how to create stories, try, as an exercise, to create a story
    for the `ActionLog` component. Create a new `.stories.jsx` file, and write a story
    that demonstrates how `ActionLog` works.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建故事，作为练习，尝试为 `ActionLog` 组件创建一个故事。创建一个新的 `.stories.jsx` 文件，并编写一个故事来展示
    `ActionLog` 的工作方式。
- en: NOTE You can find this exercise’s solution at the `chapter8/4_component _stories/1_stories`
    directory in this book’s repository on GitHub at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在本书 GitHub 仓库的 `chapter8/4_component _stories/1_stories` 目录中找到这个练习的解决方案：[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: In addition to shortening the feedback loop and creating a more friendly environment
    for others to test components manually, these stories also facilitate the communication
    among developers and members of other teams. When designers have access to stories,
    it’s easier for them to prepare layouts that adhere to existing UI patterns because
    they know how the application’s current components look and behave.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缩短反馈循环并为其他人手动测试组件创建一个更友好的环境外，这些故事还有助于开发者和其他团队成员之间的沟通。当设计师可以访问故事时，他们更容易准备符合现有
    UI 模式的布局，因为他们知道应用程序当前组件的外观和行为。
- en: Ultimately, stories are a step toward the industrialization of UI. By trying
    to constrain the development of new functionality to an existing set of components,
    you reduce rework and end up with more reliable applications. This improvement
    happens not only because you have more time to focus on tests but also because
    with less code, there are fewer places for bugs to hide.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，故事是UI工业化的一个步骤。通过尝试将新功能的开发限制在现有组件集内，你可以减少返工，并最终得到更可靠的应用程序。这种改进不仅是因为你有更多时间专注于测试，而且因为代码更少，隐藏错误的地方也更少。
- en: After reading the previous paragraph, many will probably argue that the industrialization
    of UI will limit creativity—a point with which I entirely agree. Nonetheless,
    I’d say that *this limitation is a feature, not a bug*.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读上一段之后，许多人可能会争论UI的工业化将限制创造力——我完全同意这个观点。尽管如此，我还是要说，*这种限制是一个特性，而不是一个错误*。
- en: Creativity comes at a cost, which often goes unnoticed because of how often
    product teams reach for new components. Trying to limit UI patterns to a set of
    existing components makes the amount of work needed to implement new functionality
    more noticeable for other teams.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 创造力是有代价的，这种代价往往因为产品团队经常寻求新组件而被忽视。试图将UI模式限制在现有组件的集合中，使得实现新功能所需的工作量对其他团队来说更加明显。
- en: The goal with component libraries is *not* to limit a designer’s freedom to
    create but, instead, to make the cost of creativity explicit, so that the business
    can thrive.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 组件库的目标**不是**限制设计师的创造力以进行创作，而是相反，使创造力的成本明确化，这样企业才能繁荣发展。
- en: Libraries of this kind, representing a set of UI components, constraints, and
    best practices, are also called a *design system* and have experienced a spike
    in popularity in recent years.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这类代表一组UI组件、约束和最佳实践的库也被称为*设计系统*，近年来其受欢迎程度有所上升。
- en: Despite this rise in popularity, stories aren’t *always* a good idea. Just like
    tests, stories are pieces of code that need maintenance. As you update your components,
    you need to make sure that your stories still adequately demonstrate your component’s
    use cases.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种流行度的上升，但故事**并不总是**是一个好主意。就像测试一样，故事是需要维护的代码片段。当你更新你的组件时，你需要确保你的故事仍然充分展示了组件的使用案例。
- en: Even if you have the bandwidth to keep stories up-to-date, you’ll still pay
    a higher price for maintenance. The advantage of bearing these maintenance costs
    is that you will reduce the costs involved in conceptualizing and implementing
    new functionalities. This cost reduction happens because stories facilitate the
    reuse of components and limit the design team’s creativity to what already exists,
    making the cost of change more explicit.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你有能力保持故事更新，你仍然会为维护支付更高的代价。承担这些维护成本的优势在于，你将减少概念化和实现新功能所涉及的成本。这种成本降低是因为故事促进了组件的重用，并限制了设计团队的创造力，使其局限于现有内容，使变更的成本更加明确。
- en: 8.4.2 Writing documentation
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 编写文档
- en: Louis is confident in his ability to make customers’ eyes gleam with every dessert
    they taste. Still, he knows that for his staff to do the same, his recipes must
    be carefully explained, from the most discreet cocoa nibs to the boldest portions
    of whipped cream.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 路易对他的能力充满信心，相信每位顾客品尝到的每一款甜点都能让他们眼睛发光。然而，他知道，为了让他的员工也能做到同样的事情，他的食谱必须被仔细解释，从最微妙的可可豆到最大胆的奶油部分。
- en: By writing stories, you can show what a component looks like and demonstrate
    how it behaves, but for others to understand how they’re supposed to use it, you’ll
    have to write documentation.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写故事，你可以展示组件的外观，并演示其行为，但为了让其他人理解他们应该如何使用它，你必须编写文档。
- en: In this section, you’ll learn how to use Storybook to write and publish documentation
    for your components, starting with `ItemList`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用Storybook编写和发布你的组件文档，从`ItemList`开始。
- en: To write documentation, you’ll use a file format called MDX. MDX files support
    a combination of markdown and `JSX` code so that you can write plain text to explain
    how your component works and include real instances of your components throughout
    the documentation itself.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写文档，你将使用一种名为MDX的文件格式。MDX文件支持Markdown和`JSX`代码的组合，这样你就可以用纯文本来解释你的组件是如何工作的，并在文档本身中包含组件的真实实例。
- en: For Storybook to support MDX files, you’ll use the `@storybook/addon-docs` add-on.
    This add-on causes each of your stories to display an extra tab called Docs. In
    this tab, you’ll find the MDX documentation that corresponds to the current story.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Storybook 支持MDX文件，您将使用 `@storybook/addon-docs` 插件。此插件会在每个故事中添加一个名为 Docs
    的额外选项卡。在这个选项卡中，您将找到与当前故事对应的MDX文档。
- en: When installing `@storybook/addon-docs`, you must also install the `react-is`
    package upon which this add-on depends. To install both as dev dependencies, execute
    `npm install --save-dev react-is @storybook/addon-docs`.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 `@storybook/addon-docs` 时，您还必须安装此插件所依赖的 `react-is` 包。要作为开发依赖项安装这两个包，请执行
    `npm install --save-dev react-is @storybook/addon-docs`。
- en: Once `@storybook/addon-docs` and its dependency have been installed, update
    the configurations within `.storybook/main.js` so that Storybook supports documentation
    written in MDX.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 `@storybook/addon-docs` 及其依赖项，请更新 `.storybook/main.js` 中的配置，以便 Storybook
    支持使用 MDX 编写的文档。
- en: In addition to updating the `addons` property in your configurations, you’ll
    also have to update the `stories` property so that Storybook will include files
    with an .mdx extension.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在您的配置中更新 `addons` 属性外，您还必须更新 `stories` 属性，以便 Storybook 能够包含具有 .mdx 扩展名的文件。
- en: Listing 8.59 main.js
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.59 main.js
- en: '[PRE60]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ Configures Storybook to use the @storybook/addon-docs add-on
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Storybook 使用 @storybook/addon-docs 插件
- en: ❶ Given your current Babel configuration, this option is necessary to make sure
    that the add-on will be able to handle JSX files.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据您当前的 Babel 配置，此选项是必要的，以确保插件能够处理 JSX 文件。
- en: After updating this file, rerun Storybook, and access one of your stories to
    see a Docs tab at the top.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 更新此文件后，重新运行 Storybook，并访问您的一个故事，以查看顶部的 Docs 选项卡。
- en: Now that you’ve configured this add-on, you’ll write the contents for the item
    list’s Docs tab.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经配置了此插件，您将编写项目列表 Docs 选项卡的内容。
- en: Go ahead and create a file called `ItemList.docs.mdx`, in which you will use
    markdown to describe how your component works and JSX to include real `ItemList`
    instances to illustrate your documentation.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个名为 `ItemList.docs.mdx` 的文件，在其中您将使用markdown来描述组件的工作方式，并使用 JSX 包含真实的 `ItemList`
    实例以说明文档。
- en: For Storybook to adequately render your component’s instance, don’t forget to
    wrap it into the `Preview` and `Story` components exported by `@storybook/addon-docs`.
    Additionally, to link the necessary metadata to your story, you’ll also have to
    import the add-on’s `Meta` component and add it to the beginning of your file.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Storybook 能够充分渲染您的组件实例，别忘了将其包裹在由 `@storybook/addon-docs` 导出的 `Preview` 和
    `Story` 组件中。此外，为了将必要的元数据链接到您的故事中，您还必须导入此插件的 `Meta` 组件并将其添加到文件的开头。
- en: NOTE You can find the MDX format’s complete documentation at [https://mdxjs.com](https://mdxjs.com).
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在 [https://mdxjs.com](https://mdxjs.com) 找到 MDX 格式的完整文档。
- en: Listing 8.60 ItemList.docs.mdx
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.60 ItemList.docs.mdx
- en: '[PRE61]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: After you’ve written some documentation for `ItemList`, open its stories on
    Storybook and check the Docs tab, so that you can see how your `MDX` files will
    look.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 `ItemList` 编写了一些文档之后，打开其在 Storybook 中的故事，并检查 Docs 选项卡，以便您可以看到您的 `MDX` 文件将如何显示。
- en: Good documentation aids testers in determining a component’s expected behavior.
    By writing documentation within Storybook, where your components live, you can
    clearly communicate to testers a component’s expected behavior. In turn, clear
    communication leads to quicker and more effective testing, with less overhead
    and, therefore, can reduce costs.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的文档有助于测试人员确定组件的预期行为。通过在组件所在的 Storybook 中编写文档，您可以清楚地向测试人员传达组件的预期行为。反过来，清晰的沟通可以导致更快、更有效的测试，从而减少开销，因此可以降低成本。
- en: Proper documentation also aids product teams in designing new features in such
    a way that reduces implementation time, freeing engineers to focus on reliability
    and other important aspects of software development.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的文档还有助于产品团队以减少实现时间的方式设计新功能，从而让工程师能够专注于可靠性和软件开发的其他重要方面。
- en: Summary
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When testing your components, write your integration tests as high up in the
    component tree as necessary to obtain reliable guarantees. The higher in the component
    tree your test’s target is, the more reliable the test becomes.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试您的组件时，请将集成测试编写在组件树中尽可能高的位置，以获得可靠的保证。测试目标在组件树中的位置越高，测试就越可靠。
- en: To avoid triggering a component’s side effects or testing third-party libraries,
    you can stub components. To stub a component, you can create a stub using Jest
    and use `jest.mock` to cause imports to resolve to your test double.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免触发组件的副作用或测试第三方库，你可以模拟组件。要模拟一个组件，你可以使用 Jest 创建一个模拟，并使用 `jest.mock` 使导入解析到你的测试替身。
- en: Snapshot testing is a testing technique in which you save a snapshot of an assertion’s
    target the first time a test runs. Then, in each subsequent execution, you compare
    the assertion’s target to the stored snapshot.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照测试是一种测试技术，其中你在测试首次运行时保存断言目标的快照。然后，在每次后续执行中，你将断言的目标与存储的快照进行比较。
- en: Snapshots are useful for testing components that include extensive markup or
    large quantities of text. Because you can create and update snapshots automatically,
    you avoid spending time doing laborious activities like writing and rewriting
    long and complicated strings.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照对于测试包含大量标记或大量文本的组件很有用。因为你可以自动创建和更新快照，所以你避免了花费时间进行像编写和重写长而复杂的字符串这样的繁琐活动。
- en: When testing targets other than components, make sure that you are using the
    adequate serializers so that Jest can generate snapshots that are readable and,
    therefore, easier to review. Understandable snapshots facilitate code reviews
    and make it more difficult for mistakes to go unnoticed.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试除组件之外的目标时，请确保你正在使用适当的序列化器，以便 Jest 可以生成可读的快照，因此更容易审查。可理解的快照简化了代码审查，并使错误难以被忽视。
- en: When testing styles, without visual tests you can’t guarantee that a component
    looks like it should, but you can ensure that the correct classes or rules are
    applied to it. To assert on a component’s styles, you can either assert on its
    `classname` or `style` property.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试样式时，如果没有视觉测试，你无法保证组件看起来应该是的样子，但你可以确保正确的类或规则被应用到它上。要断言组件的样式，你可以断言其 `classname`
    或 `style` 属性。
- en: Because styles can often become long and complex, you can combine Jest’s snapshots
    with CSS-in-JS to make it quicker for developers to update tests. In that case,
    make sure to use the correct serializer so that your snapshots are readable.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为样式通常可能变得很长且复杂，你可以将 Jest 的快照与 CSS-in-JS 结合使用，以便让开发者更快地更新测试。在这种情况下，请确保使用正确的序列化器，以便你的快照可读。
- en: A story is a piece of code that demonstrates the functionalities of different
    individual components. To write stories, you can use a tool called Storybook.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事是一段代码，用于展示不同单个组件的功能。要编写故事，你可以使用一个名为 Storybook 的工具。
- en: Stories make it easier for testers to perform acceptance testing at a component
    level because they eliminate the necessity to spin up an entire application before
    one can interact with your components.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事使测试人员更容易在组件级别执行验收测试，因为它们消除了在交互你的组件之前启动整个应用程序的必要性。
- en: Stories are a step toward the industrialization of UI. They constrain the development
    of new functionality to an existing set of components. This encouragement to reuse
    components reduces development time and, thus, cuts costs. With less code, you’ll
    have fewer places for bugs to hide and more time to focus on quality control.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事是 UI 工业化的一个步骤。它们将新功能的发展限制在现有组件集内。这种鼓励重用组件的做法可以减少开发时间，从而降低成本。代码越少，隐藏错误的地方就越少，你就有更多时间专注于质量控制。
- en: To document your components within Storybook, you can use the `@storybook/addon-docs`
    package. This add-on allows you to write MDX files to document your components.
    This file format accepts a mixture of markdown and JSX, so that you can both explain
    how components work and include real component instances throughout the documentation.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在 Storybook 中记录你的组件，你可以使用 `@storybook/addon-docs` 包。此插件允许你编写 MDX 文件来记录你的组件。这种文件格式接受
    markdown 和 JSX 的混合，这样你既可以解释组件的工作原理，也可以在文档中包含实际的组件实例。
