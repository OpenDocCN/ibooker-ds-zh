- en: 10 Building GraphQL APIs with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 使用Python构建GraphQL API
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating GraphQL APIs using the Ariadne web server framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ariadne网络服务器框架创建GraphQL API
- en: Validating request and response payloads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证请求和响应有效载荷
- en: Creating resolvers for queries and mutations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为查询和突变创建解析器
- en: Creating resolvers for complex object types, such as union types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为复杂对象类型，如联合类型创建解析器
- en: Creating resolvers for custom scalar types and object properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义标量类型和对象属性创建解析器
- en: In chapter 8, we designed a GraphQL API for the products service, and we produced
    a specification detailing the requirements for the products API. In this chapter,
    we implement the API according to the specification. To build the API, we’ll use
    the Ariadne framework, which is one of the most popular GraphQL libraries in the
    Python ecosystem. Ariadne allows us to leverage the benefits of documentation-driven
    development by automatically loading data validation models from the specification.
    We’ll learn to create resolvers, which are Python functions that implement the
    logic of a query or mutation. We’ll also learn to handle queries that return multiple
    types. After reading this chapter, you’ll have all the tools you need to start
    developing your own GraphQL APIs!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们为产品服务设计了GraphQL API，并生成了一份详细说明产品API要求的规范。在本章中，我们根据规范实现API。为了构建API，我们将使用Ariadne框架，这是Python生态系统中最受欢迎的GraphQL库之一。Ariadne允许我们利用文档驱动开发的优点，通过自动从规范中加载数据验证模型。我们将学习创建解析器，这些解析器是Python函数，用于实现查询或突变的逻辑。我们还将学习处理返回多个类型的查询。阅读本章后，您将拥有开始开发自己的GraphQL
    API所需的所有工具！
- en: The code for this chapter is available in the GitHub repository provided with
    this book, under the folder ch10\. Unless otherwise specified, all the file references
    within this chapter are relative to the ch10 folder. For example, server.py refers
    to the ch10/server.py file, and web/schema.py refers to the ch10/web/schema.py
    file. Also, to ensure all the commands used in this chapter work as expected,
    use the `cd` command to move the ch10 folder in your terminal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在本书提供的GitHub存储库中找到，位于ch10文件夹下。除非另有说明，本章中所有文件引用均相对于ch10文件夹。例如，server.py指的是ch10/server.py文件，而web/schema.py指的是ch10/web/schema.py文件。此外，为了确保本章中使用的所有命令按预期工作，请使用`cd`命令将ch10文件夹移动到您的终端中。
- en: 10.1 Analyzing the API requirements
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 分析API要求
- en: In this section, we analyze the requirements of the API specification. Before
    jumping into implementing an API, it’s worth spending some time analyzing the
    API specification and what it requires. Let’s do this analysis for the products
    API!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析API规范的要求。在开始实现API之前，花些时间分析API规范及其要求是值得的。让我们为产品API进行这项分析！
- en: The products API specification is available under ch10/web/products.graphql
    in the GitHub repository for this book. The specification defines a collection
    of object types that represent the data we can retrieve from the API and a set
    of queries and mutations that expose the capabilities of the products service.
    We must create validation models that faithfully represent the schemas defined
    in the specification, as well as functions that correctly implement the functionality
    of the queries and mutations. We’ll work with a framework that can handle schema
    validation automatically from the specification, so we don’t need to worry about
    implementing validation models.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 产品API规范可在本书的GitHub存储库的ch10/web/products.graphql下找到。规范定义了一个表示我们可以从API检索的数据的对象类型集合，以及一组查询和突变，它们公开了产品服务的功能。我们必须创建验证模型，这些模型忠实地表示规范中定义的模式，以及正确实现查询和突变功能的函数。我们将与一个框架一起工作，该框架可以从规范中自动处理模式验证，因此我们不需要担心实现验证模型。
- en: Our implementation will focus mainly on the queries and mutations. Most of the
    queries and mutations defined in the schema return either an array or a single
    instance of the `Ingredient` and `Product` types. `Ingredient` is simpler since
    it’s an object type, so we’ll look at queries and mutations that use this type
    first. `Product` is the union of the `Beverage` and `Cake` types, both of which
    implement the `ProductInterface` type. As we’ll see`,` implementing queries and
    mutations that return union types is slightly more complex. A query that returns
    a list of `Product` objects contains instances of both the `Beverage` and `Cake`
    types, so we need to implement additional functionality that makes it possible
    for the server to determine which type each element in the list belongs to.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将主要关注查询和突变。在模式中定义的大多数查询和突变都会返回`Ingredient`和`Product`类型的数组或单个实例。由于`Ingredient`是一个对象类型，所以它比较简单，因此我们将首先查看使用此类型的查询和突变。`Product`是`Beverage`和`Cake`类型的联合，这两个类型都实现了`ProductInterface`类型。正如我们将看到的，实现返回联合类型的查询和突变稍微复杂一些。返回`Product`对象列表的查询包含`Beverage`和`Cake`类型的实例，因此我们需要实现额外的功能，使服务器能够确定列表中每个元素属于哪种类型。
- en: With that said, let’s analyze the tech stack that we’ll use for this chapter,
    and then move straight into the implementation!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们分析一下我们将用于本章的技术栈，然后直接进入实现阶段！
- en: 10.2 Introducing the tech stack
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 介绍技术栈
- en: In this section, we discuss the tech stack that we’ll use to implement the products
    API. We discuss which libraries are available for implementing GraphQL APIs in
    Python, and we choose one of them. We also discuss the server framework that we’ll
    use to run the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论我们将用于实现产品API的技术栈。我们讨论了可用于在Python中实现GraphQL API的库，并从中选择了一个。我们还讨论了我们将用于运行应用程序的服务器框架。
- en: 'Since we’re going to implement a GraphQL API, the first thing we want to look
    for is a good GraphQL server library. GraphQL’s website ([https://graphql.org/code/](https://graphql.org/code/))
    is an excellent resource for finding tools and frameworks for the GraphQL ecosystem.
    As the ecosystem is constantly evolving, I recommend you check out that website
    every once in a while for any new additions. The website lists four Python libraries
    that support GraphQL:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将实现GraphQL API，我们首先想要寻找的是一个好的GraphQL服务器库。GraphQL的网站([https://graphql.org/code/](https://graphql.org/code/))是寻找GraphQL生态系统工具和框架的绝佳资源。由于生态系统不断演变，我建议您偶尔查看该网站，以了解任何新增内容。该网站列出了四个支持GraphQL的Python库：
- en: '*Graphene* ([https://github.com/graphql-python/graphene](https://github.com/graphql-python/graphene))
    is one of the first GraphQL libraries built for Python. It’s battle tested and
    one of the most widely used libraries.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Graphene* ([https://github.com/graphql-python/graphene](https://github.com/graphql-python/graphene))
    是为Python构建的第一个GraphQL库之一。它经过实战检验，并且是最广泛使用的库之一。'
- en: '*Ariadne* ([https://github.com/mirumee/ariadne](https://github.com/mirumee/ariadne))
    is a library built for schema-first (or documentation-driven) development. It’s
    a highly popular framework, and it handles schema validation and serialization
    automatically.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ariadne* ([https://github.com/mirumee/ariadne](https://github.com/mirumee/ariadne))
    是一个为模式优先（或文档驱动）开发构建的库。它是一个非常流行的框架，并且能够自动处理模式验证和序列化。'
- en: '*Strawberry* ([https://github.com/strawberry-graphql/strawberry](https://github.com/strawberry-graphql/strawberry))
    is a more recent library that makes it easy to implement GraphQL schema models
    by offering a clean interface inspired by Python data classes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Strawberry* ([https://github.com/strawberry-graphql/strawberry](https://github.com/strawberry-graphql/strawberry))
    是一个较新的库，它通过提供一个受Python数据类启发的干净接口，使实现GraphQL模式模型变得容易。'
- en: '*Tartiflette* ([https://github.com/tartiflette/tartiflette](https://github.com/tartiflette/tartiflette))
    is another recent addition to the Python ecosystem that allows you to implement
    a GraphQL server using a schema-first approach, and it’s built on top of asyncio,
    which is Python’s core library for asynchronous programming.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tartiflette* ([https://github.com/tartiflette/tartiflette](https://github.com/tartiflette/tartiflette))
    是Python生态系统中的另一个新成员，它允许您使用模式优先方法实现GraphQL服务器，并且它建立在asyncio之上，这是Python的异步编程核心库。'
- en: For this chapter, we’ll use Ariadne, since it supports a schema-first or documentation-driven
    development approach, and it’s a mature project. The API specification is already
    available, so we don’t want to spend time implementing each schema model in Python.
    Instead, we want to use a library that can handle schema validation and serialization
    directly from the API specification, and Ariadne can do that.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用 Ariadne，因为它支持模式优先或文档驱动的开发方法，并且是一个成熟的项目。API 规范已经可用，所以我们不想花时间在 Python
    中实现每个模式模型。相反，我们希望使用一个可以直接从 API 规范中处理模式验证和序列化的库，Ariadne 就能这样做。
- en: 'We’ll run the Ariadne server with the help of Uvicorn, which we encountered
    in chapters 2 and 6 when we worked with FastAPI. To install the dependencies for
    this chapter, you can use the Pipfile and Pipfile.lock files available under the
    ch10 folder in the repository provided with this book. Copy the Pipfile and Pipfile.lock
    files into your ch10 folder, `cd` into it, and run the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Uvicorn 运行 Ariadne 服务器，我们在第 2 章和第 6 章中与 FastAPI 一起工作时遇到了 Uvicorn。要安装本章的依赖项，您可以使用本书提供的存储库中
    ch10 文件夹下的 Pipfile 和 Pipfile.lock 文件。将 Pipfile 和 Pipfile.lock 文件复制到您的 ch10 文件夹中，然后使用
    `cd` 命令进入该文件夹，并运行以下命令：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you prefer to install the latest versions of Ariadne and Uvicorn, simply
    run
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想安装 Ariadne 和 Uvicorn 的最新版本，只需运行
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have the dependencies installed, let’s activate the environment:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了依赖项，让我们激活环境：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With all the dependencies installed, now we are ready to start coding, so let’s
    do it!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了所有依赖项之后，我们现在可以开始编码了，所以让我们开始吧！
- en: 10.3 Introducing Ariadne
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 介绍 Ariadne
- en: In this section, we introduce the Ariadne framework, and we learn how it works
    by using a simple example. We’ll learn how to run a GraphQL server with Ariadne,
    how to load a GraphQL specification, and how to implement a simple GraphQL resolver.
    As we saw in chapter 9, users interact with GraphQL APIs by running queries and
    mutations. A GraphQL resolver is a function that knows how to execute one of those
    queries or mutations. In our implementation, we’ll have as many resolvers as queries
    and mutations there are in the API specification. As you can see from figure 10.1,
    resolvers are the pillars of a GraphQL server since it’s through resolvers that
    we can return actual data to the API users.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍 Ariadne 框架，并通过一个简单的示例来了解它是如何工作的。我们将学习如何使用 Ariadne 运行 GraphQL 服务器，如何加载
    GraphQL 规范，以及如何实现一个简单的 GraphQL 解析器。正如我们在第 9 章中看到的，用户通过运行查询和突变与 GraphQL API 交互。GraphQL
    解析器是一个知道如何执行这些查询或突变之一的函数。在我们的实现中，我们将拥有与 API 规范中查询和突变一样多的解析器。如图 10.1 所示，解析器是 GraphQL
    服务器的基础，因为正是通过解析器，我们才能向 API 用户返回实际数据。
- en: '![](../Images/10-01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-01.png)'
- en: Figure 10.1 To serve data to a user, a GraphQL server uses resolvers, which
    are functions that know how to build the payload for a given query.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 为了向用户提供服务，GraphQL 服务器使用解析器，这些解析器是知道如何为给定查询构建有效载荷的函数。
- en: 'Let’s start by writing a very simple GraphQL schema. Open the server.py file
    and copy the following content into it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一个非常简单的 GraphQL 模式开始。打开 server.py 文件，并将以下内容复制到其中：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We define a variable called `schema`, and we point it to a simple GraphQL schema.
    This schema defines only one query, named `hello()`, which returns a string. The
    return value of the `hello()` query is optional, which means `null` is also a
    valid return value. To expose this query through our GraphQL server, we need to
    implement a resolver using Ariadne.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `schema` 的变量，并将其指向一个简单的 GraphQL 模式。此模式仅定义了一个名为 `hello()` 的查询，该查询返回一个字符串。`hello()`
    查询的返回值是可选的，这意味着 `null` 也是一个有效的返回值。为了通过我们的 GraphQL 服务器公开此查询，我们需要使用 Ariadne 实现一个解析器。
- en: Ariadne can run a GraphQL server from this simple schema definition. How do
    we do that? First, we need to load the schema using Ariadne’s `make_executable_
    schema()` function. `make_executable_schema()` parses the document, validates
    our definitions, and builds an internal representation of the schema. As you can
    see in figure 10.2, Ariadne uses the output of this function to validate our data.
    For example, when we return the payload for a query, Ariadne validates the payload
    against the schema.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Ariadne 可以从这个简单的模式定义中运行 GraphQL 服务器。我们如何做到这一点？首先，我们需要使用 Ariadne 的 `make_executable_schema()`
    函数加载模式。`make_executable_schema()` 解析文档，验证我们的定义，并构建模式内部表示。如图 10.2 所示，Ariadne 使用此函数的输出来验证我们的数据。例如，当我们返回查询的有效载荷时，Ariadne
    会将有效载荷与模式进行验证。
- en: '![](../Images/10-02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-02.png)'
- en: Figure 10.2 To run the GraphQL server with Ariadne, we produce an executable
    schema by loading the GraphQL schema for the API and a collection of resolvers
    for the queries and mutations. Ariadne uses the executable schema to validate
    data the user sent to the server, as well as data sent from the server to the
    user.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 要使用Ariadne运行GraphQL服务器，我们通过加载API的GraphQL模式和查询及变异的解析器集合来生成一个可执行的模式。Ariadne使用可执行模式来验证用户发送给服务器的数据，以及从服务器发送给用户的数据。
- en: 'Once we’ve loaded the schema, we can initialize our server using Ariadne’s
    `GraphQL` class (listing 10.1). Ariadne provides two implementations of the server:
    a synchronous implementation, which is available under the `ariande.wsgi` module,
    and an asynchronous implementation, which is available under the `ariande.asgi`
    module. In this chapter, we’ll use the asynchronous implementation.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了模式，我们可以使用Ariadne的`GraphQL`类（列表10.1）来初始化我们的服务器。Ariadne提供了两种服务器实现：一种同步实现，位于`ariande.wsgi`模块下，另一种异步实现，位于`ariande.asgi`模块下。在本章中，我们将使用异步实现。
- en: Listing 10.1 Initializing a GraphQL server using Ariadne
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 使用Ariadne初始化GraphQL服务器
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① We declare a simple schema.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明一个简单的模式。
- en: ② We instantiate the GraphQL server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们实例化GraphQL服务器。
- en: 'To run the server, execute the following command from the terminal:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行服务器，请在终端中执行以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Your application will be available on http://localhost:8000\. If you head over
    to that address, you’ll see an Apollo Playground interface to the application.
    As you can see in figure 10.3, Apollo Playground is similar to GraphiQL, which
    we learned in chapter 8\. On the left-side panel, we write our queries. Write
    the following query:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序将在http://localhost:8000上可用。如果您访问该地址，您将看到一个指向应用程序的Apollo Playground界面。如图10.3所示，Apollo
    Playground与我们在第8章中学到的GraphiQL类似。在左侧面板中，我们编写我们的查询。编写以下查询：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/10-03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-03.png)'
- en: Figure 10.3 The Apollo Playground interface contains a query panel where we
    execute queries and mutations; a results panel where the queries and mutations
    are evaluated; and a documentation panel where we can inspect the API schemas.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 Apollo Playground界面包含一个查询面板，我们可以在这里执行查询和变异；一个结果面板，用于评估查询和变异；以及一个文档面板，我们可以在这里检查API模式。
- en: 'This query executes the query function that we defined in listing 10.1\. If
    you press the execute button, you’ll get the results of this query on the right-side
    panel:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询执行我们在列表10.1中定义的查询函数。如果您按下执行按钮，您将在右侧面板上获得此查询的结果：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The query returns `null`. This shouldn’t come as a surprise, since the return
    value of the `hello()` query is a nullable string. How can we make the `hello()`
    query return a string? Enter resolvers. *Resolvers* are functions that let the
    server know how to produce a value for a type or an attribute. To make the `hello()`
    query return an actual string, we need to implement a resolver. Let’s create a
    resolver that returns a string of 10 random characters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回`null`。这并不令人惊讶，因为`hello()`查询的返回值是一个可空的字符串。我们如何让`hello()`查询返回一个字符串？请输入解析器。*解析器*是函数，它让服务器知道如何为类型或属性生成值。为了让`hello()`查询返回实际的字符串，我们需要实现一个解析器。让我们创建一个返回10个随机字符字符串的解析器。
- en: 'In Ariadne, a resolver is a Python callable (e.g., a function) that takes two
    positional parameters: `obj` and `info`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ariadne中，解析器是一个Python可调用对象（例如，一个函数），它接受两个位置参数：`obj`和`info`。
- en: Resolver parameters in Ariadne
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ariadne中的解析器参数
- en: Ariadne’s resolvers always have two positional-only parameters, which are commonly
    called `obj` and `info`. The signature of a basic Ariadne resolver is
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ariadne的解析器总是有两个位置参数，通常称为`obj`和`info`。基本Ariadne解析器的签名是
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the figure, `obj` will normally be set to `None`, unless the
    resolver has a parent resolver, in which case `obj` will be set to the value returned
    by the parent resolver. We encounter the latter case when a resolver doesn’t return
    an explicit type. For example, the resolver for the `allProducts()` query, which
    we’ll implement in section 10.4.4, doesn’t return an explicit type. It returns
    an object of type `Product`, which is the union of the `Cake` and `Beverage` types.
    To determine the type of each object, Ariadne needs to call a resolver for the
    `Product` type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，`obj`通常会被设置为`None`，除非解析器有一个父解析器，在这种情况下`obj`会被设置为父解析器返回的值。当我们遇到一个不返回显式类型的解析器时，我们会遇到后一种情况。例如，我们将在第10.4.4节中实现的`allProducts()`查询解析器不返回显式类型。它返回一个类型为`Product`的对象，这是`Cake`和`Beverage`类型的联合。为了确定每个对象的类型，Ariadne需要调用`Product`类型的解析器。
- en: '![](../Images/10-03_UN01.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-03_UN01.png)'
- en: When a resolver doesn't have a parent resolver, the `obj` parameter is set to
    `None`. When there's a parent resolver, `obj` will be set to the value returned
    by the parent resolver.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析器没有父解析器时，`obj`参数被设置为`None`。当存在父解析器时，`obj`将被设置为父解析器返回的值。
- en: 'The `info` parameter is an instance of `GraphQLResolveInfo`, which contains
    information required to execute a query. Ariadne uses this information to process
    and serve each request. For the application developer, the most interesting attribute
    exposed by the `info` object is `info.context`, which contains details about the
    context in which the resolver is called, such as the HTTP context. To learn more
    about the `obj` and `info` objects, check out Ariadne’s documentation: [https://ariadnegraphql.org/docs/resolvers.html](https://ariadnegraphql.org/docs/resolvers.html).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`info`参数是`GraphQLResolveInfo`的一个实例，它包含执行查询所需的信息。Ariadne使用这些信息来处理和响应每个请求。对于应用程序开发者来说，`info`对象暴露的最有趣的属性是`info.context`，它包含关于调用解析器时上下文的详细信息，例如HTTP上下文。要了解更多关于`obj`和`info`对象的信息，请查看Ariadne的文档：[https://ariadnegraphql.org/docs/resolvers.html](https://ariadnegraphql.org/docs/resolvers.html)。'
- en: 'A resolver needs to be bound to its corresponding object type. Ariadne provides
    bindable classes for each GraphQL type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器需要绑定到其对应的对象类型。Ariadne为每个GraphQL类型提供了可绑定的类：
- en: '`ObjectType` for object types.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectType`用于对象类型。'
- en: '`QueryType` for query types. In GraphQL, the query type represents the collection
    of all queries available in a schema. As we saw in chapter 8 (section 8.8), a
    query is a function that reads data from a GraphQL server.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueryType`用于查询类型。在GraphQL中，查询类型代表一个模式中所有查询的集合。正如我们在第8章（第8.8节）中看到的，查询是一个从GraphQL服务器读取数据的函数。'
- en: '`MutationType` for mutation types. As we saw in chapter 8 (section 8.9), a
    mutation is a function that alters the state of the GraphQL server.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MutationType`用于突变类型。正如我们在第8章（第8.9节）中看到的，突变是一个改变GraphQL服务器状态的函数。'
- en: '`UnionType` for union types.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnionType`用于联合类型。'
- en: '`InterfaceType` for interface types.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InterfaceType`用于接口类型。'
- en: '`EnumType` for enumeration types.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnumType`用于枚举类型。'
- en: 'Since `hello()` is a query, we need to bind its resolver to an instance of
    Ariadne’s `QueryType`. Listing 10.2 shows how we do that. We first create an instance
    of the `QueryType` class and assign it to a variable called `query`. We then use
    `QueryType`’s `field()` decorator method to bind our resolver, which is available
    on most of Ariadne’s bindable classes and allows us to bind a resolver to a specific
    field. By convention, we prefix our resolvers’ names with `resolve_`. Ariadne’s
    resolvers always get two positional-only parameters by default: `obj` and `info`.
    We don’t need to make use of those parameters in this case, so we use a wildcard
    followed by an underscore (`*_`), which is a convention in Python to ignore a
    list of positional parameters. To make Ariadne aware of our resolvers, we need
    to pass our bindable objects as an array to the `make_executable_` `schema()`
    function. The changes go under server.py.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`hello()`是一个查询，我们需要将其解析器绑定到Ariadne的`QueryType`实例。列表10.2显示了如何做到这一点。我们首先创建一个`QueryType`类的实例并将其分配给一个名为`query`的变量。然后我们使用`QueryType`的`field()`装饰器方法绑定我们的解析器，这在Ariadne的大多数可绑定类上都是可用的，并允许我们将解析器绑定到特定字段。按照惯例，我们在解析器的名称前加上`resolve_`前缀。Ariadne的解析器默认总是获取两个位置参数：`obj`和`info`。在这种情况下，我们不需要使用这些参数，所以我们使用一个通配符后跟一个下划线(`*_`)，这是Python中忽略一系列位置参数的惯例。为了使Ariadne了解我们的解析器，我们需要将我们的可绑定对象作为数组传递给`make_executable_`
    `schema()`函数。这些更改在`server.py`中进行。
- en: Listing 10.2 Implementing a GraphQL resolver with Ariadne
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 使用Ariadne实现GraphQL解析器
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Instance of QueryType
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ① `QueryType`实例
- en: ② We bind a resolver for the hello() query using QueryType’s field() decorator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 QueryType 的 field() 装饰器绑定 hello() 查询的解析器。
- en: ③ We skip positional-only parameters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们跳过仅位置参数。
- en: ④ We return a list of randomly generated ASCII characters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们返回一个随机生成的ASCII字符列表。
- en: ⑤ We declare our GraphQL schema.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们声明我们的GraphQL模式。
- en: ⑥ Instance of the GraphQL server
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ GraphQL服务器的实例
- en: Since we’re running the server with the hot reloading flag (`--reload`), the
    server automatically reloads once you save the changes to the file. Go back to
    the Apollo Playground interface in http://127.0.0.1:8000 and run the `hello()`
    `query` again. This time, you should get a random string of 10 characters as a
    result.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用热重载标志(`--reload`)运行服务器，一旦你将文件中的更改保存，服务器会自动重新加载。返回到 http://127.0.0.1:8000
    上的 Apollo Playground 接口，并再次运行 `hello()` `查询`。这次，你应该得到一个由10个字符组成的随机字符串作为结果。
- en: This completes our introduction to Ariadne. You’ve learned how to load a GraphQL
    schema with Ariadne, how to run the GraphQL server, and how to implement a resolver
    for a query function. In the rest of the chapter, we’ll apply this knowledge as
    we build the GraphQL API for the products service.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对Ariadne的介绍。你已经学会了如何使用Ariadne加载GraphQL模式，如何运行GraphQL服务器，以及如何为查询函数实现解析器。在接下来的章节中，我们将应用这些知识来构建产品服务的GraphQL
    API。
- en: 10.4 Implementing the products API
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 实现产品API
- en: In this section, we’ll use everything we learned in the previous section to
    build the GraphQL API for the products service. Specifically, you’ll learn to
    build resolvers for the queries and mutations of the products API, to handle query
    parameters, and to structure your project. Along the way, we’ll learn additional
    features of the Ariadne framework and various strategies for testing and implementing
    GraphQL resolvers. By the end of this section, you’ll be able to build GraphQL
    APIs for your own microservices. Let the journey begin!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用上一节学到的所有知识来构建产品服务的GraphQL API。具体来说，你将学习如何构建产品API的查询和突变（mutations）解析器，处理查询参数，以及构建你的项目结构。在这个过程中，我们将学习Ariadne框架的额外功能和实现GraphQL解析器的各种策略。到本节结束时，你将能够为你的微服务构建GraphQL
    API。让我们开始这段旅程吧！
- en: 10.4.1 Laying out the project structure
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 项目结构布局
- en: In this section, we structure our project for the products API implementation.
    So far, we’ve included all our code under the server.py file. To implement a whole
    API, we need to split our code into different files and add structure to the project;
    otherwise, the codebase would become difficult to read and to maintain. To keep
    the implementation simple, we’ll use an in-memory representation of our data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为产品API实现结构化我们的项目。到目前为止，我们已经在 server.py 文件下包含了所有我们的代码。为了实现整个API，我们需要将我们的代码拆分到不同的文件中，并为项目添加结构；否则，代码库将变得难以阅读和维护。为了保持实现简单，我们将使用我们数据的内存表示。
- en: 'If you followed along with the code in the previous section, delete the code
    we wrote earlier under server.py, which represents the entry point to our application
    and therefore will contain an instance of the GraphQL server. We’ll encapsulate
    the web server implementation within a folder called web/. Create this folder,
    and within it, create the following files:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随着上一节中的代码，请删除 server.py 中我们之前编写的代码，这代表了我们应用程序的入口点，因此将包含GraphQL服务器的实例。我们将在名为
    web/ 的文件夹中封装Web服务器实现。创建这个文件夹，并在其中创建以下文件：
- en: data.py will contain the in-memory representation of our data.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: data.py 将包含我们数据的内存表示。
- en: mutations.py will contain resolvers for the mutations in the products API.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mutations.py 将包含产品API中突变（mutations）的解析器。
- en: queries.py will contain resolvers for queries.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: queries.py 将包含查询的解析器。
- en: schema.py will contain all the code necessary to load an executable schema.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: schema.py 将包含加载可执行模式所需的所有代码。
- en: types.py will contain resolvers for object types, custom scalar types, and object
    properties.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: types.py 将包含对象类型、自定义标量类型和对象属性的解析器。
- en: 'The products.graphql specification file also goes under the `w`eb folder, since
    it’s handled by the code under the web/schema.py file. You can copy the API specification
    from the ch10/web/products.graphql file in the GitHub repository for this book.
    The directory structure for the products API looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 产品规格文件 products.graphql 也位于 `w`eb 文件夹下，因为它由 web/schema.py 文件下的代码处理。你可以从本书GitHub仓库中
    ch10/web/products.graphql 文件复制API规范。产品API的目录结构如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The GitHub repository for this book contains an additional module called `exceptions.py`,
    which you can check for examples of how to handle exceptions in your GraphQL APIs.
    Now that we have structured our project, it’s time to start coding!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中包含一个名为 `exceptions.py` 的附加模块，你可以从中查看如何在 GraphQL API 中处理异常的示例。现在我们已经结构化了我们的项目，是时候开始编码了！
- en: 10.4.2 Creating an entry point for the GraphQL server
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 创建 GraphQL 服务器的入口点
- en: Now that we have structured our project, it’s time to work on the implementation.
    In this section, we’ll create the entry point for the GraphQL server. We need
    to create an instance of Ariadne’s `GraphQL` class and load an executable schema
    from the products specification.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经结构化了我们的项目，是时候着手实现工作了。在本节中，我们将创建 GraphQL 服务器的入口点。我们需要创建 Ariadne 的 `GraphQL`
    类的实例，并从产品规范中加载一个可执行的架构。
- en: 'As we mentioned in section 10.4.1, the entry point for the products API server
    lives under server.py. Include the following content in this file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 10.4.1 节中提到的，产品 API 服务器的入口点位于 `server.py` 之下。将以下内容包含在这个文件中：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let’s create the executable schema under web/schema.py:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `web/schema.py` 下创建可执行的架构：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The API specification for the products API is available under the web/products.graphql
    file. We read the schema file contents and pass them on to Ariadne’s `make_executable_`
    `schema()` function. We then pass the resulting schema object to Ariadne’s `GraphQL`
    class to instantiate the server. If you haven’t started the server, you can do
    it now by executing the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 产品 API 的 API 规范位于 `web/products.graphql` 文件下。我们读取架构文件的内容，并将它们传递给 Ariadne 的 `make_executable_schema()`
    函数。然后，我们将生成的架构对象传递给 Ariadne 的 `GraphQL` 类以实例化服务器。如果你还没有启动服务器，你现在可以执行以下命令：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Like before, the API is available on http://localhost:8000\. If you visit this
    address again, you’ll see the familiar Apollo Playground UI. At this point, we
    could try running any of the queries defined in the products API specification;
    however, most of them will fail since we haven’t implemented any resolvers. For
    example, if you run the following query
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，API 可在 http://localhost:8000 上访问。如果你再次访问这个地址，你会看到熟悉的 Apollo Playground
    UI。在这个阶段，我们可以尝试运行产品 API 规范中定义的任何查询；然而，由于我们没有实现任何解析器，大多数查询都会失败。例如，如果你运行以下查询
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'you’ll get the following error message: “Cannot return null for non-nullable
    field Query.allProducts.” The server doesn’t know how to produce a value for the
    `Ingredient` type since we don’t have a resolver for it, so let’s build it!'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下错误消息：“Cannot return null for non-nullable field Query.allProducts。”服务器不知道如何为
    `Ingredient` 类型生成值，因为我们没有为其提供解析器，所以让我们构建它！
- en: 10.4.3 Implementing query resolvers
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 实现查询解析器
- en: In this section, we learn to implement query resolvers. As you can see from
    figure 10.4, a query resolver is a Python function that knows how to return a
    valid payload for a given query. We’ll build a resolver for the `allIngredients()`
    query, which is one of the simplest queries in the products API specification
    (listing 10.3).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何实现查询解析器。如图 10.4 所示，查询解析器是一个 Python 函数，它知道如何为给定的查询返回一个有效的有效载荷。我们将为
    `allIngredients()` 查询构建一个解析器，这是产品 API 规范中（列表 10.3）最简单的查询之一。
- en: '![](../Images/10-04.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-04.png)'
- en: Figure 10.4 GraphQL uses resolvers to serve the query requests sent by the user
    to the server. A resolver is a Python function that knows how to return a valid
    payload for a given query.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 GraphQL 使用解析器来服务用户发送到服务器的查询请求。解析器是一个 Python 函数，它知道如何为给定的查询返回一个有效的有效载荷。
- en: 'To implement a resolver for the `allIngredients()` query, we simply need to
    create a function that returns a data structure with the shape of the `Ingredient`
    type, which has four non-nullable properties: `id`, `name`, `stock`, and `products`.
    The `stock` property is, in turn, an instance of the `Stock` object type, which,
    as per the specification, must contain the `quantity` and `unit` properties. Finally,
    the `products` property must be an array of `Product` objects. The contents of
    the array are non-nullable, but an empty array is a valid return value.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `allIngredients()` 查询的解析器，我们只需要创建一个返回与 `Ingredient` 类型形状相同的数据结构的功能，该类型有四个非空属性：`id`、`name`、`stock`
    和 `products`。`stock` 属性反过来是一个 `Stock` 对象类型的实例，根据规范，它必须包含 `quantity` 和 `unit` 属性。最后，`products`
    属性必须是一个 `Product` 对象的数组。数组的内含是非空的，但空数组是一个有效的返回值。
- en: Listing 10.3 Specification for the `Ingredient` type
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 `Ingredient` 类型的规范
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① We declare the Stock type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明 Stock 类型。
- en: ② quantity is a non-nullable float.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ② 数量是一个非空浮点数。
- en: ③ products is a non-nullable list of products.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 产品是一个非空的产品列表。
- en: ④ supplier is a nullable through type that points to the Supplier type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 供应商通过类型指向Supplier类型，是一个可空的。
- en: 'Let’s add a list of ingredients to the in-memory list representation of our
    data under the web/data.py file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在web/data.py文件下，让我们给我们的数据内存列表表示添加一个成分列表：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have some data, we can use it in the `allIngredients()`’ resolver.
    Listing 10.4 shows what `allIngredients()`’ resolver looks like. As we did in
    section 10.3, we first create an instance of the `QueryType` class, and we bind
    the resolver with this class. Since this is a resolver for a query type, the implementation
    goes under the web/queries.py file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些数据，我们可以在`allIngredients()`解析器中使用它。列表10.4显示了`allIngredients()`解析器的外观。正如我们在第10.3节中所做的那样，我们首先创建了一个`QueryType`类的实例，并将解析器与这个类绑定。由于这是一个查询类型的解析器，实现代码位于web/queries.py文件下。
- en: Listing 10.4 A resolver for the `allIngredients()` query
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.4 `allIngredients()`查询的解析器
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① We bind allIngredients()’ resolver using the decorator.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用装饰器绑定allIngredients()解析器。
- en: ② We return a hardcoded response.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们返回一个硬编码的响应。
- en: 'To enable the query resolver, we have to pass the query object to the `make_executable_`
    `schema()` function under web/schema.py:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用查询解析器，我们必须将查询对象传递给web/schema.py下的`make_executable_` `schema()`函数：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we go back to the Apollo Playground UI and we run the query
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到Apollo Playground UI并运行查询
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'we get a valid payload. The query selects only the ingredient’s name, which
    in itself is not very interesting, and it doesn’t really tell us whether our current
    resolver works as expected for other fields. Let’s write a more complex query
    to test our resolver more thoroughly. The following query selects the `id`, `name`,
    and `description` of an ingredient, as well as the `name` of each product it’s
    related to:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个有效的有效载荷。查询只选择了成分的名称，这本身并不很有趣，并且它并没有真正告诉我们我们的当前解析器是否如预期地适用于其他字段。让我们编写一个更复杂的查询来更彻底地测试我们的解析器。以下查询选择了成分的`id`、`name`和`description`，以及与之相关的每个产品的`name`：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The response payload to this query is also valid:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的响应有效载荷也是有效的：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The products list is empty because we haven’t associated any products with the
    ingredient, and `description` is `null` because this is a nullable field. Now
    that we know how to implement resolvers for simple queries, in the next section,
    we’ll learn to implement resolvers that handle more complex situations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 产品列表为空，因为我们还没有将任何产品与成分关联，`description`是`null`，因为这是一个可空字段。现在我们知道如何实现简单查询的解析器实现，在下一节中，我们将学习如何实现处理更复杂情况的解析器。
- en: 10.4.4 Implementing type resolvers
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.4 实现类型解析器
- en: 'In this section, we’ll learn to implement resolvers for queries that return
    multiple types. The `allIngredients()` query is fairly simple since it only returns
    one type of object: the `Ingredient` type. Let’s now consider the `allProducts()`
    query. As you can see from figure 10.5, `allProducts()` is more complex since
    it returns the `Product` type, which is a union of the `Beverage` and `Cake` types,
    both of which implement the `ProductInterface` type.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何实现返回多个类型的查询解析器。`allIngredients()`查询相当简单，因为它只返回一种类型的对象：`Ingredient`类型。现在让我们考虑`allProducts()`查询。如图10.5所示，`allProducts()`更复杂，因为它返回`Product`类型，它是`Beverage`和`Cake`两种类型的联合，这两种类型都实现了`ProductInterface`类型。
- en: '![](../Images/10-05.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-05.png)'
- en: 'Figure 10.5 The `allIngredients()` query returns an array of `Ingredient` objects,
    while the `allProducts()` query returns an array of `Product` objects, where `Product`
    is the union of two types: `Beverage` and `Cake`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 `allIngredients()`查询返回一个`Ingredient`对象的数组，而`allProducts()`查询返回一个`Product`对象的数组，其中`Product`是`Beverage`和`Cake`两种类型的联合。
- en: 'Let’s begin by adding a list of products to our in-memory list of data under
    the web/data.py file. We’ll add two products: one `Beverage` and one `C``ake`.
    What fields should we include in the products? As you can see in figure 10.6,
    since `Beverage` and `Cake` implement the `ProductInterface` type, we know they
    both require an `id`, a `name`, a list of `ingredients`, and a field called `available`,
    which signals if the product is available. On top of these common fields inherited
    from `ProductInterface`, `Beverage` requires two additional fields: `hasCreamOnTopOption`
    and `hasServeOnIceOption`, both of which are Booleans. In turn, `Cake` requires
    the properties `hasFilling` and `hasNutsToppingOption`, which are also Booleans.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 web/data.py 文件下的内存数据列表中添加产品列表开始。我们将添加两个产品：一个 `Beverage` 和一个 `C``ake`。我们应该在产品中包含哪些字段？如图
    10.6 所示，由于 `Beverage` 和 `Cake` 实现了 `ProductInterface` 类型，我们知道它们都需要一个 `id`、一个 `name`、一个
    `ingredients` 列表和一个名为 `available` 的字段，该字段表示产品是否可用。在这些从 `ProductInterface` 继承的公共字段之上，`Beverage`
    需要两个额外的字段：`hasCreamOnTopOption` 和 `hasServeOnIceOption`，这两个都是布尔值。反过来，`Cake` 需要属性
    `hasFilling` 和 `hasNutsToppingOption`，这些也是布尔值。
- en: '![](../Images/10-06.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-06.png)'
- en: Figure 10.6 Product is the union of the `Beverage` and the `Cake` types, both
    of which implement the `ProductInterface` type. Since `Beverage` and `Cake` implement
    the same interface, both types share the properties inherited from the interface.
    In addition to those properties, each type has its own specific properties, such
    as `hasFilling` in the case of the `Cake` type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 产品是 `Beverage` 和 `Cake` 类型的联合，这两个类型都实现了 `ProductInterface` 类型。由于 `Beverage`
    和 `Cake` 实现了相同的接口，这两个类型共享从接口继承的属性。除了这些属性外，每个类型都有自己的特定属性，例如 `Cake` 类型的 `hasFilling`。
- en: Listing 10.5 Resolver for the `allProducts()` query
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 `allProducts()` 查询的解析器
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① This ID references the ID of the milk ingredient we added earlier to web/data.py.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此 ID 引用了我们在 web/data.py 中之前添加的牛奶成分的 ID。
- en: Now that we have a list of products, let’s use it in the `allProducts()`’ resolver.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了产品列表，让我们在 `allProducts()` 解析器中使用它。
- en: Listing 10.6 Adding the `allProducts()` resolver
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 添加 `allProducts()` 解析器
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① We bind allProducts()’ resolver using the field() decorator.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用 field() 装饰器绑定 allProducts() 的解析器。
- en: ② We return a hardcoded response.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们返回一个硬编码的响应。
- en: 'Let’s run a simple query to test the resolver:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个简单的查询来测试解析器：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you run this query, you’ll get an error saying that the server can’t determine
    what types each of the elements in our list are. In these situations, we need
    a type resolver. As you can see in figure 10.7, a *type resolver* is a Python
    function that determines what type an object is, and it returns the name of the
    type.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此查询，你会得到一个错误，表示服务器无法确定我们列表中每个元素的类型。在这些情况下，我们需要一个类型解析器。如图 10.7 所示，一个 *类型解析器*
    是一个 Python 函数，它确定对象的类型，并返回类型的名称。
- en: '![](../Images/10-07.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-07.png)'
- en: Figure 10.7 A type resolver is a function that determines the type of an object.
    This example shows how the `resolve_product_type()` resolver determines the type
    of an object returned by the `resolve_all_products()` resolver.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 类型解析器是一个确定对象类型的函数。此示例显示了 `resolve_product_type()` 解析器如何确定 `resolve_all_products()`
    解析器返回的对象的类型。
- en: We need type resolvers in queries and mutations that return more than one object
    type. In the products API, this affects all queries and mutations that return
    the `Product` type, such as `allProducts()`, `addProduct()`, and `product()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询和突变中，我们需要类型解析器来返回多于一个对象类型。在产品 API 中，这影响到所有返回 `Product` 类型的查询和突变，例如 `allProducts()`、`addProduct()`
    和 `product()`。
- en: Returning multiple types Whenever a query or mutation returns multiple types,
    you’ll need to implement a type resolver. This applies to queries and mutations
    that return union types and object types that implement interfaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多个类型 当查询或突变返回多个类型时，你需要实现一个类型解析器。这适用于返回联合类型和实现接口的对象类型的查询和突变。
- en: 'Listing 10.7 shows how we implement a type resolver for the `Product` type
    in Ariadne. The type resolver function takes two positional parameters, the first
    of which is an object. We need to determine the type of this object. As you can
    see in figure 10.8, since we know that `Cake` and `Beverage` have different required
    fields, we can use this information to determine their types: if the object has
    a `hasFilling` property, we know it’s a `Cake`; otherwise, it’s a `Beverage`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 展示了我们在 Ariadne 中如何实现 `Product` 类型的类型解析器。类型解析器函数接受两个位置参数，第一个是一个对象。我们需要确定这个对象的类型。如图
    10.8 所示，由于我们知道 `Cake` 和 `Beverage` 有不同的必需字段，我们可以使用这些信息来确定它们的类型：如果对象有 `hasFilling`
    属性，我们知道它是一个 `Cake`；否则，它是一个 `Beverage`。
- en: '![](../Images/10-08.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-08.png)'
- en: Figure 10.8 A type resolver inspects the properties of a payload to determine
    its type. In this example, `resolve_product_type()` looks for distinguishing properties
    that differentiate a `Cake` from a `Beverage` type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 类型解析器检查有效负载的属性以确定其类型。在这个例子中，`resolve_product_type()` 寻找区分 `Cake` 和 `Beverage`
    类型的区分属性。
- en: The type resolver must be bound to the `Product` type. Since `Product` is a
    union type, we create a bindable object of it using the `UnionType` class. Ariadne
    guarantees that the first argument in a resolver is an object, and we inspect
    this object to resolve its type. We don’t need any other parameters, so we ignore
    them with Python’s `*_` syntax, which is standard for ignoring positional parameters.
    To resolve the type of the object, we check if it has a `hasFilling` attribute.
    If it does, we know it’s a `Cake` object; otherwise, it’s a `Beverage`. Finally,
    we pass the product bindable to the `make_executable_schema()` function. Since
    this is a type resolver, this code goes into the web/types.py.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类型解析器必须绑定到 `Product` 类型。由于 `Product` 是一个联合类型，我们使用 `UnionType` 类创建它的一个可绑定对象。Ariadne
    保证解析器中的第一个参数是一个对象，我们检查这个对象以解析其类型。我们不需要任何其他参数，因此我们使用 Python 的 `*_` 语法忽略它们，这是忽略位置参数的标准做法。为了解析对象的类型，我们检查它是否有
    `hasFilling` 属性。如果有，我们知道它是一个 `Cake` 对象；否则，它是一个 `Beverage`。最后，我们将产品可绑定对象传递给 `make_executable_schema()`
    函数。由于这是一个类型解析器，这段代码将放入 web/types.py。
- en: Listing 10.7 Implementing a type resolver for the `Product` union type
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 实现对 `Product` 联合类型的类型解析器
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① We create a bindable object for the Product type using the UnionType class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用 UnionType 类为 Product 类型创建一个可绑定对象。
- en: ② We bind Product’s resolver using the resolver() decorator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 resolver() 装饰器绑定 Product 的解析器。
- en: ③ We capture the resolver’s first positional argument as obj.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们将解析器的第一个位置参数捕获为 obj。
- en: 'To enable the type resolver, we need to add the product object to the `make_executable_`
    `schema()` function under web/schema.py:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用类型解析器，我们需要将产品对象添加到 web/schema.py 下的 `make_executable_` `schema()` 函数中：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s run the `allProducts()` query again:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行 `allProducts()` 查询：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You’ll now get a successful response. You have just learned to implement type
    resolvers and to handle queries that return multiple types! In the next section,
    we continue exploring queries by learning how to handle query parameters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将获得一个成功的响应。你已经学会了如何实现类型解析器和处理返回多个类型的查询！在下一节中，我们将继续通过学习如何处理查询参数来探索查询。
- en: 10.4.5 Handling query parameters
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.5 处理查询参数
- en: 'In this section, we learn to handle query parameters in the resolvers. Most
    of the queries in the products API accept filtering parameters, and all the mutations
    require at least one parameter. Let’s see how we access parameters by studying
    one example from the products API: the `products()` query, which accepts an `input`
    filter object whose type is `ProductsFilter`. How do we access this filter object
    in a resolver?'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何在解析器中处理查询参数。大多数产品 API 中的查询都接受过滤参数，并且所有突变至少需要一个参数。让我们通过研究产品 API 中的一个示例来了解我们如何访问参数：`products()`
    查询接受一个 `input` 过滤对象，其类型为 `ProductsFilter`。我们如何在解析器中访问这个过滤对象？
- en: '![](../Images/10-09.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-09.png)'
- en: Figure 10.9 Query parameters are passed to our resolvers as keyword arguments.
    This example illustrates how the `resolve_products()` resolver is called, with
    the `input` parameter passed as a keyword argument. The parameter `input` is an
    object of type `ProductsFilter`, and therefore it comes in the form of a dictionary.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 查询参数作为关键字参数传递给我们的解析器。这个例子说明了 `resolve_products()` 解析器是如何被调用的，其中 `input`
    参数作为关键字参数传递。参数 `input` 是 `ProductsFilter` 类型的对象，因此它以字典的形式出现。
- en: 'As you can see in figure 10.9, when a query or mutation takes parameters, Ariadne
    passes those parameters to our resolvers as keyword arguments. Listing 10.8 shows
    how we access the `input` parameter for the `products()` query resolver. Since
    the `input` parameter is optional and therefore nullable, we set it by default
    to `None`. The `input` parameter is an instance of the `ProductsFilter` input
    type, so when it’s present in the query, it comes in the form of a dictionary.
    From the API specification, we know that `ProductsFilter` guarantees the presence
    of the following fields:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如图10.9所示，当查询或突变带有参数时，Ariadne将这些参数作为关键字参数传递给我们的解析器。列表10.8显示了如何访问`products()`查询解析器的`input`参数。由于`input`参数是可选的，因此可能是null，我们将其默认设置为`None`。`input`参数是`ProductsFilter`输入类型的一个实例，因此当它在查询中存在时，它以字典的形式出现。从API规范中，我们知道`ProductsFilter`保证以下字段的可用性：
- en: '`available`—Boolean field that filters products by whether they’re available'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`available`——布尔字段，通过是否可用过滤产品'
- en: '`sortBy`—An enumeration type that allows us to sort products by price or name'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortBy`——枚举类型，允许我们按价格或名称对产品进行排序'
- en: '`sort`—Enumeration type that allows us to sort the results in ascending or
    descending order'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`——枚举类型，允许我们按升序或降序排序结果'
- en: '`resultsPerPage`—Indicates how many results should be shown per page'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resultsPerPage`——指示每页应显示多少结果'
- en: '`page`—Indicates which page of the results we should return'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`——指示应返回哪个结果页'
- en: 'In addition to these parameters, `ProductsFilter` may also include two optional
    parameters: `maxPrice`, which filters results by maximum price, and `minPrice`,
    which filters results by minimum price. Since `maxPrice` and `minPrice` are not
    required fields, we check for their presence using the Python dictionary’s `get()`
    method, which returns `None` if they’re not found. Let’s implement the filtering
    and sorting functionality first, and deal with pagination afterwards. The following
    code goes under web/ queries.py.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些参数之外，`ProductsFilter`还可能包括两个可选参数：`maxPrice`，它通过最大价格过滤结果，以及`minPrice`，它通过最小价格过滤结果。由于`maxPrice`和`minPrice`不是必填字段，我们使用Python字典的`get()`方法检查它们是否存在，如果找不到则返回`None`。让我们首先实现过滤和排序功能，然后再处理分页。以下代码位于web/queries.py文件中。
- en: Listing 10.8 Accessing `input` parameters in a resolver
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.8 在解析器中访问`input`参数
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① We bind products()’ resolver using the field() decorator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用field()装饰器绑定products()的解析器。
- en: ② We ignore the default positional arguments and instead capture the input parameter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们忽略默认的位置参数，而是捕获输入参数。
- en: ③ We copy the list of products.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们复制产品列表。
- en: ④ If input is None, we return the whole dataset.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果输入为None，我们返回整个数据集。
- en: ⑤ We filter products by availability.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们通过可用性过滤产品。
- en: ⑥ We filter products by minPrice.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们通过minPrice过滤产品。
- en: ⑦ We sort the filtered dataset.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们对过滤后的数据集进行排序。
- en: ⑧ We return the filtered dataset.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们返回过滤后的数据集。
- en: 'Let’s run a query to test this resolver:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个查询来测试这个解析器：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should get a valid response from the server. Now that we have filtered
    the results, we need to paginate them. Listing 10.9 adds a generic pagination
    function called `get_page()` to web/queries.py. Just a word of warning: in normal
    circumstances, you’ll be storing your data in a database and delegating filtering
    and pagination to the database. The examples here are to illustrate how you use
    the query parameters in the resolver. We paginate the results using the `islice()`
    function from the `itertools` module.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从服务器获得一个有效的响应。现在我们已经过滤了结果，我们需要对它们进行分页。列表10.9向web/queries.py添加了一个名为`get_page()`的通用分页函数。提醒一下：在正常情况下，你会在数据库中存储数据，并将过滤和分页委托给数据库。这里的示例是为了说明如何在解析器中使用查询参数。我们使用`itertools`模块中的`islice()`函数进行分页。
- en: '![](../Images/10-10.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图10-10](../Images/10-10.png)'
- en: Figure 10.10 The `islice()` function from the `itertools` module allows you
    to get a slice of an iterable object by selecting the `start` and `stop` indices
    of the subset that you want to slice.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 `itertools`模块中的`islice()`函数允许你通过选择子集的`start`和`stop`索引来获取可迭代对象的切片。
- en: 'As you can see in figure 10.10, `islice()` allows us to extract a slice of
    an iterable object. `islice()` requires us to provide the start and stop indices
    of the portion that we want to slice. For example, a list of 10 items comprising
    the numbers 0 to 9, providing a start index of 2 and a stop index of 6, would
    give us a slice with the following items: `[2,` `3,` `4,` `5]`. The API paginates
    results starting at 1, while `islice()` uses zero-based indexing, so `get_page()`
    subtracts one unit from the `page` parameter to account for that difference.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图 10.10 中可以看到，`islice()` 允许我们从可迭代对象中提取一个片段。`islice()` 需要我们提供我们想要切片的部分的起始和停止索引。例如，一个包含数字
    0 到 9 的 10 项列表，提供起始索引为 2 和停止索引为 6，将给我们以下项的切片：`[2,` `3,` `4,` `5]`。API 从 1 开始分页结果，而
    `islice()` 使用基于零的索引，因此 `get_page()` 从 `page` 参数中减去一个单位来补偿这个差异。
- en: Listing 10.9 Paginating results
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 分页结果
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① We import islice().
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入 islice()。
- en: ② We resolve the start index.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们解析起始索引。
- en: ③ We calculate the stop index.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们计算停止索引。
- en: ④ We return a slice of the list.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们返回列表的一个切片。
- en: ⑤ We paginate the results.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们分页结果。
- en: 'Our hardcoded dataset only contains two products, so let’s test the pagination
    with `resutlsPerPage` set to 1, which will split the list into two pages:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们硬编码的数据集只包含两个产品，所以让我们将 `resutlsPerPage` 设置为 1 来测试分页，这将把列表分成两页：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You should get exactly one result. Once we implement the `addProduct()` mutation
    in the next section, we’ll be able to add more products through the API and make
    more use of the pagination parameters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个确切的结果。一旦我们在下一节实现 `addProduct()` 突变，我们就能通过 API 添加更多产品并充分利用分页参数。
- en: You just learned how to handle query parameters! We’re now in a good position
    to learn how to implement mutations. Mutation resolvers are similar to query resolvers,
    but they always have parameters. But that’s enough of a spoiler; move on to the
    next section to learn more about mutations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了如何处理查询参数！我们现在处于一个很好的位置来学习如何实现突变。突变解析器与查询解析器类似，但它们总是有参数。但这就足够剧透了；继续到下一节，了解更多关于突变的信息。
- en: 10.4.6 Implementing mutation resolvers
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.6 实现突变解析器
- en: In this section, we learn to implement mutation resolvers. Implementing a mutation
    resolver follows the same guidelines we saw for queries. The only difference is
    the class we use to bind the mutation resolvers. While queries are bound to an
    instance of the `QueryType` class, mutations are bound to an instance of the `MutationType`
    class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何实现突变解析器。实现突变解析器遵循我们看到的查询的相同指南。唯一的区别是我们用来绑定突变解析器的类。虽然查询绑定到 `QueryType`
    类的实例，但突变绑定到 `MutationType` 类的实例。
- en: 'Let’s have a look at implementing the resolver for the `addProduct()` mutation.
    From the specification, we know that the `addProduct()` mutation has three required
    parameters: `name`, `type`, and `input`. The shape of the `input` parameter is
    given by the `AddProductInput` object type. `AddProductInput` defines additional
    properties that can be set when creating a new product, all of which are optional
    and therefore nullable. Finally, the `addProduct()` mutation must return a product
    type.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现 `addProduct()` 突变的解析器。从规范中，我们知道 `addProduct()` 突变有三个必需参数：`name`、`type`
    和 `input`。`input` 参数的形状由 `AddProductInput` 对象类型给出。`AddProductInput` 定义了在创建新产品时可以设置的附加属性，所有这些属性都是可选的，因此是可空的。最后，`addProduct()`
    突变必须返回一个产品类型。
- en: '![](../Images/10-11.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11](../Images/10-11.png)'
- en: Figure 10.11 Mutation parameters are passed to our resolvers as keyword arguments.
    This example illustrates how the `resolve_add_product()` resolver is called, with
    the `name`, `type`, and `input` parameters passed as keyword arguments.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 突变参数作为关键字参数传递给我们的解析器。此示例说明了如何调用 `resolve_add_product()` 解析器，其中 `name`、`type`
    和 `input` 参数作为关键字参数传递。
- en: Listing 10.10 shows how we implement the resolver for the `addProduct()` mutation
    (see figure 10.11 for an illustration). We first import the `MutationType` bindable
    class and instantiate it. We then declare our resolver and bind it to `MutationType`
    using its `field()` decorator. We don’t need to use Ariadne’s default positional
    parameters `obj` and `info`, so we skip them using a wildcard followed by an underscore
    (`*_`). We don’t set default values for `addProduct()`’s parameters, since the
    specification states they’re all required. `addProduct()` must return a valid
    `Product` object, so we build the object with its expected attributes in the body
    of the resolver. Since `Product` is the union of the `Cake` and `Beverage` types,
    and each type requires different sets of properties, we check the `type` parameter
    to determine which fields we should add to our object. The following code goes
    into the web/mutations.py file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10展示了我们如何实现`addProduct()`变异的解析器（参见图10.11以获取说明）。我们首先导入`MutationType`可绑定类并实例化它。然后我们声明我们的解析器，并使用其`field()`装饰器将其绑定到`MutationType`。我们不需要使用Ariadne的默认位置参数`obj`和`info`，所以我们使用一个通配符后跟一个下划线(`*_`)来跳过它们。由于规范指出它们都是必需的，我们没有为`addProduct()`的参数设置默认值。`addProduct()`必须返回一个有效的`Product`对象，因此我们在解析器的主体中构建具有预期属性的该对象。由于`Product`是`Cake`和`Beverage`类型的联合，并且每种类型都需要不同的属性集，我们检查`type`参数以确定我们应该向我们的对象添加哪些字段。以下代码将放入`web/mutations.py`文件中。
- en: Listing 10.10 Resolver for the `addProduct()` mutation
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 `addProduct()`变异的解析器
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① Bindable object for mutations
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ① 用于变异的可绑定对象
- en: ② We bind addProduct()’s resolver using the field() decorator.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用field()装饰器绑定`addProduct()`的解析器。
- en: ③ We capture addProduct()’s parameters.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们捕获`addProduct()`的参数。
- en: ④ We declare the new product as a dictionary.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们将新产品声明为一个字典。
- en: ⑤ We set server-side properties such as the ID.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们设置服务器端属性，如ID。
- en: ⑥ We parse optional parameters and set their default values.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们解析可选参数并设置它们的默认值。
- en: ⑦ We check whether the product is a Beverage or a Cake.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们检查产品是饮料还是蛋糕。
- en: ⑧ We return the newly created product.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们返回新创建的产品。
- en: 'To enable the resolver implemented in listing 10.10, we need to add the `mutation`
    object to the `make_executable_schema()` function in web/schema.py:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用列表10.10中实现的解析器，我们需要将`mutation`对象添加到`web/schema.py`中的`make_executable_schema()`函数中：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s put the new mutation to work by running a simple test. Go to the Apollo
    Playground running on http://127.0.0.1:8000, and run the following mutation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行一个简单的测试来使用这个新的变异。转到运行在http://127.0.0.1:8000上的Apollo Playground，并运行以下变异：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You’ll get a valid response, and a new product will be added to our list. To
    verify things are working correctly, run the following query and check that the
    response contains the new item just created:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个有效的响应，并且一个新的产品将被添加到我们的列表中。为了验证一切是否正常工作，运行以下查询并检查响应是否包含刚刚创建的新条目：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Remember that we are running the service with an in-memory list representation
    of our data, so if you stop or reload the server, the list will be reset and you’ll
    lose any newly created data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们正在使用我们数据的内存列表表示运行服务，所以如果你停止或重新加载服务器，列表将被重置，你将丢失任何新创建的数据。
- en: 'You just learned how to build mutations! This is a powerful feature: with mutations,
    you can create and update data in a GraphQL server. We’ve now covered nearly all
    the major aspects of the implementation of a GraphQL server. In the next section,
    we’ll take this further by learning how to implement resolvers for custom scalar
    types.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了如何构建变异！这是一个强大的功能：使用变异，你可以在GraphQL服务器中创建和更新数据。我们现在已经涵盖了GraphQL服务器实现的大部分主要方面。在下一节中，我们将进一步学习如何实现自定义标量类型的解析器。
- en: 10.4.7 Building resolvers for custom scalar types
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.7 为自定义标量类型构建解析器
- en: In this section, we learn how to implement resolvers for custom scalar types.
    As we saw in chapter 8, GraphQL provides a decent amount of scalar types, such
    as Boolean, integer, and string. And in many cases, GraphQL’s default scalar types
    are sufficient to develop an API. Sometimes, however, we need to define our own
    custom scalars. The products API contains a custom scalar called `Datetime`. The
    `lastUpdated` field in both the `Ingredient` and `Product` types have a `Datetime`
    scalar type. Since `Datetime` is a custom scalar, Ariadne doesn’t know how to
    handle it, so we need to implement a resolver for it. How do we do that?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何实现自定义标量类型的解析器。正如我们在第8章中看到的，GraphQL提供了一定数量的标量类型，例如布尔值、整数和字符串。在许多情况下，GraphQL的默认标量类型足以开发API。有时，然而，我们需要定义我们自己的自定义标量。产品API包含一个名为`Datetime`的自定义标量。`Ingredient`和`Product`类型中的`lastUpdated`字段都有一个`Datetime`标量类型。由于`Datetime`是一个自定义标量，Ariadne不知道如何处理它，因此我们需要为它实现一个解析器。我们如何做到这一点？
- en: '![](../Images/10-12.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-12.png)'
- en: Figure 10.12 When a GraphQL server receives data from the user, it validates
    and deserializes the data into native Python objects. In this example, the server
    deserializes the name `"Mocha"` into a Python string, and the date `"2021-01-01"`
    into a Python datetime.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 当GraphQL服务器从用户接收数据时，它验证并反序列化数据为原生Python对象。在这个例子中，服务器将名称`"Mocha"`反序列化为Python字符串，将日期`"2021-01-01"`反序列化为Python
    datetime对象。
- en: '![](../Images/10-13.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-13.png)'
- en: Figure 10.13 When the GraphQL server sends data to the user, it transforms native
    Python objects into serializable data. In this example, the server serializes
    the both the name and the date as strings.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 当GraphQL服务器向用户发送数据时，它将原生Python对象转换为可序列化的数据。在这个例子中，服务器将名称和日期都序列化为字符串。
- en: 'As you can see in figures 10.12 and 10.13, when we encounter a custom scalar
    type in a GraphQL API, we need to make sure we can perform the following three
    actions on the custom scalar:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图10.12和10.13中可以看到的，当我们遇到GraphQL API中的自定义标量类型时，我们需要确保我们能够对自定义标量执行以下三个操作：
- en: '*Serialization*—When a user requests data from the server, Ariadne has to be
    able to serialize the data. Ariadne knows how to serialize GraphQL’s built-in
    scalars, but for custom scalars, we need to implement a custom serializer. In
    the case of the `Datetime` scalar in the products API, we have to implement a
    method to serialize a `datetime` object.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*序列化*—当用户从服务器请求数据时，Ariadne必须能够序列化数据。Ariadne知道如何序列化GraphQL的内置标量，但对于自定义标量，我们需要实现一个自定义序列化器。在产品API中`Datetime`标量的情况下，我们必须实现一个序列化`datetime`对象的方法。'
- en: '*Deserialization*—When a user sends data to our server, Ariadne deserializes
    the data and makes it available to us as a Python native data structure, such
    as a dictionary. If the data includes a custom scalar, we need to implement a
    method that lets Ariadne know how to parse and load the scalar into a native Python
    data structure. For the `Datetime` scalar, we want to be able to load it as a
    `datetime` object.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反序列化*—当用户向我们的服务器发送数据时，Ariadne将数据反序列化并使其以Python原生数据结构的形式（如字典）可用。如果数据中包含自定义标量，我们需要实现一个方法，让Ariadne知道如何解析和将标量加载到原生Python数据结构中。对于`Datetime`标量，我们希望能够将其加载为`datetime`对象。'
- en: '*Validation*—GraphQL enforces validation of each scalar and type, and Ariadne
    knows how to validate GraphQL’s built-in scalars. For custom scalars, we have
    to implement our own validation methods. In the case of the `Datetime` scalar,
    we want to make sure it has a valid ISO format.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证*—GraphQL强制执行每个标量和类型的验证，Ariadne知道如何验证GraphQL的内置标量。对于自定义标量，我们必须实现我们自己的验证方法。在`Datetime`标量的情况下，我们想要确保它具有有效的ISO格式。'
- en: 'Ariadne provides a simple API to handle these actions through its `ScalarType`
    class. The first thing we need to do is create an instance of this class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Ariadne通过其`ScalarType`类提供了一个简单的API来处理这些操作。我们需要做的第一件事是创建这个类的实例：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`ScalarType` exposes decorator methods that allow us to implement serialization,
    deserialization, and validation. For serialization, we use `ScalarType`’s `serializer()`
    decorator. We want to serialize `datetime` objects into ISO standard date format,
    and Python’s `datetime` library provides a convenient method for ISO formatting,
    the `isoformat()` method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalarType`公开了装饰器方法，允许我们实现序列化、反序列化和验证。对于序列化，我们使用`ScalarType`的`serializer()`装饰器。我们希望将`datetime`对象序列化为ISO标准日期格式，Python的`datetime`库提供了一个方便的ISO格式化方法，即`isoformat()`方法：'
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For validation and deserialization, `ScalarType` provides the `value_parser()`
    decorator. When a user sends data to the server containing a `Datetime` scalar,
    we expect the date to be in ISO format and therefore parsable by Python’s `datetime.fromisoformat()`
    method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于验证和反序列化，`ScalarType` 提供了 `value_parser()` 装饰器。当用户向服务器发送包含 `Datetime` 标量数据时，我们期望日期以
    ISO 格式，因此可以被 Python 的 `datetime.fromisoformat()` 方法解析：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the date comes in the wrong format, `fromisoformat()` will raise a `ValueError`,
    which will be caught by Ariadne and shown to the user with the following message:
    “Invalid isoformat string.” The following code goes under web/types.py since it
    implements a type resolver.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日期以错误的格式传入，`fromisoformat()` 将引发一个 `ValueError`，这将由 Ariadne 捕获并向用户显示以下消息：“Invalid
    isoformat string.” 以下代码位于 web/types.py 中，因为它实现了类型解析器。
- en: Listing 10.11 Serializing and parsing a custom scalar
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 序列化和解析自定义标量
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① We create a bindable object for the Datetime scalar using the ScalarType class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用 ScalarType 类创建一个可绑定的 Datetime 标量对象。
- en: ② We bind Datetime’s serializer using the serializer() decorator.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 serializer() 装饰器绑定 Datetime 的序列化器。
- en: ③ We capture the serializer’s argument as date.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们将序列化器的参数捕获为日期。
- en: ④ We serialize the date object.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们序列化日期对象。
- en: ⑤ We bind Datetime’s parser using the value_parser() decorator.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们使用 value_parser() 装饰器绑定 Datetime 的解析器。
- en: ⑥ We capture the parser’s argument.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们捕获解析器的参数。
- en: ⑦ We parse a date.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们解析一个日期。
- en: 'To enable the `Datetime` resolvers, we add `datetime_scalar` to the array of
    bindable objects for the `make_executable_schema()` function under web/schema.py:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 `Datetime` 解析器，我们将 `datetime_scalar` 添加到 web/schema.py 中 `make_executable_schema()`
    函数的可绑定对象数组中：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s put the new resolvers to the test! Go back to the Apollo Playground running
    on http://127.0.0.1:8000 and execute the following query:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将新的解析器付诸实践！回到运行在 http://127.0.0.1:8000 的 Apollo Playground，并执行以下查询：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should get a list of all products with their names, and with an ISO-formatted
    date in the `lastUpdated` field. You now have the power to implement your own
    custom scalar types in GraphQL. Use it wisely! Before we close the chapter, there’s
    one more topic we need to explore: implementing resolvers for the fields of an
    object type.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个包含所有产品名称以及 `lastUpdated` 字段中 ISO 格式日期的产品列表。现在你有了在 GraphQL 中实现自定义标量类型的能力。明智地使用它！在我们结束这一章之前，还有一个话题我们需要探讨：实现对象类型字段的解析器。
- en: 10.4.8 Implementing field resolvers
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.8 实现字段解析器
- en: 'In this section, we learn to implement resolvers for the fields of an object
    type. We’ve implemented nearly all the resolvers that we need to serve all sorts
    of queries on the products API, but there’s still one type of query that our server
    can’t resolve: queries involving fields that map to other GraphQL types. For example,
    the `Products` type has a field called `ingredients`, which maps to an array of
    `IngredientRecipe` objects. According to the specification, the shape of the `IngredientRecipe`
    type looks like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何实现对象类型字段的解析器。我们已经实现了几乎所有在产品 API 上提供各种查询所需的解析器，但我们的服务器仍然无法解析一种类型的查询：涉及映射到其他
    GraphQL 类型的字段。例如，`Products` 类型有一个名为 `ingredients` 的字段，它映射到一个 `IngredientRecipe`
    对象数组。根据规范，`IngredientRecipe` 类型的形状如下：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Each `IngredientRecipe` object has an `ingredient` field, which maps to an
    `Ingredient` object type. This means that, when we query the `ingredients` field
    of a product, we should be able to pull information about each ingredient, such
    as its name, description, or supplier information. In other words, we should be
    able to run the following query against the server:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `IngredientRecipe` 对象都有一个 `ingredient` 字段，它映射到 `Ingredient` 对象类型。这意味着，当我们查询产品的
    `ingredients` 字段时，我们应该能够获取每个成分的信息，例如其名称、描述或供应商信息。换句话说，我们应该能够在服务器上运行以下查询：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you run this query in Apollo Playground at this juncture, you’ll get an
    error with the following message: “Cannot return null for non-nullable field Ingredient.name.”'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候在 Apollo Playground 中运行这个查询，你会得到一个错误，错误信息如下：“Cannot return null for
    non-nullable field Ingredient.name。”
- en: 'Why is this happening? If you look at the list of products in listing 10.5,
    you’ll notice that the `ingredients` field maps to an array of objects with three
    fields: `ingredient`, `quantity`, and `unit`. For example, the Walnut Bomb has
    the following ingredients:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？如果你查看 10.5 列表中的产品列表，你会注意到 `ingredients` 字段映射到一个包含三个字段的对象数组：`ingredient`、`quantity`
    和 `unit`。例如， Walnut Bomb 有以下成分：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `ingredient` field maps to an ingredient ID, not a full ingredient object.
    This is our internal representation of the product’s ingredients. It’s how we
    store product data in our database (in-memory list in this implementation). And
    it’s a useful representation since it allows us to identify each ingredient by
    ID. However, the API specification tells us that the `ingredients` field should
    map to an array of `IngredientRecipe` objects and that each `ingredient` should
    represent an `Ingredient` object, not just an ID.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`ingredient`字段映射到成分ID，而不是完整的成分对象。这是我们产品成分的内部表示。这是我们如何在数据库中存储产品数据（在本实现中为内存列表）的方式。并且这是一个有用的表示，因为它允许我们通过ID识别每个成分。然而，API规范告诉我们，`ingredients`字段应该映射到`IngredientRecipe`对象的数组，并且每个`ingredient`应该代表一个`Ingredient`对象，而不仅仅是ID。'
- en: How do we solve this problem? We can use different approaches. For example,
    we could make sure that each ingredient payload is correctly built in the resolvers
    for each query that returns a `Product` type. For example, listing 10.12 shows
    how we can modify the `allProducts()` resolver to accomplish this. The snippet
    modifies every product’s `ingredients` property to make sure it contains a full
    ingredient payload. Since every product is represented by a dictionary, we make
    a deep copy of each product to make sure the changes we apply in this function
    don’t affect our in-memory list of products.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？我们可以使用不同的方法。例如，我们可以确保每个成分负载在返回`Product`类型的每个查询的解析器中都被正确构建。例如，列表10.12展示了我们如何修改`allProducts()`解析器来完成这个任务。该片段修改了每个产品的`ingredients`属性，以确保它包含一个完整的成分负载。由于每个产品都由一个字典表示，我们为每个产品进行深度复制，以确保在这个函数中应用的变化不会影响我们的内存产品列表。
- en: Listing 10.12 Updating products to contain full ingredient payloads, not just
    IDs
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.12 更新产品以包含完整的成分负载，而不仅仅是ID
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① We make a deep copy of each object in the products list.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们对产品列表中的每个对象进行深度复制。
- en: ② We update the ingredient property with a full representation of the ingredient.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用成分的完整表示更新成分属性。
- en: ③ We return the list of products with ingredients.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们返回包含成分的产品列表。
- en: The approach in listing 10.12 is perfectly fine, but as you can see, it makes
    the code grow in complexity. If we had to do this for a few more properties, the
    function would quickly become difficult to understand and to maintain.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.12中的方法完全可行，但正如你所看到的，它使得代码的复杂性增加。如果我们需要为更多的属性做同样的事情，函数很快就会变得难以理解和维护。
- en: '![](../Images/10-14.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-14.png)'
- en: Figure 10.14 GraphQL allows us to create resolvers for specific fields of an
    object. In this example, the `resolve_product_ingredients()` resolver takes care
    of returning a valid payload for the `ingredients` property of a product.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 GraphQL允许我们为对象的特定字段创建解析器。在这个例子中，`resolve_product_ingredients()`解析器负责为产品的`ingredients`属性返回一个有效的负载。
- en: As you can see in figure 10.14, GraphQL offers an alternative way of resolving
    object properties. Instead of modifying the product payload within the `allProducts()`
    resolver, we can create a specific resolver for the product’s `ingredients` property
    and make any necessary changes within that resolver. Listing 10.13 shows what
    the resolver for the product’s `ingredients` property looks like and goes under
    web/types.py since it implements a resolver for object properties.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图10.14中可以看到的，GraphQL提供了一种解决对象属性的方法的替代方式。我们不是在`allProducts()`解析器中修改产品负载，而是可以创建一个针对产品`ingredients`属性的特定解析器，并在该解析器内进行任何必要的修改。列表10.13展示了产品`ingredients`属性的解析器是什么样的，并且位于`web/types.py`下，因为它实现了对象属性的解析器。
- en: Listing 10.13 Implementing a field resolver
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.13 实现字段解析器
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ① We create a deep copy of each ingredient.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们为每个成分创建深度复制。
- en: Object property resolvers help us keep our code more modular because every resolver
    does only one thing. They also help us avoid repetition. By having a single resolver
    that takes care of updating the `ingredients` property in product payloads, we
    avoid having to perform this operation in every resolver that returns a product
    type. On the downside, property resolvers may be more difficult to trace and debug.
    If something is wrong with the `ingredients` payload, you won’t find the bug within
    the `allProducts()` resolver. You have to know that there’s a resolver for products’
    ingredients and look into that resolver. Application logs will help to point you
    in the right direction when debugging this kind of issues, but bear in mind that
    this design will not be entirely obvious to other developers who are not familiar
    with GraphQL. As with everything else in software design, make sure that code
    reusability doesn’t impair the readability and ease of maintenance of your code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对象属性解析器帮助我们使代码更加模块化，因为每个解析器只做一件事。它们还帮助我们避免重复。通过拥有一个单独的解析器来处理更新产品负载中的`ingredients`属性，我们避免了在每个返回产品类型的解析器中执行此操作。缺点是属性解析器可能更难追踪和调试。如果`ingredients`负载有问题，你不会在`allProducts()`解析器中找到错误。你必须知道有一个解析器负责产品的成分，并查看该解析器。应用日志将帮助你在调试此类问题时指明方向，但请记住，这种设计对于不熟悉GraphQL的其他开发者来说可能并不完全明显。就像软件设计中的其他一切一样，确保代码的可重用性不会损害代码的可读性和易于维护性。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The Python ecosystem offers various frameworks for implementing GraphQL APIs.
    See GraphQL’s official website for the latest news on available frameworks: [https://graphql.org/code/](https://graphql.org/code/).'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python生态系统提供了各种框架来实现GraphQL API。有关可用框架的最新消息，请参阅GraphQL的官方网站：[https://graphql.org/code/](https://graphql.org/code/)。
- en: You can use the Ariadne framework to implement GraphQL APIs following a schema-first
    approach, which means we first design the API, and then we implement the server
    against the specification. This approach is beneficial since it allows the server
    and client development teams to work in parallel.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Ariadne框架按照schema-first方法实现GraphQL API，这意味着我们首先设计API，然后根据规范实现服务器。这种方法的好处在于它允许服务器和客户端开发团队并行工作。
- en: Ariadne can validate request and response payloads automatically using the specification,
    which means we don’t have to spend time implementing custom validation models.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ariadne可以使用规范自动验证请求和响应负载，这意味着我们不必花费时间实现自定义验证模型。
- en: For each query and mutation in the API specification, we need to implement a
    resolver. A resolver is a function that knows how to process the request for a
    given query or mutation. Resolvers are the code that allow us to expose the capabilities
    of a GraphQL API and therefore represent the backbone of the implementation.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于API规范中的每个查询和突变，我们需要实现一个解析器。解析器是一个知道如何处理给定查询或突变请求的函数。解析器是允许我们公开GraphQL API功能的代码，因此代表了实现的骨干。
- en: To register a resolver, we use one of Ariadne’s bindable classes, such as `QueryType`
    or `MutationType`. These classes expose decorators that allow us to bind a resolver
    function.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要注册一个解析器，我们使用Ariadne的可绑定类之一，例如`QueryType`或`MutationType`。这些类公开了装饰器，允许我们绑定解析器函数。
- en: GraphQL specifications can contain complex types, such as union types, which
    combine two or more object types. If our API specification contains a union type,
    we must implement a resolver that knows how to determine the type of an object;
    otherwise, the GraphQL server doesn’t know how to resolve it.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL规范可以包含复杂类型，例如联合类型，它们结合了两个或多个对象类型。如果我们的API规范包含联合类型，我们必须实现一个解析器，该解析器知道如何确定对象的类型；否则，GraphQL服务器不知道如何解析它。
- en: With GraphQL, we can define custom scalars. If the specification contains a
    custom scalar, we must implement resolvers that know how to serialize, parse,
    and validate the custom scalar type; otherwise, the GraphQL server doesn’t know
    how to handle them.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphQL，我们可以定义自定义标量。如果规范包含自定义标量，我们必须实现知道如何序列化、解析和验证自定义标量类型的解析器；否则，GraphQL服务器不知道如何处理它们。
