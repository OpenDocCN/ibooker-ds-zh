- en: Appendix B. Server-side React Router
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 B. 服务器端 React Router
- en: 'From an isomorphic app standpoint, one of the difficult parts of moving to
    React Router 4 is that the maintainers and community at large have yet to arrive
    at a consistent set of best practices for data prefetching patterns. You’ll see
    this sentiment over and over in the documentation; for instance, the React Router
    Config readme file states: “There are a lot of ways to do server rendering with
    data and pending navigation, and we haven’t settled on one.”'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从同构应用的角度来看，迁移到 React Router 4 的难点之一是维护者和整个社区尚未就数据预取模式达成一致的最佳实践。你会在文档中反复看到这种观点；例如，React
    Router Config 的 README 文件中提到：“有很多人实现带有数据和待处理导航的服务器端渲染的方法，我们还没有确定一个。”
- en: '[Chapter 7](kindle_split_019_split_000.xhtml#ch07) teaches you how to prefetch
    data on the server so that it’s available at render time. This appendix shows
    you how to do that with React Router 4\. The code for the example here can be
    found in the repo at [http://mng.bz/S3N0](http://mng.bz/S3N0), in branch chapter-7-complete-react-router-4
    (`git checkout chapter-7-complete-react-router-4`).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 7 章](kindle_split_019_split_000.xhtml#ch07) 教你如何在服务器上预取数据，以便在渲染时可用。本附录展示了如何使用
    React Router 4 来实现这一点。示例代码可以在 [http://mng.bz/S3N0](http://mng.bz/S3N0) 的仓库中找到，在分支
    chapter-7-complete-react-router-4 (`git checkout chapter-7-complete-react-router-4`)。'
- en: React Router 4 allows you to prefetch your data on the server before rendering.
    In the setup I suggest in [appendix A](kindle_split_027_split_000.xhtml#app01),
    you use `matchRoutes` from React Router Config to prefetch data in the browser.
    You do the same thing on the server! This allows you to have consistency on the
    server and the browser because you’re using the same approach via the utility
    functions provided in the library. This function is synchronous, unlike the asynchronous
    route match function in React Router 3\. (If you want consistency for your Node.js
    app, you could always wrap it so it returns asynchronously.) The following listing
    shows how to update the code to work with React Router 4.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 4 允许你在渲染之前在服务器上预取数据。在我建议的附录 A 中，你使用 React Router Config 的 `matchRoutes`
    来在浏览器中预取数据。你同样在服务器上做同样的事情！这允许你在服务器和浏览器上保持一致性，因为你通过库中提供的实用函数使用相同的方法。这个函数是同步的，与
    React Router 3 中的异步路由匹配函数不同。（如果你想要你的 Node.js 应用保持一致性，你可以总是将其包装以返回异步。）以下列表显示了如何更新代码以与
    React Router 4 一起工作。
- en: Listing B.1\. Fetching data on the server—middleware/renderView.jsx
  id: totrans-4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.1\. 服务器端数据获取——中间件/renderView.jsx
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Imports the dependencies**'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 导入依赖项'
- en: '***2* Imports the dependencies**'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 导入依赖项'
- en: '***3* Calls matchRoutes to find out which components are being loaded**'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 调用 matchRoutes 以找出正在加载哪些组件'
- en: '***4* Creates a context object used to determine whether there’s a route redirect**'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 创建一个上下文对象，用于确定是否存在路由重定向'
- en: '***5* Iterates through the matches so you can call the prefetchActions function.
    Most of this method is the same as in [chapter 7](kindle_split_019_split_000.xhtml#ch07).**'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 遍历匹配项以便你可以调用预取动作函数。这个方法的大部分内容与第 7 章相同。[第 7 章](kindle_split_019_split_000.xhtml#ch07)。'
- en: '***6* This is the major difference in the code. Because App is wrapped in two
    HOCs, you have to check two levels down to access the root component.**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 这是代码中的主要区别。因为 App 被两个高阶组件（HOCs）包裹，所以你必须向下检查两级才能访问根组件。'
- en: '***7* Uses the StaticRouter on the server instead of the BrowserRouter, as
    you don’t need a history. Passes in the location and context object.**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 在服务器上使用 StaticRouter 而不是 BrowserRouter，因为你不需要历史记录。传递位置和上下文对象。'
- en: '***8* Calls renderRoutes just as in main.jsx**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 正如 main.jsx 中的那样调用 renderRoutes'
- en: '***9* Checks the context to make sure there isn’t a redirect**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** 检查上下文以确保没有重定向'
