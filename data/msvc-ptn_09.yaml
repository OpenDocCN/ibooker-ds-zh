- en: 'Chapter 10\. Testing microservices: Part 2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章。测试微服务：第2部分
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Techniques for testing services in isolation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离测试服务的技巧
- en: Using consumer-driven contract testing to write tests that quickly yet reliably
    verify interservice communication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消费者驱动的契约测试来编写快速且可靠地验证服务间通信的测试
- en: When and how to do end-to-end testing of applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何进行应用程序的端到端测试
- en: This chapter builds on the previous chapter, which introduced testing concepts,
    including the test pyramid. The *test pyramid* describes the relative proportions
    of the different types of tests that you should write. The previous chapter described
    how to write unit tests, which are at the base of the testing pyramid. In this
    chapter, we continue our ascent of the testing pyramid.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于上一章，介绍了测试概念，包括测试金字塔。*测试金字塔*描述了你应该编写的不同类型测试的相对比例。上一章介绍了如何编写单元测试，这些测试位于测试金字塔的底部。在本章中，我们继续攀登测试金字塔。
- en: This chapter begins with how to write integration tests, which are the level
    above unit tests in the testing pyramid. *Integration tests* verify that a service
    can properly interact with infrastructure services, such as databases, and other
    application services. Next, I cover *component tests*, which are acceptance tests
    for services. A component test tests a service in isolation by using stubs for
    its dependencies. After that, I describe how to write end-to-end tests, which
    test a group of services or the entire application. End-to-end tests are at the
    top of the test pyramid and should, therefore, be used sparingly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍如何编写集成测试，这是测试金字塔中位于单元测试之上的层级。*集成测试*验证服务能否正确地与基础设施服务（如数据库）和其他应用服务进行交互。接下来，我将介绍*组件测试*，这是对服务的验收测试。组件测试通过使用存根来模拟其依赖项，从而在隔离状态下测试服务。之后，我将描述如何编写端到端测试，这些测试针对一组服务或整个应用程序。端到端测试位于测试金字塔的顶端，因此应谨慎使用。
- en: Let’s start by taking a look at how to write integration tests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何编写集成测试。
- en: 10.1\. Writing integration tests
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1。编写集成测试
- en: Services typically interact with other services. For example, `Order Service`,
    as [figure 10.1](#ch10fig01) shows, interacts with several services. Its REST
    API is consumed by `API Gateway`, and its domain events are consumed by services,
    including `Order History Service`. `Order Service` uses several other services.
    It persists `Orders` in MySQL. It also sends commands to and consumes replies
    from several other services, such as `Kitchen Service`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通常与其他服务进行交互。例如，如图10.1所示，`Order Service`与多个服务进行交互。它的REST API被`API Gateway`消费，它的领域事件被包括`Order
    History Service`在内的服务消费。`Order Service`还使用其他几个服务。它在MySQL中持久化`Orders`，同时也向其他几个服务发送命令并消费它们的回复，例如`Kitchen
    Service`。
- en: Figure 10.1\. Integration tests must verify that a service can communicate with
    its clients and dependencies. But rather than testing whole services, the strategy
    is to test the individual adapter classes that implement the communication.
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1。集成测试必须验证服务能否与其客户端和依赖项进行通信。但策略不是测试整个服务，而是测试实现通信的各个适配器类。
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/10fig01_alt.jpg)'
- en: In order to be confident that a service such as `Order Service` works as expected,
    we must write tests that verify that the service can properly interact with infrastructure
    services and other application services. One approach is to launch all the services
    and test them through their APIs. This, however, is what’s known as end-to-end
    testing, which is slow, brittle, and costly. As explained in [section 10.3](#ch10lev1sec3),
    there’s a role for end-to-end testing sometimes, but it’s at the top of the test
    pyramid, so you want to minimize the number of end-to-end tests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保像`Order Service`这样的服务按预期工作，我们必须编写测试来验证该服务能否正确地与基础设施服务和其他应用服务进行交互。一种方法是通过启动所有服务并通过它们的API进行测试。然而，这被称为端到端测试，它速度慢、脆弱且成本高。如[第10.3节](#ch10lev1sec3)所述，有时端到端测试有其作用，但它位于测试金字塔的顶端，因此你希望最小化端到端测试的数量。
- en: A much more effective strategy is to write what are known as integration tests.
    As [figure 10.2](#ch10fig02) shows, integration tests are the layer above unit
    tests in the testing pyramid. They verify that a service can properly interact
    with infrastructure services and other services. But unlike end-to-end tests,
    they don’t launch services. Instead, we use a couple of strategies that significantly
    simplify the tests without impacting their effectiveness.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更有效的策略是编写所谓的集成测试。如图10.2所示，集成测试在测试金字塔中位于单元测试之上。它们验证服务能否正确地与基础设施服务和其它服务交互。但与端到端测试不同，它们不会启动服务。相反，我们使用一些策略，这些策略显著简化了测试，同时不影响其有效性。
- en: Figure 10.2\. Integration tests are the layer above unit tests. They verify
    that a service can communicate with its dependencies, which includes infrastructure
    services, such as the database, and application services.
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2。集成测试位于单元测试之上。它们验证服务能否与其依赖项通信，这包括数据库等基础设施服务。
- en: '![](Images/10fig02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2](Images/10fig02.jpg)'
- en: The first strategy is to test each of the service’s adapters, along with, perhaps,
    the adapter’s supporting classes. For example, in [section 10.1.1](#ch10lev2sec1)
    you’ll see a JPA persistence test that verifies that `Orders` are persisted correctly.
    Rather than test persistence through `Order Service`’s API, it directly tests
    the `OrderRepository` class. Similarly, in [section 10.1.3](#ch10lev2sec3) you’ll
    see a test that verifies that `Order Service` publishes correctly structured domain
    events by testing the `OrderDomainEventPublisher` class. The benefit of testing
    only a small number of classes rather than the entire service is that the tests
    are significantly simpler and faster.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略是测试服务中的每个适配器，也许还包括适配器的支持类。例如，在[第10.1.1节](#ch10lev2sec1)中，你会看到一个JPA持久化测试，该测试验证`Orders`是否正确持久化。而不是通过`Order
    Service`的API进行持久化测试，它直接测试`OrderRepository`类。同样，在[第10.1.3节](#ch10lev2sec3)中，你会看到一个测试，通过测试`OrderDomainEventPublisher`类来验证`Order
    Service`是否正确发布结构化的域事件。仅测试少量类而不是整个服务的好处是，测试显著更简单、更快。
- en: The second strategy for simplifying integration tests that verify interactions
    between application services is to use contracts, discussed in [chapter 9](kindle_split_017.xhtml#ch09).
    A *contract* is a concrete example of an interaction between a pair of services.
    As [table 10.1](#ch10table01) shows, the structure of a contract depends on the
    type of interaction between the services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简化验证应用服务之间交互的集成测试的第二种策略是使用合约，这在[第9章](kindle_split_017.xhtml#ch09)中讨论过。一个 *合约*
    是一对服务之间交互的具体示例。如图10.1所示，合约的结构取决于服务之间的交互类型。
- en: Table 10.1\. The structure of a contract depends on the type of interaction
    between the services.
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1。合约的结构取决于服务之间的交互类型。
- en: '| Interaction style | Consumer | Provider | Contract |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 交互风格 | 消费者 | 提供者 | 合约 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| REST-based, request/response | API Gateway | Order Service | HTTP request
    and response |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 基于REST的请求/响应 | API网关 | 订单服务 | HTTP请求和响应 |'
- en: '| Publish/subscribe | Order History Service | Order Service | Domain event
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 发布/订阅 | 订单历史服务 | 订单服务 | 域事件 |'
- en: '| Asynchronous request/response | Order Service | Kitchen Service | Command
    message and reply message |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 异步请求/响应 | 订单服务 | 厨房服务 | 命令消息和回复消息 |'
- en: A contract consists of either one message, in the case of publish/subscribe
    style interactions, or two messages, in the case of request/response and asynchronous
    request/response style interactions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 合约在发布/订阅风格的交互中包含一个消息，在请求/响应和异步请求/响应风格的交互中包含两个消息。
- en: 'The contracts are used to test both the consumer and the provider, which ensures
    that they agree on the API. They’re used in slightly different ways depending
    on whether you’re testing the consumer or the provider:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 合约用于测试消费者和提供者，这确保了它们对API达成一致。根据你是测试消费者还是提供者，它们的使用方式略有不同：
- en: '***Consumer-side tests*—** These are tests for the consumer’s adapter. They
    use the contracts to configure stubs that simulate the provider, enabling you
    to write integration tests for a consumer that don’t require a running provider.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***消费者端测试**—** 这些是对消费者适配器的测试。它们使用合约来配置存根，模拟提供者，使你能够编写不需要运行提供者的消费者集成测试。'
- en: '***Provider-side tests*—** These are tests for the provider’s adapter. They
    use the contracts to test the adapters using mocks for the adapters’s dependencies.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Provider-side tests*—** 这些是对提供者适配器的测试。它们使用合约，通过模拟适配器依赖项来测试适配器。'
- en: Later in this section, I describe examples of these types of tests—but first
    let’s look at how to write persistence tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的后面部分，我将描述这些类型测试的示例——但首先让我们看看如何编写持久化测试。
- en: 10.1.1\. Persistence integration tests
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 持久化集成测试
- en: Services typically store data in a database. For instance, `Order Service` persists
    aggregates, such as `Order`, in MySQL using JPA. Similarly, `Order History Service`
    maintains a CQRS view in AWS DynamoDB. The unit tests we wrote earlier only test
    in-memory objects. In order to be confident that a service works correctly, we
    must write persistence integration tests, which verify that a service’s database
    access logic works as expected. In the case of `Order Service`, this means testing
    the JPA repositories, such as `OrderRepository`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通常将数据存储在数据库中。例如，`Order Service` 使用 JPA 在 MySQL 中持久化聚合，如 `Order`。同样，`Order
    History Service` 在 AWS DynamoDB 中维护一个 CQRS 视图。我们之前编写的单元测试仅测试内存中的对象。为了确保服务正确工作，我们必须编写持久化集成测试，这些测试验证服务的数据访问逻辑是否按预期工作。在
    `Order Service` 的情况下，这意味着测试 JPA 存储库，如 `OrderRepository`。
- en: 'Each phase of a persistence integration test behaves as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化集成测试的每个阶段的行为如下：
- en: '***Setup*—** Set up the database by creating the database schema and initializing
    it to a known state. It might also begin a database transaction.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Setup*—** 通过创建数据库模式并将其初始化到已知状态来设置数据库。它也可能开始一个数据库事务。'
- en: '***Execute*—** Perform a database operation.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Execute*—** 执行数据库操作。'
- en: '***Verify*—** Make assertions about the state of the database and objects retrieved
    from the database.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Verify*—** 对数据库状态和从数据库检索的对象的状态进行断言。'
- en: '***Teardown*—** An optional phase that might undo the changes made to the database
    by, for example, rolling back the transaction that was started by the setup phase.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Teardown*—** 一个可选阶段，可能撤销由设置阶段启动的事务对数据库所做的更改。'
- en: '[Listing 10.1](#ch10ex01) shows a persistent integration test for the `Order`
    aggregate and `OrderRepository`. Apart from relying on JPA to create the database
    schema, the persistence integration tests don’t make any assumption about the
    state of the database. Consequently, tests don’t need to roll back the changes
    they make to the database, which avoids problems with the ORM caching data changes
    in memory.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.1](#ch10ex01) 展示了 `Order` 聚合和 `OrderRepository` 的持久化集成测试。除了依赖于 JPA 创建数据库模式外，持久化集成测试对数据库的状态没有任何假设。因此，测试不需要回滚它们对数据库所做的更改，这避免了
    ORM 在内存中缓存数据更改的问题。'
- en: Listing 10.1\. An integration test that verifies that an `Order` can be persisted
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 一个验证 `Order` 可以被持久化的集成测试
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `shouldSaveAndLoadOrder()` test method executes two transactions. The first
    saves a newly created `Order` in the database. The second transaction loads the
    `Order` and verifies that its fields are properly initialized.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldSaveAndLoadOrder()` 测试方法执行两个事务。第一个事务在数据库中保存一个新创建的 `Order`。第二个事务加载 `Order`
    并验证其字段是否正确初始化。'
- en: One problem you need to solve is how to provision the database that’s used in
    persistence integration tests. An effective solution to run an instance of the
    database during testing is to use Docker. [Section 10.2](#ch10lev1sec2) describes
    how to use the Docker Compose Gradle plugin to automatically run services during
    component testing. You can use a similar approach to run MySQL, for example, during
    persistence integration testing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要解决的问题是如何为持久化集成测试提供数据库。在测试期间运行数据库实例的有效解决方案是使用 Docker。[第 10.2 节](#ch10lev1sec2)
    描述了如何使用 Docker Compose Gradle 插件在组件测试期间自动运行服务。你可以使用类似的方法在持久化集成测试期间运行 MySQL，例如。
- en: The database is only one of the external services a service interacts with.
    Let’s now look at how to write integration tests for interservice communication
    between application services, starting with REST.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库只是服务交互的外部服务之一。现在让我们看看如何编写应用服务之间交互的集成测试，从 REST 开始。
- en: 10.1.2\. Integration testing REST-based request/response style interactions
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 基于REST的请求/响应风格交互的集成测试
- en: REST is a widely used interservice communication mechanism. The REST client
    and REST service must agree on the REST API, which includes the REST endpoints
    and the structure of the request and response bodies. The client must send an
    HTTP request to the correct endpoint, and the service must send back the response
    that the client expects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一种广泛使用的服务间通信机制。REST 客户端和 REST 服务必须就 REST API 达成一致，这包括 REST 端点和请求/响应体的结构。客户端必须向正确的端点发送
    HTTP 请求，而服务必须发送客户端期望的响应。
- en: For example, [chapter 8](kindle_split_016.xhtml#ch08) describes how the FTGO
    application’s `API Gateway` makes REST API calls to numerous services, including
    `ConsumerService`, `Order Service`, and `Delivery Service`. The `OrderService`’s
    `GET /orders/{orderId}` endpoint is one of the endpoints invoked by the `API Gateway`.
    In order to be confident that `API Gateway` and `Order Service` can communicate
    without using an end-to-end test, we need to write integration tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[第 8 章](kindle_split_016.xhtml#ch08) 描述了 FTGO 应用程序的 `API Gateway` 如何向包括 `ConsumerService`、`Order
    Service` 和 `Delivery Service` 在内的多个服务发出 REST API 调用。`OrderService` 的 `GET /orders/{orderId}`
    端点是 `API Gateway` 调用的端点之一。为了确保 `API Gateway` 和 `Order Service` 可以在不使用端到端测试的情况下通信，我们需要编写集成测试。
- en: As stated in the preceding chapter, a good integration testing strategy is to
    use consumer-driven contract tests. The interaction between `API Gateway` and
    `GET /orders/{orderId}` can be described using a set of HTTP-based contracts.
    Each contract consists of an HTTP request and an HTTP reply. The contracts are
    used to test `API Gateway` and `Order Service`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，一个好的集成测试策略是使用消费者驱动的合约测试。`API Gateway` 和 `GET /orders/{orderId}` 之间的交互可以使用一组基于
    HTTP 的合约来描述。每个合约由一个 HTTP 请求和一个 HTTP 响应组成。合约用于测试 `API Gateway` 和 `Order Service`。
- en: '[Figure 10.3](#ch10fig03) shows how to use Spring Cloud Contract to test REST-based
    interactions. The consumer-side `API Gateway` integration tests use the contracts
    to configure an HTTP stub server that simulates the behavior of `Order Service`.
    A contract’s request specifies an HTTP request from the API gateway, and the contract’s
    response specifies the response that the stub sends back to the API gateway. Spring
    Cloud Contract uses the contracts to code-generate the provider-side `Order Service`
    integration tests, which test the controllers using Spring Mock MVC or Rest Assured
    Mock MVC. The contract’s request specifies the HTTP request to make to the controller,
    and the contract’s response specifies the controller’s expected response.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.3](#ch10fig03) 展示了如何使用 Spring Cloud Contract 测试基于 REST 的交互。消费者端的 `API
    Gateway` 集成测试使用合约配置一个模拟 `Order Service` 行为的 HTTP 模拟服务器。合约的请求指定了来自 API 网关的 HTTP
    请求，合约的响应指定了模拟发送回 API 网关的响应。Spring Cloud Contract 使用合约生成提供者端 `Order Service` 集成测试，这些测试使用
    Spring Mock MVC 或 Rest Assured Mock MVC 测试控制器。合约的请求指定了要发送到控制器的 HTTP 请求，合约的响应指定了控制器期望的响应。'
- en: Figure 10.3\. The contracts are used to verify that the adapter classes on both
    sides of the REST-based communication between `API Gateway` and `Order Service`
    conform to the contract. The consumer-side tests verify that `OrderServiceProxy`
    invokes `Order Service` correctly. The provider-side tests verify that `OrderController`
    implements the REST API endpoints correctly.
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3 显示了合约用于验证 `API Gateway` 和 `Order Service` 之间基于 REST 的通信两端的适配器类是否符合合约。消费者端测试验证
    `OrderServiceProxy` 正确调用 `Order Service`。提供者端测试验证 `OrderController` 正确实现了 REST
    API 端点。
- en: '![](Images/10fig03_alt.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10.3](Images/10fig03_alt.jpg)'
- en: The consumer-side `OrderServiceProxyTest` invokes `OrderServiceProxy`, which
    has been configured to make HTTP requests to WireMock. WireMock is a tool for
    efficiently mocking HTTP servers—in this test it simulates `Order Service.` Spring
    Cloud Contract manages WireMock and configures it to respond to the HTTP requests
    defined by the contracts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者端的 `OrderServiceProxyTest` 调用 `OrderServiceProxy`，该代理已被配置为向 WireMock 发送 HTTP
    请求。WireMock 是一个用于高效模拟 HTTP 服务器的工具——在这个测试中，它模拟 `Order Service`。Spring Cloud Contract
    管理WireMock，并配置它响应由合约定义的 HTTP 请求。
- en: On the provider side, Spring Cloud Contract generates a test class called `HttpTest`,
    which uses Rest Assured Mock MVC to test `Order Service`’s controllers. Test classes
    such as `HttpTest` must extend a handwritten base class. In this example, the
    base class `BaseHttp` instantiates `OrderController` injected with mock dependencies
    and calls `RestAssuredMockMvc.standaloneSetup()` to configure Spring MVC.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供者端，Spring Cloud Contract 生成一个名为 `HttpTest` 的测试类，该类使用 Rest Assured Mock MVC
    来测试 `Order Service` 的控制器。像 `HttpTest` 这样的测试类必须扩展一个手写的基类。在这个例子中，基类 `BaseHttp` 实例化注入了模拟依赖的
    `OrderController`，并调用 `RestAssuredMockMvc.standaloneSetup()` 来配置 Spring MVC。
- en: Let’s take a closer look at how this works, starting with an example contract.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看它是如何工作的，从一个示例合同开始。
- en: An example contract for a REST API
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个 REST API 的示例合同
- en: A REST contract, such as the one shown in [listing 10.2](#ch10ex02), specifies
    an HTTP request, which is sent by the REST client, and the HTTP response, which
    the client expects to get back from the REST server. A contract’s request specifies
    the HTTP method, the path, and optional headers. A contract’s response specifies
    the HTTP status code, optional headers, and, when appropriate, the expected body.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 REST 合同，例如 [列表 10.2](#ch10ex02) 中所示，指定了一个 HTTP 请求，这是由 REST 客户端发送的，以及客户端期望从
    REST 服务器接收的 HTTP 响应。合同请求指定了 HTTP 方法、路径和可选的头部。合同响应指定了 HTTP 状态码、可选的头部，以及当适用时，预期的体。
- en: Listing 10.2\. A contract that describes an HTTP-based request/response style
    interaction
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 描述基于 HTTP 请求/响应样式交互的合同
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This particular contract describes a successful attempt by `API Gateway` to
    retrieve an `Order` from `Order Service`. Let’s now look at how to use this contract
    to write integration tests, starting with the tests for `Order Service`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的合同描述了 `API Gateway` 成功从 `Order Service` 中检索 `Order` 的尝试。现在让我们看看如何使用这个合同来编写集成测试，从
    `Order Service` 的测试开始。
- en: Consumer-driven contract integration tests for Order Service
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 订单服务的消费者驱动合同集成测试
- en: The consumer-driven contract integration tests for `Order Service` verify that
    its API meets its clients’ expectations. [Listing 10.3](#ch10ex03) shows `HttpBase`,
    which is the base class for the test class code-generated by Spring Cloud Contract.
    It’s responsible for the setup phase of the test. It creates the controllers injected
    with mock dependencies and configures those mocks to return values that cause
    the controller to generate the expected response.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 订单服务的消费者驱动合同集成测试验证其 API 是否满足客户端的期望。[列表 10.3](#ch10ex03) 显示了 `HttpBase`，这是由 Spring
    Cloud Contract 代码生成的测试类的基类。它负责测试的设置阶段。它创建了注入了模拟依赖的控制器，并配置这些模拟以返回导致控制器生成预期响应的值。
- en: Listing 10.3\. The abstract base class for the tests code-generated by Spring
    Cloud Contract
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 由 Spring Cloud Contract 代码生成的测试的抽象基类
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Create OrderRepository injected with mocks.**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建注入了模拟的 OrderRepository。**'
- en: '***2* Configure OrderResponse to return an Order when findById() is invoked
    with the orderId specified in the contract.**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置 OrderResponse，当使用合同中指定的 orderId 调用 findById() 时返回一个 Order。**'
- en: '***3* Configure Spring MVC with OrderController.**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 OrderController 配置 Spring MVC。**'
- en: The argument `1223232L` that’s passed to the mock `OrderRepository`’s `findById()`
    method matches the `orderId` specified in the contract shown in [listing 10.3](#ch10ex03).
    This test verifies that `Order Service` has a `GET /orders/{orderId}` endpoint
    that matches its client’s expectations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给模拟 `OrderRepository` 的 `findById()` 方法的参数 `1223232L` 与 [列表 10.3](#ch10ex03)
    中显示的合同中指定的 `orderId` 匹配。这个测试验证了 `Order Service` 有一个 `GET /orders/{orderId}` 端点，该端点符合其客户端的期望。
- en: Let’s take a look at the corresponding client test.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看相应的客户端测试。
- en: Consumer-side integration test for API Gateway’s OrderServiceProxy
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API Gateway 的 OrderServiceProxy 的消费者端集成测试
- en: '`API Gateway`’s `OrderServiceProxy` invokes the `GET /orders/{orderId}` endpoint.
    [Listing 10.4](#ch10ex04) shows the `OrderServiceProxyIntegrationTest` test class,
    which verifies that it conforms to the contracts. This class is annotated with
    `@AutoConfigureStubRunner`, provided by Spring Cloud Contract. It tells Spring
    Cloud Contract to run the WireMock server on a random port and configure it using
    the specified contracts. `OrderServiceProxyIntegrationTest` configures `OrderServiceProxy`
    to make requests to the WireMock port.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`API Gateway` 的 `OrderServiceProxy` 调用 `GET /orders/{orderId}` 端点。[列表 10.4](#ch10ex04)
    展示了 `OrderServiceProxyIntegrationTest` 测试类，它验证了其是否符合合约。这个类被 `@AutoConfigureStubRunner`
    注解，由 Spring Cloud Contract 提供。它告诉 Spring Cloud Contract 在随机端口上运行 WireMock 服务器，并使用指定的合约进行配置。`OrderServiceProxyIntegrationTest`
    配置 `OrderServiceProxy` 向 WireMock 端口发送请求。'
- en: Listing 10.4\. A consumer-side integration test for `API Gateway`’s `OrderServiceProxy`
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. `API Gateway` 的 `OrderServiceProxy` 的消费者端集成测试
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Tell Spring Cloud Contract to configure WireMock with Order Service’s
    contracts.**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 告诉 Spring Cloud Contract 配置 WireMock 使用订单服务的合约。**'
- en: '***2* Obtain the randomly assigned port that WireMock is running on.**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取 WireMock 运行的随机分配端口。**'
- en: '***3* Create an OrderServiceProxy configured to make requests to WireMock.**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个配置为向 WireMock 发送请求的 OrderServiceProxy。**'
- en: Each test method invokes `OrderServiceProxy` and verifies that either it returns
    the correct values or throws the expected exception. The `shouldVerifyExistingCustomer()`
    test method verifies that `findOrderById()` returns values equal to those specified
    in the contract’s response. The `shouldFailToFindMissingOrder()` attempts to retrieve
    a nonexistent `Order` and verifies that `OrderServiceProxy` throws an `OrderNotFoundException`.
    Testing both the REST client and the REST service using the same contracts ensures
    that they agree on the API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试方法都会调用 `OrderServiceProxy` 并验证它返回正确的值或抛出预期的异常。`shouldVerifyExistingCustomer()`
    测试方法验证 `findOrderById()` 返回的值等于合约响应中指定的值。`shouldFailToFindMissingOrder()` 尝试检索一个不存在的
    `Order`，并验证 `OrderServiceProxy` 抛出 `OrderNotFoundException`。使用相同的合约测试 REST 客户端和
    REST 服务确保它们在 API 上达成一致。
- en: Let’s now look at how to do the same kind of testing for services that interact
    using messaging.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看如何对使用消息交互的服务进行相同类型的测试。
- en: 10.1.3\. Integration testing publish/subscribe-style interactions
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3\. 集成测试发布/订阅式交互
- en: Services often publish domain events that are consumed by one or more other
    services. Integration testing must verify that the publisher and its consumers
    agree on the message channel and the structure of the domain events. `Order Service`,
    for example, publishes `Order*` events whenever it creates or updates an `Order`
    aggregate. `Order History Service` is one of the consumers of those events. We
    must, therefore, write tests that verify that these services can interact.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通常会发布领域事件，这些事件被一个或多个其他服务消费。集成测试必须验证发布者和其消费者在消息通道和领域事件结构上达成一致。例如，`Order Service`
    在创建或更新 `Order` 聚合时，会发布 `Order*` 事件。`Order History Service` 是这些事件的消费者之一。因此，我们必须编写测试来验证这些服务可以交互。
- en: '[Figure 10.4](#ch10fig04) shows the approach to integration testing publish/subscribe
    interactions. Its quite similar to the approach used for testing REST interactions.
    As before, the interactions are defined by a set of contracts. What’s different
    is that each contract specifies a domain event.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.4](#ch10fig04) 展示了集成测试发布/订阅交互的方法。它与测试 REST 交互的方法非常相似。与之前一样，交互由一组合约定义。不同的是，每个合约指定一个领域事件。'
- en: Figure 10.4\. The contracts are used to test both sides of the publish/subscribe
    interaction. The provider-side tests verify that `OrderDomainEventPublisher` publishes
    events that confirm to the contract. The consumer-side tests verify that `OrderHistoryEventHandlers`
    consume the example events from the contract.
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.4\. 合约被用来测试发布/订阅交互的两端。提供方测试验证 `OrderDomainEventPublisher` 发布符合合约的事件。消费者端测试验证
    `OrderHistoryEventHandlers` 消费合约中的示例事件。
- en: '![](Images/10fig04_alt.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig04_alt.jpg)'
- en: Each consumer-side test publishes the event specified by the contract and verifies
    that `OrderHistoryEventHandlers` invokes its mocked dependencies correctly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消费者端测试都会发布由合约指定的事件，并验证 `OrderHistoryEventHandlers` 是否正确调用其模拟的依赖项。
- en: On the provider side, Spring Cloud Contract code-generates test classes that
    extend `MessagingBase`, which is a hand-written abstract superclass. Each test
    method invokes a hook method defined by `MessagingBase`, which is expected to
    trigger the publication of an event by the service. In this example, each hook
    method invokes `OrderDomainEventPublisher`, which is responsible for publishing
    `Order` aggregate events. The test method then verifies that `OrderDomainEventPublisher`
    published the expected event. Let’s look at the details of how these tests work,
    starting with the contract.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供者端，Spring Cloud Contract代码生成扩展`MessagingBase`的测试类，`MessagingBase`是一个手写的抽象超类。每个测试方法调用由`MessagingBase`定义的钩子方法，预期这将触发服务发布事件。在这个例子中，每个钩子方法调用`OrderDomainEventPublisher`，它负责发布`Order`聚合事件。然后测试方法验证`OrderDomainEventPublisher`发布了预期的事件。让我们看看这些测试如何工作的细节，从合约开始。
- en: The contract for publishing an OrderCreated event
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 发布`OrderCreated`事件的合约
- en: '[Listing 10.5](#ch10ex05) shows the contract for an `OrderCreated` event. It
    specifies the event’s channel, along with the expected body and message headers.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.5](#ch10ex05)显示了`OrderCreated`事件的合约。它指定了事件通道、预期的正文和消息头。'
- en: Listing 10.5\. A contract for a publish/subscribe interaction style
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5\. 一个发布/订阅交互风格的合约
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Used by the consumer test to trigger the event to be published**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由消费者测试用于触发要发布的事件**'
- en: '***2* Invoked by the code-generated provider test**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 由代码生成的提供者测试调用**'
- en: '***3* An OrderCreated domain event**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一个`OrderCreated`域事件**'
- en: 'The contract also has two other important elements:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 合约还有两个其他重要元素：
- en: '`label`—is used by a consumer test to trigger publication of the event by Spring
    Contact'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`——由消费者测试使用，通过Spring Contact触发事件的发布'
- en: '`triggeredBy`—the name of the superclass method invoked by the generated test
    method to trigger the publishing of the event'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`triggeredBy`——由生成的测试方法调用的超类方法名称，用于触发事件的发布'
- en: Let’s look at how the contract is used, starting with the provider-side test
    for `OrderService`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看合约是如何使用的，从`OrderService`的提供者端测试开始。
- en: Consumer-driven contract tests for Order Service
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 订单服务的消费者驱动合约测试
- en: The provider-side test for `Order Service` is another consumer-driven contract
    integration test. It verifies that `OrderDomainEventPublisher`, which is responsible
    for publishing `Order` aggregate domain events, publishes events that match its
    clients’ expectations. [Listing 10.6](#ch10ex06) shows `MessagingBase`, which
    is the base class for the test classes code-generated by Spring Cloud Contract.
    It’s responsible for configuring the `OrderDomainEventPublisher` class to use
    in-memory messaging stubs. It also defines the methods, such as `orderCreated()`,
    which are invoked by the generated tests to trigger the publishing of the event.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order Service`的提供者端测试是另一个消费者驱动的合约集成测试。它验证负责发布`Order`聚合域事件的`OrderDomainEventPublisher`是否发布了符合其客户端期望的事件。[列表10.6](#ch10ex06)显示了`MessagingBase`，这是由Spring
    Cloud Contract代码生成的测试类的基类。它负责配置`OrderDomainEventPublisher`类以使用内存中的消息存根。它还定义了`orderCreated()`等方法，这些方法由生成的测试调用以触发事件的发布。'
- en: Listing 10.6\. The abstract base class for the Spring Cloud Contract provider-side
    tests
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. Spring Cloud Contract提供者端测试的抽象基类
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* orderCreated() is invoked by a code-generated test subclass to publish
    the event.**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `orderCreated()`由代码生成的测试子类调用以发布事件。**'
- en: This test class configures `OrderDomainEventPublisher` with in-memory messaging
    stubs. `orderCreated()` is invoked by the test method generated from the contract
    shown earlier in [listing 10.5](#ch10ex05). It invokes `OrderDomainEventPublisher`
    to publish an `OrderCreated` event. The test method attempts to receive this event
    and then verifies that it matches the event specified in the contract. Let’s now
    look at the corresponding consumer-side tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试类使用内存中的消息存根配置了`OrderDomainEventPublisher`。`orderCreated()`方法由从前面[列表10.5](#ch10ex05)中显示的合约生成的测试方法调用。它调用`OrderDomainEventPublisher`来发布一个`OrderCreated`事件。测试方法尝试接收此事件，然后验证它是否与合约中指定的事件匹配。现在让我们看看相应的消费者端测试。
- en: Consumer-side contract test for the Order History Service
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 订单历史服务的消费者端合约测试
- en: '`Order History Service` consumes events published by `Order Service`. As I
    described in [chapter 7](kindle_split_015.xhtml#ch07), the adapter class that
    handles these events is the `OrderHistoryEventHandlers` class. Its event handlers
    invoke `OrderHistoryDao` to update the CQRS view. [Listing 10.7](#ch10ex07) shows
    the consumer-side integration test. It creates an `OrderHistoryEventHandlers`
    injected with a mock `OrderHistoryDao`. Each test method first invokes Spring
    Cloud to publish the event defined in the contract and then verifies that `OrderHistoryEventHandlers`
    invokes `OrderHistoryDao` correctly.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order History Service` 消费由 `Order Service` 发布的事件。正如我在[第7章](kindle_split_015.xhtml#ch07)中描述的，处理这些事件的适配器类是
    `OrderHistoryEventHandlers` 类。它的事件处理器调用 `OrderHistoryDao` 来更新CQRS视图。[列表10.7](#ch10ex07)
    展示了消费者端的集成测试。它创建了一个注入了模拟 `OrderHistoryDao` 的 `OrderHistoryEventHandlers`。每个测试方法首先调用Spring
    Cloud发布合约中定义的事件，然后验证 `OrderHistoryEventHandlers` 是否正确地调用了 `OrderHistoryDao`。'
- en: Listing 10.7\. The consumer-side integration test for the `OrderHistoryEventHandlers`
    class
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. `OrderHistoryEventHandlers` 类的消费者端集成测试
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Create a mock OrderHistoryDao to inject into OrderHistoryEventHandlers.**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个模拟的 `OrderHistoryDao` 以注入到 `OrderHistoryEventHandlers` 中。**'
- en: '***2* Trigger the orderCreatedEvent stub, which emits an OrderCreated event.**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 触发 `orderCreatedEvent` 模拟器，它发出 `OrderCreated` 事件。**'
- en: '***3* Verify that OrderHistoryEventHandlers invoked orderHistoryDao.addOrder().**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 验证 `OrderHistoryEventHandlers` 是否调用了 `orderHistoryDao.addOrder()`。**'
- en: The `shouldHandleOrderCreatedEvent()` test method tells Spring Cloud Contract
    to publish the `OrderCreated` event. It then verifies that `OrderHistoryEventHandlers`
    invoked `orderHistoryDao.addOrder()`. Testing both the domain event’s publisher
    and consumer using the same contracts ensures that they agree on the API. Let’s
    now look at how to do integration test services that interact using asynchronous
    request/response.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldHandleOrderCreatedEvent()` 测试方法告诉Spring Cloud Contract发布 `OrderCreated`
    事件。然后它验证 `OrderHistoryEventHandlers` 是否调用了 `orderHistoryDao.addOrder()`。使用相同的合约测试领域事件的发布者和消费者确保他们就API达成一致。现在让我们看看如何进行使用异步请求/响应交互的集成测试服务。'
- en: 10.1.4\. Integration contract tests for asynchronous request/response interactions
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.4\. 异步请求/响应交互的集成合约测试
- en: Publish/subscribe isn’t the only kind of messaging-based interaction style.
    Services also interact using asynchronous request/response. For example, in [chapter
    4](kindle_split_012.xhtml#ch04) we saw that `Order Service` implements sagas that
    send command messages to various services, such as `Kitchen Service`, and processes
    the reply messages.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅不是基于消息的唯一交互风格。服务还可以使用异步请求/响应进行交互。例如，在第4章中我们看到了 `Order Service` 实现了向各种服务（如
    `Kitchen Service`）发送命令消息的sagas，并处理回复消息。
- en: The two parties in an asynchronous request/response interaction are the requestor,
    which is the service that sends the command, and the replier, which is the service
    that processes the command and sends back a reply. They must agree on the name
    of command message channel and the structure of the command and reply messages.
    Let’s look at how to write integration tests for asynchronous request/response
    interactions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 异步请求/响应交互的双方是请求者，即发送命令的服务，和回复者，即处理命令并发送回复的服务。他们必须就命令消息通道的名称和命令及回复消息的结构达成一致。让我们看看如何编写异步请求/响应交互的集成测试。
- en: '[Figure 10.5](#ch10fig05) shows how to test the interaction between `Order
    Service` and `Kitchen Service`. The approach to integration testing asynchronous
    request/response interactions is quite similar to the approach used for testing
    REST interactions. The interactions between the services are defined by a set
    of contracts. What’s different is that a contract specifies an input message and
    an output message instead of an HTTP request and reply.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.5](#ch10fig05) 展示了如何测试 `Order Service` 和 `Kitchen Service` 之间的交互。异步请求/响应交互的集成测试方法与用于测试REST交互的方法相当相似。服务之间的交互由一系列合约定义。不同之处在于，合约指定了一个输入消息和一个输出消息，而不是HTTP请求和回复。'
- en: Figure 10.5\. The contracts are used to test the adapter classes that implement
    each side of the asynchronous request/response interaction. The provider-side
    tests verify that `KitchenServiceCommandHandler` handles commands and sends back
    replies. The consumer-side tests verify `KitchenServiceProxy` sends commands that
    conform to the contract, and that it handles the example replies from the contract.
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.5\. 这些合同用于测试实现异步请求/响应交互每一方的适配器类。提供端测试验证 `KitchenServiceCommandHandler`
    处理命令并发送回复。消费端测试验证 `KitchenServiceProxy` 发送符合合同的命令，并处理合同中的示例回复。
- en: '![](Images/10fig05_alt.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig05_alt.jpg)'
- en: The consumer-side test verifies that the command message proxy class sends correctly
    structured command messages and correctly processes reply messages. In this example,
    `KitchenServiceProxyTest` tests `KitchenServiceProxy`. It uses Spring Cloud Contract
    to configure messaging stubs that verify that the command message matches a contract’s
    input message and replies with the corresponding output message.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 消费端测试验证命令消息代理类发送正确结构的命令消息，并正确处理回复消息。在这个例子中，`KitchenServiceProxyTest` 测试 `KitchenServiceProxy`。它使用
    Spring Cloud Contract 配置消息存根，以验证命令消息与合同的输入消息匹配，并回复相应的输出消息。
- en: The provider-side tests are code-generated by Spring Cloud Contract. Each test
    method corresponds to a contract. It sends the contract’s input message as a command
    message and verifies that the reply message matches the contract’s output message.
    Let’s look at the details, starting with the contract.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 提供端测试由 Spring Cloud Contract 代码生成。每个测试方法对应一个合同。它发送合同输入消息作为命令消息，并验证回复消息是否与合同的输出消息匹配。让我们看看细节，从合同开始。
- en: Example asynchronous request/response contract
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异步请求/响应合同示例
- en: '[Listing 10.8](#ch10ex08) shows the contract for one interaction. It consists
    of an input message and an output message. Both messages specify a message channel,
    message body, and message headers. The naming convention is from the provider’s
    perspective. The input message’s `messageFrom` element specifies the channel that
    the message is read from. Similarly, the output message’s `sentTo` element specifies
    the channel that the reply should be sent to.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.8](#ch10ex08) 展示了一个交互的合同。它包括一个输入消息和一个输出消息。两个消息都指定了消息通道、消息体和消息头。命名规范是从提供者的角度出发的。输入消息的
    `messageFrom` 元素指定了消息读取的通道。同样，输出消息的 `sentTo` 元素指定了回复应该发送到的通道。'
- en: Listing 10.8\. Contract describing how `Order Service` asynchronously invokes
    `Kitchen Service`
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 描述 `Order Service` 如何异步调用 `Kitchen Service` 的合同
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* The command message sent by Order Service to the kitchenService channel**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 订单服务发送到 kitchenService 通道的命令消息**'
- en: '***2* The reply message sent by Kitchen Service**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Kitchen Service 发送的回复消息**'
- en: In this example contract, the input message is a `CreateTicket` command that’s
    sent to the `kitchenService` channel. The output message is a successful reply
    that’s sent to the `CreateOrderSaga`’s reply channel. Let’s look at how to use
    this contract in tests, starting with the consumer-side tests for `Order Service`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个合同示例中，输入消息是发送到 `kitchenService` 通道的 `CreateTicket` 命令。输出消息是发送到 `CreateOrderSaga`
    回复通道的成功回复。让我们看看如何在测试中使用这个合同，从 `Order Service` 的消费端测试开始。
- en: Consumer-side contract integration test for an asynchronous reque- est/response
    interaction
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 消费端异步请求/响应交互的合同集成测试
- en: The strategy for writing a consumer-side integration test for an asynchronous
    request/response interaction is similar to testing a REST client. The test invokes
    the service’s messaging proxy and verifies two aspects of its behavior. First,
    it verifies that the messaging proxy sends a command message that conforms to
    the contract. Second, it verifies that the proxy properly handles the reply message.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 编写消费端异步请求/响应交互集成测试的策略与测试 REST 客户端相似。测试调用服务的信息代理，并验证其行为的两个方面。首先，它验证信息代理发送符合合同的命令消息。其次，它验证代理正确处理回复消息。
- en: '[Listing 10.9](#ch10ex09) shows the consumer-side integration test for `KitchenServiceProxy`,
    which is the messaging proxy used by `Order Service` to invoke `Kitchen Service`.
    Each test sends a command message using `KitchenServiceProxy` and verifies that
    it returns the expected result. It uses Spring Cloud Contract to configure messaging
    stubs for `Kitchen Service` that find the contract whose input message matches
    the command message and sends its output message as the reply. The tests use in-memory
    messaging for simplicity and speed.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.9](#ch10ex09) 展示了 `KitchenServiceProxy` 的消费者端集成测试，`Order Service` 使用
    `KitchenServiceProxy` 调用 `Kitchen Service`。每个测试使用 `KitchenServiceProxy` 发送一个命令消息，并验证它返回预期的结果。它使用
    Spring Cloud Contract 配置 `Kitchen Service` 的消息模拟，以找到与命令消息匹配的合约并以其输出消息作为回复。测试使用内存消息以提高简单性和速度。'
- en: Listing 10.9\. The consumer-side contract integration test for `Order Service`
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. `Order Service` 的消费者端合约集成测试
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Configure the stub Kitchen Service to respond to messages.**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 配置模拟 Kitchen Service 以响应消息。**'
- en: '***2* Send the command and wait for a reply.**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 发送命令并等待回复。**'
- en: '***3* Verify the reply.**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 验证回复。**'
- en: The `shouldSuccessfullyCreateTicket()` test method sends a `CreateTicket` command
    message and verifies that the reply contains the expected data. It uses `SagaMessagingTestHelper`,
    which is a test helper class that synchronously sends and receives messages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldSuccessfullyCreateTicket()` 测试方法发送一个 `CreateTicket` 命令消息，并验证回复包含预期的数据。它使用
    `SagaMessagingTestHelper`，这是一个同步发送和接收消息的测试辅助类。'
- en: Let’s now look at how to write provider-side integration tests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何编写提供者端集成测试。
- en: Writing provider-side, consumer-driven contract tests for asynchr- ronous request/response
    interactions
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写异步请求/响应交互的提供者端、消费者驱动的合约测试
- en: A provider-side integration test must verify that the provider handles a command
    message by sending the correct reply. Spring Cloud Contract generates test classes
    that have a test method for each contract. Each test method sends the contract’s
    input message and verifies that the reply matches the contract’s output message.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者端集成测试必须验证提供者通过发送正确的回复来处理命令消息。Spring Cloud Contract 生成测试类，每个合约都有一个测试方法。每个测试方法发送合约的输入消息，并验证回复与合约的输出消息匹配。
- en: The provider-side integration tests for `Kitchen Service` test `KitchenServiceCommandHandler`.
    The `KitchenServiceCommandHandler` class handles a message by invoking `KitchenService`.
    The following listing shows the `AbstractKitchenServiceConsumerContractTest` class,
    which is the base class for the Spring Cloud Contract-generated tests. It creates
    a `KitchenServiceCommandHandler` injected with a mock `KitchenService`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kitchen Service` 的提供者端集成测试测试 `KitchenServiceCommandHandler`。`KitchenServiceCommandHandler`
    类通过调用 `KitchenService` 来处理消息。以下列表显示了 `AbstractKitchenServiceConsumerContractTest`
    类，它是 Spring Cloud Contract 生成的测试的基础类。它创建了一个注入模拟 `KitchenService` 的 `KitchenServiceCommandHandler`。'
- en: Listing 10.10\. Superclass of provider-side, consumer-driven contract tests
    for `Kitchen Service`
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. `Kitchen Service` 提供者端、消费者驱动的合约测试的超级类
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Overrides the definition of the kitchenService @Bean with a mock**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用模拟覆盖 kitchenService @Bean 的定义**'
- en: '***2* Configures the mock to return the values that match a contract’s output
    message**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置模拟以返回与合约输出消息匹配的值**'
- en: '`KitchenServiceCommandHandler` invokes `KitchenService` with arguments that
    are derived from a contract’s input message and creates a reply message that’s
    derived from the return value. The test class’s `setup()` method configures the
    mock `KitchenService` to return the values that match the contract’s output message'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`KitchenServiceCommandHandler` 使用从合约输入消息派生的参数调用 `KitchenService`，并创建一个从返回值派生的回复消息。测试类的
    `setup()` 方法配置模拟的 `KitchenService` 以返回与合约输出消息匹配的值'
- en: Integration tests and unit tests verify the behavior of individual parts of
    a service. The integration tests verify that services can communicate with their
    clients and dependencies. The unit tests verify that a service’s logic is correct.
    Neither type of test runs the entire service. In order to verify that a service
    as a whole works, we’ll move up the pyramid and look at how to write component
    tests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和单元测试验证服务各个部分的行为。集成测试验证服务能否与其客户端和依赖项通信。单元测试验证服务的逻辑是否正确。这两种类型的测试都不会运行整个服务。为了验证服务作为一个整体是否工作，我们将向上移动金字塔，看看如何编写组件测试。
- en: 10.2\. Developing component tests
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 开发组件测试
- en: So far, we’ve looked at how to test individual classes and clusters of classes.
    But imagine that we now want to verify that `Order Service` works as expected.
    In other words, we want to write the service’s acceptance tests, which treat it
    as a black box and verify its behavior through its API. One approach is to write
    what are essentially end-to-end tests and deploy `Order Service` and all of its
    transitive dependencies. As you should know by now, that’s a slow, brittle, and
    expensive way to test a service.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何测试单个类和类簇。但想象一下，我们现在想要验证`Order Service`是否按预期工作。换句话说，我们想要编写服务的验收测试，将其视为一个黑盒，并通过其API验证其行为。一种方法就是编写本质上属于端到端测试，并部署`Order
    Service`及其所有传递依赖项。正如你现在应该知道的，这是一种缓慢、脆弱且昂贵的测试服务的方法。
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Service component test**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：服务组件测试**'
- en: Test a service in isolation. See [http://microservices.io/patterns/testing/service-component-test.html](http://microservices.io/patterns/testing/service-component-test.html).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在隔离状态下测试服务。参见[http://microservices.io/patterns/testing/service-component-test.html](http://microservices.io/patterns/testing/service-component-test.html)。
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A much better way to write acceptance tests for a service is to use component
    testing. As [figure 10.6](#ch10fig06) shows, *component tests* are sandwiched
    between integration tests and end-to-end tests. Component testing verifies the
    behavior of a service in isolation. It replaces a service’s dependencies with
    stubs that simulate their behavior. It might even use in-memory versions of infrastructure
    services such as databases. As a result, component tests are much easier to write
    and faster to run.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为服务编写验收测试的一个更好的方法是使用组件测试。如图10.6所示，*组件测试*位于集成测试和端到端测试之间。组件测试在隔离状态下验证服务的行为。它用模拟行为的存根替换了服务的依赖项。甚至可能使用内存中的基础设施服务版本，如数据库。因此，组件测试编写起来更容易，运行速度更快。
- en: Figure 10.6\. A component test tests a service in isolation. It typically uses
    stubs for the service’s dependencies.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6.组件测试在隔离状态下测试服务。它通常使用服务依赖项的存根。
- en: '![](Images/10fig06_alt.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig06_alt.jpg)'
- en: I begin by briefly describing how to use a testing DSL called Gherkin to write
    acceptance tests for services, such as `Order Service`. After that I discuss various
    component testing design issues. I then show how to write acceptance tests for
    `Order Service`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先简要描述如何使用名为Gherkin的测试DSL编写服务的验收测试，例如`Order Service`。之后，我将讨论各种组件测试设计问题。然后，我将展示如何为`Order
    Service`编写验收测试。
- en: Let’s look at writing acceptance tests using Gherkin.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Gherkin编写验收测试。
- en: 10.2.1\. Defining acceptance tests
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1. 定义验收测试
- en: 'Acceptance tests are business-facing tests for a software component. They describe
    the desired externally visible behavior from the perspective of the component’s
    clients rather than in terms of the internal implementation. These tests are derived
    from user stories or use cases. For example, one of the key stories for `Order
    Service` is the `Place Order` story:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是面向业务的软件组件测试。它们从组件客户端的角度描述了期望的外部可见行为，而不是从内部实现的角度。这些测试是从用户故事或用例中派生出来的。例如，`Order
    Service`的一个关键故事是`Place Order`故事：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can expand this story into scenarios such as the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个故事扩展到以下场景：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This scenario describes the desired behavior of `Order Service` in terms of
    its API.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景描述了`Order Service`的API方面的期望行为。
- en: 'Each scenario defines an acceptance test. The *givens* correspond to the test’s
    setup phase, the *when* maps to the execute phase, and the *then* and the *and*
    to the verification phase. Later, you see a test for this scenario that does the
    following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景定义一个验收测试。*给定*对应于测试的设置阶段，*当*对应于执行阶段，而*然后*和*并且*对应于验证阶段。稍后，你将看到对这个场景的测试，它执行以下操作：
- en: Creates an `Order` by invoking the `POST /orders` endpoint
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`POST /orders`端点创建`Order`
- en: Verifies the state of the `Order` by invoking the `GET /orders/{orderId}` endpoint
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`GET /orders/{orderId}`端点验证`Order`的状态
- en: Verifies that the `Order Service` published an `OrderAuthorized` event by subscribing
    to the appropriate message channel
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过订阅适当的消息通道验证`Order Service`是否发布了`OrderAuthorized`事件
- en: We could translate each scenario into Java code. An easier option, though, is
    to write the acceptance tests using a DSL such as Gherkin.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每个场景翻译成Java代码。然而，一个更简单的方法是使用Gherkin之类的DSL编写验收测试。
- en: 10.2.2\. Writing acceptance tests using Gherkin
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2. 使用Gherkin编写验收测试
- en: Writing acceptance tests in Java is challenging. There’s a risk that the scenarios
    and the Java tests diverge. There’s also a disconnect between the high-level scenarios
    and the Java tests, which consist of low-level implementation details. Also, there’s
    a risk that a scenario lacks precision or is ambiguous and can’t be translated
    into Java code. A much better approach is to eliminate the manual translation
    step and write executable scenarios.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中编写验收测试具有挑战性。存在场景和 Java 测试之间发生分歧的风险。此外，高级场景和由低级实现细节组成的 Java 测试之间存在脱节。还有风险是一个场景缺乏精确性或含糊不清，无法转换为
    Java 代码。一个更好的方法是消除手动翻译步骤，并编写可执行的场景。
- en: Gherkin is a DSL for writing executable specifications. When using Gherkin,
    you define your acceptance tests using English-like scenarios, such as the one
    shown earlier. You then execute the specifications using Cucumber, a test automation
    framework for Gherkin. Gherkin and Cucumber eliminate the need to manually translate
    scenarios into runnable code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 是一个用于编写可执行规范的 DSL。当使用 Gherkin 时，你使用类似英语的场景定义你的验收测试，例如前面所示。然后，使用 Gherkin
    的测试自动化框架 Cucumber 执行规范。Gherkin 和 Cucumber 消除了手动将场景转换为可运行代码的需求。
- en: The Gherkin specification for a service such as `Order Service` consists of
    a set of features. Each *feature* is described by a set of scenarios such as the
    one you saw earlier. A scenario has the given-when-then structure. The *givens*
    are the preconditions, the *when* is the action or event that occurs, and the
    *then*/*and* are the expected outcome.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Order Service` 等服务，Gherkin 规范由一系列特性组成。每个 *特性* 都由一组场景描述，例如你之前看到的。一个场景具有给定-当-然后的结构。*给定*
    是前提条件，*当* 是发生的行为或事件，而 *然后*/*和* 是预期的结果。
- en: 'For example, the desired behavior of `Order Service` is defined by several
    features, including `Place Order`, `Cancel Order`, and `Revise Order`. [Listing
    10.11](#ch10ex11) is an excerpt of the `Place Order` feature. This feature consists
    of several elements:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Order Service` 的预期行为由几个特性定义，包括 `Place Order`、`Cancel Order` 和 `Revise Order`。[列表
    10.11](#ch10ex11) 是 `Place Order` 特性的摘录。这个特性由几个元素组成：
- en: '***Name*—** For this feature, the name is `Place Order`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***名称*—** 对于这个特性，名称是 `Place Order`。'
- en: '***Specification brief*—** This describes why the feature exists. For this
    feature, the specification brief is the user story.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***规范摘要*—** 这描述了特性的存在原因。对于这个特性，规范摘要就是用户故事。'
- en: '***Scenarios*—** `Order authorized` and `Order rejected due to expired credit
    card`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***场景*—** `Order authorized` 和 `Order rejected due to expired credit card`。'
- en: Listing 10.11\. The Gherkin definition of the `Place Order` feature and some
    of its scenarios
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. `Place Order` 特性和其一些场景的 Gherkin 定义
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In both scenarios, a consumer attempts to place an order. In the first scenario,
    they succeed. In the second scenario, the order is rejected because the consumer’s
    credit card has expired. For more information on Gherkin, see the book *Writing
    Great Specifications: Using Specification by Example and Gherkin* by Kamil Nicieja
    (Manning, 2017).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个场景中，消费者试图下订单。在第一个场景中，他们成功了。在第二个场景中，由于消费者的信用卡已过期，订单被拒绝。有关 Gherkin 的更多信息，请参阅
    Kamil Nicieja 所著的《编写优秀的规范：使用示例规范和 Gherkin》（Manning，2017）。
- en: Executing Gherkin specifications using Cucumber
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Cucumber 执行 Gherkin 规范
- en: Cucumber is an automated testing framework that executes tests written in Gherkin.
    It’s available in a variety of languages, including Java. When using Cucumber
    for Java, you write a step definition class, such as the one shown in [listing
    10.12](#ch10ex12). A *step definition class* consists of methods that define the
    meaning of each given-then-when step. Each step definition method is annotated
    with either `@Given`, `@When`, `@Then`, or `@And`. Each of these annotations has
    a `value` element that’s a regular expression, which Cucumber matches against
    the steps.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber 是一个自动化测试框架，用于执行用 Gherkin 编写的测试。它支持多种语言，包括 Java。当使用 Cucumber 进行 Java
    测试时，你将编写一个步骤定义类，例如 [列表 10.12](#ch10ex12) 中所示。一个 *步骤定义类* 包含定义每个给定-然后-当步骤含义的方法。每个步骤定义方法都带有
    `@Given`、`@When`、`@Then` 或 `@And` 之一的注解。每个注解都有一个 `value` 元素，它是一个正则表达式，Cucumber
    会将其与步骤进行匹配。
- en: Listing 10.12\. The Java step definitions class makes the Gherkin scenarios
    executable.
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12\. Java 步骤定义类使 Gherkin 场景可执行。
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each type of method is part of a particular phase of the test:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法类型都是测试特定阶段的一部分：
- en: '`@Given`—The setup phase'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Given`—设置阶段'
- en: '`@When`—The execute phase'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@When`—执行阶段'
- en: '`@Then` *and* `@And`—The verification phase'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Then` *和* `@And`—验证阶段'
- en: Later in [section 10.2.4](#ch10lev2sec8), when I describe this class in more
    detail, you’ll see that many of these methods make REST calls to `Order Service`.
    For example, the `placeOrder()` method creates `Order` by invoking the `POST /orders`
    REST endpoint. The `theOrderShouldBe()` method verifies the status of the order
    by invoking `GET /orders/{orderId}`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10.2.4节](#ch10lev2sec8)的后面，当我更详细地描述这个类时，你会看到许多这些方法都向`Order Service`发起REST调用。例如，`placeOrder()`方法通过调用`POST
    /orders` REST端点来创建`Order`。`theOrderShouldBe()`方法通过调用`GET /orders/{orderId}`来验证订单的状态。
- en: But before getting into the details of how to write step classes, let’s explore
    some design issues with component tests.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入探讨如何编写步骤类之前，让我们先探讨一些组件测试的设计问题。
- en: 10.2.3\. Designing component tests
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3. 设计组件测试
- en: Imagine you’re implementing the component tests for `Order Service`. [Section
    10.2.2](#ch10lev2sec6) shows how to specify the desired behavior using Gherkin
    and execute it using Cucumber. But before a component test can execute the Gherkin
    scenarios, it must first run `Order Service` and set up the service’s dependencies.
    You need to test `Order Service` in isolation, so the component test must configure
    stubs for several services, including `Kitchen Service`. It also needs to set
    up a database and the messaging infrastructure. There are a few different options
    that trade off realism with speed and simplicity.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在实现`Order Service`的组件测试。[第10.2.2节](#ch10lev2sec6)展示了如何使用Gherkin指定期望的行为，并使用Cucumber执行它。但在组件测试可以执行Gherkin场景之前，它必须首先运行`Order
    Service`并设置服务的依赖项。你需要单独测试`Order Service`，因此组件测试必须为包括`Kitchen Service`在内的几个服务配置存根。它还需要设置数据库和消息基础设施。有几个不同的选项，这些选项在现实性、速度和简单性之间进行权衡。
- en: In-process component tests
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在制品组件测试
- en: One option is to write in-process component tests. An *in-process component
    test* runs the service with in-memory stubs and mocks for its dependencies. For
    example, you can write a component test for a Spring Boot-based service using
    the Spring Boot testing framework. A test class, which is annotated with `@SpringBootTest`,
    runs the service in the same JVM as the test. It uses dependency injection to
    configure the service to use mocks and stubs. For instance, a test for `Order
    Service` would configure it to use an in-memory JDBC database, such as H2, HSQLDB,
    or Derby, and in-memory stubs for Eventuate Tram. In-process tests are simpler
    to write and faster, but have the downside of not testing the deployable service.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是编写在制品组件测试。一种*在制品组件测试*在内存存根和模拟依赖项的情况下运行服务。例如，你可以使用Spring Boot测试框架编写一个基于Spring
    Boot服务的组件测试。一个带有`@SpringBootTest`注解的测试类在测试相同的JVM中运行服务。它使用依赖注入来配置服务以使用模拟和存根。例如，对`Order
    Service`的测试会配置它使用内存JDBC数据库，如H2、HSQLDB或Derby，以及Eventuate Tram的内存存根。在制品测试编写起来更简单，速度更快，但缺点是它没有测试可部署的服务。
- en: Out-of-process component testing
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 离进程组件测试
- en: A more realistic approach is to package the service in a production-ready format
    and run it as a separate process. For example, [chapter 12](kindle_split_020.xhtml#ch12)
    explains that it’s increasingly common to package services as Docker container
    images. An *out-of-process component test* uses real infrastructure services,
    such as databases and message brokers, but uses stubs for any dependencies that
    are application services. For example, an out-of-process component test for `FTGO
    Order Service` would use MySQL and Apache Kafka, and stubs for services including
    `Consumer Service` and `Accounting Service`. Because `Order Service` interacts
    with those services using messaging, these stubs would consume messages from Apache
    Kafka and send back reply messages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更现实的方法是将服务打包成生产就绪格式，并作为一个单独的进程运行。例如，[第12章](kindle_split_020.xhtml#ch12)解释说，将服务打包成Docker容器镜像的做法越来越普遍。一种*离进程组件测试*使用真实的底层服务，例如数据库和消息代理，但对于任何应用程序服务的依赖项则使用存根。例如，对`FTGO
    Order Service`的离进程组件测试将使用MySQL和Apache Kafka，以及`Consumer Service`和`Accounting Service`等服务用的存根。因为`Order
    Service`通过消息与这些服务交互，这些存根将消费Apache Kafka中的消息并返回回复消息。
- en: A key benefit of out-of-process component testing is that it improves test coverage,
    because what’s being tested is much closer to what’s being deployed. The drawback
    is that this type of test is more complex to write, slower to execute, and potentially
    more brittle than an in-process component test. You also have to figure out how
    to stub the application services. Let’s look at how to do that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 进程外组件测试的一个关键优势是它提高了测试覆盖率，因为被测试的内容与部署的内容非常接近。缺点是这种类型的测试编写更复杂，执行速度更慢，并且可能比进程内组件测试更脆弱。您还必须弄清楚如何存根应用程序服务。让我们看看如何做到这一点。
- en: How to stub services in out-of-process component tests
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如何在进程外组件测试中存根服务
- en: The service under test often invokes dependencies using interaction styles that
    involve sending back a response. `Order Service`, for example, uses asynchronous
    request/response and sends command messages to various services. `API Gateway`
    uses HTTP, which is a request/response interaction style. An out-of-process test
    must configure stubs for these kinds of dependencies, which handle requests and
    send back replies.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的服务通常使用涉及发送响应的交互样式调用依赖项。例如，`Order Service`使用异步请求/响应并向各种服务发送命令消息。`API Gateway`使用HTTP，这是一种请求/响应交互样式。进程外测试必须为这些类型的依赖项配置存根，这些存根处理请求并发送回复。
- en: One option is to use Spring Cloud Contract, which we looked at earlier in [section
    10.1](#ch10lev1sec1) when discussing integration tests. We could write contracts
    that configure stubs for component tests. One thing to consider, though, is that
    it’s likely that these contracts, unlike those used for integration, would only
    be used by the component tests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用我们在[第10.1节](#ch10lev1sec1)中讨论集成测试时查看的Spring Cloud Contract。我们可以编写配置组件测试存根的合同。不过，有一点需要考虑的是，与用于集成的合同不同，这些合同可能只会被组件测试使用。
- en: Another drawback of using Spring Cloud Contract for component testing is that
    because its focus is consumer contract testing, it takes a somewhat heavyweight
    approach. The JAR files containing the contracts must be deployed in a Maven repository
    rather than merely being on the classpath. Handling interactions involving dynamically
    generated values is also challenging. Consequently, a simpler option is to configure
    stubs from within the test itself.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Contract进行组件测试的另一个缺点是，由于其重点是消费者合同测试，因此它采取了一种相对重量级的策略。包含合同的JAR文件必须在Maven仓库中部署，而不仅仅是放在类路径上。处理涉及动态生成值的交互也是一项挑战。因此，一个更简单的选择是在测试本身内部配置存根。
- en: A test can, for example, configure an HTTP stub using the WireMock stubbing
    DSL. Similarly, a test for a service that uses Eventuate Tram messaging can configure
    messaging stubs. Later in this section I show an easy-to-use Java library that
    does this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个测试可以使用WireMock存根DSL配置HTTP存根。同样，对使用Eventuate Tram消息传递的服务进行的测试可以配置消息存根。在本节的后面部分，我将展示一个易于使用的Java库，它可以完成这项工作。
- en: Now that we’ve looked at how to design component tests, let’s consider how to
    write component tests for the FTGO `Order Service`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何设计组件测试，让我们考虑如何为FTGO `Order Service`编写组件测试。
- en: 10.2.4\. Writing component tests for the FTGO Order Service
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.4. 为FTGO `Order Service`编写组件测试
- en: As you saw earlier in this section, there are a few different ways to implement
    component tests. This section describes the component tests for `Order Service`
    that use the out-of-process strategy to test the service running as a Docker container.
    You’ll see how the tests use a Gradle plugin to start and stop the Docker container.
    I discuss how to use Cucumber to execute the Gherkin-based scenarios that define
    the desired behavior for `Order Service`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本节前面所见，实现组件测试有几种不同的方法。本节描述了使用进程外策略来测试作为Docker容器运行的服务`Order Service`的组件测试。您将看到测试如何使用Gradle插件来启动和停止Docker容器。我还将讨论如何使用Cucumber来执行定义`Order
    Service`期望行为的基于Gherkin的场景。
- en: '[Figure 10.7](#ch10fig07) shows the design of the component tests for `Order
    Service`. `OrderServiceComponentTest` is the test class that runs Cucumber:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.7](#ch10fig07)显示了`Order Service`组件测试的设计。`OrderServiceComponentTest`是运行Cucumber的测试类：'
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Figure 10.7\. The component tests for `Order Service` use the Cucumber testing
    framework to execute tests scenarios written using Gherkin acceptance testing
    DSL. The tests use Docker to run `Order Service` along with its infrastructure
    services, such as Apache Kafka and MySQL.
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.7\. `Order Service` 组件测试使用 Cucumber 测试框架执行使用 Gherkin 接受测试 DSL 编写的测试场景。测试使用
    Docker 运行 `Order Service` 及其基础设施服务，例如 Apache Kafka 和 MySQL。
- en: '![](Images/10fig07_alt.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig07_alt.jpg)'
- en: It has an `@CucumberOptions` annotation that specifies where to find the Gherkin
    feature files. It’s also annotated with `@RunWith(Cucumber.class)`, which tells
    JUNIT to use the Cucumber test runner. But unlike a typical JUNIT-based test class,
    it doesn’t have any test methods. Instead, it defines the tests by reading the
    Gherkin features and uses the `OrderServiceComponentTestStepDefinitions` class
    to make them executable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个 `@CucumberOptions` 注解，指定了 Gherkin 特性文件的查找位置。它还带有 `@RunWith(Cucumber.class)`
    注解，告诉 JUNIT 使用 Cucumber 测试运行器。但与典型的基于 JUNIT 的测试类不同，它没有测试方法。相反，它通过读取 Gherkin 特性来定义测试，并使用
    `OrderServiceComponentTestStepDefinitions` 类使它们可执行。
- en: Using Cucumber with the Spring Boot testing framework requires a slightly unusual
    structure. Despite not being a test class, `OrderServiceComponentTestStepDefinitions`
    is still annotated with `@ContextConfiguration`, which is part of the Spring Testing
    framework. It creates Spring `ApplicationContext`, which defines the various Spring
    components, including messaging stubs. Let’s look at the details of the step definitions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cucumber 与 Spring Boot 测试框架需要稍微不寻常的结构。尽管它不是一个测试类，但 `OrderServiceComponentTestStepDefinitions`
    仍然被 `@ContextConfiguration` 注解，这是 Spring 测试框架的一部分。它创建 Spring `ApplicationContext`，该上下文定义了各种
    Spring 组件，包括消息存根。让我们看看步骤定义的详细情况。
- en: The OrderServiceComponentTestStepDefinitions class
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`OrderServiceComponentTestStepDefinitions` 类'
- en: The `OrderServiceComponentTestStepDefinitions` class is the heart of the tests.
    This class defines the meaning of each step in `Order Service`’s component tests.
    The following listing shows the `usingCreditCard()` method, which defines the
    meaning of the `Given using ... credit card` step.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderServiceComponentTestStepDefinitions` 类是测试的核心。该类定义了 `Order Service` 组件测试中每个步骤的含义。下面的列表展示了
    `usingCreditCard()` 方法，该方法定义了 `Given using ... credit card` 步骤的含义。'
- en: Listing 10.13\. The `@GivenuseCreditCard()` method defines the meaning of the
    `Given using ... credit card` step.
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13\. `@GivenuseCreditCard()` 方法定义了 `Given using ... credit card` 步骤的含义。
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Send a success reply.**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 发送成功回复。**'
- en: '***2* Send a failure reply.**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 发送失败回复。**'
- en: This method uses the `SagaParticipantStubManager` class, a test helper class
    that configures stubs for saga participants. The `useCreditCard()` method uses
    it to configure the `Accounting Service` stub to reply with either a success or
    a failure message, depending on the specified credit card.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `SagaParticipantStubManager` 类，这是一个测试辅助类，用于配置 saga 参与者的存根。`useCreditCard()`
    方法使用它来配置 `Accounting Service` 存根以根据指定的信用卡回复成功或失败消息。
- en: The following listing shows the `placeOrder()` method, which defines the `When
    I place an order for Chicken Vindaloo at Ajanta` step. It invokes the `Order Service`
    REST API to create `Order` and saves the response for validation in a later step.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了 `placeOrder()` 方法，该方法定义了 `When I place an order for Chicken Vindaloo
    at Ajanta` 步骤。它调用 `Order Service` REST API 创建 `Order` 并将响应保存以供后续步骤验证。
- en: Listing 10.14\. The `placeOrder()` method defines the `When I place an order
    for Chicken Vindaloo at Ajanta` step.
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. `placeOrder()` 方法定义了 `When I place an order for Chicken Vindaloo
    at Ajanta` 步骤。
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Invokes the Order Service REST API to create Order**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用 Order Service REST API 创建订单**'
- en: The `baseUrl()` help method returns the URL of the order service.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseUrl()` 辅助方法返回订单服务的 URL。'
- en: '[Listing 10.15](#ch10ex15) shows the `theOrderShouldBe()` method, which defines
    the meaning of the `Then the order should be ...` step. It verifies that `Order`
    was successfully created and that it’s in the expected state.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.15](#ch10ex15) 展示了 `theOrderShouldBe()` 方法，该方法定义了 `Then the order should
    be ...` 步骤的含义。它验证 `Order` 已成功创建并且处于预期的状态。'
- en: Listing 10.15\. The `@ThentheOrderShouldBe()` method verifies HTTP request was
    successful.
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. `@ThentheOrderShouldBe()` 方法验证 HTTP 请求是否成功。
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Verify that Order was created successfully.**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 验证订单是否成功创建。**'
- en: '***2* Verify the state of Order.**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证订单状态。**'
- en: The assertion of the expected state is wrapped in a call to `eventually()`,
    which repeatedly executes the assertion.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 预期状态的断言被封装在 `eventually()` 调用中，该调用会重复执行断言。
- en: The following listing shows the `verifyEventPublished()` method, which defines
    the `And an ... event should be published` step. It verifies that the expected
    domain event was published.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 `verifyEventPublished()` 方法，它定义了 `And an ... event should be published`
    步骤。它验证预期的领域事件是否已发布。
- en: Listing 10.16\. The Cucumber step definitions class for the `Order Service`
    component tests
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.16\. `Order Service` 组件测试的 Cucumber 步骤定义类
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `verifyEventPublished()` method uses the `MessageTracker` class, a test
    helper class that records the events that have been published during the test.
    This class and `SagaParticipantStubManager` are instantiated by the `TestConfiguration@Configuration`
    class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyEventPublished()` 方法使用 `MessageTracker` 类，这是一个测试辅助类，用于记录测试期间已发布的事件。这个类和
    `SagaParticipantStubManager` 都是由 `TestConfiguration@Configuration` 类实例化的。'
- en: Now that we’ve looked at the step definitions, let’s look at how to run the
    component tests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看步骤定义，让我们看看如何运行组件测试。
- en: Running the component tests
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行组件测试
- en: Because these tests are relatively slow, we don’t want to run them as part of
    `./gradlew test`. Instead, we’ll put the test code in a separate `src/component-test/java`
    directory and run them using `./gradlew componentTest`. Take a look at the `ftgo-order-service/build.gradle`
    file to see the Gradle configuration.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试相对较慢，我们不希望将它们作为 `./gradlew test` 的一部分运行。相反，我们将测试代码放在一个单独的 `src/component-test/java`
    目录中，并使用 `./gradlew componentTest` 运行它们。查看 `ftgo-order-service/build.gradle` 文件以了解
    Gradle 配置。
- en: The tests use Docker to run `Order Service` and its dependencies. As described
    in [chapter 12](kindle_split_020.xhtml#ch12), a Docker container is a lightweight
    operating system virtualization mechanism that lets you deploy a service instance
    in an isolated sandbox. Docker Compose is an extremely useful tool with which
    you can define a set of containers and start and stop them as a unit. The FTGO
    application has a `docker-compose` file in the root directory that defines containers
    for all the services, and the infrastructure service.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用 Docker 运行 `Order Service` 及其依赖项。如第 12 章所述，Docker 容器是一种轻量级的操作系统虚拟化机制，允许你在隔离的沙盒中部署服务实例。Docker
    Compose 是一个极其有用的工具，可以定义一组容器，并将它们作为一个单元启动和停止。FTGO 应用在根目录中有一个 `docker-compose` 文件，定义了所有服务以及基础设施服务的容器。
- en: 'We can use the Gradle Docker Compose plugin to run the containers before executing
    the tests and stop the containers once the tests complete:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Gradle Docker Compose 插件在执行测试之前运行容器，并在测试完成后停止容器：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding snippet of Gradle configuration does two things. First, it configures
    the Gradle Docker Compose plugin to run before the component tests and start `Order
    Service` along with the infrastructure services that it’s configured to depend
    on. Second, it configures `componentTest` to depend on `assemble` so that the
    JAR file required by the Docker image is built first. With that in place, we can
    run these component tests with the following commands:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 Gradle 配置片段做了两件事。首先，它配置 Gradle Docker Compose 插件在组件测试之前运行，并启动 `Order Service`
    以及它配置依赖的基础设施服务。其次，它配置 `componentTest` 依赖于 `assemble`，以确保 Docker 镜像所需的 JAR 文件首先构建。有了这些配置，我们可以使用以下命令运行这些组件测试：
- en: '[PRE20]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Those commands, which take a couple of minutes, perform the following actions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令需要几分钟，执行以下操作：
- en: Build `Order Service`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `Order Service`。
- en: Run the service and its infrastructure services.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务及其基础设施服务。
- en: Run the tests.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Stop the running services.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止运行中的服务。
- en: Now that we’ve looked at how to test a service in isolation, we’ll see how to
    test the entire application.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何单独测试服务，我们将看到如何测试整个应用程序。
- en: 10.3\. Writing end-to-end tests
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 编写端到端测试
- en: Component testing tests each service separately. End-to-end testing, though,
    tests the entire application. As [figure 10.8](#ch10fig08) shows, end-to-end testing
    is the top of the test pyramid. That’s because these kinds of tests are—say it
    with me now—slow, brittle, and time consuming to develop.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试分别测试每个服务。然而，端到端测试则测试整个应用程序。如图 10.8 所示，端到端测试位于测试金字塔的顶部。这是因为这些类型的测试——现在跟我一起说——速度慢、脆弱且开发耗时。
- en: Figure 10.8\. End-to-end tests are at the top of the test pyramid. They are
    slow, brittle, and time consuming to develop. You should minimize the number of
    end-to-end tests.
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.8\. 端到端测试位于测试金字塔的顶部。它们速度慢、脆弱且开发耗时。你应该尽量减少端到端测试的数量。
- en: '![](Images/10fig08_alt.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig08_alt.jpg)'
- en: End-to-end tests have a large number of moving parts. You must deploy multiple
    services and their supporting infrastructure services. As a result, end-to-end
    tests are slow. Also, if your test needs to deploy a large number of services,
    there’s a good chance one of them will fail to deploy, making the tests unreliable.
    Consequently, you should minimize the number of end-to-end tests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试涉及许多移动部件。您必须部署多个服务和它们的支持性基础设施服务。因此，端到端测试运行缓慢。此外，如果您的测试需要部署大量服务，那么其中一个服务部署失败的可能性很大，这使得测试不可靠。因此，您应该尽量减少端到端测试的数量。
- en: 10.3.1\. Designing end-to-end tests
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 设计端到端测试
- en: As I’ve explained, it’s best to write as few of these as possible. A good strategy
    is to write user journey tests. A *user journey test* corresponds to a user’s
    journey through the system. For example, rather than test create order, revise
    order, and cancel order separately, you can write a single test that does all
    three. This approach significantly reduces the number of tests you must write
    and shortens the test execution time.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我解释的，最好尽可能少地编写这些测试。一个好的策略是编写用户旅程测试。*用户旅程测试*对应于用户在系统中的旅程。例如，与其分别测试创建订单、修改订单和取消订单，您可以编写一个执行所有这三个操作的单一测试。这种方法显著减少了您必须编写的测试数量，并缩短了测试执行时间。
- en: 10.3.2\. Writing end-to-end tests
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 编写端到端测试
- en: End-to-end tests are, like the acceptance tests covered in [section 10.2](#ch10lev1sec2),
    business-facing tests. It makes sense to write them in a high-level DSL that’s
    understood by the business people. You can, for example, write the end-to-end
    tests using Gherkin and execute them using Cucumber. The following listing shows
    an example of such a test. It’s similar to the acceptance tests we looked at earlier.
    The main difference is that rather than a single `Then`, this test has multiple
    actions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试，就像第 10.2 节中提到的验收测试一样，是面向业务的测试。使用业务人员理解的高级 DSL 编写它们是有意义的。例如，您可以使用 Gherkin
    编写端到端测试，并使用 Cucumber 执行它们。以下列表显示了一个此类测试的示例。它与之前我们查看的验收测试类似。主要区别是，这个测试有多个动作，而不仅仅是单个
    `Then`。
- en: Listing 10.17\. A Gherkin-based specification of a user journey
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.17\. 基于Gherkin的用户旅程规范
- en: '[PRE21]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Create Order.**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建订单。**'
- en: '***2* Revise Order.**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 修改订单。**'
- en: '***3* Cancel Order.**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 取消订单。**'
- en: This scenario places an order, revises it, and then cancels it. Let’s look at
    how to run it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景包括下单、修改订单，然后取消订单。让我们看看如何运行它。
- en: 10.3.3\. Running end-to-end tests
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3\. 运行端到端测试
- en: End-to-end tests must run the entire application, including any required infrastructure
    services. As you saw in earlier in [section 10.2](#ch10lev1sec2), the Gradle Docker
    Compose plugin provides a convenient way to do this. Instead of running a single
    application service, though, the Docker Compose file runs all the application’s
    services.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试必须运行整个应用程序，包括任何所需的必需基础设施服务。正如您在第 10.2 节中看到的，Gradle Docker Compose 插件提供了一个方便的方式来执行此操作。然而，与运行单个应用程序服务不同，Docker
    Compose 文件运行应用程序的所有服务。
- en: Now that we’ve looked at different aspects of designing and writing end-to-end
    tests, let’s see an example end-to-end test.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了设计和编写端到端测试的不同方面，让我们来看一个端到端测试的例子。
- en: The `ftgo-end-to-end-test` module implements the end-to-end tests for the FTGO
    application. The implementation of the end-to-end test is quite similar to the
    implementation of the component tests discussed earlier in [section 10.2](#ch10lev1sec2).
    These tests are written using Gherkin and executed using Cucumber. The Gradle
    Docker Compose plugin runs the containers before the tests run. It takes around
    four to five minutes to start the containers and run the tests.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`ftgo-end-to-end-test` 模块实现了 FTGO 应用程序的端到端测试。端到端测试的实现与之前在第 10.2 节中讨论的组件测试实现相当相似。这些测试使用
    Gherkin 编写，并使用 Cucumber 执行。Gradle Docker Compose 插件在测试运行之前启动容器。启动容器并运行测试大约需要四到五分钟。'
- en: That may not seem like a long time, but this is a relatively simple application
    with just a handful of containers and tests. Imagine if there were hundreds of
    containers and many more tests. The tests could take quite a long time. Consequently,
    it’s best to focus on writing tests that are lower down the pyramid.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来时间不长，但这是一个相对简单的应用程序，只有几个容器和测试。想象一下，如果有数百个容器和更多的测试，测试可能需要相当长的时间。因此，最好专注于编写金字塔底部的测试。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Use contracts, which are example messages, to drive the testing of interactions
    between services. Rather than write slow-running tests that run both services
    and their transitive dependencies, write tests that verify that the adapters of
    both services conform to the contracts.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合同，即示例消息，来驱动服务之间交互的测试。而不是编写运行缓慢的测试，这些测试同时运行服务和它们的传递依赖项，编写测试以验证两个服务的适配器都符合合同。
- en: Write component tests to verify the behavior of a service via its API. You should
    simplify and speed up component tests by testing a service in isolation, using
    stubs for its dependencies.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写组件测试以通过其API验证服务的功能。你应该通过在隔离状态下测试服务，使用存根来测试其依赖项，来简化并加快组件测试。
- en: Write user journey tests to minimize the number of end-to-end tests, which are
    slow, brittle, and time consuming. A user journey test simulates a user’s journey
    through the application and verifies high-level behavior of a relatively large
    slice of the application’s functionality. Because there are few tests, the amount
    of per-test overhead, such as test setup, is minimized, which speeds up the tests.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写用户旅程测试以最小化端到端测试的数量，因为端到端测试速度慢、脆弱且耗时。用户旅程测试模拟用户在应用程序中的旅程，并验证应用程序功能较大块的高级行为。由于测试数量较少，每个测试的额外开销，如测试设置，被最小化，从而加快了测试速度。
