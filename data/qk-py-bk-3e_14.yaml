- en: Chapter 13\. Reading and writing files
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 13 章. 读取和写入文件
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Opening files and `file` objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件和 `file` 对象
- en: Closing files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭文件
- en: Opening files in different modes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同模式打开文件
- en: Reading and writing text or binary data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入文本或二进制数据
- en: Redirecting screen input/output
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向屏幕输入/输出
- en: Using the `struct` module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `struct` 模块
- en: Pickling objects into files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象序列化到文件中
- en: Shelving objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档对象
- en: 13.1\. Opening files and file objects
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1. 打开文件和文件对象
- en: Probably the single most common thing you’ll want to do with files is open and
    read them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能最想对文件做的单个操作就是打开和读取它们。
- en: 'In Python, you open and read a file by using the built-in `open` function and
    various built-in reading operations. The following short Python program reads
    in one line from a text file named myfile:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以通过使用内置的 `open` 函数和多种内置的读取操作来打开和读取文件。以下简短的 Python 程序从名为 myfile
    的文本文件中读取一行：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`open` doesn’t read anything from the file; instead, it returns an object called
    a `file` object that you can use to access the opened file. A `file` object keeps
    track of a file and how much of the file has been read or written. All Python
    file I/O is done using `file` objects rather than filenames.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 不会从文件中读取任何内容；相反，它返回一个名为 `file` 对象的实例，你可以使用它来访问已打开的文件。`file` 对象跟踪文件以及已读取或写入文件的程度。所有
    Python 文件 I/O 都是通过 `file` 对象而不是文件名来完成的。'
- en: The first call to `readline` returns the first line in the `file` object, everything
    up to and including the first newline character or the entire file if there’s
    no newline character in the file; the next call to `readline` returns the second
    line, if it exists, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `readline` 返回 `file` 对象中的第一行，包括第一个换行符或如果没有换行符则整个文件；下一次调用 `readline` 返回第二行（如果存在），依此类推。
- en: 'The first argument to the `open` function is a pathname. In the previous example,
    you’re opening what you expect to be an existing file in the current working directory.
    The following opens a file at an absolute location—`c:\My Documents\test\myfile`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 函数的第一个参数是路径名。在先前的示例中，你正在打开你期望在当前工作目录中存在的文件。以下是在绝对位置打开文件——`c:\My Documents\test\myfile`：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note also that this example uses the `with` keyword, indicating that the file
    will be opened with a context manager, which I explain more in [chapter 14](kindle_split_025.html#ch14).
    For now, it’s enough to note that this style of opening files better manages potential
    I/O errors and is generally preferred.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此示例使用了 `with` 关键字，表示文件将以上下文管理器的方式打开，我将在第 14 章[第 14 章](kindle_split_025.html#ch14)中解释更多。现在，只需注意这种打开文件的方式更好地管理潜在的
    I/O 错误，并且通常更受欢迎。
- en: 13.2\. Closing files
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2. 关闭文件
- en: After all data has been read from or written to a `file` object, it should be
    closed. Closing a `file` object frees up system resources, allows the underlying
    file to be read or written to by other code, and in general makes the program
    more reliable. For small scripts, not closing a `file` object generally doesn’t
    have much of an effect; `file` objects are automatically closed when the script
    or program terminates. For larger programs, too many open `file` objects may exhaust
    system resources, causing the program to abort.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 `file` 对象读取或写入所有数据之后，应该关闭它。关闭 `file` 对象可以释放系统资源，允许其他代码读取或写入底层文件，并且通常使程序更可靠。对于小型脚本，不关闭
    `file` 对象通常没有太大影响；`file` 对象在脚本或程序终止时自动关闭。对于大型程序，过多的打开 `file` 对象可能会耗尽系统资源，导致程序终止。
- en: 'You close a `file` object by using the `close` method when the `file` object
    is no longer needed. The earlier short program then becomes this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要 `file` 对象时，你可以使用 `close` 方法来关闭它。先前的简短程序变为如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using a context manager and the keyword `with` is also a good way to automatically
    close files when you’re done:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文管理器和 `with` 关键字也是自动关闭文件的好方法：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 13.3\. Opening files in write or other modes
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3. 以写入或其他模式打开文件
- en: 'The second argument of the `open` command is a string denoting how the file
    should be opened. `''r''` means “Open the file for reading,” `''w''` means “Open
    the file for writing” (any data already in the file will be erased), and `''a''`
    means “Open the file for appending” (new data will be appended to the end of any
    data already in the file). If you want to open the file for reading, you can leave
    out the second argument; `''r''` is the default. The following short program writes
    “Hello, World” to a file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 命令的第二个参数是一个字符串，表示文件应该如何打开。`''r''` 表示“以读取方式打开文件”，`''w''` 表示“以写入方式打开文件”（文件中已有的数据将被删除），`''a''`
    表示“以追加方式打开文件”（新数据将被追加到文件中已有的数据末尾）。如果你想以读取方式打开文件，可以省略第二个参数；`''r''` 是默认值。以下简短的程序将“Hello,
    World”写入文件：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Depending on the operating system, `open` may also have access to additional
    file modes. These modes aren’t necessary for most purposes. As you write more
    advanced Python programs, you may want to consult the Python reference manuals
    for details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作系统，`open` 也可能访问到额外的文件模式。这些模式对于大多数目的来说并不是必需的。随着你编写更高级的 Python 程序，你可能需要查阅
    Python 参考手册以获取详细信息。
- en: '`open` can take an optional third argument, which defines how reads or writes
    for that file are buffered. *Buffering* is the process of holding data in memory
    until enough data has been requested or written to justify the time cost of doing
    a disk access. Other parameters to `open` control the encoding for text files
    and the handling of newline characters in text files. Again, these features aren’t
    things you typically need to worry about, but as you become more advanced in your
    use of Python, you may want to read up on them.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 可以接受一个可选的第三个参数，该参数定义了该文件的读取或写入如何进行缓冲。*缓冲* 是将数据保留在内存中，直到请求或写入足够的数据以证明进行磁盘访问的时间成本是合理的。`open`
    的其他参数控制文本文件的编码以及文本文件中换行符的处理。再次强调，这些功能通常不是你需要担心的事情，但随着你在 Python 中的使用变得更加高级，你可能想了解它们。'
- en: 13.4\. Functions to read and write text or binary data
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4. 读取和写入文本或二进制数据的功能
- en: 'I’ve already presented the most common text file–reading function, `readline`.
    This function reads and returns a single line from a `file` object, including
    any newline character on the end of the line. If there’s nothing more to be read
    from the file, `readline` returns an empty string, which makes it easy to (for
    example) count the number of lines in a file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经介绍了最常用的文本文件读取函数 `readline`。此函数从 `file` 对象中读取并返回一行，包括行尾的任何换行符。如果没有更多内容可从文件中读取，`readline`
    返回一个空字符串，这使得（例如）计算文件中的行数变得容易：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For this particular problem, an even shorter way to count all the lines is
    to use the built-in `readlines` method, which reads *all* the lines in a file
    and returns them as a list of strings, one string per line (with trailing newlines
    still included):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定问题，一个更短的方法来计算所有行数是使用内置的 `readlines` 方法，该方法读取文件中的所有行，并将它们作为字符串列表返回，每行一个字符串（包括尾随换行符）：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you happen to be counting all the lines in a huge file, of course, this method
    may cause your computer to run out of memory because it reads the entire file
    into memory at once. It’s also possible to overflow memory with `readline` if
    you have the misfortune to try to read a line from a huge file that contains no
    newline characters, although this situation is highly unlikely. To handle such
    circumstances, both `readline` and `readlines` can take an optional argument affecting
    the amount of data they read at any one time. See the Python reference documentation
    for details.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你碰巧正在计算一个大型文件中的所有行数，当然，这种方法可能会导致你的计算机内存耗尽，因为它一次性将整个文件读入内存。如果你不幸尝试从一个不包含换行符的大型文件中读取一行，使用
    `readline` 也可能导致内存溢出，尽管这种情况非常不可能。为了处理这种情况，`readline` 和 `readlines` 都可以接受一个可选参数，该参数影响它们在任何一次读取的数据量。有关详细信息，请参阅
    Python 参考文档。
- en: 'Another way to iterate over all of the lines in a file is to treat the `file`
    object as an iterator in a `for` loop:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种遍历文件中所有行的方法是将 `file` 对象作为 `for` 循环中的迭代器处理：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method has the advantage that the lines are read into memory as needed,
    so even with large files, running out of memory isn’t a concern. The other advantage
    of this method is that it’s simpler and easier to read.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于，行是按需读入内存的，因此即使对于大文件，内存耗尽也不是一个担忧。这种方法的其他优势在于它更简单，更容易阅读。
- en: 'A possible problem with the `read` method may arise due to the fact that on
    Windows and Macintosh machines, text-mode translations occur if you use the `open`
    command in text mode—that is, without adding a `b` to the mode. In text mode,
    on a Macintosh any `\r` is converted to `"\n"`, whereas on Windows `"\r\n"` pairs
    are converted to `"\n"`. You can specify the treatment of newline characters by
    using the newline parameter when you open the file and specifying `newline="\n"`,
    `"\r"`, or `"\r\n"`, which forces only that string to be used as a newline:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 方法的可能问题可能源于在 Windows 和 Macintosh 机器上，如果你使用 `open` 命令以文本模式打开，则会发生文本模式转换——也就是说，没有在模式中添加
    `b`。在文本模式下，在 Macintosh 上，任何 `\r` 都会被转换为 `"\n"`，而在 Windows 上，`"\r\n"` 对会被转换为 `"\n"`。你可以通过在打开文件时使用
    newline 参数并指定 `newline="\n"`、`"\r"` 或 `"\r\n"` 来指定换行符的处理方式，这将强制只使用该字符串作为换行符：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example forces only `"\n"` to be considered to be a newline. If the file
    has been opened in binary mode, the newline parameter isn’t needed, because all
    bytes are returned exactly as they are in the file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例强制只将 `"\n"` 考虑为换行符。如果文件是以二进制模式打开的，则不需要 newline 参数，因为所有字节都会按文件中的原始字节返回。
- en: 'The write methods that correspond to the `readline` and `readlines` methods
    are the `write` and `writelines` methods. Note that there’s no `writeline` function.
    `write` writes a single string, which can span multiple lines if newline characters
    are embedded within the string, as in this example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `readline` 和 `readlines` 方法对应的写入方法是 `write` 和 `writelines` 方法。请注意，没有 `writeline`
    函数。`write` 方法写入单个字符串，如果字符串中嵌入换行符，则可以跨越多行，如下例所示：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`write` doesn’t write out a newline after it writes its argument; if you want
    a newline in the output, you must put it there yourself. If you open a file in
    text mode (using `w`), any `\n` characters are mapped back to the platform-specific
    line endings (that is, `''\r\n''` on Windows or `''\r''` on Macintosh platforms).
    Again, opening the file with a specified newline prevents this situation.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 在写入其参数后不会写入换行符；如果你想在输出中包含换行符，你必须自己添加。如果你以文本模式打开文件（使用 `w`），则任何 `\n`
    字符都会映射回平台特定的行结束符（即 Windows 平台上的 `''\r\n''` 或 Macintosh 平台上的 `''\r''`）。再次强调，使用指定换行符打开文件可以防止这种情况。'
- en: '`writelines` is something of a misnomer because it doesn’t necessarily write
    lines; it takes a list of strings as an argument and writes them, one after the
    other, to the given `file` object without writing newlines. If the strings in
    the list end with newlines, they’re written as lines; otherwise, they’re effectively
    concatenated in the file. But `writelines` is a precise inverse of `readlines`
    in that it can be used on the list returned by `readlines` to write a file identical
    to the file `readlines` read from. Assuming that myfile.txt exists and is a text
    file, this bit of code creates an exact copy of myfile.txt called myfile2.txt:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`writelines` 有点名不副实，因为它不一定写入行；它接受一个字符串列表作为参数，并将它们依次写入给定的 `file` 对象，而不写入换行符。如果列表中的字符串以换行符结尾，则它们作为行写入；否则，它们在文件中实际上被连接起来。但
    `writelines` 是 `readlines` 的精确逆操作，因为它可以用在 `readlines` 返回的列表上，以写入与 `readlines`
    读取的文件相同的文件。假设 `myfile.txt` 存在并且是一个文本文件，以下代码创建了一个名为 `myfile2.txt` 的 `myfile.txt`
    的精确副本：'
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 13.4.1\. Using binary mode
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.1\. 使用二进制模式
- en: 'On some occasions, you may want to read all the data in a file into a single
    `bytes` object, especially if the data isn’t a string, and you want to get it
    all into memory so you can treat it as a byte sequence. Or you may want to read
    data from a file as `bytes` objects of a fixed size. You may be reading data without
    explicit newlines, for example, where each line is assumed to be a sequence of
    characters of a fixed size. To do so, use the `read` method. Without any argument,
    this method reads all of a file from the current position and returns that data
    as a `bytes` object. With a single-integer argument, it reads that number of bytes
    (or less, if there isn’t enough data in the file to satisfy the request) and returns
    a `bytes` object of the given size:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望将文件中的所有数据读入一个单独的 `bytes` 对象中，特别是如果数据不是字符串，并且你希望将其全部加载到内存中以便将其作为字节序列处理。或者你可能希望以固定大小的
    `bytes` 对象读取文件中的数据。你可能正在读取没有显式换行符的数据，例如，假设每一行是固定大小的字符序列。为此，请使用 `read` 方法。如果没有提供任何参数，此方法将从当前位置读取文件的全部内容，并返回一个
    `bytes` 对象。使用单个整数参数时，它将读取指定数量的字节（如果文件中没有足够的数据来满足请求，则读取的字节数可能更少），并返回一个给定大小的 `bytes`
    对象：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line opens a file for reading in binary mode, the second line reads
    the first four bytes as a header string, and the third line reads the rest of
    the file as a single piece of data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以二进制模式打开文件进行读取，第二行读取前四个字节作为标题字符串，第三行将文件的其余部分作为单个数据读取。
- en: Keep in mind that files open in binary mode deal only in bytes, not strings.
    To use the data as strings, you must decode any `bytes` objects to `string` objects.
    This point is often important in dealing with network protocols, where data streams
    often behave as files but need to be interpreted as bytes, not strings.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以二进制模式打开的文件只处理字节，而不是字符串。要使用数据作为字符串，你必须将任何`bytes`对象解码为`string`对象。在处理网络协议时，这一点通常很重要，因为数据流通常表现为文件，但需要被解释为字节，而不是字符串。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Quick Check
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查
- en: What is the significance of adding a `"b"` to the file open mode string, as
    in `open("file", "wb")`?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件打开模式字符串中添加一个`"b"`（如`open("file", "wb")`）有什么意义？
- en: Suppose that you want to open a file named `myfile.txt` and write additional
    data on the end of it. What command would you use to open `myfile.txt`? What command
    would you use to reopen the file to read from the beginning?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想打开一个名为`myfile.txt`的文件并在其末尾写入附加数据。你将使用什么命令来打开`myfile.txt`？你将使用什么命令来重新打开文件以从头读取？
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.5\. Reading and writing with pathlib
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5\. 使用pathlib进行读写
- en: 'In addition to its path-manipulation powers discussed in [chapter 12](kindle_split_023.html#ch12),
    a `Path` object can be used to read and write text and binary files. This capability
    can be convenient because no open or close is required, and separate methods are
    used for text and binary operations. One limitation, however, is that you have
    no way to append by using `Path` methods, because writing replaces any existing
    content:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在第12章中讨论的路径操作功能外，`Path`对象还可以用于读取和写入文本和二进制文件。这种能力可能很方便，因为不需要打开或关闭文件，并且使用不同的方法进行文本和二进制操作。然而，有一个限制，那就是你不能使用`Path`方法进行追加，因为写入会替换任何现有内容：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 13.6\. Screen input/output and redirection
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6\. 屏幕输入/输出和重定向
- en: 'You can use the built-in `input` method to prompt for and read an input string:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置的`input`方法提示并读取输入字符串：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The prompt line is optional, and the newline at the end of the input line is
    stripped off. To read in numbers by using `input`, you need to explicitly convert
    the string that `input` returns to the correct number type. The following example
    uses `int`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 提示行是可选的，输入行末尾的换行符被删除。要使用`input`读取数字，你需要显式地将`input`返回的字符串转换为正确的数字类型。以下示例使用`int`：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`input` writes its prompt to the *standard output* and reads from the *standard
    input*. Lower-level access to these and *standard error* can be obtained by using
    the `sys` module, which has `sys.stdin`, `sys.stdout`, and `sys.stderr` attributes.
    These attributes can be treated as specialized `file` objects.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`将它的提示写入到*标准输出*并从*标准输入*读取。可以通过使用`sys`模块来获得对这些和*标准错误*的更低级访问，该模块具有`sys.stdin`、`sys.stdout`和`sys.stderr`属性。这些属性可以被视为专门的`file`对象。'
- en: 'For `sys.stdin`, you have the `read`, `readline`, and `readlines` methods.
    For `sys.stdout` and `sys.stderr`, you can use the standard `print` function as
    well as the `write` and `writelines` methods, which operate as they do for other
    `file` objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`sys.stdin`，你有`read`、`readline`和`readlines`方法。对于`sys.stdout`和`sys.stderr`，你可以使用标准的`print`函数以及`write`和`writelines`方法，它们的作用方式与其他`file`对象相同：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* sys.stdout.write returns the number of characters written.**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* sys.stdout.write返回写入的字符数。**'
- en: 'You can redirect standard input to read from a file. Similarly, standard output
    or standard error can be set to write to files and then programmatically restored
    to their original values by using `sys.__stdin__`, `sys.__stdout__`, and `sys.__stderr__`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将标准输入重定向到从文件中读取。同样，可以将标准输出或标准错误设置为写入文件，然后使用`sys.__stdin__`、`sys.__stdout__`和`sys.__stderr__`程序性地恢复它们的原始值：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* After this line outfile.txt contains two lines:** **A first line** **A
    second line**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在此行之后，输出文件`outfile.txt`包含两行：** **第一行** **第二行**'
- en: '***2* outfile.txt now contains three lines:** **A first line** **A second line**
    **A line from the print function**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输出文件`outfile.txt`现在包含三行：** **第一行** **第二行** **来自打印函数的行**'
- en: 'The `print` function also can be redirected to any file without changing standard
    output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`函数也可以重定向到任何文件，而不会改变标准输出：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* outfile.txt contains:** **A first line** **A second line**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 输出文件`outfile.txt`包含：** **第一行** **第二行**'
- en: While the standard output is redirected, you receive prompts and tracebacks
    from errors but no other output. If you’re using IDLE, these examples using `sys.__
    stdout__` won’t work as indicated; you have to use the interpreter’s interactive
    mode directly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在重定向标准输出时，你会收到提示和错误跟踪，但没有其他输出。如果你使用 IDLE，这些使用 `sys.__ stdout__` 的示例不会按指示工作；你必须直接使用解释器的交互模式。
- en: You’d normally use this technique when you’re running from a script or program.
    But if you’re using the interactive mode on Windows, you may want to temporarily
    redirect standard output to capture what might otherwise scroll off the screen.
    The short module shown here implements a set of functions that provides this capability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会在运行脚本或程序时使用这种技术。但是，如果你在 Windows 上使用交互模式，你可能想暂时将标准输出重定向以捕获可能否则会滚动到屏幕上的内容。这里展示的简短模块实现了一组提供这种功能的函数。
- en: Listing 13.1\. File mio.py
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1\. 文件 mio.py
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `capture_output()` redirects standard output to a file that defaults to
    `"capture_file.txt"`. The function `restore_output()` restores standard output
    to the default. Assuming `capture_output` hasn’t been executed, `print_file()`
    prints this file to the standard output, and `clear_file()` clears its current
    contents.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`capture_output()` 将标准输出重定向到默认为 `"capture_file.txt"` 的文件。函数 `restore_output()`
    将标准输出恢复到默认状态。假设 `capture_output` 没有被执行，`print_file()` 将此文件打印到标准输出，而 `clear_file()`
    清除其当前内容。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Redirecting input and output'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：重定向输入和输出
- en: Write some code to use the mio.py module in [listing 13.1](#ch13ex01) to capture
    all the print output of a script to a file named myfile.txt, reset the standard
    output to the screen, and print that file to screen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些代码来使用 [列表 13.1](#ch13ex01) 中的 mio.py 模块，将脚本的全部打印输出捕获到名为 myfile.txt 的文件中，将标准输出重置到屏幕，并将该文件打印到屏幕上。
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 13.7\. Reading structured binary data with the struct module
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.7\. 使用 `struct` 模块读取结构化二进制数据
- en: Generally speaking, when working with your own files, you probably don’t want
    to read or write binary data in Python. For very simple storage needs, it’s usually
    best to use text or bytes input and output. For more sophisticated applications,
    Python provides the ability to easily read or write arbitrary Python objects (*pickling*,
    described in [section 13.8](#ch13lev1sec8)). This ability is much less error-prone
    than directly writing and reading your own binary data and is highly recommended.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，当你处理自己的文件时，你可能不希望在 Python 中读取或写入二进制数据。对于非常简单的存储需求，通常最好使用文本或字节输入和输出。对于更复杂的应用，Python
    提供了轻松读取或写入任意 Python 对象的能力（称为 *pickling*，在 [第 13.8 节](#ch13lev1sec8) 中描述）。这种能力比直接编写和读取自己的二进制数据要少出错，并且强烈推荐。
- en: 'But there’s at least one situation in which you’ll likely need to know how
    to read or write binary data: when you’re dealing with files that are generated
    or used by other programs. This section describes how to do this by using the
    `struct` module. Refer to the Python reference documentation for more details.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但至少有一种情况下，你可能会需要知道如何读取或写入二进制数据：当你处理由其他程序生成或使用的文件时。本节描述了如何使用 `struct` 模块来完成这项工作。有关更多详细信息，请参阅
    Python 参考文档。
- en: As you’ve seen, Python supports explicit binary input or output by using bytes
    instead of strings if you open the file in binary mode. But because most binary
    files rely on a particular structure to help parse the values, writing your own
    code to read and split them into variables correctly is often more work than it’s
    worth. Instead, you can use the standard `struct` module to permit you to treat
    those strings as formatted byte sequences with some specific meaning.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python 支持通过使用字节而不是字符串来显式地支持二进制输入或输出，如果你以二进制模式打开文件。但是，由于大多数二进制文件依赖于特定的结构来帮助解析值，因此编写自己的代码来正确地读取和分割它们到变量中通常比它值得的工作要多。相反，你可以使用标准的
    `struct` 模块，允许你将这些字符串视为具有特定意义的格式化字节序列。
- en: Assume that you want to read in a binary file called data, containing a series
    of records generated by a C program. Each record consists of a C short integer,
    a C double float, and a sequence of four characters that should be taken as a
    four-character string. You want to read this data into a Python list of tuples,
    with each tuple containing an integer, a floating-point number, and a string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要读取一个名为 data 的二进制文件，该文件包含由 C 程序生成的记录序列。每个记录由一个 C 短整数、一个 C 双精度浮点数和一系列四个字符组成，这些字符应被视为一个四字符字符串。你希望将这些数据读取到
    Python 的元组列表中，每个元组包含一个整数、一个浮点数和一个字符串。
- en: The first thing to do is define a *format string* understandable to the `struct`
    module, which tells the module how the data in one of your records is packed.
    The format string uses characters meaningful to `struct` to indicate what type
    of data is expected where in a record. The character `'h'`, for example, indicates
    the presence of a single C short integer, and the character `'d'` indicates the
    presence of a single C double-precision floating-point number. Not surprisingly,
    `'s'` indicates the presence of a string. Any of these may be preceded by an integer
    to indicate the number of values; in this case, `'4s'` indicates a string consisting
    of four characters. For your records, the appropriate format string is therefore
    `'hd4s'`. `struct` understands a wide range of numeric, character, and string
    formats. See the *Python Library Reference* for details.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是定义一个`struct`模块能理解的*格式字符串*，它告诉模块你的记录中的数据是如何打包的。格式字符串使用对`struct`有意义的字符来指示记录中预期的数据类型。例如，字符`'h'`表示存在单个C短整型，而字符`'d'`表示存在单个C双精度浮点数。不出所料，`'s'`表示存在字符串。这些中的任何一个都可以由一个整数前缀，表示值的数量；在这种情况下，`'4s'`表示由四个字符组成的字符串。因此，对于你的记录，适当的格式字符串是`'hd4s'`。`struct`理解广泛的数字、字符和字符串格式。有关详细信息，请参阅*Python库参考*。
- en: Before you start reading records from your file, you need to know how many bytes
    to read at a time. Fortunately, `struct` includes a `calcsize` function, which
    takes your format string as an argument and returns the number of bytes used to
    contain data in such a format.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始从你的文件中读取记录之前，你需要知道每次读取多少字节。幸运的是，`struct`包含一个`calcsize`函数，它接受你的格式字符串作为参数，并返回用于包含这种格式的数据的字节数。
- en: 'To read each record, you use the `read` method described earlier in this chapter.
    Then the `struct.unpack` function conveniently returns a tuple of values by parsing
    a read record according to your format string. The program to read your binary
    data file is remarkably simple:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取每条记录，你使用本章前面描述的`read`方法。然后`struct.unpack`函数会根据你的格式字符串解析读取的记录，方便地返回一个值的元组。读取你的二进制数据文件的程序非常简单：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Reads in a single record**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 读取单个记录**'
- en: '***3* Unpacks record into a tuple; appends to results**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将记录解包到元组中；将结果添加到其中**'
- en: If the record is empty, you’re at the end of the file, so you quit the loop
    ***2***. Note that there’s no checking for file consistency; if the last record
    is an odd size, the `struct.unpack` function raises an error.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录为空，那么你已到达文件末尾，因此退出循环***2***。请注意，这里没有检查文件一致性；如果最后一个记录的大小是奇数，`struct.unpack`函数会引发错误。
- en: 'As you may already have guessed, `struct` also provides the ability to take
    Python values and convert them to packed byte sequences. This conversion is accomplished
    through the `struct.pack` function, which is almost, but not quite, an inverse
    of `struct.unpack`. The *almost* comes from the fact that whereas `struct.unpack`
    returns a tuple of Python values, `struct.pack` doesn’t take a tuple of Python
    values; rather, it takes a format string as its first argument and then enough
    additional arguments to satisfy the format string. To produce a binary record
    of the form used in the previous example, you might do something like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测，`struct`还提供了将Python值转换为打包字节的序列的能力。这种转换是通过`struct.pack`函数完成的，它几乎，但不是完全，是`struct.unpack`的逆操作。*几乎*是因为`struct.unpack`返回一个Python值的元组，而`struct.pack`不接收Python值的元组；相反，它接收一个格式字符串作为其第一个参数，然后接收足够多的额外参数以满足格式字符串。为了生成与前面示例中使用的格式相同的二进制记录，你可能做如下操作：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`struct` gets even better; you can insert other special characters into the
    format string to indicate that data should be read/written in big-endian, little-endian,
    or machine-native-endian format (default is machine-native) and to indicate that
    things like a C short integer should be sized either as native to the machine
    (the default) or as standard C sizes. If you need these features, it’s nice to
    know that they exist. See the *Python Library Reference* for details.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`功能更强大；你可以在格式字符串中插入其他特殊字符，以指示数据应以大端、小端或机器本地端格式（默认为机器本地）读取/写入，以及指示像C短整型这样的数据应按机器本地（默认）或标准C大小来设置大小。如果你需要这些功能，知道它们存在是很好的。有关详细信息，请参阅*Python库参考*。'
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: struct'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：struct
- en: What use cases can you think of in which the struct module would be useful for
    either reading or writing binary data?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到哪些使用场景，其中`struct`模块对读取或写入二进制数据是有用的？
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.8\. Pickling objects files
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.8\. 序列化对象文件
- en: Python can write any data structure into a file, read that data structure back
    out of a file, and re-create it with just a few commands. This capability is unusual
    but can be useful, because it can save you many pages of code that do nothing
    but dump the state of a program into a file (and can save a similar amount of
    code that does nothing but read that state back in).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以将任何数据结构写入文件，从文件中读取该数据结构，并使用几个命令重新创建它。这种能力不同寻常，但可能很有用，因为它可以节省你许多页面的代码，这些代码只是将程序状态保存到文件中（并且可以节省同样数量的代码，这些代码只是读取该状态）。
- en: 'Python provides this capability via the `pickle` module. Pickling is powerful
    but simple to use. Assume that the entire state of a program is held in three
    variables: `a`, `b`, and `c`. You can save this state to a file called state as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过 `pickle` 模块提供这种能力。序列化功能强大但使用简单。假设程序的全部状态都保存在三个变量 `a`、`b` 和 `c` 中。你可以将此状态保存到名为
    `state` 的文件中，如下所示：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It doesn’t matter what was stored in `a`, `b`, and `c`. The content might be
    as simple as numbers or as complex as a list of dictionaries containing instances
    of user-defined classes. `pickle.dump` saves everything.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无论存储在 `a`、`b` 和 `c` 中的内容是什么，内容可能只是数字，也可能非常复杂，如包含用户定义类实例的字典列表。`pickle.dump` 会保存一切。
- en: Now, to read that data back in on a later run of the program, just write
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在程序稍后的运行中读取这些数据，只需编写
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Any data that was previously in the variables `a`, `b`, or `c` is restored to
    them by `pickle.load`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle.load` 会将之前存储在变量 `a`、`b` 或 `c` 中的任何数据恢复到这些变量中。'
- en: The `pickle` module can store almost anything in this manner. It can handle
    lists, tuples, numbers, strings, dictionaries, and just about anything made up
    of these types of objects, which includes all class instances. It also handles
    shared objects, cyclic references, and other complex memory structures correctly,
    storing shared objects only once and restoring them as shared objects, not as
    identical copies. But code objects (what Python uses to store byte-compiled code)
    and system resources (like files or sockets) can’t be pickled.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle` 模块可以以这种方式存储几乎任何东西。它可以处理列表、元组、数字、字符串、字典以及由这些类型对象组成的几乎所有东西，包括所有类实例。它还可以正确处理共享对象、循环引用和其他复杂的内存结构，只存储共享对象一次，并将它们作为共享对象恢复，而不是作为相同的副本。但是代码对象（Python用来存储字节编译代码的东西）和系统资源（如文件或套接字）不能被序列化。'
- en: 'More often than not, you won’t want to save your entire program state with
    `pickle`. Most applications can have multiple documents open at one time, for
    example. If you saved the entire state of the program, you would effectively save
    all open documents in one file. An easy and effective way of saving and restoring
    only data of interest is to write a save function that stores all data you want
    to save into a dictionary and then uses `pickle` to save the dictionary. Then
    you can use a complementary restore function to read the dictionary back in (again
    using `pickle`) and to assign the values in the dictionary to the appropriate
    program variables. This technique also has the advantage that there’s no possibility
    of reading values back in an incorrect order—that is, an order different from
    the order in which the values were stored. Using this approach with the previous
    example, you get code looking something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，你不会想要使用 `pickle` 来保存整个程序状态。例如，大多数应用程序可以同时打开多个文档。如果你保存了整个程序状态，实际上你就是在同一个文件中保存了所有打开的文档。保存和恢复感兴趣数据的简单有效方法之一是编写一个保存函数，该函数将所有想要保存的数据存储到一个字典中，然后使用
    `pickle` 来保存这个字典。然后你可以使用一个互补的恢复函数来读取这个字典（再次使用 `pickle`），并将字典中的值分配给适当的程序变量。这种技术还有一个优点，那就是没有可能以错误的顺序读取值——也就是说，与存储值的顺序不同的顺序。使用这种方法与前面的示例相结合，你得到的代码看起来可能像这样：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example is somewhat contrived. You probably won’t be saving the state of
    the top-level variables of your interactive mode very often.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有些牵强。你可能不会经常保存交互模式中顶层变量的状态。
- en: A real-life application is an extension of the cache example given in [chapter
    7](kindle_split_018.html#ch07). In that chapter, you called a function that performed
    a time-intensive calculation based on its three arguments. During the course of
    a program run, many of your calls to that function ended up using the same set
    of arguments. You were able to obtain a significant performance improvement by
    caching the results in a dictionary, keyed by the arguments that produced them.
    But it was also the case that many sessions of this program were being run many
    times over the course of days, weeks, and months. Therefore, by pickling the cache,
    you can avoid having to start over with every session. Here is a pared-down version
    of the module you might use for this purpose.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际应用是第7章中给出的缓存示例的扩展。[第7章](kindle_split_018.html#ch07)。在第7章中，您调用了一个基于其三个参数进行耗时计算的功能。在程序运行过程中，您对那个函数的许多调用最终都使用了相同的参数集。您通过在字典中缓存结果，以产生它们的参数为键，获得了显著的性能提升。但这种情况也是，这个程序在几天、几周和几个月的时间里被多次运行。因此，通过pickle缓存，您可以避免每次会话都需要从头开始。以下是您可能用于此目的的模块的简化版本。
- en: Listing 13.2\. File sole.py
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2. 文件 sole.py
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Initialization code executes when module loads.**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 初始化代码在模块加载时执行。**'
- en: '***2* Public functions**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 公共函数**'
- en: 'This code assumes that the cache file already exists. If you want to play around
    with it, use the following to initialize the cache file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码假定缓存文件已经存在。如果您想尝试使用它，请使用以下代码初始化缓存文件：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You also, of course, need to replace the comment `# . . . do some time-consuming
    calculations` with an actual calculation. Note that for production code, this
    situation is one in which you’d probably use an absolute pathname for your cache
    file. Also, concurrency isn’t being handled here. If two people run overlapping
    sessions, you end up with only the additions of the last person to save. If this
    situation were an issue, you could limit the overlap window significantly by using
    the dictionary update method in the `save` function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您还需要将注释`# . . . 进行一些耗时的计算`替换为实际的计算。请注意，对于生产代码，这种情况可能是您会使用绝对路径名来指定缓存文件的情况。此外，这里没有处理并发。如果两个人同时运行重叠的会话，您最终只会保存最后一个人的添加。如果这种情况是问题，您可以通过在`save`函数中使用字典更新方法显著限制重叠窗口。
- en: 13.8.1\. Reasons not to pickle
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.8.1. 不应该使用Pickles的原因
- en: 'Although it may make some sense to use a pickled object in the previous scenario,
    you should also be aware of the drawbacks to pickles:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在前一种情况下使用pickle对象可能有些合理，但您也应该意识到pickle的缺点：
- en: Pickling is neither particularly fast nor space-efficient as a means of serialization.
    Even using JSON to store serialized objects is faster and results in smaller files
    on disk.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pickles作为一种序列化手段，既不是特别快也不是特别节省空间。即使使用JSON存储序列化对象，速度也会更快，并且生成的磁盘文件更小。
- en: Pickling isn’t secure, and loading a pickle with malicious content can result
    in the execution of arbitrary code on your machine. Therefore, you should avoid
    pickling if there’s *any* chance at all that the pickle file will be accessible
    to anyone who might alter it.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pickles不安全，加载包含恶意内容的pickle可能会导致在您的机器上执行任意代码。因此，如果pickle文件有可能被任何可能修改它的人访问，您应该避免使用pickle。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Pickles'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：Pickles
- en: 'Think about why a pickle would or would not be a good solution in the following
    use cases:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用例中pickle是否是一个好的解决方案：
- en: Saving some state variables from one run to the next
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一次运行保存一些状态变量到下一次
- en: Keeping a high-score list for a game
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏保存高分列表
- en: Storing usernames and passwords
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储用户名和密码
- en: Storing a large dictionary of English terms
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储大量英语术语的字典
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.9\. Shelving objects
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9. 暂存对象
- en: This topic is somewhat advanced but certainly not difficult. You can think of
    a `shelve` object as being a dictionary that stores its data in a file on disk
    rather than in memory, which means that you still have the convenience of access
    with a key, but you don’t have the limitations of the amount of available RAM.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题有些高级，但绝对不难。您可以将`shelve`对象想象成一个将数据存储在磁盘上的文件而不是内存中的字典，这意味着您仍然可以使用键来访问数据，但您不会受到可用RAM数量的限制。
- en: 'This section is likely of most interest to people whose work involves storing
    or accessing pieces of data in large files, because the Python `shelve` module
    does exactly that: permits the reading or writing of pieces of data in large files
    without reading or writing the entire file. For applications that perform many
    accesses of large files (such as database applications), the savings in time can
    be spectacular. Like the `pickle` module (which it uses), the `shelve` module
    is simple.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本节可能对那些工作涉及在大型文件中存储或访问数据片段的人最有兴趣，因为Python的`shelve`模块正是这样做的：允许在不读取或写入整个文件的情况下读取或写入大型文件中的数据片段。对于执行大量大型文件访问的应用程序（如数据库应用程序），节省的时间可能非常显著。像它所使用的`pickle`模块一样，`shelve`模块很简单。
- en: In this section, you explore this module through an address book. This sort
    of thing usually is small enough that an entire address file can be read in when
    the application is started and written out when the application is done. If you’re
    an extremely friendly sort of person and your address book is too big for this
    example, it would be better to use `shelve` and not worry about it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将通过地址簿来探索这个模块。这类东西通常足够小，以至于整个地址簿可以在应用程序启动时一次性读入，并在应用程序完成后写出。如果你是一个非常友好的人，并且你的地址簿对于这个例子来说太大，那么最好使用`shelve`并且不用担心它。
- en: Assume that each entry in your address book consists of a tuple of three elements,
    giving the first name, phone number, and address of a person. Each entry is indexed
    by the last name of the person the entry refers to. This setup is so simple that
    your application will be an interactive session with the Python shell.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的地址簿中的每个条目由三个元素的元组组成，分别给出一个人的名字、电话号码和地址。每个条目都按条目所引用的人的姓氏进行索引。这种设置非常简单，以至于你的应用程序将是一个与Python壳的交互式会话。
- en: 'First, import the `shelve` module, and open the address book. `shelve.open`
    creates the address book file if it doesn’t exist:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入`shelve`模块，并打开地址簿。`shelve.open`如果不存在，则创建地址簿文件：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now add a couple of entries. Notice that you’re treating the object returned
    by `shelve.open` as a dictionary (although it’s a dictionary that can use only
    strings as keys):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加几个条目。注意，你将`shelve.open`返回的对象当作字典来处理（尽管它是一个只能使用字符串作为键的字典）：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, close the file and end the session:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关闭文件并结束会话：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So what? Well, in that same directory, start Python again, and open the same
    address book:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那又如何呢？好吧，在同一个目录下，再次启动Python，并打开相同的地址簿：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But now, instead of entering something, see whether what you put in before
    is still around:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，不是输入新内容，而是看看你之前输入的内容是否还在：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The addresses file created by `shelve.open` in the first interactive session
    has acted just like a persistent dictionary. The data you entered before was stored
    to disk, even though you did no explicit disk writes. That’s exactly what `shelve`
    does.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次交互式会话中，`shelve.open`创建的地址簿文件就像一个持久的字典。你之前输入的数据已经存储到磁盘上，即使你没有进行显式的磁盘写入。这正是`shelve`所做的事情。
- en: 'More generally, `shelve.open` returns a `shelf` object that permits basic dictionary
    operations, key assignment or lookup, `del`, `in`, and the `keys` method. But
    unlike a normal dictionary, `shelf` objects store their data on disk, not in memory.
    Unfortunately, `shelf` objects do have one significant restriction compared with
    dictionaries: They can use only strings as keys, versus the wide range of key
    types allowable in dictionaries.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，`shelve.open`返回一个`shelf`对象，它允许基本的字典操作，如键赋值或查找、`del`、`in`和`keys`方法。但是，与正常的字典不同，`shelf`对象将数据存储在磁盘上，而不是内存中。不幸的是，与字典相比，`shelf`对象有一个显著的限制：它们只能使用字符串作为键，而字典允许使用广泛的键类型。
- en: It’s important to understand the advantage `shelf` objects give you over dictionaries
    when dealing with large data sets. `shelve.open` makes the file accessible; it
    doesn’t read an entire `shelf` object file into memory. File accesses are done
    only when needed (typically, when an element is looked up), and the file structure
    is maintained in such a manner that lookups are very fast. Even if your data file
    is really large, only a couple of disk accesses will be required to locate the
    desired object in the file, which can improve your program in several ways. The
    program may start faster, because it doesn’t need to read a potentially large
    file into memory. Also, the program may execute faster because more memory is
    available to the rest of the program; thus, less code must be swapped out into
    virtual memory. You can operate on data sets that are otherwise too large to fit
    in memory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`shelf`对象在处理大数据集时相对于字典的优势是很重要的。`shelve.open`使文件可访问；它不会将整个`shelf`对象文件读入内存。文件访问仅在需要时进行（通常，当查找元素时），文件结构以这种方式维护，使得查找非常快速。即使你的数据文件非常大，也只需要几次磁盘访问就可以在文件中定位所需的对象，这可以在几个方面提高你的程序。程序可能启动更快，因为它不需要将可能很大的文件读入内存。此外，程序可能执行得更快，因为更多的内存可供程序的其他部分使用；因此，需要交换到虚拟内存中的代码更少。你可以操作那些否则太大而无法放入内存的数据集。
- en: You have a few restrictions when using the `shelve` module. As previously mentioned,
    `shelf` object keys can be only strings, but any Python object that can be pickled
    can be stored under a key in a `shelf` object. Also, `shelf` objects aren’t suitable
    for multiuser databases because they provide no control for concurrent access.
    Make sure that you close a `shelf` object when you’re finished; closing is sometimes
    required for the changes you’ve made (entries or deletions) to be written back
    to disk.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`shelve`模块时，你有一些限制。如前所述，`shelf`对象键只能是字符串，但任何可以序列化的Python对象都可以存储在`shelf`对象的键下。此外，`shelf`对象不适合多用户数据库，因为它们不提供对并发访问的控制。确保你在完成时关闭`shelf`对象；关闭有时是必需的，以便将你已做的更改（条目或删除）写回磁盘。
- en: As written, the cache example in [listing 13.1](#ch13ex01) is an excellent candidate
    to be handled with shelves. You wouldn’t, for example, have to rely on the user
    to explicitly save their work to the disk. The only possible issue is that you
    wouldn’t have the low-level control when you write back to the file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如其所述，[列表13.1](#ch13ex01)中的缓存示例是使用shelves处理的绝佳候选。例如，你不必依赖用户明确地将他们的工作保存到磁盘上。唯一可能的问题是，当你将数据写回文件时，你不会拥有低级控制。
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Shelve'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：Shelve
- en: Using a `shelf` object looks very much like using a dictionary. In what ways
    is using a `shelf` object different? What disadvantages would you expect in using
    a `shelf` object?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`shelf`对象看起来非常像使用字典。在哪些方面使用`shelf`对象不同？你预计使用`shelf`对象会有哪些缺点？
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 13: Final fixes to wc'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室13：wc的最终修复
- en: If you look at the `man` page for the `wc` utility, you see two command-line
    options that do very similar things. `-c` makes the utility count the bytes in
    the file, and `-m` makes it count characters (which in the case of some Unicode
    characters can be two or more bytes long). In addition, if a file is given, it
    should read from and process that file, but if no file is given, it should read
    from and process `stdin`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`wc`实用程序的`man`页面，你会看到两个执行非常相似任务的命令行选项。`-c`使实用程序计算文件中的字节数，而`-m`使它计算字符数（在某些Unicode字符的情况下，字符可能占用两个或更多字节）。此外，如果提供了文件，它应该从该文件读取并处理，如果没有提供文件，它应该从标准输入读取并处理。
- en: Rewrite your version of the `wc` utility to implement both the distinction between
    bytes and characters and the ability to read from files and standard input.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的`wc`实用程序版本重写，以实现区分字节和字符的功能，并能够从文件和标准输入中读取。
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: File input and output in Python uses various built-in functions to open, read,
    write, and close files.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，文件输入和输出使用各种内置函数来打开、读取、写入和关闭文件。
- en: In addition to reading and writing text, the `struct` module gives you the ability
    to read or write packed binary data.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了读取和写入文本外，`struct`模块还赋予你读取或写入打包的二进制数据的能力。
- en: The `pickle` and `shelve` modules provide simple, safe, and powerful ways of
    saving and accessing arbitrarily complex Python data structures.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pickle`和`shelve`模块提供了简单、安全且强大的方法来保存和访问任意复杂的Python数据结构。'
