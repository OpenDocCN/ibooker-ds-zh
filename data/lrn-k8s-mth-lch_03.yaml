- en: 2 Running containers in Kubernetes with Pods and Deployments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 在Kubernetes中使用Pods和Deployments运行容器
- en: 'Kubernetes runs containers for your application workloads, but the containers
    themselves are not objects you need to work with. Every container belongs to a
    Pod, which is a Kubernetes object for managing one or more containers, and Pods,
    in turn, are managed by other resources. These higher-level resources abstract
    away the details of the container, which powers self-healing applications and
    lets you use a desired-state workflow: you tell Kubernetes what you want to happen,
    and it decides how to make it happen.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为您的应用程序工作负载运行容器，但容器本身不是您需要与之交互的对象。每个容器都属于一个Pod，Pod是Kubernetes对象，用于管理一个或多个容器，而Pod反过来由其他资源管理。这些高级资源抽象掉了容器的细节，这为自我修复应用程序提供了动力，并允许您使用期望状态工作流程：您告诉Kubernetes您想要发生什么，然后它决定如何实现。
- en: 'In this chapter, we’ll get started with the basic building blocks of Kubernetes:
    Pods, which run containers, and Deployments, which manage Pods. We’ll use a simple
    web app for the exercises, and you’ll get hands-on experience using the Kubernetes
    command-line tool to manage applications and using the Kubernetes YAML specification
    to define applications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从Kubernetes的基本构建块开始：Pods，它们运行容器，以及Deployments，它们管理Pods。我们将使用一个简单的Web应用程序进行练习，您将通过使用Kubernetes命令行工具来管理应用程序和使用Kubernetes
    YAML规范来定义应用程序来获得实践经验。
- en: 2.1 How Kubernetes runs and manages containers
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 Kubernetes如何运行和管理容器
- en: 'A container is a virtualized environment that typically runs a single application
    component. Kubernetes wraps the container in another virtualized environment:
    the Pod. A Pod is a unit of compute, which runs on a single node in the cluster.
    The Pod has its own virtual IP address, which is managed by Kubernetes, and Pods
    in the cluster can communicate with other Pods over that virtual network, even
    if they’re running on different nodes.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个虚拟化环境，通常运行单个应用程序组件。Kubernetes将容器包装在另一个虚拟化环境中：Pod。Pod是一个计算单元，在集群的单个节点上运行。Pod有自己的虚拟IP地址，由Kubernetes管理，集群中的Pod可以通过该虚拟网络与其他Pod进行通信，即使它们运行在不同的节点上。
- en: You normally run a single container in a Pod, but you can run multiple containers
    in one Pod, which opens up some interesting deployment options. All the containers
    in a Pod are part of the same virtual environment, so they share the same network
    address and can communicate using localhost. Figure 2.1 shows the relationship
    between containers and Pods.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常在Pod中运行单个容器，但您可以在一个Pod中运行多个容器，这为一些有趣的部署选项打开了大门。Pod中的所有容器都是同一虚拟环境的一部分，因此它们共享相同的网络地址，可以使用localhost进行通信。图2.1显示了容器和Pod之间的关系。
- en: '![](../Images/2-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-1.jpg)'
- en: Figure 2.1 Containers run inside Pods. You manage the Pods, and the Pods manage
    the containers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 容器在Pod内运行。您管理Pod，Pod管理容器。
- en: This business of multicontainer Pods is a bit much to introduce this early on,
    but if I glossed over it and talked only about single-container Pods, you’d be
    rightfully asking why Kubernetes uses Pods at all instead of just containers.
    Let’s run a Pod and see what it looks like to work with this abstraction over
    containers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这关于多容器Pod的业务在早期介绍可能有点多，但如果我略过了它，只谈论单容器Pod，您会合理地询问为什么Kubernetes使用Pod而不是仅仅使用容器。让我们运行一个Pod，看看与容器抽象交互是什么样的。
- en: 'Try it now You can run a simple Pod using the Kubernetes command line without
    needing a YAML specification. The syntax is similar to running a container using
    Docker: you state the container image you want to use and any other parameters
    to configure the Pod behavior.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 您可以使用Kubernetes命令行运行一个简单的Pod，而无需YAML规范。语法类似于使用Docker运行容器：您指定要使用的容器镜像以及任何其他配置Pod行为的参数。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see my output in figure 2.2, where I’ve abridged the response from the
    final `describe` `pod` command. When you run it yourself, you’ll see a whole lot
    more obscure-sounding information in there, like node selectors and tolerations.
    They’re all part of the Pod specification, and Kubernetes has applied default
    values for everything that we didn’t specify in the `run` command.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图2.2中看到我的输出，其中我简化了来自最终`describe pod`命令的响应。当您自己运行时，您会在其中看到很多听起来更晦涩的信息，比如节点选择器和容忍度。它们都是Pod规范的一部分，Kubernetes为我们在`run`命令中未指定的所有内容都应用了默认值。
- en: '![](../Images/2-2.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-2.jpg)'
- en: Figure 2.2 Running the simplest of Pods and checking its status using kubectl
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 运行最简单的Pod并使用kubectl检查其状态
- en: Now you have a single application container in your cluster, running inside
    a single Pod. If you’re used to working with Docker, this is a familiar workflow,
    and it turns out that Pods are not as complicated as they might seem. The majority
    of your Pods will run single containers (until you start to explore more advanced
    options), and so you can effectively think of the Pod as the mechanism Kubernetes
    uses to run a container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的集群中有一个单独的应用容器，运行在单个Pod内部。如果你习惯于使用Docker，这将是一个熟悉的流程，而且事实证明，Pod并没有看起来那么复杂。你的大多数Pod将运行单个容器（直到你开始探索更高级的选项），因此你可以有效地将Pod视为Kubernetes用来运行容器的机制。
- en: 'Kubernetes doesn’t really run containers, though—it passes the responsibility
    for that to the container runtime installed on the node, which could be Docker
    or containerd or something more exotic. That’s why the Pod is an abstraction:
    it’s the resource that Kubernetes manages, whereas the container is managed by
    something outside of Kubernetes. You can get a sense of that by using kubectl
    to fetch specific information about the Pod.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kubernetes实际上并不运行容器，但它将这项责任转交给节点上安装的容器运行时，这可能是Docker、containerd或更复杂的其他东西。这就是为什么Pod是一个抽象：它是Kubernetes管理的资源，而容器则由Kubernetes之外的东西管理。你可以通过使用kubectl获取有关Pod的特定信息来感受到这一点。
- en: Try it now Kubectl returns basic information from the `get` `pod` command, but
    you can request more by applying an output parameter. You can name individual
    fields you want to see in the output parameter, and you can use the JSONPath query
    language or Go templates for complex output.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 Kubectl通过`get pod`命令返回基本信息，但你可以通过应用输出参数来请求更多信息。你可以在输出参数中命名你想要看到的单个字段，并且可以使用JSONPath查询语言或Go模板来获取复杂输出。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: My output is shown in figure 2.3\. I’m running a single-node Kubernetes cluster
    using Docker Desktop on Windows. The `node` `IP` in the second command is the
    IP address of my Linux VM, and the `Pod` `IP` is the virtual address of the Pod
    in the cluster. The `container` `ID` returned in the third command is prefixed
    by the name of the container runtime; mine is Docker.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出显示在图2.3中。我正在使用Windows上的Docker Desktop运行一个单节点Kubernetes集群。第二个命令中的`node IP`是我的Linux
    VM的IP地址，而`Pod IP`是集群中Pod的虚拟地址。第三个命令返回的`container ID`前面带有容器运行时的名称；我的容器运行时是Docker。
- en: '![](../Images/2-3.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-3.jpg)'
- en: Figure 2.3 Kubectl has many options for customizing its output for Pods and
    other objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 Kubectl为Pod和其他对象提供了许多自定义输出的选项。
- en: That may have felt like a pretty dull exercise, but it comes with two important
    takeaways. The first is that kubectl is a hugely powerful tool—as your main point
    of contact with Kubernetes, you’ll be spending a lot of time with it, and it’s
    worth getting a solid understanding of what it can do. Querying the output from
    commands is a useful way to see the information you care about, and because you
    can access all the details of the resource, it’s great for automation too. The
    second takeaway is a reminder that Kubernetes does not run containers—the container
    ID in the Pod is a reference to another system that runs containers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉像是一项相当枯燥的练习，但它带来了两个重要的启示。第一个是kubectl是一个非常强大的工具——作为你与Kubernetes的主要接触点，你将花费大量时间与之打交道，因此了解它能够做什么是非常有价值的。查询命令的输出是一种查看你关心的信息的有用方式，而且因为你可以访问资源的所有详细信息，它对于自动化也非常有用。第二个启示是提醒我们，Kubernetes并不运行容器——Pod中的容器ID是另一个运行容器的系统的引用。
- en: Pods are allocated to one node when they’re created, and it’s that node’s responsibility
    to manage the Pod and its containers. It does that by working with the container
    runtime using a known API called the Container Runtime Interface (CRI). The CRI
    lets the node manage containers in the same way for all the different container
    runtimes. It uses a standard API to create and delete containers and to query
    their state. While the Pod is running, the node works with the container runtime
    to ensure the Pod has all the containers it needs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pod创建时，它们会被分配到一个节点上，并且管理Pod及其容器的责任属于该节点。它通过使用一个名为容器运行时接口（CRI）的已知API与容器运行时协作来完成这项工作。CRI允许节点以相同的方式管理所有不同的容器运行时中的容器。它使用标准API来创建和删除容器，并查询它们的状态。当Pod运行时，节点会与容器运行时协作，确保Pod拥有它需要的所有容器。
- en: Try it now All Kubernetes environments use the same CRI mechanism to manage
    containers, but not all container runtimes allow you to access containers outside
    of Kubernetes. This exercise shows you how a Kubernetes node keeps its Pod containers
    running, but you’ll only be able to follow it if you’re using Docker as your container
    runtime.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 所有Kubernetes环境都使用相同的CRI机制来管理容器，但并非所有容器运行时都允许您访问Kubernetes之外的容器。这个练习向您展示了Kubernetes节点如何保持Pod容器运行，但您只有在使用Docker作为容器运行时的情况下才能理解它。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see from figure 2.4 that Kubernetes reacted when I deleted my Docker
    container. For an instant, the Pod had zero containers, but Kubernetes immediately
    created a replacement to repair the Pod and bring it back to the correct state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从图2.4中看到，当我在删除我的Docker容器时，Kubernetes做出了反应。一瞬间，Pod中的容器数量为零，但Kubernetes立即创建了一个替换容器来修复Pod并将其恢复到正确状态。
- en: It’s the abstraction from containers to Pods that lets Kubernetes repair issues
    like this. A failed container is a temporary fault; the Pod still exists, and
    the Pod can be brought back up to spec with a new container. This is just one
    level of self-healing that Kubernetes provides, with further abstractions on top
    of Pods giving your apps even more resilience.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是从容器到Pod的抽象让Kubernetes能够修复这类问题。失败的容器是一个暂时性的故障；Pod仍然存在，并且可以通过一个新的容器将其恢复到规范状态。这只是Kubernetes提供的自我修复的一个层次，在Pod之上还有更多的抽象，这为您的应用程序提供了更多的弹性。
- en: '![](../Images/2-4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-4.jpg)'
- en: Figure 2.4 Kubernetes makes sure Pods have all the containers they need.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 Kubernetes确保Pod拥有所有需要的容器。
- en: One of those abstractions is the Deployment, which we’ll look at in the next
    section. Before we move on, let’s see what’s actually running in that Pod. It’s
    a web application, but you can’t browse to it because we haven’t configured Kubernetes
    to route network traffic to the Pod. We can get around that using another feature
    of kubectl.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个抽象是Deployment，我们将在下一节中探讨。在继续之前，让我们看看Pod中实际运行的是什么。它是一个Web应用程序，但您无法浏览到它，因为我们还没有配置Kubernetes将网络流量路由到Pod。我们可以使用kubectl的另一个功能来解决这个问题。
- en: Try it now Kubectl can forward traffic from a node to a Pod, which is a quick
    way to communicate with a Pod from outside the cluster. You can listen on a specific
    port on your machine—which is the single node in your cluster—and forward traffic
    to the application running in the Pod.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 Kubectl可以将节点流量转发到Pod，这是一种从集群外部与Pod进行通信的快捷方式。您可以在您的机器上的特定端口上监听——这是您集群中的单个节点——并将流量转发到Pod中运行的应用程序。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: My output is shown in figure 2.5, and you can see it’s a pretty basic website
    (don’t contact me for web design consultancy). The web server and all the content
    are packaged into a container image on Docker Hub, which is publicly available.
    All the CRI-compatible container runtimes can pull the image and run a container
    from it, so I know that for whichever Kubernetes environment you’re using, when
    you run the app, it will work in the same way for you as it does for me.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出如图2.5所示，您可以看到它是一个非常基础的网站（不要联系我进行网页设计咨询）。Web服务器和所有内容都打包在Docker Hub上的容器镜像中，这是公开可用的。所有兼容CRI的容器运行时都可以拉取这个镜像并从中运行容器，所以我知道，无论您使用的是哪种Kubernetes环境，当您运行应用程序时，它将以与我相同的方式为您工作。
- en: '![](../Images/2-5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-5.jpg)'
- en: Figure 2.5 This app isn’t configured to receive network traffic, but kubectl
    can forward it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 此应用程序未配置为接收网络流量，但kubectl可以转发它。
- en: Now we have a good handle on the Pod, which is the smallest unit of compute
    in Kubernetes. You need to understand how that all works, but the Pod is a primitive
    resource, and in normal use, you’d never run a Pod directly; you’d always create
    a controller object to manage the Pod for you.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地掌握了Pod，这是Kubernetes中最小的计算单元。您需要了解这一切是如何工作的，但Pod是一个原始资源，在正常使用中，您永远不会直接运行Pod；您总是会创建一个控制器对象来为您管理Pod。
- en: 2.2 Running Pods with controllers
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用控制器运行Pod
- en: It’s only the second section of the second chapter, and we’re already on to
    a new Kubernetes object, which is an abstraction over other objects. Kubernetes
    does get complicated quickly, but that complexity is a necessary part of such
    a powerful and configurable system. The learning curve is the entrance fee for
    access to a world-class container platform.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是第二章的第二部分，我们已经开始接触到一个新的Kubernetes对象，它是对其他对象的抽象。Kubernetes确实很快就会变得复杂，但这样的复杂性是这样一个强大且可配置的系统所必需的。学习曲线是进入世界级容器平台的入场费。
- en: Pods are too simple to be useful on their own; they are isolated instances of
    an application, and each Pod is allocated to one node. If that node goes offline,
    the Pod is lost, and Kubernetes does not replace it. You could try to get high
    availability by running several Pods, but there’s no guarantee Kubernetes won’t
    run them all on the same node. Even if you do get Pods spread across several nodes,
    you need to manage them yourself. Why do that when you have an orchestrator that
    can manage them for you?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Pod本身过于简单，单独使用没有太大用处；它们是应用程序的隔离实例，每个Pod都分配给一个节点。如果该节点离线，Pod就会丢失，Kubernetes不会替换它。你可以尝试通过运行多个Pod来获得高可用性，但无法保证Kubernetes不会将它们全部运行在同一个节点上。即使你确实将Pod分散在多个节点上，你也需要自己管理它们。为什么要在有可以为你管理它们的编排器的情况下还这么做呢？
- en: That’s where controllers come in. A *controller* is a Kubernetes resource that
    manages other resources. It works with the Kubernetes API to watch the current
    state of the system, compares that to the desired state of its resources, and
    makes any changes necessary. Kubernetes has many controllers, but the main one
    for managing Pods is the Deployment, which solves the problems I’ve just described.
    If a node goes offline and you lose a Pod, the Deployment creates a replacement
    Pod on another node; if you want to scale your Deployment, you can specify how
    many Pods you want, and the Deployment controller runs them across many nodes.
    Figure 2.6 shows the relationship between Deployments, Pods, and containers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，控制器发挥了作用。*控制器*是Kubernetes资源，用于管理其他资源。它与Kubernetes API协同工作，监视系统的当前状态，将其与资源的期望状态进行比较，并做出必要的更改。Kubernetes有许多控制器，但用于管理Pod的主要控制器是Deployment，它解决了我刚才描述的问题。如果一个节点离线并且你丢失了一个Pod，Deployment将在另一个节点上创建一个替换Pod；如果你想扩展你的Deployment，你可以指定你想要的Pod数量，Deployment控制器将在多个节点上运行它们。图2.6显示了Deployment、Pod和容器之间的关系。
- en: '![](../Images/2-6.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-6.jpg)'
- en: Figure 2.6 Deployment controllers manage Pods, and Pods manage containers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 部署控制器管理Pod，Pod管理容器。
- en: You can create Deployment resources with kubectl, specifying the container image
    you want to run and any other configuration for the Pod. Kubernetes creates the
    Deployment, and the Deployment creates the Pod.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用kubectl创建Deployment资源，指定你想要运行的容器镜像和Pod的任何其他配置。Kubernetes创建Deployment，Deployment创建Pod。
- en: Try it now Create another instance of the web application, this time using a
    Deployment. The only required parameters are the name for the Deployment and the
    image to run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：创建另一个Web应用的实例，这次使用Deployment。唯一必需的参数是Deployment的名称和要运行的镜像。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see my output in figure 2.7\. Now you have two Pods in your cluster:
    the original one you created with the kubectl `run` command, and the new one created
    by the Deployment. The Deployment-managed Pod has a name generated by Kubernetes,
    which is the name of the Deployment followed by a random suffix.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图2.7中看到我的输出。现在你的集群中有两个Pod：你使用kubectl `run`命令创建的原始Pod，以及由Deployment创建的新Pod。由Deployment管理的Pod有一个由Kubernetes生成的名称，即Deployment的名称后跟一个随机后缀。
- en: '![](../Images/2-7.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-7.jpg)'
- en: Figure 2.7 Create a controller resource, and it creates its own resources-Deployments
    create Pods.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 创建控制器资源，它将创建自己的资源——部署创建Pod。
- en: 'One important thing to realize from this exercise: you created the Deployment,
    but you did not directly create the Pod. The Deployment specification described
    the Pod you wanted, and the Deployment created that Pod. The Deployment is a controller
    that checks with the Kubernetes API to see which resources are running, realizes
    the Pod it should be managing doesn’t exist, and uses the Kubernetes API to create
    it. The exact mechanism doesn’t really matter; you can just work with the Deployment
    and rely on it to create your Pod.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个练习中，你需要意识到的一个重要事情是：你创建了Deployment，但你并没有直接创建Pod。Deployment规范描述了你想要的Pod，Deployment创建了那个Pod。Deployment是一个控制器，它会与Kubernetes
    API核对正在运行的资源，意识到它应该管理的Pod不存在，并使用Kubernetes API创建它。确切的机制并不重要；你只需与Deployment协同工作，并依赖它来创建你的Pod。
- en: How the deployment keeps track of its resources does matter, though, because
    it’s a pattern that Kubernetes uses a lot. Any Kubernetes resource can have labels
    applied that are simple key-value pairs. You can add labels to record your own
    data. For example, you might add a label to a Deployment with the name release
    and the value 20.04 to indicate this Deployment is from the 20.04 release cycle.
    Kubernetes also uses labels to loosely couple resources, mapping the relationship
    between objects like a Deployment and its Pods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然部署如何跟踪其资源确实很重要，因为这是Kubernetes大量使用的模式。任何Kubernetes资源都可以应用标签，这些标签是简单的键值对。你可以添加标签来记录自己的数据。例如，你可能会为部署添加一个名为release的标签，其值为20.04，以指示此部署来自20.04发布周期。Kubernetes还使用标签来松散耦合资源，映射部署和其Pod等对象之间的关系。
- en: 'Try it now The Deployment adds labels to Pods it manages. Use kubectl as follows
    to print the labels the Deployment adds, and then list the Pods that match that
    label:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 部署为它管理的Pod添加标签。使用以下kubectl命令来打印部署添加的标签，然后列出匹配该标签的Pod：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: My output is shown in figure 2.8, where you can see some internals of how the
    resources are configured. Deployments use a template to create Pods, and part
    of that template is a metadata field, which includes the labels for the Pod(s).
    In this case, the Deployment adds a label called *app* with the value *hello-kiamol-2*
    to the Pod. Querying Pods that have a matching label returns the single Pod managed
    by the Deployment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出显示在图2.8中，你可以看到资源配置的一些内部细节。部署使用模板创建Pod，该模板的一部分是元数据字段，它包括Pod的标签。在这种情况下，部署为Pod添加了一个名为*app*的标签，其值为*hello-kiamol-2*。查询具有匹配标签的Pod会返回由部署管理的单个Pod。
- en: '![](../Images/2-8.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-8.jpg)'
- en: Figure 2.8 Deployments add labels when they create Pods, and you can use those
    labels as filters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 部署在创建Pod时添加标签，你可以使用这些标签作为过滤器。
- en: Using labels to identify the relationship between resources is such a core pattern
    in Kubernetes that it’s worth showing a diagram to make sure it’s clear. Resources
    can have labels applied at creation and then added, removed, or edited during
    their lifetime. Controllers use a label selector to identify the resources they
    manage. That can be a simple query matching resources with a particular label,
    as shown in figure 2.9.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签来识别资源之间的关系是Kubernetes中的一个核心模式，值得展示一个图表以确保其清晰。资源可以在创建时应用标签，并在其生命周期内添加、删除或编辑。控制器使用标签选择器来识别它们管理的资源。这可以是一个简单的查询，匹配具有特定标签的资源，如图2.9所示。
- en: '![](../Images/2-9.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-9.jpg)'
- en: Figure 2.9 Controllers identify the resources they manage by using labels and
    selectors.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9控制器通过使用标签和选择器来识别它们管理的资源。
- en: This process is flexible because it means controllers don’t need to maintain
    a list of all the resources they manage; the label selector is part of the controller
    specification, and controllers can find matching resources at any time by querying
    the Kubernetes API. It’s also something you need to be careful with, because you
    can edit the labels for a resource and end up breaking the relationship between
    it and its controller.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程是灵活的，因为它意味着控制器不需要维护它们管理的所有资源的列表；标签选择器是控制器规范的一部分，控制器可以通过查询Kubernetes API在任何时候找到匹配的资源。这也需要你小心处理，因为你可以编辑资源的标签，最终破坏它与控制器之间的关系。
- en: Try it now The Deployment doesn’t have a direct relationship with the Pod it
    created; it only knows there needs to be one Pod with labels that match its label
    selector. If you edit the labels on the Pod, the Deployment no longer recognizes
    it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 部署与其创建的Pod没有直接关系；它只知道需要有一个Pod具有与它的标签选择器匹配的标签。如果你编辑Pod上的标签，部署将不再识别它。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What did you expect to happen? You can see from the output shown in figure 2.10
    that changing the Pod label effectively removes the Pod from the Deployment. At
    that point, the Deployment sees that no Pods that match its label selector exist,
    so it creates a new one. The Deployment has done its job, but by editing the Pod
    directly, you now have an unmanaged Pod.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望发生什么？从图2.10所示的输出中可以看出，更改Pod标签实际上将Pod从部署中移除。此时，部署看到没有匹配其标签选择器的Pod存在，因此它创建了一个新的Pod。部署已经完成了它的任务，但通过直接编辑Pod，你现在有一个未管理的Pod。
- en: '![](../Images/2-10.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-10.jpg)'
- en: Figure 2.10 If you meddle with the labels on a Pod, you can remove it from the
    control of the Deployment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 如果你干涉Pod上的标签，你可以将其从部署的控制中移除。
- en: 'This can be a useful technique in debugging—removing a Pod from a controller
    so you can connect and investigate a problem, while the controller starts a replacement
    Pod, which keeps your app running at the desired scale. You can also do the opposite:
    editing the labels on a Pod to fool a controller into acquiring that Pod as part
    of the set it manages.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一种有用的调试技术——从控制器中移除一个 Pod，以便你可以连接并调查问题，同时控制器启动一个替换 Pod，保持你的应用程序以期望的规模运行。你也可以做相反的事情：编辑
    Pod 的标签，让控制器误以为该 Pod 是它管理的集合的一部分。
- en: Try it now Return the original Pod to the control of the Deployment by setting
    its app label back so it matches the label selector.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 通过设置应用程序标签使其与标签选择器匹配，将原始 Pod 返回到 Deployment 的控制之下。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This exercise effectively reverses the previous exercise, setting the app label
    back to hello-kiamol-2 for the original Pod in the Deployment. Now when the Deployment
    controller checks with the API, it sees two Pods that match its label selector.
    It’s supposed to manage only a single Pod, however, so it deletes one (using a
    set of deletion rules to decide which one). You can see in figure 2.11 that the
    Deployment removed the second Pod and retained the original.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习实际上逆转了之前的练习，将应用程序标签重新设置为 hello-kiamol-2，以便在 Deployment 中的原始 Pod。现在当 Deployment
    控制器通过 API 检查时，它看到两个与它的标签选择器匹配的 Pods。然而，它应该只管理一个 Pod，因此它删除了一个（使用一系列删除规则来决定删除哪一个）。你可以在图
    2.11 中看到 Deployment 删除了第二个 Pod 并保留了原始的。
- en: '![](../Images/2-11.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11](../Images/2-11.jpg)'
- en: Figure 2.11 More label meddling—you can force a Deployment to adopt a Pod if
    the labels match.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11](../Images/2-11.jpg)'
- en: Pods run your application containers, but just like containers, Pods are meant
    to be short-lived. You will usually use a higher-level resource like a Deployment
    to manage Pods for you. Doing so gives Kubernetes a better chance of keeping your
    app running if there are issues with containers or nodes, but ultimately the Pods
    are running the same containers you would run yourself, and the end-user experience
    for your apps will be the same.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 运行你的应用程序容器，但就像容器一样，Pods 的设计目的是短暂的。你通常会使用更高层次的资源，如 Deployment，来为你管理 Pods。这样做可以让
    Kubernetes 在容器或节点出现问题时更好地保持你的应用程序运行，但最终 Pods 运行的是你将运行的相同容器，并且你的应用程序的用户体验将保持不变。
- en: Try it now Kubectl’s `port-forward` command sends traffic to a Pod, but you
    don’t have to find the random Pod name for a Deployment. You can configure the
    port forward on the Deployment resource, and the Deployment selects one of its
    Pods as the target.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 Kubectl 的 `port-forward` 命令将流量发送到 Pod，但你不需要为 Deployment 找到随机的 Pod 名称。你可以在
    Deployment 资源上配置端口转发，并且 Deployment 会选择其 Pod 中的一个作为目标。
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see my output, shown in figure 2.12, of the same app running in a container
    from the same Docker image, but this time, in a Pod managed by a Deployment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我的输出，如图 2.12 所示，同一个应用程序在同一个 Docker 镜像中运行，但这次是在由 Deployment 管理的 Pod 中。
- en: '![](../Images/2-12.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12](../Images/2-12.jpg)'
- en: Figure 2.12 Pods and Deployments are layers on top of containers, but the app
    still runs in a container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.12](../Images/2-12.jpg)'
- en: Pods and Deployments are the only resources we’ll cover in this chapter. You
    can deploy very simple apps by using the kubectl `run` and `create` commands,
    but more complex apps need lots more configuration, and those commands won’t do.
    It’s time to enter the world of Kubernetes YAML.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 和 Deployments 是本章我们将涵盖的唯一资源。你可以通过使用 kubectl 的 `run` 和 `create` 命令来部署非常简单的应用程序，但对于更复杂的应用程序，需要更多的配置，而这些命令无法做到。现在是时候进入
    Kubernetes YAML 的世界了。
- en: 2.3 Defining Deployments in application manifests
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 在应用程序清单中定义 Deployment
- en: Application manifests are one of the most attractive aspects of Kubernetes,
    but also one of the most frustrating. When you’re wading through hundreds of lines
    of YAML trying to find the small misconfiguration that has broken your app, it
    can seem like the API was deliberately written to confuse and irritate you. At
    those times, remember that Kubernetes manifests are a complete description of
    your app, which can be versioned and tracked in source control, and result in
    the same deployment on any Kubernetes cluster.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序清单是 Kubernetes 最吸引人的特性之一，但也是最具挫败感之一。当你正在处理数百行 YAML，试图找到导致你的应用程序崩溃的小错误配置时，可能会觉得
    API 是故意编写来混淆和激怒你的。在这些时候，请记住 Kubernetes 清单是应用程序的完整描述，可以在源代码控制中进行版本控制和跟踪，并在任何 Kubernetes
    集群上产生相同的部署。
- en: Manifests can be written in JSON or YAML; JSON is the native language of the
    Kubernetes API, but YAML is preferred for manifests because it’s easier to read,
    lets you define multiple resources in a single file, and, most important, can
    record comments in the specification. Listing 2.1 is the simplest app manifest
    you can write. It defines a single Pod using the same container image we’ve already
    used in this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 清单可以写成JSON或YAML；JSON是Kubernetes API的本地语言，但YAML是清单的首选，因为它更容易阅读，允许你在单个文件中定义多个资源，最重要的是，可以在规范中记录注释。列表2.1是你能编写的最简单的应用程序清单。它使用我们在本章中已经使用过的相同容器镜像定义了一个单个Pod。
- en: Listing 2.1 pod.yaml, a single Pod to run a single container
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 pod.yaml，一个运行单个容器的单个Pod
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s a lot more information than you need for a kubectl `run` command, but
    the big advantage of the application manifest is that it’s declarative. Kubectl
    `run` and `create` are imperative operations—it’s you telling Kubernetes to do
    something. Manifests are declarative—you tell Kubernetes what you want the end
    result to be, and it goes off and decides what it needs to do to make that happen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这比kubectl `run`命令所需的信息要多得多，但应用程序清单的大优点是它是声明性的。kubectl `run`和`create`是命令式操作——是你告诉Kubernetes做什么。清单是声明性的——你告诉Kubernetes你想要的结果是什么，然后它去决定需要做什么来实现这一点。
- en: Try it now You still use kubectl to deploy apps from manifest files, but you
    use the `apply` command, which tells Kubernetes to apply the configuration in
    the file to the cluster. Run another pod for this chapter’s sample app using a
    YAML file with the same contents as listing 2.1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：你仍然使用kubectl从清单文件部署应用程序，但使用`apply`命令，它告诉Kubernetes将文件中的配置应用到集群中。使用与列表2.1相同内容的YAML文件运行本章示例应用程序的另一个Pod。
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The new Pod works in the same way as a Pod created with the kubectl `run` command:
    it’s allocated to a node, and it runs a container. The output in figure 2.13 shows
    that when I applied the manifest, Kubernetes decided it needed to create a Pod
    to get the current state of the cluster up to my desired state. That’s because
    the manifest specifies a Pod named hello-kiamol-3, and no such Pod existed.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Pod与使用kubectl `run`命令创建的Pod工作方式相同：它被分配到一个节点上，并运行一个容器。图2.13中的输出显示，当我应用清单时，Kubernetes决定需要创建一个Pod来将集群的当前状态提升到我所期望的状态。这是因为清单指定了一个名为hello-kiamol-3的Pod，而这样的Pod并不存在。
- en: '![](../Images/2-13.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-13.jpg)'
- en: Figure 2.13 Applying a manifest sends the YAML file to the Kubernetes API, which
    applies changes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 应用清单将YAML文件发送到Kubernetes API，该API应用更改。
- en: 'Now that the Pod is running, you can manage it in the same way with kubectl:
    by listing the details of the Pod and running a port forward to send traffic to
    the Pod. The big difference is that the manifest is easy to share, and manifest-based
    Deployment is repeatable. I can run the same kubectl `apply` command with the
    same manifest any number of times, and the result will always be the same: a Pod
    named hello-kiamol-3 running my web container.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Pod正在运行，你可以使用kubectl以相同的方式管理它：通过列出Pod的详细信息并运行端口转发将流量发送到Pod。最大的不同之处在于清单易于分享，并且基于清单的部署是可重复的。我可以多次运行相同的kubectl
    `apply`命令和相同的清单，结果始终相同：一个名为hello-kiamol-3的Pod运行我的Web容器。
- en: Try it now Kubectl doesn’t even need a local copy of a manifest file. It can
    read the contents from any public URL. Deploy the same Pod definition direct from
    the file on GitHub.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：kubectl甚至不需要本地清单文件的副本。它可以从任何公共URL读取内容。直接从GitHub上的文件部署相同的Pod定义。
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Figure 2.14 shows the output. The resource definition matches the Pod running
    in the cluster, so Kubernetes doesn’t need to do anything, and kubectl shows that
    the matching resource is unchanged.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14显示了输出。资源定义与集群中运行的Pod相匹配，因此Kubernetes不需要做任何事情，kubectl显示匹配的资源没有变化。
- en: '![](../Images/2-14.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-14.jpg)'
- en: Figure 2.14 Kubectl can download manifest files from a web server and send them
    to the Kubernetes API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 Kubectl可以从Web服务器下载清单文件并将其发送到Kubernetes API。
- en: Application manifests start to get more interesting when you work with higher-level
    resources. When you define a Deployment in a YAML file, one of the required fields
    is the specification of the Pod that the Deployment should run. That Pod specification
    is the same API for defining a Pod on its own, so the Deployment definition is
    a composite that includes the Pod spec. Listing 2.2 shows the minimal definition
    for a Deployment resource, running yet another version of the same web app.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理更高级的资源时，应用程序清单开始变得更有趣。当你在一个 YAML 文件中定义 Deployment 时，所需字段之一是 Deployment 应该运行的
    Pod 的规范。这个 Pod 规范与定义 Pod 的相同 API，因此 Deployment 定义是一个组合，它包括 Pod 规范。列表 2.2 显示了 Deployment
    资源的最小定义，运行的是同一网络应用的另一个版本。
- en: Listing 2.2 deployment.yaml, a Deployment and Pod specification
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 deployment.yaml，Deployment 和 Pod 规范
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This manifest is for a completely different resource (which just happens to
    run the same application), but all Kubernetes manifests are deployed in the same
    way using kubectl `apply`. That gives you a nice layer of consistency across all
    your apps—no matter how complex they are, you’ll define them in one or more YAML
    files and deploy them using the same kubectl command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单是为一个完全不同的资源（碰巧运行了相同的应用程序），但所有 Kubernetes 清单都是使用 kubectl `apply` 以相同的方式部署的。这为你提供了所有应用程序的一致性层——无论它们多么复杂，你都会在一个或多个
    YAML 文件中定义它们，并使用相同的 kubectl 命令部署它们。
- en: Try it now Apply the Deployment manifest to create a new Deployment, which in
    turn will create a new Pod.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 应用 Deployment 清单以创建一个新的 Deployment，这将反过来创建一个新的 Pod。
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output in figure 2.15 shows the same end result as creating a Deployment
    with kubectl `create`, but my whole app specification is clearly defined in a
    single YAML file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 中的输出显示了与使用 kubectl `create` 创建 Deployment 相同的最终结果，但我的整个应用程序规范清晰地定义在一个单独的
    YAML 文件中。
- en: '![](../Images/2-15.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-15.jpg)'
- en: Figure 2.15 Applying a manifest creates the Deployment because no matching resource
    existed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 应用清单创建 Deployment，因为不存在匹配的资源。
- en: As the app grows in complexity, I need to specify how many replicas I want,
    what CPU and memory limits should apply, how Kubernetes can check whether the
    app is healthy, and where the application configuration settings come from and
    where it writes data—I can do all that just by adding to the YAML.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序复杂性的增长，我需要指定我想要多少个副本，应该应用什么 CPU 和内存限制，Kubernetes 如何检查应用程序是否健康，以及应用程序配置设置从何而来以及写入数据的位置——我可以通过添加
    YAML 来完成所有这些。
- en: 2.4 Working with applications in Pods
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 在 Pod 中处理应用程序
- en: Pods and Deployments are there to keep your app running, but all the real work
    is happening in the container. Your container runtime may not give you access
    to work with containers directly—a managed Kubernetes cluster won’t give you control
    of Docker or containerd—but you can still work with containers in Pods using kubectl.
    The Kubernetes command line lets you run commands in containers, view application
    logs, and copy files.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 和 Deployments 存在是为了让你的应用程序运行，但所有真正的工作都在容器中发生。你的容器运行时可能不会直接给你访问容器的能力——托管
    Kubernetes 集群不会给你 Docker 或 containerd 的控制权——但你仍然可以使用 kubectl 在 Pods 中与容器一起工作。Kubernetes
    命令行让你可以在容器中运行命令、查看应用程序日志和复制文件。
- en: Try it now You can run commands inside containers with kubectl and connect a
    terminal session, so you can connect into a Pod’s container as though you were
    connecting to a remote machine.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 你可以使用 kubectl 在容器内运行命令，并连接一个终端会话，这样你就可以像连接到远程机器一样连接到 Pod 的容器。
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: My output is shown in figure 2.16, where you can see that the IP address in
    the container environment is the one set by Kubernetes, and the web server running
    in the container is available at the localhost address.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出显示在图 2.16 中，你可以看到容器环境中的 IP 地址是由 Kubernetes 设置的，运行在容器中的 Web 服务器可以通过 localhost
    地址访问。
- en: '![](../Images/2-16.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-16.jpg)'
- en: Figure 2.16 You can use kubectl to run commands inside Pod containers, including
    interactive shells.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 你可以使用 kubectl 在 Pod 容器内运行命令，包括交互式 shell。
- en: Running an interactive shell inside a Pod container is a useful way of seeing
    how the world looks to that Pod. You can read file contents to check that configuration
    settings are being applied correctly, run DNS queries to verify that services
    are resolving as expected, and ping endpoints to test the network. Those are all
    good troubleshooting techniques, but for ongoing administration, a simpler option
    is to read the application logs, and kubectl has a dedicated command just for
    that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod容器内运行交互式shell是一种有用的方式，可以看到对该Pod的世界观。你可以读取文件内容以检查配置设置是否正确应用，运行DNS查询以验证服务是否按预期解析，以及ping端点以测试网络。这些都是很好的故障排除技术，但对于持续管理，一个更简单的选项是读取应用程序日志，而kubectl有一个专门的命令专门用于此。
- en: Try it now Kubernetes fetches application logs from the container runtime. You
    can read logs with kubectl, and if you have access to the container runtime, you
    can verify that they are the same as the container logs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 Kubernetes从容器运行时获取应用程序日志。你可以使用kubectl读取日志，如果你有权访问容器运行时，你可以验证它们与容器日志相同。
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see from my output, shown in figure 2.17, that Kubernetes just relays
    log entries exactly as they come from the container runtime.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从图2.17中看到我的输出，Kubernetes正是按照容器运行时接收到的日志条目原样转发日志。
- en: '![](../Images/2-17.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-17.jpg)'
- en: Figure 2.17 Kubernetes reads logs from the container so you don’t need access
    to the container runtime.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 Kubernetes从容器中读取日志，因此你不需要访问容器运行时。
- en: The same features are available for all Pods, no matter how they were created.
    Pods that are managed by controllers have random names, so you don’t refer to
    them directly. Instead, you can access them by their controller or by their labels.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Pods都提供相同的功能，无论它们是如何创建的。由控制器管理的Pods具有随机名称，因此你不会直接引用它们。相反，你可以通过控制器或标签来访问它们。
- en: Try it now You can run commands in Pods that are managed by a Deployment without
    knowing the Pod name, and you can view the logs of all Pods that match a label
    selector.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 你可以在不知道Pod名称的情况下运行由Deployment管理的Pods中的命令，并且可以查看所有匹配标签选择器的Pods的日志。
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Figure 2.18 shows the command running inside the Pod container, which causes
    the application to write a log entry. We see that in the Pod logs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18显示了在Pod容器内运行的命令，这会导致应用程序写入日志条目。我们在Pod日志中看到了这一点。
- en: '![](../Images/2-18.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-18.jpg)'
- en: Figure 2.18 You can work with Pods using kubectl without knowing the Pod’s name.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 你可以使用kubectl与Pods一起工作，而无需知道Pod的名称。
- en: In a production environment, you can have all the logs from all of your Pods
    collected and sent to a central storage system, but until you get there, this
    is a useful and easy way to read application logs. You also saw in that exercise
    that there are different ways to get to Pods that are managed by a controller.
    Kubectl lets you supply a label selector to most commands, and some commands—like
    `exec`—can be run against different targets.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你可以收集所有Pods的日志并发送到中央存储系统，但在到达那里之前，这是一种有用且简单的方法来读取应用程序日志。在那个练习中，你也看到了访问由控制器管理的Pods的不同方式。Kubectl允许你在大多数命令中提供标签选择器，并且一些命令——如`exec`——可以针对不同的目标运行。
- en: The last function you’re likely to use with Pods is to interact with the filesystem.
    Kubectl lets you copy files between your local machine and containers in Pods.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能最常与Pods一起使用的功能是与文件系统交互。Kubectl允许你在本地机器和Pods中的容器之间复制文件。
- en: Try it now Create a temporary directory on your machine, and copy a file into
    it from the Pod container.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 在你的机器上创建一个临时目录，并将文件从Pod容器复制到该目录中。
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In figure 2.19, you can see that kubectl copies the file from the Pod container
    onto my local machine. This works whether your Kubernetes cluster is running locally
    or on remote servers, and it’s bidirectional, so you can use the same command
    to copy a local file into a Pod. That can be a useful—if hacky—way to work around
    an application problem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.19中，你可以看到kubectl将文件从Pod容器复制到我的本地机器。这适用于你的Kubernetes集群是本地运行还是远程服务器，并且它是双向的，因此你可以使用相同的命令将本地文件复制到Pod。这可能是一种有用——如果有些不正规——的方法来绕过应用程序问题。
- en: '![](../Images/2-19.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-19.jpg)'
- en: Figure 2.19 Copying files between Pod containers and the local machine is useful
    for troubleshooting.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 在Pod容器和本地机器之间复制文件对于故障排除很有用。
- en: That’s about all we’re going to cover in this chapter, but before we move on,
    we need to delete the Pods we have running, and that is a little bit more involved
    than you might think.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章我们将要涵盖的所有内容，但在我们继续之前，我们需要删除我们正在运行的Pods，这比你想象的要复杂一些。
- en: 2.5 Understanding Kubernetes resource management
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 理解Kubernetes资源管理
- en: You can easily delete a Kubernetes resource using kubectl, but the resource
    might not stay deleted. If you created a resource with a controller, then it’s
    the controller’s job to manage that resource. It owns the resource life cycle,
    and it doesn’t expect any external interference. If you delete a managed resource,
    then its controller will create a replacement.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用kubectl轻松地删除Kubernetes资源，但资源可能不会保持删除状态。如果你使用控制器创建了一个资源，那么管理该资源就是控制器的职责。它拥有资源生命周期，并且不期望任何外部干扰。如果你删除了一个受管理的资源，那么它的控制器将创建一个替代品。
- en: Try it now Use the kubectl `delete` command to remove all Pods and verify that
    they’re really gone.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 使用kubectl的`delete`命令删除所有Pods并验证它们是否真的被删除了。
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see my output in figure 20.20\. Is it what you expected?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图20.20中看到我的输出。这是你预期的结果吗？
- en: '![](../Images/2-20.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-20.jpg)'
- en: Figure 2.20 Controllers own their resources. If something else deletes them,
    the controller replaces them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 控制器拥有自己的资源。如果其他东西删除了它们，控制器会重新创建。
- en: Two of those Pods were created directly with the `run` command and with a YAML
    Pod specification. They don’t have a controller managing them, so when you delete
    them, they stay deleted. The other two were created by Deployments, and when you
    delete the Pod, the Deployment controllers still exist. They see there are no
    Pods that match their label selectors, so they create new ones.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其中有两个Pod是通过`run`命令和YAML Pod规范直接创建的。它们没有控制器来管理它们，所以当你删除它们时，它们会保持删除状态。另外两个是由Deployments创建的，当你删除Pod时，Deployment控制器仍然存在。它们看到没有Pod匹配它们的标签选择器，所以它们会创建新的Pods。
- en: It seems obvious when you know about it, but it’s a gotcha that will probably
    keep cropping up through all your days with Kubernetes. If you want to delete
    a resource that is managed by a controller, you need to delete the controller
    instead. Controllers clean up their resources when they are deleted, so removing
    a Deployment is like a cascading delete that removes all the Deployment’s Pods,
    too.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道这一点时，这似乎很明显，但这是一个可能会在你与Kubernetes共度的每一天中不断出现的陷阱。如果你想删除由控制器管理的资源，你需要删除控制器。当控制器被删除时，它们会清理自己的资源，所以删除Deployment就像是一个级联删除，也会删除所有Deployment的Pods。
- en: Try it now Check the Deployments you have running, and then delete them and
    confirm that the remaining Pods have been deleted.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 检查你正在运行的Deployments，然后删除它们并确认剩余的Pods已经被删除。
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Figure 2.21 shows my output. I was fast enough to see the Pods being removed,
    so they’re shown in the terminating state. A few seconds later, the Pods and the
    Deployment were removed, so the only resource I have running is the Kubernetes
    API server itself.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21显示了我的输出。我足够快地看到了Pods正在被移除，所以它们显示在终止状态。几秒钟后，Pods和Deployment都被移除了，所以我唯一运行的资源就是Kubernetes
    API服务器本身。
- en: '![](../Images/2-21.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-21.jpg)'
- en: Figure 2.21 Deleting controllers starts a cascade effect, where the controller
    deletes all its resources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 删除控制器会引发级联效应，控制器会删除其所有资源。
- en: Now your Kubernetes cluster isn’t running any applications, and it’s back to
    its original state.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的Kubernetes集群没有运行任何应用程序，它已经回到了原始状态。
- en: We’ve covered a lot in this chapter. You’ve got a good understanding of how
    Kubernetes manages containers with Pods and Deployments, had an introduction to
    YAML specifications, and had lots of experience using kubectl to work with the
    Kubernetes API. We’ve built on the core concepts gradually, but you probably have
    a fair idea now that Kubernetes is a complex system. If you have time to go through
    the following lab, that will certainly help cement what you’ve learned.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量的内容。你对Kubernetes如何使用Pods和Deployments管理容器有了很好的理解，对YAML规范也有了一定的了解，并且通过使用kubectl与Kubernetes
    API交互积累了丰富的经验。我们逐步构建了核心概念，但你可能已经有一个相当清晰的认识，那就是Kubernetes是一个复杂的系统。如果你有时间去完成下面的实验，那将无疑有助于巩固你所学的知识。
- en: 2.6 Lab
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 实验
- en: 'This is your first lab; it’s a challenge for you to complete yourself. The
    goal is to write a Kubernetes YAML spec for a Deployment that will run an application
    in a Pod, and then test the app to make sure it runs as expected. Here are a few
    hints to get you started:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的第一个实验；这是一个需要你自己完成的挑战。目标是编写一个Kubernetes YAML规范，用于在Pod中运行应用程序，然后测试应用程序以确保它按预期运行。以下是一些帮助你开始的提示：
- en: In the ch02/lab folder, there’s a file called pod.yaml that you can try out.
    It runs the app but defines a Pod rather than a Deployment.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ch02/lab文件夹中，有一个名为pod.yaml的文件，你可以尝试运行。它运行应用程序，但定义的是Pod而不是Deployment。
- en: The application container runs a website that listens on port 80.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序容器运行一个监听80端口的网站。
- en: When you forward traffic to the port, the web app responds with the hostname
    of the machine it’s running on.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你转发流量到该端口时，Web应用程序会响应运行在其上的机器的主机名。
- en: That hostname is actually the Pod name, which you can verify using kubectl.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个主机名实际上是Pod的名称，你可以使用kubectl来验证。
- en: 'If you find this a bit tricky, I have the following sample solution on GitHub
    that you can use for reference: [https://github.com/sixeyed/kiamol/blob/master/ch02/lab/
    README.md](https://github.com/sixeyed/kiamol/blob/master/ch02/lab/README.md).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这有点棘手，我有一个在GitHub上的示例解决方案，你可以作为参考使用：[https://github.com/sixeyed/kiamol/blob/master/ch02/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch02/lab/README.md)。
