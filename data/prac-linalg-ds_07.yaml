- en: Chapter 7\. Matrix Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。矩阵应用
- en: 'I hope that now, after the past two theory-heavy chapters, you feel like you
    just finished an intense workout at the gym: exhausted but energized. This chapter
    should feel like a bike ride through the hills in the countryside: effortful at
    times but offering a fresh and inspiring perspective.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望现在，在过去两个理论密集的章节之后，你感觉就像刚刚完成了一次健身房的剧烈锻炼：疲惫但充满活力。这一章应该感觉就像在乡村小路上骑自行车：有时费力但提供了新鲜且令人振奋的视角。
- en: The applications in this chapter are loosely built off of those in [Chapter 4](ch04.xhtml#Chapter_4).
    I did this to have some common threads that bind the chapters on vectors and on
    matrices. And because I want you to see that although the concepts and applications
    become more complex as you progress in linear algebra, the foundations are still
    built on the same simple principles such as linear weighted combinations and the
    dot product.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的应用松散地基于第4章的内容。我这样做是为了在向量和矩阵的章节中保持一些共同的主题线索。因为我希望你看到，尽管随着线性代数的深入，概念和应用变得更加复杂，但其基础仍建立在诸如线性加权组合和点积等简单原理上。
- en: Multivariate Data Covariance Matrices
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多元数据协方差矩阵
- en: In [Chapter 4](ch04.xhtml#Chapter_4), you learned how to compute the Pearson
    correlation coefficient as the vector dot product between two data variables,
    divided by the product of the vector norms. That formula was for two variables
    (e.g., height and weight); what if you have multiple variables (e.g., height,
    weight, age, weekly exercise…)?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml#Chapter_4)中，你学会了如何计算Pearson相关系数，即两个数据变量之间的向量点积，除以向量范数的乘积。那个公式是用于两个变量（例如身高和体重）的；如果你有多个变量（例如身高、体重、年龄、每周运动……）呢？
- en: You could imagine writing a double `for` loop over all of the variables, and
    applying the bivariate correlation formula to all pairs of variables. But that
    is cumbersome and inelegant, and therefore antithetical to the spirit of linear
    algebra. The purpose of this section is to show you how to compute covariance
    and correlation *matrices* from multivariate datasets.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象在所有变量上写一个双重`for`循环，并将双变量相关性公式应用于所有变量对。但那样既笨重又不优雅，与线性代数精神相违背。本节的目的是向你展示如何从多变量数据集中计算协方差和相关性*矩阵*。
- en: Let’s start with *covariance*. Covariance is simply the numerator of the correlation
    equation—in other words, the dot product between two mean-centered variables.
    Covariance is interpreted in the same way as correlation (positive when variables
    move together, negative when variables move apart, zero when the variables have
    no linear relationship), except that covariance retains the scale of the data,
    and therefore is not bound by ±1.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*协方差*开始。协方差简单来说是相关方程的分子部分，换句话说，是两个均值中心化变量的点积。协方差的解释与相关性相同（变量同向移动时为正，反向移动时为负，无线性关系时为零），但协方差保留了数据的尺度，因此不受±1的限制。
- en: 'Covariance also has a normalization factor of *n* − 1, where *n* is the number
    of data points. That normalization prevents the covariance from growing larger
    as you sum more data values together (analogous to dividing by *N* to transform
    a sum into an average). Here is the equation for covariance:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差还有一个*（n-1）*的归一化因子，其中*n*是数据点的数量。这种归一化防止了随着数据值的累加协方差变得越来越大（类似于通过*N*来将总和转换为平均值）。以下是协方差的方程式：
- en: <math alttext="c Subscript a comma b Baseline equals left-parenthesis n minus
    1 right-parenthesis Superscript negative 1 Baseline sigma-summation Underscript
    i equals 1 Overscript n Endscripts left-parenthesis x Subscript i Baseline minus
    x overbar right-parenthesis left-parenthesis y Subscript i Baseline minus y overbar
    right-parenthesis" display="block"><mrow><msub><mi>c</mi> <mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow></msub>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></munderover> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>-</mo>
    <mover accent="true"><mi>x</mi> <mo>¯</mo></mover> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>-</mo> <mover accent="true"><mi>y</mi>
    <mo>¯</mo></mover> <mo>)</mo></mrow></mrow></math>
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="c Subscript a comma b Baseline equals left-parenthesis n minus
    1 right-parenthesis Superscript negative 1 Baseline sigma-summation Underscript
    i equals 1 Overscript n Endscripts left-parenthesis x Subscript i Baseline minus
    x overbar right-parenthesis left-parenthesis y Subscript i Baseline minus y overbar
    right-parenthesis" display="block"><mrow><msub><mi>c</mi> <mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow></msub>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></munderover> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>-</mo>
    <mover accent="true"><mi>x</mi> <mo>¯</mo></mover> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>-</mo> <mover accent="true"><mi>y</mi>
    <mo>¯</mo></mover> <mo>)</mo></mrow></mrow></math>
- en: As in [Chapter 4](ch04.xhtml#Chapter_4), if we call <math alttext="bold x overTilde"><mover
    accent="true"><mi>𝐱</mi> <mo>˜</mo></mover></math> to be the mean-centered variable
    <math alttext="bold x"><mi>𝐱</mi></math> , then covariance is simply <math alttext="bold
    x overTilde Superscript upper T Baseline bold y overTilde slash left-parenthesis
    n minus 1 right-parenthesis"><mrow><msup><mover accent="true"><mi>𝐱</mi> <mo>˜</mo></mover>
    <mtext>T</mtext></msup> <mover accent="true"><mi>𝐲</mi> <mo>˜</mo></mover> <mo>/</mo>
    <mrow><mo>(</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第4章](ch04.xhtml#Chapter_4)中所述，如果我们称<mover accent="true"><mi>𝐱</mi> <mo>˜</mo></mover>为均值中心化变量<mover
    accent="true"><mi>𝐱</mi></mover>，那么协方差就是简单的<mover accent="true"><mi>𝐱</mi> <mo>˜</mo></mover><mtext><msup><mi>T</mi></msup></mtext>
    <mover accent="true"><mi>𝐲</mi> <mo>˜</mo></mover> /（n-1）。
- en: The key insight to implementing this formula for multiple variables is that
    matrix multiplication is an organized collection of dot products between rows
    of the left matrix and columns of the right matrix.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此多变量公式的关键见解是矩阵乘法是左矩阵行和右矩阵列的点积的组织集合。
- en: 'So here’s what we do: create a matrix in which each column corresponds to each
    variable (a variable is a data feature). Let’s call that matrix <math alttext="bold
    upper X"><mi>𝐗</mi></math> . Now, the multiplication <math alttext="bold upper
    X bold upper X"><mrow><mi>𝐗</mi> <mi>𝐗</mi></mrow></math> is not sensible (and
    probably not even valid, because data matrices tend to be tall, thus *M* > *N*).
    But if we were to transpose the first matrix, then the *rows* of <math alttext="bold
    upper X Superscript upper T"><msup><mi>𝐗</mi> <mtext>T</mtext></msup></math> correspond
    to the *columns* of <math alttext="bold upper X"><mi>𝐗</mi></math> . Therefore,
    the matrix product <math alttext="bold upper X Superscript upper T Baseline bold
    upper X"><mrow><msup><mi>𝐗</mi> <mtext>T</mtext></msup> <mi>𝐗</mi></mrow></math>
    encodes all of the pair-wise covariances (assuming the columns are mean centered,
    and when dividing by *n* − 1). In other words, the (*i,j*)th element in the covariance
    matrix is the dot product between data features *i* and *j*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们做的是：创建一个矩阵，其中每一列对应一个变量（变量是数据特征）。让我们称这个矩阵为<math alttext="bold upper X"><mi>𝐗</mi></math>。现在，乘积<math
    alttext="bold upper X bold upper X"><mrow><mi>𝐗</mi> <mi>𝐗</mi></mrow></math>是不合理的（甚至可能无效，因为数据矩阵往往是高的，因此*M*
    > *N*)。但是如果我们转置第一个矩阵，那么<math alttext="bold upper X Superscript upper T"><msup><mi>𝐗</mi>
    <mtext>T</mtext></msup></math>的*行*对应于<math alttext="bold upper X"><mi>𝐗</mi></math>的*列*。因此，矩阵乘积<math
    alttext="bold upper X Superscript upper T Baseline bold upper X"><mrow><msup><mi>𝐗</mi>
    <mtext>T</mtext></msup> <mi>𝐗</mi></mrow></math>编码了所有成对协方差（假设列是均值居中的，并且在除以*n*
    - 1时）。换句话说，协方差矩阵中的(*i,j*)元素是数据特征*i*和*j*的点积。
- en: 'The matrix equation for a covariance matrix is elegant and compact:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差矩阵的矩阵方程非常优雅且紧凑：
- en: <math alttext="bold upper C equals bold upper X Superscript upper T Baseline
    bold upper X StartFraction 1 Over n minus 1 EndFraction" display="block"><mrow><mi>𝐂</mi>
    <mo>=</mo> <msup><mi>𝐗</mi> <mtext>T</mtext></msup> <mi>𝐗</mi> <mfrac><mn>1</mn>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper C equals bold upper X Superscript upper T Baseline
    bold upper X StartFraction 1 Over n minus 1 EndFraction" display="block"><mrow><mi>𝐂</mi>
    <mo>=</mo> <msup><mi>𝐗</mi> <mtext>T</mtext></msup> <mi>𝐗</mi> <mfrac><mn>1</mn>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math>
- en: 'Matrix <math alttext="bold upper C"><mi>𝐂</mi></math> is symmetric. That comes
    from the proof in [Chapter 5](ch05.xhtml#Chapter_5) that any matrix times its
    transpose is square symmetric, but it also makes sense statistically: covariance
    and correlation are symmetric, meaning that, for example, the correlation between
    height and weight is the same as the correlation between weight and height.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵<math alttext="bold upper C"><mi>𝐂</mi></math>是对称的。这来自于第5章中证明的任何矩阵乘以其转置都是方阵对称的，但从统计学上讲也是有道理的：协方差和相关性是对称的，意味着例如身高和体重之间的相关性与体重和身高之间的相关性相同。
- en: What are the diagonal elements of <math alttext="bold upper C"><mi>𝐂</mi></math>
    ? Those contain the covariances of each variable with itself, which in statistics
    is called the *variance*, and quantifies the dispersion around the mean (variance
    is the squared standard deviation).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于<math alttext="bold upper C"><mi>𝐂</mi></math>的对角元素是什么？这些元素包含每个变量与自身的协方差，在统计学中称为*方差*，用来量化围绕均值的离散程度（方差是标准差的平方）。
- en: The example in the online code creates a covariance matrix from a publicly available
    dataset on crime statistics. The dataset includes over a hundred features about
    social, economic, educational, and housing information in various communities
    around the US.^([1](ch07.xhtml#idm45733299773872)) The goal of the dataset is
    to use these features to predict levels of crime, but here we will use it to inspect
    covariance and correlation matrices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线代码示例中，使用公开可用的犯罪统计数据集创建了一个协方差矩阵。该数据集包括有关美国各社区社会、经济、教育和住房信息的一百多个特征^([1](ch07.xhtml#idm45733299773872))。该数据集的目标是利用这些特征来预测犯罪水平，但在这里我们将用它来检查协方差和相关矩阵。
- en: 'After importing and some light data processing (explained in the online code),
    we have a data matrix called `dataMat`. The following code shows how to compute
    the covariance matrix:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 导入并进行一些轻微的数据处理后（在在线代码中有解释），我们有一个名为`dataMat`的数据矩阵。以下代码显示如何计算协方差矩阵：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 7-1](#fig_7_1) shows an image of the covariance matrix. First of all:
    it looks neat, doesn’t it? I work with multivariate datasets in my “day job” as
    a neuroscience professor, and ogling covariance matrices has never failed to put
    a smile on my face.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-1](#fig_7_1)显示了协方差矩阵的图像。首先：看起来整洁，不是吗？我在“日常工作”中是一名神经科学教授，经常研究多变量数据集，并且仰慕协方差矩阵从未让我失望过。'
- en: In this matrix, light colors indicate variables that covary positively (e.g.,
    percentage of divorced males versus number of people in poverty), dark colors
    indicate variables that covary negatively (e.g., percentage of divorced males
    versus median income), and gray colors indicate variables that are unrelated to
    each other.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个矩阵中，浅色表示正相关的变量（例如，离婚男性的百分比与贫困人口数），深色表示负相关的变量（例如，离婚男性的百分比与中位收入），灰色表示彼此无关的变量。
- en: As you learned in [Chapter 4](ch04.xhtml#Chapter_4), computing a correlation
    from a covariance simply involves scaling by the norms of the vectors. This can
    be translated into a matrix equation, which will allow you to compute the data
    correlation matrix without `for` loops. [Exercise 7-1](#exercise_7_1) and [Exercise
    7-2](#exercise_7_2) will walk you through the procedure. As I wrote in [Chapter 4](ch04.xhtml#Chapter_4),
    I encourage you to work through those exercises before continuing to the next
    section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第四章](ch04.xhtml#Chapter_4)中学到的，从协方差计算相关性仅涉及向量的范数缩放。这可以转化为一个矩阵方程，让你能够计算数据相关矩阵而无需使用`for`循环。[练习
    7-1](#exercise_7_1) 和 [练习 7-2](#exercise_7_2) 将引导你完成这一过程。正如我在[第四章](ch04.xhtml#Chapter_4)中所写，我鼓励你在继续下一节之前先完成这些练习。
- en: '![covmat](assets/plad_0701.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![covmat](assets/plad_0701.png)'
- en: Figure 7-1\. A data covariance matrix
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. 数据协方差矩阵
- en: 'Final note: NumPy has functions to compute covariance and correlation matrices
    (respectively, `np.cov()` and `np.corrcoef()`). In practice, it’s more convenient
    to use those functions than to write out the code yourself. But—as always in this
    book—I want you to understand the math and mechanisms that those functions implement.
    Hence, for these exercises you should implement the covariance as a direct translation
    of the formulas instead of calling NumPy functions.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后注意：NumPy有用于计算协方差和相关矩阵的函数（分别是`np.cov()`和`np.corrcoef()`）。在实践中，使用这些函数比自己编写代码更方便。但是——正如本书始终如一地强调的——我希望你理解这些函数实现的数学和机制。因此，在这些练习中，你应该将协方差实现为直接的公式翻译，而不是调用NumPy函数。
- en: Geometric Transformations via Matrix-Vector Multiplication
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何变换通过矩阵-向量乘法实现
- en: I mentioned in [Chapter 5](ch05.xhtml#Chapter_5) that one of the purposes of
    matrix-vector multiplication is to apply a geometric transform to a set of coordinates.
    In this section, you will see this in 2D static images and in animations. Along
    the way, you’ll learn about pure rotation matrices and about creating data animations
    in Python.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第五章](ch05.xhtml#Chapter_5)中提到，矩阵-向量乘法的一个目的是对一组坐标应用几何变换。在本节中，你将在二维静态图像和动画中看到这一点。顺便说一句，你将了解纯旋转矩阵以及如何在Python中创建数据动画。
- en: 'A “pure rotation matrix” rotates a vector while preserving its length. You
    can think about the hands of an analog clock: as time ticks by, the hands rotate
    but do not change in length. A 2D rotation matrix can be expressed as:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “纯旋转矩阵”旋转一个向量同时保持其长度不变。你可以将其类比为模拟时钟的指针：随着时间的推移，指针旋转但长度不变。一个二维旋转矩阵可以表示为：
- en: <math alttext="bold upper T equals Start 2 By 2 Matrix 1st Row 1st Column cosine
    left-parenthesis theta right-parenthesis 2nd Column sine left-parenthesis theta
    right-parenthesis 2nd Row 1st Column minus sine left-parenthesis theta right-parenthesis
    2nd Column cosine left-parenthesis theta right-parenthesis EndMatrix" display="block"><mrow><mi>𝐓</mi>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo form="prefix">cos</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mtd> <mtd><mrow><mo form="prefix">sin</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo form="prefix">-sin</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mtd> <mtd><mrow><mo form="prefix">cos</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper T equals Start 2 By 2 Matrix 1st Row 1st Column cosine
    left-parenthesis theta right-parenthesis 2nd Column sine left-parenthesis theta
    right-parenthesis 2nd Row 1st Column minus sine left-parenthesis theta right-parenthesis
    2nd Column cosine left-parenthesis theta right-parenthesis EndMatrix" display="block"><mrow><mi>𝐓</mi>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo form="prefix">cos</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mtd> <mtd><mrow><mo form="prefix">sin</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo form="prefix">-sin</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mtd> <mtd><mrow><mo form="prefix">cos</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: A pure rotation matrix is an example of an *orthogonal matrix*. I will write
    more about orthogonal matrices in the next chapter, but I would like to point
    out that the columns of <math alttext="bold upper T"><mi>𝐓</mi></math> are orthogonal
    (their dot product is cos(*θ*)sin(*θ*) − sin(*θ*)cos(*θ*)) and are unit vectors
    (recall the trig identity that cos²(*θ*) + sin²(*θ*) = 1.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 纯旋转矩阵是*正交矩阵*的一个示例。我将在下一章更多地讨论正交矩阵，但我想指出<math alttext="bold upper T"><mi>𝐓</mi></math>的列是正交的（它们的点积是cos(*θ*)sin(*θ*)
    − sin(*θ*)cos(*θ*)）并且是单位向量（回忆三角恒等式cos²(*θ*) + sin²(*θ*) = 1）。
- en: To use this transformation matrix, set <math alttext="theta"><mi>θ</mi></math>
    to some angle of clockwise rotation, and then muliply matrix <math alttext="bold
    upper T"><mi>𝐓</mi></math> by a <math alttext="2 times upper N"><mrow><mn>2</mn>
    <mo>×</mo> <mi>N</mi></mrow></math> matrix of geometric points, where each column
    in that matrix contains the (X,Y) coordinates for each of *N* data points. For
    example, setting <math alttext="theta equals 0"><mrow><mi>θ</mi> <mo>=</mo> <mn>0</mn></mrow></math>
    does not change the points’ locations (this is because <math alttext="theta equals
    0"><mrow><mi>θ</mi> <mo>=</mo> <mn>0</mn></mrow></math> means <math alttext="bold
    upper T equals bold upper I"><mrow><mi>𝐓</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math>
    ); setting <math alttext="theta equals pi slash 2"><mrow><mi>θ</mi> <mo>=</mo>
    <mi>π</mi> <mo>/</mo> <mn>2</mn></mrow></math> rotates the points by <math alttext="90
    Superscript ring"><msup><mn>90</mn> <mo>∘</mo></msup></math> around the origin.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此变换矩阵，将<math alttext="theta"><mi>θ</mi></math>设置为某个顺时针旋转的角度，然后将矩阵<math alttext="bold
    upper T"><mi>𝐓</mi></math>乘以一个<math alttext="2 times upper N"><mrow><mn>2</mn>
    <mo>×</mo> <mi>N</mi></mrow></math>几何点矩阵，该矩阵中每一列包含*N*个数据点的(X,Y)坐标。例如，设置<math alttext="theta
    equals 0"><mrow><mi>θ</mi> <mo>=</mo> <mn>0</mn></mrow></math>不会改变点的位置（这是因为<math
    alttext="theta equals 0"><mrow><mi>θ</mi> <mo>=</mo> <mn>0</mn></mrow></math>意味着<math
    alttext="bold upper T equals bold upper I"><mrow><mi>𝐓</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math>）；设置<math
    alttext="theta equals pi slash 2"><mrow><mi>θ</mi> <mo>=</mo> <mi>π</mi> <mo>/</mo>
    <mn>2</mn></mrow></math>会使点围绕原点逆时针旋转<math alttext="90 Superscript ring"><msup><mn>90</mn>
    <mo>∘</mo></msup></math>。
- en: As a simple example, consider a set of points aligned in a vertical line and
    the effect of multiplying those coordinates by <math alttext="bold upper T"><mi>𝐓</mi></math>
    . In [Figure 7-2](#fig_7_2), I set <math alttext="theta equals pi slash 5"><mrow><mi>θ</mi>
    <mo>=</mo> <mi>π</mi> <mo>/</mo> <mn>5</mn></mrow></math> .
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，考虑一组垂直排列的点集以及通过<math alttext="bold upper T"><mi>𝐓</mi></math>乘以这些坐标的效果。在[图7-2](#fig_7_2)中，我设置了<math
    alttext="theta equals pi slash 5"><mrow><mi>θ</mi> <mo>=</mo> <mi>π</mi> <mo>/</mo>
    <mn>5</mn></mrow></math>。
- en: '![Pure rotation](assets/plad_0702.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![纯旋转](assets/plad_0702.png)'
- en: Figure 7-2\. Twirling points around the origin through a pure rotation matrix
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2. 围绕原点通过纯旋转矩阵旋转点
- en: Before continuing with this section, please inspect the online code that generates
    this figure. Make sure you understand how the math I wrote above is translated
    into code, and take a moment to experiment with different rotation angles. You
    can also try to figure out how to make the rotation counterclockwise instead of
    clockwise; the answer is in the footnote.^([2](ch07.xhtml#idm45733299628944))
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本节之前，请检查生成此图的在线代码。确保您理解我上面写的数学如何转化为代码，并花些时间尝试不同的旋转角度。您也可以尝试弄清楚如何使旋转逆时针而不是顺时针；答案在脚注中。^([2](ch07.xhtml#idm45733299628944))
- en: Let’s make our investigations of rotations more exciting by using “impure” rotations
    (that is, stretching and rotating, not only rotating) and by animating the transformations.
    In particular, we will smoothly adjust the transformation matrix at each frame
    of a movie.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用“不纯”的旋转（即拉伸和旋转，而不仅仅是旋转），并通过动画变换来使我们对旋转的调查更加精彩。特别是，我们将在电影的每一帧平滑调整变换矩阵。
- en: There are several ways to create animations in Python; the method I’ll use here
    involves defining a Python function that creates the figure content on each movie
    frame, then calling a `matplotlib` routine to run that function on each iteration
    of the movie.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建动画有几种方法；我将在这里使用的方法涉及定义一个Python函数，在每个电影帧上创建图形内容，然后调用`matplotlib`例程在每次迭代中运行该函数。
- en: I call this movie *The Wobbly Circle*. Circles are defined by a set of <math
    alttext="cosine left-parenthesis theta right-parenthesis"><mrow><mo form="prefix">cos</mo>
    <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></math> and <math alttext="sine left-parenthesis
    theta right-parenthesis"><mrow><mo form="prefix">sin</mo> <mo>(</mo> <mi>θ</mi>
    <mo>)</mo></mrow></math> points, for a vector of <math alttext="theta"><mi>θ</mi></math>
    angles that range from 0 to <math alttext="2 pi"><mrow><mn>2</mn> <mi>π</mi></mrow></math>
    .
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我称这部电影为*摇摆的圆*。圆由一组<math alttext="cosine left-parenthesis theta right-parenthesis"><mrow><mo
    form="prefix">cos</mo> <mo>(</mo> <mi>θ</mi> <mo>)</mo></mrow></math>和<math alttext="sine
    left-parenthesis theta right-parenthesis"><mrow><mo form="prefix">sin</mo> <mo>(</mo>
    <mi>θ</mi> <mo>)</mo></mrow></math>点定义，向量<math alttext="theta"><mi>θ</mi></math>角从0到<math
    alttext="2 pi"><mrow><mn>2</mn> <mi>π</mi></mrow></math>。
- en: 'I set the transformation matrix to the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了以下的变换矩阵：
- en: <math alttext="bold upper T equals Start 2 By 2 Matrix 1st Row 1st Column 1
    2nd Column 1 minus phi 2nd Row 1st Column 0 2nd Column 1 EndMatrix" display="block"><mrow><mi>𝐓</mi>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mn>1</mn>
    <mo>-</mo> <mi>φ</mi></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper T equals Start 2 By 2 Matrix 1st Row 1st Column 1
    2nd Column 1 minus phi 2nd Row 1st Column 0 2nd Column 1 EndMatrix" display="block"><mrow><mi>𝐓</mi>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mn>1</mn>
    <mo>-</mo> <mi>φ</mi></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Why did I pick these specific values, and how do you interpret a transformation
    matrix? In general, the diagonal elements scale the *x*-axis and *y*-axis coordinates,
    while the off-diagonal elements stretch both axes. The exact values in the matrix
    above were selected by playing around with the numbers until I found something
    that I thought looked neat. Later on, and in the exercises, you will have the
    opportunity to explore the effects of changing the transformation matrix.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么选择这些具体值，您如何解释变换矩阵？一般来说，对角元素缩放*x*-轴和*y*-轴坐标，而非对角元素则拉伸两个轴。上述矩阵中的确切值是通过尝试不同的数字直到我找到看起来不错的结果而选择的。稍后，在练习中，您将有机会探索更改变换矩阵的效果。
- en: Over the course of the movie, the value of <math alttext="phi"><mi>φ</mi></math>
    will smoothly transition from 1 to 0 and back to 1, following the formula <math
    alttext="phi equals x squared comma negative 1 less-than-or-equal-to x less-than-or-equal-to
    1"><mrow><mi>φ</mi><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>,</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>1</mn></mrow></math>.
    Note that <math alttext="bold upper T equals bold upper I"><mrow><mi>𝐓</mi> <mo>=</mo>
    <mi>𝐈</mi></mrow></math> when <math alttext="phi equals 1"><mrow><mi>φ</mi> <mo>=</mo>
    <mn>1</mn></mrow></math> .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影的过程中，<math alttext="phi"><mi>φ</mi></math> 的值将平稳过渡从 1 到 0，然后再到 1，遵循公式 <math
    alttext="phi equals x squared comma negative 1 less-than-or-equal-to x less-than-or-equal-to
    1"><mrow><mi>φ</mi><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>,</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>1</mn></mrow>。注意，当
    <math alttext="phi equals 1"><mrow><mi>φ</mi> <mo>=</mo> <mn>1</mn></mrow> 时，<math
    alttext="bold upper T equals bold upper I"><mrow><mi>𝐓</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math>。
- en: 'The Python code for a data animation can be separated into three parts. The
    first part is to set up the figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据动画的 Python 代码可以分为三个部分。第一部分是设置图形：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output of `ax.plot` is a variable `plth`, which is a *handle*, or a pointer,
    to the plot object. That handle allows us to update the locations of the dots
    rather than redrawing the figure from scratch on each frame.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`ax.plot` 的输出是变量 `plth`，它是一个*句柄*或指针，指向绘图对象。这个句柄允许我们更新点的位置，而不是在每一帧上从头开始重绘图形。'
- en: 'The second part is to define the function that updates the axis on each frame:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是定义在每一帧更新坐标轴的函数：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we define our transform parameter <math alttext="phi"><mi>φ</mi></math>
    and call the `matplotlib` function that creates the animation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义我们的变换参数 <math alttext="phi"><mi>φ</mi></math> 并调用创建动画的 `matplotlib` 函数：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Figure 7-3](#fig_7_3) show one frame of the movie, and you can watch the entire
    video by running the code. Admittedly, this movie is unlikely to win any awards,
    but it does show how matrix multiplication is used in animations. The graphics
    in CGI movies and video games are slightly more complicated because they use mathematical
    objects called quaternions, which are vectors in <math alttext="double-struck
    upper R Superscript 4"><msup><mi>ℝ</mi> <mn>4</mn></msup></math> that allow for
    rotations and translations in 3D. But the principle—multiply a matrix of geometric
    coordinates by a transformation matrix—is exactly the same.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](#fig_7_3) 展示了电影的一个帧，您可以通过运行代码观看整个视频。诚然，这部电影不太可能赢得任何奖项，但它确实展示了在动画中如何使用矩阵乘法。CGI
    电影和视频游戏中的图形稍微复杂一些，因为它们使用称为四元数的数学对象，这些四元数是在 <math alttext="double-struck upper
    R Superscript 4"><msup><mi>ℝ</mi> <mn>4</mn></msup></math> 中的向量，允许在 3D 中进行旋转和平移。但原理——通过变换矩阵乘以几何坐标的矩阵——完全相同。'
- en: '![Pure rotation](assets/plad_0703.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![纯旋转](assets/plad_0703.png)'
- en: Figure 7-3\. A frame of the movie The Wobbly Circle
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. 电影《摇晃的圆》的一个帧
- en: 'Before working through the exercises for this section, I encourage you to spend
    some time playing around with the code for this section. In particular, change
    the transformation matrix by setting one of the diagonal elements to .5 or 2,
    change the lower-left off-diagonal element instead of (or in addition to) the
    upper-right off-diagonal element, parameterize one of the diagonal elements instead
    of the off-diagonal element, and so on. And here’s a question: can you figure
    out how to get the circle to wobble to the left instead of to the right? The answer
    is in the footnote.^([3](ch07.xhtml#idm45733299335200))'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理本节的练习之前，我鼓励您花些时间尝试本节的代码。特别是，通过将对角元素之一设置为 0.5 或 2，更改左下角的非对角元素而不是（或者除此之外还）右上角的非对角元素，将其中一个对角元素参数化而不是非对角元素等。并且这里有个问题：您能想出如何让圆向左而不是向右摇摆吗？答案在脚注中。^([3](ch07.xhtml#idm45733299335200))
- en: Image Feature Detection
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像特征检测
- en: In this section, I will introduce you to image filtering, which is a mechanism
    for image feature detection. Image filtering is actually an extension of time
    series filtering, so having gone through [Chapter 4](ch04.xhtml#Chapter_4) will
    benefit you here. Recall that to filter or detect features in a time series signal,
    you design a kernel, and then create a time series of dot products between the
    kernel and overlapping segments of the signal.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍图像滤波，这是图像特征检测的一种机制。图像滤波实际上是时间序列滤波的一个延伸，所以在这里通过[第4章](ch04.xhtml#Chapter_4)会对你有利。回想一下，在时间序列信号中进行特征过滤或检测时，你设计一个核，然后创建核与信号重叠段的点乘时间序列。
- en: Image filtering works the same way except in 2D instead of 1D. We design a 2D
    kernel, and then create a new image comprising “dot products” between the kernel
    and overlapping windows of the image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图像滤波的工作方式与1D相同，只是在2D中。我们设计一个2D核，然后创建一个新图像，其中包含核与图像重叠窗口之间的“点乘”。
- en: I wrote “dot products” in apology quotes because the operation here is not formally
    the same as the vector dot product. The computation is the same—element-wise multiplication
    and sum—however, the operation takes place between two matrices, so the implementation
    is Hadamard multiplication and sum over all matrix elements. Graph A in [Figure 7-4](#fig_7_4)
    illustrates the procedure. There are additional details of convolution—for example,
    padding the image so that the result is the same size—that you would learn about
    in an image-processing book. Here I’d like you to focus on the linear algebra
    aspects, in particular, the idea that the dot product quantifies the relationship
    between two vectors (or matrices), which can be used for filtering and feature
    detection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我在引号中写了“点乘”，因为这里的操作与向量点乘并不完全相同。计算方式相同——逐元素相乘和求和——但是操作发生在两个矩阵之间，因此实现是Hadamard乘积并对所有矩阵元素求和。图A在[图7-4](#fig_7_4)中说明了该过程。还有卷积的额外细节——例如，填充图像以使结果大小相同——你可以在图像处理书籍中了解。在这里，我希望你专注于线性代数方面，特别是点积量化了两个向量（或矩阵）之间的关系，这可以用于滤波和特征检测。
- en: '![imconv](assets/plad_0704.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![imconv](assets/plad_0704.png)'
- en: Figure 7-4\. Mechanism of image convolution
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-4. 图像卷积机制
- en: 'Before moving on to the analysis, I will briefly explain how a 2D Gaussian
    kernel is created. A 2D Gaussian is given by the following equation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行分析之前，我将简要解释如何创建一个2D高斯核。2D高斯由以下方程给出：
- en: <math alttext="upper G equals exp left-parenthesis minus left-parenthesis upper
    X squared plus upper Y squared right-parenthesis slash sigma right-parenthesis"
    display="block"><mrow><mi>G</mi> <mo>=</mo> <mo form="prefix">exp</mo> <mo>(</mo>
    <mo>-</mo> <mrow><mo>(</mo> <msup><mi>X</mi> <mn>2</mn></msup> <mo>+</mo> <msup><mi>Y</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow> <mo>/</mo> <mi>σ</mi> <mo>)</mo></mrow></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper G equals exp left-parenthesis minus left-parenthesis upper
    X squared plus upper Y squared right-parenthesis slash sigma right-parenthesis"
    display="block"><mrow><mi>G</mi> <mo>=</mo> <mo form="prefix">exp</mo> <mo>(</mo>
    <mo>-</mo> <mrow><mo>(</mo> <msup><mi>X</mi> <mn>2</mn></msup> <mo>+</mo> <msup><mi>Y</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow> <mo>/</mo> <mi>σ</mi> <mo>)</mo></mrow></math>
- en: 'A few notes about that equation: *exp* stands for the natural exponential (the
    constant *e* = 2.71828…), and exp(x) is used instead of *e*^x when the exponential
    term is long. The *X* and *Y* are 2D grids of x,y coordinates on which to evaluate
    the function. Finally, <math alttext="sigma"><mi>σ</mi></math> is a parameter
    of the function that is often called the “shape” or “width”: smaller values make
    the Gaussian narrower, while larger values make the Gaussian wider. For now, I
    will fix that parameter to certain values, and you’ll get to explore the implications
    of changing that parameter in [Exercise 7-6](#exercise_7_6).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于该方程的一些说明：*exp*代表自然指数（常数*e* = 2.71828…），当指数项较长时，使用exp(x)而不是*e*^x。*X*和*Y*是2D坐标网格，用于评估函数。最后，<math
    alttext="sigma"><mi>σ</mi></math>是函数的一个参数，通常称为“形状”或“宽度”：较小的值使高斯变窄，而较大的值使高斯变宽。现在，我将该参数固定为某些值，你将有机会探索改变该参数的影响在[练习7-6](#exercise_7_6)中。
- en: 'Here’s how that formula translates into code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何将该公式转化为代码：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The *X* and *Y* grids go from −3 to +3 in 21 steps. The width parameter is hard
    coded to 20\. The third line normalizes the values in the kernel so that the sum
    over the entire kernel is 1\. That preserves the original scale of the data. When
    properly normalized, each step of convolution—and therefore, each pixel in the
    filtered image—becomes a weighted average of the surrounding pixels, with the
    weights defined by the Gaussian.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*和*Y*网格从-3到+3，步长为21步。宽度参数硬编码为20。第三行对核中的值进行归一化，使整个核的总和为1。这保持了数据的原始比例。当正确归一化时，每一步卷积——因此，过滤后图像中的每个像素——都成为周围像素的加权平均值，权重由高斯定义。'
- en: 'Back to the task at hand: we will smooth a random-numbers matrix, similar to
    how we smoothed a random-numbers time series in [Chapter 4](ch04.xhtml#Chapter_4).
    You can see the random-numbers matrix, the Gaussian kernel, and the result of
    convolution in [Figure 7-4](#fig_7_4).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回到手头的任务：我们将平滑一个随机数矩阵，类似于我们在[第四章](ch04.xhtml#Chapter_4)中平滑随机数时间序列的方式。你可以在[图 7-4](#fig_7_4)中看到随机数矩阵、高斯核以及卷积结果。
- en: 'The following Python code shows how image convolution is implemented. Again,
    think back to the time series convolution in [Chapter 4](ch04.xhtml#Chapter_4)
    to appreciate that the idea is the same but with an extra dimension necessitating
    an extra `for` loop:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码展示了如何实现图像卷积。再次回想一下[第四章](ch04.xhtml#Chapter_4)中的时间序列卷积，你会发现其思想相同，只是多了一个维度，需要额外的`for`循环：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implementing convolution as a double `for` loop is actually computationally
    inefficient. It turns out that convolution can be implemented faster and with
    less code in the frequency domain. This is thanks to the convolution theorem,
    which states that convolution in the time (or space) domain is equal to multiplication
    in the frequency domain. A full exposition of the convolution theorem is outside
    the scope of this book; I mention it here to justify the recommendation that you
    use SciPy’s `convolve2d` function instead of the double `for` loop implementation,
    particularly for large images.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将卷积实现为双重`for`循环实际上计算效率低下。事实证明，在频域中可以更快速地实现卷积，并且代码更少。这要归功于卷积定理，该定理指出时间（或空间）域中的卷积等于频率域中的乘法。对卷积定理的全面阐述超出了本书的范围；我在此提到它是为了建议你使用SciPy的`convolve2d`函数而不是双重`for`循环实现，尤其是对于大图像。
- en: Let’s try smoothing a real picture. We’ll use a picture of the Stedelijk Museum
    in Amsterdam, which I lovingly call “the bathtub from outer space.” This image
    is a 3D matrix because it has rows, columns, and depth—the depth contains pixel
    intensity values from the red, green, and blue color channels. This picture is
    stored as a matrix in <math alttext="double-struck upper R Superscript 1675 times
    3000 times 3"><msup><mi>ℝ</mi> <mrow><mn>1675</mn><mo>×</mo><mn>3000</mn><mo>×</mo><mn>3</mn></mrow></msup></math>
    . Formally, that’s called a *tensor* because it is a cube, not a spreadsheet,
    of numbers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试平滑一张真实的图片。我们将使用阿姆斯特丹斯特德利克博物馆的图片，我爱称它为“外太空的浴缸”。这张图片是一个3D矩阵，因为它具有行、列和深度——深度包含了来自红、绿和蓝色通道的像素强度值。这张图片存储为一个矩阵在<math
    alttext="double-struck upper R Superscript 1675 times 3000 times 3"><msup><mi>ℝ</mi>
    <mrow><mn>1675</mn><mo>×</mo><mn>3000</mn><mo>×</mo><mn>3</mn></mrow></msup></math>
    。严格来说，这被称为一个*张量*，因为它是一个立方体，而不是一个数字表格。
- en: For now, we will reduce it to a 2D matrix by converting to grayscale. That simplifies
    the computations, although it is not necessary. In [Exercise 7-5](#exercise_7_5),
    you will figure out how to smooth the 3D image. [Figure 7-5](#fig_7_5) shows the
    grayscale image before and after applying the Gaussian smoothing kernel.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将通过转换为灰度来将其减少为2D矩阵。这简化了计算，尽管并非必要。在[练习 7-5](#exercise_7_5)中，您将了解如何平滑3D图像。[图 7-5](#fig_7_5)展示了应用高斯平滑核前后的灰度图像。
- en: '![Smooth the bathtub.](assets/plad_0705.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![平滑浴缸](assets/plad_0705.png)'
- en: Figure 7-5\. A picture of the bathtub museum, before and after a respectable
    smoothing
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. 浴缸博物馆的图片，在进行了适当平滑前后
- en: Both of these examples used a Gaussian kernel. How many other kernels are available?
    An infinite number! In [Exercise 7-7](#exercise_7_7), you will test two other
    kernels that are used to identify vertical and horizontal lines. Those feature
    detectors are common in image processing (and are used by the neurons in your
    brain to detect edges in the patterns of light that hit your retina).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都使用了高斯核。还有多少其他核可用？无限多个！在[练习 7-7](#exercise_7_7)中，您将测试另外两个用于识别垂直和水平线的核。这些特征检测器在图像处理中很常见（并且被用于您大脑中用于检测光模式中边缘的神经元）。
- en: Image convolution kernels are a major topic in computer vision. In fact, the
    incredible performance of convolutional neural networks (the deep learning architecture
    optimized for computer vision) is entirely due to the network’s ability to craft
    optimal filter kernels through learning.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图像卷积核在计算机视觉中是一个重要的主题。事实上，卷积神经网络（专为计算机视觉优化的深度学习架构）的惊人性能完全归因于网络通过学习来制作最佳的滤波器核。
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'I’ll keep this simple: the point is that—yet again—incredibly important and
    sophisticated methods in data science and machine learning are built on simple
    linear algebra principles.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我简单解释一下：重要且复杂的数据科学和机器学习方法又一次是建立在简单的线性代数原理上。
- en: Code Exercises
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码练习
- en: Covariance and Correlation Matrices Exercises
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协方差和相关矩阵练习
- en: Exercise 7-1\.
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Exercise 7-1\.
- en: In this exercise, you will transform the covariance matrix into a correlation
    matrix. The procedure involves dividing each matrix element (that is, the covariance
    between each pair of variables) by the product of the variances of those two variables.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将把协方差矩阵转换为相关矩阵。该过程涉及将每个矩阵元素（即每对变量之间的协方差）除以这两个变量的方差的乘积。
- en: This is implemented by pre- and postmultiplying the covariance matrix by a diagonal
    matrix containing inverted standard deviations of each variable (standard deviation
    is the square root of variance). The standard deviations are inverted because
    we need to *divide* by the variances although we will *multiply* matrices. The
    reason for pre- and postmultiplying by standard deviations is the special property
    of pre- and postmultiplying by a diagonal matrix, which was explained in [Exercise
    5-11](ch05.xhtml#exercise_5_11).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将协方差矩阵分别预乘和后乘一个包含每个变量标准差的对角矩阵（标准差是方差的平方根）来实现的。标准差被倒置，因为我们需要*除以*方差，尽管我们将*乘以*矩阵。预乘和后乘标准差的原因是预乘和后乘对角矩阵的特殊性质，这在[Exercise
    5-11](ch05.xhtml#exercise_5_11)中已经解释过了。
- en: '[Equation 7-1](#cov2corr) shows the formula.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[Equation 7-1](#cov2corr)显示了公式。'
- en: Equation 7-1\. Correlation from covariance
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Equation 7-1\. 从协方差到相关的公式
- en: <math alttext="bold upper R equals bold upper S bold upper C bold upper S" display="block"><mrow><mi>𝐑</mi>
    <mo>=</mo> <mi>𝐒</mi> <mi>𝐂</mi> <mi>𝐒</mi></mrow></math>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper R equals bold upper S bold upper C bold upper S" display="block"><mrow><mi>𝐑</mi>
    <mo>=</mo> <mi>𝐒</mi> <mi>𝐂</mi> <mi>𝐒</mi></mrow></math>
- en: <math alttext="bold upper C"><mi>𝐂</mi></math> is the covariance matrix, and
    <math alttext="bold upper S"><mi>𝐒</mi></math> is a diagonal matrix of reciprocated
    standard deviations per variable (that is, the *i*th diagonal is <math alttext="1
    slash sigma Subscript i"><mrow><mn>1</mn> <mo>/</mo> <msub><mi>σ</mi> <mi>i</mi></msub></mrow></math>
    where <math alttext="sigma Subscript i"><msub><mi>σ</mi> <mi>i</mi></msub></math>
    is the standard deviation of variable *i*).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper C"><mi>𝐂</mi></math>是协方差矩阵，<math alttext="bold upper
    S"><mi>𝐒</mi></math>是每个变量的倒数标准差的对角矩阵（即第*i*个对角线是<math alttext="1 slash sigma Subscript
    i"><mrow><mn>1</mn> <mo>/</mo> <msub><mi>σ</mi> <mi>i</mi></msub></mrow></math>，其中<math
    alttext="sigma Subscript i"><msub><mi>σ</mi> <mi>i</mi></msub></math>是第*i*个变量的标准差）。
- en: Your goal in this exercise is to compute the correlation matrix from the covariance
    matrix, by translating [Equation 7-1](#cov2corr) into Python code. You can then
    reproduce [Figure 7-6](#fig_7_6).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你的目标是通过将[Equation 7-1](#cov2corr)翻译成Python代码，从协方差矩阵计算相关矩阵。然后，你可以重现[Figure 7-6](#fig_7_6)。
- en: '![covmat](assets/plad_0706.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![covmat](assets/plad_0706.png)'
- en: Figure 7-6\. Solution to Exercise 7-1
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 7-6\. Exercise 7-1的解答
- en: Exercise 7-2\.
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Exercise 7-2\.
- en: NumPy has a function `np.corrcoef()` that returns a correlation matrix, given
    an input data matrix. Use this function to reproduce the correlation matrix you
    created in the previous exercise. Show both matrices, and their difference, in
    a figure like [Figure 7-7](#fig_7_7) to confirm that they are the same.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy有一个函数`np.corrcoef()`，给定输入数据矩阵，返回一个相关矩阵。使用这个函数重现你在上一个练习中创建的相关矩阵。在类似[Figure 7-7](#fig_7_7)的图中展示这两个矩阵及它们的差异，以确认它们是相同的。
- en: '![cormat](assets/plad_0707.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![cormat](assets/plad_0707.png)'
- en: Figure 7-7\. Solution to Exercise 7-2\. Note the difference in color scaling.
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 7-7\. Exercise 7-2的解答。注意颜色比例的差异。
- en: Next, inspect the source code of `np.corrcoef()` by evaluating `??np.corrcoef()`.
    NumPy uses a slightly different implementation of broadcast dividing by the standard
    deviations instead of pre- and postmultiplying by a diagonal matrix of inverted
    standard deviations, but you should be able to understand how their code implementation
    matches the math and the Python code you wrote in the previous exercise.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过评估`??np.corrcoef()`来检查`np.corrcoef()`的源代码。NumPy使用了一种稍微不同的实现，通过标准偏差的广播除法而不是预乘和后乘一个倒置标准偏差的对角矩阵，但你应该能够理解它们的代码实现如何与你在前一个练习中编写的数学和Python代码相匹配。
- en: Geometric Transformations Exercises
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何变换练习
- en: Exercise 7-3\.
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Exercise 7-3\.
- en: 'The goal of this exercise is to show points in a circle before and after applying
    a transformation, similar to how I showed the line before and after rotation in
    [Figure 7-2](#fig_7_2). Use the following transformation matrix and then create
    a graph that looks like [Figure 7-8](#fig_7_8):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是展示应用变换前后的圆内点，类似于我在[图 7-2](#fig_7_2)中展示线段前后旋转的方式。使用以下变换矩阵，然后创建一个类似[图 7-8](#fig_7_8)的图形：
- en: <math alttext="bold upper T equals Start 2 By 2 Matrix 1st Row 1st Column 1
    2nd Column .5 2nd Row 1st Column 0 2nd Column .5 EndMatrix" display="block"><mrow><mi>𝐓</mi>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mn>.5</mn></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>.5</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>![A
    circle, transformed](assets/plad_0708.png)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="加粗的大写T等于开始2乘2矩阵第一行第一列1第二列.5第二行第一列0第二列.5结束矩阵" display="block"><mrow><mi>𝐓</mi>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mn>.5</mn></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>.5</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>![一个圆形，经过变换](assets/plad_0708.png)
- en: Figure 7-8\. Solution to Exercise 7-3
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-8\. 练习 7-3 的解答
- en: Exercise 7-4\.
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 7-4。
- en: 'Now for another movie. I call this one *The Coiling DNA*. [Figure 7-9](#fig_7_9)
    shows one frame of the movie. The procedure is the same as for *The Wobbly Circle*—set
    up a figure, create a Python function that applies a transformation matrix to
    a matrix of coordinates, and tell `matplotlib` to create an animation using that
    function. Use the following transformation matrix:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看另一个电影。我称其为*螺旋的DNA*。[图 7-9](#fig_7_9)展示了电影的一个镜头。步骤与*摇摆的圆形*相同——设置一个图表，创建一个将变换矩阵应用于坐标矩阵的Python函数，并告诉`matplotlib`使用该函数创建动画。使用以下变换矩阵：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>𝐓</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <mi>φ</mi> <mo>/</mo> <mn>3</mn> <mo>)</mo></mrow></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mi>φ</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mn>-1</mn> <mo>≤</mo></mrow></mtd> <mtd columnalign="left"><mrow><mi>φ</mi>
    <mo>≤</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>![The bouncing DNA](assets/plad_0709.png)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>𝐓</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <mi>φ</mi> <mo>/</mo> <mn>3</mn> <mo>)</mo></mrow></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mi>φ</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mn>-1</mn> <mo>≤</mo></mrow></mtd> <mtd columnalign="left"><mrow><mi>φ</mi>
    <mo>≤</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>![弹跳的DNA](assets/plad_0709.png)
- en: Figure 7-9\. Solution to Exercise 7-4
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-9\. 练习 7-4 的解答
- en: Image Feature Detection Exercises
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像特征检测练习
- en: Exercise 7-5\.
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 7-5。
- en: Smooth the 3D bathtub picture (if you need a hint, check the footnote^([4](ch07.xhtml#idm45733299011504))).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑3D浴缸图片（如果需要提示，请查看脚注^([4](ch07.xhtml#idm45733299011504))）。
- en: The output of the `convolve2d` function has a data type `float64` (you can see
    this yourself by typing `variableName.dtype`). However, `plt.imshow` will give
    a warning about clipping numerical values, and the picture won’t render properly.
    Therefore, you’ll need to convert the result of convolution to `uint8`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`convolve2d` 函数的输出数据类型为 `float64`（您可以通过输入 `variableName.dtype` 自行查看）。然而，`plt.imshow`
    将会警告有关裁剪数值的问题，图片无法正常渲染。因此，您需要将卷积结果转换为 `uint8`。'
- en: Exercise 7-6\.
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 7-6。
- en: You don’t need to use the same kernel for each color channel. Change the width
    parameter of the Gaussian for each channel according to the values shown in [Figure 7-10](#fig_7_10).
    The effect on the image is subtle, but the different blurs of the different colors
    give it a bit of a 3D look, as if you are looking at a red-blue anaglyph without
    the glasses.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要为每个颜色通道使用相同的核。根据[图 7-10](#fig_7_10)中显示的值，为每个通道更改高斯的宽度参数。对图像的影响微妙，但不同颜色的模糊使其具有一种稍微立体的外观，就像您没有戴眼镜看红蓝立体照片一样。
- en: '![Different strokes for different folks.](assets/plad_0710.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![各取所需](assets/plad_0710.png)'
- en: Figure 7-10\. Kernels used per color channel in Exercise 7-6
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-10\. 练习 7-6 中每个颜色通道使用的核
- en: Exercise 7-7\.
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 7-7。
- en: 'Technically, image smoothing is feature extraction, because it involves extracting
    the smooth features of the signal while dampening the sharp features. Here we
    will change the filter kernels to solve other image feature detection problems:
    identifying horizontal and vertical lines.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，图像平滑是特征提取的一种，因为它涉及提取信号的平滑特征，同时抑制尖锐特征。在这里，我们将改变滤波器核以解决其他图像特征检测问题：识别水平和垂直线条。
- en: The two kernels are shown in [Figure 7-11](#fig_7_11), as are their effects
    on the image. You can handcraft the two kernels based on their visual appearance;
    they are <math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>
    and comprise only the numbers −1, 0, and +1\. Convolve those kernels with the
    2D grayscale picture to create the feature maps shown in [Figure 7-11](#fig_7_11).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个卷积核如同[图 7-11](#fig_7_11)中所示，它们对图像的影响也被展示了出来。您可以根据它们的视觉外观手工制作这两个卷积核；它们是<math
    alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>的矩阵，只包含数字
    −1、0 和 +1\. 将这些卷积核与2D灰度图像卷积，以创建[图 7-11](#fig_7_11)中显示的特征图。
- en: '![Different strokes for different folks.](assets/plad_0711.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![各有所爱。](assets/plad_0711.png)'
- en: Figure 7-11\. Results of Exercise 7-7
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-11\. 练习 7-7 的结果
- en: '^([1](ch07.xhtml#idm45733299773872-marker)) M. A. Redmond and A. Baveja, “A
    Data-Driven Software Tool for Enabling Cooperative Information Sharing Among Police
    Departments,” *European Journal of Operational Research* 141 (2002): 660–678.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.xhtml#idm45733299773872-marker)) M. A. Redmond 和 A. Baveja，《A Data-Driven
    Software Tool for Enabling Cooperative Information Sharing Among Police Departments》，《European
    Journal of Operational Research》141（2002）：660–678。
- en: ^([2](ch07.xhtml#idm45733299628944-marker)) Swap the minus signs in the sine
    functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.xhtml#idm45733299628944-marker)) 将正弦函数中的负号互换。
- en: ^([3](ch07.xhtml#idm45733299335200-marker)) Set the lower-right element to −1.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.xhtml#idm45733299335200-marker)) 将右下角的元素设为 −1。
- en: '^([4](ch07.xhtml#idm45733299011504-marker)) Hint: smooth each color channel
    separately.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch07.xhtml#idm45733299011504-marker)) 提示：分别平滑每个颜色通道。
