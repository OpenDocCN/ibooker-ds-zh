- en: 'Lesson 23\. Capstone project: analyze your friends'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第23课：综合项目：分析你的朋友
- en: After reading [lesson 23](#ch23), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完[第23课](#ch23)后，你将能够
- en: Write a function to read a file line by line
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数来逐行读取文件
- en: Save numbers and strings from the file in variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件中的数字和字符串保存到变量中
- en: Write a function to analyze the stored information
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数来分析存储的信息
- en: The only two ways you’ve seen so far to input data are to (1) to predefine variables
    in your program or (2) to ask the user to input data one-by-one. But when users
    have a lot of information to input into your program, you can’t expect them to
    enter it in real time. It’s often useful to have them give you the information
    in a file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止看到的两种输入数据的方式是：(1) 在你的程序中预定义变量，或者(2) 要求用户逐个输入数据。但是，当用户有很多信息要输入到你的程序中时，你不能期望他们实时输入。让他们以文件的形式提供信息通常很有用。
- en: Computers are great at doing many computations quickly. A natural use for computers
    is to write programs that can read in large amounts of data from files and to
    perform simple analyses on that data. For example, you can export your own data
    from Microsoft Excel spreadsheets as files, or you can download data (such as
    weather or election data). After you’re given a file structured in a certain way,
    you can use knowledge of the structure to write a program to sequentially read
    and store the information from the file. With the data stored in your program,
    you can analyze it (for example, to find averages, maximums/minimums, and duplicates).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机擅长快速进行大量计算。计算机的一个自然用途是编写程序，可以从文件中读取大量数据，并对这些数据进行简单的分析。例如，你可以将Microsoft Excel电子表格中的数据导出为文件，或者你可以下载数据（如天气或选举数据）。在你得到一个以某种方式结构的文件后，你可以使用对该结构的了解来编写一个程序，以顺序读取和存储文件中的信息。在你的程序中存储的数据，你可以分析它（例如，找到平均值、最大值/最小值和重复项）。
- en: In addition to reviewing the concepts in this unit, this lesson will show you
    how to read data from a file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了复习本单元的概念外，本课还将向你展示如何从文件中读取数据。
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The problem
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: Write a program that reads input from a file in a specific format, regarding
    all your friends’ names and phone numbers. Your program should store that information
    and analyze it in some way. For example, you can show the user where their friends
    live based on the area code of the phone numbers, and the number of states where
    they live.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，从文件中读取特定格式的输入，包括你所有朋友的姓名和电话号码。你的程序应该存储这些信息并以某种方式分析它们。例如，你可以根据电话号码的区号显示用户朋友居住的地区，以及他们居住的州的数量。
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 23.1\. Reading a file
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1\. 读取文件
- en: You’ll write a function named `read_file` to go through each line and put the
    information from each line into a variable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写一个名为 `read_file` 的函数，用于遍历每一行，并将每行的信息放入变量中。
- en: 23.1.1\. File format
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.1.1\. 文件格式
- en: 'This function assumes that the user gives you information in the following
    format, with a different piece of information on each line:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数假设用户以以下格式提供信息，每行包含不同的信息：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It’s important that each piece of information is on a separate line, implying
    that your program will have a newline character as the final character on each
    line. Python has a way to deal with this, as you’ll soon see. Knowing this is
    the format, you can read the file line by line. You store every other line, starting
    with the first line, in a tuple. Then you store every other line, starting with
    the second line, in another tuple. The tuples look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每条信息都在单独的一行上，这意味着你的程序将在每行的末尾有一个换行符。Python 有一种处理这种格式的方法，你很快就会看到。知道了这个格式，你可以逐行读取文件。你将每行存储在元组中，从第一行开始。然后，你将每行的另一部分，从第二行开始，存储在另一个元组中。元组看起来像这样：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that at index 0, both tuples store information regarding Friend 1; at
    index 1, both tuples store info regarding Friend 2, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在索引0处，两个元组都存储有关朋友1的信息；在索引1处，两个元组都存储有关朋友2的信息，依此类推。
- en: You have to go through every line. This should trigger the idea to use a loop
    that goes through each line. The loop reads each line from the file as a string.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须逐行阅读。这应该会触发使用循环逐行遍历的想法。循环将文件中的每一行作为字符串读取。
- en: 23.1.2\. The newline character
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.1.2\. 换行符
- en: 'A special hidden character is at the end of every line, the newline character.
    The representation of this character is `\n`. To see the effect of this character,
    type the following in your console:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行的末尾都有一个特殊的隐藏字符，即换行符。该字符的表示为 `\n`。为了看到这个字符的效果，请在你的控制台中输入以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The console prints the phrase `no newline` and then gives you the prompt to
    type something in again. Now type in the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台打印出短语`no newline`然后给你提示再次输入。现在输入以下内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you see an extra empty line between what was printed and the next prompt.
    This is because the special character combination of the backslash and the letter
    *n* tells Python that you want a new line.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到打印内容和下一个提示之间有一个额外的空行。这是因为反斜杠和字母*n*的特殊字符组合告诉Python你想要一个新行。
- en: 23.1.3\. Remove the newline character
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.1.3\. 删除换行符
- en: When you’re reading a line from the file, the line contains all the characters
    you can see plus the newline character. You want to store everything except that
    special character, so you need to remove it before storing the information.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从文件中读取一行时，该行包含你看到的所有字符以及换行符。你想要存储除那个特殊字符之外的所有内容，因此需要在存储信息之前将其删除。
- en: Because each line you read in is a string, you can use a string method on it.
    The easiest thing to do is to replace every occurrence of `\n` with the empty
    string “”. This will effectively remove the newline character.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每行你读取的都是一个字符串，所以你可以使用字符串方法。最简单的事情就是将`\n`的每个出现替换为空字符串“”。这将有效地删除换行符。
- en: The following listing shows how to replace a newline character with an empty
    string and save the result into a variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何将换行符替换为空字符串，并将结果保存到变量中。
- en: Listing 23.1\. Remove the newline character
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.1\. 删除换行符
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Creates a variable whose value is a string with a newline character**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个值包含换行符的字符串的变量**'
- en: '***2* Prints the word with an extra newline**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印带有额外换行的单词**'
- en: '***3* Replaces newline with an empty string, and assigns the result back to
    the same variable**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将换行符替换为空字符串，并将结果赋值回同一变量**'
- en: '***4* Prints without an extra line**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 不打印额外行**'
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking like a programmer**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: 'What’s intuitive to one programmer may not be to another. Often there’s more
    than one way to write a piece of code. When faced with writing a line of code,
    browse the Python documentation to see what functions you can use before writing
    your own. For example, [listing 23.1](#ch23ex01) replaces newline characters with
    the empty space character, using `replace` on strings. The Python documentation
    has another function that would be appropriate to use: `strip`. The `strip` function
    removes all instances of a certain character from the beginning and end of a string.
    The following two lines do the same thing:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个程序员来说直观的，可能对另一个程序员来说就不直观。通常，编写一段代码的方式不止一种。面对编写一行代码的情况，在编写自己的代码之前，浏览Python文档以查看你可以使用哪些函数。例如，[列表23.1](#ch23ex01)使用字符串上的`replace`方法将换行符替换为空格字符。Python文档中还有一个适合使用的函数：`strip`。`strip`函数会从字符串的开始和结束处删除所有实例的特定字符。以下两行做的是同样的事情：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 23.1.4\. Using tuples to store information
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.1.4\. 使用元组存储信息
- en: Now that each line is cleaned up of newline characters, you’re left with the
    pure data, as strings. The next step is to store it in variables. Because you’ll
    have a collection of data, you should use one tuple to store all the names together
    and another tuple to store all the phone numbers together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '现在每行都清理了换行符，你剩下的是纯数据，作为字符串。下一步是将它存储在变量中。因为你会有一组数据，你应该使用一个元组来存储所有名称，另一个元组来存储所有电话号码。 '
- en: Every time you read in a line, add the new information to the tuple. Recall
    that adding an item to a tuple gives you a tuple that contains the old information,
    with the thing you just added at the end of the tuple. Now you have what the old
    tuple had, plus the new information you just read in that line. [Figure 23.1](#ch23fig01)
    shows which lines of the file are stored in which tuple. In the next section,
    you’ll see the code for this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你在一行中读取信息时，将新信息添加到元组中。记住，将一个项目添加到元组中会给你一个包含旧信息的元组，你刚刚添加的项目位于元组的末尾。现在你有了旧元组中的所有信息，加上你刚刚读取的那行中的新信息。[图23.1](#ch23fig01)显示了文件中的哪些行存储在哪个元组中。在下一节中，你将看到相应的代码。
- en: Figure 23.1\. The input data contains lines of data. The first line is the name
    of a friend, and the second is that friend’s phone number. The third is the name
    of your second friend, and the fourth is their phone number, and so on. Starting
    from the first line, take every other line to store all the names of your friends
    in a tuple. Starting from the second line, take all the phone numbers and store
    those in a separate tuple.
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图23.1\. 输入数据包含数据行。第一行是朋友的姓名，第二行是朋友的电话号码。第三行是你第二个朋友的姓名，第四行是他们的电话号码，以此类推。从第一行开始，每隔一行取出来，存储你朋友的所有姓名到一个元组中。从第二行开始，取所有电话号码，并将它们存储到另一个单独的元组中。
- en: '![](images/23fig01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/23fig01.jpg)'
- en: 23.1.5\. What to return
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.1.5\. 返回内容
- en: 'You’re writing a function that does the simple task of reading a file, organizing
    the information, and giving the organized information back. Now that you have
    two tuples (one with all the names and the other with all the phone numbers, as
    shown in [figure 23.1](#ch23fig01)), return a tuple of tuples, like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在编写一个函数，该函数执行简单的读取文件、组织信息和返回组织信息的任务。现在你有了两个元组（一个包含所有姓名，另一个包含所有电话号码，如图23.1所示），返回一个元组元组，如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You have to return a tuple of tuples because a function can return only one
    thing. Recall from [lesson 21](kindle_split_035.html#ch21) that returning a tuple
    with multiple elements allows you to get around this!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须返回一个元组元组，因为函数只能返回一个东西。回想一下[第21课](kindle_split_035.html#ch21)，返回一个包含多个元素的元组可以让你绕过这个限制！
- en: The following listing shows you the code for the function to read in the data.
    The function `read_file` takes in a file object; you’ll see what this means later
    in this lesson. It iterates through every line in the file and strips the line
    of the newlines. If you’re looking at an even numbered line, you add to your tuple
    of names. If you’re looking at an odd numbered line, you add to your tuple of
    phone numbers. In both cases, notice that you’re adding a singleton tuple, so
    you need to put an extra comma in the parentheses. Lastly, the function returns
    a tuple of tuples so that you can hand off the information parsed from the file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了读取数据的函数代码。函数`read_file`接受一个文件对象；你将在本课的后面看到这意味着什么。它遍历文件中的每一行，并去除行中的换行符。如果你正在查看偶数行，你将添加到你的姓名元组中。如果你正在查看奇数行，你将添加到你的电话号码元组中。在这两种情况下，请注意你正在添加一个单元素元组，因此需要在括号中添加一个额外的逗号。最后，该函数返回一个元组元组，以便你可以传递从文件中解析出的信息。
- en: Listing 23.2\. Read names and phone numbers from a file
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.2\. 从文件中读取姓名和电话号码
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* docstring**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 文档字符串**'
- en: '***2* Empty tuples for names and phone numbers**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 空元组用于姓名和电话号码**'
- en: '***3* Counter for line number**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 行号计数器**'
- en: '***4* Loops through every line**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 遍历每一行**'
- en: '***5* Removes newline character**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 移除换行符**'
- en: '***6* Odd-numbered lines**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 奇数行**'
- en: '***7* Adds to the names tuple**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 添加到姓名元组**'
- en: '***8* Even-numbered lines**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 偶数行**'
- en: '***9* Adds to the phone tuple**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 添加到电话号码元组**'
- en: '***10* Increments line number**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 增加行号**'
- en: '***11* Returns a tuple of tuples**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 返回元组元组**'
- en: 23.2\. Sanitizing user inputs
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.2\. 清理用户输入
- en: 'Now you have the information the user gave you, in two tuples: one tuple contains
    people names, and the other tuple contains phone numbers.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了用户给你提供的信息，在两个元组中：一个元组包含人名，另一个元组包含电话号码。
- en: You never specified the format of phone numbers, so the user can have a file
    that contains phone numbers in any format; users might have dashes, parentheses,
    spaces, or any other weird characters. Before you can analyze the numbers, you
    have to get them into a consistent form. This means removing all the special characters
    and leaving the digits all together.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你从未指定电话号码的格式，因此用户可以有一个包含任何格式的电话号码的文件；用户可能有破折号、括号、空格或任何其他奇怪的字符。在你分析这些数字之前，你必须将它们转换成一致的形式。这意味着移除所有特殊字符，并保留所有数字。
- en: This seems like a good job for a function. The function `sanitize` does this
    by using the `replace` method you learned about to replace all the special characters
    with the empty string “”. The following listing shows a possible implementation.
    You iterate through each string and replace unnecessary characters that might
    be found in phone numbers. After removing dashes, spaces, and parentheses, you
    put the cleaned-up phone number (as a string) into the new tuple that you return.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个适合函数的工作。函数 `sanitize` 通过使用你学过的 `replace` 方法来替换所有特殊字符为空字符串 “”。下面的列表显示了可能的实现。你遍历每个字符串，并替换掉可能出现在电话号码中的不必要的字符。在移除破折号、空格和括号后，将清理后的电话号码（作为一个字符串）放入你返回的新元组中。
- en: Listing 23.3\. Remove spaces, dashes, and parentheses from phone numbers
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.3\. 从电话号码中移除空格、破折号和括号
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Replaces unnecessary characters with empty string**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将不必要的字符替换为空字符串**'
- en: '***2* Empty tuple**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 空元组**'
- en: '***3* Adds cleaned number to new tuple**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将清理后的数字添加到新元组**'
- en: '***4* Returns new tuple**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回新元组**'
- en: 23.3\. Testing and debugging what you have so far
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3\. 测试和调试到目前为止的工作
- en: The remainder of the larger task is to do analysis on this data. Before moving
    on to this, it’s a good idea to do a little testing (and debugging, if necessary)
    to make sure the two functions you wrote work well together.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的任务剩余部分是对这些数据进行分析。在继续之前，进行一些测试（如果需要，进行调试）以确保你编写的两个函数能够很好地协同工作。
- en: At this point, you have two functions that do a couple of interesting tasks.
    Recall that functions don’t run until they’re called somewhere in a larger program.
    Now you’ll write code that integrates these functions together.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你编写了两个执行一些有趣任务的函数。回想一下，函数只有在更大程序中的某个地方被调用时才会运行。现在你将编写代码将这些函数集成在一起。
- en: 23.3.1\. File objects
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.3.1\. 文件对象
- en: When you’re working with files, you have to create file *objects*. As with other
    objects you’ve seen so far, Python knows how to work with these file objects to
    do specialized operations. For example, in the `read_file` function you wrote,
    you were able to write `for line in file` to iterate over each line in a specific
    file object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与文件一起工作时，你必须创建文件 *对象*。与其他你迄今为止看到的对象一样，Python 知道如何与这些文件对象一起工作以执行专门的操作。例如，在你编写的
    `read_file` 函数中，你能够写 `for line in file` 来遍历特定文件对象中的每一行。
- en: 23.3.2\. Writing a text file with names and phone numbers
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.3.2\. 使用名字和电话号码写入文本文件
- en: In Spyder, create a new file. Type in a few lines of data in the format that
    `read_file` expects. Start with a name; on the next line, put in a phone number,
    then another name, then another phone number, and so on. For example,
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spyder 中创建一个新文件。按照 `read_file` 期望的格式输入几行数据。从名字开始；在下一行，输入一个电话号码，然后是另一个名字，然后是另一个电话号码，依此类推。例如，
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now save the file as friends.txt or any other name you want. Make sure you save
    the file in the same folder as the Python program you’re writing. This file will
    be read by your program, so it’s a plaintext file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将文件保存为 friends.txt 或你想要的任何其他名称。确保将文件保存在你编写的 Python 程序所在的同一文件夹中。这个文件将被你的程序读取，因此它是一个纯文本文件。
- en: 23.3.3\. Opening files for reading
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.3.3\. 打开文件进行读取
- en: You create file objects by opening a filename. You use a function named `open`,
    which takes in a string with the filename you want to read. The file must be located
    in the same folder as your .py program file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过打开一个文件名来创建文件对象。你使用一个名为 `open` 的函数，该函数接受一个包含你想要读取的文件名的字符串。文件必须位于你的 .py 程序文件所在的同一文件夹中。
- en: '[Listing 23.4](#ch23ex04) shows how to open a file, run the functions you wrote,
    and check that the functions return the correct thing. You use the `open` function
    to open a file named friends.txt. This creates a file object, which is the parameter
    to the function `read_file()`. `read_file()` returns a tuple of tuples. You store
    the return in two tuples: one for the names and one for the phones.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 23.4](#ch23ex04) 展示了如何打开一个文件，运行你编写的函数，并检查函数是否返回正确的结果。你使用 `open` 函数打开一个名为
    friends.txt 的文件。这创建了一个文件对象，它是函数 `read_file()` 的参数。`read_file()` 返回一个元组的元组。你将返回值存储在两个元组中：一个用于名字，一个用于电话号码。'
- en: You can test that your `sanitize` function works by calling it with the phones
    tuple as its parameter. At each step, you can print variables and see that the
    output is as you expect it to be.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将电话号码元组作为参数调用 `sanitize` 函数来测试你的函数是否工作。在每一步，你都可以打印变量并查看输出是否符合你的预期。
- en: Listing 23.4\. Read names and phone numbers from a file
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.4\. 从文件中读取名字和电话号码
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Opens the file**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打开文件**'
- en: '***2* Calls function**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用函数**'
- en: '***3* Outputs printed to the user**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印给用户的输出**'
- en: '***4* Sees whether your function worked**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 检查你的函数是否工作**'
- en: '***5* Outputs printed to the user**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印给用户的输出**'
- en: '***6* Closes the file**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 关闭文件**'
- en: It’s good practice to test functions one by one before moving on to write more.
    Occasionally, you should test to make sure that the data being passed around from
    the output of one function to the input of another function works well together.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写更多代码之前，逐个测试函数是一个好习惯。偶尔，你应该测试以确保从一个函数的输出传递到另一个函数的输入的数据能够很好地协同工作。
- en: 23.4\. Reusing functions
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.4\. 重复使用函数
- en: The great thing about functions is that they’re reusable. You don’t have to
    write them to work for a specific kind of data; for example, if you write a program
    that adds two numbers, you can call the function to add two numbers representing
    temperatures, or ages, or weights.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的伟大之处在于它们的可重用性。你不需要为特定类型的数据编写它们；例如，如果你编写了一个添加两个数字的程序，你可以调用该函数来添加表示温度、年龄或重量的两个数字。
- en: You already wrote a function to read in data. You used the function to read
    in and store names and phone numbers into two tuples. You can reuse that function
    to read in a different set of data organized in the same format.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经编写了一个读取数据的函数。你使用该函数读取并存储名字和电话号码到两个元组中。你可以重用该函数来读取以相同格式组织的数据集。
- en: 'Because the user is going to give you phone numbers, suppose you have a file
    that contains area codes and the states to which they belong. The lines in this
    file are going to be in the same format as the file containing people names and
    their phone numbers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为用户将给你电话号码，假设你有一个包含区号及其所属州的文件。这个文件中的行将与包含人名和电话号码的文件格式相同：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first few lines of a file called map_areacodes_states.txt are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: map_areacodes_states.txt 文件的前几行如下：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this file, you can call the same function, `read_data`, and store the
    returned value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个文件，你可以调用相同的函数 `read_data` 并存储返回的值：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 23.5\. Analyzing the information
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.5\. 分析信息
- en: 'Now it’s time to put everything together. You gathered all your data and stored
    it into variables. The data you now have is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将所有东西组合在一起了。你已经收集了所有数据并将它们存储到变量中。你现在拥有的数据如下：
- en: Names of people
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人的名字
- en: Phone numbers corresponding to each name
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个名字对应的电话号码
- en: Area codes
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区号
- en: States corresponding to the area codes
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应区号的州
- en: 23.5.1\. The specification
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.5.1\. 规范
- en: 'Write a function named `analyze_friends` that takes in your four tuples: the
    first is the names of friends, the second is their phone numbers, the third is
    all the area codes, and the fourth is all the places corresponding to the area
    codes.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `analyze_friends` 的函数，它接受你的四个元组：第一个是朋友的姓名，第二个是他们的电话号码，第三个是所有区号，第四个是对应区号的地点。
- en: 'The function prints information. It doesn’t return anything. Say the friends
    given in the file are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 函数打印信息。它不返回任何内容。假设文件中给出的朋友如下：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then the function will print this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后该函数将打印以下内容：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice that even though you have four friends, two live in the same state,
    so you’ll print only the unique states. The following is the docstring of the
    function you’ll write:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管你有四个朋友，但其中两个住在同一个州，所以你将只打印唯一的州。以下是你将要编写的函数的文档字符串：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 23.5.2\. Helper functions
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.5.2\. 辅助函数
- en: The task of analyzing the information is complicated enough that you should
    write helper functions. *Helper functions* are functions that help another function
    achieve its task.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 分析信息的任务足够复杂，你应该编写辅助函数。*辅助函数*是帮助另一个函数完成任务的功能。
- en: Unique area codes
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 唯一的区号
- en: The first helper function you’ll write is `get_unique_area_codes`. It doesn’t
    take in any parameters and returns a tuple of only the unique area codes, in any
    order. In other words, it doesn’t duplicate area codes in a tuple of area codes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的第一个辅助函数是 `get_unique_area_codes`。它不接受任何参数，并返回一个只包含唯一区号的元组，顺序不限。换句话说，它不会在区号元组中重复区号。
- en: '[Listing 23.5](#ch23ex05) shows the function. This function will be nested
    in the `analyze_friends` function. Because it’s nested, this function knows of
    all parameters given to `analyze_friends`. This includes the `phones` tuple, meaning
    that you don’t have to pass in this tuple as a parameter again to `get_unique_area_codes`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 23.5](#ch23ex05) 显示了该函数。这个函数将嵌套在 `analyze_friends` 函数中。因为它嵌套，所以这个函数知道 `analyze_friends`
    给出的所有参数。这包括 `phones` 元组，这意味着你不需要再次将此元组作为参数传递给 `get_unique_area_codes`。'
- en: The function iterates through every number in phones and looks only at the first
    three digits (the area code). It keeps track of all the area codes it has seen
    so far and adds it to the unique area codes tuple only if it isn’t already in
    there.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数遍历 `phones` 中的每个数字，只查看前三位数字（区号）。它跟踪到目前为止看到的所有区号，并且只有当它不在其中时，才将其添加到唯一的区号元组中。
- en: Listing 23.5\. Helper function to keep only unique area codes
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.5\. 仅保留唯一区号的辅助函数
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Tuple to contain unique area codes**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 元组用于包含唯一的区号**'
- en: '***2* Goes through every area code, variable phones is a parameter to analyze_friends**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 遍历每个区号，变量 phones 是 analyze_friends 的参数**'
- en: '***3* Checks that area code isn’t there**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查区号是否已存在**'
- en: '***4* Concatenates tuple of unique codes with a singleton tuple**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将唯一代码元组与单元素元组连接**'
- en: Mapping area codes to states
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将区号映射到州
- en: Two of the inputs to `analyze_friends` are tuples containing area codes and
    states. Now you want to use these tuples to map each unique area code to its state.
    You can write another function that does this; call it `get_states`. The function
    takes in a tuple of area codes and returns a tuple of states corresponding to
    each area code. This function is also nested inside `analyze_friends`, so it will
    know of all the parameters given to `analyze_friends`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`analyze_friends` 函数的两个输入是包含区号和州的元组。现在你想使用这些元组将每个唯一的区号映射到其对应的州。你可以编写另一个函数来完成这个任务；将其命名为
    `get_states`。该函数接收一个区号元组并返回一个与每个区号对应的州元组。这个函数也嵌套在 `analyze_friends` 函数内部，因此它将知道传递给
    `analyze_friends` 的所有参数。'
- en: '[Listing 23.6](#ch23ex06) shows how to do this. You use a loop to go through
    every area code. With a valid area code, you now have to figure out the position
    in the area code tuple where the given area code is. You use the `index` method
    on tuples to get this value. Recall that the area code tuple and the states tuples
    match up (that’s how we created them when we read them in from the file). You
    use the index you get from the area code tuple to look up the state at that same
    position in the state tuple.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 23.6](#ch23ex06) 展示了如何做到这一点。你使用循环遍历每个区号。对于有效的区号，你现在必须确定给定区号在区号元组中的位置。你使用元组的
    `index` 方法来获取这个值。回想一下，区号元组和州元组是一一对应的（这就是我们在从文件中读取它们时创建它们的方式）。你使用从区号元组获得的索引在州元组的相同位置查找州。'
- en: A good programmer anticipates any possible problems with inputs from the user
    and tries to deal with them gracefully. For example, sometimes the user might
    enter a bogus area code. You anticipate that by writing code to the effect of
    something like “if you give me a bad area code, I will associate a state with
    it named BAD AREACODE.”
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的程序员会预见用户输入可能出现的任何问题，并尝试优雅地处理它们。例如，有时用户可能会输入一个无效的区号。你可以通过编写类似“如果你给我一个无效的区号，我将将其与名为
    BAD AREACODE 的州关联”的代码来预见这种情况。
- en: Listing 23.6\. Helper function to look up states from unique area codes
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.6\. 从唯一区号查找州的辅助函数
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* User gave you a bogus value; variable all_areacodes is a parameter to
    analyze_friends**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用户给出了一个无效值；变量 all_areacodes 是 analyze_friends 的参数**'
- en: '***2* Finds the position of the area code in tuple**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 查找区号在元组中的位置**'
- en: '***3* Uses position to look up the state**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用位置查找州**'
- en: And that’s it for the helper functions nested within the `analyze_friends` function.
    Now you can use them so that the code inside the `analyze_friends` function is
    simple and readable, as shown in the following listing. You just call the helper
    functions and print the information they return.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `analyze_friends` 函数嵌套的辅助函数的全部内容。现在你可以使用它们，使得 `analyze_friends` 函数内部的代码简单易读，如下面的列表所示。你只需调用辅助函数并打印它们返回的信息。
- en: Listing 23.7\. Body of the `analyze_friends` function
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.7\. `analyze_friends` 函数的主体
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Number of friends**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 朋友数量**'
- en: '***2* Keeps only unique area codes**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 仅保留唯一的区号**'
- en: '***3* Gets states corresponding to the unique area codes**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取与唯一区号对应的州**'
- en: '***4* Prints number of friends**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印朋友数量**'
- en: '***5* Prints the unique states**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印唯一的州**'
- en: '***6* Nothing to return**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 没有返回值**'
- en: The final step of the program is to read the two files, call the function to
    analyze the data, and close the files. The following listing shows this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一步是读取两个文件，调用分析数据的函数，然后关闭文件。以下列表显示了这一过程。
- en: Listing 23.8\. Commands to read files, analyze content, and close files
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.8\. 读取文件、分析内容和关闭文件的命令
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Opens files in the same directory as the program**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在程序相同的目录中打开文件**'
- en: '***2* Uses the same function to read two different data sets**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用相同的函数读取两个不同的数据集**'
- en: '***3* Normalizes the phone data**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 标准化电话数据**'
- en: '***4* Calls the function that does most of the work**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 调用执行大部分工作的函数**'
- en: '***5* Closes the files**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 关闭文件**'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, my objective was to teach you how to take on the problem of
    analyzing your friends’ data. You wrote a few functions that specialized in doing
    certain tasks. One function read data from a file. You used that function twice:
    once to read in names and phone numbers, and another time to read in area codes
    and states. Another function cleaned up data by removing unnecessary characters
    from phone numbers. A final function analyzed the data you collected from the
    files. This function comprised two helper functions: one to return unique area
    codes from a set of area codes, and one to convert the unique area codes to their
    respective states. Here are the major takeaways:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教您如何处理分析您朋友数据的问题。您编写了一些专门执行特定任务的函数。一个函数从文件中读取数据。您使用了该函数两次：一次读取姓名和电话号码，另一次读取区号和州。另一个函数通过从电话号码中删除不必要的字符来清理数据。最后一个函数分析了您从文件中收集的数据。该函数包含两个辅助函数：一个用于从一组区号中返回唯一的区号，另一个将唯一的区号转换为相应的州。以下是主要收获：
- en: You can open files in Python to work with their contents (to read lines as strings).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在Python中打开文件以处理其内容（读取字符串形式的行）。
- en: Functions are useful for organizing code. You can reuse any function you wrote
    with different inputs.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对于组织代码很有用。您可以重复使用您编写的任何函数，并使用不同的输入。
- en: You should test your functions often. Write a function and immediately test
    it. When you have a couple of functions, make sure they work well together.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该经常测试您的函数。编写一个函数并立即测试它。当您有几个函数时，请确保它们能很好地协同工作。
- en: You can nest functions inside other functions if the nested functions are relevant
    to only a specific task, as opposed to the program as a whole.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果嵌套函数只与特定任务相关，而不是整个程序，则可以在其他函数内部嵌套函数。
