- en: Appendix A. JavaScript coding standard
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A. JavaScript编码标准
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This appendix covers:**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本附录涵盖：**'
- en: Exploring why a coding standard is important
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探讨为什么编码标准很重要
- en: Laying out and documenting code consistently
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致地布局和记录代码
- en: Naming variables consistently
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致地命名变量
- en: Isolating code using namespaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间隔离代码
- en: Organizing files and ensuring consistent syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织文件并确保一致的语法
- en: Validating code using JSLint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSLint验证代码
- en: Using of a template that embodies the standard
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用体现标准的模板
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Coding standards are contentious. Almost everyone agrees you should have one,
    but few seem to agree on what the standard should be. Let’s consider why a coding
    standard is especially important for JavaScript.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准是有争议的。几乎每个人都同意你应该有一个，但似乎很少有人同意标准应该是什么。让我们考虑一下为什么编码标准对JavaScript尤其重要。
- en: A.1\. Why we need a coding standard
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1. 为什么我们需要编码标准
- en: Having a well-defined standard for a loosely typed, dynamic language like JavaScript
    is almost certainly more important than with stricter languages. JavaScript’s
    very flexibility can make it a Pandora’s box of coding syntax and practice. Whereas
    stricter languages provide structure and consistency inherently, JavaScript requires
    discipline and an applied standard to achieve the same effect.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像JavaScript这样的松散类型、动态语言，有一个明确的标准几乎比严格的语言更重要。JavaScript的极大灵活性可能使其成为编码语法和实践的潘多拉盒子。而严格的语言天生提供结构和一致性，JavaScript则需要纪律和适用的标准来实现同样的效果。
- en: What follows is the standard we’ve used and revised over many years. It’s fairly
    comprehensive and cohesive, and we use it consistently throughout the book. Its
    presentation here isn’t very concise because we’ve added many explanations and
    examples. Most of it has been condensed into a three-page cheat-sheet found at
    [https://github.com/mmikowski/spa](https://github.com/mmikowski/spa).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们多年来使用和修订的标准。它相当全面和连贯，我们在整本书中一直使用它。在这里的表述并不非常简洁，因为我们添加了许多解释和示例。其中大部分都被压缩成了一份三页的速查表，可在[https://github.com/mmikowski/spa](https://github.com/mmikowski/spa)找到。
- en: 'We’re not presumptive enough to think this coding standard is right for everyone:
    you should use or ignore this standard for your work as you see fit. In any event,
    we hope the concepts discussed will encourage you to review your own practices.
    We strongly recommend any team agree on a standard before embarking on a large
    project to avoid experiencing their own Tower of Babble.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不自以为是地认为这个编码标准适合所有人：你应该根据自己的需要使用或忽略这个标准。无论如何，我们希望讨论的概念能鼓励你审视自己的实践。我们强烈建议任何团队在开始大型项目之前就达成一致的标准，以避免经历自己的巴别塔。
- en: Experience and research show we’ll spend more time maintaining code than writing
    it. Our standard therefore favors readability over speed of creation. We’ve found
    that code which is written to be understood tends to be more carefully considered
    and better constructed the first time around.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 经验和研究表明，我们将花费更多的时间维护代码而不是编写它。因此，我们的标准更倾向于可读性而不是创建速度。我们发现，编写为了被理解的代码往往在第一次编写时更加仔细和结构化。
- en: 'We’ve found that a successful coding standard:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，一个成功的编码标准：
- en: Minimizes the chance of coding errors.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化编码错误的可能性。
- en: Results in code suitable for large-scale projects and teams—consistent, readable,
    extensible, and maintainable.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是适合大规模项目和团队的代码——一致、可读、可扩展和可维护。
- en: Encourages code efficiency, effectiveness, and reuse.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼓励代码的效率、效果和重用。
- en: Encourages the use of JavaScript’s strengths and avoids its weaknesses.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼓励使用JavaScript的优势并避免其弱点。
- en: Is used by all members of the development team.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被开发团队的每个成员使用。
- en: Martin Fowler once famously said, “Any fool can write code that a computer can
    understand. Good programmers write code that humans can understand.” Though well-defined
    and comprehensive standards don’t ensure human-readable JavaScript, they sure
    can help—just as dictionaries and grammar guides help ensure human-readable English.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒曾著名地说：“任何傻瓜都能写出计算机能理解的代码。优秀的程序员写出人类能理解的代码。”虽然明确和全面的标准不能保证JavaScript的可读性，但它们确实能有所帮助——就像词典和语法指南有助于确保英语的可读性一样。
- en: A.2\. Code layout and comments
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2. 代码布局和注释
- en: Laying out your code in a consistent and considered manner is one of the best
    way to increase comprehension. It’s also one of the more contentious issue in
    code standards.^([[1](#app01fn01)]) So when you read this section, relax. Have
    a decaf latte, get a spearmint tea-leaf pedicure, and open your mind. It’ll be
    fun. Really.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以一致和深思熟虑的方式布局你的代码是提高理解度的一种最佳方式。它也是代码标准中更具争议性的问题之一。[^1](#app01fn01) 所以当你阅读这一节时，放松一下。喝一杯无咖啡因的拿铁，做一个薄荷茶叶足疗，打开你的心扉。这会很有趣。真的。
- en: ¹ Legions of developers have spent countless hours rabidly flaming each other
    over the use of tabs alone—search the internet for “tabs versus spaces” if you
    need more proof.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 无数的开发者花费了无数小时狂热地争论制表位的使用——如果你需要更多证据，请在互联网上搜索“制表位与空格”。
- en: A.2.1\. Lay out your code for readability
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.1\. 为可读性布局你的代码
- en: What if we omitted all headers, punctuation, spacing and capitalization from
    this book? Well, the book would have come out months earlier, but our audience
    would probably find it unintelligible. Perhaps that is why our editor insisted
    that we format and apply conventions to our writing so that you, dear reader,
    would have a fighting chance at understanding the content.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从这本书中省略所有标题、标点、空格和大写字母，会怎样呢？嗯，这本书可能会提前几个月出版，但我们的读者可能会发现它难以理解。也许这就是为什么我们的编辑坚持要求我们格式化和应用写作约定，以便你，亲爱的读者，有理解内容的机会。
- en: JavaScript code has two audiences that need to understand it—the machines that
    will execute it and the humans who will maintain or extend it. Typically, our
    code will be read by humans many more times than it’s written. We format and apply
    conventions to our code so that our fellow developers (and that includes ourselves
    a few weeks from now) will have a fighting chance at understanding the content.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码有两个需要理解它的受众——将执行它的机器和将维护或扩展它的人类。通常，我们的代码会被阅读得比编写得多。我们格式化和应用约定到我们的代码中，以便我们的同事开发者（包括几周后的我们自己）有理解内容的机会。
- en: Use Consistent Indentation and Line Lengths
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用一致的缩进和行长度
- en: We probably all have noticed the text columns in a newspaper are between 50
    and 80 characters in length. Lines longer that 80 characters are progressively
    harder for the human eye to follow. Bringhurst’s authoritative book, *The Elements
    of Typographic Style*, recommends line lengths between 45-75 characters for optimal
    reading comprehension and comfort, with 66 considered the optimal.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能都注意到了报纸上的文本栏长度通常在50到80个字符之间。超过80个字符的行对于人眼来说越来越难以跟随。Bradyhurst的权威著作《版式设计要素》建议行长度在45-75个字符之间，以获得最佳的阅读理解和舒适度，其中66个字符被认为是最佳选择。
- en: Longer lines are also hard to read on computer displays. Today more and more
    web pages have multi-column layouts—even though this is notoriously expensive
    to implement well. The only reason a web developer is going to go though such
    trouble is if there’s a problem with long lines (or if they get paid by the hour).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 较长的行在电脑显示屏上阅读起来也很有难度。如今，越来越多的网页采用多列布局——尽管这通常被认为实施起来非常昂贵。一个网页开发者愿意付出这样的麻烦，唯一的理由可能是存在长行的问题（或者如果他们按小时收费）。
- en: 'Proponents for wider tab stops (4-8 spaces) say it makes their code more legible.
    But they often also advocate long line lengths to compensate for the wide tabs.
    We take the other approach: short tab width (2 spaces) and shortish line length
    (78 characters) work together to provide a narrower, more legible document with
    significant content per line. The short tab stop also recognizes that an event-driven
    language like JavaScript is typically more indented than a purely procedural language
    due to the proliferation of callbacks and closures.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 支持更宽的制表位（4-8个空格）的人说，这使他们的代码更易读。但他们也经常主张较长的行长度来补偿宽的制表位。我们采取另一种方法：较短的制表位宽度（2个空格）和较短的行长度（78个字符）共同作用，提供更窄、更易读的文档，每行内容丰富。短的制表位宽度也认识到，像JavaScript这样的事件驱动语言通常比纯过程性语言缩进更多，这是由于回调和闭包的普遍存在。
- en: '**Indent two spaces** per code level.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每级代码缩进两个空格**。'
- en: '**Use spaces, not tabs** to indent as there’s not a standard for the placement
    of tab stops.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用空格而不是制表位进行缩进，因为没有制表位位置的标准**。'
- en: '**Limit lines to 78 characters.**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制行长度为78个字符**。'
- en: Narrower documents also work better across all displays, allowing an individual
    to open six views of files concurrently on two high-definition displays, or easily
    read a single document on the smaller screens found on notebooks, tablets, or
    smart phones. They also fit nicely as listings on e-readers or in a printed book
    format, which makes our editor much happier.^([[2](#app01fn02)])
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 较窄的文档在所有显示设备上都表现更好，允许个人在两个高清显示器上同时打开六个文件视图，或者轻松地在笔记本电脑、平板电脑或智能手机上的较小屏幕上阅读单个文档。它们也适合作为电子阅读器或印刷书籍格式中的列表，这使得我们的编辑器非常高兴.^([[2](#app01fn02)])
- en: ² The line length limit for listings in this book is actually 72 characters,
    and losing those last six characters was painful.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²本书中列表的行长度限制实际上是72个字符，失去最后六个字符是痛苦的。
- en: Organize your Code in Paragraphs
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在段落中组织代码
- en: English and other written languages are presented in paragraphs to help the
    reader understand when one topic is complete and another is to be presented. Computer
    languages also benefit from this convention. These paragraphs can be annotated
    as a whole. Through the appropriate use of white space^([[3](#app01fn03)]) our
    JavaScript can read like a well-formated book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 英语和其他书面语言以段落的形式呈现，以帮助读者理解何时一个主题完成，另一个主题要呈现。计算机语言也受益于这一惯例。这些段落可以作为整体进行注释。通过适当使用空白^([[3](#app01fn03)))，我们的JavaScript可以像格式良好的书籍一样阅读。
- en: ³ White space is any combination of space, line breaks, or tabs. But don’t use
    tabs.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³空白是指空格、换行符或制表的任意组合。但不要使用制表符。
- en: '**Organize your code in logical paragraphs** and place blank lines between
    each.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将代码组织成逻辑段落**，并在每个段落之间留空白行。'
- en: '**Each line should contain at most one statement or assignment** although we
    do allow multiple variable declarations per line.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每行最多包含一个语句或赋值**，尽管我们确实允许每行有多个变量声明。'
- en: '**Place white space between operators** and variables so that variables are
    easier to spot.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在运算符和变量之间留空白**，以便更容易地找到变量。'
- en: '**Place white space after every comma.**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个逗号后都要留空白。**'
- en: '**Align like operators** within paragraphs.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在段落内对齐相同类型的运算符。**'
- en: '**Indent comments** the same amount as the code they explain.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将注释缩进与它们解释的代码相同。**'
- en: '**Place a semicolon at the end of every statement.**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在每条语句的末尾放置分号。**'
- en: '**Place braces around all statements in a control structure.** Control structures
    include `for`, `if`, and `while` constructs, among others. Perhaps the most common
    violation of this guideline is to omit braces for a single line `if` statement.
    Don’t do this. Always use braces so it’s easy to add statements without accidentally
    introducing bugs.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在控制结构中的所有语句周围放置花括号。**控制结构包括`for`、`if`和`while`构造等。也许最常见的是违反这一指南的做法是省略单行`if`语句的花括号。不要这样做。始终使用花括号，这样就可以轻松添加语句而不会意外引入错误。'
- en: Listing A.1\. Not like this
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.1\. 不像这样
- en: '![](338fig01_alt.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](338fig01_alt.jpg)'
- en: Listing A.2\. But like this
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.2\. 但像这样
- en: '![](339fig01_alt.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](339fig01_alt.jpg)'
- en: When we lay out our code, we want to aim for clarity and not reduced byte-count.
    Once our code reaches production, our JavaScript will be concatenated, minified,
    and compressed before it reaches our users. As a result, the tools we use to aid
    comprehension—white space, comments, and more descriptive variable names—will
    have little to no effect on the performance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们布局代码时，我们希望追求清晰度，而不是减少字节数。一旦我们的代码达到生产阶段，我们的JavaScript将在到达用户之前被连接、压缩和压缩。因此，我们用来帮助理解的工具——空白、注释和更具描述性的变量名——对性能的影响很小或没有影响。
- en: Break Lines Consistently
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保持一致的换行
- en: 'We should place a statement on a single line if it doesn’t exceed the maximum
    line length. But that is often not possible, so we have to break it into two or
    more lines. These guidelines will help reduce errors and improve cognition:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句不超过最大行长度，我们应该将其放在一行上。但这种情况通常是不可能的，所以我们必须将其分成两行或更多行。以下指南将有助于减少错误并提高认知：
- en: '**Break lines before operators** as one can easily review all operators in
    the left column.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在运算符之前换行**，这样就可以轻松地查看左列中的所有运算符。'
- en: '**Indent subsequent lines** of the statement one level, for example two spaces
    in our case.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩进语句的后续行**一个级别，例如在我们的例子中是两个空格。'
- en: '**Break lines after comma separators.**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在逗号分隔符后换行。**'
- en: '**Place a closing bracket or parenthesis on its own line.** This clearly indicates
    the conclusion of the statement without forcing the reader to scan horizontally
    for the semicolon.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将结束括号或括号单独放在一行上。**这清楚地表明了语句的结束，而不必强迫读者水平扫描分号。'
- en: Listing A.3\. Not like this
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.3\. 不像这样
- en: '![](340fig01_alt.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](340fig01_alt.jpg)'
- en: Listing A.4\. But like this
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.4\. 但像这样
- en: '![](340fig02_alt.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](340fig02_alt.jpg)'
- en: We’ll install JSLint a little later in this appendix, which will help us check
    our syntax.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在附录的稍后部分安装JSLint，这将帮助我们检查我们的语法。
- en: Use K&R Style Bracketing
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用K&R风格括号
- en: '*K&R style bracketing* balances the use of vertical space with readability.
    It should be used when formatting objects and maps, arrays, compound statements,
    or invocations. A compound statement contains one or more statements enclosed
    in curly braces. Examples include `if`, `while`, and `for` statements. An invocation
    like `alert( ‘I have been invoked!'' );` calls a function or a method.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*K&R风格括号*平衡了垂直空间的使用与可读性。在格式化对象和映射、数组、复合语句或调用时应该使用它。复合语句包含一个或多个用大括号括起来的语句。例如包括`if`、`while`和`for`语句。像`alert(
    ‘I have been invoked!'' );`这样的调用调用一个函数或方法。'
- en: '**Prefer single lines** when possible. For example, do not unnecessarily break
    a short array declaration into three lines when it can fit on one.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽可能使用单行**。例如，当短数组声明可以放在一行时，不要不必要地将它拆分为三行。'
- en: '**Place the opening** parenthesis, brace or bracket at the end of the opening
    line.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将开括号、花括号或方括号放在开行末尾**。'
- en: '**Indent the code inside the delimiters** (parenthesis, brace, or bracket)
    one level—for example, two spaces.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在分隔符内缩进代码**（括号、花括号或方括号）一级——例如，两个空格。'
- en: '**Place the closing** parenthesis, brace or bracket on its own line with the
    same indentation as the opening line.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将关闭括号、花括号或方括号放在与开行相同的缩进级别上**。'
- en: Listing A.5\. Not like this
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.5\. 不像这样
- en: '![](app01list05-0.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](app01list05-0.jpg)'
- en: '![](app01list05-1.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](app01list05-1.jpg)'
- en: Listing A.6\. But like this
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.6\. 但像这样
- en: '![](341fig01_alt.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](341fig01_alt.jpg)'
- en: Adjusting elements to line up vertically really helps comprehension, but also
    can be time-consuming if you don’t have a powerful text editor. Vertical text
    selection—as provided by Vim, Sublime, WebStorm, and others—is helpful in aligning
    values. WebStorm even provides tools to auto-align map values, which is a great
    time-saver. If your editor doesn’t allow for vertical selection, we highly recommend
    you consider changing editors.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 调整元素以垂直对齐确实有助于理解，但如果没有强大的文本编辑器，也可能很耗时。Vim、Sublime、WebStorm等提供的垂直文本选择有助于对齐值。WebStorm甚至提供了自动对齐映射值的工具，这是一个节省时间的好方法。如果你的编辑器不支持垂直选择，我们强烈建议你考虑更换编辑器。
- en: Use White Space to Distinguish Functions and Keywords
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用空白空间来区分函数和关键字
- en: Many languages have the concept of an article—words like *an*, *a* or *the*.
    One purpose of an article is to alert the reader or listener that the next word
    will be a noun or noun phrase. White space can be used with functions and keywords
    for a similar effect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言都有文章的概念——像*an*、*a*或*the*这样的词。文章的一个目的是让读者或听者知道下一个词将是名词或名词短语。空白空间可以与函数和关键字一起使用，以达到类似的效果。
- en: '**Follow a function with no space** between the function keyword and the opening
    left parenthesis, `(`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在函数关键字和开括号`(`之间没有空格**。'
- en: '**Follow a keyword with a single space** and then its opening left parenthesis,
    `(`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在关键字后跟一个空格**，然后是其开括号，`(`。'
- en: '**When formatting a for statement**, add a space after each semicolon.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在格式化for语句时**，在每个分号后添加一个空格。'
- en: Listing A.7\. Not like this
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.7\. 不像这样
- en: '![](342fig01_alt.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](342fig01_alt.jpg)'
- en: Listing A.8\. But like this
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.8\. 但像这样
- en: '![](342fig02_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](342fig02_alt.jpg)'
- en: This convention is common with other dynamic languages like Python, Perl, or
    PHP.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约定与其他动态语言（如Python、Perl或PHP）很常见。
- en: Quote Consistently
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一致引用
- en: We *prefer single quotes* over double quotes for string delimiters, as the HTML
    standard attribute delimiter is double quotes. And HTML is typically quoted often
    in SPAs. HTML delimited with single quotes requires less character escaping or
    encoding. The result is shorter, easier to read, and less likely to have errors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*更喜欢单引号*作为字符串分隔符，因为HTML标准属性分隔符是双引号。HTML通常在SPA中经常引用。使用单引号的HTML分隔符需要更少的字符转义或编码。结果是更短、更容易阅读，且出错的可能性更小。
- en: Listing A.9\. Not like this
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.9\. 不像这样
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Listing A.10\. But like this
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.10\. 但像这样
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Many languages like Perl, PHP, and Bash have the concept of interpolating and
    non-interpolating quotes. *Interpolating quotes* expand variable values found
    inside, whereas *non-interpolating quotes* don’t. Typically, double quotes (`"`)
    are interpolating, and single quotes (`‘`) are not. JavaScript quotes never interpolate,
    yet both single and double quotes may be used with no variance in behavior. Our
    use is therefore consistent with other popular languages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言如Perl、PHP和Bash都有插值和非插值引号的概念。*插值引号*会扩展其中找到的变量值，而*非插值引号*则不会。通常，双引号（`"`）是插值的，而单引号（`‘`）不是。JavaScript引号从不插值，但单双引号的使用没有行为上的差异。因此，我们的使用与其他流行语言保持一致。
- en: A.2.2\. Comment to explain and document
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.2\. 注释以解释和记录
- en: Comments can be even more important than the code they reference because they
    can convey critical details that aren’t otherwise obvious. This is especially
    evident in event-driven programming, as the number of callbacks can make tracing
    code execution a big time sink. This doesn’t mean that adding more comments is
    always better. Strategically placed, informative, and well-maintained comments
    are highly valued, whereas a clutter of inaccurate comments can be worse than
    no comments at all.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注释甚至可能比它们引用的代码更重要，因为它们可以传达一些不明显的关键细节。这在事件驱动编程中尤为明显，因为回调的数量可能会使跟踪代码执行变得耗时。但这并不意味着添加更多的注释总是更好的。战略性地放置、信息丰富且维护良好的注释非常受重视，而一堆不准确的注释可能比没有注释更糟。
- en: Explain Code Strategically
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 战略性地解释代码
- en: Our standard is intended to minimize comments and maximize their value. We minimize
    comments by using conventions to make the code as self-evident as possible. We
    maximize their value by aligning them to the paragraphs they describe and ensuring
    their content is of value to the reader.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标准旨在最小化注释并最大化其价值。我们通过使用约定来使代码尽可能自明来最小化注释。我们通过将它们与描述的段落对齐并确保其内容对读者有价值来最大化它们的值。
- en: Listing A.11\. Not like this
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.11\. 不像这样
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing A.12\. But like this
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.12\. 但像这样
- en: '![](344fig01_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](344fig01_alt.jpg)'
- en: Consistent, meaningful variable names can provide *more* information with *fewer*
    comments. Our section on variable naming appears a little later in the appendix,
    but let’s look at a few highlights. Variables that refer to functions all have
    a verb as their first word—`get_spec_map`, `run_init`. Other variables are named
    to help us understand their content—`welcome_html` is an HTML string, `house_color_list`
    is an array of color names, and `spec_map` is a map of specifications. This helps
    reduce the number of comments we need to add or maintain to make the code understandable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一致的、有意义的变量名可以用更少的注释提供更多信息。我们关于变量命名的部分将在附录中稍后出现，但让我们先看看一些亮点。所有指代函数的变量都以动词作为其首词——`get_spec_map`、`run_init`。其他变量被命名以帮助我们理解其内容——`welcome_html`是一个HTML字符串，`house_color_list`是一个颜色名称数组，而`spec_map`是一个规格映射。这有助于减少我们需要添加或维护的注释数量。
- en: Document your Apis and Todos
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记录你的API和待办事项
- en: Comments can also provide more formal documentation for your code. We need to
    be careful though—documentation about general architecture shouldn’t be buried
    in one of dozens of JavaScript files, but instead should go into a dedicated architecture
    document. But documentation about a function or an object API can and often should
    be placed right next to the code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注释也可以为你的代码提供更正式的文档。但我们需要小心——关于一般架构的文档不应该被埋在几十个JavaScript文件中的一个，而应该放入一个专门的架构文档中。但关于函数或对象API的文档可以，并且通常应该直接放置在代码旁边。
- en: '**Explain any non-trivial function** by specifying its *purpose*, the *arguments*
    or *settings* it uses, the values it *returns*, and any exception it *throws*.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过指定其*目的*、使用的*参数*或*设置*、返回的*值*以及抛出的任何*异常*来解释任何非平凡函数**。'
- en: '**If you disable code**, explain why with a comment of the following format:
    `//TODO date username - comment`. The user name and date are valuable in deciding
    the freshness of the comment, and can be also used by automated tools to report
    on TODO items in the code base.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果你禁用代码**，请用以下格式的注释解释原因：`//TODO 日期 用户名 - 注释`。用户名和日期对于决定注释的新鲜度很有价值，也可以由自动化工具用来报告代码库中的待办事项。'
- en: Listing A.13\. Example of API documentation for a function
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.13\. 函数API文档示例
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing A.14\. Example of disabled code
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.14\. 禁用代码示例
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Some people say you should always delete code immediately and recover it from
    source control if you need it again. But we have found that commenting-out code
    which we’ll *likely* need again is more efficient than trying to find the version
    where the disabled code was pristine and then merging it back. After the code
    has been disabled for a while, you can safely remove it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人说，你应该总是立即删除代码，并在需要时从源代码控制中恢复它。但我们发现，注释掉我们可能还会用到的代码比尝试找到禁用代码原始版本的版本然后合并它更有效率。代码禁用一段时间后，你可以安全地将其删除。
- en: A.3\. Variable names
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3\. 变量名
- en: Ever notice how books often include an ad-hoc naming convention in their code
    listings? For example, you’ll see lines like `person_str = ‘fred';`. The author
    typically does this because he doesn’t want to insert a clumsy, time-and-focus-sapping
    reminder later about what the variable represents. The name is self-evident.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，书籍通常在其代码列表中包含一个临时的命名约定？例如，你会看到像 `person_str = ‘fred’;` 这样的行。作者通常这样做是因为他不想后来插入一个笨拙的、消耗时间和注意力的提醒，说明变量代表什么。名字本身就是显而易见的。
- en: Everyone that codes uses a naming convention, whether they realize it or not.^([[4](#app01fn04)])
    A good naming convention provides the greatest value when all members of a team
    understand it and use it. When they do, they’re liberated from dull code tracing
    and arduous comment maintenance, and can instead focus on the purpose and logic
    of the code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编写代码的人都会使用命名约定，无论他们是否意识到这一点。[^4](#app01fn04) 一个好的命名约定在所有团队成员都理解并使用它时提供最大的价值。当他们这样做时，他们就可以从单调的代码追踪和艰难的注释维护中解放出来，并可以专注于代码的目的和逻辑。
- en: ⁴ A bit like “if you choose not to decide you still have made a choice” (“Freewill”
    by Rush, *Permanent Waves* album, 1980)
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 就像“如果你选择不决定，你仍然做出了选择”（出自 Rush 的《Freewill》，收录于《Permanent Waves》专辑，1980年）
- en: A.3.1\. Reduce and improve comments with a naming convention
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.1\. 使用命名约定减少和改进注释
- en: 'Consistent and descriptive names are extremely important for enterprise-class
    JavaScript applications, as they can greatly speed cognition and also help avoid
    common errors. Consider this completely valid and realistic JavaScript code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一致且具有描述性的名称对于企业级 JavaScript 应用程序至关重要，因为它们可以极大地加快认知速度，并有助于避免常见错误。考虑以下完全有效且现实的
    JavaScript 代码：
- en: Listing A.15\. Example A
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.15\. 示例 A
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let’s rewrite it using our naming conventions, which we’ll discuss shortly:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们即将讨论的命名约定重写它：
- en: Listing A.16\. Example B
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.16\. 示例 B
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Example B certainly seems more descriptive. With our convention, we can tell
    the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 B 显然更具有描述性。根据我们的约定，我们可以得出以下结论：
- en: '`make_house` is an object constructor.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_house` 是一个对象构造函数。'
- en: The called function is a currying function—it employs a closure to maintain
    a state and returns a function.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被调用的函数是一个柯里化函数——它使用闭包来维护状态并返回一个函数。
- en: The called function takes a string argument that indicates a `type`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被调用的函数接受一个字符串参数，该参数指示一个 `type`。
- en: The variables are local in scope.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量在局部作用域内。
- en: Now we could figure all of that out for example A by looking at the context
    of the code. Maybe it’ll take us 5, 30, or 60 minutes to trace all the functions
    and variables. And then *we’ll need to remember it all* while working with or
    around this code. Not only will we lose time, but we might lose focus on what
    we’re trying to accomplish in the first place.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过查看代码的上下文来找出示例 A 的所有这些信息。这可能需要我们花费 5、30 或 60 分钟来追踪所有函数和变量。然后，*我们还需要记住所有这些*，在处理或围绕这段代码时。这不仅会浪费时间，还可能使我们失去最初想要完成的目标的焦点。
- en: This avoidable expense will be incurred *every time* a new developer works with
    this code. And remember, after a few weeks away from this code, any developer—including
    the original author—is effectively a new developer. Obviously, this is horribly
    inefficient and error-prone.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可避免的开销将在每次新开发者使用此代码时产生。记住，离开这段代码几周后，任何开发者——包括原始作者——实际上都相当于一个新开发者。显然，这是效率低下且容易出错的。
- en: 'Lets see how example A would look if we used comments to provide the same amount
    of meaning as in example B:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果使用注释提供与示例 B 相同数量的意义，示例 A 会是什么样子：
- en: Listing A.17\. Example A with comments
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.17\. 带注释的示例 A
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Not only is example A with comments much more verbose than example B, it also
    took much longer to write, probably because we tried to convey the same amount
    of information as the naming convention. It gets worse: the comments are prone
    to become inaccurate over time as the code changes and developers exert their
    laziness. Let’s say we decide to change a few names a few weeks later:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅带有注释的示例A比示例B更冗长，而且编写它也花费了更长的时间，这可能是我们试图传达与命名约定相同数量的信息。更糟糕的是：随着时间的推移，随着代码的变化和开发者的懒惰，注释容易变得不准确。让我们假设我们决定几周后更改几个名称：
- en: Listing A.18\. Example A with comments after variable name changes
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.18. 变量名更改后的示例A，带有注释
- en: '![](347fig01_alt.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](347fig01_alt.jpg)'
- en: 'Oh dear, we forgot to update the comments that referenced the variable names
    we just changed. Now the comments are completely wrong and misleading. Not only
    that, but all these comments obscure the code because the listing is *nine times*
    longer. It would be better to have no comments at all. Compare that to if we wanted
    to change variable names in example B:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们忘记更新引用我们刚刚更改的变量名的注释了。现在，注释完全错误且具有误导性。不仅如此，所有这些注释都使代码变得混乱，因为列表的长度是*九倍*。最好一点注释都没有。与如果我们想更改示例B中的变量名相比：
- en: Listing A.19\. Example B with the names changed
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.19. 变量名更改后的示例B
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These revisions are immediately correct, as *there are no comments to adjust*.
    As this shows, a well-considered naming convention is a great way to self-document
    code *by the original author*, with greater precision and without a clutter of
    comments that are near-impossible to maintain. It helps speed development, improve
    quality, and ease maintenance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修订立即正确，因为*没有注释需要调整*。正如这所示，一个经过深思熟虑的命名约定是自我文档化代码的绝佳方式，由原始作者以更高的精度进行，而不需要注释的杂乱，这些注释几乎无法维护。它有助于加快开发速度，提高质量，并简化维护。
- en: A.3.2\. Use naming guidelines
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.2. 使用命名指南
- en: A variable name can convey a lot of information, as we have illustrated above.
    Let’s step through some guidelines we’ve found most useful.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名可以传达很多信息，正如我们上面所展示的。让我们回顾一些我们认为最有用的指南。
- en: Use Common Characters
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用公共字符
- en: Though much of our team might think it clever to name a variable `queensrÿche_album_name`,
    those who try to find the `ÿ` key on their keyboard might have different and significantly
    more negative opinions. It’s better to limit variable names to characters available
    on most of the world’s keyboards.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们团队中许多人可能认为将变量命名为`queensrÿche_album_name`很聪明，但试图在键盘上找到`ÿ`键的人可能会有不同的、并且明显更负面的看法。最好将变量名限制在大多数世界键盘上可用的字符。
- en: '**Use a-z, A-Z, 0-9, undescore, and $** characters in variable names.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在变量名中使用a-z, A-Z, 0-9, 下划线和$字符**。'
- en: '**Don’t begin a variable name with a number.**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要以数字开头变量名**。'
- en: Communicate Variable Scope
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通信变量作用域
- en: Our JavaScript files and modules have a one-to-one correspondence, similar to
    Node.js (we detail this later in the appendix). We’ve found it useful to distinguish
    between variables that are available anywhere in the module, and those that have
    a more limited scope.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript文件和模块有一一对应的关系，类似于Node.js（我们将在附录中详细说明）。我们发现区分在模块中任何地方都可用和作用域更有限的变量是有用的。
- en: '**Use camel case when the variable is full-module scope** (it can be accessed
    anywhere in a module namespace).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当变量是全模块作用域时使用驼峰式命名**（它可以在模块命名空间的任何地方访问）。'
- en: '**Use underscores when the variable is not full-module scope** (variables local
    to a function within a module namespace).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当变量不是全模块作用域时使用下划线**（模块命名空间内函数的局部变量）。'
- en: '**Make sure all module scope variables have at least two syllables** so that
    the scope is clear. For example, instead of using a variable called `config` we
    can use the more descriptive and obviously module-scoped `configMap`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保所有模块作用域变量至少有两个音节**，以便作用域清晰。例如，我们可以在变量`config`中使用更描述性和显然是模块作用域的`configMap`。'
- en: Recognize that Variable Type is Important
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 认识到变量类型的重要性
- en: 'Just because JavaScript allows you to play fast and loose with variable types
    doesn’t mean you should. Consider the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JavaScript允许你对变量类型进行快速和宽松的处理，但这并不意味着你应该这样做。考虑以下示例：
- en: Listing A.20\. Implicit conversion of type
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.20. 类型隐式转换
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, JavaScript converts `x` into a string and concatenates it to
    `y` (`02`) to get the string `1002`. Which is probably not what was intended.
    The results of type conversion can have more profound effects as well:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，JavaScript 将 `x` 转换为字符串，并将其与 `y` (`02`) 连接，得到字符串 `1002`。这可能不是预期的结果。类型转换的结果可能产生更深远的影响：
- en: Listing A.21\. The dark side of type conversion
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.21\. 类型转换的阴暗面
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve found that *unintentional* type conversion like this is much more common
    than *intentional*, and this often leads to difficult to find and solve bugs.
    We hardly ever *purposely* change a variable’s type because (among other reasons)
    doing so is almost always too confusing or difficult to manage to be worth the
    benefit.^([[5](#app01fn05)]) Therefore, when we name our variables, we often want
    to convey the variable type we intend it to contain
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，这种 *非故意* 的类型转换比 *故意* 的类型转换更为常见，这通常会导致难以找到和解决的错误。我们很少 *故意* 改变变量的类型，因为（原因之一）这样做几乎总是太混乱或难以管理，以至于不值得这种好处。[5](#app01fn05)
    因此，当我们命名我们的变量时，我们通常希望传达我们打算让它包含的变量类型
- en: ⁵ More recent versions of Firefox’s JavaScript JIT compiler recognize this fact
    and use a technique called *type inference* to realize a 20-30% performance gain
    in real-world code.
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 更新版本的 Firefox 的 JavaScript JIT 编译器认识到这个事实，并使用一种称为 *类型推断* 的技术，在现实世界的代码中实现 20-30%
    的性能提升。
- en: Naming Booleans
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名布尔值
- en: When a boolean represents a state, we use the word `is`; for example, `is_retracted`
    or `is_stale`. When we use a boolean to direct an action, say as in a function
    argument, we use the word `do`, as in `do_retract` or `do_extend`. And when we
    use a boolean to indicate ownership, we use `has`; for example, `has_whiskers`
    or `has_wheels`. [Table A.1](#app01table01) shows some examples.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当布尔值表示状态时，我们使用单词 `is`；例如，`is_retracted` 或 `is_stale`。当我们使用布尔值来指导动作时，比如在函数参数中，我们使用单词
    `do`，例如 `do_retract` 或 `do_extend`。当我们使用布尔值来表示所有权时，我们使用 `has`；例如，`has_whiskers`
    或 `has_wheels`。[表 A.1](#app01table01) 展示了一些例子。
- en: Table A.1\. Example regular expression names
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.1\. 正则表达式命名示例
- en: '| Indicator | Local scope | Module scope |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 局部作用域 | 模块作用域 |'
- en: '| --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| bool [generic] | bool_return | boolReturn |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| bool [通用] | bool_return | boolReturn |'
- en: '| do (requests action) | do_retract | doRetract |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| do (请求动作) | do_retract | doRetract |'
- en: '| has (indicates inclusion) | has_whiskers | hasWhiskers |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| has (表示包含) | has_whiskers | hasWhiskers |'
- en: '| is (indicates state) | is_retracted | isRetracted |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| is (表示状态) | is_retracted | isRetracted |'
- en: Naming Strings
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名字符串
- en: Our earlier example shows that it’s useful if we know we’re using a string variable.
    [Table A.2](#app01table02) is a chart of indicators that we commonly use with
    strings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子表明，如果我们知道我们正在使用一个字符串变量，那么这很有用。[表 A.2](#app01table02) 是一个我们常用字符串的指标图表。
- en: Table A.2\. Example string name
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.2\. 字符串命名示例
- en: '| Indicator | Local scope | Module scope |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 局部作用域 | 模块作用域 |'
- en: '| --- | --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| str [generic] | direction_str | directionStr |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| str [通用] | direction_str | directionStr |'
- en: '| id (identifier) | email_id | emailId |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| id (标识符) | email_id | emailId |'
- en: '| date | email_date | emailDate |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| date | email_date | emailDate |'
- en: '| html | body_html | bodyHtml |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| html | body_html | bodyHtml |'
- en: '| msg (message) | employee_msg | employeeMsg |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| msg (消息) | employee_msg | employeeMsg |'
- en: '| name | employee_name | employeeName |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| name | employee_name | employeeName |'
- en: '| text | email_text | emailText |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| text | email_text | emailText |'
- en: '| type | item_type | itemType |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| type | item_type | itemType |'
- en: Naming Integers
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名整数
- en: 'JavaScript doesn’t expose integers as a supported variable type, but there
    are many instances where the language won’t work properly unless we provide an
    integer. When iterating over an array, for example, the use of a floating-point
    number as an index doesn’t work right:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 不暴露整数作为支持的变量类型，但在许多情况下，除非我们提供整数，否则语言无法正常工作。例如，在遍历数组时，使用浮点数作为索引是不正确的：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Other built-ins also expect integer values, like the string `substr()` method.
    So when it’s important that the number you’re using is an integer, you can use
    indicators, as shown in [Table A.3](#app01table03).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其他内置函数也期望整数值，例如字符串 `substr()` 方法。因此，当使用数字是整数很重要时，可以使用指标，如 [表 A.3](#app01table03)
    所示。
- en: Table A.3\. Example integer names
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.3\. 整数命名示例
- en: '| Indicator | Local scope | Module scope |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 局部作用域 | 模块作用域 |'
- en: '| --- | --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| int [generic] | size_int | sizeInt |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| int [通用] | size_int | sizeInt |'
- en: '| *none* (convention) | i, j, k | (not allowed in module scope) |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| *none* (约定) | i, j, k | (不允许在模块作用域中) |'
- en: '| count | employee_count | employeeCount |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| count | employee_count | employeeCount |'
- en: '| index | employee_index | employeeIndex |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| index | employee_index | employeeIndex |'
- en: '| time (milliseconds) | retract_time | retractTime |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| time（毫秒）| retract_time | retractTime |'
- en: Naming Numbers
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名数字
- en: We can use other indicators (see [Table A.4](#app01table04)) if it’s important
    to understand that we’re dealing with non-integer numbers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果理解我们正在处理非整数数字很重要，我们可以使用其他指标（见 [表 A.4](#app01table04)）。
- en: Table A.4\. Example number names
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.4\. 示例数字名称
- en: '| Indicator | Local scope | Module scope |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 本地作用域 | 模块作用域 |'
- en: '| --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| num [generic] | size_num | sizeNum |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| num [通用] | size_num | sizeNum |'
- en: '| *none* (convention) | x, y, z | (not allowed in module scope) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| *none*（约定）| x, y, z | （在模块作用域中不允许）|'
- en: '| coord (coordinate) | x_coord | xCoord |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| coord（坐标）| x_coord | xCoord |'
- en: '| ratio | sales_ratio | salesRatio |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| ratio | sales_ratio | salesRatio |'
- en: Naming Regular Expressions
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名正则表达式
- en: We typically prefix a regular expression with `regex`, as in [Table A.5](#app01table05).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在正则表达式前加上 `regex`，如 [表 A.5](#app01table05) 中所示。
- en: Table A.5\. Example regular expression names
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.5\. 示例正则表达式名称
- en: '| Indicator | Local scope | Module scope |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 本地作用域 | 模块作用域 |'
- en: '| --- | --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| regex | regex_filter | regexFilter |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| regex | regex_filter | regexFilter |'
- en: Naming Arrays
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名数组
- en: 'Here are a few guidelines we have found useful in naming arrays:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名数组时，我们发现以下几条准则很有用：
- en: '**An array variable name should be a singular noun followed by the word “list”.**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组变量名应该是一个单数名词，后跟“list”这个词。**'
- en: Prefer the noun-“List” form for module-scoped arrays.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于模块作用域的数组，首选名词-“List”形式。
- en: '[Table A.6](#app01table06) shows some examples.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 A.6](#app01table06) 展示了一些示例。'
- en: Table A.6\. Example array names
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.6\. 示例数组名称
- en: '| Indicator | Local scope | Module scope |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 本地作用域 | 模块作用域 |'
- en: '| --- | --- | --- |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| list | timestamp-list | timestampList |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| list | timestamp-list | timestampList |'
- en: '| list | color_list | colorList |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| list | color_list | colorList |'
- en: Naming Maps
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名映射
- en: JavaScript doesn’t officially have a `map` data type—it just has objects. But
    we’ve found it useful to distinguish between simple objects used only to store
    data (`maps`) and full-featured objects. This map structure is analogous to a
    `map` in Java, a `dict` in Python, an *associative array* in PHP, or a `hash`
    in Perl.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 官方并没有 `map` 数据类型——它只有对象。但我们发现区分仅用于存储数据（`maps`）的简单对象和功能齐全的对象是有用的。这种映射结构类似于
    Java 中的 `map`，Python 中的 `dict`，PHP 中的 `关联数组`，或 Perl 中的 `hash`。
- en: When we name a map, we usually want to emphasize the developer’s intent and
    include the word `map` in the name. Typically, the structure is a noun followed
    by the word `map`, and it’s always singular. See [Table A.7](#app01table07) for
    example map names.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们命名一个映射时，我们通常希望强调开发者的意图并在名称中包含 `map` 这个词。通常结构是一个名词后跟 `map` 这个词，并且总是单数。见 [表
    A.7](#app01table07) 中的示例映射名称。
- en: Table A.7\. Example map names
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.7\. 示例映射名称
- en: '| Indicator | Local scope | Module scope |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 本地作用域 | 模块作用域 |'
- en: '| --- | --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| map | employee_map | employeeMap |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| map | employee_map | employeeMap |'
- en: '| map | receipt_timestamp_map | receiptTimestampMap |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| map | receipt_timestamp_map | receiptTimestampMap |'
- en: Sometimes the key of a map is an unusual or a distinguishing feature. In such
    cases, we indicate the key in the name, for example, `receipt_timestamp_map`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有时映射的键是一个不寻常或区分性的特征。在这种情况下，我们在名称中指明键，例如，`receipt_timestamp_map`。
- en: Naming Objects
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名对象
- en: 'Objects typically have a concrete “real world” analog and we name them accordingly:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对象通常有一个具体的“现实世界”对应物，我们相应地命名它们：
- en: '**An object variable name should be a noun** followed by an optional modifier—`employee`
    or `receipt`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象变量名应该是一个名词**，后跟一个可选的修饰符——`employee` 或 `receipt`。'
- en: '**Make sure a module-scoped object variable name has two syllables** or more
    so the scope is clear—`storeEmployee` or `salesReceipt`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保模块作用域的对象变量名有两个或更多音节**，以便作用域清晰——`storeEmployee` 或 `salesReceipt`。'
- en: '**Prefix jQuery objects with a $.** This is a common convention these days,
    and jQuery objects (or collections as they’re sometimes called) are prevalent
    in SPAs.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在 jQuery 对象前加上 $.** 这是当今的一个常见约定，jQuery 对象（或有时称为集合）在单页应用（SPAs）中很常见。'
- en: '[Table A.8](#app01table08) shows some examples.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 A.8](#app01table08) 展示了一些示例。'
- en: Table A.8\. Example object names
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.8\. 示例对象名称
- en: '| Indicator | Local scope | Module scope |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 本地作用域 | 模块作用域 |'
- en: '| --- | --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *none* (singular noun) | employee | storeEmployee |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| *none*（单数名词）| 员工 | 店铺员工 |'
- en: '| *none* (singular noun) | receipt | salesReceipt |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| *none*（单数名词）| 收据 | 销售收据 |'
- en: '| $ | $area_tabs | $areaTabs |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| $ | $area_tabs | $areaTabs |'
- en: If we expect a jQuery collection to contain multiple entries, we make it plural.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们期望 jQuery 集合包含多个条目，我们将其变为复数。
- en: Naming Functions
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数命名
- en: 'A function almost always performs an action on an object. Therefore we always
    like to place the action verb as the first part of a function name:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 函数几乎总是对一个对象执行操作。因此，我们总是喜欢将动作动词作为函数名称的第一部分：
- en: '**Name functions should always include a verb followed by a noun**, for example,
    `get_record` or `empty_cache_map`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数名应始终包含一个动词后跟一个名词**，例如 `get_record` 或 `empty_cache_map`。'
- en: '**Module-scoped functions should always contain two or more syllables** so
    the scope is clear, for example, `getRecord` or `emptyCacheMap`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块作用域的函数应始终包含两个或更多音节**，以便作用域清晰，例如 `getRecord` 或 `emptyCacheMap`。'
- en: '**Use consistent verb meanings**. [Table A.9](#app01table09) shows consistent
    meanings for common verbs.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用一致的动词意义**。[表 A.9](#app01table09) 显示了常见动词的一致意义。'
- en: Table A.9\. Example function names
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.9\. 示例函数名称
- en: '| Indicator | Meaning of indicator | Local scope | Module scope |'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 指示符 | 指示符的含义 | 本地作用域 | 模块作用域 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| fn [generic] | Generic function indicator. | fn_sync | fnSync |'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| fn [通用] | 通用函数指示符。 | fn_sync | fnSync |'
- en: '| curry | Return a function as specified by argument(s). | curry_make_user
    | curryMakeUser |'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| curry | 返回由参数指定的函数。 | curry_make_user | curryMakeUser |'
- en: '| destroy, remove | Remove a data structure, such as an array. Implies that
    data references will be tidied up as needed. | destroy_entry, remove_element |
    destroyEntry, removeElement |'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| destroy, remove | 删除数据结构，例如数组。意味着数据引用将根据需要整理。 | destroy_entry, remove_element
    | destroyEntry, removeElement |'
- en: '| empty | Remove some or all members of a data structure without removing the
    container—for example, remove all elements of an array but leave the array intact.
    | empty_cache_map | emptyCacheMap |'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| empty | 在不删除容器的情况下删除数据结构的一些或全部成员——例如，删除数组中的所有元素但保持数组完整。 | empty_cache_map
    | emptyCacheMap |'
- en: '| fetch | Return data fetched from an external source, such as from an AJAX
    or web socket call. | fetch_user_list | fetchUserList |'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| fetch | 从外部源返回数据，例如从 AJAX 或 WebSocket 调用。 | fetch_user_list | fetchUserList
    |'
- en: '| get | Return data from an object or other internal data structure. | get_user_list
    | getUserList |'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| get | 从对象或其他内部数据结构返回数据。 | get_user_list | getUserList |'
- en: '| make | Return newly constructed object (doesn’t use the new operator) | make_user
    | makeUser |'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| make | 返回新构造的对象（不使用 new 操作符） | make_user | makeUser |'
- en: '| on | Event handler. The event should be a single word as in the HTML markup.
    | on_mouseover | onMouseover |'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| on | 事件处理器。事件应为一个单词，如 HTML 标记中的用法。 | on_mouseover | onMouseover |'
- en: '| save | Save data to an object or other internal data structure. | save_user_list
    | saveUserList |'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| save | 将数据保存到对象或其他内部数据结构。 | save_user_list | saveUserList |'
- en: '| set | Initialize or update values as provided by arguments. | set_user_name
    | setUserName |'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| set | 初始化或更新由参数提供的值。 | set_user_name | setUserName |'
- en: '| store | Send data to an external source for storage, for example via an AJAX
    call. | store_user_list | storeUserList |'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| store | 将数据发送到外部源进行存储，例如通过 AJAX 调用。 | store_user_list | storeUserList |'
- en: '| update | Similar to set, but has a “was previously initialized” connotation
    | update_user_list | updateUserList |'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| update | 与 set 类似，但有“之前已初始化”的含义 | update_user_list | updateUserList |'
- en: We’ve found the `make` constructor verb, and the distinctions between `fetch/get`
    and `store/save`, especially valuable in communicating intent across a development
    team. Also, using `onEventname` for event handlers has become common and useful.
    The general form is *on<eventname><modifier>* where the modifier is optional.
    Note that we keep the event name as a single word. For example, `onMouseover`
    *not* `onMouseOver`, or `on_dragstart` *not* `on_drag_start`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了 `make` 构造函数动词，以及 `fetch/get` 和 `store/save` 之间的区别，这在跨开发团队传达意图方面特别有价值。此外，使用
    `onEventname` 作为事件处理器已成为常见且有用。一般形式为 *on<eventname><modifier>*，其中修饰符是可选的。请注意，我们保持事件名称为一个单词。例如，`onMouseover`
    *不是* `onMouseOver`，或 `on_dragstart` *不是* `on_drag_start`。
- en: Naming Variables with Unknown Types
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 未知类型变量命名
- en: 'Sometimes we really don’t know what data types our variables contain. There
    are two situations where this is common:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们真的不知道我们的变量包含什么数据类型。这种情况通常有两种情况：
- en: '**We’re writing a polymorphic function**—one that accepts multiple data types.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们编写一个多态函数**——一个可以接受多种数据类型的函数。'
- en: '**We’re receiving data from an external data source**, such as an AJAX or web
    socket feed.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们从外部数据源接收数据**，例如 AJAX 或 WebSocket 数据流。'
- en: In these cases, the primary feature of the variable is the uncertainty of its
    data type. We’ve settled on a practice of ensuring the word `data` is in the name
    (see [Table A.10](#app01table10)).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，变量的主要特征是其数据类型的不可确定性。我们确定了一个做法，确保名字中包含单词 `data`（见 [表 A.10](#app01table10)）。
- en: Table A.10\. Example data names
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 A.10. 示例数据名称
- en: '| Local scope | Module scope | Notes |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 本地作用域 | 模块作用域 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| http_data, socket_data | httpData, socketData | Unknown data type received
    from an HTTP feed or web socket |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| http_data, socket_data | httpData, socketData | 从 HTTP 源或 WebSocket 接收到的未知数据类型
    |'
- en: '| arg_data, data | --- | Unknown data type received as an argument |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| arg_data, data | --- | 接收到的参数数据类型未知 |'
- en: Now that we’ve reviewed our naming guidelines, let’s put them to use.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查了我们的命名指南，让我们开始使用它们。
- en: A.3.3\. Put the guidelines to use
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.3. 应用指南
- en: Let’s compare an object prototype before and after we apply naming guidelines.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用命名指南之前和之后，让我们比较一下对象原型的变化。
- en: Listing A.22\. Not like this
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.22. 不像这样
- en: '![](354fig01_alt.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](354fig01_alt.jpg)'
- en: Listing A.23\. But like this
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.23. 但像这样
- en: '![](354fig02_alt.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](354fig02_alt.jpg)'
- en: These examples are snippets from two web page examples—`[listings/apx0A/bad_dog.html](http://listings/apx0A/bad_dog.html)`
    and `[listings/apx0A/good_dog.html](http://listings/apx0A/good_dog.html)` found
    in the book resources. You’re encouraged to download and compare them to see which
    is more comprehensible and maintainable.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例是从两篇网页示例中摘录的——可以在本书资源中找到的 `[listings/apx0A/bad_dog.html](http://listings/apx0A/bad_dog.html)`
    和 `[listings/apx0A/good_dog.html](http://listings/apx0A/good_dog.html)`。我们鼓励您下载并比较它们，看看哪个更易于理解和维护。
- en: A.4\. Variable declaration and assignment
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4. 变量声明和赋值
- en: Variables can be assigned to functions pointers, object pointers, array pointers,
    strings, numbers, null, or undefined. Some JavaScript implementations may make
    internal distinctions between integers, 32-bit signed, and 64-bit double-precision
    floating point numbers, but there’s no formal interface to enforce this typing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以被赋值为函数指针、对象指针、数组指针、字符串、数字、null 或 undefined。一些 JavaScript 实现可能在整数、32 位有符号和
    64 位双精度浮点数之间进行内部区分，但没有正式的接口来强制这种类型。
- en: '**Use {} or []** instead of `new Object()` or `new Array()` to create a new
    object, map, or array. Remember, a map is a simple data-only object with no methods.
    If you require object inheritance, use the `createObject` utility shown in [chapter
    2](kindle_split_012.html#ch02) and in Section A.5 of this appendix.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 `{}` 或 `[]`** 来创建新的对象、映射或数组，而不是使用 `new Object()` 或 `new Array()`。记住，映射是一个没有方法的简单数据对象。如果您需要对象继承，请使用
    [第 2 章](kindle_split_012.html#ch02) 和本附录的 A.5 节中展示的 `createObject` 工具。'
- en: '**Use utilities to copy objects and arrays.** Simple variables such as booleans,
    strings, or numbers are copied when they’are assigned. For example, `new_str =
    this_str` will copy the underlying data (in this case, a string) to `new_str`.
    Complex variables in JavaScript, such as arrays and objects, are *not* copied
    when they’re assigned; instead the pointer to the data structure is copied. For
    example, `second_map = first_map`, will result in `second_map` pointing to the
    same data as `first_map`, and any manipulations of `second_map` will be reflected
    in `first_map`. Copying arrays and objects correctly is not always obvious or
    easy. We highly recommend the use of well-tested utilities for this purpose, such
    as those provided by jQuery.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用工具来复制对象和数组**。当变量被赋值时，简单的变量，如布尔值、字符串或数字会被复制。例如，`new_str = this_str` 将会将底层数据（在这种情况下，是一个字符串）复制到
    `new_str`。JavaScript 中的复杂变量，如数组和对象，在赋值时**不会**被复制；相反，数据结构的指针会被复制。例如，`second_map
    = first_map` 将导致 `second_map` 指向与 `first_map` 相同的数据，并且对 `second_map` 的任何操作都会反映在
    `first_map` 上。正确地复制数组和对象并不总是显而易见或容易。我们强烈建议使用经过良好测试的工具来完成此目的，例如 jQuery 提供的工具。'
- en: '**Explicitly declare all variables first** in the functional scope using a
    single `var` key-word. JavaScript scopes variables by function and doesn’t provide
    block scope. Therefore if you declare a variable anywhere within a function, it’ll
    be initialized with a value of `undefined` immediately on invocation of the function.
    Placing all the variable declarations first recognizes this behavior. It also
    makes the code easier to read and to detect undeclared variables (which are never
    acceptable).'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首先在功能范围内使用单个`var`关键字明确声明所有变量**。JavaScript通过函数来管理变量作用域，并且不提供块级作用域。因此，如果你在函数内部任何地方声明一个变量，在函数调用时它将被立即初始化为`undefined`的值。将所有变量声明放在前面可以识别这种行为。这也有助于使代码更易于阅读和检测未声明的变量（这是不可接受的）。'
- en: '![](355fig01_alt.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](355fig01_alt.jpg)'
- en: 'Declaring a variable is *not* the same as assigning a value to it: *declaring*
    informs the JavaScript engine that the variable exists within a scope. *Assigning*
    provides the variable a value (instead of `undefined`). As a convenience, you
    may combine declaration and assignment with the `var` statement, but it’s not
    required.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个变量与向其赋值不同：*声明*通知JavaScript引擎该变量存在于某个作用域中。*赋值*为变量提供一个值（而不是`undefined`）。为了方便，你可以使用`var`语句将声明和赋值结合起来，但这不是必需的。
- en: '**Don’t use blocks** as JavaScript doesn’t provide block scope.^([[6](#app01fn06)])
    Defining variables in blocks can confuse programmers who are experienced with
    other C family languages. Define variables in functional scope instead.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用代码块**，因为JavaScript不提供块级作用域.^([[6](#app01fn06)]) 在代码块中定义变量可能会让熟悉其他C系列语言的程序员感到困惑。请在功能作用域中定义变量。'
- en: ⁶ This is mostly true, but Firefox’s JavaScript, as of version 1.7, introduced
    the `let` statement, which can be used to provide block scope. But it’s not supported
    by all major browsers and, therefore, should be ignored.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 这基本上是正确的，但截至版本1.7，Firefox的JavaScript引入了`let`语句，它可以用来提供块级作用域。但是，它不是所有主流浏览器都支持的，因此应该忽略。
- en: '**Assign all functions to variables.** This reinforces the fact that JavaScript
    treats functions as first-class objects.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将所有函数分配给变量**。这强调了JavaScript将函数视为一等对象的事实。'
- en: '[PRE12]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Use named arguments** whenever requiring three or more arguments in a function,
    as positional arguments are easy to forget and aren’t self-documenting.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在函数中需要三个或更多参数时，请使用命名参数**，因为位置参数容易忘记，并且不具备自文档化的特性。'
- en: '[PRE13]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Use one line per variable assignment.** Order them alphabetically or in logical
    groups when possible. *More than one declaration* may be placed on a single line:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个变量赋值使用一行**。如果可能，按字母顺序或逻辑分组排序。*多个声明*可以放在同一行上：'
- en: '![](356fig01_alt.jpg)'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](356fig01_alt.jpg)'
- en: A.5\. Functions
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5\. 函数
- en: 'Functions play a central role in JavaScript: they organize code, provide a
    container for variable scope, and they provide an execution context which can
    be used to construct prototype-based objects. So though we have few guidelines
    for functions, we hold them quite dear.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在JavaScript中扮演着核心角色：它们组织代码，提供变量作用域的容器，并提供执行上下文，可以用来构建基于原型的对象。因此，尽管我们对函数的指导原则不多，但我们非常重视它们。
- en: '**Use the factory pattern for object constructors**, as it better illustrates
    how JavaScript objects actually work, is fast, and can be used to provide class-like
    capabilities like object count.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用工厂模式进行对象构造**，因为它更好地说明了JavaScript对象的实际工作方式，速度快，并且可以用来提供类似类的功能，如对象计数。'
- en: '[PRE14]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Avoid pseudoclassical object constructors**—those that take a `new` keyword.
    If you call such a constructor without the `new` keyword, the global namespace
    gets corrupted. If you *must* keep such a constructor, its first letter should
    be capitalized so it may be recognized as a pseudo classical constructor.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免使用伪类对象构造函数**——那些带有`new`关键字的。如果你不带`new`关键字调用这样的构造函数，全局命名空间会被破坏。如果你*必须*保留这样的构造函数，它的第一个字母应该大写，以便识别为伪类构造函数。'
- en: '**Declare all functions before they are used**—remember that declaring functions
    is *not* the same as *assigning a value* to them.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在使用函数之前声明所有函数**——记住，声明函数与*赋值*给它们是不同的。'
- en: '**When a function is to be invoked immediately**, wrap the function in parenthesis
    so that it’s clear that the value being produced is the result of the function
    and not the function itself: `spa.shell = (function () { ... }());`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当函数需要立即调用时**，将函数用括号括起来，以便清楚地表明产生的值是函数的结果，而不是函数本身：`spa.shell = (function ()
    { ... }());`'
- en: A.6\. Namespaces
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.6\. 命名空间
- en: Much early JavaScript code was relatively small and used alone on a single web
    page. These scripts could (and often *did*) use global variables with few repercussions.
    But as JavaScript applications have become more ambitious and third-party libraries
    have become common, the chance that someone else is going to want the global `i`
    variable rises steeply. And when two code bases claim the same global variable,
    all hell can break loose.^([[7](#app01fn07)])
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的许多 JavaScript 代码相对较小，并且单独在单个网页上使用。这些脚本可以使用全局变量，几乎没有影响。但随着 JavaScript 应用程序变得更加雄心勃勃，第三方库变得普遍，其他人想要全局
    `i` 变量的可能性急剧增加。当两个代码库声称相同的全局变量时，所有的事情都可能变得混乱。[^([[7](#app01fn07))]
- en: ⁷ The author once worked on an application where a third-party library suddenly
    and mistakenly claimed the global variable `util` (they should have used JSLint...).
    Though our application had only three namespaces, `util` was one of them. The
    conflict crashed our application, and it took four hours to diagnose and work
    around the problem. We were significantly less than happy.
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作者曾经在一个应用程序中工作，其中一个第三方库突然错误地声明了全局变量 `util`（他们本应该使用 JSLint...）。尽管我们的应用程序只有三个命名空间，`util`
    就是其中之一。这种冲突导致我们的应用程序崩溃，诊断和解决这个问题花了四个小时。我们非常不满意。
- en: 'We can greatly minimize this problem by using only a single global function
    inside of which all our other variables are scoped as illustrated here:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在单个全局函数内部使用所有其他变量作为示例来大大减少这个问题：
- en: '[PRE15]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We call this single global function (`spa`, in this example) our *namespace*.
    The function we assign to it executes on load, and of course, any local variables
    assigned within that function won’t be available to the global namespace. Note
    that we did make the `init-Module` method available. So other code can call the
    initialization function, but it can’t access anything else. And it has to use
    our `spa` prefix:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个单独的全局函数（在这个例子中是 `spa`）为我们的 *命名空间*。我们分配给它的函数在加载时执行，当然，在该函数内部分配的任何局部变量都不会对全局命名空间可用。请注意，我们确实使
    `init-Module` 方法可用。因此，其他代码可以调用初始化函数，但不能访问其他内容。而且它必须使用我们的 `spa` 前缀：
- en: '[PRE16]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can subdivide the namespace so that we aren’t forced to cram a 50KB application
    into a single file. For example, we can create the namespaces of `spa`, `spa.shell`,
    and `spa.slider`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以细分命名空间，这样我们就不必被迫将一个 50KB 的应用程序压缩到一个文件中。例如，我们可以创建 `spa`、`spa.shell` 和 `spa.slider`
    的命名空间：
- en: '[PRE17]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This namespacing is key to creating manageable code in JavaScript.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名空间对于在 JavaScript 中创建可管理的代码至关重要。
- en: A.7\. File names and layout
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.7\. 文件名和布局
- en: 'Namespacing is the foundation of our file naming and layout. Here are the general
    guidelines:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是我们文件命名和布局的基础。以下是一些一般性指南：
- en: '**Use jQuery** for DOM manipulations.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 jQuery** 进行 DOM 操作。'
- en: '**Investigate third-party code** like jQuery plugins before building your own—balance
    the cost of integration and bloat versus the benefits of standardization and code
    consistency.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在构建自己的代码之前调查第三方代码**，如 jQuery 插件——平衡集成成本和膨胀与标准化和代码一致性的好处。'
- en: '**Avoid embedding** **JavaScript** code in HTML; use external libraries instead.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免在 HTML 中嵌入** **JavaScript** 代码；使用外部库代替。'
- en: '**Minify, obfuscate, and gzip** JavaScript and CSS before go-live. For example,
    use Uglify to minify and obsfucate Javascript during preparation, and use Apache2/
    mod_gzip to gzip the files on delivery.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在上线前压缩、混淆和 gzip JavaScript 和 CSS**。例如，在准备阶段使用 Uglify 压缩和混淆 JavaScript，在交付时使用
    Apache2/ mod_gzip 对文件进行 gzip。'
- en: 'JavaScript file guidelines are as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 文件指南如下：
- en: '**Include third-party JavaScript files first** in our HTML so their functions
    may be evaluated and made ready for our application.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在我们的 HTML 中首先包含第三方 JavaScript 文件**，这样它们的函数就可以被评估并准备好用于我们的应用程序。'
- en: '**Include our JavaScript files next**, in order of namespace. You can’t load
    namespace `spa.shell`, for example, if the root namespace, `spa`, has not yet
    been loaded.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按命名空间的顺序包含我们的 JavaScript 文件**。例如，如果根命名空间 `spa` 尚未加载，则无法加载命名空间 `spa.shell`。'
- en: '**Give all JavaScript files a .js suffix**.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给所有 JavaScript 文件添加 .js 后缀**。'
- en: '**Store all static JavaScript files** under a directory called `js`.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将所有静态 JavaScript 文件存储在名为 `js` 的目录下**。'
- en: '**Name JavaScript files** according to the namespace they provide, one namespace
    per file. Examples:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据提供的命名空间命名 JavaScript 文件**，每个文件一个命名空间。例如：'
- en: '[PRE18]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Use the template** to start any JavaScript module file. One is found at the
    end of this appendix.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用模板**开始任何 JavaScript 模块文件。一个可以在本附录的末尾找到。'
- en: 'We maintain a parallel structure between JavaScript and CSS files and class
    names:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 JavaScript 和 CSS 文件以及类名之间保持平行结构：
- en: '**Create a CSS file for each JavaScript file** that generates HTML. Examples:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为每个生成 HTML 的 JavaScript 文件创建一个 CSS 文件**。例如：'
- en: '[PRE19]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Give all CSS files a .css suffix.**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给所有 CSS 文件添加 .css 后缀。**'
- en: '**Store all CSS files** under a directory called *css*.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将所有 CSS 文件**存储在名为 *css* 的目录下。'
- en: '**Prefix CSS selectors** according to the name of the module they support.
    This practice helps greatly to avoid unintended interaction with classes from
    third-party modules. Examples:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据模块的名称前缀 CSS 选择器**。这种做法有助于极大地避免与第三方模块的类产生意外交互。例如：'
- en: '[PRE20]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Use <namespace>-x-<descriptor>** for state-indicator and other shared class
    names. Examples include `spa-x-select` and `spa-x-disabled`. Place these in the
    root namespace stylesheet, for example `spa.css`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 <namespace>-x-<descriptor>** 为状态指示符和其他共享类名。例如包括 `spa-x-select` 和 `spa-x-disabled`。将这些放在根命名空间样式表中，例如
    `spa.css`。'
- en: These are simple guidelines and easy to follow. The resulting organization and
    consistency make the correlation between CSS and JavaScript much easier to understand.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是简单的指南，易于遵循。结果的组织和一致性使得 CSS 和 JavaScript 之间的关联更容易理解。
- en: A.8\. Syntax
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.8\. 语法
- en: This section is a survey of JavaScript syntax and the guidelines we follow.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是对 JavaScript 语法以及我们遵循的指南的概述。
- en: A.8.1\. Labels
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.8.1\. 标签
- en: 'Statement labels are optional. Only these statements should be labeled: `while`,
    `do`, `for`, `switch`. Labels should always be uppercase and should be a singular
    noun:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 语句标签是可选的。只有以下这些语句应该有标签：`while`、`do`、`for`、`switch`。标签应始终为大写单数名词：
- en: '[PRE21]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A.8.2\. Statements
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.8.2\. 语句
- en: Common JavaScript statements are listed next, along with our suggested use.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下文列出了常见的 JavaScript 语句，以及我们建议的使用方式。
- en: Continue
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Continue
- en: We avoid use of the `continue` statement unless we use a label. It otherwise
    tends to obscure the control flow. The inclusion of a label also makes `continue`
    more resilient.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免使用 `continue` 语句，除非我们使用标签。否则，它往往会模糊控制流。标签的包含也使得 `continue` 更健壮。
- en: '[PRE22]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: DO
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: DO
- en: 'A `do` statement should have the following form:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` 语句应具有以下形式：'
- en: '[PRE23]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Always end a `do` statement with a semicolon.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 总是以分号结束 `do` 语句。
- en: For
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: For
- en: 'A `for` statement should have one of the forms illustrated next:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句应具有以下形式之一：'
- en: '[PRE24]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first form should be used with arrays and with loops of a known number of
    iterations.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式应与数组和已知迭代次数的循环一起使用。
- en: 'The second form should be used with objects and maps. Be aware that members
    with attributes and methods added to the prototype of the object will be included
    in the enumeration. Use the `hasOwnProperty` method to filter the true properties:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式应与对象和映射一起使用。请注意，添加到对象原型的属性和方法将包含在枚举中。使用 `hasOwnProperty` 方法来过滤真正的属性：
- en: '[PRE25]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: If
- en: 'The `if` statement should have one of the forms illustrated as follows. An
    `else` keyword should begin its own line:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句应具有以下形式之一。`else` 关键字应开始其自己的行：'
- en: '[PRE26]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Return
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Return
- en: A `return` statement shouldn’t use parentheses around the return value. The
    `return` value expression must start on the same line as the `return` keyword
    in order to avoid semicolon insertion.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 语句不应在返回值周围使用括号。返回值表达式必须与 `return` 关键字在同一行上开始，以避免插入分号。'
- en: Switch
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Switch
- en: 'A `switch` statement should have the following form:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句应具有以下形式：'
- en: '[PRE27]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each group of statements (except the default) should end with `break`, `return`,
    or `throw`; fall-through should only be used with great caution and accompanying
    comments, and even then you should rethink the need for it. Is the terseness really
    worth the trade-off in legibility? Probably not.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 每组语句（除了默认情况）应结束于 `break`、`return` 或 `throw`；只有在使用标签和伴随注释时才应使用 fall-through，并且即使如此，也应重新考虑其必要性。简洁性真的值得牺牲可读性吗？可能不是。
- en: Try
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Try
- en: 'A `try` statement should have one of the following forms:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句应具有以下形式之一：'
- en: '[PRE28]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: While
- en: 'A `while` statement should have the following form:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句应具有以下形式：'
- en: '[PRE29]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`While` statements should be avoided as they tend to induce endless loop conditions.
    Favor using the `for` statement when possible.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免使用 `while` 语句，因为它们往往会引起无限循环条件。尽可能使用 `for` 语句。
- en: With
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: With
- en: The `with` statement should be avoided. Use the `object.call()` family of methods
    instead to adjust the value of `this` during function invocation.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免使用 `with` 语句。使用 `object.call()` 方法族来调整函数调用期间 `this` 的值。
- en: A.8.3\. Other syntax
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.8.3\. 其他语法
- en: 'Of course there’s more to JavaScript than just labels and statements. Here
    are some additional guidelines we follow:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，JavaScript不仅仅是标签和语句。以下是我们遵循的一些额外指南：
- en: Avoid the Comma Operator
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 避免使用逗号运算符
- en: Avoid the use of the comma operator (as found in some `for` loop constructs).
    This doesn’t apply to the comma separator, which is used in object literals, array
    literals, var statements, and parameter lists.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用逗号运算符（如在某些`for`循环结构中找到的）。这不适用于逗号分隔符，它在对象字面量、数组字面量、var语句和参数列表中使用。
- en: Avoid Assignment Expressions
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 避免使用赋值表达式
- en: Avoid using assignments in the condition part of `if` and `while` statements—don’t
    write `if ( a = b ) { ...` as it’s not clear if you intended to test for equality
    or a successful assignment.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在`if`和`while`语句的条件部分使用赋值——不要写成`if ( a = b ) { ...`，因为这不清楚你是否打算测试相等性或成功的赋值。
- en: Always Use === and !== Comparisons
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总是使用 === 和 !== 比较运算符
- en: 'It is almost always better to use the `===` and `!==` operators. The `==` and
    `!=` operators do type coercion. In particular, don’t use `==` to compare against
    falsey values. Our JSLint configuration doesn’t allow type coercion. If you want
    to test if a value is truthy or falsey, use a construct like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是最好使用`===`和`!==`运算符。`==`和`!=`运算符会进行类型强制转换。特别是，不要使用`==`来比较非真值。我们的JSLint配置不允许类型强制转换。如果你想测试一个值是否为真值或假值，可以使用如下结构：
- en: '[PRE30]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Avoid Confusing Pluses and Minuses
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 避免混淆加号和减号
- en: Be careful to not follow a `+` with a `+` or a `++`. This pattern can be confusing.
    Insert parentheses between them to make your intention clear.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要将一个`+`后面直接跟另一个`+`或`++`。这种模式可能会令人困惑。在它们之间插入括号以明确你的意图。
- en: '[PRE31]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This prevents the `+ +` from being misread as `++`. The same guideline applies
    for the minus sign, `-`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止`+ +`被误读为`++`。同样的规则也适用于减号，`-`。
- en: Don’t Use Eval
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不要使用Eval
- en: Be careful—`eval` has evil aliases. Don’t use the `Function` constructor. Don’t
    pass strings to `setTimeout` or `setInterval`. Use a parser instead of `eval`
    to convert JSON strings into internal data structures.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 小心——`eval`有邪恶的别名。不要使用`Function`构造函数。不要将字符串传递给`setTimeout`或`setInterval`。使用解析器而不是`eval`将JSON字符串转换为内部数据结构。
- en: A.9\. Validating code
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.9. 验证代码
- en: JSLint is a JavaScript validation tool written and maintained by Douglas Crockford.
    It’s very popular and useful in spotting code errors and ensuring fundamental
    guidelines are followed. If you’re creating professional-grade JavaScript, you
    should be using JSLint or a similar validator. It helps us avoid numerous types
    of bugs and significantly shortens development time.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: JSLint是由Douglas Crockford编写和维护的JavaScript验证工具。它非常受欢迎且非常有用，可以查找代码错误并确保遵循基本指南。如果你正在创建专业级的JavaScript，你应该使用JSLint或类似的验证器。它帮助我们避免了许多类型的错误，并显著缩短了开发时间。
- en: A.9.1\. Install JSLint
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.9.1. 安装JSLint
- en: Download the latest jslint4java distribution, such as `jslint4java-2.0.2.zip`,
    from [http://code.google.com/p/jslint4java/](http://code.google.com/p/jslint4java/)
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://code.google.com/p/jslint4java/](http://code.google.com/p/jslint4java/)下载最新的jslint4java发行版，例如`jslint4java-2.0.2.zip`。
- en: Unpack and install per the instructions for your platform.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您平台上的说明进行解包和安装。
- en: '|  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**If you’re running OS X or Linux**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你正在运行OS X或Linux**'
- en: 'You may move the jar file, for example `sudo mv jslint4java-2.0.2.jar /usr/local/lib/`,
    and then create the following wrapper in `/usr/local/bin/jslint`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将jar文件移动，例如`sudo mv jslint4java-2.0.2.jar /usr/local/lib/`，然后在`/usr/local/bin/jslint`中创建以下包装器：
- en: '[PRE32]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Make sure jslint is executable—`sudo chmod 755 /usr/local/bin/jslint`
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 确保jslint是可执行的——`sudo chmod 755 /usr/local/bin/jslint`
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you have Node.js installed, you may install a different version like so:
    `npm install-g jslint`. This version runs much faster, although it’s untested
    with the listings in this book.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了Node.js，你可以安装不同的版本，例如：`npm install-g jslint`。这个版本运行得更快，尽管它没有与本书中的列表进行测试。
- en: A.9.2\. Configure JSLint
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.9.2. 配置JSLint
- en: 'Our module template includes the configuration for JSLint. These settings are
    used to match our coding standard:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模块模板包括JSLint的配置。这些设置用于匹配我们的编码标准：
- en: '[PRE33]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`browser : true`—Allow browser keywords like `document`, `history`, `clearInterval`,
    and so on.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browser : true`—允许浏览器关键字如`document`、`history`、`clearInterval`等。'
- en: '`continue : true`—Allow the `continue` statement.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue : true`—允许`continue`语句。'
- en: '`devel : true`—Allow development keywords like `alert`, `console`, and so forth.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devel : true`—允许开发关键字如`alert`、`console`等。'
- en: '`indent : 2`—Expect two-space indentation.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indent : 2`—期望两个空格缩进。'
- en: '`maxerr : 50`—Abort JSLint after 50 errors.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxerr : 50`—在50个错误后终止JSLint。'
- en: '`newcap : true`—Tolerate leading underscores.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newcap : true`—容忍前导下划线。'
- en: '`nomen : true`—Tolerate uncapitalized constructors.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nomen : true`—容忍未大写的构造函数。'
- en: '`plusplus : true`—Tolerate ++ and --.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plusplus : true`—容忍 ++ 和 --。'
- en: '`regexp : true`—Allow useful but potentially dangerous regular expression constructions.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp : true`—允许有用但可能危险的正则表达式构造。'
- en: '`sloppy : true`—Don’t require the `use strict` pragma.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sloppy : true`—不要求使用 `use strict` 预言。'
- en: '`vars : false`—Don’t allow multiple `var` statements per functional scope.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars : false`—不允许在功能作用域内多次使用 `var` 语句。'
- en: '`white : true`—Disable JSLint’s formatting checks.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`white : true`—禁用 JSLint 的格式检查。'
- en: A.9.3\. Use JSLint
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.9.3. 使用 JSLint
- en: 'We can use JSLint from the command line whenever we want to check code validity.
    The syntax is:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在需要检查代码有效性时随时从命令行使用 JSLint。语法如下：
- en: '[PRE34]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve written a `git` commit hook to test all changed JavaScript files before
    allowing a commit into the repository. The following shell script can be added
    as `repo/.git/hooks/pre-commit`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个 `git` 提交钩子，在允许将更改的 JavaScript 文件提交到仓库之前，对其进行测试。以下 shell 脚本可以添加为 `repo/.git/hooks/pre-commit`。
- en: '[PRE35]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You may need to modify it somewhat for your purposes. Also, please ensure it’s
    executable (in Mac or Linux, `chmod 755 pre-commit`).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要根据您的需求对其进行一些修改。另外，请确保它是可执行的（在 Mac 或 Linux 中，`chmod 755 pre-commit`）。
- en: A.10\. A template for modules
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.10. 模块模板
- en: 'Experience has shown that breaking a module into consistent sections is a valuable
    practice. It assists our comprehension and navigation, and it reminds us of good
    coding practice. The template we’ve settled on after hundreds of modules over
    many projects is shown next, with some sample code sprinkled in:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 经验表明，将模块分解为一致的章节是一种有价值的实践。它有助于我们的理解和导航，并提醒我们良好的编码实践。在数百个模块和多个项目中，我们确定下来的模板如下，其中穿插了一些示例代码：
- en: Listing A.24\. Recommended module template
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.24. 推荐的模块模板
- en: '![](app01list24-0.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图片](app01list24-0.jpg)'
- en: '![](app01list24-1.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图片](app01list24-1.jpg)'
- en: A.11\. Summary
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.11. 摘要
- en: A good coding standard is required for one or many developers to work most effectively.
    The standard we present is comprehensive and cohesive, but we recognize it may
    not be right for every team. In any event, we hope it encourages our readers to
    think about common issues and how a convention may solve or mitigate them. We
    strongly advise any team to agree on a standard before embarking on a large project.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个或多个开发者高效工作，需要良好的编码标准。我们提出的标准是全面且一致的，但我们认识到它可能并不适合每个团队。无论如何，我们希望它能鼓励我们的读者思考常见问题以及公约如何解决或减轻这些问题。我们强烈建议任何团队在开始大型项目之前就达成一致的标准。
- en: Code will be read many times more than it will be written, so we optimize for
    readability. We limit our lines to 78 characters and use a two-space indentation.
    We don’t allow tab stops. We group our lines into logical paragraphs to help readers
    understand our intent, and we break lines consistently. K&R style is used for
    bracketing, and whitespace is used to differentiate keywords from functions. We
    prefer to use the single quote when defining string literals. We favor conventions
    over comments to convey what the code is doing. Descriptive and consistent variable
    names are key to conveying our intent without over-using comments. When we comment,
    we document strategically by paragraph. Non-trivial internal interfaces are documented
    consistently.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将被阅读得多于编写，因此我们优化了可读性。我们限制行宽为 78 个字符，并使用两个空格缩进。我们不允许使用制表符。我们将行分组为逻辑段落，以帮助读者理解我们的意图，并保持行的一致性。我们使用
    K&R 风格进行括号，并使用空格来区分关键字和函数。我们倾向于在定义字符串字面量时使用单引号。我们更喜欢使用公约而不是注释来传达代码的功能。描述性和一致的变量名是传达我们的意图的关键，而不需要过度使用注释。当我们注释时，我们通过段落进行战略性的文档记录。非平凡的内部接口是一致记录的。
- en: We protect our code from unwanted interaction with other scripts through the
    use of namespaces. Self-executing functions are used to provide namespaces. We
    subdivide our root namespace to organize our code and provide reasonable file
    size and scope. Our JavaScript files each contain a single namespace, and their
    filename reflects the namespace they provide. We create a parallel namespace for
    CSS selectors and files.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用命名空间来保护我们的代码不受其他脚本的不当交互。我们使用自执行函数来提供命名空间。我们将根命名空间细分以组织我们的代码，并提供合理的文件大小和范围。我们的
    JavaScript 文件每个都包含一个命名空间，它们的文件名反映了它们提供的命名空间。我们为 CSS 选择器和文件创建了一个并行命名空间。
- en: We installed and configured JSLint. Our code is always validated using JSLint
    before we allow it to be checked into our code base. We use consistent settings
    for validation. We presented a module template that embodies many of the conventions
    presented and that includes our JSLint settings in the header.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装并配置了JSLint。在允许代码被提交到我们的代码库之前，我们总是使用JSLint来验证我们的代码。我们使用一致的设置进行验证。我们展示了一个模块模板，它体现了许多提出的约定，并在头部包含了我们的JSLint设置。
- en: A coding standard is meant to liberate developers from menial tasks through
    the introduction of a common dialect and consistent structure. This allows them
    to instead focus their creative energy on the logic that matters. A good standard
    provides a clarity of intent crucial for the success of large-scale projects.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准旨在通过引入一种通用方言和一致的结构，使开发者从繁琐的任务中解放出来。这使他们能够将创造性的精力集中在重要的逻辑上。一个好的标准为大型项目的成功提供了至关重要的意图清晰度。
