- en: 18 Working with Hibernate OGM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 使用 Hibernate OGM
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing Hibernate OGM
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Hibernate OGM
- en: Building a simple MongoDB Hibernate OGM application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 MongoDB Hibernate OGM 简单应用程序
- en: Switching to the Neo4j NoSQL database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换到 Neo4j NoSQL 数据库
- en: The world of databases is extremely diverse and complex. Besides the challenges
    of working with different relational database systems, the NoSQL world may add
    to these challenges. One goal of the persistence frameworks is to ensure portability
    of the code, so we’ll now look at the Hibernate OGM alternative and how it tries
    to support the JPA solution working with NoSQL databases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的世界极其多样和复杂。除了与不同的关系数据库系统合作所面临的挑战外，NoSQL 世界可能还会增加这些挑战。持久性框架的一个目标是要确保代码的可移植性，因此我们现在将探讨
    Hibernate OGM 的替代方案以及它是如何尝试支持与 NoSQL 数据库一起工作的 JPA 解决方案的。
- en: 18.1 Introducing Hibernate OGM
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 介绍 Hibernate OGM
- en: A NoSQL database is a database that keeps data in a format different than relational
    tables. In general, NoSQL databases provide the advantage of flexible schemas,
    meaning that the designer of the database does not have to determine the schema
    before persisting data. In applications that quickly change their requirements,
    this may be an important advantage for development speed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库是一种以不同于关系表的形式存储数据的数据库。通常，NoSQL 数据库提供灵活的模式优势，这意味着数据库的设计者不需要在持久化数据之前确定模式。在需求快速变化的应用程序中，这可能是开发速度的一个重要优势。
- en: 'NoSQL databases can be classified according to the format they use to keep
    data:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们用于存储数据格式的不同，可以将 NoSQL 数据库进行分类：
- en: Document-oriented databases, like MongoDB, which we introduced in chapter 17,
    use JSON-like documents to keep the information.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档导向数据库，如我们在第 17 章中介绍的 MongoDB，使用类似 JSON 的文档来存储信息。
- en: 'Graph-oriented databases store information using graphs. A graph consists of
    nodes and edges: the role of the nodes is to keep the data, and the edges represent
    the relationships between nodes. Neo4j is an example of such a database.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图导向数据库使用图来存储信息。图由节点和边组成：节点的作用是存储数据，边表示节点之间的关系。Neo4j 是此类数据库的一个例子。
- en: Key/value databases store data using a map structure. The key identifies the
    record, while the value represents the data. Redis is an example of such a database.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值数据库使用映射结构来存储数据。键标识记录，而值表示数据。Redis 是此类数据库的一个例子。
- en: Wide-column stores keep data using tables, rows, and columns. The difference
    between these and traditional relational databases is that the name and format
    of a column can vary between rows belonging to the same table. This capability
    is known as dynamic columns. Apache Cassandra is an example of such a database.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广度列存储使用表、行和列来存储数据。这些与传统的关系数据库之间的区别在于，同一表的行之间的列的名称和格式可以不同。这种能力被称为动态列。Apache Cassandra
    是此类数据库的一个例子。
- en: A significant part of our previous demonstrations used JPA and Hibernate to
    interact with relational databases. This allowed us to write portable applications,
    independent of the relational database vendor, and to manage the differences between
    providers through the framework.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的许多演示都使用了 JPA 和 Hibernate 来与关系数据库交互。这使我们能够编写可移植的应用程序，独立于关系数据库供应商，并通过框架管理供应商之间的差异。
- en: Hibernate OGM extends the portability concept from relational databases to NoSQL
    databases. Portability may come with the tradeoff of influencing execution speed,
    but overall it provides more advantages than shortcomings. OGM stands for Object-Grid
    Mapper. It reuses the Hibernate Core engine, the API, and JPQL to interact not
    only with relational databases but also with NoSQL ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate OGM 将关系数据库的可移植性概念扩展到 NoSQL 数据库。可移植性可能需要以影响执行速度为代价，但总体来说，它提供的优势多于不足。OGM
    代表对象-网格映射器。它重用了 Hibernate Core 引擎、API 和 JPQL，不仅能够与关系数据库交互，还能与 NoSQL 数据库交互。
- en: Hibernate OGM supports a series of NoSQL databases, and in this chapter we’ll
    use MongoDB and Neo4j.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate OGM 支持一系列 NoSQL 数据库，在本章中我们将使用 MongoDB 和 Neo4j。
- en: 18.2 Building a simple MongoDB Hibernate OGM application
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 构建 MongoDB Hibernate OGM 简单应用程序
- en: We’ll start building a simple Hibernate OGM application managed by Maven. We’ll
    examine the steps involved, the dependencies that need to be added to the project,
    and the persistence code that needs to be written.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建一个由 Maven 管理的简单 Hibernate OGM 应用程序。我们将检查涉及的步骤、需要添加到项目中的依赖项以及需要编写的持久性代码。
- en: We’ll work first with MongoDB as a document-oriented NoSQL database. Then we’ll
    modify our application to use Neo4j, a graph-oriented NoSQL database. We’ll change
    only some needed dependencies and configurations—we won’t touch the code that
    uses JPA and JPQL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用MongoDB作为文档导向的NoSQL数据库。然后，我们将修改我们的应用程序以使用Neo4j，这是一个图导向的NoSQL数据库。我们只更改一些必要的依赖项和配置——我们不会触及使用JPA和JPQL的代码。
- en: 18.2.1 Configuring the Hibernate OGM application
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.1 配置Hibernate OGM应用程序
- en: In the Maven pom.xml file, we’ll add `org.hibernate.ogm:hibernate-ogm-bom` to
    the `dependencyManagement` section. BOM is an acronym for *bill of materials*.
    Adding a BOM to the `dependencyManagement` block will not actually add the dependency
    to the project, but it is a declaration of intention. The transitive dependencies
    that will later be found in the dependencies section will have their versions
    controlled by this initial declaration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maven pom.xml文件中，我们将在`dependencyManagement`部分添加`org.hibernate.ogm:hibernate-ogm-bom`。BOM是*材料清单*的缩写。将BOM添加到`dependencyManagement`块实际上不会将依赖项添加到项目中，但它是一个意向声明。稍后在依赖项部分找到的传递依赖项将由这个初始声明控制版本。
- en: 'Next we’ll add two other things to the dependencies section: `hibernate-ogm-mongodb`,
    which is needed to work with MongoDB, and `org.jboss.jbossts :jbossjta`, a JTA
    (Java Transaction API) implementation that Hibernate OGM will need to support
    transactions.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在依赖项部分添加另外两个东西：`hibernate-ogm-mongodb`，这是与MongoDB一起工作所需的，以及`org.jboss.jbossts
    :jbossjta`，这是一个Hibernate OGM需要支持的JTA（Java事务API）实现。
- en: 'We’ll also use JUnit 5 for testing and Lombok, a Java library that can be used
    to automatically create constructors, getters, and setters through annotations,
    thus reducing the boilerplate code. As previously mentioned (in section 17.2),
    Lombok comes with its own shortcomings: you will need a plugin for the IDE to
    understand the annotations and not complain about missing constructors, getters,
    and setters; and you cannot set breakpoints and debug inside the generated methods
    (but the need to debug generated methods is pretty rare).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用JUnit 5进行测试和Lombok，这是一个Java库，可以通过注解自动创建构造函数、获取器和设置器，从而减少样板代码。如前所述（在第17.2节中），Lombok有其自身的不足：你需要一个IDE插件来理解注解，并且不会对缺少构造函数、获取器和设置器进行抱怨；并且你无法在生成的代码中设置断点进行调试（但调试生成代码的需要相当罕见）。
- en: The resulting Maven pom.xml file is shown in the following listing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的Maven pom.xml文件如下所示。
- en: Listing 18.1 The pom.xml Maven file
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.1 pom.xml Maven文件
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll now move on to the standard configuration file for persistence units,
    src/main/ resources/META-INF/persistence.xml.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续处理持久化单元的标准配置文件，即src/main/resources/META-INF/persistence.xml。
- en: Listing 18.2 The persistence.xml configuration file
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.2 `persistence.xml`配置文件
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ The persistence.xml file configures the `ch18.hibernate_ogm` persistence unit.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `persistence.xml`文件配置了`ch18.hibernate_ogm`持久化单元。
- en: Ⓑ The vendor-specific provider implementation of the API is Hibernate OGM.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ API的供应商特定提供者实现是Hibernate OGM。
- en: Ⓒ The data store provider is MongoDB.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 数据存储提供者是MongoDB。
- en: Ⓓ The name of the database is `hibernate_ogm`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 数据库的名称是`hibernate_ogm`。
- en: Ⓔ The database will be created if it does not exist.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 如果数据库不存在，将会创建它。
- en: 18.2.2 Creating the entities
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.2 创建实体
- en: 'We’ll now create the classes that represent the entities of the application:
    `User`, `Bid`, `Item`, and `Address`. The relationships between them will be of
    type one-to-many, many-to-one, or embedded.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建代表应用程序实体的类：`User`、`Bid`、`Item`和`Address`。它们之间的关系将是单对多、多对一或嵌入式类型。
- en: Listing 18.3 The `User` class
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.3 `User`类
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ⓐ The ID field is an identifier generated by the `ID_GENERATOR` generator. This
    one uses the `uuid2` strategy, which produces a unique 128-bit UUID. For a review
    of the generator strategies, refer to section 5.2.5.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ ID字段是由`ID_GENERATOR`生成器生成的标识符。这个生成器使用`uuid2`策略，它产生一个唯一的128位UUID。有关生成器策略的回顾，请参阅第5.2.5节。
- en: Ⓑ The address does not have its own identity; it is embeddable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 地址没有自己的标识符；它是可嵌入的。
- en: Ⓒ There is a one-to-many relationship between `User` and `Bid`, with this being
    mapped by the `user` field on the `Bid` side. `CascadeType.PERSIST` indicates
    that the persist operation will be propagated from the parent `User` to the child
    `Bid`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `User`和`Bid`之间存在一对一的关系，这通过`Bid`侧的`user`字段进行映射。`CascadeType.PERSIST`表示持久化操作将从父`User`传播到子`Bid`。
- en: The `Address` class does not have its own persistence identity, and it will
    be embeddable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`类没有自己的持久化标识符，并且它是可嵌入的。'
- en: Listing 18.4 The `Address` class
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.4 `Address`类
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Item` class will contain an `id` field with a similar generation strategy
    as in `User`. The relationship between `Item` and `Bid` will be one-to-many, and
    the cascade type will propagate persist operations from parent to child.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`类将包含一个与`User`中类似的生成策略的`id`字段。`Item`和`Bid`之间的关系将是一对多，级联类型将传播持久化操作从父级到子级。'
- en: Listing 18.5 The `Item` class
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.5 `Item`类
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 18.2.3 Using the application with MongoDB
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.3 使用MongoDB应用程序
- en: To persist entities from the application to MongoDB, we’ll write code that uses
    the regular JPA classes and JPQL. This means that our application can work with
    relational databases and with various NoSQL databases. We’d just need to change
    some configuration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将实体从应用程序持久化到MongoDB，我们将编写使用常规JPA类和JPQL的代码。这意味着我们的应用程序可以与关系型数据库以及各种NoSQL数据库一起工作。我们只需要更改一些配置。
- en: To work with JPA the way we did with relational databases, we’ll first initialize
    an `EntityManagerFactory`. The `ch18.hibernate_ogm` persistence unit was previously
    declared in persistence.xml.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要以与关系型数据库相同的方式使用JPA，我们首先初始化一个`EntityManagerFactory`。`ch18.hibernate_ogm`持久化单元在persistence.xml中已声明。
- en: Listing 18.6 Initializing the `EntityManagerFactory`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.6 初始化`EntityManagerFactory`
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the execution of each test from the `HibernateOGMTest` class, we’ll close
    the `EntityManagerFactory`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`HibernateOGMTest`类中的每个测试之后，我们将关闭`EntityManagerFactory`。
- en: Listing 18.7 Closing the `EntityManagerFactory`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.7 关闭`EntityManagerFactory`
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before the execution of each test from the `HibernateOGMTest` class, we’ll persist
    a few entities to the NoSQL MongoDB database. Our code will use JPA for these
    operations, which is unaware of whether it is interacting with a relational or
    a non-relational database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`HibernateOGMTest`类中的每个测试之前，我们将一些实体持久化到NoSQL MongoDB数据库。我们的代码将使用JPA进行这些操作，它不知道它是在与关系型数据库还是非关系型数据库交互。
- en: Listing 18.8 Persisting the data to test on
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.8 将数据持久化以进行测试
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ⓐ Create an `EntityManager` with the help of the existing `EntityManagerFactory`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用现有的`EntityManagerFactory`创建一个`EntityManager`。
- en: Ⓑ Start a transaction. As you’ll recall, operations with JPA need to be transactional.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 开始一个事务。如您所回忆的，使用JPA的操作需要是事务性的。
- en: Ⓒ Create and set up the entities to be persisted.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 创建并设置要持久化的实体。
- en: Ⓓ Persist the `Item` entity and the `User` entity. As the `Bid` entities from
    an `Item` and a `User` are referenced using `CascadeType.PERSIST`, the persist
    operation will be propagated from parent to child.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 持久化`Item`实体和`User`实体。由于从`Item`和`User`引用的`Bid`实体使用`CascadeType.PERSIST`，持久化操作将从父级传播到子级。
- en: Ⓔ Commit the previously started transaction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 提交之前启动的事务。
- en: Ⓕ Close the previously created `EntityManager`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 关闭之前创建的`EntityManager`。
- en: We’ll query the database using JPA. We’ll use the `entityManager.find` method,
    as we do when interacting with a relational database. As previously discussed,
    every interaction with a database should occur within transaction boundaries,
    even if we’re only reading data, so we’ll start and commit transactions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JPA查询数据库。我们将使用`entityManager.find`方法，就像与关系型数据库交互时一样。正如之前讨论的，每次与数据库的交互都应该在事务边界内进行，即使我们只是在读取数据，因此我们将启动并提交事务。
- en: Listing 18.9 Querying the MongoDB database using JPA
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.9 使用JPA查询MongoDB数据库
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ⓐ Create an `EntityManager` with the help of the existing `EntityManagerFactory`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用现有的`EntityManagerFactory`创建一个`EntityManager`。
- en: Ⓑ Start a transaction; the operations need to be transactional.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 开始一个事务；操作需要是事务性的。
- en: Ⓒ Fetch the previously persisted `User`, `Item,` and `Bid`s based on the `id`s
    of the entities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 根据实体的`id`检索之前持久化的`User`、`Item`和`Bid`。
- en: Ⓓ Check that the fetched information contains what we previously persisted.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 确认检索到的信息包含我们之前持久化的内容。
- en: Ⓔ Commit the previously started transaction.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 提交之前启动的事务。
- en: Ⓕ Close the previously created `EntityManager`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 关闭之前创建的`EntityManager`。
- en: We can examine the content of the MongoDB database after executing this test.
    Open the MongoDB Compass program, as shown in figure 18.1\. MongoDB Compass is
    a GUI for interacting with and querying MongoDB databases. It will show us that
    three collections were created after executing the test. This demonstrates that
    the code written using JPA was able to interact with the NoSQL MongoDB database,
    with the help of Hibernate OGM.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在执行此测试后检查 MongoDB 数据库的内容。打开 MongoDB Compass 程序，如图 18.1 所示。MongoDB Compass
    是一个用于与 MongoDB 数据库交互和查询的 GUI。它将显示在执行测试后创建了三个集合。这证明了使用 JPA 编写的代码能够在 Hibernate OGM
    的帮助下与 NoSQL MongoDB 数据库交互。
- en: '![](../../OEBPS/Images/CH18_F01_Tudose2.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH18_F01_Tudose2.png)'
- en: Figure 18.1 The test written using JPA and Hibernate OGM created three collections
    inside MongoDB.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1 使用 JPA 和 Hibernate OGM 编写的测试在 MongoDB 内部创建了三个集合。
- en: We can also inspect the collections that were created and see that they contain
    the documents persisted from the test (this should be viewed before the `afterEach()`
    method, which removes the newly added documents, runs). For example, the `Bid`
    collection contains two documents, as shown in figure 18.2.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查创建的集合，并查看它们是否包含从测试中持久化的文档（这应该在 `afterEach()` 方法之前查看，该方法会删除新添加的文档并运行）。例如，`Bid`
    集合包含两个文档，如图 18.2 所示。
- en: '![](../../OEBPS/Images/CH18_F02_Tudose2.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH18_F02_Tudose2.png)'
- en: Figure 18.2 The `Bid` collection contains the two documents persisted from the
    test.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2 `Bid` 集合包含从测试中持久化的两个文档。
- en: We’ll also query the database using JPQL. JPQL (Jakarta Persistence Query Language,
    previously Java Persistence Query Language) is an object-oriented query language
    independent of the platform.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 JPQL 查询数据库。JPQL（Jakarta Persistence Query Language，之前称为 Java Persistence
    Query Language）是一种独立于平台的面向对象查询语言。
- en: We previously used JPQL to query relational databases independent of their SQL
    dialect, and now we’ll use JPQL to interact with NoSQL databases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用 JPQL 查询与 SQL 方言无关的关系型数据库，现在我们将使用 JPQL 与 NoSQL 数据库交互。
- en: Listing 18.10 Querying the MongoDB database using JPQL
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.10 使用 JPQL 查询 MongoDB 数据库
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ⓐ Create an `EntityManager` with the help of the existing `EntityManagerFactory`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在现有 `EntityManagerFactory` 的帮助下创建一个 `EntityManager`。
- en: Ⓑ Start a transaction; the operations need to be transactional.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 开始一个交易；操作需要是事务性的。
- en: Ⓒ Create a JPQL query to get all `Bid`s from the database, in descending order
    of `amount`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 创建一个 JPQL 查询以按 `amount` 降序从数据库中获取所有 `Bid`。
- en: Ⓓ Create a JPQL query to get the `Item` from the database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 创建一个 JPQL 查询以从数据库中获取 `Item`。
- en: Ⓔ Create a JPQL query to get the `User` from the database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 创建一个 JPQL 查询以从数据库中获取 `User`。
- en: Ⓕ Check that the information obtained through JPQL contains what we previously
    persisted.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 检查通过 JPQL 获取的信息是否包含我们之前持久化的内容。
- en: Ⓖ Commit the previously started transaction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 提交之前开始的交易。
- en: Ⓗ Close the previously created `EntityManager`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 关闭之前创建的 `EntityManager`。
- en: As previously stated, we want to keep the database clean and the tests independent,
    so we’ll clean up the data inserted after the execution of each test in the `HibernateOGMTest`
    class. Our code will use JPA for these operations, which is unaware of whether
    it is interacting with a relational or non-relational database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望保持数据库干净，测试独立，因此我们将在 `HibernateOGMTest` 类中每个测试执行后清理插入的数据。我们的代码将使用 JPA
    进行这些操作，它不知道它是在与关系型数据库还是非关系型数据库交互。
- en: Listing 18.11 Cleaning the database after the execution of each test
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.11 每个测试执行后清理数据库
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ⓐ Create an `EntityManager` with the help of the existing `EntityManagerFactory`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在现有 `EntityManagerFactory` 的帮助下创建一个 `EntityManager`。
- en: Ⓑ Start a transaction; the operations need to be transactional.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 开始一个交易；操作需要是事务性的。
- en: Ⓒ Fetch the previously persisted `User`, `Item,` and `Bid`s based on the `id`s
    of the entities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 根据实体的 `id` 获取之前持久化的 `User`、`Item` 和 `Bid`。
- en: Ⓓ Remove the previously persisted entities.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 删除之前持久化的实体。
- en: Ⓔ Commit the previously started transaction.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 提交之前开始的交易。
- en: Ⓕ Close the previously created `EntityManager`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 关闭之前创建的 `EntityManager`。
- en: 18.3 Switching to the Neo4j NoSQL database
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 切换到 Neo4j NoSQL 数据库
- en: 'Neo4j is also a NoSQL database, and specifically a graph-oriented database.
    Unlike MongoDB, which uses JSON-like documents to store the data, Neo4j uses graphs
    to store it. A graph consists of nodes that keep the data and edges that represent
    the relationships. Neo4j can run in a desktop version or an embedded version (which
    we’ll use for our demonstrations). For a comprehensive guide of Neo4j’s capabilities,
    see the Neo4j website: [https://neo4j.com/](https://neo4j.com/).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 也是一个 NoSQL 数据库，具体来说是一个图型数据库。与使用类似 JSON 的文档来存储数据的 MongoDB 不同，Neo4j 使用图来存储数据。图由节点组成，节点保存数据，边表示关系。Neo4j
    可以以桌面版本或嵌入式版本（我们将用于我们的演示）运行。有关 Neo4j 功能的全面指南，请参阅 Neo4j 网站：[https://neo4j.com/](https://neo4j.com/)。
- en: Hibernate OGM facilitates the quick and efficient switching between different
    NoSQL databases, even if they internally use different paradigms to store data.
    Currently, Hibernate OGM supports both MongoDB, the document-oriented database
    that we already demonstrated how to work with, and Neo4j, a graph-oriented database
    that we would like to quickly switch to.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate OGM 促进了在不同 NoSQL 数据库之间快速且高效地切换，即使它们在内部使用不同的范式来存储数据。目前，Hibernate OGM
    支持MongoDB，这是我们已演示如何与之交互的文档型数据库，以及 Neo4j，一个我们希望快速切换到的图型数据库。
- en: 'The efficiency of Hibernate OGM consists of the fact that we can still use
    the JPA code that we previously presented to define the entities and describe
    the interaction with the database. That code remains unchanged. We only need to
    make changes at the level of the configuration: we need to replace the Hibernate
    OGM MongoDB dependency with Hibernate OGM Neo4j, and we need to change the persistence
    unit configuration from MongoDB to Neo4j.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate OGM 的效率在于我们仍然可以使用之前提供的 JPA 代码来定义实体并描述与数据库的交互。该代码保持不变。我们只需要在配置层面进行更改：我们需要将
    Hibernate OGM MongoDB 依赖项替换为 Hibernate OGM Neo4j，并且需要将持久化单元配置从 MongoDB 更改为 Neo4j。
- en: We’ll update the Maven pom.xml file to include the Hibernate OGM Neo4j dependency.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新 Maven pom.xml 文件，以包含 Hibernate OGM Neo4j 依赖项。
- en: Listing 18.12 The pom.xml file with the Hibernate OGM Neo4j dependency
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.12 包含 Hibernate OGM Neo4j 依赖项的 pom.xml 文件
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll also replace the persistence unit configuration in src/main/resources/META-INF/persistence.xml.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将替换 src/main/resources/META-INF/persistence.xml 中的持久化单元配置。
- en: Listing 18.13 The persistence.xml configuration file for Neo4j
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.13 Neo4j 的 persistence.xml 配置文件
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ⓐ The persistence.xml file configures the `ch18.hibernate_ogm` persistence unit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `persistence.xml` 文件配置了 `ch18.hibernate_ogm` 持久化单元。
- en: Ⓑ The vendor-specific provider implementation of the API is Hibernate OGM.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ API 的供应商特定提供者实现是 Hibernate OGM。
- en: Ⓒ The data store provider is Neo4j; the database is embedded.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 数据存储提供者是 Neo4j；数据库是嵌入式的。
- en: Ⓓ The name of the database is `hibernate_ogm`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 数据库的名称是 `hibernate_ogm`。
- en: Ⓔ The database path is in test_data_dir, in the target folder created by Maven.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 数据库路径位于 test_data_dir，在 Maven 创建的目标文件夹中。
- en: The functionality of the application will be the same with Neo4j as with MongoDB.
    Using Hibernate OGM, the code is untouched, and JPA can access different kinds
    of NoSQL databases. The changes are only at the level of configuration.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MongoDB 相同，应用程序的功能在 Neo4j 中也将保持不变。使用 Hibernate OGM，代码保持不变，JPA 可以访问不同类型的 NoSQL
    数据库。更改仅限于配置层面。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can create a simple Hibernate OGM application using MongoDB and set the
    Maven dependencies it needs to interact with the database.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 MongoDB 和设置与数据库交互所需的 Maven 依赖项来创建一个简单的 Hibernate OGM 应用程序。
- en: You can configure the persistence unit with the MongoDB provider and a MongoDB
    database.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 MongoDB 提供者和 MongoDB 数据库来配置持久化单元。
- en: You can create entities that use only JPA annotations and functionality and
    persist them against the MongoDB database, verifying the insertion of the entities
    in MongoDB.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建仅使用 JPA 注释和功能来创建的实体，并将它们持久化到 MongoDB 数据库中，验证实体在 MongoDB 中的插入。
- en: You can switch from the document-oriented MongoDB database to the graph-oriented
    Neo4j database, changing only the Maven dependencies and the persistence unit
    configuration.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过仅更改 Maven 依赖项和持久化单元配置，从文档型 MongoDB 数据库切换到图型 Neo4j 数据库。
- en: You can persist the previously created entities that use only JPA annotations
    against the Neo4j database without touching the existing code.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在不修改现有代码的情况下，将之前创建的仅使用 JPA 注释的实体持久化到 Neo4j 数据库中。
