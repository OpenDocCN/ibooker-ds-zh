- en: Chapter 9\. Functions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章 函数
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Defining functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数
- en: Using function parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数参数
- en: Passing mutable objects as parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可变对象作为参数传递
- en: Understanding local and global variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解局部和全局变量
- en: Creating and using generator functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用生成器函数
- en: Creating and using lambda expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用lambda表达式
- en: Using decorators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器
- en: This chapter assumes that you’re familiar with function definitions in at least
    one other computer language and with the concepts that correspond to function
    definitions, arguments, parameters, and so forth.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您至少熟悉一种其他计算机语言中的函数定义以及与函数定义、参数等相对应的概念。
- en: 9.1\. Basic function definitions
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 基本函数定义
- en: The basic syntax for a Python function definition is
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数定义的基本语法是
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As it does with control structures, Python uses indentation to delimit the
    body of the function definition. The following simple example puts the factorial
    code from a previous section into a function body, so you can call a `fact` function
    to obtain the factorial of a number:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像控制结构一样，Python 使用缩进来限定函数定义的主体。以下简单示例将之前章节中的阶乘代码放入函数体中，这样您就可以通过调用 `fact` 函数来获取一个数的阶乘：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second line ***1*** is an optional *documentation string,* or *docstring.*
    You can obtain its value by printing `fact.__doc__`. The intention of docstrings
    is to describe the external behavior of a function and the parameters it takes,
    whereas comments should document internal information about how the code works.
    Docstrings are strings that immediately follow the first line of a function definition
    and are usually triple quoted to allow for multiline descriptions. Browsing tools
    are available that extract the first line of document strings. It’s standard practice
    for multiline documentation strings to give a synopsis of the function in the
    first line, follow this synopsis with a blank second line, and end with the rest
    of the information. This line indicates that the value after the return is sent
    back to the code calling the function ***2***.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行 ***1*** 是可选的 *文档字符串*，或 *docstring*。您可以通过打印 `fact.__doc__` 来获取其值。文档字符串的目的是描述函数的外部行为及其参数，而注释应记录有关代码内部工作方式的信息。文档字符串是紧跟在函数定义第一行之后的字符串，通常使用三引号来允许多行描述。有浏览工具可以提取文档字符串的第一行。对于多行文档字符串，标准做法是在第一行给出函数的概述，接着是一个空行，然后是其余信息。这一行表明返回值之后将返回给调用函数的代码
    ***2***。
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Procedure or function?**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程或函数？**'
- en: In some languages, a function that doesn’t return a value is called a *procedure*.
    Although you can (and will) write functions that don’t have a `return` statement,
    they aren’t really procedures. All Python procedures are functions; if no explicit
    `return` is executed in the procedure body, the special Python value `None` is
    returned, and if `return arg` is executed, the value `arg` is immediately returned.
    Nothing else in the function body is executed after a `return` has been executed.
    Because Python doesn’t have true procedures, I’ll refer to both types as *functions*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，不返回值的函数被称为 *过程*。尽管您可以（并将会）编写没有 `return` 语句的函数，但它们并不是真正的过程。所有Python过程都是函数；如果在过程体中没有执行显式的
    `return`，则返回特殊的Python值 `None`，如果执行了 `return arg`，则立即返回值 `arg`。在执行 `return` 之后，函数体中的其他内容不再执行。因为Python没有真正的过程，所以我会将这两种类型都称为
    *函数*。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Although all Python functions return values, it’s up to you whether a function’s
    return value is used:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有Python函数都返回值，但您可以选择是否使用函数的返回值：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The return value isn’t associated with a variable ***1***. The `fact` function’s
    value is printed in the interpreter only ***2***. The return value is associated
    with the variable `x` ***3***.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值与变量无关 ***1***。`fact` 函数的值仅在解释器中打印 ***2***。返回值与变量 `x` 相关联 ***3***。
- en: 9.2\. Function parameter options
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 函数参数选项
- en: Most functions need parameters, and each language has its own specifications
    for how function parameters are defined. Python is flexible and provides three
    options for defining function parameters. These options are outlined in this section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数需要参数，每种语言都有自己的函数参数定义规范。Python非常灵活，提供了三种定义函数参数的选项。这些选项在本节中概述。
- en: 9.2.1\. Positional parameters
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 位置参数
- en: 'The simplest way to pass parameters to a function in Python is by position.
    In the first line of the function, you specify variable names for each parameter;
    when the function is called, the parameters used in the calling code are matched
    to the function’s parameter variables based on their order. The following function
    computes `x` to the power of `y`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中向函数传递参数的最简单方法是按位置传递。在函数的第一行中，您为每个参数指定变量名；当函数被调用时，调用代码中使用的参数根据它们的顺序与函数的参数变量匹配。以下函数计算
    `x` 的 `y` 次幂：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method requires that the number of parameters used by the calling code
    exactly matches the number of parameters in the function definition; otherwise,
    a `TypeError` exception is raised:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法要求调用代码使用的参数数量与函数定义中的参数数量完全匹配；否则，将引发 `TypeError` 异常：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Default values**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认值**'
- en: 'Function parameters can have default values, which you declare by assigning
    a default value in the first line of the function definition, like so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数可以具有默认值，您可以通过在函数定义的第一行分配默认值来声明，如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any number of parameters can be given default values. Parameters with default
    values must be defined as the last ones in the parameter list because Python,
    like most languages, pairs arguments with parameters on a positional basis. There
    must be enough arguments to a function that the last parameter in that function’s
    parameter list without a default value gets an argument. See [section 9.2.2](#ch09lev2sec2),
    “[Passing arguments by parameter name](#ch09lev2sec2),” for a more flexible mechanism.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为任意数量的参数指定默认值。具有默认值的参数必须在参数列表的末尾定义，因为 Python，像大多数语言一样，根据位置将参数与参数配对。必须向函数提供足够的参数，使得该函数参数列表中最后一个没有默认值的参数获得一个参数。有关更灵活的机制，请参阅[第
    9.2.2 节](#ch09lev2sec2)，“[通过参数名传递参数](#ch09lev2sec2)。”
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The following function also computes `x` to the power of `y`. But if `y` isn’t
    given in a call to the function, the default value of 2 is used, and the function
    is just the square function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数也计算 `x` 的 `y` 次幂。但如果在函数调用中没有给出 `y`，则使用默认值 2，该函数只是平方函数：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see the effect of the default argument in the following interactive
    session:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下交互会话中看到默认参数的效果：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 9.2.2\. Passing arguments by parameter name
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 通过参数名传递参数
- en: You can also pass arguments into a function by using the name of the corresponding
    function parameter rather than its position. Continuing with the previous interactive
    example, you can type
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用相应的函数参数的名称而不是其位置来将参数传递给函数。继续使用之前的交互示例，您可以输入
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because the arguments to `power` in the final invocation are named, their order
    is irrelevant; the arguments are associated with the parameters of the same name
    in the definition of `power`, and you get back `3^2`. This type of argument passing
    is called *keyword* *passing.*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在最终调用 `power` 的参数是命名的，它们的顺序无关紧要；参数与 `power` 定义中同名参数相关联，并返回 `3^2`。这种参数传递方式称为
    *关键字* *传递*。
- en: Keyword passing, in combination with the default argument capability of Python
    functions, can be highly useful when you’re defining functions with large numbers
    of possible arguments, most of which have common defaults. Consider a function
    that’s intended to produce a list with information about files in the current
    directory and that uses Boolean arguments to indicate whether that list should
    include information such as file size, last modified date, and so forth, for each
    file. You can define such a function along these lines
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字传递与 Python 函数的默认参数功能结合使用时，在定义具有大量可能参数的函数时非常有用，其中大多数参数具有常见的默认值。考虑一个旨在生成关于当前目录中文件信息的列表的函数，并使用布尔参数来指示该列表是否应包括有关每个文件的信息，例如文件大小、最后修改日期等。您可以按照以下方式定义此类函数
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'and then call it from other code using keyword argument passing to indicate
    that you want only certain information (in this example, the file size and modification
    date but *not* the creation date):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以通过使用关键字参数传递从其他代码中调用它，以指示您只想获取某些信息（在这个例子中，是文件大小和修改日期，但*不是*创建日期）：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This type of argument handling is particularly suited for functions with very
    complex behavior, and one place where such functions occur is in a graphical user
    interface (GUI). If you ever use the Tkinter package to build GUIs in Python,
    you’ll find that the use of optional, keyword-named arguments like this is invaluable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的参数处理特别适合于具有非常复杂行为的函数，这类函数出现在图形用户界面（GUI）中。如果你曾经使用 Tkinter 包在 Python 中构建
    GUI，你会发现使用这种可选的、以关键字命名的参数非常有价值。
- en: 9.2.3\. Variable numbers of arguments
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3\. 可变数量的参数
- en: Python functions can also be defined to handle variable numbers of arguments,
    which you can do in two ways. One way handles the relatively familiar case in
    which you want to collect an unknown number of arguments at the end of the argument
    list into a list. The other method can collect an arbitrary number of keyword-passed
    arguments, which have no correspondingly named parameter in the function parameter
    list, into a dictionary. These two mechanisms are discussed next.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数也可以定义为处理可变数量的参数，这可以通过两种方式实现。一种方式处理相对熟悉的案例，即你想要将未知数量的参数收集到参数列表的末尾到一个列表中。另一种方法可以收集任意数量的关键字传递参数，这些参数在函数参数列表中没有相应的命名参数。接下来将讨论这两种机制。
- en: Dealing with an indefinite number of positional arguments
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理通过位置传递的不定数量参数
- en: Prefixing the final parameter name of the function with a `*` causes all excess
    non-keyword arguments in a call of a function (that is, those positional arguments
    not assigned to another parameter) to be collected together and assigned as a
    tuple to the given parameter. Here’s a simple way to implement a function to find
    the maximum in a list of numbers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的最后一个参数名称前加上 `*` 前缀会导致在函数调用中收集所有多余的、非关键字参数（即未分配给其他参数的位置参数）并作为一个元组分配给指定的参数。以下是一个实现查找数字列表中最大值的函数的简单方法。
- en: 'First, implement the function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，实现该函数：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now test the behavior of the function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试函数的行为：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Dealing with an indefinite number of arguments passed by keyword
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理通过关键字传递的不定数量参数
- en: An arbitrary number of keyword arguments can also be handled. If the final parameter
    in the parameter list is prefixed with `**`, it collects all excess *keyword-passed*
    arguments into a dictionary. The key for each entry in the dictionary is the keyword
    (parameter name) for the excess argument. The value of that entry is the argument
    itself. An argument passed by keyword is excess in this context if the keyword
    by which it was passed doesn’t match one of the parameter names in the function
    definition.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以处理任意数量的关键字参数。如果参数列表中的最后一个参数以 `**` 前缀开头，它将所有多余的 *关键字传递* 参数收集到一个字典中。字典中每个条目的键是多余参数的关键字（参数名称），该条目的值是参数本身。如果传递参数的关键字与函数定义中的参数名称不匹配，则在这种情况下通过关键字传递的参数是多余的。
- en: 'For example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Trying out this function in an interactive session reveals that it can handle
    arguments passed in under the keywords `foo` and `bar`, even though `foo` and
    `bar` aren’t parameter names in the function definition:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式会话中尝试此函数显示，它可以处理在关键字 `foo` 和 `bar` 下传递的参数，即使 `foo` 和 `bar` 不是函数定义中的参数名称：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 9.2.4\. Mixing argument-passing techniques
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4\. 混合参数传递技术
- en: It’s possible to use all of the argument-passing features of Python functions
    at the same time, although it can be confusing if not done with care. The general
    rule for using mixed argument-passing is that positional arguments come first,
    then named arguments, followed by the indefinite positional argument with a single
    *, and last of all the indefinite keyword argument with **. See the documentation
    for full details.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以同时使用 Python 函数的所有参数传递功能，尽管如果不小心使用可能会令人困惑。使用混合参数传递的一般规则是，位置参数先于命名参数，然后是不定位置参数（单个
    `*`），最后是不定关键字参数 `**`。有关完整详情，请参阅文档。
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Functions and parameters'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：函数和参数
- en: How would you write a function that could take any number of unnamed arguments
    and print their values out in reverse order?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何编写一个函数，它可以接受任意数量的未命名参数，并按相反顺序打印它们的值？
- en: What do you need to do to create a procedure or void function—that is, a function
    with no return value?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做什么来创建一个过程或无返回值的函数？
- en: What happens if you capture the return value of a function with a variable?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你捕获了函数的返回值变量会发生什么？
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3\. Mutable objects as arguments
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 可变对象作为参数
- en: 'Arguments are passed in by object reference. The parameter becomes a new reference
    to the object. For immutable objects (such as tuples, strings, and numbers), what
    is done with a parameter has no effect outside the function. But if you pass in
    a mutable object (such as a list, dictionary, or class instance), any change made
    to the object changes what the argument is referencing outside the function. Reassigning
    the parameter doesn’t affect the argument, as shown in [figures 9.1](#ch09fig01)
    and [9.2](#ch09fig02):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是通过对象引用传递的。参数成为指向对象的新的引用。对于不可变对象（如元组、字符串和数字），对参数所做的操作在函数外部没有效果。但是，如果你传递一个可变对象（如列表、字典或类实例），对对象所做的任何更改都会改变函数外部参数所引用的内容。重新分配参数不会影响参数，如[图9.1](#ch09fig01)
    和 [9.2](#ch09fig02) 所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figures 9.1](#ch09fig01) and [9.2](#ch09fig02) illustrate what happens when
    function `f` is called. The variable `x` isn’t changed because it’s immutable.
    Instead, the function parameter `n` is set to refer to the new value of 6\. Likewise,
    variable `z` is unchanged because inside function `f`, its corresponding parameter
    `list2` was set to refer to a new object, `[4, 5, 6]`. Only `y` sees a change
    because the actual list it points to was changed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.1](#ch09fig01) 和 [9.2](#ch09fig02) 展示了当调用函数 `f` 时会发生什么。变量 `x` 没有改变，因为它是不变的。相反，函数参数
    `n` 被设置为引用新的值6。同样，变量 `z` 没有改变，因为在函数 `f` 内部，它对应的参数 `list2` 被设置为引用一个新的对象 `[4, 5,
    6]`。只有 `y` 看到了变化，因为指向其实际列表的引用被改变了。'
- en: Figure 9.1\. At the beginning of function `f()`, both the initial variables
    and the function parameters refer to the same objects.
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1。在函数 `f()` 的开始时，初始变量和函数参数都指向相同的对象。
- en: '![](images/09fig01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](images/09fig01.jpg)'
- en: Figure 9.2\. At the end of function `f(),y (list1` inside the function) has
    been changed internally, whereas `n` and `list2` refer to different objects.
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2。在函数 `f()` 结束时，函数内部的 `y`（`list1`）已被内部更改，而 `n` 和 `list2` 指向不同的对象。
- en: '![](images/09fig02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](images/09fig02.jpg)'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Mutable function parameters'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：可变函数参数
- en: What would be the result of changing a list or dictionary that was passed into
    a function as a parameter value? Which operations would be likely to create changes
    that would be visible outside the function? What steps might you take to minimize
    that risk?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果改变作为参数值传递给函数的列表或字典，结果会是什么？哪些操作可能会创建在函数外部可见的更改？你可以采取哪些步骤来最小化这种风险？
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.4\. Local, nonlocal, and global variables
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4。局部、非局部和全局变量
- en: 'Here, you return to the definition of `fact` from the beginning of this chapter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你回到本章开头对 `fact` 的定义：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both the variables `r` and `n` are *local* to any particular call of the factorial
    function; changes to them made when the function is executing have no effect on
    any variables outside the function. Any variables in the parameter list of a function,
    and any variables created within a function by an assignment (like `r = 1` in
    `fact`), are local to the function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `r` 和 `n` 都是对任何特定的阶乘函数调用来说是**局部**的；在函数执行时对它们的更改不会影响函数外的任何变量。函数参数列表中的任何变量，以及函数内部通过赋值（如
    `fact` 中的 `r = 1`）创建的任何变量，都是局部于函数的。
- en: 'You can explicitly make a variable global by declaring it so before the variable
    is used, using the `global` statement. Global variables can be accessed and changed
    by the function. They exist outside the function and can also be accessed and
    changed by other functions that declare them global or by code that’s not within
    a function. Here’s an example that shows the difference between local and global
    variables:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在变量使用之前声明它来显式地将变量设置为全局变量，使用 `global` 语句。全局变量可以被函数访问和修改。它们存在于函数外部，也可以被声明为全局的其他函数或不在函数内的代码访问和修改。以下是一个显示局部和全局变量之间差异的示例：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example defines a function that treats `a` as a global variable and `b`
    as a local variable, and attempts to modify both `a` and `b`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了一个函数，它将 `a` 作为全局变量处理，将 `b` 作为局部变量，并尝试修改这两个变量。
- en: 'Now test this function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试这个函数：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The assignment to `a` within `fun` is an assignment to the global variable `a`
    also existing outside `fun`. Because `a` is designated `global` in `fun`, the
    assignment modifies that global variable to hold the value `1` instead of the
    value `"one"`. The same isn’t true for `b`; the local variable called `b` inside
    `fun` starts out referring to the same value as the variable `b` outside `fun`,
    but the assignment causes `b` to point to a new value that’s local to the function
    `fun`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fun`中赋值给`a`是对存在于`fun`外部的全局变量`a`的赋值。因为`a`在`fun`中被指定为`global`，所以赋值会修改该全局变量以保持值`1`而不是值`"one"`。对于`b`来说并不相同；在`fun`内部称为`b`的局部变量最初指向与`fun`外部的变量`b`相同的值，但赋值导致`b`指向一个新的值，该值是函数`fun`的局部值。
- en: Similar to the `global` statement is the `nonlocal` statement, which causes
    an identifier to refer to a previously bound variable in the closest enclosing
    scope. I discuss scopes and namespaces in more detail in [chapter 10](kindle_split_021.html#ch10),
    but the point is that `global` is used for a top-level variable, whereas `nonlocal`
    can refer to any variable in an enclosing scope, as the example in [listing 9.1](#ch09ex01)
    illustrates.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与`global`语句类似的是`nonlocal`语句，它使一个标识符引用最接近的封闭作用域中之前绑定的变量。我在[第10章](kindle_split_021.html#ch10)中更详细地讨论了作用域和命名空间，但重点是`global`用于顶层变量，而`nonlocal`可以引用封闭作用域中的任何变量，如[列表9.1](#ch09ex01)中的示例所示。
- en: Listing 9.1\. File nonlocal.py
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. 文件nonlocal.py
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* g_var in inner_test binds top-level g_var.**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 内部_test中的g_var绑定到顶层g_var。**'
- en: '***2* nl_var in inner_test binds to nl_var in test.**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 内部_test中的nl_var绑定到test中的nl_var。**'
- en: '***3* g_var in inner_test binds top-level g_var.**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 内部_test中的g_var绑定到顶层g_var。**'
- en: '***4* nl_var in inner_test binds to nl_var in test.**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 内部_test中的nl_var绑定到test中的nl_var。**'
- en: 'When run, this code prints the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，此代码将打印以下内容：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the value of the top-level `nl_var` hasn’t been affected, which would
    happen if `inner_test` contained the line `global nl_var`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，顶层`nl_var`的值没有受到影响，如果`inner_test`包含`global nl_var`这一行，就会发生这种情况。
- en: The bottom line is that if you want to assign to a variable existing outside
    a function, you must explicitly declare that variable to be nonlocal or global.
    But if you’re accessing a variable that exists outside the function, you don’t
    need to declare it nonlocal or global. If Python can’t find a variable name in
    the local function scope, it attempts to look up the name in the global scope.
    Hence, accesses to global variables are automatically sent through to the correct
    global variable. Personally, I don’t recommend using this shortcut. It’s much
    clearer to a reader if all global variables are explicitly declared as global.
    Further, you probably want to limit the use of global variables within functions
    to rare occasions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 核心原则是，如果你想要将变量分配给函数外部存在的变量，你必须明确声明该变量为非局部或全局变量。但是，如果你正在访问函数外部存在的变量，你不需要声明它为非局部或全局。如果Python在局部函数作用域中找不到变量名，它会尝试在全局作用域中查找该名称。因此，对全局变量的访问会自动传递到正确的全局变量。我个人不推荐使用这个快捷方式。如果所有全局变量都明确声明为全局，对读者来说会更清晰。此外，你可能希望将函数内部的全局变量使用限制在罕见场合。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Global vs. local variables'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：全局变量与局部变量
- en: Assuming that `x = 5`, what will be the value of `x` after `funct_1()` below
    executes? After `funct_2()` executes?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`x = 5`，在`funct_1()`执行后，`x`的值将会是什么？在`funct_2()`执行后？
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.5\. Assigning functions to variables
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 将函数分配给变量
- en: 'Functions can be assigned, like other Python objects, to variables, as shown
    in this example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以像其他Python对象一样分配给变量，如本例所示：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Defines the f_to_kelvin kelvin function**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义f_to_kelvin kelvin函数**'
- en: '***2* Defines the c_to_kelvin function**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义c_to_kelvin函数**'
- en: '***3* Assigns function to variable**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将函数分配给变量**'
- en: 'You can place functions in lists, tuples, or dictionaries:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将函数放入列表、元组或字典中：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***2* Accesses the f_to_kelvin function as value in dictionary**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将f_to_kelvin函数作为字典中的值访问**'
- en: '***3* Accesses the c_to_kelvin function as value in dictionary**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将c_to_kelvin函数作为字典中的值访问**'
- en: A variable that refers to a function can be used in exactly the same way as
    the function ***1***. This last example shows how you can use a dictionary to
    call different functions by the value of the strings used as keys. This pattern
    is common in situations in which different functions need to be selected based
    on a string value, and in many cases, it takes the place of the `switch` structure
    found in languages such as C and Java.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指向函数的变量可以像函数 ***1*** 一样使用。最后一个示例展示了如何使用字典通过用作键的字符串值调用不同的函数。这种模式在需要根据字符串值选择不同函数的情况下很常见，并且在许多情况下，它取代了C和Java等语言中找到的
    `switch` 结构。
- en: 9.6\. lambda expressions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6\. lambda 表达式
- en: Short functions like those you just saw can also be defined by using `lambda`
    expressions of the form
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您刚才看到的短函数一样，也可以使用以下形式的 `lambda` 表达式来定义：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`lambda` expressions are anonymous little functions that you can quickly define
    inline. Often, a small function needs to be passed to another function, like the
    key function used by a list’s sort method. In such cases, a large function is
    usually unnecessary, and it would be awkward to have to define the function in
    a separate place from where it’s used. The dictionary in the previous subsection
    can be defined all in one place with'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 表达式是匿名的小函数，您可以在行内快速定义。通常，需要将一个小函数传递给另一个函数，例如列表排序方法中使用的键函数。在这种情况下，通常不需要大函数，并且需要在使用它的地方之外定义函数会显得很尴尬。前一小节中的字典可以在一个地方全部定义：'
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example defines `lambda` expressions as values of the dictionary ***1***.
    Note that `lambda` expressions don’t have a `return` statement because the value
    of the expression is automatically returned.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将 `lambda` 表达式定义为字典的值 ***1***。请注意，`lambda` 表达式没有 `return` 语句，因为表达式的值会自动返回。
- en: 9.7\. Generator functions
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7\. 生成器函数
- en: 'A *generator* function is a special kind of function that you can use to define
    your own iterators. When you define a generator function, you return each iteration’s
    value using the `yield` keyword. The generator will stop returning values when
    there are no more iterations, or it encounters either an empty `return` statement
    or the end of the function. Local variables in a generator function are saved
    from one call to the next, unlike in normal functions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成器* 函数是一种特殊的函数，您可以使用它来定义自己的迭代器。当您定义生成器函数时，您使用 `yield` 关键字返回每次迭代的值。当没有更多的迭代或遇到空的
    `return` 语句或函数的末尾时，生成器将停止返回值。与普通函数不同，生成器函数中的局部变量在每次调用之间被保存：'
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Sets initial value of x to 0**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将x的初始值设置为0**'
- en: '***2* Returns current value of x**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回x的当前值**'
- en: '***3* Increments value of x**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 增加x的值**'
- en: Note that this generator function has a `while` loop that limits the number
    of times the generator executes. Depending on how it’s used, a generator that
    doesn’t have some condition to halt it could cause an endless loop when called.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此生成器函数有一个 `while` 循环，限制了生成器执行的次数。根据其使用方式，没有停止条件的生成器在调用时可能会导致无限循环。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**yield vs. yield from**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**yield 与 yield from**'
- en: 'Starting with Python 3.3, the new key word for generators, `yield from`, joins
    `yield`. Basically, `yield from` makes it possible to string generators together.
    `yield from` behaves the same way as `yield`, except that it delegates the generator
    machinery to a subgenerator. So in a simple case, you could do this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.3开始，新的生成器关键字 `yield from` 与 `yield` 结合。基本上，`yield from` 使得将生成器连接起来成为可能。`yield
    from` 的行为与 `yield` 相同，但它将生成器机制委托给子生成器。所以，在简单的情况下，你可以这样做：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example allows the `yield` expression to be moved out of the main generator,
    making refactoring easier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例允许将 `yield` 表达式移出主生成器，使重构更容易。
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can also use generator functions with `in` to see whether a value is in
    the series that the generator produces:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `in` 与生成器函数一起使用，以查看值是否在生成器产生的序列中：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Generator functions'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：生成器函数
- en: What would you need to modify in the previous code for the function `four()`to
    make it work for any number? What would you need to add to allow the starting
    point to also be set?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改前面的代码中的哪些部分才能使函数 `four()` 对任何数字都有效？你需要添加什么才能允许设置起始点？
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.8\. Decorators
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8\. 装饰器
- en: Because functions are first-class objects in Python, they can be assigned to
    variables, as you’ve seen. Functions can also be passed as arguments to other
    functions and passed back as return values from other functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数在Python中是一等对象，因此它们可以被分配给变量，正如您所看到的。函数还可以作为参数传递给其他函数，并作为其他函数的返回值传递。
- en: 'It’s possible, for example, to write a Python function that takes another function
    as its parameter, wraps it in another function that does something related, and
    then returns the new function. This new combination can be used instead of the
    original function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以编写一个Python函数，该函数接受另一个函数作为其参数，将其包装在执行相关操作的另一个函数中，然后返回新的函数。这个新的组合可以用作原始函数的替代：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A decorator is syntactic sugar for this process and lets you wrap one function
    inside another with a one-line addition. It still gives you exactly the same effect
    as the previous code, but the resulting code is much cleaner and easier to read.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是这个过程的语法糖，它允许您通过一行代码将一个函数包装在另一个函数中。它仍然提供了与之前代码完全相同的效果，但生成的代码更加简洁且易于阅读。
- en: 'Very simply, using a decorator involves two parts: defining the function that
    will be wrapping or “decorating” other functions and then using an `@` followed
    by the decorator immediately before the wrapped function is defined. The decorator
    function should take a function as a parameter and return a function, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，使用装饰器涉及两个部分：定义将要包装或“装饰”其他函数的函数，然后在定义包装函数之前立即使用一个`@`符号后跟装饰器。装饰器函数应该接受一个函数作为参数并返回一个函数，如下所示：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `decorate` function prints the name of the function it’s wrapping when the
    function is defined ***1***. When it’s finished, the decorator returns the wrapped
    function ***2***. `myfunction` is decorated using `@decorate` ***3***. The wrapped
    function is called after the decorator function has completed ***4***.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorate`函数在定义函数时打印它所包装的函数名称 ***1***。当它完成时，装饰器返回包装函数 ***2***。`myfunction`使用`@decorate`进行装饰
    ***3***。在装饰器函数完成后，调用包装函数 ***4***。'
- en: Using a decorator to wrap one function in another can be handy for several purposes.
    In web frameworks such as Django, decorators are used to make sure that a user
    is logged in before executing a function; and in graphics libraries, decorators
    can be used to register a function with the graphics framework.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器将一个函数包装在另一个函数中，对于多个目的来说可能很有用。在像Django这样的Web框架中，装饰器用于确保在执行函数之前用户已登录；在图形库中，装饰器可以用来将函数注册到图形框架中。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Decorators'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：装饰器
- en: How would you modify the code for the decorator function to remove unneeded
    messages and enclose the return value of the wrapped function in `"<html>"` and
    `"</html>"`, so that `myfunction ("hello")` would return `"<html>hello<html>"`?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如何修改装饰器函数的代码以删除不需要的消息，并将包装函数的返回值封装在`"<html>"`和`"</html>"`中，以便`myfunction ("hello")`返回`"<html>hello<html>"`？
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 9: Useful functions'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室9：有用的函数
- en: Looking back at the labs in [chapters 6](kindle_split_017.html#ch06) and [7](kindle_split_018.html#ch07),
    refactor that code into functions for cleaning and processing the data. The goal
    should be that most of the logic is moved into functions. Use your own judgment
    as to the types of functions and parameters, but keep in mind that functions should
    do just one thing, and they shouldn’t have any side effects that carry over outside
    the function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第6章和第7章的实验室，将代码重构为用于清理和处理数据的函数。目标应该是将大部分逻辑移动到函数中。根据您的判断选择函数类型和参数，但请记住，函数应该只做一件事，并且它们不应该有任何在函数外部延续的副作用。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: External variables can easily be accessed within a function by using the `global`
    statement.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用`global`语句轻松在函数内部访问外部变量。
- en: Arguments may be passed by position or by parameter name.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数可以通过位置或通过参数名称传递。
- en: Default values may be provided for function parameters.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数可以提供默认值。
- en: Functions can collect arguments into tuples, giving you the ability to define
    functions that take an indefinite number of arguments.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以将参数收集到元组中，这使您能够定义接受不定数量参数的函数。
- en: Functions can collect arguments into dictionaries, giving you the ability to
    define functions that take an indefinite number of arguments passed by parameter
    name.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以将参数收集到字典中，这使您能够定义接受通过参数名称传递的不定数量参数的函数。
- en: Functions are first-class objects in Python, which means that they can be assigned
    to variables, accessed by way of variables, and decorated.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数在Python中是一等对象，这意味着它们可以被分配给变量，通过变量访问，并且可以装饰。
