- en: Chapter 10\. Row Reduction and LU Decomposition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬10ç«  è¡Œç®€åŒ–ä¸LUåˆ†è§£
- en: Now we move to LU decomposition. LU, like QR, is one of the computational backbones
    underlying data-science algorithms, including least squares model fitting and
    the matrix inverse. This chapter is, therefore, pivotal to your linear algebra
    education.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è½¬å‘LUåˆ†è§£ã€‚LUåˆ†è§£ï¼ŒåƒQRä¸€æ ·ï¼Œæ˜¯æ”¯æŒæ•°æ®ç§‘å­¦ç®—æ³•çš„è®¡ç®—åŸºç¡€ä¹‹ä¸€ï¼ŒåŒ…æ‹¬æœ€å°äºŒä¹˜æ¨¡å‹æ‹Ÿåˆå’ŒçŸ©é˜µæ±‚é€†ã€‚å› æ­¤ï¼Œè¿™ä¸€ç« å¯¹ä½ çš„çº¿æ€§ä»£æ•°æ•™è‚²è‡³å…³é‡è¦ã€‚
- en: The thing about LU decomposition is you cannot simply learn it immediately.
    Instead, you first need to learn about systems of equations, row reduction, and
    Gaussian elimination. And in the course of learning those topics, youâ€™ll also
    learn about echelon matrices and permutation matrices. Oh yes, dear reader, this
    will be an exciting and action-packed chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LUåˆ†è§£çš„å…³é”®åœ¨äºä½ ä¸èƒ½ç®€å•åœ°ç«‹åˆ»å­¦ä¼šå®ƒã€‚ç›¸åï¼Œä½ é¦–å…ˆéœ€è¦å­¦ä¹ å…³äºæ–¹ç¨‹ç»„ã€è¡Œç®€åŒ–å’Œé«˜æ–¯æ¶ˆå…ƒã€‚åœ¨å­¦ä¹ è¿™äº›ä¸»é¢˜çš„è¿‡ç¨‹ä¸­ï¼Œä½ ä¹Ÿä¼šäº†è§£åˆ°æ¢¯å½¢çŸ©é˜µå’Œç½®æ¢çŸ©é˜µã€‚äº²çˆ±çš„è¯»è€…ï¼Œæ˜¯çš„ï¼Œè¿™å°†æ˜¯ä¸€ä¸ªä»¤äººå…´å¥‹å’Œå……æ»¡æ´»åŠ›çš„ç« èŠ‚ã€‚
- en: Systems of Equations
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹ç»„
- en: To understand LU decomposition and its applications, you need to understand
    row reduction and Gaussian elimination. And to understand those topics, you need
    to understand how to manipulate equations, convert them into a matrix equation,
    and solve that matrix equation using row reduction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ç†è§£LUåˆ†è§£åŠå…¶åº”ç”¨ï¼Œä½ éœ€è¦äº†è§£è¡Œç®€åŒ–å’Œé«˜æ–¯æ¶ˆå…ƒã€‚è€Œè¦ç†è§£è¿™äº›ä¸»é¢˜ï¼Œä½ éœ€è¦äº†è§£å¦‚ä½•æ“ä½œæ–¹ç¨‹ã€å°†å…¶è½¬æ¢ä¸ºçŸ©é˜µæ–¹ç¨‹ï¼Œå¹¶ä½¿ç”¨è¡Œç®€åŒ–æ¥è§£å†³è¯¥çŸ©é˜µæ–¹ç¨‹ã€‚
- en: 'Letâ€™s start with a â€œsystemâ€ of one equation:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»ä¸€ä¸ªâ€œç³»ç»Ÿâ€æ–¹ç¨‹å¼€å§‹ï¼š
- en: <math alttext="2 x equals 8" display="block"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>8</mn></mrow></math>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 x equals 8" display="block"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>8</mn></mrow></math>
- en: 'As Iâ€™m sure you learned in school, you can do various mathematical manipulations
    to the equationâ€”as long as you do the same thing to both sides of the equation.
    That means that the following equation is not the same as the previous one, but
    they are related to each other by simple manipulations. More importantly, any
    solution to one equation is a solution to the other:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ åœ¨å­¦æ ¡ä¸­å­¦åˆ°çš„é‚£æ ·ï¼Œä½ å¯ä»¥å¯¹æ–¹ç¨‹è¿›è¡Œå„ç§æ•°å­¦æ“ä½œâ€”â€”åªè¦ä½ åŒæ—¶å¯¹æ–¹ç¨‹çš„ä¸¤è¾¹åšåŒæ ·çš„æ“ä½œã€‚è¿™æ„å‘³ç€ä¸‹é¢çš„æ–¹ç¨‹ä¸å‰ä¸€ä¸ªæ–¹ç¨‹ä¸åŒï¼Œä½†å®ƒä»¬é€šè¿‡ç®€å•çš„æ“ä½œç›¸å…³è”ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œä»»ä½•ä¸€ä¸ªæ–¹ç¨‹çš„è§£ä¹Ÿæ˜¯å¦ä¸€ä¸ªæ–¹ç¨‹çš„è§£ï¼š
- en: <math alttext="5 left-parenthesis 2 x minus 3 right-parenthesis equals 5 left-parenthesis
    8 minus 3 right-parenthesis" display="block"><mrow><mn>5</mn> <mo>(</mo> <mn>2</mn>
    <mi>x</mi> <mo>-</mo> <mn>3</mn> <mo>)</mo> <mo>=</mo> <mn>5</mn> <mo>(</mo> <mn>8</mn>
    <mo>-</mo> <mn>3</mn> <mo>)</mo></mrow></math>
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="5 left-parenthesis 2 x minus 3 right-parenthesis equals 5 left-parenthesis
    8 minus 3 right-parenthesis" display="block"><mrow><mn>5</mn> <mo>(</mo> <mn>2</mn>
    <mi>x</mi> <mo>-</mo> <mn>3</mn> <mo>)</mo> <mo>=</mo> <mn>5</mn> <mo>(</mo> <mn>8</mn>
    <mo>-</mo> <mn>3</mn> <mo>)</mo></mrow></math>
- en: 'Now letâ€™s move to a system of two equations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬è½¬å‘ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªæ–¹ç¨‹çš„ç³»ç»Ÿï¼š
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 minus y
    2nd Row 1st Column y 2nd Column equals x slash 2 plus 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 minus y
    2nd Row 1st Column y 2nd Column equals x slash 2 plus 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math>
- en: In this system of equations, it is impossible to solve for unique values of
    *x* and *y* from either of those equations alone. Instead, you need to consider
    both equations simultaneously to derive the solution. If you try to solve that
    system now, you would probably take the strategy of substituting *y* in the first
    equation with the right-hand side of the second equation. After solving for *x*
    in the first equation, you plug that value into the second equation to solve for
    *y*. This strategy is similar to (though not as efficient as) back substitution,
    which Iâ€™ll define later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªæ–¹ç¨‹ç»„ä¸­ï¼Œä»ä»»ä½•ä¸€ä¸ªæ–¹ç¨‹ä¸­éƒ½ä¸å¯èƒ½å•ç‹¬æ±‚è§£å‡º*x*å’Œ*y*çš„å”¯ä¸€å€¼ã€‚ç›¸åï¼Œä½ éœ€è¦åŒæ—¶è€ƒè™‘ä¸¤ä¸ªæ–¹ç¨‹æ¥æ¨å¯¼è§£ã€‚å¦‚æœä½ ç°åœ¨å°è¯•è§£å†³è¿™ä¸ªç³»ç»Ÿï¼Œä½ å¯èƒ½ä¼šé‡‡å–ç”¨ç¬¬äºŒä¸ªæ–¹ç¨‹çš„å³ä¾§å€¼ä»£æ›¿ç¬¬ä¸€ä¸ªæ–¹ç¨‹ä¸­çš„*y*çš„ç­–ç•¥ã€‚åœ¨ç¬¬ä¸€ä¸ªæ–¹ç¨‹ä¸­è§£å‡º*x*åï¼Œå°†è¯¥å€¼ä»£å…¥ç¬¬äºŒä¸ªæ–¹ç¨‹ä¸­è§£å‡º*y*ã€‚è¿™ç§ç­–ç•¥ç±»ä¼¼äºï¼ˆå°½ç®¡ä¸å¦‚ï¼‰åä»£æ¢ï¼Œç¨åæˆ‘ä¼šå®šä¹‰å®ƒã€‚
- en: 'An important feature of a system of equations is that you can add or subtract
    individual equations to each other. In the following equations, Iâ€™ve added two
    times the second equation to the first, and subtracted the first original equation
    from the second (parentheses added for clarity):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹ç»„çš„ä¸€ä¸ªé‡è¦ç‰¹ç‚¹æ˜¯ä½ å¯ä»¥å°†å„ä¸ªæ–¹ç¨‹ç›¸åŠ æˆ–ç›¸å‡ã€‚åœ¨ä¸‹é¢çš„æ–¹ç¨‹ä¸­ï¼Œæˆ‘å°†ç¬¬äºŒä¸ªæ–¹ç¨‹ä¹˜ä»¥2åŠ åˆ°ç¬¬ä¸€ä¸ªæ–¹ç¨‹ä¸­ï¼Œå¹¶ä»ç¬¬äºŒä¸ªæ–¹ç¨‹ä¸­å‡å»ç¬¬ä¸€ä¸ªåŸå§‹æ–¹ç¨‹ï¼ˆä¸ºäº†æ¸…æ™°èµ·è§æ·»åŠ äº†æ‹¬å·ï¼‰ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column x plus left-parenthesis 2 y right-parenthesis
    2nd Column equals 4 minus y plus left-parenthesis x plus 4 right-parenthesis 2nd
    Row 1st Column y minus left-parenthesis x right-parenthesis 2nd Column equals
    x slash 2 plus 2 minus left-parenthesis 4 minus y right-parenthesis EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi>
    <mo>+</mo> <mo>(</mo> <mn>2</mn> <mi>y</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi> <mo>+</mo> <mo>(</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>y</mi> <mo>-</mo>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo> <mn>2</mn> <mo>-</mo> <mo>(</mo> <mn>4</mn>
    <mo>-</mo> <mi>y</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x plus left-parenthesis 2 y right-parenthesis
    2nd Column equals 4 minus y plus left-parenthesis x plus 4 right-parenthesis 2nd
    Row 1st Column y minus left-parenthesis x right-parenthesis 2nd Column equals
    x slash 2 plus 2 minus left-parenthesis 4 minus y right-parenthesis EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi>
    <mo>+</mo> <mo>(</mo> <mn>2</mn> <mi>y</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi> <mo>+</mo> <mo>(</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>y</mi> <mo>-</mo>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo> <mn>2</mn> <mo>-</mo> <mo>(</mo> <mn>4</mn>
    <mo>-</mo> <mi>y</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
- en: 'I will let you work through the arithmetic, but the upshot is that *x* drops
    out of the first equation while *y* drops out of the second equation. That makes
    the solution much easier to calculate (*x* = 4/3, *y* = 8/3). Hereâ€™s the important
    point: scalar multiplying equations and adding them to other equations made the
    solution to the system easier to find. Again, the modulated and original systems
    are not the same equations, but their solutions are the same because the two systems
    are linked by a series of linear operations.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¼šè®©ä½ è¿›è¡Œç®—æœ¯è¿ç®—ï¼Œä½†è¦ç‚¹æ˜¯*x*åœ¨ç¬¬ä¸€ä¸ªæ–¹ç¨‹ä¸­æ¶ˆå¤±ï¼Œè€Œ*y*åœ¨ç¬¬äºŒä¸ªæ–¹ç¨‹ä¸­æ¶ˆå¤±ã€‚è¿™ä½¿å¾—è§£çš„è®¡ç®—å˜å¾—æ›´å®¹æ˜“ï¼ˆ*x* = 4/3ï¼Œ*y* = 8/3ï¼‰ã€‚è¿™é‡Œçš„é‡è¦ä¸€ç‚¹æ˜¯ï¼šå¯¹æ–¹ç¨‹è¿›è¡Œæ ‡é‡ä¹˜æ³•å¹¶å°†å®ƒä»¬ç›¸åŠ ä½¿å¾—ç³»ç»Ÿçš„è§£æ›´å®¹æ˜“æ‰¾åˆ°ã€‚å†æ¬¡å¼ºè°ƒï¼Œè°ƒæ•´åå’ŒåŸå§‹ç³»ç»Ÿå¹¶ä¸æ˜¯ç›¸åŒçš„æ–¹ç¨‹ï¼Œä½†å®ƒä»¬çš„è§£æ˜¯ç›¸åŒçš„ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç³»ç»Ÿé€šè¿‡ä¸€ç³»åˆ—çº¿æ€§æ“ä½œç›¸è¿æ¥ã€‚
- en: This is the background knowledge you need to learn how to solve systems of equations
    using linear algebra. But before learning that approach, you need to learn how
    to represet a system of equations using matrices and vectors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä½ éœ€è¦å­¦ä¹ å¦‚ä½•ä½¿ç”¨çº¿æ€§ä»£æ•°è§£æ–¹ç¨‹ç»„ä¹‹å‰çš„èƒŒæ™¯çŸ¥è¯†ã€‚ä½†åœ¨å­¦ä¹ è¯¥æ–¹æ³•ä¹‹å‰ï¼Œä½ éœ€è¦å­¦ä¹ å¦‚ä½•ä½¿ç”¨çŸ©é˜µå’Œå‘é‡è¡¨ç¤ºæ–¹ç¨‹ç»„ã€‚
- en: Converting Equations into Matrices
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å°†æ–¹ç¨‹è½¬åŒ–ä¸ºçŸ©é˜µ
- en: Converting systems of equations into a matrix-vector equation is used to solve
    systems of equations, and itâ€™s used to set up the formula for the general linear
    model in statistics. Fortunately, translating equations into matrices is conceptually
    simple, and involves two steps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ–¹ç¨‹ç»„è½¬åŒ–ä¸ºçŸ©é˜µ-å‘é‡æ–¹ç¨‹ç”¨äºè§£å†³æ–¹ç¨‹ç»„ï¼Œå¹¶ç”¨äºå»ºç«‹ç»Ÿè®¡å­¦ä¸­ä¸€èˆ¬çº¿æ€§æ¨¡å‹çš„å…¬å¼ã€‚å¹¸è¿çš„æ˜¯ï¼Œå°†æ–¹ç¨‹è½¬åŒ–ä¸ºçŸ©é˜µåœ¨æ¦‚å¿µä¸Šå¾ˆç®€å•ï¼Œå¹¶åŒ…æ‹¬ä¸¤ä¸ªæ­¥éª¤ã€‚
- en: 'First, organize the equations so that the constants are on the right-hand side
    of the equations. The *constants* are the numbers that are unattached to the variables
    (sometimes called *intercepts* or *offsets*). The variables and their multiplying
    coefficients are on the left-hand side of the equation, in the same order (e.g.,
    all equations should have the *x* term first, then the *y* term, and so on). The
    following equations form the system of equations weâ€™ve been working with, in the
    proper organization:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œç»„ç»‡æ–¹ç¨‹ä½¿å¾—å¸¸æ•°ä½äºæ–¹ç¨‹çš„å³ä¾§ã€‚*å¸¸æ•°*æ˜¯ä¸å˜é‡æ— å…³çš„æ•°å­—ï¼ˆæœ‰æ—¶ç§°ä¸º*æˆªè·*æˆ–*åç§»é‡*ï¼‰ã€‚å˜é‡åŠå…¶ä¹˜æ³•ç³»æ•°æŒ‰ç…§ç›¸åŒçš„é¡ºåºä½äºæ–¹ç¨‹çš„å·¦ä¾§ï¼ˆä¾‹å¦‚ï¼Œæ‰€æœ‰æ–¹ç¨‹åº”å…ˆæœ‰*x*é¡¹ï¼Œç„¶åæ˜¯*y*é¡¹ï¼Œä¾æ­¤ç±»æ¨ï¼‰ã€‚ä»¥ä¸‹æ–¹ç¨‹å½¢æˆæˆ‘ä»¬ä¸€ç›´åœ¨å¤„ç†çš„æ–¹ç¨‹ç»„ï¼Œå¹¶æŒ‰æ­£ç¡®çš„æ–¹å¼ç»„ç»‡ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column x plus y 2nd Column equals 4 2nd
    Row 1st Column negative x slash 2 plus y 2nd Column equals 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi> <mo>+</mo>
    <mi>y</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mo>-</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn>
    <mo>+</mo> <mi>y</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x plus y 2nd Column equals 4 2nd
    Row 1st Column negative x slash 2 plus y 2nd Column equals 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi> <mo>+</mo>
    <mi>y</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mo>-</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn>
    <mo>+</mo> <mi>y</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
- en: 'Second, separate the coefficients (the numbers multiplying the variables; variables
    that are missing from an equation have a coefficient of zero) into a matrix with
    one row per equation. The variables are placed into a column vector that right-multiplies
    the coefficients matrix. And the constants are placed into a column vector on
    the right-hand side of the equation. Our example system has a matrix equation
    that looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶æ¬¡ï¼Œå°†ç³»æ•°ï¼ˆä¹˜ä»¥å˜é‡çš„æ•°å­—ï¼›ç¼ºå°‘æ–¹ç¨‹çš„å˜é‡å…·æœ‰é›¶ç³»æ•°ï¼‰åˆ†æˆä¸€ä¸ªçŸ©é˜µï¼Œæ¯ä¸ªæ–¹ç¨‹ä¸€è¡Œã€‚å˜é‡è¢«æ”¾ç½®åˆ°å³ä¹˜ç³»æ•°çŸ©é˜µçš„åˆ—å‘é‡ä¸­ã€‚å¸¸æ•°åˆ™æ”¾ç½®åœ¨æ–¹ç¨‹çš„å³ä¾§çš„åˆ—å‘é‡ä¸­ã€‚æˆ‘ä»¬çš„ç¤ºä¾‹ç³»ç»Ÿæœ‰ä¸€ä¸ªçŸ©é˜µæ–¹ç¨‹ï¼Œçœ‹èµ·æ¥åƒè¿™æ ·ï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column negative 1 slash 2 2nd Column 1 EndMatrix StartBinomialOrMatrix x Choose
    y EndBinomialOrMatrix equals StartBinomialOrMatrix 4 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column negative 1 slash 2 2nd Column 1 EndMatrix StartBinomialOrMatrix x Choose
    y EndBinomialOrMatrix equals StartBinomialOrMatrix 4 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: And voilÃ ! Youâ€™ve converted a system of equations into one matrix equation.
    We can refer to this equation as <math alttext="bold upper A bold x equals bold
    b"><mrow><mi>ğ€</mi> <mi>ğ±</mi> <mo>=</mo> <mi>ğ›</mi></mrow></math> , where <math
    alttext="bold upper A"><mi>ğ€</mi></math> is the matrix of coefficients, <math
    alttext="bold x"><mi>ğ±</mi></math> is a vector of unknown variables to solve for
    (in this case, <math alttext="bold x"><mi>ğ±</mi></math> is the vector comprising
    [*x* *y*]), and <math alttext="bold b"><mi>ğ›</mi></math> is a vector of constants.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼ä½ å·²ç»å°†æ–¹ç¨‹ç»„è½¬åŒ–ä¸ºä¸€ä¸ªçŸ©é˜µæ–¹ç¨‹ã€‚æˆ‘ä»¬å¯ä»¥ç§°è¿™ä¸ªæ–¹ç¨‹ä¸º<math alttext="bold upper A bold x equals bold
    b"><mrow><mi>ğ€</mi> <mi>ğ±</mi> <mo>=</mo> <mi>ğ›</mi></mrow></math>ï¼Œå…¶ä¸­<math alttext="bold
    upper A"><mi>ğ€</mi></math>æ˜¯ç³»æ•°çŸ©é˜µï¼Œ<math alttext="bold x"><mi>ğ±</mi></math>æ˜¯å¾…æ±‚çš„æœªçŸ¥å˜é‡å‘é‡ï¼ˆåœ¨æœ¬ä¾‹ä¸­ï¼Œ<math
    alttext="bold x"><mi>ğ±</mi></math>æ˜¯åŒ…å«[*x* *y*]çš„å‘é‡ï¼‰ï¼Œè€Œ<math alttext="bold b"><mi>ğ›</mi></math>æ˜¯å¸¸æ•°å‘é‡ã€‚
- en: Please take a moment to make sure you understand how the matrix equation maps
    onto the system of equations. In particular, work through the matrix-vector multiplication
    to demonstrate that it equals the original system of equations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·èŠ±ä¸€ç‚¹æ—¶é—´ç¡®ä¿ä½ ç†è§£çŸ©é˜µæ–¹ç¨‹æ˜¯å¦‚ä½•æ˜ å°„åˆ°æ–¹ç¨‹ç»„çš„ã€‚ç‰¹åˆ«æ˜¯é€šè¿‡çŸ©é˜µ-å‘é‡ä¹˜æ³•æ¥æ¼”ç¤ºå®ƒç­‰äºåŸå§‹æ–¹ç¨‹ç»„ã€‚
- en: Working with Matrix Equations
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä½¿ç”¨çŸ©é˜µæ–¹ç¨‹
- en: 'You can manipulate matrix equations just like normal equations, including adding,
    multiplying, transposing, etc., as long as the manipulations are valid (e.g.,
    matrix sizes match for addition) and all manipulations affect both sides of the
    equation. For example, the following progression of equations is valid:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥åƒå¤„ç†æ™®é€šæ–¹ç¨‹ä¸€æ ·æ“ä½œçŸ©é˜µæ–¹ç¨‹ï¼ŒåŒ…æ‹¬åŠ æ³•ã€ä¹˜æ³•ã€è½¬ç½®ç­‰ï¼Œåªè¦æ“ä½œæ˜¯æœ‰æ•ˆçš„ï¼ˆä¾‹å¦‚ï¼ŒåŠ æ³•çš„çŸ©é˜µå°ºå¯¸åŒ¹é…ï¼‰ï¼Œå¹¶ä¸”æ‰€æœ‰æ“ä½œå½±å“æ–¹ç¨‹çš„ä¸¤è¾¹ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ–¹ç¨‹çš„è¿›å±•æ˜¯æœ‰æ•ˆçš„ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold x 2nd Column
    equals bold b 2nd Row 1st Column bold v plus bold upper A bold x 2nd Column equals
    bold v plus bold b 3rd Row 1st Column left-parenthesis bold v plus bold upper
    A bold x right-parenthesis Superscript upper T 2nd Column equals left-parenthesis
    bold v plus bold b right-parenthesis Superscript upper T EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ±</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ›</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>ğ¯</mi> <mo>+</mo> <mi>ğ€</mi> <mi>ğ±</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ¯</mi> <mo>+</mo> <mi>ğ›</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mrow><mo>(</mo><mi>ğ¯</mi><mo>+</mo><mi>ğ€</mi><mi>ğ±</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><mi>ğ¯</mi><mo>+</mo><mi>ğ›</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold x 2nd Column
    equals bold b 2nd Row 1st Column bold v plus bold upper A bold x 2nd Column equals
    bold v plus bold b 3rd Row 1st Column left-parenthesis bold v plus bold upper
    A bold x right-parenthesis Superscript upper T 2nd Column equals left-parenthesis
    bold v plus bold b right-parenthesis Superscript upper T EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ±</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ›</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>ğ¯</mi> <mo>+</mo> <mi>ğ€</mi> <mi>ğ±</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ¯</mi> <mo>+</mo> <mi>ğ›</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mrow><mo>(</mo><mi>ğ¯</mi><mo>+</mo><mi>ğ€</mi><mi>ğ±</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><mi>ğ¯</mi><mo>+</mo><mi>ğ›</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
- en: The main difference between working with matrix equations versus scalar equations
    is that because matrix multiplication is side-dependent, you must multiply matrices
    in the same way on both sides of the equation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨çŸ©é˜µæ–¹ç¨‹ä¸æ ‡é‡æ–¹ç¨‹çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œç”±äºçŸ©é˜µä¹˜æ³•æ˜¯ä¾§å‘ä¾èµ–çš„ï¼Œä½ å¿…é¡»åœ¨æ–¹ç¨‹çš„ä¸¤è¾¹ä»¥ç›¸åŒçš„æ–¹å¼è¿›è¡ŒçŸ©é˜µä¹˜æ³•ã€‚
- en: 'For example, the following progression of equations is valid:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œä»¥ä¸‹æ–¹ç¨‹çš„è¿›å±•æ˜¯æœ‰æ•ˆçš„ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper X 2nd
    Column equals bold upper B 2nd Row 1st Column bold upper C bold upper A bold upper
    X 2nd Column equals bold upper C bold upper B EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ—</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>ğ‚</mi> <mi>ğ€</mi> <mi>ğ—</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>ğ‚</mi> <mi>ğ</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper X 2nd
    Column equals bold upper B 2nd Row 1st Column bold upper C bold upper A bold upper
    X 2nd Column equals bold upper C bold upper B EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ—</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>ğ‚</mi> <mi>ğ€</mi> <mi>ğ—</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>ğ‚</mi> <mi>ğ</mi></mrow></mtd></mtr></mtable></math>
- en: 'Notice that <math alttext="bold upper C"><mi>ğ‚</mi></math> premultiplies both
    sides of the equation. In contrast, the following progression is **not** valid:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ<math alttext="bold upper C"><mi>ğ‚</mi></math> åœ¨æ–¹ç¨‹å¼ä¸¤è¾¹éƒ½æ˜¯å·¦ä¹˜çš„ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œä»¥ä¸‹æ¨è¿›æ˜¯**æ— æ•ˆ**çš„ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper X 2nd
    Column equals bold upper B 2nd Row 1st Column bold upper A bold upper X bold upper
    C 2nd Column equals bold upper C bold upper B EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ—</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ—</mi> <mi>ğ‚</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>ğ‚</mi> <mi>ğ</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper X 2nd
    Column equals bold upper B 2nd Row 1st Column bold upper A bold upper X bold upper
    C 2nd Column equals bold upper C bold upper B EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ—</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ—</mi> <mi>ğ‚</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>ğ‚</mi> <mi>ğ</mi></mrow></mtd></mtr></mtable></math>
- en: The problem here is that <math alttext="bold upper C"><mi>ğ‚</mi></math> *post*multiplies
    in the left-hand side but *pre*multiplies in the right-hand side. To be sure,
    there will be a few exceptional cases where that equation is valid (e.g., if <math
    alttext="bold upper C"><mi>ğ‚</mi></math> is the identity or zeros matrix), but
    in general that progression is not valid.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„é—®é¢˜åœ¨äºæ•°å­¦å…¬å¼ <math alttext="bold upper C"><mi>ğ‚</mi></math> åœ¨å·¦è¾¹ä¹˜ä»¥åé¢çš„éƒ¨åˆ†ï¼Œä½†åœ¨å³è¾¹ä¹˜ä»¥å‰é¢çš„éƒ¨åˆ†ã€‚å¯ä»¥è‚¯å®šåœ°è¯´ï¼Œæœ‰å‡ ç§ä¾‹å¤–æƒ…å†µï¼Œä½¿å¾—è¯¥æ–¹ç¨‹å¼æœ‰æ•ˆï¼ˆä¾‹å¦‚ï¼Œå¦‚æœ
    <math alttext="bold upper C"><mi>ğ‚</mi></math> æ˜¯å•ä½çŸ©é˜µæˆ–é›¶çŸ©é˜µï¼‰ï¼Œä½†ä¸€èˆ¬æƒ…å†µä¸‹è¿™ç§æ¨è¿›æ˜¯æ— æ•ˆçš„ã€‚
- en: Letâ€™s see an example in Python. We will solve for the unknown matrix <math alttext="bold
    upper X"><mi>ğ—</mi></math> in the equation <math alttext="bold upper A bold upper
    X equals bold upper B"><mrow><mi>ğ€</mi> <mi>ğ—</mi> <mo>=</mo> <mi>ğ</mi></mrow></math>
    . The following code generates <math alttext="bold upper A"><mi>ğ€</mi></math>
    and <math alttext="bold upper B"><mi>ğ</mi></math> from random numbers. You already
    know that we can solve for <math alttext="bold upper X"><mi>ğ—</mi></math> by using
    <math alttext="bold upper A Superscript negative 1"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    . The question is whether the order of multiplication matters.^([1](ch10.xhtml#idm45733296963648))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªPythonçš„ä¾‹å­ã€‚æˆ‘ä»¬å°†è§£å‡ºæœªçŸ¥çŸ©é˜µ <math alttext="bold upper X"><mi>ğ—</mi></math> åœ¨æ–¹ç¨‹
    <math alttext="bold upper A bold upper X equals bold upper B"><mrow><mi>ğ€</mi>
    <mi>ğ—</mi> <mo>=</mo> <mi>ğ</mi></mrow></math> ä¸­ã€‚ä»¥ä¸‹ä»£ç ç”Ÿæˆ <math alttext="bold upper
    A"><mi>ğ€</mi></math> å’Œ <math alttext="bold upper B"><mi>ğ</mi></math> çš„éšæœºæ•°ã€‚ä½ å·²ç»çŸ¥é“æˆ‘ä»¬å¯ä»¥é€šè¿‡
    <math alttext="bold upper A Superscript negative 1"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    æ¥è§£å‡º <math alttext="bold upper X"><mi>ğ—</mi></math> ã€‚é—®é¢˜æ˜¯ä¹˜æ³•çš„é¡ºåºæ˜¯å¦é‡è¦ã€‚^([1](ch10.xhtml#idm45733296963648))
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If matrix multiplication were commutative (meaning that the order doesnâ€™t matter),
    then `res1` and `res2` should both equal the zeros matrix. Letâ€™s see:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœçŸ©é˜µä¹˜æ³•æ˜¯å¯äº¤æ¢çš„ï¼ˆæ„å‘³ç€é¡ºåºä¸é‡è¦ï¼‰ï¼Œé‚£ä¹ˆ `res1` å’Œ `res2` éƒ½åº”è¯¥ç­‰äºé›¶çŸ©é˜µã€‚è®©æˆ‘ä»¬çœ‹çœ‹ï¼š
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you know how to express a system of equations using one matrix equation.
    Iâ€™m going to get back to this in a few sections; first, I need to teach you about
    row reduction and the echelon form of a matrix.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ çŸ¥é“å¦‚ä½•ç”¨ä¸€ä¸ªçŸ©é˜µæ–¹ç¨‹è¡¨ç¤ºä¸€ä¸ªæ–¹ç¨‹ç»„ã€‚åœ¨æ¥ä¸‹æ¥çš„å‡ èŠ‚ä¸­ï¼Œæˆ‘å°†å›åˆ°è¿™ä¸ªé—®é¢˜ï¼›é¦–å…ˆï¼Œæˆ‘éœ€è¦æ•™ä½ å…³äºè¡Œåˆ—å¼å˜æ¢å’ŒçŸ©é˜µçš„é˜¶æ¢¯å½¢å¼ã€‚
- en: Row Reduction
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è¡Œåˆ—å¼å˜æ¢
- en: Row reduction is a topic that gets a lot of attention in traditional linear
    algebra, because it is the time-honored way to solve systems of equations *by
    hand*. I seriously doubt youâ€™ll solve any systems of equations by hand in your
    career as a data scientist. But row reduction is useful to know about, and it
    leads directly to LU decomposition, which actually is used in applied linear algebra.
    So letâ€™s begin.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: è¡Œåˆ—å¼å˜æ¢æ˜¯ä¼ ç»Ÿçº¿æ€§ä»£æ•°ä¸­å¤‡å—å…³æ³¨çš„è¯é¢˜ï¼Œå› ä¸ºå®ƒæ˜¯é€šè¿‡æ‰‹å·¥è§£å†³æ–¹ç¨‹ç»„çš„å¤è€æ–¹å¼ã€‚æˆ‘ç¡®å®æ€€ç–‘åœ¨ä½œä¸ºæ•°æ®ç§‘å­¦å®¶çš„èŒä¸šç”Ÿæ¶¯ä¸­ä½ ä¼šæ‰‹å·¥è§£å†³ä»»ä½•æ–¹ç¨‹ç»„ã€‚ä½†äº†è§£è¡Œåˆ—å¼å˜æ¢æ˜¯æœ‰ç”¨çš„ï¼Œå¹¶ä¸”ç›´æ¥å¯¼è‡´LUåˆ†è§£ï¼Œè€ŒLUåˆ†è§£å®é™…ä¸Šè¢«åº”ç”¨åœ¨åº”ç”¨çº¿æ€§ä»£æ•°ä¸­ã€‚æ‰€ä»¥è®©æˆ‘ä»¬å¼€å§‹å§ã€‚
- en: '*Row reduction* means iteratively applying two operationsâ€”scalar multiplication
    and additionâ€”to rows of a matrix. Row reduction relies on the same principle as
    adding equations to other equations within a system.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¡Œåˆ—å¼å˜æ¢* æ„å‘³ç€åå¤åº”ç”¨ä¸¤ç§æ“ä½œâ€”â€”è¡Œçš„æ ‡é‡ä¹˜æ³•å’ŒåŠ æ³•â€”â€”åˆ°çŸ©é˜µçš„è¡Œä¸Šã€‚è¡Œåˆ—å¼å˜æ¢ä¾èµ–äºåœ¨ç³»ç»Ÿä¸­å‘å…¶ä»–æ–¹ç¨‹å¼æ·»åŠ æ–¹ç¨‹å¼çš„ç›¸åŒåŸç†ã€‚'
- en: 'Memorize this statement: *The goal of row reduction is to transform a dense
    matrix into an upper-triangular matrix.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½è¿™ä¸ªå£°æ˜ï¼š*è¡Œåˆ—å¼å˜æ¢çš„ç›®æ ‡æ˜¯å°†å¯†é›†çŸ©é˜µè½¬æ¢ä¸ºä¸Šä¸‰è§’çŸ©é˜µ*ã€‚
- en: 'Letâ€™s start with a simple example. In the following dense matrix, we add the
    first row to the second row, which knocks out the âˆ’2\. And with that, weâ€™ve transformed
    our dense matrix into an upper-triangular matrix:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»ä¸€ä¸ªç®€å•çš„ä¾‹å­å¼€å§‹ã€‚åœ¨ä¸‹é¢çš„å¯†é›†çŸ©é˜µä¸­ï¼Œæˆ‘ä»¬å°†ç¬¬ä¸€è¡ŒåŠ åˆ°ç¬¬äºŒè¡Œï¼Œè¿™æ¶ˆé™¤äº†-2ã€‚æœ‰äº†è¿™ä¸ªå˜åŒ–ï¼Œæˆ‘ä»¬å°†å¯†é›†çŸ©é˜µè½¬æ¢æˆäº†ä¸Šä¸‰è§’çŸ©é˜µï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row
    1st Column negative 2 2nd Column 2 EndMatrix StartLayout 1st Row  right-arrow
    Overscript upper R 1 plus upper R 2 Endscripts EndLayout Start 2 By 2 Matrix 1st
    Row 1st Column 2 2nd Column 3 2nd Row 1st Column 0 2nd Column 5 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd>
    <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>â†’</mo>
    <mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row
    1st Column negative 2 2nd Column 2 EndMatrix StartLayout 1st Row  right-arrow
    Overscript upper R 1 plus upper R 2 Endscripts EndLayout Start 2 By 2 Matrix 1st
    Row 1st Column 2 2nd Column 3 2nd Row 1st Column 0 2nd Column 5 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd>
    <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>â†’</mo>
    <mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: The upper-triangular matrix that results from row reduction is called the *echelon
    form* of the matrix.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¡Œåˆ—å¼å˜æ¢åçš„ä¸Šä¸‰è§’çŸ©é˜µè¢«ç§°ä¸ºçŸ©é˜µçš„*é˜¶æ¢¯å½¢å¼*ã€‚
- en: Formally, a matrix is in echelon form if (1) the leftmost nonzero number in
    a row (which is called the *pivot*) is to the right of the pivot of rows above,
    and (2) any rows of all zeros are below rows containing nonzeros.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å½¢å¼ä¸Šï¼Œå¦‚æœä¸€ä¸ªçŸ©é˜µæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œå®ƒå°±æ˜¯é˜¶æ¢¯å½¢å¼ï¼šï¼ˆ1ï¼‰æ¯ä¸€è¡Œçš„æœ€å·¦è¾¹éé›¶æ•°ï¼ˆç§°ä¸º*ä¸»å…ƒ*ï¼‰åœ¨ä¸Šé¢è¡Œçš„ä¸»å…ƒå³è¾¹ï¼Œï¼ˆ2ï¼‰æ‰€æœ‰é›¶è¡Œåœ¨éé›¶è¡Œçš„ä¸‹é¢ã€‚
- en: 'Similar to manipulating equations in a system, the matrix *after* row reduction
    is different from the matrix *before* row reduction. But the two matrices are
    linked by a linear transform. And because linear transforms can be represented
    by matrices, we can use matrix multiplication to express row reduction:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼äºåœ¨ç³»ç»Ÿä¸­æ“ä½œæ–¹ç¨‹ï¼Œè¡Œå˜æ¢åçš„çŸ©é˜µä¸è¡Œå˜æ¢å‰çš„çŸ©é˜µä¸åŒã€‚ä½†æ˜¯è¿™ä¸¤ä¸ªçŸ©é˜µé€šè¿‡çº¿æ€§å˜æ¢ç›¸è¿ã€‚ç”±äºçº¿æ€§å˜æ¢å¯ä»¥ç”¨çŸ©é˜µè¡¨ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨çŸ©é˜µä¹˜æ³•æ¥è¡¨ç¤ºè¡Œå˜æ¢ï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 0 2nd Row
    1st Column 1 2nd Column 1 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 2 2nd
    Column 3 2nd Row 1st Column negative 2 2nd Column 2 EndMatrix equals Start 2 By
    2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row 1st Column 0 2nd Column 5 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 0 2nd Row
    1st Column 1 2nd Column 1 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 2 2nd
    Column 3 2nd Row 1st Column negative 2 2nd Column 2 EndMatrix equals Start 2 By
    2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row 1st Column 0 2nd Column 5 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'I will call that matrix <math alttext="bold upper L Superscript negative 1"><msup><mi>ğ‹</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> for reasons that will become clear
    when I introduce LU decomposition.^([2](ch10.xhtml#idm45733296685312)) Thus, in
    the expression <math alttext="left-parenthesis bold upper L Superscript negative
    1 Baseline bold upper A equals bold upper U right-parenthesis"><mrow><mo>(</mo>
    <msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>ğ€</mi> <mo>=</mo>
    <mi>ğ”</mi> <mo>)</mo></mrow></math> , <math alttext="bold upper L Superscript
    negative 1"><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> is
    the linear transformation that keeps track of the manipulations weâ€™ve implemented
    through row reduction. For now, you donâ€™t need to focus on <math alttext="bold
    upper L Superscript negative 1"><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    â€”in fact, itâ€™s often ignored during Gaussian elimination. But the key point (slightly
    expanded from an earlier claim) is this: *row reduction involves transforming
    a matrix into an upper-triangular matrix via row manipulations, which can be implemented
    as premultiplication by a transformation matrix.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å°†ç§°é‚£ä¸ªçŸ©é˜µä¸º<math alttext="bold upper L Superscript negative 1"><msup><mi>ğ‹</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>ï¼ŒåŸå› å°†åœ¨æˆ‘ä»‹ç»LUåˆ†è§£æ—¶å˜å¾—æ¸…æ¥šã€‚å› æ­¤ï¼Œåœ¨è¡¨è¾¾å¼<math
    alttext="left-parenthesis bold upper L Superscript negative 1 Baseline bold upper
    A equals bold upper U right-parenthesis"><mrow><mo>(</mo> <msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ€</mi> <mo>=</mo> <mi>ğ”</mi> <mo>)</mo></mrow></math> ä¸­ï¼Œ<math alttext="bold
    upper L Superscript negative 1"><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    æ˜¯çº¿æ€§å˜æ¢ï¼Œé€šè¿‡è¡Œå˜æ¢å®ç°çš„æ“ä½œçš„å˜æ¢çŸ©é˜µã€‚ç°åœ¨ä½ ä¸éœ€è¦ä¸“æ³¨äº<math alttext="bold upper L Superscript negative
    1"><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> â€”â€”äº‹å®ä¸Šï¼Œåœ¨é«˜æ–¯æ¶ˆå…ƒè¿‡ç¨‹ä¸­å®ƒç»å¸¸è¢«å¿½ç•¥ã€‚ä½†å…³é”®ç‚¹ï¼ˆç¨å¾®æ‰©å±•äº†å‰é¢çš„è¯´æ³•ï¼‰æ˜¯ï¼š*è¡Œå˜æ¢æ¶‰åŠé€šè¿‡è¡Œæ“ä½œå°†çŸ©é˜µè½¬æ¢ä¸ºä¸Šä¸‰è§’çŸ©é˜µï¼Œå¯ä»¥é€šè¿‡å˜æ¢çŸ©é˜µçš„å‰ä¹˜æ¥å®ç°ã€‚*
- en: 'Hereâ€™s another example of a <math alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo>
    <mn>3</mn></mrow></math> matrix. This matrix requires two steps to transform into
    its echelon form:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰å¦ä¸€ä¸ªä¾‹å­ï¼Œä¸€ä¸ª<math alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>3</mn></mrow></math>çŸ©é˜µã€‚è¿™ä¸ªçŸ©é˜µéœ€è¦ä¸¤æ­¥å˜æ¢æˆå®ƒçš„æ¢¯å½¢å½¢å¼ï¼š
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    2 2nd Row 1st Column negative 1 2nd Column 3 3rd Column 0 3rd Row 1st Column 2
    2nd Column 4 3rd Column negative 3 EndMatrix StartLayout 1st Row  right-arrow
    Overscript minus 2 upper R 1 plus upper R 3 Endscripts EndLayout Start 3 By 3
    Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column 2 2nd Row 1st Column negative
    1 2nd Column 3 3rd Column 0 3rd Row 1st Column 0 2nd Column 0 3rd Column negative
    7 EndMatrix StartLayout 1st Row  right-arrow Overscript upper R 1 plus upper R
    2 Endscripts EndLayout Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd
    Column 2 2nd Row 1st Column 0 2nd Column 5 3rd Column 2 3rd Row 1st Column 0 2nd
    Column 0 3rd Column negative 7 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>4</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>â†’</mo>
    <mrow><mo>-</mo><mn>2</mn><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>3</mn></msub></mrow></mover></mrow></mtd></mtr></mtable> <mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>7</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>â†’</mo>
    <mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>7</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    2 2nd Row 1st Column negative 1 2nd Column 3 3rd Column 0 3rd Row 1st Column 2
    2nd Column 4 3rd Column negative 3 EndMatrix StartLayout 1st Row  right-arrow
    Overscript minus 2 upper R 1 plus upper R 3 Endscripts EndLayout Start 3 By 3
    Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column 2 2nd Row 1st Column negative
    1 2nd Column 3 3rd Column 0 3rd Row 1st Column 0 2nd Column 0 3rd Column negative
    7 EndMatrix StartLayout 1st Row  right-arrow Overscript upper R 1 plus upper R
    2 Endscripts EndLayout Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd
    Column 2 2nd Row 1st Column 0 2nd Column 5 3rd Column 2 3rd Row 1st Column 0 2nd
    Column 0 3rd Column negative 7 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>4</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>â†’</mo>
    <mrow><mo>-</mo><mn>2</mn><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>3</mn></msub></mrow></mover></mrow></mtd></mtr></mtable> <mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>7</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>â†’</mo>
    <mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>7</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: Row reduction is tedious (see [â€œIs Row Reduction Always So Easy?â€](#row-reduction)).
    Surely there must be a Python function to do it for us! Well, there is and there
    isnâ€™t. There is no Python function that returns an echelon form like what I created
    in the two previous examples. The reason is that the echelon form of a matrix
    is not unique. For example, in the previous <math alttext="3 times 3"><mrow><mn>3</mn>
    <mo>Ã—</mo> <mn>3</mn></mrow></math> matrix, you could multiply the second row
    by 2 to give a row vector of [0 10 4]. That creates a perfectly validâ€”but differentâ€”echelon
    form of the same original matrix. Indeed, there is an infinite number of echelon
    matrices associated with that matrix.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¡Œå˜æ¢æ˜¯ä¹å‘³çš„ï¼ˆè§[â€œè¡Œå˜æ¢æ€»æ˜¯è¿™ä¹ˆç®€å•å—ï¼Ÿâ€](#row-reduction)ï¼‰ã€‚è‚¯å®šæœ‰ä¸€ä¸ªPythonå‡½æ•°å¯ä»¥å¸®æˆ‘ä»¬åšè¿™ä»¶äº‹ï¼æœ‰ä¹Ÿæœ‰æ²¡æœ‰ã€‚æ²¡æœ‰ä¸€ä¸ªPythonå‡½æ•°èƒ½è¿”å›åƒæˆ‘åœ¨å‰é¢ä¸¤ä¸ªä¾‹å­ä¸­åˆ›å»ºçš„æ¢¯å½¢å½¢å¼ã€‚åŸå› æ˜¯çŸ©é˜µçš„æ¢¯å½¢å½¢å¼ä¸æ˜¯å”¯ä¸€çš„ã€‚ä¾‹å¦‚ï¼Œåœ¨å‰é¢çš„<math
    alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>3</mn></mrow></math>çŸ©é˜µä¸­ï¼Œä½ å¯ä»¥å°†ç¬¬äºŒè¡Œä¹˜ä»¥2å¾—åˆ°ä¸€ä¸ªè¡Œå‘é‡[0
    10 4]ã€‚è¿™åˆ›å»ºäº†ä¸€ä¸ªå®Œå…¨æœ‰æ•ˆä½†ä¸åŒçš„åŸå§‹çŸ©é˜µçš„æ¢¯å½¢å½¢å¼ã€‚å®é™…ä¸Šï¼Œä¸è¯¥çŸ©é˜µç›¸å…³è”çš„æ¢¯å½¢çŸ©é˜µæœ‰æ— ç©·å¤šä¸ªã€‚
- en: That said, two echelon forms of a matrix are preferred over the infinite possible
    echelon forms. Those two forms are unique given some constraints and are called
    the reduced row echelon form and <math alttext="bold upper U"><mi>ğ”</mi></math>
    from LU decomposition. I will introduce both later; first, itâ€™s time to learn
    how to use row reduction to solve systems of equations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è¯è™½å¦‚æ­¤ï¼ŒçŸ©é˜µçš„ä¸¤ä¸ªæ¢¯å½¢å½¢å¼ä¼˜äºæ— é™å¯èƒ½çš„æ¢¯å½¢å½¢å¼ã€‚è¿™ä¸¤ç§å½¢å¼åœ¨ç»™å®šä¸€äº›çº¦æŸæ¡ä»¶ä¸‹æ˜¯å”¯ä¸€çš„ï¼Œç§°ä¸ºç®€åŒ–è¡Œæ¢¯å½¢å½¢å¼å’Œ<math alttext="bold
    upper U"><mi>ğ”</mi></math>æ¥è‡ªLUåˆ†è§£ã€‚ç¨åæˆ‘å°†ä»‹ç»è¿™ä¸¤è€…ï¼›é¦–å…ˆï¼Œç°åœ¨æ˜¯æ—¶å€™å­¦ä¹ å¦‚ä½•ä½¿ç”¨è¡Œå˜æ¢æ¥è§£æ–¹ç¨‹ç»„äº†ã€‚
- en: Gaussian Elimination
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é«˜æ–¯æ¶ˆå…ƒ
- en: At this point in the book, you know how to solve matrix equations using the
    matrix inverse. What if I told you that you could solve a matrix equation without
    inverting any matrices?^([3](ch10.xhtml#idm45733296566688))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ä¹¦çš„è¿™ä¸€éƒ¨åˆ†ï¼Œä½ å·²ç»å­¦ä¼šå¦‚ä½•ä½¿ç”¨çŸ©é˜µé€†æ¥è§£å†³çŸ©é˜µæ–¹ç¨‹ã€‚å¦‚æœæˆ‘å‘Šè¯‰ä½ ï¼Œä½ å¯ä»¥åœ¨ä¸æ±‚é€†ä»»ä½•çŸ©é˜µçš„æƒ…å†µä¸‹è§£å†³çŸ©é˜µæ–¹ç¨‹ï¼Œä½ ä¼šæ€ä¹ˆæƒ³ï¼Ÿ^([3](ch10.xhtml#idm45733296566688))
- en: This technique is called *Gaussian elimination*. Despite its name, the algorithm
    was actually developed by Chinese mathematicians nearly two thousand years before
    Gauss and then rediscovered by Newton hundreds of years before Gauss. But Gauss
    made important contributions to the method, including the techniques that modern
    computers implement.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æŠ€æœ¯è¢«ç§°ä¸º*é«˜æ–¯æ¶ˆå…ƒæ³•*ã€‚å°½ç®¡å…¶åç§°å¦‚æ­¤ï¼Œè¿™ä¸ªç®—æ³•å®é™…ä¸Šæ˜¯ç”±ä¸­å›½æ•°å­¦å®¶åœ¨é«˜æ–¯ä¹‹å‰è¿‘ä¸¤åƒå¹´å‘å±•å‡ºæ¥çš„ï¼Œç„¶åç”±ç‰›é¡¿åœ¨é«˜æ–¯ä¹‹å‰æ•°ç™¾å¹´é‡æ–°å‘ç°ã€‚ä½†æ˜¯é«˜æ–¯åœ¨è¯¥æ–¹æ³•ä¸­ä½œå‡ºäº†é‡è¦è´¡çŒ®ï¼ŒåŒ…æ‹¬ç°ä»£è®¡ç®—æœºå®ç°çš„æŠ€æœ¯ã€‚
- en: 'Gaussian elimination is simple: augment the matrix of coefficients by the vector
    of constants, row reduce to echelon form, and then use back substitution to solve
    for each variable in turn.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: é«˜æ–¯æ¶ˆå…ƒæ³•å¾ˆç®€å•ï¼šå°†ç³»æ•°çŸ©é˜µå¢å¹¿ä¸ºå¸¸æ•°å‘é‡ï¼Œè¡Œçº¦åŒ–ä¸ºæ¢¯å½¢å½¢å¼ï¼Œç„¶åä½¿ç”¨å›ä»£æ³•ä¾æ¬¡æ±‚è§£æ¯ä¸ªå˜é‡ã€‚
- en: 'Letâ€™s start with the system of two equations that we solved earlier:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»æˆ‘ä»¬ä¹‹å‰è§£å†³çš„ä¸¤ä¸ªæ–¹ç¨‹ç»„å¼€å§‹ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 minus y
    2nd Row 1st Column y 2nd Column equals x slash 2 plus 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 minus y
    2nd Row 1st Column y 2nd Column equals x slash 2 plus 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math>
- en: 'The first step is to convert this system of equations into a matrix equation.
    Weâ€™ve already worked through this step; that equation is printed here as a reminder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€æ­¥æ˜¯å°†è¿™ä¸ªæ–¹ç¨‹ç»„è½¬æ¢ä¸ºä¸€ä¸ªçŸ©é˜µæ–¹ç¨‹ã€‚æˆ‘ä»¬å·²ç»å®Œæˆäº†è¿™ä¸€æ­¥ï¼›è¿™ä¸ªæ–¹ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column negative 1 slash 2 2nd Column 1 EndMatrix StartBinomialOrMatrix x Choose
    y EndBinomialOrMatrix equals StartBinomialOrMatrix 4 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column negative 1 slash 2 2nd Column 1 EndMatrix StartBinomialOrMatrix x Choose
    y EndBinomialOrMatrix equals StartBinomialOrMatrix 4 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Next, we augment the coefficients matrix with the constants vector:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ç³»æ•°çŸ©é˜µä¸å¸¸æ•°å‘é‡è¿›è¡Œå¢å¹¿ï¼š
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column negative 1 slash 2 2nd Column 1 3rd Column 2 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column negative 1 slash 2 2nd Column 1 3rd Column 2 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></math>
- en: 'Then we row reduce that augmented matrix. Note that the column vector of constants
    will change during row reduction:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬å¯¹å¢å¹¿çŸ©é˜µè¿›è¡Œè¡Œçº¦åŒ–ã€‚æ³¨æ„åœ¨è¡Œçº¦åŒ–è¿‡ç¨‹ä¸­ï¼Œå¸¸æ•°åˆ—å‘é‡å°†å‘ç”Ÿå˜åŒ–ï¼š
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column negative 1 slash 2 2nd Column 1 3rd Column 2 EndMatrix StartLayout
    1st Row  right-arrow Overscript 1 slash 2 upper R 1 plus upper R 2 Endscripts
    EndLayout Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column 4 2nd
    Row 1st Column 0 2nd Column 3 slash 2 3rd Column 4 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mtable><mtr><mtd><mrow><mover><mo>â†’</mo> <mrow><mn>1</mn><mo>/</mo><mn>2</mn><msub><mi>R</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>3</mn> <mo>/</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column negative 1 slash 2 2nd Column 1 3rd Column 2 EndMatrix StartLayout
    1st Row  right-arrow Overscript 1 slash 2 upper R 1 plus upper R 2 Endscripts
    EndLayout Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column 4 2nd
    Row 1st Column 0 2nd Column 3 slash 2 3rd Column 4 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mtable><mtr><mtd><mrow><mover><mo>â†’</mo> <mrow><mn>1</mn><mo>/</mo><mn>2</mn><msub><mi>R</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>3</mn> <mo>/</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Once we have the matrix in its echelon form, we translate the augmented matrix
    back into a system of equations. That looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬å°†çŸ©é˜µè½¬æ¢ä¸ºå…¶æ¢¯å½¢å½¢å¼ï¼Œæˆ‘ä»¬å°†å¢å¹¿çŸ©é˜µè½¬æ¢å›æ–¹ç¨‹ç»„ã€‚çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column x plus y 2nd Column equals 4 2nd
    Row 1st Column 3 slash 2 y 2nd Column equals 4 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi> <mo>+</mo>
    <mphantom><mn>3</mn> <mo>/</mo> <mn>2</mn></mphantom> <mi>y</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mn>3</mn> <mo>/</mo> <mn>2</mn> <mi>y</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x plus y 2nd Column equals 4 2nd
    Row 1st Column 3 slash 2 y 2nd Column equals 4 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi> <mo>+</mo>
    <mphantom><mn>3</mn> <mo>/</mo> <mn>2</mn></mphantom> <mi>y</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mn>3</mn> <mo>/</mo> <mn>2</mn> <mi>y</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr></mtable></math>
- en: Gaussian elimination via row reduction removed the *x* term in the second equation,
    which means that solving for *y* merely involves some arithmetic. Once you solve
    for *y* = 8/3, plug that value into *y* in the first equation and solve for *x*.
    This procedure is called *back substitution*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¡Œçº¦åŒ–çš„é«˜æ–¯æ¶ˆå…ƒæ³•ç§»é™¤äº†ç¬¬äºŒä¸ªæ–¹ç¨‹ä¸­çš„*x*é¡¹ï¼Œè¿™æ„å‘³ç€è§£*y*ä»…æ¶‰åŠä¸€äº›ç®—æœ¯è¿ç®—ã€‚ä¸€æ—¦è§£å‡º*y* = 8/3ï¼Œå°†è¯¥å€¼ä»£å…¥ç¬¬ä¸€ä¸ªæ–¹ç¨‹ä¸­çš„*y*ï¼Œå¹¶è§£å‡º*x*ã€‚è¿™ä¸ªè¿‡ç¨‹è¢«ç§°ä¸º*å›ä»£æ³•*ã€‚
- en: In the previous section, I wrote that Python does not have a function to compute
    the echelon form of a matrix because it is not unique. And then I wrote that there
    is one unique echelon matrix, called the *reduced row echelon form* and often
    abbreviated RREF, which Python will compute. Keep reading to learn moreâ€¦
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰ä¸€èŠ‚ä¸­ï¼Œæˆ‘å†™é“Pythonæ²¡æœ‰å‡½æ•°æ¥è®¡ç®—çŸ©é˜µçš„æ¢¯å½¢å½¢å¼ï¼Œå› ä¸ºå®ƒä¸æ˜¯å”¯ä¸€çš„ã€‚ç„¶åæˆ‘å†™é“æœ‰ä¸€ä¸ªå”¯ä¸€çš„æ¢¯å½¢çŸ©é˜µï¼Œç§°ä¸º*ç®€åŒ–è¡Œé˜¶æ¢¯å½¢å¼*ï¼Œé€šå¸¸ç¼©å†™ä¸ºRREFï¼ŒPythonå°†ä¼šè®¡ç®—ã€‚ç»§ç»­é˜…è¯»ä»¥äº†è§£æ›´å¤šä¿¡æ¯â€¦
- en: Gauss-Jordan Elimination
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é«˜æ–¯-çº¦å½“æ¶ˆå…ƒ
- en: 'Letâ€™s keep row reducing our example matrix with the goal of turning all the
    *pivots*â€”the leftmost nonzero numbers in each rowâ€”into 1s. Once you have the echelon
    matrix, you simply divide each row by its pivot. In this example, the first row
    already has a 1 in the leftmost position, so we just need to adjust the second
    row. That gives us the following matrix:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç»§ç»­å¯¹æˆ‘ä»¬çš„ç¤ºä¾‹çŸ©é˜µè¿›è¡Œè¡Œçº¦åŒ–ï¼Œç›®æ ‡æ˜¯å°†æ‰€æœ‰*ä¸»å…ƒ*â€”â€”æ¯è¡Œä¸­æœ€å·¦ä¾§çš„éé›¶æ•°â€”â€”è½¬æ¢ä¸º1ã€‚ä¸€æ—¦å¾—åˆ°æ¢¯å½¢çŸ©é˜µï¼Œä½ åªéœ€å°†æ¯è¡Œé™¤ä»¥å…¶ä¸»å…ƒã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç¬¬ä¸€è¡Œå·²ç»æœ‰äº†å·¦ä¾§ä½ç½®çš„1ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦è°ƒæ•´ç¬¬äºŒè¡Œã€‚è¿™ç»™å‡ºäº†ä»¥ä¸‹çŸ©é˜µï¼š
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mn>8</mn> <mo>/</mo>
    <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mn>8</mn> <mo>/</mo>
    <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></math>
- en: 'And now for the trick: we continue row reducing *upward* to eliminate all the
    elements above each pivot. In other words, we want an echelon matrix in which
    each pivot is 1 and itâ€™s the only nonzero number in its column.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®²è§£ä¸€ä¸ªçªé—¨ï¼šæˆ‘ä»¬ç»§ç»­å‘*ä¸Š*è¡Œçº¦åŒ–ï¼Œä»¥æ¶ˆé™¤æ¯ä¸ªä¸»å…ƒä¸Šæ–¹çš„æ‰€æœ‰å…ƒç´ ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¸Œæœ›å¾—åˆ°ä¸€ä¸ªæ¢¯å½¢çŸ©é˜µï¼Œå…¶ä¸­æ¯ä¸ªä¸»å…ƒä¸º1ï¼Œä¸”æ˜¯å…¶æ‰€åœ¨åˆ—çš„å”¯ä¸€éé›¶æ•°ã€‚
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix StartLayout
    1st Row  right-arrow Overscript minus upper R 2 plus upper R 1 Endscripts EndLayout
    Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column 4 slash 3 2nd
    Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mn>8</mn> <mo>/</mo>
    <mn>3</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>â†’</mo>
    <mrow><mo>-</mo><msub><mi>R</mi> <mn>2</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>1</mn></msub></mrow></mover></mrow></mtd></mtr></mtable> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mrow><mn>4</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>8</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix StartLayout
    1st Row  right-arrow Overscript minus upper R 2 plus upper R 1 Endscripts EndLayout
    Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column 4 slash 3 2nd
    Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mn>8</mn> <mo>/</mo>
    <mn>3</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>â†’</mo>
    <mrow><mo>-</mo><msub><mi>R</mi> <mn>2</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>1</mn></msub></mrow></mover></mrow></mtd></mtr></mtable> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mrow><mn>4</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>8</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: Thatâ€™s the RREF of our original matrix. You can see the identity matrix on the
    leftâ€”RREF will always produce an identity matrix as a submatrix in the upper-left
    of the original matrix. Thatâ€™s a result of setting all pivots to 1 and using upward
    row reduction to eliminate all elements above each pivot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘ä»¬åŸå§‹çŸ©é˜µçš„ç®€åŒ–è¡Œé˜¶æ¢¯å½¢å¼ï¼ˆRREFï¼‰ã€‚ä½ å¯ä»¥çœ‹åˆ°å·¦ä¾§æ˜¯å•ä½çŸ©é˜µâ€”â€”RREFæ€»ä¼šåœ¨åŸå§‹çŸ©é˜µçš„å·¦ä¸Šè§’ç”Ÿæˆä¸€ä¸ªå•ä½çŸ©é˜µã€‚è¿™æ˜¯é€šè¿‡å°†æ‰€æœ‰ä¸»å…ƒè®¾ä¸º1ï¼Œå¹¶ä½¿ç”¨å‘ä¸Šè¡Œçº¦åŒ–æ¥æ¶ˆé™¤æ¯ä¸ªä¸»å…ƒä¸Šæ–¹çš„æ‰€æœ‰å…ƒç´ å¾—åˆ°çš„ç»“æœã€‚
- en: 'Now we continue with Gaussian elimination by translating the matrix back into
    a system of equations:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬é€šè¿‡å°†çŸ©é˜µè½¬æ¢å›æ–¹ç¨‹ç»„æ¥ç»§ç»­é«˜æ–¯æ¶ˆå…ƒï¼š
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 slash 3
    2nd Row 1st Column y 2nd Column equals 8 slash 3 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>8</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 slash 3
    2nd Row 1st Column y 2nd Column equals 8 slash 3 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>8</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr></mtable></math>
- en: 'We no longer need back substitution, or even basic arithmetic: the modified
    Gaussian eliminationâ€”which is called Gauss-Jordan eliminationâ€”decoupled the interwoven
    variables in the system of equations, and laid bare the solutions to each variable.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸å†éœ€è¦å›ä»£ï¼Œç”šè‡³åŸºæœ¬çš„ç®—æœ¯ï¼šä¿®æ”¹åçš„é«˜æ–¯æ¶ˆå…ƒæ³•â€”â€”ç§°ä¸ºé«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒæ³•â€”â€”è§£å¼€äº†æ–¹ç¨‹ç»„ä¸­äº¤ç»‡çš„å˜é‡ï¼Œå¹¶æ˜¾éœ²äº†æ¯ä¸ªå˜é‡çš„è§£ã€‚
- en: Gauss-Jordan elimination was how people solved systems of equations by hand
    for over a century before computers came along to help us with the number crunching.
    In fact, computers still implement this exact same method, with only a few small
    modifications to ensure numerical stability.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¡ç®—æœºå¸®åŠ©æˆ‘ä»¬è¿›è¡Œæ•°å­—è®¡ç®—ä¹‹å‰ï¼Œé«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒæ³•æ˜¯äººä»¬æ‰‹å·¥è§£æ–¹ç¨‹ç»„çš„æ–¹æ³•è¶…è¿‡ä¸€ä¸ªä¸–çºªã€‚äº‹å®ä¸Šï¼Œè®¡ç®—æœºä»ç„¶å®ç°è¿™ä¸ªå®Œå…¨ç›¸åŒçš„æ–¹æ³•ï¼Œåªæ˜¯è¿›è¡Œäº†ä¸€äº›å°çš„ä¿®æ”¹ä»¥ç¡®ä¿æ•°å€¼ç¨³å®šæ€§ã€‚
- en: 'The RREF is unique, meaning that a matrix has exactly one associated RREF.
    NumPy does not have a function to compute the RREF of a matrix, but the sympy
    library does (sympy is the symbolic math library in Python and is a powerful engine
    for â€œchalkboard mathâ€):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: RREFæ˜¯å”¯ä¸€çš„ï¼Œè¿™æ„å‘³ç€ä¸€ä¸ªçŸ©é˜µæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªç›¸å…³çš„RREFã€‚NumPyæ²¡æœ‰è®¡ç®—çŸ©é˜µRREFçš„å‡½æ•°ï¼Œä½†sympyåº“æœ‰ï¼ˆsympyæ˜¯Pythonä¸­çš„ç¬¦å·æ•°å­¦åº“ï¼Œæ˜¯â€œé»‘æ¿æ•°å­¦â€çš„å¼ºå¤§å¼•æ“ï¼‰ï¼š
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Matrix Inverse via Gauss-Jordan Elimination
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é€šè¿‡é«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒæ³•æ±‚çŸ©é˜µçš„é€†
- en: The key insight from Gauss-Jordan elimination is that row reduction produces
    a sequence of row manipulations that solves a set of equations. Those row manipulations
    are linear transformations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ä»é«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒæ³•çš„å…³é”®æ´è§æ˜¯è¡Œçº¦ç®€äº§ç”Ÿäº†ä¸€ç³»åˆ—è§£å†³æ–¹ç¨‹ç»„çš„è¡Œæ“ä½œã€‚è¿™äº›è¡Œæ“ä½œæ˜¯çº¿æ€§å˜æ¢ã€‚
- en: 'Curiously, the description of Gauss-Jordan elimination is consistent with the
    description of the matrix inverse: a linear transformation that solves a set of
    equations. But wait, what â€œsystem of equationsâ€ does the matrix inverse solve?
    A fresh perspective on the matrix inverse will provide some new insights. Consider
    this system of equations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰è¶£çš„æ˜¯ï¼Œé«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒçš„æè¿°ä¸çŸ©é˜µé€†çš„æè¿°ä¸€è‡´ï¼šä¸€ä¸ªè§£å†³ä¸€ç»„æ–¹ç¨‹çš„çº¿æ€§å˜æ¢ã€‚ä½†ç­‰ç­‰ï¼ŒçŸ©é˜µé€†è§£å†³çš„â€œæ–¹ç¨‹ç»„â€æ˜¯ä»€ä¹ˆï¼Ÿå¯¹çŸ©é˜µé€†çš„æ–°è§†è§’å°†æä¾›ä¸€äº›æ–°çš„è§è§£ã€‚è€ƒè™‘è¿™ä¸ªæ–¹ç¨‹ç»„ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column a x 1 plus b y 1 2nd Column equals
    1 2nd Row 1st Column c x 1 plus d y 1 2nd Column equals 0 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>a</mi> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>b</mi> <msub><mi>y</mi> <mn>1</mn></msub></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>c</mi> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo>
    <mi>d</mi> <msub><mi>y</mi> <mn>1</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column a x 1 plus b y 1 2nd Column equals
    1 2nd Row 1st Column c x 1 plus d y 1 2nd Column equals 0 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>a</mi> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>b</mi> <msub><mi>y</mi> <mn>1</mn></msub></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>c</mi> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo>
    <mi>d</mi> <msub><mi>y</mi> <mn>1</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr></mtable></math>
- en: 'Translated into a matrix equation, we get:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: è½¬åŒ–ä¸ºçŸ©é˜µæ–¹ç¨‹ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix StartBinomialOrMatrix x 1 Choose y 1 EndBinomialOrMatrix
    equals StartBinomialOrMatrix 1 Choose 0 EndBinomialOrMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>1</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix StartBinomialOrMatrix x 1 Choose y 1 EndBinomialOrMatrix
    equals StartBinomialOrMatrix 1 Choose 0 EndBinomialOrMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>1</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Check out that constants vectorâ€”it is the first column of the <math alttext="2
    times 2"><mrow><mn>2</mn> <mo>Ã—</mo> <mn>2</mn></mrow></math> identity matrix!
    That means that applying RREF to a square full-rank matrix augmented by the first
    column of the identity matrix will reveal the linear transformation that brings
    the matrix into the first column of the identity matrix. And that in turn means
    that the vector [ <math alttext="x 1 y 1"><mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <msub><mi>y</mi> <mn>1</mn></msub></mrow></math> ] <math alttext="Superscript
    upper T"><msup><mtext>T</mtext></msup></math> is the first column of the matrix
    inverse.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹å¸¸æ•°å‘é‡å§â€”â€”å®ƒæ˜¯<math alttext="2 times 2"><mrow><mn>2</mn> <mo>Ã—</mo> <mn>2</mn></mrow></math>å•ä½çŸ©é˜µçš„ç¬¬ä¸€åˆ—ï¼è¿™æ„å‘³ç€å¯¹äºä¸€ä¸ªæ–¹é˜µæ»¡ç§©çŸ©é˜µï¼Œåº”ç”¨RREFå¹¶å¢å¹¿å•ä½çŸ©é˜µçš„ç¬¬ä¸€åˆ—å°†æ­ç¤ºå°†çŸ©é˜µå¸¦å…¥å•ä½çŸ©é˜µç¬¬ä¸€åˆ—çš„çº¿æ€§å˜æ¢ã€‚è€Œè¿™åè¿‡æ¥æ„å‘³ç€å‘é‡
    [ <math alttext="x 1 y 1"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <msub><mi>y</mi>
    <mn>1</mn></msub></mrow></math> ] <math alttext="Superscript upper T"><msup><mtext>T</mtext></msup></math>
    æ˜¯çŸ©é˜µé€†çš„ç¬¬ä¸€åˆ—ã€‚
- en: 'We then repeat the procedure but solving for the second column of the inverse:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬é‡å¤è¯¥è¿‡ç¨‹ï¼Œä½†è§£å†³çŸ©é˜µé€†çš„ç¬¬äºŒåˆ—ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column a x 2 plus b y 2 2nd Column equals
    0 2nd Row 1st Column c x 2 plus d y 2 2nd Column equals 1 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>a</mi> <msub><mi>x</mi>
    <mn>2</mn></msub> <mo>+</mo> <mi>b</mi> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>c</mi> <msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo>
    <mi>d</mi> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>1</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column a x 2 plus b y 2 2nd Column equals
    0 2nd Row 1st Column c x 2 plus d y 2 2nd Column equals 1 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>a</mi> <msub><mi>x</mi>
    <mn>2</mn></msub> <mo>+</mo> <mi>b</mi> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>c</mi> <msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo>
    <mi>d</mi> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>1</mn></mrow></mtd></mtr></mtable></math>
- en: RREF on that system gives the vector [ <math alttext="x 2 y 2"><mrow><msub><mi>x</mi>
    <mn>2</mn></msub> <msub><mi>y</mi> <mn>2</mn></msub></mrow></math> ] <math alttext="Superscript
    upper T"><msup><mtext>T</mtext></msup></math> , which is the second column of
    the matrix inverse.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹è¯¥ç³»ç»Ÿè¿›è¡ŒRREFå¾—åˆ°å‘é‡ [ <math alttext="x 2 y 2"><mrow><msub><mi>x</mi> <mn>2</mn></msub>
    <msub><mi>y</mi> <mn>2</mn></msub></mrow></math> ] <math alttext="Superscript
    upper T"><msup><mtext>T</mtext></msup></math> ï¼Œå³çŸ©é˜µé€†çš„ç¬¬äºŒåˆ—ã€‚
- en: Iâ€™ve separated the columns of the identity matrix to link back to the perspective
    of solving systems of equations. But we can augment the entire identity matrix
    and solve for the inverse with one RREF.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å·²ç»å°†å•ä½çŸ©é˜µçš„åˆ—åˆ†å¼€ï¼Œä»¥å›åˆ°è§£å†³æ–¹ç¨‹ç»„çš„è§†è§’ã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥å¢å¹¿æ•´ä¸ªå•ä½çŸ©é˜µï¼Œå¹¶é€šè¿‡ä¸€ä¸ªRREFæ±‚è§£é€†çŸ©é˜µã€‚
- en: 'Here is the birdâ€™s-eye view of obtaining the matrix inverse via Gauss-Jordan
    elimination (the square brackets indicate augmented matrices with the vertical
    line separating the two constituent matrices):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯é€šè¿‡é«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒæ³•è·å¾—çŸ©é˜µé€†çš„é¸Ÿç°å›¾ï¼ˆæ–¹æ‹¬å·è¡¨ç¤ºå¸¦æœ‰å‚ç›´çº¿åˆ†éš”çš„å¢å¹¿çŸ©é˜µï¼‰ï¼š
- en: <math alttext="r r e f left-parenthesis Start 1 By 1 Matrix 1st Row  bold upper
    A vertical-bar bold upper I EndMatrix right-parenthesis right double arrow Start
    1 By 1 Matrix 1st Row  bold upper I vertical-bar bold upper A Superscript negative
    1 EndMatrix" display="block"><mrow><mi>r</mi> <mi>r</mi> <mi>e</mi> <mi>f</mi>
    <mrow><mo>(</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>ğ€</mi>
    <mo>|</mo> <mi>ğˆ</mi></mrow></mtd></mtr></mtable></mfenced> <mo>)</mo></mrow>
    <mo>â‡’</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mrow><mi>ğˆ</mi>
    <mo>|</mo></mrow> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="r r e f left-parenthesis Start 1 By 1 Matrix 1st Row  bold upper
    A vertical-bar bold upper I EndMatrix right-parenthesis right double arrow Start
    1 By 1 Matrix 1st Row  bold upper I vertical-bar bold upper A Superscript negative
    1 EndMatrix" display="block"><mrow><mi>r</mi> <mi>r</mi> <mi>e</mi> <mi>f</mi>
    <mrow><mo>(</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>ğ€</mi>
    <mo>|</mo> <mi>ğˆ</mi></mrow></mtd></mtr></mtable></mfenced> <mo>)</mo></mrow>
    <mo>â‡’</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mrow><mi>ğˆ</mi>
    <mo>|</mo></mrow> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: This is interesting because it provides a mechanism for computing the matrix
    inverse without computing determinants. On the other hand, row reduction does
    involve a lot of division, which increases the risk of numerical precision errors.
    For example, imagine we have two numbers that are essentially zero plus rounding
    error. If we end up dividing those numbers during RREF, we could get the fraction
    <math alttext="10 Superscript negative 15 Baseline slash 10 Superscript negative
    16"><mrow><msup><mn>10</mn> <mrow><mo>-</mo><mn>15</mn></mrow></msup> <mo>/</mo>
    <msup><mn>10</mn> <mrow><mo>-</mo><mn>16</mn></mrow></msup></mrow></math> , which
    is really 0/0 but the answer will be 10.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¾ˆæœ‰è¶£ï¼Œå› ä¸ºå®ƒæä¾›äº†ä¸€ç§è®¡ç®—çŸ©é˜µé€†çš„æœºåˆ¶ï¼Œè€Œæ— éœ€è®¡ç®—è¡Œåˆ—å¼ã€‚å¦ä¸€æ–¹é¢ï¼Œè¡Œå˜æ¢ç¡®å®æ¶‰åŠå¤§é‡çš„é™¤æ³•ï¼Œè¿™å¢åŠ äº†æ•°å€¼ç²¾åº¦è¯¯å·®çš„é£é™©ã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹æˆ‘ä»¬æœ‰ä¸¤ä¸ªåŸºæœ¬ä¸Šæ˜¯é›¶åŠ ä¸Šèˆå…¥è¯¯å·®çš„æ•°å­—ã€‚å¦‚æœæˆ‘ä»¬åœ¨
    RREF è¿‡ç¨‹ä¸­é™¤ä»¥è¿™äº›æ•°å­—ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¾—åˆ°åˆ†æ•° <math alttext="10 Superscript negative 15 Baseline slash
    10 Superscript negative 16"><mrow><msup><mn>10</mn> <mrow><mo>-</mo><mn>15</mn></mrow></msup>
    <mo>/</mo> <msup><mn>10</mn> <mrow><mo>-</mo><mn>16</mn></mrow></msup></mrow></math>
    ï¼Œè¿™å®é™…ä¸Šæ˜¯ 0/0ï¼Œä½†ç­”æ¡ˆå°†æ˜¯ 10ã€‚
- en: 'The conclusion here is similar to what I discussed in the previous chapter
    about using QR to compute the matrix inverse: using Gauss-Jordan elimination to
    compute the matrix inverse is likely to be more numerically stable than the full
    algorithm for the inverse, but a matrix that is close to singular or that has
    a high condition number is difficult to invert, regardless of the algorithm used.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“è®ºç±»ä¼¼äºæˆ‘åœ¨å‰ä¸€ç« è®¨è®ºè¿‡çš„å…³äºä½¿ç”¨ QR åˆ†è§£è®¡ç®—çŸ©é˜µé€†çš„å†…å®¹ï¼šä½¿ç”¨ Gauss-Jordan æ¶ˆå…ƒæ³•è®¡ç®—çŸ©é˜µé€†å¾ˆå¯èƒ½æ¯”å®Œæ•´çš„é€†ç®—æ³•åœ¨æ•°å€¼ç¨³å®šæ€§ä¸Šæ›´å¯é ï¼Œä½†æ˜¯æ¥è¿‘å¥‡å¼‚æˆ–å…·æœ‰é«˜æ¡ä»¶æ•°çš„çŸ©é˜µå¾ˆéš¾åè½¬ï¼Œæ— è®ºä½¿ç”¨å“ªç§ç®—æ³•ã€‚
- en: LU Decomposition
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LU åˆ†è§£
- en: 'The â€œLUâ€ in *LU decomposition* stands for â€œlower upper,â€ as in lower-triangular,
    upper-triangular. The idea is to decompose a matrix into the product of two triangular
    matrices:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*LU åˆ†è§£* ä¸­çš„â€œLUâ€ä»£è¡¨â€œä¸‹ä¸‰è§’ï¼Œä¸Šä¸‰è§’â€ã€‚å…¶æ€æƒ³æ˜¯å°†ä¸€ä¸ªçŸ©é˜µåˆ†è§£æˆä¸¤ä¸ªä¸‰è§’çŸ©é˜µçš„ä¹˜ç§¯ï¼š'
- en: <math alttext="bold upper A equals bold upper L bold upper U" display="block"><mrow><mi>ğ€</mi>
    <mo>=</mo> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper A equals bold upper L bold upper U" display="block"><mrow><mi>ğ€</mi>
    <mo>=</mo> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math>
- en: 'Hereâ€™s a numerical example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä¸€ä¸ªæ•°å€¼ä¾‹å­ï¼š
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 2 2nd Column 2 3rd Column
    4 2nd Row 1st Column 1 2nd Column 0 3rd Column 3 3rd Row 1st Column 2 2nd Column
    1 3rd Column 2 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 1 slash 2 2nd Column 1 3rd Column 0 3rd Row
    1st Column 1 2nd Column 1 3rd Column 1 EndMatrix Start 3 By 3 Matrix 1st Row 1st
    Column 2 2nd Column 2 3rd Column 4 2nd Row 1st Column 0 2nd Column negative 1
    3rd Column 1 3rd Row 1st Column 0 2nd Column 0 3rd Column negative 3 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 2 2nd Column 2 3rd Column
    4 2nd Row 1st Column 1 2nd Column 0 3rd Column 3 3rd Row 1st Column 2 2nd Column
    1 3rd Column 2 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 1 slash 2 2nd Column 1 3rd Column 0 3rd Row
    1st Column 1 2nd Column 1 3rd Column 1 EndMatrix Start 3 By 3 Matrix 1st Row 1st
    Column 2 2nd Column 2 3rd Column 4 2nd Row 1st Column 0 2nd Column negative 1
    3rd Column 1 3rd Row 1st Column 0 2nd Column 0 3rd Column negative 3 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'And hereâ€™s the corresponding Python code (note that the function for LU decomposition
    is in the SciPy library):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¯¹åº”çš„ Python ä»£ç ï¼ˆæ³¨æ„ LU åˆ†è§£çš„å‡½æ•°åœ¨ SciPy åº“ä¸­ï¼‰ï¼š
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Where do these two matrices come from? In fact, you already know the answer:
    row reduction can be expressed as <math alttext="bold upper L Superscript negative
    1 Baseline bold upper A equals bold upper U"><mrow><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ€</mi> <mo>=</mo> <mi>ğ”</mi></mrow></math> , where <math alttext="bold upper
    L Superscript negative 1"><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    contains the set of row manipulations that transforms the dense <math alttext="bold
    upper A"><mi>ğ€</mi></math> into upper-triangular (echelon) <math alttext="bold
    upper U"><mi>ğ”</mi></math> .'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªçŸ©é˜µæ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿäº‹å®ä¸Šï¼Œä½ å·²ç»çŸ¥é“ç­”æ¡ˆï¼šè¡Œå˜æ¢å¯ä»¥è¡¨ç¤ºä¸º <math alttext="bold upper L Superscript negative
    1 Baseline bold upper A equals bold upper U"><mrow><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ€</mi> <mo>=</mo> <mi>ğ”</mi></mrow></math> ï¼Œå…¶ä¸­ <math alttext="bold upper L
    Superscript negative 1"><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    åŒ…å«äº†å°†å¯†é›†çŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math> è½¬æ¢ä¸ºä¸Šä¸‰è§’å½¢å¼çš„è¡Œæ“ä½œé›†åˆ <math alttext="bold
    upper U"><mi>ğ”</mi></math> ã€‚
- en: Because the echelon form is not unique, LU decomposition is not necessarily
    unique. That is, there is an infinite pairing of lower- and upper-triangular matrices
    that could multiply to produce matrix <math alttext="bold upper A"><mi>ğ€</mi></math>
    . However, adding the constraint that the diagonals of <math alttext="bold upper
    L"><mi>ğ‹</mi></math> equal 1 ensures that LU decomposition is unique for a full-rank
    square matrix <math alttext="bold upper A"><mi>ğ€</mi></math> (you can see this
    in the previous example). The uniqueness of LU decompositions of reduced-rank
    and nonsquare matrices is a longer discussion that I will omit here; however,
    SciPyâ€™s LU decomposition algorithm is determinstic, meaning that repeated LU decompositions
    of a given matrix will be identical.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæ¢¯å½¢å½¢å¼ä¸å”¯ä¸€ï¼ŒLU åˆ†è§£ä¹Ÿä¸ä¸€å®šå”¯ä¸€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå­˜åœ¨æ— é™å¤šä¸ªä¸‹ä¸‰è§’çŸ©é˜µå’Œä¸Šä¸‰è§’çŸ©é˜µçš„é…å¯¹ï¼Œå®ƒä»¬å¯ä»¥ç›¸ä¹˜å¾—åˆ°çŸ©é˜µ <math alttext="bold
    upper A"><mi>ğ€</mi></math> ã€‚ç„¶è€Œï¼Œé€šè¿‡åŠ ä¸Š <math alttext="bold upper L"><mi>ğ‹</mi></math>
    å¯¹è§’çº¿å…ƒç´ ä¸º 1 çš„çº¦æŸæ¡ä»¶ï¼Œå¯ä»¥ç¡®ä¿å¯¹äºæ»¡ç§©æ–¹é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math> ï¼ŒLU åˆ†è§£æ˜¯å”¯ä¸€çš„ï¼ˆä½ å¯ä»¥åœ¨å‰é¢çš„ä¾‹å­ä¸­çœ‹åˆ°è¿™ä¸€ç‚¹ï¼‰ã€‚å…³äºé™ç§©å’Œéæ–¹é˜µçš„LUåˆ†è§£å”¯ä¸€æ€§æ˜¯ä¸€ä¸ªæ›´é•¿çš„è®¨è®ºï¼Œæˆ‘è¿™é‡Œä¸å†è¯¦è¿°ï¼›ç„¶è€Œï¼ŒSciPy
    çš„ LU åˆ†è§£ç®—æ³•æ˜¯ç¡®å®šæ€§çš„ï¼Œè¿™æ„å‘³ç€å¯¹äºç»™å®šçŸ©é˜µçš„é‡å¤ LU åˆ†è§£ç»“æœå°†æ˜¯ç›¸åŒçš„ã€‚
- en: Row Swaps via Permutation Matrices
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é€šè¿‡ç½®æ¢çŸ©é˜µè¿›è¡Œè¡Œäº¤æ¢
- en: 'Some matrices do not easily transform into an upper-triangular form. Consider
    the following matrix:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº›çŸ©é˜µä¸å®¹æ˜“è½¬æ¢æˆä¸Šä¸‰è§’å½¢å¼ã€‚è€ƒè™‘ä»¥ä¸‹çŸ©é˜µï¼š
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 3 2nd Column 2 3rd Column
    1 2nd Row 1st Column 0 2nd Column 0 3rd Column 5 3rd Row 1st Column 0 2nd Column
    7 3rd Column 2 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 3 2nd Column 2 3rd Column
    1 2nd Row 1st Column 0 2nd Column 0 3rd Column 5 3rd Row 1st Column 0 2nd Column
    7 3rd Column 2 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></math>
- en: 'Itâ€™s not in echelon form, but it would be if we swapped the second and third
    rows. Row swaps are one of the tricks of row reduction, and are implemented through
    a permutation matrix:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä¸å¤„äºæ¢¯å½¢å½¢å¼ï¼Œä½†å¦‚æœæˆ‘ä»¬äº¤æ¢ç¬¬äºŒè¡Œå’Œç¬¬ä¸‰è¡Œï¼Œå®ƒå°†å¤„äºæ¢¯å½¢å½¢å¼ã€‚è¡Œäº¤æ¢æ˜¯è¡Œçº¦ç®€çš„æŠ€å·§ä¹‹ä¸€ï¼Œå¹¶ä¸”é€šè¿‡æ’åˆ—çŸ©é˜µå®ç°ï¼š
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 0 3rd Column 1 3rd Row 1st Column 0 2nd Column
    1 3rd Column 0 EndMatrix Start 3 By 3 Matrix 1st Row 1st Column 3 2nd Column 2
    3rd Column 1 2nd Row 1st Column 0 2nd Column 0 3rd Column 5 3rd Row 1st Column
    0 2nd Column 7 3rd Column 2 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    3 2nd Column 2 3rd Column 1 2nd Row 1st Column 0 2nd Column 7 3rd Column 2 3rd
    Row 1st Column 0 2nd Column 0 3rd Column 5 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 0 3rd Column 1 3rd Row 1st Column 0 2nd Column
    1 3rd Column 0 EndMatrix Start 3 By 3 Matrix 1st Row 1st Column 3 2nd Column 2
    3rd Column 1 2nd Row 1st Column 0 2nd Column 0 3rd Column 5 3rd Row 1st Column
    0 2nd Column 7 3rd Column 2 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    3 2nd Column 2 3rd Column 1 2nd Row 1st Column 0 2nd Column 7 3rd Column 2 3rd
    Row 1st Column 0 2nd Column 0 3rd Column 5 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Permutation matrices are often labeled <math alttext="bold upper P"><mi>ğ</mi></math>
    . Thus, the full LU decomposition actually takes the following form:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: æ’åˆ—çŸ©é˜µé€šå¸¸æ ‡è®°ä¸º<math alttext="bold upper P"><mi>ğ</mi></math>ã€‚å› æ­¤ï¼Œå®Œæ•´çš„LUåˆ†è§£å®é™…ä¸Šé‡‡ç”¨ä»¥ä¸‹å½¢å¼ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper P bold upper A 2nd
    Column equals bold upper L bold upper U 2nd Row 1st Column bold upper A 2nd Column
    equals bold upper P Superscript upper T Baseline bold upper L bold upper U EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ</mi>
    <mi>ğ€</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>ğ€</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper P bold upper A 2nd
    Column equals bold upper L bold upper U 2nd Row 1st Column bold upper A 2nd Column
    equals bold upper P Superscript upper T Baseline bold upper L bold upper U EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ğ</mi>
    <mi>ğ€</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>ğ€</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></mtd></mtr></mtable></math>
- en: Remarkably, permutation matrices are orthogonal, and so <math alttext="bold
    upper P Superscript negative 1 Baseline equals bold upper P Superscript upper
    T"><mrow><msup><mi>ğ</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo>
    <msup><mi>ğ</mi> <mtext>T</mtext></msup></mrow></math> . Briefly, the reason is
    that all elements of a permutation matrix are either 0 or 1, and because rows
    are swapped only once, each column has exactly one nonzero element (indeed, all
    permutation matrices are identity matrices with row swaps). Therefore, the dot
    product of any two columns is 0 while the dot product of a column with itself
    is 1, meaning <math alttext="bold upper P Superscript upper T Baseline bold upper
    P equals bold upper I"><mrow><msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ</mi>
    <mo>=</mo> <mi>ğˆ</mi></mrow></math> .
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæ’åˆ—çŸ©é˜µæ˜¯æ­£äº¤çš„ï¼Œå› æ­¤<math alttext="bold upper P Superscript negative 1 Baseline
    equals bold upper P Superscript upper T"><mrow><msup><mi>ğ</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <msup><mi>ğ</mi> <mtext>T</mtext></msup></mrow></math>ã€‚ç®€è€Œè¨€ä¹‹ï¼ŒåŸå› åœ¨äºæ’åˆ—çŸ©é˜µçš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯0æˆ–1ï¼Œå¹¶ä¸”å› ä¸ºåªäº¤æ¢è¡Œä¸€æ¬¡ï¼Œæ‰€ä»¥æ¯åˆ—æ°å¥½æœ‰ä¸€ä¸ªéé›¶å…ƒç´ ï¼ˆäº‹å®ä¸Šï¼Œæ‰€æœ‰æ’åˆ—çŸ©é˜µéƒ½æ˜¯é€šè¿‡è¡Œäº¤æ¢å¾—åˆ°çš„å•ä½çŸ©é˜µï¼‰ã€‚å› æ­¤ï¼Œä»»æ„ä¸¤åˆ—çš„ç‚¹ç§¯ä¸º0ï¼Œè€Œåˆ—ä¸è‡ªèº«çš„ç‚¹ç§¯ä¸º1ï¼Œè¿™æ„å‘³ç€<math
    alttext="bold upper P Superscript upper T Baseline bold upper P equals bold upper
    I"><mrow><msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math>ã€‚
- en: '**Important:** the formulas I wrote above provide the *mathematical* description
    of LU decomposition. Scipy actually returns <math alttext="bold upper A equals
    bold upper P bold upper L bold upper U"><mrow><mi>ğ€</mi> <mo>=</mo> <mi>ğ</mi>
    <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math> , which we could also write as <math alttext="bold
    upper P Superscript upper T Baseline bold upper A equals bold upper L bold upper
    U"><mrow><msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ€</mi> <mo>=</mo> <mi>ğ‹</mi>
    <mi>ğ”</mi></mrow></math> . [Exercise 10-4](#exercise_10_4) provides the opportunity
    to explore this point of confusion.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡è¦æç¤ºï¼š**æˆ‘ä¸Šé¢å†™çš„å…¬å¼æä¾›äº†LUåˆ†è§£çš„*æ•°å­¦*æè¿°ã€‚å®é™…ä¸Šï¼ŒScipyè¿”å›çš„æ˜¯<math alttext="bold upper A equals
    bold upper P bold upper L bold upper U"><mrow><mi>ğ€</mi> <mo>=</mo> <mi>ğ</mi>
    <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math>ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å†™æˆ<math alttext="bold upper P Superscript
    upper T Baseline bold upper A equals bold upper L bold upper U"><mrow><msup><mi>ğ</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi> <mo>=</mo> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math>ã€‚[ç»ƒä¹ Â 10-4](#exercise_10_4)æä¾›äº†æ¢ç´¢è¿™ä¸€æ··æ·†ç‚¹çš„æœºä¼šã€‚'
- en: '[FigureÂ 10-1](#fig_10_1) shows an example of LU decomposition applied to a
    random matrix.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾Â 10-1](#fig_10_1)å±•ç¤ºäº†LUåˆ†è§£åº”ç”¨äºéšæœºçŸ©é˜µçš„ç¤ºä¾‹ã€‚'
- en: '![L to the U](assets/plad_1001.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![L to the U](assets/plad_1001.png)'
- en: Figure 10-1\. Visualization of LU decomposition
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾Â 10-1\. LUåˆ†è§£çš„å¯è§†åŒ–
- en: LU decomposition is used in several applications, including computing the determinant
    and the matrix inverse. In the next chapter, youâ€™ll see how LU decomposition is
    used in the least squares computation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: LUåˆ†è§£åœ¨å¤šä¸ªåº”ç”¨ä¸­ä½¿ç”¨ï¼ŒåŒ…æ‹¬è®¡ç®—è¡Œåˆ—å¼å’ŒçŸ©é˜µé€†ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæ‚¨å°†çœ‹åˆ°LUåˆ†è§£å¦‚ä½•ç”¨äºæœ€å°äºŒä¹˜è®¡ç®—ã€‚
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: 'I opened this chapter by promising an action-packed educational adventure.
    I hope you experienced several adrenaline rushes while learning new perspectives
    on algebraic equations, matrix decompositions, and the matrix inverse. Here are
    the key take-home messages of this chapter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åœ¨æœ¬ç« å¼€å¤´æ‰¿è¯ºæä¾›ä¸€ä¸ªå……æ»¡æ•™è‚²æ„ä¹‰çš„åŠ¨æ„Ÿå†’é™©ã€‚å¸Œæœ›åœ¨å­¦ä¹ ä»£æ•°æ–¹ç¨‹ã€çŸ©é˜µåˆ†è§£å’ŒçŸ©é˜µé€†çš„æ–°è§†è§’æ—¶ï¼Œæ‚¨ä½“éªŒåˆ°äº†å‡ æ¬¡è‚¾ä¸Šè…ºç´ é£™å‡ã€‚ä»¥ä¸‹æ˜¯æœ¬ç« çš„ä¸»è¦è¦ç‚¹ï¼š
- en: Systems of equations can be translated into a matrix equation. In addition to
    providing a compact representation, this allows for sophisticated linear algebra
    solutions to solving systems of equations.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹ç»„å¯ä»¥è½¬æ¢ä¸ºçŸ©é˜µæ–¹ç¨‹ã€‚é™¤äº†æä¾›ç´§å‡‘çš„è¡¨ç¤ºå¤–ï¼Œè¿™è¿˜å…è®¸å¯¹è§£æ–¹ç¨‹ç»„çš„çº¿æ€§ä»£æ•°è§£å†³æ–¹æ¡ˆè¿›è¡Œå¤æ‚çš„å¤„ç†ã€‚
- en: When working with matrix equations, remember that manipulations must be applied
    to both sides of the equation, and remember that matrix multiplication is noncommutative.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å¤„ç†çŸ©é˜µæ–¹ç¨‹æ—¶ï¼Œè¯·è®°ä½å¿…é¡»åŒæ—¶åº”ç”¨åˆ°æ–¹ç¨‹çš„ä¸¤è¾¹ï¼Œå¹¶ä¸”çŸ©é˜µä¹˜æ³•æ˜¯éäº¤æ¢çš„ã€‚
- en: Row reduction is a procedure in which the rows of matrix <math alttext="bold
    upper A"><mi>ğ€</mi></math> are scalar multiplied and added, until the matrix is
    linearly transformed into an upper-triangular matrix <math alttext="bold upper
    U"><mi>ğ”</mi></math> . The set of linear transformations can be stored in another
    matrix <math alttext="bold upper L Superscript negative 1"><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    that left-multiplies <math alttext="bold upper A"><mi>ğ€</mi></math> to produce
    the expression <math alttext="bold upper L Superscript negative 1 Baseline bold
    upper A equals bold upper U"><mrow><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ€</mi> <mo>=</mo> <mi>ğ”</mi></mrow></math> .
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¡Œçº¦ç®€æ˜¯ä¸€ç§è¿‡ç¨‹ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­çŸ©é˜µ<math alttext="bold upper A"><mi>ğ€</mi></math>çš„è¡Œè¿›è¡Œæ ‡é‡ä¹˜æ³•å’ŒåŠ æ³•æ“ä½œï¼Œç›´åˆ°çŸ©é˜µçº¿æ€§å˜æ¢ä¸ºä¸Šä¸‰è§’çŸ©é˜µ<math
    alttext="bold upper U"><mi>ğ”</mi></math>ã€‚çº¿æ€§å˜æ¢é›†åˆå¯ä»¥å­˜å‚¨åœ¨å¦ä¸€ä¸ªçŸ©é˜µ<math alttext="bold upper
    L Superscript negative 1"><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>ä¸­ï¼Œè¯¥çŸ©é˜µå·¦ä¹˜<math
    alttext="bold upper A"><mi>ğ€</mi></math>ä»¥ç”Ÿæˆè¡¨è¾¾å¼<math alttext="bold upper L Superscript
    negative 1 Baseline bold upper A equals bold upper U"><mrow><msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ€</mi> <mo>=</mo> <mi>ğ”</mi></mrow></math>ã€‚
- en: Row reduction has been used for centuries to solve systems of equations, including
    the matrix inverse, by hand. We still use row reduction, although computers take
    care of the arithmetic.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡ ä¸ªä¸–çºªä»¥æ¥ï¼Œè¡Œçº¦ç®€ä¸€ç›´è¢«ç”¨æ¥æ‰‹å·¥è§£å†³æ–¹ç¨‹ç»„ï¼ŒåŒ…æ‹¬çŸ©é˜µæ±‚é€†ã€‚å°½ç®¡è®¡ç®—æœºè´Ÿè´£ç®—æœ¯è¿ç®—ï¼Œæˆ‘ä»¬ä»ç„¶ä½¿ç”¨è¡Œçº¦ç®€ã€‚
- en: Row reduction is also used to implement LU decomposition. LU decomposition is
    unique under some constraints, which are incorporated into the `lu()` function
    in SciPy.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¡Œçº¦ç®€ä¹Ÿç”¨äºå®ç°LUåˆ†è§£ã€‚åœ¨æŸäº›çº¦æŸæ¡ä»¶ä¸‹ï¼ŒLUåˆ†è§£æ˜¯å”¯ä¸€çš„ï¼Œåœ¨SciPyçš„`lu()`å‡½æ•°ä¸­å·²ç»å®ç°äº†è¿™äº›çº¦æŸæ¡ä»¶ã€‚
- en: Code Exercises
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»£ç ç»ƒä¹ 
- en: Exercise 10-1\.
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  10-1\.
- en: LU decomposition can be computationally intensive, although it is more efficient
    than other decompositions such as QR. Interestingly, LU decomposition is often
    used as a benchmark to compare computation times between operating systems, hardware
    processors, computer languages (e.g., C versus Python versus MATLAB), or implementation
    algorithms. Out of curiousity, I tested how long it took Python and MATLAB to
    run LU decomposition on a thousand matrices of size <math alttext="100 times 100"><mrow><mn>100</mn>
    <mo>Ã—</mo> <mn>100</mn></mrow></math> . On my laptop, MATLAB took around 300 ms
    while Python took around 410 ms. Python on Google Colab took around 1,000 ms.
    Test how long this takes on your computer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: LUåˆ†è§£å¯èƒ½éœ€è¦å¤§é‡è®¡ç®—èµ„æºï¼Œå°½ç®¡å®ƒæ¯”QRç­‰åˆ†è§£æ–¹æ³•æ›´é«˜æ•ˆã€‚æœ‰è¶£çš„æ˜¯ï¼ŒLUåˆ†è§£ç»å¸¸è¢«ç”¨ä½œæ¯”è¾ƒæ“ä½œç³»ç»Ÿã€ç¡¬ä»¶å¤„ç†å™¨ã€è®¡ç®—æœºè¯­è¨€ï¼ˆä¾‹å¦‚Cä¸Pythonä¸MATLABä¹‹é—´ï¼‰ã€æˆ–è€…å®ç°ç®—æ³•çš„è®¡ç®—æ—¶é—´çš„åŸºå‡†ã€‚å‡ºäºå¥½å¥‡ï¼Œæˆ‘æµ‹è¯•äº†Pythonå’ŒMATLABåœ¨ä¸€åƒä¸ªå¤§å°ä¸º<math
    alttext="100 times 100"><mrow><mn>100</mn> <mo>Ã—</mo> <mn>100</mn></mrow></math>çš„çŸ©é˜µä¸Šè¿è¡ŒLUåˆ†è§£æ‰€éœ€çš„æ—¶é—´ã€‚åœ¨æˆ‘çš„ç¬”è®°æœ¬ç”µè„‘ä¸Šï¼ŒMATLABå¤§çº¦éœ€è¦300æ¯«ç§’ï¼Œè€ŒPythonå¤§çº¦éœ€è¦410æ¯«ç§’ã€‚åœ¨Google
    Colabä¸Šï¼ŒPythonéœ€è¦å¤§çº¦1,000æ¯«ç§’ã€‚è¯·æµ‹è¯•ä¸€ä¸‹åœ¨ä½ çš„ç”µè„‘ä¸Šéœ€è¦å¤šé•¿æ—¶é—´ã€‚
- en: Exercise 10-2\.
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  10-2\.
- en: Use the matrix-multiplication method to make a <math alttext="6 times 8"><mrow><mn>6</mn>
    <mo>Ã—</mo> <mn>8</mn></mrow></math> rank-3 matrix. Take its LU decomposition,
    and show the three matrices with their ranks in the title, as in [FigureÂ 10-2](#fig_10_2).
    Notice the ranks of the three matrices and that <math alttext="bold upper L"><mi>ğ‹</mi></math>
    has all 1s on the diagonal. Feel free to explore the ranks of matrices with other
    sizes and ranks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨çŸ©é˜µä¹˜æ³•æ–¹æ³•åˆ¶ä½œä¸€ä¸ª<math alttext="6 times 8"><mrow><mn>6</mn> <mo>Ã—</mo> <mn>8</mn></mrow></math>ç§©ä¸º3çš„çŸ©é˜µã€‚è¿›è¡Œå…¶LUåˆ†è§£ï¼Œå¹¶æ˜¾ç¤ºä¸‰ä¸ªå¸¦æœ‰å®ƒä»¬ç§©çš„çŸ©é˜µçš„æ ‡é¢˜ï¼Œå°±åƒ[å›¾
    10-2](#fig_10_2)ä¸­ä¸€æ ·ã€‚æ³¨æ„è¿™ä¸‰ä¸ªçŸ©é˜µçš„ç§©ä»¥åŠ<math alttext="bold upper L"><mi>ğ‹</mi></math>å¯¹è§’çº¿ä¸Šçš„å…¨ä¸º1ã€‚éšæ—¶æ¢ç´¢å…¶ä»–å¤§å°å’Œç§©çš„çŸ©é˜µçš„ç§©ã€‚
- en: '![LUdecom](assets/plad_1002.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![LUdecom](assets/plad_1002.png)'
- en: Figure 10-2\. Results of Exercise 10-2
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 10-2\. ç»ƒä¹  10-2 çš„ç»“æœ
- en: Exercise 10-3\.
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  10-3\.
- en: One application of LU decomposition is computing the determinant. Here are two
    properties of the determinant:^([4](ch10.xhtml#idm45733295824352)) the determinant
    of a triangular matrix is the product of the diagonals, and the determinant of
    a product matrix equals the product of the determinants (that is, <math alttext="d
    e t left-parenthesis bold upper A bold upper B right-parenthesis equals d e t
    left-parenthesis bold upper A right-parenthesis d e t left-parenthesis bold upper
    B right-parenthesis"><mrow><mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>ğ€</mi>
    <mi>ğ</mi> <mo>)</mo> <mo>=</mo> <mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>ğ€</mi>
    <mo>)</mo> <mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>ğ</mi> <mo>)</mo></mrow></math>
    ). Putting these two facts together, you can compute the determinant of a matrix
    as the product of the diagonals of <math alttext="bold upper L"><mi>ğ‹</mi></math>
    times the product of the diagonals of <math alttext="bold upper U"><mi>ğ”</mi></math>
    . On the other hand, because the diagonals of <math alttext="bold upper L"><mi>ğ‹</mi></math>
    are all 1 (when implemented in Python to ensure uniqueness of the decomposition),
    then the determinant of a matrix <math alttext="bold upper A"><mi>ğ€</mi></math>
    is simply the product of the diagonals of <math alttext="bold upper U"><mi>ğ”</mi></math>
    . Try it in Pythonâ€”and compare to the result of `np.linalg.det(A)`â€”multiple times
    with different random matrices, before reading the next paragraph.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: LU åˆ†è§£çš„ä¸€ä¸ªåº”ç”¨æ˜¯è®¡ç®—è¡Œåˆ—å¼ã€‚è¡Œåˆ—å¼çš„ä¸¤ä¸ªæ€§è´¨å¦‚ä¸‹ï¼šä¸‰è§’çŸ©é˜µçš„è¡Œåˆ—å¼æ˜¯å¯¹è§’çº¿å…ƒç´ çš„ä¹˜ç§¯ï¼Œä¹˜ç§¯çŸ©é˜µçš„è¡Œåˆ—å¼ç­‰äºè¡Œåˆ—å¼çš„ä¹˜ç§¯ï¼ˆå³ <math alttext="d
    e t left-parenthesis bold upper A bold upper B right-parenthesis equals d e t
    left-parenthesis bold upper A right-parenthesis d e t left-parenthesis bold upper
    B right-parenthesis"><mrow><mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>ğ€</mi>
    <mi>ğ</mi> <mo>)</mo> <mo>=</mo> <mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>ğ€</mi>
    <mo>)</mo> <mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>ğ</mi> <mo>)</mo></mrow></math>
    ï¼‰ã€‚å°†è¿™ä¸¤ä¸ªäº‹å®ç»“åˆèµ·æ¥ï¼Œä½ å¯ä»¥å°†çŸ©é˜µçš„è¡Œåˆ—å¼è®¡ç®—ä¸º <math alttext="bold upper L"><mi>ğ‹</mi></math> çš„å¯¹è§’çº¿ä¹˜ç§¯ä¹˜ä»¥
    <math alttext="bold upper U"><mi>ğ”</mi></math> çš„å¯¹è§’çº¿ä¹˜ç§¯ã€‚å¦ä¸€æ–¹é¢ï¼Œå› ä¸ºåœ¨ Python å®ç°ä¸­ç¡®ä¿åˆ†è§£çš„å”¯ä¸€æ€§ï¼Œ<math
    alttext="bold upper L"><mi>ğ‹</mi></math> çš„å¯¹è§’çº¿å…ƒç´ éƒ½æ˜¯ 1ï¼Œæ‰€ä»¥çŸ©é˜µ <math alttext="bold upper
    A"><mi>ğ€</mi></math> çš„è¡Œåˆ—å¼åªæ˜¯ <math alttext="bold upper U"><mi>ğ”</mi></math> å¯¹è§’çº¿å…ƒç´ çš„ä¹˜ç§¯ã€‚åœ¨å¤šæ¬¡ä½¿ç”¨ä¸åŒéšæœºçŸ©é˜µçš„æƒ…å†µä¸‹ï¼Œå°è¯•åœ¨
    Python ä¸­æ‰§è¡Œï¼Œå¹¶ä¸ `np.linalg.det(A)` çš„ç»“æœè¿›è¡Œæ¯”è¾ƒï¼Œç„¶åå†é˜…è¯»ä¸‹ä¸€æ®µã€‚
- en: Did you get the same result as Python? I assume you found that the determinants
    match in magnitude but that the signs would seemingly randomly differ. Why did
    that happen? It happened because I omitted the permutation matrix in the instructions.
    The determinant of a permutation matrix is +1 for an even number of row swaps
    and âˆ’1 for an odd number of row swaps. Now go back to your code and include the
    determinant of <math alttext="bold upper P"><mi>ğ</mi></math> in your computations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¾—åˆ°äº†ä¸ Python ç›¸åŒçš„ç»“æœå—ï¼Ÿæˆ‘å‡è®¾ä½ å‘ç°è¡Œåˆ—å¼çš„å¤§å°åŒ¹é…ï¼Œä½†ç¬¦å·ä¼¼ä¹ä¼šéšæœºä¸åŒã€‚ä¸ºä»€ä¹ˆä¼šå‘ç”Ÿè¿™ç§æƒ…å†µï¼Ÿè¿™æ˜¯å› ä¸ºæˆ‘åœ¨è¯´æ˜ä¸­çœç•¥äº†æ’åˆ—çŸ©é˜µã€‚ç½®æ¢çŸ©é˜µçš„è¡Œäº¤æ¢æ¬¡æ•°ä¸ºå¶æ•°æ—¶è¡Œåˆ—å¼ä¸º
    +1ï¼Œä¸ºå¥‡æ•°æ—¶ä¸º âˆ’1ã€‚ç°åœ¨å›åˆ°ä½ çš„ä»£ç ä¸­ï¼Œå¹¶åœ¨è®¡ç®—ä¸­åŒ…æ‹¬ <math alttext="bold upper P"><mi>ğ</mi></math> çš„è¡Œåˆ—å¼ã€‚
- en: Exercise 10-4\.
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  10-4\.
- en: 'Following the formula from the section [â€œLU Decompositionâ€](#LUdecomp), the
    inverse of a matrix can be expressed as:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®ç« èŠ‚ [â€œLU Decompositionâ€](#LUdecomp) ä¸­çš„å…¬å¼ï¼ŒçŸ©é˜µçš„é€†å¯ä»¥è¡¨ç¤ºä¸ºï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A 2nd Column equals
    bold upper P Superscript upper T Baseline bold upper L bold upper U 2nd Row 1st
    Column bold upper A Superscript negative 1 2nd Column equals left-parenthesis
    bold upper P Superscript upper T Baseline bold upper L bold upper U right-parenthesis
    Superscript negative 1 Baseline 3rd Row 1st Column bold upper A Superscript negative
    1 2nd Column equals bold upper U Superscript negative 1 Baseline bold upper L
    Superscript negative 1 Baseline bold upper P EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>ğ€</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>ğ</mi>
    <mtext>T</mtext></msup> <mi>ğ‹</mi><mi>ğ”</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ”</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>ğ</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A 2nd Column equals
    bold upper P Superscript upper T Baseline bold upper L bold upper U 2nd Row 1st
    Column bold upper A Superscript negative 1 2nd Column equals left-parenthesis
    bold upper P Superscript upper T Baseline bold upper L bold upper U right-parenthesis
    Superscript negative 1 Baseline 3rd Row 1st Column bold upper A Superscript negative
    1 2nd Column equals bold upper U Superscript negative 1 Baseline bold upper L
    Superscript negative 1 Baseline bold upper P EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>ğ€</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>ğ</mi> <mtext>T</mtext></msup> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>ğ</mi>
    <mtext>T</mtext></msup> <mi>ğ‹</mi><mi>ğ”</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ”</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ‹</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>ğ</mi></mrow></mtd></mtr></mtable></math>
- en: Implement that third equation directly using the output from `scipy.linalg.lu`
    on a <math alttext="4 times 4"><mrow><mn>4</mn> <mo>Ã—</mo> <mn>4</mn></mrow></math>
    random-numbers matrix. Is <math alttext="bold upper A bold upper A Superscript
    negative 1"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    the identity matrix? Sometimes it is and sometimes it isnâ€™t, depending on <math
    alttext="bold upper P"><mi>ğ</mi></math> . This discrepancy occurs because of
    what I wrote about the output of `scipy.linalg.lu`. Adjust the code so that it
    follows SciPyâ€™s convention instead of the math convention.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ä» `scipy.linalg.lu` è¾“å‡ºçš„ <math alttext="4 times 4"><mrow><mn>4</mn> <mo>Ã—</mo>
    <mn>4</mn></mrow></math> éšæœºæ•°çŸ©é˜µç›´æ¥å®ç°ç¬¬ä¸‰ä¸ªæ–¹ç¨‹ã€‚ <math alttext="bold upper A bold upper
    A Superscript negative 1"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    æ˜¯å•ä½çŸ©é˜µå—ï¼Ÿæœ‰æ—¶æ˜¯ï¼Œæœ‰æ—¶ä¸æ˜¯ï¼Œè¿™å–å†³äº <math alttext="bold upper P"><mi>ğ</mi></math> ã€‚ è¿™ç§å·®å¼‚æ˜¯ç”±äºæˆ‘åœ¨
    `scipy.linalg.lu` è¾“å‡ºçš„å†…å®¹æ‰€è¿°ã€‚ è°ƒæ•´ä»£ç ä»¥éµå¾ª SciPy çš„æƒ¯ä¾‹ï¼Œè€Œä¸æ˜¯æ•°å­¦æƒ¯ä¾‹ã€‚
- en: 'Here is the take-home message from this exercise: the absence of error messages
    does not necessarily mean your code is correct. Please sanity-check your mathematical
    code as much as possible.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç»ƒä¹ çš„è¦ç‚¹æ˜¯ï¼šç¼ºå°‘é”™è¯¯æ¶ˆæ¯å¹¶ä¸ä¸€å®šæ„å‘³ç€ä½ çš„ä»£ç æ˜¯æ­£ç¡®çš„ã€‚è¯·å°½å¯èƒ½å¤šåœ°æ£€æŸ¥ä½ çš„æ•°å­¦ä»£ç ã€‚
- en: Exercise 10-5\.
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  10-5\.
- en: For matrix <math alttext="bold upper A equals bold upper P bold upper L bold
    upper U"><mrow><mi>ğ€</mi> <mo>=</mo> <mi>ğ</mi> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math>
    (using Pythonâ€™s ordering of the permutation matrix), <math alttext="bold upper
    A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup>
    <mi>ğ€</mi></mrow></math> can be computed as <math alttext="bold upper U Superscript
    upper T Baseline bold upper L Superscript upper T Baseline bold upper L bold upper
    U"><mrow><msup><mi>ğ”</mi> <mtext>T</mtext></msup> <msup><mi>ğ‹</mi> <mtext>T</mtext></msup>
    <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math> â€”*without the permutation matrices*. Why is
    it possible to drop the permutation matrix? Answer the question and then confirm
    in Python using random matrices that <math alttext="bold upper A Superscript upper
    T Baseline bold upper A equals bold upper U Superscript upper T Baseline bold
    upper L Superscript upper T Baseline bold upper L bold upper U"><mrow><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi> <mo>=</mo> <msup><mi>ğ”</mi> <mtext>T</mtext></msup>
    <msup><mi>ğ‹</mi> <mtext>T</mtext></msup> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math> even
    when <math alttext="bold upper P not-equals bold upper I"><mrow><mi>ğ</mi> <mo>â‰ </mo>
    <mi>ğˆ</mi></mrow></math> .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºçŸ©é˜µ <math alttext="bold upper A equals bold upper P bold upper L bold upper
    U"><mrow><mi>ğ€</mi> <mo>=</mo> <mi>ğ</mi> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math>ï¼ˆä½¿ç”¨Pythonä¸­çš„æ’åˆ—çŸ©é˜µé¡ºåºï¼‰ï¼Œ<math
    alttext="bold upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>ğ€</mi>
    <mtext>T</mtext></msup> <mi>ğ€</mi></mrow></math> å¯ä»¥è®¡ç®—ä¸º <math alttext="bold upper
    U Superscript upper T Baseline bold upper L Superscript upper T Baseline bold
    upper L bold upper U"><mrow><msup><mi>ğ”</mi> <mtext>T</mtext></msup> <msup><mi>ğ‹</mi>
    <mtext>T</mtext></msup> <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math> â€”*æ²¡æœ‰æ’åˆ—çŸ©é˜µ*ã€‚ä¸ºä»€ä¹ˆå¯ä»¥çœç•¥æ’åˆ—çŸ©é˜µï¼Ÿå›ç­”è¿™ä¸ªé—®é¢˜ï¼Œç„¶åç”¨éšæœºçŸ©é˜µåœ¨Pythonä¸­ç¡®è®¤
    <math alttext="bold upper A Superscript upper T Baseline bold upper A equals bold
    upper U Superscript upper T Baseline bold upper L Superscript upper T Baseline
    bold upper L bold upper U"><mrow><msup><mi>ğ€</mi> <mtext>T</mtext></msup> <mi>ğ€</mi>
    <mo>=</mo> <msup><mi>ğ”</mi> <mtext>T</mtext></msup> <msup><mi>ğ‹</mi> <mtext>T</mtext></msup>
    <mi>ğ‹</mi> <mi>ğ”</mi></mrow></math> å³ä½¿ <math alttext="bold upper P not-equals
    bold upper I"><mrow><mi>ğ</mi> <mo>â‰ </mo> <mi>ğˆ</mi></mrow></math> ã€‚
- en: ^([1](ch10.xhtml#idm45733296963648-marker)) Of course you know that order matters,
    but empirical demonstrations help build intuition. And I want you to get in the
    habit of using Python as a tool to empirically confirm principles in mathematics.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#idm45733296963648-marker)) å½“ç„¶ï¼Œæ‚¨çŸ¥é“é¡ºåºå¾ˆé‡è¦ï¼Œä½†ç»éªŒæ¼”ç¤ºæœ‰åŠ©äºå»ºç«‹ç›´è§‰ã€‚æˆ‘å¸Œæœ›æ‚¨å…»æˆä½¿ç”¨Pythonä½œä¸ºå·¥å…·æ¥ç»éªŒæ€§åœ°ç¡®è®¤æ•°å­¦åŸç†çš„ä¹ æƒ¯ã€‚
- en: '^([2](ch10.xhtml#idm45733296685312-marker)) Spoiler alert: LU decomposition
    involves representing a matrix as the product of a lower-triangular and an upper-triangular
    matrix.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.xhtml#idm45733296685312-marker)) å‰§é€è­¦å‘Šï¼šLUåˆ†è§£æ¶‰åŠå°†çŸ©é˜µè¡¨ç¤ºä¸ºä¸‹ä¸‰è§’çŸ©é˜µå’Œä¸Šä¸‰è§’çŸ©é˜µçš„ä¹˜ç§¯ã€‚
- en: ^([3](ch10.xhtml#idm45733296566688-marker)) Please conjure into your imagination
    that *Matrix* meme with Morpheus proffering the red and blue pill, corresponding
    to new knowledge versus sticking to what you know.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.xhtml#idm45733296566688-marker)) è¯·æƒ³è±¡ä¸€ä¸‹*çŸ©é˜µ*çš„ç±³é»„æ–¯ç”¨çº¢è‰²å’Œè“è‰²è¯ä¸¸çš„è¡¨æƒ…åŒ…ï¼Œå¯¹åº”äºæ¥å—æ–°çŸ¥è¯†ä¸å›ºå®ˆç°æœ‰çŸ¥è¯†çš„é€‰æ‹©ã€‚
- en: ^([4](ch10.xhtml#idm45733295824352-marker)) These are among the myriad aspects
    of linear algbera that you would learn in a traditional linear algebra textbook;
    they are interesting in their own right but less directly relevant to data science.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.xhtml#idm45733295824352-marker)) è¿™äº›éƒ½æ˜¯ä¼ ç»Ÿçº¿æ€§ä»£æ•°æ•™æä¸­ä½ ä¼šå­¦åˆ°çš„ä¼—å¤šæ–¹é¢ï¼›å®ƒä»¬æœ¬èº«å¾ˆæœ‰è¶£ï¼Œä½†ä¸æ•°æ®ç§‘å­¦çš„ç›´æ¥ç›¸å…³æ€§è¾ƒå°ã€‚
