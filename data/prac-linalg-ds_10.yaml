- en: Chapter 10\. Row Reduction and LU Decomposition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 行简化与LU分解
- en: Now we move to LU decomposition. LU, like QR, is one of the computational backbones
    underlying data-science algorithms, including least squares model fitting and
    the matrix inverse. This chapter is, therefore, pivotal to your linear algebra
    education.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向LU分解。LU分解，像QR一样，是支持数据科学算法的计算基础之一，包括最小二乘模型拟合和矩阵求逆。因此，这一章对你的线性代数教育至关重要。
- en: The thing about LU decomposition is you cannot simply learn it immediately.
    Instead, you first need to learn about systems of equations, row reduction, and
    Gaussian elimination. And in the course of learning those topics, you’ll also
    learn about echelon matrices and permutation matrices. Oh yes, dear reader, this
    will be an exciting and action-packed chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LU分解的关键在于你不能简单地立刻学会它。相反，你首先需要学习关于方程组、行简化和高斯消元。在学习这些主题的过程中，你也会了解到梯形矩阵和置换矩阵。亲爱的读者，是的，这将是一个令人兴奋和充满活力的章节。
- en: Systems of Equations
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方程组
- en: To understand LU decomposition and its applications, you need to understand
    row reduction and Gaussian elimination. And to understand those topics, you need
    to understand how to manipulate equations, convert them into a matrix equation,
    and solve that matrix equation using row reduction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解LU分解及其应用，你需要了解行简化和高斯消元。而要理解这些主题，你需要了解如何操作方程、将其转换为矩阵方程，并使用行简化来解决该矩阵方程。
- en: 'Let’s start with a “system” of one equation:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个“系统”方程开始：
- en: <math alttext="2 x equals 8" display="block"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>8</mn></mrow></math>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 x equals 8" display="block"><mrow><mn>2</mn> <mi>x</mi> <mo>=</mo>
    <mn>8</mn></mrow></math>
- en: 'As I’m sure you learned in school, you can do various mathematical manipulations
    to the equation—as long as you do the same thing to both sides of the equation.
    That means that the following equation is not the same as the previous one, but
    they are related to each other by simple manipulations. More importantly, any
    solution to one equation is a solution to the other:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在学校中学到的那样，你可以对方程进行各种数学操作——只要你同时对方程的两边做同样的操作。这意味着下面的方程与前一个方程不同，但它们通过简单的操作相关联。更重要的是，任何一个方程的解也是另一个方程的解：
- en: <math alttext="5 left-parenthesis 2 x minus 3 right-parenthesis equals 5 left-parenthesis
    8 minus 3 right-parenthesis" display="block"><mrow><mn>5</mn> <mo>(</mo> <mn>2</mn>
    <mi>x</mi> <mo>-</mo> <mn>3</mn> <mo>)</mo> <mo>=</mo> <mn>5</mn> <mo>(</mo> <mn>8</mn>
    <mo>-</mo> <mn>3</mn> <mo>)</mo></mrow></math>
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="5 left-parenthesis 2 x minus 3 right-parenthesis equals 5 left-parenthesis
    8 minus 3 right-parenthesis" display="block"><mrow><mn>5</mn> <mo>(</mo> <mn>2</mn>
    <mi>x</mi> <mo>-</mo> <mn>3</mn> <mo>)</mo> <mo>=</mo> <mn>5</mn> <mo>(</mo> <mn>8</mn>
    <mo>-</mo> <mn>3</mn> <mo>)</mo></mrow></math>
- en: 'Now let’s move to a system of two equations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向一个包含两个方程的系统：
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 minus y
    2nd Row 1st Column y 2nd Column equals x slash 2 plus 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 minus y
    2nd Row 1st Column y 2nd Column equals x slash 2 plus 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math>
- en: In this system of equations, it is impossible to solve for unique values of
    *x* and *y* from either of those equations alone. Instead, you need to consider
    both equations simultaneously to derive the solution. If you try to solve that
    system now, you would probably take the strategy of substituting *y* in the first
    equation with the right-hand side of the second equation. After solving for *x*
    in the first equation, you plug that value into the second equation to solve for
    *y*. This strategy is similar to (though not as efficient as) back substitution,
    which I’ll define later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程组中，从任何一个方程中都不可能单独求解出*x*和*y*的唯一值。相反，你需要同时考虑两个方程来推导解。如果你现在尝试解决这个系统，你可能会采取用第二个方程的右侧值代替第一个方程中的*y*的策略。在第一个方程中解出*x*后，将该值代入第二个方程中解出*y*。这种策略类似于（尽管不如）后代换，稍后我会定义它。
- en: 'An important feature of a system of equations is that you can add or subtract
    individual equations to each other. In the following equations, I’ve added two
    times the second equation to the first, and subtracted the first original equation
    from the second (parentheses added for clarity):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 方程组的一个重要特点是你可以将各个方程相加或相减。在下面的方程中，我将第二个方程乘以2加到第一个方程中，并从第二个方程中减去第一个原始方程（为了清晰起见添加了括号）：
- en: <math alttext="StartLayout 1st Row 1st Column x plus left-parenthesis 2 y right-parenthesis
    2nd Column equals 4 minus y plus left-parenthesis x plus 4 right-parenthesis 2nd
    Row 1st Column y minus left-parenthesis x right-parenthesis 2nd Column equals
    x slash 2 plus 2 minus left-parenthesis 4 minus y right-parenthesis EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi>
    <mo>+</mo> <mo>(</mo> <mn>2</mn> <mi>y</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi> <mo>+</mo> <mo>(</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>y</mi> <mo>-</mo>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo> <mn>2</mn> <mo>-</mo> <mo>(</mo> <mn>4</mn>
    <mo>-</mo> <mi>y</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x plus left-parenthesis 2 y right-parenthesis
    2nd Column equals 4 minus y plus left-parenthesis x plus 4 right-parenthesis 2nd
    Row 1st Column y minus left-parenthesis x right-parenthesis 2nd Column equals
    x slash 2 plus 2 minus left-parenthesis 4 minus y right-parenthesis EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi>
    <mo>+</mo> <mo>(</mo> <mn>2</mn> <mi>y</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi> <mo>+</mo> <mo>(</mo> <mi>x</mi> <mo>+</mo> <mn>4</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>y</mi> <mo>-</mo>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo> <mn>2</mn> <mo>-</mo> <mo>(</mo> <mn>4</mn>
    <mo>-</mo> <mi>y</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
- en: 'I will let you work through the arithmetic, but the upshot is that *x* drops
    out of the first equation while *y* drops out of the second equation. That makes
    the solution much easier to calculate (*x* = 4/3, *y* = 8/3). Here’s the important
    point: scalar multiplying equations and adding them to other equations made the
    solution to the system easier to find. Again, the modulated and original systems
    are not the same equations, but their solutions are the same because the two systems
    are linked by a series of linear operations.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我会让你进行算术运算，但要点是*x*在第一个方程中消失，而*y*在第二个方程中消失。这使得解的计算变得更容易（*x* = 4/3，*y* = 8/3）。这里的重要一点是：对方程进行标量乘法并将它们相加使得系统的解更容易找到。再次强调，调整后和原始系统并不是相同的方程，但它们的解是相同的，因为这两个系统通过一系列线性操作相连接。
- en: This is the background knowledge you need to learn how to solve systems of equations
    using linear algebra. But before learning that approach, you need to learn how
    to represet a system of equations using matrices and vectors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要学习如何使用线性代数解方程组之前的背景知识。但在学习该方法之前，你需要学习如何使用矩阵和向量表示方程组。
- en: Converting Equations into Matrices
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将方程转化为矩阵
- en: Converting systems of equations into a matrix-vector equation is used to solve
    systems of equations, and it’s used to set up the formula for the general linear
    model in statistics. Fortunately, translating equations into matrices is conceptually
    simple, and involves two steps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将方程组转化为矩阵-向量方程用于解决方程组，并用于建立统计学中一般线性模型的公式。幸运的是，将方程转化为矩阵在概念上很简单，并包括两个步骤。
- en: 'First, organize the equations so that the constants are on the right-hand side
    of the equations. The *constants* are the numbers that are unattached to the variables
    (sometimes called *intercepts* or *offsets*). The variables and their multiplying
    coefficients are on the left-hand side of the equation, in the same order (e.g.,
    all equations should have the *x* term first, then the *y* term, and so on). The
    following equations form the system of equations we’ve been working with, in the
    proper organization:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，组织方程使得常数位于方程的右侧。*常数*是与变量无关的数字（有时称为*截距*或*偏移量*）。变量及其乘法系数按照相同的顺序位于方程的左侧（例如，所有方程应先有*x*项，然后是*y*项，依此类推）。以下方程形成我们一直在处理的方程组，并按正确的方式组织：
- en: <math alttext="StartLayout 1st Row 1st Column x plus y 2nd Column equals 4 2nd
    Row 1st Column negative x slash 2 plus y 2nd Column equals 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi> <mo>+</mo>
    <mi>y</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mo>-</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn>
    <mo>+</mo> <mi>y</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x plus y 2nd Column equals 4 2nd
    Row 1st Column negative x slash 2 plus y 2nd Column equals 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi> <mo>+</mo>
    <mi>y</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mo>-</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn>
    <mo>+</mo> <mi>y</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
- en: 'Second, separate the coefficients (the numbers multiplying the variables; variables
    that are missing from an equation have a coefficient of zero) into a matrix with
    one row per equation. The variables are placed into a column vector that right-multiplies
    the coefficients matrix. And the constants are placed into a column vector on
    the right-hand side of the equation. Our example system has a matrix equation
    that looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，将系数（乘以变量的数字；缺少方程的变量具有零系数）分成一个矩阵，每个方程一行。变量被放置到右乘系数矩阵的列向量中。常数则放置在方程的右侧的列向量中。我们的示例系统有一个矩阵方程，看起来像这样：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column negative 1 slash 2 2nd Column 1 EndMatrix StartBinomialOrMatrix x Choose
    y EndBinomialOrMatrix equals StartBinomialOrMatrix 4 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column negative 1 slash 2 2nd Column 1 EndMatrix StartBinomialOrMatrix x Choose
    y EndBinomialOrMatrix equals StartBinomialOrMatrix 4 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: And voilà! You’ve converted a system of equations into one matrix equation.
    We can refer to this equation as <math alttext="bold upper A bold x equals bold
    b"><mrow><mi>𝐀</mi> <mi>𝐱</mi> <mo>=</mo> <mi>𝐛</mi></mrow></math> , where <math
    alttext="bold upper A"><mi>𝐀</mi></math> is the matrix of coefficients, <math
    alttext="bold x"><mi>𝐱</mi></math> is a vector of unknown variables to solve for
    (in this case, <math alttext="bold x"><mi>𝐱</mi></math> is the vector comprising
    [*x* *y*]), and <math alttext="bold b"><mi>𝐛</mi></math> is a vector of constants.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后！你已经将方程组转化为一个矩阵方程。我们可以称这个方程为<math alttext="bold upper A bold x equals bold
    b"><mrow><mi>𝐀</mi> <mi>𝐱</mi> <mo>=</mo> <mi>𝐛</mi></mrow></math>，其中<math alttext="bold
    upper A"><mi>𝐀</mi></math>是系数矩阵，<math alttext="bold x"><mi>𝐱</mi></math>是待求的未知变量向量（在本例中，<math
    alttext="bold x"><mi>𝐱</mi></math>是包含[*x* *y*]的向量），而<math alttext="bold b"><mi>𝐛</mi></math>是常数向量。
- en: Please take a moment to make sure you understand how the matrix equation maps
    onto the system of equations. In particular, work through the matrix-vector multiplication
    to demonstrate that it equals the original system of equations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请花一点时间确保你理解矩阵方程是如何映射到方程组的。特别是通过矩阵-向量乘法来演示它等于原始方程组。
- en: Working with Matrix Equations
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用矩阵方程
- en: 'You can manipulate matrix equations just like normal equations, including adding,
    multiplying, transposing, etc., as long as the manipulations are valid (e.g.,
    matrix sizes match for addition) and all manipulations affect both sides of the
    equation. For example, the following progression of equations is valid:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理普通方程一样操作矩阵方程，包括加法、乘法、转置等，只要操作是有效的（例如，加法的矩阵尺寸匹配），并且所有操作影响方程的两边。例如，以下方程的进展是有效的：
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold x 2nd Column
    equals bold b 2nd Row 1st Column bold v plus bold upper A bold x 2nd Column equals
    bold v plus bold b 3rd Row 1st Column left-parenthesis bold v plus bold upper
    A bold x right-parenthesis Superscript upper T 2nd Column equals left-parenthesis
    bold v plus bold b right-parenthesis Superscript upper T EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐱</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐛</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>𝐯</mi> <mo>+</mo> <mi>𝐀</mi> <mi>𝐱</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐯</mi> <mo>+</mo> <mi>𝐛</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mrow><mo>(</mo><mi>𝐯</mi><mo>+</mo><mi>𝐀</mi><mi>𝐱</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><mi>𝐯</mi><mo>+</mo><mi>𝐛</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold x 2nd Column
    equals bold b 2nd Row 1st Column bold v plus bold upper A bold x 2nd Column equals
    bold v plus bold b 3rd Row 1st Column left-parenthesis bold v plus bold upper
    A bold x right-parenthesis Superscript upper T 2nd Column equals left-parenthesis
    bold v plus bold b right-parenthesis Superscript upper T EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐱</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐛</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>𝐯</mi> <mo>+</mo> <mi>𝐀</mi> <mi>𝐱</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐯</mi> <mo>+</mo> <mi>𝐛</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mrow><mo>(</mo><mi>𝐯</mi><mo>+</mo><mi>𝐀</mi><mi>𝐱</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><mi>𝐯</mi><mo>+</mo><mi>𝐛</mi><mo>)</mo></mrow>
    <mtext>T</mtext></msup></mrow></mtd></mtr></mtable></math>
- en: The main difference between working with matrix equations versus scalar equations
    is that because matrix multiplication is side-dependent, you must multiply matrices
    in the same way on both sides of the equation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵方程与标量方程的主要区别在于，由于矩阵乘法是侧向依赖的，你必须在方程的两边以相同的方式进行矩阵乘法。
- en: 'For example, the following progression of equations is valid:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下方程的进展是有效的：
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper X 2nd
    Column equals bold upper B 2nd Row 1st Column bold upper C bold upper A bold upper
    X 2nd Column equals bold upper C bold upper B EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐗</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐁</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>𝐂</mi> <mi>𝐀</mi> <mi>𝐗</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>𝐂</mi> <mi>𝐁</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper X 2nd
    Column equals bold upper B 2nd Row 1st Column bold upper C bold upper A bold upper
    X 2nd Column equals bold upper C bold upper B EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐗</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐁</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>𝐂</mi> <mi>𝐀</mi> <mi>𝐗</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>𝐂</mi> <mi>𝐁</mi></mrow></mtd></mtr></mtable></math>
- en: 'Notice that <math alttext="bold upper C"><mi>𝐂</mi></math> premultiplies both
    sides of the equation. In contrast, the following progression is **not** valid:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，<math alttext="bold upper C"><mi>𝐂</mi></math> 在方程式两边都是左乘的。相比之下，以下推进是**无效**的：
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper X 2nd
    Column equals bold upper B 2nd Row 1st Column bold upper A bold upper X bold upper
    C 2nd Column equals bold upper C bold upper B EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐗</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐁</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐗</mi> <mi>𝐂</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>𝐂</mi> <mi>𝐁</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold upper X 2nd
    Column equals bold upper B 2nd Row 1st Column bold upper A bold upper X bold upper
    C 2nd Column equals bold upper C bold upper B EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐗</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐁</mi></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐗</mi> <mi>𝐂</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>𝐂</mi> <mi>𝐁</mi></mrow></mtd></mtr></mtable></math>
- en: The problem here is that <math alttext="bold upper C"><mi>𝐂</mi></math> *post*multiplies
    in the left-hand side but *pre*multiplies in the right-hand side. To be sure,
    there will be a few exceptional cases where that equation is valid (e.g., if <math
    alttext="bold upper C"><mi>𝐂</mi></math> is the identity or zeros matrix), but
    in general that progression is not valid.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于数学公式 <math alttext="bold upper C"><mi>𝐂</mi></math> 在左边乘以后面的部分，但在右边乘以前面的部分。可以肯定地说，有几种例外情况，使得该方程式有效（例如，如果
    <math alttext="bold upper C"><mi>𝐂</mi></math> 是单位矩阵或零矩阵），但一般情况下这种推进是无效的。
- en: Let’s see an example in Python. We will solve for the unknown matrix <math alttext="bold
    upper X"><mi>𝐗</mi></math> in the equation <math alttext="bold upper A bold upper
    X equals bold upper B"><mrow><mi>𝐀</mi> <mi>𝐗</mi> <mo>=</mo> <mi>𝐁</mi></mrow></math>
    . The following code generates <math alttext="bold upper A"><mi>𝐀</mi></math>
    and <math alttext="bold upper B"><mi>𝐁</mi></math> from random numbers. You already
    know that we can solve for <math alttext="bold upper X"><mi>𝐗</mi></math> by using
    <math alttext="bold upper A Superscript negative 1"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    . The question is whether the order of multiplication matters.^([1](ch10.xhtml#idm45733296963648))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个Python的例子。我们将解出未知矩阵 <math alttext="bold upper X"><mi>𝐗</mi></math> 在方程
    <math alttext="bold upper A bold upper X equals bold upper B"><mrow><mi>𝐀</mi>
    <mi>𝐗</mi> <mo>=</mo> <mi>𝐁</mi></mrow></math> 中。以下代码生成 <math alttext="bold upper
    A"><mi>𝐀</mi></math> 和 <math alttext="bold upper B"><mi>𝐁</mi></math> 的随机数。你已经知道我们可以通过
    <math alttext="bold upper A Superscript negative 1"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    来解出 <math alttext="bold upper X"><mi>𝐗</mi></math> 。问题是乘法的顺序是否重要。^([1](ch10.xhtml#idm45733296963648))
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If matrix multiplication were commutative (meaning that the order doesn’t matter),
    then `res1` and `res2` should both equal the zeros matrix. Let’s see:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵乘法是可交换的（意味着顺序不重要），那么 `res1` 和 `res2` 都应该等于零矩阵。让我们看看：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you know how to express a system of equations using one matrix equation.
    I’m going to get back to this in a few sections; first, I need to teach you about
    row reduction and the echelon form of a matrix.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何用一个矩阵方程表示一个方程组。在接下来的几节中，我将回到这个问题；首先，我需要教你关于行列式变换和矩阵的阶梯形式。
- en: Row Reduction
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行列式变换
- en: Row reduction is a topic that gets a lot of attention in traditional linear
    algebra, because it is the time-honored way to solve systems of equations *by
    hand*. I seriously doubt you’ll solve any systems of equations by hand in your
    career as a data scientist. But row reduction is useful to know about, and it
    leads directly to LU decomposition, which actually is used in applied linear algebra.
    So let’s begin.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式变换是传统线性代数中备受关注的话题，因为它是通过手工解决方程组的古老方式。我确实怀疑在作为数据科学家的职业生涯中你会手工解决任何方程组。但了解行列式变换是有用的，并且直接导致LU分解，而LU分解实际上被应用在应用线性代数中。所以让我们开始吧。
- en: '*Row reduction* means iteratively applying two operations—scalar multiplication
    and addition—to rows of a matrix. Row reduction relies on the same principle as
    adding equations to other equations within a system.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*行列式变换* 意味着反复应用两种操作——行的标量乘法和加法——到矩阵的行上。行列式变换依赖于在系统中向其他方程式添加方程式的相同原理。'
- en: 'Memorize this statement: *The goal of row reduction is to transform a dense
    matrix into an upper-triangular matrix.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个声明：*行列式变换的目标是将密集矩阵转换为上三角矩阵*。
- en: 'Let’s start with a simple example. In the following dense matrix, we add the
    first row to the second row, which knocks out the −2\. And with that, we’ve transformed
    our dense matrix into an upper-triangular matrix:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。在下面的密集矩阵中，我们将第一行加到第二行，这消除了-2。有了这个变化，我们将密集矩阵转换成了上三角矩阵：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row
    1st Column negative 2 2nd Column 2 EndMatrix StartLayout 1st Row  right-arrow
    Overscript upper R 1 plus upper R 2 Endscripts EndLayout Start 2 By 2 Matrix 1st
    Row 1st Column 2 2nd Column 3 2nd Row 1st Column 0 2nd Column 5 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd>
    <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>→</mo>
    <mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row
    1st Column negative 2 2nd Column 2 EndMatrix StartLayout 1st Row  right-arrow
    Overscript upper R 1 plus upper R 2 Endscripts EndLayout Start 2 By 2 Matrix 1st
    Row 1st Column 2 2nd Column 3 2nd Row 1st Column 0 2nd Column 5 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd>
    <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>→</mo>
    <mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: The upper-triangular matrix that results from row reduction is called the *echelon
    form* of the matrix.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式变换后的上三角矩阵被称为矩阵的*阶梯形式*。
- en: Formally, a matrix is in echelon form if (1) the leftmost nonzero number in
    a row (which is called the *pivot*) is to the right of the pivot of rows above,
    and (2) any rows of all zeros are below rows containing nonzeros.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，如果一个矩阵满足以下条件，它就是阶梯形式：（1）每一行的最左边非零数（称为*主元*）在上面行的主元右边，（2）所有零行在非零行的下面。
- en: 'Similar to manipulating equations in a system, the matrix *after* row reduction
    is different from the matrix *before* row reduction. But the two matrices are
    linked by a linear transform. And because linear transforms can be represented
    by matrices, we can use matrix multiplication to express row reduction:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于在系统中操作方程，行变换后的矩阵与行变换前的矩阵不同。但是这两个矩阵通过线性变换相连。由于线性变换可以用矩阵表示，我们可以使用矩阵乘法来表示行变换：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 0 2nd Row
    1st Column 1 2nd Column 1 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 2 2nd
    Column 3 2nd Row 1st Column negative 2 2nd Column 2 EndMatrix equals Start 2 By
    2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row 1st Column 0 2nd Column 5 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 0 2nd Row
    1st Column 1 2nd Column 1 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 2 2nd
    Column 3 2nd Row 1st Column negative 2 2nd Column 2 EndMatrix equals Start 2 By
    2 Matrix 1st Row 1st Column 2 2nd Column 3 2nd Row 1st Column 0 2nd Column 5 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'I will call that matrix <math alttext="bold upper L Superscript negative 1"><msup><mi>𝐋</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> for reasons that will become clear
    when I introduce LU decomposition.^([2](ch10.xhtml#idm45733296685312)) Thus, in
    the expression <math alttext="left-parenthesis bold upper L Superscript negative
    1 Baseline bold upper A equals bold upper U right-parenthesis"><mrow><mo>(</mo>
    <msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>𝐀</mi> <mo>=</mo>
    <mi>𝐔</mi> <mo>)</mo></mrow></math> , <math alttext="bold upper L Superscript
    negative 1"><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> is
    the linear transformation that keeps track of the manipulations we’ve implemented
    through row reduction. For now, you don’t need to focus on <math alttext="bold
    upper L Superscript negative 1"><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    —in fact, it’s often ignored during Gaussian elimination. But the key point (slightly
    expanded from an earlier claim) is this: *row reduction involves transforming
    a matrix into an upper-triangular matrix via row manipulations, which can be implemented
    as premultiplication by a transformation matrix.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我将称那个矩阵为<math alttext="bold upper L Superscript negative 1"><msup><mi>𝐋</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>，原因将在我介绍LU分解时变得清楚。因此，在表达式<math
    alttext="left-parenthesis bold upper L Superscript negative 1 Baseline bold upper
    A equals bold upper U right-parenthesis"><mrow><mo>(</mo> <msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐀</mi> <mo>=</mo> <mi>𝐔</mi> <mo>)</mo></mrow></math> 中，<math alttext="bold
    upper L Superscript negative 1"><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    是线性变换，通过行变换实现的操作的变换矩阵。现在你不需要专注于<math alttext="bold upper L Superscript negative
    1"><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> ——事实上，在高斯消元过程中它经常被忽略。但关键点（稍微扩展了前面的说法）是：*行变换涉及通过行操作将矩阵转换为上三角矩阵，可以通过变换矩阵的前乘来实现。*
- en: 'Here’s another example of a <math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo>
    <mn>3</mn></mrow></math> matrix. This matrix requires two steps to transform into
    its echelon form:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子，一个<math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>矩阵。这个矩阵需要两步变换成它的梯形形式：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    2 2nd Row 1st Column negative 1 2nd Column 3 3rd Column 0 3rd Row 1st Column 2
    2nd Column 4 3rd Column negative 3 EndMatrix StartLayout 1st Row  right-arrow
    Overscript minus 2 upper R 1 plus upper R 3 Endscripts EndLayout Start 3 By 3
    Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column 2 2nd Row 1st Column negative
    1 2nd Column 3 3rd Column 0 3rd Row 1st Column 0 2nd Column 0 3rd Column negative
    7 EndMatrix StartLayout 1st Row  right-arrow Overscript upper R 1 plus upper R
    2 Endscripts EndLayout Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd
    Column 2 2nd Row 1st Column 0 2nd Column 5 3rd Column 2 3rd Row 1st Column 0 2nd
    Column 0 3rd Column negative 7 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>4</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>→</mo>
    <mrow><mo>-</mo><mn>2</mn><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>3</mn></msub></mrow></mover></mrow></mtd></mtr></mtable> <mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>7</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>→</mo>
    <mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>7</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column
    2 2nd Row 1st Column negative 1 2nd Column 3 3rd Column 0 3rd Row 1st Column 2
    2nd Column 4 3rd Column negative 3 EndMatrix StartLayout 1st Row  right-arrow
    Overscript minus 2 upper R 1 plus upper R 3 Endscripts EndLayout Start 3 By 3
    Matrix 1st Row 1st Column 1 2nd Column 2 3rd Column 2 2nd Row 1st Column negative
    1 2nd Column 3 3rd Column 0 3rd Row 1st Column 0 2nd Column 0 3rd Column negative
    7 EndMatrix StartLayout 1st Row  right-arrow Overscript upper R 1 plus upper R
    2 Endscripts EndLayout Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 2 3rd
    Column 2 2nd Row 1st Column 0 2nd Column 5 3rd Column 2 3rd Row 1st Column 0 2nd
    Column 0 3rd Column negative 7 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>4</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>→</mo>
    <mrow><mo>-</mo><mn>2</mn><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>3</mn></msub></mrow></mover></mrow></mtd></mtr></mtable> <mfenced close="]"
    open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>3</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>7</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>→</mo>
    <mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>0</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>7</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: Row reduction is tedious (see [“Is Row Reduction Always So Easy?”](#row-reduction)).
    Surely there must be a Python function to do it for us! Well, there is and there
    isn’t. There is no Python function that returns an echelon form like what I created
    in the two previous examples. The reason is that the echelon form of a matrix
    is not unique. For example, in the previous <math alttext="3 times 3"><mrow><mn>3</mn>
    <mo>×</mo> <mn>3</mn></mrow></math> matrix, you could multiply the second row
    by 2 to give a row vector of [0 10 4]. That creates a perfectly valid—but different—echelon
    form of the same original matrix. Indeed, there is an infinite number of echelon
    matrices associated with that matrix.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 行变换是乏味的（见[“行变换总是这么简单吗？”](#row-reduction)）。肯定有一个Python函数可以帮我们做这件事！有也有没有。没有一个Python函数能返回像我在前面两个例子中创建的梯形形式。原因是矩阵的梯形形式不是唯一的。例如，在前面的<math
    alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>矩阵中，你可以将第二行乘以2得到一个行向量[0
    10 4]。这创建了一个完全有效但不同的原始矩阵的梯形形式。实际上，与该矩阵相关联的梯形矩阵有无穷多个。
- en: That said, two echelon forms of a matrix are preferred over the infinite possible
    echelon forms. Those two forms are unique given some constraints and are called
    the reduced row echelon form and <math alttext="bold upper U"><mi>𝐔</mi></math>
    from LU decomposition. I will introduce both later; first, it’s time to learn
    how to use row reduction to solve systems of equations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，矩阵的两个梯形形式优于无限可能的梯形形式。这两种形式在给定一些约束条件下是唯一的，称为简化行梯形形式和<math alttext="bold
    upper U"><mi>𝐔</mi></math>来自LU分解。稍后我将介绍这两者；首先，现在是时候学习如何使用行变换来解方程组了。
- en: Gaussian Elimination
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高斯消元
- en: At this point in the book, you know how to solve matrix equations using the
    matrix inverse. What if I told you that you could solve a matrix equation without
    inverting any matrices?^([3](ch10.xhtml#idm45733296566688))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，你已经学会如何使用矩阵逆来解决矩阵方程。如果我告诉你，你可以在不求逆任何矩阵的情况下解决矩阵方程，你会怎么想？^([3](ch10.xhtml#idm45733296566688))
- en: This technique is called *Gaussian elimination*. Despite its name, the algorithm
    was actually developed by Chinese mathematicians nearly two thousand years before
    Gauss and then rediscovered by Newton hundreds of years before Gauss. But Gauss
    made important contributions to the method, including the techniques that modern
    computers implement.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为*高斯消元法*。尽管其名称如此，这个算法实际上是由中国数学家在高斯之前近两千年发展出来的，然后由牛顿在高斯之前数百年重新发现。但是高斯在该方法中作出了重要贡献，包括现代计算机实现的技术。
- en: 'Gaussian elimination is simple: augment the matrix of coefficients by the vector
    of constants, row reduce to echelon form, and then use back substitution to solve
    for each variable in turn.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯消元法很简单：将系数矩阵增广为常数向量，行约化为梯形形式，然后使用回代法依次求解每个变量。
- en: 'Let’s start with the system of two equations that we solved earlier:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们之前解决的两个方程组开始：
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 minus y
    2nd Row 1st Column y 2nd Column equals x slash 2 plus 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 minus y
    2nd Row 1st Column y 2nd Column equals x slash 2 plus 2 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>-</mo> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>/</mo> <mn>2</mn> <mo>+</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math>
- en: 'The first step is to convert this system of equations into a matrix equation.
    We’ve already worked through this step; that equation is printed here as a reminder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将这个方程组转换为一个矩阵方程。我们已经完成了这一步；这个方程如下所示：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column negative 1 slash 2 2nd Column 1 EndMatrix StartBinomialOrMatrix x Choose
    y EndBinomialOrMatrix equals StartBinomialOrMatrix 4 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column negative 1 slash 2 2nd Column 1 EndMatrix StartBinomialOrMatrix x Choose
    y EndBinomialOrMatrix equals StartBinomialOrMatrix 4 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>1</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Next, we augment the coefficients matrix with the constants vector:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将系数矩阵与常数向量进行增广：
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column negative 1 slash 2 2nd Column 1 3rd Column 2 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column negative 1 slash 2 2nd Column 1 3rd Column 2 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></math>
- en: 'Then we row reduce that augmented matrix. Note that the column vector of constants
    will change during row reduction:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对增广矩阵进行行约化。注意在行约化过程中，常数列向量将发生变化：
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column negative 1 slash 2 2nd Column 1 3rd Column 2 EndMatrix StartLayout
    1st Row  right-arrow Overscript 1 slash 2 upper R 1 plus upper R 2 Endscripts
    EndLayout Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column 4 2nd
    Row 1st Column 0 2nd Column 3 slash 2 3rd Column 4 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mtable><mtr><mtd><mrow><mover><mo>→</mo> <mrow><mn>1</mn><mo>/</mo><mn>2</mn><msub><mi>R</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>3</mn> <mo>/</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column negative 1 slash 2 2nd Column 1 3rd Column 2 EndMatrix StartLayout
    1st Row  right-arrow Overscript 1 slash 2 upper R 1 plus upper R 2 Endscripts
    EndLayout Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column 4 2nd
    Row 1st Column 0 2nd Column 3 slash 2 3rd Column 4 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>1</mn>
    <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mtable><mtr><mtd><mrow><mover><mo>→</mo> <mrow><mn>1</mn><mo>/</mo><mn>2</mn><msub><mi>R</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi> <mn>2</mn></msub></mrow></mover></mrow></mtd></mtr></mtable>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>3</mn> <mo>/</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Once we have the matrix in its echelon form, we translate the augmented matrix
    back into a system of equations. That looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将矩阵转换为其梯形形式，我们将增广矩阵转换回方程组。看起来是这样的：
- en: <math alttext="StartLayout 1st Row 1st Column x plus y 2nd Column equals 4 2nd
    Row 1st Column 3 slash 2 y 2nd Column equals 4 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi> <mo>+</mo>
    <mphantom><mn>3</mn> <mo>/</mo> <mn>2</mn></mphantom> <mi>y</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mn>3</mn> <mo>/</mo> <mn>2</mn> <mi>y</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x plus y 2nd Column equals 4 2nd
    Row 1st Column 3 slash 2 y 2nd Column equals 4 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>x</mi> <mo>+</mo>
    <mphantom><mn>3</mn> <mo>/</mo> <mn>2</mn></mphantom> <mi>y</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mn>3</mn> <mo>/</mo> <mn>2</mn> <mi>y</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>4</mn></mrow></mtd></mtr></mtable></math>
- en: Gaussian elimination via row reduction removed the *x* term in the second equation,
    which means that solving for *y* merely involves some arithmetic. Once you solve
    for *y* = 8/3, plug that value into *y* in the first equation and solve for *x*.
    This procedure is called *back substitution*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过行约化的高斯消元法移除了第二个方程中的*x*项，这意味着解*y*仅涉及一些算术运算。一旦解出*y* = 8/3，将该值代入第一个方程中的*y*，并解出*x*。这个过程被称为*回代法*。
- en: In the previous section, I wrote that Python does not have a function to compute
    the echelon form of a matrix because it is not unique. And then I wrote that there
    is one unique echelon matrix, called the *reduced row echelon form* and often
    abbreviated RREF, which Python will compute. Keep reading to learn more…
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我写道Python没有函数来计算矩阵的梯形形式，因为它不是唯一的。然后我写道有一个唯一的梯形矩阵，称为*简化行阶梯形式*，通常缩写为RREF，Python将会计算。继续阅读以了解更多信息…
- en: Gauss-Jordan Elimination
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高斯-约当消元
- en: 'Let’s keep row reducing our example matrix with the goal of turning all the
    *pivots*—the leftmost nonzero numbers in each row—into 1s. Once you have the echelon
    matrix, you simply divide each row by its pivot. In this example, the first row
    already has a 1 in the leftmost position, so we just need to adjust the second
    row. That gives us the following matrix:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续对我们的示例矩阵进行行约化，目标是将所有*主元*——每行中最左侧的非零数——转换为1。一旦得到梯形矩阵，你只需将每行除以其主元。在这个例子中，第一行已经有了左侧位置的1，所以我们只需要调整第二行。这给出了以下矩阵：
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mn>8</mn> <mo>/</mo>
    <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix" display="block"><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mn>8</mn> <mo>/</mo>
    <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></math>
- en: 'And now for the trick: we continue row reducing *upward* to eliminate all the
    elements above each pivot. In other words, we want an echelon matrix in which
    each pivot is 1 and it’s the only nonzero number in its column.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在讲解一个窍门：我们继续向*上*行约化，以消除每个主元上方的所有元素。换句话说，我们希望得到一个梯形矩阵，其中每个主元为1，且是其所在列的唯一非零数。
- en: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix StartLayout
    1st Row  right-arrow Overscript minus upper R 2 plus upper R 1 Endscripts EndLayout
    Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column 4 slash 3 2nd
    Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mn>8</mn> <mo>/</mo>
    <mn>3</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>→</mo>
    <mrow><mo>-</mo><msub><mi>R</mi> <mn>2</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>1</mn></msub></mrow></mover></mrow></mtd></mtr></mtable> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mrow><mn>4</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>8</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 3rd Column
    4 2nd Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix StartLayout
    1st Row  right-arrow Overscript minus upper R 2 plus upper R 1 Endscripts EndLayout
    Start 2 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column 4 slash 3 2nd
    Row 1st Column 0 2nd Column 1 3rd Column 8 slash 3 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mn>8</mn> <mo>/</mo>
    <mn>3</mn></mrow></mtd></mtr></mtable></mfenced> <mtable><mtr><mtd><mrow><mover><mo>→</mo>
    <mrow><mo>-</mo><msub><mi>R</mi> <mn>2</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>1</mn></msub></mrow></mover></mrow></mtd></mtr></mtable> <mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mrow><mn>4</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>8</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: That’s the RREF of our original matrix. You can see the identity matrix on the
    left—RREF will always produce an identity matrix as a submatrix in the upper-left
    of the original matrix. That’s a result of setting all pivots to 1 and using upward
    row reduction to eliminate all elements above each pivot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们原始矩阵的简化行阶梯形式（RREF）。你可以看到左侧是单位矩阵——RREF总会在原始矩阵的左上角生成一个单位矩阵。这是通过将所有主元设为1，并使用向上行约化来消除每个主元上方的所有元素得到的结果。
- en: 'Now we continue with Gaussian elimination by translating the matrix back into
    a system of equations:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过将矩阵转换回方程组来继续高斯消元：
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 slash 3
    2nd Row 1st Column y 2nd Column equals 8 slash 3 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>8</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals 4 slash 3
    2nd Row 1st Column y 2nd Column equals 8 slash 3 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>4</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>8</mn> <mo>/</mo> <mn>3</mn></mrow></mtd></mtr></mtable></math>
- en: 'We no longer need back substitution, or even basic arithmetic: the modified
    Gaussian elimination—which is called Gauss-Jordan elimination—decoupled the interwoven
    variables in the system of equations, and laid bare the solutions to each variable.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要回代，甚至基本的算术：修改后的高斯消元法——称为高斯-约旦消元法——解开了方程组中交织的变量，并显露了每个变量的解。
- en: Gauss-Jordan elimination was how people solved systems of equations by hand
    for over a century before computers came along to help us with the number crunching.
    In fact, computers still implement this exact same method, with only a few small
    modifications to ensure numerical stability.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机帮助我们进行数字计算之前，高斯-约旦消元法是人们手工解方程组的方法超过一个世纪。事实上，计算机仍然实现这个完全相同的方法，只是进行了一些小的修改以确保数值稳定性。
- en: 'The RREF is unique, meaning that a matrix has exactly one associated RREF.
    NumPy does not have a function to compute the RREF of a matrix, but the sympy
    library does (sympy is the symbolic math library in Python and is a powerful engine
    for “chalkboard math”):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: RREF是唯一的，这意味着一个矩阵有且仅有一个相关的RREF。NumPy没有计算矩阵RREF的函数，但sympy库有（sympy是Python中的符号数学库，是“黑板数学”的强大引擎）：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Matrix Inverse via Gauss-Jordan Elimination
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过高斯-约旦消元法求矩阵的逆
- en: The key insight from Gauss-Jordan elimination is that row reduction produces
    a sequence of row manipulations that solves a set of equations. Those row manipulations
    are linear transformations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从高斯-约旦消元法的关键洞见是行约简产生了一系列解决方程组的行操作。这些行操作是线性变换。
- en: 'Curiously, the description of Gauss-Jordan elimination is consistent with the
    description of the matrix inverse: a linear transformation that solves a set of
    equations. But wait, what “system of equations” does the matrix inverse solve?
    A fresh perspective on the matrix inverse will provide some new insights. Consider
    this system of equations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，高斯-约旦消元的描述与矩阵逆的描述一致：一个解决一组方程的线性变换。但等等，矩阵逆解决的“方程组”是什么？对矩阵逆的新视角将提供一些新的见解。考虑这个方程组：
- en: <math alttext="StartLayout 1st Row 1st Column a x 1 plus b y 1 2nd Column equals
    1 2nd Row 1st Column c x 1 plus d y 1 2nd Column equals 0 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>a</mi> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>b</mi> <msub><mi>y</mi> <mn>1</mn></msub></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>c</mi> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo>
    <mi>d</mi> <msub><mi>y</mi> <mn>1</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column a x 1 plus b y 1 2nd Column equals
    1 2nd Row 1st Column c x 1 plus d y 1 2nd Column equals 0 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>a</mi> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo> <mi>b</mi> <msub><mi>y</mi> <mn>1</mn></msub></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>1</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>c</mi> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo>
    <mi>d</mi> <msub><mi>y</mi> <mn>1</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>0</mn></mrow></mtd></mtr></mtable></math>
- en: 'Translated into a matrix equation, we get:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 转化为矩阵方程，我们得到：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix StartBinomialOrMatrix x 1 Choose y 1 EndBinomialOrMatrix
    equals StartBinomialOrMatrix 1 Choose 0 EndBinomialOrMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>1</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix StartBinomialOrMatrix x 1 Choose y 1 EndBinomialOrMatrix
    equals StartBinomialOrMatrix 1 Choose 0 EndBinomialOrMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>1</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Check out that constants vector—it is the first column of the <math alttext="2
    times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math> identity matrix!
    That means that applying RREF to a square full-rank matrix augmented by the first
    column of the identity matrix will reveal the linear transformation that brings
    the matrix into the first column of the identity matrix. And that in turn means
    that the vector [ <math alttext="x 1 y 1"><mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <msub><mi>y</mi> <mn>1</mn></msub></mrow></math> ] <math alttext="Superscript
    upper T"><msup><mtext>T</mtext></msup></math> is the first column of the matrix
    inverse.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 看看常数向量吧——它是<math alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>单位矩阵的第一列！这意味着对于一个方阵满秩矩阵，应用RREF并增广单位矩阵的第一列将揭示将矩阵带入单位矩阵第一列的线性变换。而这反过来意味着向量
    [ <math alttext="x 1 y 1"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <msub><mi>y</mi>
    <mn>1</mn></msub></mrow></math> ] <math alttext="Superscript upper T"><msup><mtext>T</mtext></msup></math>
    是矩阵逆的第一列。
- en: 'We then repeat the procedure but solving for the second column of the inverse:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重复该过程，但解决矩阵逆的第二列：
- en: <math alttext="StartLayout 1st Row 1st Column a x 2 plus b y 2 2nd Column equals
    0 2nd Row 1st Column c x 2 plus d y 2 2nd Column equals 1 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>a</mi> <msub><mi>x</mi>
    <mn>2</mn></msub> <mo>+</mo> <mi>b</mi> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>c</mi> <msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo>
    <mi>d</mi> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>1</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column a x 2 plus b y 2 2nd Column equals
    0 2nd Row 1st Column c x 2 plus d y 2 2nd Column equals 1 EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>a</mi> <msub><mi>x</mi>
    <mn>2</mn></msub> <mo>+</mo> <mi>b</mi> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>0</mn></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mrow><mi>c</mi> <msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo>
    <mi>d</mi> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>1</mn></mrow></mtd></mtr></mtable></math>
- en: RREF on that system gives the vector [ <math alttext="x 2 y 2"><mrow><msub><mi>x</mi>
    <mn>2</mn></msub> <msub><mi>y</mi> <mn>2</mn></msub></mrow></math> ] <math alttext="Superscript
    upper T"><msup><mtext>T</mtext></msup></math> , which is the second column of
    the matrix inverse.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对该系统进行RREF得到向量 [ <math alttext="x 2 y 2"><mrow><msub><mi>x</mi> <mn>2</mn></msub>
    <msub><mi>y</mi> <mn>2</mn></msub></mrow></math> ] <math alttext="Superscript
    upper T"><msup><mtext>T</mtext></msup></math> ，即矩阵逆的第二列。
- en: I’ve separated the columns of the identity matrix to link back to the perspective
    of solving systems of equations. But we can augment the entire identity matrix
    and solve for the inverse with one RREF.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将单位矩阵的列分开，以回到解决方程组的视角。但是我们可以增广整个单位矩阵，并通过一个RREF求解逆矩阵。
- en: 'Here is the bird’s-eye view of obtaining the matrix inverse via Gauss-Jordan
    elimination (the square brackets indicate augmented matrices with the vertical
    line separating the two constituent matrices):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是通过高斯-约旦消元法获得矩阵逆的鸟瞰图（方括号表示带有垂直线分隔的增广矩阵）：
- en: <math alttext="r r e f left-parenthesis Start 1 By 1 Matrix 1st Row  bold upper
    A vertical-bar bold upper I EndMatrix right-parenthesis right double arrow Start
    1 By 1 Matrix 1st Row  bold upper I vertical-bar bold upper A Superscript negative
    1 EndMatrix" display="block"><mrow><mi>r</mi> <mi>r</mi> <mi>e</mi> <mi>f</mi>
    <mrow><mo>(</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>𝐀</mi>
    <mo>|</mo> <mi>𝐈</mi></mrow></mtd></mtr></mtable></mfenced> <mo>)</mo></mrow>
    <mo>⇒</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mrow><mi>𝐈</mi>
    <mo>|</mo></mrow> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="r r e f left-parenthesis Start 1 By 1 Matrix 1st Row  bold upper
    A vertical-bar bold upper I EndMatrix right-parenthesis right double arrow Start
    1 By 1 Matrix 1st Row  bold upper I vertical-bar bold upper A Superscript negative
    1 EndMatrix" display="block"><mrow><mi>r</mi> <mi>r</mi> <mi>e</mi> <mi>f</mi>
    <mrow><mo>(</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>𝐀</mi>
    <mo>|</mo> <mi>𝐈</mi></mrow></mtd></mtr></mtable></mfenced> <mo>)</mo></mrow>
    <mo>⇒</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mrow><mi>𝐈</mi>
    <mo>|</mo></mrow> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: This is interesting because it provides a mechanism for computing the matrix
    inverse without computing determinants. On the other hand, row reduction does
    involve a lot of division, which increases the risk of numerical precision errors.
    For example, imagine we have two numbers that are essentially zero plus rounding
    error. If we end up dividing those numbers during RREF, we could get the fraction
    <math alttext="10 Superscript negative 15 Baseline slash 10 Superscript negative
    16"><mrow><msup><mn>10</mn> <mrow><mo>-</mo><mn>15</mn></mrow></msup> <mo>/</mo>
    <msup><mn>10</mn> <mrow><mo>-</mo><mn>16</mn></mrow></msup></mrow></math> , which
    is really 0/0 but the answer will be 10.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，因为它提供了一种计算矩阵逆的机制，而无需计算行列式。另一方面，行变换确实涉及大量的除法，这增加了数值精度误差的风险。例如，想象一下我们有两个基本上是零加上舍入误差的数字。如果我们在
    RREF 过程中除以这些数字，我们可能会得到分数 <math alttext="10 Superscript negative 15 Baseline slash
    10 Superscript negative 16"><mrow><msup><mn>10</mn> <mrow><mo>-</mo><mn>15</mn></mrow></msup>
    <mo>/</mo> <msup><mn>10</mn> <mrow><mo>-</mo><mn>16</mn></mrow></msup></mrow></math>
    ，这实际上是 0/0，但答案将是 10。
- en: 'The conclusion here is similar to what I discussed in the previous chapter
    about using QR to compute the matrix inverse: using Gauss-Jordan elimination to
    compute the matrix inverse is likely to be more numerically stable than the full
    algorithm for the inverse, but a matrix that is close to singular or that has
    a high condition number is difficult to invert, regardless of the algorithm used.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结论类似于我在前一章讨论过的关于使用 QR 分解计算矩阵逆的内容：使用 Gauss-Jordan 消元法计算矩阵逆很可能比完整的逆算法在数值稳定性上更可靠，但是接近奇异或具有高条件数的矩阵很难反转，无论使用哪种算法。
- en: LU Decomposition
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LU 分解
- en: 'The “LU” in *LU decomposition* stands for “lower upper,” as in lower-triangular,
    upper-triangular. The idea is to decompose a matrix into the product of two triangular
    matrices:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*LU 分解* 中的“LU”代表“下三角，上三角”。其思想是将一个矩阵分解成两个三角矩阵的乘积：'
- en: <math alttext="bold upper A equals bold upper L bold upper U" display="block"><mrow><mi>𝐀</mi>
    <mo>=</mo> <mi>𝐋</mi> <mi>𝐔</mi></mrow></math>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper A equals bold upper L bold upper U" display="block"><mrow><mi>𝐀</mi>
    <mo>=</mo> <mi>𝐋</mi> <mi>𝐔</mi></mrow></math>
- en: 'Here’s a numerical example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个数值例子：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 2 2nd Column 2 3rd Column
    4 2nd Row 1st Column 1 2nd Column 0 3rd Column 3 3rd Row 1st Column 2 2nd Column
    1 3rd Column 2 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 1 slash 2 2nd Column 1 3rd Column 0 3rd Row
    1st Column 1 2nd Column 1 3rd Column 1 EndMatrix Start 3 By 3 Matrix 1st Row 1st
    Column 2 2nd Column 2 3rd Column 4 2nd Row 1st Column 0 2nd Column negative 1
    3rd Column 1 3rd Row 1st Column 0 2nd Column 0 3rd Column negative 3 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 2 2nd Column 2 3rd Column
    4 2nd Row 1st Column 1 2nd Column 0 3rd Column 3 3rd Row 1st Column 2 2nd Column
    1 3rd Column 2 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 1 slash 2 2nd Column 1 3rd Column 0 3rd Row
    1st Column 1 2nd Column 1 3rd Column 1 EndMatrix Start 3 By 3 Matrix 1st Row 1st
    Column 2 2nd Column 2 3rd Column 4 2nd Row 1st Column 0 2nd Column negative 1
    3rd Column 1 3rd Row 1st Column 0 2nd Column 0 3rd Column negative 3 EndMatrix"
    display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>0</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'And here’s the corresponding Python code (note that the function for LU decomposition
    is in the SciPy library):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对应的 Python 代码（注意 LU 分解的函数在 SciPy 库中）：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Where do these two matrices come from? In fact, you already know the answer:
    row reduction can be expressed as <math alttext="bold upper L Superscript negative
    1 Baseline bold upper A equals bold upper U"><mrow><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐀</mi> <mo>=</mo> <mi>𝐔</mi></mrow></math> , where <math alttext="bold upper
    L Superscript negative 1"><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    contains the set of row manipulations that transforms the dense <math alttext="bold
    upper A"><mi>𝐀</mi></math> into upper-triangular (echelon) <math alttext="bold
    upper U"><mi>𝐔</mi></math> .'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个矩阵是从哪里来的？事实上，你已经知道答案：行变换可以表示为 <math alttext="bold upper L Superscript negative
    1 Baseline bold upper A equals bold upper U"><mrow><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐀</mi> <mo>=</mo> <mi>𝐔</mi></mrow></math> ，其中 <math alttext="bold upper L
    Superscript negative 1"><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    包含了将密集矩阵 <math alttext="bold upper A"><mi>𝐀</mi></math> 转换为上三角形式的行操作集合 <math alttext="bold
    upper U"><mi>𝐔</mi></math> 。
- en: Because the echelon form is not unique, LU decomposition is not necessarily
    unique. That is, there is an infinite pairing of lower- and upper-triangular matrices
    that could multiply to produce matrix <math alttext="bold upper A"><mi>𝐀</mi></math>
    . However, adding the constraint that the diagonals of <math alttext="bold upper
    L"><mi>𝐋</mi></math> equal 1 ensures that LU decomposition is unique for a full-rank
    square matrix <math alttext="bold upper A"><mi>𝐀</mi></math> (you can see this
    in the previous example). The uniqueness of LU decompositions of reduced-rank
    and nonsquare matrices is a longer discussion that I will omit here; however,
    SciPy’s LU decomposition algorithm is determinstic, meaning that repeated LU decompositions
    of a given matrix will be identical.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于梯形形式不唯一，LU 分解也不一定唯一。也就是说，存在无限多个下三角矩阵和上三角矩阵的配对，它们可以相乘得到矩阵 <math alttext="bold
    upper A"><mi>𝐀</mi></math> 。然而，通过加上 <math alttext="bold upper L"><mi>𝐋</mi></math>
    对角线元素为 1 的约束条件，可以确保对于满秩方阵 <math alttext="bold upper A"><mi>𝐀</mi></math> ，LU 分解是唯一的（你可以在前面的例子中看到这一点）。关于降秩和非方阵的LU分解唯一性是一个更长的讨论，我这里不再详述；然而，SciPy
    的 LU 分解算法是确定性的，这意味着对于给定矩阵的重复 LU 分解结果将是相同的。
- en: Row Swaps via Permutation Matrices
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过置换矩阵进行行交换
- en: 'Some matrices do not easily transform into an upper-triangular form. Consider
    the following matrix:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有些矩阵不容易转换成上三角形式。考虑以下矩阵：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 3 2nd Column 2 3rd Column
    1 2nd Row 1st Column 0 2nd Column 0 3rd Column 5 3rd Row 1st Column 0 2nd Column
    7 3rd Column 2 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 3 2nd Column 2 3rd Column
    1 2nd Row 1st Column 0 2nd Column 0 3rd Column 5 3rd Row 1st Column 0 2nd Column
    7 3rd Column 2 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced></math>
- en: 'It’s not in echelon form, but it would be if we swapped the second and third
    rows. Row swaps are one of the tricks of row reduction, and are implemented through
    a permutation matrix:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它不处于梯形形式，但如果我们交换第二行和第三行，它将处于梯形形式。行交换是行约简的技巧之一，并且通过排列矩阵实现：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 0 3rd Column 1 3rd Row 1st Column 0 2nd Column
    1 3rd Column 0 EndMatrix Start 3 By 3 Matrix 1st Row 1st Column 3 2nd Column 2
    3rd Column 1 2nd Row 1st Column 0 2nd Column 0 3rd Column 5 3rd Row 1st Column
    0 2nd Column 7 3rd Column 2 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    3 2nd Column 2 3rd Column 1 2nd Row 1st Column 0 2nd Column 7 3rd Column 2 3rd
    Row 1st Column 0 2nd Column 0 3rd Column 5 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 0 3rd Column 1 3rd Row 1st Column 0 2nd Column
    1 3rd Column 0 EndMatrix Start 3 By 3 Matrix 1st Row 1st Column 3 2nd Column 2
    3rd Column 1 2nd Row 1st Column 0 2nd Column 0 3rd Column 5 3rd Row 1st Column
    0 2nd Column 7 3rd Column 2 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    3 2nd Column 2 3rd Column 1 2nd Row 1st Column 0 2nd Column 7 3rd Column 2 3rd
    Row 1st Column 0 2nd Column 0 3rd Column 5 EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>7</mn></mtd> <mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Permutation matrices are often labeled <math alttext="bold upper P"><mi>𝐏</mi></math>
    . Thus, the full LU decomposition actually takes the following form:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 排列矩阵通常标记为<math alttext="bold upper P"><mi>𝐏</mi></math>。因此，完整的LU分解实际上采用以下形式：
- en: <math alttext="StartLayout 1st Row 1st Column bold upper P bold upper A 2nd
    Column equals bold upper L bold upper U 2nd Row 1st Column bold upper A 2nd Column
    equals bold upper P Superscript upper T Baseline bold upper L bold upper U EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>𝐏</mi>
    <mi>𝐀</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐋</mi> <mi>𝐔</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>𝐀</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>𝐏</mi> <mtext>T</mtext></msup> <mi>𝐋</mi> <mi>𝐔</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper P bold upper A 2nd
    Column equals bold upper L bold upper U 2nd Row 1st Column bold upper A 2nd Column
    equals bold upper P Superscript upper T Baseline bold upper L bold upper U EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>𝐏</mi>
    <mi>𝐀</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐋</mi> <mi>𝐔</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>𝐀</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>𝐏</mi> <mtext>T</mtext></msup> <mi>𝐋</mi> <mi>𝐔</mi></mrow></mtd></mtr></mtable></math>
- en: Remarkably, permutation matrices are orthogonal, and so <math alttext="bold
    upper P Superscript negative 1 Baseline equals bold upper P Superscript upper
    T"><mrow><msup><mi>𝐏</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo>
    <msup><mi>𝐏</mi> <mtext>T</mtext></msup></mrow></math> . Briefly, the reason is
    that all elements of a permutation matrix are either 0 or 1, and because rows
    are swapped only once, each column has exactly one nonzero element (indeed, all
    permutation matrices are identity matrices with row swaps). Therefore, the dot
    product of any two columns is 0 while the dot product of a column with itself
    is 1, meaning <math alttext="bold upper P Superscript upper T Baseline bold upper
    P equals bold upper I"><mrow><msup><mi>𝐏</mi> <mtext>T</mtext></msup> <mi>𝐏</mi>
    <mo>=</mo> <mi>𝐈</mi></mrow></math> .
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，排列矩阵是正交的，因此<math alttext="bold upper P Superscript negative 1 Baseline
    equals bold upper P Superscript upper T"><mrow><msup><mi>𝐏</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <msup><mi>𝐏</mi> <mtext>T</mtext></msup></mrow></math>。简而言之，原因在于排列矩阵的所有元素都是0或1，并且因为只交换行一次，所以每列恰好有一个非零元素（事实上，所有排列矩阵都是通过行交换得到的单位矩阵）。因此，任意两列的点积为0，而列与自身的点积为1，这意味着<math
    alttext="bold upper P Superscript upper T Baseline bold upper P equals bold upper
    I"><mrow><msup><mi>𝐏</mi> <mtext>T</mtext></msup> <mi>𝐏</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math>。
- en: '**Important:** the formulas I wrote above provide the *mathematical* description
    of LU decomposition. Scipy actually returns <math alttext="bold upper A equals
    bold upper P bold upper L bold upper U"><mrow><mi>𝐀</mi> <mo>=</mo> <mi>𝐏</mi>
    <mi>𝐋</mi> <mi>𝐔</mi></mrow></math> , which we could also write as <math alttext="bold
    upper P Superscript upper T Baseline bold upper A equals bold upper L bold upper
    U"><mrow><msup><mi>𝐏</mi> <mtext>T</mtext></msup> <mi>𝐀</mi> <mo>=</mo> <mi>𝐋</mi>
    <mi>𝐔</mi></mrow></math> . [Exercise 10-4](#exercise_10_4) provides the opportunity
    to explore this point of confusion.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示：**我上面写的公式提供了LU分解的*数学*描述。实际上，Scipy返回的是<math alttext="bold upper A equals
    bold upper P bold upper L bold upper U"><mrow><mi>𝐀</mi> <mo>=</mo> <mi>𝐏</mi>
    <mi>𝐋</mi> <mi>𝐔</mi></mrow></math>，我们也可以写成<math alttext="bold upper P Superscript
    upper T Baseline bold upper A equals bold upper L bold upper U"><mrow><msup><mi>𝐏</mi>
    <mtext>T</mtext></msup> <mi>𝐀</mi> <mo>=</mo> <mi>𝐋</mi> <mi>𝐔</mi></mrow></math>。[练习 10-4](#exercise_10_4)提供了探索这一混淆点的机会。'
- en: '[Figure 10-1](#fig_10_1) shows an example of LU decomposition applied to a
    random matrix.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-1](#fig_10_1)展示了LU分解应用于随机矩阵的示例。'
- en: '![L to the U](assets/plad_1001.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![L to the U](assets/plad_1001.png)'
- en: Figure 10-1\. Visualization of LU decomposition
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. LU分解的可视化
- en: LU decomposition is used in several applications, including computing the determinant
    and the matrix inverse. In the next chapter, you’ll see how LU decomposition is
    used in the least squares computation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: LU分解在多个应用中使用，包括计算行列式和矩阵逆。在下一章中，您将看到LU分解如何用于最小二乘计算。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'I opened this chapter by promising an action-packed educational adventure.
    I hope you experienced several adrenaline rushes while learning new perspectives
    on algebraic equations, matrix decompositions, and the matrix inverse. Here are
    the key take-home messages of this chapter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章开头承诺提供一个充满教育意义的动感冒险。希望在学习代数方程、矩阵分解和矩阵逆的新视角时，您体验到了几次肾上腺素飙升。以下是本章的主要要点：
- en: Systems of equations can be translated into a matrix equation. In addition to
    providing a compact representation, this allows for sophisticated linear algebra
    solutions to solving systems of equations.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程组可以转换为矩阵方程。除了提供紧凑的表示外，这还允许对解方程组的线性代数解决方案进行复杂的处理。
- en: When working with matrix equations, remember that manipulations must be applied
    to both sides of the equation, and remember that matrix multiplication is noncommutative.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理矩阵方程时，请记住必须同时应用到方程的两边，并且矩阵乘法是非交换的。
- en: Row reduction is a procedure in which the rows of matrix <math alttext="bold
    upper A"><mi>𝐀</mi></math> are scalar multiplied and added, until the matrix is
    linearly transformed into an upper-triangular matrix <math alttext="bold upper
    U"><mi>𝐔</mi></math> . The set of linear transformations can be stored in another
    matrix <math alttext="bold upper L Superscript negative 1"><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    that left-multiplies <math alttext="bold upper A"><mi>𝐀</mi></math> to produce
    the expression <math alttext="bold upper L Superscript negative 1 Baseline bold
    upper A equals bold upper U"><mrow><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐀</mi> <mo>=</mo> <mi>𝐔</mi></mrow></math> .
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行约简是一种过程，在此过程中矩阵<math alttext="bold upper A"><mi>𝐀</mi></math>的行进行标量乘法和加法操作，直到矩阵线性变换为上三角矩阵<math
    alttext="bold upper U"><mi>𝐔</mi></math>。线性变换集合可以存储在另一个矩阵<math alttext="bold upper
    L Superscript negative 1"><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>中，该矩阵左乘<math
    alttext="bold upper A"><mi>𝐀</mi></math>以生成表达式<math alttext="bold upper L Superscript
    negative 1 Baseline bold upper A equals bold upper U"><mrow><msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐀</mi> <mo>=</mo> <mi>𝐔</mi></mrow></math>。
- en: Row reduction has been used for centuries to solve systems of equations, including
    the matrix inverse, by hand. We still use row reduction, although computers take
    care of the arithmetic.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个世纪以来，行约简一直被用来手工解决方程组，包括矩阵求逆。尽管计算机负责算术运算，我们仍然使用行约简。
- en: Row reduction is also used to implement LU decomposition. LU decomposition is
    unique under some constraints, which are incorporated into the `lu()` function
    in SciPy.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行约简也用于实现LU分解。在某些约束条件下，LU分解是唯一的，在SciPy的`lu()`函数中已经实现了这些约束条件。
- en: Code Exercises
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码练习
- en: Exercise 10-1\.
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 10-1\.
- en: LU decomposition can be computationally intensive, although it is more efficient
    than other decompositions such as QR. Interestingly, LU decomposition is often
    used as a benchmark to compare computation times between operating systems, hardware
    processors, computer languages (e.g., C versus Python versus MATLAB), or implementation
    algorithms. Out of curiousity, I tested how long it took Python and MATLAB to
    run LU decomposition on a thousand matrices of size <math alttext="100 times 100"><mrow><mn>100</mn>
    <mo>×</mo> <mn>100</mn></mrow></math> . On my laptop, MATLAB took around 300 ms
    while Python took around 410 ms. Python on Google Colab took around 1,000 ms.
    Test how long this takes on your computer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: LU分解可能需要大量计算资源，尽管它比QR等分解方法更高效。有趣的是，LU分解经常被用作比较操作系统、硬件处理器、计算机语言（例如C与Python与MATLAB之间）、或者实现算法的计算时间的基准。出于好奇，我测试了Python和MATLAB在一千个大小为<math
    alttext="100 times 100"><mrow><mn>100</mn> <mo>×</mo> <mn>100</mn></mrow></math>的矩阵上运行LU分解所需的时间。在我的笔记本电脑上，MATLAB大约需要300毫秒，而Python大约需要410毫秒。在Google
    Colab上，Python需要大约1,000毫秒。请测试一下在你的电脑上需要多长时间。
- en: Exercise 10-2\.
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 10-2\.
- en: Use the matrix-multiplication method to make a <math alttext="6 times 8"><mrow><mn>6</mn>
    <mo>×</mo> <mn>8</mn></mrow></math> rank-3 matrix. Take its LU decomposition,
    and show the three matrices with their ranks in the title, as in [Figure 10-2](#fig_10_2).
    Notice the ranks of the three matrices and that <math alttext="bold upper L"><mi>𝐋</mi></math>
    has all 1s on the diagonal. Feel free to explore the ranks of matrices with other
    sizes and ranks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵乘法方法制作一个<math alttext="6 times 8"><mrow><mn>6</mn> <mo>×</mo> <mn>8</mn></mrow></math>秩为3的矩阵。进行其LU分解，并显示三个带有它们秩的矩阵的标题，就像[图
    10-2](#fig_10_2)中一样。注意这三个矩阵的秩以及<math alttext="bold upper L"><mi>𝐋</mi></math>对角线上的全为1。随时探索其他大小和秩的矩阵的秩。
- en: '![LUdecom](assets/plad_1002.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![LUdecom](assets/plad_1002.png)'
- en: Figure 10-2\. Results of Exercise 10-2
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. 练习 10-2 的结果
- en: Exercise 10-3\.
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 10-3\.
- en: One application of LU decomposition is computing the determinant. Here are two
    properties of the determinant:^([4](ch10.xhtml#idm45733295824352)) the determinant
    of a triangular matrix is the product of the diagonals, and the determinant of
    a product matrix equals the product of the determinants (that is, <math alttext="d
    e t left-parenthesis bold upper A bold upper B right-parenthesis equals d e t
    left-parenthesis bold upper A right-parenthesis d e t left-parenthesis bold upper
    B right-parenthesis"><mrow><mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐀</mi>
    <mi>𝐁</mi> <mo>)</mo> <mo>=</mo> <mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐀</mi>
    <mo>)</mo> <mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐁</mi> <mo>)</mo></mrow></math>
    ). Putting these two facts together, you can compute the determinant of a matrix
    as the product of the diagonals of <math alttext="bold upper L"><mi>𝐋</mi></math>
    times the product of the diagonals of <math alttext="bold upper U"><mi>𝐔</mi></math>
    . On the other hand, because the diagonals of <math alttext="bold upper L"><mi>𝐋</mi></math>
    are all 1 (when implemented in Python to ensure uniqueness of the decomposition),
    then the determinant of a matrix <math alttext="bold upper A"><mi>𝐀</mi></math>
    is simply the product of the diagonals of <math alttext="bold upper U"><mi>𝐔</mi></math>
    . Try it in Python—and compare to the result of `np.linalg.det(A)`—multiple times
    with different random matrices, before reading the next paragraph.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: LU 分解的一个应用是计算行列式。行列式的两个性质如下：三角矩阵的行列式是对角线元素的乘积，乘积矩阵的行列式等于行列式的乘积（即 <math alttext="d
    e t left-parenthesis bold upper A bold upper B right-parenthesis equals d e t
    left-parenthesis bold upper A right-parenthesis d e t left-parenthesis bold upper
    B right-parenthesis"><mrow><mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐀</mi>
    <mi>𝐁</mi> <mo>)</mo> <mo>=</mo> <mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐀</mi>
    <mo>)</mo> <mi>d</mi> <mi>e</mi> <mi>t</mi> <mo>(</mo> <mi>𝐁</mi> <mo>)</mo></mrow></math>
    ）。将这两个事实结合起来，你可以将矩阵的行列式计算为 <math alttext="bold upper L"><mi>𝐋</mi></math> 的对角线乘积乘以
    <math alttext="bold upper U"><mi>𝐔</mi></math> 的对角线乘积。另一方面，因为在 Python 实现中确保分解的唯一性，<math
    alttext="bold upper L"><mi>𝐋</mi></math> 的对角线元素都是 1，所以矩阵 <math alttext="bold upper
    A"><mi>𝐀</mi></math> 的行列式只是 <math alttext="bold upper U"><mi>𝐔</mi></math> 对角线元素的乘积。在多次使用不同随机矩阵的情况下，尝试在
    Python 中执行，并与 `np.linalg.det(A)` 的结果进行比较，然后再阅读下一段。
- en: Did you get the same result as Python? I assume you found that the determinants
    match in magnitude but that the signs would seemingly randomly differ. Why did
    that happen? It happened because I omitted the permutation matrix in the instructions.
    The determinant of a permutation matrix is +1 for an even number of row swaps
    and −1 for an odd number of row swaps. Now go back to your code and include the
    determinant of <math alttext="bold upper P"><mi>𝐏</mi></math> in your computations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到了与 Python 相同的结果吗？我假设你发现行列式的大小匹配，但符号似乎会随机不同。为什么会发生这种情况？这是因为我在说明中省略了排列矩阵。置换矩阵的行交换次数为偶数时行列式为
    +1，为奇数时为 −1。现在回到你的代码中，并在计算中包括 <math alttext="bold upper P"><mi>𝐏</mi></math> 的行列式。
- en: Exercise 10-4\.
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 10-4\.
- en: 'Following the formula from the section [“LU Decomposition”](#LUdecomp), the
    inverse of a matrix can be expressed as:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据章节 [“LU Decomposition”](#LUdecomp) 中的公式，矩阵的逆可以表示为：
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A 2nd Column equals
    bold upper P Superscript upper T Baseline bold upper L bold upper U 2nd Row 1st
    Column bold upper A Superscript negative 1 2nd Column equals left-parenthesis
    bold upper P Superscript upper T Baseline bold upper L bold upper U right-parenthesis
    Superscript negative 1 Baseline 3rd Row 1st Column bold upper A Superscript negative
    1 2nd Column equals bold upper U Superscript negative 1 Baseline bold upper L
    Superscript negative 1 Baseline bold upper P EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>𝐀</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>𝐏</mi> <mtext>T</mtext></msup> <mi>𝐋</mi> <mi>𝐔</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>𝐏</mi>
    <mtext>T</mtext></msup> <mi>𝐋</mi><mi>𝐔</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐔</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>𝐏</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A 2nd Column equals
    bold upper P Superscript upper T Baseline bold upper L bold upper U 2nd Row 1st
    Column bold upper A Superscript negative 1 2nd Column equals left-parenthesis
    bold upper P Superscript upper T Baseline bold upper L bold upper U right-parenthesis
    Superscript negative 1 Baseline 3rd Row 1st Column bold upper A Superscript negative
    1 2nd Column equals bold upper U Superscript negative 1 Baseline bold upper L
    Superscript negative 1 Baseline bold upper P EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>𝐀</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>𝐏</mi> <mtext>T</mtext></msup> <mi>𝐋</mi> <mi>𝐔</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>𝐏</mi>
    <mtext>T</mtext></msup> <mi>𝐋</mi><mi>𝐔</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐔</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>𝐋</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>𝐏</mi></mrow></mtd></mtr></mtable></math>
- en: Implement that third equation directly using the output from `scipy.linalg.lu`
    on a <math alttext="4 times 4"><mrow><mn>4</mn> <mo>×</mo> <mn>4</mn></mrow></math>
    random-numbers matrix. Is <math alttext="bold upper A bold upper A Superscript
    negative 1"><mrow><mi>𝐀</mi> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    the identity matrix? Sometimes it is and sometimes it isn’t, depending on <math
    alttext="bold upper P"><mi>𝐏</mi></math> . This discrepancy occurs because of
    what I wrote about the output of `scipy.linalg.lu`. Adjust the code so that it
    follows SciPy’s convention instead of the math convention.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从 `scipy.linalg.lu` 输出的 <math alttext="4 times 4"><mrow><mn>4</mn> <mo>×</mo>
    <mn>4</mn></mrow></math> 随机数矩阵直接实现第三个方程。 <math alttext="bold upper A bold upper
    A Superscript negative 1"><mrow><mi>𝐀</mi> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    是单位矩阵吗？有时是，有时不是，这取决于 <math alttext="bold upper P"><mi>𝐏</mi></math> 。 这种差异是由于我在
    `scipy.linalg.lu` 输出的内容所述。 调整代码以遵循 SciPy 的惯例，而不是数学惯例。
- en: 'Here is the take-home message from this exercise: the absence of error messages
    does not necessarily mean your code is correct. Please sanity-check your mathematical
    code as much as possible.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的要点是：缺少错误消息并不一定意味着你的代码是正确的。请尽可能多地检查你的数学代码。
- en: Exercise 10-5\.
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 10-5\.
- en: For matrix <math alttext="bold upper A equals bold upper P bold upper L bold
    upper U"><mrow><mi>𝐀</mi> <mo>=</mo> <mi>𝐏</mi> <mi>𝐋</mi> <mi>𝐔</mi></mrow></math>
    (using Python’s ordering of the permutation matrix), <math alttext="bold upper
    A Superscript upper T Baseline bold upper A"><mrow><msup><mi>𝐀</mi> <mtext>T</mtext></msup>
    <mi>𝐀</mi></mrow></math> can be computed as <math alttext="bold upper U Superscript
    upper T Baseline bold upper L Superscript upper T Baseline bold upper L bold upper
    U"><mrow><msup><mi>𝐔</mi> <mtext>T</mtext></msup> <msup><mi>𝐋</mi> <mtext>T</mtext></msup>
    <mi>𝐋</mi> <mi>𝐔</mi></mrow></math> —*without the permutation matrices*. Why is
    it possible to drop the permutation matrix? Answer the question and then confirm
    in Python using random matrices that <math alttext="bold upper A Superscript upper
    T Baseline bold upper A equals bold upper U Superscript upper T Baseline bold
    upper L Superscript upper T Baseline bold upper L bold upper U"><mrow><msup><mi>𝐀</mi>
    <mtext>T</mtext></msup> <mi>𝐀</mi> <mo>=</mo> <msup><mi>𝐔</mi> <mtext>T</mtext></msup>
    <msup><mi>𝐋</mi> <mtext>T</mtext></msup> <mi>𝐋</mi> <mi>𝐔</mi></mrow></math> even
    when <math alttext="bold upper P not-equals bold upper I"><mrow><mi>𝐏</mi> <mo>≠</mo>
    <mi>𝐈</mi></mrow></math> .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵 <math alttext="bold upper A equals bold upper P bold upper L bold upper
    U"><mrow><mi>𝐀</mi> <mo>=</mo> <mi>𝐏</mi> <mi>𝐋</mi> <mi>𝐔</mi></mrow></math>（使用Python中的排列矩阵顺序），<math
    alttext="bold upper A Superscript upper T Baseline bold upper A"><mrow><msup><mi>𝐀</mi>
    <mtext>T</mtext></msup> <mi>𝐀</mi></mrow></math> 可以计算为 <math alttext="bold upper
    U Superscript upper T Baseline bold upper L Superscript upper T Baseline bold
    upper L bold upper U"><mrow><msup><mi>𝐔</mi> <mtext>T</mtext></msup> <msup><mi>𝐋</mi>
    <mtext>T</mtext></msup> <mi>𝐋</mi> <mi>𝐔</mi></mrow></math> —*没有排列矩阵*。为什么可以省略排列矩阵？回答这个问题，然后用随机矩阵在Python中确认
    <math alttext="bold upper A Superscript upper T Baseline bold upper A equals bold
    upper U Superscript upper T Baseline bold upper L Superscript upper T Baseline
    bold upper L bold upper U"><mrow><msup><mi>𝐀</mi> <mtext>T</mtext></msup> <mi>𝐀</mi>
    <mo>=</mo> <msup><mi>𝐔</mi> <mtext>T</mtext></msup> <msup><mi>𝐋</mi> <mtext>T</mtext></msup>
    <mi>𝐋</mi> <mi>𝐔</mi></mrow></math> 即使 <math alttext="bold upper P not-equals
    bold upper I"><mrow><mi>𝐏</mi> <mo>≠</mo> <mi>𝐈</mi></mrow></math> 。
- en: ^([1](ch10.xhtml#idm45733296963648-marker)) Of course you know that order matters,
    but empirical demonstrations help build intuition. And I want you to get in the
    habit of using Python as a tool to empirically confirm principles in mathematics.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#idm45733296963648-marker)) 当然，您知道顺序很重要，但经验演示有助于建立直觉。我希望您养成使用Python作为工具来经验性地确认数学原理的习惯。
- en: '^([2](ch10.xhtml#idm45733296685312-marker)) Spoiler alert: LU decomposition
    involves representing a matrix as the product of a lower-triangular and an upper-triangular
    matrix.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.xhtml#idm45733296685312-marker)) 剧透警告：LU分解涉及将矩阵表示为下三角矩阵和上三角矩阵的乘积。
- en: ^([3](ch10.xhtml#idm45733296566688-marker)) Please conjure into your imagination
    that *Matrix* meme with Morpheus proffering the red and blue pill, corresponding
    to new knowledge versus sticking to what you know.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.xhtml#idm45733296566688-marker)) 请想象一下*矩阵*的米黄斯用红色和蓝色药丸的表情包，对应于接受新知识与固守现有知识的选择。
- en: ^([4](ch10.xhtml#idm45733295824352-marker)) These are among the myriad aspects
    of linear algbera that you would learn in a traditional linear algebra textbook;
    they are interesting in their own right but less directly relevant to data science.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.xhtml#idm45733295824352-marker)) 这些都是传统线性代数教材中你会学到的众多方面；它们本身很有趣，但与数据科学的直接相关性较小。
