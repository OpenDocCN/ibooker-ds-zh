- en: Chapter 11\. Solving real problems with advanced trees
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章. 使用高级树解决实际问题
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Avoiding stack overflow with self-balancing trees
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自平衡树避免栈溢出
- en: Implementing the red-black tree
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现红黑树
- en: Creating functional maps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数式映射
- en: Designing a functional priority queue
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计函数式优先队列
- en: In the previous chapter, you learned about the binary tree structure and basic
    tree operations. But you saw that to fully benefit from trees, you must either
    have very specific use cases, such as handling randomly ordered data, or a limited
    data set, in order to avoid any risk of stack overflows. Making trees stack-safe
    is much more difficult than it is for lists, because each computing step involves
    two recursive calls, which makes it impossible to create tail-recursive versions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了二叉树结构和基本树操作。但你看到，为了充分利用树，你必须有非常具体的使用案例，例如处理随机排序的数据，或者有限的数据集，以避免任何栈溢出的风险。使树栈安全比列表要困难得多，因为每个计算步骤都涉及两个递归调用，这使得无法创建尾递归版本。
- en: 'In this chapter, we’ll study two specific trees:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究两种特定的树：
- en: The red-black tree is a self-balancing, general-purpose tree with high performance.
    It’s suitable for general use and data sets of any size.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红黑树是一种高性能的自平衡通用树。它适用于通用用途和任何大小的数据集。
- en: The leftist heap is a very specific tree suitable for implementing priority
    queues.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左式堆是一个非常适合实现优先队列的特定树。
- en: 11.1\. Better performance and stack safety with self-balancing trees
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. 更好的性能和栈安全性通过自平衡树
- en: 'The Day-Stout-Warren balancing algorithm that you used in the previous chapter
    isn’t well suited for balancing functional trees because it was designed for in-place
    modifications. In functional programming, in-place modifications are generally
    avoided, and instead, a new structure is created for each change. A much better
    solution is to define a balancing process that doesn’t involve transforming the
    tree into a list before reconstructing a totally unbalanced tree and then finally
    balancing it. There are two ways to optimize this process:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一章中使用的Day-Stout-Warren平衡算法并不适合平衡函数树，因为它是为就地修改而设计的。在函数式编程中，通常避免就地修改，而是为每次更改创建一个新的结构。一个更好的解决方案是定义一个平衡过程，该过程不涉及在重建一个完全不平衡的树并最终平衡它之前将树转换为列表。有两种方法可以优化这个过程：
- en: Directly rotate the original tree (eliminating the list/unbalanced tree process).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接旋转原始树（消除列表/不平衡树的过程）。
- en: Accept a certain amount of imbalance.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一定程度的失衡。
- en: You could try to invent such a solution, but others have long since done that.
    One of the most efficient self-balancing tree designs is the red-black tree. This
    structure was invented in 1978 by Guibas and Sedgewick.^([[1](#ch11fn01)]) In
    1999, Chris Okasaki published a functional version of the red-black tree algorithm
    in his book *Purely Functional Data Structures* (Cambridge University Press, 1999).
    The description was illustrated by an implementation in Standard ML, and a Haskell
    implementation was added later. It’s this algorithm that you’ll implement in Java.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试发明这样的解决方案，但其他人早已做到了。最有效的自平衡树设计之一是红黑树。这种结构是在1978年由古巴斯和赛德维克发明的.^([[1](#ch11fn01)])
    在1999年，Chris Okasaki在他的书《纯函数数据结构》（Cambridge University Press，1999）中发布了红黑树算法的函数式版本。描述通过在Standard
    ML中的实现来展示，后来又添加了Haskell的实现。这就是你将在Java中实现的算法。
- en: ¹
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leo J. Guibas and Robert Sedgewick, “A dichromatic framework for balanced trees,”
    *Foundations of Computer Science* (1978), [http://mng.bz/Ly5Jl](http://mng.bz/Ly5Jl).
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 李奥·J·古巴斯和罗伯特·赛德维克，“平衡树的二色框架”，*计算机科学基础* (1978), [http://mng.bz/Ly5Jl](http://mng.bz/Ly5Jl).
- en: If you’re interested in functional data structures, I strongly encourage you
    to buy and read Okasaki’s book. You can also read his 1996 thesis with the same
    title. It’s much less complete than his book, but it’s available as a free download
    ([www.cs.cmu.edu/~rwh/theses/okasaki.pdf](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对手动数据结构感兴趣，我强烈建议你购买并阅读Okasaki的书。你也可以阅读他1996年的同名论文。它不如他的书完整，但可以作为免费下载([www.cs.cmu.edu/~rwh/theses/okasaki.pdf](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf))。
- en: 11.1.1\. The basic tree structure
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1. 基本树结构
- en: The red-black tree is a binary search tree (BST) with some additions to its
    structure and a modified insertion algorithm, which also balances the result.
    Unfortunately, Okasaki didn’t describe removal, which happens to be a far more
    complex process. But Kimball Germane and Matthew Might described this “missing
    method” in 2014.^([[2](#ch11fn02)])
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树是一种二叉搜索树（BST），在其结构和插入算法上做了一些补充，并且也平衡了结果。不幸的是，Okasaki没有描述删除操作，而这实际上是一个更为复杂的过程。但Kimball
    Germane和Matthew Might在2014年描述了这种“缺失的方法”[[2](#ch11fn02)]。
- en: ²
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Kimball Germane and Matthew Might, “Functional Pearl, Deletion: The curse of
    the red-black tree,” *JFP 24*, 4 (2014): 423–433; [http://matt.might.net/papers/germane2014deletion.pdf](http://matt.might.net/papers/germane2014deletion.pdf).'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Kimball Germane和Matthew Might，“功能珍珠，删除：红黑树的诅咒”，*JFP 24*，4（2014）：423–433；[http://matt.might.net/papers/germane2014deletion.pdf](http://matt.might.net/papers/germane2014deletion.pdf)。
- en: In a red-black tree, each tree (including subtrees) has an additional property
    representing its color. Besides this, the structure is exactly the same as the
    BST structure, as shown in the following listing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在红黑树中，每个树（包括子树）都有一个额外的属性来表示其颜色。除此之外，结构与BST结构完全相同，如下所示。
- en: Listing 11.1\. The red-black tree base structure
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1. 红黑树基本结构
- en: '![](Images/ch11ex01-0.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/ch11ex01-0.jpg)'
- en: '![](Images/ch11ex01-1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/ch11ex01-1.jpg)'
- en: '![](Images/291fig01b_alt.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/291fig01b_alt.jpg)'
- en: '![](Images/291fig01c_alt.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/291fig01c_alt.jpg)'
- en: '![](Images/291fig01d_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/291fig01d_alt.jpg)'
- en: The `member` method hasn’t been represented, nor the other methods such as `fold`,
    `map`, and so on, because they aren’t different from the standard tree versions.
    As you’ll see, only the `insert` and `remove` methods are different.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`member`方法没有表示，也没有其他方法，如`fold`、`map`等，因为它们与标准树版本没有区别。正如你将看到的，只有`insert`和`remove`方法不同。'
- en: 11.1.2\. Inserting an element into the red-black tree
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2. 将元素插入到红黑树中
- en: 'The main characteristic of a red-black tree is invariants that must always
    be verified. While modifying the tree, it will be tested to check whether these
    invariants are being broken and to restore them through rotations and color changes
    if necessary. These invariants are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树的主要特征是必须始终验证的不变量。在修改树的过程中，它将测试这些不变量是否被破坏，并在必要时通过旋转和颜色变化来恢复它们。这些不变量如下：
- en: An empty tree is black. (This can’t change, so there’s no need to verify it.)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空树是黑色的。（这不会改变，因此不需要验证。）
- en: The left and right subtrees of a red tree are black. In other words, it’s not
    possible to find two successive reds while descending the tree.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红树的左右子树都是黑色。换句话说，在向下遍历树的过程中，不可能找到两个连续的红色节点。
- en: Every path from the root to an empty subtree has the same number of blacks.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从根到每个空子树的所有路径都有相同数量的黑色节点。
- en: 'Inserting an element in a red-black tree is then a somewhat complex process
    that includes checking the invariants after insertion (and rebalancing, if necessary).
    Here’s the corresponding algorithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在红黑树中插入一个元素是一个相对复杂的过程，包括在插入后检查不变量（如果需要，还会进行重新平衡）。以下是相应的算法：
- en: An empty tree is always black.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空树始终是黑色的。
- en: Insertion proper is done exactly as in an ordinary tree, but is followed by
    balancing.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的插入操作与普通树完全相同，但随后会进行平衡。
- en: Inserting an element into an empty tree produces a red tree.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个元素插入到空树中会产生一个红色树。
- en: After balancing, the root is blackened.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡后，根节点变为黑色。
- en: '[Figures 11.1](#ch11fig01) through [11.7](#ch11fig07) illustrate insertion
    of integers 1 through 7 into an initially empty tree. [Figure 11.1](#ch11fig01)
    shows the insertion of element `1` into the empty tree. Because you’re inserting
    into an empty tree, the initial color is red. Once the element is inserted, the
    root is blackened.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.1](#ch11fig01)至[11.7](#ch11fig07)展示了将整数1到7插入到初始为空的树中的过程。[图11.1](#ch11fig01)展示了元素`1`被插入到空树中的情况。由于你是在向空树中插入，初始颜色是红色。一旦元素被插入，根节点变为黑色。'
- en: Figure 11.1\. Insertion of integers 1 through 7 into an initially empty tree,
    step 1
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1. 将整数1到7插入到初始为空的树中，步骤1
- en: '![](Images/11fig01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/11fig01.jpg)'
- en: '[Figure 11.2](#ch11fig02) shows the insertion of element `2`. The inserted
    element is red, the root is already black, and there’s still no need for balancing.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.2](#ch11fig02)展示了元素`2`的插入。插入的元素是红色，根节点已经是黑色，而且仍然不需要平衡。'
- en: Figure 11.2\. Insertion of integers 1 through 7 into an initially empty tree,
    step 2
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2. 将整数1到7插入到初始为空的树中，步骤2
- en: '![](Images/11fig02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/11fig02.jpg)'
- en: '[Figure 11.3](#ch11fig03) illustrates insertion of element `3`. The inserted
    element is red, and the tree is being balanced because it has two successive red
    elements. Because the red element now has two children, they are made black. (Children
    of a red element must always be black.) Eventually, the root is blackened.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.3](#ch11fig03) 说明了元素 `3` 的插入。插入的元素是红色，树正在平衡，因为它有两个连续的红色元素。因为红色元素现在有两个孩子，它们被设置为黑色。（红色元素的子节点必须是黑色。）最终，根被变黑。'
- en: Figure 11.3\. Insertion of integers 1 through 7 into an initially empty tree,
    step 3
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.3\. 将整数 1 至 7 插入初始为空的树中，第 3 步
- en: '![](Images/11fig03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig03.jpg)'
- en: '[Figure 11.4](#ch11fig04) shows the insertion of element `4`. No further manipulation
    is needed.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.4](#ch11fig04) 展示了元素 `4` 的插入。不需要进一步操作。'
- en: Figure 11.4\. Insertion of integers 1 through 7 into an initially empty tree,
    step 4
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.4\. 将整数 1 至 7 插入初始为空的树中，第 4 步
- en: '![](Images/11fig04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig04.jpg)'
- en: '[Figure 11.5](#ch11fig05) illustrates the insertion of element `5`. You now
    have two successive red elements, so the tree must be balanced by making `3` the
    left child of `4`. `4` becomes the right child of `2`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.5](#ch11fig05) 说明了元素 `5` 的插入。现在你有两个连续的红色元素，所以树必须通过将 `3` 作为 `4` 的左孩子来平衡。`4`
    成为 `2` 的右孩子。'
- en: Figure 11.5\. Insertion of integers 1 through 7 into an initially empty tree,
    step 5
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.5\. 将整数 1 至 7 插入初始为空的树中，第 5 步
- en: '![](Images/11fig05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig05.jpg)'
- en: '[Figure 11.6](#ch11fig06) shows the insertion of element `6`. No further manipulation
    is needed.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.6](#ch11fig06) 展示了元素 `6` 的插入。不需要进一步操作。'
- en: Figure 11.6\. Insertion of integers 1 through 7 into an initially empty tree,
    step 6
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.6\. 将整数 1 至 7 插入初始为空的树中，第 6 步
- en: '![](Images/11fig06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig06.jpg)'
- en: 'In [figure 11.7](#ch11fig07), element `7` is added to the tree. Because elements
    `6` and `7` are two successive red elements, the tree must be balanced. The first
    step is to make `5` the left child of `6`, and `6` the right child of `4`, which
    leaves again two successive red elements: `4` and `6`. The tree is then balanced
    again, making `4` the root, `2` the left child of `4`, and `3` the right child
    of `2`. The last operation consists of blackening the root.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11.7](#ch11fig07) 中，元素 `7` 被添加到树中。因为元素 `6` 和 `7` 是两个连续的红色元素，所以树必须平衡。第一步是将
    `5` 作为 `6` 的左孩子，将 `6` 作为 `4` 的右孩子，这又留下了两个连续的红色元素：`4` 和 `6`。然后树再次平衡，使 `4` 成为根，`2`
    成为 `4` 的左孩子，`3` 成为 `2` 的右孩子。最后的操作是使根变黑。
- en: Figure 11.7\. Insertion of integers 1 through 7 into an initially empty tree,
    step 7
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.7\. 将整数 1 至 7 插入初始为空的树中，第 7 步
- en: '![](Images/11fig07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig07.jpg)'
- en: 'The `balance` method takes the same arguments as the tree constructor: `color`,
    `left`, `value`, and `right`. These four parameters are tested for various patterns,
    and the result is constructed accordingly. In other words, the `balance` method
    replaces the tree constructor. Any process using the constructor should be modified
    to use this method instead.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`balance` 方法接受与树构造函数相同的参数：`color`、`left`、`value` 和 `right`。这四个参数被测试以适应各种模式，并据此构建结果。换句话说，`balance`
    方法替换了树构造函数。任何使用构造函数的过程都应该修改为使用此方法。'
- en: 'The following list shows how each pattern of arguments is transformed by this
    method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了每种参数模式如何通过此方法进行转换：
- en: (T B (T R (T R a x b) y c) z d) → (T R (T B a x b) y (T B c z d))
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (T B (T R (T R a x b) y c) z d) → (T R (T B a x b) y (T B c z d))
- en: (T B (T R a x (T R b y c)) z d) → (T R (T B a x b) y (T B c z d))
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (T B (T R a x (T R b y c)) z d) → (T R (T B a x b) y (T B c z d))
- en: (T B a x (T R (T R b y c) z d)) → (T R (T B a x b) y (T B c z d))
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (T B a x (T R (T R b y c) z d)) → (T R (T B a x b) y (T B c z d))
- en: (T B a x (T R b y (T R c z d))) → (T R (T B a x b) y (T B c z d))
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (T B a x (T R b y (T R c z d))) → (T R (T B a x b) y (T B c z d))
- en: (T color a x b) → (T color a x b)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (T color a x b) → (T color a x b)
- en: Each pair in parentheses corresponds to a tree. The letter T indicates a non-empty
    tree. B and R indicate the colors. Lowercase letters are placeholders for any
    value that could be valid at the corresponding place. Each left pattern (those
    to the left of the arrow, →) is applied in descending order, which means that
    if a match is found, the corresponding right pattern is applied as the resulting
    tree. This way of presenting things is very similar to the `switch ... case` instruction,
    with the last line being the default case.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的每一对对应一棵树。字母 T 表示非空树。B 和 R 表示颜色。小写字母是占位符，代表任何可能在该位置有效的值。每个左模式（箭头左侧的模式）按降序应用，这意味着如果找到匹配项，则将相应的右模式应用于结果树。这种呈现方式与
    `switch ... case` 指令非常相似，最后一行是默认情况。
- en: Exercise 11.1
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.1
- en: Write the `insert`, `balance`, and `blacken` methods for implementing insertion
    into the red-black tree. Unfortunately, Java doesn’t implement pattern matching,
    so you’ll have to use conditional instructions instead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `insert`、`balance` 和 `blacken` 方法以实现红黑树中的插入。不幸的是，Java 不实现模式匹配，所以你必须使用条件指令。
- en: Hint
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Write an `ins` method that will perform a regular insertion, and then replace
    constructor calls with calls to the `balance` method. Next, write the `blacken`
    method, and finally write the `insert` method in the parent class, calling `blacken`
    on the result of `ins`. All these methods should be protected, except for the
    `insert` method, which will be public.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `ins` 方法，执行常规插入，然后使用 `balance` 方法的调用替换构造函数调用。接下来，编写 `blacken` 方法，最后在父类中编写
    `insert` 方法，在 `ins` 的结果上调用 `blacken`。所有这些方法都应该是受保护的，除了 `insert` 方法，它将是公共的。
- en: Solution 11.1
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.1
- en: 'For once, I don’t recommended using the conditional operator. It’s much easier
    to represent the patterns with a succession of `if` sections, each containing
    a `return`. Here’s the `balance` method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一次，我不建议使用条件运算符。使用一系列 `if` 部分来表示模式要容易得多，每个部分都包含一个 `return`。以下是 `balance` 方法：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each `if` section implements one of the patterns listed before this exercise.
    If you want to compare them, it’s probably much easier to do so in a text editor
    than on a printed page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `if` 部分实现了在此练习之前列出的一个模式。如果您想比较它们，在文本编辑器中可能比在打印页面上更容易做到。
- en: 'The `ins` method is very similar to what you did in the standard BST, with
    the exception that the `balance` method replaces the `T` constructor (plus there’s
    the additional `color` parameter). Here’s the implementation in the `T` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ins` 方法与你在标准二叉搜索树（BST）中做的非常相似，唯一的区别是 `balance` 方法替换了 `T` 构造函数（此外还有一个额外的 `color`
    参数）。以下是 `T` 类中的实现：'
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And here’s the implementation in the `E` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `E` 类中的实现：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `blacken` method is implemented in the `Tree` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`blacken` 方法在 `Tree` 类中实现：'
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, the `insert` method is defined in the `Tree` class and returns the
    blackened result of `ins`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`insert` 方法在 `Tree` 类中定义，并返回 `ins` 的黑化结果：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Removing elements from a red-black tree
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从红黑树中删除元素
- en: 'Removing an element from a red-black tree is discussed by Kimball Germane and
    Matthew Might in an article titled “The missing method: Deleting from Okasaki’s
    red-black trees” ([http://matt.might.net/articles/red-black-delete/](http://matt.might.net/articles/red-black-delete/)).
    The implementation in Java is too long to include in this book, but it’s included
    in the accompanying code ([http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava)).
    It will be used in the next exercise.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从红黑树中删除元素由 Kimball Germane 和 Matthew Might 在一篇题为“缺失的方法：从 Okasaki 的红黑树中删除”的文章中讨论（[http://matt.might.net/articles/red-black-delete/](http://matt.might.net/articles/red-black-delete/))。Java
    中的实现太长，无法包含在这本书中，但它包含在配套代码中（[http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava)）。它将在下一个练习中使用。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '11.2\. A use case for the red-black tree: maps'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 红黑树的一个应用案例：映射
- en: Trees of integers are not often useful (although sometimes they are). One very
    important use of binary search trees is *maps*, also called *dictionaries* or
    *associative arrays*. Maps are collections of key/value pairs that allow insertion,
    removal, and fast retrieval of each pair. Maps are familiar to Java programmers,
    and Java offers several implementations, among which the most common are the `HashMap`
    and the `TreeMap`. However, these maps can’t be used in a multithreaded environment
    without using some protection mechanisms that are difficult to design correctly
    and to use (although concurrent versions are available for this kind of use).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 整数树通常不很有用（尽管有时它们是有用的）。二叉搜索树的一个重要用途是映射，也称为字典或关联数组。映射是一组键/值对，允许插入、删除和快速检索每一对。映射对Java程序员来说很熟悉，Java提供了几种实现，其中最常见的是`HashMap`和`TreeMap`。然而，这些映射在没有使用一些难以正确设计和使用的保护机制的情况下不能在多线程环境中使用（尽管有可用于此类用途的并发版本）。
- en: 11.2.1\. Implementing Map
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1\. 实现映射
- en: Functional trees, like the red-black tree you’ve developed, have the advantage
    of immutability, which allows you to use them in multithreaded environments without
    bothering about locks and synchronization. The next listing shows the interface
    of a `Map` that can be implemented using the red-black tree.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数树，如你开发的红黑树，具有不可变性的优势，这允许你在多线程环境中使用它们，而不必担心锁和同步。下一个列表显示了可以使用红黑树实现的`Map`接口。
- en: Listing 11.2\. A functional map
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.2\. 一个函数式映射
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exercise 11.2
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.2
- en: Complete the `Map` class by implementing all methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现所有方法来完善`Map`类。
- en: Hint
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You should use a delegate. From this delegate, all methods can be implemented
    in one line of code. The only (very easy) problem is choosing how you’ll store
    data in the map.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用一个委托。从这个委托中，所有方法都可以用一行代码实现。唯一（非常简单）的问题是选择你如何在映射中存储数据。
- en: Solution 11.2
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.2
- en: 'The solution is to create a component to represent the key/value pair, and
    to store instances of this component in a tree. This component is very similar
    to a `Tuple`, with an important difference: it must be comparable, and the comparison
    must be based on the `key`. The `equals` and `hashCode` methods will also be based
    on key equality and hash codes. Here’s a possible implementation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个表示键/值对的组件，并将该组件的实例存储在树中。这个组件与`Tuple`非常相似，但有一个重要的区别：它必须是可比较的，比较必须基于`key`。`equals`和`hashCode`方法也将基于键的相等性和哈希码。以下是一个可能的实现：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implementing the `Map` component is now just a matter of delegating all operations
    to a `Tree<MapEntry<Key, Value>>`. Here’s a possible implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Map`组件现在只是将所有操作委托给`Tree<MapEntry<Key, Value>>`的问题。以下是一个可能的实现：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 11.2.2\. Extending maps
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2\. 扩展映射
- en: 'Not all tree operations have been delegated because some operations don’t make
    much sense in the current conditions. But you may need additional operations in
    some special use cases. Implementing these operations is easy: extend the `Map`
    class and add delegating methods. For example, you might need to find the object
    with the maximal or minimal key. Another possible need is to fold the map, perhaps
    to get a list of the contained values. Here’s an example of delegating the `foldLeft`
    method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有树操作都进行了委托，因为有些操作在当前条件下没有太多意义。但某些特殊用例可能需要额外的操作。实现这些操作很简单：扩展`Map`类并添加委托方法。例如，你可能需要找到具有最大或最小键的对象。另一个可能的需求是将映射折叠起来，例如获取包含值的列表。以下是一个委托`foldLeft`方法的示例：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generally, folding maps occur in very specific use cases that deserve to be
    abstracted inside the `Map` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，折叠映射发生在非常具体的用例中，这些用例值得在`Map`类内部进行抽象。
- en: Exercise 11.3
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.3
- en: Write a `values` method in the `Map` class that returns a list of the values
    contained in the map in ascending key order.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Map`类中编写一个`values`方法，该方法按升序键顺序返回映射中包含的值的列表。
- en: Hint
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You might have to create a new folding method in the `Tree` class and delegate
    to it from the `Map` class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要在`Tree`类中创建一个新的折叠方法，并从`Map`类中委托给它。
- en: Solution 11.3
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.3
- en: There are several possible implementations of the `values` method. It would
    be possible to delegate to the `foldInOrder` method, but this method iterates
    over the tree values in ascending order. Using this method to construct a list
    would result in a list in descending order. You could reverse the result, but
    this wouldn’t be very efficient.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`values` 方法的实现有几种可能。可以委托给 `foldInOrder` 方法，但这个方法按升序遍历树值。使用此方法构造列表将导致列表按降序排列。你可以反转结果，但这不会很高效。'
- en: 'A much better solution is to add a `foldInReverseOrder` method into the `Tree`
    class. Recall the `foldInOrder` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是在 `Tree` 类中添加一个 `foldInReverseOrder` 方法。回想一下 `foldInOrder` 方法：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All you have to do is reverse the order:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所要做的就是反转顺序：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As usual, the `Empty` implementation returns `identity`. Now you can delegate
    to this method from inside the `Map` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，`Empty` 实现返回 `identity`。现在你可以从 `Map` 类内部委托给这个方法：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you have a problem with the types, you can write the function with explicit
    types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有类型问题，你可以用显式类型编写函数：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 11.2.3\. Using Map with noncomparable keys
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.3\. 使用不可比较键的 Map
- en: 'The `Map` class is useful and relatively efficient, but it has a big disadvantage
    compared to the maps you may be used to: the keys must be comparable. The types
    used for keys are usually comparable, such as integers or strings, but what if
    you need to use a noncomparable type for the keys?'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 类很有用且相对高效，但与您可能习惯的映射相比有一个很大的缺点：键必须是可比较的。用于键的类型通常是可比较的，例如整数或字符串，但如果你需要使用不可比较的类型作为键呢？'
- en: Exercise 11.4
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.4
- en: Implement a version of `Map` that works with noncomparable keys.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个使用不可比较键的 `Map` 版本。
- en: Hint
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: There are two things to modify. First, the `MapEntry` class should be made comparable,
    although the key is not. Second, non-equal values might happen to be held in equal
    map entries, so collisions should be resolved by keeping both colliding entries.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事需要修改。首先，`MapEntry` 类应该是可比较的，尽管键不是。其次，可能发生非相等值恰好被存储在相等的映射条目中，因此应该通过保留两个冲突条目来解决冲突。
- en: Solution 11.4
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.4
- en: 'The first thing to do is to modify the `MapEntry` class by removing the need
    for the key to be comparable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是修改 `MapEntry` 类，移除键需要可比较的要求：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the `MapEntry` class is still comparable, although the `K` type is
    not.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `K` 类型不是，`MapEntry` 类仍然是可比较的。
- en: 'Second, you must use a different implementation for the `compareTo` method.
    One possibility is to compare the map entries based on key hash code comparison:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你必须为 `compareTo` 方法使用不同的实现。一种可能性是基于键哈希码比较来比较映射条目：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then you must handle collisions that happen when two map entries have different
    keys with the same hash code. In such cases, you should keep both of them. The
    simplest solution is to store the map entries in a list, and to do this, you must
    modify the `Map` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须处理当两个映射条目具有相同哈希码的不同键时发生的冲突。在这种情况下，应该保留它们两个。最简单的解决方案是将映射条目存储在列表中，为此，你必须修改
    `Map` 类。
- en: 'First, the tree delegate will have a modified type:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，树代理将有一个修改后的类型：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, you must change the constructor that takes the delegate as a parameter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须更改接受代理作为参数的构造函数：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, you’ll need a method to retrieve the list of key/value tuples corresponding
    to the same key hash code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一个方法来检索与相同键哈希码对应的关键字/值元组的列表：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can next define the `add`, `contains`, `remove`, and `get` methods in terms
    of the `getAll` method. Here’s the `add` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义 `add`、`contains`、`remove` 和 `get` 方法，这些方法基于 `getAll` 方法。以下是 `add` 方法：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the `contains` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `contains` 方法：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here’s the `remove` method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `remove` 方法：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, the `min` and `max` methods need to be removed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要删除 `min` 和 `max` 方法。
- en: With these modifications, the `Map` class can be used with noncomparable keys.
    Using a list for storing the key/value tuples may not be the most efficient implementation,
    because searching in a list takes an amount of time proportional to the number
    of elements. But in most cases the list will contain only one element, so the
    search will return in no time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些修改，`Map` 类可以用于不可比较的键。使用列表存储键/值元组可能不是最有效的实现，因为列表中的搜索需要与元素数量成比例的时间。但在大多数情况下，列表中只包含一个元素，因此搜索将立即返回。
- en: One thing to note about this implementation is that the `remove` method tests
    whether the resulting list of tuples is empty. If it is, it calls the `remove`
    method on the delegate. Otherwise, it calls the `insert` method to re-insert the
    new list from which the corresponding entry has been deleted. Recall exercise
    10.1 from [chapter 10](kindle_split_017.xhtml#ch10). This is possible only because
    you decided to implement insert in such a way that an element found equal to an
    element present in the map would be inserted in place of the original one. If
    you hadn’t done this, you’d have had to first remove the element and then insert
    the new one with the modified list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种实现的一个需要注意的事项是，`remove` 方法会检查生成的元组列表是否为空。如果是，它会在代理上调用 `remove` 方法。否则，它会调用
    `insert` 方法重新插入从其中删除相应条目的新列表。回想一下第 10 章的练习 10.1。[第 10 章](kindle_split_017.xhtml#ch10)。这之所以可能，仅仅是因为你决定以这种方式实现插入，即如果找到与映射中存在的元素相等的元素，则将其插入原位置。如果你没有这样做，你将不得不首先删除元素，然后使用修改后的列表插入新元素。
- en: 11.3\. Implementing a functional priority queue
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 实现功能优先队列
- en: As you know, a queue is a kind of list with a specific access protocol. Queues
    can be single-ended, like the singly linked list you’ve used so often in previous
    chapters. In that case, the access protocol is last in, first out (LIFO). A queue
    can also be double-ended, allowing the first in, first out (FIFO) access protocol.
    But there are also data structures with more-specialized protocols. Among them
    is the *priority queue*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，队列是一种具有特定访问协议的列表。队列可以是单端队列，就像你在前几章中经常使用的单链表一样。在这种情况下，访问协议是后进先出（LIFO）。队列也可以是双端队列，允许先进先出（FIFO）的访问协议。但也有一些具有更特殊协议的数据结构。其中之一是*优先队列*。
- en: 11.3.1\. The priority queue access protocol
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. 优先队列的访问协议
- en: Values can be inserted in a priority queue in any order, but they can only be
    retrieved in a very specific order. All values have a priority level, and only
    the element with the highest priority is available. Priority is represented by
    an ordering of the elements, which implies that the elements must be comparable
    in some way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以以任何顺序插入到优先队列中，但它们只能以非常特定的顺序检索。所有值都有一个优先级级别，并且只有具有最高优先级的元素是可用的。优先级通过元素的排序来表示，这意味着元素必须在某种程度上是可比较的。
- en: The priority corresponds to the position of the elements in a theoretical waiting
    queue. The highest priority belongs to the element with the lowest position (the
    first element). So, by convention, the highest priority is represented by the
    lowest value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级对应于理论等待队列中元素的位置。最高优先级属于位置最低的元素（即第一个元素）。因此，按照惯例，最高优先级用最低的值来表示。
- en: Because a priority queue will contain comparable elements, this makes it a good
    fit for a tree-like structure. But from the user’s perspective, the priority queue
    is seen as a list, with a head (the element with the highest priority, meaning
    the lowest value) and a tail (the rest of the queue).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于优先队列将包含可比较的元素，这使得它非常适合树状结构。但从用户的角度来看，优先队列被视为一个列表，有一个头部（具有最高优先级的元素，即最低的值）和一个尾部（队列的其余部分）。
- en: 11.3.2\. Priority queue use cases
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 优先队列的使用场景
- en: The priority queue has many different use cases. One that comes to mind quickly
    is sorting. You could insert elements into a priority queue in random order and
    retrieve them sorted. This isn’t the main use case for this structure, but it
    may be useful for sorting small data sets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列有许多不同的使用场景。一个很快就能想到的是排序。你可以在随机顺序中将元素插入到优先队列中，然后按顺序检索它们。这不是这种结构的主要使用场景，但它可能对排序小型数据集很有用。
- en: Another very common use case is reordering elements after asynchronous parallel
    processing. Let’s say you have a number of pages of data to process. To speed
    processing, you can distribute the data to several threads that will work in parallel.
    But there’s no guarantee that the threads will give back their work in the same
    order that they received it. To resynchronize the pages, you can put them in a
    priority queue. The process that is supposed to consume the pages will then poll
    the queue to check if the available element (the head of the queue) is the expected
    one. For example, if pages 1, 2, 3, 4, 5, 6, 7, and 8 are given to eight threads
    to be processed in parallel, the consumer will poll the queue to see if [page
    1](kindle_split_008.xhtml#ch01) is available. If it is, it will consume it. If
    not, it will just wait.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的用例是在异步并行处理后重新排序元素。假设你有大量数据页面需要处理。为了加快处理速度，你可以将数据分配给多个线程并行工作。但是，没有保证线程将以接收它们的相同顺序返回工作。为了重新同步页面，你可以将它们放入优先队列。然后，应该消费页面的进程将轮询队列以检查是否有可用的元素（队列的头部）是预期的。例如，如果将1、2、3、4、5、6、7和8页分配给八个线程并行处理，消费者将轮询队列以查看[第1页](kindle_split_008.xhtml#ch01)是否可用。如果是，它将消费它。如果不是，它将只是等待。
- en: In such a scenario, the queue acts both as a buffer and as a way to reorder
    the elements. This will generally imply limited variation in size, because elements
    will be removed from the queue more or less at the same speed they’re inserted.
    Of course, this is true if the consumer consumes elements at approximately the
    same pace as they’re produced by the eight threads. If it isn’t the case, it may
    be possible to use several consumers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，队列既充当缓冲区，也充当重新排序元素的方式。这通常意味着大小变化有限，因为元素将从队列中以大致相同的速度被移除。当然，这是在消费者以与生产者相同的速度消费元素的情况下成立的。如果不是这样，可能可以使用多个消费者。
- en: As I said earlier, choosing an implementation is generally a matter of trading
    space against time or time against time. Here, the choice you have to make is
    between insertion and retrieval times. In the general use case, retrieval time
    must be optimized over insertion time because the ratio between the numbers of
    insertion and retrieval operations will generally be largely in favor of retrieval.
    (Often the head will be read but not removed.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，选择实现通常是一个权衡空间和时间或时间与时间的问题。在这里，你必须做出的选择是在插入和检索时间之间。在一般用例中，检索时间必须比插入时间优化，因为插入和检索操作的数量比通常将大大有利于检索。（通常头部会被读取但不会被移除。）
- en: 11.3.3\. Implementation requirements
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3. 实现要求
- en: You could implement a priority queue based on the red-black tree, because finding
    the minimum value is fast. But retrieval doesn’t mean removal. If you search for
    the minimum value and find that it’s not the one you want, you’ll have to come
    back later and search again. One solution to this problem could be to memoize
    the lowest value on insertion. The other change you may want to make is in regard
    to removal. Removing an element is relatively fast, but because you’ll always
    be removing the lowest element, you might be able to optimize the data structure
    for this operation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现一个基于红黑树的优先队列，因为查找最小值非常快。但检索并不意味着删除。如果你搜索最小值，却发现它不是你想要的，你将不得不稍后回来再次搜索。解决这个问题的一个方案可能是在插入时缓存最小值。你可能还想做的另一个改变是关于删除。删除一个元素相对较快，但由于你总是删除最小元素，你可能能够优化数据结构以适应这种操作。
- en: Another important problem would be in regard to duplicates. Although the red-black
    tree doesn’t allow duplicates, the priority queue must, because it’s perfectly
    possible to have several elements with the same priority. The solution can be
    the same as for maps—storing lists of elements (instead of single elements) with
    the same priority—but this will probably not be optimal for performance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的问题将涉及到重复项。尽管红黑树不允许重复项，但优先队列必须允许，因为完全可能存在具有相同优先级的多个元素。解决方案可以与映射相同——存储具有相同优先级的元素列表（而不是单个元素），但这可能不会对性能最优。
- en: 11.3.4\. The leftist heap data structure
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.4. 左式堆数据结构
- en: 'To meet your requirements for the priority queue, you’ll use the “leftist heap”
    described by Okasaki in his book, *Purely Functional Data Structures*.^([[3](#ch11fn03)])
    This data structure meets the requirements for the priority queue. Okasaki defines
    the leftist heap as a “heap-ordered tree with an additional leftist property”:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足您对优先队列的要求，您将使用 Okasaki 在其书籍《纯函数式数据结构》中描述的“左侧堆”。^([[3](#ch11fn03)]) 这种数据结构满足优先队列的要求。Okasaki
    将左侧堆定义为“具有额外左侧属性的堆有序树”：
- en: ³
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leftist heaps were first described by Clark Allan Crane in “Linear lists and
    priority queues as balanced binary trees,” (1972), but Okasaki was one of the
    first to publish a purely functional implementation.
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 左侧堆最初由 Clark Allan Crane 在“线性列表和优先队列作为平衡二叉树”（1972年）中描述，但 Okasaki 是最早发布纯函数式实现的人之一。
- en: A heap-ordered tree is a tree in which each branch of an element is greater
    than or equal to the element itself. This guarantees that the lowest element in
    the tree is always the root element, making access to the lowest value instantaneous.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆有序树是一种树，其中每个元素的分支都大于或等于该元素本身。这保证了树中的最低元素总是根元素，使得访问最低值是瞬时的。
- en: The “leftist” property means that, for each element, the left branch *rank*
    is greater than or equal to the right branch rank.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “左侧”属性意味着，对于每个元素，左侧分支 *rank* 大于或等于右侧分支 rank。
- en: The *rank* of an element is the length of the right path (also called the right
    *spine*) to an empty element. The leftist property guarantees that the shortest
    path from any element to an empty element is the right path. A consequence of
    this is that elements are always found in ascending order along any descending
    path.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个元素的 *rank* 是到达一个空元素右侧路径（也称为右侧 *脊*）的长度。左侧属性保证了从任何元素到空元素的最短路径是右侧路径。这一结果的后果是，元素总是按照升序沿任何下降路径找到。
- en: '[Figure 11.8](#ch11fig08) shows an example of a leftist tree.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.8](#ch11fig08) 展示了一个左侧树的示例。'
- en: Figure 11.8\. A heap-ordered leftist tree, showing that each branch of an element
    is higher than or equal to the element itself, and each left branch rank is greater
    than or equal to the corresponding right branch rank
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.8\. 堆有序的左侧树，显示每个元素的分支都高于或等于该元素本身，并且每个左侧分支的 rank 都大于或等于相应的右侧分支 rank
- en: '![](Images/11fig08.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig08.jpg)'
- en: As you can see, retrieving the highest priority element is possible in constant
    time because it will always be the root of the tree. This element will be called
    the “head” of the structure. Removing an element, by analogy with a list, will
    consist of returning the rest of the tree once the root has been removed. This
    returned value will be called the “tail” of the structure.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，检索最高优先级元素是可能的，因为这将始终是树的根。这个元素将被称为结构的“头”。通过类比列表，移除一个元素将包括在移除根之后返回树的其余部分。这个返回值将被称为结构的“尾”。
- en: 11.3.5\. Implementing the leftist heap
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.5\. 实现左侧堆
- en: The leftist heap main class will be called `Heap` and will be a tree implementation.
    The basic structure is shown in [listing 11.3](#ch11ex03). The main difference
    from the trees you’ve been developing up to now is that methods such as `right`,
    `left`, and `head` (equivalent to what you called `value` in previous examples)
    will return a `Result` instead of raw values. Note also that the number of elements
    is called `length` (by analogy with a queue) and that the memoized `length` and
    `rank` will be computed by the callers of the constructor instead of by the constructor
    itself. This is an unmotivated design choice, just to show another way of doing
    things. The constructors are private, so the difference won’t leak outside the
    `Heap` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧堆的主类将被命名为 `Heap`，并且将是一个树形实现。其基本结构在[列表 11.3](#ch11ex03)中展示。与您至今为止所开发的树相比，主要区别在于
    `right`、`left` 和 `head`（在之前的例子中您称之为 `value`）等方法将返回一个 `Result` 而不是原始值。请注意，元素的个数被称为
    `length`（类比于队列），而缓存的 `length` 和 `rank` 将由构造函数的调用者计算，而不是由构造函数本身计算。这是一个没有明确动机的设计选择，只是为了展示另一种做事的方式。构造函数是私有的，所以这种差异不会泄露到
    `Heap` 类外部。
- en: Listing 11.3\. The leftist heap structures
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 左侧堆结构
- en: '![](Images/ch11ex03-0.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch11ex03-0.jpg)'
- en: '![](Images/ch11ex03-1.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch11ex03-1.jpg)'
- en: '![](Images/309fig01b_alt.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/309fig01b_alt.jpg)'
- en: Exercise 11.5
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.5
- en: 'The first functionality you’ll want to add to your `Heap` implementation is
    the ability to add an element. Define an `add` method for this. Make it an instance
    method in the `Heap` class with the following signature:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要添加到你的`Heap`实现中的第一个功能是添加一个元素的能力。为此定义一个`add`方法。将其作为`Heap`类中的一个实例方法，其签名如下：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The requirement is that if the value is smaller than any element in the heap,
    it should become the root of the new heap. Otherwise, the root of the heap shouldn’t
    change. Also, the other requirements about rank and length of the right path should
    be respected.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要求是在值小于堆中任何元素的情况下，它应成为新堆的根。否则，堆的根不应改变。还应遵守关于右路径等级和长度的其他要求。
- en: Hint
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'Define a static method to create a `Heap` from an element, and another to create
    a heap by merging two heaps, with the following signatures:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个静态方法来从一个元素创建一个`Heap`，另一个方法是通过合并两个堆来创建一个堆，其签名如下：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then define the `add` method in terms of those two.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后根据这两个定义`add`方法。
- en: Solution 11.5
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.5
- en: 'The method for creating a heap from a single element is simple. Just create
    a new tree with length 1, rank 1; the parameter element as the head; and two empty
    heaps as the left and right branches:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个元素创建堆的方法很简单。只需创建一个长度为1，等级为1的新树；参数元素作为头；以及两个空堆作为左右分支：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Creating a heap by merging two heaps is a bit more complicated. For this, you’ll
    need an additional helper method that creates a heap from one element and two
    heaps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过合并两个堆来创建堆要复杂一些。为此，你需要一个额外的辅助方法，该方法可以从一个元素和两个堆创建一个堆：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code first checks whether the first heap’s rank is greater than or equal
    to the second one. If the first heap’s rank is greater than or equal, the new
    rank is set to the rank of the second heap + 1, and the two heaps are used in
    first, second order. Otherwise, the new rank is set to the rank of the first heap
    + 1, and the two heaps are used in reverse order (second, first).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先检查第一个堆的等级是否大于或等于第二个堆。如果第一个堆的等级大于或等于，则新等级设置为第二个堆的等级 + 1，并且两个堆按第一、第二顺序使用。否则，新等级设置为第一个堆的等级
    + 1，并且两个堆按相反顺序（第二、第一）使用。
- en: 'Now the method to merge two heaps can be written as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以编写合并两个堆的方法如下：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Of course, if one of the heaps to be merged is empty, you return the other one.
    Otherwise, you compute the result of the merge.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果要合并的堆之一为空，则返回另一个堆。否则，计算合并的结果。
- en: 'If you find this code difficult to understand (and by now I hope you don’t),
    it’s simply the fully functional equivalent of the following less-functional implementations:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现这段代码难以理解（到现在我希望你没有），它只是以下不太有效的实现的全功能等价物：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As a general rule, you should always remember that calling `successValue`, like
    `getOrThrow`, could throw an exception if the `Result` is `Empty`. You could either
    test for emptiness first (as in the first example above), or include the code
    in a `try ... catch` block (as in the second example), but none of these solutions
    is really functional.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你应该始终记住，调用`successValue`，就像`getOrThrow`一样，如果`Result`是`Empty`，可能会抛出异常。你可以先测试空值（如上面的第一个示例），或者将代码包含在`try
    ... catch`块中（如第二个示例），但上述任何解决方案都不是真正有效的。
- en: By the way, you should try to avoid calling `successValue` and `getOrThrow`.
    The `successValue` method should only be used inside the `Result` class. The best
    solution for enforcing this would be to make it protected, but it’s useful to
    use it while learning, to see what’s happening.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你应该尽量避免调用`successValue`和`getOrThrow`。`successValue`方法应该只在使用`Result`类内部时使用。强制执行此操作的最佳解决方案是将其设置为受保护的，但在学习时使用它是很有用的，以便了解发生了什么。
- en: 'With these methods defined, it’s easy to create the `add` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些方法后，创建`add`方法就很容易了：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 11.3.6\. Implementing the queue-like interface
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.6\. 实现类似队列的接口
- en: Although it’s implemented as a tree, the heap, from the user’s perspective,
    is like a priority queue, which means a kind of linked list where the head is
    always the smallest element. By analogy, the root element of the tree is called
    the `head`, and what remains after having “removed” the `head` is called the `tail`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它被实现为一个树，但从用户的角度来看，堆就像是一个优先队列，这意味着一种链表，其中头始终是最小的元素。通过类比，树的根元素被称为`head`，而“移除”头之后剩下的部分被称为`tail`。
- en: Exercise 11.6
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.6
- en: 'Define a `tail` method that returns what’s left after removing the `head`.
    This method, like the `head` method, returns a `Result` in order to make it safe
    when it’s called on an empty queue. Here’s its signature in the `Heap` parent
    class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `tail` 方法，它返回移除 `head` 后剩余的内容。这个方法，就像 `head` 方法一样，返回一个 `Result` 以确保在空队列上调用时的安全性。这是它在
    `Heap` 父类中的签名：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Solution 11.6
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.6
- en: 'The `Empty` implementation is obvious and returns a `Failure`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 的实现很明显，并返回一个 `Failure`：'
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `H` implementation is no more complex, given the methods you defined in
    the previous exercise. It simply returns the result of merging the left and right
    branches:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个练习中定义的方法的基础上，`H` 的实现并不复杂，它只是简单地返回合并左右分支的结果：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Exercise 11.7
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.7
- en: 'Implement a `get` method that takes an `int` parameter and returns the *n*^(th)
    element by priority order. This method will return a `Result` to handle the case
    where no element is found. Here’s its signature in the `Heap` parent class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个 `get` 方法，它接受一个 `int` 参数，并按优先级顺序返回第 *n* 个元素。这个方法将返回一个 `Result` 以处理找不到元素的情况。这是它在
    `Heap` 父类中的签名：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Solution 11.7
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.7
- en: 'The `Empty` implementation is obvious and will return a failure:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 的实现很明显，将返回一个失败：'
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `H` implementation is equally simple. It starts by testing the index. If
    it’s 0, it returns a `Success` of the `head` value. Otherwise, it recursively
    searches for the element of index *n* - 1 in the tail. Because the tail doesn’t
    really exist, but is only the value returned by the `getTail` method (which is
    a `Result`), this result is flat-mapped with a recursive call to `get`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`H` 的实现同样简单。它首先测试索引。如果是 0，它返回 `head` 值的 `Success`。否则，它递归地在尾部搜索索引 *n* - 1 的元素。因为尾部实际上并不存在，它只是
    `getTail` 方法返回的值（这是一个 `Result`），所以这个结果通过递归调用 `get` 进行扁平映射：'
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 11.4\. A priority queue for noncomparable elements
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4. 非可比较元素的优先队列
- en: To insert elements into a priority queue, you must be able to compare their
    priorities. But priority isn’t always a property of elements; not all elements
    implement the `Comparable` interface. Elements that don’t implement this interface
    can still be compared using a `Comparator`, so can you do this for your priority
    queue?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要将元素插入到优先队列中，你必须能够比较它们的优先级。但优先级并不总是元素的一个属性；并非所有元素都实现了 `Comparable` 接口。没有实现此接口的元素仍然可以使用
    `Comparator` 进行比较，那么你能否为你的优先队列实现这一点？
- en: Exercise 11.8
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.8
- en: Modify the `Heap` class so that it can be used either with `Comparable` elements
    or with a separate `Comparator`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `Heap` 类，使其可以使用 `Comparable` 元素或单独的 `Comparator`。
- en: Solution 11.8
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.8
- en: First, you can add a method to the `Heap` class that will return the `Comparator`.
    Because the comparator is optional, this method will return a `Result<Comparator>`
    that will potentially be empty.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以在 `Heap` 类中添加一个方法，该方法将返回 `Comparator`。因为比较器是可选的，所以这个方法将返回一个可能为空的 `Result<Comparator>`。
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can then implement it in both subclasses. The `Empty` implementation will
    return the value of an added property that will be initialized in a constructor:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在两个子类中实现它。`Empty` 的实现将返回一个在构造函数中初始化的已添加属性的值：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will, of course, do the same in the `H` class, with the difference that
    you’ll modify the existing constructor rather than create a new one:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也会在 `H` 类中做同样的事情，不同之处在于你将修改现有的构造函数而不是创建一个新的：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You’ll then have to update the factory methods. But before you do that, you
    must change the type parameter for the classes, replacing this
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须更新工厂方法。但在你这样做之前，你必须更改类的类型参数，替换为这个
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'with this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The same modification should be applied to the subclass constructors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 应将相同的修改应用于子类构造函数。
- en: 'The static factory method for creating an empty `Heap` will take an additional
    `Result<Comparator>` argument, and you’ll need to add a new method using a default
    `Result.Empty`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 创建空 `Heap` 的静态工厂方法将接受一个额外的 `Result<Comparator>` 参数，并且你需要添加一个使用默认 `Result.Empty`
    的新方法：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that I have also added a method taking a `Comparator<A>` instead of a `Result<Comparable>`
    in order to make using the `Heap` class easier. This method will be used mainly
    from outside of the `Heap` class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我还添加了一个接受 `Comparator<A>` 而不是 `Result<Comparable>` 的方法，以便更容易地使用 `Heap` 类。这个方法主要将从
    `Heap` 类外部使用。
- en: You will, however, keep an `empty` method taking no parameter. This method will
    still need to be parameterized with a `Comparable` type. Otherwise, you’d risk
    getting a `ClassCastException` later.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你将保留一个不带参数的 `empty` 方法。这个方法仍然需要使用一个 `Comparable` 类型进行参数化。否则，你可能会在以后的风险中遇到
    `ClassCastException`。
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By using a `Comparable` type, you can be sure you get a compiler error instead
    of a runtime exception.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Comparable` 类型，你可以确保你得到的是编译器错误而不是运行时异常。
- en: 'You can now do the same for the methods that create a `Heap` from a single
    element:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你也可以对创建单个元素 `Heap` 的方法做同样的处理：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The method taking an element and two heaps needs to be modified accordingly,
    but this time, you’ll extract the comparator from the heap arguments:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修改接受一个元素和两个 `Heap` 的方法，但这次，你将从堆参数中提取比较器：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the `merge` method, you can use the `Comparator` from either of the two
    trees to be merged. If none have a `Comparator`, you can use a `Result.Empty`.
    In order to not extract the comparator from the arguments on each recursive call,
    you can split the method in two:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `merge` 方法，你可以使用要合并的两个树中的任何一个的 `Comparator`。如果没有 `Comparator`，你可以使用 `Result.Empty`。为了不在每次递归调用中从参数中提取比较器，你可以将方法分成两部分：
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The second method uses a `helper` method called `compare`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法使用了一个名为 `compare` 的 `helper` 方法：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This method performs a cast of one of its arguments, but you know you aren’t
    risking a `ClassCastException` being thrown because you ensured that no heap could
    be created without a comparator if the type parameter didn’t extend `Comparable`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法对其参数之一进行强制类型转换，但你知道你不会冒 `ClassCastException` 被抛出的风险，因为如果你确保没有比较器就不能创建堆，如果类型参数没有扩展
    `Comparable`。
- en: 'Now the static final `EMPTY` singleton can be removed. The `add` method must
    also be modified as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，静态最终 `EMPTY` 单例可以被移除。`add` 方法也必须按以下方式修改：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, the `left` and `right` methods in the `Empty` class must be changed
    as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Empty` 类中的 `left` 和 `right` 方法必须按以下方式更改：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Exercise 11.9
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.9
- en: 'So far, the only way you had to add an element to a `Heap` is through the `merge`
    method. Implement an `insert` method that adds an element without resorting to
    `merge`. Define an abstract method in the `Heap` parent class with the following
    signature:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你向 `Heap` 添加元素的唯一方法是通过 `merge` 方法。实现一个 `insert` 方法，在不使用 `merge` 的情况下添加元素。在
    `Heap` 父类中定义一个抽象方法，其签名如下：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Hint
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You should reuse the `compare` method from the previous exercise.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该重用之前练习中的 `compare` 方法。
- en: Solution 11.9
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.9
- en: 'The `Empty` implementation just calls the `heap` factory method, passing it
    the value to be inserted and two references to `this`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 的实现只是调用 `heap` 工厂方法，传递要插入的值和两个对 `this` 的引用：'
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `H` class, the algorithm you need to implement is simple. Let’s call
    `a` the element to be inserted. You must build a new `H` with a `head`, a `left`,
    and a `right`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `H` 类中，你需要实现算法很简单。让我们称 `a` 为要插入的元素。你必须构建一个新的 `H`，包含一个 `head`、一个 `left` 和一个
    `right`：
- en: If this `head` is lower than `a`, keep it as the current `head`. Else use `a`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这个 `head` 比 `a` 低，保持它作为当前 `head`。否则使用 `a`。
- en: Keep the left branch as is.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持左分支不变。
- en: If the `head` is higher than `a`, recursively insert the `head` into the right
    branch.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `head` 比 `a` 高，递归地将 `head` 插入到右分支。
- en: Else, recursively insert `a` into the right branch.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，递归地将 `a` 插入到右分支。
- en: 'Here’s the code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This code isn’t optimized because you call `compare` twice with the same argument.
    You could call it once and cache the result, which also makes the code easier
    to read:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有优化，因为你用相同的参数调用了 `compare` 两次。你可以只调用一次并缓存结果，这也会使代码更容易阅读：
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Looks nice? Not so.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错？其实不然。
- en: Exercise 11.10
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 11.10
- en: Running the solution to exercise 11.9 on a `Heap<Integer>` will work, but it
    has a bug. Find it and fix it. Of course, if you did exercise 11.9 and directly
    found the correct solution, you may take a break.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Heap<Integer>` 上运行练习 11.9 的解决方案将工作，但它有一个错误。找出它并修复它。当然，如果你做了练习 11.9 并直接找到了正确的解决方案，你可以休息一下。
- en: Hint
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Think about what happens if the value inserted has the same priority as the
    head.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下如果插入的值与头部的优先级相同会发生什么。
- en: Solution 11.10
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 11.10
- en: 'If the priority of the `head` is equal to the priority of the inserted element
    `a`, `a` is used for the new `head` and is then inserted into the new right branch.
    This isn’t a big deal with a heap of integers, but it will probably be a big bug
    with most other types. Consider the following type:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`head`的优先级等于插入元素`a`的优先级，则使用`a`作为新的`head`，并将其插入到新的右分支中。对于整数堆来说，这并不是什么大问题，但对于大多数其他类型来说，这可能会是一个大错误。考虑以下类型：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This type represents points that can be compared using only their `x` coordinate.
    Now, consider this program simulating insertions of points into a heap:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型表示可以使用其`x`坐标进行比较的点。现在，考虑以下模拟将点插入堆的程序：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After the points are inserted, they’re extracted again by priority order into
    a list. Here’s the result (with the first line showing the original points):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在将点插入后，它们将按优先级顺序再次从列表中提取。以下是结果（第一行显示原始点）：
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the second line, you can see that you get two points with x = 1, but instead
    of `(1,0)` and `(1,9)`, you get `(1,9)` twice. You have the same problem with
    points where x = 2\. This problem wouldn’t be apparent if you were only inserting
    integers into the heap.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，你可以看到你得到了两个x = 1的点，但不是`(1,0)`和`(1,9)`，而是`(1,9)`两次。对于x = 2的点，你也会有同样的问题。如果你只向堆中插入整数，这个问题就不会明显。
- en: 'Here’s the correct implementation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是正确的实现：
- en: '![](Images/319fig01_alt.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/319fig01_alt.jpg)'
- en: 'Now you’ll get the following (correct) result:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将得到以下（正确）的结果：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 11.5\. Summary
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5. 概述
- en: Trees can be balanced for better performance and to avoid stack overflows in
    recursive operations.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高性能并避免递归操作中的栈溢出，可以平衡树。
- en: The red-black tree is a self-balancing tree structure that frees you from caring
    about tree balancing.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红黑树是一种自我平衡的树结构，可以让你不必关心树的平衡。
- en: Maps can be implemented by delegating to a tree that stores key/value tuples.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过委托到一个存储键/值对的树来实现映射。
- en: Maps with noncomparable keys must handle collisions in order to store elements
    with the same key representation.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可比较键的映射必须处理冲突，以便存储具有相同键表示的元素。
- en: Priority queues are structures that allow elements to be retrieved by priority
    order.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列是允许按优先级顺序检索元素的集合。
- en: Priority queues can be implemented using a leftist heap, which is a heap-ordered
    binary tree.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用左倾堆实现优先队列，它是一种堆有序的二元树。
- en: Priority queues of noncomparable elements can be constructed using an additional
    comparator.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用额外的比较器构造不可比较元素的优先队列。
