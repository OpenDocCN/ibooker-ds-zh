- en: Appendix. Answers to Twist in the Tale exercises
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录. 故事中的转折练习答案
- en: '[Chapters 1](kindle_split_011.html#ch01) through [7](kindle_split_021.html#ch07)
    include multiple Twist in the Tale exercises. The answers to these exercises,
    along with comprehensive explanations, are given in this appendix. The answers
    to each exercise include the following elements:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](kindle_split_011.html#ch01)至[第7章](kindle_split_021.html#ch07)包含多个故事中的转折练习。这些练习的答案以及详细的解释见本附录。每个练习的答案包括以下元素：'
- en: '***Purpose—*** The aim of the exercise (the *twist* to which each exercise
    is trying to draw your attention)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的—** 练习的目标（每个练习试图吸引你注意的转折）'
- en: '***Answer—*** The correct answer'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**答案—** 正确答案'
- en: '***Explanation—*** A comprehensive explanation of the answer'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释—** 对答案的全面解释'
- en: Let’s get started with the first chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一章开始吧。
- en: 'A.1 [Chapter 1](kindle_split_011.html#ch01): Java basics'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1 [第1章](kindle_split_011.html#ch01)：Java基础知识
- en: '[Chapter 1](kindle_split_011.html#ch01) includes four Twist in the Tale exercises.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](kindle_split_011.html#ch01)包含四个故事中的转折练习。'
- en: A.1.1 Twist in the Tale 1.1
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.1 故事中的转折 1.1
- en: 'Purpose: This exercise encourages you to practice code with a combination of
    the correct contents (classes and interfaces) of a Java source code file.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：这个练习鼓励你使用Java源代码文件的正确内容（类和接口）的组合来练习代码。
- en: 'Answer: c, d'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：c, d
- en: 'Explanation: Options (a) and (b) are incorrect.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：选项（a）和（b）是错误的。
- en: Option (c) is correct because a Java source code file can define multiple interfaces
    and classes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 选项（c）是正确的，因为Java源代码文件可以定义多个接口和类。
- en: Option (d) is correct because a `public` interface or class can be defined in
    a Java source code file with a matching name. The `public` interface `Printable`
    can’t be defined in the Java source code file, Multiple.java. It must be defined
    in Printable.java.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 选项（d）是正确的，因为在具有匹配名称的Java源代码文件中可以定义`public`接口或类。`public`接口`Printable`不能在Java源代码文件Multiple.java中定义。它必须在Printable.java中定义。
- en: A.1.2 Twist in the Tale 1.2
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.2 故事中的转折 1.2
- en: 'Purpose: Though similar to Twist in the Tale 1.1, this question is different
    in terms of its wording and intent. It asks you to select the options that are
    correct *individually*. Selecting an option that’s correct individually means
    that an option should be correct on its own and not in combination with any other
    option. You may get to answer similar questions in the real exam.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：尽管与故事中的转折1.1相似，但这个问题在措辞和意图方面有所不同。它要求你选择单独正确的选项。选择一个单独正确的选项意味着该选项应该单独正确，而不是与其他任何选项结合。你可能在真正的考试中遇到类似的问题。
- en: 'Answer: a, c, d'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a, c, d
- en: 'Explanation: Option (a) is correct and (b) is incorrect because Multiple2.java
    won’t compile. Multiple2.java can’t define a `public` class `Car`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：选项（a）是正确的，而（b）是错误的，因为Multiple2.java无法编译。Multiple2.java不能定义一个`public`类`Car`。
- en: Option (c) is correct because removal of the definition of the `public` class
    `Car` from Multiple2.java will leave only one `public` interface in Multiple2.java—`Multiple2`.
    Because the names of the `public` interface `Multiple2` and the source code file
    match, Multiple2.java will compile successfully.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 选项（c）是正确的，因为从Multiple2.java中删除`public`类`Car`的定义将在Multiple2.java中留下一个唯一的`public`接口——`Multiple2`。因为`public`接口`Multiple2`和源代码文件的名称匹配，所以Multiple2.java将成功编译。
- en: Option (d) is correct. Changing the `public` class `Car` to a non-`public` class
    will leave only one `public` interface in Multiple2.java—`Multiple2`. Because
    the names of the public interface `Multiple2` and source code file match, Multiple2.java
    will compile successfully.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 选项（d）是正确的。将`public`类`Car`更改为非`public`类将在Multiple2.java中留下一个唯一的`public`接口——`Multiple2`。因为`public`接口`Multiple2`和源代码文件的名称匹配，所以Multiple2.java将成功编译。
- en: Option (e) is incorrect. If you change the access modifier of the `public` interface
    `Multiple2` to non-`public`, Multiple2.java will contain a definition of a `public`
    class `Car`, which isn’t allowed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 选项（e）是错误的。如果你将`public`接口`Multiple2`的访问修饰符更改为非`public`，Multiple2.java将包含一个`public`类`Car`的定义，这是不允许的。
- en: A.1.3 Twist in the Tale 1.3
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.3 故事中的转折 1.3
- en: 'Purpose: This exercise encourages you to execute the code in the options to
    understand the correct method signature of the method `main` together with the
    method parameters that are passed to it.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：这个练习鼓励你执行选项中的代码，以理解方法`main`的正确方法签名以及传递给它的方法参数。
- en: 'Answer: a, b'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a, b
- en: 'Explanation: All the options in this question are supposed to execute using
    the command `javaEJava java one one`. The purpose of each of these terms is as
    follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：这个问题中的所有选项都应该使用命令 `javaEJava java one one` 来执行。每个术语的目的如下：
- en: Term 1, `java`—Used to execute a Java class
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语 1，`java`—用于执行 Java 类
- en: Term 2, `EJava`—Name of class to execute
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语 2，`EJava`—要执行的类名
- en: Term 3, `java`—Passed as the first argument to the method `main`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语 3，`java`—作为 `main` 方法的第一个参数传递
- en: Term 4, `one`—Passed as the second argument to `main`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语 4，`one`—作为 `main` 方法的第二个参数传递
- en: Term 5, `one`—Passed as the third argument to `main`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语 5，`one`—作为 `main` 方法的第三个参数传递
- en: To output `java one`, the `main` method should output the first and either the
    second or third method parameters passed to it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出 `java one`，`main` 方法应该输出传递给它的第一个参数以及第二个或第三个参数。
- en: Options (a) and (b) are correct because they use the correct method signature
    of the method `main`. The name of the method parameter need not be `args`. It
    can be any other valid identifier. Option (a) outputs the values of the first
    and third terms passed to it. Option (b) outputs the values of the first and second
    terms passed to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 (a) 和 (b) 是正确的，因为它们使用了方法 `main` 的正确方法签名。方法参数的名称不必是 `args`。它可以是一个其他有效的标识符。选项
    (a) 输出传递给它的第一个和第三个参数的值。选项 (b) 输出传递给它的第一个和第二个参数的值。
- en: Option (c) is incorrect because this `main` method accepts a two-dimensional
    array. Hence, it won’t be treated as *the* `main` method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 (c) 是错误的，因为这个 `main` 方法接受一个二维数组。因此，它不会被当作 *the* `main` 方法处理。
- en: Option (d) is incorrect because this code won’t compile. The access modifier
    of a method (`public`) should be placed before its return type (`void`); otherwise,
    the code won’t compile.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 (d) 是错误的，因为这个代码无法编译。方法的访问修饰符（`public`）应该放在其返回类型（`void`）之前；否则，代码无法编译。
- en: A.1.4 Twist in the Tale 1.4
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.4 “故事中的转折”1.4
- en: 'Purpose: Apart from determining the right access modifier that can limit the
    visibility of a class within a package, this exercise wants you to try out different
    access modifiers that can be used to declare a class.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：除了确定可以限制类在包内可见性的正确访问修饰符之外，这个练习还希望你尝试不同的访问修饰符，这些修饰符可以用来声明一个类。
- en: 'Answer: The code submitted by Harry.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：哈里提交的代码。
- en: 'Explanation: The code submitted by Paul is incorrect because when the class
    `Curtain` is defined with the `public` access modifier, it will be accessible
    outside the package `building`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：保罗提交的代码是不正确的，因为当使用 `public` 访问修饰符定义类 `Curtain` 时，它将在包 `building` 外部可访问。
- en: The code submitted by Shreya and Selvan is incorrect because the class `Curtain`
    is a top-level class (it’s not defined within another class), so it can’t be defined
    using the access modifiers `protected` and `private`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 淑瑞亚和塞尔万提交的代码是不正确的，因为类 `Curtain` 是一个顶级类（它不是在另一个类中定义的），因此不能使用 `protected` 和 `private`
    访问修饰符来定义。
- en: 'A.2 [Chapter 2](kindle_split_013.html#ch02): Working with Java data types'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2 [第二章](kindle_split_013.html#ch02)：使用 Java 数据类型
- en: '[Chapter 2](kindle_split_013.html#ch02) includes four Twist in the Tale exercises.
    Twist in the Tale 2.1 has two parts.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](kindle_split_013.html#ch02) 包含四个“故事中的转折”练习。故事中的转折 2.1 有两部分。'
- en: A.2.1 Twist in the Tale 2.1 (part 1)
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.1 “故事中的转折”2.1（第一部分）
- en: 'Purpose: By default, `System.out.println()` will print out a number in its
    decimal base. It does so regardless of the base number system that you use to
    initialize a number.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：默认情况下，`System.out.println()` 会以其十进制基数打印数字。它这样做，无论你使用什么基数数系统来初始化数字。
- en: 'Answer: The code prints the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：该代码打印以下输出：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Explanation: Often programmers are tricked by similar questions. If a variable
    is assigned a value using `0b100001011` (a number in the binary number system),
    a programmer might believe that `System.out.println()` will print out numbers
    in the binary number system, which is incorrect. By default, `System.out.println()`
    will print out a number in its decimal base. All four variables `baseDecimal`,
    `octVal`, `hexVal`, and `binVal` represent the decimal value `267` in the decimal,
    octal, hexadecimal, and binary number systems. The addition operation adds these
    values and prints `534` twice.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：程序员经常被类似的问题所迷惑。如果一个变量使用 `0b100001011`（二进制数系统中的数字）赋值，程序员可能会认为 `System.out.println()`
    会以二进制数系统打印数字，这是不正确的。默认情况下，`System.out.println()` 会以十进制基数打印数字。所有四个变量 `baseDecimal`、`octVal`、`hexVal`
    和 `binVal` 分别代表十进制、八进制、十六进制和二进制数系统中的十进制值 `267`。加法运算将这些值相加并打印 `534` 两次。
- en: 'You can use a method from the class `Integer` to print out a value in the binary
    number system as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Integer`类中的方法以如下方式打印出二进制数系统中的值：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the class `Integer` isn’t on this exam and you won’t be asked any
    questions on it. This class is mentioned only for your reference.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Integer`类不在此考试中，你不会就它提出任何问题。这个类仅用于参考。
- en: A.2.2 Twist in the Tale 2.1 (part 2)
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.2 故事中的转折 2.1（第二部分）
- en: 'Purpose: A new Java 7 language feature is the use of the underscore in literal
    number values. This exercise’s purpose is to help you get familiar with this feature
    if you haven’t worked with underscores in literal number values before.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：Java 7语言的一个新特性是在字面数值中使用下划线。本练习的目的是帮助你熟悉这个特性，如果你之前没有在字面数值中使用下划线的话。
- en: 'Answer: Only `var1`, `var6`, and `var7` correctly define a literal integer
    value.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：只有`var1`、`var6`和`var7`正确地定义了字面整数值。
- en: 'Explanation: The literal value `0_x_4_13` defined by `var2` is incorrect because
    it uses underscores after the starting `0` and after the letter `x`, neither of
    which is allowed. The correct value is `0x4_13`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：由`var2`定义的字面值`0_x_4_13`是不正确的，因为它在起始的`0`和字母`x`之后使用了下划线，这两者都是不允许的。正确的值是`0x4_13`。
- en: The literal value `0b_x10_BA_75` defined by `var3` is incorrect. You can’t place
    an underscore right after the prefixes `0b` and `0B` that are used to define binary
    literal values. Also, a binary value can contain only the digits `1` and `0`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由`var3`定义的字面值`0b_x10_BA_75`是不正确的。你不能在用于定义二进制字面值的`0b`和`0B`前缀之后放置下划线。此外，二进制值只能包含数字`1`和`0`。
- en: The literal value `0b_10000_10_11` defined by value `var4` is incorrect. You
    can’t place an underscore right after the prefixes `0b` and `0B` used to define
    binary literal values. The correct value is `0b10000_10_11`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由值`var4`定义的字面值`0b_10000_10_11`是不正确的。你不能在用于定义二进制字面值的`0b`和`0B`前缀之后放置下划线。正确的值是`0b10000_10_11`。
- en: The literal value `0xa10_AG_75` defined by `var5` is incorrect because it uses
    the letter `G`, which isn’t allowed in a hexadecimal number system. A correct
    value is `0xa10_A_75`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由`var5`定义的字面值`0xa10_AG_75`是不正确的，因为它使用了字母`G`，这在十六进制数系统中是不允许的。正确的值是`0xa10_A_75`。
- en: The literal integer defined by `var1` is valid. But `0` (for octal literals)
    is an exception to the rule stating that a radix prefix can’t be isolated by an
    underscore (for example, `0x_100_267_760` and `0b_100_110` are invalid expressions).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由`var1`定义的字面整数值是有效的。但`0`（用于八进制字面值）是规则的一个例外，即基数前缀不能被下划线孤立（例如，`0x_100_267_760`和`0b_100_110`是无效的表达式）。
- en: A.2.3 Twist in the Tale 2.2
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.3 故事中的转折 2.2
- en: 'Purpose: To reinforce the following concepts:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：为了加强以下概念：
- en: Multiple variables of the *same type* can be defined on the same line of code.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在同一行代码中定义多个*相同类型*的变量。
- en: 'Variable assignment rule: if multiple variables of *similar types* are assigned
    values on the same line, assignment starts from right to left. Also, unlike other
    programming languages such as C, the literal value `0` can’t be assigned to a
    variable of type `boolean`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量赋值规则：如果同一行上为多个*相似类型*的变量赋值，赋值从右向左开始。此外，与C语言等其他编程语言不同，字面值`0`不能赋给类型为`boolean`的变量。
- en: Questions that ask you to select incorrect answers or code can be confusing.
    It’s common to start by determining the incorrect options and then selecting the
    correct options. Make note of such questions.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求你选择错误答案或代码的问题可能会令人困惑。通常，我们首先确定错误的选项，然后选择正确的选项。注意这些问题。
- en: 'Answer: a, b, c, e'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a, b, c, e
- en: 'Explanation: Options (a) and (b) are incorrect statements. You can define multiple
    variables of the same type on the same line. Also, you can assign values to variables
    of compatible types on the same line of code. Assignment starts from right to
    left. For proof, the following lines of code will compile:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：选项（a）和（b）是错误的陈述。你可以在同一行上定义多个相同类型的变量。此外，你还可以在同一行代码中为兼容类型的变量赋值。赋值从右向左开始。为了证明这一点，以下代码行将可以编译：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But the following lines of code won’t compile:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下代码行将无法编译：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the final line of the preceding code, a literal value `10` is assigned to
    the variable `long2` of type `long`, which is acceptable. An attempt to assign
    the value of the variable `long2` to `int1` fails because it would need an explicit
    cast.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的最后一行中，字面值`10`被赋值给类型为`long`的变量`long2`，这是可接受的。尝试将变量`long2`的值赋给`int1`会失败，因为这需要显式的转换。
- en: Option (c) is an incorrect statement because a literal value `0` can’t be assigned
    to a variable of type `boolean`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 (c) 是一个错误的陈述，因为字面值 `0` 不能赋值给 `boolean` 类型的变量。
- en: Option (d) is a correct statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 (d) 是一个正确的陈述。
- en: Option (e) is an incorrect statement. The code doesn’t define a variable with
    the name `yes` and thus seems to treat it like a literal value. Java doesn’t define
    a literal value `yes`, so the code doesn’t compile.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 (e) 是一个错误的陈述。代码没有定义名为 `yes` 的变量，因此似乎将其视为字面值。Java 没有定义字面值 `yes`，所以代码无法编译。
- en: A.2.4 Twist in the Tale 2.3
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.4 故事中的转折 2.3
- en: 'Purpose: The exercise encourages you to'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：这个练习鼓励你
- en: Try code with increment and decrement postfix and prefix unary operators
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用增量、减量后缀和前缀一元运算符的代码
- en: Get the hang of how variables are evaluated in an expression that has multiple
    occurrences of unary operators in postfix and prefix notation
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉变量在具有后缀和前缀表示法中多个一元运算符的表达式中的评估方式。
- en: 'Answer: 32'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：32
- en: 'Explanation: The actual task is to evaluate the following expression:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：实际任务是评估以下表达式：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the actual task because the question asks you to replace all occurrences
    of `++a` with `a++, --a` with `a--`, and vice versa. This expression is depicted
    in [figure A.1](#app01fig01):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际的任务，因为问题要求你将所有 `++a` 替换为 `a++, --a` 替换为 `a--`，反之亦然。这个表达式在[图 A.1](#app01fig01)中展示：
- en: Figure A.1\. Evaluation of an expression that has multiple unary operators in
    postfix and prefix notation
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.1\. 具有多重一元运算符（后缀和前缀表示法）的表达式评估
- en: '![](a0fig01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](a0fig01.jpg)'
- en: A.2.5 Twist in the Tale 2.4
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.5 故事中的转折 2.4
- en: 'Purpose: To determine whether the operands of an expression that uses the short-circuit
    operators `&&` and `||` will evaluate.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：确定使用短路运算符 `&&` 和 `||` 的表达式的操作数是否会评估。
- en: 'Answer: The operands that will execute are circled and the ones that won’t
    are enclosed in rectangles in [figure A.2](#app01fig02).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：将要执行的操作数用圆圈标出，不会执行的操作数用矩形框起来，见[图 A.2](#app01fig02)。
- en: Figure A.2\. In an expression that uses the short-circuit operators `&&` and
    `||`, the operands that are evaluated are circled and the ones that aren’t evaluated
    are enclosed in rectangles.
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.2\. 在使用短路运算符 `&&` 和 `||` 的表达式中，被评估的操作数用圆圈标出，未被评估的操作数用矩形框起来。
- en: '![](a0fig02_alt.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](a0fig02_alt.jpg)'
- en: 'Explanation: Both of the short-circuit operators, `&&` and `||`, will evaluate
    their first operand. For the short-circuit operator `&&`, if the first operand
    evaluates to `false`, it won’t evaluate the second operator. For the short-circuit
    operator `||`, if the first operand evaluates to `true`, it won’t evaluate the
    second operator.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：短路运算符 `&&` 和 `||` 都会评估它们的第一操作数。对于短路运算符 `&&`，如果第一个操作数评估为 `false`，则不会评估第二个操作数。对于短路运算符
    `||`，如果第一个操作数评估为 `true`，则不会评估第二个操作数。
- en: For the expression `(a++ > 10 || ++b < 30)`, because `a++ > 10` evaluates to
    `false`, both operands will evaluate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表达式 `(a++ > 10 || ++b < 30)`，因为 `a++ > 10` 评估为 `false`，两个操作数都将被评估。
- en: For the expression `(a > 90 && ++b < 30)`, because `a > 90` evaluates to `false`,
    the second operand won’t execute.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表达式 `(a > 90 && ++b < 30)`，因为 `a > 90` 评估为 `false`，第二个操作数不会执行。
- en: For expression `(!(c > 20) && a == 10)`, because `!(c > 20)` evaluates to `false`,
    the second operand won’t execute.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表达式 `(!(c > 20) && a == 10)`，因为 `!(c > 20)` 评估为 `false`，第二个操作数不会执行。
- en: 'The expression `(a >= 99 || a <= 33 && b == 10)` has three operands together
    with the OR (`||`) and AND (`&&`) short-circuit operators. Because the short-circuit
    operator AND has higher operator precedence than the short-circuit operator OR,
    the expression is evaluated as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `(a >= 99 || a <= 33 && b == 10)` 有三个操作数，以及 OR (`||`) 和 AND (`&&`) 短路运算符。因为短路运算符
    AND 的运算符优先级高于短路运算符 OR，所以表达式按以下方式评估：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Evaluation of the preceding expression starts with the evaluation of `(a <=
    33 && b == 10)`. Because `a <= 33` evaluates to `true`, the operator `&&` evaluates
    the second operand `(b == 10)` to determine whether `(a <= 33 && b == 10`) will
    return `true` or `false`. `a <= 33` returns `true` and `b == 10` returns `false`,
    so the expression `(a <= 33 && b == 10)` returns `false`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 评估前面的表达式从评估 `(a <= 33 && b == 10)` 开始。因为 `a <= 33` 评估为 `true`，运算符 `&&` 会评估第二个操作数
    `(b == 10)` 以确定 `(a <= 33 && b == 10)` 将返回 `true` 还是 `false`。`a <= 33` 返回 `true`，而
    `b == 10` 返回 `false`，所以表达式 `(a <= 33 && b == 10)` 返回 `false`。
- en: 'The original expression—`(a >= 99 || (a <= 33 && b == 10))`—is now reduced
    to the following expression:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 原始表达式—`(a >= 99 || (a <= 33 && b == 10))`—现在简化为以下表达式：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The short-circuit operator OR (`||`) executes its first operand (even if the
    value of the second operand is known), evaluating `a >= 99`. So for this expression,
    all three operands are evaluated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 短路操作符OR (`||`)执行其第一个操作数（即使第二个操作数的值已知），评估`a >= 99`。所以对于这个表达式，所有三个操作数都被评估。
- en: 'The expression `(a >= 99 && a <= 33 || b == 10)` also has three operands, together
    with `OR` and `AND` short-circuit operators. Because the short-circuit operator
    `AND` has a higher operator precedence than the short-circuit operator `OR`, this
    expression is evaluated as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(a >= 99 && a <= 33 || b == 10)`也有三个操作数，以及`OR`和`AND`短路操作符。因为短路操作符`AND`的运算符优先级高于短路操作符`OR`，所以这个表达式按以下方式评估：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`a >= 99` evaluates to `false`, so the next operand `(a <= 33)` isn’t evaluated.
    Because the first operand to operator `||`, `a >= 99 && a <= 33)`, evaluates to
    `false`, `b == 10` is evaluated.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`a >= 99`评估为`false`，所以下一个操作数`(a <= 33)`不会被评估。因为操作符`||`的第一个操作数`(a >= 99 && a
    <= 33)`评估为`false`，所以评估`b == 10`。'
- en: 'A.3 [Chapter 3](kindle_split_014.html#ch03): Methods and encapsulation'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3 [第3章](kindle_split_014.html#ch03)：方法和封装
- en: '[Chapter 3](kindle_split_014.html#ch03) includes three Twist in the Tale exercises.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](kindle_split_014.html#ch03)包括三个故事中的转折练习。'
- en: A.3.1 Twist in the Tale 3.1
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.1 故事中的转折 3.1
- en: 'Purpose: In the same way that the class `TestPhone` in this exercise defines
    a local variable with the same name as its instance variable, I strongly recommend
    that you try out different combinations of defining variables with the same name
    in a class, but with different scope.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：与这个练习中定义与其实例变量同名局部变量的`TestPhone`类一样，我强烈建议你尝试在类中定义具有相同名称但不同作用域的变量的不同组合。
- en: 'Answer: a'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a
- en: 'Explanation: The class `Phone` defines an instance variable with the name `phoneNumber`.
    The method `setNumber` also defines a local variable `phoneNumber` and assigns
    a value to its local variable. A local variable takes precedence over an instance
    variable defined in the class with the same names. Because there is no change
    in the value of the instance variable `phoneNumber`, `123456789` is printed to
    the console from the method `main`, defined in the class `TestPhone`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：类`Phone`定义了一个名为`phoneNumber`的实例变量。方法`setNumber`也定义了一个局部变量`phoneNumber`并将其局部变量的值赋给它。局部变量会覆盖类中具有相同名称的实例变量。因为实例变量`phoneNumber`的值没有变化，所以`123456789`被打印到`TestPhone`类中定义的`main`方法控制的控制台。
- en: A.3.2 Twist in the Tale 3.2
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.2 故事中的转折 3.2
- en: 'Purpose: To learn that *recursive* or *circular* calls to constructors aren’t
    allowed.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：了解不允许对构造函数进行**递归**或**循环**调用。
- en: 'Answer: The code fails to compile, with the following compilation error message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：代码无法编译，出现以下编译错误信息：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Explanation: A method calling itself is called *recursion*. Two or more methods
    calling each other, in a circular manner, is called *circular method calling*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：一个方法调用自身被称为**递归**。两个或更多方法以循环方式相互调用被称为**循环方法调用**。
- en: Starting in Java version 1.4.1, the Java compiler won’t compile code with *recursive*
    or *circular* constructors. A constructor is used to initialize an object, so
    it doesn’t make sense to allow recursive calls to a constructor. You can initialize
    an object once and then modify it. You can’t initialize an object multiple times.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java版本1.4.1开始，Java编译器不会编译具有**递归**或**循环**构造函数的代码。构造函数用于初始化对象，因此允许对构造函数进行递归调用是没有意义的。你可以初始化对象一次，然后修改它。你不能多次初始化对象。
- en: 'In case you’re wondering whether you can call a constructor conditionally from
    another constructor, you can’t. A call to a constructor must be the first statement:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道是否可以从另一个构造函数有条件地调用构造函数，你无法这样做。对构造函数的调用必须是第一条语句：
- en: '![](648fig01_alt.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](648fig01_alt.jpg)'
- en: 'Also, circular constructor calls aren’t allowed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不允许循环构造函数调用：
- en: '![](648fig02_alt.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](648fig02_alt.jpg)'
- en: 'The previous example doesn’t compile, with the following compilation error
    message:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子无法编译，出现以下编译错误信息：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that similar recursive or circular calls defined in methods don’t result
    in compilation errors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在方法中定义的类似的递归或循环调用不会导致编译错误。
- en: A.3.3 Twist in the Tale 3.3
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.3 故事中的转折 3.3
- en: 'Purpose: A class with `public` instance variable(s) can never be designated
    as a well-encapsulated class.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：具有`public`实例变量（s）的类永远不能被指定为良好封装的类。
- en: 'Answer: e'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：e
- en: 'Explanation: This question tries to trick you by defining options that play
    with multiple access modifiers for methods `getWeight` and `setWeight`. Because
    the instance variable `model` of the class `Phone` is defined using the `public`
    access modifier (and no proposed options address this issue), it’s accessible
    outside this class. So `Phone` isn’t a well-encapsulated class.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：这个问题试图通过定义玩弄方法 `getWeight` 和 `setWeight` 的多个访问修饰符的选项来欺骗你。因为类 `Phone` 的实例变量
    `model` 使用 `public` 访问修饰符定义（并且没有提出的选项解决这个问题），它可以在类外访问。所以 `Phone` 不是一个封装良好的类。
- en: 'A.4 [Chapter 4](kindle_split_015.html#ch04): Selected classes from the Java
    API and arrays'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4 [第四章](kindle_split_015.html#ch04)：Java API 中的选择类和数组
- en: '[Chapter 4](kindle_split_015.html#ch04) includes four Twist in the Tale exercises.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四章](kindle_split_015.html#ch04) 包含四个“故事中的转折”练习。'
- en: A.4.1 Twist in the Tale 4.1
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.1 “故事中的转折”4.1
- en: 'Purpose: To remind you to be careful with the overloaded methods of the class
    `String` that accept either `char` or `String` or both, the code in this exercise
    passes an invalid method argument—a `char`—to method `startsWith`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：提醒你注意类 `String` 的重载方法，这些方法可以接受 `char` 或 `String` 或两者，这个练习中的代码向 `startsWith`
    方法传递了一个无效的方法参数——一个 `char`。
- en: 'Answer: e'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：e
- en: 'Explanation: When it comes to the `String` class, it’s easy to confuse the
    methods that accept `char` or `String` values as method arguments. For example,
    the overloaded method `indexOf` can accept both `String` and `char` values to
    search for a target value in a `String`. The methods `startsWith` and `endsWith`
    accept only arguments of type `String`. The method `charAt` accepts only method
    arguments of type `int`. Hence, this method can be passed `char` values, which
    are stored as unsigned integer values.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：当涉及到 `String` 类时，很容易混淆接受 `char` 或 `String` 值作为方法参数的方法。例如，重载的方法 `indexOf`
    可以接受 `String` 和 `char` 值来在 `String` 中搜索目标值。方法 `startsWith` 和 `endsWith` 只接受 `String`
    类型的参数。方法 `charAt` 只接受 `int` 类型的参数。因此，这个方法可以传递 `char` 值，这些值被存储为无符号整数值。
- en: A.4.2 Twist in the Tale 4.2
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.2 “故事中的转折”4.2
- en: 'Purpose: This exercise has multiple purposes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：这个练习有多个目的：
- en: To confuse you with the use of method names, which are used in the Java API
    by other classes to create their objects.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让你混淆方法名称的使用，这些名称被其他类在 Java API 中用来创建它们的对象。
- en: To encourage you to refer to the Java API documentation when you work with classes
    from the Java API. The Java API documentation is an extensive source of information
    and facts that are often not included in most books (because it’s practically
    impossible to do so).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了鼓励你在使用 Java API 中的类时参考 Java API 文档。Java API 文档是一个广泛的信息和事实来源，这些信息通常不包括在大多数书中（因为实际上不可能做到这一点）。
- en: 'Answer: d'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：d
- en: 'Explanation: The correct way to create an object of class `StringBuilder` with
    a default capacity of 16 characters is to call `StringBuilder`’s no-argument constructor,
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：创建具有默认容量16个字符的 `StringBuilder` 类对象的正确方法是调用 `StringBuilder` 的无参数构造函数，如下所示：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A.4.3 Twist in the Tale 4.3
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.3 “故事中的转折”4.3
- en: 'Purpose: Identify the difference between an array element that isn’t initialized
    and an array element that doesn’t exist. A pictorial representation of a multidimensional
    array is quick to draw, and you can easily refer to its nonexistent or `null`
    array elements. This concept is shown in [figure A.3](#app01fig03).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：识别未初始化的数组元素和不存在数组元素之间的区别。一个多维数组的图示很容易绘制，你可以轻松地参考其不存在或 `null` 的数组元素。这个概念在
    [图A.3](#app01fig03) 中展示。
- en: Figure A.3\. Array `multiStrArr` and its elements
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.3\. 数组 `multiStrArr` 及其元素
- en: '![](a0fig03.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图A.3](a0fig03.jpg)'
- en: 'Answer: b, d'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：b, d
- en: 'Explanation: Option (a) is incorrect. Initializing a row of array `multiStrArr`
    with `{"Jan","Feb",null}` and `{"Jan","Feb",null,null}` isn’t the same. The former
    option defines *three* array elements with the last array element assigned to
    `null`. The latter option defines *four* array elements with the last two array
    elements assigned to `null`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：选项(a)是错误的。使用 `{"Jan","Feb",null}` 和 `{"Jan","Feb",null,null}` 初始化数组 `multiStrArr`
    的行并不相同。前者定义了 *三个* 数组元素，最后一个数组元素被赋值为 `null`。后者定义了 *四个* 数组元素，最后两个数组元素被赋值为 `null`。
- en: Option (b) is correct. The array element at the position exists but isn’t assigned
    any value. It’s assigned to `null`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 选项(b)是正确的。该位置的数组元素存在，但没有被赋予任何值。它被赋值为 `null`。
- en: Option (c) is incorrect. Because `multiStrArr[1]` refers to `null`, `multiStrArr[1][1]`
    doesn’t exist.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 选项(c)是错误的。因为 `multiStrArr[1]` 指向 `null`，所以 `multiStrArr[1][1]` 不存在。
- en: Option (d) is correct. As shown in [figure A.3](#app01fig03), the array `multiStrArr`
    doesn’t define an equal number of elements in each row, so it’s asymmetric.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 (d) 是正确的。如图 A.3 所示，数组 `multiStrArr` 在每一行中定义的元素数量不相等，因此它是不对称的。
- en: A.4.4 Twist in the Tale 4.4
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.4 故事中的转折 4.4
- en: 'Purpose: This exercise tries to trick you by using multiple objects of `ArrayList`,
    assigning the object reference of one `ArrayList` to another, and modifying the
    value of the `ArrayList` objects. `String` objects are immutable—you can’t change
    their values.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：这个练习试图通过使用多个 `ArrayList` 对象、将一个 `ArrayList` 的对象引用赋给另一个，并修改 `ArrayList` 对象的值来欺骗你。`String`
    对象是不可变的——你不能改变它们的值。
- en: 'Answer: a'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a
- en: 'Explanation: Option (a) is correct, and options (b), (c), and (d) are incorrect.
    The `ArrayList`s `myArrList` and `yourArrList` contain `String` objects. The value
    of `String` objects can’t be modified once created.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：选项 (a) 是正确的，而选项 (b)、(c) 和 (d) 是错误的。`ArrayList` `myArrList` 和 `yourArrList`
    包含 `String` 对象。一旦创建，`String` 对象的值就不能修改。
- en: 'A.5 [Chapter 5](kindle_split_018.html#ch05): Flow control'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5 [第 5 章](kindle_split_018.html#ch05)：流程控制
- en: '[Chapter 5](kindle_split_018.html#ch05) includes four Twist in the Tale exercises.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](kindle_split_018.html#ch05) 包含四个故事中的转折练习。'
- en: A.5.1 Twist in the Tale 5.1
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.5.1 故事中的转折 5.1
- en: 'Purpose: To emphasize multiple points:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：为了强调多个要点：
- en: A variable of any type can be (re)assigned a value in an expression used in
    an `if` condition.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类型的变量都可以在 `if` 条件中使用的表达式中（重新）赋值。
- en: '`if`-`else`-`if` statements execute each `if` condition as control is passed
    to them, changing the value of any variable that’s manipulated in the evaluation
    of the expression.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`-`else`-`if` 语句在控制传递给它们时执行每个 `if` 条件，并更改在表达式评估中操作的任何变量的值。'
- en: An expression used in an `if` condition should evaluate to a `boolean` value.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 `if` 条件的表达式应该评估为 `boolean` 值。
- en: 'Answer: f'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：f
- en: 'Explanation: The flow of execution of code statements in this exercise is shown
    in [figure A.4](#app01fig04).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：本练习中代码语句的执行流程如图 A.4 所示。
- en: Figure A.4\. Flow of execution of code in Twist in the Tale 5.1
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.4\. 故事中的转折 5.1 中的代码执行流程
- en: '![](a0fig04_alt.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.4](a0fig04_alt.jpg)'
- en: 'The arrows on the left in [figure A.4](#app01fig04) show the flow of execution
    of statements for this code snippet. The `if` conditions on the right show the
    actual values that are compared after the expression used in the `if` statements
    is evaluated. Following is a detailed description:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A.4](#app01fig04) 中左侧的箭头显示了此代码片段中语句的执行流程。右侧的 `if` 条件显示了在 `if` 语句中使用的表达式评估后的实际比较值。以下是一个详细的描述：'
- en: The initial value of variable `score` is `10`. The first condition `((score
    = score + 10) == 100)` reassigns the value of variable `score` to `20` and then
    compares it to the literal integer value `100`. The expression `20 == 100` returns
    a `boolean` value `false`. The control doesn’t evaluate the *then* part of the
    `if` construct and moves on to the evaluation of the second `if` condition defined
    in the `else` part.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `score` 的初始值是 `10`。第一个条件 `((score = score + 10) == 100)` 将变量 `score` 的值重新赋为
    `20`，然后将其与字面整数值 `100` 进行比较。表达式 `20 == 100` 返回 `boolean` 值 `false`。控制不会评估 `if`
    构造的 `then` 部分，而是继续评估 `else` 部分中定义的第二个 `if` 条件。
- en: The second condition `((score = score + 29) == 50)` adds `29` to the existing
    value `20` of variable `score` and then compares the new value `49` with `50`.
    The expression `49 == 50` returns `false` again. The control doesn’t evaluate
    the *then* part of the `if` construct and moves on to evaluation of the second
    `if` condition defined in the `else` part.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个条件 `((score = score + 29) == 50)` 将 `29` 添加到变量 `score` 的现有值 `20` 上，然后将新值
    `49` 与 `50` 进行比较。表达式 `49 == 50` 再次返回 `false`。控制不会评估 `if` 构造的 `then` 部分，而是继续评估
    `else` 部分中定义的第二个 `if` 条件。
- en: The third condition `((score = score + 200) == 10)` adds a value of `200` to
    the existing value `49` of variable `score`, making it `249`, and compares that
    with the integer literal value `10`. Because `249 == 10` evaluates to `false`,
    control moves to the `else` part. The `else` part assigns a literal value `F`
    to the variable `result`. At the end of execution of the `if-else-if` statement,
    the variable `score` is assigned a value of `249` and `result` is assigned a value
    of `F`. The code outputs `F:249`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个条件`((score = score + 200) == 10)`将`200`的值加到变量`score`现有的`49`值上，使其变为`249`，并将其与整型字面值`10`进行比较。因为`249
    == 10`评估为`false`，控制流移动到`else`部分。`else`部分将字面值`F`赋给变量`result`。在`if-else-if`语句执行结束时，变量`score`被赋予`249`的值，`result`被赋予`F`的值。代码输出`F:249`。
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: This exercise is a nice opportunity to remind you that such assignations are
    always performed before the test or other expression they are part of (that is,
    preassignations) except for post-incrementations (that is, postfixed ++).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习是一个很好的机会来提醒你，这样的赋值总是在它们所属的测试或其他表达式之前执行（即预赋值），除了后增量（即后缀++）。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A.5.2 Twist in the Tale 5.2
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.5.2 故事中的转折 5.2
- en: 'Purpose: The `switch` construct uses the `equals` method to compare the value
    of its argument with the `case` values. It doesn’t compare the variable references.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：`switch`结构使用`equals`方法比较其参数的值与`case`值。它不比较变量引用。
- en: 'Answer: c'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：c
- en: 'Explanation: You may have answered questions with code like the following,
    which prints `false`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：你可能已经用如下代码回答过问题，该代码打印`false`：
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`String` objects that are created using the assignment operator (`=`) are stored
    in a pool of `String` objects, but `String` objects that are created using the
    operator `new` aren’t stored in the pool of `String` objects.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用赋值运算符（`=`）创建的`String`对象存储在`String`对象池中，但使用`new`运算符创建的`String`对象不存储在`String`对象池中。
- en: When a `String` object is passed as an argument to a `switch` construct, it
    doesn’t compare the object references; it compares the object values using the
    `equals` method. In the code snippet shown in the question, a match is found for
    the `String` literal value `SUN`, so the code prints `Weekend!`, executes the
    `break` statement, and exits the block.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个`String`对象作为参数传递给`switch`结构时，它不比较对象引用；它使用`equals`方法比较对象值。在问题中显示的代码片段中，找到了与`String`字面值`SUN`的匹配，因此代码打印`Weekend!`，执行`break`语句，并退出块。
- en: A.5.3 Twist in the Tale 5.3
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.5.3 故事中的转折 5.3
- en: 'Purpose: Note the type of the variable that’s passed as an argument to the
    `switch` construct. Among the primitive data types, you can pass on variables
    of types `byte`, `short`, `char`, and `int` to a `switch` construct. Other data
    types that you can pass to a `switch` construct are `Byte`, `Short`, `Integer`,
    `Character`, `enum`, and `String`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：注意传递给`switch`结构的变量的类型。在原始数据类型中，你可以将`byte`、`short`、`char`和`int`类型的变量传递给`switch`结构。可以传递给`switch`结构的其他数据类型有`Byte`、`Short`、`Integer`、`Character`、`enum`和`String`。
- en: This question tries to take your attention off this simple basic requirement
    and to move your focus to the logic of the question.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题试图将你的注意力从这个简单的基本要求转移到问题的逻辑上。
- en: 'Answer: The submission by Harry.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：哈里的提交。
- en: 'Explanation: Paul’s submission doesn’t compile because a `switch` construct
    doesn’t accept an argument of the `long` primitive data type.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：保罗的提交无法编译，因为`switch`结构不接受`long`原始数据类型的参数。
- en: A.5.4 Twist in the Tale 5.4
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.5.4 故事中的转折 5.4
- en: 'Purpose: When an unlabeled `break` statement is used within nested loops (for
    any combinations of `for`, `do-while`, or `while` loops), a `break` statement
    will end the execution of the *inner loop*, not all the nested loops. The *outer
    loop* will continue to execute, starting with its *next* iteration value.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：当在嵌套循环（任何组合的`for`、`do-while`或`while`循环）中使用未标记的`break`语句时，`break`语句将结束`inner
    loop`的执行，而不是所有嵌套循环。`outer loop`将继续执行，从它的下一个迭代值开始。
- en: 'Answer: a'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a
- en: 'Explanation: Let’s start with the *outer loop*’s first iteration. In the first
    iteration, the value of the variable `outer` is `Outer`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：让我们从`outer loop`的第一次迭代开始。在第一次迭代中，变量`outer`的值是`Outer`。
- en: For the outer loop’s first iteration, the inner loop should execute for the
    values `Outer` and `Inner` for the variable `inner`. For the first iteration of
    the inner loop, the value of the variable `inner` is `Outer`, so the condition
    `inner.equals("Inner")` evaluates to `false` and the `break` statement doesn’t
    execute. The code prints the value of the variable `inner`, which is `Outer:`,
    and starts with the next iteration of the inner loop. In the second iteration
    of the inner loop, the value of the variable `inner` is `Inner`, so the condition
    `inner.equals("Inner")` evaluates to `true` and the `break` statement executes,
    ending the execution of the inner loop and skipping the code that prints out the
    value of the variable `inner`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外层循环的第一次迭代，内层循环应该对变量 `inner` 的值 `Outer` 和 `Inner` 执行。对于内层循环的第一次迭代，变量 `inner`
    的值是 `Outer`，所以条件 `inner.equals("Inner")` 评估为 `false`，`break` 语句不执行。代码打印变量 `inner`
    的值，即 `Outer:`，并开始内层循环的下一个迭代。在内层循环的第二次迭代中，变量 `inner` 的值是 `Inner`，所以条件 `inner.equals("Inner")`
    评估为 `true`，`break` 语句执行，结束内层循环的执行，跳过打印变量 `inner` 值的代码。
- en: The outer loop starts its execution with the second iteration. In this iteration,
    the value of the variable `outer` is `Outer`. For the outer loop’s iteration,
    the inner loop executes twice in the same manner as mentioned in the previous
    paragraph. This iteration of the outer loop again prints the value of the variable
    `inner` when it’s equal to `Outer`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环从第二次迭代开始执行。在这个迭代中，变量 `outer` 的值是 `Outer`。对于外层循环的迭代，内层循环以与上一段中提到相同的方式执行两次。外层循环的这个迭代再次打印变量
    `inner` 的值，当它等于 `Outer` 时。
- en: 'The nested loops included in the question print out the value `Outer:` twice:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 问题中包含的嵌套循环打印出 `Outer:` 两次：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A.6 [Chapter 6](kindle_split_019.html#ch06): Working with inheritance'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.6 [第6章](kindle_split_019.html#ch06)：使用继承
- en: '[Chapter 6](kindle_split_019.html#ch06) includes four Twist in the Tale exercises.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](kindle_split_019.html#ch06) 包含了四个“故事中的转折”练习。'
- en: A.6.1 Twist in the Tale 6.1
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.6.1 “故事中的转折”6.1
- en: 'Purpose: This question is an example of a simple concept (`private` members
    are not accessible to a derived class) that is made to look complex by including
    code and options that try to divert your attention. Expect similar questions on
    the exam.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：这个问题是一个简单概念（`private` 成员对派生类不可访问）的例子，通过包含试图转移您注意力的代码和选项，使其看起来很复杂。考试中可能会出现类似的问题。
- en: 'Answer: e'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：e
- en: 'Explanation: The code fails to compile because the `private` members of a class
    can’t be accessed outside a class—not even by its derived class. The compiler
    can detect such attempts; this code won’t compile.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：代码未能编译，因为类中的 `private` 成员不能在类外访问——甚至不能由其派生类访问。编译器可以检测此类尝试；此代码无法编译。
- en: A.6.2 Twist in the Tale 6.2
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.6.2 “故事中的转折”6.2
- en: 'Purpose: To help you to work with a combination of'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：帮助您处理组合
- en: Arrays
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Assigning an object of a derived class to a reference variable of the base class
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将派生类的对象赋给基类的引用变量
- en: Assigning an object of a class that implements an interface to a reference variable
    of the interface
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实现接口的类的对象赋给接口的引用变量
- en: 'Answer: a, c'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a, c
- en: 'Explanation: The rules you need to follow to assign a value to an array element
    are the same rules you follow when you assign an object to a reference variable.
    Because the type of array `interviewer` is `Interviewer`, you can assign objects
    of classes that implement this interface. The inheritance of classes `Employee`,
    `Manager`, and `HRExecutive` and the interface `Interviewer` are shown in [figure
    A.5](#app01fig05).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：您需要遵循的规则来为数组元素赋值与您在将对象赋给引用变量时遵循的规则相同。因为数组 `interviewer` 的类型是 `Interviewer`，您可以分配实现此接口的类的对象。`Employee`、`Manager`
    和 `HRExecutive` 类以及接口 `Interviewer` 的继承关系如 [图A.5](#app01fig05) 所示。
- en: Figure A.5\. UML notation of inheritance hierarchy of the classes `Employee`,
    `Manager`, and `HRExecutive` and the interface `Interviewer`
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图A.5\. 类 `Employee`、`Manager` 和 `HRExecutive` 以及接口 `Interviewer` 的继承层次结构的UML表示
- en: '![](a0fig05.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](a0fig05.jpg)'
- en: As you can see in [figure A.5](#app01fig05), the classes `Manager` and `HRExecutive`
    implement the interface `Interviewer`. The class `Employee` doesn’t implement
    the interface `Interviewer`; hence, an object of the class `Employee` can’t be
    added to an array of type `Interviewer`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 [图A.5](#app01fig05) 中所见，类 `Manager` 和 `HRExecutive` 实现了接口 `Interviewer`。类
    `Employee` 没有实现接口 `Interviewer`；因此，`Employee` 类的对象不能添加到类型为 `Interviewer` 的数组中。
- en: From this explanation, it’s apparent that options (a) and (c) are correct and
    option (b) is incorrect.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个解释中可以看出，选项(a)和(c)是正确的，选项(b)是不正确的。
- en: Option (d) is incorrect because you can’t create objects of an interface. Option
    (d) tries to create an object of the interface `Interviewer`. Code that tries
    to create an instance of an interface won’t compile.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 选项(d)是不正确的，因为你不能创建接口的对象。选项(d)试图创建接口`Interviewer`的对象。试图创建接口实例的代码将无法编译。
- en: A.6.3 Twist in the Tale 6.3
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.6.3 故事中的转折 6.3
- en: 'Purpose: If there is no collision with the name of a variable defined in the
    base class or derived class, the variable can be accessed using both `super` and
    `this` references from a derived class. If there is a collision, the base class
    variable can be accessed using the `super` reference.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：如果没有与基类或派生类中定义的变量名称冲突，则可以从派生类使用`super`和`this`引用访问变量。如果有冲突，则可以使用`super`引用来访问基类变量。
- en: 'Answer: b'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：b
- en: 'Explanation: In a derived class, you’d normally use the implicit reference
    `super` to refer to a method or variable of a base class. Similarly, you’d normally
    use the implicit reference `this` to refer to a method or variable defined in
    the same class. A derived class contains within it an object of its base class
    and can access non-`private` members of its base class. A derived class can *also*
    refer to the members of its base class as its own members using the reference
    `this`. This approach is acceptable only if the same member isn’t defined in the
    derived class, that is, if there are no name collisions.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：在派生类中，你通常使用隐式引用`super`来引用基类的方法或变量。同样，你通常使用隐式引用`this`来引用同一类中定义的方法或变量。派生类包含其基类的对象，并且可以访问其基类的非`私有`成员。派生类可以使用引用`this`来将其基类的成员作为自己的成员来引用。这种方法只有在派生类中没有定义相同的成员时才是可接受的，也就是说，没有名称冲突。
- en: The base class `Employee` defines two non-`private` variables, `name` and `address`,
    which are accessible in `Employee`’s derived class `Programmer`. The class `Programmer`
    also defines an instance variable `name`, so the variable `name` should be prefixed
    with the explicit references `super` and `this` to refer to the variable `name`
    defined in the classes `Employee` and `Programmer`. The variable `address` can
    be referred to using both `super` and `this` in the derived class `Programmer`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 基类`Employee`定义了两个非`私有`变量，`name`和`address`，这些变量在`Employee`的派生类`Programmer`中是可访问的。类`Programmer`还定义了一个实例变量`name`，因此变量`name`应该使用显式的引用`super`和`this`来引用在`Employee`和`Programmer`类中定义的变量`name`。变量`address`在派生类`Programmer`中可以使用`super`和`this`来引用。
- en: Option (a) is incorrect. The derived class `Programmer` can refer to the variable
    `address` defined in the base class using `this.address`. This value won’t print
    `null`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 选项(a)是不正确的。派生类`Programmer`可以使用`this.address`来引用在基类中定义的变量`address`。这个值不会打印`null`。
- en: Option (c) is incorrect. `this.address` won’t print blank when accessed from
    the derived class `Programmer`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 选项(c)是不正确的。从派生类`Programmer`访问时，`this.address`不会打印空白。
- en: Option (d) is incorrect. The code has no compilation issues.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 选项(d)是不正确的。代码没有编译问题。
- en: A.6.4 Twist in the Tale 6.4
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.6.4 故事中的转折 6.4
- en: 'Purpose: Polymorphic methods should define a method’s overriding rules.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：多态方法应该定义一个方法的重写规则。
- en: 'Answer: a'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a
- en: 'Explanation: Polymorphic methods exist when classes or interfaces share an
    inheritance relationship. A polymorphic method can be defined by a derived class
    if'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：当类或接口共享继承关系时存在多态方法。如果派生类可以定义一个多态方法，则
- en: The derived class implements an `abstract` method defined in a base class or
    interface
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类实现了在基类或接口中定义的`抽象`方法
- en: The derived class overrides a non-`abstract` method defined in a base class
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类覆盖了在基类中定义的非`抽象`方法
- en: Options (b) and (d) are incorrect. A method can’t be overridden if it defines
    a different parameter list.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 选项(b)和(d)是不正确的。如果一个方法定义了不同的参数列表，则不能重写该方法。
- en: Option (c) is incorrect. The return type of the overridden method must be the
    same in the base class and the derived class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 选项(c)是不正确的。重写方法的重写类型必须在基类和派生类中相同。
- en: 'A.7 [Chapter 7](kindle_split_021.html#ch07): Exception handling'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.7 [第7章](kindle_split_021.html#ch07)：异常处理
- en: '[Chapter 7](kindle_split_021.html#ch07) includes five Twist in the Tale exercises.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](kindle_split_021.html#ch07) 包含了五个故事中的转折练习。'
- en: A.7.1 Twist in the Tale 7.1
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.7.1 故事中的转折 7.1
- en: 'Purpose: A `finally` block can’t be placed before the `catch` blocks. A number
    of programmers have compared this question with placing the label `default` before
    the label `case` in a `switch` construct. Though the latter approach works, the
    `finally` and `catch` blocks aren’t so flexible.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：`finally` 块不能放在 `catch` 块之前。许多程序员将这个问题与在 `switch` 结构中将标签 `default` 放在标签 `case`
    之前进行比较。尽管后者方法可行，但 `finally` 和 `catch` 块并不那么灵活。
- en: 'Answer: d'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：d
- en: 'Explanation: Options (a), (b), and (c) are incorrect because code that defines
    a `finally` block before `catch` blocks won’t compile.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：选项 (a)、(b) 和 (c) 是错误的，因为定义在 `catch` 块之前的 `finally` 块的代码无法编译。
- en: A.7.2 Twist in the Tale 7.2
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.7.2 故事中的转折 7.2
- en: 'Purpose: Unhandled exceptions thrown by an inner exception handler are passed
    on to the outer `try-catch` block to handle.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：未处理的异常由内部异常处理器传递到外部的 `try-catch` 块以处理。
- en: 'Answer: a'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：a
- en: 'Explanation: Options (b), (c), and (d) are incorrect. The question assumes
    that a text file players.txt exists on your system so that the following code
    won’t throw a `FileNotFoundException` exception:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：选项 (b)、(c) 和 (d) 是错误的。此问题假设系统上存在一个名为 players.txt 的文本文件，因此以下代码不会抛出 `FileNotFoundException`
    异常：
- en: '[PRE13]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code defined for this question doesn’t initialize the `static` variable
    `coach` before executing the following code, which is bound to throw a `NullPointerException`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为此问题定义的代码在执行以下代码之前没有初始化 `static` 变量 `coach`，这将必然抛出 `NullPointerException`：
- en: '[PRE14]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous line of code is defined in the inner `try` block, which doesn’t
    define an exception handler for the exception `NullPointerException`. This exception
    is propagated to the outer exception-handler block. The outer exception handler
    *catches* the `NullPointerException` thrown by the inner `try` block and executes
    the appropriate exception handler. Hence, the code prints the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码定义在内部 `try` 块中，该块没有为 `NullPointerException` 异常定义异常处理器。这个异常被传播到外部的异常处理器块。外部异常处理器
    *捕获* 内部 `try` 块抛出的 `NullPointerException` 并执行适当的异常处理器。因此，代码打印以下内容：
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A.7.3 Twist in the Tale 7.3
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.7.3 故事中的转折 7.3
- en: 'Purpose: To determine whether exception-handling code for errors will execute.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：确定错误处理的异常代码是否会执行。
- en: 'Answer: b'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：b
- en: 'Explanation: We know that typically errors shouldn’t be handled programmatically
    and that they should be left for the JVM to take care of. Also, you can’t be sure
    that error-handling code for all the errors will execute. For example, error-handling
    code for `StackOverFlowError` may execute but (as the name suggests) may not execute
    for `VirtualMachineError`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：我们知道通常错误不应该通过程序处理，而应该留给 JVM 处理。此外，你也不能确定所有错误的错误处理代码都会执行。例如，`StackOverFlowError`
    的错误处理代码可能会执行，但（正如其名称所暗示的）可能不会为 `VirtualMachineError` 执行。
- en: A.7.4 Twist in the Tale 7.4
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.7.4 故事中的转折 7.4
- en: 'Purpose: `ClassCastException` is a runtime exception. As you know, a runtime
    exception can be thrown only by the JVM.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：`ClassCastException` 是一个运行时异常。正如你所知，运行时异常只能由 JVM 抛出。
- en: 'Answer: b, d'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：b, d
- en: 'Explanation: Options (a) and (c) are incorrect because the code throws `ClassCast-Exception`,
    which is a runtime exception, for the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：选项 (a) 和 (c) 是错误的，因为代码会抛出 `ClassCastException`，这是一个运行时异常，对于以下代码：
- en: '[PRE16]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Option (d) is correct because neither the class `BlackInk` nor any of its base
    classes implement the interface `Printable`. Thus, the code that assigns `blackInk`
    to `printable` without an explicit cast will fail to compile.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 (d) 是正确的，因为 `BlackInk` 类及其任何基类都没有实现 `Printable` 接口。因此，将 `blackInk` 赋值给 `printable`
    而不进行显式转换的代码将无法编译。
- en: A.7.5 Twist in the Tale 7.5
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.7.5 故事中的转折 7.5
- en: 'Purpose: Trying to access a nonexistent position of an array throws an `ArrayIndexOutOfBoundsException`.
    Calling a member on a `null` value stored in an array throws a `NullPointerException`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 目的：尝试访问数组中不存在的位置会抛出 `ArrayIndexOutOfBoundsException`。在存储在数组中的 `null` 值上调用成员会抛出
    `NullPointerException`。
- en: 'Answer: c'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：c
- en: 'Explanation: Let’s indent the assignment of the two-dimensional array `oldLaptops`
    so that it’s easier to understand the values that are assigned to it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：让我们缩进二维数组 `oldLaptops` 的赋值，以便更容易理解分配给它的值：
- en: '[PRE17]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code results in the following assignments:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码导致以下赋值：
- en: '[PRE18]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A pictorial representation of the two-dimensional `String` array `oldLaptops`
    is shown in [figure A.6](#app01fig06).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 两个维度的 `String` 数组 `oldLaptops` 的示意图显示在 [图 A.6](#app01fig06) 中。
- en: Figure A.6\. The array `oldLaptops`
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.6\. 数组 `oldLaptops`
- en: '![](a0fig06.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](a0fig06.jpg)'
- en: As you can see, `oldLaptops[3]` is an array of 10 uninitialized `String` objects.
    All the members (from index position `0` to `9`) of the array `oldLaptops[3]`
    are assigned a `null` value. The code on line `4` tries to call the method `length`
    on the first element of array `oldLaptops[0]`, which is `null`, throwing a `NullPointerException`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`oldLaptops[3]` 是一个包含 10 个未初始化的 `String` 对象的数组。数组 `oldLaptops[3]` 的所有成员（从索引位置
    `0` 到 `9`）都被分配了一个 `null` 值。第 `4` 行的代码试图在数组 `oldLaptops[0]` 的第一个元素上调用 `length`
    方法，该元素是 `null`，从而抛出了 `NullPointerException`。
