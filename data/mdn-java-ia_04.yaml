- en: Part 5\. Enhanced Java concurrency
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5部分\. 加强版Java并发
- en: The fifth part of this book explores the more advanced ways of structuring concurrent
    programs in Java—beyond the ideas of easy-to-use parallel processing for streams
    introduced in [chapters 6](kindle_split_017.xhtml#ch06) and [7](kindle_split_018.xhtml#ch07).
    Again, nothing in the rest of the book depends on this part, so do feel free to
    skip this part if you don’t (yet) need to explore these ideas.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第五部分探讨了在Java中构建并发程序的更高级方法——超越[第6章](kindle_split_017.xhtml#ch06)和[第7章](kindle_split_018.xhtml#ch07)中引入的易于使用的流并行处理理念。再次强调，本书其余部分的内容不依赖于本部分，因此如果您（目前）不需要探索这些想法，请随时跳过这部分。
- en: '[Chapter 15](kindle_split_029.xhtml#ch15) is new to this second edition and
    covers the “big-picture” idea of asynchronous APIs, including the ideas of Futures
    and the publish-subscribe protocol behind reactive programming and encapsulated
    in the Java 9 Flow API.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第15章](kindle_split_029.xhtml#ch15)是第二版的新增内容，涵盖了异步API的“大局”理念，包括Futures和反应式编程背后的发布-订阅协议，这些都被封装在Java
    9 Flow API中。'
- en: '[Chapter 16](kindle_split_030.xhtml#ch16) explores `CompletableFuture`, which
    lets you express complex asynchronous computations in a declarative way—paralleling
    the design of the Streams API.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16章](kindle_split_030.xhtml#ch16)探讨了`CompletableFuture`，它允许您以声明式的方式表达复杂的异步计算，与Streams
    API的设计相呼应。'
- en: '[Chapter 17](kindle_split_031.xhtml#ch17) is also new to this second edition
    and explores the Java 9 Flow API in detail, focusing on practical reactive programming
    code.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](kindle_split_031.xhtml#ch17)也是第二版的新增内容，详细探讨了Java 9 Flow API，重点关注实用的反应式编程代码。'
- en: Chapter 15\. Concepts behind CompletableFuture and reactive programming
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章\. CompletableFuture和反应式编程背后的概念
- en: '*This chapter covers*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Threads, Futures, and the evolutionary forces causing Java to support richer
    concurrency APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程、未来以及导致Java支持更丰富并发API的进化力量
- en: Asynchronous APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步API
- en: The boxes-and-channels view of concurrent computing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发计算的框-通道视图
- en: CompletableFuture combinators to connect boxes dynamically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于动态连接框的CompletableFuture组合器
- en: The publish-subscribe protocol that forms the basis of the Java 9 Flow API for
    reactive programming
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成Java 9 Flow API反应式编程基础的发布-订阅协议
- en: Reactive programming and reactive systems
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程和反应式系统
- en: In recent years, two trends are obliging developers to rethink the way software
    is written. The first trend is related to the hardware on which applications run,
    and the second trend concerns how applications are structured (particularly how
    they interact). We discussed the effect of the hardware trend in [chapter 7](kindle_split_018.xhtml#ch07).
    We noted that since the advent of multicore processors, the most effective way
    to speed your applications is to write software that can fully exploit multicore
    processors. You saw that you can split large tasks and make each subtask run in
    parallel with the others. You also learned how the fork/join framework (available
    since Java 7) and parallel streams (new in Java 8) allow you to accomplish this
    task in a simpler, more effective way than working directly with threads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，两个趋势迫使开发者重新思考软件的编写方式。第一个趋势与运行应用程序的硬件有关，第二个趋势涉及应用程序的结构（尤其是它们如何交互）。我们在[第7章](kindle_split_018.xhtml#ch07)中讨论了硬件趋势的影响。我们指出，自从多核处理器问世以来，提高应用程序速度最有效的方法是编写能够充分利用多核处理器的软件。您了解到，您可以分解大任务，并使每个子任务与其他子任务并行运行。您还学习了如何使用自Java
    7以来可用的fork/join框架和Java 8中的并行流以比直接操作线程更简单、更有效的方式完成此任务。
- en: The second trend reflects the increasing availability and use by applications
    of Internet services. The adoption of microservices architecture, for example,
    has grown over the past few years. Instead of being one monolithic application,
    your application is subdivided into smaller services. The coordination of these
    smaller services requires increased network communication. Similarly, many more
    internet services are accessible through public APIs, made available by known
    providers such as Google (localization information), Facebook (social information),
    and Twitter (news). Nowadays, it’s relatively rare to develop a website or a network
    application that works in total isolation. It’s far more likely that your next
    web application will be a mashup, using content from multiple sources and aggregating
    it to ease your users’ lives.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个趋势反映了应用程序对互联网服务的可用性和使用的增加。例如，微服务架构在过去几年中得到了增长。你的应用程序不再是单一的大型应用，而是被细分为更小的服务。这些较小服务的协调需要增加网络通信。同样，许多互联网服务通过公共API提供，由知名提供商如谷歌（本地化信息）、Facebook（社交信息）和Twitter（新闻）提供。如今，开发一个完全独立工作的网站或网络应用相对罕见。你的下一个网络应用更有可能是一个混合应用，使用来自多个来源的内容，并将其聚合以简化用户的生活。
- en: You may want to build a website that collects and summarizes social-media sentiment
    on a given topic to your French users. To do so, you could use the Facebook or
    Twitter API to find trending comments about that topic in many languages and rank
    the most relevant ones with your internal algorithms. Then you might use Google
    Translate to translate the comments into French or use Google Maps to geolocate
    their authors, aggregate all this information, and display it on your website.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要构建一个网站，收集并总结特定主题在法国用户中的社交媒体情绪。为此，你可以使用Facebook或Twitter API来查找关于该主题的多种语言的趋势评论，并使用你内部的算法对最相关的评论进行排序。然后你可能使用谷歌翻译将评论翻译成法语或使用谷歌地图定位其作者，聚合所有这些信息，并在你的网站上显示。
- en: If any of these external network services are slow to respond, of course, you’ll
    want to provide partial results to your users, perhaps showing your text results
    alongside a generic map with a question mark in it instead of showing a blank
    screen until the map server responds or times out. [Figure 15.1](#ch15fig01) illustrates
    how this style of *mashup* application interacts with remote services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些外部网络服务响应缓慢，当然，你将希望向用户提供部分结果，例如，在地图服务器响应或超时之前显示一个带有问号的通用地图，而不是显示一个空白屏幕。[图15.1](#ch15fig01)说明了这种风格的*mashup*应用如何与远程服务交互。
- en: Figure 15.1\. A typical mashup application
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.1\. 一个典型的混合应用
- en: '![](Images/15fig01_alt.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig01_alt.jpg)'
- en: To implement applications like this, you have to contact multiple web services
    across the Internet. But you don’t want to block your computations and waste billions
    of precious clock cycles of your CPU waiting for an answer from these services.
    You shouldn’t have to wait for data from Facebook before processing the data coming
    from Twitter, for example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这样的应用程序，你必须联系互联网上的多个网络服务。但你不想阻塞你的计算并浪费CPU宝贵的数十亿时钟周期等待这些服务的答案。例如，你不应该在处理来自Twitter的数据之前等待来自Facebook的数据。
- en: This situation represents the other side of the multitask-programming coin.
    The fork/join framework and parallel streams, discussed in [chapter 7](kindle_split_018.xhtml#ch07),
    are valuable tools for parallelism; they divide a task into multiple subtasks
    and perform those subtasks in parallel on different cores, CPUs, or even machines.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况代表了多任务编程的另一面。在第7章中讨论的fork/join框架和并行流是并行化的宝贵工具；它们将任务分解为多个子任务，并在不同的核心、CPU或甚至机器上并行执行这些子任务。
- en: Conversely, when you’re dealing with concurrency instead of parallelism, or
    when your main goal is to perform several loosely related tasks on the same CPUs,
    keeping their cores as busy as possible to maximize the throughput of your application,
    you want to avoid blocking a thread and wasting its computational resources while
    waiting (potentially for quite a while) for a result from a remote service or
    from interrogating a database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当你处理并发而不是并行时，或者当你主要的目标是在同一CPU上执行几个松散相关的任务，尽可能让它们的内核忙碌以最大化应用程序的吞吐量时，你想要避免阻塞线程并浪费其计算资源，在等待（可能相当长一段时间）远程服务或查询数据库的结果。
- en: Java offers two main tool sets for such circumstances. First, as you’ll see
    in [chapters 16](kindle_split_030.xhtml#ch16) and [17](kindle_split_031.xhtml#ch17),
    the `Future` interface, and particularly its Java 8 `CompletableFuture` implementation,
    often provide simple and effective solutions ([chapter 16](kindle_split_030.xhtml#ch16)).
    More recently, Java 9 added the idea of reactive programming, built around the
    idea of the so-called publish-subscribe protocol via the `Flow` API, which offers
    more sophisticated programming approaches ([chapter 17](kindle_split_031.xhtml#ch17)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java为这种情形提供了两个主要的工具集。首先，正如你将在[第16章](kindle_split_030.xhtml#ch16)和[第17章](kindle_split_031.xhtml#ch17)中看到的，`Future`接口，特别是其Java
    8的`CompletableFuture`实现，通常提供简单而有效的解决方案（[第16章](kindle_split_030.xhtml#ch16)）。最近，Java
    9增加了响应式编程的概念，它围绕所谓的发布-订阅协议通过`Flow` API构建，提供了更复杂的编程方法（[第17章](kindle_split_031.xhtml#ch17)）。
- en: '[Figure 15.2](#ch15fig02) illustrates the difference between concurrency and
    parallelism. Concurrency is a programming property (overlapped execution) that
    can occur even for a single-core machine, whereas parallelism is a property of
    execution hardware (simultaneous execution).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15.2](#ch15fig02) 展示了并发与并行之间的区别。并发是一种编程属性（重叠执行），即使对于单核机器也可以发生，而并行性是执行硬件的属性（同时执行）。'
- en: Figure 15.2\. Concurrency versus parallelism
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.2. 并发与并行对比
- en: '![](Images/15fig02_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig02_alt.jpg)'
- en: The rest of this chapter explains the fundamental ideas underpinning Java’s
    new CompletableFuture and Flow APIs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分解释了支撑Java新CompletableFuture和Flow API的基本思想。
- en: We start by explaining the Java evolution of concurrency, including Threads,
    and higher-level abstractions, including Thread Pools and Futures ([section 15.1](#ch15lev1sec1)).
    We note that [chapter 7](kindle_split_018.xhtml#ch07) dealt with mainly using
    parallelism in looplike programs. [Section 15.2](#ch15lev1sec2) explores how you
    can better exploit concurrency for method calls. [Section 15.3](#ch15lev1sec3)
    gives you a diagrammatic way to see parts of programs as boxes that communicate
    over channels. [Section 15.4](#ch15lev1sec4) and [section 15.5](#ch15lev1sec5)
    look at the CompletableFuture and reactive-programming principles in Java 8 and
    9\. Finally, [section 15.6](#ch15lev1sec6) explains the difference between a reactive
    system and reactive programming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解释Java在并发方面的演变，包括线程和高级抽象，如线程池和Future（[第15.1节](#ch15lev1sec1)）。我们注意到[第7章](kindle_split_018.xhtml#ch07)主要讨论了在循环程序中使用并行性。[第15.2节](#ch15lev1sec2)探讨了如何更好地利用并发进行方法调用。[第15.3节](#ch15lev1sec3)提供了一种图示方法，将程序的某些部分视为通过通道进行通信的盒子。[第15.4节](#ch15lev1sec4)和[第15.5节](#ch15lev1sec5)探讨了Java
    8和9中的CompletableFuture和响应式编程原则。[最后，[第15.6节](#ch15lev1sec6)解释了响应式系统与响应式编程之间的区别。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Guidance for the reader**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**读者指南**'
- en: This chapter contains little real-life Java code. We suggest that readers who
    want to see only code skip to [chapters 16](kindle_split_030.xhtml#ch16) and [17](kindle_split_031.xhtml#ch17).
    On the other hand, as we’ve all discovered, code that implements unfamiliar ideas
    can be hard to understand. Therefore, we use simple functions and include diagrams
    to explain the big-picture ideas, such as the publish-subscribe protocol behind
    the Flow API capturing reactive programming.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含很少的实际Java代码。我们建议只想看代码的读者跳转到[第16章](kindle_split_030.xhtml#ch16)和[第17章](kindle_split_031.xhtml#ch17)。另一方面，正如我们所有人所发现的，实现不熟悉想法的代码可能难以理解。因此，我们使用简单的函数并包含图表来解释大局，例如Flow
    API背后的发布-订阅协议，该协议捕获了响应式编程。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We exemplify most of the concepts with a running example showing how to calculate
    expressions such as `f(x)+g(x)` and then return, or print, the result by using
    various Java concurrency features—assuming that `f(x)` and `g(x)` are long-running
    computations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个运行示例来举例说明大多数概念，展示如何使用各种Java并发特性来计算表达式，如`f(x)+g(x)`，然后返回或打印结果——假设`f(x)`和`g(x)`是长时间运行的计算。
- en: 15.1\. Evolving Java support for expressing concurrency
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1. 不断发展的Java对表达并发的支持
- en: Java has evolved considerably in its support for concurrent programming, largely
    reflecting the changes in hardware, software systems, and programming concepts
    over the past 20 years. Summarizing this evolution can help you understand the
    reason for the new additions and their roles in programming and system design.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java在支持并发编程方面已经取得了很大的进步，这主要反映了过去20年来硬件、软件系统和编程概念的变化。总结这一演变可以帮助你理解新添加内容的原因以及它们在编程和系统设计中的作用。
- en: Initially, Java had locks (via `synchronized` classes and methods), `Runnable`s
    and `Thread`s. In 2004, Java 5 introduced the `java.util.concurrent` package,
    which supported more expressive concurrency, particularly the `ExecutorService`^([[1](#ch15fn01)])
    interface (which decoupled task submission from thread execution), as well as
    `Callable<T>` and `Future<T>`, which produced higher-level and result-returning
    variants of `Runnable` and `Thread` and used generics (also introduced in Java
    5). `ExecutorService`s can execute both `Runnable`s and `Callable`s. These features
    facilitated parallel programming on the multicore CPUs that started to appear
    the following year. To be honest, nobody enjoyed working with threads directly!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Java 有锁（通过 `synchronized` 类和方法）、`Runnable`s 和 `Thread`s。在 2004 年，Java 5 引入了
    `java.util.concurrent` 包，它支持更丰富的并发性，特别是 `ExecutorService` 接口（它将任务提交与线程执行解耦），以及
    `Callable<T>` 和 `Future<T>`，它们是 `Runnable` 和 `Thread` 的高级和返回结果的变体，并使用了泛型（也是在 Java
    5 中引入的）。`ExecutorService`s 可以执行 `Runnable`s 和 `Callable`s。这些特性促进了随后一年出现的多核 CPU
    上的并行编程。说实话，没有人喜欢直接与线程打交道！
- en: ¹
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `ExecutorService` interface extends the `Executor` interface with the `submit`
    method to run a `Callable`; the `Executor` interface merely has an `execute` method
    for `Runnables`.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ExecutorService` 接口通过 `submit` 方法扩展了 `Executor` 接口以运行 `Callable`；`Executor`
    接口仅有一个 `execute` 方法用于 `Runnables`。'
- en: Later versions of Java continued to enhance concurrency support, as it became
    increasingly demanded by programmers who needed to program multicore CPUs effectively.
    As you saw in [chapter 7](kindle_split_018.xhtml#ch07), Java 7 added `java.util.concurrent.Recursive-Task`
    to support fork/join implementation of divide-and-conquer algorithms, and Java
    8 added support for `Stream`s and their parallel processing (building on the newly
    added support for lambdas).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的后续版本继续增强并发支持，因为随着程序员需要有效地编程多核 CPU，这种需求变得越来越迫切。正如您在 [第 7 章](kindle_split_018.xhtml#ch07)
    中所看到的，Java 7 添加了 `java.util.concurrent.Recursive-Task` 以支持分治算法的 fork/join 实现，Java
    8 添加了对 `Stream`s 和它们并行处理的支持（建立在新添加的 lambda 支持之上）。
- en: Java further enriched its concurrency features by providing support for *composing*
    Futures (via the Java 8 `CompletableFuture` implementation of `Future`, [section
    15.4](#ch15lev1sec4) and [chapter 16](kindle_split_030.xhtml#ch16)), and Java
    9, provided explicit support for distributed asynchronous programming. These APIs
    give you a mental model and toolkit for building the sort of mashup application
    mentioned in the introduction to this chapter. There the application worked by
    contacting various web services and combining their information in real time for
    a user or to expose it as a further web service. This process is called *reactive
    programming*, and Java 9 provides support for it via the *publish-subscribe protocol*
    (specified by the `java.util.concurrent.Flow` interface; see [section 15.5](#ch15lev1sec5)
    and [chapter 17](kindle_split_031.xhtml#ch17)). A key concept of `CompletableFuture`
    and `java.util.concurrent.Flow` is to provide programming structures that enable
    independent tasks to execute concurrently wherever possible and in a way that
    easily exploits as much as possible of the parallelism provided by multicore or
    multiple machines.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Java 通过提供对 *组合* 未来的支持（通过 Java 8 的 `CompletableFuture` 实现 `Future`，[第 15.4 节](#ch15lev1sec4)
    和 [第 16 章](kindle_split_030.xhtml#ch16)），进一步丰富了其并发特性，并且 Java 9 提供了对分布式异步编程的显式支持。这些
    API 为您提供了构建本章引言中提到的混合应用的心理模型和工具集。在那里，应用程序通过联系各种网络服务并在实时中为用户组合它们的信息，或者将其作为进一步的网络服务公开来工作。这个过程被称为
    *响应式编程*，Java 9 通过 *发布-订阅协议*（由 `java.util.concurrent.Flow` 接口指定；参见 [第 15.5 节](#ch15lev1sec5)
    和 [第 17 章](kindle_split_031.xhtml#ch17)）提供了对它的支持。`CompletableFuture` 和 `java.util.concurrent.Flow`
    的一个关键概念是提供编程结构，使得尽可能独立地执行任务，并以一种能够尽可能充分利用多核或多机提供的并行性的方式执行。
- en: 15.1.1\. Threads and higher-level abstractions
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.1. 线程和高级抽象
- en: Many of us learned about threads and processes from a course on operating systems.
    A single-CPU computer can support multiple users because its operating system
    allocates a process to each user. The operating system gives these processes separate
    virtual address spaces so that two users feel like they’re the only users of the
    computer. The operating system furthers this illusion by waking periodically to
    share the CPU among the processes. A process can request that the operating system
    allocate it one or more *threads*—processes that share an address space as their
    owning process and therefore can run tasks concurrently and cooperatively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人都是从操作系统课程中了解到线程和进程的。单核CPU计算机可以支持多个用户，因为它的操作系统为每个用户分配一个进程。操作系统为这些进程提供单独的虚拟地址空间，这样两个用户就会感觉他们是计算机的唯一用户。操作系统通过定期唤醒以在进程之间共享CPU来进一步这种错觉。一个进程可以请求操作系统为其分配一个或多个*线程*——这些线程与拥有它们的进程共享地址空间，因此可以并发和协作地运行任务。
- en: In a multicore setting, perhaps a single-user laptop running only one user process,
    a program can never fully exploit the computing power of the laptop unless it
    uses threads. Each core can be used for one or more processes or threads, but
    if your program doesn’t use threads, it’s effectively using only one of the processor
    cores.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在多核环境中，可能是一个只运行一个用户进程的单用户笔记本电脑，除非它使用线程，否则程序永远无法充分利用笔记本电脑的计算能力。每个核心可以用于一个或多个进程或线程，但如果你不使用线程，实际上你只是在使用处理器核心中的一个。
- en: Indeed, if you have a four-core CPU and can arrange for each core to continually
    do useful work, your program theoretically runs up to four times faster. (Overheads
    reduce this result somewhere, of course.) Given an array of numbers of size 1,000,000
    storing the number of correct questions answered by students in an example, compare
    the program
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你有一个四核CPU并且能够安排每个核心持续进行有用的工作，你的程序理论上可以快四倍（当然，开销会降低这个结果）。给定一个包含1,000,000个数字的数组，存储学生在示例中回答的正确问题的数量，比较程序
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: running on a single thread, which worked fine in single-core days, with a version
    that creates four threads, with the first thread executing
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程上运行，这在单核时代工作得很好，有一个创建四个线程的版本，第一个线程执行
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and to the fourth thread executing
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以及第四个线程执行
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These four threads are complemented by the main program starting them in turn
    (.`start()` in Java), waiting for them to complete (`.join()`), and then computing
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个线程由主程序依次启动（Java中的`.start()`方法），等待它们完成（`.join()`方法），然后进行计算。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The trouble is that doing this for each loop is tedious and error-prone. Also,
    what can you do for code that isn’t a loop?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，对每个循环都这样做既麻烦又容易出错。此外，对于不是循环的代码，你能做什么？
- en: '[Chapter 7](kindle_split_018.xhtml#ch07) showed how Java Streams can achieve
    this parallelism with little programmer effort by using internal iteration instead
    of external iteration (explicit loops):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](kindle_split_018.xhtml#ch07)展示了Java Streams如何通过使用内部迭代而不是外部迭代（显式循环）来以最小的程序员努力实现并行性：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The takeaway idea is that parallel Stream iteration is a higher-level concept
    than explicit use of threads. In other words, this use of Streams *abstracts*
    a given use pattern of threads. This abstraction into Streams is analogous to
    a design pattern, but with the benefit that much of the complexity is implemented
    inside the library rather than being boilerplate code. [Chapter 7](kindle_split_018.xhtml#ch07)
    also explained how to use `java.util.concurrent.RecursiveTask` support in Java
    7 for the fork/join abstraction of threads to parallelize divide-and-conquer algorithms,
    providing a higher-level way to sum the array efficiently on a multicore machine.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的想法是，并行Stream迭代是一个比显式使用线程的高级概念。换句话说，这种对Streams的使用*抽象*了线程的特定使用模式。这种抽象到Streams类似于设计模式，但好处是大部分复杂性都在库内部实现，而不是样板代码。[第7章](kindle_split_018.xhtml#ch07)还解释了如何使用Java
    7中的`java.util.concurrent.RecursiveTask`支持来并行化分而治之算法的fork/join抽象，提供了一种在多核机器上高效求和数组的高级方法。
- en: Before looking at additional abstractions for threads, we visit the (Java 5)
    idea of `ExecutorServices` and the thread pools on which these further abstractions
    are built.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看线程的额外抽象之前，我们来看看（Java 5）的`ExecutorServices`概念以及这些进一步抽象所基于的线程池。
- en: 15.1.2\. Executors and thread pools
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.2. 执行器和线程池
- en: Java 5 provided the Executor framework and the idea of thread pools as a higher-level
    idea capturing the power of threads, which allow Java programmers to decouple
    task submission from task execution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5提供了Executor框架和线程池的概念，作为一个更高级的想法，它捕捉了线程的力量，允许Java程序员将任务提交与任务执行解耦。
- en: Problems with threads
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 线程的问题
- en: Java threads access operating-system threads directly. The problem is that operating-system
    threads are expensive to create and to destroy (involving interaction with page
    tables), and moreover, only a limited number exist. Exceeding the number of operating-system
    threads is likely to cause a Java application to crash mysteriously, so be careful
    not to leave threads running while continuing to create new ones.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Java线程直接访问操作系统线程。问题是操作系统线程的创建和销毁都很昂贵（涉及与页表的交互），而且数量有限。超过操作系统线程的数量可能会导致Java应用程序神秘地崩溃，所以请注意不要在继续创建新线程的同时留下线程运行。
- en: The number of operating system (and Java) threads will significantly exceed
    the number of hardware threads^([[2](#ch15fn02)]), so all the hardware threads
    can be usefully occupied executing code even when some operating-system threads
    are blocked or sleeping. As an example, the 2016 Intel Core i7-6900K server processor
    has eight cores, each with two symmetric multiprocessing (SMP) hardware threads,
    leading to 16 hardware threads, and a server may contain several of these processors,
    consisting of perhaps 64 hardware threads. By contrast, a laptop may have only
    one or two hardware threads, so portable programs must avoid making assumptions
    about how many hardware threads are available. Contrarily, the optimum number
    of Java threads for a given program depends on the number of hardware cores available!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（和Java）线程的数量将显著超过硬件线程的数量^([[2](#ch15fn02)]），因此即使一些操作系统线程被阻塞或睡眠，所有硬件线程也可以有效地执行代码。例如，2016年英特尔Core
    i7-6900K服务器处理器有八个核心，每个核心有两个对称多处理（SMP）硬件线程，总共16个硬件线程，服务器可能包含几个这样的处理器，可能包含64个硬件线程。相比之下，笔记本电脑可能只有一到两个硬件线程，因此可移植程序必须避免对可用的硬件线程数量做出假设。相反，给定程序的最佳Java线程数量取决于可用的硬件核心数量！
- en: ²
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We’d use the word *core* here, but CPUs like the Intel i7-6900K have multiple
    hardware threads per core, so the CPU can execute useful instructions even for
    short delays such as a cache miss.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在这里会使用“核心”这个词，但像英特尔i7-6900K这样的CPU每个核心都有多个硬件线程，因此即使对于像缓存未命中这样的短暂延迟，CPU也能执行有用的指令。
- en: Thread pools and why they’re better
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 线程池及其为何更好
- en: 'The Java `ExecutorService` provides an interface where you can submit tasks
    and obtain their results later. The expected implementation uses a pool of threads,
    which can be created by one of the factory methods, such as the `newFixedThreadPool`
    method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`ExecutorService`提供了一个接口，你可以提交任务并在稍后获取它们的结果。预期的实现使用线程池，这可以通过工厂方法之一创建，例如`newFixedThreadPool`方法：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method creates an `ExecutorService` containing `nThreads` (often called
    *worker threads*) and stores them in a thread pool, from which unused threads
    are taken to run submitted tasks on a first-come, first-served basis. These threads
    are returned to the pool when their tasks terminate. One great outcome is that
    it’s cheap to submit thousands of tasks to a thread pool while keeping the number
    of tasks to a hardware-appropriate number. Several configurations are possible,
    including the size of the queue, rejection policy, and priority for different
    tasks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个包含`nThreads`（通常称为*工作线程*）的`ExecutorService`，并将它们存储在线程池中，从其中取出未使用的线程以按先到先服务的原则运行提交的任务。当它们的任务结束时，这些线程被返回到池中。一个很好的结果是，在保持任务数量为硬件适当的数量同时，向线程池提交数千个任务的成本很低。可能的配置包括队列大小、拒绝策略和不同任务的优先级。
- en: 'Note the wording: The programmer provides a *task* (a `Runnable` or a `Callable`),
    which is executed by a *thread*.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意措辞：程序员提供一个*任务*（一个`Runnable`或`Callable`），由*线程*执行。
- en: Thread pools and why they’re worse
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 线程池及其为何更差
- en: Thread pools are better than explicit thread manipulation in almost all ways,
    but you need to be aware of two “gotchas:”
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池在几乎所有方面都比显式线程操作更好，但你需要意识到两个“陷阱”：
- en: A thread pool with *k* threads can execute only *k* tasks concurrently. Any
    further task submissions are held in a queue and not allocated a thread until
    one of the existing tasks completes. This situation is generally good, in that
    it allows you to submit many tasks without accidentally creating an excessive
    number of threads, but you have to be wary of tasks that sleep or wait for I/O
    or network connections. In the context of blocking I/O, these tasks occupy worker
    threads but do no useful work while they’re waiting. Try taking four hardware
    threads and a thread pool of size 5 and submitting 20 tasks to it ([figure 15.3](#ch15fig03)).
    You might expect that the tasks would run in parallel until all 20 have completed.
    But suppose that three of the first-submitted tasks sleep or wait for I/O. Then
    only two threads are available for the remaining 15 tasks, so you’re getting only
    half the throughput you expected (and would have if you created the thread pool
    with eight threads instead). It’s even possible to cause deadlock in a thread
    pool if earlier task submissions or already running tasks, need to wait for later
    task submissions, which is a typical use-pattern for Futures.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 *k* 个线程的线程池只能同时执行 *k* 个任务。任何进一步的提交任务都会被保留在队列中，直到现有任务之一完成才会分配线程。这种情况通常很好，因为它允许你提交许多任务而不会意外地创建过多的线程，但你必须警惕那些睡眠或等待I/O或网络连接的任务。在阻塞I/O的上下文中，这些任务在等待时占用工作线程，但不会做任何有用的工作。尝试使用四个硬件线程和一个大小为5的线程池提交20个任务（[图15.3](#ch15fig03)）。你可能期望任务会并行运行，直到所有20个任务都完成。但假设前三个提交的任务睡眠或等待I/O。那么，剩余的15个任务就只能有2个线程可用，所以你只能获得预期吞吐量的一半（如果你用8个线程创建线程池的话）。如果早期任务提交或已运行的任务需要等待后续任务提交，这通常是对Futures的典型使用模式，那么甚至可能导致线程池发生死锁。
- en: Figure 15.3\. Sleeping tasks reduce the throughput of thread pools.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.3\. 睡眠任务会降低线程池的吞吐量。
- en: '![](Images/15fig03_alt.jpg)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图15.3的替代文本](Images/15fig03_alt.jpg)'
- en: The takeaway is to try to avoid submitting tasks that can block (sleep or wait
    for events) to thread pools, but you can’t always do so in existing systems.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要点是要尽量避免向线程池提交可能阻塞（睡眠或等待事件）的任务，但在现有系统中你并不总是能这样做。
- en: Java typically waits for all threads to complete before allowing a return from
    `main` to avoid killing a thread executing vital code. Therefore, it’s important
    in practice and as part of good hygiene to shut down every thread pool before
    exiting the program (because worker threads for this pool will have been created
    but not terminated, as they’re waiting for another task submission). In practice,
    it’s common to have a long-running `ExecutorService` that manages an always-running
    Internet service. Java does provide the `Thread.setDaemon` method to control this
    behavior, which we discuss in the next section.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java通常在允许从`main`返回之前等待所有线程完成，以避免杀死执行关键代码的线程。因此，在实践中，作为良好卫生习惯的一部分，在退出程序之前关闭每个线程池是很重要的（因为该池的工作线程已经被创建但尚未终止，因为它们正在等待另一个任务提交）。在实践中，通常会有一个长时间运行的`ExecutorService`来管理一个始终运行的互联网服务。Java确实提供了`Thread.setDaemon`方法来控制这种行为，我们将在下一节讨论。
- en: '15.1.3\. Other abstractions of threads: non-nested with method calls'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.3\. 线程的其他抽象：非嵌套的方法调用
- en: 'To explain why the forms of concurrency used in this chapter differ from those
    used in [chapter 7](kindle_split_018.xhtml#ch07) (parallel Stream processing and
    the fork/join framework), we’ll note that the forms used in [chapter 7](kindle_split_018.xhtml#ch07)
    have one special property: whenever any task (or thread) is started within a method
    call, the same method call waits for it to complete before returning. In other
    words, thread creation and the matching `join()` happen in a way that nests properly
    within the call-return nesting of method calls. This idea, called *strict fork/join*,
    is depicted in [figure 15.4](#ch15fig04).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释为什么本章中使用的并发形式与第7章（并行Stream处理和fork/join框架）中使用的并发形式不同，我们将指出第7章中使用的并发形式有一个特殊属性：在方法调用中启动的任何任务（或线程）都会等待它完成后再返回。换句话说，线程创建和匹配的`join()`以正确的方式嵌套在方法调用的调用-返回嵌套中。这种称为*严格fork/join*的想法在[图15.4](#ch15fig04)中展示。
- en: Figure 15.4\. Strict fork/join. Arrows denote threads, circles represent forks
    and joins, and rectangles represent method calls and returns.
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.4\. 严格的fork/join。箭头表示线程，圆圈表示fork和join，矩形表示方法调用和返回。
- en: '![](Images/15fig04_alt.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4的替代文本](Images/15fig04_alt.jpg)'
- en: It’s relatively innocuous to have a more relaxed form of fork/join in which
    a spawned task escapes from an internal method call but is joined in an outer
    call, so that the interface provided to users still appears to be a normal call,^([[3](#ch15fn03)])
    as shown in [figure 15.5](#ch15fig05).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在一种更宽松的fork/join形式中，派生的任务可以从内部方法调用中逃逸，但在外部调用中合并，因此提供给用户的外观仍然像是正常的调用，^([[3](#ch15fn03)])
    如[图15.5](#ch15fig05)所示。
- en: ³
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compare “[Thinking Functionally](kindle_split_033.xhtml#ch18)” ([chapter 18](kindle_split_033.xhtml#ch18))
    in which we discuss having a side-effect-free interface to a method that internally
    uses side-effects!
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 比较一下“[功能性思考](kindle_split_033.xhtml#ch18)”([第18章](kindle_split_033.xhtml#ch18))，其中我们讨论了提供一个无副作用的接口给内部使用副作用的方法！
- en: Figure 15.5\. Relaxed fork/join
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.5. 松弛的fork/join
- en: '![](Images/15fig05_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig05_alt.jpg)'
- en: In this chapter, we focus on richer forms of concurrency in which threads created
    (or tasks spawned) by a user’s method call may outlive the call, as shown in [figure
    15.6](#ch15fig06).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关注更丰富的并发形式，其中用户方法调用创建的线程（或派生的任务）可能比调用存活得更久，如图15.6所示。
- en: Figure 15.6\. An asynchronous method
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.6. 异步方法
- en: '![](Images/15fig06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig06.jpg)'
- en: 'This type of method is often called an asynchronous method, particularly when
    the ongoing spawned task continues to do work that’s helpful to the method caller.
    We explore Java 8 and 9 techniques for benefiting from such methods later in this
    chapter, starting in [section 15.2](#ch15lev1sec2), but first, check the dangers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常被称为异步方法，尤其是当正在进行的派生任务继续执行对方法调用者有帮助的工作时。我们将在本章后面探索Java 8和9的技术，以从这些方法中受益，从[15.2节](#ch15lev1sec2)开始，但首先，检查一下危险：
- en: The ongoing thread runs concurrently with the code following the method call
    and therefore requires careful programming to avoid data races.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前线程与方法调用后的代码并发运行，因此需要仔细编程以避免数据竞争。
- en: 'What happens if the Java `main()` method returns before the ongoing thread
    has terminated? There are two answers, both rather unsatisfactory:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Java的`main()`方法在当前线程终止之前返回会发生什么？有两个答案，都相当令人不满意：
- en: Wait for all such outstanding threads before exiting the application.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在退出应用程序之前等待所有此类挂起的线程。
- en: Kill all outstanding threads and then exit.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杀死所有挂起的线程然后退出。
- en: The former solution risks a seeming application crash by never terminating due
    to a forgotten thread; the latter risks interrupting a sequence of I/O operations
    writing to disk, thereby leaving an external data in an inconsistent state. To
    avoid both of these problems, ensure that your program keeps track of all threads
    it creates and joins them all before exiting (including shutting down any thread
    pools).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种解决方案由于忘记的线程而永远不会终止，存在看似应用程序崩溃的风险；后一种解决方案会中断写入磁盘的I/O操作序列，从而将外部数据置于不一致的状态。为了避免这两个问题，确保你的程序跟踪它创建的所有线程，并在退出前将它们全部合并（包括关闭任何线程池）。
- en: Java threads can be labeled as *daemon*^([[4](#ch15fn04)]) or nondaemon, using
    the `setDaemon()` method call. Daemon threads are killed on exit (and therefore
    are useful for services that don’t leave the disk in an inconsistent state), whereas
    returning from `main` continues to wait for all threads that aren’t daemons to
    terminate before exiting the program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Java线程可以使用`setDaemon()`方法调用标记为*daemon*^([[4](#ch15fn04)])或nondaemon。守护线程在退出时被杀死（因此对于不会留下不一致磁盘状态的服务很有用），而从`main`返回则继续等待所有非守护线程终止，然后退出程序。
- en: ⁴
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Etymologically, *daemon* and *demon* arise from the same Greek word, but *daemon*
    captures the idea of a helpful spirit, whereas *demon* captures the idea of an
    evil spirit. UNIX coined the word *daemon* for computing purposes, using it for
    system services such as sshd, a process or thread that listens for incoming ssh
    connections.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从词源学上讲，*daemon*和*demon*都源于同一个希腊单词，但*daemon*捕捉到的是有益精神的概念，而*demon*捕捉到的是邪恶精神的概念。UNIX为计算目的创造了*daemon*这个词，用于系统服务，如sshd，一个监听传入ssh连接的进程或线程。
- en: 15.1.4\. What do you want from threads?
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.4. 你希望从线程中得到什么？
- en: What you want is to be able to structure your program so that whenever it can
    benefit from parallelism, enough tasks are available to occupy all the hardware
    threads, which means structuring your program to have many smaller tasks (but
    not too small because of the cost of task switching). You saw how to do this for
    loops and divide-conquer algorithms in [chapter 7](kindle_split_018.xhtml#ch07),
    using parallel stream processing and fork/join, but in the rest of this chapter
    (and in [chapters 16](kindle_split_030.xhtml#ch16) and [17](kindle_split_031.xhtml#ch17)),
    you see how to do it for method calls without writing swaths of boilerplate thread-manipulation
    code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望的是能够构建程序结构，以便每当它可以从并行化中受益时，都有足够多的任务来占用所有硬件线程，这意味着构建程序以拥有许多较小的任务（但不要因为任务切换的成本而太小）。您在[第7章](kindle_split_018.xhtml#ch07)中看到了如何为循环和分而治之算法做这件事，使用并行流处理和fork/join，但在本章的其余部分（以及第16章和第17章），您将看到如何为方法调用做这件事，而无需编写大量的模板线程操作代码。
- en: 15.2\. Synchronous and asynchronous APIs
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2. 同步和异步API
- en: '[Chapter 7](kindle_split_018.xhtml#ch07) showed you that Java 8 Streams give
    you a way to exploit parallel hardware. This exploitation happens in two stages.
    First, you replace external iteration (explicit `for` loops) with internal iteration
    (using Stream methods). Then you can use the `parallel()` method on Streams to
    allow the elements to be processed in parallel by the Java runtime library instead
    of rewriting every loop to use complex thread-creation operations. An additional
    advantage is that the runtime system is much better informed about the number
    of available threads when the loop is executed than is the programmer, who can
    only guess.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](kindle_split_018.xhtml#ch07)向您展示了Java 8 Streams如何让您利用并行硬件。这种利用分为两个阶段。首先，您将外部迭代（显式的`for`循环）替换为内部迭代（使用Stream方法）。然后您可以使用Streams上的`parallel()`方法，允许Java运行时库并行处理元素，而不是重写每个循环以使用复杂的线程创建操作。一个额外的优势是，当循环执行时，运行时系统比程序员更清楚地了解可用的线程数量，程序员只能猜测。'
- en: Situations other than loop-based computations can also benefit from parallelism.
    An important Java development that forms the background of this chapter and [chapters
    16](kindle_split_030.xhtml#ch16) and [17](kindle_split_031.xhtml#ch17) is asynchronous
    APIs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于循环的计算之外，其他情况也可以从并行化中受益。本章以及第16章和第17章的背景是一个重要的Java开发，即异步API。
- en: 'Let’s take for a running example the problem of summing the results of calls
    to methods `f` and `g` with signatures:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个运行示例来探讨，即计算方法`f`和`g`的调用结果之和的问题，这两个方法的签名如下：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For emphasis, we’ll refer to these signatures as a *synchronous API*, as they
    return their results when they physically return, in a sense that will soon become
    clear. You might invoke this API with a code fragment that calls them both and
    prints the sum of their results:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调，我们将把这些签名称为*同步API*，因为它们在物理返回时返回结果，这种含义很快就会变得清晰。您可能需要使用一个代码片段来调用它们并打印它们结果的和：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now suppose that methods `f` and `g` execute for a long time. (These methods
    could implement a mathematical optimization task, such as gradient descent, but
    in [chapters 16](kindle_split_030.xhtml#ch16) and [17](kindle_split_031.xhtml#ch17),
    we consider more-practical cases in which they make Internet queries.) In general,
    the Java compiler can do nothing to optimize this code because `f` and `g` may
    interact in ways that aren’t clear to the compiler. But if you know that `f` and
    `g` don’t interact, or you don’t care, you want to execute `f` and `g` in separate
    CPU cores, which makes the total execution time only the maximum of that of the
    calls to `f` and `g` instead of the sum. All you need to do is run the calls to
    `f` and `g` in separate threads. This idea is a great one, but it complicates^([[5](#ch15fn05)])
    the simple code from before:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设方法`f`和`g`执行时间较长。（这些方法可能实现数学优化任务，如梯度下降，但在第16章和第17章中，我们考虑更实际的案例，其中它们执行网络查询。）一般来说，Java编译器无法优化此代码，因为`f`和`g`可能以编译器不清楚的方式交互。但是，如果您知道`f`和`g`没有交互，或者您不在乎，您希望`f`和`g`在单独的CPU核心上执行，这样总执行时间只是`f`和`g`调用时间的最大值，而不是总和。您需要做的就是分别在不同的线程中运行`f`和`g`的调用。这个想法非常好，但它使之前的简单代码复杂化了^([[5](#ch15fn05)])。
- en: ⁵
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some of the complexity here has to do with transferring results back from the
    thread. Only final outer-object variables can be used in lambdas or inner classes,
    but the real problem is all the explicit thread manipulation.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里的一些复杂性涉及到将结果从线程中传回。只有最终的外部对象变量可以在 lambda 表达式或内部类中使用，但真正的问题是所有的显式线程操作。
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can simplify this code somewhat by using the `Future` API interface instead
    of `Runnable`. Assuming that you previously set up a thread pool as an `ExecutorService`
    (such as `executorService`), you can write
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `Future` API 接口而不是 `Runnable` 来简化此代码。假设您之前已将线程池设置为 `ExecutorService`（例如
    `executorService`），您可以编写
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: but this code is still polluted by the boilerplate code involving explicit calls
    to `submit`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但这段代码仍然被涉及显式调用 `submit` 的样板代码所污染。
- en: You need a better way of expressing this idea, analogous to how internal iteration
    on Streams avoided the need to use thread-creation syntax to parallelize external
    iteration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个更好的方式来表达这个想法，类似于在 Streams 的内部迭代避免了使用线程创建语法来并行化外部迭代的需求。
- en: The answer involves changing the API to an *asynchronous API*.^([[6](#ch15fn06)])
    Instead of allowing a method to return its result at the same time that it physically
    returns to the caller (synchronously), you allow it to return physically before
    producing its result, as shown in [figure 15.6](#ch15fig06). Thus, the call to
    `f` and the code following this call (here, the call to `g`) can execute in parallel.
    You can achieve this parallelism by using two techniques, both of which change
    the signatures of `f` *and* `g`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 答案涉及到将 API 更改为 *异步 API*。^([[6](#ch15fn06)]) 与允许方法在物理返回到调用者（同步）的同时返回其结果相比，您允许它在产生结果之前物理返回，如图
    15.6 所示。因此，对 `f` 的调用以及此调用之后的代码（这里是对 `g` 的调用）可以并行执行。您可以通过两种技术实现这种并行性，这两种技术都会改变
    `f` 和 `g` 的签名。
- en: ⁶
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Synchronous APIs are also known as *blocking APIs,* as the physical return is
    delayed until the result is ready (clearest when considering a call to an I/O
    operation), whereas asynchronous APIs can naturally implement nonblocking I/O
    (where the API call merely initiates the I/O operation without waiting for the
    result, provided that the library at hand, such as Netty, supports nonblocking
    I/O operations).
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同步 API 也被称为 *阻塞 API*，因为物理返回被延迟，直到结果准备好（在考虑对 I/O 操作的调用时最为明显），而异步 API 可以自然地实现非阻塞
    I/O（API 调用仅初始化 I/O 操作而不等待结果，前提是所使用的库，如 Netty，支持非阻塞 I/O 操作）。
- en: The first technique uses Java Futures in a better way. Futures appeared in Java
    5 and were enriched into `CompletableFuture` in Java 8 to make them composable;
    we explain this concept in [section 15.4](#ch15lev1sec4) and explore the Java
    API in detail with a worked Java code example in [chapter 16](kindle_split_030.xhtml#ch16).
    The second technique is a reactive-programming style that uses the Java 9 `java.util.concurrent.Flow`
    interfaces, based on the publish-subscribe protocol explained in [section 15.5](#ch15lev1sec5)
    and exemplified with practical code in [chapter 17](kindle_split_031.xhtml#ch17).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术以更好的方式使用 Java Futures。Futures 出现在 Java 5 中，并在 Java 8 中扩展为 `CompletableFuture`
    以使其可组合；我们在 [第 15.4 节](#ch15lev1sec4) 中解释了这个概念，并在 [第 16 章](kindle_split_030.xhtml#ch16)
    中通过一个工作的 Java 代码示例详细探讨了 Java API。第二种技术是一种使用 Java 9 `java.util.concurrent.Flow`
    接口的响应式编程风格，基于 [第 15.5 节](#ch15lev1sec5) 中解释的发布-订阅协议，并在 [第 17 章](kindle_split_031.xhtml#ch17)
    中通过实际代码进行示例。
- en: How do these alternatives affect the signatures of `f` and `g`?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替代方案如何影响 `f` 和 `g` 的签名？
- en: 15.2.1\. Future-style API
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1\. Future-style API
- en: In this alternative, change the signature of `f` and `g` to
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个替代方案中，将 `f` 和 `g` 的签名更改为
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: and change the calls to
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 并更改调用为
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The idea is that method `f` returns a Future, which contains a task that continues
    to evaluate its original body, but the return from `f` happens as quickly as possible
    after the call. Method `g` similarly returns a future, and the third code line
    uses `get()` to wait for both Futures to complete and sums their results.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是方法 `f` 返回一个 Future，其中包含一个继续评估其原始体的任务，但 `f` 的返回尽可能快地发生在调用之后。方法 `g` 类似地返回一个
    Future，第三行代码使用 `get()` 等待两个 Future 完成，并求和它们的结果。
- en: 'In this case, you could have left the API and call of `g` unchanged without
    reducing parallelism—only introducing Futures for `f`. You have two reasons not
    to do so in bigger programs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以在不减少并行性的情况下保持 API 和 `g` 的调用不变——只需为 `f` 引入 Future。在更大的程序中不这样做有两个原因：
- en: Other uses of `g` may require a Future-style version, so you prefer a uniform
    API style.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`的其他使用可能需要Future风格的版本，因此你更喜欢统一的API风格。'
- en: To enable parallel hardware to execute your programs as fast as possible, it’s
    useful to have more and smaller tasks (within reason).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使并行硬件尽可能快地执行你的程序，拥有更多且更小的任务（在合理范围内）是有用的。
- en: 15.2.2\. Reactive-style API
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.2\. 响应式API
- en: In the second alternative, the core idea is to use callback-style programming
    by changing the signature of `f` and `g` to
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种替代方案中，核心思想是通过改变`f`和`g`的签名来使用回调风格编程。
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This alternative may seem to be surprising at first. How can `f` work if it
    doesn’t return a value? The answer is that you instead pass a *callback*^([[7](#ch15fn07)])
    (a lambda) to `f` as an additional argument, and the body of `f` spawns a task
    that calls this lambda with the result when it’s ready instead of returning a
    value with `return`. Again, `f` returns immediately after spawning the task to
    evaluate the body, which results in the following style of code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代方案一开始可能看起来令人惊讶。如果`f`不返回值，它怎么能工作呢？答案是，你将一个*回调*^([[7](#ch15fn07)])（一个lambda）作为额外的参数传递给`f`，然后`f`的主体启动一个任务，在准备好时调用这个lambda而不是使用`return`返回值。再次强调，`f`在启动任务以评估主体后立即返回，这导致以下代码风格：
- en: ⁷
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some authors use the term *callback* to mean any lambda or method reference
    passed as an argument to a method, such as the argument to `Stream.filter` or
    `Stream.map`. We use it only for those lambda and method references that can be
    called *after* the method has returned.
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些作者使用术语*回调*来表示任何作为方法参数传递的lambda或方法引用，例如`Stream.filter`或`Stream.map`的参数。我们只将其用于那些可以在方法返回后调用的lambda和方法引用。
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Ah, but this isn’t the same! Before this code prints the correct result (the
    sum of the calls to `f` and `g`), it prints the fastest value to complete (and
    occasionally instead prints the sum twice, as there’s no locking here, and both
    operands to + could be updated before either of the `println` calls is executed).
    There are two answers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，但这并不相同！在这段代码打印出正确的结果（`f`和`g`调用的总和）之前，它打印出完成最快的值（有时甚至打印出总和两次，因为没有锁定，加法的两个操作数可以在任一`println`调用执行之前更新）。有两个答案：
- en: You could recover the original behavior by invoking `println` after testing
    with if-then-else that both callbacks have been called, perhaps by counting them
    with appropriate locking.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在测试后调用`println`来恢复原始行为，使用if-then-else检查两个回调都已调用，可能通过适当的锁定来计数。
- en: This reactive-style API is intended to react to a sequence of events, not to
    single results, for which `Future`s are more appropriate.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种响应式风格的API旨在对一系列事件做出反应，而不是对单个结果，对于`Future`s来说更为合适。
- en: Note that this reactive style of programming allows methods `f` and `g` to invoke
    their callback `dealWithResult` multiple times. The original versions of `f` and
    `g` were obliged to use a `return` that can be performed only once. Similarly,
    a `Future` can be completed only once, and its result is available to `get()`.
    In a sense, the reactive-style asynchronous API naturally enables a sequence (which
    we will later liken to a stream) of values, whereas the `Future`-style API corresponds
    to a one-shot conceptual framework.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种响应式编程风格允许方法`f`和`g`多次调用它们的回调`dealWithResult`。`f`和`g`的原始版本被迫使用只能执行一次的`return`。同样，`Future`只能完成一次，其结果可以通过`get()`获取。从某种意义上说，响应式风格的异步API自然地启用了一组值（我们稍后将将其比作流），而`Future`风格的API则对应于一次性概念框架。
- en: In [section 15.5](#ch15lev1sec5), we refine this core-idea example to model
    a spreadsheet call containing a formula such as `=C1+C2`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15.5节](#ch15lev1sec5)中，我们细化了这个核心思想示例，以模拟包含公式`=C1+C2`的工作表调用。
- en: You may argue that both alternatives make the code more complex. To some extent,
    this argument is correct; you shouldn’t thoughtlessly use either API for every
    method. But APIs keep code simpler (and use higher-level constructs) than explicit
    thread manipulation does. Also, careful use of these APIs for method calls that
    (a) cause long-running computations (perhaps longer than several milliseconds)
    or (b) wait for a network or for input from a human can significantly improve
    the efficiency of your application. In case (a), these techniques make your program
    faster without the explicit ubiquitous use of threads polluting your program.
    In case (b), there’s the additional benefit that the underlying system can use
    threads effectively without clogging up. We turn to the latter point in the next
    section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，这两种替代方案都会使代码更复杂。在某种程度上，这种论点是正确的；你不应该无意识地使用每个方法的API。但是，API比显式地操作线程使代码更简单（并使用更高级的构造）。此外，谨慎使用这些API进行方法调用，这些调用（a）导致长时间的计算（可能超过几毫秒）或（b）等待网络或来自人类的输入，可以显著提高应用程序的效率。在情况（a）中，这些技术使你的程序更快，而无需在程序中显式地使用污染线程。在情况（b）中，还有一个额外的好处，即底层系统可以有效地使用线程而不会阻塞。我们将在下一节中转向这一点。
- en: 15.2.3\. Sleeping (and other blocking operations) considered harmful
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.3. 休眠（以及其他阻塞操作）被认为是有害的
- en: When you’re interacting with a human or an application that needs to restrict
    the rate at which things happen, one natural way to program is to use the `sleep()`
    method. A sleeping thread still occupies system resources, however. This situation
    doesn’t matter if you have only a few threads, but it matters if you have many
    threads, most of which are sleeping. (See the discussion in [section 15.2.1](#ch15lev2sec5)
    and [figure 15.3](#ch15fig03).)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与人类或需要限制事件发生速率的应用程序交互时，一种自然的编程方式是使用`sleep()`方法。然而，休眠的线程仍然占用系统资源。如果你只有少数几个线程，这种情况并不重要，但如果你有很多线程，其中大多数都在休眠，那就很重要了。（参见[15.2.1节](#ch15lev2sec5)和[15.3图](#ch15fig03)的讨论。）
- en: The lesson to remember is that tasks sleeping in a thread pool consume resources
    by blocking other tasks from starting to run. (They can’t stop tasks already allocated
    to a thread, as the operating system schedules these tasks.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的教训是，在线程池中休眠的任务通过阻塞其他任务开始运行来消耗资源。（它们不能停止已分配给线程的任务，因为操作系统调度这些任务。）
- en: 'It’s not only sleeping that can clog the available threads in a thread pool,
    of course. Any blocking operation can do the same thing. Blocking operations fall
    into two classes: waiting for another task to do something, such as invoking `get()`
    on a Future; and waiting for external interactions such as reads from networks,
    database servers, or human interface devices such as keyboards.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不仅仅是休眠会阻塞线程池中可用的线程。任何阻塞操作都可以做到这一点。阻塞操作分为两类：等待另一个任务执行某些操作，例如在Future上调用`get()`；以及等待外部交互，如从网络、数据库服务器或键盘等人类界面设备读取。
- en: What can you do? One rather totalitarian answer is never to block within a task
    or at least to do so with a small number of exceptions in your code. (See [section
    15.2.4](#ch15lev2sec8) for a reality check.) The better alternative is to break
    your task into two parts—before and after—and ask Java to schedule the after part
    only when it won’t block.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做什么？一个相当独裁的回答是永远不要在任务中阻塞，或者至少在你的代码中只允许少数例外。 （参见[15.2.4节](#ch15lev2sec8)以了解现实情况。）更好的替代方案是将任务分为两部分——在之前和之后——并让Java在不会阻塞的情况下仅调度后面的部分。
- en: Compare code A, shown as a single task
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 比较代码A，显示为一个单一的任务
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Sleep for 10 seconds.**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1.*** 休眠10秒。'
- en: 'with code B:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码B：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Schedule a separate task for work2() 10 seconds after work1() finishes.**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1.*** 在work1()完成后10秒为work2()安排一个单独的任务。'
- en: Think of both tasks being executed within a thread pool.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这两个任务都在线程池中执行。
- en: Consider how code A executes. First, it’s queued to execute in the thread pool,
    and later, it starts executing. Halfway through, however, it blocks in the call
    to sleep, occupying a worker thread for 10 whole seconds doing nothing. Then it
    executes `work2()` before terminating and releasing the worker thread. Code B,
    by comparison, executes `work1()` and then terminates—but only after having queued
    a task to do `work2()` 10 seconds later.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑代码A的执行方式。首先，它被排队在线程池中执行，然后开始执行。然而，在执行到一半时，它在`sleep()`调用中阻塞，占用了一个工作线程整整10秒钟什么也不做。然后它执行`work2()`并在终止和释放工作线程之前完成。相比之下，代码B执行`work1()`然后终止——但仅在10秒后排队一个任务来执行`work2()`。
- en: Code B is better, but why? Code A and code B do the same thing. The difference
    is that code A occupies a precious thread while it sleeps, whereas code B queues
    another task to execute (with a few bytes of memory and no requirement for a thread)
    instead of sleeping.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码B更好，但为什么？代码A和代码B做的是同一件事。区别在于，代码A在睡眠时占用了一个宝贵的线程，而代码B则将另一个任务排队执行（只需要少量内存，且不需要线程）而不是睡眠。
- en: This effect is something that you should always bear in mind when creating tasks.
    Tasks occupy valuable resources when they start executing, so you should aim to
    keep them running until they complete and release their resources. Instead of
    blocking, a task should terminate after submitting a follow-up task to complete
    the work it intended to do.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果是在创建任务时应始终牢记在心的事情。任务在开始执行时占用宝贵的资源，因此你应该努力让它们运行直到完成并释放其资源。而不是阻塞，任务应在提交后续任务以完成其打算执行的工作后终止。
- en: Whenever possible, this guideline applies to I/O, too. Instead of doing a classical
    blocking read, a task should issue a nonblocking “start a read” method call and
    terminate after asking the runtime library to schedule a follow-up task when the
    read is complete.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能的情况下，此指南也适用于I/O。而不是进行传统的阻塞式读取，任务应发出一个非阻塞的“启动读取”方法调用，并在请求运行时库在读取完成后安排后续任务后终止。
- en: This design pattern may seem to lead to lots of hard-to-read code. But the Java
    `CompletableFuture` interface ([section 15.4](#ch15lev1sec4) and [chapter 16](kindle_split_030.xhtml#ch16))
    abstracts this style of code within the runtime library, using combinators instead
    of explicit uses of blocking `get()` operations on `Future`s, as we discussed
    earlier.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式可能会让人感觉代码难以阅读。但Java的`CompletableFuture`接口（[第15.4节](#ch15lev1sec4)和[第16章](kindle_split_030.xhtml#ch16)）在运行时库中抽象了这种代码风格，使用组合子而不是对`Future`的阻塞`get()`操作的显式使用，正如我们之前讨论的那样。
- en: As a final remark, we’ll note that code A and code B would be equally effective
    if threads were unlimited and cheap. But they aren’t, so code B is the way to
    go whenever you have more than a few tasks that might sleep or otherwise block.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将指出，如果线程是无限且便宜的，代码A和代码B将同样有效。但它们不是，所以当你有超过几个可能睡眠或阻塞的任务时，代码B是最佳选择。
- en: 15.2.4\. Reality check
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.4. 现实检查
- en: If you’re designing a new system, designing it with many small, concurrent tasks
    so that all possible blocking operations are implemented with asynchronous calls
    is probably the way to go if you want to exploit parallel hardware. But reality
    needs to intrude into this “everything asynchronous” design principle. (Remember,
    “the best is the enemy of the good.”) Java has had nonblocking IO primitives (`java.nio`)
    since Java 1.4 in 2002, and they’re relatively complicated and not well known.
    Pragmatically, we suggest that you try to identify situations that would benefit
    from Java’s enhanced concurrency APIs, and use them without worrying about making
    every API asynchronous.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在设计一个新的系统，为了利用并行硬件，将系统设计为包含许多小型、并发任务，以便所有可能的阻塞操作都通过异步调用实现，这可能是一条可行的道路。但现实需要打破这种“一切异步”的设计原则。（记住，“最好的是好的敌人。”）自2002年Java
    1.4以来，Java就拥有了非阻塞I/O原语（`java.nio`），但它们相对复杂且不太为人所知。实用地说，我们建议你尝试确定那些可以从Java增强的并发API中受益的情况，并使用它们而无需担心使每个API都异步。
- en: You may also find it useful to look at newer libraries such as Netty ([https://netty.io/](https://netty.io/)),
    which provides a uniform blocking/nonblocking API for network servers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看像Netty（[https://netty.io/](https://netty.io/)）这样的较新库，它为网络服务器提供了一致的阻塞/非阻塞API。
- en: 15.2.5\. How do exceptions work with asynchronous APIs?
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.5. 异常如何与异步API协同工作？
- en: In both Future-based and reactive-style asynchronous APIs, the conceptual body
    of the called method executes in a separate thread, and the caller’s execution
    is likely to have exited the scope of any exception handler placed around the
    call. It’s clear that unusual behavior that would have triggered an exception
    needs to perform an alternative action. But what might this action be? In the
    `CompletableFuture` implementation of Futures, the API includes provision for
    exposing exceptions at the time of the `get()` method and also provides methods
    such as `exceptionally()` to recover from exceptions, which we discuss in [chapter
    16](kindle_split_030.xhtml#ch16).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Future 和反应式风格的异步 API 中，被调用方法的逻辑主体在单独的线程中执行，调用者的执行很可能已经退出了围绕调用放置的任何异常处理程序的范畴。显然，会触发异常的不寻常行为需要执行替代操作。但这种操作可能是什么呢？在
    `CompletableFuture` 的 Future 实现中，API 包括在 `get()` 方法时暴露异常的提供，还提供了如 `exceptionally()`
    之类的从异常中恢复的方法，我们将在第 16 章[16](kindle_split_030.xhtml#ch16)中讨论。
- en: 'For reactive-style asynchronous APIs, you have to modify the interface by introducing
    an additional callback, which is called instead of an exception being raised,
    as the existing callback is called instead of a `return` being executed. To do
    this, include multiple callbacks in the reactive API, as in this example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反应式风格的异步 API，您必须通过引入一个额外的回调来修改接口，这个回调在抛出异常而不是执行 `return` 时被调用。为此，在反应式 API
    中包含多个回调，如下例所示：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then the body of `f` might perform
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`f` 的主体可能会执行
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If there are multiple callbacks, instead of supplying them separately, you
    can equivalently wrap them as methods in a single object. The Java 9 `Flow` API,
    for example, wraps these multiple callbacks within a single object (of class `Subscriber<T>`
    containing four methods interpreted as callbacks). Here are three of them:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个回调，而不是单独提供它们，您可以将它们等价地包装在一个单一的对象中的方法。例如，Java 9 的 `Flow` API 将这些多个回调包装在一个单一的对象中（`Subscriber<T>`
    类的对象，包含四个方法，被解释为回调）。以下是其中的三个：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Separate callbacks indicate when a value is available (`onNext`), when an exception
    arose while trying to make a value available (`onError`), and when an `onComplete`
    callback enables the program to indicate that no further values (or exceptions)
    will be produced. For the preceding example, the API for `f` would now be
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 分离的回调指示何时有值可用（`onNext`），何时在尝试提供值时出现异常（`onError`），以及何时 `onComplete` 回调允许程序指示不会产生更多值（或异常）。对于前面的示例，`f`
    的 API 现在将是
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: and the body of `f` would now indicate an exception, represented as `Throwable
    t`, by performing
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `f` 的主体现在会通过执行来指示一个异常，该异常表示为 `Throwable t`
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compare this API containing multiple callbacks with reading numbers from a file
    or keyboard device. If you think of such a device as being a producer rather than
    a passive data structure, it produces a sequence of “Here’s a number” or “Here’s
    a malformed item instead of a number” items, and finally a “There are no more
    characters left (end-of-file)” notification.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含多个回调的此 API 与从文件或键盘设备读取数字进行比较。如果您将此类设备视为生产者而不是被动数据结构，它会产生一系列“这里有数字”或“这里有格式不正确的项而不是数字”的项目，最后是一个“没有更多字符（文件结束）”的通知。
- en: It’s common to refer to these calls as messages, or *events*. You might say,
    for example, that the file reader produced the number events 3, 7, and 42, followed
    by a malformed-number event, followed by the number event 2 and then by the end-of-file
    event.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将这些调用称为消息或 *事件*。例如，您可能会说，文件读取器产生了数字事件 3、7 和 42，然后是一个格式不正确的数字事件，接着是数字事件 2，然后是文件结束事件。
- en: When seeing these events as part of an API, it’s important to note that the
    API signifies nothing about the relative ordering of these events (often called
    the *channel protocol*). In practice, the accompanying documentation specifies
    the protocol by using phases such as “After an `onComplete` event, no more events
    will be produced.”
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当将这些事件视为 API 的一部分时，需要注意的是，API 并没有表明这些事件的相对顺序（通常称为 *通道协议*）。在实践中，相关的文档通过使用诸如“在
    `onComplete` 事件之后，将不再产生更多事件”之类的阶段来指定协议。
- en: 15.3\. The box-and-channel model
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3. 盒子-通道模型
- en: Often, the best way to design and think about concurrent systems is pictorially.
    We call this technique the *box-and-channel model*. Consider a simple situation
    involving integers, generalizing the earlier example of calculating `f(x) + g(x)`.
    Now you want to call method or function `p` with argument `x`, pass its result
    to functions `q1` and `q2`, call method or function `r` with the results of these
    two calls, and then print the result. (To avoid clutter in this explanation, we’re
    not going to distinguish between a method `m` of class `C` and its associated
    function `C::m`.) Pictorially, this task is simple, as shown in [figure 15.7](#ch15fig07).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设计和思考并发系统的最佳方式是直观地表示。我们称这种技术为**箱-通道模型**。考虑一个涉及整数的简单情况，这是对之前计算 `f(x) + g(x)`
    例子的一般化。现在你想要用参数 `x` 调用方法或函数 `p`，将它的结果传递给函数 `q1` 和 `q2`，然后用这两个调用的结果调用方法或函数 `r`，最后打印结果。（为了避免解释中的混乱，我们不会区分类
    `C` 的方法 `m` 和其关联的函数 `C::m`。）直观地看，这个任务很简单，如图 [15.7](#ch15fig07) 所示。
- en: Figure 15.7\. A simple box-and-channel diagram
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.7\. 一个简单的箱-通道图
- en: '![](Images/15fig07_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig07_alt.jpg)'
- en: Look at two ways of coding [figure 15.7](#ch15fig07) in Java to see the problems
    they cause. The first way is
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 查看两种在 Java 中编码 [图 15.7](#ch15fig07) 的方式，以了解它们引起的问题。第一种方式是
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code appears to be clear, but Java runs the calls to `q1` and `q2` in turn,
    which is what you want to avoid when trying to exploit hardware parallelism.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来很清晰，但 Java 会依次运行对 `q1` 和 `q2` 的调用，这是你在尝试利用硬件并行性时想要避免的。
- en: 'Another way is to use Futures to evaluate `f` and `g` in parallel:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是使用 `Futures` 并行评估 `f` 和 `g`：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note: We didn’t wrap `p` and `r` in Futures in this example because of the
    shape of the box-and-channel diagram. `p` has to be done before everything else
    and `r` after everything else. This would no longer be the case if we changed
    the example to mimic'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们没有在这个例子中将 `p` 和 `r` 包裹在 `Futures` 中，因为箱-通道图的形状。`p` 必须在所有其他操作之前完成，而 `r`
    必须在所有其他操作之后完成。如果我们改变这个例子来模仿
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: in which we’d need to wrap all five functions (`p`, `q1`, `q2`, `r`, and `s`)
    in Futures to maximize concurrency.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们需要将所有五个函数（`p`、`q1`、`q2`、`r` 和 `s`）包裹在 `Futures` 中以最大化并发性。
- en: This solution works well if the total amount of concurrency in the system is
    small. But what if the system becomes large, with many separate box-and-channel
    diagrams, and with some of the boxes themselves internally using their own boxes
    and channels? In this situation, many tasks might be waiting (with a call to `get()`)
    for a Future to complete, and as discussed in [section 15.1.2](#ch15lev2sec2),
    the result may be underexploitation of hardware parallelism or even deadlock.
    Moreover, it tends to be hard to understand such large-scale system structure
    well enough to work out how many tasks are liable to be waiting for a `get()`.
    The solution that Java 8 adopts (`CompletableFuture`; see [section 15.4](#ch15lev1sec4)
    for details) is to use *combinators*. You’ve already seen that you can use methods
    such as `compose()` and `andThen()` on two `Function`s to get another `Function`
    (see [chapter 3](kindle_split_013.xhtml#ch03)). Assuming that `add1` adds 1 to
    an Integer and that `dble` doubles an Integer, for example, you can write
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统中并发的总量很小，这种解决方案效果很好。但如果系统变得很大，包含许多独立的箱-通道图，并且其中一些盒子本身内部使用自己的盒子和通道，会怎样呢？在这种情况下，许多任务可能会等待（通过调用
    `get()`）一个 `Future` 完成，正如在 [15.1.2 节](#ch15lev2sec2) 中讨论的，结果可能是硬件并行性的低效利用，甚至死锁。此外，通常很难充分理解这样的大型系统结构，以确定有多少任务可能会等待
    `get()`。Java 8 采取的解决方案（`CompletableFuture`；有关详细信息，请参阅 [15.4 节](#ch15lev1sec4)）是使用**组合器**。你已经看到，你可以使用
    `compose()` 和 `andThen()` 等方法在两个 `Function` 上操作以获得另一个 `Function`（参见 [第 3 章](kindle_split_013.xhtml#ch03)）。例如，假设
    `add1` 将整数加 1，而 `dble` 将整数加倍，你可以编写
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: to create a `Function` that doubles its argument and adds 2 to the result. But
    box-and-channel diagrams can be also coded directly and nicely with combinators.
    [Figure 15.7](#ch15fig07) could be captured succinctly with Java `Function`s `p,
    q1, q2` and `BiFunction r` as
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个将它的参数加倍并将结果加 2 的 `Function`。但箱-通道图也可以直接且优雅地使用组合器编码。Java `Function`s `p`、`q1`、`q2`
    和 `BiFunction` `r` 可以简洁地捕获 [图 15.7](#ch15fig07)：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Unfortunately, neither `thenBoth` nor `thenCombine` is part of the Java `Function`
    and `BiFunction` classes in exactly this form.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`thenBoth` 和 `thenCombine` 并不是以这种形式成为 Java `Function` 和 `BiFunction` 类的一部分。
- en: In the next section, you see how similar ideas of combinators work for `CompletableFuture`
    and prevent tasks from ever to have to wait using `get()`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到类似的思想如何应用于 `CompletableFuture` 并防止任务必须使用 `get()` 等待。
- en: Before leaving this section, we want to emphasize the fact that the box-and-channel
    model can be used to structure thoughts and code. In an important sense, it raises
    the level of abstraction for constructing a larger system. You draw boxes (or
    use combinators in programs) to express the computation you want, which is later
    executed, perhaps more efficiently than you might have obtained by hand-coding
    the computation. This use of combinators works not only for mathematical functions,
    but also for Futures and reactive streams of data. In [section 15.5](#ch15lev1sec5),
    we generalize these box-and-channel diagrams into marble diagrams in which multiple
    marbles (representing messages) are shown on every channel. The box-and-channel
    model also helps you change perspective from directly programming concurrency
    to allowing combinators to do the work internally. Similarly, Java 8 Streams change
    perspective from the coder having to iterate over a data structure to combinators
    on Streams doing the work internally.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开这一节之前，我们想强调的是，盒子和通道模型可以用来组织思想和代码。在某种重要的意义上，它提高了构建更大系统的抽象级别。你画盒子（或在程序中使用组合器）来表达你想要的计算，稍后执行，可能比手动编码计算更有效率。这种组合器的使用不仅适用于数学函数，也适用于
    Future 和数据反应流。在 [第 15.5 节](#ch15lev1sec5) 中，我们将这些盒子和通道图推广到宝石图，其中每个通道上都会显示多个宝石（代表消息）。盒子和通道模型还帮助你从直接编程并发转变为允许组合器内部执行工作。同样，Java
    8 Streams 从程序员必须遍历数据结构到组合器在内部执行工作的角度转变了视角。
- en: 15.4\. CompletableFuture and combinators for concurrency
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4. CompletableFuture 和并发组合器
- en: 'One problem with the `Future` interface is that it’s an interface, encouraging
    you to think of and structure your concurrent coding tasks as Futures. Historically,
    however, Futures have provided few actions beyond `FutureTask` implementations:
    creating a future with a given computation, running it, waiting for it to terminate,
    and so on. Later versions of Java provided more structured support (such as `RecursiveTask`,
    discussed in [chapter 7](kindle_split_018.xhtml#ch07)).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 接口的一个问题是它是一个接口，这鼓励你将你的并发编程任务视为 Future。然而，从历史上看，Future 提供了很少的操作，除了
    `FutureTask` 实现：创建一个具有给定计算的未来，运行它，等待它终止等等。Java 的后续版本提供了更多的结构化支持（例如，第 7 章中讨论的 `RecursiveTask`）。'
- en: What Java 8 brings to the party is the ability to compose Futures, using the
    `CompletableFuture` implementation of the `Future` interface. So why call it `CompletableFuture`
    rather than, say, `ComposableFuture`? Well, an ordinary Future is typically created
    with a `Callable`, which is run, and the result is obtained with a `get()`. But
    a `CompletableFuture` allows you to create a Future without giving it any code
    to run, and a `complete()` method allows some other thread to complete it later
    with a value (hence the name) so that `get()` can access that value. To sum `f(x)`
    and `g(x)` concurrently, you can write
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 带来的新功能是能够使用 `Future` 接口的 `CompletableFuture` 实现来组合 Future。那么为什么叫它 `CompletableFuture`
    而不是，比如说，`ComposableFuture` 呢？嗯，一个普通的 Future 通常是用一个 `Callable` 创建的，它会被执行，然后通过 `get()`
    获取结果。但是 `CompletableFuture` 允许你创建一个 Future 而不给它任何要运行的代码，并且一个 `complete()` 方法允许其他线程稍后用值完成它（因此得名），这样
    `get()` 就可以访问那个值。为了并发地求和 `f(x)` 和 `g(x)`，你可以这样写
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: or you can write
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以这样写
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that both these code versions can waste processing resources (recall [section
    15.2.3](#ch15lev2sec7)) by having a thread blocked waiting for a `get`—the former
    if `f(x)` takes longer, and the latter if `g(x)` takes longer. Using Java 8’s
    `CompletableFuture` enables you to avoid this situation; but first a quiz.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两种代码版本都可能因为有一个线程阻塞等待 `get` 而浪费处理资源（回想一下 [第 15.2.3 节](#ch15lev2sec7)）。前者如果
    `f(x)` 花费时间更长，后者如果 `g(x)` 花费时间更长。使用 Java 8 的 `CompletableFuture` 可以让你避免这种情况；但首先有一个测验。
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 15.1:**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**测验 15.1：**'
- en: 'Before reading further, think how you might write tasks to exploit threads
    perfectly in this case: two active threads while both `f(x)` and `g(x)` are executing,
    and one thread starting from when the first one completes up to the return statement.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，思考一下你如何编写任务以完美地利用线程：当 `f(x)` 和 `g(x)` 都在执行时有两个活跃的线程，以及从第一个线程完成开始直到返回语句的一个线程。
- en: The answer is that you’d use one task to execute `f(x)`, a second task to execute
    `g(x)`, and a third task (a new one or one of the existing ones) to calculate
    the sum, and somehow, the third task can’t start before the first two finish.
    How do you solve this problem in Java?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，你会使用一个任务来执行`f(x)`，第二个任务来执行`g(x)`，第三个任务（一个新的或现有的）来计算总和，并且某种方式下，第三个任务在第一个两个完成之前不能开始。你如何在Java中解决这个问题？
- en: The solution is to use the idea of composition on Futures.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用Future上的组成思想。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'First, refresh your memory about composing operations, which you’ve seen twice
    before in this book. Composing operations is a powerful program-structuring idea
    used in many other languages, but it took off in Java only with the addition of
    lambdas in Java 8\. One instance of this idea of composition is composing operations
    on streams, as in this example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回顾一下你在本书中之前见过两次的组成操作。组成操作是一种在许多其他语言中使用的强大程序结构化思想，但只有在Java 8中添加了lambda表达式之后，Java才开始流行这种思想。这个想法的一个实例是在流上组成操作，如下面的例子所示：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Another instance of this idea is using methods such as `compose()` and `andThen()`
    on two `Function`s to get another `Function` (see [section 15.5](#ch15lev1sec5)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的另一个实例是在两个`Function`上使用`compose()`和`andThen()`方法来获取另一个`Function`（参见[第15.5节](#ch15lev1sec5)）。
- en: 'This gives you a new and better way to add the results of your two computations
    by using the `thenCombine` method from `CompletableFuture<T>`. Don’t worry too
    much about the details at the moment; we discuss this topic more comprehensively
    in [chapter 16](kindle_split_030.xhtml#ch16). The method `thenCombine` has the
    following signature (slightly simplified to prevent the clutter associated with
    generics and wildcards):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了一个使用`CompletableFuture<T>`中的`thenCombine`方法添加两个计算结果的新且更好的方法。目前不必过于担心细节；我们将在[第16章](kindle_split_030.xhtml#ch16)更全面地讨论这个话题。`thenCombine`方法具有以下签名（略微简化以防止泛型和通配符相关的杂乱）：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The method takes two `CompletableFuture` values (with result types `T` and
    `U`) and creates a new one (with result type `V`). When the first two complete,
    it takes both their results, applies `fn` to both results, and completes the resulting
    future without blocking. The preceding code could now be rewritten in the following
    form:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受两个`CompletableFuture`值（结果类型为`T`和`U`）并创建一个新的（结果类型为`V`）。当前两个完成时，它获取它们的结果，对这两个结果应用`fn`，然后不阻塞地完成结果future。前面的代码现在可以按照以下形式重写：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `thenCombine` line is critical: without knowing anything about computations
    in the Futures `a` and `b`, it creates a computation that’s scheduled to run in
    the thread pool only when both of the first two computations have completed. The
    third computation, `c`, adds their results and (most important) isn’t considered
    to be eligible to execute on a thread until the other two computations have completed
    (rather than starting to execute early and then blocking). Therefore, no actual
    wait operation is performed, which was troublesome in the earlier two versions
    of this code. In those versions, if the computation in the Future happens to finish
    second, two threads in the thread pool are still active, even though you need
    only one! [Figure 15.8](#ch15fig08) shows this situation diagrammatically. In
    both earlier versions, calculating `y+z` happens on the same fixed thread that
    calculates `f(x)` or `g(x)`—with a potential wait in between. By contrast, using
    `thenCombine` schedules the summing computation only after both `f(x)` and `g(x)`
    have completed.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`thenCombine`这一行是关键：在不知道`Futures`中的`a`和`b`的计算内容的情况下，它创建了一个仅在前面两个计算完成时才在线程池中运行的调度计算。第三个计算`c`将它们的结果相加（最重要的是）并且只有在其他两个计算完成之后才被认为有资格在线程上执行（而不是开始执行然后阻塞）。因此，没有实际等待操作，这在代码的早期两个版本中是麻烦的。在那个版本中，如果Future中的计算恰好是第二个完成的，那么线程池中的两个线程仍然处于活动状态，尽管你只需要一个！[图15.8](#ch15fig08)以图解方式展示了这种情况。在两个早期版本中，计算`y+z`都是在计算`f(x)`或`g(x)`的相同固定线程上进行的，中间可能存在潜在的等待。相比之下，使用`thenCombine`仅在`f(x)`和`g(x)`都完成之后才调度求和计算。'
- en: 'Figure 15.8\. Timing diagram showing three computations: `f(x)`, `g(x)` and
    adding their results'
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.8\. 显示三个计算：`f(x)`、`g(x)`和它们结果的时序图
- en: '![](Images/15fig08.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig08.jpg)'
- en: To be clear, for many pieces of code, you don’t need to worry about a few threads
    being blocked waiting for a `get()`, so pre-Java 8 Futures remain sensible programming
    options. In some situations, however, you want to have a large number of Futures
    (such as for dealing with multiple queries to services). In these cases, using
    `CompletableFuture` and its combinators to avoid blocking calls to `get()` and
    possible loss of parallelism or deadlock is often the best solution.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，对于许多代码片段，你不需要担心几个线程被阻塞等待`get()`，因此Java 8之前的Futures仍然是合理的编程选项。然而，在某些情况下，你可能需要拥有大量的Futures（例如处理对服务的多个查询）。在这些情况下，使用`CompletableFuture`及其组合器来避免阻塞调用`get()`以及可能的并行性丢失或死锁通常是最佳解决方案。
- en: 15.5\. Publish-subscribe and reactive programming
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5. 发布-订阅和响应式编程
- en: The mental model for a `Future` and `CompletableFuture` is that of a computation
    that executes independently and concurrently. The result of the Future is available
    with `get()` after the computation completes. Thus, Futures are *one-shot*, executing
    code that runs to completion only once.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Future`和`CompletableFuture`的心理模型是独立并发执行的计算。Future的结果在计算完成后通过`get()`方法可用。因此，Futures是单次执行的，代码只运行到完成一次。
- en: 'By contrast, the mental model for reactive programming is a Future-like object
    that, over time, yields multiple results. Consider two examples, starting with
    a thermometer object. You expect this object to yield a result repeatedly, giving
    you a temperature value every few seconds. Another example is an object representing
    the listener component of a web server; this object waits until an HTTP request
    appears over the network and similarly yields with the data from the request.
    Then other code can process the result: a temperature or data from an HTTP request.
    Then the thermometer and listener objects go back to sensing temperatures or listening
    before potentially yielding further results.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，响应式编程的心理模型是一个类似于Future的对象，随着时间的推移，它会产生多个结果。考虑两个例子，从一个温度计对象开始。你期望这个对象会反复产生结果，每隔几秒给你一个温度值。另一个例子是代表Web服务器监听器组件的对象；这个对象等待网络中出现HTTP请求，并以类似的方式产生请求的数据。然后其他代码可以处理结果：温度或HTTP请求的数据。然后温度计和监听器对象回到感应温度或监听之前，可能还会产生进一步的结果。
- en: Note two points here. The core point is that these examples are like Futures
    but differ in that they can complete (or yield) multiple times instead of being
    one-shot. Another point is that in the second example, earlier results may be
    as important as ones seen later, whereas for a thermometer, most users are interested
    only in the most-recent temperature. But why is this type of a programming called
    *reactive*? The answer is that another part of the program may want to *react*
    to a low temperature report (such as by turning on a heater).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要注意两点。核心点是这些例子类似于Futures，但不同之处在于它们可以多次完成（或产生）而不是单次执行。另一个点是，在第二个例子中，早期结果可能和后期看到的结果一样重要，而对于温度计，大多数用户只对最新的温度感兴趣。但为什么这种编程被称为*响应式*呢？答案是程序的其他部分可能想要对低温报告做出反应（例如打开加热器）。
- en: You may think that the preceding idea is only a Stream. If your program fits
    naturally into the Stream model, a Stream may be the best implementation. In general,
    though, the reactive-programming paradigm is more expressive. A given Java Stream
    can be consumed by only one terminal operation. As we mention in [section 15.3](#ch15lev1sec3),
    the Stream paradigm makes it hard to express Stream-like operations that can split
    a sequence of values between two processing pipelines (think fork) or process
    and combine items from two separate streams (think join). Streams have linear
    processing pipelines.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为前面的想法只是一个Stream。如果你的程序自然地适合Stream模型，Stream可能是最好的实现。然而，总的来说，响应式编程范式更具表现力。一个Java
    Stream只能被一个终端操作消费。正如我们在[第15.3节](#ch15lev1sec3)中提到的，Stream范式使得表达可以在两个处理管道之间分割值序列的操作（例如fork）或处理和合并来自两个不同流的项（例如join）变得困难。Streams具有线性处理管道。
- en: 'Java 9 models reactive programming with interfaces available inside `java.util.concurrent.Flow`
    and encodes what’s known as the publish-subscribe model (or protocol, often shortened
    to pub-sub). You learn about the Java 9 Flow API in more detail in [chapter 17](kindle_split_031.xhtml#ch17),
    but we provide a short overview here. There are three main concepts:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9使用`java.util.concurrent.Flow`内部可用的接口来建模响应式编程，并编码了所谓的发布-订阅模型（或协议，通常简称为pub-sub）。你可以在第17章中详细了解Java
    9 Flow API，但在这里我们提供一个简要概述。有三个主要概念：
- en: A *publisher* to which a *subscriber* can subscribe.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*发布者*，订阅者可以订阅它。
- en: The connection is known as a *subscription*.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种连接被称为*订阅*。
- en: '*Messages* (also known an *events*) are transmitted via the connection.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息*（也称为*事件*）通过连接传输。'
- en: '[Figure 15.9](#ch15fig09) shows the idea pictorially, with subscriptions as
    channels and publishers and subscribers as ports on boxes. Multiple components
    can subscribe to a single publisher, a component can publish multiple separate
    streams, and a component can subscribe to multiple publishers. In this next section,
    we show you how this idea works step by step, using the nomenclature of the Java
    9 Flow interface.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15.9](#ch15fig09)以图形方式展示了这个想法，其中订阅是通道，发布者和订阅者是盒子上的端口。多个组件可以订阅单个发布者，一个组件可以发布多个单独的流，一个组件可以订阅多个发布者。在下一节中，我们将使用Java
    9 Flow接口的术语逐步展示这个想法是如何工作的。'
- en: Figure 15.9\. The publish-subscribe model
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.9\. 发布-订阅模型
- en: '![](Images/15fig09.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig09.jpg)'
- en: 15.5.1\. Example use for summing two flows
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.1\. 用于求和两个流的示例用途
- en: A simple but characteristic example of publish-subscribe combines events from
    two sources of information and publishes them for others to see. This process
    may sound obscure at first, but it’s what a cell containing a formula in a spreadsheet
    does conceptually. Model a spreadsheet cell C3, which contains the formula `"=C1+C2"`.
    Whenever cell C1 or C2 is updated (by a human or because the cell contains a further
    formula), C3 is updated to reflect the change. The following code assumes that
    the only operation available is adding the values of cells.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅的一个简单但具有代表性的例子是将两个信息源的事件结合起来，并供其他人查看。这个过程一开始可能听起来很神秘，但这就是电子表格中包含公式的单元格在概念上所做的事情。建模一个包含公式`"=C1+C2"`的电子表格单元格C3。每当C1或C2被更新（由人类或因为单元格包含另一个公式），C3都会更新以反映变化。以下代码假设唯一可用的操作是添加单元格的值。
- en: 'First, model the concept of a cell that holds a value:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，建模一个持有值的细胞的概念：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At the moment, the code is simple, and you can initialize a few cells, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，代码很简单，你可以初始化几个细胞，如下所示：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'How do you specify that when the value of `c1` or `c2` changes, `c3` sums the
    two values? You need a way for `c1` and `c2` to subscribe `c3` to their events.
    To do so, introduce the interface `Publisher<T>`, which at its core looks like
    this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何指定当`c1`或`c2`的值发生变化时，`c3`将这两个值相加？你需要一种方式让`c1`和`c2`订阅`c3`的事件。为此，引入接口`Publisher<T>`，其核心看起来像这样：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This interface takes a subscriber as an argument that it can communicate with.
    The `Subscriber<T>` interface includes a simple method, `onNext`, that takes that
    information as an argument and then is free to provide a specific implementation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口接受一个订阅者作为参数，它可以与之通信。`Subscriber<T>`接口包括一个简单的方法`onNext`，该方法将信息作为参数，然后可以自由提供特定的实现：
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'How do you bring these two concepts together? You may realize that a `Cell`
    is in fact both a `Publisher` (can subscribe cells to its events) and a `Subscriber`
    (reacts to events from other cells). The implementation of the `Cell` class now
    looks like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将这两个概念结合起来？你可能意识到`Cell`实际上既是`Publisher`（可以订阅单元格到其事件）又是`Subscriber`（对其他单元格的事件做出反应）。`Cell`类的实现现在看起来像这样：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* This method notifies all the subscribers with a new value.**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此方法通过新值通知所有订阅者。**'
- en: '***2* Reacts to a new value from a cell it is subscribed to by updating its
    value**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过更新其值来响应它所订阅的细胞的新值**'
- en: '***3* Prints the value in the console but could be rendering the updated cell
    as part of an UI**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在控制台打印值，但可以是渲染更新单元格的一部分UI**'
- en: '***4* Notifies all subscribers about the updated value**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通知所有订阅者关于更新后的值**'
- en: 'Try a simple example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一个简单的例子：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code outputs the following result because C3 is directly subscribed to
    C1:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码输出以下结果，因为C3直接订阅了C1：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'How do you implement the behavior of `"C3=C1+C2"` ? You need to introduce a
    separate class that’s capable of storing two sides of an arithmetic operation
    (left and right):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何实现 `"C3=C1+C2"` 的行为？你需要引入一个能够存储算术运算两边（左和右）的独立类：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Update the cell value and notify any subscribers.**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新单元格值并通知任何订阅者。**'
- en: '***2* Update the cell value and notify any subscribers.**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更新单元格值并通知任何订阅者。**'
- en: 'Now you can try a more-realistic example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试一个更实际的例子：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output is
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By inspecting the output, you see that when C1 was updated to 15, C3 immediately
    reacted and updated its value as well. What’s neat about the publisher-subscriber
    interaction is the fact that you can set up a graph of publishers and subscribers.
    You could create another cell C5 that depends on C3 and C4 by expressing `"C5=C3+C4"`,
    for example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查输出，你可以看到当 `C1` 更新为 `15` 时，`C3` 立即做出反应并更新其值。发布者-订阅者交互中很酷的一点是你可以设置一个发布者和订阅者的图。例如，你可以创建另一个依赖于
    `C3` 和 `C4` 的单元格 `C5`，通过表达 `"C5=C3+C4"`：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then you can perform various updates in your spreadsheet:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在你的电子表格中执行各种更新：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'These actions result in the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作会产生以下输出：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the end, the value of `C5` is `38` because `C1` is `15`, `C2` is `20`, and
    `C4` is `3`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`C5` 的值是 `38`，因为 `C1` 是 `15`，`C2` 是 `20`，而 `C4` 是 `3`。
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Nomenclature**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名法**'
- en: Because data flows from publisher (producer) to subscriber (consumer), developers
    often use words such as *upstream* and *downstream*. In the preceding code examples,
    the data `newValue` received by the upstream `onNext()` methods is passed via
    the call to `notifyAllSubscribers()` to the downstream `onNext()` call.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据从发布者（生产者）流向订阅者（消费者），开发者经常使用诸如 *上游* 和 *下游* 这样的词汇。在前面的代码示例中，上游 `onNext()`
    方法接收到的 `newValue` 数据通过调用 `notifyAllSubscribers()` 传递给下游的 `onNext()` 调用。
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That’s the core idea of publish-subscribe. We’ve left out a few things, however,
    some of which are straightforward embellishments, and one of which (backpressure)
    is so vital that we discuss it separately in the next section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是发布-订阅的核心思想。然而，我们省略了一些事情，其中一些是直接的装饰，而其中一个（背压）是如此重要，以至于我们在下一节中单独讨论它。
- en: First, we’ll discuss the straightforward things. As we remark in [section 15.2](#ch15lev1sec2),
    practical programming of flows may want to signal things other than an `onNext`
    event, so subscribers (listeners) need to define `onError` and `onComplete` methods
    so that the publisher can indicate exceptions and terminations of data flow. (Perhaps
    the example of a thermometer has been replaced and will never produce more values
    via `onNext`.) The methods `onError` and `onComplete` are supported in the actual
    `Subscriber` interface in the Java 9 Flow API. These methods are among the reasons
    why this protocol is more powerful than the traditional Observer pattern.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论直接的事情。正如我们在[第15.2节](#ch15lev1sec2)中提到的，流的实际编程可能需要传递比 `onNext` 事件更多的信息，因此订阅者（监听器）需要定义
    `onError` 和 `onComplete` 方法，以便发布者可以指示异常和数据流的终止。（也许温度计的例子已经被替换，并且将永远不会通过 `onNext`
    产生更多值。）`onError` 和 `onComplete` 方法在Java 9 Flow API的实际 `Subscriber` 接口中得到支持。这些方法就是为什么这个协议比传统的观察者模式更强大的原因之一。
- en: Two simple but vital ideas that significantly complicate the Flow interfaces
    are pressure and backpressure. These ideas can appear to be unimportant, but they’re
    vital for thread utilization. Suppose that your thermometer, which previously
    reported a temperature every few seconds, was upgraded to a better one that reports
    a temperature every millisecond. Could your program react to these events sufficiently
    quickly, or might some buffer overflow and cause a crash? (Recall the problems
    giving thread pools large numbers of tasks if more than a few tasks might block.)
    Similarly, suppose that you subscribe to a publisher that furnishes all the SMS
    messages onto your phone. The subscription might work well on my newish phone
    with only a few SMS messages, but what happens in a few years when there are thousands
    of messages, all potentially sent via calls to `onNext` in less than a second?
    This situation is often known as *pressure*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 两个简单但至关重要的想法，这些想法极大地复杂化了Flow接口，即压力和反压。这些想法可能看起来并不重要，但它们对于线程利用至关重要。假设你的温度计，之前每几秒钟报告一次温度，现在升级到了一个更好的版本，每毫秒报告一次温度。你的程序能否足够快速地对这些事件做出反应，或者可能会发生缓冲区溢出并导致崩溃？（回想一下，如果可能阻塞的任务超过几个，给线程池分配大量任务时会出现的问题。）同样，假设你订阅了一个向你的手机提供所有短信消息的发布者。在只有少量短信消息的情况下，这个订阅在我的新手机上可能运行良好，但几年后，当有数千条消息时，所有这些消息都可能在不到一秒的时间内通过调用`onNext`发送，会发生什么？这种情况通常被称为*压力*。
- en: Now think of a vertical pipe containing messages written on balls. You also
    need a form of backpressure, such as a mechanism that restricts the number of
    balls being added to the column. Backpressure is implemented in the Java 9 Flow
    API by a `request()` method (in a new interface called `Subscription`) that invites
    the publisher to send the next item(s), instead of items being sent at an unlimited
    rate (the pull model instead of the push model). We turn this topic in the next
    section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一个包含写有消息的球体的垂直管道。你还需要一种形式的反压，例如一种限制添加到柱子中的球体数量的机制。Java 9 Flow API通过一个`request()`方法（在一个新接口`Subscription`中实现）实现了反压，该方法邀请发布者发送下一个项目（或多个项目），而不是以无限的速度发送项目（拉模型而不是推模型）。我们将在下一节中讨论这个话题。
- en: 15.5.2\. Backpressure
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.2\. 反压
- en: You’ve seen how to pass a `Subscriber` object (containing `onNext`, `onError`,
    and `OnComplete` methods) to a `Publisher`, which the publisher calls when appropriate.
    This object passes information from `Publisher` to `Subscriber`. You want to limit
    the rate at which this information is sent via backpressure (flow control), which
    requires you to send information from `Subscriber` to `Publisher`. The problem
    is that the `Publisher` may have multiple `Subscriber`s, and you want backpressure
    to affect only the point-to-point connection involved. In the Java 9 Flow API,
    the `Subscriber` interface includes a fourth method
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何将包含`onNext`、`onError`和`OnComplete`方法的`Subscriber`对象传递给`Publisher`，发布者在适当的时候调用这个对象。该对象将信息从`Publisher`传递到`Subscriber`。你希望通过反压（流量控制）限制发送信息的速率，这需要你从`Subscriber`向`Publisher`发送信息。问题是`Publisher`可能有多个`Subscriber`，而你希望反压只影响点对点连接。在Java
    9 Flow API中，`Subscriber`接口包括第四个方法
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'that’s called as the first event sent on the channel established between `Publisher`
    and `Subscriber`. The `Subscription` object contains methods that enable the `Subscriber`
    to communicate with the `Publisher`, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为在`Publisher`和`Subscriber`之间建立的通道上发送的第一个事件。`Subscription`对象包含使`Subscriber`能够与`Publisher`通信的方法，如下所示：
- en: '[PRE45]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note the usual “this seems backward” effect with callbacks. The `Publisher`
    creates the `Subscription` object and passes it to the `Subscriber`, which can
    call its methods to pass information from the `Subscriber` back to the `Publisher`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意回调中常见的“这似乎是反的”效应。`Publisher`创建`Subscription`对象并将其传递给`Subscriber`，`Subscriber`可以调用其方法将信息从`Subscriber`传递回`Publisher`。
- en: 15.5.3\. A simple form of real backpressure
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.3\. 真实反压的简单形式
- en: 'To enable a publish-subscribe connection to deal with events one at a time,
    you need to make the following changes:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使发布-订阅连接能够逐个处理事件，你需要进行以下更改：
- en: Arrange for the `Subscriber` to store the `Subscription` object passed by `OnSubscribe`
    locally, perhaps as a field `subscription`.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排`Subscriber`将`OnSubscribe`传递的`Subscription`对象本地存储，可能作为一个字段`subscription`。
- en: Make the last action of `onSubscribe`, `onNext`, and (perhaps) `onError` be
    a call to `channel.request(1)` to request the next event (only one event, which
    stops the `Subscriber` from being overwhelmed).
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`onSubscribe`、`onNext`和（可能）`onError`的最后一个动作是调用`channel.request(1)`来请求下一个事件（只有一个事件，这阻止了`Subscriber`被淹没）。
- en: Change the `Publisher` so that `notifyAllSubscribers` (in this example) sends
    an `onNext` or `onError` event along only the channels that made a request. (Typically,
    the `Publisher` creates a new `Subscription` object to associate with each `Subscriber`
    so that multiple `Subscriber`s can each process data at their own rate.)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变`Publisher`，使得`notifyAllSubscribers`（在这个例子中）只通过请求的通道发送`onNext`或`onError`事件。（通常，`Publisher`会为每个`Subscriber`创建一个新的`Subscription`对象，以便多个`Subscriber`可以各自以自己的速率处理数据。）
- en: 'Although this process seems to be simple, implementing backpressure requires
    thinking about a range of implementation trade-offs:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个过程看起来很简单，但实现背压需要考虑一系列的实现权衡：
- en: Do you send events to multiple `Subscriber`s at the speed of the slowest, or
    do you have a separate queue of as-yet-unsent data for each `Subscriber`?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会以最慢的`Subscriber`的速度发送事件，还是为每个`Subscriber`有一个单独的尚未发送的数据队列？
- en: What happens when these queues grow excessively?
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这些队列过度增长时会发生什么？
- en: Do you drop events if the `Subscriber` isn’t ready for them?
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Subscriber`没有准备好，你会丢弃事件吗？
- en: The choice depends on the semantics of the data being sent. Losing one temperature
    report from a sequence may not matter, but losing a credit in your bank account
    certainly does!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 选择取决于发送数据的语义。丢失一个温度报告序列可能无关紧要，但丢失银行账户中的信用额度肯定很重要！
- en: You often hear this concept referred to as reactive pull-based backpressure.
    The concept is called *reactive pull*-based because it provides a way for the
    `Subscriber` to pull (request) more information from the `Publisher` via events
    (reactive). The result is a backpressure mechanism.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常听到这个概念被称为基于反应式拉取的背压。这个概念被称为基于反应式拉取，因为它提供了一种方式，让`Subscriber`通过事件（反应式）从`Publisher`拉取（请求）更多信息。结果是背压机制。
- en: 15.6\. Reactive systems vs. reactive programming
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.6. 反应式系统与反应式编程
- en: Increasingly in the programming and academic communities, you may hear about
    reactive systems and reactive programming, and it’s important to realize that
    these terms express quite different ideas.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程和学术界，你可能会越来越多地听到关于反应式系统和反应式编程的内容，重要的是要意识到这些术语表达的是相当不同的概念。
- en: A *reactive system* is a program whose architecture allows it to react to changes
    in its runtime environments. Properties that reactive systems should have are
    formalized in the Reactive Manifesto ([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))
    (see [chapter 17](kindle_split_031.xhtml#ch17)). Three of these properties can
    be summarized as responsive, resilient, and elastic.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*反应式系统*是一个程序，其架构允许它对其运行时环境的变化做出反应。反应式系统应具备的属性在《反应式宣言》（[http://www.reactivemanifesto.org](http://www.reactivemanifesto.org)）中得到了形式化（见第17章）。这三个属性可以总结为响应性、弹性和弹性。'
- en: '*Responsive* means that a reactive system can respond to inputs in real time
    rather delaying a simple query because the system is processing a big job for
    someone else. *Resilient* means that a system generally doesn’t fail because one
    component fails; a broken network link shouldn’t affect queries that don’t involve
    that link, and queries to an unresponsive component can be rerouted to an alternative
    component. *Elastic* means that a system can adjust to changes in its workload
    and continue to execute efficiently. As you might dynamically reallocate staff
    in a bar between serving food and serving drinks so that wait times in both lines
    are similar, you might adjust the number of worker threads associated with various
    software services so that no worker is idle while ensuring that each queue continues
    to be processed.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*响应性*意味着反应式系统可以实时响应输入，而不是因为系统正在为其他人处理大任务而延迟简单的查询。*弹性*意味着系统通常不会因为一个组件失败而失败；损坏的网络链接不应该影响不涉及该链接的查询，并且可以重新路由到未响应组件的查询。*弹性*意味着系统可以调整其工作负载的变化，并继续高效地执行。就像你可以在酒吧在服务食物和服务饮料之间动态重新分配员工，以便两条队伍的等待时间相似一样，你可以调整与各种软件服务关联的工作线程数量，以确保没有工作线程空闲，同时确保每个队列继续被处理。'
- en: 'Clearly, you can achieve these properties in many ways, but one main approach
    is to use *reactive programming* style, provided in Java by interfaces associated
    with `java.util.concurrent.Flow`. The design of these interfaces reflects the
    fourth and final property of the Reactive Manifesto: being message-driven. *Message-driven*
    systems have internal APIs based on the box-and-channel model, with components
    waiting for inputs that are processed, with the results sent as messages to other
    components to enable the system to be responsive.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以用许多方式实现这些属性，但主要的方法是使用由与`java.util.concurrent.Flow`关联的接口提供的*反应式编程*风格。这些接口的设计反映了反应式宣言的第四个和最后一个属性：消息驱动。*消息驱动*系统具有基于箱-通道模型的内部API，组件等待被处理的输入，结果以消息的形式发送到其他组件，以使系统能够响应。
- en: 15.7\. Road map
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7\. 路线图
- en: '[Chapter 16](kindle_split_030.xhtml#ch16) explores the `CompletableFuture`
    API with a real Java example, and [chapter 17](kindle_split_031.xhtml#ch17) explores
    the Java 9 Flow (publish-subscribe) API.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16章](kindle_split_030.xhtml#ch16)通过一个真实的Java示例探讨了`CompletableFuture` API，而[第17章](kindle_split_031.xhtml#ch17)探讨了Java
    9 Flow（发布-订阅）API。'
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Support for concurrency in Java has evolved and continues to evolve. Thread
    pools are generally helpful but can cause problems when you have many tasks that
    can block.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java对并发的支持已经发展并持续发展。线程池通常很有帮助，但当你有许多可能阻塞的任务时，可能会引起问题。
- en: Making methods asynchronous (returning before all their work is done) allows
    additional parallelism, complementary to that used to optimize loops.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使方法异步（在所有工作完成之前返回）允许额外的并行性，与用于优化循环的并行性互补。
- en: You can use the box-and-channel model to visualize asynchronous systems.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用箱-通道模型来可视化异步系统。
- en: The Java 8 `CompletableFuture` class and the Java 9 Flow API can both represent
    box-and-channel diagrams.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8的`CompletableFuture`类和Java 9 Flow API都可以表示箱-通道图。
- en: The `CompletableFuture` class expresses one-shot asynchronous computations.
    Combinators can be used to compose asynchronous computations without the risk
    of blocking that’s inherent in traditional uses of Futures.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`类表达了一次性异步计算。可以使用组合器来组合异步计算，而无需承担传统Future使用中固有的阻塞风险。'
- en: The Flow API is based on the publish-subscribe protocol, including backpressure,
    and forms the basis for reactive programming in Java.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flow API基于发布-订阅协议，包括背压，并构成了Java中反应式编程的基础。
- en: Reactive programming can be used to implement a reactive system.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程可用于实现反应式系统。
- en: 'Chapter 16\. CompletableFuture: composable asynchronous programming'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章\. CompletableFuture：可组合的异步编程
- en: '*This chapter covers*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating an asynchronous computation and retrieving its result
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建异步计算并检索其结果
- en: Increasing throughput by using nonblocking operations
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用非阻塞操作提高吞吐量
- en: Designing and implementing an asynchronous API
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现异步API
- en: Consuming asynchronously a synchronous API
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步消费同步API
- en: Pipelining and merging two or more asynchronous operations
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道化和合并两个或更多异步操作
- en: Reacting to the completion of an asynchronous operation
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对异步操作完成的响应
- en: '[Chapter 15](kindle_split_029.xhtml#ch15) explored the modern concurrency context:
    that multiple processing resources (CPU cores and the like) are available, and
    you want your programs to exploit as many of these resources as possible in a
    high-level manner (rather than litter your programs with ill-structured, unmaintainable
    operations on threads). We noted that parallel streams and fork/join parallelism
    provide higher-level constructs for expressing parallelism in programs iterating
    over collections and in programs involving divide-and-conquer, but that method
    invocations provide additional opportunities for executing code in parallel. Java
    8 and 9 introduce two specific APIs for this purpose: `CompletableFuture` and
    the reactive-programming paradigm. This chapter explains, through practical code
    examples, how the Java 8 `CompletableFuture` implementation of the `Future` interface
    gives you additional weapons in your programming armory. It also discusses additions
    introduced in Java 9.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[第15章](kindle_split_029.xhtml#ch15)探讨了现代并发上下文：多个处理资源（CPU核心等）可用，并且您希望以高级方式尽可能利用这些资源（而不是在程序中散布结构不良、难以维护的线程操作）。我们指出，并行流和fork/join并行性为在遍历集合的程序和涉及分而治之的程序中表达并行性提供了高级构造，但方法调用提供了执行代码的并行执行的机会。Java
    8和9引入了两个特定的API来实现此目的：`CompletableFuture`和响应式编程范式。本章通过实际代码示例解释了Java 8 `CompletableFuture`实现如何为您的编程工具箱提供额外的武器。它还讨论了Java
    9中引入的添加功能。'
- en: 16.1\. Simple use of Futures
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1\. 简单使用Futures
- en: The `Future` interface was introduced in Java 5 to model a result made available
    at some point in the future. A query to a remote service won’t be available immediately
    when the caller makes the request, for example. The `Future` interface models
    an asynchronous computation and provides a reference to its result that becomes
    available when the computation itself is completed. Triggering a potentially time-consuming
    action inside a `Future` allows the caller `Thread` to continue doing useful work
    instead of waiting for the operation’s result. You can think of this process as
    being like taking a bag of clothes to your favorite dry cleaner. The cleaner gives
    you a receipt to tell you when your clothes will be cleaned (a `Future`); in the
    meantime, you can do some other activities. Another advantage of `Future` is that
    it’s friendlier to work with than lower-level `Thread`s. To work with a `Future`,
    you typically have to wrap the time-consuming operation inside a `Callable` object
    and submit it to an `ExecutorService`. The following listing shows an example
    written before Java 8.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`接口是在Java 5中引入的，用于模拟在未来的某个时刻可用的结果。例如，当调用者发起请求时，对远程服务的查询不会立即可用。`Future`接口模拟异步计算，并提供了一个引用，当计算本身完成时，该引用将指向结果。在`Future`内部触发可能耗时的操作允许调用者`Thread`继续执行有用的工作，而不是等待操作的结果。您可以将这个过程想象成把一袋衣服拿到您最喜欢的干洗店。干洗店会给您一张收据，告诉您衣服什么时候会被清洗（一个`Future`）；在此期间，您可以做一些其他活动。`Future`的另一个优点是它比低级的`Thread`s更容易使用。要使用`Future`，通常需要将耗时的操作包装在一个`Callable`对象中，并将其提交给`ExecutorService`。以下列表显示了Java
    8之前编写的示例。'
- en: Listing 16.1\. Executing a long-lasting operation asynchronously in a `Future`
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.1\. 在`Future`中异步执行长时间操作
- en: '[PRE46]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Create an ExecutorService allowing you to submit tasks to a thread pool.**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个ExecutorService，允许您将任务提交到线程池。**'
- en: '***2* Submit a Callable to the ExecutorService.**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将Callable提交给ExecutorService。**'
- en: '***3* Execute a long operation asynchronously in a separate thread.**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在单独的线程中异步执行长时间操作。**'
- en: '***4* Do something else while the asynchronous operation is progressing.**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在异步操作进行时做其他事情。**'
- en: '***5* Retrieve the result of the asynchronous operation, blocking if it isn’t
    available yet but waiting for 1 second at most before timing out.**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 获取异步操作的结果，如果结果尚未可用则阻塞，但最多等待1秒钟然后超时。**'
- en: As depicted in [figure 16.1](#ch16fig01), this style of programming allows your
    thread to perform some other tasks while the long-lasting operation is executed
    concurrently in a separate thread provided by the `ExecutorService`. Then, when
    you can’t do any other meaningful work without having the result of that asynchronous
    operation, you can retrieve it from the `Future` by invoking its `get` method.
    This method immediately returns the result of the operation if it’s already completed
    or blocks your thread, waiting for its result to be available.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图16.1](#ch16fig01)所示，这种编程风格允许你的线程在另一个由`ExecutorService`提供的单独线程中并发执行长时间操作的同时执行其他任务。然后，当你没有异步操作的结果就无法进行任何其他有意义的工作时，你可以通过调用其`get`方法从`Future`检索它。如果操作已经完成，此方法立即返回操作的结果，或者它会阻塞你的线程，等待其结果可用。
- en: Figure 16.1\. Using a `Future` to execute a long operation asynchronously
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.1\. 使用`Future`异步执行长时间操作
- en: '![](Images/16fig01_alt.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/16fig01_alt.jpg)'
- en: Note the problem with this scenario. What if the long operation never returns?
    To handle this possibility, it’s almost always a good idea to use the two-argument
    version of `get`, which takes a timeout specifying the maximum time (along with
    its time unit) that your thread is willing to wait for the `Future`’s result (as
    in [listing 16.1](#ch16ex01)). The zero-argument version of `get` would instead
    wait indefinitely.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个场景的问题。如果长时间操作永远不会返回怎么办？为了处理这种可能性，几乎总是使用`get`函数的两个参数版本是一个好主意，它接受一个超时参数，指定线程愿意等待`Future`结果的最大时间（及其时间单位）（如[列表16.1](#ch16ex01)所示）。`get`函数的无参数版本将无限期地等待。
- en: 16.1.1\. Understanding Futures and their limitations
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.1\. 理解Futures及其限制
- en: 'This first small example shows that the `Future` interface provides methods
    for checking whether the asynchronous computation is complete (by using the `isDone`
    method), waiting for its completion, and retrieving its result. But these features
    aren’t enough to let you write concise concurrent code. It’s difficult, for example,
    to express dependencies among results of a `Future`. Declaratively, it’s easy
    to specify, “When the result of the long computation is available, please send
    its result to another long computation, and when that’s done, combine its result
    with the result from another query.” Implementing this specification with the
    operations available in a `Future` is a different story, which is why it would
    be useful to have more declarative features in the implementation, such as these:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子表明，`Future`接口提供了检查异步计算是否完成的方法（通过使用`isDone`方法），等待其完成，并检索其结果。但这些都不足以让你编写简洁的并发代码。例如，表达`Future`结果之间的依赖关系是困难的。声明式地指定，“当长时间计算的结果可用时，请将其结果发送给另一个长时间计算，当它完成时，将其结果与另一个查询的结果合并。”使用`Future`中可用的操作来实现这个规范是一个不同的故事，这就是为什么在实现中拥有更多声明式特性会有所帮助，例如：
- en: Combining two asynchronous computations both when they’re independent and when
    the second depends on the result of the first
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个异步计算独立或第二个依赖于第一个的结果时结合它们
- en: Waiting for the completion of all tasks performed by a set of `Future`s
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待一组`Future`执行的所有任务的完成
- en: Waiting for the completion of only the quickest task in a set of `Future`s (possibly
    because the `Future`s are trying to calculate the same value in different ways)
    and retrieving its result
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只等待一组`Future`中的最快任务完成（可能是因为`Future`正在以不同的方式尝试计算相同的值）并检索其结果
- en: Programmatically completing a `Future` (that is, by providing the result of
    the asynchronous operation manually)
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式完成一个`Future`（即通过手动提供异步操作的结果）
- en: Reacting to a `Future` completion (that is, being notified when the completion
    happens and then being able to perform a further action with the result of the
    `Future` instead of being blocked while waiting for its result)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`Future`完成的响应（即在完成发生时被通知，然后能够使用`Future`的结果执行进一步的操作，而不是在等待其结果时被阻塞）
- en: In the rest of this chapter, you learn how the `CompletableFuture` class (which
    implements the `Future` interface) makes all these things possible in a declarative
    way by means of Java 8’s new features. The designs of `Stream` and `CompletableFuture`
    follow similar patterns, because both use lambda expressions and pipelining. For
    this reason, you could say that `CompletableFuture` is to a plain `Future` what
    `Stream` is to a `Collection`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将学习`CompletableFuture`类（它实现了`Future`接口）如何通过Java 8的新特性以声明式的方式实现所有这些功能。`Stream`和`CompletableFuture`的设计遵循类似的模式，因为它们都使用lambda表达式和管道化。因此，可以说`CompletableFuture`对于普通的`Future`就像`Stream`对于`Collection`一样。
- en: 16.1.2\. Using CompletableFutures to build an asynchronous application
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.2\. 使用CompletableFutures构建异步应用程序
- en: 'To explore the `CompletableFuture` features, in this section you incrementally
    develop a best-price-finder application that contacts multiple online shops to
    find the lowest price for a given product or service. Along the way, you learn
    several important skills:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索`CompletableFuture`的功能，在本节中，你将逐步开发一个最佳价格查找应用程序，该应用程序联系多个在线商店以找到给定产品或服务的最低价格。在这个过程中，你将学习几个重要的技能：
- en: How to provide an asynchronous API for your customers (useful if you’re the
    owner of one of the online shops).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为你的客户提供异步API（如果你是某个在线商店的所有者，这很有用）。
- en: How to make your code nonblocking when you’re a consumer of a synchronous API.
    You discover how to pipeline two subsequent asynchronous operations, merging them
    into a single asynchronous computation. This situation arises, for example, when
    the online shop returns a discount code along with the original price of the item
    you wanted to buy. You have to contact a second remote discount service to find
    out the percentage discount associated with this discount code before calculating
    the actual price of that item.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你是一个同步API的消费者时，如何让你的代码非阻塞。你将发现如何将两个后续的异步操作管道化，将它们合并成一个单独的异步计算。这种情况发生在，例如，在线商店返回了你想要购买的商品的原价以及折扣码时。在计算该商品的实际价格之前，你必须联系第二个远程折扣服务来找出与该折扣码相关的百分比折扣。
- en: How to reactively process events representing the completion of an asynchronous
    operation and how doing so allows the best-price-finder application to constantly
    update the best-buy quote for the item you want to buy as each shop returns its
    price, instead of waiting for all the shops to return their respective quotes.
    This skill also averts the scenario in which the user sees a blank screen forever
    if one of the shops’ servers is down.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何反应性地处理表示异步操作完成的事件的完成，以及这样做如何允许最佳价格查找应用程序在每家商店返回其价格时不断更新你想要购买的商品的最佳购买报价，而不是等待所有商店返回各自的报价。这项技能还可以避免用户在一家商店的服务器宕机时永远看到空白屏幕的情况。
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Synchronous vs. asynchronous API**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步与异步API**'
- en: 'The phrase *synchronous API* is another way of talking about a traditional
    call to a method: you call it, the caller waits while the method computes, the
    method returns, and the caller continues with the returned value. Even if the
    caller and callee were executed on different threads, the caller would still wait
    for the callee to complete. This situation gives rise to the phrase *blocking
    call*.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“同步API”是另一种谈论传统方法调用的方式：你调用它，调用者等待方法计算，方法返回，调用者继续使用返回的值。即使调用者和被调用者是在不同的线程上执行的，调用者仍然会等待被调用者完成。这种情况导致了“阻塞调用”这个术语的产生。
- en: 'By contrast, in an *asynchronous API* the method returns immediately (or at
    least before its computation is complete), delegating its remaining computation
    to a thread, which runs asynchronously to the caller—hence, the phrase *nonblocking
    call*. The remaining computation gives its value to the caller by calling a callback
    method, or the caller invokes a further “wait until the computation is complete”
    method. This style of computation is common in I/O systems programming: you initiate
    a disc access, which happens asynchronously while you do more computation, and
    when you have nothing more useful to do, you wait until the disc blocks are loaded
    into memory. Note that blocking and nonblocking are often used for specific implementations
    of I/O by the operating system. However, these terms tend to be used interchangeably
    with asynchronous and synchronous even in non-I/O contexts.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在异步API中，方法立即返回（或者至少在计算完成之前返回），将剩余的计算委托给一个线程，该线程异步于调用者运行——因此，短语“非阻塞调用”。剩余的计算通过调用回调方法将其值提供给调用者，或者调用者调用一个“等待计算完成”的进一步方法。这种计算方式在I/O系统编程中很常见：你启动一个磁盘访问，它在执行更多计算的同时异步发生，当你没有更多有用的事情可做时，你等待磁盘块加载到内存中。请注意，阻塞和非阻塞通常用于操作系统对I/O的具体实现。然而，即使在非I/O环境中，这些术语也常常与异步和同步互换使用。
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 16.2\. Implementing an asynchronous API
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2\. 实现异步API
- en: 'To start implementing the best-price-finder application, define the API that
    each shop should provide. First, a shop declares a method that returns the price
    of a product, given its name:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现最佳价格查找应用程序，定义每个商店应提供的API。首先，一个商店声明一个方法，该方法返回产品的价格，给定其名称：
- en: '[PRE47]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The internal implementation of this method would query the shop’s database,
    but probably also perform other time-consuming tasks, such as contacting other
    external services (such as the shop’s suppliers or manufacturer-related promotional
    discounts). To fake such a long-running method execution, in the rest of this
    chapter you use a `delay` method, which introduces an artificial delay of 1 second,
    as defined in the following listing.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的内部实现将查询商店的数据库，但可能还会执行其他耗时任务，例如联系其他外部服务（如商店的供应商或与制造商相关的促销折扣）。为了模拟这种长时间运行的方法执行，在本章的其余部分，你使用`delay`方法，该方法引入了1秒的人工延迟，如下所示。
- en: Listing 16.2\. A method to simulate a 1-second delay
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.2\. 模拟1秒延迟的方法
- en: '[PRE48]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For the purposes of this chapter, you can model the `getPrice` method by calling
    `delay` and then returning a randomly calculated value for the price, as shown
    in the next listing. The code for returning a randomly calculated price may look
    like a bit of a hack; it randomizes the price based on the product name by using
    the result of `charAt` as a number.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，你可以通过调用`delay`然后返回一个随机计算的价格值来模拟`getPrice`方法，如下所示。返回随机计算的价格的代码可能看起来有点像黑客行为；它通过使用`charAt`的结果作为数字来随机化价格。
- en: Listing 16.3\. Introducing a simulated delay in the `getPrice` method
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.3\. 在`getPrice`方法中引入模拟延迟
- en: '[PRE49]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This code implies that when the consumer of this API (in this case, the best-price-finder
    application) invokes this method, it remains blocked and then is idle for 1 second
    while waiting for its synchronous completion. This situation is unacceptable,
    especially considering that the best-price-finder application has to repeat this
    operation for all the shops in its network. In the subsequent sections of this
    chapter, you discover how to resolve this problem by consuming this synchronous
    API in an asynchronous way. But for the purposes of learning how to design an
    asynchronous API, you continue in this section to pretend to be on the other side
    of the barricade. You’re a wise shop owner who realizes how painful this synchronous
    API is for its users, and you want to rewrite it as an asynchronous API to make
    your customers’ lives easier.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码意味着当API的消费者（在这种情况下，最佳价格查找应用程序）调用此方法时，它会保持阻塞，然后空闲1秒，等待其同步完成。这种情况是不可接受的，尤其是考虑到最佳价格查找应用程序必须对其网络中的所有商店重复此操作。在本章的后续部分，你将发现如何通过以异步方式消费此同步API来解决此问题。但为了学习如何设计异步API，你继续在本节中假装站在另一边。你是一位明智的店主，意识到这种同步API对其用户来说是多么痛苦，你希望将其重写为异步API，以便让你的客户的生活更轻松。
- en: 16.2.1\. Converting a synchronous method into an asynchronous one
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.1\. 将同步方法转换为异步方法
- en: 'To achieve this goal, you first have to turn the `getPrice` method into a `getPriceAsync`
    method and change its return value, as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，你首先必须将 `getPrice` 方法转换为 `getPriceAsync` 方法，并更改其返回值，如下所示：
- en: '[PRE50]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we mentioned in the introduction of this chapter, the `java.util.concurrent.Future`
    interface was introduced in Java 5 to represent the result of an asynchronous
    computation. (That is, the caller thread is allowed to proceed without blocking.)
    A `Future` is a handle for a value that isn’t available yet but that can be retrieved
    by invoking its `get` method after its computation finally terminates. As a result,
    the `getPriceAsync` method can return immediately, giving the caller thread a
    chance to perform other useful computations in the meantime. The Java 8 `CompletableFuture`
    class gives you various possibilities to implement this method easily, as shown
    in the following listing.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章引言中提到的，Java 5 中引入了 `java.util.concurrent.Future` 接口，用于表示异步计算的结果。（也就是说，调用线程可以在不阻塞的情况下继续执行。）`Future`
    是一个用于访问尚未可用但最终可以通过调用其 `get` 方法来检索的值的句柄。因此，`getPriceAsync` 方法可以立即返回，给调用线程一个机会在同时执行其他有用的计算。Java
    8 的 `CompletableFuture` 类为你提供了多种实现此方法的简便方法，如下所示。
- en: Listing 16.4\. Implementing the `getPriceAsync` method
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.4\. 实现 `getPriceAsync` 方法
- en: '[PRE51]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Create the CompletableFuture that will contain the result of the computation.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建将包含计算结果的 CompletableFuture。**'
- en: '***2* Execute the computation asynchronously in a different Thread.**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在不同的 Thread 中异步执行计算。**'
- en: '***3* Set the value returned by the long computation on the Future when it
    becomes available.**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当结果可用时，在 Future 上设置长时间计算返回的值。**'
- en: '***4* Return the Future without waiting for the computation of the result it
    contains to be completed.**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 不等待包含的结果的计算完成就返回 Future。**'
- en: Here, you create an instance of `CompletableFuture`, representing an asynchronous
    computation and containing a result when it becomes available. Then you fork a
    different `Thread` that will perform the actual price calculation and return the
    `Future` instance without waiting for that long-lasting calculation to terminate.
    When the price of the requested product is finally available, you can complete
    the `CompletableFuture`, using its `complete` method to set the value. This feature
    also explains the name of this Java 8 implementation of `Future`. A client of
    this API can invoke it, as shown in the next listing.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个 `CompletableFuture` 的实例，它代表一个异步计算，并在结果可用时包含该结果。然后你创建一个不同的 `Thread`
    来执行实际的价格计算，并在等待长时间的计算完成之前返回 `Future` 实例。当请求产品的价格最终可用时，你可以使用其 `complete` 方法完成 `CompletableFuture`，以设置值。这一特性也解释了这种
    Java 8 `Future` 实现的名称。API 的客户端可以调用它，如下一个列表所示。
- en: Listing 16.5\. Using an asynchronous API
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.5\. 使用异步 API
- en: '[PRE52]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Query the shop to retrieve the price of a product.**'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 查询商店以获取产品的价格。**'
- en: '***2* Read the price from the Future or block until it becomes available.**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 Future 读取价格或阻塞，直到它可用。**'
- en: 'As you can see, the client asks the shop to get the price of a certain product.
    Because the shop provides an asynchronous API, this invocation almost immediately
    returns the `Future`, through which the client can retrieve the product’s price
    later. Then the client can perform other tasks, such as querying other shops,
    instead of remaining blocked, waiting for the first shop to produce the requested
    result. Later, when the client can do no other meaningful jobs without having
    the product price, it can invoke `get` on the `Future`. By doing so, the client
    unwraps the value contained in the `Future` (if the asynchronous task is finished)
    or remains blocked until that value is available. The output produced by the code
    in [listing 16.5](#ch16ex05) could be something like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，客户端请求商店获取某种产品的价格。因为商店提供了一个异步 API，所以这个调用几乎立即返回 `Future`，客户端可以通过它稍后检索产品的价格。然后客户端可以执行其他任务，例如查询其他商店，而不是保持阻塞，等待第一个商店产生所需的结果。稍后，当客户端在没有产品价格的情况下无法执行其他有意义的任务时，它可以调用
    `Future` 上的 `get`。通过这样做，客户端解包 `Future` 中包含的值（如果异步任务已完成）或者保持阻塞，直到该值可用。代码在 [列表 16.5](#ch16ex05)
    中产生的输出可能如下所示：
- en: '[PRE53]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can see that the invocation of the `getPriceAsync` method returns far sooner
    than when the price calculation eventually finishes. In [section 16.4](#ch16lev1sec4),
    you learn that it’s also possible for the client to avoid any risk of being blocked.
    Instead, the client can be notified when the `Future` is complete and can execute
    a callback code, defined through a lambda expression or a method reference, only
    when the result of the computation is available. For now, we’ll address another
    problem: how to manage an error during the execution of the asynchronous task.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，调用 `getPriceAsync` 方法的返回时间远早于价格计算最终完成的时间。在 [第 16.4 节](#ch16lev1sec4) 中，您将了解到客户端还可以避免任何阻塞的风险。相反，当
    `Future` 完成时，客户端会被通知，并且可以在计算结果可用时执行回调代码，该代码通过 lambda 表达式或方法引用定义。现在，我们将解决另一个问题：如何在异步任务执行期间管理错误。
- en: 16.2.2\. Dealing with errors
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.2\. 处理错误
- en: 'The code you’ve developed so far works correctly if everything goes smoothly.
    But what happens if the price calculation generates an error? Unfortunately, in
    this case you get a particularly negative outcome: the exception raised to signal
    the error remains confined in the thread, which is trying to calculate the product
    price, and ultimately kills the thread. As a consequence, the client remains blocked
    forever, waiting for the result of the `get` method to arrive.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 您到目前为止开发的代码在一切顺利的情况下可以正常工作。但如果价格计算生成错误会发生什么？遗憾的是，在这种情况下，您会得到一个特别负面的结果：表示错误的异常仍然局限于尝试计算产品价格的线程中，并最终杀死该线程。因此，客户端将永远阻塞，等待
    `get` 方法的返回结果。
- en: The client can prevent this problem by using an overloaded version of the `get`
    method that also accepts a timeout. It’s good practice to use a timeout to prevent
    similar situations elsewhere in your code. This way, the client at least avoids
    waiting indefinitely, but when the timeout expires, it’s notified with a `TimeoutException`.
    As a consequence, the client won’t have a chance to discover what caused that
    failure inside the thread that was trying to calculate the product price. To make
    the client aware of the reason why the shop wasn’t able to provide the price of
    the requested product, you have to propagate the `Exception` that caused the problem
    inside the `CompletableFuture` through its `completeExceptionally` method. Applying
    this idea to [listing 16.4](#ch16ex04) produces the code shown in the following
    listing.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以通过使用接受超时参数的重载版 `get` 方法来防止这个问题。使用超时来防止代码其他部分出现类似情况是一种良好的实践。这样，客户端至少可以避免无限期地等待，但当超时到期时，它会通过
    `TimeoutException` 被通知。因此，客户端将没有机会发现导致失败的线程中计算产品价格的原因。为了使客户端了解商店无法提供请求产品价格的原因，您必须通过
    `CompletableFuture` 的 `completeExceptionally` 方法传播导致问题的 `Exception`。将这个想法应用到 [列表
    16.4](#ch16ex04) 中，产生以下列表中的代码。
- en: Listing 16.6\. Propagating an error inside the `CompletableFuture`
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.6\. 在 `CompletableFuture` 内部传播错误
- en: '[PRE54]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* If the price calculation completed normally, complete the Future with
    the price.**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果价格计算正常完成，则使用价格完成 Future。**'
- en: '***2* Otherwise, complete the Future exceptionally with the Exception that
    caused the failure.**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 否则，使用导致失败的异常来异常完成 Future。**'
- en: 'Now the client will be notified with an `ExecutionException` (which takes an
    `Exception` parameter containing the cause—the original `Exception` thrown by
    the price calculation method). If that method throws a `RuntimeException` saying
    that product isn’t available, for example, the client gets an `ExecutionException`
    like the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端将收到一个 `ExecutionException`（它包含一个 `Exception` 参数，包含原因——原始的价格计算方法抛出的 `Exception`）。如果该方法抛出一个表示产品不可用的
    `RuntimeException`，例如，客户端将收到以下类似的 `ExecutionException`：
- en: '[PRE55]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Creating a CompletableFuture with the supplyAsync factory method
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 supplyAsync 工厂方法创建 CompletableFuture
- en: Up to now, you’ve created `CompletableFuture`s and completed them programmatically
    when it seemed convenient to do so, but the `CompletableFuture` class comes with
    lots of handy factory methods that can make this process far easier and less verbose.
    The `supplyAsync` method, for example, lets you rewrite the `getPriceAsync` method
    in [listing 16.4](#ch16ex04) with a single statement, as shown in the next listing.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了 `CompletableFuture` 并在方便的时候程序化地完成它们，但 `CompletableFuture` 类附带了许多方便的工厂方法，可以使这个过程更加容易和简洁。例如，`supplyAsync`
    方法允许您使用单个语句重写 [列表 16.4](#ch16ex04) 中的 `getPriceAsync` 方法，如下一个列表所示。
- en: Listing 16.7\. Creating a `CompletableFuture` with the `supplyAsync` factory
    method
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.7. 使用`supplyAsync`工厂方法创建`CompletableFuture`
- en: '[PRE56]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `supplyAsync` method accepts a `Supplier` as argument and returns a `CompletableFuture`
    that will be asynchronously completed with the value obtained by invoking that
    `Supplier`. This `Supplier` is run by one of the `Executor`s in the `ForkJoinPool`,
    but you can specify a different `Executor` by passing it as a second argument
    to the overloaded version of this method. More generally, you can pass an `Executor`
    to all other `CompletableFuture` factory methods. You use this capability in [section
    16.3.4](#ch16lev2sec8), where we demonstrate that using an `Executor` that fits
    the characteristics of your application can have a positive effect on its performance.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`supplyAsync`方法接受一个`Supplier`作为参数，并返回一个`CompletableFuture`，该`CompletableFuture`将通过调用该`Supplier`异步完成。这个`Supplier`由`ForkJoinPool`中的一个`Executor`运行，但你可以通过将`Executor`作为第二个参数传递给该方法的重载版本来指定不同的`Executor`。更一般地说，你可以将`Executor`传递给所有其他`CompletableFuture`工厂方法。你在[第16.3.4节](#ch16lev2sec8)中使用了这种能力，我们展示了使用适合你应用程序特性的`Executor`可以对其性能产生积极影响。'
- en: Also note that the `CompletableFuture` returned by the `getPriceAsync` method
    in [listing 16.7](#ch16ex07) is equivalent to the one you created and completed
    manually in [listing 16.6](#ch16ex06), meaning that it provides the same error
    management you carefully added.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，[列表16.7](#ch16ex07)中`getPriceAsync`方法返回的`CompletableFuture`与你手动在[列表16.6](#ch16ex06)中创建和完成的`CompletableFuture`是等效的，这意味着它提供了你仔细添加的错误管理。
- en: For the rest of this chapter, we’ll suppose that you have no control of the
    API implemented by the `Shop` class and that it provides only synchronous blocking
    methods. This situation typically happens when you want to consume an HTTP API
    provided by some service. You see how it’s still possible to query multiple shops
    asynchronously, thus avoiding becoming blocked on a single request and thereby
    increasing the performance and the throughput of your best-price-finder application.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们假设你无法控制`Shop`类实现的API，并且它只提供同步阻塞方法。这种情况通常发生在你想使用某个服务提供的HTTP API时。你可以看到，即使在这种情况下，仍然可以异步查询多个商店，从而避免在单个请求上阻塞，从而提高你最佳价格查找应用程序的性能和吞吐量。
- en: 16.3\. Making your code nonblocking
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3. 使你的代码非阻塞
- en: 'You’ve been asked to develop a best-price-finder application, and all the shops
    you have to query provide only the same synchronous API implemented as shown at
    the beginning of [section 16.2](#ch16lev1sec2). In other words, you have a list
    of shops, like this one:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求开发一个最佳价格查找应用程序，而你需要查询的所有商店都只提供与[第16.2节](#ch16lev1sec2)开头所示相同的同步API。换句话说，你有一份商店列表，如下所示：
- en: '[PRE57]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You have to implement a method with the following signature, which, given the
    name of a product, returns a list of strings. Each string contains the name of
    a shop and the price of the requested product in that shop, as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须实现一个具有以下签名的函数，该函数给定一个产品的名称，返回一个字符串列表。每个字符串包含商店的名称和在该商店请求的产品价格，如下所示：
- en: '[PRE58]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Your first idea probably will be to use the `Stream` features you learned in
    [chapters 4](kindle_split_015.xhtml#ch04), [5](kindle_split_016.xhtml#ch05), and
    [6](kindle_split_017.xhtml#ch06). You may be tempted to write something like this
    next listing. (Yes, it’s good if you’re already thinking that this first solution
    is bad!)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个想法可能就是使用你在[第4章](kindle_split_015.xhtml#ch04)、[第5章](kindle_split_016.xhtml#ch05)和[第6章](kindle_split_017.xhtml#ch06)中学到的`Stream`功能。你可能会有写类似下面这样的代码的冲动。（是的，如果你已经认为这个第一个解决方案不好，那真是太好了！）
- en: Listing 16.8\. A `findPrices` implementation sequentially querying all the shops
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.8. 顺序查询所有商店的`findPrices`实现
- en: '[PRE59]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This solution is straightforward. Now try to put the method `findPrices` to
    work with the only product you want madly these days: the myPhone27S. In addition,
    record how long the method takes to run, as shown in the following listing. This
    information lets you compare the method’s performance with that of the improved
    method you develop later.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案很简单。现在尝试使用你目前非常想要的唯一产品：myPhone27S来使用`findPrices`方法。此外，记录该方法运行所需的时间，如下所示列表所示。这些信息让你可以比较该方法与后来开发的改进方法的性能。
- en: Listing 16.9\. Checking `findPrices` correctness and performance
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.9. 检查`findPrices`的正确性和性能
- en: '[PRE60]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The code in [listing 16.9](#ch16ex09) produces output like this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表16.9](#ch16ex09)中的代码会产生如下输出：'
- en: '[PRE61]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you may have expected, the time that the `findPrices` method takes to run
    is a few milliseconds longer than 4 seconds, because the four shops are queried
    sequentially and blocking one after the other, and each shop takes 1 second to
    calculate the price of the requested product. How can you improve on this result?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，`findPrices`方法运行所需的时间比4秒长几毫秒，因为四个商店是顺序查询的，一个接一个地阻塞，每个商店需要1秒钟来计算请求产品的价格。你如何改进这个结果？
- en: 16.3.1\. Parallelizing requests using a parallel Stream
  id: totrans-411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.1\. 使用并行Stream并行化请求
- en: After reading [chapter 7](kindle_split_018.xhtml#ch07), the first and quickest
    improvement that should occur to you would be to avoid this sequential computation
    by using a parallel `Stream` instead of a sequential, as shown in the next listing.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第7章](kindle_split_018.xhtml#ch07)之后，第一个应该想到的快速改进是避免使用顺序`Stream`而不是并行`Stream`来避免这种顺序计算，如下一个列表所示。
- en: Listing 16.10\. Parallelizing the `findPrices` method
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.10\. 并行化`findPrices`方法
- en: '[PRE62]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Use a parallel Stream to retrieve the prices from the different shops
    in parallel.**'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用并行Stream并行检索不同商店的价格。**'
- en: 'Find out whether this new version of `findPrices` is any better by again running
    the code in [listing 16.9](#ch16ex09):'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次运行[列表16.9](#ch16ex09)中的代码来找出这个新的`findPrices`版本是否有所改进：
- en: '[PRE63]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Well done! It looks like this idea is simple but effective. Now the four shops
    are queried in parallel, so the code takes a bit more than a second to complete.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！看起来这个想法简单但有效。现在四个商店是并行查询的，所以代码完成需要超过一秒钟。
- en: Can you do even better? Try to turn all the synchronous invocations to the shops
    in the `findPrices` method into asynchronous invocations, using what you’ve learned
    so far about `CompletableFuture`s.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做得更好吗？尝试将`findPrices`方法中所有对商店的同步调用转换为异步调用，使用你迄今为止学到的关于`CompletableFuture`s的知识。
- en: 16.3.2\. Making asynchronous requests with CompletableFutures
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.2\. 使用CompletableFutures进行异步请求
- en: 'You saw earlier that you can use the factory method `supplyAsync` to create
    `CompletableFuture` objects. Now use it:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到可以使用工厂方法`supplyAsync`来创建`CompletableFuture`对象。现在使用它：
- en: '[PRE64]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With this approach, you obtain a `List<CompletableFuture<String>>`, where each
    `CompletableFuture` in the `List` contains the `String` name of a shop when its
    computation is complete. But because the `findPrices` method you’re trying to
    reimplement with `CompletableFuture`s has to return a `List<String>`, you’ll have
    to wait for the completion of all these futures and extract the values they contain
    before returning the `List`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你将获得一个`List<CompletableFuture<String>>`，其中`List`中的每个`CompletableFuture`在其计算完成后都包含商店的`String`名称。但是，因为你试图用`CompletableFuture`s重新实现的`findPrices`方法必须返回一个`List<String>`，你将不得不等待所有这些未来的完成并提取它们包含的值，然后才能返回`List`。
- en: To achieve this result, you can apply a second `map` operation to the original
    `List<CompletableFuture<String>>`, invoking a `join` on all the futures in the
    `List` and then waiting for their completion one by one. Note that the `join`
    method of the `CompletableFuture` class has the same meaning as the `get` method
    also declared in the `Future` interface, the only difference being that `join`
    doesn’t throw any checked exception. By using `join`, you don’t have to bloat
    the lambda expression passed to this second `map` with a `try/catch` block. Putting
    everything together, you can rewrite the `findPrices` method as shown in the listing
    that follows.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个结果，你可以对原始的`List<CompletableFuture<String>>`应用第二个`map`操作，对`List`中的所有未来调用`join`，然后逐个等待它们的完成。请注意，`CompletableFuture`类的`join`方法与在`Future`接口中声明的`get`方法具有相同的意义，唯一的区别是`join`不会抛出任何检查型异常。通过使用`join`，你不需要在传递给这个第二个`map`的lambda表达式中添加`try/catch`块。将所有这些放在一起，你可以像下面的列表所示重写`findPrices`方法。
- en: Listing 16.11\. Implementing the `findPrices` method with `CompletableFuture`s
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.11\. 使用`CompletableFuture`s实现`findPrices`方法
- en: '[PRE65]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Calculate each price asynchronously with a CompletableFuture.**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用CompletableFuture异步计算每个价格。**'
- en: '***2* Wait for the completion of all asynchronous operations.**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待所有异步操作完成。**'
- en: Note that you use two separate stream pipelines instead of putting the two `map`
    operations one after the other in the same stream-processing pipeline—and for
    a good reason. Given the lazy nature of intermediate stream operations, if you’d
    processed the stream in a single pipeline, you’d have succeeded only in executing
    all the requests to different shops synchronously and sequentially. The creation
    of each `CompletableFuture` to interrogate a given shop would start only when
    the computation of the previous one completed, letting the `join` method return
    the result of that computation. [Figure 16.2](#ch16fig02) clarifies this important
    detail.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用两个独立的流管道，而不是将两个 `map` 操作一个接一个地放在同一个流处理管道中——这有一个很好的原因。鉴于中间流操作的延迟性质，如果你在一个管道中处理流，你只能成功同步和顺序地执行所有对不同商店的请求。只有当前一个的计算完成时，才会开始创建每个
    `CompletableFuture` 来查询特定的商店，让 `join` 方法返回该计算的结果。[图16.2](#ch16fig02) 清晰地说明了这个重要细节。
- en: The top half of [figure 16.2](#ch16fig02) shows that processing the stream with
    a single pipeline implies that the evaluation order (identified by the dotted
    line) is sequential. In fact, a new `CompletableFuture` is created only after
    the former one is completely evaluated. Conversely, the bottom half of the figure
    demonstrates how first gathering the `CompletableFuture`s in a list (represented
    by the oval) allows all of them to start before waiting for their completion.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16.2](#ch16fig02) 的上半部分显示，使用单个管道处理流意味着评估顺序（由虚线标识）是顺序的。实际上，只有在前一个完全评估之后才会创建一个新的
    `CompletableFuture`。相反，图的下半部分展示了首先将 `CompletableFuture` 收集到一个列表中（由椭圆形表示），这样它们就可以在等待完成之前同时开始。'
- en: Figure 16.2\. Why `Stream`’s laziness causes a sequential computation and how
    to avoid it
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.2\. 为什么 `Stream` 的延迟性导致顺序计算以及如何避免它
- en: '![](Images/16fig02_alt.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16fig02_alt.jpg)'
- en: 'Running the code in [listing 16.11](#ch16ex11) to check the performance of
    this third version of the `findPrices` method, you could obtain output along these
    lines:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [列表16.11](#ch16ex11) 中的代码来检查 `findPrices` 方法的第三个版本的性能，你可能会得到如下输出：
- en: '[PRE66]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This result is quite disappointing, isn’t it? With a runtime of more than 2
    seconds, this implementation with `CompletableFuture`s is faster than the original
    naïve sequential and blocking implementation from [listing 16.8](#ch16ex08). But
    it’s also almost twice as slow as the previous implementation using a parallel
    stream. It’s even more disappointing considering the fact that you obtained the
    parallel stream version with a trivial change to the sequential version.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果相当令人失望，不是吗？运行时间超过2秒，这个使用 `CompletableFuture` 的实现比 [列表16.8](#ch16ex08) 中的原始天真顺序和阻塞实现要快，但它也几乎比之前使用并行流的实现慢一倍。考虑到你只是对顺序版本进行了微小的修改就得到了并行流版本，这更加令人失望。
- en: The newer version with `CompletableFuture`s required quite a bit of work. But
    is using `CompletableFuture`s in this scenario a waste of time? Or are you overlooking
    something important? Take a few minutes before going forward, particularly recalling
    that you’re testing the code samples on a machine that’s capable of running four
    threads in parallel.^([[1](#ch16fn01)])
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `CompletableFuture` 版本需要相当多的工作。但在这个场景中使用 `CompletableFuture` 是浪费时间吗？或者你忽略了一些重要的东西？在继续前进之前，花几分钟时间回想一下，你正在测试的代码样本是在一个能够并行运行四个线程的机器上运行的.^([[1](#ch16fn01)])
- en: ¹
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you’re using a machine that’s capable of running more threads in parallel
    (say, eight), you need more shops and processes in parallel to reproduce the behavior
    shown in these pages.
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你使用的是能够并行运行更多线程的机器（比如，八个），你需要更多的商店和并行进程来重现这些页面上的行为。
- en: 16.3.3\. Looking for the solution that scales better
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.3\. 寻找更好的扩展性解决方案
- en: 'The parallel stream version performs so well only because it can run four tasks
    in parallel, so it’s able to allocate exactly one thread for each shop. What happens
    if you decide to add a fifth shop to the list of shops crawled by your best-price-finder
    application? Not surprisingly, the sequential version requires a bit more than
    5 seconds to run, as shown in the following output:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 并行流版本之所以表现良好，仅仅是因为它可以并行运行四个任务，因此可以为每个商店分配一个线程。如果你决定将第五个商店添加到你的最佳价格查找应用程序爬取的商店列表中，会发生什么呢？不出所料，顺序版本需要超过5秒的时间来运行，如下面的输出所示：
- en: '[PRE67]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* The output of the program using a sequential stream**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用顺序流程序的输出**'
- en: 'Unfortunately, the parallel stream version also requires a whole second more
    than before, because all four threads that it can run in parallel (available in
    the common thread pool) are now busy with the first four shops. The fifth query
    has to wait for the completion of one of the former operations to free a thread,
    as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并行流版本也比之前多了一秒钟，因为可以并行运行的四个线程（在公共线程池中可用）现在都在忙于处理前四家商店。第五个查询必须等待前一个操作完成以释放一个线程，如下所示：
- en: '[PRE68]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* The output of the program using a parallel stream**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用并行流程序的输出**'
- en: 'What about the `CompletableFuture` version? Give it a try with the fifth shop:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`CompletableFuture`版本呢？用第五家商店试一试：
- en: '[PRE69]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* The output of the program using CompletableFutures**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用CompletableFutures程序的输出**'
- en: 'The `CompletableFuture` version seems to be a bit faster than the one using
    parallel stream, but this version isn’t satisfying either. If you try to run your
    code with nine shops, the parallel stream version takes 3143 milliseconds, whereas
    the `CompletableFuture` cersion requires 3009 milliseconds. The versions look
    equivalent for a good reason: both internally use the same common pool that by
    default has a fixed number of threads equal to the one returned by `Runtime.getRuntime().available-Processors()`.
    Nevertheless, the `CompletableFuture`s version has an advantage: by contrast with
    the parallel `Streams` API, it allows you to specify a different `Executor` to
    submit tasks to. You can configure this `Executor`, and size its thread pool,
    in a way that better fits the requirements of your application. In the next section,
    you translate this better level of configurability into practical performance
    gain for your application.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CompletableFuture`版本的程序似乎比使用并行流的版本快一点，但这种版本也不令人满意。如果你尝试用九家商店运行你的代码，并行流版本需要3143毫秒，而`CompletableFuture`版本则需要3009毫秒。这两个版本看起来相当，原因很好：它们都内部使用相同的公共池，默认情况下具有与`Runtime.getRuntime().availableProcessors()`返回的线程数量相等的固定线程数。然而，`CompletableFuture`版本有一个优势：与并行`Streams`
    API相比，它允许你指定一个不同的`Executor`来提交任务。你可以配置这个`Executor`，并调整其线程池的大小，使其更好地满足你应用程序的需求。在下一节中，你将把这个更好的可配置性转化为你应用程序的实际性能提升。
- en: 16.3.4\. Using a custom Executor
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.4\. 使用自定义的Executor
- en: In this case, a sensible choice seems to be to create an `Executor` with a number
    of threads in its pool that takes into account the actual workload you could expect
    in your application. How do you size this `Executor` correctly?
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建一个具有考虑你应用程序中可能期望的实际工作负载的线程数的`Executor`似乎是一个明智的选择。你如何正确地调整这个`Executor`的大小？
- en: '|  |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Sizing thread pools**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整线程池大小**'
- en: 'In the great book *Java Concurrency in Practice* (Addison-Wesley, 2006; [http://jcip.net](http://jcip.net)),
    Brian Goetz and his co-authors give some advice on finding the optimal size for
    a thread pool. This advice is important because if the number of threads in the
    pool is too big, the threads end up competing for scarce CPU and memory resources,
    wasting their time performing context switching. Conversely, if this number is
    too small (as it likely is in your application), some of the cores of the CPU
    will remain underused. Goetz suggests that you can calculate the right pool size
    to approximate a desired CPU use rate with the following formula:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在伟大的书籍《Java并发实践》（Addison-Wesley，2006年；[http://jcip.net](http://jcip.net)）中，Brian
    Goetz及其合著者提供了一些关于寻找线程池最佳大小的建议。这些建议很重要，因为如果池中的线程数太多，线程最终会竞争稀缺的CPU和内存资源，浪费它们的时间进行上下文切换。相反，如果这个数字太小（正如你应用程序中可能的那样），CPU的一些核心将未被充分利用。Goetz建议，你可以使用以下公式来计算正确的池大小，以近似所需的CPU使用率：
- en: N^(threads) = N^(CPU) * U^(CPU) * (1 + W/C)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: N^(threads) = N^(CPU) * U^(CPU) * (1 + W/C)
- en: In this formula, NCPU is the number of cores, available through `Runtime.get-Runtime().availableProcessors()`
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，NCPU是通过`Runtime.getRuntime().availableProcessors()`可用的核心数。
- en: U^(CPU) is the target CPU use (between 0 and 1).
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U^(CPU) 是目标CPU使用率（介于0和1之间）。
- en: W/C is the ratio of wait time to compute time.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W/C 是等待时间与计算时间的比率。
- en: '|  |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The application is spending about 99 percent of its time waiting for the shops’
    responses, so you could estimate a W/C ratio of 100\. If your target is 100 percent
    CPU use, you should have a pool with 400 threads. In practice, it’s wasteful to
    have more threads than shops, because you’ll have threads in your pool that are
    never used. For this reason, you need to set up an `Executor` with a fixed number
    of threads equal to the number of shops you have to query, so that you have one
    thread for each shop. Also set an upper limit of 100 threads to avoid a server
    crash for a larger number of shops, as shown in the following listing.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序大约有99%的时间在等待商店的响应，因此你可以估计一个W/C比率为100。如果你的目标是100%的CPU使用率，你应该有一个包含400个线程的线程池。在实践中，拥有比商店更多的线程是浪费的，因为你将会有一些永远不会使用的线程。因此，你需要设置一个具有固定数量的线程的`Executor`，该数量等于你需要查询的商店数量，这样你就有每个商店一个线程。此外，设置一个上限为100个线程，以避免在商店数量较多时服务器崩溃，如下面的列表所示。
- en: Listing 16.12\. A custom `Executor` fitting the best-price-finder application
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.12\. 适用于最佳价格查找应用的定制`Executor`
- en: '[PRE70]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* Create a thread pool with a number of threads equal to the minimum of
    100 and the number of shops.**'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个包含与商店数量相同或小于100个线程的线程池。**'
- en: '***2* Use daemon threads, which don’t prevent the termination of the program.**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用守护线程，这不会阻止程序的终止。**'
- en: 'Note that you’re creating a pool made of daemon threads. A Java program can’t
    terminate or exit while a normal thread is executing, so a leftover thread waiting
    for a never-satisfiable event causes problems. By contrast, marking a thread as
    a daemon means that it can be killed on program termination. There’s no performance
    difference. Now you can pass the new `Executor` as the second argument of the
    `supplyAsync` factory method. In addition, now create the `CompletableFuture`
    that retrieves the price of the requested product from a given shop as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你正在创建一个由守护线程组成的线程池。Java程序在正常线程执行时无法终止或退出，所以一个等待永远不会满足的事件的遗留线程会导致问题。相比之下，将线程标记为守护线程意味着程序终止时它可以被杀死。这没有性能差异。现在你可以将新的`Executor`作为`supplyAsync`工厂方法的第二个参数传递。此外，现在创建一个`CompletableFuture`，如下所示，以从给定的商店检索请求产品的价格：
- en: '[PRE71]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After this improvement, the `CompletableFuture`s solution takes 1021 milliseconds
    to process five shops and 1022 milliseconds to process nine shops. This trend
    carries on until the number of shops reaches the threshold of 400 that you calculated
    earlier. This example demonstrates the fact that it’s a good idea to create an
    `Executor` that fits the characteristics of your application and to use `CompletableFuture`s
    to submit tasks to it. This strategy is almost always effective and something
    to consider when you make intensive use of asynchronous operations.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这次改进，处理五个商店的`CompletableFuture`解决方案需要1021毫秒，处理九个商店需要1022毫秒。这种趋势一直持续到商店数量达到你之前计算的400个阈值。这个例子证明了创建一个适合你应用程序特性的`Executor`并使用`CompletableFuture`s向其提交任务是一个好主意。这种策略几乎总是有效的，当你大量使用异步操作时，这是一个需要考虑的因素。
- en: '|  |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Parallelism: via Streams or CompletableFutures?**'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行化：通过Streams还是CompletableFutures？**'
- en: 'You’ve seen two ways to do parallel computing on a collection: convert the
    collection to a parallel stream and use operations such as `map` on it, or iterate
    over the collection and spawn operations within a `CompletableFuture`. The latter
    technique provides more control by resizing thread pools, which ensures that your
    overall computation doesn’t block because all your (fixed number of) threads are
    waiting for I/O.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在集合上执行并行计算的两个方法：将集合转换为并行流并在其上使用如`map`之类的操作，或者遍历集合并在`CompletableFuture`中生成操作。后者通过调整线程池的大小提供更多控制，这确保了你的整体计算不会因为所有（固定数量的）线程都在等待I/O而阻塞。
- en: 'Our advice for using these APIs is as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些API的建议如下：
- en: If you’re doing computation-heavy operations with no I/O, the `Stream` interface
    provides the simplest implementation and the one that’s likely to be most efficient.
    (If all threads are compute-bound, there’s no point in having more threads than
    processor cores.)
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在进行没有I/O的计算密集型操作，`Stream`接口提供了最简单的实现，也可能是最有效的实现。（如果所有线程都是计算密集型的，那么拥有比处理器核心更多的线程是没有意义的。）
- en: If your parallel units of work involve waiting for I/O (including network connections),
    the `CompletableFuture`s solution provides more flexibility and allows you to
    match the number of threads to the wait/computer (W/C) ratio, as discussed previously.
    Another reason to avoid using parallel streams when I/O waits are involved in
    the stream-processing pipeline is that the laziness of streams can make it harder
    to reason about when the waits happen.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的并行工作单元涉及等待I/O（包括网络连接），则`CompletableFuture`解决方案提供了更多的灵活性，并允许你匹配线程数与等待/计算机（W/C）比，如前所述。另一个避免在流处理管道中涉及I/O等待时使用并行流的原因是流的惰性可能会使得推理等待发生的时间更加困难。
- en: '|  |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ve learned how to take advantage of `CompletableFuture`s to provide an asynchronous
    API to your clients and to function as the client of a synchronous but slow server,
    but you performed only a single time-consuming operation in each `Future`. In
    the next section, you use `CompletableFuture`s to pipeline multiple asynchronous
    operations in a declarative style similar to what you learned by using the Streams
    API.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何利用`CompletableFuture`为你的客户端提供一个异步API，并作为同步但缓慢的服务器客户端，但你只在每个`Future`中执行了一个耗时的操作。在下一节中，你将使用`CompletableFuture`以声明式风格将多个异步操作管道化，这与你通过使用Streams
    API所学的类似。
- en: 16.4\. Pipelining asynchronous tasks
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4\. 管道化异步任务
- en: Suppose that all the shops have agreed to use a centralized discount service.
    This service uses five discount codes, each of which has a different discount
    percentage. You represent this idea by defining a `Discount.Code` enumeration,
    as shown in the next listing.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有商店都已同意使用集中式折扣服务。此服务使用五个折扣代码，每个代码都有一个不同的折扣百分比。你通过定义一个`Discount.Code`枚举来表示这个想法，如下所示。
- en: Listing 16.13\. An enumeration defining the discount codes
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.13\. 定义折扣代码的枚举
- en: '[PRE72]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Also suppose that the shops have agreed to change the format of the result
    of the `getPrice` method, which now returns a `String` in the format `ShopName:price:DiscountCode`.
    Your sample implementation returns a random `Discount.Code` together with the
    random price already calculated, as follows:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设商店已同意更改`getPrice`方法的格式，现在它返回一个格式为`ShopName:price:DiscountCode`的`String`。你的示例实现返回一个随机的`Discount.Code`以及已经计算出的随机价格，如下所示：
- en: '[PRE73]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Invoking `getPrice` might then return a `String` such as
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`getPrice`可能返回如下`String`：
- en: '[PRE74]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 16.4.1\. Implementing a discount service
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.1\. 实现折扣服务
- en: 'Your best-price-finder application should now obtain the prices from the shops;
    parse the resulting `String`s; and, for each `String`, query the discount server’s
    needs. This process determines the final discounted price of the requested product.
    (The actual discount percentage associated with each discount code could change,
    which is why you query the server each time.) The parsing of the `String`s produced
    by the shop is encapsulated in the following `Quote` class:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最佳价格查找应用现在应该从商店获取价格；解析生成的`String`；并且，对于每个`String`，查询折扣服务器的需求。这个过程确定了所需产品的最终折扣价格。（与每个折扣代码相关联的实际折扣百分比可能会改变，这就是为什么每次都要查询服务器。）商店生成的`String`的解析封装在以下`Quote`类中：
- en: '[PRE75]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can obtain an instance of the `Quote` class—which contains the name of the
    shop, the nondiscounted price, and the discount code—by passing the `String` produced
    by a shop to the static `parse` factory method.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将商店生成的`String`传递给静态`parse`工厂方法来获取`Quote`类的实例——它包含商店的名称、未折扣的价格和折扣代码。
- en: The `Discount` service also has an `applyDiscount` method that accepts a `Quote`
    object and returns a `String` stating the discounted price for the shop that produced
    that quote, as shown in the following listing.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`Discount`服务还有一个`applyDiscount`方法，它接受一个`Quote`对象并返回一个`String`，声明了产生该报价的商店的折扣价格，如下所示。'
- en: Listing 16.14\. The `Discount` service
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.14\. `Discount`服务
- en: '[PRE76]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Apply the discount code to the original price.**'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将折扣代码应用于原始价格。**'
- en: '***2* Simulate a delay in the Discount service response.**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模拟折扣服务响应的延迟。**'
- en: 16.4.2\. Using the Discount service
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.2\. 使用折扣服务
- en: Because the `Discount` service is a remote service, you again add a simulated
    delay of 1 second to it, as shown in the next listing. As you did in [section
    16.3](#ch16lev1sec3), first try to reimplement the `findPrices` method to fit
    these new requirements in the most obvious (but, sadly, sequential and synchronous)
    way.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Discount` 服务是一个远程服务，你再次给它添加了1秒的模拟延迟，如下一列表所示。正如你在[第16.3节](#ch16lev1sec3)中所做的那样，首先尝试重新实现
    `findPrices` 方法，以最明显（但遗憾的是，是顺序和同步的）的方式适应这些新要求。
- en: Listing 16.15\. Simplest `findPrices` implementation that uses the `Discount`
    service
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.15\. 使用 `Discount` 服务实现的简单 `findPrices` 实现
- en: '[PRE77]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Retrieve the nondiscounted price from each shop.**'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从每个商店检索未折扣的价格。**'
- en: '***2* Transform the Strings returned by the shops in Quote objects.**'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将报价中商店返回的字符串转换为报价对象。**'
- en: '***3* Contact the Discount service to apply the discount on each Quote.**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 联系折扣服务以在每个报价上应用折扣。**'
- en: 'You obtain the desired result by pipelining three `map` operations on the stream
    of shops:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过在商店流上管道化三个 `map` 操作来获得期望的结果：
- en: The first operation transforms each shop into a `String` that encodes the price
    and discount code of the requested product for that shop.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个操作将每个商店转换为一个 `String`，该字符串编码了该商店请求产品的价格和折扣代码。
- en: The second operation parses those `String`s, converting each of them in a `Quote`
    object.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个操作解析这些 `String`，将每个 `String` 转换为 `Quote` 对象。
- en: The third operation contacts the remote `Discount` service, which calculates
    the final discounted price and returns another `String` containing the name of
    the shop with that price.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个操作联系远程 `Discount` 服务，该服务计算最终折扣价格，并返回另一个包含该价格的商店名称的 `String`。
- en: 'As you might imagine, the performance of this implementation is far from optimal.
    But try to measure it as usual by running your benchmark:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这个实现的性能远非最佳。但像往常一样通过运行你的基准测试来尝试测量它：
- en: '[PRE78]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As expected, this code takes 10 seconds to run, because the 5 seconds required
    to query the five shops sequentially is added to the 5 seconds consumed by the
    discount service in applying the discount code to the prices returned by the five
    shops. You already know that you can improve this result by converting the stream
    to a parallel one. But you also know (from [section 16.3](#ch16lev1sec3)) that
    this solution doesn’t scale well when you increase the number of shops to be queried,
    due to the fixed common thread pool on which streams rely. Conversely, you learned
    that you can better use your CPU by defining a custom `Executor` that schedules
    the tasks performed by the `CompletableFuture`s.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，这段代码运行需要10秒，因为查询五个商店所需的5秒加上折扣服务应用折扣代码到五个商店返回的价格上所消耗的5秒。你已经知道你可以通过将流转换为并行流来提高这个结果。但你也知道（从[第16.3节](#ch16lev1sec3)中），当你增加要查询的商店数量时，这个解决方案的扩展性不好，因为流依赖于固定的公共线程池。相反，你了解到你可以通过定义一个自定义的
    `Executor` 来更好地利用你的CPU，该 `Executor` 调度 `CompletableFuture` 执行的任务。
- en: 16.4.3\. Composing synchronous and asynchronous operations
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.3\. 组合同步和异步操作
- en: In this section, you try to reimplement the `findPrices` method asynchronously,
    again using the features provided by `CompletableFuture`. This next listing shows
    the code. Don’t worry if something looks unfamiliar; we explain the code in this
    section.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你尝试异步重新实现 `findPrices` 方法，再次使用 `CompletableFuture` 提供的功能。下一列表显示了代码。如果你对某些东西看起来不熟悉，我们将在本节中解释代码。
- en: Listing 16.16\. Implementing the `findPrices` method with `CompletableFuture`s
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.16\. 使用 `CompletableFuture` 实现 `findPrices` 方法
- en: '[PRE79]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* Asynchronously retrieve the nondiscounted price from each shop.**'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 异步从每个商店检索未折扣的价格。**'
- en: '***2* Transform the String returned by a shop into a Quote object when it becomes
    available.**'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当报价可用时，将商店返回的字符串转换为报价对象。**'
- en: '***3* Compose the resulting Future with another asynchronous task, applying
    the discount code.**'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将结果 `Future` 与另一个异步任务组合，应用折扣代码。**'
- en: '***4* Wait for all the Futures in the stream to be completed and extract their
    respective results.**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 等待流中的所有 `Future` 完成，并提取它们各自的结果。**'
- en: Things look a bit more complex this time, so try to understand what’s going
    on step-by-step. [Figure 16.3](#ch16fig03) depicts the sequence of these three
    transformations.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这次事情看起来有点复杂，所以尝试一步一步地理解正在发生的事情。[图16.3](#ch16fig03) 描述了这三个转换的顺序。
- en: Figure 16.3\. Composing synchronous operations and asynchronous tasks
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.3\. 组合同步操作和异步任务
- en: '![](Images/16fig03.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16fig03.jpg)'
- en: You’re performing the same three `map` operations that you did in the synchronous
    solution of [listing 16.15](#ch16ex15), but you make those operations asynchronous
    when necessary, using the feature provided by the `CompletableFuture` class.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在执行与[列表16.15](#ch16ex15)中同步解决方案相同的三个`map`操作，但在必要时将这些操作异步化，使用`CompletableFuture`类提供的功能。
- en: Getting the prices
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取价格
- en: You’ve seen the first of these three operations in various examples in this
    chapter; you query the shop asynchronously by passing a lambda expression to the
    `supplyAsync` factory method. The result of this first transformation is a `Stream<CompletableFuture<String>>`,
    where each `CompletableFuture` contains, when complete, the `String` returned
    by the corresponding shop. Note that you configure the `CompletableFuture`s with
    the custom `Executor` developed in [listing 16.12](#ch16ex12).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在本章的各种示例中看到了这三个操作中的第一个；你通过传递一个lambda表达式到`supplyAsync`工厂方法来异步查询商店。第一次转换的结果是一个`Stream<CompletableFuture<String>>`，其中每个`CompletableFuture`在完成时都包含由相应商店返回的`String`。请注意，你使用在[列表16.12](#ch16ex12)中开发的自定义`Executor`配置了`CompletableFuture`。
- en: Parsing the quotes
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析报价
- en: Now you have to convert those `String`s to `Quote`s with a second transformation.
    But because this parsing operation isn’t invoking any remote service or doing
    any I/O in general, it can be performed almost instantaneously and can be done
    synchronously without introducing any delay. For this reason, you implement this
    second transformation by invoking the `thenApply` method on the `CompletableFuture`s
    produced by the first step and passing to it a `Function` converting a `String`
    to an instance of `Quote`.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你必须通过第二次转换将这些`String`转换为`Quote`。但由于这种解析操作没有调用任何远程服务或进行任何I/O操作，它可以几乎瞬间完成，并且可以同步执行而不引入任何延迟。因此，你通过在第一步生成的`CompletableFuture`s上调用`thenApply`方法并传递一个将`String`转换为`Quote`实例的`Function`来实现这个第二次转换。
- en: Note that using the `thenApply` method doesn’t block your code until the `CompletableFuture`
    on which you’re invoking it is complete. When the `CompletableFuture` finally
    completes, you want to transform the value that it contains by using the lambda
    expression passed to the `then-Apply` method, thus transforming each `CompletableFuture<String>`
    in the stream into a corresponding `CompletableFuture <Quote>`. You can see this
    process as building a recipe that specifies what to do with the result of the
    `CompletableFuture`, as when you worked with a stream pipeline.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用`thenApply`方法不会阻塞你的代码，直到你调用的`CompletableFuture`完成。当`CompletableFuture`最终完成时，你想要通过传递给`then-Apply`方法的lambda表达式来转换它包含的值，从而将流中的每个`CompletableFuture<String>`转换为相应的`CompletableFuture<Quote>`。你可以将这个过程视为构建一个食谱，指定如何处理`CompletableFuture`的结果，就像你在处理流管道时一样。
- en: Composing the futures for calculating the discounted price
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为计算折后价格而编写未来
- en: The third `map` operation involves contacting the remote `Discount` service
    to apply the appropriate discount percentage to the nondiscounted prices received
    from the shops. This transformation is different from the previous one because
    it has to be executed remotely (or, in this case, has to simulate the remote invocation
    with a delay), and for this reason, you also want to perform it asynchronously.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次`map`操作涉及联系远程`Discount`服务，将商店收到的非折后价格应用适当的折扣百分比。这种转换与之前的不同，因为它需要在远程执行（或者在这种情况下，需要通过延迟模拟远程调用），因此，你也希望异步执行此操作。
- en: 'To achieve this goal, as you did with the first invocation of `supplyAsync`
    with `getPrice`, you pass this operation as a lambda expression to the `supplyAsync`
    factory method, which returns another `CompletableFuture`. At this point you have
    two asynchronous operations, modeled with two distinct `CompletableFuture`s, that
    you want to perform in a cascade:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，就像你用`getPrice`的第一个`supplyAsync`调用一样，你将这个操作作为一个lambda表达式传递给`supplyAsync`工厂方法，它返回另一个`CompletableFuture`。在这个时候，你有了两个异步操作，用两个不同的`CompletableFuture`建模，你想要按顺序执行：
- en: Retrieve the price from a shop and then transform it into a `Quote.`
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从商店获取价格并将其转换为`Quote`。
- en: Take this `Quote` and pass it to the `Discount` service to obtain the final
    discounted price.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此`Quote`传递给`Discount`服务以获取最终折后价格。
- en: The Java 8 `CompletableFuture` API provides the `thenCompose` method specifically
    for this purpose, allowing you to pipeline two asynchronous operations, passing
    the result of the first operation to the second operation when it becomes available.
    In other words, you can compose two `CompletableFuture`s by invoking the `thenCompose`
    method on the first `CompletableFuture` and passing to it a `Function`. This `Function`
    has as an argument the value returned by that first `CompletableFuture` when it
    completes, and it returns a second `CompletableFuture` that uses the result of
    the first as input for its computation. Note that with this approach, while the
    `Future`s are retrieving the quotes from the shops, the main thread can perform
    other useful operations, such as responding to UI events.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8的`CompletableFuture` API提供了专门用于此目的的`thenCompose`方法，允许你将两个异步操作串联起来，当第一个操作的结果可用时，将其传递给第二个操作。换句话说，你可以通过在第一个`CompletableFuture`上调用`thenCompose`方法并将一个`Function`传递给它来组合两个`CompletableFuture`。这个`Function`以第一个`CompletableFuture`完成时返回的值作为参数，并返回一个使用第一个的结果作为其计算输入的第二个`CompletableFuture`。请注意，使用这种方法时，虽然`Future`正在从商店检索报价，但主线程可以执行其他有用的操作，例如响应用户界面事件。
- en: 'Collecting the elements of the `Stream` resulting from these three `map` operations
    into a `List`, you obtain a `List<CompletableFuture<String>>`. Finally, you can
    wait for the completion of those `CompletableFuture`s and extract their values
    by using `join`, exactly as you did in [listing 16.11](#ch16ex11). This new version
    of the `findPrices` method implemented in [listing 16.8](#ch16ex08) might produce
    output like this:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三个`map`操作产生的`Stream`的元素收集到一个`List`中，你得到一个`List<CompletableFuture<String>>`。最后，你可以通过使用`join`等待这些`CompletableFuture`的完成并提取它们的值，就像你在[列表16.11](#ch16ex11)中所做的那样。在[列表16.8](#ch16ex08)中实现的`findPrices`方法的新版本可能产生如下输出：
- en: '[PRE80]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `thenCompose` method you used in [listing 16.16](#ch16ex16), like other
    methods of the `CompletableFuture` class, has a variant with an `Async` suffix,
    `thenComposeAsync`. In general, a method without the `Async` suffix in its name
    executes its task in the same thread as the previous task, whereas a method terminating
    with `Async` always submits the succeeding task to the thread pool, so each of
    the tasks can be handled by a different thread. In this case, the result of the
    second `CompletableFuture` depends on the first, so it makes no difference to
    the final result or to its broad-brush timing whether you compose the two `CompletableFuture`s
    with one or the other variant of this method. You chose to use the one with `thenCompose`
    only because it’s slightly more efficient due to less thread-switching overhead.
    Note, however, that it may not always be clear which thread is being used, especially
    if you run an application that manages its own thread pool (such as Spring).
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[列表16.16](#ch16ex16)中使用的`thenCompose`方法，就像`CompletableFuture`类的其他方法一样，有一个带有`Async`后缀的变体，即`thenComposeAsync`。一般来说，没有`Async`后缀的方法在其名称中将在前一个任务所在的线程中执行其任务，而以`Async`结尾的方法总是将后续任务提交到线程池，因此每个任务可以由不同的线程处理。在这种情况下，第二个`CompletableFuture`的结果依赖于第一个，因此使用此方法的任一变体对最终结果或其大致时间没有影响。你选择使用带有`thenCompose`的变体仅仅是因为它稍微更有效率，因为减少了线程切换的开销。然而，请注意，并不总是清楚使用的是哪个线程，特别是如果你运行一个管理自己的线程池的应用程序（如Spring）。
- en: '16.4.4\. Combining two CompletableFutures: dependent and independent'
  id: totrans-534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.4. 组合两个CompletableFutures：依赖性和独立性
- en: In [listing 16.16](#ch16ex16), you invoked the `thenCompose` method on one `CompletableFuture`
    and passed to it a second `CompletableFuture`, which needed as input the value
    resulting from the execution of the first. In another common case, you need to
    combine the results of the operations performed by two independent `CompletableFuture`s,
    and you don’t want to wait for the first to complete before starting the second.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表16.16](#ch16ex16)中，你在第一个`CompletableFuture`上调用了`thenCompose`方法，并将第二个`CompletableFuture`传递给它，该`CompletableFuture`需要第一个执行的结果作为输入。在另一种常见情况下，你需要组合两个独立`CompletableFuture`执行的操作的结果，而且你不想在开始第二个操作之前等待第一个完成。
- en: In situations like this one, use the `thenCombine` method. This method takes
    as a second argument a `BiFunction`, which defines how the results of the two
    `CompletableFuture`s are to be combined when both become available. Like `thenCompose`,
    the `thenCombine` method comes with an `Async` variant. In this case, using the
    `then-CombineAsync` method causes the combination operation defined by the `BiFunction`
    to be submitted to the thread pool and then executed asynchronously in a separate
    task.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用`thenCombine`方法。此方法将`BiFunction`作为第二个参数，它定义了当两个`CompletableFuture`都可用时如何组合它们的结果。与`thenCompose`方法一样，`thenCombine`方法还有一个`Async`变体。在这种情况下，使用`thenCombineAsync`方法会导致由`BiFunction`定义的组合操作提交到线程池，并在单独的任务中异步执行。
- en: Turning to this chapter’s running example, you may know that one of the shops
    provides prices in € (EUR), but you always want to communicate them to your customers
    in $(USD). You can asynchronously ask the shop the price of a given product *and
    separately* retrieve, from a remote exchange-rate service, the current exchange
    rate between € and $. After both requests have completed, you can combine the
    results by multiplying the price by the exchange rate. With this approach, you
    obtain a third `CompletableFuture` that completes when the results of the two
    `CompletableFuture`s are both available and have been combined by means of the
    `BiFunction`, as shown in the following listing.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 转到本章的运行示例，你可能知道其中一家商店提供的价格是€（欧元），但你总是想以$(美元)的形式与客户沟通。你可以异步地询问商店给定产品的价格，并从远程汇率服务中单独检索€和$之间的当前汇率。在两个请求都完成后，你可以通过将价格乘以汇率来组合结果。使用这种方法，你将获得一个第三`CompletableFuture`，当两个`CompletableFuture`的结果都可用并且通过`BiFunction`组合时，它将完成，如下面的列表所示。
- en: Listing 16.17\. Combining two independent `CompletableFuture`s
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.17\. 组合两个独立的`CompletableFuture`
- en: '[PRE81]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* Create a first task querying the shop to obtain the price of a product.**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个任务，查询商店以获取产品的价格。**'
- en: '***2* Create a second independent task to retrieve the conversion rate between
    USD and EUR.**'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个独立任务以检索美元和欧元之间的汇率转换率。**'
- en: '***3* Combine the price and exchange rate by multiplying them.**'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过相乘将价格和汇率结合起来。**'
- en: Here, because the combination operation is a simple multiplication, performing
    it in a separate task would have been a waste of resources, so you need to use
    the `then-Combine` method instead of its asynchronous `thenCombineAsync` counterpart.
    [Figure 16.4](#ch16fig04) shows how the tasks created in [listing 16.17](#ch16ex17)
    are executed on the different threads of the pool and how their results are combined.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为组合操作是一个简单的乘法，执行它将是一个资源的浪费，所以你需要使用`thenCombine`方法而不是其异步的`thenCombineAsync`对应方法。[图16.4](#ch16fig04)显示了[列表16.17](#ch16ex17)中创建的任务如何在池的不同线程上执行以及它们的结果是如何组合的。
- en: Figure 16.4\. Combining two independent asynchronous tasks
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.4\. 组合两个独立的异步任务
- en: '![](Images/16fig04_alt.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16fig04_alt.jpg)'
- en: 16.4.5\. Reflecting on Future vs. CompletableFuture
  id: totrans-546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.5\. 关于Future与CompletableFuture的反思
- en: The last two examples in [listings 16.16](#ch16ex16) and [16.17](#ch16ex17)
    clearly show one of the biggest advantages of `CompletableFuture`s over the other
    pre-Java 8 `Future` implementations. `CompletableFuture`s use lambda expressions
    to provide a declarative API. This API allows you to easily combine and compose
    various synchronous and asynchronous tasks to perform a complex operation in the
    most effective way. To get a more tangible idea of the code-readability benefits
    of `CompletableFuture`, try to obtain the result of [listing 16.17](#ch16ex17)
    purely in Java 7\. The next listing shows you how.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表16.16](#ch16ex16)和[16.17](#ch16ex17)的最后两个示例中，清楚地展示了`CompletableFuture`相对于其他Java
    8之前的`Future`实现的最大优势之一。`CompletableFuture`使用lambda表达式提供声明式API。此API允许你轻松组合和组合各种同步和异步任务，以最有效的方式执行复杂操作。为了更直观地了解`CompletableFuture`的代码可读性优势，尝试仅使用Java
    7来获取[列表16.17](#ch16ex17)的结果。下一个列表将向您展示如何做到这一点。
- en: Listing 16.18\. Combining two `Future`s in Java 7
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.18\. Java 7中组合两个`Future`
- en: '[PRE82]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Create an ExecutorService allowing you to submit tasks to a thread pool.**'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个ExecutorService，允许你向线程池提交任务。**'
- en: '***2* Create a Future retrieving the exchange rate between EUR and USD.**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个Future，用于检索欧元和美元之间的汇率。**'
- en: '***3* Find the price of the requested product for a given shop in a second
    Future.**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在第二个Future中找到给定商店请求产品的价格。**'
- en: '***4* Multiply the price and exchange rate in the same Future used to find
    the price.**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在用于查找价格的同一Future中乘以价格和汇率。**'
- en: In [listing 16.18](#ch16ex18), you create a first `Future`, submitting a `Callable`
    to an `Executor` querying an external service to find the exchange rate between
    EUR and USD. Then you create a second `Future,` retrieving the price in EUR of
    the requested product for a given shop. Finally, as you did in [listing 16.17](#ch16ex17),
    you multiply the exchange rate by the price in the same future that also queried
    the shop to retrieve the price in EUR. Note that using `thenCombineAsync` instead
    of `thenCombine` in [listing 16.17](#ch16ex17) would have been equivalent to performing
    the price by rate multiplication in a third `Future` in [listing 16.18](#ch16ex18).
    The difference between these two implementations may seem to be small only because
    you’re combining two `Future`s.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表16.18](#ch16ex18)中，你创建了一个第一个`Future`，向`Executor`提交一个`Callable`以查询外部服务以找到EUR和USD之间的汇率。然后你创建了一个第二个`Future`，检索给定商店请求产品的EUR价格。最后，正如你在[列表16.17](#ch16ex17)中所做的那样，你将汇率乘以EUR价格，在同一future中查询商店以检索EUR价格。请注意，在[列表16.17](#ch16ex17)中使用`thenCombineAsync`而不是`thenCombine`将与在[列表16.18](#ch16ex18)中执行第三个`Future`中的价格乘以汇率相等效。这两种实现之间的差异可能看起来很小，只是因为你正在组合两个`Future`。
- en: 16.4.6\. Using timeouts effectively
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.6\. 有效使用超时
- en: '![](Images/java.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/java.jpg)'
- en: As mentioned in [section 16.2.2](#ch16lev2sec4), it’s always a good idea to
    specify a timeout when trying to read the value calculated by a `Future` to avoid
    being blocked indefinitely while waiting for the computation of that value. Java
    9 introduced a couple of convenient methods that enrich the timeout capabilities
    provided by the `CompletableFuture`s. The `orTimeout` method uses a `ScheduledThreadExecutor`
    to complete the `CompletableFuture` with a `TimeoutException` after the specified
    timeout has elapsed, and it returns another `CompletableFuture`. By using this
    method, you can further chain your computation pipeline and deal with the `TimeoutException`
    by providing a friendly message back. You can add a timeout to the `Future` in
    [listing 16.17](#ch16ex17) and make it throw a `TimeoutException` if not completed
    after 3 seconds by adding this method at the end of the methods chain, as shown
    in the next listing. The timeout duration should match your business requirements,
    of course.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第16.2.2节](#ch16lev2sec4)中所述，在尝试读取`Future`计算出的值时指定超时总是一个好主意，以避免在等待该值的计算时被无限期地阻塞。Java
    9引入了一些方便的方法，这些方法丰富了`CompletableFuture`提供的超时功能。`orTimeout`方法使用`ScheduledThreadExecutor`在指定超时时间过后，用`TimeoutException`完成`CompletableFuture`，并返回另一个`CompletableFuture`。通过使用此方法，你可以进一步连接你的计算管道，并通过提供友好的消息来处理`TimeoutException`。你可以在[列表16.17](#ch16ex17)中的`Future`上添加超时，并在方法链的末尾添加此方法，以在3秒后未完成时抛出`TimeoutException`，如下一列表所示。当然，超时持续时间应与你的业务需求相匹配。
- en: Listing 16.19\. Adding a timeout to `CompletableFuture`
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.19\. 向`CompletableFuture`添加超时
- en: '[PRE83]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1* Make the Future throw a Timeout-Exception if not completed after 3 seconds.
    Asynchronous timeout management was added in Java 9.**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果在3秒后未完成，让Future抛出Timeout-Exception。Java 9中增加了异步超时管理。**'
- en: Sometimes, it’s also acceptable to use a default value in case a service is
    momentarily unable to respond in a timely manner. You might decide that in [listing
    16.19](#ch16ex19), you want to wait for the exchange service to provide the current
    EUR-to-USD exchange rate for no more than 1 second, but if the request takes longer
    to complete, you don’t want to abort the whole the computation with an `Exception`.
    Instead, you can fall back by using a predefined exchange rate. You can easily
    add this second kind of timeout by using the `completeOnTimeout` method, also
    introduced in Java 9 (the following listing).
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果服务暂时无法及时响应，使用默认值也是可以接受的。你可能会决定在[列表16.19](#ch16ex19)中，你希望等待交易所提供当前EUR兑USD的汇率不超过1秒，但如果请求需要更长的时间来完成，你不想因为一个`Exception`而终止整个计算。相反，你可以通过使用预定义的汇率来回退。你可以通过使用`completeOnTimeout`方法轻松地添加这种第二种超时，该方法也是在Java
    9中引入的（以下列表）。
- en: Listing 16.20\. Completing a `CompletableFuture` with a default value after
    a timeout
  id: totrans-562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.20\. 超时后使用默认值完成`CompletableFuture`
- en: '[PRE84]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* Use a default exchange rate if the exchange service doesn’t provide a
    result in 1 second.**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果汇率服务在1秒内不提供结果，使用默认汇率。**'
- en: 'Like the `orTimeout` method, the `completeOnTimeOut` method returns a `CompletableFuture`,
    so you can chain it with other `CompletableFuture` methods. To recap, you’ve configured
    two kinds of timeouts: one that makes the whole computation fail if it takes more
    than 3 seconds, and one that expires in 1 second but completes the `Future` with
    a predetermined value instead of causing a failure.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 与`orTimeout`方法一样，`completeOnTimeOut`方法返回一个`CompletableFuture`，因此你可以将其与其他`CompletableFuture`方法链式调用。为了回顾，你已经配置了两种类型的超时：一种是在整个计算超过3秒时使整个计算失败，另一种是在1秒后过期，但用预定的值完成`Future`而不是导致失败。
- en: You’re almost finished with your best-price-finder application, but one ingredient
    is still missing. You’d like to show your users the prices provided by the shops
    as soon as they become available (as car insurance and flight-comparison websites
    typically do), instead of waiting for all the price requests to complete, as you’ve
    done up to now. In the next section, you discover how to achieve this goal by
    reacting to the completion of a `CompletableFuture` instead of invoking `get`
    or `join` on it and thereby remaining blocked until the `CompletableFuture` itself
    completes.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎完成了你的最佳价格查找应用程序，但仍然缺少一个成分。你希望用户一有可用价格就能看到商店提供的价格（就像汽车保险和航班比较网站通常所做的那样），而不是像你现在所做的那样等待所有价格请求完成。在下一节中，你将了解如何通过响应`CompletableFuture`的完成而不是对其调用`get`或`join`来达到这个目标，从而避免在`CompletableFuture`本身完成之前被阻塞。
- en: 16.5\. Reacting to a CompletableFuture completion
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5\. 响应CompletableFuture的完成
- en: In all the code examples you’ve seen in this chapter, you’ve simulated methods
    that do remote invocations with a 1-second delay in their response. In a real-world
    scenario, the remote services you need to contact from your application are likely
    to have unpredictable delays caused by everything from server load to network
    delays, and perhaps by how valuable the server regards your application’s business
    to be compared with that of applications that pay more per query.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中你看到的所有代码示例中，你都模拟了具有1秒延迟的远程调用方法。在现实世界的场景中，你需要从你的应用程序中联系到的远程服务可能由于服务器负载、网络延迟等因素而具有不可预测的延迟，也许还因为服务器认为你的应用程序的业务价值与支付更多查询费用的应用程序相比如何。
- en: For these reasons, it’s likely the prices of the products you want to buy will
    be available for some shops far earlier than for others. In the next listing,
    you simulate this scenario by introducing a random delay of 0.5 to 2.5 seconds,
    using the `randomDelay` method instead of the `delay` method that waits 1 second.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，你想要购买的产品价格可能在某些商店比其他商店更早可用。在下一列表中，你通过引入0.5到2.5秒的随机延迟来模拟这种场景，使用`randomDelay`方法而不是等待1秒的`delay`方法。
- en: Listing 16.21\. A method to simulate a random delay between 0.5 and 2.5 seconds
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.21\. 模拟0.5到2.5秒随机延迟的方法
- en: '[PRE85]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Up to now, you’ve implemented the `findPrices` method so that it shows the prices
    provided by the shops only when all of them are available. Now you want to have
    the best-price-finder application display the price for a given shop as soon as
    it becomes available without waiting for the slowest one (which may even time
    out). How can you achieve this further improvement?
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经实现了`findPrices`方法，使其仅在所有商店的价格都可用时显示价格。现在你希望最佳价格查找应用程序能够在给定商店的价格一有可用就显示，而不必等待最慢的那个（甚至可能超时）。你如何实现这一进一步的改进？
- en: 16.5.1\. Refactoring the best-price-finder application
  id: totrans-573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.1\. 重构最佳价格查找应用程序
- en: The first thing to avoid is waiting for the creation of a `List` that already
    contains all the prices. You need to work directly with the stream of `CompletableFuture`s,
    in which each `CompletableFuture` is executing the sequence of operations necessary
    for a given shop. In the next listing, you refactor the first part of the implementation
    from [listing 16.16](#ch16ex16) into a `findPricesStream` method to produce this
    stream of `CompletableFuture`s.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要避免的是等待包含所有价格的`List`的创建。你需要直接与`CompletableFuture`的流一起工作，其中每个`CompletableFuture`正在执行给定商店所需的操作序列。在下一列表中，你将实现的第一部分重构为`findPricesStream`方法，以生成这个`CompletableFuture`的流。
- en: Listing 16.22\. Refactoring the `findPrices` method to return a stream of `Future`s
  id: totrans-575
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.22\. 重构`findPrices`方法以返回一个`Future`流
- en: '[PRE86]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'At this point, you add a fourth `map` operation on the `Stream` returned by
    the `findPricesStream` method to the three already performed inside that method.
    This new operation registers an action on each `CompletableFuture`; this action
    consumes the value of the `CompletableFuture` as soon as it completes. The Java
    8 `CompletableFuture` API provides this feature via the `thenAccept` method, which
    takes as an argument a `Consumer` of the value with which it completes. In this
    case, this value is the `String` returned by the discount services and containing
    the name of a shop together with the discounted price of the requested product
    for that shop. The only action that you want to perform to consume this value
    is to print it:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你将一个第四个 `map` 操作添加到 `findPricesStream` 方法返回的 `Stream` 上，该方法中已经执行了三个操作。这个新操作在每个
    `CompletableFuture` 上注册一个动作；这个动作在 `CompletableFuture` 完成时立即消费其值。Java 8 的 `CompletableFuture`
    API 通过 `thenAccept` 方法提供了这个功能，该方法接受一个 `Consumer` 作为参数，该 `Consumer` 消费其完成的值。在这种情况下，这个值是由折扣服务返回的
    `String`，其中包含商店的名称以及该商店请求产品的折扣价格。你想要执行的唯一动作是打印这个值：
- en: '[PRE87]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you’ve seen for the `thenCompose` and `thenCombine` methods, the `thenAccept`
    method has an `Async` variant named `thenAcceptAsync`. The `Async` variant schedules
    the execution of the `Consumer` passed to it on a new thread from the thread pool
    instead of performing it directly, using the same thread that completed the `CompletableFuture`.
    Because you want to avoid an unnecessary context switch, and because (more important)
    you want to react to the completion of the `CompletableFuture` as soon as possible
    instead waiting for a new thread to be available, you don’t use this variant here.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 `thenCompose` 和 `thenCombine` 方法中看到的，`thenAccept` 方法有一个名为 `thenAcceptAsync`
    的 `Async` 变体。`Async` 变体将传递给它的 `Consumer` 的执行调度到线程池中的新线程上，而不是使用完成 `CompletableFuture`
    的相同线程直接执行。因为你想要避免不必要的上下文切换，并且（更重要的是）你想要尽快对 `CompletableFuture` 的完成做出反应，而不是等待新线程可用，所以在这里不使用这个变体。
- en: Because the `thenAccept` method already specifies how to consume the result
    produced by the `CompletableFuture` when it becomes available, it returns a `CompletableFuture<Void>`.
    As a result, the `map` operation returns a `Stream<CompletableFuture <Void>>`.
    You can’t do much with a `CompletableFuture<Void>` except wait for its completion,
    but this is exactly what you need. You also want to give the slowest shop a chance
    to provide its response and print its returned price. To do so, you can put all
    the `CompletableFuture<Void>`s of the stream into an array and then wait for all
    of them to complete, as shown in this next listing.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `thenAccept` 方法已经指定了当 `CompletableFuture` 可用时如何消费其产生的结果，所以它返回一个 `CompletableFuture<Void>`。因此，`map`
    操作返回一个 `Stream<CompletableFuture<Void>>`。对于 `CompletableFuture<Void>`，除了等待其完成之外，你几乎无法做任何事情，但这正是你所需要的。你还想给最慢的商店一个机会来提供其响应并打印其返回的价格。为此，你可以将流中的所有
    `CompletableFuture<Void>` 放入一个数组中，然后等待它们全部完成，就像在下面的列表中所展示的那样。
- en: Listing 16.23\. Reacting to `CompletableFuture` completion
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.23\. 对 `CompletableFuture` 完成做出反应
- en: '[PRE88]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `allOf` factory method takes as input an array of `CompletableFuture`s and
    returns a `CompletableFuture<Void>` that’s completed only when all the `CompletableFuture`s
    passed have completed. Invoking `join` on the `CompletableFuture` returned by
    the `allOf` method provides an easy way to wait for the completion of all the
    `CompletableFuture`s in the original stream. This technique is useful for the
    best-price-finder application because it can display a message such as `All shops
    returned results or timed out` so that a user doesn’t keep wondering whether more
    prices might become available.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`allOf` 工厂方法接受一个 `CompletableFuture` 数组作为输入，并返回一个 `CompletableFuture<Void>`，只有当传递的所有
    `CompletableFuture` 都已完成时才会完成。在 `allOf` 方法返回的 `CompletableFuture` 上调用 `join` 提供了一种等待原始流中所有
    `CompletableFuture` 完成的简单方法。这种技术在最佳价格查找应用程序中很有用，因为它可以显示一条消息，例如 `所有商店都返回了结果或超时`，这样用户就不会继续想知道是否还有更多的价格可能变得可用。'
- en: In other applications, you may want to wait for the completion of only one of
    the `CompletableFuture`s in an array, perhaps if you’re consulting two currency-exchange
    servers and are happy to take the result of the first to respond. In this case,
    you can use the `anyOf` factory method. As a matter of detail, this method takes
    as input an array of `CompletableFuture`s and returns a `CompletableFuture<Object>`
    that completes with the same value as the first-to-complete `CompletableFuture`.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他应用程序中，您可能只想等待数组中`CompletableFuture`的完成，例如，如果您正在咨询两个货币兑换服务器，并且对第一个响应的结果感到满意，您可以使用`anyOf`工厂方法。作为一个细节，此方法接受一个`CompletableFuture`数组作为输入，并返回一个`CompletableFuture<Object>`，它以第一个完成的`CompletableFuture`的相同值完成。
- en: 16.5.2\. Putting it all together
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.2\. 将所有内容整合在一起
- en: 'As discussed at the beginning of [section 16.5](#ch16lev1sec5), now suppose
    that all the methods simulating a remote invocation use the `randomDelay` method
    of [listing 16.21](#ch16ex21), introducing a random delay distributed between
    0.5 and 2.5 seconds instead of a delay of 1 second. Running the code in [listing
    16.23](#ch16ex23) with this change, you see that the prices provided by the shops
    don’t appear all at the same time, as happened before, but are printed incrementally
    as soon as the discounted price for a given shop is available. To make the result
    of this change more obvious, the code is slightly modified to report a timestamp
    showing the time taken for each price to be calculated:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第16.5节开头所述，现在假设所有模拟远程调用的方法都使用[列表16.21](#ch16ex21)中的`randomDelay`方法，引入介于0.5到2.5秒之间的随机延迟，而不是1秒的延迟。使用此更改运行[列表16.23](#ch16ex23)中的代码，您会发现商店提供的价格不会像之前那样同时出现，而是随着给定商店的折扣价格可用而逐步打印。为了使此更改的结果更明显，代码略有修改，以报告每个价格计算所需的时间戳：
- en: '[PRE89]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Running this code produces output similar to the following:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生类似于以下内容的输出：
- en: '[PRE90]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You can see that, due to the effect of the random delays, the first price now
    prints more than twice as fast as the last!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，由于随机延迟的影响，第一个价格现在打印的速度比最后一个快两倍以上！
- en: 16.6\. Road map
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.6\. 路线图
- en: '[Chapter 17](kindle_split_031.xhtml#ch17) explores the Java 9 Flow API, which
    generalizes the idea of `Computable-Future` (one-shot, either computing or terminated-with-a-value)
    by enabling computations to produce a series of values before optionally terminating.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](kindle_split_031.xhtml#ch17)探讨了Java 9 Flow API，该API通过启用计算在可选终止之前产生一系列值，从而泛化了`Computable-Future`（一次性，要么计算要么带有值的终止）的概念。'
- en: Summary
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Executing relatively long-lasting operations by using asynchronous tasks can
    increase the performance and responsiveness of your application, especially if
    it relies on one or more remote external services.
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用异步任务执行相对较长的操作可以提高应用程序的性能和响应速度，尤其是如果它依赖于一个或多个远程外部服务。
- en: You should consider providing an asynchronous API to your clients. You can easily
    implement one by using `CompletableFuture`s features.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该考虑为您的客户端提供一个异步API。您可以通过使用`CompletableFuture`的特性轻松实现一个。
- en: A `CompletableFuture` allows you to propagate and manage errors generated within
    an asynchronous task.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`允许您传播和管理异步任务中生成的错误。'
- en: You can asynchronously consume from a synchronous API by wrapping its invocation
    in a `CompletableFuture`.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过将同步API的调用包装在`CompletableFuture`中，异步地从同步API中消费。
- en: You can compose or combine multiple asynchronous tasks when they’re independent
    and when the result of one of them is used as the input to another.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个异步任务独立且其中一个的结果用作另一个的输入时，您可以组合或合并多个异步任务。
- en: You can register a callback on a `CompletableFuture` to reactively execute some
    code when the `Future` completes and its result becomes available.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在`CompletableFuture`上注册一个回调，以便在`Future`完成并且其结果可用时，反应性地执行一些代码。
- en: You can determine when all values in a list of `CompletableFuture`s have completed,
    or you can wait for only the first to complete.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以确定`CompletableFuture`列表中所有值何时完成，或者您可以只等待第一个完成。
- en: Java 9 added support for asynchronous timeouts on `CompletableFuture` via the
    `orTimeout` and `completeOnTimeout` methods.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9通过`orTimeout`和`completeOnTimeout`方法在`CompletableFuture`上添加了对异步超时的支持。
- en: Chapter 17\. Reactive programming
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17章\. 响应式编程
- en: '![](Images/java.jpg)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/java.jpg)'
- en: '*This chapter covers*'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Defining reactive programming and discussing the principles of the Reactive
    Manifesto
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义响应式编程并讨论响应式宣言的原则
- en: Reactive programming at the application and system levels
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序和系统级别的响应式编程
- en: Showing example code using reactive streams and the Java 9 Flow API
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式流和Java 9 Flow API展示示例代码
- en: Introducing RxJava, a widely used reactive library
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍广泛使用的响应式库RxJava
- en: Exploring the RxJava operations to transform and combine multiple reactive streams
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索RxJava操作以转换和组合多个响应式流
- en: Presenting marble diagrams that visually document operations on reactive streams
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示文档化响应式流操作的宝石图
- en: 'Before we dig into what reactive programming is and how it works, it’s helpful
    to clarify why this new paradigm is of growing importance. A few years ago, the
    largest applications had tens of servers and gigabytes of data; response times
    of several seconds and offline-maintenance times measured in hours were considered
    to be acceptable. Nowadays, this situation is changing rapidly for at least three
    reasons:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨响应式编程是什么以及它是如何工作的之前，澄清为什么这种新范例越来越重要是有帮助的。几年前，最大的应用程序有数十台服务器和数GB的数据；几秒钟的响应时间和以小时计的离线维护时间被认为是可接受的。如今，这种情况正在迅速变化，至少有三个原因：
- en: '***Big Data*—** Big Data usually is measured in petabytes and increasing daily.'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大数据**—大数据通常以PB（拍字节）为单位，并且每天都在增加。'
- en: '***Heterogeneous environments*—** Applications are deployed in diverse environments
    ranging from mobile devices to cloud-based clusters running thousands of multicore
    processors.'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异构环境**—应用程序被部署在从移动设备到运行数千个多核处理器的基于云的集群的多种环境中。'
- en: '***Use patterns*—** Users expect millisecond response times and 100 percent
    uptime.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用模式**—用户期望毫秒级响应时间和100%的在线时间。'
- en: These changes imply that today’s demands aren’t being met by yesterday’s software
    architectures. This situation has become evident especially now that mobile devices
    are the biggest source of internet traffic, and things can only worsen in the
    near future when such traffic is overtaken by the Internet of Things (IoT).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化意味着今天的需求无法通过昨天的软件架构得到满足。这种情况在移动设备成为互联网流量最大来源的今天尤为明显，而在不久的将来，当这种流量被物联网（IoT）所超越时，情况只会变得更糟。
- en: Reactive programming addresses these issues by allowing you to process and combine
    streams of data items coming from different systems and sources in an asynchronous
    way. In fact, applications written following this paradigm react to data items
    as they occur, which allows them to be more responsive in their interactions with
    users. Moreover, the reactive approach can be applied not only to building a single
    component or application, but also to coordinating many components into a whole
    reactive system. Systems engineered in this way can exchange and route messages
    in varying network conditions and provide availability under heavy load while
    taking into consideration failures and outages. (Note that although developers
    traditionally see their systems or applications as being built from components,
    in this new mashup, loosely coupled style of building systems, these components
    are often whole applications themselves. Hence, *components* and *applications*
    are near synonyms.)
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程通过允许你以异步方式处理和组合来自不同系统和来源的数据项流来解决这些问题。事实上，遵循这种范例编写的应用程序会对发生的数据项做出反应，这使得它们在与用户的交互中更加响应。此外，响应式方法不仅可以应用于构建单个组件或应用程序，还可以应用于将许多组件协调成一个完整的响应式系统。以这种方式构建的系统可以在不同的网络条件下交换和路由消息，在考虑故障和中断的情况下提供高负载下的可用性。（请注意，尽管开发者传统上认为他们的系统或应用程序是由组件构建的，但在这种新的混合风格中，松散耦合的系统构建方式，这些组件往往是完整的应用程序本身。因此，“组件”和“应用程序”几乎是同义词。）
- en: The features and advantages that characterize reactive applications and systems
    are crystallized in the Reactive Manifesto, which we discuss in the next section.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式应用程序和系统的特征和优势在下一节讨论的响应式宣言中得到了体现。
- en: 17.1\. The Reactive Manifesto
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1. 响应式宣言
- en: 'The Reactive Manifesto ([https://www.reactivemanifesto.org](https://www.reactivemanifesto.org))—developed
    in 2013 and 2014 by Jonas Bonér, Dave Farley, Roland Kuhn, and Martin Thompson—formalized
    a set of core principles for developing reactive applications and systems. The
    Manifesto identified four characteristic features:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式宣言（[https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)）——由Jonas
    Bonér、Dave Farley、Roland Kuhn和Martin Thompson于2013年和2014年开发——为开发响应式应用程序和系统制定了一套核心原则。宣言确定了四个特征：
- en: '***Responsive*—** A reactive system has a fast and, even more important, consistent,
    predictable response time. As a result, the user knows what to expect. This fact
    in turn increases user confidence, which is without a doubt the key aspect of
    a usable application.'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***响应性***—**反应式系统具有快速且更重要的是一致、可预测的响应时间。因此，用户知道可以期待什么。这一事实反过来又增加了用户的信心，这无疑是可用应用程序的关键方面。'
- en: '***Resilient*—** A system has to remain responsive despite failures. The Reactive
    Manifesto suggests different techniques to achieve resiliency, including replicating
    the execution of components, decoupling these components in time (sender and receiver
    have independent life cycles) and space (sender and receiver run in different
    processes), and letting each component asynchronously delegate tasks to other
    components.'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***弹性***—**一个系统必须在出现故障的情况下保持响应性。反应式宣言建议了不同的技术来实现弹性，包括复制组件的执行、在时间（发送者和接收者有独立的生命周期）和空间（发送者和接收者运行在不同的进程中）上解耦这些组件，以及让每个组件异步地将任务委托给其他组件。'
- en: '***Elastic*—** Another issue that harms the responsiveness of applications
    is the fact that they can be subject to different workloads during their life
    cycles. Reactive systems are designed to react automatically to a heavier workload
    by increasing the number of resources allocated to the affected components.'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***弹性***—**另一个损害应用程序响应性的问题是，它们在其生命周期内可能会受到不同的工作负载的影响。反应式系统被设计为能够自动对更重的工作负载做出反应，通过增加分配给受影响组件的资源数量。'
- en: '***Message-driven*—** Resilience and elasticity require the boundaries of the
    components that form the system to be clearly defined to ensure loose coupling,
    isolation, and location transparency. Communication across these boundaries is
    performed through asynchronous message passing. This choice enables both resiliency
    (by delegating failures as messages) and elasticity (by monitoring the number
    of exchanged messages and then scaling the number of the resources intended to
    manage them accordingly).'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***消息驱动***—**弹性和弹性要求构成系统的组件的边界清晰定义，以确保松散耦合、隔离和位置透明。这些边界之间的通信是通过异步消息传递来完成的。这种选择既实现了弹性（通过将故障作为消息委托）又实现了弹性（通过监控交换的消息数量，然后相应地扩展管理这些资源的资源数量）。'
- en: '[Figure 17.1](#ch17fig01) shows how these four features are related and dependent
    on one another. These principles are valid at different scales, from structuring
    the internals of a small application to determining how these applications have
    to be coordinated to build a large system. Specific points concerning the level
    of granularity where these ideas are applied, however, deserve to be discussed
    in further detail.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17.1](#ch17fig01) 展示了这四个特性是如何相互关联和依赖的。这些原则在不同的尺度上都是有效的，从小型应用程序的内部结构到确定这些应用程序如何协调以构建大型系统。然而，关于应用这些想法的粒度级别的具体问题，值得进一步详细讨论。'
- en: Figure 17.1\. The key features of a reactive system
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 17.1\. 反应式系统的关键特性
- en: '![](Images/17fig01_alt.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/17fig01_alt.jpg)'
- en: 17.1.1\. Reactive at application level
  id: totrans-627
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.1.1\. 应用级别的反应式
- en: The main feature of reactive programming for application-level components allows
    tasks to be executed asynchronously. As we discuss in the rest of this chapter,
    processing streams of events in an asynchronous and nonblocking way is essential
    for maximizing the use rate of modern multicore CPUs and, more precisely, of the
    threads competing for their use. To achieve this goal, the reactive frameworks
    and libraries share threads (relatively expensive and scarce resources) among
    lighter constructs such as futures; actors; and (more commonly) event loops dispatching
    a sequence of callbacks intended to aggregate, transform, and manage the events
    to be processed.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程在应用级组件中的主要特性允许异步执行任务。正如我们在本章的其余部分所讨论的，以异步和非阻塞的方式处理事件流对于最大化现代多核CPU的使用率至关重要，更确切地说，对于竞争使用它们的线程至关重要。为了实现这一目标，反应式框架和库在较轻的构造（如未来、演员；以及更常见的）事件循环中共享线程（相对昂贵且稀缺的资源），这些事件循环分发一系列回调，旨在聚合、转换和管理要处理的事件。
- en: '|  |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Background knowledge check**'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景知识检查**'
- en: If you’re puzzled by terms such as *event*, *message*, *signal*, and *event
    loop* (or *publish-subscribe*, *listener*, and *backpressure*, which are used
    later in this chapter), please read the gentler introduction in [chapter 15](kindle_split_029.xhtml#ch15).
    If not, read on.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于诸如*事件*、*消息*、*信号*和*事件循环*（或*发布-订阅*、*监听器*和*背压*，这些将在本章后面使用）等术语感到困惑，请阅读[第15章](kindle_split_029.xhtml#ch15)中的温和介绍。如果不，请继续阅读。
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'These techniques not only have the benefit of being cheaper than threads, but
    also have a major advantage from developers’ point of view: they raise the level
    of abstraction of implementing concurrent and asynchronous applications, allowing
    developers to concentrate on the business requirements instead of dealing with
    typical problems of low-level multithreading issues such as synchronization, race
    conditions, and deadlocks.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术不仅比线程更便宜，而且从开发者的角度来看还有一个主要优势：它们提高了实现并发和异步应用程序的抽象级别，使开发者能够专注于业务需求，而不是处理低级多线程问题（如同步、竞态条件和死锁）的典型问题。
- en: The most important thing to pay attention to when using these thread-multiplexing
    strategies is to never perform blocking operations inside the main event loop.
    It’s helpful to include as blocking operations all I/O-bound operations such as
    accessing a database or the file system or calling a remote service that may take
    a long or unpredictable time to complete. It’s easy and interesting to explain
    why you should avoid blocking operations by providing a practical example.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些线程多路复用策略时，最重要的是永远不要在主事件循环中执行阻塞操作。将所有I/O密集型操作（如访问数据库或文件系统或调用可能需要很长时间或不可预测时间完成的远程服务）视为阻塞操作是有帮助的。通过提供一个实际例子来解释为什么你应该避免阻塞操作，既容易又有趣。
- en: Imagine a simplified yet typical multiplexing scenario with a pool of two threads
    processing three streams of events. Only two streams can be processed at the same
    time and the streams have to compete to share those two threads as fairly and
    efficiently as possible. Now suppose that processing one stream’s event triggers
    a potentially slow I/O operation, such as writing into the file system or retrieving
    data from a database by using a blocking API. As [figure 17.2](#ch17fig02) shows,
    in this situation Thread 2 is wastefully blocked waiting for the I/O operation
    to complete, so although the Thread 1 can process the first stream, the third
    stream can’t be processed before the blocking operation finishes.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简化但典型的多路复用场景，其中有两个线程的线程池处理三个事件流。同时只能处理两个流，并且流必须尽可能公平和高效地竞争这两个线程。现在假设处理一个流的事件触发一个可能缓慢的I/O操作，例如通过阻塞API写入文件系统或从数据库检索数据。如图17.2[图17.2](#ch17fig02)所示，在这种情况下，线程2无谓地阻塞等待I/O操作完成，因此尽管线程1可以处理第一个流，但在阻塞操作完成之前，第三个流无法被处理。
- en: Figure 17.2\. A blocking operation wastefully keeps a thread busy preventing
    it from performing other computations.
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图17.2\. 一个阻塞操作无谓地占用线程，阻止它执行其他计算。
- en: '![](Images/17fig02_alt.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/17fig02_alt.jpg)'
- en: To overcome this problem, most reactive frameworks (such as RxJava and Akka)
    allow blocking operations to be executed by means of a separate dedicated thread
    pool. All the threads in the main pool are free to run uninterruptedly, keeping
    all the cores of the CPU at the highest possible use rate. Keeping separate thread
    pools for CPU-bound and I/O-bound operations has the further benefit of allowing
    you to size and configure the pools with a finer granularity and to monitor the
    performance of these two kinds of tasks more precisely.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，大多数响应式框架（如RxJava和Akka）允许通过一个单独的专用线程池来执行阻塞操作。主线程池中的所有线程都可以不间断地运行，保持CPU的所有核心以尽可能高的使用率运行。为CPU密集型和I/O密集型操作保留单独的线程池还有进一步的优点，即允许你以更精细的粒度对线程池进行大小和配置，并更精确地监控这两种类型任务的性能。
- en: Developing applications by following the reactive principles is only one aspect
    of reactive programming and often not even the hardest one. Having a set of beautifully
    designed reactive applications performing efficiently in isolation is at least
    as important as making them cooperate in a well-coordinated reactive system.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循响应式原则来开发应用程序只是响应式编程的一个方面，而且往往甚至不是最困难的。拥有一套设计精美的响应式应用程序，在独立运行时效率高，至少与使它们在一个协调良好的响应式系统中协作一样重要。
- en: 17.1.2\. Reactive at system level
  id: totrans-640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.1.2\. 系统级别的响应式
- en: A *reactive system* is a software architecture that allows multiple applications
    to work as a single coherent, resilient platform and also allows these applications
    to be sufficiently decoupled so when one of them fails, it doesn’t bring down
    the whole system. The main difference between reactive applications and systems
    is that the former type usually perform computations based on ephemeral streams
    of data and are called event-driven. The latter type are intended to compose the
    applications and facilitate communication. Systems with this property are often
    referred to as being message-driven.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**反应式系统**是一种软件架构，它允许多个应用程序作为一个单一、连贯、弹性的平台协同工作，同时也允许这些应用程序足够解耦，以至于当其中一个失败时，不会导致整个系统崩溃。反应式应用程序和系统之间的主要区别在于，前者通常基于短暂的数据流进行计算，被称为事件驱动。后者旨在组合应用程序并促进通信。具有这种特性的系统通常被称为消息驱动系统。
- en: The other important distinction between messages and events is the fact that
    messages are directed toward a defined single destination, whereas events are
    facts that will be received by the components that are registered to observe them.
    In reactive systems, it’s also essential for these messages to be asynchronous
    to keep the sending and the receiving operations decoupled from the sender and
    receiver, respectively. This decoupling is a requirement for full isolation between
    components and is fundamental for keeping the system *responsive* under both failures
    (*resilience*) and heavy load (*elasticity*).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 消息和事件之间的另一个重要区别是，消息是针对一个定义明确的单一目的地，而事件是事实，将被注册以观察它们的组件接收。在反应式系统中，这些消息也必须是异步的，以保持发送和接收操作与发送者和接收者之间的解耦。这种解耦是组件之间完全隔离的要求，对于在故障（弹性）和重负载（弹性）下保持系统**响应性**是基本的。
- en: More precisely, resilience is achieved in reactive architectures by isolating
    failures in the components where they happen to prevent the malfunctions from
    being propagated to adjacent components and from there in a catastrophic cascade
    to the rest of the system. Resilience in this reactive sense is more than fault-tolerance.
    The system doesn’t gracefully degrade but fully recovers from failures by isolating
    them and bringing the system back to a healthy state. This “magic” is obtained
    by containing the errors and reifying them as messages that are sent to other
    components acting as supervisors. In this way, the management of the problem can
    be performed from a safe context external to the failing component itself.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，通过隔离发生故障的组件，以防止故障传播到相邻组件，并从那里以灾难性的级联方式传播到整个系统，从而在反应式架构中实现弹性。在这种反应式意义上，弹性不仅仅是容错。系统不会优雅地退化，而是通过隔离故障并使系统恢复到健康状态，从而完全恢复。这种“魔法”是通过包含错误并将它们作为消息发送到其他作为监督者的组件来实现的。通过这种方式，可以从失败组件外部安全的环境中执行问题的管理。
- en: As isolation and decoupling are key for resilience, the main enabler for elasticity
    is *location transparency*, which allows any component of a reactive system to
    communicate with any other service, regardless of where the recipient resides.
    Location transparency in turn allows the system to replicate and (automatically)
    scale any application depending on the current workload. Such location-agnostic
    scaling shows another difference between reactive applications (asynchronous and
    concurrent and decoupled in time) and reactive systems (which can become decoupled
    in space through location transparency).
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隔离和解耦对于弹性至关重要，弹性主要是由*位置透明性*实现的，它允许反应式系统的任何组件与任何其他服务通信，无论接收者位于何处。位置透明性反过来又允许系统根据当前的工作负载复制和（自动）扩展任何应用程序。这种位置无关的扩展显示了反应式应用程序（异步、并发和解耦）和反应式系统（可以通过位置透明性在空间上解耦）之间的另一个区别。
- en: In the rest of this chapter, you put some of these ideas into practice with
    a few examples of reactive programming, and in particular, you explore Java 9’s
    Flow API.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将通过一些反应式编程的示例将这些想法付诸实践，特别是你将探索Java 9的Flow API。
- en: 17.2\. Reactive streams and the Flow API
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2. 反应式流和Flow API
- en: '*Reactive programming* is programming that uses reactive streams. Reactive
    streams are a standardized technique (based on the publish-subscribe, or pub-sub,
    protocol explained in [chapter 15](kindle_split_029.xhtml#ch15)) to process potentially
    unbounded streams of data asynchronously, in sequence and with mandatory nonblocking
    backpressure. Backpressure is a flow-control mechanism used in publish-subscribe
    to prevent a slow consumer of the events in the stream from being overwhelmed
    by one or more faster producers. When this situation occurs, it’s unacceptable
    for the component under stress to fail catastrophically or to drop events in an
    uncontrolled fashion. The component needs a way to ask the upstream producers
    to slow down or to tell them how many events it can accept and process at a given
    time before receiving more data.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '*反应式编程* 是一种使用反应式流的编程方式。反应式流是一种基于发布-订阅（或pub-sub）协议（在第15章中解释）的标准技术，用于异步、按顺序处理可能无界的数据流，并带有强制性的非阻塞背压。背压是发布-订阅中用于防止流中事件慢消费者被一个或多个更快生产者压垮的流量控制机制。当这种情况发生时，处于压力下的组件失败或无序地丢弃事件是不可接受的。该组件需要一种方式来请求上游生产者减速，或者告诉它们在接收更多数据之前可以接受和处理的特定时间内的数据量。'
- en: It’s worth noting that the requirement for built-in backpressure is justified
    by the asynchronous nature of the stream processing. In fact, when synchronous
    invocations are being performed, the system is implicitly backpressured by the
    blocking APIs. Unfortunately, this situation prevents you from executing any other
    useful task until the blocking operation is complete, so you end up wasting a
    lot of resources by waiting. Conversely, with asynchronous APIs you can maximize
    the use rate of your hardware, but run the risk of overwhelming some other slower
    downstream component. Backpressure or flow-control mechanisms come into play in
    this situation; they establish a protocol that prevents data recipients from being
    overwhelmed without having to block any threads.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，内置背压的要求是由流处理异步性质所证明的。事实上，当执行同步调用时，系统会隐式地通过阻塞API进行背压。不幸的是，这种情况阻止你执行任何其他有用的任务，直到阻塞操作完成，因此你最终会浪费大量资源等待。相反，使用异步API可以最大化硬件的使用率，但会面临压垮某些其他较慢下游组件的风险。在这种情况下，背压或流量控制机制就派上用场了；它们建立了一种协议，防止数据接收者被压垮，而不需要阻塞任何线程。
- en: These requirements and the behavior that they imply were condensed in the Reactive
    Streams^([[1](#ch17fn01)]) project ([www.reactive-streams.org](http://www.reactive-streams.org)),
    which involved engineers from Netflix, Red Hat, Twitter, Lightbend, and other
    companies, and produced the definition of four interrelated interfaces representing
    the minimal set of features that any Reactive Streams implementation has to provide.
    These interfaces are now part of Java 9, nested within the new `java.util.concurrent.Flow`
    class, and implemented by many third-party libraries, including Akka Streams (Lightbend),
    Reactor (Pivotal), RxJava (Netflix), and Vert.x (Red Hat). In the next section,
    we examine in detail the methods declared by these interfaces and clarify how
    they’re expected to be used to express reactive components.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求和它们所隐含的行为被总结在反应式流项目（Reactive Streams^([[1](#ch17fn01)]))中，该项目涉及Netflix、Red
    Hat、Twitter、Lightbend和其他公司的工程师，并产生了四个相互关联的接口的定义，这些接口代表了任何反应式流实现必须提供的最小功能集。这些接口现在是Java
    9的一部分，嵌套在新的`java.util.concurrent.Flow`类中，并由许多第三方库实现，包括Akka Streams（Lightbend）、Reactor（Pivotal）、RxJava（Netflix）和Vert.x（Red
    Hat）。在下一节中，我们将详细检查这些接口声明的方法，并阐明它们预期如何用于表达反应式组件。
- en: ¹
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We capitalize for the Reactive Streams project, but use reactive streams for
    the concept.
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们为反应式流项目命名，但使用反应式流的概念。
- en: 17.2.1\. Introducing the Flow class
  id: totrans-653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.2.1. 介绍 Flow 类
- en: 'Java 9 adds one new class for reactive programming: `java.util.concurrent.Flow`.
    This class contains only static components and can’t be instantiated. The `Flow`
    class contains four nested interfaces to express the publish-subscribe model of
    reactive programming as standardized by the Reactive Streams project:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 为反应式编程添加了一个新类：`java.util.concurrent.Flow`。这个类只包含静态组件，不能被实例化。`Flow` 类包含四个嵌套接口，用于表达反应式编程的发布-订阅模型，该模型由反应式流项目标准化：
- en: Publisher
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者
- en: Subscriber
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者
- en: Subscription
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅
- en: Processor
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器
- en: The `Flow` class allows interrelated interfaces and static methods to establish
    flow-controlled components, in which `Publisher`s produce items consumed by one
    or more `Subscriber`s, each managed by a `Subscription`. The `Publisher` is a
    provider of a potentially unbounded number of sequenced events, but it’s constrained
    by the backpressure mechanism to produce them according to the demand received
    from its `Subscriber`(s). The `Publisher` is a Java functional interface (declares
    only one single abstract method) that allows a `Subscriber` to register itself
    as a listener of the events issued by the `Publisher`; flow control, including
    backpressure, between `Publisher`s and `Subscriber`s is managed by a `Subscription`.
    These three interfaces, along with the `Processor` interface, are captured in
    [listings 17.1](#ch17ex01), [17.2](#ch17ex02), [17.3](#ch17ex03), and [17.4](#ch17ex04).
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow` 类允许通过相关接口和静态方法建立受控流组件，其中 `Publisher` 产生由一个或多个 `Subscriber` 消费的项目，每个
    `Subscriber` 都由一个 `Subscription` 管理。`Publisher` 是一个提供可能无界序列事件的提供者，但它受到背压机制的约束，必须根据从其
    `Subscriber`(s) 收到的需求来产生它们。`Publisher` 是一个 Java 函数式接口（仅声明一个抽象方法），允许 `Subscriber`
    将自己注册为 `Publisher` 发出事件的监听器；`Publisher` 和 `Subscriber` 之间的流控制，包括背压，由 `Subscription`
    管理。这三个接口，连同 `Processor` 接口，在 [列表 17.1](#ch17ex01)、[17.2](#ch17ex02)、[17.3](#ch17ex03)
    和 [17.4](#ch17ex04) 中列出。'
- en: Listing 17.1\. The `Flow.Publisher` interface
  id: totrans-660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.1\. `Flow.Publisher` 接口
- en: '[PRE91]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: On the other side, the `Subscriber` interface has four callback methods that
    are invoked by the `Publisher` when it produces the corresponding events.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，`Subscriber` 接口有四个回调方法，当 `Publisher` 产生相应的事件时，由 `Publisher` 调用。
- en: Listing 17.2\. The `Flow.Subscriber` interface
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.2\. `Flow.Subscriber` 接口
- en: '[PRE92]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Those events have to be published (and the corresponding methods invoked) strictly
    following the sequence defined by this protocol:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件必须严格按照此协议定义的顺序发布（并调用相应的方法）：
- en: '[PRE93]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This notation means that `onSubscribe` is always invoked as the first event,
    followed by an arbitrary number of `onNext` signals. The stream of events can
    go on forever, or it can be terminated by an `onComplete` callback to signify
    that no more elements will be produced or by an `onError` if the `Publisher` experiences
    a failure. (Compare reading from a terminal when you get a string or an indication
    of an end-of-file or I/O error.)
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法意味着 `onSubscribe` 总是作为第一个事件被调用，随后是任意数量的 `onNext` 信号。事件流可以无限进行，或者可以通过 `onComplete`
    回调来终止，表示不再产生更多元素，或者通过 `onError` 如果 `Publisher` 遇到失败。（与从终端读取字符串或文件结束或 I/O 错误的指示进行比较。）
- en: When a `Subscriber` registers itself on a `Publisher`, the `Publisher`’s first
    action is to invoke the `onSubscribe` method to pass back a `Subscription` object.
    The `Subscription` interface declares two methods. The `Subscriber` can use the
    first method to notify the `Publisher` that it’s ready to process a given number
    of events; the second method allows it to cancel the `Subscription`, thereby telling
    the `Publisher` that it’s no longer interested in receiving its events.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Subscriber` 在 `Publisher` 上注册时，`Publisher` 的第一个动作是调用 `onSubscribe` 方法来返回一个
    `Subscription` 对象。`Subscription` 接口声明了两个方法。`Subscriber` 可以使用第一个方法来通知 `Publisher`
    它已准备好处理给定数量的事件；第二个方法允许它取消 `Subscription`，从而告诉 `Publisher` 它不再感兴趣接收其事件。
- en: Listing 17.3\. The `Flow.Subscription` interface
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.3\. `Flow.Subscription` 接口
- en: '[PRE94]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The Java 9 Flow specification defines a set of rules through which the implementations
    of these interfaces should cooperate. These rules can be summarized as follows:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 流规范定义了一套规则，通过这些规则这些接口的实现应该相互协作。这些规则可以总结如下：
- en: The `Publisher` must send the `Subscriber` a number of elements no greater than
    that specified by the `Subscription`’s `request` method. A `Publisher`, however,
    may send fewer `onNext` than requested and terminate the `Subscription` by calling
    `onComplete` if the operation terminated successfully or `onError` if it failed.
    In these cases, when a terminal state has been reached (`onComplete` or `onError`),
    the `Publisher` can’t send any other signal to its `Subscriber`s, and the `Subscription`
    has to be considered to be canceled.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher` 必须向 `Subscriber` 发送不超过 `Subscription` 的 `request` 方法指定的元素数量。然而，`Publisher`
    可以发送少于请求的 `onNext` 并通过调用 `onComplete` 来终止 `Subscription`，如果操作成功或通过 `onError` 如果它失败。在这些情况下，当达到终端状态（`onComplete`
    或 `onError`）时，`Publisher` 不能向其 `Subscriber`s 发送任何其他信号，并且必须认为 `Subscription` 已被取消。'
- en: The `Subscriber` must notify the `Publisher` that it’s ready to receive and
    process `n` elements. In this way, the `Subscriber` exercises backpressure on
    the `Publisher` preventing the `Subscriber` from being overwhelmed by too many
    events to manage. Moreover, when processing the `onComplete` or `onError` signals,
    the `Subscriber` isn’t allowed to call any method on the `Publisher` or `Subscription`
    and must consider the `Subscription` to be canceled. Finally, the `Subscriber`
    must be prepared to receive these terminal signals even without any preceding
    call of the `Subscription.request()` method and to receive one or more `onNext`
    even after having called `Subscription.cancel()`.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber` 必须通知 `Publisher` 它已准备好接收和处理 `n` 个元素。通过这种方式，`Subscriber` 对 `Publisher`
    实施反向压力，防止 `Subscriber` 被过多的管理事件所淹没。此外，当处理 `onComplete` 或 `onError` 信号时，`Subscriber`
    不被允许在 `Publisher` 或 `Subscription` 上调用任何方法，并且必须认为 `Subscription` 已被取消。最后，`Subscriber`
    必须准备好在没有先前的 `Subscription.request()` 方法调用的情况下接收这些终端信号，甚至在调用 `Subscription.cancel()`
    之后也要接收一个或多个 `onNext`。'
- en: The `Subscription` is shared by exactly one `Publisher` and `Subscriber` and
    represents the unique relationship between them. For this reason, it must allow
    the `Subscriber` to call its `request` method synchronously from both the `onSubscribe`
    and `onNext` methods. The standard specifies that the implementation of the `Subscription.cancel()`
    method has to be idempotent (calling it repeatedly has the same effect as calling
    it once) and thread-safe so that, after the first time it has been called, any
    other additional invocation on the `Subscription` has no effect. Invoking this
    method asks the `Publisher` to eventually drop any references to the corresponding
    `Subscriber`. Resubscribing with the same `Subscriber` object is discouraged,
    but the specification doesn’t mandate an exception being raised in this situation
    because all previously canceled subscriptions would have to be stored indefinitely.
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscription` 由一个 `Publisher` 和一个 `Subscriber` 共享，并代表它们之间独特的关系。因此，它必须允许 `Subscriber`
    从 `onSubscribe` 和 `onNext` 方法中同步调用其 `request` 方法。标准指定 `Subscription.cancel()`
    方法的实现必须是幂等的（重复调用与单次调用具有相同的效果）并且线程安全的，这样，在第一次调用之后，对 `Subscription` 的任何其他附加调用都没有效果。调用此方法要求
    `Publisher` 最终放弃对相应 `Subscriber` 的任何引用。不建议使用相同的 `Subscriber` 对象重新订阅，但规范没有规定在这种情况下抛出异常，因为所有之前取消的订阅都必须无限期地存储。'
- en: '[Figure 17.3](#ch17fig03) shows the typical life cycle of an application implementing
    the interfaces defined by the Flow API.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.3](#ch17fig03) 展示了实现 Flow API 定义的接口的应用程序的典型生命周期。'
- en: Figure 17.3\. The life cycle of a reactive application using the Flow API
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 17.3\. 使用 Flow API 的反应式应用程序的生命周期
- en: '![](Images/17fig03_alt.jpg)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.3 替代文本](Images/17fig03_alt.jpg)'
- en: The fourth and final member of the `Flow` class is the `Processor` interface,
    which extends both `Publisher` and `Subscriber` without requiring any additional
    method.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow` 类的第四个也是最后一个成员是 `Processor` 接口，它扩展了 `Publisher` 和 `Subscriber` 接口，而不需要任何额外的函数。'
- en: Listing 17.4\. The `Flow.Processor` interface
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.4\. `Flow.Processor` 接口
- en: '[PRE95]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In fact, this interface represents a transformation stage of the events processed
    through the reactive stream. When receiving an error, the `Processor` can choose
    to recover from it (and then consider the `Subscription` to be canceled) or immediately
    propagate the `onError` signal to its `Subscriber`(s). The `Processor` should
    also cancel its upstream `Subscription` when its last `Subscriber` cancels its
    `Subscription` to propagate the cancellation signal (even though this cancellation
    isn’t strictly required by the specification).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，此接口代表了通过反应式流处理的事件的转换阶段。当收到错误时，`Processor` 可以选择从中恢复（然后认为 `Subscription` 已被取消）或立即将
    `onError` 信号传播给其 `Subscriber`(s)。当最后一个 `Subscriber` 取消其 `Subscription` 时，`Processor`
    应取消其上游 `Subscription` 以传播取消信号（即使规范没有严格要求这样做）。
- en: The Java 9 `Flow` API/Reactive Streams API mandates that any implementation
    of all the methods of the `Subscriber` interface should never block the `Publisher`,
    but it doesn’t specify whether these methods should process the events synchronously
    or asynchronously. Note, however, that all methods defined by these interfaces
    return `void` so that they can be implemented in a completely asynchronous way.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 的 `Flow` API/Reactive Streams API 要求任何 `Subscriber` 接口所有方法的实现都不应该阻塞 `Publisher`，但它没有指定这些方法应该同步还是异步地处理事件。然而，请注意，这些接口定义的所有方法都返回
    `void`，这样就可以完全异步地实现。
- en: In this next section, you try to put to work what you’ve learned so far through
    a simple, practical example.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的这一节中，你将通过一个简单实用的例子来运用到目前为止所学到的知识。
- en: 17.2.2\. Creating your first reactive application
  id: totrans-684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.2.2\. 创建你的第一个反应式应用程序
- en: The interfaces defined in the `Flow` class are, in most cases, not intended
    to be implemented directly. Unusually, the Java 9 library doesn’t provide classes
    that implement them either! These interfaces are implemented by the reactive libraries
    that we’ve already mentioned (Akka, RxJava, and so on). The Java 9 specification
    of `java.util.concurrency.Flow` works both as a contract to which all those libraries
    must adhere and a lingua franca allowing reactive applications developed on top
    of different reactive libraries to cooperate and talk to one another. Moreover,
    those reactive libraries typically offer many more features (classes and methods
    that transform and merge reactive streams beyond the minimal subset specified
    by the `java.util.concurrency.Flow` interface).
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Flow`类中定义的接口，在大多数情况下，并不是直接实现的。不寻常的是，Java 9库也没有提供实现它们的类！这些接口是由我们之前提到的反应式库（Akka、RxJava等）实现的。Java
    9对`java.util.concurrency.Flow`的规范既是一个所有这些库都必须遵守的合同，也是一个通用语言，允许基于不同反应式库开发的应用程序相互合作和通信。此外，这些反应式库通常提供更多功能（类和方法，这些类和方法可以转换和合并反应式流，而不仅仅是`java.util.concurrency.Flow`接口指定的最小子集）。
- en: 'That being said, it makes sense for you to develop a first reactive application
    directly on top of the Java 9 `Flow` API to get a feeling for how the four interfaces
    discussed in the preceding sections work together. To this end, you’ll write a
    simple temperature-reporting program using reactive principles. This program has
    two components:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，直接在Java 9的`Flow` API之上开发第一个反应式应用程序是有意义的，以了解前面几节讨论的四个接口是如何协同工作的。为此，你将编写一个简单的温度报告程序，使用反应式原则。这个程序有两个组件：
- en: '`TempInfo`, which mimics a remote thermometer (constantly reporting randomly
    chosen temperatures between 0 and 99 degrees Fahrenheit, which is appropriate
    for U.S. cities most of the time)'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TempInfo`，模拟一个远程温度计（不断报告0到99华氏度之间随机选择的温度，这对于大多数美国城市来说很合适）'
- en: '`TempSubscriber`, which listens to these reports and prints the stream of temperatures
    reported by a sensor installed in a given city'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TempSubscriber`，它监听这些报告并打印安装在特定城市中的传感器报告的温度流'
- en: The first step is defining a simple class that conveys the currently reported
    temperature, as shown in the following listing.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义一个简单的类，用于传达当前报告的温度，如下面的列表所示。
- en: Listing 17.5\. A Java bean conveying the currently reported temperature
  id: totrans-690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.5\. 一个传达当前报告温度的Java Bean
- en: '[PRE96]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* TempInfo instance for a given town is created via a static factory method.**'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过静态工厂方法创建给定城镇的TempInfo实例。**'
- en: '***2* Fetching the current temperature may randomly fail one time out of ten.**'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取当前温度可能会在十次中随机失败一次。**'
- en: '***3* Returns a random temperature in the range 0 to 99 degrees Fahrenheit**'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回0到99华氏度范围内的随机温度**'
- en: After defining this simple domain model, you can implement a `Subscription`
    for the temperatures of a given town that sends a temperature report whenever
    this report is requested by its `Subscriber` as shown in the following listing.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这个简单的领域模型之后，你可以实现一个针对特定城镇温度的`Subscription`，每当其`Subscriber`请求报告时，就会发送温度报告，如下面的列表所示。
- en: Listing 17.6\. A `Subscription` sending a stream of `TempInfo` to its `Subscriber`
  id: totrans-696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.6\. 一个向其`Subscriber`发送`TempInfo`流的`Subscription`
- en: '[PRE97]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '***1* Loops once per request made by the Subscriber**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每次由Subscriber发起的请求中循环一次**'
- en: '***2* Sends the current temperature to the Subscriber**'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将当前温度发送给Subscriber**'
- en: '***3* In case of a failure while fetching the temperature propagates the error
    to the Subscriber**'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在获取温度失败的情况下，将错误传播给Subscriber**'
- en: '***4* If the subscription is canceled, send a completion (onComplete) signal
    to the Subscriber.**'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果取消订阅，向Subscriber发送完成（onComplete）信号。**'
- en: The next step is creating a `Subscriber` that, every time it gets a new element,
    prints the temperatures received from the `Subscription` and asks for a new report
    as shown in the next listing.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个`Subscriber`，每次它接收到新元素时，都会打印从`Subscription`接收到的温度，并请求新的报告，如下面的列表所示。
- en: Listing 17.7\. A `Subscriber` printing the received temperatures
  id: totrans-703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.7\. 一个打印接收到的温度的`Subscriber`
- en: '[PRE98]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1* Stores the subscription and sends a first request**'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 存储订阅并发送第一个请求**'
- en: '***2* Prints the received temperature and requests a further one**'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印接收到的温度并请求进一步的一个**'
- en: '***3* Prints the error message in case of an error**'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在出错时打印错误信息**'
- en: The next listing puts your reactive application to work with a `Main` class
    that creates a `Publisher` and then subscribes to it by using `TempSubscriber`.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何使用创建 `Publisher` 并通过 `TempSubscriber` 订阅到它的 `Main` 类来使你的响应式应用程序工作。
- en: 'Listing 17.8\. A `main` class: creating a `Publisher` and subscribing `TempSubscriber`
    to it'
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.8\. 创建一个 `main` 类：创建一个 `Publisher` 并将 `TempSubscriber` 订阅到它
- en: '[PRE99]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '***1* Creates a new Publisher of temperatures in New York and subscribes the
    TempSubscriber to it**'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的纽约温度 `Publisher` 并将 `TempSubscriber` 订阅到它**'
- en: '***2* Returns a Publisher that sends a TempSubscription to the Subscriber that
    subscribes to it**'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回一个向订阅它的订阅者发送 `TempSubscription` 的 `Publisher**`'
- en: 'Here, the `getTemperatures` method returns a lambda expression that takes a
    `Subscriber` as an argument and invokes its `onSubscribe` method, passing to it
    a new `TempSubscription` instance. Because the signature of this lambda is identical
    to the only abstract method of the `Publisher` functional interface, the Java
    compiler can automatically convert the lambda to a `Publisher` (as you learned
    in [chapter 3](kindle_split_013.xhtml#ch03)). The `main` method creates a `Publisher`
    for the temperatures in New York and then subscribes a new instance of the `TempSubscriber`
    class to it. Running `main` produces output something like this:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`getTemperatures` 方法返回一个接受 `Subscriber` 作为参数并调用其 `onSubscribe` 方法的 lambda
    表达式，并将一个新的 `TempSubscription` 实例传递给它。因为这个 lambda 的签名与 `Publisher` 功能接口的唯一抽象方法签名相同，Java
    编译器可以自动将 lambda 转换为 `Publisher`（正如你在第 3 章中学到的）。`main` 方法创建了一个纽约温度的 `Publisher`，然后订阅了一个新的
    `TempSubscriber` 类实例。运行 `main` 会产生类似以下的输出：
- en: '[PRE100]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In the preceding run, `TempSubscription` successfully fetched the temperature
    in New York four times but failed on the fifth reading. It seems that you correctly
    implemented the problem by using three of the four interfaces of the Flow API.
    But are you sure that there aren’t any mistakes in the code? Give this question
    some thought by completing the following quiz.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的运行中，`TempSubscription` 成功获取了纽约的温度四次，但在第五次读取时失败了。似乎你正确地使用了 Flow API 的四个接口中的三个来实现了这个问题。但你确定代码中没有错误吗？通过完成以下练习来思考这个问题。
- en: '|  |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 17.1:**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 17.1：**'
- en: The example developed so far has a subtle problem. This problem, however, is
    hidden by the fact that at some point, the stream of temperatures will be interrupted
    by the error randomly generated inside the `TempInfo` factory method. Can you
    guess what will happen if you comment out the statement generating the random
    error and let your `main` run long enough?
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止开发的示例存在一个微妙的问题。然而，这个问题被这样一个事实所掩盖，即在某个时刻，温度流会被 `TempInfo` 工厂方法内部随机生成的错误中断。如果你注释掉生成随机错误的语句并让
    `main` 运行足够长的时间，你能猜到会发生什么吗？
- en: '**Answer:**'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'The problem with what you’ve done so far is that every time the `TempSubscriber`
    receives a new element into its `onNext` method, it sends a new request to the
    `TempSubscription`, and then the `request` method sends another element to the
    `Temp-Subscriber` itself. These recursive invocations are pushed onto the stack
    one after the other until the stack overflows, generating `StackOverflowError`
    like the following:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止所做的问题在于，每次 `TempSubscriber` 在其 `onNext` 方法中接收到一个新元素时，它会向 `TempSubscription`
    发送一个新的请求，然后 `request` 方法会向 `Temp-Subscriber` 本身发送另一个元素。这些递归调用一个接一个地推入栈中，直到栈溢出，生成类似于以下的
    `StackOverflowError`：
- en: '[PRE101]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '|  |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What can you do to fix this problem and avoid overflowing the stack? One possible
    solution is to add an `Executor` to the `TempSubscription` and then use it to
    send new elements to the `TempSubscriber` from a different thread. To achieve
    this goal, you can modify the `TempSubscription` as shown in the next listing.
    (The class is incomplete; the full definition uses the remaining definitions from
    [listing 17.6](#ch17ex06).)
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做什么来解决这个问题并避免栈溢出？一个可能的解决方案是在 `TempSubscription` 中添加一个 `Executor`，然后使用它从不同的线程向
    `TempSubscriber` 发送新的元素。为了达到这个目标，你可以按照下一个列表所示修改 `TempSubscription`。（该类是不完整的；完整的定义使用了
    [列表 17.6](#ch17ex06) 中的剩余定义。）
- en: Listing 17.9\. Adding an `Executor` to the `TempSubscription`
  id: totrans-724
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.9\. 向 `TempSubscription` 添加一个 `Executor`
- en: '[PRE102]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1* Unmodified code of original TempSubscription has been omitted.**'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 省略了原始 `TempSubscription` 的未修改代码。**'
- en: '***2* Sends the next elements to the subscriber from a different thread**'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从不同的线程向订阅者发送下一个元素**'
- en: So far, you’ve used only three of the four interfaces defined by the Flow API.
    What about the `Processor` interface? A good example of how to use that interface
    is to create a `Publisher` that reports the temperatures in Celsius instead of
    Fahrenheit (for subscribers outside the United States).
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只使用了 Flow API 定义的四个接口中的三个。那么 `Processor` 接口呢？使用该接口的一个好例子是创建一个 `Publisher`，它报告的是摄氏温度而不是华氏温度（对于美国以外的订阅者）。
- en: 17.2.3\. Transforming data with a Processor
  id: totrans-729
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.2.3\. 使用 Processor 转换数据
- en: As described in [section 17.2.1](#ch17lev2sec3), a `Processor` is both a `Subscriber`
    and a `Publisher`. In fact, it’s intended to subscribe to a `Publisher` and republish
    the data that it receives after transforming that data. As a practical example,
    implement a `Processor` that subscribes to a `Publisher` that emits temperatures
    in Fahrenheit and republishes them after converting them to Celsius, as shown
    in this next listing.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [17.2.1 节](#ch17lev2sec3) 所述，`Processor` 既是 `Subscriber` 也是 `Publisher`。实际上，它旨在订阅一个
    `Publisher` 并在转换数据后重新发布它接收到的数据。作为一个实际例子，实现一个 `Processor`，它订阅一个发布华氏温度的 `Publisher`
    并在将其转换为摄氏度后重新发布，如下一个列表所示。
- en: Listing 17.10\. A `Processor` transforming temperatures from Fahrenheit to Celsius
  id: totrans-731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.10\. 一个将华氏温度转换为摄氏温度的 `Processor`
- en: '[PRE103]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '***1* A processor transforming a TempInfo into another TempInfo**'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将一个 `TempInfo` 转换为另一个 `TempInfo` 的处理器**'
- en: '***2* Republishes the TempInfo after converting the temperature to Celsius**'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在将温度转换为摄氏度后重新发布 `TempInfo`**'
- en: '***3* All other signals are delegated unchanged to the upstream subscriber.**'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 所有其他信号都未改变地委托给上游订阅者。**'
- en: Note that the only method of the `TempProcessor` that contains some business
    logic is `onNext`, which republishes temperatures after converting them from Fahrenheit
    to Celsius. All other methods that implement the `Subscriber` interface merely
    pass on unchanged (delegate) all received signals to the upstream `Subscriber`,
    and the `Publisher`’s `subscribe` method registers the upstream `Subscriber` into
    the `Processor`.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`TempProcessor` 中唯一包含一些业务逻辑的方法是 `onNext`，它将温度从华氏转换为摄氏后再重新发布。所有其他实现 `Subscriber`
    接口的方法只是将接收到的所有信号（委托）传递给上游 `Subscriber`，而 `Publisher` 的 `subscribe` 方法将上游 `Subscriber`
    注册到 `Processor` 中。
- en: The next listing puts the `TempProcessor` to work by using it in your `Main`
    class.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表将 `TempProcessor` 用于你的 `Main` 类中。
- en: 'Listing 17.11\. `Main` class: create a `Publisher` and subscribe `TempSubscriber`
    to it'
  id: totrans-738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.11\. `Main` 类：创建一个 `Publisher` 并将其订阅给 `TempSubscriber`
- en: '[PRE104]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '***1* Creates a new Publisher of Celsius temperatures for New York**'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为纽约创建一个新的摄氏温度发布者**'
- en: '***2* Subscribes the TempSubscriber to the Publisher**'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 `TempSubscriber` 订阅到发布者**'
- en: '***3* Creates a TempProcessor and puts it between the Subscriber and returned
    Publisher**'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个 `TempProcessor` 并将其置于订阅者和返回的发布者之间**'
- en: 'This time, running `Main` produces the following output, with temperatures
    that are typical of the Celsius scale:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，运行 `Main` 产生了以下输出，其中温度是摄氏温度尺度上的典型值：
- en: '[PRE105]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In this section, you directly implemented the interfaces defined in the Flow
    API, and in doing so, you became familiar with asynchronous stream processing
    via the publish-subscribe protocol that forms the core idea of the Flow API. But
    there was something slightly unusual about this example, which we turn to in the
    next section.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你直接实现了在 Flow API 中定义的接口，并在这样做的同时，通过发布-订阅协议熟悉了异步流处理，这是 Flow API 的核心思想。但这个例子中有一点稍微不同寻常，我们将在下一节中讨论。
- en: 17.2.4\. Why doesn’t Java provide an implementation of the Flow API?
  id: totrans-746
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.2.4\. 为什么 Java 不提供 Flow API 的实现？
- en: The Flow API in Java 9 is rather odd. The Java library generally provides interfaces
    and implementations for them, but here, you’ve implemented the Flow API yourself.
    Let’s make a comparison with the List API. As you know, Java provides the `List<T>`
    interface that’s implemented by many classes, including `ArrayList<T>`. More precisely
    (and rather invisibly to the user) the class `ArrayList<T>` extends the abstract
    class `AbstractList<T>`, which implements the interface `List<T>`. By contrast,
    Java 9 declares the interface `Publisher<T>` and provides no implementation, which
    is why you had to define your own (apart from the learning benefit you got from
    implementing it). Let’s face it—an interface on its own may help you structure
    your programming thoughts, but it doesn’t help you write programs any faster!
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中的Flow API相当奇特。Java库通常提供接口及其实现，但在这里，你亲自实现了Flow API。让我们将其与List API进行比较。正如你所知，Java提供了由许多类实现的`List<T>`接口，包括`ArrayList<T>`。更精确（并且对用户来说几乎不可见）的是，`ArrayList<T>`类扩展了抽象类`AbstractList<T>`，该类实现了接口`List<T>`。相比之下，Java
    9声明了接口`Publisher<T>`，但没有提供实现，这就是为什么你必须定义自己的（除了从实现中获得的学习收益之外）。让我们面对现实——一个接口本身可能有助于你组织编程思想，但它并不能帮助你更快地编写程序！
- en: 'What’s going on? The answer is historic: there were multiple Java code libraries
    of reactive streams (such as Akka and RxJava). Originally, these libraries were
    developed separately, and although they implemented reactive programming via publish-subscribe
    ideas, they used different nomenclature and APIs. During the standardization process
    of Java 9, these libraries evolved so that their classes formally implemented
    the interfaces in `java.util.concurrent.Flow`, as opposed to merely implementing
    the reactive concepts. This standard enables more collaboration among different
    libraries.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？答案是历史的：有多个Java代码库的reactive streams（如Akka和RxJava）。最初，这些库是分别开发的，尽管它们通过发布-订阅思想实现了反应式编程，但它们使用了不同的命名法和API。在Java
    9标准化的过程中，这些库发生了演变，使得它们的类正式实现了`java.util.concurrent.Flow`中的接口，而不是仅仅实现了反应式概念。这一标准使得不同库之间的协作更加紧密。
- en: Note that building a reactive-streams implementation is complex, so most users
    will merely use an existing one. Like many classes that implement an interface,
    they typically provide richer functionality than is required for a minimal implementation.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构建一个reactive-streams实现是复杂的，因此大多数用户将仅使用现有的实现。像许多实现接口的类一样，它们通常提供比最小实现所需更丰富的功能。
- en: 'In the next section, you use one of the most widely used libraries: the RxJava
    (reactive extensions to Java) library developed by Netflix, specifically the current
    RxJava 2.0 version, which implements the Java 9 Flow interfaces.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将使用最广泛使用的库之一：由Netflix开发的RxJava（Java的反应式扩展）库，特别是当前的RxJava 2.0版本，它实现了Java
    9的Flow接口。
- en: 17.3\. Using the reactive library RxJava
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3\. 使用反应式库RxJava
- en: RxJava was among one the first libraries to develop reactive applications in
    Java. It was born at Netflix as a port of the Reactive Extensions (Rx) project,
    originally developed by Microsoft in the. Net environment. RxJava version 2.0
    was adjusted to adhere to the Reactive Streams API explained earlier in this chapter
    and adopted by Java 9 as `java.util.concurrent.Flow`.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava是第一个在Java中开发反应式应用的库之一。它诞生于Netflix，作为由微软在.NET环境中最初开发的Reactive Extensions
    (Rx)项目的移植。RxJava 2.0版本被调整以符合本章前面解释的反应式流API，并被Java 9作为`java.util.concurrent.Flow`采用。
- en: 'When you use an external library in Java, this fact is apparent from the imports.
    You import the Java Flow interfaces, for example, including `Publisher` with a
    line such as this:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Java中使用外部库时，这一点从导入中很明显。例如，你导入Java Flow接口，包括`Publisher`，使用如下一行代码：
- en: '[PRE106]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: But you also need to import the appropriate implementing classes with a line
    such as
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 但你还需要导入适当的实现类，例如使用一行代码
- en: '[PRE107]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: if you want to use the `Observable` implementation of `Publisher`, as you’ll
    choose to do later in this chapter.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用`Publisher`的`Observable`实现，正如你将在本章后面选择做的那样。
- en: 'We must emphasize one architectural issue: good systems-architectural style
    avoids making visible throughout the system any fine-details concepts that are
    used in only one part of the system. Accordingly, it’s good practice to use an
    `Observable` only where the additional structure of an `Observable` is required
    and otherwise use its interface of `Publisher`. Note that you observe this guideline
    with the `List` interface without thinking. Even though a method may have been
    passed a value that you know to be an `ArrayList`, you declare the parameter for
    this value to be of type `List`, so you avoid exposing and constraining the implementation
    details. Indeed, you allow a later change of implementation from `ArrayList` to
    `LinkedList` not to require ubiquitous changes.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须强调一个架构问题：良好的系统架构风格避免在整个系统中使任何仅在系统的一部分中使用的详细概念可见。因此，只在使用 `Observable` 的额外结构时使用
    `Observable` 是一个好的实践，否则使用其 `Publisher` 接口。请注意，你无需思考就能观察到这个指南与 `List` 接口。即使一个方法可能传递了一个你知道是
    `ArrayList` 的值，你也会声明这个值的参数类型为 `List`，这样你就避免了暴露和约束实现细节。实际上，你允许稍后从 `ArrayList` 更改为
    `LinkedList` 的实现，而不需要无处不在的更改。
- en: In the rest of this section, you define a temperature-reporting system by using
    RxJava’s implementation of reactive streams. The first issue you come across is
    that RxJava provides two classes, both of which implement `Flow.Publisher`.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，你将使用 RxJava 的反应式流实现来定义一个温度报告系统。你遇到的第一问题是 RxJava 提供了两个类，这两个类都实现了 `Flow.Publisher`。
- en: On reading the RxJava documentation, you find that one class is the `io.reactivex.Flowable`
    class, which includes the reactive pull-based backpressure feature of Java 9 `Flow`
    (using request) exemplified in [listings 17.7](#ch17ex07) and [17.9](#ch17ex09).
    Backpressure prevents a `Subscriber` from being overrun by data being produced
    by a fast `Publisher`. The other class is the original RxJava `io.reactivex.Observable`
    version of `Publisher`, which didn’t support backpressure. This class is both
    simpler to program and more appropriate for user-interface events (such as mouse
    movements); these events are streams that can’t be reasonably backpressured. (You
    can’t ask the user to slow down or stop moving the mouse!) For this reason, RxJava
    provides these two implementing classes for the common idea stream of events.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 RxJava 文档时，你会发现有一个类是 `io.reactivex.Flowable` 类，它包括 Java 9 `Flow`（使用请求）的基于反应式拉取的背压特性，这在
    [列表 17.7](#ch17ex07) 和 [17.9](#ch17ex09) 中举例说明。背压防止 `Subscriber` 被快速 `Publisher`
    产生的数据淹没。另一个类是原始 RxJava `io.reactivex.Observable` 版本的 `Publisher`，它不支持背压。这个类编程起来更简单，更适合用户界面事件（如鼠标移动）；这些事件是无法合理进行背压的流。（你不能要求用户减慢或停止移动鼠标！）因此，RxJava
    提供了这两个实现类来表示常见的事件流概念。
- en: The RxJava advice is to use the nonbackpressured `Observable` when you have
    a stream of no more than a thousand elements or when you’re are dealing with GUI
    events such as mouse moves or touch events, which are impossible to backpressure
    and aren’t frequent anyway.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 的建议是在你有不超过一千个元素的流或处理 GUI 事件（如鼠标移动或触摸事件）时使用非背压的 `Observable`，这些事件无法进行背压，而且本身也不频繁。
- en: Because we analyzed the backpressure scenario while discussing the Flow API
    in the preceding section, we won’t discuss `Flowable` anymore; instead, we’ll
    demonstrate the `Observable` interface at work in a use case without backpressure.
    It’s worth noting that any subscriber can effectively turn off backpressuring
    by invoking `request(Long .MAX_VALUE)` on the subscription, even if this practice
    isn’t advisable unless you’re sure that the `Subscriber` will always be able to
    process all the received events in a timely manner.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一节讨论 Flow API 时已经分析了背压场景，所以我们不再讨论 `Flowable`；相反，我们将通过一个没有背压的使用案例来展示 `Observable`
    接口的工作。值得注意的是，任何订阅者都可以通过在订阅上调用 `request(Long.MAX_VALUE)` 来有效地关闭背压，即使这种做法除非你确定 `Subscriber`
    总是能够及时处理所有接收到的事件，否则不建议这样做。
- en: 17.3.1\. Creating and using an Observable
  id: totrans-763
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.3.1\. 创建和使用一个可观察对象
- en: The `Observable` and `Flowable` classes come with many convenient factory methods
    that allow you to create many types of reactive streams. (Both `Observable` and
    `Flowable` implement `Publisher`, so these factory methods publish reactive streams.)
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 和 `Flowable` 类提供了许多方便的工厂方法，允许你创建许多类型的反应式流。（`Observable` 和 `Flowable`
    都实现了 `Publisher`，因此这些工厂方法发布反应式流。）'
- en: 'The simplest `Observable` that you may want to create is made of a fixed number
    of predetermined elements, as follows:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要创建的最简单的`Observable`是由固定数量的预定义元素组成的，如下所示：
- en: '[PRE108]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, the `just()` factory method^([[2](#ch17fn02)]) converts one or more elements
    to an `Observable` that emits those elements. A subscriber to this `Observable`
    receives `onNext("first")`, `onNext("second")`, and `onComplete()` messages, in
    that order.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`just()`工厂方法将一个或多个元素转换为发出这些元素的`Observable`。订阅此`Observable`的订阅者将按顺序接收到`onNext("first")`、`onNext("second")`和`onComplete()`消息。
- en: ²
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This naming convention is slightly unfortunate, because Java 8 started using
    `of()` for similar factory methods as popularized by the Stream and Optional APIs.
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种命名约定稍微有些不幸，因为Java 8开始使用`of()`来为类似工厂方法命名，这些方法是由Stream和Optional API推广的。
- en: 'Another `Observable` factory method that’s quite common, especially when your
    application interacts with a user in real time, emits events at a fixed time rate:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当常见的`Observable`工厂方法，尤其是在你的应用程序与用户实时交互时，以固定的时间速率发出事件：
- en: '[PRE109]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `interval` factory method returns an `Observable`, named `onePerSec`, that
    emits an infinite sequence of ascending values of type `long`, starting at zero,
    at a fixed time interval of your choosing (1 second in this example). Now plan
    to use `onePerSec` as the basis of another `Observable` that emits the temperature
    reported for a given town each second.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '`interval`工厂方法返回一个名为`onePerSec`的`Observable`，它发出一个无限序列，序列中的`long`类型值按升序排列，从零开始，以你选择的固定时间间隔（本例中为1秒）发出。现在计划使用`onePerSec`作为另一个`Observable`的基础，该`Observable`每秒发出给定城镇报告的温度。'
- en: As an intermediate step toward this goal, you can print those temperatures each
    second. To do so, you need to subscribe to `onePerSec` to be notified by it every
    time a second has passed and then fetch and print the temperatures of the town
    of interest. In RxJava, the `Observable`^([[3](#ch17fn03)]) plays the role of
    the `Publisher` in the Flow API, so the `Observer` similarly corresponds to Flow’s
    `Subscriber` interface. The RxJava `Observer` interface declares the same methods
    as the Java 9 `Subscriber` given in [listing 17.2](#ch17ex02), with the difference
    that the `onSubscribe` method has a `Disposable` argument rather than a `Subscription`.
    As we mentioned earlier, `Observable` doesn’t support backpressure, so it doesn’t
    have a `request` method that forms part of a `Subscription`. The full `Observer`
    interface is
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实现这一目标的中间步骤，你可以每秒打印这些温度。为此，你需要订阅`onePerSec`，以便在每过一秒时收到通知，然后获取并打印感兴趣城镇的温度。在RxJava中，`Observable`在Flow
    API中扮演了`Publisher`的角色，因此`Observer`类似于Flow的`Subscriber`接口。RxJava的`Observer`接口声明了与Java
    9中给出的`Subscriber`相同的函数，区别在于`onSubscribe`方法有一个`Disposable`参数而不是`Subscription`。如我们之前提到的，`Observable`不支持背压，因此它没有形成`Subscription`一部分的`request`方法。完整的`Observer`接口如下：
- en: ³
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the `Observer` interface and the `Observable` class have been deprecated
    since Java 9\. New code should use the Flow API. It remains to be seen how RxJava
    will evolve.
  id: totrans-777
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，自Java 9以来，`Observer`接口和`Observable`类已被弃用。新代码应使用Flow API。RxJava将如何发展还有待观察。
- en: '[PRE110]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Note, however, that RxJava’s API are more flexible (have more overloaded variants)
    than the native Java 9 `Flow` API. You can subscribe to an `Observable`, for example,
    by passing a lambda expression with the signature of the `onNext` method and omitting
    the other three methods. In other words, you can subscribe to an `Observable`
    with an `Observer` that implements only the `onNext` method with a `Consumer`
    of the received event, leaving the other methods defaulting to a no-op for completion
    and error handling. By using this feature, you can subscribe to the `Observable
    onePerSec` and use it to print the temperatures in New York once a second, all
    in a single line of code:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，RxJava的API比原生Java 9 `Flow` API更灵活（有更多的重载变体）。例如，你可以通过传递一个具有`onNext`方法签名的lambda表达式来订阅`Observable`，并省略其他三个方法。换句话说，你可以使用只实现`onNext`方法的`Observer`来订阅`Observable`，该`Observer`接收事件的处理为`Consumer`，其他方法默认为无操作（no-op）以处理完成和错误。通过使用此功能，你可以订阅`Observable
    onePerSec`并使用它每秒打印纽约的温度，所有这些都在一行代码中完成：
- en: '[PRE111]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In this statement, the `onePerSec Observable` emits one event per second. and
    on receipt of this message, the `Subscriber` fetches the temperature in New York
    and prints it. If you put this statement in a `main` method and try to execute
    it, however, you see nothing because the `Observable` publishing one event per
    second is executed in a thread that belongs to RxJava’s computation thread pool,
    which is made up of daemon threads.^([[4](#ch17fn04)]) But your `main` program
    terminates immediately and, in doing so, kills the daemon thread before it can
    produce any output.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，`onePerSec Observable`每秒发出一个事件。在收到这个消息后，`Subscriber`会获取纽约的温度并打印出来。然而，如果你将这个语句放在`main`方法中并尝试执行它，你将看不到任何东西，因为每秒发布一个事件的`Observable`是在属于RxJava计算线程池的线程中执行的，该线程池由守护线程组成。[4](#ch17fn04)
    但你的`main`程序会立即终止，在这个过程中，它会杀死守护线程，使其无法产生任何输出。
- en: ⁴
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This fact doesn’t seem to be clear from the documentation, although you can
    find statements to this effect in the [stackoverflow.com](http://stackoverflow.com)
    online developer community.
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个事实似乎在文档中并不明显，尽管你可以在[stackoverflow.com](http://stackoverflow.com)在线开发者社区中找到类似的说法。
- en: 'As a bit of a hack, you can prevent this immediate termination by putting a
    thread sleep after the preceding statement. Better, you could use the `blockingSubscribe`
    method that calls the callbacks on the current thread (in this case, the main
    thread). For the purposes of a running demonstration, `blockingSubscribe` is perfectly
    suitable. In a production context, however, you normally use the `subscribe` method,
    as follows:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种小技巧，你可以在前面的语句之后放置一个线程休眠来防止这种立即终止。更好的方法是使用`blockingSubscribe`方法，该方法在当前线程（在这种情况下，是主线程）上调用回调。为了演示的目的，`blockingSubscribe`是完美的。然而，在生产环境中，你通常使用`subscribe`方法，如下所示：
- en: '[PRE112]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'You may obtain output such as the following:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到以下输出：
- en: '[PRE113]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Unfortunately, the temperature fetching may, by design, fail randomly (and indeed
    does after three readings). Because your `Observer` implements only the happy
    path and doesn’t have any sort of error management, such as `onError`, this failure
    blows up in the user’s face as an uncaught exception.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于设计原因，温度获取可能会随机失败（实际上在读取三次后就会失败）。因为你的`Observer`只实现了快乐路径，并且没有进行任何错误管理，例如`onError`，这种失败会以未捕获异常的形式出现在用户面前。
- en: It’s time to raise the bar and start complicating this example a bit. You don’t
    want to add only error management. You also have to generalize what you have.
    You don’t want to print the temperatures immediately but provide users a factory
    method that returns an `Observable` emitting those temperatures once a second
    for (say) at most five times before completing. You can achieve this goal easily
    by using a factory method named `create` that creates an `Observable` from a lambda,
    taking as an argument another `Observer` and returning `void`, as shown in the
    following listing.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候提高标准并开始使这个例子复杂化一点了。你不仅想要添加错误管理，还要泛化你所拥有的。你不想立即打印温度，而是提供一个工厂方法，该方法返回一个每秒发出这些温度的`Observable`，最多（比如说）五次后完成。你可以通过使用名为`create`的工厂方法轻松实现这个目标，该方法从一个lambda表达式创建一个`Observable`，将另一个`Observer`作为参数，并返回`void`，如下所示。
- en: Listing 17.12\. Creating an `Observable` emitting temperature once a second
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表17.12\. 创建每秒发出温度的`Observable`
- en: '[PRE114]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '***1* Creates an Observable from a function consuming an Observer**'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从一个消耗观察者的函数创建Observable**'
- en: '***2* An Observable emitting an infinite sequence of ascending longs, one per
    second**'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个每秒发出无限升序长整型序列的Observable**'
- en: '***3* Do something only if the consumed observer hasn’t been disposed yet (for
    a former error).**'
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 只有在消耗的观察者尚未被处置（对于先前的错误）时才执行某些操作。**'
- en: '***4* If the temperature has been already emitted five times, completes the
    observer terminating the stream**'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果温度已经发出五次，完成观察者并终止流**'
- en: '***5* Otherwise, sends a temperature report to the Observer**'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 否则，向观察者发送温度报告**'
- en: '***6* In case of error, notifies the Observer**'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 发生错误时，通知观察者**'
- en: Here, you’re creating the returned `Observable` from a function that consumes
    an `ObservableEmitter`, sending the desired events to it. The RxJava `ObservableEmitter`
    interface extends the basic RxJava `Emitter`, which you can think of as being
    an `Observer` without the `onSubscribe` method,
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你从消耗`ObservableEmitter`的函数创建返回的`Observable`，向它发送所需的事件。RxJava的`ObservableEmitter`接口扩展了基本的RxJava
    `Emitter`，你可以将其视为没有`onSubscribe`方法的`Observer`，
- en: '[PRE115]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: with a few more methods to set a new `Disposable` on the `Emitter` and check
    whether the sequence has been already disposed downstream.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 几个额外的设置新 `Disposable` 在 `Emitter` 上和检查序列是否已经被下游丢弃的方法。
- en: Internally, you subscribe to an `Observable` such as `onePerSec` that publishes
    an infinite sequence of ascending longs, one per second. Inside the subscribing
    function (passed as an argument to the `subscribe` method), you first check whether
    the consumed `Observer` has been already disposed by the `isDisposed` method provided
    by the `ObservableEmitter` interface. (This situation could happen if an error
    occurred in an earlier iteration.) If the temperature has been already emitted
    five times, the code completes the `Observer,` terminating the stream; otherwise,
    it sends the most recent temperature report for the requested town to the `Observer`
    in a try/catch block. If an error occurs during the temperature fetching, it propagates
    the error to the `Observer`.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，你订阅了一个如 `onePerSec` 这样的 `Observable`，它发布了一个无限序列的递增长整型，每秒一个。在订阅函数（作为 `subscribe`
    方法的参数传递）中，你首先使用 `ObservableEmitter` 接口提供的 `isDisposed` 方法检查消耗的 `Observer` 是否已经被丢弃。（这种情况可能会在早期迭代中发生错误。）如果温度已经发射了五次，代码将完成
    `Observer`，终止流；否则，它将在一个 try/catch 块中将请求城镇的最新温度报告发送到 `Observer`。如果在获取温度期间发生错误，它将错误传播到
    `Observer`。
- en: Now it’s easy to implement a complete `Observer` that will later be used to
    subscribe to the `Observable` returned by the `getTemperature` method and that
    prints the temperatures it publishes as shown in the next listing.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易实现一个完整的 `Observer`，稍后它将被用来订阅由 `getTemperature` 方法返回的 `Observable` 并打印它发布的温度，如下一个列表所示。
- en: Listing 17.13\. An `Observer` printing the received temperatures
  id: totrans-804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.13\. 打印接收到的温度的 `Observer`
- en: '[PRE116]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This `Observer` is similar to the `TempSubscriber` class from [listing 17.7](#ch17ex07)
    (which implements Java 9’s `Flow.Subscriber)`, but you have a further simplification.
    Because RxJava’s `Observable` doesn’t support backpressure, you don’t need to
    `request()` further elements after processing the published ones.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Observer` 与 [列表 17.7](#ch17ex07) 中的 `TempSubscriber` 类（实现了 Java 9 的 `Flow.Subscriber`)
    类似，但你有一个更进一步的简化。因为 RxJava 的 `Observable` 不支持背压，所以在处理已发布的元素后，你不需要进一步 `request()`
    更多元素。
- en: In the next listing, you create a main program in which you subscribe this `Observer`
    to the `Observable` returned by the `getTemperature` method from [listing 17.12](#ch17ex12).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，你创建了一个主程序，在这个程序中，你将这个 `Observer` 订阅到由 `getTemperature` 方法返回的 `Observable`，该方法来自
    [列表 17.12](#ch17ex12)。
- en: Listing 17.14\. A `main` class printing the temperatures in New York
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.14\. 一个打印纽约温度的 `main` 类
- en: '[PRE117]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '***1* Creates an Observable emitting the temperatures reported in New York
    once a second**'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个每秒发射纽约报告温度的 `Observable`**'
- en: '***2* Subscribes to that Observable with a simple Observer that prints the
    temperatures**'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用一个简单的 `Observer` 订阅到那个 `Observable` 并打印温度**'
- en: 'Supposing that this time, no error occurs while the temperatures are being
    fetched, `main` prints a line per second five times, and then the `Observable`
    emits the `onComplete` signal, so you might obtain output like the following:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这次在获取温度时没有发生错误，`main` 每秒打印一行，共打印五次，然后 `Observable` 发射 `onComplete` 信号，因此你可能得到以下输出：
- en: '[PRE118]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: It’s time to enrich your RxJava example a bit further and in particular to see
    how this library allows you to manipulate one or more reactive streams.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进一步丰富你的 RxJava 示例了，特别是看看这个库如何让你操作一个或多个响应式流。
- en: 17.3.2\. Transforming and combining Observables
  id: totrans-815
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.3.2\. 转换和组合 Observables
- en: One of the main advantages of RxJava and other reactive libraries in working
    with reactive streams, compared with what’s offered by the native Java 9 `Flow`
    API, is that they provide a rich toolbox of functions to combine, create, and
    filter any of those streams. As we demonstrated in the preceding sections, a stream
    can be used as an input to another one. Also, you’ve learned about the Java 9
    `Flow.Processor` used in [section 17.2.3](#ch17lev2sec5) to transform temperatures
    in Fahrenheit to Celsius. But you can also filter a stream to get another one
    that has only the elements you’re interested in, transform those elements with
    a given mapping function (both these things can be achieved with `Flow.Processor`),
    or even merge or combine two streams in many ways (which can’t be achieved with
    `Flow.Processor`).
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 与原生Java 9 `Flow` API提供的功能相比，RxJava和其他反应库在处理反应流方面的主要优势之一是它们提供了一套丰富的函数工具箱，用于组合、创建和过滤这些流中的任何流。正如我们在前面的章节中展示的那样，一个流可以用作另一个流的输入。此外，你已经了解了在[第17.2.3节](#ch17lev2sec5)中使用的Java
    9 `Flow.Processor`，用于将华氏温度转换为摄氏温度。但你也可以过滤一个流以获取只包含你感兴趣元素的另一个流，使用给定的映射函数转换这些元素（这两件事都可以通过`Flow.Processor`实现），或者以许多方式合并或组合两个流（这不能通过`Flow.Processor`实现）。
- en: 'These transforming and combining functions can be quite sophisticated, to the
    point that explaining their behavior in plain words may result in awkward, convoluted
    sentences. To get an idea, see how RxJava documents its `mergeDelayError` function:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换和组合函数可能相当复杂，以至于用普通语言解释它们的行为可能会导致尴尬、复杂的句子。为了获得一个概念，看看RxJava如何记录其`mergeDelayError`函数：
- en: '*Flattens an Observable that emits Observables into one Observable, in a way
    that allows an Observer to receive all successfully emitted items from all of
    the source Observables without being interrupted by an error notification from
    one of them, while limiting the number of concurrent subscriptions to these Observables.*'
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*将发出Observables的Observable扁平化为一个Observable，以允许观察者接收所有成功发出的项目，而不会因其中一个Observable的错误通知而中断，同时限制对这些Observable的并发订阅数量。*'
- en: You must admit that what this function does isn’t immediately evident. To alleviate
    this problem, the reactive-streams community decided to document the behaviors
    of these functions in a visual way, using so-called marble diagrams. A *marble
    diagram*, such as that shown in [figure 17.4](#ch17fig04), represents the temporally
    ordered sequence of elements in a reactive stream as geometric shapes on a horizontal
    line; special symbols represent error and completion signals. Boxes indicate how
    named operators transform those elements or combine multiple streams.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须承认这个函数所做的事情并不立即明显。为了减轻这个问题，反应流社区决定以视觉方式记录这些函数的行为，使用所谓的弹珠图。一个*弹珠图*，如图17.4所示，将反应流中元素的时序序列表示为水平线上的几何形状；特殊符号表示错误和完成信号。方框表示命名操作符如何转换这些元素或组合多个流。
- en: Figure 17.4\. Legend of a marble diagram documenting an operator provided by
    a typical reactive library
  id: totrans-820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图17.4. 记录一个典型反应库提供的操作符的弹珠图例
- en: '![](Images/17fig04_alt.jpg)'
  id: totrans-821
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/17fig04_alt.jpg)'
- en: Using this notation, it’s easy to provide a visual representation of the features
    of all the RxJava library’s functions as shown in [figure 17.5](#ch17fig05), which
    exemplifies `map` (which transforms the elements published by an `Observable)`
    and `merge` (which combines the events emitted by two or more `Observable`s into
    one).
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种表示法，很容易提供RxJava库所有函数特性的视觉表示，如图17.5所示，该图例展示了`map`（将`Observable`发布的元素进行转换）和`merge`（将两个或更多`Observable`发出的事件合并成一个）。
- en: Figure 17.5\. The marble diagrams for the map and merge functions
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图17.5. map和merge函数的弹珠图
- en: '![](Images/17fig05_alt.jpg)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/17fig05_alt.jpg)'
- en: You may wonder how you can use `map` and `merge` to improve and add features
    to the RxJava example that you developed in the preceding section. Using `map`
    is a more concise way to achieve the transformation from Fahrenheit to Celsius
    that you implemented by using the Flow API’s `Processor`, as shown in the following
    listing.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何使用`map`和`merge`来改进和添加你在前面章节中开发的RxJava示例的功能。使用`map`是一种更简洁的方式来实现使用Flow
    API的`Processor`实现的华氏到摄氏的转换，如下面的列表所示。
- en: Listing 17.15\. Using `map` on `Observable` to transform Fahrenheit into Celsius
  id: totrans-826
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表17.15. 使用`map`在`Observable`上转换华氏温度到摄氏温度
- en: '[PRE119]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This simple method takes the `Observable` returned by the `getTemperature` method
    of [listing 17.12](#ch17ex12) and returns another `Observable` that re-emits the
    temperatures published (once a second) by the first one after transforming them
    from Fahrenheit to Celsius.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法接受 [列表 17.12](#ch17ex12) 中的 `getTemperature` 方法返回的 `Observable`，并返回另一个
    `Observable`，它重新发出第一个 `Observable`（每秒发布一次）发布的温度，在将其从华氏度转换为摄氏度后。
- en: To reinforce your understanding of how you can manipulate the elements emitted
    by an `Observable`, try to use another transforming function in the following
    quiz.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强你对如何操作 `Observable` 发出的元素的理解，尝试在以下练习中使用另一个转换函数。
- en: '|  |'
  id: totrans-830
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 17.2: Filtering only negative temperatures**'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 17.2：仅过滤负温度**'
- en: The `filter` method of the `Observable` class takes a `Predicate` as an argument
    and produces a second `Observable` that emits only the elements that pass the
    test defined by that `Predicate`. Suppose that you’ve been asked to develop a
    warning system that alerts the user when there’s risk of ice. How can you use
    this operator to create an `Observable` that emits the temperature in Celsius
    registered in a town only in case the temperature is below zero? (The Celsius
    scale conveniently uses zero for the freezing point of water.)
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 类的 `filter` 方法接受一个 `Predicate` 作为参数，并产生一个第二个 `Observable`，它只发出通过该
    `Predicate` 定义测试的元素。假设你被要求开发一个预警系统，当有结冰风险时提醒用户。你如何使用这个操作符创建一个只当温度低于零时才发出城镇摄氏温度的
    `Observable`？（摄氏度方便地使用零作为水的冰点。）'
- en: '**Answer:**'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'It’s enough to take the `Observable` returned by the method in [listing 17.15](#ch17ex15)
    and apply to it the `filter` operator with a `Predicate` that accepts only negative
    temperature as follows:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用 [列表 17.15](#ch17ex15) 中的方法返回的 `Observable`，并应用一个只接受负温度的 `Predicate` 的 `filter`
    操作符，如下所示：
- en: '[PRE120]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '|  |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now also imagine that you’ve been asked to generalize this last method and allow
    your users to have an `Observable` that emits the temperatures not only for a
    single town, but also for a set of towns. [Listing 17.16](#ch17ex16) satisfies
    the last requirement by invoking the method in [listing 17.15](#ch17ex15) once
    for each town and combining all the `Observable`s obtained from these invocations
    into a single one through the `merge` function.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 现在也假设你被要求推广这个最后的方法，并允许用户拥有一个不仅为单个城镇，也为一组城镇发出温度的 `Observable`。[列表 17.16](#ch17ex16)
    通过对每个城镇调用 [列表 17.15](#ch17ex15) 中的方法一次，并将从这些调用中获得的所有 `Observable` 通过 `merge` 函数合并成一个来满足最后一个要求。
- en: Listing 17.16\. Merging the temperatures reported for one or more towns
  id: totrans-838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.16\. 合并一个或多个城镇报告的温度
- en: '[PRE121]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This method takes a varargs argument containing the set of towns for which you
    want temperatures. This varargs is converted to a stream of `String`; then each
    `String` is passed to the `getCelsiusTemperature` method of [listing 17.11](#ch17ex11)
    (improved in [listing 17.15](#ch17ex15)). This way, each town is transformed into
    an `Observable` emitting the temperature of that town each second. Finally, the
    stream of `Observable`s is collected into a list, and the list is passed to the
    m`erge` static factory method provided by the `Observable` class itself. This
    method takes an `Iterable` of `Observable`s and combines their output so that
    they act like a single `Observable`. In other words, the resulting `Observable`
    emits all the events published by all the `Observable`s contained in the passed
    `Iterable`, preserving their temporal order.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个包含你想要温度的城镇集合的 varargs 参数。这个 varargs 被转换为 `String` 的流；然后每个 `String` 都传递给
    [列表 17.11](#ch17ex11)（在 [列表 17.15](#ch17ex15) 中改进）中的 `getCelsiusTemperature` 方法。这样，每个城镇都被转换为一个每秒发出该城镇温度的
    `Observable`。最后，`Observable` 的流被收集到一个列表中，该列表被传递给 `Observable` 类本身提供的 `merge` 静态工厂方法。这个方法接受一个
    `Observable` 的 `Iterable`，并组合它们的输出，使它们像一个单一的 `Observable`。换句话说，生成的 `Observable`
    发出所有在传递的 `Iterable` 中包含的 `Observable` 发布的事件，并保持它们的时序。
- en: To test this method, use it in one final `main` class as shown in the following
    listing.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个方法，可以在以下列表中将其用于一个最终的 `main` 类。
- en: Listing 17.17\. A `main` class printing the temperatures in three towns
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.17\. 打印三个城镇温度的 `main` 类
- en: '[PRE122]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This `main` class is identical to the one in [listing 17.14](#ch17ex14) except
    that you’re now subscribing to the `Observable` returned by the `getCelsiusTemperatures`
    method in [listing 17.16](#ch17ex16) and printing the temperatures registered
    for three towns. Running this `main` produces output such as this:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`main`类与[列表17.14](#ch17ex14)中的类相同，只是你现在正在订阅[列表17.16](#ch17ex16)中`getCelsiusTemperatures`方法返回的`Observable`，并打印三个城镇注册的温度。运行这个`main`会产生如下输出：
- en: '[PRE123]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Each second, `main` prints the temperature of each requested town until one
    of the temperature-fetching operations raises an error that’s propagated to the
    `Observer`, interrupting the stream of data.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒钟，`main`都会打印每个请求城镇的温度，直到温度检索操作引发一个错误，该错误传播到`Observer`，中断数据流。
- en: The purpose of this chapter wasn’t to provide a complete overview of RxJava
    (or any other reactive library), for which a complete book would be necessary,
    but to give you a feeling for how this kind of toolkit works and to introduce
    you to the principles of reactive programming. We’ve merely scratched the surface
    of this programming style, but we hope that we’ve demonstrated some of its advantages
    and stimulated your curiosity about it.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 这章的目的不是提供一个完整的RxJava（或任何其他反应式库）概述，这需要一本完整的书，而是让你对这类工具包的工作方式有一个感觉，并介绍你到反应式编程的原则。我们只是触及了这种编程风格的表面，但我们希望我们已经展示了它的一些优点，并激发了你对它的好奇心。
- en: Summary
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The fundamental ideas behind reactive programming are 20 to 30 years old, but
    have become popular recently because of the high demands of modern applications
    in terms of amount of processed data and users’ expectations.
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程背后的基本思想已有20到30年的历史，但最近因为现代应用对处理数据量和用户期望的高要求而变得流行。
- en: 'These ideas have been formalized by the Reactive Manifesto, which states that
    reactive software must be characterized by four interrelated features: responsiveness,
    resiliency, elasticity, and that quality of being message-driven.'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些思想通过反应式宣言得到了正式化，该宣言指出，反应式软件必须由四个相互关联的特征来表征：响应性、弹性、弹性和消息驱动性。
- en: The principles of reactive programming can be applied, with some differences,
    in implementing a single application and in designing a reactive system that integrates
    multiple applications.
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程的原则可以应用于实现单个应用程序，以及在设计和集成多个应用程序的反应式系统中，有一些差异。
- en: A reactive application is based on asynchronous processing of one or more flows
    of events conveyed by reactive streams. Because the role of reactive streams is
    so central in development of reactive applications, a consortium of companies
    including Netflix, Pivotal, Lightbend, and Red Hat standardized the concepts to
    maximize the interoperability of different implementations.
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个反应式应用程序基于异步处理一个或多个由反应式流传达的事件流。由于反应式流在反应式应用程序开发中的角色非常关键，包括Netflix、Pivotal、Lightbend和Red
    Hat在内的公司联盟将这些概念标准化，以最大化不同实现之间的互操作性。
- en: Because reactive streams are processed asynchronously, they’ve been designed
    with a built-in backpressure mechanism. This prevents a slow consumer from being
    overwhelmed by faster producers.
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于反应式流是异步处理的，因此它们被设计为具有内置的背压机制。这可以防止消费者被更快的生产者淹没。
- en: 'The result of this design and standardization process has been incorporated
    into Java. The Java 9 `Flow` API defines four core interfaces: `Publisher`, `Subscriber`,
    `Subscription`, and `Processor`.'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个设计和标准化过程的结果已经被纳入Java中。Java 9的`Flow` API定义了四个核心接口：`Publisher`、`Subscriber`、`Subscription`和`Processor`。
- en: These interfaces aren’t intended, in most cases, to be implemented directly
    by developers, but to act as a lingua franca for the various libraries that implement
    the reactive paradigm.
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，这些接口不是为了直接由开发者实现，而是作为实现反应式范式的各种库之间的通用语言。
- en: One of the most commonly used of these toolkits is RxJava, which (in addition
    to the basic features defined by the Java 9 `Flow` API) provides many useful,
    powerful operators. Examples include operators that conveniently transform and
    filter the elements published by a single reactive stream and operators that combine
    and aggregate multiple streams.
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些工具包中最常用的是RxJava，它（除了Java 9 `Flow` API定义的基本功能外）还提供了许多有用的强大操作符。例如，包括方便地转换和过滤单个反应式流发布的元素的操作符，以及合并和聚合多个流的操作符。
