- en: 7 Putting a GUI onto a game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 将GUI添加到游戏中
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Comparing old and newer GUI systems
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较旧的和新的GUI系统
- en: Creating a canvas for the interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为界面创建画布
- en: Positioning UI elements by using anchor points
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锚点定位UI元素
- en: Adding interactivity to the UI (buttons, sliders, and so on)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向UI添加交互性（按钮、滑块等）
- en: Broadcasting and listening for events from the UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从UI广播和监听事件
- en: In this chapter, you’ll build a 2D interface display for a 3D game. So far,
    we’ve focused on the virtual scene itself while building a first-person demo.
    But every game needs abstract interaction and information displays in addition
    to the virtual scene the gameplay takes place in. This is true for all games,
    whether they’re 2D or 3D, first-person shooters or puzzle games. So, while the
    techniques in this chapter will be used on a 3D game, they apply to 2D games as
    well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将为3D游戏构建一个2D界面显示。到目前为止，我们在构建第一人称演示时一直专注于虚拟场景本身。但每个游戏都需要除了游戏发生的虚拟场景之外的抽象交互和信息显示。这对所有游戏都适用，无论是2D还是3D，第一人称射击游戏还是益智游戏。因此，尽管本章中的技术将用于3D游戏，但它们也适用于2D游戏。
- en: These abstract interaction displays are referred to as the *UI*, or more specifically,
    the *GUI*. GUI (short for Graphical User Interface) refers to the visual part
    of the interface, such as text and buttons (see figure 7.1). Technically, the
    UI includes nongraphical controls, such as the keyboard or game pad, but people
    tend to be referring to the graphical parts when they say “user interface.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象交互显示被称为**UI**，或者更具体地说，**GUI**。GUI（代表图形用户界面）指的是界面的视觉部分，如文本和按钮（见图7.1）。技术上，UI包括非图形控件，如键盘或游戏手柄，但人们通常在提到“用户界面”时指的是图形部分。
- en: '![CH07_F01_Hocking3](../Images/CH07_F01_Hocking3.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_Hocking3](../Images/CH07_F01_Hocking3.png)'
- en: Figure 7.1 The GUI you’ll create for a game
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 为游戏创建的GUI
- en: Although any software requires some sort of UI in order for the user of that
    software to control it, games often use their GUI in a slightly different way
    from other software. In a website, for example, the GUI basically *is* the website
    (in terms of visual representation). In a game, though, text and buttons are often
    an additional overlay on top of the Game view, a kind of display called a *heads-up
    display* (*HUD*).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何软件都需要某种形式的UI以便用户控制它，但游戏通常以与其他软件略有不同的方式使用它们的GUI。例如，在一个网站上，GUI基本上**就是**网站（从视觉表现的角度来看）。然而，在游戏中，文本和按钮通常是游戏视图上的额外叠加，这是一种称为**抬头显示**
    (*HUD*) 的显示方式。
- en: DEFINITION A *heads-up display* (*HUD*) superimposes graphics on top of the
    view of the world. The concept of a HUD originated with military jets—its purpose
    was to enable pilots to see crucial information without having to look down. Similarly,
    a GUI superimposed on the Game view is referred to as the HUD.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 一个**抬头显示** (*HUD*) 将图形叠加在世界的视图之上。HUD的概念起源于军用飞机——其目的是让飞行员能够在不低头的情况下看到关键信息。同样，叠加在游戏视图上的GUI被称为HUD。'
- en: This chapter shows how to build the game’s HUD by using the UI tools in Unity.
    As you saw in chapter 5, Unity provides multiple ways to create UI displays. This
    chapter demonstrates the advanced UI system that replaced Unity’s first UI system.
    I also discuss the previous UI system and the advantages of the newer system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何使用Unity中的UI工具构建游戏的HUD。正如你在第5章中看到的，Unity提供了多种创建UI显示的方式。本章演示了取代Unity最初UI系统的先进UI系统。我还讨论了之前的UI系统以及新系统的优势。
- en: 'To learn about the UI tools in Unity, you’ll build on top of the FPS project
    from chapter 3\. The project in this chapter involves these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Unity中的UI工具，你将在第3章的FPS项目基础上进行构建。本章的项目涉及以下步骤：
- en: Planning the interface
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规划界面
- en: Placing UI elements on the display
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示上放置UI元素
- en: Programming interactions with the UI elements
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程与UI元素之间的交互
- en: Making the GUI respond to events in the scene
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使GUI对场景中的事件做出响应
- en: Making the scene respond to actions on the GUI
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使场景对GUI上的操作做出响应
- en: Copy the project from chapter 3 and open the copy to start working in this chapter.
    As usual, the art assets you need are in the sample download. With those files
    set up, you’re ready to start building the game’s UI.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 复制第3章的项目并打开副本以开始本章的工作。像往常一样，你需要的艺术资源在样本下载中。设置好这些文件后，你就可以开始构建游戏的UI了。
- en: NOTE All the examples in this chapter are built on top of the FPS game created
    in chapter 3\. But the content of this chapter is largely independent of that
    base project; we’ll just add a graphical interface on top of the existing game
    demo. Although I’ve suggested that you download the chapter 3 project, you’re
    free to use whatever game demo you’d like.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中的所有示例都是基于第 3 章创建的 FPS 游戏。但本章的内容在很大程度上独立于那个基础项目；我们只是在现有的游戏演示上添加了一个图形界面。尽管我建议你下载第
    3 章的项目，但你完全可以使用你喜欢的任何游戏演示。
- en: 7.1 Before you start writing code . . .
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 在你开始编写代码之前...
- en: To start building the HUD, you first need to understand how the UI system works.
    Unity provides multiple approaches to building a game’s HUD, so we need to go
    over how those systems work. Then we can briefly plan the UI and prepare the art
    assets that we’ll need.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建 HUD，你首先需要了解 UI 系统的工作方式。Unity 提供了多种构建游戏 HUD 的方法，因此我们需要了解这些系统是如何工作的。然后我们可以简要规划
    UI 并准备我们需要的艺术资源。
- en: 7.1.1 Immediate mode GUI or advanced 2D interface?
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 立即模式 GUI 还是高级 2D 界面？
- en: 'From its first version, Unity has come with an immediate mode GUI system. The
    immediate mode system makes it easy to put a clickable button on the screen. Listing
    7.1 shows the code to do that: simply attach this script to any object in the
    scene.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从其第一个版本开始，Unity 就附带了一个立即模式 GUI 系统。立即模式系统使得在屏幕上放置可点击的按钮变得容易。列表 7.1 展示了执行此操作的代码：只需将此脚本附加到场景中的任何对象上。
- en: DEFINITION *Immediate mode* refers to explicitly issuing draw commands every
    frame—instead of defining all the visuals once, and then for every frame the system
    knows what to draw without you having to tell it again. The latter approach is
    called *retained mode*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *立即模式* 指的是每帧明确发出绘制命令——而不是一次性定义所有视觉元素，然后对于每一帧，系统知道要绘制什么，而不需要你再次告诉它。后一种方法称为
    *保留模式*。
- en: For another example of immediate mode UI, recall the target cursor displayed
    in chapter 3\. This GUI system is entirely based on code, with no work done in
    Unity’s editor.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为立即模式 UI 的另一个示例，回忆一下第 3 章中显示的目标光标。这个 GUI 系统完全基于代码，没有在 Unity 的编辑器中做任何工作。
- en: Listing 7.1 Example of a button using the immediate mode GUI
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 使用立即模式 GUI 的按钮示例
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Function called every frame after everything else renders
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每渲染完其他所有内容后每帧调用的函数
- en: '❷ Parameters: position X, pos Y, width, height, text label'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 参数：位置 X，位置 Y，宽度，高度，文本标签
- en: The core of the code in this listing is the OnGUI() method. Much like Start()
    and Update(), every MonoBehaviour automatically responds to OnGUI(). That function
    runs every frame after the 3D scene is rendered, providing a place to put GUI
    drawing commands. This code draws a button; note that the command for a button
    is executed every frame (that is, in immediate mode style). The button command
    is used in a conditional that responds when the button is clicked.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中代码的核心是 OnGUI() 方法。与 Start() 和 Update() 类似，每个 MonoBehaviour 都会自动响应 OnGUI()。该函数在
    3D 场景渲染后每帧运行，提供了一个放置 GUI 绘图命令的位置。此代码绘制了一个按钮；请注意，按钮的命令每帧执行（即在立即模式风格中）。按钮命令用于条件语句中，当按钮被点击时作出响应。
- en: Because the immediate mode GUI makes it easy to get a few buttons onscreen with
    minimal effort, we’ll sometimes use it for examples in future chapters. But default
    buttons are about the only thing easy to create with that system, so more recent
    versions of Unity now have a new interface system based on 2D graphics laid out
    in the editor. This newer interface system takes a bit more effort to set up,
    but you’ll probably want to use it in finished games because it produces more
    polished results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于立即模式 GUI 使得以最小的努力在屏幕上放置几个按钮变得容易，我们有时会在未来的章节中使用它作为示例。但默认按钮是那个系统中唯一容易创建的东西，因此
    Unity 的较新版本现在有一个基于编辑器中布局的 2D 图形的新界面系统。这个较新的界面系统需要更多的工作来设置，但你可能会希望在完成的游戏中使用它，因为它会产生更精致的结果。
- en: 'The newer UI system works in retained mode, so the graphics are laid out once
    and then drawn every frame without needing to be continually redefined. In this
    system, graphics for the UI are placed in Unity’s editor. This provides two advantages
    over the immediate mode UI: (1) you can see what the UI looks like while placing
    UI elements, and (2) this system makes it straightforward to customize the UI
    with your own images.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的 UI 系统在保留模式下工作，因此图形只布局一次，然后每帧绘制，而不需要不断重新定义。在这个系统中，UI 的图形放置在 Unity 的编辑器中。这比立即模式
    UI 提供两个优势：（1）你可以在放置 UI 元素时看到 UI 的外观，并且（2）这个系统使得使用自己的图像自定义 UI 变得简单直接。
- en: NOTE Chapter 1 mentioned that Unity has three UI systems (which are compared
    at [http://mng.bz/205X](https://shortener.manning.com/205X)) because successively
    developed systems improved on their predecessor. This book covers the second UI
    system (Unity UI, or uGUI) because it is still preferred over the incomplete third
    UI system (UI Toolkit).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第1章提到Unity有三个UI系统（这些系统在[http://mng.bz/205X](https://shortener.manning.com/205X)进行了比较），因为相继开发的系统在先前的系统基础上进行了改进。本书涵盖了第二个UI系统（Unity
    UI，或uGUI），因为它仍然比不完整的第三个UI系统（UI Toolkit）更受欢迎。
- en: To use this system, you’re going to import images and then drag objects into
    the scene. Next, let’s plan how this UI will look.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此系统，你需要导入图像并将对象拖动到场景中。接下来，让我们规划这个UI的外观。
- en: 7.1.2 Planning the layout
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 规划布局
- en: The HUD for most games comprises a few UI controls repeated over and over. Therefore,
    this project doesn’t need to be terribly complex in order for you to learn how
    to build a game’s UI. You’re going to put a score display and a Settings button
    in the corners of the screen over the main Game view (see figure 7.2). The Settings
    button will bring up a pop-up window, which will have both a text field and a
    slider.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏的HUD由一些重复的UI控制组成。因此，这个项目不需要非常复杂，你就可以学习如何构建游戏的UI。你将在屏幕角落的主游戏视图上方放置一个得分显示和一个设置按钮（见图7.2）。设置按钮将弹出一个包含文本字段和滑块的弹出窗口。
- en: '![CH07_F02_Hocking3](../Images/CH07_F02_Hocking3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F02_Hocking3](../Images/CH07_F02_Hocking3.png)'
- en: Figure 7.2 Planned GUI
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 计划的GUI
- en: For this example, those input controls will be used for setting the player’s
    name and movement speed, but ultimately those UI elements could control any settings
    relevant to your game. Well, that plan is pretty simple! The next step is bringing
    in the images that are needed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这些输入控制将用于设置玩家的名字和移动速度，但最终这些UI元素可以控制与你的游戏相关的任何设置。嗯，这个计划相当简单！下一步是引入所需的图像。
- en: 7.1.3 Importing UI images
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 导入UI图像
- en: 'This UI requires some images to display for things like buttons. The UI is
    built from 2D images like the graphics in chapter 5, so you’ll follow the same
    two steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI需要一些图像来显示按钮等元素。UI是由第5章中的图形等2D图像构建的，所以你将遵循相同的两个步骤：
- en: Import images (if needed, set them to Sprite).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入图像（如果需要，设置为精灵）。
- en: Drag the sprites into the scene.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵拖动到场景中。
- en: To accomplish these steps, first drag the images into Project view to import
    them. Then, in the Inspector, change their Texture Type setting to Sprite (2D
    and UI).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这些步骤，首先将图像拖动到项目视图中以导入它们。然后，在检查器中，将它们的纹理类型设置更改为精灵（2D和UI）。
- en: WARNING The Texture Type setting defaults to Texture in 3D projects and to Sprite
    in 2D projects. If you want sprites in a 3D project, you need to manually adjust
    this setting.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在3D项目中，纹理类型设置默认为纹理，在2D项目中默认为精灵。如果你想在3D项目中使用精灵，你需要手动调整此设置。
- en: Get all the necessary images from the sample download (see figure 7.3) and then
    import them into your project. Make sure all the imported assets are set to Sprite;
    you’ll probably need to adjust Texture Type in the settings displayed after importing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从样本下载中获取所有必要的图像（见图7.3），然后将它们导入到你的项目中。确保所有导入的资产都设置为精灵；你可能需要调整导入后显示的设置中的纹理类型。
- en: '![CH07_F03_Hocking3](../Images/CH07_F03_Hocking3.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F03_Hocking3](../Images/CH07_F03_Hocking3.png)'
- en: Figure 7.3 Images that are needed for this chapter’s project
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 本章项目所需的图像
- en: These sprites comprise the buttons, score display, and pop-up that you’ll create.
    Now that the images are imported, let’s put these graphics onto the screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些精灵包括你将创建的按钮、得分显示和弹出窗口。现在图像已经导入，让我们将这些图形放到屏幕上。
- en: 7.2 Setting up the GUI display
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 设置GUI显示
- en: The art assets are the same kind of 2D sprites we used in chapter 5, but we’ll
    use those assets in the scene a bit differently. Unity provides special tools
    to make the images a HUD that’s displayed over the 3D scene, rather than displaying
    the images as part of the scene. Some special tricks are used when positioning
    UI elements, because of the needs of a display that may change on different screens.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术资产与我们第5章使用的2D精灵相同，但我们将以不同的方式使用这些资产。Unity提供了特殊工具，可以将图像作为显示在3D场景上而不是场景一部分的HUD。在定位UI元素时使用了一些特殊技巧，因为可能需要在不同的屏幕上显示的显示需求。
- en: 7.2.1 Creating a canvas for the interface
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 为界面创建画布
- en: One of the most fundamental and nonobvious aspects of how the UI system works
    is that all images must be attached to a canvas object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: UI系统工作方式的最基本且不明显的一个方面是，所有图像都必须附加到画布对象。
- en: TIP Canvas is a special kind of object that Unity renders as the UI for a game.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：Canvas是Unity渲染游戏UI的一种特殊对象。
- en: Open the GameObject menu to see the objects you can create; in the UI category,
    choose Canvas. A canvas object will appear in the scene (it may be clearer to
    rename the object HUD Canvas). This object represents the entire extent of the
    screen, and it’s huge compared to the 3D scene because it scales one pixel of
    the screen to one unit in the scene.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开游戏对象菜单，查看你可以创建的对象；在UI类别中，选择画布。画布对象将出现在场景中（可能将对象重命名为HUD画布会更清晰）。此对象代表整个屏幕范围，与3D场景相比非常大，因为它将屏幕上的一个像素缩放到场景中的一个单位。
- en: WARNING When you create a canvas object, an EventSystem object is automatically
    created too. That object is required for UI interaction, but you can otherwise
    ignore it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：当你创建画布对象时，也会自动创建一个事件系统对象。该对象用于UI交互，但你可以忽略它。
- en: Switch to 2D view mode (refer to figure 7.4) and double-click the canvas in
    the Hierarchy to zoom out and view it fully. The 2D view mode is automatic when
    the entire project is 2D, but in a 3D project, this toggle must be clicked to
    switch between the UI and the main scene. To return to viewing the 3D scene, toggle
    off the 2D view mode and then double-click the building to zoom in to that object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到2D视图模式（参见图7.4），然后在层次结构中双击画布以缩放并完全查看它。当整个项目是2D时，2D视图模式是自动的，但在3D项目中，必须单击此切换按钮来在UI和主场景之间切换。要返回查看3D场景，关闭2D视图模式，然后双击建筑以缩放到该对象。
- en: '![CH07_F04_Hocking3](../Images/CH07_F04_Hocking3.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F04_Hocking3](../Images/CH07_F04_Hocking3.png)'
- en: Figure 7.4 A blank canvas object in the Scene view
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 场景视图中一个空白的画布对象
- en: 'TIP Don’t forget this tip from chapter 4: across the top of the Scene view’s
    pane are buttons that control what’s visible, so look there for the Effects button
    to turn off the skybox.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：不要忘记第4章中的这个提示：场景视图面板顶部有按钮可以控制可见内容，所以请查看那里以找到效果按钮来关闭天空盒。
- en: 'The canvas has settings that you can adjust. The first is the Render Mode option.
    Leave this at the default setting (Screen Space—Overlay), but you should know
    what the three possible settings mean:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 画布有一些你可以调整的设置。第一个是渲染模式选项。将其保留在默认设置（屏幕空间—叠加），但你应该知道三个可能设置的含义：
- en: '*Screen Space —Overlay* —Renders the UI as 2D graphics on top of the camera
    view. (This is the default setting.)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*屏幕空间 —叠加* —将UI作为2D图形渲染在相机视图之上。（这是默认设置。）'
- en: '*Screen Space —Camera* —Also renders the UI on top of the camera view, but
    UI elements can rotate for perspective effects.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*屏幕空间 —相机* —也在相机视图中渲染UI，但UI元素可以旋转以产生透视效果。'
- en: '*World Space* —Places the canvas object within the scene, as if the UI were
    part of the 3D scene.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*世界空间* —将画布对象放置在场景中，就像UI是3D场景的一部分。'
- en: The two modes besides the initial default can sometimes be useful for specific
    effects but are slightly more complicated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始默认设置之外，其他两种模式有时可能对特定效果有用，但稍微复杂一些。
- en: The other important setting is Pixel Perfect. This setting causes the rendering
    to subtly adjust the position of images so that they’re always perfectly crisp
    and sharp (as opposed to blurring them when positioned between pixels). Go ahead
    and select that check box. Now the HUD canvas is set up, but it’s still blank
    and needs sprites.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的设置是像素完美。此设置会导致渲染微妙地调整图像的位置，使它们始终完美清晰（与在像素之间定位时模糊它们相反）。请选择该复选框。现在HUD画布已设置好，但仍然是空的，需要精灵。
- en: 7.2.2 Buttons, images, and text labels
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 按钮、图像和文本标签
- en: The canvas object defines an area to display as the UI, but it still requires
    sprites to display. Referring to the UI mock-up in figure 7.2, you’ll see an image
    of the block/enemy in the top-left corner, text displaying the score next to that,
    and a gear-shaped button in the top-right corner. Accordingly, the UI section
    of the GameObject menu contains options to create an image, text, or button. Create
    one of each, but using the TextMeshPro version when applicable. That is, choose
    GameObject > UI > Image, then Text - TextMeshPro, then Button - TextMeshPro.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 画布对象定义了一个用于显示UI的区域，但它仍然需要精灵来显示。参考图7.2中的UI原型，你会看到左上角有一个方块/敌人的图像，旁边显示分数的文字，右上角有一个齿轮形状的按钮。因此，GameObject菜单的UI部分包含创建图像、文本或按钮的选项。创建每种类型的一个，但在适用的情况下使用TextMeshPro版本。也就是说，选择GameObject
    > UI > Image，然后Text - TextMeshPro，然后Button - TextMeshPro。
- en: NOTE Just as in chapter 5, you need to have the TextMeshPro package installed,
    so go to Window > Package Manager if no TextMeshPro versions are displayed in
    the menu of UI objects. The TMP Importer window will automatically appear when
    you create a TextMeshPro object for the first time. Click the Import TMP Essentials
    button.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：正如第5章所述，你需要安装TextMeshPro包，所以如果UI对象的菜单中没有显示TextMeshPro版本，请转到Window > Package
    Manager。当你第一次创建TextMeshPro对象时，TMP Importer窗口将自动出现。点击导入TMP Essentials按钮。
- en: To display correctly, UI elements need to be a child of the canvas object. Unity
    does this automatically, but remember that, as usual, you can drag objects around
    the Hierarchy view to make parent-child linkages (see figure 7.5).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确显示，UI元素需要是画布对象的子对象。Unity会自动完成这项工作，但请记住，就像通常一样，你可以拖动对象在Hierarchy视图中进行父子链接（见图7.5）。
- en: '![CH07_F05_Hocking3](../Images/CH07_F05_Hocking3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F05_Hocking3](../Images/CH07_F05_Hocking3.png)'
- en: Figure 7.5 Canvas with an image linked in the Hierarchy view
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 Hierarchy视图中链接了图像的画布
- en: Objects within the canvas can be parented together for positioning purposes,
    just like any other objects in the scene. For example, you should drag the text
    object onto the image so that the text will move with the image. The default button
    object also has a text object as its child, but this project’s button doesn’t
    need a text label, so delete the default text object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 画布内的对象可以为了定位目的相互关联，就像场景中的任何其他对象一样。例如，你应该将文本对象拖到图像上，以便文本随图像移动。默认按钮对象也有一个文本对象作为其子对象，但这个项目的按钮不需要文本标签，所以删除默认的文本对象。
- en: Roughly position the UI elements into their corners. In the next section, we’ll
    make the positions exact; for now, just drag the objects until they’re pretty
    much in position. Click and drag the image object to the top left of the canvas;
    the button goes in the top right.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 大致将UI元素放置到它们的角落。在下一节中，我们将使位置精确；现在，只需拖动对象直到它们大致到位。点击并拖动图像对象到画布的左上角；按钮放在右上角。
- en: 'TIP As noted in chapter 5, you use the Rect tool in 2D mode. I described it
    as a single manipulation tool that encompasses all three transforms: Move, Rotate,
    and Scale. These operations have to be separate tools in 3D but are combined in
    2D because that’s one less dimension to worry about. In 2D mode, this tool is
    selected automatically, or you can click the button near the top-left corner of
    Unity.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：正如第5章所述，你在2D模式下使用矩形工具。我将其描述为一种包含所有三个变换（移动、旋转和缩放）的单个操作工具。这些操作在3D中必须是单独的工具，但在2D中它们是组合的，因为这样少了一个要考虑的维度。在2D模式下，此工具会自动选择，或者你可以点击Unity左上角附近的按钮。
- en: At the moment, the images are blank. If you select a UI object and look at the
    Inspector, you should see a Source Image slot near the top of the image component.
    As shown in figure 7.6, drag over sprites (remember, not textures!) from the Project
    view to assign images to the objects. Assign the enemy sprite to the image object,
    and the gear sprite to the button object (click Set Native Size after assigning
    sprites to properly size the image object).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，图像是空的。如果你选择一个UI对象并查看检查器，你应该在图像组件的顶部附近看到一个源图像槽。如图7.6所示，从项目视图中拖动精灵（记住，不是纹理！）以将图像分配给对象。将敌人精灵分配给图像对象，将齿轮精灵分配给按钮对象（在分配精灵后点击设置原生大小以正确调整图像对象的大小）。
- en: '![CH07_F06_Hocking3](../Images/CH07_F06_Hocking3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F06_Hocking3](../Images/CH07_F06_Hocking3.png)'
- en: Figure 7.6 Assigning 2D sprites to the Image property of UI elements.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 将2D精灵分配给UI元素的Image属性。
- en: That took care of the appearance of both the enemy image and the gear button.
    As for the text object, the Inspector has a bunch of settings (see figure 7.7).
    First, type a single number in the large Text Input box; this text will be overwritten
    later, but it’s useful because it looks like a score display within the editor.
    The text is the wrong size, so change the Font Size to 24. Also click the first
    Font Style button for Bold, and then change Vertex Color to black. You also want
    to set this label to left horizontal alignment and middle vertical alignment.
    For now, the remaining settings can be left at their default values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了敌图像和齿轮按钮的外观。至于文本对象，检查器有一系列设置（见图7.7）。首先，在大的文本输入框中输入一个单独的数字；此文本稍后将会被覆盖，但它很有用，因为它看起来像编辑器内的分数显示。文本大小不正确，所以将字体大小更改为24。然后点击第一个字体样式按钮以加粗，并将顶点颜色更改为黑色。您还希望将此标签设置为左对齐和中间垂直对齐。目前，其余设置可以保留为默认值。
- en: '![CH07_F07_Hocking3](../Images/CH07_F07_Hocking3.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F07_Hocking3](../Images/CH07_F07_Hocking3.png)'
- en: Figure 7.7 Settings for a UI text object
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 UI文本对象的设置
- en: NOTE The most commonly adjusted property that we didn’t just touch on is the
    font. To use a TrueType font with TextMeshPro, first import the font into Unity
    and then choose Window > TextMeshPro > Font Asset Creator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们尚未涉及的最常见调整属性是字体。要使用TextMeshPro的TrueType字体，首先将字体导入Unity，然后选择Window > TextMeshPro
    > Font Asset Creator。
- en: Now that sprites have been assigned to the UI images and the score text is set
    up, you can click Play to see the HUD on top of the 3D game. The canvas displayed
    in Unity’s editor shows the bounds of the screen, and UI elements are drawn onto
    the screen in the positions shown in figure 7.8.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经将精灵分配给UI图像，并且设置了分数文本，您可以点击播放来查看3D游戏顶部的HUD。Unity编辑器中显示的画布显示了屏幕的边界，UI元素在图7.8所示的位置绘制到屏幕上。
- en: '![CH07_F08_Hocking3](../Images/CH07_F08_Hocking3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F08_Hocking3](../Images/CH07_F08_Hocking3.png)'
- en: Figure 7.8 The GUI as seen in the editor (left) and when playing the game (right)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 在编辑器中看到的GUI（左侧）和游戏播放时的GUI（右侧）
- en: 'Great, you made a HUD with 2D images displayed over the 3D game! One more complex
    visual setting remains: positioning UI elements relative to the canvas.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，您已经创建了一个带有2D图像覆盖3D游戏的HUD！还有一个更复杂的视觉设置需要处理：相对于画布定位UI元素。
- en: 7.2.3 Controlling the position of UI elements
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 控制UI元素的位置
- en: All UI objects have an anchor, displayed in the editor as an X shape (see figure
    7.9). An *anchor* is a flexible way of positioning objects on the UI.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有UI对象都有一个锚点，在编辑器中以X形状显示（见图7.9）。锚点是一种灵活的方式来定位UI上的对象。
- en: '![CH07_F09_Hocking3](../Images/CH07_F09_Hocking3.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F09_Hocking3](../Images/CH07_F09_Hocking3.png)'
- en: Figure 7.9 The anchor point of an image object
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 图像对象的锚点
- en: DEFINITION The *anchor* of an object is the point where an object attaches to
    the canvas or screen. That object’s position is measured relative to the anchor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：对象的**锚点**是对象连接到画布或屏幕的点。该对象的位置是相对于锚点测量的。
- en: 'Positions are values like “50 pixels on the x-axis.” But that leaves the question:
    50 pixels from what? This is where anchors come in. The purpose of an anchor is
    to keep the object in place relative to the anchor point, whereas the anchor moves
    around relative to the canvas. The anchor is defined as something like “center
    of the screen,” and then the anchor will stay centered while the screen changes
    size. Similarly, setting the anchor to the right-hand side of the screen will
    keep the object rooted to the right-hand side even if the screen changes size
    (for example, if the game is played on different monitors).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 位置是像“x轴上的50像素”这样的值。但这留下了一个问题：50像素是从哪里开始的？这就是锚点发挥作用的地方。锚点的目的是保持对象相对于锚点的位置不变，而锚点则相对于画布移动。锚点被定义为类似于“屏幕中心”的东西，然后锚点将保持居中，即使屏幕大小发生变化。同样，将锚点设置为屏幕的右侧将保持对象相对于右侧的位置不变，即使屏幕大小发生变化（例如，如果游戏在不同的显示器上播放）。
- en: The easiest way to understand what I’m talking about is to see it in action.
    Select the image object and look over at the Inspector. Anchor settings will appear
    right below the transform component (see figure 7.10). By default, UI elements
    have their anchor set to Center, but you want to set the anchor to Top Left for
    this image; figure 7.10 shows how to adjust that by using the Anchor Presets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我所谈论的内容最简单的方法是看到它在实际操作中的表现。选择图像对象，然后查看检查器。锚点设置将直接出现在变换组件下方（见图7.10）。默认情况下，UI元素锚点设置为居中，但您需要将此图像的锚点设置为左上角；图7.10展示了如何通过使用锚点预设进行调整。
- en: '![CH07_F10_Hocking3](../Images/CH07_F10_Hocking3.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F10_Hocking3](../Images/CH07_F10_Hocking3.png)'
- en: Figure 7.10 How to adjust anchor settings
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 如何调整锚点设置
- en: 'Change the gear button’s anchor as well. Set it to Top Right for this object;
    click the top-right Anchor Preset. Now try scaling the window left and right:
    click and drag on the side of the game’s view. Thanks to the anchors, the UI objects
    will stay in their corners while the canvas changes size. As figure 7.11 shows,
    these UI elements are now rooted in place while the screen moves.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 也要改变齿轮按钮的锚点。将此对象设置为右上角；点击右上角的锚点预设。现在尝试左右缩放窗口：点击并拖动游戏的视图边缘。多亏了锚点，UI对象会保持在它们的角落，而画布改变大小。如图7.11所示，这些UI元素现在固定在位置，而屏幕移动。
- en: '![CH07_F11_Hocking3](../Images/CH07_F11_Hocking3.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F11_Hocking3](../Images/CH07_F11_Hocking3.png)'
- en: Figure 7.11 Anchors stay in place while the screen changes size.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 当屏幕改变大小时，锚点保持在原位。
- en: TIP Anchor points can adjust scale as well as position. We’re not going to explore
    that functionality in this chapter, but each corner of the image can be rooted
    to a different corner of the screen. In figure 7.11, the images didn’t change
    size, but we could adjust the anchors so that when the screen changes size, the
    image stretches with it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 锚点可以调整缩放和位置。我们在这章中不会探讨这个功能，但图像的每个角落都可以锚定到屏幕的不同角落。在图7.11中，图像的大小没有改变，但我们可以调整锚点，使得当屏幕改变大小时，图像也会随之拉伸。
- en: All of the visual setup is done, so it’s time to program interactivity.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的视觉设置都已经完成，现在是时候编程交互性了。
- en: 7.3 Programming interactivity in the UI
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 在UI中编程交互性
- en: Before you can interact with the UI, you need to have a mouse cursor. As you
    may recall, we adjusted Cursor settings in the Start() method of the RayShooter
    code. Those settings lock and hide the mouse cursor, a behavior that works for
    the controls in an FPS game but that interferes with using the UI. Remove those
    lines from RayShooter so that you can click the HUD.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以与UI交互之前，你需要有一个鼠标光标。如你所回忆，我们在RayShooter代码的Start()方法中调整了光标设置。这些设置锁定并隐藏鼠标光标，这对于FPS游戏中的控制是有效的，但会干扰使用UI。从RayShooter中删除这些行，以便你可以点击HUD。
- en: While you have RayShooter open, you could also make sure not to shoot while
    interacting with the GUI. Here is the code for that.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开RayShooter时，你也可以确保在交互GUI时不要射击。这是相应的代码。
- en: Listing 7.2 Adding a GUI check to the code in RayShooter
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 在RayShooter代码中添加GUI检查
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Include UI system code frameworks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含UI系统代码框架。
- en: ❷ Italicized code was already in script; shown for reference.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 斜体代码已经在脚本中；此处显示仅供参考。
- en: ❸ Check that GUI isn’t being used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查是否使用了GUI。
- en: Now you can play the game and click the button, although it doesn’t do anything
    yet. You can watch the tinting of the button change as you mouse over it and click.
    This mouseover and click behavior is a default tint that can be changed for each
    button, but the default looks fine for now. You could speed up the default fading
    behavior; Fade Duration is a setting in the button component, so try decreasing
    that to 0.01 to see how the button changes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以玩游戏并点击按钮，尽管它目前还没有任何功能。你可以观察按钮在鼠标悬停和点击时的着色变化。这种鼠标悬停和点击行为是每个按钮的默认着色，可以更改，但默认设置目前看起来很好。你可以加快默认的淡入淡出行为；淡入淡出持续时间是按钮组件中的一个设置，所以尝试将其减小到0.01，看看按钮如何变化。
- en: 'TIP Sometimes the default interaction controls of the UI also interfere with
    the game. Remember the EventSystem object that was created automatically along
    with the canvas? That object controls the UI interaction controls, and by default
    it uses the arrow keys to interact with the GUI. You may need to turn off the
    arrow keys to avoid interacting with the GUI by accident: to do this, deselect
    the Send Navigation Event check box in the settings for EventSystem.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 有时候，UI的默认交互控制也会干扰游戏。还记得与画布一起自动创建的事件系统对象吗？该对象控制UI交互控制，默认情况下它使用箭头键与GUI交互。你可能需要关闭箭头键以避免意外与GUI交互：为此，在EventSystem的设置中取消选中“发送导航事件”复选框。
- en: But nothing else happens when you click the button because you haven’t yet linked
    it up to any code. Let’s take care of that next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但点击按钮时没有发生其他任何事情，因为你还没有将其链接到任何代码。让我们在下一部分处理这个问题。
- en: 7.3.1 Programming an invisible UIController
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 编程不可见的UIController
- en: 'In general, UI interaction is programmed with a standard series of steps that’s
    the same for all UI elements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，UI交互是通过一系列标准步骤编程的，这些步骤对所有UI元素都是相同的：
- en: Create a UI object in the scene (the button created in the previous section).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个UI对象（上一节中创建的按钮）。
- en: Write a script to call when the UI is operated.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个在操作UI时调用的脚本。
- en: Attach that script to an object in the scene.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该脚本附加到场景中的对象。
- en: Link UI elements (such as buttons) to the object with that script.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UI元素（如按钮）链接到具有该脚本的对象。
- en: To follow these steps, first we need to create a controller object to link to
    the button. Create a script called UIController and drag that script onto the
    controller object in the scene.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这些步骤，首先我们需要创建一个控制器对象以将其链接到按钮。创建一个名为UIController的脚本，并将其拖放到场景中的控制器对象上。
- en: Listing 7.3 UIController script used to program buttons
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3用于编程按钮的UIController脚本
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Import the TextMeshPro code framework.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入TextMeshPro代码框架。
- en: ❷ Reference the Text object in the scene to set the text property.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在场景中引用文本对象以设置文本属性。
- en: ❸ Method called by Settings button
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 由设置按钮调用的方法
- en: 'TIP You might be wondering why we need separate objects for SceneController
    and UIController. Indeed, this scene is so simple that you could have one controller
    handling both the 3D scene and the UI. As the game gets more complex, though,
    it’ll become increasingly useful for the 3D scene and the UI to be separate modules,
    communicating indirectly. This notion extends well beyond games to software in
    general: software engineers refer to this principle as *separation of concerns*.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 你可能想知道为什么我们需要为SceneController和UIController使用单独的对象。确实，这个场景非常简单，你可以有一个控制器同时处理3D场景和UI。然而，随着游戏的复杂化，将3D场景和UI作为独立的模块，间接通信将变得越来越有用。这一概念不仅适用于游戏，也适用于软件的通用性：软件工程师将这一原则称为*关注点分离*。
- en: Now drag objects to component slots to wire them up. Drag the Score label (the
    text object we created before) to the UIController text slot. The code in UIController
    sets the text displayed on that label. Currently, the code displays a timer to
    test the text display; that will later be changed to the score.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将对象拖到组件槽位以连接它们。将得分标签（我们之前创建的文本对象）拖到UIController文本槽位。UIController中的代码设置了该标签上显示的文本。目前，该代码显示一个计时器以测试文本显示；这将被后来更改为得分。
- en: Next, add an OnClick entry to the button to drag the controller object onto.
    Select the button to see its settings in the Inspector. Toward the bottom, you
    should see an On Click panel; initially that panel is empty, but you can click
    the + button to add an entry (as you can see in figure 7.12). Each entry defines
    a single function that gets called when that button is clicked; the listing has
    both a slot for an object and a menu for the function to call. Drag the controller
    object to the object slot, and then look for UIController in the menu; select
    OnOpenSettings() in that section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向按钮添加一个OnClick条目以拖动控制器对象。选择按钮以在检查器中查看其设置。在底部附近，你应该看到一个OnClick面板；最初该面板是空的，但你可以点击+按钮添加一个条目（如图7.12所示）。每个条目定义了一个当按钮被点击时调用的单个函数；列表中有一个对象槽位和一个用于调用函数的菜单。将控制器对象拖到对象槽位，然后在菜单中查找UIController；在该部分选择OnOpenSettings()。
- en: '![CH07_F12_Hocking3](../Images/CH07_F12_Hocking3.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F12_Hocking3](../Images/CH07_F12_Hocking3.png)'
- en: Figure 7.12 The On Click panel toward the bottom of the button settings
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12按钮设置底部的OnClick面板
- en: Responding to other mouse events
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 响应其他鼠标事件
- en: OnClick is the only event that the button component exposes, but UI elements
    can respond to multiple interactions. To go beyond the default interactions, use
    an EventTrigger component.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OnClick是按钮组件暴露的唯一事件，但UI元素可以响应多个交互。要超越默认交互，请使用EventTrigger组件。
- en: 'Add a new component to the button object and look for the Event section of
    the component’s menu. Select EventTrigger from that menu. Although the button’s
    OnClick responded to only a full click (the mouse button being pressed down and
    then released), let’s try responding to the mouse button being pressed but not
    released. Perform the same steps as for OnClick, only responding to a different
    event. First add another method to UIController:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 向按钮对象添加一个新组件，并查找组件菜单的事件部分。从菜单中选择EventTrigger。尽管按钮的OnClick只响应完整的点击（鼠标按钮按下然后释放），但让我们尝试响应鼠标按钮按下但不释放的情况。执行与OnClick相同的步骤，但响应不同的事件。首先向UIController添加另一个方法：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now click Add New Event Type to add a new type to the EventTrigger component.
    Choose Pointer Down for the event. This will create an empty panel for that event,
    just like OnClick had. Click the + button to add an event listing, drag the controller
    object to this entry, and select OnPointerDown() in the menu. There you go!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击“添加新事件类型”以向事件触发器组件添加一个新类型。选择“指针按下”作为事件。这将为此事件创建一个空面板，就像“OnClick”一样。点击“+”按钮添加事件列表，将控制器对象拖到这个条目中，并在菜单中选择“OnPointerDown()”。就这样！
- en: Play the game and click the button to output debug messages in the console.
    Again, the code is currently random output to test the button’s functionality.
    We want to open a settings pop-up, so let’s create that pop-up window next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并点击按钮，在控制台输出调试信息。再次强调，当前代码是随机输出以测试按钮的功能。我们想要打开一个设置弹窗，所以接下来让我们创建那个弹窗窗口。
- en: 7.3.2 Creating a pop-up window
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 创建弹窗窗口
- en: The UI has a button to open a pop-up window, but there’s no pop-up yet. That
    will be a new image object, along with several controls (such as buttons and sliders)
    attached to that object. The first step is to create a new image, so choose GameObject
    > UI > Image. Just as before, the new image has a slot in the Inspector called
    Source Image. Drag a sprite to that slot to set this image. This time, use the
    sprite called popup.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: UI有一个按钮可以打开弹窗窗口，但目前还没有弹窗。那将是一个新的图像对象，以及一些附加到该对象上的控件（如按钮和滑块）。第一步是创建一个新的图像，所以选择“游戏对象”>“UI”>“图像”。就像之前一样，新的图像在检查器中有一个名为“源图像”的槽位。将精灵拖到该槽位以设置此图像。这次，使用名为“popup”的精灵。
- en: Ordinarily, the sprite is stretched over the entire image object; this was how
    the score and gear images worked, and you clicked the Set Native Size button to
    resize the object to the size of the image. This behavior is the default for image
    objects, but the pop-up will use a sliced image instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，精灵会拉伸到整个图像对象上；这是分数和齿轮图像的工作方式，你点击“设置原生大小”按钮来调整对象的大小以匹配图像的大小。这是图像对象的默认行为，但弹窗将使用分割图像。
- en: DEFINITION A *sliced image* is split into nine sections that scale differently
    from one another. By scaling the edges of the image separately from the middle,
    you ensure that the image can scale to any size you want, and it maintains its
    sharp, crisp edges. In other development tools, these kinds of images often have
    “9” somewhere in the name (such as 9-slice, 9-patch, scale-9) to indicate the
    nine sections of the image.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个*分割图像*被分割成九个部分，这些部分相对于彼此有不同的缩放比例。通过将图像的边缘与中间部分分别缩放，你可以确保图像可以缩放到任何你想要的大小，并且保持其清晰、锐利的边缘。在其他开发工具中，这类图像的名称中通常有“9”字样（如9-slice、9-patch、scale-9），以表示图像的九个部分。
- en: As you can see in figure 7.13, the image component has an Image Type setting.
    This setting defaults to Simple, which was the correct image type earlier. For
    the pop-up, though, set Image Type to Sliced. Unity will probably display an error,
    complaining that the image doesn’t have a border, so we’ll correct that next.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图7.13中看到的，图像组件有一个“图像类型”设置。此设置默认为“简单”，这是之前正确的图像类型。但对于弹窗，应将“图像类型”设置为“分割”。Unity可能会显示一个错误，抱怨图像没有边框，所以我们将稍后纠正这一点。
- en: '![CH07_F13_Hocking3](../Images/CH07_F13_Hocking3.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F13_Hocking3](../Images/CH07_F13_Hocking3.png)'
- en: Figure 7.13 Settings for the image component, including Image Type
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 图像组件的设置，包括图像类型
- en: The error happens because the popup sprite doesn’t have the nine border sections
    defined yet. To set that up, first select the popup sprite in the Project view.
    In the Inspector, you should see the Sprite Editor button (see figure 7.14); click
    that button, and the Sprite Editor window will appear.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为弹窗精灵还没有定义九个边框部分。为了设置这些部分，首先在项目视图中选择弹窗精灵。在检查器中，你应该能看到精灵编辑器按钮（见图7.14）；点击该按钮，精灵编辑器窗口将出现。
- en: WARNING As mentioned in chapter 6, the Sprite Editor window requires the 2D
    Sprite package. Creating a 2D project may automatically install that package,
    but for this project, you need to open Window > Package Manager and look for 2D
    Sprite in the list on the left side of the window. Select that package and then
    click the Install button.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 如第6章所述，精灵编辑器窗口需要2D精灵包。创建2D项目可能会自动安装该包，但针对此项目，您需要打开“窗口”>“包管理器”，并在窗口左侧的列表中查找“2D精灵”。选择该包，然后点击“安装”按钮。
- en: '![CH07_F14_Hocking3](../Images/CH07_F14_Hocking3.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F14_Hocking3](../Images/CH07_F14_Hocking3.png)'
- en: Figure 7.14 Sprite Editor button in the Inspector and a pop-up window
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 检查器中的精灵编辑器按钮和弹窗窗口
- en: In the Sprite Editor, you can see green lines that indicate how the image will
    be sliced. Initially, the image won’t have any border (all of the Border settings
    are 0). Increase the border width to 12 for all four sides, which will result
    in the border shown in figure 7.14\. Because all four sides (Left, Right, Bottom,
    and Top) have the border set to 12 pixels wide, the border lines will intersect
    into nine sections. Close the editor window and apply the changes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在精灵编辑器中，你可以看到表示图像如何切片的绿色线条。最初，图像不会有任何边框（所有边框设置均为 0）。将所有四边的边框宽度增加到 12，这将导致图 7.14
    中显示的边框。因为所有四边（左、右、下和上）的边框都设置为 12 像素宽，边框线将相交成九个部分。关闭编辑器窗口并应用更改。
- en: Now that the sprite has the nine sections defined, the sliced image will work
    correctly (and the Image component settings will show Fill Center; make sure that
    setting is on). Click and drag the blue indicators in the corner of the image
    to scale it (switch to the Rect tool described in chapter 5 if you don’t see any
    scale indicators). The border sections will maintain their size while the center
    portion scales.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在精灵已经定义了九个部分，切片图像将正常工作（并且图像组件设置将显示填充中心；确保该设置是开启的）。点击并拖动图像角落的蓝色指示器以缩放它（如果你看不到任何缩放指示器，请切换到第
    5 章中描述的矩形工具）。边框部分将保持其大小，而中心部分将缩放。
- en: Because the border sections maintain their size, a sliced image can be scaled
    to any size and still have crisp edges. This is perfect for UI elements—different
    windows may be different sizes but should still look the same. For this pop-up,
    enter a width of 250 and a height of 200 to make it look like figure 7.15 (also,
    center it on position 0, 0, 0).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于边框部分保持其大小，切片图像可以缩放到任何大小，并且仍然具有清晰的边缘。这对于 UI 元素来说非常完美——不同的窗口可能有不同的大小，但应该看起来相同。对于这个弹出窗口，输入宽度为
    250 和高度为 200，使其看起来像图 7.15（此外，将其居中对齐在位置 0, 0, 0）。
- en: '![CH07_F15_Hocking3](../Images/CH07_F15_Hocking3.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F15_Hocking3](../Images/CH07_F15_Hocking3.png)'
- en: Figure 7.15 Sliced image scaled to dimensions of the pop-up
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 将切片图像缩放到弹出窗口的尺寸
- en: TIP The way that UI images stack on top of each other is determined by their
    order in the Hierarchy view. In the Hierarchy list, drag the pop-up object above
    other UI objects (always staying attached to the canvas, of course). Now move
    the pop-up around within the Scene view; you can see how images overlap the pop-up
    window. Finally, drag the pop-up to the bottom of the canvas hierarchy so that
    it will display on top of everything else.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：UI 图像堆叠的方式由它们在层次结构视图中的顺序决定。在层次结构列表中，将弹出窗口对象拖放到其他 UI 对象之上（当然，始终附着在画布上）。现在在场景视图中移动弹出窗口；你可以看到图像如何重叠弹出窗口。最后，将弹出窗口拖放到画布层次结构的底部，以便它显示在所有其他内容之上。
- en: The pop-up object is set up now, so write some code for it. Create a script
    called SettingsPopup and drag that script onto the pop-up object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出窗口对象已设置好，因此为它编写一些代码。创建一个名为 SettingsPopup 的脚本，并将其拖放到弹出窗口对象上。
- en: Listing 7.4 SettingsPopup script for the pop-up object
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 弹出窗口对象的 SettingsPopup 脚本
- en: '[PRE4]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Turn the object on to open the window.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打开对象以打开窗口。
- en: ❷ Deactivate this object to close the window.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使此对象失效以关闭窗口。
- en: Next, open UIController to make a few adjustments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 UIController 进行一些调整。
- en: Listing 7.5 Adjusting UIController to handle the pop-up
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 调整 UIController 以处理弹出窗口
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Close the pop-up when the game starts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 游戏开始时关闭弹出窗口。
- en: ❷ Replace the debug text with the pop-up’s method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将调试文本替换为弹出窗口的方法。
- en: This code adds a slot for the pop-up object, so drag the pop-up to UIController.
    The pop-up will be closed initially when you play the game, and it’ll open when
    you click the Settings button.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码为弹出窗口对象添加了一个槽位，因此将弹出窗口拖放到 UIController。当你玩游戏时，弹出窗口将最初关闭，当你点击设置按钮时，它将打开。
- en: 'At the moment, there’s no way to close it again, so add a button to the pop-up.
    The steps are pretty much the same as for the button created earlier: choose GameObject
    > UI> Button - TextMeshPro, position the new button in the top-right corner of
    the pop-up, drag the close sprite to this UI element’s Source Image property,
    and then click Set Native Size to correctly resize the image. Unlike with the
    previous button, we want this text label, so select the text object and type Close
    in the text field, reduce Font Size to 14, and set Vertex Color to white. In the
    Hierarchy view, drag this button onto the pop-up object so that it will be a child
    of the pop-up window. And as a final touch of polish, adjust the button transition
    to a Fade Duration value of 0.01 and a darker Normal Color setting of 210, 210,
    210, 255.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，没有方法可以再次关闭它，所以给弹出窗口添加一个按钮。步骤与之前创建按钮时基本相同：选择 GameObject > UI > Button - TextMeshPro，将新按钮放置在弹出窗口的右上角，将关闭精灵拖动到这个UI元素的Source
    Image属性，然后点击Set Native Size以正确调整图像大小。与之前的按钮不同，我们想要这个文本标签，因此选择文本对象，在文本字段中输入“关闭”，将字体大小调整为14，并将顶点颜色设置为白色。在Hierarchy视图中，将此按钮拖动到弹出对象上，使其成为弹出窗口的子对象。最后，为了增加细节，调整按钮过渡效果，将淡入持续时间设置为0.01，并将正常颜色设置为210,
    210, 210, 255。
- en: To make the button close the pop-up, it needs an OnClick entry; click the +
    button on the button’s On Click panel, drag the pop-up window into the object
    slot, and choose SettingsPopup > Close() from the function list. Now play the
    game, and this button will close the pop-up window.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要使按钮关闭弹出窗口，需要添加一个OnClick条目；在按钮的OnClick面板上点击+按钮，将弹出窗口拖动到对象槽中，并从函数列表中选择SettingsPopup
    > Close()。现在开始游戏，这个按钮将关闭弹出窗口。
- en: The pop-up window has been added to the HUD. The window is currently blank,
    though, so let’s add controls to it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出窗口已添加到HUD中。不过，窗口目前是空的，所以让我们向它添加控件。
- en: 7.3.3 Setting values using sliders and input fields
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 使用滑块和输入字段设置值
- en: As with the buttons we made earlier, adding controls to the settings pop-up
    involves two main steps. You create UI elements attached to the canvas and link
    those objects to a script. The input controls we need are a text field and a slider,
    as well as a static text label to identify the slider. Choose GameObject > UI
    > InputField - TextMeshPro to create the text field, GameObject > UI > Slider
    to create the slider object, and GameObject > UI > Text - TextMeshPro to create
    the text label object (see figure 7.16).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前创建的按钮一样，向设置弹出窗口添加控件涉及两个主要步骤。您创建附加到画布的UI元素，并将这些对象链接到脚本。我们需要的是文本字段和滑块控件，以及一个静态文本标签来标识滑块。选择GameObject
    > UI > InputField - TextMeshPro创建文本字段，GameObject > UI > Slider创建滑块对象，以及GameObject
    > UI > Text - TextMeshPro创建文本标签对象（见图7.16）。
- en: '![CH07_F16_Hocking3](../Images/CH07_F16_Hocking3.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F16_Hocking3](../Images/CH07_F16_Hocking3.png)'
- en: Figure 7.16 Input controls added to the pop-up window
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 添加到弹出窗口的输入控件
- en: Make all three objects children of the pop-up by dragging them in the Hierarchy
    view and then position them as indicated in the figure, lined up in the middle
    of the pop-up. To make a label for the slider, set the text object to Speed and
    color it black. The input field is for typing in text, and the content of the
    big text box is shown before the player types something else; set this value to
    Name. You can leave the options Content Type and Line Type at their defaults;
    if desired, you can use Content Type to restrict typing to things like only letters
    or only numbers, whereas you can use Line Type to switch from a single line to
    multiline text.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Hierarchy视图中拖动并将它们放置如图所示的位置，使所有三个对象成为弹出窗口的子对象，并使它们在弹出窗口的中间对齐。为了给滑块创建标签，将文本对象设置为“Speed”，并将其颜色设置为黑色。输入字段用于输入文本，大文本框中的内容在玩家输入其他内容之前显示；将此值设置为“Name”。您可以保留“内容类型”和“行类型”选项的默认设置；如果需要，可以使用“内容类型”来限制输入为仅字母或仅数字，而可以使用“行类型”从单行文本切换到多行文本。
- en: WARNING You won’t be able to click the slider if the text label covers it. Move
    the text object above the slider in the Hierarchy, or better yet turn off the
    Raycast Target setting (expand Extra Settings as shown in figure 7.7) so that
    mouse clicks will ignore this object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：如果文本标签覆盖了滑块，您将无法点击滑块。在Hierarchy中将文本对象移到滑块上方，或者最好关闭Raycast Target设置（如图7.7所示展开额外设置），这样鼠标点击将忽略此对象。
- en: WARNING You should probably leave the Input Field at the default size for this
    example, but if you do decide to shrink it, reduce only the Width, not the Height.
    If you set the Height to less than 30, that’s too small for the text to appear.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在这个示例中，你可能应该将输入字段保留在默认大小，但如果你决定缩小它，只减小宽度，不要减小高度。如果你将高度设置为小于30，那么文本将无法显示。
- en: As for the slider itself, several settings appear toward the bottom of the component
    inspector. Min Value is set to 0 by default; leave that. Max Value defaults to
    1, but make it 2 for this example. Similarly, both Value and Whole Numbers can
    be left at their defaults; Value controls the starting value of the slider, and
    Whole Numbers constrains it to 0, 1, 2 rather than decimal values (a constraint
    we don’t want).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 至于滑块本身，在组件检查器的底部出现了一些设置。默认情况下，最小值设置为0；保留它。默认情况下，最大值设置为1，但在这个示例中将其设置为2。同样，值和整数都可以保留在默认值；值控制滑块的起始值，整数将其限制为0、1、2而不是小数值（我们不希望有这种限制）。
- en: And that wraps up all the objects. Now you need to write the code that the objects
    are linked to; add the methods shown in the following listing to SettingsPopup.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象都处理完毕。现在你需要编写与对象链接的代码；将以下列表中的方法添加到SettingsPopup。
- en: Listing 7.6 SettingsPopup methods for the pop-up’s input controls
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6弹出窗口的输入控件设置方法
- en: '[PRE6]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Triggers when the user types in the input field
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当用户在输入字段中输入时触发
- en: ❷ Triggers when the user adjusts the slider
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当用户调整滑块时触发
- en: ❸ Constructs the message using string interpolation
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用字符串插值构建消息
- en: Great! We have methods for the controls to use. Now select the input object,
    and at the bottom of the settings you’ll see an On End Edit panel; events listed
    here are triggered when the user finishes typing. Add an entry to this panel,
    drag the pop-up to the object slot, and choose SettingsPopup.OnSubmitName() in
    the function list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们有了控件使用的方法。现在选择输入对象，在设置的最下面你会看到一个On End Edit面板；这里列出的事件是在用户完成输入时触发的。向这个面板添加一个条目，将弹出窗口拖到对象槽中，并在函数列表中选择SettingsPopup.OnSubmitName()。
- en: WARNING Be sure to select the function in the End Edit panel’s top section,
    Dynamic String, and not the bottom section, Static Parameters. The OnSubmitName()
    function appears in both sections, but selecting it under Static Parameters will
    send only a single string defined ahead of time; *dynamic string* refers to whatever
    value is typed in the input field.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：务必在End Edit面板的上部选择函数，动态字符串，而不是下部，静态参数。OnSubmitName()函数出现在两个部分中，但在静态参数下选择它将只发送之前定义的单个字符串；*动态字符串*指的是在输入字段中输入的任何值。
- en: 'Follow these same steps for the slider: look for the event panel toward the
    end of the component settings (in this case, the panel is OnValueChanged), click
    + to add an entry, drag in the settings pop-up, and choose SettingsPopup.OnSpeedValue()
    in the list of dynamic value functions.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于滑块，遵循相同的步骤：在组件设置的最后部分（在这种情况下，面板是OnValueChanged）查找事件面板，点击+添加一个条目，将设置弹出窗口拖入，并在动态值函数列表中选择SettingsPopup.OnSpeedValue()。
- en: Now both of the input controls are connected to code in the pop-up’s script.
    Play the game, and watch the console while you move the slider or press Enter
    after typing input.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两个输入控件都已连接到弹出窗口脚本中的代码。玩游戏，当你移动滑块或输入后按Enter键时，观察控制台。
- en: Saving settings between plays by using PlayerPrefs
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用PlayerPrefs在游戏之间保存设置
- en: A few methods are available for saving persistent data in Unity, and one of
    the simplest is called PlayerPrefs. Unity provides an abstracted way (that is,
    you don’t worry about the details) to save small amounts of information that work
    on all platforms (with their differing filesystems). PlayerPrefs isn’t too useful
    for large amounts of data (in future chapters, we’ll use other methods to save
    the game’s progress), but it’s perfect for saving settings.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中可用于保存持久数据的几种方法，其中最简单的一种叫做PlayerPrefs。Unity提供了一种抽象的方式（也就是说，你不必担心细节），可以保存少量信息，这些信息在所有平台上（具有不同的文件系统）都有效。PlayerPrefs对于大量数据来说并不太有用（在未来的章节中，我们将使用其他方法来保存游戏进度），但它非常适合保存设置。
- en: PlayerPrefs provides simple commands to get and set named values (it works a
    lot like a hash table or dictionary). For example, you can save the speed setting
    by adding the line PlayerPrefs.SetFloat("speed", speed); inside the OnSpeedValue()
    method of the SettingsPopup script. That method will save the float in a value
    called speed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerPrefs 提供了简单的命令来获取和设置命名值（它的工作方式类似于哈希表或字典）。例如，您可以通过在 SettingsPopup 脚本的 OnSpeedValue()
    方法中添加行 PlayerPrefs.SetFloat("speed", speed); 来保存速度设置。该方法将浮点值保存在名为 speed 的值中。
- en: 'Similarly, you’ll want to initialize the slider to the saved value. Add the
    following code to SettingsPopup:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可能希望将滑块初始化为保存的值。将以下代码添加到 SettingsPopup：
- en: '[PRE7]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Import the UI code framework.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 UI 代码框架。
- en: Note that the get command has both the value to get as well as a default value
    in case speed wasn’t previously saved.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，获取命令既有要获取的值，也有默认值，以防速度之前未保存。
- en: Although the controls generate debug output, they still don’t affect the game.
    Making the HUD affect the game (and vice versa) is the topic of the final section
    of this chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管控制生成调试输出，但它们仍然不影响游戏。使 HUD 影响游戏（反之亦然）是本章最后部分的主题。
- en: 7.4 Updating the game by responding to events
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 通过响应事件更新游戏
- en: Up to now, the HUD and main game have been ignoring each other, but they ought
    to be communicating back and forth. That could be accomplished via script references,
    as you’ve done for other sorts of inter-object communication, but that approach
    would have major downsides. In particular, doing so would tightly couple the scene
    and the HUD; you want to keep them fairly independent of each other so that you
    can freely edit the game without worrying that you’ve broken the HUD.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，HUD 和主游戏一直在相互忽视，但它们应该相互通信。这可以通过脚本引用来实现，就像您为其他类型的对象间通信所做的那样，但这种方法会有很大的缺点。特别是，这样做会将场景和
    HUD 紧密耦合；您希望它们相对独立，这样您就可以自由地编辑游戏，而不用担心破坏了 HUD。
- en: 'To alert the UI of actions in the scene, we’re going to use a broadcast messenger
    system. Figure 7.17 illustrates how this event messaging system works: scripts
    can register to listen for an event, other code can broadcast an event, and listeners
    will be alerted about broadcast messages. Let’s go over a messaging system to
    accomplish that.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 UI 警告场景中的动作，我们将使用广播信使系统。图 7.17 展示了该事件消息系统的工作原理：脚本可以注册以监听事件，其他代码可以广播事件，监听器将收到广播消息的警报。让我们回顾一下消息系统以实现这一点。
- en: '![CH07_F17_Hocking3](../Images/CH07_F17_Hocking3.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F17_Hocking3](../Images/CH07_F17_Hocking3.png)'
- en: Figure 7.17 Diagram of the broadcast event system we’ll implement
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 我们将实现的广播事件系统图
- en: TIP C# does have a built-in system for handling events, so you might wonder
    why we don’t use that. Well, the built-in event system enforces targeted messages,
    whereas we want a broadcast messenger system. A targeted system requires the code
    to know exactly where messages originate from; broadcasts can originate from anywhere.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 C# 确实有一个内置的事件处理系统，所以您可能会想知道为什么我们不使用它。嗯，内置的事件系统强制执行目标消息，而我们需要的是广播信使系统。目标系统要求代码确切知道消息的来源；广播可以来自任何地方。
- en: 7.4.1 Integrating an event system
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 集成事件系统
- en: To alert the UI of actions in the scene, we’re going to use a broadcast messenger
    system. Although Unity doesn’t have this feature built in, you can download a
    good code library for this purpose. This messenger system is great for providing
    a decoupled way of communicating events to the rest of the program. When some
    code broadcasts a message, that code doesn’t need to know anything about the listeners,
    allowing for a great deal of flexibility in switching around or adding objects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 UI 警告场景中的动作，我们将使用广播信使系统。尽管 Unity 没有内置此功能，但您可以下载一个用于此目的的好代码库。此信使系统非常适合以解耦的方式将事件传达给程序的其他部分。当某些代码广播消息时，该代码不需要了解任何关于监听器的信息，这允许在切换或添加对象时具有很大的灵活性。
- en: Create a script called Messenger and paste in the code from [https://github.com/jhocking/from-unity-wiki/blob/main/Messenger.cs](https://github.com/jhocking/from-unity-wiki/blob/main/Messenger.cs).
    Then, you also need to create a script called GameEvent and fill it with the code
    from listing 7.7.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 Messenger 的脚本，并将代码粘贴到 [https://github.com/jhocking/from-unity-wiki/blob/main/Messenger.cs](https://github.com/jhocking/from-unity-wiki/blob/main/Messenger.cs)。然后，您还需要创建一个名为
    GameEvent 的脚本，并用列表 7.7 中的代码填充它。
- en: Listing 7.7 GameEvent script to use with Messenger
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 与 Messenger 一起使用的 GameEvent 脚本
- en: '[PRE8]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This script defines constants for a couple of event messages; the messages are
    more organized this way, and you don’t have to remember and type the message string
    all over the place.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本定义了一些事件消息的常量；这样组织消息更加有序，你也不必到处记住并输入消息字符串。
- en: Now the event messenger system is ready to use, so let’s start using it. First,
    we’ll communicate from the scene to the HUD, and then we’ll go in the other direction.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事件消息系统已经准备好使用，让我们开始使用它。首先，我们将从场景与HUD进行通信，然后我们将进行相反方向的通信。
- en: 7.4.2 Broadcasting and listening for events from the scene
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 从场景广播和监听事件
- en: Up to now, the score display has displayed a timer as a test of the text display
    functionality. But we want to display a count of enemies hit, so let’s modify
    the code in UIController. First, delete the entire Update() method, because that
    was the test code. When an enemy dies, it will emit an event, so the following
    listing makes UIController listen for that event.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，分数显示已经显示了一个计时器来测试文本显示功能。但我们要显示被击中敌人的数量，所以让我们修改UIController中的代码。首先，删除整个Update()方法，因为那是测试代码。当敌人死亡时，它将发出一个事件，所以下面的列表使UIController监听该事件。
- en: Listing 7.8 Adding event listeners to UIController
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 向UIController添加事件监听器
- en: '[PRE9]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Declare which method responds to the ENEMY_HIT event.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明哪个方法响应ENEMY_HIT事件。
- en: ❷ When an object is deactivated, remove the listener to avoid errors.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当对象被停用时，移除监听器以避免错误。
- en: ❸ Initialize the score to 0.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将分数初始化为0。
- en: ❹ Increment the score in response to the event.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在事件响应中增加分数。
- en: First notice the OnEnable() and OnDisable() methods. Much like Start() and Update(),
    every MonoBehaviour automatically responds when the object is activated or deactivated.
    A listener gets added and removed in OnEnable()/OnDisable(). This listener is
    part of the broadcast messaging system, and it calls OnEnemyHit() when that message
    is received. OnEnemyHit()increments the score and then puts that value in the
    score display.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意OnEnable()和OnDisable()方法。与Start()和Update()类似，每个MonoBehaviour对象在激活或停用时都会自动响应。在OnEnable()/OnDisable()中添加和删除监听器。这个监听器是广播消息系统的一部分，当接收到该消息时调用OnEnemyHit()。OnEnemyHit()增加分数并将该值放入分数显示中。
- en: The event listeners are set up in the UI code, so now we need to broadcast that
    message whenever an enemy is hit. The code to respond to hits is in RayShooter,
    so emit the message as shown here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器在UI代码中设置，所以现在每当敌人被击中时，我们需要广播该消息。响应击中的代码在RayShooter中，所以按照以下方式发出消息。
- en: Listing 7.9 Broadcast event message from RayShooter
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9 从RayShooter广播事件消息
- en: '[PRE10]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Message broadcast added to hit response
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将消息广播添加到击中响应
- en: Play the game after adding that message and watch the score display when you
    shoot an enemy. You should see the count going up every time you make a hit. That
    covers sending messages from the 3D game to the 2D interface, but we also want
    an example going in the other direction.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加该消息后玩游戏，并观察在射击敌人时分数显示的变化。你应该会看到每次击中时计数都会增加。这涵盖了从3D游戏向2D界面发送消息，但我们还想要一个相反方向的例子。
- en: 7.4.3 Broadcasting and listening for events from the HUD
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 从HUD广播和监听事件
- en: In the previous section, an event was broadcast from the scene and received
    by the HUD. In a similar way, UI controls can broadcast a message that both players
    and enemies listen for. In this way, the settings pop-up can affect the settings
    of the game. Open WanderingAI and add this code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，场景广播了一个事件，并被HUD接收。以类似的方式，UI控件可以广播一个消息，玩家和敌人都可以监听。这样，设置弹出窗口就可以影响游戏设置。打开WanderingAI并添加以下代码。
- en: Listing 7.10 Event listener added to WanderingAI
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.10 向WanderingAI添加事件监听器
- en: '[PRE11]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Base speed that is adjusted by the speed setting
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 被速度设置调整的基本速度
- en: ❷ Method that was declared in listener for event SPEED_CHANGED
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在监听器中声明的用于事件SPEED_CHANGED的方法
- en: OnEnable() and OnDisable() add and remove, respectively, an event listener here,
    too, but the methods have a value this time. That value is used to set the speed
    of the wandering AI.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: OnEnable()和OnDisable()也会在这里分别添加和删除事件监听器，但这次方法有了一个值。这个值用于设置游荡AI的速度。
- en: TIP The code in the previous section used a generic event, but this messaging
    system can also pass a value along with the message. Supporting a value in the
    listener is as simple as adding a type definition; note the <float> added to the
    listener command.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：上一节中的代码使用了通用事件，但此消息系统也可以在消息中传递一个值。在监听器中支持一个值就像添加一个类型定义一样简单；注意监听器命令中添加的<float>。
- en: Now make the same changes in FPSInput to affect the speed of the player. The
    code in the next listing is almost the same as that in listing 7.10, except that
    the player has a different number for baseSpeed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在FPSInput中做出相同的更改以影响玩家的速度。下一列表中的代码几乎与列表7.10中的相同，只是玩家的baseSpeed有不同的数值。
- en: Listing 7.11 Event listener added to FPSInput
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11 添加到FPSInput的事件监听器
- en: '[PRE12]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ This value is changed from listing 7.10.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个值是从列表7.10中改变的。
- en: Finally, broadcast the speed values from SettingsPopup in response to the slider.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据滑块广播SettingsPopup中的速度值。
- en: Listing 7.12 Broadcast message from SettingsPopup
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.12 SettingsPopup的广播消息
- en: '[PRE13]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Send slider value as <float> event.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将滑块值作为<float>事件发送。
- en: Now the enemy and player have their speed changed when you adjust the slider.
    Click Play and try it out!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调整滑块时，敌人和玩家的速度都会改变。点击播放并尝试一下！
- en: 'Exercise: Changing the speed of spawned enemies'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：改变产生敌人的速度
- en: 'Currently, the speed value is updated only for enemies already in the scene
    and not for newly spawned enemies; new enemies aren’t created at the correct speed
    setting. I’ll leave it as an exercise for you to figure out how to set the speed
    on spawned enemies. Here’s a hint: add a SPEED_CHANGED listener to SceneController,
    because that script is where enemies are spawned from.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只有场景中已有的敌人速度值会被更新，而新产生的敌人不会以正确的速度设置创建。我将把它留给你作为练习，去思考如何设置新产生敌人的速度。这里有一个提示：给SceneController添加一个SPEED_CHANGED监听器，因为敌人就是从那里产生的。
- en: You now know how to build a graphical interface by using the new UI tools offered
    by Unity. This knowledge will come in handy in all future projects, even as we
    explore different game genres.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何使用Unity提供的新UI工具构建图形界面。这项知识将在所有未来的项目中派上用场，即使我们在探索不同的游戏类型时也是如此。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Unity has both an immediate mode GUI system as well as a newer system based
    on 2D sprites.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity既有即时模式的GUI系统，也有基于2D精灵的新系统。
- en: Using 2D sprites for a GUI requires that the scene have a canvas object.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用2D精灵构建GUI需要场景中有一个画布对象。
- en: UI elements can be anchored to relative positions on the adjustable canvas.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI元素可以被锚定到可调整画布上的相对位置。
- en: Set the Active property to turn UI elements on and off.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Active属性设置为打开或关闭UI元素。
- en: A decoupled messaging system is a great way to broadcast events between the
    interface and the scene.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦的消息系统是广播界面和场景之间事件的好方法。
