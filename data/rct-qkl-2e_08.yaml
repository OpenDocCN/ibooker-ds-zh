- en: 8 Handling events in React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 在React中处理事件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Reacting to user input using events
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件响应用户输入
- en: Handling event capturing and bubbling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事件捕获和冒泡
- en: Managing default event actions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理默认事件行为
- en: Attaching event listeners directly to the DOM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将事件监听器附加到DOM
- en: Events are the way that users interact with a JavaScript web application. Events
    can be caused by mouse movement or clicking, touch interface clicks and drags,
    keyboard button presses, scrolling, copying and pasting, as well as indirect interactions
    such as focusing and unfocusing elements or the entire application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是用户与JavaScript Web应用程序交互的方式。事件可能由鼠标移动或点击、触摸界面的点击和拖动、键盘按钮按下、滚动、复制和粘贴，以及间接交互，如聚焦和取消聚焦元素或整个应用程序等引起。
- en: So far, we’ve created React applications with very little user interaction.
    We’ve handled clicking a button here and there, but not really talked in depth
    about how the click event works, and how we as developers handle it. We’re going
    to change that in this chapter, which is dedicated to event handling.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的React应用程序用户交互非常少。我们处理了这里和那里的按钮点击，但并没有深入讨论点击事件是如何工作的，以及我们作为开发者如何处理它。在本章中，我们将改变这一点，本章专门讨论事件处理。
- en: You can think of events as the way to handle inputs from a user. Our web application
    creates JavaScript XML (JSX), which is converted to HTML. The user then interacts
    with that HTML, and the result of those interactions are events dispatched from
    the HTML elements to our React application. This simple flow of information is
    illustrated in figure 8.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将事件视为处理用户输入的方式。我们的Web应用程序创建JavaScript XML（JSX），然后将其转换为HTML。用户随后与该HTML进行交互，这些交互的结果作为事件从HTML元素派发到我们的React应用程序。这种简单的信息流流程在图8.1中得到了说明。
- en: '![08-01](../Images/08-01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![08-01](../Images/08-01.png)'
- en: Figure 8.1 Information flow between React and the user goes through the HTML.
    Imagine the user visiting a login page. The user inputs the email and password,
    the browser forwards those interactions as events to React, the application then
    generates the JSX required to display a green checkmark next to each input as
    it’s filled, and the browser renders the corresponding HTML to display to the
    user.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 React与用户之间的信息流通过HTML进行。想象一下用户访问登录页面。用户输入电子邮件和密码，浏览器将这些交互作为事件转发给React，应用程序随后生成所需的JSX来显示每个输入旁边的绿色勾选标记，浏览器渲染相应的HTML以显示给用户。
- en: Events are also used internally in the browser to signify when things change
    between elements. It can be when a video is playing/pausing/buffering, an animation
    is completed, a DOM node is mutated, data is loaded (or failed to load), and so
    on. There are hundreds of possible events, and any interactive web application
    will be using a sizable chunk of them. (You can read more about all the possible
    DOM events in the event reference document at [http://mng.bz/9D1j](https://shortener.manning.com/9D1j).)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事件也被浏览器内部用来表示元素之间发生变化的情况。这可能是在视频播放/暂停/缓冲时、动画完成时、DOM节点发生变更时、数据加载（或加载失败）时等情况。有数百种可能的事件，任何交互式Web应用程序都将使用其中相当一部分。（你可以在[http://mng.bz/9D1j](https://shortener.manning.com/9D1j)的事件参考文档中了解更多关于所有可能的DOM事件的信息。）
- en: 'There are two ways to handle events in React:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中处理事件有两种方式：
- en: You can use React to manage your event listener.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用React来管理你的事件监听器。
- en: You can manually add and remove your event listener directly on a DOM node.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以直接在DOM节点上手动添加和移除你的事件监听器。
- en: Relying on React to handle listeners saves a bunch of tedious work and headaches
    (and potential memory leaks), but it comes with a minor loss of flexibility. Directly
    adding event listeners allows you to listen for all kinds of events and assign
    listeners to whichever nodes you feel like when you need to, but comes with the
    cost of having to manage listeners (and remember to remove them again) as well
    as dealing with native events that might differ between browsers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖React来处理监听器可以节省大量繁琐的工作和头痛（以及潜在的内存泄漏），但这也带来了一些灵活性的损失。直接添加事件监听器允许你在需要时监听所有类型的事件，并将监听器分配给你觉得合适的任何节点，但这也带来了需要管理监听器（并记得再次移除它们）以及处理可能在不同浏览器中有所不同的原生事件的成本。
- en: In this chapter, we’ll show you both approaches and discuss when best to apply
    one or the other. Note that handling events *in React* is both a whole lot easier
    as well as recommended. Therefore, this scenario will be covered in a lot more
    detail in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示这两种方法，并讨论何时最好应用其中一种。请注意，在 React 中处理事件既容易又推荐。因此，这个场景将在本章中详细讨论。
- en: 'As we cover how you can listen to events using React’s interface, we’ll discuss
    a number of topics about how React handles events and how you can work with the
    React API to listen to the specific events that you need. We’ll answer the following
    questions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍如何使用 React 的接口监听事件时，我们将讨论许多关于 React 如何处理事件以及你如何与 React API 合作以监听所需特定事件的话题。我们将回答以下问题：
- en: Which events are supported?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些事件是被支持的？
- en: How do you create the event handler function?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何创建事件处理器函数？
- en: What event objects will you receive?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将接收到哪些事件对象？
- en: How do event phases and propagation work?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件阶段和传播是如何工作的？
- en: How do you handle events in the capture phase of the event dispatch?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在事件分发的捕获阶段处理事件？
- en: What are default actions and how do you prevent them?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认操作是什么，你如何防止它们？
- en: When should you persist an event?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该在何时持久化事件？
- en: Can you use properties as event handlers?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否使用属性作为事件处理器？
- en: What are event handler generators?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是事件处理器生成器？
- en: We’ll then proceed to situations where React’s built-in event handling isn’t
    capable enough, and we need to handle events manually in the DOM. We’ll give you
    all the insights into how to do this best, as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将继续到 React 内置事件处理能力不足的情况，我们需要在 DOM 中手动处理事件。我们也会给你提供如何最好地做到这一点的所有见解。
- en: All of this will lead to the next chapter, where we’ll use our newfound understanding
    of event handling to create interactive form inputs and forms in general, which
    is a cornerstone of many web applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将引导我们进入下一章，我们将利用我们对事件处理的全新理解来创建交互式表单输入和表单，这是许多 Web 应用的基石。
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch08](https://rq2e.com/ch08).
    But as you learned in chapter 2, you can instantiate all the examples directly
    from the command line using a single command.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在 [https://rq2e.com/ch08](https://rq2e.com/ch08) 找到。但正如你在第 2 章中学到的，你可以使用单个命令直接从命令行实例化所有示例。
- en: 8.1 Handling DOM events in React
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 在 React 中处理 DOM 事件
- en: Events are an essential way of communicating in the browser between the user
    and the script as well as between different elements in the application. Because
    of this, proper event handling is a first-class citizen in React, meaning that
    React has dedicated a big part of its core API to this exact purpose.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是用户与脚本以及应用程序中不同元素之间在浏览器中进行通信的基本方式。正因为如此，适当的事件处理是 React 的一等公民，这意味着 React 已经为其核心
    API 中的这一特定目的投入了很大一部分。
- en: The API is very simple. If you define a property on a JSX element that references
    an HTML node, and that property matches a known event from React’s list of supported
    events, React will treat the property as an event listener rather than as a DOM
    attribute. React will then make sure to correctly add and remove the event listener,
    as the component mounts and unmounts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: API 非常简单。如果你在 JSX 元素上定义了一个属性，该属性引用了一个 HTML 节点，并且该属性与 React 支持的事件列表中的已知事件匹配，React
    将将该属性视为事件监听器，而不是 DOM 属性。React 将确保在组件挂载和卸载时正确地添加和移除事件监听器。
- en: 8.1.1 Basic event handling in React
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 React 中的基本事件处理
- en: The most important event of all in almost any web application is the click event.
    Contrary to its name, it’s not only used to accept clicks from a mouse. The click
    event in HTML is also invoked when a touchscreen user taps on a button (or a link)
    or when a keyboard user activates a button (or a link) using the Enter key.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在所有 Web 应用程序中，最重要的一个事件就是点击事件。尽管它的名字叫点击事件，但它不仅仅用于接受鼠标的点击。当触摸屏用户点击按钮（或链接）或键盘用户使用
    Enter 键激活按钮（或链接）时，HTML 中的点击事件也会被触发。
- en: Let’s go back to our trusted counter component and take a closer look at how
    we handle the click event. If you remember, this application had a button, and
    we incremented the state value as a response to the user clicking. First, let’s
    repeat the code for this simple application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们信任的计数器组件，并更仔细地看看我们是如何处理点击事件的。如果你还记得，这个应用程序有一个按钮，我们通过用户点击来增加状态值。首先，让我们重复这个简单应用程序的代码。
- en: Listing 8.1 Counter component
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 计数器组件
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates a local variable, which is a function, that will increment the state
    value when invoked
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个局部变量，它是一个函数，当被调用时会增加状态值
- en: ❷ Assigns that local variable to the onClick property on our button
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将该局部变量分配给我们的按钮的onClick属性
- en: In this example, we handle a click event on an HTML object, which is a <button>.
    Any HTML element will dispatch a click event if clicked, so we could have changed
    this element to a <div> or any other type of element.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们处理了一个HTML对象的点击事件，该对象是一个<button>。任何HTML元素在点击时都会触发一个点击事件，因此我们可以将此元素更改为<div>或其他类型的元素。
- en: Another event that we can listen for on all objects is the mouse (or pointer)
    event. Any element can dispatch, for example, a mousemove event, when a mouse
    moves inside that element’s boundary. We can listen for such an event in the same
    way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在所有对象上监听的其他事件之一是鼠标（或指针）事件。任何元素都可以在鼠标移动到该元素边界内时触发，例如，mousemove事件。我们可以以相同的方式监听此类事件。
- en: Let’s create a component that shows a checkmark if the mouse is moving around
    inside the element, but changes to a cross if the mouse has stopped moving for
    half a second or if the mouse moved outside the element.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个组件，如果鼠标在元素内部移动，则显示勾选标记，但如果鼠标停止移动半秒钟或鼠标移出元素，则变为叉号。
- en: To do that, we need to listen for the mousemove event. In React, that means
    we assign a function as the onMouseMove property on our target element. In this
    case, we’ll use a <section> element and display our result in a heading inside
    of that. See this implemented in the following listing and the result in figure
    8.2.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要监听鼠标移动事件。在React中，这意味着我们将一个函数分配为我们的目标元素的onMouseMove属性。在这种情况下，我们将使用一个<section>元素，并在其中显示我们的结果。请参见以下列表中的实现和图8.2中的结果。
- en: '![08-02](../Images/08-02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![08-02](../Images/08-02.png)'
- en: Figure 8.2 Our mouse status component when the mouse isn’t moving or is moving,
    respectively
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 当鼠标不移动或移动时，我们的鼠标状态组件分别显示
- en: Listing 8.2 Is the mouse moving?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 鼠标是否在移动？
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates a local variable, which is a function that will set the moving flag
    to true when invoked
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个局部变量，它是一个函数，当被调用时会将移动标志设置为true
- en: ❷ Assigns that local variable to the relevant property on our element—this time,
    the onMouseMove property on our section element
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将该局部变量分配给我们的元素的相关属性——这次是section元素的onMouseMove属性
- en: 'Repository: rq08-mouse-status'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq08-mouse-status
- en: 'This example can be seen in repository rq08-mouse-status. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq08-mouse-status存储库中查看。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在您的浏览器中查看应用程序，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq08-mouse-status](https://rq2e.com/rq08-mouse-status)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-mouse-status](https://rq2e.com/rq08-mouse-status)'
- en: Not all events are dispatched by all types of elements, though. Video (and audio)
    elements dispatch a play event once the video (or audio) starts playing. Buttons
    don’t dispatch that event because they aren’t videos (or audios) that play.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有事件都是由所有类型的元素触发的。视频（和音频）元素在视频（或音频）开始播放时触发play事件。按钮不会触发该事件，因为它们不是播放视频（或音频）的元素。
- en: Let’s create an application that displays a Play/Pause button next to a video.
    When the video is playing, the button is a Pause button; when the video is paused,
    the button is a Play button.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，显示一个位于视频旁边的播放/暂停按钮。当视频正在播放时，按钮是暂停按钮；当视频暂停时，按钮是播放按钮。
- en: For this, we need a total of four listeners. We need to listen to the play and
    pause events on the video object, and we need to listen for the click event on
    our button, but with two different event listeners depending on whether the video
    is playing or not. We’ll implement this in the next listing. If you run this application,
    you should see something similar to figure 8.3 in your browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要总共四个监听器。我们需要监听视频对象上的播放和暂停事件，并且我们需要监听我们按钮上的点击事件，但根据视频是否正在播放，使用两个不同的事件监听器。我们将在下一个列表中实现这一点。如果您运行此应用程序，您应该在浏览器中看到类似于图8.3的内容。
- en: '![08-03](../Images/08-03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![08-03](../Images/08-03.png)'
- en: Figure 8.3 The video player interface when the video is playing and paused,
    respectively
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 分别显示视频播放和暂停时的视频播放器界面
- en: Listing 8.3 A very simple video player
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 一个非常简单的视频播放器
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Toggles the state flag to true when the video starts playing
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当视频开始播放时，将状态标志切换为true
- en: ❷ Toggles the flag to false when the video pauses
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当视频暂停时，将标志切换为false
- en: ❸ Invokes play on the reference to the video DOM element when the button is
    clicked to play the video
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当按钮被点击以播放视频时，在视频DOM元素的引用上调用play
- en: ❹ Pauses the video when the button is clicked while the video is already playing
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当视频正在播放时点击按钮，将暂停视频
- en: ❺ Assigns the two video event listeners to the video element using the appropriate
    properties
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用适当的属性将两个视频事件监听器分配给视频元素
- en: ❻ Assigns one of the button click event listeners to the onClick property depending
    on the flag
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 根据标志将其中一个按钮点击事件监听器分配给onClick属性
- en: 'Repository: rq08-video-player'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq08-video-player
- en: 'This example can be seen in repository rq08-video-player. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq08-video-player仓库中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在您的浏览器中查看应用程序的运行情况，或下载源代码的zip文件：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listening to events in React is really only about three things:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中监听事件实际上只涉及三件事：
- en: Knowing what event to listen for
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道要监听哪个事件
- en: Knowing which element to listen on
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道要监听哪个元素
- en: Assigning a listening function to the correct property on the correct element
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在正确的元素上为正确的属性分配监听函数
- en: That’s really all there is to it. The rest of this chapter walks through a number
    of event examples, so your toolbox will be ready to handle any event scenario
    that you come across.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。本章的其余部分将介绍许多事件示例，因此您的工具箱将准备好处理您遇到的任何事件场景。
- en: Events supported by react
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由react支持的事件
- en: You can only use React to listen for events that are supported by React. Normally,
    this isn’t something you have to worry about because almost all DOM events are
    supported by React. You can see a full list of all the supported events in table
    8.1.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能使用React监听由React支持的事件。通常，这并不是您需要担心的事情，因为几乎所有的DOM事件都由React支持。您可以在表8.1中查看所有支持的事件的完整列表。
- en: However, there are some JavaScript events that aren’t supported in React—mostly
    because these events are dispatched from objects that aren’t in the DOM, but are
    objects that you create in JavaScript only. These include events from objects
    such as socket connections and request objects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些JavaScript事件在React中不受支持——主要是因为这些事件是从不在DOM中的对象派发的，但您只在JavaScript中创建了这些对象。这些包括来自套接字连接和请求对象等对象的这些事件。
- en: Some other unsupported DOM events are events that are only sent to the window
    or document nodes. They aren’t supported by React because these two nodes are
    never inside your React application. React only lives somewhere inside the document
    element, never above it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他不受支持的DOM事件是仅发送到window或document节点的那些事件。React不支持这些事件，因为这些两个节点永远不会在您的React应用程序内部。React只存在于文档元素内部，永远不会在其上方。
- en: Note that if you set a property on a JSX element that matches a known event
    type listed in table 8.1, React will convert that property to a listener on that
    element, regardless of whether that element can dispatch that event at all. You
    can, for instance, assign an onPlay event listener to an <h1 /> element, even
    though that event will only ever be dispatched from <video /> and <audio /> elements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您在JSX元素上设置一个属性，该属性与表8.1中列出的已知事件类型匹配，React会将该属性转换为该元素上的监听器，无论该元素是否可以派发该事件。例如，您可以将onPlay事件监听器分配给<h1
    />元素，尽管该事件将仅从<video />和<audio />元素派发。
- en: Table 8.1 List of events directly supported in React
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 列出React直接支持的事件
- en: '| Clipboard events | onCopy onCut onPaste |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 剪贴板事件 | onCopy onCut onPaste |'
- en: '| Composition events | onCompositionEnd onCompositionStart onCompositionUpdate
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 组合事件 | onCompositionEnd onCompositionStart onCompositionUpdate |'
- en: '| Keyboard events | onKeyDown onKeyPress onKeyUp |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 键盘事件 | onKeyDown onKeyPress onKeyUp |'
- en: '| Focus events | onFocus onBlur |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 焦点事件 | onFocus onBlur |'
- en: '| Form events | onChange onInput onInvalid onReset onSubmit |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 表单事件 | onChange onInput onInvalid onReset onSubmit |'
- en: '| Generic events | onError onLoad |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 通用事件 | onError onLoad |'
- en: '| Mouse events | onClick onContextMenu onDoubleClick onDrag onDragEndonDragEnter
    onDragExitonDragLeave onDragOver onDragStart onDrop onMouseDownonMouseEnter onMouseLeaveonMouseMove
    onMouseOut onMouseOver onMouseUp |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 鼠标事件 | onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit
    onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave
    onMouseMove onMouseOut onMouseOver onMouseUp |'
- en: '| Pointer events | onPointerDown onPointerMove onPointerUp onPointerCancelonGotPointerCaptureonLostPointerCapture
    onPointerEnter onPointerLeaveonPointerOver onPointerOut |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 指针事件 | onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture
    onLostPointerCapture onPointerEnter onPointerLeave onPointerOver onPointerOut
    |'
- en: '| Selection events | onSelect |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 选择事件 | onSelect |'
- en: '| Touch events | onTouchCancel onTouchEnd onTouchMove onTouchStart |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 触摸事件 | onTouchCancel onTouchEnd onTouchMove onTouchStart |'
- en: '| UI events | onScroll |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| UI事件 | onScroll |'
- en: '| Wheel events | onWheel |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 滚轮事件 | onWheel |'
- en: '| Media events | onAbort onCanPlay onCanPlayThrough onDurationChangeonEmptied
    onEncryptedonEnded onError onLoadedData onLoadedMetadata onLoadStartonPause onPlayonPlaying
    onProgress onRateChange onSeeked onSeekingonStalled onSuspendonTimeUpdate onVolumeChange
    onWaiting |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 媒体事件 | onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted
    onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay onPlaying
    onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange
    onWaiting |'
- en: '| Image events | onLoad onError |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 图像事件 | onLoad onError |'
- en: '| Animation events | onAnimationStart onAnimationEnd onAnimationIteration |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 动画事件 | onAnimationStart onAnimationEnd onAnimationIteration |'
- en: '| Transition events | onTransitionEnd |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 过渡事件 | onTransitionEnd |'
- en: '| Other events | onToggle |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 其他事件 | onToggle |'
- en: 8.2 Event handlers
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 事件处理器
- en: To handle an event, simply assign any function to the relevant property of a
    JSX element that might dispatch such an event. Your function doesn’t have to behave
    in any particular way or accept any particular argument. The event handler function
    will be called with a single argument—the event object—but you don’t have to accept
    it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理一个事件，只需将任何函数分配给可能触发此类事件的JSX元素的相关属性。你的函数不需要以任何特定的方式表现或接受任何特定的参数。事件处理器函数将使用单个参数——事件对象来调用，但你不必接受它。
- en: Because there are no restrictions nor any defined best practices from an “official”
    source on how to define an event handler function, you’ll see people do it in
    many different ways. In this section, we’ll cover some of the different options
    and some conventions that we’ve seen used in larger codebases.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有来自“官方”来源的任何限制或定义的最佳实践来定义事件处理器函数，你会看到人们以许多不同的方式来做这件事。在本节中，我们将介绍一些不同的选项和一些我们在较大的代码库中看到的使用惯例。
- en: 8.2.1 Definition of event handlers
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 事件处理器定义
- en: Note This subsection doesn’t teach you anything new React-wise. It mainly reiterates
    how you can define functions in different ways in JavaScript inside other functions.
    If you’re a JavaScript expert, feel free to skip this section and go straight
    to section 8.2.2.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本小节不会教授你任何新的React知识。它主要重申了如何在JavaScript函数内部以不同的方式定义函数。如果你是JavaScript专家，请随意跳过本节，直接进入8.2.2节。
- en: 'You can define the event function any way you like. If it’s a valid function,
    it’s valid as an event handler. Common options include the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以任何你喜欢的方式定义事件函数。如果它是一个有效的函数，它就作为事件处理器有效。常见选项包括以下：
- en: Define the function as a local variable using an arrow function.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用箭头函数将函数定义为局部变量。
- en: Define the function as a local variable using a function expression.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数表达式将函数定义为局部变量。
- en: Define the function as an inline function using an arrow function directly assigned
    to the property.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用箭头函数直接分配给属性的方式将函数定义为行内函数。
- en: 'Here’s an example of our counter component once again with a local variable
    using an arrow function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的计数器组件的另一个示例，使用箭头函数和局部变量：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a variable using const and assigns a function using the arrow function
    notation
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用const创建变量并使用箭头函数符号分配函数
- en: ❷ Assigns that variable to the onClick property
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将该变量分配给onClick属性
- en: 'Here’s the very same component, but with the handler function defined using
    a function expression:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全相同的组件，但使用函数表达式定义了处理器函数：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates the function using a function expression, which will scope the variable
    as a local variable
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用函数表达式创建函数，这将变量作用域作为局部变量
- en: ❷ Assigns that variable to the onClick property
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将该变量分配给onClick属性
- en: 'And, finally, here’s the same component with the handler defined inline using
    an arrow function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是同一个组件，但使用箭头函数在行内定义了处理器：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates the event handler inline and directly assigns it to the relevant property
    on the HTML element
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在行内创建事件处理器并将其直接分配给HTML元素的相关属性
- en: The second approach, with a function expression inside your component, is a
    bit unusual, albeit fully valid. We won’t use that syntax, and we haven’t seen
    it much in the wild.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，在组件内部使用函数表达式，虽然完全有效，但有点不寻常。我们不会使用那种语法，而且在野外也没有看到很多。
- en: Whether you define your event handler in a variable or inline in the JSX is
    up to you. Many will mix and match the two options, and so will we throughout
    this book. Your team will most likely find a convention that works for them, and
    if you’re working alone, find what works for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你是在变量中定义事件处理程序还是在 JSX 中内联定义，这取决于你。许多人会混合使用这两种选项，本书也是如此。你的团队可能会找到一个对他们有效的约定，如果你是单独工作的，找到对你有效的方法。
- en: 'A common convention is to define single-line event handlers inline, but multiline
    event handlers in a separate variable. So, there’s nothing stopping you from doing
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的做法是将单行事件处理程序直接定义在内联中，而将多行事件处理程序定义在单独的变量中。因此，没有任何阻止你这样做的原因：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But some developers will find it a bit messy and will prefer to have such multiline
    event handlers defined separately in a variable before the JSX is returned:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但一些开发者可能会觉得这有点混乱，并更喜欢在 JSX 返回之前将这样的多行事件处理程序单独定义在变量中：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 8.2.2 Event objects
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 事件对象
- en: When an event handler is invoked because an event has occurred, the event handler
    is invoked with a single argument—the event object. This happens both in regular
    HTML and JavaScript, as well as in React.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件处理程序因为事件发生而被调用时，事件处理程序会带有一个参数——事件对象。这既发生在常规 HTML 和 JavaScript 中，也发生在 React
    中。
- en: React event objects are a bit special, but we’ll get to that in the next subsection.
    For now, we’ll showcase a few things that regular JavaScript event objects and
    React event objects have in common.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: React 事件对象有点特殊，但我们在下一小节中会讨论这一点。现在，我们将展示常规 JavaScript 事件对象和 React 事件对象的一些共同点。
- en: Let’s try to build our counter component with both increment and decrement buttons
    again, but this time we’ll use the same event handler function to handle the click
    event on both buttons. We do this to display an alternative way of structuring
    the code. It’s not faster or better in terms of code performance, but some will
    prefer this style over the previous one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试构建我们的计数器组件，这次我们将使用带有增加和减少按钮的组件，但这次我们将使用相同的事件处理程序函数来处理两个按钮的点击事件。我们这样做是为了展示代码结构的另一种方式。在代码性能方面，这并不更快或更好，但有些人可能更喜欢这种风格而不是之前的那一种。
- en: To do this, we need to know which button caused the event that was sent to the
    event handler. We can do that by looking at the event object passed. It will have
    a property, .target, that points to the HTML node that was clicked. To compare
    this target property with the actual node, we need a reference to one of the nodes
    in our component. Let’s implement this in the following listing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要知道哪个按钮触发了发送给事件处理程序的事件。我们可以通过查看传递的事件对象来实现。它将有一个属性，.target，指向被点击的 HTML
    节点。为了将这个目标属性与实际节点进行比较，我们需要我们组件中的一个节点的引用。让我们在下面的列表中实现这一点。
- en: Listing 8.4 Increment and decrement with a single event handler
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 使用单个事件处理程序进行增加和减少
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ First, we need a ref, so we can access the HTML node.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先，我们需要一个引用，这样我们就可以访问 HTML 节点。
- en: ❷ Then, in our single event handler, we compare the event target with the increment
    node. If it’s not that button, it must be the other one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 然后，在我们的单个事件处理程序中，我们比较事件目标与增量节点。如果不是那个按钮，那么它一定是另一个按钮。
- en: ❸ Adds the delta to the currently stored value
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将增量添加到当前存储的值
- en: ❹ Assigns the same event handler to both buttons but only a ref to the increment
    button
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将相同的事件处理程序分配给两个按钮，但只将引用分配给增量按钮
- en: Is this better than having two separate event handlers? That’s a subjective
    question. Both solutions are fine. Sometimes one seems more appropriate, and other
    times, the other one does. The choice mostly comes down to personal preference.
    Do you feel that having a single event handler makes the code more readable, or
    do you prefer having separate handlers? There’s no difference in performance,
    so it’s completely up to your preferred style.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否比有两个单独的事件处理程序更好？这是一个主观的问题。两种解决方案都很好。有时一种方法似乎更合适，而有时则相反。选择通常取决于个人偏好。你是否觉得使用单个事件处理程序可以使代码更易读，或者你更喜欢使用单独的处理程序？在性能上没有区别，所以这完全取决于你喜欢的风格。
- en: Event objects always have a target property that refers to the target of the
    event. Another property that all events have is the type property. The value of
    this property is the type of event invoked. Imagine that we assigned the same
    event handler to both the onMouseEnter and the onFocus property of an input field.
    Then, our event handler would fire if the user either moved their mouse over the
    field or used the keyboard to tab into the field. We could tell which event occurred
    by looking at the evt.type property.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象始终有一个目标属性，该属性指向事件的目标。所有事件都具有的一个属性是类型属性。该属性的值是触发事件的类型。想象一下，如果我们将相同的事件处理程序分配给输入字段的onMouseEnter和onFocus属性。那么，当用户将鼠标移至字段或使用键盘切换到字段时，我们的事件处理程序就会触发。我们可以通过查看evt.type属性来确定哪个事件发生了。
- en: 'Some event objects have extra properties that are specific for the event types
    that dispatched them. For instance, mouse event objects always have the properties
    .clientX and .clientY, which indicate where in the document the mouse event occurred,
    as well as .ctrlKey and .shiftKey, which indicate whether either of those keys
    were pressed while the mouse event occurred. Mouse event objects have many other
    properties than these, though. To see the full list of available properties for
    all the different event objects in React, check the online documentation here:
    [http://mng.bz/D4Zy](http://mng.bz/D4Zy).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件对象具有特定于它们触发的事件类型的额外属性。例如，鼠标事件对象始终具有.clientX和.clientY属性，这些属性指示鼠标事件在文档中的位置，以及.ctrlKey和.shiftKey属性，这些属性指示在鼠标事件发生时是否按下了这些键。尽管鼠标事件对象还有许多其他属性，但这些都是其中的一部分。要查看React中所有不同事件对象的所有可用属性列表，请在此处查看在线文档：[http://mng.bz/D4Zy](http://mng.bz/D4Zy)。
- en: 8.2.3 React event objects
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 React事件对象
- en: React event handlers aren’t the same as “true” DOM event handlers. A DOM event
    handler is added to a DOM node and passed a DOM event object when invoked. A React
    event handler isn’t directly added to any DOM node and will be invoked by React
    with a React event object when React detects that an event of the given type happened
    on that node. Compare and contrast the two approaches in figure 8.4.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: React事件处理程序与“真正的”DOM事件处理程序不同。DOM事件处理程序被添加到DOM节点上，并在调用时传递一个DOM事件对象。React事件处理程序不会直接添加到任何DOM节点上，而是在React检测到该节点上发生了给定类型的事件时，由React使用React事件对象调用。在图8.4中比较和对比这两种方法。
- en: '![08-04](../Images/08-04.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![08-04](../Images/08-04.png)'
- en: Figure 8.4 React doesn’t add a listener on the individual node, but listens
    to any event on any node, unlike native DOM listeners.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 React不会在单个节点上添加监听器，而是监听任何节点上的任何事件，这与原生的DOM监听器不同。
- en: 'In figure 8.4, notice that when you add a listener to a JSX element, React
    *doesn’t* add a new listener anywhere. Instead, it just remembers that you want
    to be informed about this specific type of event for this specific node. React
    already listens to all events on all nodes, so when an event of the specified
    type occurs, React will check if the target matches the one you asked about; if
    so, React will invoke your event listener with a custom React event object. The
    reasoning for React implementing this new event system on top of the already existing
    native browser event system is two-fold: performance and consistency.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在图8.4中，请注意，当你向JSX元素添加监听器时，React不会在任何地方添加新的监听器。相反，它只是记住你想要了解这个特定节点上这种特定类型的事件。React已经监听所有节点上的所有事件，所以当指定类型的事件发生时，React会检查目标是否与请求的目标匹配；如果是，React将使用自定义的React事件对象调用你的事件监听器。React在现有的原生浏览器事件系统之上实现这个新的事件系统的理由有两个：性能和一致性。
- en: Performance
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: As we just mentioned, React doesn’t add listeners to individual nodes. React
    adds a single listener of every event type to the document, and this is done for
    performance reasons.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，React不会向单个节点添加监听器。React为每个事件类型向文档添加一个单独的监听器，这是出于性能考虑。
- en: The performance gain is real. If you add a thousand buttons and assign a click
    event listener to each node in pure JavaScript, it requires a lot of memory. But
    if you use React to do the same, React will only ever create a single click event
    listener on the document as a whole and, when invoked, check if the target matches
    any that you asked for. This significantly reduces memory usage.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升是真实的。如果你添加了1000个按钮，并将点击事件监听器分配给纯JavaScript中的每个节点，这需要大量的内存。但如果你使用React来做同样的事情，React将只为整个文档创建一个单独的点击事件监听器，并在调用时检查目标是否与请求的目标匹配。这显著减少了内存使用。
- en: For this reason, you don’t have to worry about adding too many event listeners
    in React. If you were implementing a web app in plain JavaScript, you might have
    to create some workarounds to reduce how many listeners you have. When using React,
    this is all taken care of for you, so you can just add listeners as you like and
    know that you still have great performance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你不必担心在 React 中添加过多的事件监听器。如果你使用纯 JavaScript 实现一个 Web 应用程序，你可能需要创建一些解决方案来减少监听器的数量。当使用
    React 时，这一切都为你处理好了，所以你可以随意添加监听器，并知道你仍然拥有出色的性能。
- en: Consistency
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性
- en: Despite browsers being more and more standards compliant, there are still older
    browsers out there, and they might do things a bit differently. This is particularly
    relevant when it comes to the event API. A lot of this concern is about browsers
    that are 5+ years old (older versions of Firefox and especially Internet Explorer
    9 and earlier), so it doesn’t seem extremely important today, but these browsers
    might still exist in the wild.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管浏览器越来越符合标准，但仍然存在一些较老的浏览器，它们可能以不同的方式处理事情。这尤其与事件 API 有关。许多这种担忧都与 5 年以上（Firefox
    的旧版本，尤其是 Internet Explorer 9 及更早版本）的浏览器有关，所以今天这并不显得特别重要，但这些浏览器可能仍然存在。
- en: Another big reason for consistency might be slightly surprising. Some events
    aren’t standardized but are still implemented by every browser. This includes
    events such as the mouse wheel event. There is no standard for this event, nor
    is any such on the way, but all browsers still support it, so React does as well.
    Because there is no standard, browsers handle the mouse wheel event slightly differently
    when it comes to naming. The scroll wheel change in the x direction is stored
    in a property called either .deltaX or .wheelDeltaX in different browsers. React’s
    synthetic mouse wheel event takes care of this and unifies this naming as .deltaX
    always. Similar unification happens for some other nonstandard properties on this
    and other event types.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个导致一致性的重要原因可能有些令人惊讶。一些事件没有标准化，但每个浏览器都实现了它们。这包括鼠标滚轮事件。这个事件没有标准，也没有任何即将到来的标准，但所有浏览器仍然支持它，因此
    React 也一样。因为没有标准，所以当涉及到命名时，浏览器在处理鼠标滚轮事件时略有不同。在 x 方向上的滚动轮变化被存储在不同的属性中，比如 `.deltaX`
    或 `.wheelDeltaX`，这取决于不同的浏览器。React 的合成鼠标滚轮事件处理了这一点，并统一了这个命名，即始终使用 `.deltaX`。类似的一统也发生在其他非标准属性上，包括这个和其他事件类型。
- en: For this reason, you don’t have to worry about browser differences at all when
    using React events. You can rely on the React documentation only and trust that
    React will take care of all the underlying details for you. Due to browser differences
    disappearing as the use of older browsers decreases, it’s likely that this feature
    of the React synthetic event system will disappear at some point in the future
    and be replaced exclusively with browser-native events.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用 React 事件时，你不必担心浏览器的差异。你只需依赖 React 文档，并相信 React 会为你处理所有底层细节。由于随着旧浏览器使用的减少，浏览器差异正在消失，因此
    React 合成事件系统的这个特性可能在未来的某个时刻消失，并完全被浏览器原生事件所取代。
- en: The Synthetic Event API
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 合成事件 API
- en: React’s synthetic events have an API that’s based on the standard API model
    as defined in the HTML specification. This means that you can use all the properties
    and methods that you expect from an event.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: React 的合成事件有一个基于 HTML 规范中定义的标准 API 模型。这意味着你可以使用你期望从事件中获取的所有属性和方法。
- en: All synthetic events share a set of common properties and methods, and more
    specialized events have extra properties specific to certain events. For instance,
    all events have a .type property and a .target property. They also all have .preventDefault()
    and .stopPropagation() methods. We’ll get back to how these work later.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有合成事件都共享一组常见的属性和方法，而更专业的事件则具有特定事件的额外属性。例如，所有事件都有一个 `.type` 属性和一个 `.target`
    属性。它们还都有 `.preventDefault()` 和 `.stopPropagation()` 方法。我们稍后会回到这些方法是如何工作的。
- en: Individual event types have extra properties as needed for specific events,
    including, for example, the .pageX and .pageY properties on mouse and pointer
    events, which include the coordinates of the clicks on the page.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 个体事件类型根据特定事件的需要具有额外的属性，包括例如鼠标和指针事件上的 `.pageX` 和 `.pageY` 属性，它们包括页面上的点击坐标。
- en: 'Note For details on the specific properties and methods, please see the React
    synthetic event API documentation: [http://mng.bz/D4Zy](http://mng.bz/D4Zy).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关特定属性和方法的详细信息，请参阅 React 合成事件 API 文档：[http://mng.bz/D4Zy](http://mng.bz/D4Zy)。
- en: Access to native events
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 访问原生事件
- en: If for some reason you need access to the underlying native event, maybe because
    you’re doing something for a specific browser that can include some extra information
    that is useful for your particular application, you can access it via the .nativeEvent
    property. This is a nonstandard property and a React-only extension of the event
    API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因你需要访问底层原生事件，可能是因为你正在为特定浏览器做某些事情，这可能包括一些对你特定应用程序有用的额外信息，你可以通过.nativeEvent属性来访问它。这是一个非标准属性，是React对事件API的扩展。
- en: 8.2.4 Synthetic event object persistence
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 合成事件对象持久性
- en: Events need no longer be persisted. That’s it, next section. Wait, what? This
    might seem odd, but event persistence was a thing you had to do in earlier versions
    of React up until the release of React 17, after which it was no longer needed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 事件不再需要持久化。就是这样，下一节。等等，什么？这听起来可能有些奇怪，但在React 17发布之前，事件持久化是早期版本React中必须执行的操作，在那之后就不再需要了。
- en: However, because persistence was a commonly used “feature” that only fairly
    recently became obsolete, we’ll still cover it here in case you stumble upon it
    in the wild. You’ll find event persistence in a codebase that hasn’t been fully
    updated when moving to newer versions of React or even in tutorials and guides
    about React that aren’t completely up to date.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于持久化是一个曾经广泛使用的“特性”，但最近才变得过时，我们仍然在这里介绍它，以防你在野外遇到它。你会在迁移到React新版本或甚至在不完全更新的React教程和指南中找到事件持久化。
- en: Back in the day, for performance reasons, React’s synthetic events were pooled
    in order to not create too many objects all the time. Before version 17, React
    didn’t create new event objects every time an event was dispatched. React instead
    held an internal pool (an array, basically) of events, and when it needed to send
    an event, React would get one from the pool, and then immediately after dispatching
    the event, return the event object to the pool. As the event object returned to
    the pool, the event was “cleared out,” meaning that all properties were reset
    to have no value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时代，出于性能考虑，React的合成事件被池化，以避免不断创建过多的对象。在版本17之前，React在每次事件分发时并不会创建新的事件对象。相反，React维护一个内部的事件池（基本上是一个数组），当需要发送事件时，React会从池中取出一个事件，然后在事件分发后立即将事件对象返回到池中。当事件对象返回池中时，事件会被“清除”，意味着所有属性都被重置为无值。
- en: As a developer, this meant that if you received an event in an event handler,
    you had to *consume* the event right away. You couldn’t save it or otherwise access
    it in a delayed manner.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，这意味着如果你在事件处理器中收到一个事件，你必须立即*消费*该事件。你不能保存它或以其他方式延迟访问它。
- en: Let’s say that we want to create a counter that we can increase by a value selected
    from a drop-down. We’ve created a ton of counters, but this is a new variant.
    The goal is to display the current counter value (starting at 0) and also a drop-down
    with values from 1 to 5\. When you select one of the values, the counter will
    increase by that amount. When you then select a new value, the drop-down will
    again increase by that new amount, and so on. Let’s implement this in the next
    listing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个计数器，我们可以通过下拉选择来增加它的值。我们已经创建了很多计数器，但这是一个新的变体。目标是显示当前的计数器值（从0开始）以及一个包含1到5的值的下拉菜单。当你选择其中一个值时，计数器将增加相应的数量。当你选择新的值时，下拉菜单将再次增加新的数量，依此类推。让我们在下一个列表中实现这个功能。
- en: Listing 8.5 Drop-down counter
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 下拉计数器
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Adds the selected option to the current counter value in our change event
    handler by using an update function
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过使用更新函数将选定的选项添加到当前计数器的值中，在我们的更改事件处理器中
- en: ❷ Assigns the event handler to the select element
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将事件处理器分配给选择元素
- en: 'Repository: rq08-persistence'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq08-persistence
- en: 'This example can be seen in repository rq08-persistence. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq08-persistence仓库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq08-persistence](https://rq2e.com/rq08-persistence)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-persistence](https://rq2e.com/rq08-persistence)'
- en: 'This works and all is well. However, if you were to create this in React 16.8
    (when React hooks were introduced) through React 16.14 (the latest React 16 version
    before React 17 was introduced), this wouldn’t work. Instead, evt.target.value
    would throw an error in the console because evt.target is undefined. This happens
    because we pass an update function to the state setter, and that update function
    is invoked asynchronously. By the time the function is invoked, React already
    has returned the event object to the pool and reset it, including clearing evt.target.
    We could have solved this in React 16 in one of two ways:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法可行且一切顺利。然而，如果你在 React 16.8（React hooks 介绍时）通过 React 16.14（React 17 介绍之前的最新
    React 16 版本）中创建这样的功能，它将不会工作。相反，evt.target.value 会在控制台中抛出一个错误，因为 evt.target 是未定义的。这是因为我们向状态设置器传递了一个更新函数，而这个更新函数是异步调用的。当函数被调用时，React
    已经将事件对象返回到池中并重置了它，包括清除 evt.target。我们可以在 React 16 中通过以下两种方式之一解决这个问题：
- en: Make a local copy of the value from the event object we needed right away and
    use that value asynchronously in our update function.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即从所需的事件对象中制作一个值的本地副本，并在我们的更新函数中异步使用该值。
- en: Persist the event, meaning that React would know not to return this particular
    event object to the pool, and instead discard it as a “one-time event object”
    and create another new event object to return to the pool instead.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持事件状态，这意味着 React 会知道不要将此特定事件对象返回到池中，而是将其丢弃作为“一次性事件对象”，并创建另一个新的事件对象返回到池中。
- en: 'The first approach for copying the values we need would look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 复制所需值的第一个方法看起来像这样：
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ First, we copy the value from the event object we need to access later.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先，我们复制需要稍后访问的事件对象的值。
- en: ❷ Then, we use that value.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 然后，我们使用那个值。
- en: 'The second approach, where we persist the event object, would look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 持续事件对象的第二种方法看起来像这样：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ We instruct React to not reuse this event object, but persist it for our use
    indefinitely.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们指示 React 不要重用此事件对象，而是无限期地保持其状态以供我们使用。
- en: ❷ Then, we can freely use the event object even in asynchronous code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 然后，我们可以在异步代码中自由使用事件对象。
- en: This whole mess of having to remember to persist events if used asynchronously
    was pretty annoying. It didn’t happen very frequently and was a very common source
    of confusion and errors, even for experienced developers, which is partially why
    it was abandoned. The other reason was that the performance gained by pooling
    events decreased as devices grew faster, so it became an unnecessary optimization.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种必须记住在异步使用时保持事件状态的情况相当令人烦恼。这种情况并不经常发生，并且是混淆和错误的一个非常常见来源，即使是经验丰富的开发者也是如此，这也是它被放弃的部分原因。另一个原因是，随着设备速度的提高，事件池化的性能增益减少了，因此它成为了一个不必要的优化。
- en: 8.3 Event phases and propagation
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 事件阶段和传播
- en: Events are not *just* sent to the target object. When you click a link, the
    link dispatches a click event. But if the link had a bold text element inside
    it (e.g., <a href>A <strong>bold</strong> link</a>), you actually click the bold
    text element. The link then dispatches a click event because you also click the
    link element. You “click” all the parent elements of the bold text element. This
    is called *event propagation*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事件不仅仅是发送到目标对象。当你点击一个链接时，链接会分发一个点击事件。但如果链接内部有一个加粗的文本元素（例如，<a href>A <strong>bold</strong>
    link</a>），你实际上点击的是加粗的文本元素。然后链接会分发一个点击事件，因为你同时也点击了链接元素。你“点击”了加粗文本元素的所有父元素。这被称为
    *事件传播*。
- en: To introduce the concept of event propagation, let’s consider a new example.
    We want to build a contact form that contains two different sections (field sets).
    The first section is information about the user (name and email), and the second
    is about why they are sending this contact request (subject and body).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍事件传播的概念，让我们考虑一个新的例子。我们想要构建一个包含两个不同部分（字段集）的联系人表单。第一个部分是关于用户的信息（姓名和电子邮件），第二个部分是关于他们为什么发送这个联系请求（主题和正文）。
- en: Because we want the form to look nice and user friendly, we’ll highlight the
    section in which the user is currently inputting data. We want the result to look
    like what you see in figure 8.5.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要使表单看起来既美观又用户友好，所以我们会突出显示用户当前输入数据的部分。我们希望结果看起来像图 8.5 中所示的那样。
- en: '![08-05](../Images/08-05.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![08-05](../Images/08-05.png)'
- en: Figure 8.5 Our finished form when the user is inputting data into either section
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 用户在任一部分输入数据时的完成表单
- en: To achieve this goal, we need to listen to the focus and blur events on the
    input fields. When an input receives focus, store its section as the focused one.
    When an input field loses focus, remember that no section has focus. With this
    approach, we need to put two event listeners on every input in both sections.
    In this example, we only have two inputs in each section, so that’s a total of
    eight listeners, but what if we had a lot more inputs? We would have to duplicate
    the same two listeners to every input field. If that seems like a terrible way
    to do this, it is. You should avoid repeating yourself if possible. In this instance,
    it’s very much avoidable because events bubble!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们需要监听输入字段的焦点和失焦事件。当一个输入获得焦点时，将其部分存储为焦点部分。当一个输入字段失去焦点时，记住没有部分有焦点。采用这种方法，我们需要在每个部分的每个输入上放置两个事件监听器。在这个例子中，每个部分中只有两个输入，所以总共是八个监听器，但如果我们有更多的输入呢？我们就必须将相同的两个监听器复制到每个输入字段。如果这听起来像是一种糟糕的方法，那它确实如此。如果可能的话，你应该避免重复。在这个例子中，由于事件冒泡，这种情况完全可以避免。
- en: Every event in React *bubbles* up through all the nodes in the document tree
    above it. To know which section has focus, we just need to listen for when anything
    inside a section receives focus. Likewise, to know that an element loses focus,
    we just need to know whenever any element inside the form loses focus. We can
    use this trick to place our focus listeners on the two sections and the blur listener
    on the form itself. Then, we only need a total of three event listeners to achieve
    this result rather than eight different listeners, of which most are identical.
    Let’s look at the resulting JSX structure and where we want to put our listeners
    in figure 8.6.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: React 中的每个事件都会向上冒泡，穿过其文档树上的所有节点。为了知道哪个部分有焦点，我们只需要监听任何部分内的元素何时获得焦点。同样，为了知道某个元素失去焦点，我们只需要知道表单内任何元素何时失去焦点。我们可以使用这个技巧在两个部分上放置焦点监听器，并在表单本身上放置失焦监听器。然后，我们只需要总共三个事件监听器就能达到这个效果，而不是八个不同的监听器，其中大多数是相同的。让我们看看图
    8.6 中的结果 JSX 结构以及我们想要放置监听器的位置。
- en: '![08-06](../Images/08-06.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![08-06](../Images/08-06.png)'
- en: Figure 8.6 We add a blur listener to the entire form and focus listeners on
    both field sets. When an event occurs on any input (in the bottom row), the event
    will travel up the tree and be handled by the proper event handler.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 我们在表单上添加了一个失焦监听器，并在两个字段集上添加了焦点监听器。当任何输入（在底部行）上发生事件时，事件将向上传播并被适当的事件处理程序处理。
- en: When you focus any input field, the event will first dispatch on the input field
    itself, but after that, the same event will dispatch on every ancestor to the
    target element in order from the parent all the way up to the root node of the
    React application. When the bubbling reaches the field set, React will invoke
    our onFocus listener placed there. Similarly, when an input blurs, React will
    invoke the onBlur listener placed on the form element.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你聚焦任何输入字段时，事件首先在输入字段本身上触发，但之后，相同的事件将在目标元素的所有祖先元素上依次触发，从父元素一直向上到 React 应用程序的根节点。当冒泡到达字段集时，React
    将调用我们放置在那里的 onFocus 监听器。同样，当输入失去焦点时，React 将调用放置在表单元素上的 onBlur 监听器。
- en: Now that we know what we want to achieve and what the resulting JSX is going
    to look like, all that remains is to put it all together into a single component.
    Let’s do that in listing 8.6.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了我们想要实现什么，以及结果的 JSX 将会是什么样子，剩下的就是将所有这些组合成一个单独的组件。让我们在列表 8.6 中这样做。
- en: Listing 8.6 Highlighting contact form sections
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 突出显示联系表单部分
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ First, we add a helper function to generate the style for a section depending
    on whether it’s the active section or not.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先，我们添加一个辅助函数，根据该部分是否为活动部分来生成其样式。
- en: ❷ Second, we need to remember what section has focus right now (at the start,
    none of them do).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第二，我们需要记住当前哪个部分有焦点（一开始，它们都没有）。
- en: ❸ Creates three different and very simple listeners that we need to use
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建三个不同且非常简单的监听器，我们需要使用它们
- en: ❹ Assigns the listeners where we need them
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将监听器分配到所需的位置
- en: ❺ Assigns the correct style to each section depending on whether it has focus
    or not
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 根据部分是否有焦点，为每个部分分配正确的样式
- en: 'Repository: rq08-contact'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq08-contact
- en: 'This example can be seen in repository rq08-contact. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库 rq08-contact 中看到。你可以通过基于相关模板创建一个新应用程序来使用该仓库：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站浏览代码，直接在您的浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq08-contact](https://rq2e.com/rq08-contact)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-contact](https://rq2e.com/rq08-contact)'
- en: That’s it! We now have a fancy styled contact form with some pretty clever focus
    listeners. If you run this in a browser, you’ll get exactly the desired result
    that we saw in figure 8.5.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！我们现在有一个样式精美的联系表单，其中包含一些非常聪明的焦点监听器。如果您在浏览器中运行它，您将得到与图8.5中看到的结果完全一致的结果。
- en: In the rest of this section, we’ll discuss in a lot more detail how event propagation
    works from a technical perspective. First, we’ll cover events in HTML and JavaScript
    in general, and later, events in React specifically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将更详细地讨论从技术角度如何实现事件传播。首先，我们将涵盖HTML和JavaScript中的事件，然后是React中的事件。
- en: 8.3.1 How phases and propagation work in the browser
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 浏览器中阶段和传播的工作原理
- en: React events bubble, as just mentioned. HTML events also bubble. When you click
    a button, every ancestor of that button will dispatch an event. They will dispatch
    two events—one *before* the target element itself and one *after* the target element
    itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚才提到的，React事件会冒泡。HTML事件也会冒泡。当您点击一个按钮时，该按钮的所有祖先节点都会派发事件。它们将派发两个事件——一个在目标元素本身之前，一个在目标元素本身之后。
- en: Note This subsection is about events in HTML in general, and not React specifically.
    We need to cover this topic first in order for you to better understand how events
    in React work. In the next subsections, we’ll discuss event phases in React specifically,
    which are slightly different.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本小节是关于HTML中一般事件的，而不是专门关于React的。我们需要先介绍这个主题，以便您更好地理解React中事件的工作方式。在接下来的小节中，我们将具体讨论React中的事件阶段，它们略有不同。
- en: 'Previously, we discussed events bubbling, which is what happens when the ancestors
    dispatch an event *after* the event has already dispatched to the target element.
    However, all events also *capture*, which is what happens *before* the event is
    dispatched to the target element. The three stages of event dispatches are as
    follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了事件冒泡，这是在事件已经派发到目标元素之后，祖先节点派发事件的情况。然而，所有事件也会*捕获*，这是在事件派发到目标元素之前发生的情况。事件派发的三个阶段如下：
- en: '*Capture phase*—Events are dispatched to all parent DOM nodes in descending
    order, starting with the window element, going through every ancestor, and ending
    at the parent of the target element.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*捕获阶段*—事件按降序派发到所有父DOM节点，从窗口元素开始，经过每个祖先节点，直到目标元素的父节点。'
- en: '*Target phase*—An event is dispatched to the target element itself.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标阶段*—事件被派发到目标元素本身。'
- en: '*Bubble phase*—Events are dispatched to all parent DOM nodes in ascending order,
    starting with the parent of the target element and moving up through the ancestors
    until the window element'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冒泡阶段*—事件按顺序派发到所有父DOM节点，从目标元素的父节点开始，向上移动到祖先节点，直到窗口元素'
- en: See figure 8.7 for an illustration of this. This entire concept is called *event
    propagation*. An event propagates first in the capture phase from the window object
    “down” to the target element and then proceeds to propagate back “up” to the window
    object in the bubble phase.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅图8.7以了解这一过程的说明。整个概念被称为*事件传播*。事件首先在捕获阶段从窗口对象“向下”传播到目标元素，然后在冒泡阶段继续传播回窗口对象。
- en: '![08-07](../Images/08-07.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![08-07](../Images/08-07.png)'
- en: Figure 8.7 When you click the black button, the browser will start propagating
    events throughout the nodes in the document starting at the window, moving down
    through the document tree in the capture phase until the target, and then moving
    back up the tree in the bubbling phase until it reaches the window.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 当您点击黑色按钮时，浏览器将从窗口开始在整个文档节点中传播事件，从捕获阶段开始向下通过文档树，直到目标，然后在冒泡阶段向上移动到窗口。
- en: When you want to listen for an event on a particular element, you can specify
    in which phase you’re listening to the event. The default is to listen for an
    event in the bubbling and target phases, but you can add an argument to listen
    for events in the capture phase specifically.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在特定元素上监听事件时，您可以指定在哪个阶段监听该事件。默认情况下，监听冒泡和目标阶段的事件，但您可以添加一个参数来专门监听捕获阶段的事件。
- en: 'In JavaScript, you add a listener (bubble and target) by simply calling addEventListener
    with the event and callback function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你通过简单地调用addEventListener并传递事件和回调函数来添加监听器（冒泡和目标）：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you wanted to use a capture listener instead, you would have to add a third
    argument with an object:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用捕获监听器，你必须添加一个带有对象的第三个参数：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you receive an event, you can check the .eventPhase property of the event
    object to see which event phase it belongs to. The possible values are listed
    here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到一个事件时，你可以检查事件对象的 `.eventPhase` 属性以查看它属于哪个事件阶段。可能的值在此列出：
- en: Event.CAPTURING_PHASE (1) for capture
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Event.CAPTURING_PHASE (1) 用于捕获
- en: Event.AT_TARGET (2) for target
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Event.AT_TARGET (2) 用于目标
- en: Event.BUBBLING_PHASE (3) for bubble
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Event.BUBBLING_PHASE (3) 用于冒泡
- en: 'In the example in figure 8.7, a total of 14 potential events will be sent in
    this exact order:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在图8.7的示例中，总共将按以下顺序发送14个潜在事件：
- en: 'Capture phase:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获阶段：
- en: Capture event dispatched on window
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口上派发捕获事件
- en: Capture event dispatched on document
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档上派发捕获事件
- en: Capture event dispatched on the <html> element
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<html>` 元素上派发捕获事件
- en: Capture event dispatched on the <body> element
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<body>` 元素上派发捕获事件
- en: Capture event dispatched on the <header> element
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<header>` 元素上派发捕获事件
- en: Capture event dispatched on the <nav> element
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<nav>` 元素上派发捕获事件
- en: 'Target phase:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标阶段：
- en: Target event (registered as capture listener) dispatched on the <button> element
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标事件（注册为捕获监听器）在 `<button>` 元素上派发
- en: Target event (registered as bubble listener) dispatched on the <button> element
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标事件（注册为冒泡监听器）在 `<button>` 元素上派发
- en: 'Bubbling phase:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡阶段：
- en: Bubble event dispatched on the <nav> element
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<nav>` 元素上派发冒泡事件
- en: Bubble event dispatched on the <header> element
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<header>` 元素上派发冒泡事件
- en: Bubble event dispatched on the <body> element
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<body>` 元素上派发冒泡事件
- en: Bubble event dispatched on the <html> element
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<html>` 元素上派发冒泡事件
- en: Bubble event dispatched on document
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档上派发冒泡事件
- en: Bubble event dispatched on window
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口上派发冒泡事件
- en: Events 2.a and 2.b might seem similar, but they will be grouped first into all
    dispatches to listeners defined as capture listeners, and then into dispatches
    to listeners defined as bubble listeners. You can, of course, have multiple listeners
    listening to the same event on the same target. If that happens, events will be
    dispatched in order of assignment of the listeners.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 事件2.a和2.b可能看起来很相似，但它们首先将被分组到所有派发到定义为捕获监听器的监听器中，然后是派发到定义为冒泡监听器的监听器中。当然，你可以在同一个目标上对同一个事件有多个监听器。如果发生这种情况，事件将按监听器分配的顺序派发。
- en: Let’s make a simplified view of the previous figure with only three elements
    in descending order in figure 8.8.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在图8.8中用一个简化视图来表示前面的图，其中只包含三个元素，按降序排列。
- en: '![08-08](../Images/08-08.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![08-08](../Images/08-08.png)'
- en: Figure 8.8 Three elements in descending order
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 降序排列的三个元素
- en: 'Let’s say that we add a number of listeners to the different elements in this
    order:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们按以下顺序向不同元素添加多个监听器：
- en: Add a capture listener to <nav> element
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将捕获监听器添加到 `<nav>` 元素
- en: Add a bubble listener to <button> element
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将冒泡监听器添加到 `<button>` 元素
- en: Add a capture listener to <button> element
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次将捕获监听器添加到 `<button>` 元素
- en: Add a capture listener to <header> element
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将捕获监听器添加到 `<header>` 元素
- en: Add a capture listener to <nav> element (again)
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次将捕获监听器添加到 `<nav>` 元素
- en: Add a capture listener to <button> element (again)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次将捕获监听器添加到 `<button>` 元素
- en: Add a bubble listener to <nav> element
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将冒泡监听器添加到 `<nav>` 元素
- en: 'These eight listeners (A through G) will be invoked in this order:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这八个监听器（A到G）将按以下顺序调用：
- en: 'Capture listeners on <header>: D (eventPhase=CAPTURING_PHASE)'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<header>` 上的捕获监听器：D (事件阶段=CAPTURING_PHASE)
- en: 'Capture listeners on <nav>: A, E (eventPhase=CAPTURING_PHASE)'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<nav>` 上的捕获监听器：A, E (事件阶段=CAPTURING_PHASE)
- en: 'Capture listeners on <button>: C, F (eventPhase=AT_TARGET)'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<button>` 上的捕获监听器：C, F (事件阶段=AT_TARGET)
- en: 'Bubble listeners on <button>: B (eventPhase=AT_TARGET)'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<button>` 上的冒泡监听器：B (事件阶段=AT_TARGET)
- en: 'Bubble listeners on <nav> element: G (eventPhase: BUBBLING_PHASE)'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `<nav>` 元素上的冒泡监听器：G (事件阶段: BUBBLING_PHASE)'
- en: 'Bubble listeners on <header> element: *None*'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<header>` 元素上的冒泡监听器：*无*
- en: Note that even though the listeners on the target element itself will be dispatched
    in the order of capturing listeners first, then bubbling listeners second, they
    will all be invoked with an event phase of AT_TARGET, rather than capturing and
    bubbling phases, respectively.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管目标元素上的监听器将按捕获监听器先派发，然后是冒泡监听器的顺序派发，但它们都将使用事件阶段AT_TARGET，而不是分别使用捕获和冒泡阶段。
- en: 8.3.2 Handling event phases in React
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 在React中处理事件阶段
- en: Events in React aren’t added by adding a listener to a node using a method.
    Events in React are added by assigning a property to the JSX element that represents
    that node. Because of that, you can’t add an argument to say which phase you’re
    listening to an event in. In React, as in JavaScript, the default is to add events
    as bubble listeners. When you write
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，事件不是通过在节点上添加监听器来添加的。在React中，事件是通过将属性分配给表示该节点的JSX元素来添加的。因此，你无法添加一个参数来说明你正在监听事件的哪个阶段。在React中，就像在JavaScript中一样，默认情况下是将事件添加为冒泡监听器。当你写下
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: this onClickHandler would be added as a bubble phase listener. If you want to
    add a capture event listener, you have to postfix the event with *Capture. For
    a click handler, that would be onClickCapture. So, if you have
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个onClickHandler将被添加为冒泡阶段监听器。如果你想添加捕获事件监听器，你必须将事件后缀为*Capture*。对于一个点击处理程序，那就是onClickCapture。所以，如果你有
- en: '[PRE21]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: these click handlers would be invoked as handler1, handler2, handler3, and then
    handler4.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点击处理程序将被调用为handler1、handler2、handler3，然后是handler4。
- en: Capture handlers are pretty rare. You’ll likely never use them or maybe use
    them only once or twice in a huge application, but they’re a great tool to have
    available when you really need them. They’re the julienne peelers of React—rarely
    used, but when they are, they are perfect for the job!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获处理程序相当罕见。你可能永远不会使用它们，或者在一个大型应用程序中可能只使用一两次，但当你真正需要它们时，它们是一个非常好的工具。它们是React的细丝皮削器——很少使用，但使用时却非常适合这项工作！
- en: 8.3.3 Unusual event propagation
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 不寻常的事件传播
- en: Four event types have a very unusual event propagation flow in React. This concerns
    the pairs mouseEnter/mouseLeave and pointerEnter/pointerLeave. These pairs of
    events are related, as the mouse or pointer will enter one element as it leaves
    the other. The propagation of these events bubble from the element being left
    to the element being entered, and they don’t capture.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种事件类型在React中有非常不寻常的事件传播流程。这涉及到鼠标进入/离开和指针进入/离开这对。这些事件相关联，因为鼠标或指针在离开一个元素的同时会进入另一个元素。这些事件的传播是从离开的元素冒泡到进入的元素，并且它们不捕获。
- en: 'Please see the following article for details on this flow if you ever need
    it: [https://barklund.dev/mouseevents](https://barklund.dev/mouseevents). It would
    only come up in some very specialized cases though, so this is probably not something
    you need to worry about.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要有关此流程的详细信息，请参阅以下文章：[https://barklund.dev/mouseevents](https://barklund.dev/mouseevents)。这只会出现在一些非常特殊的情况下，所以这可能不是你需要担心的事情。
- en: 8.3.4 Nonbubbling DOM events
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 非冒泡DOM事件
- en: 'In the DOM, some events don’t bubble at all, but they still capture. This only
    happens for blur and focus events. However, in React, for ease of use, both of
    these events still bubble as normal, like other events. So, let’s say you have
    this structure in React:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在DOM中，一些事件根本不冒泡，但它们仍然捕获。这仅发生在失焦和焦点事件上。然而，在React中，为了方便使用，这两个事件仍然像其他事件一样冒泡。所以，假设你在React中有以下结构：
- en: '[PRE22]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you put the cursor inside the input field, the three event handlers would
    fire in this order: handler1, handler2, handler3. If you implemented the same
    thing without React and added the event listeners using JavaScript, handler3 would
    never fire because it’s an event in the bubbling phase of an event type that doesn’t
    bubble.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将光标放在输入字段内，三个事件处理程序将按以下顺序触发：handler1、handler2、handler3。如果你在没有React的情况下实现相同的功能并使用JavaScript添加事件监听器，handler3永远不会触发，因为它是一个不冒泡的事件类型的冒泡阶段的事件。
- en: There is a technical reason for these events not bubbling in HTML, but because
    it’s pretty confusing for developers (and very easy to forget), React simply bubbles
    these events as well. As a React developer, you don’t need to worry about this
    and can just use the focus and blur events as normal events, which we actually
    already did in the beginning of this section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件在HTML中不冒泡有一个技术原因，但因为它对开发者来说非常令人困惑（而且很容易忘记），React简单地也将这些事件冒泡。作为一个React开发者，你不需要担心这个问题，可以直接像使用正常事件一样使用焦点和失焦事件，实际上我们在本节的开始就已经这样做了。
- en: Why focus and blur events don’t bubble in HTML
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么焦点和失焦事件在HTML中不冒泡
- en: When the window loses focus by the user (because the user switches tabs in the
    browser or even switches to a different program), a blur event will be dispatched
    on the window object. Similarly, when the window regains focus by a user returning
    to the same window/tab in the browser, a focus event will be dispatched on the
    window object.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过切换浏览器标签或切换到不同的程序使窗口失去焦点时，将在window对象上触发一个blur事件。同样，当用户返回到浏览器中的相同窗口/标签时，窗口将重新获得焦点，并在window对象上触发一个focus事件。
- en: If a focus or blur event on an input field or button bubbled, it would have
    to bubble all the way up to the window object. Then, you as a developer could
    be confusing the event for the window losing/gaining focus by the user. You would
    be able to tell the two occurrences apart by examining the .target property of
    the event, but for historical reasons, these events don’t bubble simply to make
    sure this confusion doesn’t happen.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入字段或按钮上的focus或blur事件冒泡，它必须冒泡到window对象。然后，作为开发者，您可能会因为用户使窗口失去/获得焦点而混淆事件。您可以通过检查事件的.target属性来区分这两种情况，但出于历史原因，这些事件不会简单地冒泡，以确保不会发生这种混淆。
- en: In React, that’s not a problem because you can’t assign a React event listener
    to the window object. You can only assign React event listeners to actual HTML
    elements (and the window object isn’t an HTML element) and only those inside your
    application (which goes somewhere inside the <body> element). For this reason,
    focus and blur events *do* bubble in React.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，这不是问题，因为您不能将React事件监听器分配给window对象。您只能将React事件监听器分配给实际的HTML元素（并且window对象不是HTML元素），并且仅限于您应用程序内部的元素（这些元素位于<body>元素内部）。因此，在React中，focus和blur事件*确实*会冒泡。
- en: 8.4 Default actions and how to prevent them
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 默认操作及其防止方法
- en: Browsers have default actions as the consequence of some events. Most of the
    time, you as a developer want these default actions to occur, but sometimes you
    don’t. In this next example, we’ll see a default action that you don’t want the
    browser to do, and we’ll see how to prevent it from happening.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器在某些事件发生后会有默认操作。大多数时候，作为开发者，您希望这些默认操作发生，但有时您不希望这样。在下一个示例中，我们将看到一个您不希望浏览器执行默认操作，并展示如何防止其发生。
- en: Let’s say we want to create an administrator login form in React with a password
    field and a login button. When the user clicks the button, we want our code to
    check if the password matches the secret string "platypus". If it does, whatever
    secret information we have inside our application should be revealed to the clearly
    legit administrator. Let’s start by creating this in the following listing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在React中创建一个管理员登录表单，其中包含密码字段和登录按钮。当用户点击按钮时，我们希望我们的代码检查密码是否与秘密字符串"platypus"匹配。如果是，我们应用程序内部的所有秘密信息都应该向显然合法的管理员揭示。让我们从以下列表开始创建这个功能。
- en: Listing 8.7 Admin form (potentially broken?)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 管理员表单（可能已损坏？）
- en: '[PRE23]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Stores the entered password in a state value
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将输入的密码存储在状态值中
- en: ❷ Stores whether the user is approved as an admin user in another state value
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在另一个状态值中存储用户是否被批准为管理员用户
- en: ❸ When the user clicks the button, checks if the entered password matches the
    expectation and, if so, updates the state
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当用户点击按钮时，检查输入的密码是否与预期匹配，如果是，则更新状态
- en: ❹ Displays conditional JSX depending on whether the user is approved as an admin
    user or not
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 根据用户是否被批准为管理员用户显示条件JSX
- en: ❺ Our input field will update the state password when changed.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们输入字段会在更改时更新状态password。
- en: ❻ Our button will call the event handler when clicked.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 我们按钮在被点击时会调用事件处理器。
- en: If you spin this up in a browser, enter something into the input field, and
    click the button, something unexpected happens. The whole page reloads, and the
    input field is cleared. That’s not at all what we wanted here and seems like a
    completely arbitrary result. Why did this happen?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开它，输入一些内容到输入字段，并点击按钮，会发生一些意外的事情。整个页面重新加载，输入字段被清除。这完全不是我们想要的，看起来像是一个完全随机的结果。为什么会发生这种情况？
- en: 8.4.1 The default event action
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 默认事件操作
- en: If we create an HTML form with a button on a webpage and click the button, the
    page will reload. This is the default behavior in HTML.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在网页上创建一个带有按钮的HTML表单并点击该按钮，页面将重新加载。这是HTML中的默认行为。
- en: 'Let’s say we put this HTML (note that we’re talking about plain HTML at this
    point, not JSX) into a file and open it in a browser:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将以下HTML（注意我们现在谈论的是纯HTML，而不是JSX）放入一个文件并在浏览器中打开它：
- en: '[PRE24]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Clicking this button reloads the page. That’s because a button inside a form
    causes the form to submit, and when a form submits, the variables inside the form
    will be sent to the target URL of the form. This happens even if the form doesn’t
    have any inputs and even if the form doesn’t have an explicit target URL (the
    default target URL is the page itself).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮会重新加载页面。这是因为表单内的按钮会导致表单提交，当表单提交时，表单内的变量将被发送到表单的目标URL。即使表单没有任何输入，即使表单没有显式的目标URL（默认目标URL是页面本身），这种情况也会发生。
- en: Knowing this information, we now see what we did wrong before. Our button inside
    our application would submit the form, and submitting a form causes the page to
    reload by default.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些信息后，我们现在可以看到之前我们犯了什么错误。我们应用程序内的按钮会提交表单，提交表单会导致页面默认重新加载。
- en: 8.4.2 Preventing default
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 防止默认行为
- en: With our newfound knowledge, we’ll do two things in our form to make it work
    correctly. First, we’ll move the event handler from clicking the button to submitting
    the form. It’s the same handler, we just assign it to the onSubmit property of
    the form rather than the onClick property of the button.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们新获得的知识，我们将在表单中做两件事以使其正确工作。首先，我们将事件处理程序从点击按钮移动到提交表单。这是同一个处理程序，我们只是将其分配给表单的onSubmit属性，而不是按钮的onClick属性。
- en: Second, we need to tell the form not to perform the default action that it normally
    does when submitting. We do that by invoking evt.preventDefault() on the event
    object passed to the event handler. Let’s implement this in the next listing.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要告诉表单不要执行它通常在提交时执行的默认操作。我们通过在传递给事件处理程序的事件对象上调用evt.preventDefault()来实现这一点。让我们在下一个列表中实现这一点。
- en: Listing 8.8 Admin form (potentially fixed?)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 管理表单（可能已修复？）
- en: '[PRE25]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Accepts the event object as an argument to the event handler in order to prevent
    the default action
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将事件对象作为参数传递给事件处理程序以防止默认操作
- en: ❷ Invokes the evt.preventDefault method in the submit handler regardless of
    what else happens in the handler
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在提交处理程序中调用 evt.preventDefault() 方法，无论处理程序中发生什么
- en: ❸ Connects the event handler to the form element
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将事件处理程序连接到表单元素
- en: 'Repository: rq08-admin'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq08-admin
- en: 'This example can be seen in repository rq08-admin. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq08-admin存储库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE26]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的运行情况，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq08-admin](https://rq2e.com/rq08-admin)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-admin](https://rq2e.com/rq08-admin)'
- en: And there we go. Our admin form works as intended! We prevented the default
    event from happening in our form, so the browser native event handler didn’t kick
    in. You can see the result in figure 8.9.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们的管理表单按预期工作！我们在表单中阻止了默认事件的发生，因此浏览器原生的事件处理程序没有启动。您可以在图 8.9 中看到结果。
- en: '![08-09](../Images/08-09.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![08-09](../Images/08-09.png)'
- en: Figure 8.9 The admin login form works, and when we enter the correct password,
    the secrets of the universe are revealed to us (and apparently those secrets are
    delicious).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 管理登录表单工作正常，当我们输入正确的密码时，宇宙的秘密就展现在我们面前（而且显然这些秘密很美味）。
- en: If you press Enter while focusing an input field inside a form that also has
    a Submit button, the form will be submitted. If we just put our event handler
    on the button as onClick, submitting the form by pressing Enter with focus in
    the input field would not work as intended, and it would still reload the page
    because of form submission. By moving our handler to the form’s submit event,
    we handle both ways of submitting a form.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在表单内具有提交按钮的输入字段中按下Enter键，表单将被提交。如果我们只是将事件处理程序放在按钮上作为onClick，则在输入字段中聚焦时按下Enter键提交表单将不会按预期工作，并且由于表单提交，页面仍然会重新加载。通过将我们的处理程序移动到表单的提交事件上，我们处理了两种提交表单的方式。
- en: Note This example is, of course, not in any way proper web security. Anything
    that happens in React is readable by any visitor on your web page, and the preceding
    security would be compromised in seconds. Be sure to use proper web architecture
    for creating secure logins.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当然，这个示例在网络安全方面并不恰当。在React中发生的任何事情都可以被您的网页上的任何访客读取，并且上述安全措施会在几秒钟内被破坏。请确保使用适当的网络架构来创建安全的登录。
- en: 8.4.3 Other default events
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 其他默认事件
- en: Form submit events have a default action, where the form actually submits to
    the target URL with all the values entered into the form. This is one of the default
    events used in the browser, but definitely not the only one.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 表单提交事件有一个默认操作，即表单实际上会提交到目标URL，并包含表单中输入的所有值。这是浏览器中使用的默认事件之一，但绝对不是唯一的一个。
- en: Clicking a link will create a click event on the link element. The default action
    for this event is to follow the link and go to the new URL as indicated by the
    href property. Again, you can prevent this default behavior by invoking the .preventDefault()
    method on the click event object received in an event handler. This would mean
    the browser wouldn’t go to the target URL, and effectively nothing would happen.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接将在链接元素上创建一个点击事件。此事件的默认操作是遵循链接并转到由href属性指示的新URL。同样，您可以通过在事件处理程序中接收到的点击事件对象上调用.preventDefault()方法来防止此默认行为。这意味着浏览器不会转到目标URL，实际上什么都不会发生。
- en: 'You can check if an event is cancellable by checking the .cancellable property.
    If true, .preventDefault() can be invoked to stop whatever the browser’s default
    action would have been. If false, invoking .preventDefault() is still possible,
    but it just doesn’t do anything. Here’s an inexhaustive list of cancellable events:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查.cancellable属性来检查事件是否可取消。如果是true，则可以调用.preventDefault()来阻止浏览器执行默认操作。如果是false，调用.preventDefault()仍然是可能的，但它不会做任何事情。以下是一个不完整的可取消事件列表：
- en: Scroll events are cancellable, which causes the scroll not to occur and the
    scroll offset to remain unchanged.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动事件是可取消的，这会导致滚动不会发生，并且滚动偏移量保持不变。
- en: Key-down, key-press, and key-up events are cancellable and cause the character
    to not be inserted (if invoked on an input field or text area) or cause whatever
    the browser would do in case of the given key *not* to happen (e.g., make the
    browser not scroll the page when canceling the press of Page Up). On the other
    hand, input events aren’t cancellable as they are dispatched after the fact (e.g.,
    after the user typed something or pasted something).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘按下、按键和键盘抬起事件是可取消的，这会导致字符不会被插入（如果是在输入字段或文本区域中调用）或者防止浏览器执行给定键的默认操作（例如，在取消Page
    Up的按下时，使浏览器不滚动页面）。另一方面，输入事件是不可取消的，因为它们是在事实发生后分发的（例如，在用户输入某些内容或粘贴某些内容之后）。
- en: Drag-start and drag-enter events are cancellable (respectively, causing the
    drag not to happen at all or causing the drag effect to remain unchanged), but
    the drag-end and drag-leave events aren’t cancellable.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动开始和拖动进入事件是可取消的（分别，导致根本不发生拖动或导致拖动效果保持不变），但拖动结束和拖动离开事件是不可取消的。
- en: React follows the same procedures for default actions and preventable actions
    as HTML, so refer to any online HTML guide on which events are cancellable and
    what the default action is.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: React遵循与HTML相同的默认操作和可预防操作的程序，因此请参考任何在线HTML指南，了解哪些事件是可取消的以及默认操作是什么。
- en: 8.5 React event objects in summary
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 React事件对象总结
- en: We’ve seen a number of different ways to use the event object that React sends
    to an event handler. Table 8.2 lists a subset of properties that all event objects
    have in common. A lot of these properties have already been explained in detail
    in this chapter. These aren’t all the properties available on all event objects,
    but in our opinion, they are the most important ones.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多使用React发送到事件处理程序的事件对象的不同方法。表8.2列出了所有事件对象共有的属性子集。这些属性中的许多已经在本章中详细解释过。这些并不是所有事件对象上可用的所有属性，但据我们意见，它们是最重要的。
- en: Table 8.2 Important properties common for all event objects in both React and
    HTML
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 React和HTML中所有事件对象共有的重要属性
- en: '| Property | Purpose |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 目的 |'
- en: '| bubbles | A Boolean value indicating whether or not the event bubbles |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 冒泡 | 一个布尔值，表示事件是否冒泡 |'
- en: '| cancelable | A Boolean value indicating whether or not the event can be canceled
    |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 可取消 | 一个布尔值，表示事件是否可以被取消 |'
- en: '| eventPhase | A numerical value indicating which phase in the event propagation
    this event belongs to |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 事件阶段 | 一个数值，表示事件传播中此事件属于哪个阶段 |'
- en: '| preventDefault | A method to prevent the browser from handling the event
    with its default action |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| preventDefault | 防止浏览器使用默认操作处理事件的方法 |'
- en: '| stopPropagation | A method to prevent the event from propagating any further
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| stopPropagation | 防止事件进一步传播的方法 |'
- en: '| target | The target node that this event was assigned to |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 目标 | 此事件分配到的目标节点 |'
- en: '| timestamp | The time at which the event was created in milliseconds |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| timestamp | 事件创建的时间，以毫秒为单位 |'
- en: '| type | The type of event that caused this event object to be dispatched |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| type | 导致此事件对象被分发的事件的类型 |'
- en: 8.6 Event handler functions from properties
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 从属性中获取事件处理器函数
- en: When you’re creating reusable UI elements, a vital part is to create generalized
    interface elements that you can then use in other locations without having to
    style them every time. For this purpose, let’s now create a styled generalized
    button component that can be reused over and over. We’ll use this generalized
    button component to create a counter with Increment and Decrement buttons—but
    styled. We want to create something that looks like figure 8.10—look at those
    stylish buttons.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建可重用的UI元素时，一个关键部分是创建通用的接口元素，然后你可以将其用于其他位置，而无需每次都对其进行样式设计。为此，现在让我们创建一个可以重复使用的样式化通用按钮组件。我们将使用这个通用按钮组件来创建一个带有增加和减少按钮的计数器——但具有样式。我们希望创建出像图8.10那样的东西——看看那些时尚的按钮。
- en: '![08-10](../Images/08-10.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![08-10](../Images/08-10.png)'
- en: Figure 8.10 The final application with the counter already increased a few times.
    Don’t these buttons look just a bit nicer than the default ones we’re used to
    seeing?
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 最终应用程序，计数器已经增加了几次。这些按钮看起来是不是比我们习惯看到的默认按钮要好看一点？
- en: We’ll structure the application shown in the JSX diagram in figure 8.11.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照图8.11中的JSX图结构化所示的应用程序。
- en: '![08-11](../Images/08-11.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![08-11](../Images/08-11.png)'
- en: Figure 8.11 Our styled counter application will include two instances of our
    button component with slightly different properties.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 我们定制的计数器应用程序将包含两个具有略微不同属性的按钮组件实例。
- en: As you can see, we’ll pass a function, handleClick, to each of the button component
    instances, which should internally be assigned to the button as the click handler.
    Let’s implement this in listing 8.9.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将传递一个函数，handleClick，到每个按钮组件实例，它应该内部被分配为按钮的点击处理器。让我们在列表8.9中实现这一点。
- en: Listing 8.9 Styled counter
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 样式化计数器
- en: '[PRE27]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Directly assigns the received handleClick property as the onClick event handler
    inside the button component
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 直接将接收到的handleClick属性作为按钮组件内的onClick事件处理器
- en: ❷ When buttons are clicked, sets the handleClick property to a function updating
    the state
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当按钮被点击时，将handleClick属性设置为更新状态的函数
- en: 'Repository: rq08-styled-counter'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq08-styled-counter
- en: 'This example can be seen in repository rq08-styled-counter. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq08-styled-counter存储库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE28]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq08-styled-counter](https://rq2e.com/rq08-styled-counter)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-styled-counter](https://rq2e.com/rq08-styled-counter)'
- en: This looks pretty good and is a nice, compact, well-defined application. However,
    something is slightly weird. When we use our button components, we assign a function
    that should be invoked when the button is clicked. However, in listing 8.9, because
    we assign the function directly as the onClick property to the button, the function
    is invoked with an event object as the first and only argument. Sometimes, this
    might be a good solution, but other times this isn’t ideal. The outside component
    should not have access to this event object because it’s an internal implementation
    detail of the button component.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当不错，是一个很好、紧凑、定义良好的应用程序。然而，有一点稍微有点奇怪。当我们使用我们的按钮组件时，我们分配了一个当按钮被点击时应调用的函数。然而，在列表8.9中，因为我们直接将函数作为onClick属性分配给按钮，所以函数以事件对象作为第一个和唯一的参数被调用。有时，这可能是一个好的解决方案，但有时这并不理想。外部组件不应访问此事件对象，因为它按钮组件的内部实现细节。
- en: 'To remove this event from the function invocation, we have to create another
    function as the event handler and, when invoked, call the handleClick property
    (without any arguments). That would look something like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要从函数调用中移除此事件，我们必须创建另一个函数作为事件处理器，并在调用时调用handleClick属性（不带任何参数）。这看起来可能像这样：
- en: '[PRE29]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Still receives a handleClick property as before
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仍然像以前一样接收handleClick属性
- en: ❷ Now creates a local function that, when called, invokes the passed property
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 现在创建一个局部函数，当调用时，调用传递的属性
- en: ❸ Assigns this local function as the event handler, not the passed property
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将此局部函数分配为事件处理器，而不是传递的属性
- en: Note that we’ve named the event listener as a property handle*. That is a fairly
    common practice when passing functions as properties to elements that aren’t directly
    event listeners themselves, but rather just callbacks that will be invoked by
    event listeners or effects as needed. We could also have named this property onClick,
    but that would make it seem like an event listener, and users would expect it
    to act as an event listener (and we would definitely have to send the event object
    to it as an argument).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将事件监听器命名为一个 handle* 属性。这是一种相当常见的做法，当将函数作为属性传递给不是直接事件监听器本身，而是作为回调函数（根据需要由事件监听器或效果调用）的元素时。我们也可以将这个属性命名为
    onClick，但这样会让人误以为它是一个事件监听器，用户会期望它作为事件监听器行事（而且我们肯定必须将事件对象作为参数发送给它）。
- en: You’ll see many examples of function properties invoked as callbacks (either
    directly as event listeners or inside event listeners) in real-life codebases
    because it’s a very common way to design reusable UI component libraries. We’ll
    also use this structure in future chapters. We’ll use on* naming for direct event
    handlers (that receive an event object) and handle* naming for callbacks (that
    either don’t take any arguments or take some custom arguments).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在现实世界的代码库中看到许多将函数属性作为回调调用的例子（要么直接作为事件监听器，要么在事件监听器内部），因为这是一种非常常见的用于设计可重用 UI
    组件库的方法。我们也会在未来的章节中使用这种结构。我们将使用 on* 命名来为直接事件处理程序（接收事件对象）命名，并使用 handle* 命名来为回调（要么不带任何参数，要么带一些自定义参数）命名。
- en: 8.7 Event handler generators
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 事件处理程序生成器
- en: 'If you have many event handler functions that only vary slightly, you might
    want to generalize them into an *event handler generator*. Let’s take our earlier
    example of a counter with Increment and Decrement buttons. We generalized these
    two different functions into a single function that updates the value based on
    an argument, and then we called *that* function with different arguments in the
    click event handler on the two buttons:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多只有细微差别的事件处理程序函数，你可能希望将它们泛化成一个 *事件处理程序生成器*。让我们以我们之前的例子为例，一个带有增加和减少按钮的计数器。我们将这两个不同的函数泛化成一个基于参数更新值的单个函数，然后在两个按钮的点击事件处理程序中用不同的参数调用
    *这个* 函数：
- en: '[PRE30]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ A generic function for updating the counter value with a delta
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个用于使用 delta 更新计数器值的通用函数
- en: ❷ Invokes update with two different values in the event handlers
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在事件处理程序中调用 update 并使用两个不同的值
- en: 'We can take this concept one step further. Note that in both event handlers,
    we’re still defining a function that then calls update (both have an arrow definition
    such as () => update). We can move that function definition inside the update
    function with a *curried* function. This turns the update function into an event
    handler *generator*, which returns an event handler when invoked. So, it’s a function
    that returns another function:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个概念进一步发展。请注意，在这两个事件处理程序中，我们仍然在定义一个函数，然后调用 update（两者都有箭头定义，如 () => update）。我们可以使用一个
    *柯里化* 函数将这个函数定义移到 update 函数内部。这使得 update 函数成为一个事件处理程序 *生成器*，当被调用时返回一个事件处理程序。所以，这是一个返回另一个函数的函数：
- en: '[PRE31]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ A generic event handler generator for updating the counter value with a delta
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个用于使用 delta 更新计数器值的通用事件处理程序生成器
- en: ❷ Invokes the event handler generator in the event handlers to generate an event
    handler with a specific delta
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在事件处理程序中调用事件处理程序生成器以生成具有特定 delta 的事件处理程序
- en: This might look a bit esoteric, and it’s not essential that you fully understand
    the logic here. Just note that this is a fairly common approach used by many developers,
    so you might see it in your everyday work. We’ll revisit this approach of using
    event handler generators in the next chapter on event handling in forms, so you’ll
    get some more experience with the concept there.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点晦涩，而且你并不需要完全理解这里的逻辑。只需注意，这是一种许多开发者常用的相当常见的方法，所以你可能会在日常工作中看到它。我们将在下一章关于表单事件处理中重新审视使用事件处理程序生成器的方法，这样你就可以在那里获得更多关于这个概念的经验。
- en: 8.8 Listening to DOM events manually
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 手动监听 DOM 事件
- en: 'Sometimes, you want to be able to listen for events on nodes not directly controlled
    by React, whereas other times, you want to manually control whether to listen
    for events at all. For both of these purposes, you can listen for events directly
    on the DOM nodes in regular JavaScript, circumventing React’s event listener setup.
    Here are some example situations where you might want to manually manage event
    listeners:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你希望能够在不由React直接控制的节点上监听事件，而有时，你希望手动控制是否监听事件。为了这两个目的，你可以在常规JavaScript中直接在DOM节点上监听事件，绕过React的事件监听器设置。以下是一些你可能想要手动管理事件监听器的情况示例：
- en: You want to listen for events on the window or document object.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想监听窗口或文档对象上的事件。
- en: You want to listen for events on HTML nodes not directly included inside the
    React application, such as body, which can never be inside your React application,
    but could also just be some node outside of the control of the React application.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在HTML节点上监听事件，这些节点不是直接包含在React应用程序中的，例如body，它永远不可能在React应用程序内部，但也可能是React应用程序控制之外的某个节点。
- en: You want to listen for events on non-DOM objects, such as a request, socket,
    or any other JavaScript object.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在非DOM对象上监听事件，例如请求、套接字或任何其他JavaScript对象。
- en: You want to listen for a single event on a particular node but don’t care about
    more than one instance of the event occurring.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在特定节点上监听单个事件，而不关心事件发生的多个实例。
- en: You want to conditionally listen for an event on a node.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想有条件地监听节点上的事件。
- en: The first three examples in this list are only possible by listening directly
    on the nodes, but the two latter two are still possible using React. However,
    both would require extra work that might not be necessary. In the following subsection,
    you’ll see how to achieve each of the items in the preceding list through manually
    listening to DOM events by going outside of the React architecture.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的前三个示例只能通过直接在节点上监听来实现，但后两个示例仍然可以使用React实现。然而，两者都可能需要额外的工作，这可能不是必要的。在下面的子节中，你将看到如何通过在React架构之外手动监听DOM事件来实现前面列表中的每一项。
- en: 8.8.1 Listening for window and document events
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.1 监听窗口和文档事件
- en: Let’s say that we want to display the size of the browser window in our application.
    We can display the size of the browser window when the component renders the first
    time by looking at window.innerWidth and window.innerHeight. But if the user resizes
    the window while our component is mounted, it won’t automatically re-render, and
    we won’t update our displayed value.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在应用程序中显示浏览器窗口的大小。我们可以在组件首次渲染时通过查看window.innerWidth和window.innerHeight来显示浏览器窗口的大小。但是，如果用户在组件挂载时调整窗口大小，它不会自动重新渲染，我们也不会更新显示的值。
- en: To make sure our component updates when the window resizes, we need to listen
    for the resize event on the window object. Because this is an event not managed
    by React, we need to attach our listener directly on the window object using window
    .addEventListener. But we also need to make sure to remove our event listener
    again if our component unmounts by calling window.removeEventListener.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的组件在窗口大小调整时更新，我们需要监听窗口对象上的resize事件。因为这是一个不由React管理的事件，我们需要直接在窗口对象上使用window.addEventListener附加我们的监听器。但是，我们也需要确保在组件卸载时通过调用window.removeEventListener再次移除我们的事件监听器。
- en: If you remember back to chapter 6 on component life cycles, this might seem
    like a perfect candidate for a useEffect hook—and, it is! We’ll combine this with
    a useState hook to achieve a component that works something like the flowchart
    outlined in figure 8.12\. The implementation in shown in listing 8.10.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起第6章关于组件生命周期的内容，这可能会是一个使用useEffect钩子的完美候选者——而且确实如此！我们将结合useState钩子来实现一个组件，其工作流程类似于图8.12中概述的流程图。实现方式在列表8.10中展示。
- en: '![08-12](../Images/08-12.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![08-12](../Images/08-12.png)'
- en: Figure 8.12 The WindowSize component must add a listener on mount and remove
    it again as the component unmounts. While mounted, the browser will invoke our
    callback if the browser window ever resizes.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 WindowSize组件必须在挂载时添加监听器，并在组件卸载时再次移除。在挂载期间，如果浏览器窗口大小发生变化，浏览器将调用我们的回调函数。
- en: Listing 8.10 Window size display
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 窗口大小显示
- en: '[PRE32]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ First, a little utility function to get a nice display value for the size
    of the browser window
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先，一个实用函数，用于获取浏览器窗口大小的良好显示值
- en: ❷ Uses that utility function to initialize our state value
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用该实用函数来初始化我们的状态值
- en: ❸ Sets up an effect hook
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置一个effect钩子
- en: ❹ Inside this hook, we define a function to be called when the window resizes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在这个钩子内部，我们定义了一个在窗口大小改变时被调用的函数。
- en: ❺ Assigns this function as an event listener directly on the window object
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将此函数直接作为事件监听器分配给窗口对象
- en: ❻ Makes sure that our effect hook returns a cleanup function, which removes
    the listener again
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 确保我们的effect钩子返回一个清理函数，该函数再次移除监听器
- en: ❼ Because it’s an effect hook, we need to set up our dependencies. They only
    contain the setSize function, which we know to be stable, but is included anyway
    for transparency.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 因为它是一个effect钩子，我们需要设置我们的依赖项。它们只包含我们知道的稳定的setSize函数，但仍然包含在内以提高透明度。
- en: ❽ Renders the actual window size in the returned JSX
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 在返回的JSX中渲染实际的窗口大小
- en: 'Repository: rq08-window-size'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq08-window-size
- en: 'This example can be seen in repository rq08-window-size. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq08-window-size仓库中看到。你可以通过创建一个基于相关模板的新应用来使用该仓库：
- en: '[PRE33]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq08-window-size](https://rq2e.com/rq08-window-size)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-window-size](https://rq2e.com/rq08-window-size)'
- en: If you run this app in a browser, you’ll see something like figure 8.13.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中运行此应用，你将看到类似于图8.13的内容。
- en: '![08-13](../Images/08-13.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![08-13](../Images/08-13.png)'
- en: Figure 8.13 The window size app in action with a small window
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 窗口大小应用在小型窗口中的运行情况
- en: This is a very basic example of how to listen for events on a permanent object
    such as a window or document. This is a common approach for a number of events
    that only occur on those two objects or to catch all events of some type that
    bubble all the way up to them.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何监听永久对象（如窗口或文档）上事件的非常基础的例子。这是处理仅在这两个对象上发生的一定数量的事件或捕获某些类型所有冒泡事件的常见方法。
- en: Note the clever use of a cleanup function in our useEffect. Because we define
    our listener function inside the effect, add the listener in the effect, and—in
    case we need to clean up—remove the listener again, this structure works regardless
    of our dependencies and regardless of whether our function mounts and remounts
    several times.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在useEffect中巧妙地使用了清理函数。因为我们定义我们的监听函数在effect内部，添加监听器在effect中，并且——如果我们需要清理——再次移除监听器，这种结构无论我们的依赖项如何，以及我们的函数是否多次挂载和卸载，都是有效的。
- en: However, also note that because we’re not using React’s clever trick of only
    listening to events once and manually remembering who listens for what, we’re
    adding a listener to the window object for every instance of our component. If
    this was an element in a long list of similar elements, we would be adding a new
    listener for every element that we added. That definitely seems pointless if we
    could instead be adding a single listener. When adding events directly on DOM
    nodes, you might have to pay extra attention to how to optimize them.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也请注意，因为我们没有使用React的巧妙技巧，即只监听一次事件并手动记住谁监听什么，所以我们为我们的组件的每个实例添加了一个监听器到窗口对象。如果这是一个长列表中的类似元素之一，我们就会为添加的每个元素添加一个新的监听器。如果我们能够添加单个监听器，这显然是毫无意义的。当直接在DOM节点上添加事件时，你可能需要特别注意如何优化它们。
- en: 8.8.2 Dealing with unsupported HTML events
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.2 处理不受支持的HTML事件
- en: Now let’s look at how to listen for the few DOM events that are *not* supported
    by React, for example, transition events. These events are dispatched by CSS actually,
    when a CSS transition is assigned, started, ended, and canceled. Of these four
    events, only the ended event is supported directly in React, using the onTransitionEnd
    property.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何监听React不支持的一些DOM事件，例如过渡事件。这些事件实际上是由CSS触发的，当CSS过渡被分配、开始、结束和取消时。在这四个事件中，只有ended事件在React中直接支持，使用onTransitionEnd属性。
- en: Let’s create a component with an element with a transition. We want to display
    a text in a transition from red to blue and back again. We’ll trigger this transition
    with two different buttons that set the color directly on the HTML node using
    the node’s style object. We then want to display in the headline whether the transition
    is running or not.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有过渡元素的组件。我们希望显示从红色到蓝色再返回的文本过渡。我们将使用两个不同的按钮来触发这个过渡，这两个按钮直接在HTML节点上使用节点的style对象设置颜色。然后我们想在标题中显示过渡是否正在运行。
- en: While we can listen for the transitionend event in React using the onTransitionEnd
    property, we can’t listen to the transitionstart event in the same way. So, for
    ease of use, we’ll listen for both events using a regular DOM listener. Let’s
    combine all of this in the following listing. You can see the result in figure
    8.14.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在React中使用onTransitionEnd属性监听transitionend事件，但我们不能以同样的方式监听transitionstart事件。因此，为了方便使用，我们将使用常规DOM监听器来监听这两个事件。让我们在下面的列表中将所有这些结合起来。你可以在图8.14中看到结果。
- en: '![08-14](../Images/08-14.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![08-14](../Images/08-14.png)'
- en: Figure 8.14 If you click the two buttons, you’ll see the text change color from
    red to blue to red, and the headline will reflect whether the animation is running
    or not. As a bonus, notice that if you click the Go Red button while the text
    is already red, the transition never starts, so the headline never changes.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 如果你点击两个按钮，你会看到文本颜色从红色变为蓝色再变回红色，标题将反映动画是否正在运行。作为额外奖励，注意如果你在文本已经是红色时点击Go
    Red按钮，过渡永远不会开始，所以标题永远不会改变。
- en: Listing 8.11 Transition events
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 过渡事件
- en: '[PRE34]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Because we need to reference an HTML element, we need to use the useRef hook.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为我们需要引用一个HTML元素，所以我们需要使用useRef钩子。
- en: ❷ Creates two callbacks inside an effect hook to use as listeners
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在effect钩子内部创建两个回调函数作为监听器
- en: ❸ We also need a local variable that points to the DOM element so we can access
    the element in the cleanup function.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们还需要一个指向DOM元素的本地变量，这样我们就可以在清理函数中访问该元素。
- en: ❹ Adds the listeners in the effect hook directly on the DOM element
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在effect钩子中直接在DOM元素上添加监听器
- en: ❺ Removes the same listeners from the same object on cleanup
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在清理时从同一对象中移除相同的监听器
- en: ❻ Sets the ref property on our target element
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在我们的目标元素上设置ref属性
- en: 'Repository: rq08-transition'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq08-transition
- en: 'This example can be seen in repository rq08-transition. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq08-transition仓库中看到。你可以通过创建一个基于相关模板的新应用程序来使用那个仓库：
- en: '[PRE35]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq08-transition](https://rq2e.com/rq08-transition)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-transition](https://rq2e.com/rq08-transition)'
- en: This is an example of one of those unique cases where you need to listen for
    one of the few events not directly supported in React. That’s because this event
    is rarely used in an application, but that doesn’t mean it doesn’t have its use
    cases.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个独特的案例之一，你需要监听React直接不支持的一些事件之一。这是因为这个事件在应用程序中很少使用，但这并不意味着它没有用例。
- en: Applications with complex scenarios are more likely to use direct DOM listeners
    on HTML nodes. In these situations, listeners can change based on other criteria,
    and it makes more sense to manage the event listeners manually rather than relying
    on JSX and React to add and remove listeners for us. We have an example of that
    coming up next.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂场景的应用程序中，更有可能使用直接在HTML节点上的DOM监听器。在这些情况下，监听器可以根据其他标准进行更改，手动管理事件监听器比依赖JSX和React为我们添加和删除监听器更有意义。接下来，我们将看到一个这样的例子。
- en: 8.8.3 Combining React and DOM event handling
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.3 结合React和DOM事件处理
- en: In this example, we’ll use a combination of React’s event listeners with manual
    DOM event listeners. Let’s create a menu that pops up when we click a button,
    and then closes again when we click the mouse anywhere outside the menu. We’ll
    create this application in two iterations. We’ll first implement it in a slightly
    naive way, but as we find a bug, we’ll fix that bug and then implement the component
    correctly.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将结合使用React的事件监听器和手动DOM事件监听器。让我们创建一个当点击按钮时弹出菜单，然后当我们在菜单外部任何地方点击鼠标时再次关闭的菜单。我们将分两个迭代创建这个应用程序。我们首先以一种稍微简单的方式实现它，然后当我们发现一个错误时，我们会修复这个错误，并正确实现组件。
- en: For now, let’s consider the flow of events. We need to listen for clicks on
    the button that open the menu. We know how to do that using onClick in React.
    But then we also need to listen for mouse-down events anywhere when the menu is
    opened. To do that, we need to listen for any mouse down (or pointer down, so
    we also catch touch events) on the window object, and we need to assign this handler
    in an effect hook. This flow of events is illustrated in figure 8.15, and the
    implementation is shown in the next listing.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑事件流。我们需要监听打开菜单的按钮上的点击。我们知道如何使用 React 中的 onClick 来做这件事。但是，我们还需要在菜单打开时监听任何地方的鼠标按下事件。为此，我们需要在窗口对象上监听任何鼠标按下（或指针按下，因此我们也捕获触摸事件），并且我们需要在效果钩子中分配此处理程序。此事件流如图
    8.15 所示，实现将在下一个列表中展示。
- en: '![08-15](../Images/08-15.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![08-15](../Images/08-15.png)'
- en: Figure 8.15 The flowchart that governs our menu component
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 控制我们的菜单组件的事件流程图
- en: Listing 8.12 An expandable menu (naive version)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 可扩展菜单（原始版本）
- en: '[PRE36]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Stores whether the menu is expanded or not in a state value (default false)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在状态值中存储菜单是否展开（默认为 false）
- en: ❷ Aborts early inside our effect hook if the menu isn’t expanded (nothing to
    do, in this case)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果菜单未展开，则在我们的效果钩子内部提前终止（在这种情况下没有要做的）
- en: ❸ If the menu is expanded, we create a listener that will collapse the menu
    again to be invoked when the mouse is clicked anywhere inside the window.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果菜单已展开，我们创建一个监听器，当鼠标在窗口内任何地方点击时，将再次折叠菜单。
- en: ❹ Adds the listener to the window object
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将监听器添加到窗口对象
- en: ❺ Removes the listener again on cleanup
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在清理时再次移除监听器
- en: ❻ Because we have isExpanded in the dependency array, this hook will rerun every
    time the menu changes state from expanded to collapsed and vice versa.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 因为我们在依赖数组中有 isExpanded，所以每当菜单从展开状态变为折叠状态，反之亦然时，此钩子都会重新运行。
- en: ❼ Causes the menu button to simply toggle the expanded flag to true
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 使菜单按钮简单地切换展开标志为 true
- en: ❽ Renders our menu if the expanded flag is true
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 如果展开标志为 true，则渲染我们的菜单
- en: 'Repository: rq08-naive-menu'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq08-naive-menu
- en: 'This example can be seen in repository rq08-naive-menu. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在仓库 rq08-naive-menu 中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE37]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站来浏览代码，直接在您的浏览器中查看应用程序的运行情况，或下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq08-naive-menu](https://rq2e.com/rq08-naive-menu)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-naive-menu](https://rq2e.com/rq08-naive-menu)'
- en: Figure 8.16 shows this application running in the browser. However, there is
    a slight problem. If you try this out, and click *outside* the menu when it’s
    expanded, the menu does correctly close. However, if you click *inside* the menu,
    it also closes. That’s not good. We want the user to be able to interact with
    our menu because we’ll probably have some buttons or links in there at a later
    point.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 显示了该应用程序在浏览器中的运行情况。然而，存在一个小问题。如果你尝试这个，当菜单展开时点击*外部*，菜单会正确关闭。然而，如果你点击*内部*菜单，它也会关闭。这不太好。我们希望用户能够与我们的菜单进行交互，因为我们可能稍后会在这里放置一些按钮或链接。
- en: '![08-16](../Images/08-16.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![08-16](../Images/08-16.png)'
- en: Figure 8.16 The menu app when collapsed and expanded, respectively
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 菜单应用在折叠和展开时的状态
- en: 'What we want is to close the menu only when the user clicks the mouse outside
    the menu, not when they do it inside the menu. The tricky part is to do something
    when clicking the mouse “anywhere” except in a specific location. To do this,
    we’ll use three techniques that we’ve learned so far:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望仅在用户点击菜单外的鼠标时关闭菜单，而不是在菜单内点击时关闭。棘手的部分是在除特定位置外的“任何地方”点击鼠标时执行某些操作。为此，我们将使用我们迄今为止学到的三种技术：
- en: When we expand the menu, we’ll add a listener on the window object for any pointer-down
    events that happen on the window. When invoked, we’ll collapse the menu just like
    before.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们展开菜单时，我们将在窗口对象上添加一个监听器，以监听在窗口上发生的任何指针按下事件。当被调用时，我们将像之前一样折叠菜单。
- en: This time, we’ll also add an event listener on the menu itself that will block
    these pointer events inside it from bubbling to the window object. We do this
    by stopping the propagation of those events.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这次，我们还会在菜单本身上添加一个事件监听器，该监听器将阻止这些指针事件在内部冒泡到窗口对象。我们通过停止这些事件的传播来实现这一点。
- en: Because we’re going to need a reference to our menu DOM node, we need to use
    a useRef hook.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们需要对我们的菜单 DOM 节点的引用，所以我们需要使用 useRef 钩子。
- en: By combining these three things, we’ll ensure that any mouse down *inside the
    window* (even on elements completely outside React’s control) will cause our menu
    to collapse, but any mouse down *inside the menu* won’t cause our menu to collapse
    because we’ve ensured that these events don’t bubble to the window object. We’ve
    captured this flow of events in figure 8.17 and implemented it in listing 8.13.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这三件事，我们将确保任何鼠标点击（即使在完全不受React控制的元素上）都会导致我们的菜单折叠，但任何在菜单内部的鼠标点击都不会导致菜单折叠，因为我们已经确保这些事件不会冒泡到窗口对象。我们在图8.17中捕获了这种事件流，并在列表8.13中实现了它。
- en: '![08-17](../Images/08-17.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![08-17](../Images/08-17.png)'
- en: Figure 8.17 The flowchart that governs our menu component
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 控制我们的菜单组件的流程图
- en: Listing 8.13 An expandable menu
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 可展开菜单
- en: '[PRE38]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Stops pointer events inside the menu itself to close the menu by suppressing
    propagation of pointer events from “escaping” beyond the menu node
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过抑制指针事件从菜单节点“逃逸”的传播来停止菜单内部的指针事件，从而关闭菜单
- en: ❷ Before we assign a listener to the menu element, we need to capture a reference
    to said element via the ref.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在我们为菜单元素分配监听器之前，我们需要通过ref捕获对该元素的引用。
- en: ❸ Adds a listener to the menu element
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为菜单元素添加监听器
- en: ❹ Removes both of these listeners on cleanup
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在清理时移除这两个监听器
- en: ❺ We need a useRef to store our reference to the menu element.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们需要一个useRef来存储我们对菜单元素的引用。
- en: ❻ Assigns our reference to the proper JSX element
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将我们的引用分配给正确的JSX元素
- en: 'Repository: rq08-menu'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq08-menu
- en: 'This example can be seen in repository rq08-menu. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在rq08-menu仓库中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE39]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用程序的实际应用，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq08-menu](https://rq2e.com/rq08-menu)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq08-menu](https://rq2e.com/rq08-menu)'
- en: If you run this app in a browser, you’ll see the same thing as before in figure
    8.16\. Observe that when you expand the menu, you can collapse the menu by clicking
    anywhere except on the menu itself (i.e., except when inside the big box with
    a black border).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中运行此应用程序，您将看到与图8.16中相同的内容。注意，当您展开菜单时，您可以通过点击除菜单本身以外的任何地方来折叠菜单（即，除了在带有黑色边框的大框内）。
- en: Notice how we use a variety of hooks and even combine React event listeners
    with DOM event listeners to achieve this result. All of these low-level elements
    go together nicely in a simple component that does exactly what we want it to
    do.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用各种钩子，甚至将React事件监听器与DOM事件监听器结合起来以实现此结果。所有这些低级元素都很好地组合在一个简单的组件中，该组件正好完成我们想要它做的事情。
- en: 8.9 Quiz
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.9 小测验
- en: What is the correct way to add a click listener to a JSX button?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加点击监听器到JSX按钮的正确方式是什么？
- en: <button click={onClick}>Click me</button>
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <button click={onClick}>点击我</button>
- en: <button click="onClick">Click me</button>
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <button click="onClick">点击我</button>
- en: <button onClick={onClick}>Click me</button>
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <button onClick={onClick}>点击我</button>
- en: <button onClick="onClick">Click me</button>
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <button onClick="onClick">点击我</button>
- en: React event handlers can also be assigned by calling addEventListener on the
    JSX element. *True* or *false*?
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React事件处理器也可以通过在JSX元素上调用addEventListener来分配。*正确*或*错误*？
- en: Event bubbling is rare and only happens for a few event types. *True* or *false*?
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件冒泡很少见，并且仅发生在少数事件类型中。*正确*或*错误*？
- en: If you don’t want a form to reload the page when submitted, what do you do?
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不希望在表单提交时重新加载页面，您该怎么办？
- en: Assign the listener as a capture listener.
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将监听器作为捕获监听器分配。
- en: Invoke evt.preventDefault() on the event object.
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件对象上调用evt.preventDefault()。
- en: Assign the listener manually on the HTML node.
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML节点上手动分配监听器。
- en: Invoke evt.stopPropagation() on the event object.
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件对象上调用evt.stopPropagation()。
- en: You can’t listen to events on HTML nodes that aren’t inside the React application.
    *True* or *false*?
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您不能监听不在React应用程序内部的HTML节点上的事件。*正确*或*错误*？
- en: Quiz answers
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验答案
- en: <button onClick={onClick}>Click me</click>.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <button onClick={onClick}>点击我</click>.
- en: '*False*. React event handlers can only be assigned using a property, for example,
    onClick. They can’t be assigned using addEventListener.'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。React事件处理器只能通过属性分配，例如，onClick。它们不能使用addEventListener分配。'
- en: '*False*. All events bubble in React—even some events that don’t bubble in HTML.'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。所有事件在React中都会冒泡——甚至一些在HTML中不会冒泡的事件。'
- en: If you want to cancel the default action, you must invoke evt.preventDefault()
    on the event object. An HTML form would cause the page to reload on submission
    as the default action.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想取消默认操作，必须在事件对象上调用 evt.preventDefault()。一个 HTML 表单在提交时会作为默认操作导致页面重新加载。
- en: '*False*. You can use manual DOM event listeners to listen for events on any
    HTML node as long as you have a reference to it.'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。只要你有对其的引用，你可以使用手动 DOM 事件监听器来监听任何 HTML 节点上的事件。'
- en: Summary
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Events are essential to creating interactive web applications. Events are the
    way an application reacts to user input.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件对于创建交互式 Web 应用程序至关重要。事件是应用程序对用户输入做出反应的方式。
- en: Events are also used to communicate between HTML nodes and the React application,
    for example, when a resource has loaded or a video has finished playing.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件也被用于在 HTML 节点与 React 应用程序之间进行通信，例如，当资源已加载或视频播放完毕时。
- en: React event listeners are assigned to JSX elements using a property. A click
    listener is assigned using onClick, a paste listener is assigned using onPaste,
    and so on.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性将 React 事件监听器分配给 JSX 元素。使用 onClick 分配点击监听器，使用 onPaste 分配粘贴监听器，依此类推。
- en: Event listeners are invoked with an event object, which can be used to tell
    which event occurred, which node caused the event to happen, which phase in the
    event propagation is currently in process, and several other properties relevant
    for the specific event.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件监听器使用事件对象来调用，该对象可以用来确定发生了哪个事件，哪个节点导致了事件的发生，当前事件传播的哪个阶段正在进行中，以及与特定事件相关的其他几个属性。
- en: Event objects are also used to interrupt the normal progression of event handling
    by either preventing the browser’s default action, stopping further propagation
    of the event to other event listeners, or both.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件对象也可以通过阻止浏览器默认行为、停止事件进一步传播到其他事件监听器或两者兼而有之来中断事件处理的正常流程。
- en: Events propagate from the window object down to the target node and back up
    to the window again. You can assign listeners to listen for events as they go
    up or down the tree in order to, for example, interrupt the regular flow or listen
    for events on multiple targets.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件从窗口对象传播到目标节点，然后再从窗口传播回来。你可以分配监听器来监听事件在树中向上或向下传播，例如，中断常规流程或监听多个目标上的事件。
- en: You can still assign regular event listeners to JavaScript objects and HTML
    nodes using regular JavaScript. You have to do this sometimes, as not all event
    types are supported in React, nor are all HTML nodes accessible through React.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你仍然可以使用常规 JavaScript 将常规事件监听器分配给 JavaScript 对象和 HTML 节点。有时你必须这样做，因为并非所有事件类型都在
    React 中受支持，也并非所有 HTML 节点都可以通过 React 访问。
