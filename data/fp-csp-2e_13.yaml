- en: 10 Working effectively with multi-argument functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 高效使用多参数函数
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using multi-argument functions with elevated types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提升类型与多参数函数一起使用
- en: Using LINQ syntax with any monadic type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LINQ 语法与任何单调类型
- en: Fundamentals of property-based testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于属性的测试基础
- en: The main goal of this chapter is to teach you to use multi-argument functions
    in the world of *effectful* types, so the “effectively” in the title is also a
    pun! Remember from section 6.6.1, effectful types are types such as `Option` (which
    adds the effect of optionality), `Exceptional` (exception handling), `IEnumerable`
    (aggregation), and others. In part 3, you’ll see several more effects related
    to state, laziness, and asynchrony.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是教会你如何在 *effectful* 类型世界中使用多参数函数，因此标题中的“effectively”也是一个双关语！记得在 6.6.1
    节中，effectful 类型包括 `Option`（添加了可选性效果）、`Exceptional`（异常处理）、`IEnumerable`（聚合）等。在第
    3 部分中，你将看到更多与状态、惰性和异步相关的效果。
- en: As you code more functionally, you’ll come to rely heavily on these effects.
    You probably already use `IEnumerable` a lot. If you embrace the fact that types
    like `Option` and some variation of `Either` add robustness to your programs,
    you’ll soon be dealing in elevated types in much of your code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你更多地使用函数式编程，你将严重依赖这些效果。你可能已经大量使用了 `IEnumerable`。如果你接受 `Option` 和一些 `Either`
    变体类型可以为你的程序增加鲁棒性的事实，你很快就会在大部分代码中使用提升类型。
- en: 'Although you’ve seen the power of core functions like `Map` and `Bind`, there’s
    an important technique you haven’t seen yet: how to integrate multi-argument functions
    in your workflows, given that `Map` and `Bind` both take unary functions.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已经看到了像 `Map` 和 `Bind` 这样的核心函数的强大功能，但你还没有看到一项重要的技术：如何在你的工作流程中集成多参数函数，因为 `Map`
    和 `Bind` 都接受单元函数。
- en: 'It turns out that there are two possible approaches: the applicative and monadic
    approaches. We’ll first look at the applicative approach, which uses the `Apply`
    function (a core function you haven’t seen yet). We’ll then revisit monads, and
    you’ll see how you can use `Bind` with multi-argument functions and how LINQ syntax
    can be helpful in this area. We’ll then compare the two approaches and see why
    both can be useful in different cases. Along the way, I’ll also present some of
    the theory related to monads and applicatives, and I’ll introduce a technique
    for unit testing called *property-based testing*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，有两种可能的方法：applicative 和 monadic 方法。我们首先将查看 applicative 方法，它使用 `Apply` 函数（你还没有见过的核心函数）。然后我们将重新审视
    monads，你将看到如何使用 `Bind` 与多参数函数，以及 LINQ 语法如何有助于这个领域。然后我们将比较两种方法，并了解为什么在不同的场景中两者都可以很有用。在这个过程中，我还会介绍与
    monads 和 applicatives 相关的一些理论，并介绍一种称为 *基于属性的测试* 的单元测试技术。
- en: 10.1 Function application in the elevated world
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 提升世界中的函数应用
- en: In this section, I’ll introduce the *applicative* approach, which relies on
    the definition of a new function, `Apply`, that performs function application
    in the elevated world. `Apply`, like `Map` and `Bind`, is one of the core functions
    in FP.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍 *applicative* 方法，该方法依赖于一个新函数 `Apply` 的定义，该函数在提升的世界中执行函数应用。`Apply`，就像
    `Map` 和 `Bind` 一样，是 FP 中的核心函数之一。
- en: 'To warm up, start the REPL and import the `LaYumba.Functional` library as usual.
    Then, type the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了热身，启动 REPL 并像往常一样导入 `LaYumba.Functional` 库。然后，输入以下内容：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So far, nothing new: you have a number wrapped in an `Option`, and you can
    apply the unary function `doubl` to it with `Map`. Now, say you have a *binary*
    function like multiplication, and you have two numbers, each wrapped in an `Option`.
    How can you apply the function to its arguments?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么新东西：你有一个被 `Option` 包裹的数字，你可以使用 `Map` 将单元函数 `doubl` 应用到它上面。现在，假设你有一个
    *二元* 函数，比如乘法，并且你有两个数字，每个数字都被 `Option` 包裹。你如何将函数应用到其参数上？
- en: 'Here’s the key concept: currying (which was covered in chapter 9) allows you
    to turn any *n*-ary function into a unary function that, when given its argument,
    returns a *(n–1)*-ary function. This means you can use `Map` with any function
    as long as it’s curried! Let’s see this in practice as the following listing shows.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关键概念：柯里化（在第 9 章中已介绍）允许你将任何 *n*-元函数转换为接受其参数时返回 *(n–1)*-元函数的单元函数。这意味着只要你将函数柯里化，你就可以使用
    `Map` 与任何函数一起使用！让我们通过以下列表来实际看看。
- en: Listing 10.1 Mapping a curried function onto an `Option`
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 将柯里化函数映射到 `Option`
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember, when you `Map` a function onto an `Option`, `Map` extracts the value
    in the `Option` and applies the given function to it. In the preceding listing,
    `Map` extracts the value `3` from `Option` and feeds it to the `multiply` function:
    `3` replaces the variable `x`, yielding the function `y` `=>` `3` `*` `y`. Let’s
    look at the types:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你将一个函数映射到`Option`上时，`Map`会提取`Option`中的值并将其应用于该函数。在上面的列表中，`Map`从`Option`中提取了值`3`，并将其传递给`multiply`函数：`3`替换了变量`x`，得到函数`y`
    `=>` `3` `*` `y`。让我们看看类型：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you map a multi-argument function, the function is partially applied to
    the argument wrapped in the `Option`. Let’s look at this from a more general point
    of view. Here’s the signature of `Map` for a functor `F`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你映射一个多参数函数时，函数被部分应用于`Option`包裹的参数。让我们从更一般的角度来看这个问题。这是`Map`对于函子`F`的签名：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now imagine that the type of `R` happens to be `T1` `→` `T2`, so `R` is actually
    a function. In that case, the signature expands to
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，`R`的类型恰好是`T1` `→` `T2`，因此`R`实际上是一个函数。在这种情况下，签名扩展为
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But look at the second argument: `T` `→` `T1` `→` `T2`. That’s a binary function
    in curried form. This means that you can use `Map` with functions of any arity!
    In order to free the caller from having to curry functions, my functional library
    includes overloads of `Map` that accept functions of various arities and takes
    care of currying: for example,'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但是看看第二个参数：`T` `→` `T1` `→` `T2`。这是一个柯里化的二元函数。这意味着你可以使用`Map`与任何可变元的函数！为了使调用者免于必须柯里化函数，我的函数库包括接受各种可变元函数的重载的`Map`，并负责柯里化：例如，
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As a result, the code in the following listing also works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下列表中的代码也有效。
- en: Listing 10.2 Mapping a binary function onto an `Option`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2：将二元函数映射到`Option`
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that you know you can effectively use `Map` with multi-argument functions,
    let’s look at the resulting value. This is something you’ve not seen before: an
    elevated function, which is a function wrapped in an elevated type, as figure
    10.1 illustrates.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道你可以有效地使用`Map`与多参数函数，让我们看看结果值。这是你以前没有见过的东西：一个升高的函数，它是一个被升高类型包裹的函数，如图10.1所示。
- en: '![](Images/CH10_F01_Buonanno2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F01_Buonanno2.png)'
- en: Figure 10.1 Mapping a binary function onto an `Option` yields a unary function
    wrapped in an `Option`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：将二元函数映射到`Option`得到一个被`Option`包裹的单元函数。
- en: There’s nothing special about an elevated function. Functions are values, so
    it’s simply another value wrapped in one of the usual containers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 升高函数并没有什么特殊之处。函数是值，所以它只是被通常的容器包裹的另一个值。
- en: 'And yet, how do you deal with an elevated value that’s a function? Now that
    you have a unary function wrapped in an `Option`, how do you supply it its second
    argument? And what if the second argument is also wrapped in an `Option`? A crude
    approach would be to explicitly unwrap both values and then apply the function
    to the argument like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如何处理一个作为函数的升高的值？现在你有一个被`Option`包裹的单元函数，你如何提供它的第二个参数？如果第二个参数也被`Option`包裹呢？一个粗略的方法是显式地解包两个值，然后将函数应用于参数，如下所示：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code isn’t nice. It leaves the elevated world of `Option` to apply the
    function, only to lift the result back up into an `Option`. Is it possible to
    abstract this and integrate multi-argument functions in a workflow without leaving
    the elevated world? This is indeed what the `Apply` function does, and we’ll look
    at it next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不优雅。它将`Option`的升高世界留给函数应用，然后将结果再次提升到`Option`中。是否可以抽象化这一点，并在不离开升高世界的情况下集成多参数函数？这正是`Apply`函数所做的，我们将在下一节中探讨它。
- en: 10.1.1 Understanding applicatives
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 理解应用函子
- en: Before we look at defining `Apply` for elevated values, let’s briefly review
    the `Apply` function we defined in chapter 9, which performs partial application
    in the world of regular values. We defined various overloads for `Apply` that
    take an *n*-ary function and an argument and return the result of applying the
    function to the argument. The signatures are in the form
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看为升高值定义`Apply`之前，让我们简要回顾一下在第9章中定义的`Apply`函数，它在常规值的世界中执行部分应用。我们为`Apply`定义了各种重载，它接受一个*n*-元函数和一个参数，并返回将函数应用于参数的结果。签名形式如下
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These signatures say, “Give me a function and a value, and I’ll give you the
    result of applying the function to the value,” whether that’s the function’s return
    value or the partially applied function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些签名表示，“给我一个函数和一个值，我会给你应用函数到值的结果，”无论是函数的返回值还是部分应用的函数。
- en: In the elevated world, we need to define overloads of `Apply` where the input
    and output values are wrapped in elevated types. In general, for any functor `A`
    for which `Apply` can be defined, the signatures of `Apply` will be in the form
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在提升的世界中，我们需要定义`Apply`的重载，其中输入和输出值被包裹在提升类型中。一般来说，对于任何可以定义`Apply`的函子`A`，`Apply`的签名将采用以下形式
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It’s just like the regular `Apply`, but in the elevated world, it says, “Give
    me a function wrapped in an `A` and a value wrapped in an `A`, and I’ll give you
    the result of applying the function to the value also wrapped in an `A`, of course.”
    This is illustrated in fig- ure 10.2.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像常规的`Apply`一样，但在提升世界中，它说，“给我一个包裹在`A`中的函数和一个包裹在`A`中的值，我会给你应用函数到值的结果，当然也是包裹在`A`中的。”这在图10.2中得到了说明。
- en: '![](Images/CH10_F02_Buonanno2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F02_Buonanno2.png)'
- en: Figure 10.2 `Apply` performs function application in the elevated world.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 `Apply`在提升世界中执行函数应用。
- en: An implementation of `Apply` must unwrap the function, unwrap the value, apply
    the function to the value, and wrap the result back up. When we define a suitable
    implementation of `Apply` for a functor `A`, this is called an *applicative functor*
    (or simply an *applicative*). The following listing shows how `Apply` is defined
    for `Option`, thus making `Option` an applicative.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apply`的实现必须解包函数，解包值，将函数应用于值，并将结果重新包裹。当我们为函子`A`定义一个合适的`Apply`实现时，这被称为*应用函子*（或简称为*应用*）。以下列表显示了如何为`Option`定义`Apply`，从而使`Option`成为一个应用。'
- en: Listing 10.3 Implementation of `Apply` for `Option`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 `Option`的`Apply`实现
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Only applies the wrapped function to the wrapped value if both `Options` are
    `Some`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只有当两个`Option`都是`Some`时才将包裹的函数应用于包裹的值
- en: ❷ Curries the wrapped function and calls the overload that takes an `Option`
    wrapping a unary function
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将包裹的函数柯里化并调用接受一个包裹一元函数的`Option`的重载
- en: The first overload is the important one. It takes a unary function wrapped in
    an `Option` and an argument to that function, also wrapped in an `Option`. The
    implementation returns `Some` only if both inputs are `Some` and `None` in all
    other cases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载是重要的。它接受一个包裹在`Option`中的一元函数及其参数，该参数也包裹在`Option`中。实现仅在两个输入都是`Some`时才将包裹的函数应用于包裹的值，在其他所有情况下返回`None`。
- en: As usual, overloads are required for the various arities of the wrapped functions.
    We can define those in terms of the unary version as the second overload demonstrates.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，需要为包裹函数的各种可变元定义重载。我们可以根据一元版本定义这些重载，就像第二个重载所展示的那样。
- en: 'Now that the low-level details of wrapping and unwrapping are taken care of,
    let’s see how you can use `Apply` with a binary function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在封装和解封装的低级细节已经处理完毕，让我们看看如何使用二进制函数与`Apply`：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In short, if you have a function wrapped in a container, `Apply` allows you
    to supply arguments to it. Let’s take this idea one step further.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果您有一个包裹在容器中的函数，`Apply`允许您向它提供参数。让我们进一步探讨这个想法。
- en: 10.1.2 Lifting functions
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 提升函数
- en: 'In the examples so far, you’ve seen functions lifted into a container by mapping
    a multi-argument function onto an elevated value like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，您已经看到通过将多参数函数映射到提升值（如下所示）将函数提升到容器中：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you could lift a function into a container by simply using the
    container’s `Return` function as with any other value. After all, the wrapped
    function doesn’t care *how* it gets there, so you can write this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过简单地使用容器的`Return`函数将函数提升到容器中，就像使用任何其他值一样。毕竟，包裹的函数并不关心它是如何到达那里的，所以您可以写出这个：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Lifts the function into an `Option`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将函数提升到`Option`
- en: ❷ Supplies arguments with `Apply`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用`Apply`提供参数
- en: 'This can be generalized to functions of any arity. And, as usual, you get the
    safety of `Option` so that if any value along the way is `None`, the final result
    is also `None`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以推广到任何可变元的函数。而且，像往常一样，您得到`Option`的安全性，这样如果沿途的任何值是`None`，最终结果也是`None`：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, there are two distinct but equivalent ways of evaluating a binary
    function in the elevated world. You can see these side by side in table 10.1.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在提升世界中评估二元函数有两种截然不同但等效的方法。您可以在表10.1中并排看到这些。
- en: Table 10.1 Two equivalent ways to achieve function application in the elevated
    world
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 提升世界中实现函数应用的两个等效方法
- en: '| `Map` the function, then `Apply`. | Lift the function, then `Apply`. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 将函数`Map`，然后`Apply`。 | 将函数提升，然后`Apply`。 |'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The second way (first lifting the function with `Return` and then applying arguments)
    is more readable and more intuitive because it’s similar to partial application
    in the world of regular values, as table 10.2 shows.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式（首先使用 `Return` 提升函数，然后应用参数）更易读、更直观，因为它与常规值世界中的部分应用类似，如表 10.2 所示。
- en: Table 10.2 Partial application in the worlds of regular and elevated values
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2 常规值和提升值世界中的部分应用
- en: '| Partial application with regular values | Partial application with elevated
    values |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 部分应用与常规值 | 部分应用与提升值 |'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Whether you obtain the function by using `Map` or lifting it with `Return` doesn’t
    matter in terms of the resulting functor. This is a requirement, and it will hold
    if the applicative is correctly implemented. It’s sometimes called the *applicative
    law*.[¹](#pgfId-1127187)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是通过使用 `Map` 还是使用 `Return` 提升函数，从结果函子的角度来看都没有关系。这是一个要求，如果适用性被正确实现，它将成立。有时被称为*适用性法则*。[¹](#pgfId-1127187)
- en: 10.1.3 An introduction to property-based testing
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 基于属性的测试简介
- en: Can we write some unit tests to prove that the functions we’ve been using to
    work with `Option` satisfy the applicative law? There’s a specific technique for
    this sort of testing (testing that an implementation satisfies certain laws or
    properties). It’s called *property-based testing*, and a supporting framework
    called FsCheck is available for doing property-based testing in .NET.[²](#pgfId-1139841)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否编写一些单元测试来证明我们用来处理 `Option` 的函数满足适用性法则？这种测试（测试实现是否满足某些法则或属性）有特定的技术。它被称为*基于属性的测试*，并且有一个名为
    FsCheck 的支持框架可用于在 .NET 中进行基于属性的测试。[²](#pgfId-1139841)
- en: Property-based tests are parameterized unit tests whose assertions should hold
    for *any* possible value of the parameters. You write a parameterized test and
    then let a framework, such as FsCheck, repeatedly run the test with a large set
    of randomly generated parameter values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试是参数化单元测试，其断言应适用于*任何*可能的参数值。你编写一个参数化测试，然后让一个框架，例如 FsCheck，重复使用大量随机生成的参数值运行测试。
- en: It’s easiest to understand this with an example. The following listing shows
    what a property test for the applicative law could look like.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子最容易理解这一点。以下列表展示了适用性法则的属性测试可能的样子。
- en: Listing 10.4 A property-based test illustrating the applicative law
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 展示适用性法则的基于属性的测试
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Marks a property-based test
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标记基于属性的测试
- en: ❷ FsCheck randomly generates a large set of input values to run the test with.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ FsCheck 随机生成大量输入值以运行测试。
- en: If you look at the signature of the test method, you’ll see that it’s parameterized
    with two `int` values. But unlike the parameterized tests discussed in the sidebar
    on “Parameterized unit tests” in chapter 3, here we’re not providing any values
    for the parameters. Instead, we’re just decorating the test method with the `Property`
    attribute defined in `FsCheck.Xunit`.[³](#pgfId-1129505) When you run your tests,
    FsCheck randomly generates a large number of input values and runs the test with
    these values.[⁴](#pgfId-1129509) This frees you from having to come up with sample
    inputs and gives you much better confidence that edge cases are covered.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看测试方法的签名，你会看到它使用两个 `int` 值进行参数化。但与第 3 章侧边栏“参数化单元测试”中讨论的参数化测试不同，这里我们没有为参数提供任何值。相反，我们只是用
    `FsCheck.Xunit` 中定义的 `Property` 属性装饰测试方法。[³](#pgfId-1129505) 当你运行测试时，FsCheck 会随机生成大量输入值并使用这些值运行测试。[⁴](#pgfId-1129509)
    这让你免于需要想出样本输入，并给你更大的信心，确保边缘情况被覆盖。
- en: This test passes, but we’re taking `int`s as parameters and lifting them into
    `Option`s, so it only illustrates the behavior with `Option`s in the `Some` state.
    We should also test what happens with `None`. The signature of our test method
    should really be
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试通过了，但我们正在使用 `int` 作为参数并将它们提升到 `Option` 中，所以它只说明了 `Some` 状态下的行为。我们还应该测试 `None`
    发生了什么。我们测试方法的签名应该是
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’d also ideally like FsCheck to randomly generate `Option`s in the `Some`
    or `None` state and feed them to the test.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望 FsCheck 能够随机生成 `Option` 的 `Some` 或 `None` 状态，并将它们提供给测试。
- en: If we try to run this, FsCheck will complain that it doesn’t know how to randomly
    generate an `Option<int>`. Fortunately, we can teach FsCheck how to do this as
    the following listing demonstrates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行这个，FsCheck 将会抱怨它不知道如何随机生成 `Option<int>`。幸运的是，我们可以像以下列表所展示的那样教 FsCheck
    如何做到这一点。
- en: Listing 10.5 Teaching FsCheck to create an arbitrary `Option`
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 教 FsCheck 创建任意的 `Option`
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'FsCheck knows how to generate primitive types such as `bool` and `int`, so
    generating an `Option<int>` should be easy: generate a random `bool` and then
    a random `int`; if the `bool` is false, return `None`; otherwise, wrap the generated
    `int` into a `Some`. This is the essential meaning of the preceding code—don’t
    worry about the exact details at this point.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: FsCheck 知道如何生成原始类型，如 `bool` 和 `int`，因此生成 `Option<int>` 应该很容易：生成一个随机的 `bool`，然后是一个随机的
    `int`；如果 `bool` 为假，则返回 `None`；否则，将生成的 `int` 包装到 `Some` 中。这就是前面代码的基本含义——在这个阶段不必担心确切的细节。
- en: Now we just need to instruct FsCheck to look into the `ArbitraryOption` class
    when a random `Option<T>`, is required. The following listing shows how to do
    this.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要指导 FsCheck 在需要随机 `Option<T>` 时查看 `ArbitraryOption` 类。下面的列表展示了如何做到这一点。
- en: Listing 10.6 The property-based test parameterized with arbitrary `Option`s
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 使用任意 `Option` 参数化的属性测试
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sure enough, FsCheck is now able to randomly generate the inputs to this test,
    which passes and beautifully illustrates the applicative law. Does it *prove*
    that our implementation always satisfies the applicative law? Not entirely, because
    it only tests that the property holds for the `multiply` function, whereas the
    law should hold for *any* function. Unfortunately, unlike with numbers and other
    values, it’s impossible to randomly generate a meaningful set of functions. But
    this sort of property-based test still gives us good confidence—certainly better
    than a unit test, even a parameterized one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，FsCheck 现在能够随机生成这个测试的输入，这个测试通过了，并且完美地展示了 applicative 法则。这*证明*我们的实现始终满足 applicative
    法则吗？并不完全，因为它只测试了属性对于 `multiply` 函数是成立的，而法则应该对*任何*函数都成立。不幸的是，与数字和其他值不同，随机生成一组有意义的函数是不可能的。但这类基于属性的测试仍然给我们带来了良好的信心——当然比单元测试，即使是参数化的单元测试要好。
- en: Real-world property-based testing
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于现实世界的属性测试
- en: Property-based testing is not just for theoretical stuff but can be effectively
    applied to LOB (Line of Business) applications. When you have an invariant, you
    can write property tests to capture it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试不仅适用于理论内容，还可以有效地应用于业务线（LOB）应用程序。当你有一个不变量时，你可以编写属性测试来捕捉它。
- en: 'Here’s a really simple example: if you have a randomly populated shopping cart,
    and you remove a random number of items from it, the total of the modified cart
    must always be less than or equal to the total of the original cart. You can start
    with such apparently trivial properties and keep adding properties until they
    capture the essence of your model.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的例子：如果你有一个随机填充的购物车，并且从中随机移除一定数量的商品，修改后的购物车总额必须始终小于或等于原始购物车的总额。你可以从这样的显然微不足道的属性开始，并继续添加属性，直到它们捕捉到你的模型本质。
- en: This is demonstrated nicely in Scott Wlaschin’s “Choosing properties for property-based
    testing” article, available at [http://mng.bz/Zx0A](http://mng.bz/Zx0A).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Scott Wlaschin 的“为属性测试选择属性”文章中得到了很好的展示，该文章可在 [http://mng.bz/Zx0A](http://mng.bz/Zx0A)
    找到。
- en: Now that we’ve covered the mechanics of the `Apply` function, let’s compare
    applicatives with the other patterns we’ve previously discussed. Once that’s done,
    we’ll look at applicatives in action with a more concrete example and at how they
    compare, especially to monads.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 `Apply` 函数的机制，让我们比较一下之前讨论过的其他模式。完成这些后，我们将通过一个更具体的例子来查看 applicatives
    的实际应用，以及它们与 monads 的比较。
- en: 10.2 Functors, applicatives, and monads
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 Functors、applicatives 和 monads
- en: 'Let’s recap three important patterns you’ve seen so far: functors, applicatives,
    and monads.[⁵](#pgfId-1129562) Remember that functors are defined by an implementation
    of `Map`, monads by an implementation of `Bind` and `Return`, and applicatives
    by an implementation of `Apply` and `Return` as table 10.3 shows.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你迄今为止看到的三种重要模式：functors、applicatives 和 monads。[⁵](#pgfId-1129562) 记住，functors
    是通过 `Map` 的实现定义的，monads 是通过 `Bind` 和 `Return` 的实现定义的，而 applicatives 是通过 `Apply`
    和 `Return` 的实现定义的，如表 10.3 所示。
- en: Table 10.3 Summary of the core functions for functors, applicatives, and monads
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3 针对functors、applicatives 和 monads 的核心函数总结
- en: '| Pattern | Required functions | Signature |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 必需函数 | 签名 |'
- en: '| Functor | `Map` | `F<T>` `→` `(T` `→` `R)` `→` `F<R>` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Functor | `Map` | `F<T>` `→` `(T` `→` `R)` `→` `F<R>` |'
- en: '| Applicative | `Return` | `T` `→` `A<T>` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Applicative | `Return` | `T` `→` `A<T>` |'
- en: '|  | `Apply` | `A<(T` `→` `R)>` `→` `A<T>` `→` `A<R>` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  | `Apply` | `A<(T` `→` `R)>` `→` `A<T>` `→` `A<R>` |'
- en: '| Monad | `Return` | `T` `→` `M<T>` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 单子 | `Return` | `T` `→` `M<T>` |'
- en: '|  | `Bind` | `M<T>` `→` `(T` `→` `M<R>)` `→` `M<R>` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  | `Bind` | `M<T>` `→` `(T` `→` `M<R>)` `→` `M<R>` |'
- en: First, why is `Return` a requirement for monads and applicatives but not for
    functors? You need a way to somehow put a value `T` into a functor `F<T>`; otherwise,
    you couldn’t create anything on which to `Map` a function. The point, really,
    is that the functor laws (the properties that `Map` should observe) don’t rely
    on a definition of `Return`, whereas the monad and applicative laws do. This is
    then mostly a technicality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么`Return`是单子和应用函子的要求，而不是函子的要求？你需要一种方法将值`T`放入函子`F<T>`中；否则，你无法创建任何可以对其`Map`函数的东西。实际上，问题在于函子定律（`Map`应该观察的性质）并不依赖于`Return`的定义，而单子和应用函子定律则依赖于。这主要是一个技术问题。
- en: 'More interestingly, you may be wondering what the relationship is between these
    three patterns. In chapter 7, you saw that monads are more powerful than functors.
    Applicatives are also more powerful than functors because you can define `Map`
    in terms of `Return` and `Apply`. `Map` takes an elevated value and a regular
    function, so you can lift the function using `Return` and then apply it to the
    elevated value using `Apply`. For `Option`, that looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，你可能想知道这三个模式之间的关系。在第7章中，你看到单子比函子更强大。应用函子也比函子更强大，因为你可以用`Return`和`Apply`来定义`Map`。`Map`接受提升的值和常规函数，因此你可以使用`Return`提升函数，然后使用`Apply`将其应用于提升的值。对于`Option`，它看起来像这样：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The implementation for any other applicative would be the same, using the relevant
    `Return` function instead of `Some`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他应用函子的实现都将相同，使用相关的`Return`函数而不是`Some`。
- en: 'Finally, monads are more powerful than applicatives because you can define
    `Apply` in terms of `Bind` and `Return` like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，单子比应用函子更强大，因为你可以像这样用`Bind`和`Return`来定义`Apply`：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This enables us to establish a hierarchy in which functor is the most general
    pattern and applicative sits between functor and monad. Figure 10.3 shows these
    relationships.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够建立一个层次结构，其中函子是最一般的模式，应用函子位于函子和单子之间。图10.3显示了这些关系。
- en: 'You can read this as a class diagram: if functor were an interface, applicative
    would extend it. Furthermore, in chapter 9, I discussed the *fold* function, or
    `Aggregate` as it’s called in LINQ, which is the most powerful of them all because
    you can define `Bind` in terms of it. *Foldables* (things for which *fold* can
    be defined) are more powerful than monads.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这看作是一个类图：如果函子是一个接口，应用函子将扩展它。此外，在第9章中，我讨论了`fold`函数，或者如LINQ中称为`Aggregate`的函数，这是其中最强大的，因为你可以用它来定义`Bind`。`Foldables`（可以定义`fold`的东西）比单子更强大。
- en: '![](Images/CH10_F03_Buonanno2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F03_Buonanno2.png)'
- en: Figure 10.3 Relationship of functors, applicatives, and monads
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 函子、应用函子和单子之间的关系
- en: 'Applicatives aren’t as commonly used as functors and monads, so why even bother?
    It turns out that although `Apply` can be defined in terms of `Bind`, it generally
    receives its own implementation, both for efficiency and because `Apply` can include
    interesting behavior that’s lost when you define `Apply` in terms of `Bind`. In
    this book, I’ll show two monads for which the implementation of `Apply` has such
    interesting behavior: `Validation` (later in this chapter) and `Task` (in chapter
    16).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用函子不像函子和单子那样常用，那么为什么还要费心呢？结果证明，尽管`Apply`可以用`Bind`来定义，但它通常有自己的实现，这既是为了效率，也是因为`Apply`可以包含在用`Bind`定义`Apply`时丢失的有趣行为。在这本书中，我将展示两个单子，它们的`Apply`实现具有这种有趣的行为：`Validation`（在本章后面）和`Task`（第16章）。
- en: Next, let’s go back to the topic of monads to see how you can use `Bind` with
    multi-argument functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回到单子的主题，看看你如何使用多参数函数的`Bind`。
- en: 10.3 The monad laws
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 单子定律
- en: I’ll now discuss the monad laws as promised in chapter 6, where I first introduced
    the term *monad*. If you’re not interested in the theory, skip to section 10.3.4.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将讨论单子定律，这是在第6章中首次介绍术语*单子*时承诺的。如果你对理论不感兴趣，请跳到10.3.4节。
- en: 'Remember, a monad is a type `M` for which the following functions are defined:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，单子是一个类型`M`，对于以下函数有定义：
- en: '`Return`—Takes a regular value of type `T` and lifts it into a monadic value
    of type `M<T>`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Return`——接受类型`T`的常规值并将其提升为类型`M<T>`的单子值'
- en: '`Bind`—Takes a monadic value `m` and a world-crossing function `f`; extracts
    from `m` its inner value(s) `t` and applies `f` to it'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bind`——接受一个单子值`m`和一个跨世界函数`f`；从`m`中提取其内部值`t`并将`f`应用于它'
- en: '`Return` and `Bind` should have the following three properties:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Return`和`Bind`应该具有以下三个属性：'
- en: Right identity
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右单位性
- en: Left identity
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左单位性
- en: Associativity
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合律
- en: For the present discussion, we’re mostly interested in the third law, *associativity*,
    but the first two are simple enough that we can cover them too.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前的讨论，我们主要对第三条法则，即结合律感兴趣，但前两条法则足够简单，我们也可以涵盖它们。
- en: 10.3.1 Right identity
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 右侧单位元
- en: 'The property of *right identity* states that if you `Bind` the `Return` function
    onto a monadic value `m`, you end up with `m`. In other words, the following should
    hold:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧单位元的性质表明，如果你将`Return`函数绑定到单子值`m`上，你最终会得到`m`。换句话说，以下应该成立：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you look at the preceding equation, on the right side, `Bind` unwraps the
    value inside `m` and applies `Return`, which lifts it back up. It’s not surprising
    that the net effect should be nought. The next listing shows a test that proves
    that right identity holds for the `Option` type.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看前面的等式，在右侧，`Bind`解包了`m`内部的值并应用`Return`，将其重新提升。结果是零并不令人惊讶。下一个列表显示了一个测试，证明了`Option`类型的右侧单位元成立。
- en: Listing 10.7 A property-based test for right identity
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7 右侧单位元的属性测试
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 10.3.2 Left identity
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 左侧单位元
- en: 'The property of *left identity* states that if you first use `Return` to lift
    a `t` and then `Bind` a function `f` over the result, that should be equivalent
    to applying `f` to `t`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧单位元的性质表明，如果你首先使用`Return`提升`t`，然后`Bind`一个函数`f`到结果，那么这应该等同于将`f`应用到`t`上：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you look at this equation, on the left side you’re lifting `t` with `Return`
    and then `Bind` extracts it before feeding it to `f`. This law states that this
    lifting and extracting should have no side effects, and it should also not affect
    `t` in any way. The next listing shows a test that proves that left identity holds
    for `IEnumerable`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看这个等式，在左侧你使用`Return`提升`t`，然后`Bind`在将其提供给`f`之前提取它。这个法则表明，这种提升和提取应该没有副作用，并且也不应以任何方式影响`t`。下一个列表显示了一个测试，证明了`IEnumerable`的左侧单位元成立。
- en: Listing 10.8 A property-based test for left identity
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.8 左侧单位元的属性测试
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Taken together, left and right identity ensure that the lifting operation performed
    in `Return` and the unwrapping that occurs as part of `Bind` are neutral operations
    that have no side effects and don’t distort the value of `t` or the behavior of
    `f`, regardless of whether this wrapping and unwrapping happens before (left)
    or after (right) a value is lifted into the monad. We could write a monad that,
    say, internally keeps a count of how many times `Bind` is called, or includes
    some other side effect. That would violate this property.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一起来看，左侧和右侧单位元确保在`Return`中执行的提升操作和作为`Bind`一部分发生的解包是中性操作，它们没有副作用，并且不会扭曲`t`的值或`f`的行为，无论这种包装和解包是在将值提升到单子之前（左侧）还是之后（右侧）发生。我们可以编写一个单子，比如，在内部保持`Bind`被调用的次数计数，或者包含其他副作用。这将违反这个性质。
- en: 'In simpler words, `Return` should be *as dumb as possible*: no side effects,
    no conditional logic, no acting upon the given `t`; only the minimal work required
    to satisfy the signature `T` `→` `C<T>`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 用更简单的话说，`Return`应该尽可能“愚蠢”：没有副作用，没有条件逻辑，不对给定的`t`进行操作；只需完成满足签名`T` `→` `C<T>`的最小工作。
- en: 'Let’s look at a counterexample. The following property-based test supposedly
    illustrates left identity for `Option`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个反例。以下基于属性的测试据说说明了`Option`的左侧单位元：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It turns out that the preceding property fails when the value of `t` is `null`.
    This is because our implementation of `Some` is too smart and throws an exception
    if given `null`, whereas this particular function, `f`, is `null`-tolerant and
    yields `Some("Hello ")`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，当`t`的值为`null`时，前面的性质失败了。这是因为我们的`Some`实现过于智能，如果给定`null`会抛出异常，而此特定函数`f`是`null`容忍的，并产生`Some("Hello
    ")`。
- en: If you wanted left identity to hold for any value including `null`, you’d need
    to change the implementation of `Some` to lift `null` into a `Some`. But this
    would *not* be a good idea because then `Some` would indicate the presence of
    data when, in fact, there is none. This is a case in which practicality trumps
    theory.[⁶](#pgfId-1129697)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望左侧单位元对任何值都成立，包括`null`，你需要更改`Some`的实现，将`null`提升到`Some`中。但这不是一个好主意，因为这样`Some`会表示存在数据，而实际上并没有。这是一个实用性胜过理论的例子。[⁶](#pgfId-1129697)
- en: 10.3.3 Associativity
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 结合律
- en: 'Let’s now move on to the third law, which is the most meaningful for our present
    discussion. I’ll start with a reminder of what associativity means for addition:
    if you need to add more than two numbers, it doesn’t matter how you group them.
    That is, for any numbers `a`, `b`, and `c`, the following is true:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到第三条定律，这是对我们当前讨论最有意义的。我会先提醒一下结合性对加法意味着什么：如果您需要添加两个以上的数字，您如何分组并不重要。也就是说，对于任何数字
    `a`、`b` 和 `c`，以下都是正确的：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Bind` can also be thought of as a binary operator and can be indicated with
    the symbol `>>=` so that instead of `m.Bind(f)`, you can symbolically write `m
    >>= f`, where `m` indicates a monadic value and `f` a world-crossing function.
    The symbol `>>=` is a fairly standard notation for `Bind`, and it’s supposed to
    graphically reflect what `Bind` does: extract the inner value of the left operand
    and feed it to the function that’s the right operand.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 也可以被视为一个二元运算符，可以用符号 `>>=` 表示，这样您就可以用符号 `m >>= f` 来代替 `m.Bind(f)`，其中
    `m` 表示一个单调值，而 `f` 是一个跨越世界的函数。符号 `>>=` 是 `Bind` 的相当标准的表示法，它应该能够图形化地反映 `Bind` 所做的操作：提取左操作数的内部值并将其馈送到作为右操作数的函数。'
- en: 'It turns out that `Bind` is also associative in some sense. You should be able
    to write the following equation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，`Bind` 在某种意义上也是结合的。您应该能够写出以下等式：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s look at the left side. Here you compute the first `Bind` operation and
    then you use the resulting monadic value as input to the next `Bind` operation.
    This would expand to `m.Bind(f).Bind(g)`, which is how we normally use `Bind`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看左侧。在这里，您计算第一个 `Bind` 操作，然后使用得到的单调值作为下一个 `Bind` 操作的输入。这将展开为 `m.Bind(f).Bind(g)`，这是我们通常使用
    `Bind` 的方式。
- en: 'Let’s now look at the right side. As it’s written, it’s syntactically wrong:
    `(f` `>>= g)` doesn’t work because `>>=` expects the left operand to be a monadic
    value, whereas `f` is a function. But note that `f` can be expanded to its lambda
    form, `x ⇒ f(x)`, so you can rewrite the right side as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看右侧。按照现在的写法，它是语法错误的：`(f >>= g)` 不起作用，因为 `>>=` 期望左操作数是一个单调值，而 `f` 是一个函数。但请注意，`f`
    可以展开为其 lambda 形式，`x ⇒ f(x)`，因此您可以按如下方式重写右侧：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The associativity of `Bind` can be then summarized with this equation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 的结合性可以用以下等式总结：'
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or, if you prefer, the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您愿意，可以写成以下形式：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The following listing shows how you could translate this into code. It shows
    a property-based test illustrating that the associative property holds for my
    implementation of `Option`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何将此转换为代码。它展示了一个基于属性的测试，说明 `Option` 的实现具有结合性质。
- en: Listing 10.9 A property-based test showing `Bind` associativity for `Option`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 展示 `Bind` 结合性质对于 `Option` 的基于属性的测试
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Exposes an `Option`-returning `Parse` function
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 暴露一个返回 `Option` 的 `Parse` 函数
- en: 'When we associate to the left as in `m.Bind(f).Bind(g)`, that gives the more
    readable syntax (the one we’ve used so far). But if we associate to the right
    and expand `g` to its lambda form, we get this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将左侧与 `m.Bind(f).Bind(g)` 结合时，这给出了更易读的语法（我们之前使用的语法）。但如果我们将右侧与 `g` 结合并展开为 lambda
    形式，我们得到的是这个：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The interesting thing is that here `g` has visibility not only of `y` but also
    of `x`. This is what enables you to integrate multi-argument functions in a monadic
    flow (by which I mean a workflow chaining several operations with `Bind`). We’ll
    look at this next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这里 `g` 不仅可以看到 `y`，还可以看到 `x`。这正是您能够在单调流（我指的是通过 `Bind` 连接几个操作的流程）中集成多参数函数的原因。我们接下来会看看这一点。
- en: 10.3.4 Using Bind with multi-argument functions
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 使用多参数函数与 Bind 结合
- en: 'Let’s look at how calling `Bind` inside a previous call to `Bind` allows you
    to integrate multi-argument functions. For instance, imagine multiplication where
    both arguments are wrapped in an `Option` because they must be parsed from strings.
    In this example, `Int.Parse` takes a string and returns an `Option<int>`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在之前的 `Bind` 调用内部调用 `Bind` 如何允许您集成多参数函数。例如，想象一个乘法，其中两个参数都被包裹在一个 `Option`
    中，因为它们必须从字符串中解析出来。在这个例子中，`Int.Parse` 接受一个字符串并返回一个 `Option<int>`：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That works, but it’s not at all readable. Imagine if you had a function taking
    three or more arguments! The nested calls to `Bind` make the code difficult to
    read, so you certainly wouldn’t want to write or maintain code like this. The
    applicative syntax you saw in section 10.1.2 was much clearer. It turns out that
    there’s a much better syntax for writing nested applications of `Bind`. That syntax
    is called *LINQ*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这虽然可行，但可读性极差。想象一下，如果你有一个接受三个或更多参数的函数！嵌套调用 `Bind` 使得代码难以阅读，因此你肯定不希望编写或维护这样的代码。你在
    10.1.2 节中看到的适用性语法要清晰得多。实际上，有一种更好的语法可以用来编写嵌套的 `Bind` 应用。这种语法被称为 *LINQ*。
- en: 10.4 Improving readability by using LINQ with any monad
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 使用 LINQ 提高任何单子的可读性
- en: 'Depending on the context, the name LINQ is used to indicate different things:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，LINQ 的名称用来表示不同的事物：
- en: It can simply refer to the `System.Linq` library.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以简单地引用 `System.Linq` 库。
- en: It can indicate a special SQL-like syntax that can be used to express queries
    on various kinds of data. In fact, LINQ stands for *Language-Integrated Query*.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以指一种特殊的类似 SQL 的语法，可以用来表达对各种类型数据的查询。实际上，LINQ 代表 *Language-Integrated Query*。
- en: Naturally, these two are linked, and they were both introduced in tandem in
    C# 3\. So far, all usages of the LINQ library you’ve seen in this book have used
    normal method invocation, but sometimes using the LINQ syntax can result in more
    readable queries. For example, type the two expressions in table 10.4 into the
    REPL to see that they’re equivalent.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这两个是相关的，并且它们都是在 C# 3 中同时引入的。到目前为止，你在本书中看到的 LINQ 库的所有用法都使用了正常方法调用，但有时使用 LINQ
    语法可以产生更可读的查询。例如，将表 10.4 中的两个表达式输入到 REPL 中，以查看它们是等价的。
- en: Table 10.4 LINQ is a dedicated syntax for expressing queries.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.4 LINQ 是一种用于表达查询的专用语法。
- en: '| Normal method invocation | LINQ expression |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 正常方法调用 | LINQ 表达式 |'
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: These two expressions aren’t just equivalent in the sense that they produce
    the same result; they actually compile to the same code. When the C# compiler
    finds a LINQ expression, it translates its clauses to method calls in a pattern-based
    way—you’ll see what this means in more detail in a moment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个表达式不仅在产生相同结果的意义上是等价的；实际上，它们编译成相同的代码。当 C# 编译器发现 LINQ 表达式时，它会以基于模式的方式将其子句转换为方法调用——你将在下一刻更详细地了解这一点。
- en: This means that it’s possible for you to implement the query pattern for your
    own types and work with them using LINQ syntax, which can significantly improve
    readability. Next, we’ll look at implementing the query pattern for `Option`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以为你的自定义类型实现查询模式，并使用 LINQ 语法与它们一起工作，这可以显著提高可读性。接下来，我们将探讨为 `Option` 实现查询模式。
- en: 10.4.1 Using LINQ with arbitrary functors
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 使用 LINQ 与任意函子
- en: 'The simplest LINQ queries have single `from` and `select` clauses, and they
    resolve to the `Select` method. For example, here’s a simple query using a range
    as a data source:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 LINQ 查询具有单个 `from` 和 `select` 子句，它们解析为 `Select` 方法。例如，这里是一个使用范围作为数据源的简单查询：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`Range(1,` `4)` yields a sequence with the values `[1,` `2,` `3,` `4]`, and
    this is the data source for the LINQ expression. We then create a *projection*
    by mapping each item `x` in the data source to `x * 2` to produce the result.
    What happens under the hood?'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Range(1, 4)` 返回一个包含值 `[1, 2, 3, 4]` 的序列，这是 LINQ 表达式的数据源。然后我们通过将数据源中的每个项目 `x`
    映射到 `x * 2` 来创建一个 *投影*，以生成结果。底层发生了什么？'
- en: Given a LINQ expression like the preceding one, the compiler looks at the type
    of the data source (in this case, `Range(1,` `4)` has type `RangeIterator`) and
    then looks for an instance or extension method called `Select`. The compiler uses
    its normal strategy for method resolution, prioritizing the most specific match
    in scope, which in this case is `Enumerable.Select`, defined as an extension method
    on `IEnumerable`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个如前所述的 LINQ 表达式，编译器会查看数据源的类型（在这种情况下，`Range(1, 4)` 的类型为 `RangeIterator`），然后寻找一个名为
    `Select` 的实例或扩展方法。编译器使用其正常的方法解析策略，优先考虑作用域中最具体的匹配项，在这种情况下是定义在 `IEnumerable` 上的扩展方法
    `Enumerable.Select`。
- en: In table 10.5, you can see the LINQ expression and its translation side by side.
    Notice how the lambda given to `Select` combines the identifier `x` in the `from`
    clause and the selector expression `x * 2` in the `select` clause.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在表 10.5 中，你可以看到 LINQ 表达式及其翻译并排。注意 `Select` 给出的 lambda 表达式如何结合 `from` 子句中的标识符
    `x` 和 `select` 子句中的选择表达式 `x * 2`。
- en: Table 10.5 A LINQ expression with a single `from` clause and its interpretation
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.5 带有一个 `from` 子句的 LINQ 表达式及其解释
- en: '|'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Remember from chapter 6 that `Select` is the LINQ equivalent for the operation
    more commonly known in FP as `Map`. LINQ’s pattern-based approach means that you
    can define `Select` for any type you please, and the compiler will use it whenever
    it finds that type as the data source of a LINQ query. Let’s do that for `Option`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在第六章中，`Select` 是 LINQ 对 FP 中更常见的操作 `Map` 的等价操作。LINQ 的基于模式的处理方法意味着你可以为任何类型定义
    `Select`，编译器会在找到该类型作为 LINQ 查询的数据源时使用它。让我们为 `Option` 做这件事：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code effectively just aliases `Map` with `Select`, which is the
    name that the compiler looks for. That’s all you need to be able to use an `Option`
    inside a simple LINQ expression! Here are some examples:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实际上只是将 `Map` 用 `Select` 别名，这是编译器寻找的名称。这就是你能够在简单的 LINQ 表达式中使用 `Option` 所需要的一切！以下是一些示例：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In summary, you can use LINQ queries with a single `from` clause with any functor
    by providing a suitable `Select` method. Of course, for such simple queries, the
    LINQ notation isn’t really beneficial; standard method invocation even saves you
    a couple of keystrokes. Let’s see what happens with more complex queries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你可以通过提供一个合适的 `Select` 方法，使用任何函子（functor）与单个 `from` 子句进行 LINQ 查询。当然，对于如此简单的查询，LINQ
    的表示法实际上并不带来太多好处；标准方法调用甚至可以节省你几个按键。让我们看看更复杂的查询会发生什么。
- en: 10.4.2 Using LINQ with arbitrary monads
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 使用任意单子（monads）的 LINQ
- en: 'Let’s look at queries with multiple `from` clauses—queries that combine data
    from multiple data sources. Here’s an example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看具有多个 `from` 子句的查询——这些查询结合了多个数据源的数据。以下是一个示例：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, this is somewhat analogous to a nested loop over the two data
    sources, which we discussed in section 6.3.2 when looking at `Bind` for `IEnumerable`.
    Indeed, you could write an equivalent expression using `Map` and `Bind` as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这有点类似于对两个数据源进行嵌套循环，我们在第 6.3.2 节讨论 `Bind` 时已经提到。实际上，你可以使用 `Map` 和 `Bind`
    编写一个等效的表达式，如下所示：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Or, equivalently, using the standard LINQ method names (`Select` instead of
    `Map` and `SelectMany` instead of `Bind`):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，等价地，使用标准的 LINQ 方法名（`Select` 代替 `Map`，`SelectMany` 代替 `Bind`）：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that you can construct a result that includes data from both sources
    because you close over the variable `c`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以构造一个包含来自两个数据源的数据的结果，因为你封闭了变量 `c`。
- en: 'You might guess that when multiple `from` clauses are present in a query, they’re
    interpreted with the corresponding calls to `SelectMany`. Your guess would be
    correct, but there’s a twist. For performance reasons, the compiler doesn’t perform
    the preceding translation, translating instead to an overload of `SelectMany`
    with a different signature:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会猜测，当查询中存在多个 `from` 子句时，它们会与 `SelectMany` 的相应调用一起解释。你的猜测是正确的，但有一个转折。出于性能原因，编译器不会执行前面的转换，而是转换为具有不同签名的
    `SelectMany` 重载：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That means this LINQ query
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个 LINQ 查询
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: will actually be translated as
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上会被翻译为
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The following listing shows both the plain vanilla implementation of `SelectMany`
    (which has the same signature as `Bind`) and the extended overload (which will
    be used when a query with two `from` clauses is translated into method calls).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 `SelectMany` 的普通实现（其签名与 `Bind` 相同）和扩展重载（当查询包含两个 `from` 子句并转换为方法调用时将使用）。
- en: Listing 10.10 The two overloads of `SelectMany` required by LINQ
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.10 `SelectMany` 的两个重载，LINQ 所需
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Plain vanilla `SelectMany`, equivalent to `Bind`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 普通版本的 `SelectMany`，相当于 `Bind`。
- en: ❷ Extended overload of `SelectMany` (used when translating a query with two
    from clauses)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当翻译包含两个 `from` 子句的查询时使用的扩展重载 `SelectMany`
- en: Compare the signatures. You’ll see that the second overload is obtained by “squashing”
    the plain vanilla `SelectMany` with a call to a selector function; not the usual
    selector in the form `T` `→` `R`, but a selector that takes two input arguments
    (one for each data source).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 比较签名。你会看到第二个重载是通过将普通 `SelectMany` 与一个选择函数的调用“压缩”得到的；不是一个常规的选择函数 `T` `→` `R`，而是一个接受两个输入参数（每个数据源一个）的选择函数。
- en: The advantage is that with this more elaborate overload of `SelectMany`, there’s
    no longer any need to nest one lambda inside another, improving performance.[⁷](#pgfId-1129899)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是，使用 `SelectMany` 的这个更复杂的重载，不再需要嵌套一个 lambda 表达式在另一个 lambda 表达式内部，从而提高了性能。[⁷](#pgfId-1129899)
- en: 'The extended `SelectMany` is more complex than the plain vanilla version we
    identified with the monadic `Bind`, but it’s still functionally equivalent to
    a combination of `Bind` and `Select`. This means we can define a reasonable implementation
    of the LINQ-flavored `SelectMany` for any monad. Let’s see it for `Option`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的 `SelectMany` 比我们用单子 `Bind` 识别的纯版本更复杂，但它仍然在功能上等同于 `Bind` 和 `Select` 的组合。这意味着我们可以为任何单子定义一个合理的
    LINQ 风格的 `SelectMany` 实现。让我们看看 `Option` 的例子：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you write an expression with three or more `from` clauses, the compiler also
    requires the plain vanilla version of `SelectMany`—the one with the same signature
    as `Bind`. Therefore, both overloads of `SelectMany` need to be defined to satisfy
    the LINQ query pattern.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写了一个包含三个或更多 `from` 子句的表达式，编译器还要求使用纯版本的 `SelectMany`——与 `Bind` 具有相同签名的版本。因此，需要定义
    `SelectMany` 的两个重载来满足 LINQ 查询模式。
- en: 'You can now write LINQ queries on `Option`s with multiple `from` clauses. For
    example, here’s a simple program that prompts the user for two integers and computes
    their sum, using the `Option`-returning function `Int.Parse` to validate that
    the inputs are valid integers:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在具有多个 `from` 子句的 `Option` 上编写 LINQ 查询。例如，以下是一个简单的程序，提示用户输入两个整数并计算它们的和，使用返回
    `Option` 的函数 `Int.Parse` 来验证输入是否为有效的整数：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The following listing shows how the LINQ query from the preceding example compares
    with alternative ways to write the same expression.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何将前面示例中的 LINQ 查询与编写相同表达式的替代方法进行比较。
- en: Listing 10.11 Different ways to add two optional integers
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 添加两个可选整数的不同方法
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There’s little doubt that LINQ provides the most readable syntax in this scenario.
    `Apply` compares particularly poorly because you must specify that you want your
    projection function to be used as a `Func`.[⁸](#pgfId-1129960) You may find it
    unfamiliar to use the SQL-ish LINQ syntax to do something that has nothing to
    do with querying a data source, but this use is perfectly legitimate. LINQ expressions
    simply provide a convenient syntax for working with monads, and they were modeled
    after equivalent constructs in functional languages.[⁹](#pgfId-1129963)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，LINQ 在此场景中提供了最易读的语法。`Apply` 与之相比尤其糟糕，因为你必须指定你想要你的投影函数作为 `Func` 使用。[⁸](#pgfId-1129960)
    你可能会觉得使用类似 SQL 的 LINQ 语法来做与查询数据源无关的事情是不熟悉的，但这种用法是完全合法的。LINQ 表达式只是提供了一个方便的语法来处理单子，并且它们是在函数语言中类似构造的基础上构建的。[⁹](#pgfId-1129963)
- en: 10.4.3 The LINQ clauses let, where, and others
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 LINQ 子句 let、where 以及其他
- en: In addition to the `from` and `select` clauses you’ve seen so far, LINQ provides
    a few other clauses. The `let` clause is useful for storing the results of intermediate
    computations. For example, let’s look at the program in the following listing,
    which calculates the hypotenuse of a right triangle, having prompted the user
    for the lengths of the legs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你迄今为止看到的 `from` 和 `select` 子句之外，LINQ 还提供了一些其他子句。`let` 子句对于存储中间计算结果非常有用。例如，让我们看看以下列表中的程序，它计算直角三角形的斜边长度，并提示用户输入两边的长度。
- en: Listing 10.12 Using the `let` clause with `Option`
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 使用 `let` 子句与 `Option`
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Exposes an `Option`-returning `Parse` function
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供了一个返回 `Option` 的 `Parse` 函数
- en: ❷ Assume `Prompt` is a convenience function that reads user input from the console
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 假设 `Prompt` 是一个便利函数，用于从控制台读取用户输入
- en: ❸ A `let` clause allows you to store intermediate results.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `let` 子句允许你存储中间结果。
- en: The `let` clause allows you to put a new variable, like `aa` in this example,
    within the scope of the LINQ expression. To do so, it relies on `Select`, so no
    extra work is needed to enable the use of `let`.[^(10)](#pgfId-1129998)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 子句允许你在 LINQ 表达式的范围内定义一个新的变量，例如本例中的 `aa`。为此，它依赖于 `Select`，因此不需要额外的工作来启用
    `let` 的使用。[^(10)](#pgfId-1129998)'
- en: One more clause you can use with `Option` is the `where` clause. This resolves
    to the `Where` method we’ve already defined, so no extra work is necessary in
    this case. For example, for the calculation of the hypotenuse, you should check
    not only that the user’s inputs are valid numbers but also that they are positive.
    The following listing shows how to do this.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以与 `Option` 一起使用的另一个子句是 `where` 子句。这解析为我们已经定义的 `Where` 方法，因此在这种情况下不需要额外的工作。例如，对于斜边长度的计算，你应该检查用户输入不仅是否为有效数字，而且是否为正数。以下列表展示了如何进行此操作。
- en: Listing 10.13 Using the `where` clause with `Option`
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.13 使用 `where` 子句与 `Option`
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As these examples show, the LINQ syntax allows you to concisely write queries
    that would be cumbersome to write as combinations of calls to the corresponding
    `Map`, `Bind`, and `Where` functions. LINQ also contains various other clauses
    such as `orderby`, which you’ve seen in a previous example. These clauses make
    sense for collections but have no counterpart in structures like `Option` and
    `Either`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如这些示例所示，LINQ语法允许你简洁地编写查询，这些查询作为对应`Map`、`Bind`和`Where`函数调用的组合将是繁琐的。LINQ还包含各种其他子句，如`orderby`，你已在之前的示例中看到。这些子句对于集合是有意义的，但在`Option`和`Either`之类的结构中没有对应项。
- en: In summary, for any monad you can implement the LINQ query pattern by providing
    implementations for `Select` (`Map`), `SelectMany` (`Bind`), and the ternary overload
    to `SelectMany` you’ve seen. Some structures may have other operations that can
    be included in the query pattern, such as `Where` in the case of `Option`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，对于任何单子，你可以通过提供`Select`（`Map`）、`SelectMany`（`Bind`）以及`SelectMany`的三元重载的实现来实施LINQ查询模式。某些结构可能具有其他可以包含在查询模式中的操作，例如在`Option`的情况下使用`Where`。
- en: Now that you’ve seen how LINQ provides a lightweight syntax for using `Bind`
    with multi-argument functions, let’s go back to comparing `Bind` and `Apply`,
    not just based on readability, but on actual functionality.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到LINQ如何为使用多参数函数的`Bind`提供轻量级语法，让我们回到比较`Bind`和`Apply`，不仅基于可读性，还基于实际功能。
- en: 10.5 When to use Bind vs. Apply
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 当使用Bind与Apply
- en: LINQ provides a good syntax for using `Bind`, even with multi-argument functions—even
    better than using `Apply` with normal method invocation. Should we still care
    about `Apply`? It turns out that in some cases, `Apply` can have interesting behavior.
    One such case is validation; let’s see why.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ提供了使用`Bind`的良好语法，即使对于多参数函数也是如此——甚至比使用`Apply`进行常规方法调用还要好。我们是否仍然应该关心`Apply`？实际上，在某些情况下，`Apply`可以表现出有趣的行为。其中一种情况是验证；让我们看看原因。
- en: 10.5.1 Validation with smart constructors
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 使用智能构造函数进行验证
- en: Consider the following implementation of a `PhoneNumber` class. Can you see
    anything wrong with it?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`PhoneNumber`类的实现。你能看出其中有什么问题吗？
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The answer should be staring you in the face: the types are wrong! This class
    allows you to create a `PhoneNumber` with, say, `Type` equal to “green,” `Country`
    equal to “fantasyland,” and `Nr` equal to “•10.”'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 答案应该就在你的眼前：类型是错误的！这个类允许你创建一个`PhoneNumber`，例如，`Type`等于“绿色”，`Country`等于“幻想国”，`Nr`等于“•10”。
- en: 'You saw in chapter 4 how defining custom types enables you to ensure that invalid
    data can’t creep into your system. Here’s a definition of a `PhoneNumber` class
    that follows this philosophy:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第4章中看到，定义自定义类型可以确保无效数据不会悄悄进入你的系统。以下是一个遵循这一理念的`PhoneNumber`类的定义：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now the three fields of a `PhoneNumber` all have specific types, which should
    ensure that only valid values can be represented. `CountryCode` may be used elsewhere
    in the application, but the remaining two types are specific to phone numbers,
    so they’re defined inside the `PhoneNumber` class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`PhoneNumber`的三个字段都具有特定的类型，这应该确保只能表示有效值。`CountryCode`可能在应用程序的其他地方使用，但剩余的两个类型是特定于电话号码的，因此它们在`PhoneNumber`类内部定义。
- en: 'We still need to provide a way to construct a `PhoneNumber`. For that, we can
    define a private constructor and a public factory function, `Create`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要提供一种构建`PhoneNumber`的方法。为此，我们可以定义一个私有构造函数和一个公共工厂函数`Create`：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that I’ve defined `Create` as a `Func` rather than using a constructor
    or a method to help out with type inference. This was discussed in section 9.2.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我将`Create`定义为`Func`而不是使用构造函数或方法来帮助类型推断。这已在第9.2节中讨论过。
- en: 'Now imagine we’re given three strings as raw input, and based on them, we need
    to create a `PhoneNumber`. Each property can be validated independently, so we
    can define three smart constructors with the following signatures:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们得到了三个原始输入字符串，并且基于它们，我们需要创建一个`PhoneNumber`。每个属性可以独立验证，因此我们可以定义三个具有以下签名的智能构造函数：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The implementation details of these functions aren’t important (see the code
    samples if you want to know more). The gist is that `validCountryCode` takes a
    `string` and returns a `Validation` in the `Valid` state only if the given string
    represents a valid `CountryCode`. The other two functions are similar.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的实现细节并不重要（如果你想知道更多，请参阅代码示例）。关键是`validCountryCode`接受一个`string`并仅在给定的字符串表示有效的`CountryCode`时返回`Valid`状态的`Validation`。其他两个函数类似。
- en: 10.5.2 Harvesting errors with the applicative flow
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 使用应用流收集错误
- en: Given the three input strings, we can combine these three functions in the process
    of creating a `PhoneNumber` as the following listing shows. With the applicative
    flow, we can lift the `PhoneNumber`'s factory function into a `Valid` and apply
    its three arguments.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 给定三个输入字符串，我们可以在创建`PhoneNumber`的过程中将这些三个函数组合起来，如下所示列表所示。使用应用流，我们可以将`PhoneNumber`的工厂函数提升到`Valid`并应用其三个参数。
- en: Listing 10.14 Validation using an applicative flow
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.14 使用应用流的`Validation`
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Lifts the factory function into a `Validation`
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将工厂函数提升到`Validation`
- en: ❷ Supplies arguments, each of which is also wrapped in a `Validation`
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提供参数，每个参数也被包装在一个`Validation`中
- en: 'This function yields `Invalid` if *any* of the functions we use to validate
    the individual fields yields `Invalid`. Let’s see its behavior, given a variety
    of different inputs:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的任何函数在验证单个字段时返回`Invalid`，则此函数将返回`Invalid`。让我们看看它在各种不同输入下的行为：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The first expression shows the successful creation of a `PhoneNumber`. In the
    second, we pass an invalid country code and get a failure as expected. In the
    third case, both the country and number are invalid, and we get a validation with
    two errors (remember, the `Invalid` case of a `Validation` holds an `IEnumerable<Error>`
    precisely to capture multiple errors).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式显示了成功创建`PhoneNumber`。在第二个中，我们传递一个无效的国家代码，并得到预期的失败。在第三种情况下，国家和号码都无效，我们得到一个包含两个错误的验证（记住，`Validation`的`Invalid`情况包含一个`IEnumerable<Error>`，正好用于捕获多个错误）。
- en: But how are the two errors, which are returned by different functions, harvested
    in the final result? This is due to the implementation of `Apply` for `Validation`.
    Check out the following listing.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但两个错误是如何在最终结果中收集的？这是由于`Apply`对`Validation`的实现。查看以下列表。
- en: Listing 10.15 Implementation of `Apply` for `Validation`
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.15 `Validation`的`Apply`实现
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ❶ If both inputs are valid, the wrapped function is applied to the wrapped argument,
    and the result is lifted into a `Validation` in the `Valid` state.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果两个输入都是有效的，则将包装的函数应用于包装的参数，并将结果提升到`Valid`状态的`Validation`中。
- en: ❷ If both inputs have errors, a `Validation` in the `Invalid` state is returned
    that collects the errors from both `valF` and `valT`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果两个输入都存在错误，将返回一个处于“Invalid”状态的`Validation`，该状态收集来自`valF`和`valT`的错误。
- en: As we’d expect, `Apply` applies the wrapped function to the wrapped argument
    only if both are valid. But, interestingly, if both are invalid, it returns an
    `Invalid` that combines errors from both arguments.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，`Apply`仅在两个参数都有效时才将包装的函数应用于包装的参数。但，有趣的是，如果两个参数都无效，它将返回一个结合两个参数错误的`Invalid`。
- en: 10.5.3 Failing fast with the monadic flow
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.3 使用单子流快速失败
- en: The following listing demonstrates how to create a `PhoneNumber` using LINQ.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表演示了如何使用LINQ创建`PhoneNumber`。
- en: Listing 10.16 Validation using a monadic flow
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.16 使用单子流的`Validation`
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let’s run this new version with the same test values as before:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前相同的测试值运行这个新版本：
- en: '[PRE65]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The first two cases work as before, but the third case is different: only the
    first validation error appears. To see why, let’s look at how `Bind` is defined
    in the next listing (the LINQ query actually calls `SelectMany`, but this is implemented
    in terms of `Bind`).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种情况与之前相同，但第三种情况不同：只有第一个验证错误出现。为了了解原因，让我们看看下一个列表中`Bind`的定义（LINQ查询实际上调用`SelectMany`，但这是以`Bind`为术语实现的）。
- en: Listing 10.17 Implementation of `Bind` for `Validation`
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.17 `Validation`的`Bind`实现
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If the given monadic value is `Invalid`, the given function isn’t evaluated.
    In this listing, `validCountryCode` returns `Invalid`, so `validNumber` is never
    called. Therefore, in the monadic version, we never get a chance to accumulate
    errors because any error along the way causes the subsequent functions to be bypassed.
    You can probably grasp the difference more clearly if we compare the signatures
    of `Apply` and `Bind`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的单子值是`Invalid`，则不会评估给定的函数。在这个列表中，`validCountryCode`返回`Invalid`，因此`validNumber`永远不会被调用。因此，在单子版本中，我们永远不会有机会累积错误，因为任何错误都会导致后续函数被绕过。如果您想更清楚地理解差异，我们可以比较`Apply`和`Bind`的签名：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With `Apply`, both arguments are of type `Validation`; the `Validation`s and
    any possible errors they contain have already been evaluated independently prior
    to the call to `Apply`. Because errors from both arguments are present, it makes
    sense to collect them in the resulting value.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Apply`，两个参数都是`Validation`类型；在调用`Apply`之前，`Validation`及其可能包含的错误已经独立评估。因为两个参数的错误都存在，所以在结果值中收集它们是有意义的。
- en: With `Bind`, only the first argument has type `Validation`. The second argument
    is a function that yields a `Validation`, but this hasn’t been evaluated yet,
    so the implementation of `Bind` can avoid calling the function altogether if the
    first argument is `Invalid`.[^(11)](#pgfId-1130197)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Bind`时，只有第一个参数是`Validation`类型。第二个参数是一个产生`Validation`的函数，但这个函数尚未被评估，所以如果第一个参数是`Invalid`，`Bind`的实现可以完全避免调用该函数。[^(11)](#pgfId-1130197)
- en: 'Hence, `Apply` is about combining two elevated values that are computed independently,
    whereas `Bind` is about sequencing computations that yield an elevated value.
    For this reason, the monadic flow allows short-circuiting: if an operation fails
    along the way, the following operations will be skipped.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Apply`是关于组合两个独立计算的高级值，而`Bind`是关于序列化产生高级值的计算。因此，单子流允许短路：如果在过程中某个操作失败，后续的操作将被跳过。
- en: I think what the case of `Validation` shows is that despite the apparent rigor
    of functional patterns and their laws, there’s still room for designing elevated
    types in a way that suits the particular needs of a particular application. Given
    my implementation of `Validation` and the current scenario of creating a valid
    `PhoneNumber`, you’d use the monadic flow to fail fast but the applicative flow
    to harvest errors.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为`Validation`的情况表明，尽管函数模式和它们的定律看起来很严谨，但仍然有空间以适合特定应用特定需求的方式来设计高级类型。鉴于我的`Validation`实现和当前创建有效`PhoneNumber`的场景，你会使用单子流快速失败，但使用适用性流来收集错误。
- en: 'In summary, you’ve seen three ways to use multi-argument functions in the elevated
    world: the good, the bad, and the ugly. Nested calls to `Bind` are certainly the
    ugly and are best avoided. Which of the other two is good or bad depends on your
    requirements. If you have an implementation of `Apply` with some desirable behavior
    as you saw with `Validation`, use the applicative flow; otherwise, use the monadic
    flow with LINQ.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你已经在高级世界中看到了使用多参数函数的三种方式：好的、坏的、和丑陋的。嵌套调用`Bind`无疑是丑陋的，最好避免。另外两种方式哪一种好或坏取决于你的需求。如果你有一个具有一些期望行为的`Apply`实现，就像你在`Validation`中看到的那样，使用适用性流；否则，使用LINQ的单子流。
- en: Exercises
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Implement `Apply` for `Either` and `Exceptional`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Either`和`Exceptional`实现`Apply`。
- en: Implement the query pattern for `Either` and `Exceptional`. Try to write down
    the signatures for `Select` and `SelectMany` without looking at any examples.
    For the implementation, just follow the types—if it type checks, it’s probably
    right!
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Either`和`Exceptional`的查询模式。尝试在不查看任何示例的情况下写下`Select`和`SelectMany`的签名。对于实现，只需遵循类型——如果类型检查通过，那么它很可能是正确的！
- en: Come up with a scenario in which various `Either`-returning operations are chained
    with `Bind`. (If you’re short of ideas, you can use the “favorite dish” example
    from chapter 8.) Rewrite the code using a LINQ expression.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想出一个场景，其中各种返回`Either`的操作通过`Bind`链式连接。 (如果你缺乏想法，可以使用第8章中的“最喜欢的菜肴”示例。)用LINQ表达式重写代码。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You can use the `Apply` function to perform function application in an elevated
    world, such as the world of `Option`.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`Apply`函数在高级世界中执行函数应用，例如`Option`的世界。
- en: Multi-argument functions can be lifted into an elevated world with `Return`;
    then you can supply arguments with `Apply`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多参数函数可以用`Return`提升到高级世界；然后你可以用`Apply`提供参数。
- en: Types for which `Apply` can be defined are called *applicatives*. Applicatives
    are more powerful than functors but less powerful than monads.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义`Apply`的类型被称为*适用性*。适用性比函子更强大，但比单子弱。
- en: Because monads are more powerful, you can also use nested calls to `Bind`; to
    perform function application in an elevated world.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为单子更强大，你也可以使用嵌套调用`Bind`来在高级世界中执行函数应用。
- en: LINQ provides a lightweight syntax for working with monads that reads better
    than nesting calls to `Bind`.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ提供了一种轻量级的语法来处理单子，其可读性优于嵌套调用`Bind`。
- en: To use LINQ with a custom type, you must implement the LINQ query pattern, particularly
    providing implementations of `Select` and `SelectMany` with appropriate signatures.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用自定义类型与LINQ一起使用，你必须实现LINQ查询模式，特别是提供具有适当签名的`Select`和`SelectMany`的实现。
- en: For several monads, `Bind` has short-circuiting behavior (the given function
    won’t be applied in some cases), but `Apply` doesn’t (it’s not given a function
    but rather an elevated value). For this reason, you can sometimes embed desirable
    behavior into applicatives, such as collecting validation errors in the case of
    `Validation`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于几个monads，`Bind`具有短路行为（在某些情况下不会应用给定的函数），但`Apply`没有（它不是给定一个函数，而是一个提升的值）。因此，你有时可以将期望的行为嵌入到applicatives中，例如在`Validation`的情况下收集验证错误。
- en: FsCheck is a framework for property-based testing. It allows you to run a test
    with a large number of randomly generated inputs, giving high confidence that
    the test’s assertions hold for any input.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FsCheck是一个基于属性的测试框架。它允许你运行一个测试，该测试使用大量随机生成的输入，从而可以高度确信测试的断言对任何输入都成立。
- en: '* * *'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ In reality, there are four laws that correct implementations of `Apply` and
    `Return` must satisfy; these essentially hold that the identity function, function
    composition, and function application work in the applicative world as they do
    in the normal world. The applicative law I refer to in the text holds as a consequence
    of these, and it’s more important than the underlying four laws in terms of refactoring
    and practical use. I won’t discuss the four laws in detail here, but if you want
    to learn more, you can see the documentation for the applicative module in Haskell
    at [http://mng.bz/AOBx](http://mng.bz/AOBx). In addition, you can view property-based
    tests illustrating the applicative laws in the code samples, LaYumba.Functional.Tests/Option/ApplicativeLaws.cs.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 在现实中，正确的`Apply`和`Return`实现必须满足四个定律；这些定律本质上意味着恒等函数、函数组合和函数应用在应用世界中与在正常世界中一样工作。我在文本中提到的应用定律是这些定律的结果，并且在重构和实际应用方面比这四个基本定律更重要。在这里我不会详细讨论这四个定律，但如果你想要了解更多，可以查看Haskell中应用模块的文档，网址为[http://mng.bz/AOBx](http://mng.bz/AOBx)。此外，你可以在代码示例LaYumba.Functional.Tests/Option/ApplicativeLaws.cs中查看说明应用定律的基于属性的测试。
- en: ² FsCheck is written in F# and is available freely ([https://github.com/fscheck/FsCheck](https://github.com/fscheck/FsCheck)).
    Like many similar frameworks written for other languages, it’s a port from Haskell’s
    QuickCheck.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ² FsCheck是用F#编写的，并且可以免费使用([https://github.com/fscheck/FsCheck](https://github.com/fscheck/FsCheck))。像为其他语言编写的许多类似框架一样，它是从Haskell的QuickCheck移植过来的。
- en: '³ This also has the effect of integrating the property-based tests with your
    testing framework: when you run your tests with `dotnet test`, all property-based
    tests are run, as well as the regular unit tests. An `FsCheck.NUnit` package also
    exists, exposing the `Property` attribute for NUnit.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 这也有将基于属性的测试与你的测试框架集成的效果：当你使用`dotnet test`运行测试时，所有基于属性的测试都会运行，以及常规的单元测试。也存在一个`FsCheck.NUnit`包，它公开了NUnit的`Property`属性。
- en: ⁴ By default, FsCheck generates 100 values, but you can customize the number
    and range of input values. If you start using property-based testing seriously,
    being able to fine-tune the parameters with which the values are generated becomes
    quite important.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 默认情况下，FsCheck生成100个值，但你也可以自定义输入值的数量和范围。如果你开始认真使用基于属性的测试，能够精细调整生成值的参数变得相当重要。
- en: ⁵ As pointed out in chapter 6, in the “Why is functor not an interface?” sidebar,
    some languages like Haskell allow you to capture these patterns with *type classes*,
    which are akin to interfaces but more powerful. The C# type system doesn’t support
    these generic abstractions, so you can’t idiomatically capture `Map` or `Bind`
    in an interface.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ 如第6章中“为什么functor不是一个接口？”的侧边栏所指出的，一些语言如Haskell允许你使用*类型类*来捕获这些模式，类型类类似于接口但更强大。C#的类型系统不支持这些泛型抽象，因此你无法在接口中以惯用方式捕获`Map`或`Bind`。
- en: ⁶ Of course, in a functional language, you wouldn’t have `null` in the first
    place, so you wouldn’t be in this conundrum.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ 当然，在函数式语言中，你一开始就不会有`null`，所以你不会陷入这个困境。
- en: ⁷ The designers of LINQ noticed that performance deteriorated rapidly as several
    `from` clauses were used in a query.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ LINQ的设计者注意到，当查询中使用了多个`from`子句时，性能会迅速下降。
- en: ⁸ This is because lambda expressions can be used to represent `Expression`s
    as well as `Func`s.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ⁸ 这是因为lambda表达式可以用来表示`Expression`以及`Func`。
- en: ⁹ For instance, `do` blocks in Haskell or `for` comprehensions in Scala.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ⁹ 例如，Haskell中的`do`块或Scala中的`for`推导式。
- en: ^(10) `let` stores the newly computed result in a tuple along with the previous
    result.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ^(10) `let`将新计算的结果存储在元组中，与之前的结果一起。
- en: ^(11) Of course, you could provide an implementation of `Bind` that doesn’t
    perform any such short-circuiting but always executes the bound function and collects
    any errors. This is possible, but it’s counterintuitive because it breaks the
    behavior that we’ve come to expect from similar types like `Option` and `Either`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: (11) 当然，你可以提供一个 `Bind` 的实现，它不会执行任何这样的短路操作，而是始终执行绑定的函数并收集任何错误。这是可能的，但它不符合直觉，因为它打破了我们从类似类型如
    `Option` 和 `Either` 预期的行为。
