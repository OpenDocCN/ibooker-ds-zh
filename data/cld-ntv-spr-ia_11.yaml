- en: '8 Reactive Spring: Resilience and scalability'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 反应式Spring：弹性和可伸缩性
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding reactive programming with Reactor and Spring
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Reactor和Spring理解反应式编程
- en: Building reactive servers with Spring WebFlux and Spring Data R2DBC
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring WebFlux和Spring Data R2DBC构建反应式服务器
- en: Building reactive clients with WebClient
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebClient构建反应式客户端
- en: Improving resilience for applications with Reactor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Reactor提高应用程序的弹性
- en: Testing reactive applications with Spring and Testcontainers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring和Testcontainers测试反应式应用程序
- en: Polarsophia, the organization behind the Polar Bookshop business, is very happy
    with the progress of its new software product. Its mission is to spread knowledge
    and awareness about the North Pole and the Arctic, and making its book catalog
    available worldwide is an essential part of this.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Polarsophia，Polar Bookshop业务的背后组织，对其新软件产品的进展感到非常高兴。其使命是传播关于北极和北极地区的知识和意识，使其图书目录在全球范围内可用是这一使命的重要组成部分。
- en: The Catalog Service application you built so far is a good starting point. It
    fulfills the requirements of browsing and managing books, and it does that while
    following cloud native patterns and practices. It’s self-contained and stateless.
    It uses a database as a backing service to store the state. It can be configured
    externally through environment variables or a configuration server. It respects
    environment parity. It’s verified through the automated execution of tests as
    part of a deployment pipeline, following continuous delivery practices. For maximum
    portability, it’s also containerized and can be deployed to a Kubernetes cluster
    using native functionality like service discovery, load balancing, and replication.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止构建的目录服务应用程序是一个良好的起点。它满足了浏览和管理书籍的要求，并且在遵循云原生模式和实践中做到了这一点。它是自包含且无状态的。它使用数据库作为后端服务来存储状态。可以通过环境变量或配置服务器外部配置。它尊重环境一致性。它通过作为部署管道一部分的自动化测试执行来验证，遵循持续交付实践。为了最大程度的便携性，它也被容器化，可以使用服务发现、负载均衡和复制等原生功能部署到Kubernetes集群。
- en: Another essential feature of the system is the possibility of purchasing books.
    In this chapter, you will start working on the Order Service application. This
    new component will interact not only with a database but also with Catalog Service.
    When you have applications extensively relying on I/O operations such as database
    calls or interactions with other services like HTTP request/response communications,
    the thread-per-request model used in Catalog Service begins to expose its technical
    limits.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的另一个基本功能是购买书籍的可能性。在本章中，你将开始构建订单服务应用程序。这个新组件不仅将与数据库交互，还将与目录服务交互。当你有大量依赖I/O操作的应用程序，如数据库调用或与其他服务（如HTTP请求/响应通信）的交互时，目录服务中使用的每个请求一个线程的模型开始暴露其技术限制。
- en: In the thread-per-request model, each request is bound to a thread exclusively
    allocated to its processing. If database or service calls are part of the processing,
    the thread will send out a request and then block, waiting for a response. During
    idle time, the resources allocated for that thread are wasted, since they cannot
    be used for anything else. The reactive programming paradigm solves this problem
    and improves scalability, resilience, and cost-effectiveness for all I/O-bound
    applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求一个线程的模型中，每个请求都绑定到一个专门为其处理分配的线程。如果数据库或服务调用是处理的一部分，线程将发送请求并阻塞，等待响应。在空闲时间内，为该线程分配的资源被浪费，因为它们不能用于其他任何事情。反应式编程范式解决了这个问题，并提高了所有I/O密集型应用程序的可伸缩性、弹性和成本效益。
- en: Reactive applications operate asynchronously and in a non-blocking way, meaning
    that computational resources are used more effectively. That’s a huge advantage
    in the cloud, since you pay for what you use. When a thread sends a call to a
    backing service, it will not wait idle, but it will move on to executing other
    operations. This eliminates the linear dependency between the number of threads
    and the number of concurrent requests, leading to more scalable applications.
    With the same amount of computational resources, reactive applications can serve
    more users than their non-reactive counterparts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式应用程序以异步和非阻塞的方式运行，这意味着计算资源被更有效地使用。这在云中是一个巨大的优势，因为你只为使用付费。当一个线程向后端服务发送调用时，它不会空闲等待，而是会继续执行其他操作。这消除了线程数量与并发请求数量之间的线性依赖关系，导致更可伸缩的应用程序。在相同的计算资源下，反应式应用程序可以比它们的非反应式对应物服务更多的用户。
- en: Cloud native applications are highly distributed systems deployed in a dynamic
    environment where change is a constant and failures can and will happen. What
    if the service is not available? What happens if the request gets lost on its
    way to the target service? What if the response gets lost on its way back to the
    caller? Can we guarantee high availability in this context?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用是高度分布的系统，部署在动态环境中，其中变化是常态，故障可能发生且必然会发生。如果服务不可用怎么办？如果请求在前往目标服务的路上丢失了怎么办？如果响应在返回调用者的路上丢失了怎么办？在这种情况下，我们能否保证高可用性？
- en: Resilience is one of the goals for moving to the cloud and one of the properties
    characterizing cloud native applications. Our systems should be resilient to failures
    and stable enough to ensure a certain service level to their users. The integration
    points between services over a network are among the most critical areas for achieving
    a stable and resilient system for production. It’s so important that Michael T.
    Nygard spends a large part of his book *Release It! Design and Deploy Production-Ready
    Software* (Pragmatic Bookshelf, 2018) on the subject.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是迁移到云端的其中一个目标，也是表征云原生应用的特性之一。我们的系统应该能够抵御故障，并足够稳定以确保为用户提供一定的服务水平。在网络中服务之间的集成点是实现稳定和弹性生产系统最关键的领域之一。这一点如此重要，以至于迈克尔·T·尼加德在他的书《发布它！设计和部署生产就绪软件》（Pragmatic
    Bookshelf，2018年）中花费了大量篇幅来讨论这个主题。
- en: This chapter will focus on building resilient, scalable, and efficient applications
    for the cloud using the reactive paradigm. First I’ll introduce the event loop
    model and the main features of Reactive Streams, Project Reactor, and the Spring
    reactive stack. Then you’ll build a reactive Order Service application using Spring
    WebFlux and Spring Data R2DBC.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于使用反应式范式构建云端的弹性、可扩展和高效的应用程序。首先，我将介绍事件循环模型和Reactive Streams、Project Reactor以及Spring反应式堆栈的主要特性。然后，您将使用Spring
    WebFlux和Spring Data R2DBC构建一个反应式订单服务应用程序。
- en: Order Service will interact with Catalog Service to check the availability of
    books and their details, so you’ll see how to implement a reactive REST client
    using Spring WebClient. The integration point between the two services is a critical
    area that needs extra care to achieve robustness and fault tolerance. Relying
    on the Reactor project, you’ll adopt stability patterns like retries, timeouts,
    and failovers. Finally, you’ll write autotests to verify the behavior of a reactive
    application using Spring Boot and Testcontainers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 订单服务将与目录服务交互，以检查书籍的可用性和详细信息，因此您将看到如何使用Spring WebClient实现一个反应式REST客户端。这两个服务之间的集成点是需要额外关注以实现健壮性和容错性的关键区域。依靠Reactor项目，您将采用重试、超时和故障转移等稳定性模式。最后，您将编写自动测试来验证使用Spring
    Boot和Testcontainers的反应式应用程序的行为。
- en: Note The source code for the examples in this chapter is available in the Chapter08/08-begin
    and Chapter08/08-end folders, containing the initial and final states of the project
    ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在Chapter08/08-begin和Chapter08/08-end文件夹中找到，包含项目的初始和最终状态（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: 8.1 Asynchronous and non-blocking architectures with Reactor and Spring
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 使用Reactor和Spring的异步和非阻塞架构
- en: The *Reactive Manifesto* (www.reactivemanifesto.org) describes a reactive system
    as responsive, resilient, elastic, and message-driven. Its mission to build loosely
    coupled, scalable, resilient, and cost-effective applications is fully compatible
    with our definition of cloud native. The new part is achieving that goal by using
    an asynchronous and non-blocking communication paradigm based on message-passing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 《*反应式宣言*》（www.reactivemanifesto.org）将反应式系统描述为响应的、弹性的、可伸缩的和基于消息驱动的。其构建松散耦合、可伸缩、弹性和成本效益高的应用程序的使命与我们对云原生的定义完全一致。新的部分是通过使用基于消息传递的异步和非阻塞通信范式来实现这一目标。
- en: Before diving into building reactive applications in Spring, we’ll explore the
    basics of reactive programming, why it matters for cloud native applications,
    and how it differs from imperative programming. I’ll introduce the event loop
    model, which overcomes the thread-per-request model’s shortcomings. Then you’ll
    learn the essential concepts of the Reactive Streams specification implemented
    by Project Reactor and the Spring reactive stack.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入构建Spring中的反应式应用程序之前，我们将探讨反应式编程的基础知识、为什么它对云原生应用程序很重要，以及它与命令式编程的不同之处。我将介绍事件循环模型，它克服了按请求分配线程模型的缺点。然后，你将学习由Project
    Reactor和Spring反应式堆栈实现的Reactive Streams规范的基本概念。
- en: 8.1.1 From thread-per-request to event loop
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 从按请求分配线程到事件循环
- en: As you saw in chapter 3, non-reactive applications allocate a thread per request.
    Until a response is returned, the thread will not be used for anything. That is
    the *thread-per-request* model. When the request handling involves intensive operations
    like I/O, the thread will block until those operations are completed. For example,
    if a database read is required, the thread will wait until data is returned from
    the database. During the waiting time, the resources allocated to the handling
    thread are not used efficiently. If you want to support more concurrent users,
    you’ll have to ensure you have enough threads and resources available. In the
    end, this paradigm sets constraints on the application’s scalability and doesn’t
    use computational resources in the most efficient way possible. Figure 8.1 shows
    how it works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第3章中看到的，非反应式应用程序为每个请求分配一个线程。在返回响应之前，该线程将不会被用于其他任何操作。这就是所谓的**按请求分配线程**模型。当请求处理涉及像I/O这样的密集型操作时，线程将阻塞，直到这些操作完成。例如，如果需要数据库读取，线程将等待直到从数据库返回数据。在等待期间，分配给处理线程的资源没有得到有效利用。如果你想支持更多的并发用户，你必须确保你有足够的线程和资源可用。最终，这种范式对应用程序的可扩展性设置了限制，并且没有以最有效的方式使用计算资源。图8.1展示了它是如何工作的。
- en: '![08-01](../Images/08-01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![08-01](../Images/08-01.png)'
- en: Figure 8.1 In the thread-per-request model, each request is handled by a thread
    dedicated exclusively to its handling.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 在按请求分配线程模型中，每个请求都由一个专门用于其处理的线程来处理。
- en: Reactive applications are more scalable and efficient by design. Handling requests
    in a reactive application doesn’t involve allocating a given thread exclusively—requests
    are fulfilled asynchronously based on events. For example, if a database read
    is required, the thread handling that part of the flow will not wait until data
    is returned from the database. Instead, a callback is registered, and whenever
    the information is ready, a notification is sent, and one of the available threads
    will execute the callback. During that time, the thread that requested the data
    can be used to process other requests rather than waiting idle.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式应用程序在设计上就更加可扩展和高效。在反应式应用程序中处理请求不涉及为特定线程分配——请求基于事件异步完成。例如，如果需要数据库读取，处理该流程部分的线程将不会等待直到从数据库返回数据。相反，注册一个回调，每当信息准备好时，就会发送通知，并且可用的线程之一将执行回调。在这段时间里，请求数据的线程可以被用来处理其他请求，而不是闲置等待。
- en: This paradigm, called *event loop*, doesn’t set hard constraints on the application’s
    scalability. It actually makes it easier to scale, since an increase in the number
    of concurrent requests does not strictly depend on the number of threads. As a
    matter of fact, a default configuration for reactive applications in Spring is
    to use only one thread per CPU core. With the non-blocking I/O capability and
    a communication paradigm based on events, reactive applications allow for more
    efficient utilization of computational resources. Figure 8.2 shows how it works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种被称为**事件循环**的范式，不对应用程序的可扩展性设置硬性约束。实际上，它使得可扩展性更容易实现，因为并发请求的增加并不严格依赖于线程的数量。事实上，Spring中反应式应用程序的默认配置是每个CPU核心只使用一个线程。通过非阻塞I/O能力和基于事件的通信范式，反应式应用程序允许更有效地利用计算资源。图8.2展示了它是如何工作的。
- en: '![08-02](../Images/08-02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![08-02](../Images/08-02.png)'
- en: Figure 8.2 In the event loop model, requests are handled by threads that don’t
    block while waiting for an intensive operation, allowing them to process other
    requests in the meantime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 在事件循环模型中，请求由不会在等待密集型操作时阻塞的线程处理，这使得它们可以在同时处理其他请求。
- en: I wanted to briefly mention the difference between those two paradigms because
    it helps explain the reasoning behind reactive programming. However, you don’t
    need to know the details of these paradigms’ inner mechanics since we won’t have
    to work at such a low level or implement an event loop. Instead, we’re going to
    rely on convenient higher-level abstractions that will let us focus on the business
    logic of our applications rather than spending time handling the processing at
    the thread level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我想简要地提及这两种范式之间的区别，因为这有助于解释响应式编程背后的推理。然而，你不需要了解这些范式内部机制的细节，因为我们不需要在如此低级别工作或实现事件循环。相反，我们将依赖方便的高级抽象，这将使我们能够专注于应用程序的业务逻辑，而不是花费时间处理线程级别的处理。
- en: Scale and cost optimization are two critical reasons for moving to the cloud,
    so the reactive paradigm perfectly fits cloud native applications. Scaling applications
    to support a workload increase becomes less demanding. By using resources more
    efficiently, you can save money on the computational resources offered by a cloud
    provider. Another reason for moving to the cloud is resilience, and reactive applications
    also help with that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 规模和成本优化是迁移到云的两个关键原因，因此响应式范式非常适合云原生应用程序。将应用程序扩展以支持工作负载增加变得不那么具有挑战性。通过更有效地使用资源，你可以节省云提供商提供的计算资源费用。迁移到云的另一个原因是弹性，响应式应用程序也有助于这一点。
- en: One of the essential features of reactive applications is that they provide
    non-blocking backpressure (also called *control flow*). This means that consumers
    can control the amount of data they receive, which lowers the risk of producers
    sending more data than consumers can handle, which can cause a DoS attack, slowing
    the application, cascading the failure, or even leading to a total crash.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式应用程序的一个基本特征是它们提供非阻塞背压（也称为*控制流*）。这意味着消费者可以控制他们接收的数据量，这降低了生产者发送比消费者能处理更多的数据的风险，这可能导致DoS攻击，减慢应用程序，级联故障，甚至导致完全崩溃。
- en: The reactive paradigm is a solution to the problem of blocking I/O operations
    that require more threads to handle high concurrency and which may lead to slow
    or entirely unresponsive applications. Sometimes the paradigm is mistaken as a
    way to increase the speed of an application. Reactive is about improving scalability
    and resilience, not speed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式范式是解决需要更多线程来处理高并发且可能导致应用缓慢或完全无响应的阻塞I/O操作问题的解决方案。有时，这种范式被误认为是提高应用程序速度的一种方式。响应式是关于提高可扩展性和弹性，而不是速度。
- en: With great powers come great troubles, though. Going reactive is an excellent
    choice when you expect high traffic and concurrency with fewer computational resources
    or in streaming scenarios. However, you should also be aware of the additional
    complexity introduced by such a paradigm. Besides requiring a mindset shift to
    think in an event-driven way, reactive applications are more challenging to debug
    and troubleshoot because of the asynchronous I/O. Before rushing to rewrite all
    your applications to make them reactive, think twice about whether that’s necessary,
    and consider both the benefits and drawbacks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，强大的力量伴随着巨大的麻烦。当你预期高流量和高并发，但计算资源较少或在流式场景中时，转向响应式是一个很好的选择。然而，你也应该意识到这种范式引入的额外复杂性。除了需要转变思维模式以事件驱动的方式思考外，由于异步I/O，响应式应用程序更难以调试和故障排除。在匆忙将所有应用程序重写为响应式之前，请三思是否真的有必要，并考虑其利弊。
- en: Reactive programming is not a new concept. It’s been used for years. The reason
    for the recent success of the paradigm in the Java ecosystem is due to the Reactive
    Streams specification and its implementations, like Project Reactor, RxJava, and
    Vert.x, which provided developers with convenient and high-level interfaces for
    building asynchronous and non-blocking applications without dealing with the underlying
    details of designing a message-driven flow. The following section will introduce
    Project Reactor, the reactive framework used by Spring.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程不是一个新概念。它已经使用了多年。这种范式在Java生态系统中的近期成功归因于响应式流规范及其实现，如Project Reactor、RxJava和Vert.x，它们为开发者提供了方便的高级接口，用于构建异步和非阻塞应用程序，而无需处理设计消息驱动流程的底层细节。下一节将介绍Project
    Reactor，这是Spring使用的响应式框架。
- en: '8.1.2 Project Reactor: Reactive streams with Mono and Flux'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 Project Reactor：使用Mono和Flux的响应式流
- en: Reactive Spring is based on Project Reactor, a framework for building asynchronous,
    non-blocking applications on the JVM. Reactor is an implementation of the *Reactive
    Streams* specification, and it aims to provide “a standard for asynchronous stream
    processing with non-blocking back pressure” (www.reactive-streams.org).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Spring基于Project Reactor，这是一个在JVM上构建异步、非阻塞应用程序的框架。Reactor是*响应式流*规范的实现，旨在提供“一个用于异步流处理的标准，具有非阻塞背压”（www.reactive-streams.org）。
- en: 'Conceptually, reactive streams resemble the Java Stream API in the way we use
    them to build data pipelines. One of the key differences is that a Java stream
    is pull-based: consumers process data in an imperative and synchronous fashion.
    Instead, reactive streams are push-based: consumers are notified by the producers
    when new data is available, so the processing happens asynchronously.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，响应式流在用于构建数据管道的方式上类似于Java Stream API。其中一个关键区别是Java流是基于拉取的：消费者以命令式和同步的方式处理数据。相反，响应式流是基于推送的：当生产者通知有新数据可用时，消费者会被通知，因此处理是异步的。
- en: 'Reactive streams work according to a producer/consumer paradigm. Producers
    are called *publishers*. They produce data that might be eventually available.
    Reactor provides two central APIs implementing the Producer<T> interface for objects
    of type <T>, and they are used to compose asynchronous, observable data streams:
    Mono<T> and Flux<T>:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式流根据生产者/消费者模式工作。生产者被称为*发布者*。他们生产可能最终可用的数据。Reactor提供了两个核心API，实现了类型为<T>的对象的Producer<T>接口，并用于组合异步、可观察的数据流：Mono<T>和Flux<T>：
- en: Mono<T>—Represents a single asynchronous value or empty result (0..1)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono<T>—表示单个异步值或空结果（0..1）
- en: Flux<T>—Represents an asynchronous sequence of zero or more items (0..N)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux<T>—表示零个或多个项目的异步序列（0..N）
- en: In a Java stream, you would process objects like Optional<Customer> or Collection
    <Customer>. In a reactive stream, you would have Mono<Customer> or Flux<Customer>.
    The possible outcomes of a reactive stream are an empty result, a value, or an
    error. All of them are handled as data. When the publisher returns all the data,
    we say that the reactive stream has been *completed* successfully.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java流中，您会处理像Optional<Customer>或Collection <Customer>这样的对象。在响应式流中，您将拥有Mono<Customer>或Flux<Customer>。响应式流的可能结果是一个空结果、一个值或一个错误。所有这些都被视为数据。当发布者返回所有数据时，我们说响应式流已成功*完成*。
- en: Consumers are called *subscribers* because they subscribe to a publisher and
    are notified whenever new data is available. As part of the *subscription*, consumers
    can also define backpressure by informing the publisher that they can process
    only a certain amount of data at a time. That is a powerful feature that puts
    consumers in control of how much data is received, preventing them from being
    overwhelmed and becoming unresponsive. Reactive streams are only activated if
    there’s a subscriber.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者被称为*订阅者*，因为他们订阅了一个出版商，并且每当有新数据可用时都会收到通知。作为*订阅*的一部分，消费者还可以通过通知出版商他们一次只能处理一定量的数据来定义背压。这是一个强大的功能，使消费者能够控制接收的数据量，防止他们被淹没并变得无响应。只有当有订阅者时，响应式流才会被激活。
- en: You can build reactive streams that combine data from different sources and
    manipulate it using Reactor’s vast collection of *operators*. In a Java stream,
    you can use a fluent API to process data through operators like map, flatMap,
    or filter, each of which builds a new Stream object that keeps the previous step
    immutable. Similarly, you can build reactive streams using a fluent API and operators
    to process the data received asynchronously.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建响应式流，将来自不同来源的数据组合在一起，并使用Reactor庞大的*操作符*集合来操作它。在Java流中，您可以使用流畅的API通过map、flatMap或filter等操作符处理数据，每个操作符都会构建一个新的Stream对象，保持之前步骤的不变性。同样，您可以使用流畅的API和操作符构建响应式流来处理异步接收到的数据。
- en: Besides the standard operators available to Java streams, you can use more powerful
    ones to apply backpressure, handle errors, and increase application resilience.
    For example, you’ll see how to use the retryWhen() and timeout() operators to
    make the interaction between Order Service and Catalog Service more robust. Operators
    can perform actions on a publisher and return a new publisher without modifying
    the original one, so you can build functional and immutable data streams with
    ease.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Java流可用的标准操作符之外，你还可以使用更强大的操作符来应用背压、处理错误并提高应用程序的弹性。例如，你将了解如何使用retryWhen()和timeout()操作符来使订单服务和目录服务之间的交互更加健壮。操作符可以在发布者上执行操作并返回一个新的发布者，而不修改原始的发布者，因此你可以轻松地构建函数性和不可变的数据流。
- en: Project Reactor is the foundation of the Spring reactive stack, which lets you
    implement your business logic in terms of Mono<T> and Flux<T>. In the next section,
    you’ll learn more about which options you have for building reactive applications
    with Spring.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor是Spring反应式堆栈的基础，它允许你使用Mono<T>和Flux<T>来实现你的业务逻辑。在下一节中，你将了解使用Spring构建反应式应用程序有哪些选项。
- en: 8.1.3 Understanding the Spring reactive stack
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 理解Spring反应式堆栈
- en: When you build applications with Spring, you can choose between a servlet stack
    and a reactive stack. The servlet stack relies on synchronous, blocking I/O and
    uses the thread-per-request model to handle requests. On the other hand, the reactive
    stack relies on asynchronous, non-blocking I/O and uses the event loop model to
    handle requests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Spring构建应用程序时，你可以在servlet堆栈和反应式堆栈之间进行选择。servlet堆栈依赖于同步、阻塞I/O，并使用每个请求一个线程的模型来处理请求。另一方面，反应式堆栈依赖于异步、非阻塞I/O，并使用事件循环模型来处理请求。
- en: The servlet stack is based on the Servlet API and a Servlet container (such
    as Tomcat). In contrast, the reactive model is based on the Reactive Streams API
    (implemented by Project Reactor) and either Netty or a Servlet container (version
    3.1 as a minimum). Both stacks let you build RESTful applications using either
    classes annotated as @RestController (which you used in chapter 3) or functional
    endpoints called router functions (which you’ll learn about in chapter 9). The
    servlet stack uses Spring MVC, while the reactive stack uses Spring WebFlux. Figure
    8.3 compares the two stacks. (For a broader overview, you can refer to [https://spring.io/reactive.](https://spring.io/reactive))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: servlet堆栈基于Servlet API和一个Servlet容器（如Tomcat）。相比之下，反应式模型基于Reactive Streams API（由Project
    Reactor实现）和Netty或Servlet容器（至少是版本3.1）。这两个堆栈都允许你使用标注为@RestController的类（你在第3章中使用过）或称为路由函数的功能端点（你将在第9章中了解）来构建RESTful应用程序。servlet堆栈使用Spring
    MVC，而反应式堆栈使用Spring WebFlux。图8.3比较了这两个堆栈。（对于更广泛的概述，你可以参考[https://spring.io/reactive.](https://spring.io/reactive)）
- en: '![08-03](../Images/08-03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![08-03](../Images/08-03.png)'
- en: Figure 8.3 The servlet stack is based on the Servlet API and supports synchronous
    and blocking operations. The reactive stack is based on Project Reactor and supports
    asynchronous and non-blocking operations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 servlet堆栈基于Servlet API，支持同步和阻塞操作。反应式堆栈基于Project Reactor，支持异步和非阻塞操作。
- en: Tomcat is the default choice for servlet-based applications like Catalog Service.
    Netty is the preferred choice for reactive applications, providing the best performance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat是像目录服务这样的基于servlet的应用程序的首选选择。Netty是反应式应用程序的首选选择，提供最佳性能。
- en: All the major frameworks in the Spring ecosystem offer both non-reactive and
    a reactive options, including Spring Security, Spring Data, and Spring Cloud.
    Overall, the Spring reactive stack provides a higher-level interface for building
    reactive applications, relying on the familiar Spring projects without being concerned
    with the underlying implementation of the reactive streams.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Spring生态系统中的所有主要框架都提供非反应性和反应性选项，包括Spring Security、Spring Data和Spring Cloud。总的来说，Spring反应式堆栈提供了一个高级接口来构建反应式应用程序，依赖于熟悉的Spring项目，而不必关心反应流底层的实现。
- en: 8.2 Reactive servers with Spring WebFlux and Spring Data R2DBC
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 使用Spring WebFlux和Spring Data R2DBC构建反应式服务器
- en: So far we have worked on Catalog Service, a non-reactive (or *imperative*) application,
    using Spring MVC and Spring Data JDBC. This section will teach you how to build
    a reactive web application (Order Service) using Spring WebFlux and Spring Data
    R2DBC. Order Service will provide functionality for purchasing books. Like Catalog
    Service, it will expose a REST API and store data in a PostgreSQL database. Unlike
    Catalog Service, it will use the reactive programming paradigm to improve scalability,
    resilience, and cost-effectiveness.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Spring MVC和Spring Data JDBC构建非响应式（或*命令式*）的目录服务应用。本节将教你如何使用Spring
    WebFlux和Spring Data R2DBC构建响应式Web应用（订单服务）。订单服务将提供购买书籍的功能。像目录服务一样，它将公开REST API并将数据存储在PostgreSQL数据库中。与目录服务不同，它将使用响应式编程范式来提高可伸缩性、弹性和成本效益。
- en: You’ll see that the principles and patterns you learned in the previous chapters
    also apply to reactive applications. The main difference is that we’ll shift from
    implementing the business logic in an imperative way to building reactive streams
    that are processed asynchronously.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，你在前几章中学到的原则和模式也适用于响应式应用。主要区别在于，我们将从以命令式方式实现业务逻辑转变为构建异步处理的响应式流。
- en: Order Service will also interact with Catalog Service through its REST API to
    fetch details about books and check their availability. That will be the focus
    of section 8.3\. Figure 8.4 shows the new components of the system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 订单服务还将通过其REST API与目录服务交互，以获取书籍的详细信息并检查其可用性。这将是第8.3节的重点。图8.4显示了系统的新的组件。
- en: '![08-04](../Images/08-04.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![08-04](../Images/08-04.png)'
- en: Figure 8.4 The Order Service application exposes an API to submit and retrieve
    book orders, uses a PostgreSQL database to store data, and communicates with Book
    Service to fetch book details.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 订单服务应用公开了一个提交和检索书籍订单的API，使用PostgreSQL数据库存储数据，并与图书服务通信以获取图书详情。
- en: As you learned in chapter 3, we should start with the API first. Order Service
    will expose a REST API to retrieve existing book orders and submit new ones. Each
    order can be related to one book only, and up to five copies. The API is described
    in table 8.1.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第3章中学到的，我们应该从API开始。订单服务将公开REST API以检索现有书籍订单并提交新的订单。每个订单只能关联一本书，最多五本。API在表8.1中描述。
- en: Table 8.1 Specifications for the REST API that Order Service will expose
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 订单服务将公开的REST API规范
- en: '| Endpoint | HTTP method | Request body | Status | Response body | Description
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 端点 | HTTP方法 | 请求体 | 状态 | 响应体 | 描述 |'
- en: '| /orders | POST | OrderRequest | 200 | Order | Submits a new order for a given
    book in a given quantity |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| /orders | POST | OrderRequest | 200 | Order | 提交给定数量给定书籍的新订单 |'
- en: '| /orders | GET |  | 200 | Order[] | Retrieves all the orders |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| /orders | GET |  | 200 | Order[] | 获取所有订单 |'
- en: Now, on to the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看代码。
- en: Note If you haven’t followed along with the examples implemented in the previous
    chapters, you can refer to the repository accompanying the book and use the project
    in the Chapter08/08-begin folder as a starting point ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你没有跟随前几章中实现的示例，你可以参考书籍附带的存储库，并使用第08章/08-begin文件夹中的项目作为起点（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: 8.2.1 Bootstrapping a reactive application with Spring Boot
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 使用Spring Boot启动响应式应用
- en: You can initialize the Order Service project from Spring Initializr ([https://start.spring.io](https://start.spring.io)),
    store the result in a new order-service Git repository, and push it to GitHub.
    The parameters for the initialization are shown in figure 8.5.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Spring Initializr（[https://start.spring.io](https://start.spring.io)）初始化订单服务项目，将结果存储在一个新的order-service
    Git仓库中，并将其推送到GitHub。初始化的参数如图8.5所示。
- en: '![08-05](../Images/08-05.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![08-05](../Images/08-05.png)'
- en: Figure 8.5 The parameters for initializing the Order Service project from Spring
    Initializr
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 从Spring Initializr初始化订单服务项目的参数
- en: Tip If you don’t want to go through the manual generation on the Spring Initializr
    website, you’ll find a curl command in the begin folder for this chapter that
    you can run in a Terminal window to download a zip file. It contains all the code
    you’ll need to get started.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你不想在Spring Initializr网站上手动生成，你可以在本章的开始文件夹中找到一个curl命令，你可以在终端窗口中运行它以下载zip文件。它包含你开始所需的所有代码。
- en: 'The dependencies section of the autogenerated build.gradle file is shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的build.gradle文件的依赖项部分如下所示：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These are the main dependencies:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要的依赖项：
- en: '*Spring Reactive Web* (org.springframework.boot:spring-boot-starter-webflux)—Provides
    the necessary libraries for building reactive web applications with Spring WebFlux
    and includes Netty as the default embedded server.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Reactive Web* (org.springframework.boot:spring-boot-starter-webflux)—提供构建使用Spring
    WebFlux的响应式Web应用程序所需的库，包括Netty作为默认的嵌入服务器。'
- en: '*Spring Data R2DBC* (org.springframework.boot:spring-boot-starter-data-r2dbc)—Provides
    the necessary libraries to persist data in relational databases with R2DBC using
    Spring Data in reactive applications.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Data R2DBC* (org.springframework.boot:spring-boot-starter-data-r2dbc)—提供在响应式应用程序中使用R2DBC在关系数据库中持久化数据的必要库。'
- en: '*Validation* (org.springframework.boot:spring-boot-starter-validation)—Provides
    the necessary libraries for object validation using the Java Bean Validation API.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证* (org.springframework.boot:spring-boot-starter-validation)—提供使用Java Bean验证API进行对象验证的必要库。'
- en: '*PostgreSQL* (org.postgresql:r2dbc-postgresql)—Provides an R2DBC driver that
    allows the application to connect to a PostgreSQL database reactively.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PostgreSQL* (org.postgresql:r2dbc-postgresql)—提供一个R2DBC驱动程序，允许应用程序以响应式方式连接到PostgreSQL数据库。'
- en: '*Spring Boot Test* (org.springframework.boot:spring-boot-starter-test)—Provides
    several libraries and utilities to test applications, including Spring Test, JUnit,
    AssertJ, and Mockito. It’s automatically included in every Spring Boot project.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Boot Test* (org.springframework.boot:spring-boot-starter-test)—提供用于测试应用程序的多个库和实用工具，包括Spring
    Test、JUnit、AssertJ和Mockito。它自动包含在每一个Spring Boot项目中。'
- en: '*Reactor Test* (io.projectreactor:reactor-test)—Provides utilities to test
    reactive applications based on Project Reactor. It’s automatically included in
    every reactive Spring Boot project.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Reactor Test* (io.projectreactor:reactor-test)—提供基于Project Reactor测试响应式应用程序的实用工具。它自动包含在每一个响应式Spring
    Boot项目中。'
- en: '*Testcontainers* (org.testcontainers:junit-jupiter, org.testcontainers:postgresql,
    org.testcontainers:r2dbc)—Provides the necessary libraries for testing applications
    using lightweight Docker containers. In particular, it provides test containers
    for PostgreSQL supporting the R2DBC driver.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Testcontainers* (org.testcontainers:junit-jupiter, org.testcontainers:postgresql,
    org.testcontainers:r2dbc)—提供使用轻量级Docker容器测试应用程序所需的库。特别是，它为支持R2DBC驱动的PostgreSQL提供测试容器。'
- en: The default and recommended embedded server for reactive applications in Spring
    Boot is Reactor Netty, which is built on top of Netty to provide reactive capabilities
    within Project Reactor. You can configure it either through properties or by defining
    a WebServerFactoryCustomizer<NettyReactiveWebServerFactory> component. Let’s use
    the first approach.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot中响应式应用程序的默认和推荐嵌入服务器是Reactor Netty，它基于Netty构建，在Project Reactor中提供响应式功能。你可以通过属性或通过定义一个WebServerFactoryCustomizer<NettyReactiveWebServerFactory>组件来配置它。让我们使用第一种方法。
- en: First of all, rename the application.properties file generated by Spring Initializr
    to application.yml, and define the application name using the spring.application.name
    property. Like you did for Tomcat, you can define the server port through the
    server.port property, configure the graceful shutdown through server.shutdown,
    and set the grace period with spring.lifecycle.timeout-per-shutdown-phase. Using
    the specific Netty properties, you can further customize the server’s behavior.
    For example, you can define connection and idle timeouts for Netty with the server.netty
    .connection-timeout and server.netty.idle-timeout properties.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将Spring Initializr生成的application.properties文件重命名为application.yml，并使用spring.application.name属性定义应用程序名称。就像为Tomcat做的那样，你可以通过server.port属性定义服务器端口，通过server.shutdown配置优雅关闭，并通过spring.lifecycle.timeout-per-shutdown-phase设置宽限期。使用特定的Netty属性，你可以进一步自定义服务器的行为。例如，你可以使用server.netty.connection-timeout和server.netty.idle-timeout属性为Netty定义连接和空闲超时。
- en: Listing 8.1 Configuring Netty server and graceful shutdown
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 配置Netty服务器和优雅关闭
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The port where the server will accept connections
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 服务器将接受连接的端口
- en: ❷ Enables graceful shutdown
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启用优雅关闭
- en: ❸ How long to wait for a TCP connection to be established with the server
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 等待与服务器建立TCP连接的时间长度
- en: ❹ How long to wait before closing a TCP connection if no data is transferred
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果没有数据传输，则在关闭TCP连接之前等待的时间长度
- en: ❺ Defines a 15 s grace period
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 定义了15秒的宽限期
- en: With this basic setup in place, we can now define the domain entity and its
    persistence.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基本设置到位后，我们现在可以定义领域实体及其持久化。
- en: 8.2.2 Persisting data reactively with Spring Data R2DBC
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 使用 Spring Data R2DBC 反应式持久化数据
- en: In chapter 5, you learned that interactions between a Spring Boot application
    and a database involve database drivers, entities, and repositories. The same
    concepts you learned in the context of Spring Data JDBC also apply to Spring Data
    R2DBC. Spring Data provides common abstractions and patterns, making it straightforward
    to navigate the different modules.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，您了解到 Spring Boot 应用程序与数据库之间的交互涉及数据库驱动程序、实体和仓库。您在 Spring Data JDBC 的上下文中学习的相同概念也适用于
    Spring Data R2DBC。Spring Data 提供了常见的抽象和模式，使得在不同模块之间导航变得简单。
- en: The main difference for Order Service, compared to Catalog Service, is the type
    of database driver. JDBC is the most common driver used by Java applications to
    communicate with a relational database, but it doesn’t support reactive programming.
    There have been a few attempts to provide reactive access to a relational database.
    One project that stood out and that is widely supported is Reactive Relational
    Database Connectivity (R2DBC) initiated by Pivotal (now VMware Tanzu). R2DBC drivers
    are available for all the major databases (such as PostgreSQL, MariaDB, MySQL,
    SQL Server, and Oracle DB), and there are clients for several projects, including
    Spring Boot with Spring Data R2DBC and Testcontainers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与目录服务相比，订单服务的主要区别在于数据库驱动程序的类型。JDBC 是 Java 应用程序与关系型数据库通信最常用的驱动程序，但它不支持反应式编程。已经有一些尝试提供对关系型数据库的反应式访问。一个突出且得到广泛支持的项目是由
    Pivotal（现在是 VMware Tanzu）发起的反应式关系型数据库连接（R2DBC）。R2DBC 驱动程序适用于所有主要数据库（如 PostgreSQL、MariaDB、MySQL、SQL
    Server 和 Oracle DB），并且有多个项目的客户端，包括带有 Spring Data R2DBC 的 Spring Boot 和 Testcontainers。
- en: This section will guide you through defining a domain entity and a persistence
    layer for Order Service using Spring Data R2DBC and PostgreSQL. Let’s get started.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您使用 Spring Data R2DBC 和 PostgreSQL 定义订单服务的领域实体和持久化层。让我们开始吧。
- en: Run a PostgreSQL database for Order Service
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行订单服务的 PostgreSQL 数据库
- en: First of all, we need a database. We’ll adopt a *database-per-service* approach
    to keep our applications loosely coupled. Having decided that Catalog Service
    and Order Service will have a database each, we have two options for the actual
    storage. We could either use the same database server for both databases or two
    different ones. For convenience, we’ll use the same PostgreSQL server we set up
    in chapter 5 to host both the polardb_catalog database used by Catalog Service
    and the new polardb_order database used by Order Service.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个数据库。我们将采用“每个服务一个数据库”的方法来保持我们的应用程序松散耦合。既然我们决定目录服务和订单服务各自将有一个数据库，我们有两个实际的存储选项。我们可以使用相同的数据库服务器为两个数据库服务，或者使用两个不同的服务器。为了方便，我们将使用第
    5 章中设置的相同的 PostgreSQL 服务器来托管目录服务使用的 polardb_catalog 数据库和订单服务使用的新 polardb_order
    数据库。
- en: Go to your polar-deployment repository, and create a new docker/postgresql folder.
    Then add a new init.sql file in the folder. Add the following code to the init.sql
    file; it is the initialization script that PostgreSQL should run during the startup
    phase.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前往您的 polar-deployment 仓库，并创建一个新的 docker/postgresql 文件夹。然后在文件夹中添加一个新的 init.sql
    文件。将以下代码添加到 init.sql 文件中；这是 PostgreSQL 在启动阶段应运行的初始化脚本。
- en: Listing 8.2 Initializing the PostgreSQL server with two databases
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 使用两个数据库初始化 PostgreSQL 服务器
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, open the docker-compose.yml file and update the PostgreSQL container definition
    to load the initialization script. Remember to remove the value for the POSTGRES_DB
    environment variable, since we’ll now delegate the database creation to the script.
    In the book’s source code, refer to Chapter08/08-end/polar-deployment/docker to
    check the final result.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 docker-compose.yml 文件，并更新 PostgreSQL 容器定义以加载初始化脚本。请记住删除 POSTGRES_DB 环境变量的值，因为我们现在将数据库创建委托给脚本。在本书的源代码中，请参考
    Chapter08/08-end/polar-deployment/docker 检查最终结果。
- en: Listing 8.3 Initializing the PostgreSQL server from an SQL script
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 从 SQL 脚本初始化 PostgreSQL 服务器
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ No value is defined for POSTGRES_DB anymore.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 已不再为 POSTGRES_DB 定义值。
- en: ❷ Mounts the initialization SQL script to the container as a volume
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将初始化 SQL 脚本挂载到容器中作为卷
- en: 'Finally, start a new PostgreSQL container based on the new configuration. Open
    a Terminal window, navigate to the folder where you defined the docker-compose.yml
    file, and run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据新的配置启动一个新的 PostgreSQL 容器。打开一个终端窗口，导航到定义 docker-compose.yml 文件的文件夹，并运行以下命令：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the rest of the chapter, I will assume you have the database up and running.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我将假设您的数据库已经启动并运行。
- en: Connecting to a database with R2DBC
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R2DBC 连接到数据库
- en: Spring Boot lets you configure the integration of a reactive application with
    a relational database through the spring.r2dbc properties. Open the application.yml
    file for the Order Service project, and configure the connection with PostgreSQL.
    Connection pooling is enabled by default, and you can further configure it by
    defining connection timeout and sizes, just like you did for JDBC in chapter 5\.
    Since it’s a reactive application, the connection pool will probably be smaller
    than when using JDBC. You can tune the values after monitoring your applications
    running under normal conditions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 允许您通过 spring.r2dbc 属性配置一个反应式应用程序与关系型数据库的集成。打开 Order Service 项目的
    application.yml 文件，并配置与 PostgreSQL 的连接。默认情况下启用连接池，您可以进一步通过定义连接超时和大小来配置它，就像在第5章中为
    JDBC 所做的那样。由于它是一个反应式应用程序，连接池可能比使用 JDBC 时要小。您可以在监控应用程序在正常条件下的运行后调整这些值。
- en: Listing 8.4 Configuring the database integration over R2DBC
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 通过 R2DBC 配置数据库集成
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ A user with privileges to access the given database
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 具有访问给定数据库权限的用户
- en: ❷ The password for the given user
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 给定用户的密码
- en: ❸ The R2DBC URL identifying the database you want to establish a connection
    with
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 识别您想要建立连接的数据库的 R2DBC URL
- en: ❹ The maximum time to wait to get a connection from the pool
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从池中获取连接的最大等待时间
- en: ❺ The initial size of the connection pool
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 连接池的初始大小
- en: ❻ The maximum number of connections kept in the pool
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 池中保持的最大连接数
- en: Now that you have connected a reactive Spring Boot application to a PostgreSQL
    database through an R2DBC driver, you can go ahead and define the data you want
    to persist.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经通过 R2DBC 驱动程序将一个反应式 Spring Boot 应用程序连接到了 PostgreSQL 数据库，您可以继续定义您想要持久化的数据。
- en: Defining persistent entities
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 定义持久化实体
- en: The Order Service application provides functionality for submitting and retrieving
    orders. That’s the *domain entity*. Add a new com.polarbookshop.orderservice.order
    .domain package for the business logic, and create an Order Java record to represent
    the domain entity, much like you defined Book in Catalog Service.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Order Service 应用程序提供了提交和检索订单的功能。这就是 *领域实体*。为业务逻辑添加一个新的 com.polarbookshop.orderservice.order
    .domain 包，并创建一个 Order Java 记录来表示领域实体，就像您在 Catalog Service 中定义 Book 一样。
- en: Following the same approach used in chapter 5, use the @Id annotation to mark
    the field representing the primary key in the database, and use @Version to provide
    a version number, which is essential for handling concurrent updates and using
    optimistic locking. You can also add the necessary fields to hold audit metadata
    using the @CreatedDate and @LastModifiedDate annotations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第5章中使用的方法，使用 @Id 注解标记数据库中代表主键的字段，并使用 @Version 提供一个版本号，这对于处理并发更新和使用乐观锁至关重要。您还可以添加必要的字段来存储审计元数据，使用
    @CreatedDate 和 @LastModifiedDate 注解。
- en: The default strategy for mapping an entity to a relational table is to transform
    the Java object name into lowercase. In this example, Spring Data would try to
    map the Order record to an order table. The problem is that order is a reserved
    word in SQL. It’s not recommended that you use it as a table name because it would
    require special handling. You can overcome that issue by naming the table orders
    and configuring the object-relational mapping through the @Table annotation (from
    the org.springframework.data.relational.core.mapping package).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将实体映射到关系表的默认策略是将 Java 对象名称转换为小写。在这个例子中，Spring Data 会尝试将 Order 记录映射到 order 表。问题是
    order 是 SQL 中的一个保留词。不建议将其用作表名，因为它需要特殊处理。您可以通过将表命名为 orders 并通过 @Table 注解（来自 org.springframework.data.relational.core.mapping
    包）配置对象关系映射来克服这个问题。
- en: Listing 8.5 The Order record defines the domain and persistent entity
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 Order 记录定义了领域和持久化实体
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Configures the mapping between the “Order” object and the “orders” table
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置“Order”对象与“orders”表之间的映射
- en: ❷ The primary key of the entity
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 实体的主键
- en: ❸ When the entity was created
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 实体创建的时间
- en: ❹ When the entity was modified the last time
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 实体上次修改的时间
- en: ❺ The entity’s version number
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 实体的版本号
- en: Orders can go through different phases. If the requested book is available in
    the catalog, then the order is *accepted*. If not, it’s *rejected*. Once the order
    is accepted, it can be *dispatched*, as you’ll see in chapter 10\. You can define
    these three statuses in an OrderStatus enum in the com.polarbookshop.orderservice.order.domain
    package.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 订单可以经历不同的阶段。如果请求的书籍在目录中可用，则订单将被 *接受*。如果不可用，则被 *拒绝*。一旦订单被接受，它就可以被 *发货*，正如你在第
    10 章中看到的。你可以在 com.polarbookshop.orderservice.order.domain 包中的 OrderStatus 枚举中定义这三个状态。
- en: Listing 8.6 Enum describing the statuses for the orders
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 描述订单状态的枚举
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The R2DBC auditing functionality can be enabled in a configuration class using
    the @EnableR2dbcAuditing annotation. Create a DataConfig class in a new com.polarbookshop.orderservice.config
    package, and enable auditing there.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 @EnableR2dbcAuditing 注解在配置类中启用 R2DBC 审计功能。在新的 com.polarbookshop.orderservice.config
    包中创建一个 DataConfig 类，并在此处启用审计。
- en: Listing 8.7 Enabling R2DBC auditing via annotation configuration
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 通过注解配置启用 R2DBC 审计
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Indicates a class as a source of Spring configuration
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将一个类标记为 Spring 配置的来源
- en: ❷ Enables R2DBC auditing for persistent entities
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启用 R2DBC 审计以持久化实体
- en: Having defined the data you want to persist, you can go ahead and explore how
    to access it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了要持久化的数据后，你可以继续探索如何访问它。
- en: Using reactive repositories
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反应式仓库
- en: Spring Data provides the *repository* abstraction for all the modules in the
    project, including R2DBC. The only difference between this and what you did in
    chapter 5 is that you’re going to use a reactive repository.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 为项目中的所有模块提供 *repository* 抽象，包括 R2DBC。与第 5 章中你所做不同的是，你将使用一个反应式仓库。
- en: In the com.polarbookshop.orderservice.order.domain package, create a new OrderRepository
    interface and make it extend ReactiveCrudRepository, specifying the type of data
    handled (Order) and the data type of the @Id-annotated field (Long).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 com.polarbookshop.orderservice.order.domain 包中，创建一个新的 OrderRepository 接口，并使其扩展
    ReactiveCrudRepository，指定处理的数据类型（订单）和 @Id 注解字段的 数据类型（Long）。
- en: Listing 8.8 Repository interface for accessing orders
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 用于访问订单的仓库接口
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Extends a reactive repository providing CRUD operations, specifies the type
    of managed entity (Order), and its primary key type (Long)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 扩展反应式仓库以提供 CRUD 操作，指定管理实体的类型（订单）及其主键类型（Long）
- en: The CRUD operations provided by ReactiveCrudRepository are enough for the use
    cases of the Order Service application, so you won’t need to add any custom methods.
    However, we’re still missing the orders table in the database. Let’s define it
    using Flyway.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveCrudRepository 提供的 CRUD 操作足以满足订单服务应用程序的使用案例，因此你不需要添加任何自定义方法。然而，我们仍然缺少数据库中的订单表。让我们使用
    Flyway 来定义它。
- en: Managing database schemas with Flyway
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flyway 管理数据库模式
- en: Spring Data R2DBC supports initializing data sources through schema.sql and
    data.sql files, just like Spring Data JDBC. As you learned in chapter 5, that
    functionality is convenient for demos and experiments, but it’s better to manage
    schemas explicitly for production use cases.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data R2DBC 支持通过 schema.sql 和 data.sql 文件初始化数据源，就像 Spring Data JDBC 一样。正如你在第
    5 章中学到的，这个功能对于演示和实验来说很方便，但最好在生产用例中显式管理模式。
- en: For Catalog Service we used Flyway to create and evolve its database schemas.
    We can do the same for Order Service. However, Flyway doesn’t support R2DBC yet,
    so we need to provide a JDBC driver to communicate with the database. The Flyway
    migration tasks are only run at application startup and in a single thread, so
    using a non-reactive communication approach for this one case doesn’t impact the
    overall application’s scalability and efficiency.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目录服务，我们使用了 Flyway 来创建和演进其数据库模式。我们也可以为订单服务做同样的事情。然而，Flyway 目前还不支持 R2DBC，因此我们需要提供一个
    JDBC 驱动程序来与数据库通信。Flyway 迁移任务仅在应用程序启动时和在单个线程中运行，所以在这个特定情况下使用非反应式通信方法不会影响应用程序的整体可伸缩性和效率。
- en: In the build.gradle file for your Order Service project, add new dependencies
    to Flyway, the PostgreSQL JDBC driver, and Spring JDBC. Remember to refresh or
    reimport the Gradle dependencies after the new addition.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的订单服务项目的 build.gradle 文件中，添加新的依赖项到 Flyway、PostgreSQL JDBC 驱动程序和 Spring JDBC。记得在添加新依赖项后刷新或重新导入
    Gradle 依赖项。
- en: Listing 8.9 Adding a dependency for Flyway and JDBC in Order Service
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 在订单服务中添加 Flyway 和 JDBC 依赖项
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Provides functionality to version-control your database through migrations
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供通过迁移来版本控制数据库的功能
- en: ❷ Provides a JDBC driver that allows the application to connect to a PostgreSQL
    database
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提供一个 JDBC 驱动，允许应用程序连接到 PostgreSQL 数据库
- en: ❸ Provides Spring integration with the JDBC API. It’s part of the Spring Framework,
    not to be confused with Spring Data JDBC.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提供了与 JDBC API 的 Spring 集成。它是 Spring 框架的一部分，不要与 Spring Data JDBC 混淆。
- en: Then you can write the SQL script for creating the orders table in a V1__Initial_
    schema.sql file under src/main/resources/db/migration. Ensure you type two underscores
    after the version number.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在 `src/main/resources/db/migration` 目录下的 V1__Initial_ schema.sql 文件中编写创建订单表的
    SQL 脚本。确保在版本号后输入两个下划线。
- en: Listing 8.10 Flyway migration script for schema initialization
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 用于模式初始化的 Flyway 迁移脚本
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Definition of the orders table
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 订单表的定义
- en: ❷ Declares the id field as the primary key
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 id 字段声明为主键
- en: Finally, open the application.yml file, and configure Flyway to use the same
    database managed with Spring Data R2DBC but using the JDBC driver.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 `application.yml` 文件，并配置 Flyway 以使用与 Spring Data R2DBC 管理的相同数据库，但使用 JDBC
    驱动。
- en: Listing 8.11 Configuring the Flyway integration over JDBC
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 通过 JDBC 配置 Flyway 集成
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Gets the value from the username configured for R2DBC
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从为 R2DBC 配置的用户名中获取值
- en: ❷ Gets the value from the password configured for R2DBC
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从为 R2DBC 配置的密码中获取值
- en: ❸ The same database configured for R2DBC but using the JDBC driver
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 JDBC 驱动的与 R2DBC 配置相同的数据库
- en: 'As you probably noticed, defining domain objects and adding a persistence layer
    in a reactive application is similar to what you would do with imperative applications.
    The main differences you encountered in this session are using the R2DBC driver
    instead of JDBC and having a separate Flyway configuration (at least until R2DBC
    support is added to the Flyway project: [https://github.com/flyway/flyway/issues/2502](https://github.com/flyway/flyway/issues/2502)).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你或许注意到的，在反应式应用程序中定义域对象和添加持久化层与你在命令式应用程序中要做的事情类似。在这个会话中你遇到的主要区别是使用 R2DBC 驱动而不是
    JDBC，并且有一个独立的 Flyway 配置（至少直到 R2DBC 支持被添加到 Flyway 项目：[https://github.com/flyway/flyway/issues/2502](https://github.com/flyway/flyway/issues/2502))。
- en: In the next section you’ll learn how to use Mono and Flux in your business logic.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个部分中，你将学习如何在业务逻辑中使用 `Mono` 和 `Flux`。
- en: 8.2.3 Implementing the business logic with reactive streams
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 使用反应式流实现业务逻辑
- en: The Spring reactive stack makes it straightforward to build asynchronous, non-blocking
    applications. In the previous section, we used Spring Data R2DBC and didn’t have
    to deal with any underlying reactive concerns. That’s generally true for all the
    reactive modules in Spring. As a developer, you can rely on a familiar, simple,
    and productive approach for building reactive applications while the framework
    takes care of all the heavy lifting.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 反应式堆栈使得构建异步、非阻塞应用程序变得简单直接。在上一个部分中，我们使用了 Spring Data R2DBC 并且不需要处理任何底层的反应式问题。这对于
    Spring 中所有的反应式模块都是普遍适用的。作为开发者，你可以依赖一个熟悉、简单且高效的方法来构建反应式应用程序，而框架则负责所有繁重的工作。
- en: By default, Spring WebFlux assumes that everything is reactive. This assumption
    means that you’re expected to interact with the framework by exchanging Publisher<T>
    objects like Mono<T> and Flux<T>. For example, the OrderRepository we created
    earlier will give access to orders as Mono<Order> and Flux<Order> objects instead
    of returning Optional<Order> and Collection<Order> like it would do in a non-reactive
    context. Let’s see that in action.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring WebFlux 假设一切都是反应式的。这个假设意味着你期望通过交换 `Publisher<T>` 对象（如 `Mono<T>`
    和 `Flux<T>`）与框架交互。例如，我们之前创建的 `OrderRepository` 将会以 `Mono<Order>` 和 `Flux<Order>`
    对象的形式提供订单访问，而不是像在非反应式环境中那样返回 `Optional<Order>` 和 `Collection<Order>`。让我们看看这是如何实现的。
- en: In the com.polarbookshop.orderservice.order.domain package, create a new OrderService
    class. For starters, let’s implement the logic to read orders through the repository.
    When multiple orders are involved, you can use a Flux<Order> object, representing
    an asynchronous sequence of zero or more orders.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `com.polarbookshop.orderservice.order.domain` 包中，创建一个新的 `OrderService` 类。首先，让我们实现通过仓库读取订单的逻辑。当涉及多个订单时，你可以使用
    `Flux<Order>` 对象，它代表零个或多个订单的异步序列。
- en: Listing 8.12 Fetching orders via a reactive stream
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 通过反应式流获取订单
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Stereotype annotation that marks a class to be a service managed by Spring
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标记一个类为 Spring 管理的服务的类型注解
- en: ❷ A Flux is used to publish multiple orders (0..N)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Flux 发布多个订单（0..N）
- en: Next, we need a method to submit orders. Until we have the integration with
    Catalog Service in place, we can always default to rejecting submitted orders.
    OrderRepository exposes a save() method provided by ReactiveCrudRepository. You
    can build a reactive stream to pass an object of type Mono<Order> to OrderRepository
    that will save the order in the database.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个提交订单的方法。在我们与 Catalog 服务集成到位之前，我们总是可以默认拒绝提交的订单。OrderRepository 暴露了由
    ReactiveCrudRepository 提供的 save() 方法。你可以构建一个反应流，将类型为 Mono<Order> 的对象传递给 OrderRepository，以便在数据库中保存订单。
- en: Given an ISBN identifying a book and the number of copies to order, you can
    build a Mono object with Mono.just() in the same way you would build a Java Stream
    object with Stream.of(). The difference is in the reactive behavior.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个识别书籍的 ISBN 和要订购的副本数量，你可以使用 Mono.just() 创建一个 Mono 对象，就像使用 Stream.of() 创建
    Java Stream 对象一样。区别在于反应行为。
- en: You can use the Mono object to start a reactive stream and then rely on the
    flatMap() operator to pass the data to OrderRepository. Add the following code
    to the OrderService class, and complete the business logic implementation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Mono 对象来启动一个反应流，然后依靠 flatMap() 操作符将数据传递到 OrderRepository。将以下代码添加到 OrderService
    类中，并完成业务逻辑实现。
- en: Listing 8.13 Persisting rejected orders upon submitting order requests
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 在提交订单请求时持久化拒绝的订单
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Creates a “Mono” out of an “Order” object
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从“Order”对象创建一个“Mono”
- en: ❷ Saves the Order object produced asynchronously by the previous step of the
    reactive stream into the database
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将由反应流前一步异步产生的 Order 对象保存到数据库中
- en: ❸ When an order is rejected, we only specify ISBN, quantity, and status. Spring
    Data takes care of adding identifier, version, and audit metadata.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当订单被拒绝时，我们只指定 ISBN、数量和状态。Spring Data 会负责添加标识符、版本和审计元数据。
- en: map vs. flatMap
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: map 与 flatMap 的比较
- en: When using Reactor, choosing between the map() and flatMap() operators is usually
    a source of confusion. Both operators return a reactive stream (either Mono<T>
    or Flux<T>), but while map() maps between two standard Java types, flatMap() maps
    from a Java type to another reactive stream.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Reactor 时，选择 map() 和 flatMap() 操作符通常是一个令人困惑的来源。这两个操作符都返回一个反应流（要么是 Mono<T>
    要么是 Flux<T>），但 while map() 在两个标准 Java 类型之间映射，flatMap() 则从 Java 类型映射到另一个反应流。
- en: In listing 8.13, we map from an object of type Order to a Mono<Order> (which
    is returned by OrderRepository). Since the map() operator expects the target type
    not to be a reactive stream, it will wrap it in one nevertheless and return a
    Mono<Mono<Order>> object. On the other hand, the flatMap() operator expects the
    target type to be a reactive stream, so it knows how to handle the publisher produced
    by OrderRepository and returns a Mono<Order> object correctly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.13 中，我们将 Order 类型的对象映射到 Mono<Order>（由 OrderRepository 返回）。由于 map() 操作符期望目标类型不是反应流，但它仍然会将其包装在一个反应流中，并返回一个
    Mono<Mono<Order>> 对象。另一方面，flatMap() 操作符期望目标类型是反应流，因此它知道如何处理 OrderRepository 生成的发布者，并正确地返回一个
    Mono<Order> 对象。
- en: In the next section, you’ll complete the basic implementation of Order Service
    by exposing an API to fetch and submit orders.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将通过暴露一个用于获取和提交订单的 API 来完成 Order 服务的基本实现。
- en: 8.2.4 Exposing a REST API with Spring WebFlux
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 使用 Spring WebFlux 暴露 REST API
- en: 'There are two options for defining RESTful endpoints in a Spring WebFlux application:
    @RestController classes or functional beans (router functions). For the Order
    Service application, we’ll use the first option. Unlike what we did in chapter
    3, the method handlers will return reactive objects.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring WebFlux 应用程序中定义 RESTful 端点有两种选择：@RestController 类或功能豆（路由函数）。对于 Order
    服务应用程序，我们将使用第一种选项。与第 3 章中我们所做的不同，方法处理器将返回反应对象。
- en: For the GET endpoint, we can use the Order domain entity we defined earlier
    and return a Flux<Order> object. When submitting an order, the user must provide
    the ISBN of the desired book and the number of copies they would like to purchase.
    We can model that information in an OrderRequest record that will act as a data
    transfer object (DTO). It’s also good practice to validate the input, as you learned
    in chapter 3.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GET 端点，我们可以使用我们之前定义的 Order 领域实体，并返回一个 Flux<Order> 对象。当提交订单时，用户必须提供所需书籍的 ISBN
    和他们想要购买的副本数量。我们可以在 OrderRequest 记录中建模这些信息，该记录将充当数据传输对象（DTO）。按照第 3 章中学到的，验证输入也是一个好的实践。
- en: Create a new com.polarbookshop.orderservice.order.web package, and define an
    OrderRequest record to hold the submitted order information.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 com.polarbookshop.orderservice.order.web 包，并定义一个 OrderRequest 记录来保存提交的订单信息。
- en: Listing 8.14 The OrderRequest DTO class with validation constraints
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 带有验证约束的OrderRequest DTO类
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Must not be null and must contain at least one non-whitespace character
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不能为null，并且必须包含至少一个非空白字符
- en: ❷ Must not be null and must contain a value from 1 to 5
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 不能为null，并且必须包含1到5之间的值
- en: In the same package, create an OrderController class to define the two RESTful
    endpoints exposed by the Order Service application. Since you defined validation
    constraints for the OrderRequest object, you also need to use the familiar @Valid
    annotation to trigger the validation when the method is called.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个包中，创建一个OrderController类来定义Order Service应用程序暴露的两个RESTful端点。由于你为OrderRequest对象定义了验证约束，因此你还需要使用熟悉的@Valid注解来在方法调用时触发验证。
- en: Listing 8.15 Defining handlers to process REST requests
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 定义处理程序以处理REST请求
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Stereotype annotation marking a class as a Spring component and a source of
    handlers for REST endpoints
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 轮廓注解标记一个类为Spring组件和REST端点的处理程序源
- en: ❷ Identifies the root path mapping URI for which the class provides handlers
    (/orders)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确定类提供的处理程序的根路径映射URI（/orders）
- en: ❸ A Flux is used to publish multiple orders (0..N).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用Flux发布多个订单（0..N）。
- en: ❹ Accepts an OrderRequest object, validated and used to create an order. The
    created order is returned as a Mono.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 接受一个OrderRequest对象，对其进行验证并用于创建订单。创建的订单作为Mono返回。
- en: 'This REST controller completes our basic implementation of the Order Service
    application. Let’s see it in action. First, make sure the PostgreSQL container
    you created earlier is still running. Then open a Terminal window, navigate to
    the Order Service project’s root folder, and run the application:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个REST控制器完成了Order Service应用程序的基本实现。让我们看看它的实际效果。首先，确保你之前创建的PostgreSQL容器仍在运行。然后打开一个终端窗口，导航到Order
    Service项目的根文件夹，并运行应用程序：
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can try out the API by submitting an order. The application will save the
    order as rejected and return a 200 response to the client:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提交一个订单来尝试API。应用程序会将订单保存为已拒绝，并向客户端返回200响应：
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To make it possible to submit orders successfully, we’ll need to make Order
    Service call Catalog Service to check the book’s availability and fetch the necessary
    information for processing the order. That’s the focus of the next section. Before
    moving on, stop the application with Ctrl-C.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够成功提交订单，我们需要让Order Service调用Catalog Service来检查书籍的可用性并获取处理订单所需的信息。这是下一节的重点。在继续之前，使用Ctrl-C停止应用程序。
- en: 8.3 Reactive clients with Spring WebClient
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 使用Spring WebClient的响应式客户端
- en: In a cloud native system, applications can interact in different ways. This
    section focuses on the request/response interactions over HTTP that you’ll establish
    between Order Service and Catalog Service. In this kind of interaction, the client
    making the request expects to receive a response. In an imperative application,
    that would translate into a thread blocking until a response is returned. Instead,
    in a reactive application, we can use resources more efficiently so that no thread
    will wait for a response, freeing up resources to deal with other processing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个云原生系统中，应用程序可以以不同的方式交互。本节重点介绍Order Service和Catalog Service之间通过HTTP建立的请求/响应交互。在这种交互中，发起请求的客户端期望收到响应。在命令式应用程序中，这会转化为线程阻塞，直到返回响应。相反，在响应式应用程序中，我们可以更有效地使用资源，这样就没有线程会等待响应，从而释放资源来处理其他处理。
- en: 'The Spring Framework comes bundled with two clients that perform HTTP requests:
    RestTemplate and WebClient. RestTemplate is the original Spring REST client that
    allows blocking HTTP request/response interactions based on a template method
    API. Since Spring Framework 5.0, it’s in maintenance mode and practically deprecated.
    It’s still widely used, but it will not get any new functionality in future releases.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架附带两个执行HTTP请求的客户端：RestTemplate和WebClient。RestTemplate是原始的Spring REST客户端，它允许基于模板方法API的阻塞HTTP请求/响应交互。自Spring
    Framework 5.0以来，它处于维护模式，实际上已被弃用。它仍然被广泛使用，但在未来的版本中不会获得任何新功能。
- en: WebClient is the modern alternative to RestTemplate. It provides blocking and
    non-blocking I/O, making it the perfect candidate for both imperative and reactive
    applications. It can be operated through a functional-style, fluent API that lets
    you configure any aspect of the HTTP interaction.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: WebClient是RestTemplate的现代替代品。它提供阻塞和非阻塞I/O，使其成为命令式和响应式应用程序的完美候选者。它可以通过函数式风格的流畅API操作，允许你配置HTTP交互的任何方面。
- en: This section will teach you how to use WebClient to establish non-blocking request/response
    interactions. I will also explain how to make your application more resilient
    by adopting patterns like timeouts, retries, and failovers using the Reactor operators
    timeout(), retryWhen(), and onError().
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您介绍如何使用 WebClient 建立非阻塞的请求/响应交互。我还会解释如何通过采用超时、重试和故障转移等模式，使用 Reactor 操作符
    timeout()、retryWhen() 和 onError() 来提高您的应用程序的健壮性。
- en: 8.3.1 Service-to-service communication in Spring
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 Spring 中的服务间通信
- en: As per the 15-Factor methodology, any backing service should be attached to
    an application through resource binding. For databases, you relied on the configuration
    properties provided by Spring Boot to specify credentials and the URL. When a
    backing service is another application, you need to provide its URL in a similar
    way. Following the externalized configuration principle, the URL should be configurable,
    not hardcoded. In Spring, you can achieve that through a @ConfigurationProperties
    bean, as you learned in chapter 4.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 15-Factor 方法论，任何后端服务都应该通过资源绑定附加到应用程序。对于数据库，您依赖于 Spring Boot 提供的配置属性来指定凭据和
    URL。当后端服务是另一个应用程序时，您需要以类似的方式提供其 URL。遵循外部化配置原则，URL 应该是可配置的，而不是硬编码的。在 Spring 中，您可以通过
    @ConfigurationProperties bean 实现这一点，正如您在第 4 章中学到的。
- en: In the Order Service project, add a ClientProperties record in the com.polarbookshop.orderservice.config
    package. There, define your custom polar.catalog-service-uri property to configure
    the URI for calling the Catalog Service.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Order Service 项目中，在 com.polarbookshop.orderservice.config 包中添加一个 ClientProperties
    记录。在那里，定义您的自定义 polar.catalog-service-uri 属性来配置调用目录服务的 URI。
- en: Listing 8.16 Defining a custom property for the Catalog Service URI
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 为目录服务 URI 定义自定义属性
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The prefix for the custom properties
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 自定义属性的名称前缀
- en: ❷ The property for specifying the Catalog Service URI. It cannot be null.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于指定目录服务 URI 的属性。它不能为空。
- en: Note To get autocompletion and type-validation checks from your IDE, you need
    to add a dependency on org.springframework.boot:spring-boot-configuration-processor
    with scope annotationProcessor in the build .gradle file, like you did in chapter
    4\. You can refer to the Chapter08/08-end/order-service/build.gradle file in the
    code repository accompanying the book to check the final result ([https://github.com/ThomasVitale/cloud-native
    -spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了从您的 IDE 获取自动完成和类型验证检查，您需要在 build.gradle 文件中添加对 org.springframework.boot:spring-boot-configuration-processor
    的依赖，范围设置为 annotationProcessor，就像您在第 4 章中做的那样。您可以通过查看代码库中随书附带的 Chapter08/08-end/order-service/build.gradle
    文件来检查最终结果（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: Then, enable the custom configuration properties in your OrderServiceApplication
    class using the @ConfigurationPropertiesScan annotation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 @ConfigurationPropertiesScan 注解在 OrderServiceApplication 类中启用自定义配置属性。
- en: Listing 8.17 Enabling custom configuration properties
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 启用自定义配置属性
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Loads configuration data beans in the Spring context
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Spring 上下文中加载配置数据 Bean
- en: Finally, add a value for the new property to your application.yml file. As a
    default, you can use the URI for the Catalog Service instance running in your
    local environment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将新属性的值添加到您的 application.yml 文件中。默认情况下，您可以使用运行在本地环境中的目录服务实例的 URI。
- en: Listing 8.18 Configuring the URI for Catalog Service (application.yml)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 配置目录服务的 URI（application.yml）
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note When deploying the system with Docker Compose or Kubernetes, you can override
    the property value via an environment variable, taking advantage of the service
    discovery features offered by the two platforms.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当使用 Docker Compose 或 Kubernetes 部署系统时，您可以通过环境变量覆盖属性值，利用这两个平台提供的服务发现功能。
- en: In the next section, you’ll use the value configured through this property to
    call the Catalog Service from Order Service.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将使用通过此属性配置的值从订单服务调用目录服务。
- en: 8.3.2 Understanding how to exchange data
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 理解如何交换数据
- en: Whenever a user submits an order for a specific book, Order Service needs to
    call Catalog Service to check the requested book’s availability and fetch its
    details, like the title, author, and price. The interaction (HTTP request/response)
    is illustrated in figure 8.6.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交特定书籍的订单时，订单服务需要调用目录服务来检查请求的书籍的可用性并获取其详细信息，如标题、作者和价格。交互（HTTP 请求/响应）如图 8.6
    所示。
- en: '![08-06](../Images/08-06.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![08-06](../Images/08-06.png)'
- en: Figure 8.6 When an order is submitted, Order Service calls Catalog Service over
    HTTP to check the book’s availability and fetch its details.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 当提交订单时，订单服务通过HTTP调用目录服务以检查书籍的可用性并获取其详细信息。
- en: Each order request is submitted for a specific ISBN. Order Service needs to
    know the book’s ISBN, title, author, and price to process an order correctly.
    Currently, Catalog Service exposes a /books/{bookIsbn} endpoint that returns all
    the available information about a book. In a real scenario, you might expose a
    different endpoint that returns an object containing only the required information
    (a DTO). For the sake of this example, we’ll reuse the existing endpoint, since
    our focus right now is on building reactive clients.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每个订单请求都是针对特定的ISBN提交的。订单服务需要知道书籍的ISBN、标题、作者和价格才能正确处理订单。目前，目录服务公开了一个返回关于书籍所有可用信息的/books/{bookIsbn}端点。在真实场景中，你可能公开一个返回仅包含所需信息的对象的不同端点（一个DTO）。为了这个示例，我们将重用现有的端点，因为我们现在的重点是构建响应式客户端。
- en: 'Having established which endpoint to call, how should you model the exchange
    between the two applications? You’ve just reached a crossroad:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 已经确定了要调用的端点，那么应该如何建模两个应用程序之间的交换？你刚刚到达一个十字路口：
- en: '*Create a shared library*—One option is to create a shared library with the
    classes used by both applications, and import it as a dependency into both projects.
    As per the 15-factor methodology, such a library would be tracked in its own codebase.
    Doing so would ensure that the model used by both applications is consistent and
    never out of sync. However, it would mean adding implementation coupling.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建共享库*—一个选项是创建一个包含两个应用程序都使用的类的共享库，并将其作为依赖项导入到两个项目中。根据15因素方法，这样一个库将有自己的代码库进行跟踪。这样做将确保两个应用程序使用的模型是一致的，并且永远不会不同步。然而，这意味着增加了实现耦合。'
- en: '*Duplicate the class*—The other option is to replicate the class into the upstream
    application. By doing so, you wouldn’t have implementation coupling, but you would
    have to take care of evolving the replicated model as the original one changes
    in the downstream application. There are a few techniques like consumer-driven
    contracts that can identify, through automated tests, when the called API changes.
    Besides checking the data model, those tests would also verify other aspects of
    the exposed API, like HTTP methods, response statuses, headers, variables, and
    so on. I will not cover this subject here, but I recommend checking the Spring
    Cloud Contract project if you’re interested (https:// spring.io/projects/spring-cloud-contract).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复制类*—另一个选项是将类复制到上游应用程序中。通过这样做，你不会有实现耦合，但你需要注意随着下游应用程序中原始类的变化而演变复制的模型。有一些技术，如消费者驱动的契约，可以通过自动化测试识别出被调用的API何时发生变化。除了检查数据模型外，这些测试还会验证暴露的API的其他方面，如HTTP方法、响应状态、头信息、变量等。我这里不会涉及这个主题，但如果你对此感兴趣，建议查看Spring
    Cloud Contract项目（https://spring.io/projects/spring-cloud-contract）。'
- en: Both are viable options. Which strategy you adopt is up to your project requirements
    and your organization’s structure. For the Polar Bookshop project, we will use
    the second option.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选择都是可行的。你采用哪种策略取决于你的项目需求和你的组织结构。对于极地书店项目，我们将使用第二种选项。
- en: In a new com.polarbookshop.orderservice.book package, create a Book record to
    be used as a DTO, and include only the fields used by the order processing logic.
    As I pointed out earlier, in a real scenario I would expose a new endpoint in
    Catalog Service, returning book objects modeled as this DTO. For simplicity, we’ll
    use the existing /books/{bookIsbn} endpoint, so any information that doesn’t map
    to any of the fields in this class will be discarded when deserializing the JSON
    received into the Java object. Make sure the fields you do define have the same
    names as in the Book object defined in Catalog Service, or else the parsing will
    fail. That is something that consumer-driven contract tests can verify for you
    automatically.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的com.polarbookshop.orderservice.book包中，创建一个Book记录作为DTO使用，并仅包含订单处理逻辑使用的字段。正如我之前指出的，在真实场景中，我会在目录服务中公开一个新的端点，返回以这种DTO建模的书籍对象。为了简单起见，我们将使用现有的/books/{bookIsbn}端点，因此当将接收到的JSON反序列化为Java对象时，任何映射不到此类字段的信息都将被丢弃。确保你定义的字段与目录服务中定义的Book对象中的字段名称相同，否则解析将失败。这是消费者驱动的契约测试可以为你自动验证的事情。
- en: Listing 8.19 The Book record is a DTO for storing book information
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.19 书籍记录是一个用于存储书籍信息的DTO
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that you have a DTO in Order Service ready to hold book information, let’s
    see how you can retrieve it from Catalog Service.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在 Order Service 中准备好了一个 DTO 来存储书籍信息，让我们看看你如何从 Catalog Service 中检索它。
- en: 8.3.3 Implementing REST clients with WebClient
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 使用 WebClient 实现 REST 客户端
- en: The modern and reactive choice for REST clients in Spring is WebClient. The
    framework provides several ways of instantiating a WebClient object—in this example
    we’ll use WebClient.Builder. Refer to the official documentation to explore the
    other options ([https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework)).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 中 REST 客户端的现代和响应式选择是 WebClient。该框架提供了几种实例化 WebClient 对象的方法——在这个例子中我们将使用
    WebClient.Builder。请参考官方文档以探索其他选项（[https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework)）。
- en: In the com.polarbookshop.orderservice.config package, create a ClientConfig
    class to configure a WebClient bean with the base URL provided by ClientProperties.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 com.polarbookshop.orderservice.config 包中，创建一个 ClientConfig 类来配置一个带有由 ClientProperties
    提供的基本 URL 的 WebClient 实例。
- en: Listing 8.20 Configuring a WebClient bean to call Catalog Service
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 配置 WebClient 实例以调用 Catalog Service
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ An object auto-configured by Spring Boot to build WebClient beans
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由 Spring Boot 自动配置以构建 WebClient 实例的对象
- en: ❷ Configures the WebClient base URL to the Catalog Service URL defined as a
    custom property
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 WebClient 的基本 URL 配置为自定义属性中定义的 Catalog Service URL
- en: Warning If you use IntelliJ IDEA, you might get a warning that WebClient .Builder
    cannot be autowired. Don’t worry. It’s a false positive. You can get rid of the
    warning by annotating the field with @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection").
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 如果你使用 IntelliJ IDEA，你可能会收到一个警告，表明 WebClient.Builder 无法自动装配。不要担心，这是一个误报。你可以通过在字段上注解
    @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection") 来消除警告。
- en: Next, create a BookClient class in the com.polarbookshop.orderservice.book package.
    That is where you are going to use the WebClient bean to send HTTP calls to the
    GET /books/{bookIsbn} endpoint exposed by Catalog Service through its fluent API.
    The WebClient will ultimately return a Book object wrapped in a Mono publisher.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 com.polarbookshop.orderservice.book 包中创建一个 BookClient 类。你将在这个类中使用 WebClient
    实例发送 HTTP 请求到 Catalog Service 通过其流畅 API 暴露的 GET /books/{bookIsbn} 端点。WebClient
    最终将返回一个包含在 Mono 发布者中的 Book 对象。
- en: Listing 8.21 Defining a reactive REST client using WebClient
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.21 使用 WebClient 定义一个响应式 REST 客户端
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ A WebClient bean as configured previously
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如前所述配置的 WebClient 实例
- en: ❷ The request should use the GET method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 请求应使用 GET 方法。
- en: ❸ The target URI of the request is /books/{isbn}.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 请求的目标 URI 是 /books/{isbn}。
- en: ❹ Sends the request and retrieves the response
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 发送请求并检索响应
- en: ❺ Returns the retrieved object as Mono<Book>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将检索到的对象作为 Mono<Book> 返回
- en: WebClient is a reactive HTTP client. You’ve just seen how it can return data
    as reactive publishers. In particular, the result of calling Catalog Service to
    fetch details about a specific book is a Mono<Book> object. Let’s see how you
    can include that in the order-processing logic implemented in OrderService.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: WebClient 是一个响应式 HTTP 客户端。你已经看到了它如何作为响应式发布者返回数据。特别是，调用 Catalog Service 获取特定书籍详情的结果是一个
    Mono<Book> 对象。让我们看看你如何在 OrderService 中实现的订单处理逻辑中包含它。
- en: The submitOrder() method in the OrderService class is currently rejecting orders
    all the time. But not for long. You can now autowire a BookClient instance and
    use the underlying WebClient to start a reactive stream to process the book information
    and create an order. The map() operator lets you map a Book to an accepted Order.
    If BookClient returns an empty result, you can define a rejected Order with the
    defaultIfEmpty() operator. Finally, the stream is ended by calling OrderRepository
    to save the order (either as accepted or rejected).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: OrderService 类中的 submitOrder() 方法目前一直在拒绝订单。但这种情况不会持续太久。你现在可以自动装配一个 BookClient
    实例，并使用其底层的 WebClient 来启动一个响应式流以处理书籍信息并创建订单。map() 操作符允许你将 Book 映射到一个已接受的 Order。如果
    BookClient 返回空结果，你可以使用 defaultIfEmpty() 操作符定义一个被拒绝的 Order。最后，通过调用 OrderRepository
    保存订单（无论是已接受还是被拒绝）来结束流。
- en: Listing 8.22 Calling BookClient to get the book info when ordered
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.22 在下单时调用 BookClient 获取书籍信息
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Calls the Catalog Service to check the book’s availability
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 Catalog Service 检查书籍的可用性
- en: ❷ If the book is available, it accepts the order.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果书籍可用，它将接受订单。
- en: ❸ If the book is not available, it rejects the order.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果书籍不可用，它将拒绝订单。
- en: ❹ Saves the order (either as accepted or rejected)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 保存订单（无论是已接受还是被拒绝）
- en: ❺ When an order is accepted, we specify ISBN, book name (title + author), quantity,
    and status. Spring Data takes care of adding the identifier, version, and audit
    metadata.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当订单被接受时，我们指定 ISBN、书名（标题 + 作者）、数量和状态。Spring Data 负责添加标识符、版本和审计元数据。
- en: 'Let’s try that out. First, ensure the PostgreSQL container is up and running
    by executing the following command from the folder where you keep your Docker
    Compose configuration (polar-deployment/docker):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。首先，确保 PostgreSQL 容器正在运行，通过从您保存 Docker Compose 配置的文件夹中执行以下命令：
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then build and run both Catalog Service and Order Service (./gradlew bootRun).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后构建并运行目录服务和订单服务（./gradlew bootRun）。
- en: 'Warning If you’re using an Apple Silicon computer, the application logs from
    Order Service might include some warnings related to DNS resolutions in Netty.
    In this specific case, the application should still work correctly. If you experience
    issues, you can add the following additional dependency to the Order Service project
    as runtimeOnly to fix the problem: io.netty:netty-resolver-dns-native-macos:4.1.79.Final:osx-aarch_64.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：如果您使用的是苹果硅电脑，订单服务的应用程序日志可能包含一些与 Netty 中 DNS 解析相关的警告。在这种情况下，应用程序仍然可以正常工作。如果您遇到问题，可以将以下附加依赖项添加到订单服务项目中作为
    runtimeOnly 来修复问题：io.netty:netty-resolver-dns-native-macos:4.1.79.Final:osx-aarch_64。
- en: 'Finally, send an order for one of the books created in Catalog Service at startup
    time. If the book exists, the order should be accepted:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在启动时发送一个目录服务中创建的图书的订单。如果图书存在，订单应该被接受：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you are done verifying the interaction, stop the applications with Ctrl-C
    and the container with docker-compose down.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成验证交互后，使用 Ctrl-C 停止应用程序，并使用 docker-compose down 停止容器。
- en: That concludes our implementation of the order-creation logic. If the book exists
    in the catalog, the order will be accepted. If an empty result is returned, it’s
    rejected. But what if Catalog Service takes too much time to reply? What if it’s
    momentarily unavailable and can’t process any new requests? What if it replies
    with an error? The following section will answer and handle all these questions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们订单创建逻辑的实现。如果图书在目录中存在，订单将被接受。如果返回空结果，则被拒绝。但是，如果目录服务回复时间过长怎么办？如果它暂时不可用且无法处理任何新请求怎么办？如果它回复错误怎么办？下一节将回答并处理所有这些问题。
- en: 8.4 Resilient applications with Reactive Spring
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 带有 Reactive Spring 的弹性应用程序
- en: Resilience is about keeping a system available and delivering its services,
    even when failures happen. Since failures will happen, and there’s no way to prevent
    them all, it is critical to design fault-tolerant applications. The goal is to
    keep the system available without the user noticing any failures. In the worst-case
    scenario, the system may have degraded functionality (*graceful degradation*),
    but it should still be available.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是指即使在发生故障的情况下，也能保持系统可用并交付其服务。由于故障总会发生，而且无法完全防止，因此设计容错应用程序至关重要。目标是让用户在没有任何故障的情况下保持系统可用。在最坏的情况下，系统可能具有降级功能（**优雅降级**），但它仍然应该是可用的。
- en: The critical point in achieving resilience (or fault-tolerance) is keeping the
    faulty component isolated until the fault is fixed. By doing that, you’ll prevent
    what Michael T. Nygard calls *crack propagation*. Think about Polar Bookshop.
    If Catalog Service enters a faulty state and becomes unresponsive, you don’t want
    Order Service to be affected as well. Integration points between application services
    should be carefully guarded and made resilient to failures affecting the other
    party.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实现弹性（或容错）的关键点是，在故障修复之前将故障组件隔离。通过这样做，你将防止迈克尔·T·奈格德所说的**裂纹传播**。想想 Polar Bookshop。如果目录服务进入故障状态并变得无响应，你不想让订单服务也受到影响。应用服务之间的集成点应该仔细保护，并使其能够抵御影响另一方的故障。
- en: There are several patterns for building resilient applications. In the Java
    ecosystem, a popular library for implementing such patterns was Hystrix, developed
    by Netflix, but as of 2018 it entered maintenance mode and will not be developed
    further. Resilience4J gained a lot of popularity, filling the void left by Hystrix.
    Project Reactor, the Reactive Spring stack foundation, also provides some useful
    features for resilience.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 建立弹性应用程序有几种模式。在 Java 生态系统中，Netflix 开发的 Hystrix 是实现这些模式的一个流行的库，但截至 2018 年，它已进入维护模式，并且不会再进一步开发。Resilience4J
    获得了很大的流行，填补了 Hystrix 留下的空白。Project Reactor，Reactive Spring 堆栈的基础，也提供了一些有用的弹性功能。
- en: In this section, you’ll make the integration point between Order Service and
    Catalog Service more robust, using Reactive Spring to configure timeouts, retries,
    and fallbacks. In the next chapter, you’ll learn more about building resilient
    applications with Resilience4J and Spring Cloud Circuit Breaker.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用Reactive Spring配置超时、重试和回退来使订单服务与目录服务的集成点更加健壮。在下一章中，您将了解更多关于使用Resilience4J和Spring
    Cloud Circuit Breaker构建弹性应用程序的内容。
- en: 8.4.1 Timeouts
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 超时
- en: Whenever your application calls a remote service, you don’t know if and when
    a response will be received. Timeouts (also called *time limiters*) are a simple,
    yet effective, tool for preserving the responsiveness of your application in case
    a response is not received within a reasonable time period.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您的应用程序调用远程服务时，您不知道是否会收到响应以及何时收到。超时（也称为*时间限制器*）是在合理时间内未收到响应时保持应用程序响应性的简单而有效的工具。
- en: 'There are two main reasons for setting up timeouts:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 设置超时的主要有两个原因：
- en: If you don’t limit the time your client waits, you risk your computational resources
    being blocked for too long (for imperative applications). In the worst-case scenario,
    your application will be completely unresponsive because all the available threads
    are blocked, waiting for responses from a remote service, and there are no threads
    available to handle new requests.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不对客户端等待的时间进行限制，您的计算资源可能会被阻塞太长时间（对于命令式应用程序）。在最坏的情况下，您的应用程序将完全无响应，因为所有可用的线程都被阻塞，等待远程服务的响应，并且没有线程可以处理新的请求。
- en: If you can’t meet your Service Level Agreements (SLAs), there’s no reason to
    keep waiting for an answer. It’s better to fail the request.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您无法满足服务水平协议（SLA），就没有理由继续等待答案。最好是失败请求。
- en: 'Here are some examples of timeouts:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些超时的示例：
- en: '*Connection timeout*—This is the time limit for establishing a communication
    channel with a remote resource. Earlier you configured the server.netty.connection-timeout
    property to limit the time Netty waits for a TCP connection to be established.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接超时*—这是与远程资源建立通信通道的时间限制。之前您已配置了server.netty.connection-timeout属性以限制Netty等待TCP连接建立的时间。'
- en: '*Connection pool timeout*—This is the time limit for a client to get a connection
    from a pool. In chapter 5, you configured a timeout for the Hikari connection
    pool through the spring.datasource.hikari.connection-timeout property.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接池超时*—这是客户端从连接池获取连接的时间限制。在第5章中，您通过spring.datasource.hikari.connection-timeout属性配置了Hikari连接池的超时。'
- en: '*Read timeout*—This is the time limit for reading from a remote resource after
    establishing the initial connection. In the following sections, you’ll define
    a read timeout for the call to the Catalog Service performed by the BookClient
    class.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取超时*—这是在建立初始连接后从远程资源读取的时间限制。在以下章节中，您将为BookClient类对目录服务进行的调用定义读取超时。'
- en: In this section, you’ll define a timeout for BookClient so that if it expires,
    the Order Service application will throw an exception. You can also specify a
    failover instead of throwing the exception to the user. Figure 8.7 details how
    the request/response interaction will work when timeouts and failovers are defined.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将为BookClient定义一个超时，如果它到期，订单服务应用程序将抛出异常。您还可以指定故障转移而不是将异常抛给用户。图8.7详细说明了定义超时和故障转移时请求/响应交互的工作方式。
- en: '![08-07](../Images/08-07.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![08-07](../Images/08-07.png)'
- en: Figure 8.7 When a response is received from the remote service within the time
    limit, the request is successful. If the timeout expires and no response is received,
    then a fallback behavior is executed, if any. Otherwise, an exception is thrown.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 当在时间限制内从远程服务收到响应时，请求成功。如果超时到期且没有收到响应，则执行任何回退行为。否则，抛出异常。
- en: Defining a timeout for WebClient
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 定义WebClient的超时
- en: Project Reactor provides a timeout() operator you can use to define a time limit
    for completing an operation. You can chain it with the result of the WebClient
    call to continue the reactive stream. Update the getBookByIsbn() method in the
    BookClient class as follows to define a timeout of 3 seconds.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor提供了一个timeout()操作符，您可以使用它来定义完成操作的时间限制。您可以将它与WebClient调用的结果链接起来，以继续反应流。按照以下方式更新BookClient类中的getBookByIsbn()方法，以定义3秒的超时。
- en: Listing 8.23 Defining a timeout for the HTTP interaction
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.23 定义HTTP交互的超时
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Sets a 3-second timeout for the GET request
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为GET请求设置3秒超时
- en: Instead of throwing an exception when the timeout expires, you have the chance
    to provide a fallback behavior. Considering that Order Service can’t accept an
    order if the book’s availability is not verified, you might consider returning
    an empty result so that the order will be rejected. You can define a reactive
    empty result using Mono.empty(). Update the getBookByIsbn() method in the BookClient
    class as follows.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当超时到期时，你有机会提供回退行为。考虑到订单服务在书籍可用性未验证的情况下无法接受订单，你可能考虑返回一个空的结果，以便拒绝订单。你可以在BookClient类中定义一个响应式空结果，使用Mono.empty()更新getBookByIsbn()方法，如下所示。
- en: Listing 8.24 Defining timeout and fallback for the HTTP interaction
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.24 定义HTTP交互的超时和回退
- en: '[PRE29]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ The fallback returns an empty Mono object.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 回退返回一个空的Mono对象。
- en: Note In a real production scenario, you might want to externalize the timeout
    configuration by adding a new field to the ClientProperties. In that way, you
    can change its value depending on the environment without having to rebuild the
    application. It’s also essential to monitor any timeout and tune its value if
    necessary.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在实际的生产场景中，你可能希望通过向ClientProperties添加一个新字段来外部化超时配置。这样，你可以根据环境更改其值，而无需重新构建应用程序。同样重要的是要监控任何超时，并在必要时调整其值。
- en: Understanding how to use timeouts effectively
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何有效地使用超时
- en: Timeouts improve application resilience and follow the principle of failing
    fast. But setting a good value for the timeout can be tricky. You should consider
    your system architecture as a whole. In the previous example, you defined a 3-second
    timeout. This means that a response should get from Catalog Service to Order Service
    within that time limit. Otherwise, either a failure or a fallback occurs. Catalog
    Service, in turn, sends a request to the PostgreSQL database to fetch the data
    about the specific book and waits for a response. A connection timeout guards
    that interaction. You should carefully design a time-limiting strategy for all
    the integration points in your system to meet your software’s SLAs and guarantee
    a good user experience.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 超时设置可以提高应用程序的弹性，并遵循快速失败的原则。但为超时设置一个合适的值可能很棘手。你应该考虑你的整个系统架构。在先前的例子中，你定义了一个3秒的超时。这意味着响应应该在规定的时间内从目录服务传送到订单服务。否则，将发生故障或回退。目录服务反过来会向PostgreSQL数据库发送请求以获取特定书籍的数据，并等待响应。连接超时保护了这种交互。你应该仔细设计系统所有集成点的时间限制策略，以满足软件的SLA并保证良好的用户体验。
- en: If Catalog Service were available, but a response couldn’t get to Order Service
    within the time limit, the request would likely still be processed by Catalog
    Service. That is a critical point to consider when configuring timeouts. It doesn’t
    matter much for read or query operations because they are idempotent. For write
    or command operations, you want to ensure proper handling when a timeout expires,
    including providing the user with the correct status about the operation’s outcome.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录服务可用，但响应在规定时间内无法到达订单服务，请求很可能会仍然由目录服务处理。这是配置超时时需要考虑的关键点。对于读取或查询操作来说，这并不重要，因为它们是无状态的。对于写入或命令操作，你希望在超时到期时确保适当的处理，包括向用户提供关于操作结果的正确状态。
- en: When Catalog Service is overloaded, it can take several seconds to get a JDBC
    connection from the pool, fetch data from the database, and send a response back
    to Order Service. In that case, you could think of retrying the request rather
    than falling back on a default behavior or throwing an exception.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当目录服务过载时，它可能需要几秒钟才能从连接池中获取JDBC连接，从数据库中获取数据，并将响应发送回订单服务。在这种情况下，你可以考虑重试请求，而不是回退到默认行为或抛出异常。
- en: 8.4.2 Retries
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 重试
- en: When a service downstream doesn’t respond within a specific time limit or replies
    with a server error related to its momentary inability to process the request,
    you can configure your client to try again. When a service doesn’t respond correctly,
    it’s likely because it’s going through some issues, and it’s unlikely that it
    will manage to recover immediately. Starting a sequence of retry attempts, one
    after the other, risks making the system even more unstable. You don’t want to
    launch a DoS attack on your own applications!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当下游服务在特定时间内没有响应或回复与它暂时无法处理请求相关的服务器错误时，你可以配置客户端尝试再次发送请求。当服务没有正确响应时，很可能是因为它遇到了一些问题，并且它不太可能立即恢复。连续启动一系列重试尝试可能会使系统更加不稳定。你不希望对你的应用程序发起DoS攻击！
- en: A better approach is using an *exponential backoff* strategy to perform each
    retry attempt with a growing delay. By waiting for more and more time between
    one attempt and the next, you’re more likely to give the backing service time
    to recover and become responsive again. The strategy for computing the delay can
    be configured.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的方法是使用指数退避策略，通过增加延迟来执行每个重试尝试。通过在尝试之间等待越来越长的时间，您更有可能给后端服务时间来恢复并再次变得响应。可以配置计算延迟的策略。
- en: In this section, you’ll configure retries for BookClient. Figure 8.8 details
    how the request/response interaction will work when retries are configured with
    exponential backoff. For example, the figure shows a scenario where each retry
    attempt’s delay is computed as the number of attempts multiplied by 100 ms (the
    initial backoff value).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将配置 BookClient 的重试。图 8.8 详细说明了配置指数退避重试时请求/响应交互的工作方式。例如，该图显示了一个场景，其中每次重试尝试的延迟是尝试次数乘以100毫秒（初始退避值）。
- en: '![08-08](../Images/08-08.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![08-08](../Images/08-08.png)'
- en: Figure 8.8 When Catalog Service doesn’t respond successfully, Order Service
    will try at most three more times with a growing delay.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 当目录服务未成功响应时，订单服务将尝试最多三次，每次尝试的延迟都会增加。
- en: Defining retries for WebClient
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 WebClient 的重试
- en: Project Reactor provides a retryWhen() operator to retry an operation when it
    fails. The position where you apply it to the reactive stream matters.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor 提供了一个 retryWhen() 操作符，用于在操作失败时重试。将此操作符应用到反应流中的位置很重要。
- en: Placing the retryWhen() operator after timeout() means that the timeout is applied
    to each retry attempt.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 retryWhen() 操作符放在 timeout() 之后意味着超时应用于每个重试尝试。
- en: Placing the retryWhen() operator before timeout() means that the timeout is
    applied to the overall operation (that is, the whole sequence of the initial request
    and retries has to happen within the given time limit).
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 retryWhen() 操作符放在 timeout() 之前意味着超时应用于整体操作（即，整个初始请求和重试序列必须在给定的时间限制内发生）。
- en: In BookClient, we want the timeout to apply to each retry attempt, so we’ll
    use the first option. The time limiter is applied first. If the timeout expires,
    the retryWhen() operator kicks in and tries the request again.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BookClient 中，我们希望超时应用于每个重试尝试，因此我们将使用第一个选项。首先应用时间限制器。如果超时到期，retryWhen() 操作符将启动并再次尝试请求。
- en: Update the getBookByIsbn() method in the BookClient class to configure a retry
    strategy. You can define the number of attempts and the minimum duration for the
    first backoff. The delay is computed for each retry as the current attempt number
    multiplied by the minimum backoff period. A jitter factor can be used to add randomness
    to the exponential of each backoff. By default, a jitter of at most 50% of the
    computed delay is used. When you have multiple instances of Order Service running,
    the jitter factor ensures that the replicas will not retry requests simultaneously.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 BookClient 类中的 getBookByIsbn() 方法以配置重试策略。您可以定义尝试次数和第一次退避的最小持续时间。每次重试的延迟是当前尝试次数乘以最小退避周期。可以使用抖动因子为每次退避的指数添加随机性。默认情况下，使用的抖动值不超过计算延迟的50%。当有多个
    Order Service 实例运行时，抖动因子确保副本不会同时重试请求。
- en: Listing 8.25 Defining retries with exponential backoff for the HTTP call
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.25 定义 HTTP 调用的指数退避重试
- en: '[PRE30]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Exponential backoff is used as the retry strategy. Three attempts are allowed
    with a 100 ms initial backoff.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指数退避被用作重试策略。允许进行三次尝试，初始退避时间为100毫秒。
- en: Understanding how to use retries effectively
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何有效地使用重试
- en: Retries increase the chance of getting a response back from a remote service
    when it’s momentarily overloaded or unresponsive. Use them wisely. In the context
    of timeouts, I highlighted the need for handling read and write operations differently.
    When it comes to retries, this is even more critical.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 重试增加了在远程服务暂时过载或无响应时收到响应的机会。请明智地使用它们。在超时的情况下，我强调了处理读取和写入操作的不同需求。当涉及到重试时，这一点尤为重要。
- en: Idempotent requests like read operations can be retried without harm. Even some
    write requests can be idempotent. For example, a request to change the author
    of a book with a given ISBN from “S.L. Cooper” to “Sheldon Lee Cooper” is idempotent.
    You could perform it a few times, but the outcome will not change. You shouldn’t
    retry non-idempotent requests, or you’ll risk generating inconsistent states.
    When you order a book, you don’t want to be charged multiple times just because
    the first attempt failed due to the response being lost in the network and never
    received.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 像读取操作这样的幂等请求可以无损害地重试。甚至一些写请求也可以是幂等的。例如，将给定ISBN的书籍作者从“S.L. Cooper”更改为“Sheldon
    Lee Cooper”的请求是幂等的。你可以多次执行它，但结果不会改变。你不应该重试非幂等请求，否则会冒着生成不一致状态的风险。当你订购一本书时，你不希望因为第一次尝试失败（由于响应在网络中丢失而未收到）而被多次收费。
- en: When retries are configured in a flow where the user is involved, remember to
    balance resilience and user experience. You don’t want users to wait too long
    while retrying the request behind the scenes. If you can’t avoid that, make sure
    you inform the users and give them feedback about the status of the request.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当在涉及用户的流程中配置重试时，请记住在弹性和用户体验之间取得平衡。你不想让用户在后台重试请求时等待太长时间。如果你无法避免这种情况，请确保通知用户并给他们提供关于请求状态的反馈。
- en: Retries are a helpful pattern whenever the service downstream is momentarily
    unavailable or slow due to overloading, but it’s likely to heal soon. In this
    case, you should limit the number of retries and use exponential backoff to prevent
    adding extra load on an already overloaded service. On the other hand, you shouldn’t
    retry the request if the service fails with a recurrent error, such as if it’s
    entirely down or returns an acceptable error like 404\. The following section
    will show you how to define fallbacks when specific errors happen.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当下游服务因过载而暂时不可用或缓慢时，重试是一种有用的模式，但服务很可能会很快恢复。在这种情况下，你应该限制重试次数并使用指数退避来防止给已经过载的服务增加额外负载。另一方面，如果服务因重复错误而失败，例如完全关闭或返回可接受的错误，如404，则不应重试请求。下一节将向您展示如何定义在特定错误发生时的回退。
- en: 8.4.3 Fallbacks and error handling
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 回退和错误处理
- en: A system is resilient if it keeps providing its services in the face of faults
    without the user noticing. Sometimes that’s not possible, so the least you can
    do is ensure a graceful degradation of the service level. Specifying a fallback
    behavior can help you limit the fault to a small area while preventing the rest
    of the system from misbehaving or entering a faulty state.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统在出现故障时仍然能够提供服务而用户没有注意到，那么这个系统是具有弹性的。有时这是不可能的，所以你至少可以确保服务级别以优雅的方式降低。指定回退行为可以帮助你将故障限制在一个小范围内，同时防止系统的其余部分出现异常行为或进入错误状态。
- en: In the previous discussion of timeouts, you already provided a fallback behavior
    if no response is received within the time limit. You’ll want to include fallbacks
    in your general strategy to make your system resilient, and not just in a specific
    case like timeouts. A fallback function can be triggered when some errors or exceptions
    occur, but they’re not all the same.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前关于超时讨论中，你已经提供了一个在时间限制内未收到响应时的回退行为。你希望在总体策略中包含回退，以使系统具有弹性，而不仅仅是针对特定情况，如超时。当发生某些错误或异常时，可以触发回退函数，但它们并不完全相同。
- en: Some errors are acceptable and semantically meaningful in the context of your
    business logic. When Order Service calls Catalog Service to fetch information
    about a specific book, a 404 response might be returned. That’s an acceptable
    response that should be addressed to inform the user that the order cannot be
    submitted because the book is not available in the catalog.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一些错误在你的业务逻辑上下文中是可以接受的，并且具有语义意义。当订单服务调用目录服务以获取关于特定书籍的信息时，可能会返回404响应。这是一个可以接受并应通知用户的响应，告知用户由于书籍在目录中不可用，订单无法提交。
- en: 'The retry strategy you defined in the previous section is not limited: it will
    retry the request as long as an error response is received, including acceptable
    ones like 404\. However, in that case, you don’t want to retry the request. Project
    Reactor provides an onErrorResume() operator to define a fallback when a specific
    error occurs. You can add it to the reactive stream after the timeout() operator
    and before the retryWhen() so that if a 404 response is received (WebClientResponseException.NotFound
    exception), the retry operator is not triggered. Then you can use the same operator
    again at the end of the stream to catch any other exception and fall back to an
    empty Mono. Update the getBookByIsbn() method in the BookClient class as follows.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中定义的重试策略并不受限制：只要收到错误响应，包括可接受的404响应，它就会重试请求。然而，在这种情况下，你不想重试请求。Project Reactor提供了一个onErrorResume()算子来定义特定错误发生时的回退。你可以在timeout()算子之后和retryWhen()算子之前将其添加到反应流中，这样如果收到404响应（WebClientResponseException.NotFound异常），重试算子就不会被触发。然后你可以在流的末尾再次使用相同的算子来捕获任何其他异常，并回退到空的Mono。按照以下方式更新BookClient类中的getBookByIsbn()方法。
- en: Listing 8.26 Defining exception handling and fallbacks for the HTTP call
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.26 定义HTTP调用的异常处理和回退
- en: '[PRE31]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Returns an empty object when a 404 response is received
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当收到404响应时返回一个空对象
- en: ❷ If any error happens after the 3 retry attempts, catch the exception and return
    an empty object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果在3次重试尝试之后发生任何错误，捕获异常并返回一个空对象。
- en: Note In a real-world scenario, you would probably want to return some contextual
    information depending on the type of error, instead of always returning an empty
    object. For example, you could add a reason field to the Order object to describe
    why it’s been rejected. Was it because the book is unavailable in the catalog
    or because of network problems? In the second case, you could inform the user
    that the order cannot be processed because it’s momentarily unable to check the
    book’s availability. A better option would be to save the order in a pending state,
    queue the order submission request, and try it again later, using one of the strategies
    I’ll cover in chapter 10.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在实际场景中，你可能希望根据错误类型返回一些上下文信息，而不是总是返回一个空对象。例如，你可以在订单对象中添加一个原因字段来描述为什么它被拒绝。是因为图书在目录中不可用，还是因为网络问题？在后一种情况下，你可以通知用户，由于暂时无法检查图书的可用性，订单无法处理。更好的选择是将订单保存为挂起状态，排队订单提交请求，稍后再尝试，使用我在第10章中介绍的一种策略。
- en: The key goal is designing a resilient system that, in the best-case scenario,
    can provide its services without the user noticing that there has been a failure.
    In contrast, in the worst-case scenario, it should still work but with graceful
    degradation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是设计一个具有弹性的系统，在最佳情况下，可以在用户没有注意到失败的情况下提供服务。相比之下，在最坏的情况下，它仍然应该工作，但具有优雅的降级。
- en: Note Spring WebFlux and Project Reactor are exciting subjects in the Spring
    landscape. If you want to learn more about how reactive Spring works, I recommend
    looking at *Reactive Spring* by Josh Long ([https://reactivespring.io](https://reactivespring.io)).
    In the Manning catalog, see part 3 of *Spring in Action*, sixth edition, by Craig
    Walls (Manning, 2022).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Spring WebFlux和Project Reactor是Spring生态系统中的热门主题。如果你想了解更多关于反应式Spring的工作原理，我建议查看Josh
    Long的《Reactive Spring》（[https://reactivespring.io](https://reactivespring.io)）。在Manning目录中，查看Craig
    Walls所著的《Spring in Action》第六版（Manning，2022）的第三部分。
- en: In the next section, you’ll write automated tests to verify the different aspects
    of the Order Service application.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将编写自动化测试来验证订单服务应用程序的不同方面。
- en: 8.5 Testing reactive applications with Spring, Reactor, and Testcontainers
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 使用Spring、Reactor和Testcontainers测试反应式应用程序
- en: When an application depends on a service downstream, you should test the interaction
    against the API specification of the latter. In this section, you’ll first try
    the BookClient class against a mock web server acting as the Catalog Service to
    ensure the correctness of the client. Then you’ll test the data persistence layer
    with sliced tests using the @DataR2dbcTest annotation and Testcontainers, much
    as you did in chapter 5 with @DataJdbcTest. Finally, you’ll write sliced tests
    for the web layer using the @WebFluxTest annotation, which works in the same way
    as @WebMvcTest but for reactive applications.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序依赖于下游的服务时，你应该测试与该服务的API规范之间的交互。在本节中，你将首先尝试使用充当Catalog Service的模拟Web服务器测试BookClient类，以确保客户端的正确性。然后，你将使用@DataR2dbcTest注解和Testcontainers进行切片测试来测试数据持久层，就像你在第5章中使用@DataJdbcTest所做的那样。最后，你将使用@WebFluxTest注解编写针对Web层的切片测试，它与@WebMvcTest的工作方式相同，但适用于反应式应用程序。
- en: You already have the necessary dependencies on the Spring Boot test libraries
    and Testcontainers. What is missing is a dependency on com.squareup.okhttp3:mockwebserver,
    which will provide utilities to run a mock web server. Open the build.gradle file
    of the Order Service project and add the missing dependency.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了Spring Boot测试库和Testcontainers的必要依赖项。缺少的是对com.squareup.okhttp3:mockwebserver的依赖项，这将提供运行模拟Web服务器的实用工具。打开Order
    Service项目的build.gradle文件并添加缺少的依赖项。
- en: Listing 8.27 Adding test dependency for OkHttp MockWebServer
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.27 为OkHttp MockWebServer添加测试依赖
- en: '[PRE32]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let’s start by testing the BookClient class.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试BookClient类开始。
- en: 8.5.1 Testing REST clients with a mock web server
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 使用模拟Web服务器测试REST客户端
- en: The OkHttp project provides a mock web server that you can use to test HTTP-based
    request/response interactions with a service downstream. BookClient returns a
    Mono<Book> object, so you can use the convenient utilities provided by Project
    Reactor for testing reactive applications. The StepVerifier object lets you process
    reactive streams and write assertions in steps through a fluent API.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: OkHttp项目提供了一个模拟Web服务器，你可以用它来测试与下游服务基于HTTP的请求/响应交互。BookClient返回一个Mono<Book>对象，因此你可以使用Project
    Reactor提供的方便工具来测试反应式应用程序。StepVerifier对象允许你通过流畅的API分步骤处理反应式流并编写断言。
- en: First, let’s set up the mock web server and configure WebClient to use it in
    a new BookClientTests class.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置模拟的Web服务器并配置WebClient以在新的BookClientTests类中使用它。
- en: Listing 8.28 Preparing the test setup with a mock web server
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.28 使用模拟Web服务器准备测试设置
- en: '[PRE33]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Starts the mock server before running a test case
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在运行测试用例之前启动模拟服务器
- en: ❷ Uses the mock server URL as the base URL for WebClient
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用模拟服务器URL作为WebClient的基本URL
- en: ❸ Shuts the mock server down after completing a test case
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在完成测试用例后关闭模拟服务器
- en: Next, in the BookClientTests class, you can define some test cases to validate
    the client’s functionality in Order Service.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在BookClientTests类中，你可以定义一些测试用例来验证客户端在Order Service中的功能。
- en: Listing 8.29 Testing the interaction with the Catalog Service application
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.29 测试与Catalog Service应用程序的交互
- en: '[PRE34]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Defines the response to be returned by the mock server
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义模拟服务器返回的响应
- en: ❷ Adds a mock response to the queue processed by the mock server
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向由模拟服务器处理的队列中添加模拟响应
- en: ❸ Initializes a StepVerifier object with the object returned by BookClient
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用BookClient返回的对象初始化StepVerifier对象
- en: ❹ Asserts that the Book returned has the ISBN requested
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言返回的Book具有请求的ISBN
- en: ❺ Verifies that the reactive stream completed successfully
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 验证反应式流成功完成
- en: 'Let’s run the tests and ensure they succeed. Open a Terminal window, navigate
    to the root folder of your Order Service project, and run the following command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试并确保它们成功。打开一个终端窗口，导航到Order Service项目的根目录，并运行以下命令：
- en: '[PRE35]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note When using mocks, there might be situations where the test results depend
    on the order in which test cases are executed, which tend to be the same on the
    same operating system. To prevent unwanted execution dependencies, you can annotate
    the test class with @TestMethodOrder(MethodOrderer.Random.class) to ensure that
    a pseudo-random order is used at each execution.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当使用模拟时，可能会有这样的情况，即测试结果取决于测试用例执行的顺序，这在同一操作系统上通常是相同的。为了防止不希望的执行依赖，你可以使用@TestMethodOrder(MethodOrderer.Random.class)注解测试类，以确保每次执行都使用伪随机顺序。
- en: After testing the REST client part, you can move on and verify the data persistence
    layer for Order Service.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试REST客户端部分之后，你可以继续并验证Order Service的数据持久层。
- en: 8.5.2 Testing data persistence with @DataR2dbcTest and Testcontainers
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 使用 @DataR2dbcTest 和 Testcontainers 测试数据持久性
- en: As you might recall from the previous chapters, Spring Boot allows you to run
    integration tests by loading only the Spring components used by a specific application
    slice. For the REST API, you will create tests for the WebFlux slice. Here I’ll
    show you how to write tests for the R2DBC slice using the @DataR2dbcTest annotation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从前面的章节中回忆起来，Spring Boot 允许您通过仅加载特定应用程序切片使用的 Spring 组件来运行集成测试。对于 REST API，您将为
    WebFlux 切片创建测试。在这里，我将向您展示如何使用 @DataR2dbcTest 注解编写 R2DBC 切片的测试。
- en: The approach is the same you used in chapter 5 for testing the data layer in
    Catalog Service, but there are two main differences. First, you will use the StepVerifier
    utility to test the OrderRepository behavior reactively. Second, you will define
    a PostgreSQL test container instance explicitly.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与您在第 5 章中用于测试目录服务数据层的测试方法相同，但有两大主要区别。首先，您将使用 StepVerifier 工具来反应式地测试 OrderRepository
    的行为。其次，您将明确定义一个 PostgreSQL 测试容器实例。
- en: For the Catalog Service application, we relied on the test container auto-configuration.
    In this case, we’ll define a test container in the test class and mark it as @Container.
    Then the @Testcontainers annotation on the class will activate the automatic startup
    and cleanup of the test container. Finally, we’ll use the @DynamicProperties annotation
    provided by Spring Boot to pass the test database’s credentials and URL to the
    application. This approach of defining test containers and overwriting properties
    is generic and can be applied to other scenarios.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目录服务应用程序，我们依赖于测试容器自动配置。在这种情况下，我们将在测试类中定义一个测试容器并将其标记为 @Container。然后，类上的 @Testcontainers
    注解将激活测试容器的自动启动和清理。最后，我们将使用 Spring Boot 提供的 @DynamicProperties 注解将测试数据库的凭据和 URL
    传递给应用程序。这种定义测试容器和覆盖属性的方法是通用的，可以应用于其他场景。
- en: Now, on to the code. Create an OrderRepositoryR2dbcTests class and implement
    autotests to verify the data persistence layer of the application.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看代码。创建一个 OrderRepositoryR2dbcTests 类，并实现自动测试以验证应用程序的数据持久层。
- en: Listing 8.30 Integration tests for the Data R2DBC slice
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.30 数据 R2DBC 切片的集成测试
- en: '[PRE36]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Identifies a test class that focuses on R2DBC components
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别一个专注于 R2DBC 组件的测试类
- en: ❷ Imports R2DBC configuration needed to enable auditing
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入启用审计所需的 R2DBC 配置
- en: ❸ Activates automatic startup and cleanup of test containers
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 激活测试容器的自动启动和清理
- en: ❹ Identifies a PostgreSQL container for testing
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 识别用于测试的 PostgreSQL 容器
- en: ❺ Overwrites R2DBC and Flyway configuration to point to the test PostgreSQL
    instance
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 覆盖 R2DBC 和 Flyway 配置以指向测试 PostgreSQL 实例
- en: ❻ Builds an R2DBC connection string, because Testcontainers doesn’t provide
    one out of the box as it does for JDBC
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 构建 R2DBC 连接字符串，因为 Testcontainers 不像 JDBC 那样提供内置的连接字符串
- en: ❼ Initializes a StepVerifier object with the object returned by OrderRepository
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用 OrderRepository 返回的对象初始化 StepVerifier 对象
- en: ❽ Asserts that the Order returned has the correct status
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 断言返回的订单具有正确状态
- en: ❾ Verifies that the reactive stream completed successfully
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 验证反应式流成功完成
- en: 'Since those slice tests are based on Testcontainers, ensure the Docker Engine
    is running in your local environment. Then run the tests:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些切片测试基于 Testcontainers，请确保您的本地环境中 Docker 引擎正在运行。然后运行测试：
- en: '[PRE37]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the next section, you’ll write tests for the web slice.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将为网络切片编写测试。
- en: 8.5.3 Testing REST controllers with @WebFluxTest
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3 使用 @WebFluxTest 测试 REST 控制器
- en: The WebFlux slice can be tested similarly to how you tested the MVC layer in
    chapter 3 and using the same WebTestClient utility you used for the integration
    tests. It’s an enhanced version of the standard WebClient object, containing extra
    features to simplify tests.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: WebFlux 切片可以像第 3 章中测试 MVC 层一样进行测试，并使用与集成测试相同的 WebTestClient 工具。它是标准 WebClient
    对象的增强版本，包含额外的功能以简化测试。
- en: Create an OrderControllerWebFluxTests class, and annotate it with @WebFluxTest(OrderController.class)
    to collect the slice tests for OrderController. As you learned in chapter 3, you
    can use the @MockBean Spring annotation to mock the OrderService class and have
    Spring add it to the Spring context used in the test. That’s what makes it injectable.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 OrderControllerWebFluxTests 类，并使用 @WebFluxTest(OrderController.class) 注解来收集
    OrderController 的切片测试。正如您在第 3 章中学到的，您可以使用 @MockBean Spring 注解来模拟 OrderService
    类，并让 Spring 将其添加到测试中使用的 Spring 上下文中。这就是使其可注入的原因。
- en: Listing 8.31 Integration tests for the WebFlux slice
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.31 WebFlux 切片的集成测试
- en: '[PRE38]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Identifies a test class that focuses on Spring WebFlux components, targeting
    OrderController
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别一个专注于 Spring WebFlux 组件的测试类，针对 OrderController
- en: ❷ A WebClient variant with extra features to make testing RESTful services easier
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个具有额外功能以简化 RESTful 服务测试的 WebClient 变体
- en: ❸ Adds a mock of OrderService to the Spring application context
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 OrderService 的模拟添加到 Spring 应用程序上下文中
- en: ❹ Defines the expected behavior for the OrderService mock bean
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义 OrderService 模拟 Bean 的预期行为
- en: ❺ Expects the order is created successfully
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 预期订单创建成功
- en: 'Next, run the slice tests for the web layer to ensure they pass:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行网络层的切片测试以确保它们通过：
- en: '[PRE39]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Great job! You successfully built and tested a reactive application, maximizing
    scalability, resilience, and cost-effectiveness. In the source code accompanying
    the book, you can find more test examples, including full integration tests using
    the @SpringBootTest annotation and slice tests for the JSON layer using @JsonTest,
    as you learned in chapter 3.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你成功构建并测试了一个反应式应用程序，最大化了可伸缩性、弹性和成本效益。在书中的源代码中，你可以找到更多测试示例，包括使用 @SpringBootTest
    注解的完整集成测试，以及使用 @JsonTest 对 JSON 层进行切片测试，正如你在第 3 章中学到的。
- en: Polar Labs
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Labs
- en: Feel free to apply what you learned in the previous chapters and prepare the
    Order Service application for deployment.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 随意应用你在前几章学到的知识，并为部署订单服务应用做好准备。
- en: Add Spring Cloud Config Client to Order Service to make it fetch configuration
    data from Config Service.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Spring Cloud Config Client 添加到订单服务中，使其能够从配置服务中获取配置数据。
- en: Configure the Cloud Native Buildpacks integration, containerize the application,
    and define the commit stage of the deployment pipeline.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Cloud Native Buildpacks 集成，容器化应用程序，并定义部署管道的提交阶段。
- en: Write the Deployment and Service manifests for deploying Order Service to a
    Kubernetes cluster.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写部署和服务清单，以便将订单服务部署到 Kubernetes 集群。
- en: Configure Tilt to automate the Order Service deployment to your local Kubernetes
    cluster initialized with minikube.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Tilt 以自动化将订单服务部署到使用 minikube 初始化的本地 Kubernetes 集群。
- en: You can refer to the Chapter08/08-end folder in the code repository accompanying
    the book to check the final result ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
    You can deploy the backing services from the manifests available in the Chapter08/08-end/polar-deployment/kubernetes/platform/development
    folder with kubectl apply -f services.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考书中附带的代码仓库中的 Chapter08/08-end 文件夹来检查最终结果 ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))。你可以使用
    kubectl apply -f services 从 Chapter08/08-end/polar-deployment/kubernetes/platform/development
    文件夹中可用的清单部署支持服务。
- en: The next chapter will continue our discussion of resilience and introduce more
    patterns, like circuit breakers and rate limiters, using Spring Cloud Gateway,
    Spring Cloud Circuit Breaker, and Resilience4J.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续我们关于弹性的讨论，并介绍更多模式，如断路器和速率限制器，使用 Spring Cloud Gateway、Spring Cloud Circuit
    Breaker 和 Resilience4J。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When you expect high traffic and concurrency with fewer computational resources,
    the reactive paradigm can improve the application’s scalability, resilience, and
    cost-effectiveness at the expense of a steeper initial learning curve.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你预期高流量和并发，但计算资源较少时，反应式范式可以在牺牲更陡峭的学习曲线的代价下提高应用程序的可伸缩性、弹性和成本效益。
- en: Choose between a non-reactive and a reactive stack according to your requirements.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你的需求，在非反应式和反应式堆栈之间进行选择。
- en: Spring WebFlux is based on Project Reactor and is the core of the reactive stack
    in Spring. It supports asynchronous, non-blocking I/O.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux 基于 Project Reactor，是 Spring 中反应式堆栈的核心。它支持异步、非阻塞 I/O。
- en: Reactive RESTful services can be implemented through @RestController classes
    or router functions.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过 @RestController 类或路由函数实现反应式 RESTful 服务。
- en: The Spring WebFlux slice can be tested through the @WebFluxTest annotation.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过 @WebFluxTest 注解测试 Spring WebFlux 部分。
- en: 'Spring Data R2DBC provides support for reactive data persistence using the
    R2DBC driver. The approach is the same as for any Spring Data project: database
    drivers, entities, and repositories.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data R2DBC 提供了使用 R2DBC 驱动程序支持反应式数据持久化的功能。该方法是任何 Spring Data 项目相同的：数据库驱动程序、实体和仓库。
- en: Database schemas can be managed with Flyway.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 Flyway 管理数据库模式。
- en: The persistence slice of a reactive application can be tested using the @DataR2dbcTest
    annotation and Testcontainers.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 @DataR2dbcTest 注解和 Testcontainers 测试反应式应用程序的持久化部分。
- en: A system is resilient if it keeps providing its services in the face of faults
    without the user noticing it. Sometimes that’s not possible, so the least you
    can do is ensure a graceful degradation of the services.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统在出现故障时仍能继续提供服务而用户没有察觉到，则该系统是具有弹性的。有时这可能不可能实现，所以您至少要确保服务的优雅降级。
- en: WebClient is based on Project Reactor and works with Mono and Flux publishers.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebClient基于Project Reactor，并与Mono和Flux发布者协同工作。
- en: You can use the Reactor operators to configure timeouts, retries, fallbacks,
    and error handling to make the interaction more resilient to any failure in the
    service downstream or due to the network.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Reactor操作符来配置超时、重试、回退和错误处理，以使与服务交互更加健壮，能够抵御服务下游或网络中的任何故障。
