- en: Part 2\. Foundations of design
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 设计基础
- en: The basis for effective software is intentional design, and in the process of
    designing software, you’ll find that the same few concepts pop up again and again.
    [Part 2](#part02) of this book will prepare you for the intricacies of large software
    projects by covering these fundamentals of software design. You’ll learn how to
    organize code, make it more efficient, and test that it works as you expect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的软件的基础是有意的设计，在设计软件的过程中，你会发现一些相同的概念会反复出现。[本书的第二部分](#part02)将为你准备大型软件项目的复杂性，通过涵盖软件设计的这些基本原理。你将学习如何组织代码，使其更高效，并测试其是否按预期工作。
- en: As you read the rest of this book, you’ll see these concepts explicitly reiterated
    from time to time. See if you can also tie the new things you learn back to these
    concepts on your own. Frequent repetition of software design fundamentals will
    help you make them part of your day-to-day work, where they’ll be most effective.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本书的其余部分时，你将不时地看到这些概念被明确地重申。看看你是否也能将这些新学到的知识与你自己的这些概念联系起来。软件设计基础知识的频繁重复将帮助你将它们融入日常工作中，在那里它们将最为有效。
- en: Chapter 2\. Separation of concerns
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. 关注点分离
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using Python’s features for code organization and separation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的特性进行代码组织和分离
- en: Choosing how and when to separate code into distinct pieces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择何时以及如何将代码分离成独立的片段
- en: The levels of granularity in separating code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离代码的粒度级别
- en: A cornerstone of *clear code* is the division of its various behaviors into
    small, manageable pieces. Clear code requires you to keep less knowledge in your
    head at any given time, making the code simpler to reason about. Short segments
    of code with clear intent are a big step in this direction, but bits of code should
    not be broken up along arbitrary boundaries. Separating them by *concern* is an
    effective approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰代码的基石是将各种行为划分为小而可管理的部分。清晰的代码要求你在任何给定时间记住的知识更少，这使得代码更容易推理。具有明确意图的简短代码段是朝着这个方向迈出的重要一步，但代码片段不应沿任意边界分割。通过*关注点*进行分离是一种有效的方法。
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A *concern* is a distinct behavior or piece of knowledge your software deals
    with. Concerns can range in granularity from how to calculate a square root to
    how payments are managed in an e-commerce system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*关注点*是软件处理的一个独特的行为或知识片段。关注点的粒度可以从计算平方根的方法到电子商务系统中支付管理。'
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this chapter, I’ll discuss the tools built into Python for separating the
    concerns in your code, as well as the philosophy that goes into deciding how and
    when to use them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论Python内置的工具，用于分离代码中的关注点，以及决定何时以及如何使用它们的哲学。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you haven’t yet, you’ll want to set up Python on your computer so you can
    follow along with the code in this book. The installation and best practices are
    all covered in the appendix, so before you go too much further, you should head
    there and get set up. I’ll be right here when you’re ready. Remember that you
    can get the full source code for the book’s examples and exercises in the book’s
    repository on GitHub ([https://github.com/daneah/practices-of-the-python-pro](https://github.com/daneah/practices-of-the-python-pro)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有设置，你需要在你的计算机上设置Python，以便跟随本书中的代码。安装和最佳实践都在附录中介绍，所以在你继续之前，你应该去那里设置好。当你准备好了，我就会在这里。记住，你可以在GitHub上找到本书示例和练习的完整源代码（[https://github.com/daneah/practices-of-the-python-pro](https://github.com/daneah/practices-of-the-python-pro)）。
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.1\. Namespacing
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 命名空间
- en: Like many programming languages, Python isolates code through the concept of
    *namespaces*. As a program runs, it keeps track of all the known namespaces and
    the information available in those namespaces.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多编程语言一样，Python通过*命名空间*的概念来隔离代码。当程序运行时，它会跟踪所有已知的命名空间以及这些命名空间中可用的信息。
- en: 'Namespaces are helpful in a few ways:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间在几个方面都有帮助：
- en: As software grows, multiple concepts will need similar or identical names. Namespaces
    help minimize collisions so it remains clear to which concept a name refers.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着软件的增长，多个概念将需要类似或相同的名称。命名空间有助于最小化冲突，使名称指向的概念保持清晰。
- en: As software grows, it becomes exponentially more difficult to know what code
    is already present in the codebase. Namespaces help you make educated guesses
    about where code might live, if it does exist.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着软件的增长，了解代码库中已经存在的代码变得越来越困难。命名空间帮助你做出关于代码可能存在的明智猜测。
- en: When adding new code to a large codebase, the existing namespaces can guide
    where the new code should live. If no obvious choice exists, a new namespace might
    be appropriate.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向大型代码库添加新代码时，现有的命名空间可以指导新代码应该放在哪里。如果没有明显的选择，可能需要一个新命名空间。
- en: Namespaces are so important, in fact, that they are included as the last statement
    in “The Zen of Python” (if you’re unfamiliar with “The Zen of Python,” try firing
    up the Python interpreter and typing `import` `this`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间非常重要，实际上，它们被包含在“Python之禅”的最后一条语句中（如果你不熟悉“Python之禅”，可以尝试启动Python解释器并输入`import
    this`）。
- en: '*Namespaces are one honking great idea—let’s do more of those!*'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*命名空间是一个绝妙的想法——让我们多做些这样的工作！*'
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Zen of Python*'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*《Python之禅》*'
- en: The names for all the variables, functions, and classes you’ve ever used in
    Python were names in one namespace or another. Names, like `x` or `total` or `EssentialBusinessDomainObject`,
    are references to something. When your Python code says `x = 3`, it means “assign
    the value 3 to the name `x`,” and you can then refer to `x` in your code. A “variable”
    is a name that refers to a value, though names can refer to functions, classes,
    and more in Python.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你在Python中使用过的所有变量、函数和类的名称都是某个命名空间中的名称。名称，如`x`、`total`或`EssentialBusinessDomainObject`，是对某物的引用。当你的Python代码说`x
    = 3`时，意味着“将值3赋给名称`x`”，然后你可以在代码中引用`x`。在Python中，“变量”是一个指向值的名称，尽管名称可以指向函数、类等。
- en: 2.1.1\. Namespaces and the import statement
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 命名空间和导入语句
- en: When you first open the Python interpreter, the *built-in* namespace is populated
    with all the stuff built into Python. This namespace contains built-in functions
    like `print()` and `open()`. These built-ins have no prefix, and you don’t need
    to do anything special to use them. Python makes them available to you anywhere
    in your code. That’s why the famously easy `print('Hello world!')` Just Works™
    in Python.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '当你第一次打开Python解释器时，*内置* 命名空间被所有内置到Python中的内容填充。这个命名空间包含内置函数，如`print()`和`open()`。这些内置函数没有前缀，你不需要做任何特别的事情就可以使用它们。Python使它们在代码的任何地方都可用。这就是为什么著名的简单`print(''Hello
    world!'')`在Python中“Just Works™”。 '
- en: 'Unlike in some languages, you won’t *explicitly* create namespaces in your
    Python code, but your code structure will affect what namespaces are created and
    how they interact. As an example, creating a Python *module* automatically creates
    an additional namespace for that module. At its simplest, a Python module is a
    .py file that contains some code. A file named sales_tax.py, for example, is “the
    sales_tax module”:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些语言不同，你不会在Python代码中 *显式地* 创建命名空间，但你的代码结构将影响创建哪些命名空间以及它们如何交互。例如，创建Python *模块*
    会自动为该模块创建一个额外的命名空间。在最简单的情况下，Python模块是一个包含一些代码的.py文件。例如，名为`sales_tax.py`的文件是“销售税模块”：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each module has a *global* namespace, which code in the module can access freely.
    Functions, classes, and variables that aren’t nested inside anything are in the
    module’s global namespace:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有一个 *全局* 命名空间，模块中的代码可以自由访问。不在任何东西内部嵌套的函数、类和变量都在模块的全局命名空间中：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* TAX_RATES_BY_STATE is in the module’s global namespace.**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `TAX_RATES_BY_STATE` 在模块的全局命名空间中。**'
- en: '***2* Code in the module can use TAX_RATES_BY_STATE without any fuss.**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模块中的代码可以使用 `TAX_RATES_BY_STATE` 而无需任何麻烦。**'
- en: 'Functions and classes in a module also have a *local* namespace that only they
    can access:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的函数和类也有一个 *局部* 命名空间，只有它们可以访问：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* tax_rate is only in the local scope for add_sales_tax().**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `tax_rate` 只在 `add_sales_tax()` 的局部作用域中。**'
- en: '***2* Code in add_sales_tax() can use tax_rate without any fuss.**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `add_sales_tax()` 中的代码可以使用 `tax_rate` 而无需任何麻烦。**'
- en: A module that wants to use a variable, function, or class from another module
    must *import* it into its global namespace. Importing is a way of pulling a name
    from somewhere else into the desired namespace.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想要从另一个模块使用变量、函数或类的模块必须将其 *导入* 到其全局命名空间中。导入是将名称从其他地方拉入所需命名空间的一种方式。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The add_sales_tax function is added to the receipt global namespace.**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `add_sales_tax` 函数被添加到收据的全局命名空间中。**'
- en: '***2* add_sales_tax still knows about TAX_RATES_BY_STATE and tax_rate from
    its own namespace.**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `add_sales_tax` 仍然知道它自己的命名空间中的 `TAX_RATES_BY_STATE` 和 `tax_rate`。**'
- en: 'So, to refer to a variable, function, or class in Python, one of the following
    must be true:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Python中引用变量、函数或类时，以下条件之一必须成立：
- en: The name is in the Python built-in namespace.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称在Python内置命名空间中。
- en: The name is the current module’s global namespace.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称是当前模块的全局命名空间。
- en: The name is in the current line of code’s local namespace.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称在当前代码行的局部命名空间中。
- en: 'The precedence for conflicting names works in the opposite order: a local name
    will override a global name, which will override a built-in name. You can remember
    this because generally the definition most specific to the current code is the
    one that gets used. This is shown in [figure 2.1](#ch02fig01).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突名称的优先级顺序是相反的：局部名称会覆盖全局名称，全局名称会覆盖内置名称。你可以通过记住这一点，因为通常与当前代码最具体的定义是会被使用的。这可以在[图2.1](#ch02fig01)中看到。
- en: Figure 2.1\. The specificity of namespaces
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. 命名空间的特定性
- en: '![](../Images/f0045-01_alt.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0045-01_alt.jpg)'
- en: 'You might have seen a `NameError: name ''my_var'' is not defined` error sometime
    in your adventures with Python. That means the name `my_var` wasn’t found in any
    of the namespaces known to that code. This usually means you never assigned `my_var`
    a value, or you assigned it somewhere else and need to import it.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能曾在Python的冒险中遇到过`NameError: name ''my_var'' is not defined`错误。这意味着`my_var`名称在代码所知的任何命名空间中都没有找到。这通常意味着你从未为`my_var`分配值，或者你在其他地方分配了它，需要导入它。'
- en: Modules are a great way to begin splitting up code. If you have one long script.py
    file with a bunch of unrelated functions in it, consider breaking those functions
    out into modules.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是开始分割代码的绝佳方式。如果你有一个包含许多无关函数的长脚本.py文件，考虑将这些函数拆分到模块中。
- en: 2.1.2\. The many masks of importing
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 导入的多种面貌
- en: 'The syntax for importing in Python seems straightforward at first, but there
    are a few ways to go about it, and each results in subtle differences in the information
    brought into the namespace. Earlier, you imported the `add_sales_tax()` function
    from the sales_tax module into the receipt module:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python中导入的语法一开始看起来很简单，但有一些不同的方法来实现，每种方法都会在命名空间中引入的信息上产生细微的差异。之前，你从sales_tax模块将`add_sales_tax()`函数导入到receipt模块中：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This adds the `add_sales_tax()` function to the global namespace of the receipt
    module. That’s all well and good, but suppose you add ten more functions to the
    sales_tax module and want to use them all in receipt. If you continue down the
    same path, you’ll end up with something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`add_sales_tax()`函数添加到receipt模块的全局命名空间中。这很好，但假设你向sales_tax模块添加了十个更多函数，并想在receipt中使用它们。如果你继续走这条路，你最终会得到类似这样的结果：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There’s an alternative syntax that improves on this a bit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代语法对此进行了一些改进：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Still not great. When you need a host of functionality from another module,
    you can import that module in full instead:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然不是很好。当你需要从另一个模块获取大量功能时，你可以完整地导入该模块：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This adds the whole sales_tax module to the current namespace, and its functions
    can be referenced with a `sales_tax.` prefix:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将整个sales_tax模块添加到当前命名空间中，其函数可以通过`sales_tax.`前缀来引用：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This has the benefit of avoiding long `import` statements, and, as you’ll see
    in the next section, the prefix helps avoid namespace collisions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这的好处是避免了长的`import`语句，并且，正如你将在下一节中看到的，前缀有助于避免命名空间冲突。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Python allows you to import all the names from a module in shorthand using `from
    themodule import *`. It’s tempting to use this form instead of prefixing those
    names with `themodule.` throughout your code, but *please don’t*! These wildcard
    imports can cause name collisions and make problems hard to debug because you
    can’t see the specific names being imported. Stick to explicit imports!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你使用简写`from themodule import *`从模块中导入所有名称。这很有诱惑力，但请**不要**这样做！这些通配符导入可能导致名称冲突，并使问题难以调试，因为你无法看到正在导入的具体名称。坚持使用显式导入！
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.1.3\. Namespaces prevent collisions
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3\. 命名空间防止冲突
- en: 'If you want to get the current time in a Python program, you can do so by importing
    the `time()` function from the time module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Python程序中获取当前时间，你可以通过从time模块导入`time()`函数来实现：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see output like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下输出：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`time()` returns the current Unix time.^([[1](#ch02fn01)]) The datetime module
    also contains something with the name `time`, but it does something different:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`time()`返回当前的Unix时间.^([[1](#ch02fn01)]) datetime模块也包含一个名为`time`的东西，但它做的是不同的事情：'
- en: ¹
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See the Wikipedia article for an explanation of Unix time: [https://en.wikipedia.org/wiki/Unix_time](https://en.wikipedia.org/wiki/Unix_time).'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅维基百科文章以了解Unix时间的解释：[https://en.wikipedia.org/wiki/Unix_time](https://en.wikipedia.org/wiki/Unix_time)。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This time you should see this output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你应该看到这个输出：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This `time` is actually a class, and calling it returns a `datetime.time` instance
    that defaults to midnight (0 hours, 0 minutes, and so on). What happens when you
    import them both?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `time` 实际上是一个类，调用它返回一个默认为午夜（0小时，0分钟等）的 `datetime.time` 实例。当你同时导入它们时会发生什么？
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Which time is this?**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这是哪个时间？**'
- en: In cases of ambiguity, Python uses the most recent definition it knows about.
    If you import `time` from one place and then import another `time` from another
    place, it will only know about the latter. If you don’t make use of namespaces,
    it will be difficult to tell which `time()` is being referenced in the code, and
    you might use the wrong one by mistake. This is a compelling reason to import
    modules as a whole; it forces you to prefix names from the module so that it’s
    clear where the names come from.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在歧义的情况下，Python 使用它所知道的最新定义。如果你从一个地方导入 `time`，然后从另一个地方导入另一个 `time`，它只会知道后者。如果你不使用命名空间，将很难确定代码中引用的是哪个
    `time()`，你可能会不小心使用错误的版本。这是一个强有力的理由，应该整体导入模块；它迫使你使用模块前缀来命名，这样就可以清楚地知道名称的来源。
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* It’s clear which time this means.**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 很明显，这个时间指的是什么。**'
- en: '***2* This time is referenced uniquely as well.**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这次时间被唯一地引用了。**'
- en: 'Sometimes name collisions are difficult to avoid, even with the tools you’ve
    seen so far. If you create a module with the same name as a module built into
    Python or from a third-party library, and you need them both in one module, you’ll
    need more firepower. Fortunately, it’s one Python keyword away. You can alias
    a name to another name when you import it, using the `as` keyword:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使使用你迄今为止看到的工具，名称冲突也难以避免。如果你创建了一个与 Python 内置模块或第三方库同名的模块，并且你需要在同一个模块中使用它们两个，你需要更多的力量。幸运的是，这只需要一个
    Python 关键字。当你导入时，可以使用 `as` 关键字将一个名称别名为另一个名称：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now `datetime` is available as expected, and the third-party `datetime` is available
    as `cooldatetime`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如预期的那样，`datetime` 可用，第三方 `datetime` 可用为 `cooldatetime`。
- en: You shouldn’t override Python’s built-in functionality unless you have a compelling
    reason to, so it’s best to avoid using the same names as built-ins unless you
    intend to replace them. But if you don’t know the whole standard library (I sure
    don’t!) it might still happen by accident on occasion. You could alias your module
    to a new name wherever you import it on other modules, but I recommend renaming
    the module and updating any references to it throughout your code so your imports
    stay consistent with the module’s filename.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有充分的理由要覆盖 Python 的内置功能，否则最好不要使用与内置相同的名称，除非你打算替换它们。但如果你不知道整个标准库（我肯定不知道！），有时仍然可能会意外发生。你可以在导入其他模块时将你的模块别名到一个新名称，但我建议重命名模块并更新代码中对其的所有引用，以确保你的导入与模块的文件名保持一致。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Most integrated development environments (IDEs) will give you a warning when
    you override the name of a Python built-in so you don’t go too far down that road
    by accident.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数集成开发环境（IDE）会在你覆盖 Python 内置函数名称时给你一个警告，这样你就不太可能意外地走得太远。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With these importing practices, you should be able to `import` everything you
    need without issue. Remember that module name prefixes (like `time.` and `datetime.`)
    are helpful in the long run because namespace collisions can and do happen. When
    you run into a collision, take a deep breath and confidently rework your import
    statements or create an alias and be on your way!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些导入实践，你应该能够无问题地导入你需要的一切。记住，模块名称前缀（如 `time.` 和 `datetime.`）在长期来看是有帮助的，因为命名空间冲突确实会发生。当你遇到冲突时，深呼吸，自信地重新编写你的导入语句或创建一个别名，然后继续前进！
- en: 2.2\. The hierarchy of separation in Python
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. Python 中的分离层次
- en: One way to distinguish separate concerns is to follow the Unix philosophy of
    “do one thing and do it well.”^([[2](#ch02fn02)]) When a particular function or
    class in your code is concerned with a single behavior, you can improve it independent
    of the code that uses it. In contrast, if behaviors are duplicated and mixed together
    throughout your code, it may be difficult to update a particular behavior without
    thinking about—and in the worst case, breaking—several other behaviors. Many functions
    on a website, for example, might rely on information from the currently authenticated
    user. If they all check authentication and fetch information about that user themselves,
    they’ll all need to be updated when the details about authentication change. That’s
    a lot of work, and if one function is missed, it may start doing unexpected things
    or stop working altogether.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 区分不同关注点的一种方法是通过遵循Unix哲学中的“做好一件事”原则。^([[2](#ch02fn02)]) 当你的代码中的某个特定函数或类关注单一行为时，你可以独立于使用它的代码来改进它。相比之下，如果行为在代码中重复并混合在一起，那么在不考虑——在最坏的情况下，破坏——其他几个行为的情况下更新特定行为可能会很困难。例如，网站上的许多函数可能依赖于当前认证用户的信息。如果它们都检查认证并自行获取有关该用户的信息，那么在认证细节更改时，它们都需要更新。这是一项大量工作，如果遗漏了一个函数，它可能会开始执行意外的操作或完全停止工作。
- en: ²
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See the Wikipedia article on Unix philosophy: [https://en.wikipedia.org/wiki/Unix_philosophy](https://en.wikipedia.org/wiki/Unix_philosophy).'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅维基百科上关于Unix哲学的文章：[https://en.wikipedia.org/wiki/Unix_philosophy](https://en.wikipedia.org/wiki/Unix_philosophy)。
- en: Just as namespacing has a hierarchy of granularity in Python, so too does the
    wider approach to separation of concerns. There are no steadfast rules about how
    deep or shallow to make this hierarchy; sometimes it makes sense to call a function
    that calls a function that calls a function. Remember that the goal of separating
    concerns is to group like activities together and keep dissimilar activities isolated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Python中命名空间有粒度层次一样，对关注点分离的更广泛方法也是如此。关于如何使这个层次深或浅，没有固定的规则；有时调用一个函数，该函数又调用另一个函数，这是有意义的。记住，分离关注点的目标是把类似的活动放在一起，并将不同的活动隔离开来。
- en: The next sections cover the structural tools Python programs use to organize
    and keep concerns separate. If you feel good about functions and classes, you
    can skip ahead to [section 2.2.3](#ch02lev2sec6).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍Python程序用来组织和保持关注点分离的结构性工具。如果你对函数和类感到满意，可以跳到[第2.2.3节](#ch02lev2sec6)。
- en: 2.2.1\. Functions
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1. 函数
- en: If you’re not too comfortable with *functions*, think back to math class. Mathematical
    functions are formulas, notated (in non-Python syntax) like `f(x) = x^2 + 3`,
    that map inputs to outputs. Inputting `x = 5` returns `f(5) = 5^2 + 3 = 25 + 3
    = 28`. In software, functions play the same role. Given a set of input variables,
    a function performs some calculation or transformation and returns a result.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉*函数*，回想一下数学课。数学函数是公式，用非Python语法表示，如`f(x) = x^2 + 3`，它将输入映射到输出。输入`x =
    5`返回`f(5) = 5^2 + 3 = 25 + 3 = 28`。在软件中，函数扮演着同样的角色。给定一组输入变量，函数执行一些计算或转换并返回一个结果。
- en: This way of thinking about functions leads naturally to the idea that functions
    in software should generally be short. If a function becomes too long or does
    too many things, it can be difficult to characterize and therefore difficult to
    name. `f(x) = x^2 + 3` is a quadratic function of `x`, whereas `f(x) = x^5 + 17x
    ^ 9 - 2x + 7` is more difficult to name. In software, mixing too many concepts
    leads to a nebulous mass of code that can’t be named easily.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关于函数的思考方式自然地引出了软件中的函数通常应该是短小的观点。如果一个函数变得太长或做了太多的事情，那么它可能很难被描述，因此也很难被命名。`f(x)
    = x^2 + 3`是关于`x`的二次函数，而`f(x) = x^5 + 17x^9 - 2x + 7`则更难命名。在软件中，混合过多的概念会导致难以命名的模糊代码块。
- en: 'Small functions are one of the first tools to reach for when trying to break
    up your code. A function wraps a few lines of code and gives them a clear name
    for later reference. Creating a function not only makes it clearer what’s happening,
    but lets you reuse the code as needed. Python itself does this: if you’ve used
    `open()` to read a file or `len()` to get the length of a list, you’ve made use
    of functionality Python deemed important enough to wrap and give a name.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试将代码拆分时，小型函数是首先要考虑的工具之一。一个函数封装了几行代码，并为它们提供了一个清晰的名称，以便以后参考。创建一个函数不仅使正在发生的事情更清晰，而且可以根据需要重用代码。Python本身就是这样做的：如果你使用`open()`读取文件或`len()`获取列表长度，你就已经使用了Python认为足够重要而封装并命名的功能。
- en: The process of breaking a problem into small, manageable pieces is called *decomposition*.
    Imagine a mushroom breaking down a fallen tree. It turns the wood, made of complex
    molecules, into more fundamental materials like nitrogen and carbon dioxide. These
    then get recycled back into the ecosystem. Your code can be decomposed into functions
    that get recycled back into your software’s ecosystem, as shown in [figure 2.2](#ch02fig02).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题分解成小而可管理的部分的过程称为*分解*。想象一下蘑菇分解倒下的树木。它将复杂的分子木材转化为更基本的材料，如氮气和二氧化碳。然后这些物质被重新循环回生态系统。你的代码可以被分解成函数，这些函数可以重新循环回你的软件生态系统，如图2.2所示。
- en: Figure 2.2\. The value of decomposition
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 分解的价值
- en: '![](../Images/f0050-01_alt.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0050-01_alt.jpg)'
- en: 'Suppose you’re creating a fan site for the Three Stooges (an American comedy
    troupe^([[3](#ch02fn03)])). To build the home page, you need to introduce the
    stooges: Larry, Curly, and Moe. Given the list of names and the title of the act,
    the code should produce the string `''The Three Stooges: Larry, Curly, and Moe''`.
    An initial implementation could look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '假设你正在创建一个三傻大闹的粉丝网站（一个美国喜剧团体^([[3](#ch02fn03)])）。为了构建主页，你需要介绍三傻：拉里、库利和莫伊。给定名单和节目标题，代码应该生成字符串
    `''The Three Stooges: Larry, Curly, and Moe''`。一个初始实现可能如下所示：'
- en: ³
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/The_Three_Stooges](https://en.wikipedia.org/wiki/The_Three_Stooges)'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/The_Three_Stooges](https://en.wikipedia.org/wiki/The_Three_Stooges)'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After doing some research, you realize the original lineup of the stooges was
    different, and you want an accurate page for each lineup. Your initial temptation
    is to add code to do the same work for the original lineup:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了一些研究后，你意识到三傻的原阵容是不同的，你想要为每个阵容创建一个准确的页面。你的最初冲动是添加代码来为原始阵容做同样的工作：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This works, but the original code wasn’t terribly clear to begin with, and
    now there are *two* of them! Extracting the introduction logic into a function
    reduces the duplication and gives the code a name to clarify what it does:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法可行，但原始代码一开始就不太清晰，现在有两个版本了！将介绍逻辑提取到函数中可以减少重复，并为代码赋予一个名称来明确其功能：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* The extracted function takes character names as a parameter.**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提取的函数接受角色名称作为参数。**'
- en: '***2* Multiple sets of names can be used with the same function.**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 可以使用相同的函数处理多组名称。**'
- en: Now the behavior has a clear name, and if you want to spend some time making
    the code even clearer, you can focus on the `introduce_stooges` function body
    alone. As long as the function continues accepting a list of names and continues
    printing the introduction you want, you can be confident your code still works.^([[4](#ch02fn04)])
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在行为有一个清晰的名字，如果你想要花时间使代码更加清晰，你可以专注于`introduce_stooges`函数体本身。只要函数继续接受一个名单并继续打印你想要的介绍，你就可以确信你的代码仍然有效.^([[4](#ch02fn04)])
- en: ⁴
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For a detailed discussion on extracting functions (and other valuable exercises),
    I highly recommend Martin Fowler and Kent Beck, Refactoring, second edition (Addison-Wesley
    Professional, 2018), [https://martinfowler.com/books/refactoring.html](https://martinfowler.com/books/refactoring.html).
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于提取函数（以及其他有价值的练习）的详细讨论，我强烈推荐马丁·福勒和肯特·贝克合著的《重构》（第二版，Addison-Wesley Professional，2018），[https://martinfowler.com/books/refactoring.html](https://martinfowler.com/books/refactoring.html)。
- en: 'Pleased with your Three Stooges fan page, you decide to expand to other famous
    groups. As you start working on the Teenage Mutant Ninja Turtles,^([[5](#ch02fn05)])
    though, you notice an issue: the `introduce_stooges` function only introduces
    stooges (as you might guess). As it turns out, the function has two concerns:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的三傻大闹粉丝页面感到满意，你决定扩展到其他著名团体。当你开始处理《忍者神龟》时，^([[5](#ch02fn05)]), 你注意到一个问题：`introduce_stooges`函数只介绍三傻（正如你可能猜到的）。实际上，这个函数有两个关注点：
- en: ⁵
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://mng.bz/RPan](http://mng.bz/RPan)'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://mng.bz/RPan](http://mng.bz/RPan)'
- en: Knowing the introduction is for the Three Stooges
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解三傻大闹的电影介绍
- en: Introducing a list of names as the stooges
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个角色名单作为三傻
- en: How do you move past this? You can generalize the function and separate the
    first concern by extracting the group title (“The Three Stooges”, “Teenage Mutant
    Ninja Turtles”, and so on) as another argument to the function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如何超越这个？你可以泛化函数，并通过提取组标题（“The Three Stooges”，“Teenage Mutant Ninja Turtles”等等）作为函数的另一个参数来分离第一个关注点。
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* _stooges is dropped from the function name, and title is passed in.**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从函数名中删除了“stooges”，并将标题作为参数传递。**'
- en: '***2* The group title gets passed in when the function is called.**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 当函数被调用时，会传递组标题。'
- en: '***3* Different groups can be introduced with one function.**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 可以用一个函数介绍不同的组。'
- en: 'The function accommodates the requirements of your fan site now: it knows only
    that groups have a title and several named members, and it uses that information
    to perform the introduction. It can accept new groups easily as you expand your
    site. If at some point you need to change how you introduce the groups, you’ll
    know to head over to the `introduce()` function.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数现在满足你粉丝网站的需求：它只知道组有一个标题和几个命名的成员，并使用这些信息来进行介绍。随着你网站的扩展，它可以轻松地接受新的组。如果在某个时候你需要改变介绍组的方式，你会知道去查看`introduce()`函数。
- en: After decomposing code into functions, it’s likely you’ll end up with code that’s
    longer than the original. But if you carefully decompose code by its concerns,
    drawing out and explicitly naming the different things going on, you should see
    an improvement in the readability of that code. Overall code length isn’t so important;
    it’s the length of individual functions and methods that makes a difference.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分解成函数后，你可能会得到比原始代码更长的代码。但如果你仔细地根据关注点分解代码，明确地命名正在发生的事情，你应该会看到代码可读性的提升。整体代码长度并不那么重要；真正重要的是单个函数和方法的长短。
- en: To that end, there’s still some work to be done on the `introduce` function.
    Its duty is to form an introduction string from the group title and names. It
    shouldn’t necessarily know how that list of names should be joined together, using
    commas and an Oxford comma and so on. We can extract that bit into its own function
    as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对`introduce`函数还有一些工作要做。它的任务是使用组标题和名字形成介绍字符串。它不必知道如何使用逗号和牛津逗号等将名字列表连接起来。我们可以将这部分提取出来，作为一个单独的函数。
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* This function handles only how names are joined.**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 这个函数只处理名字的连接方式。'
- en: '***2* This function now knows only that introductions are titles followed by
    joined names.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 这个函数现在只知道介绍是标题后跟连接的名字。'
- en: This will look like overkill to some—the `introduce` function doesn’t do much
    anymore. The value in this kind of decomposition, where each concern is separated
    into a function, pays dividends later when you’re trying to fix bugs, add features,
    and test your code. If you notice a bug in the way names are joined, it’s easier
    to find the lines to change in `join_names` than if it were all a single `introduce`
    function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于一些人来说可能看起来有些过度——`introduce`函数不再做太多。这种分解的价值在于，将每个关注点分离到函数中，当你试图修复错误、添加功能或测试代码时，会带来回报。如果你注意到名字连接的方式有错误，在`join_names`中找到需要更改的行比在所有内容都是单个`introduce`函数时更容易。
- en: In general, decomposition into functions that separate concerns allows for more
    *surgical* changes; that is, you can be more precise with a change and have minimal
    impact on the surrounding code. Over the course of a project, this can save you
    a significant amount of time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，将关注点分离到不同的函数中可以允许进行更**精确**的修改；也就是说，你可以更精确地进行修改，同时对周围代码的影响最小。在整个项目过程中，这可以为你节省大量的时间。
- en: I’ve mentioned that design, refactoring, and now decomposition and separation
    of concerns are practices you should incorporate into a healthy iterative development
    process. It might start to feel like you’re spinning plates instead of shipping
    code, but as you progress into bigger software, you’ll find that you draw on these
    practices regularly. The longevity and success of many projects is influenced
    by the quality of the code, which is in turn influenced by the care taken in creating
    it. Try to sprinkle these approaches into your development process as a seasoning
    to start with, and eventually you’ll find that they become the staple ingredients.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，设计、重构，现在分解和关注点分离都是你应该融入健康迭代开发过程中的实践。这可能会开始感觉像是在旋转盘子而不是在发布代码，但随着你进入更大的软件项目，你会发现你经常使用这些实践。许多项目的长期性和成功受到代码质量的影响，而代码质量又反过来受到创建它的细心程度的影响。尝试将这些方法作为调味料撒入你的开发过程中，最初，你会发现它们最终成为主要的成分。
- en: TRY IT OUT
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试一下
- en: Now that you’ve got some experience extracting functions, see what functions
    are hiding within [listing 2.1](#ch02ex1), a (probably shoddy) implementation
    of Rock, Paper, Scissors. I suggest running the code frequently as you work, to
    make sure the behavior remains consistent. I’ve extracted an example set of functions
    in [listing 2.2](#ch02ex2). As a hint, I decomposed the original code into six
    functions. Your mileage may vary, but remember that you’re shooting for functions
    that have only one concern.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一些提取函数的经验了，看看 [列表 2.1](#ch02ex1) 中隐藏的函数，这是一个（可能很糟糕的）剪刀石头布的实现。我建议你在工作时经常运行代码，以确保行为保持一致。我在
    [列表 2.2](#ch02ex2) 中提取了一组示例函数。作为一个提示，我将原始代码分解成了六个函数。你的结果可能会有所不同，但记住你是在追求只有一个关注点的函数。
- en: Listing 2.1\. Shoddy procedural code
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 糟糕的过程式代码
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 2.2\. Code with extracted functions
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 提取函数的代码
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 2.2.2\. Classes
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 类
- en: Code is made up of behaviors and data that accumulate over time. You’ve seen
    how to extract behaviors into functions that accept input data and return a result.
    Over time, you might start to notice that several functions work in tandem frequently.
    If you’re passing the result of one function to another to another often, or if
    several of your functions require the same input data, it’s possible a *class*
    is waiting to be extracted from your code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码由随着时间的推移积累的行为和数据组成。你已经看到了如何将行为提取到接受输入数据并返回结果的函数中。随着时间的推移，你可能会开始注意到几个函数经常协同工作。如果你经常将一个函数的结果传递给另一个函数，或者如果你的几个函数需要相同的数据输入，那么可能有一个*类*正等待从你的代码中提取出来。
- en: Classes are templates of closely related behaviors and data. You can use classes
    to create *objects*, or instances of the class that have the data and behaviors
    defined in the class. The data becomes the *state* of the object; in Python, the
    data composes the *attributes* of the object because the data is *attributed*
    to the object in question. The behaviors become *methods*, which are special functions
    that receive the object instance as an additional argument (ubiquitously named
    `self` by Python developers). This allows the methods to access or change the
    instance’s state. Together, the attributes and methods are the *members* of a
    class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类是密切相关行为和数据的模板。你可以使用类来创建*对象*，即类的实例，这些实例具有在类中定义的数据和行为。数据成为对象的*状态*；在 Python 中，数据组成对象的*属性*，因为数据被*赋予*给特定的对象。行为成为*方法*，这些是特殊的函数，它们接收对象实例作为额外的参数（Python
    开发者普遍将其命名为 `self`）。这允许方法访问或更改实例的状态。一起，属性和方法是类的*成员*。
- en: 'Classes in many languages contain a *constructor*, which is a special method
    used to create an instance of the class. In Python, the `__init__` method (an
    initializer) is more commonly used. The class instance has already been constructed
    when `__init__` is called, and the method sets up the initial state of the instance.
    `__init__` accepts at least one argument, which most Python developers call `self`,
    that is a reference to the instance that’s been created. The method commonly accepts
    additional arbitrary arguments that are used to set the initial state. The syntax
    for creating a class instance in Python looks a lot like using a function: you
    use the class name instead of the function name, and the arguments are the arguments
    (excluding `self`) to `__init__`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言中的类包含一个*构造函数*，这是一个用于创建类实例的特殊方法。在 Python 中，`__init__` 方法（初始化器）更常用。当调用 `__init__`
    时，类实例已经构建完成，该方法设置实例的初始状态。`__init__` 至少接受一个参数，大多数 Python 开发者将其称为 `self`，它是已创建实例的引用。该方法通常接受额外的任意参数，用于设置初始状态。在
    Python 中创建类实例的语法与使用函数非常相似：你使用类名而不是函数名，参数是传递给 `__init__` 的参数（不包括 `self`）。
- en: Have another look at the functions you decomposed from Rock, Paper, Scissors
    ([listing 2.3](#ch02ex3)). What do you notice? All of the behavior and data are
    based on the three options and which one each player chooses. Some of the functions
    use the same data; these things seem closely related. Maybe a class for playing
    this game is waiting to be born.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看你从“剪刀石头布”（[列表 2.3](#ch02ex3)）中分解出来的函数。你注意到什么了？所有行为和数据都是基于三种选择以及每个玩家选择的是哪一个。一些函数使用了相同的数据；这些事物看起来密切相关。也许一个用于玩这个游戏的类正等待诞生。
- en: Listing 2.3\. Revisiting the Rock, Paper, Scissors code
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 重新审视剪刀石头布代码
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Functions use OPTIONS to determine the choices of the players.**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数使用 OPTIONS 来确定玩家的选择。**'
- en: '***2* Several functions use the human and computer choices for the simulation.**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 几个函数使用人类和计算机的选择进行模拟。**'
- en: '***3* The human and computer choices get passed around frequently.**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 人类和计算机的选择经常被传递。**'
- en: Given that the concerns of gathering and printing different pieces of the simulation
    are nicely separated into functions, you’re now free to consider the separation
    of higher-level concerns. Separating Rock, Paper, Scissors from other areas of
    your code (maybe you’re making a whole arcade!) can be done with a class like
    the one shown in [figure 2.3](#ch02fig03). Notice the new `simulate()` method,
    which will hold the code that calls all the other methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于收集和打印模拟不同部分的关注点已经很好地分离到函数中，您现在可以自由地考虑更高层次关注点的分离。通过使用如图2.3所示的类，可以将石头、剪刀、布从您的代码的其他部分（也许您正在制作一个完整的游艺厅！）中分离出来。注意新的`simulate()`方法，它将包含调用所有其他方法的代码。
- en: Figure 2.3\. Wrapping related behaviors and data in a class
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 将相关行为和数据封装在类中
- en: '![](../Images/f0057-01_alt.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0057-01_alt.jpg)'
- en: You can start by creating the class definition and moving the functions into
    it as methods, as shown in the following listing. Remember that methods take `self`
    as their first argument.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从创建类定义并将函数移动到其中作为方法开始，如下所示列表所示。请记住，方法将`self`作为其第一个参数。
- en: Listing 2.4\. Moving functions into a class as methods
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4\. 将函数移动到类中作为方法
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Methods need a “self” argument.**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 方法需要一个“self”参数。**'
- en: '***2* Methods with existing arguments still need “self”.**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用现有参数的方法仍然需要“self”。**'
- en: 'Once you’ve moved the functions, you can create a new `simulate` method for
    calling them all. Within a class, you need to write `self.some_method()` to indicate
    you want to call the `some_method` method on the class (as opposed to some other
    function in the namespace). Note that even though `some_method` takes a `self`
    argument in its definition, you do not pass it to the method when you call it.
    Python passes `self` to methods automatically. `simulate` calls the functions
    to make the simulation run:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦移动了函数，您可以为它们创建一个新的`simulate`方法来调用它们。在类中，您需要编写`self.some_method()`来表示您想要在类上调用`some_method`方法（而不是命名空间中的其他函数）。请注意，尽管`some_method`在其定义中需要一个`self`参数，但在调用它时您不需要传递它。Python会自动将`self`传递给方法。`simulate`调用函数以使模拟运行：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You might have noticed that even though everything’s contained in a class now,
    the data is still being passed all over. But now that things are contained, it’s
    easier to make some additional changes. You can create an initializer that sets
    up the attributes you need for the class, namely `human_choice` and `computer_choice`,
    with a default value of `None`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，尽管现在所有内容都包含在一个类中，但数据仍然被传递到各个地方。但现在，由于内容被封装，更容易做一些额外的更改。您可以创建一个初始化器来设置类所需的属性，即`human_choice`和`computer_choice`，默认值为`None`：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now methods can access these attributes using the `self` argument instead of
    passing them around. As a result, you can update the method bodies to use `self.human_choice`
    in place of `human_choice` and remove the `human_choice` argument altogether.
    `computer-_choice` gets the same treatment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在方法可以使用`self`参数而不是传递它们来访问这些属性。因此，您可以更新方法体以使用`self.human_choice`代替`human_choice`，并完全删除`human_choice`参数。`computer_choice`也得到同样的处理。
- en: The code boils down to what you see in the following listing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码简化到以下列表中所示的内容。
- en: Listing 2.5\. Using `self` to access attributes
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5\. 使用`self`访问属性
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Methods can set attributes on self.**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 方法可以在self上设置属性。**'
- en: '***2* Methods don’t need to take attributes as parameters.**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 方法不需要将属性作为参数。**'
- en: '***3* Methods can read attributes from self.**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 方法可以读取self中的属性。**'
- en: 'It took some work to add `self.` to the attribute references throughout the
    class, but much of it is simplified. In particular, the methods take fewer arguments,
    and the `simulate` method does little more than glue the other methods together.
    Another great outcome is that the code to simulate a game of Rock, Paper, Scissors
    now looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个类中对属性引用添加`self.`需要一些工作，但其中大部分被简化了。特别是，方法需要的参数更少，`simulate`方法所做的只是将其他方法粘合在一起。另一个很好的结果是，模拟石头、剪刀、布游戏的代码现在看起来像这样：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Pretty concise, huh? You first decomposed a bunch of code into functions to
    separate some concerns. You then grouped them into a class to separate a higher-level
    concern. Now it’s easy to call on all the hard behind-the-scenes work with a short
    expression. This is thanks to carefully selecting and grouping related data and
    behaviors.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很简洁，对吧？你首先将大量代码分解成函数以分离一些关注点。然后，你将它们分组到一个类中以分离更高层次的关注点。现在，通过简短的表达式就可以调用所有幕后工作。这要归功于仔细选择和分组相关的数据和行为。
- en: When a class’s methods and attributes are closely related, it is said to have
    high *cohesion*. A class is cohesive if its contents make sense together as a
    whole. We want our classes to have high cohesion because if everything in a class
    is closely related, our concerns are likely to be well separated. A class with
    too many concerns has low cohesion because those concerns muddy the intent of
    the class. Usually I end up creating a class only when this cohesion is already
    clear to me; some code already exhibits relatedness through the data and behaviors
    it contains.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类的方法和属性紧密相关时，我们称它具有高**凝聚性**。一个类如果其内容作为一个整体有意义，则被认为是凝聚的。我们希望我们的类具有高凝聚性，因为如果类中的所有内容都紧密相关，我们的关注点很可能被很好地分离。具有太多关注点的类具有低凝聚性，因为这些关注点会模糊类的意图。通常，我只有在这种凝聚性对我来说已经很清晰的情况下才会创建一个类；一些代码已经通过其包含的数据和行为表现出相关性。
- en: When a class depends on another class, those classes are said to be *coupled*.
    If a class depends on many details of another class, such that changing one requires
    changing the other, those classes are *tightly* coupled. Tight coupling is expensive
    because it can lead to spending more time managing the ripple effects of a change.
    *Loose* coupling is the desired end state. You’ll learn more strategies for achieving
    loose coupling in [chapter 10](../Text/kindle_split_021.html#ch10).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类依赖于另一个类时，我们称这两个类是**耦合的**。如果一个类依赖于另一个类的许多细节，以至于改变一个需要改变另一个，那么这两个类就是**紧密耦合的**。紧密耦合是昂贵的，因为它可能导致花费更多时间来管理变化的涟漪效应。**松耦合**是我们希望达到的状态。你将在第10章中学习更多实现松耦合的策略。
- en: A set of highly cohesive classes serves much the same purpose as a set of clear
    functions. It clarifies intent, helps us navigate existing code, and guides us
    in adding new code. This all helps us produce the features we want faster, instead
    of requiring us to spend time spelunking in the caverns of our software.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一组高度凝聚的类与一组清晰的函数具有相同的作用。它明确了意图，帮助我们导航现有代码，并指导我们添加新代码。所有这些都有助于我们更快地实现我们想要的特性，而不是让我们花费时间在软件的洞穴中探险。
- en: 2.2.3\. Modules
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3. 模块
- en: 'You’ve already learned the basics of creating modules in Python: a .py file
    that contains valid Python code is already a module! I touched on the question
    of when to create one, but let’s circle back to that.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了在Python中创建模块的基本知识：一个包含有效Python代码的`.py`文件已经是一个模块了！我提到了何时创建模块的问题，但现在让我们回到那个问题上来。
- en: You might have started this chapter knowing that most of your code lived in
    one giant procedural blob in script.py. And if you’ve got a short attention span
    like me, you might have gone and extracted a number of functions and classes from
    it already. Welcome back.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能一开始就知道大部分代码都生活在一个巨大的过程块中，即`script.py`。如果你像我一样注意力集中时间短，你可能已经从其中提取了许多函数和类。欢迎回来。
- en: Although your code is now nicely separated into well-named functions, classes,
    and methods, it all still lives in script.py. Eventually, the minimal structure
    provided by a single file will be insufficient for holding all your code in a
    sensible way. You won’t remember if the function you’re looking for is on line
    5 or line 205\. Breaking it down into memorable categories of behavior is the
    path forward.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的代码现在已经被很好地分离成具有良好命名的函数、类和方法，但它们仍然都生活在`script.py`文件中。最终，单文件提供的最小结构将不足以以合理的方式容纳所有代码。你将无法记得你正在寻找的函数是在第5行还是第205行。将它们分解成易于记忆的行为类别是前进的道路。
- en: 'The concerns you identify will map well to the modules you should create. Be
    conservative with the effort you spend guessing what these categories should be
    up front. They’ll change frequently at the start anyway, as your mental model
    of the system evolves and improves. But spend a little time sketching out what
    you think you’ll need, and remain open to the possibility that a different structure
    will make more sense later. The clearest code is the code you don’t write: every
    line adds additional cognitive load. The next best thing after *no* code is *well-organized*
    code.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你所提出的担忧将很好地映射到你应该创建的模块。在猜测这些类别应该是什么时，要保守地投入精力。它们在开始时就会频繁变化，因为你的系统心理模型会随着发展和改进而变化。但花点时间勾勒出你认为需要什么，并保持开放的心态，即不同的结构可能在以后会更有意义。最清晰的代码是你没有写的代码：每一行都增加了额外的认知负担。在没有任何代码之后，最好的事情就是*组织良好的代码*。
- en: Modules create additional structure around the code in them, exclaiming, “The
    code contained here is all about statistics!” If you need to do statistics things,
    you know to `import statistics` and use what’s there. If what you need isn’t there
    already, at least you have a good idea where to put it. Can you say the same for
    a 500-line script.py file? Perhaps, but not for long.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在其代码周围创建额外的结构，宣称，“这里的代码都是关于统计学的！”如果你需要做统计工作，你知道要`import statistics`并使用那里提供的内容。如果你需要的东西还没有，至少你有一个很好的想法知道把它放在哪里。你能对500行的`script.py`文件说同样的话吗？也许可以，但不会太久。
- en: 2.2.4\. Packages
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4\. 包
- en: I’ve been praising the use of modules for their ability to neatly break code
    up. Why do we need anything else?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在赞扬模块的使用，因为它们能够整洁地分割代码。我们还需要其他什么吗？
- en: 'Remember that separation of concerns is a hierarchy and that name collisions
    can still happen. Suppose your fan site has gotten popular, and now you need a
    database and a search page to keep track of it all. You’ve written record.py,
    a module for creating database records, and query.py, a module for querying the
    database:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，关注点的分离是一个层次结构，并且名称冲突仍然可能发生。假设你的粉丝网站已经变得流行，现在你需要一个数据库和一个搜索页面来跟踪所有内容。你已经编写了`record.py`，这是一个用于创建数据库记录的模块，以及`query.py`，这是一个用于查询数据库的模块：
- en: '![](../Images/f0038-01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0038-01.jpg)'
- en: 'Now you need to write a module for creating search queries. What do you call
    it? search_query.py might be an okay name, but then it would make sense to rename
    query.py to database_query.py for clarity:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要编写一个用于创建搜索查询的模块。你叫它什么？`search_query.py`可能是一个不错的名字，但这样就有必要将`query.py`重命名为`database_query.py`以提高清晰度：
- en: '![](../Images/f0038-02.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0038-02.jpg)'
- en: When two modules are conflicting in name or concept like this, you’ve outgrown
    the structure you have in place. *Packages* add further structure by splitting
    modules up into related groups. In Python, a package is nothing more than a directory
    that contains modules (.py files) and a special file that tells Python to treat
    the directory as a package (`__init__.py`). This file is often empty, but it can
    be used for more complex management of imports. Like a sales_tax.py file becomes
    “the sales_tax module,” an ecommerce/ directory becomes “the ecommerce package.”
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个模块在名称或概念上发生冲突时，你就已经超出了你现有的结构。*包*通过将模块分成相关组来添加更多的结构。在Python中，包不过是一个包含模块（.py文件）和特殊文件的目录，该文件告诉Python将该目录视为包（`__init__.py`）。这个文件通常是空的，但它可以用于更复杂的导入管理。就像`sales_tax.py`文件成为“销售税模块”一样，`ecommerce/`目录成为“电子商务包”。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: The term “packages” also refers to third-party Python libraries you can install
    from the Python Package Index (PyPI). I will do my best to disambiguate where
    needed in this book, but be warned that some resources won’t make the distinction.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: “包”这个术语也指可以从Python包索引（PyPI）安装的第三方Python库。我将尽我所能在本书中澄清需要的地方，但请注意，有些资源不会做出区分。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For the database and search modules, a database package and a search package
    would make good sense. Then the `database_` and `search_` prefixes for the modules
    will be redundant and can be removed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库和搜索模块，一个数据库包和一个搜索包会很有意义。然后模块的`database_`和`search_`前缀将是多余的，可以删除。
- en: You can expand your code hierarchy into a package, which ultimately creates
    a nice structure that you can read and navigate. Each package addresses a high-level
    area of concern, and each module in a package manages a smaller concern. Within
    each module, classes, methods, and functions further clarify the different pieces
    of the application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的代码层次结构扩展到包中，这最终创建了一个良好的结构，你可以阅读和导航。每个包解决一个高级关注领域，包中的每个模块管理一个较小的关注领域。在每个模块内部，类、方法和函数进一步阐明应用程序的不同部分。
- en: '![](../Images/f0039-01.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0039-01.jpg)'
- en: 'Where you previously would have written `import query` to use the database
    query *module*, you’ll now need to import it from the database *package* instead.
    You can write `import database.query`, which will require you to prefix names
    from the module with `database.query.`, or you can write `from database import
    query`. If you’re only using the database code in a particular module, the latter
    might be fine. But if you need to use the new search query code *and* the database
    code in a module, you must disambiguate the names, and it helps to maintain the
    prefixes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在你之前会写 `import query` 来使用数据库查询 *模块* 的情况下，你现在需要从数据库 *包* 中导入它。你可以写 `import database.query`，这将要求你在模块名称前加上
    `database.query.` 前缀，或者你可以写 `from database import query`。如果你只在特定模块中使用数据库代码，后者可能就足够了。但如果你需要在模块中使用新的搜索查询代码
    *和* 数据库代码，你必须消除歧义，并且保持前缀有助于这一点：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You could also use the `from` syntax and alias each module:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `from` 语法并为每个模块指定别名：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Aliases can be too verbose, though, and sometimes downright confusing if they’re
    poorly named. Use them sparingly to avoid naming collisions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 别名可能过于冗长，如果命名不当，有时甚至可能让人困惑。请谨慎使用，以避免命名冲突。
- en: 'You can nest packages in a process similar to creating an initial package.
    Create a directory with an `__init__.py` file, and put modules or packages inside:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在创建初始包的过程类似的方式中嵌套包。创建一个包含 `__init__.py` 文件的目录，并将模块或包放在里面：
- en: '![](../Images/f0040-01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0040-01.jpg)'
- en: In this example, all the math code is in the math package, and each subfield
    of mathematics has its own subpackage that contains modules. If you want to look
    at the code for calculating an integral, you can make a guess that it’s in math/calculus/integral.py.
    This aspect of packages—being able to navigate to where code is likely to live—becomes
    invaluable as a project grows in size.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有数学代码都在 math 包中，每个数学子领域都有自己的子包，其中包含模块。如果你想查看计算积分的代码，你可以猜测它位于 math/calculus/integral.py。包的这一特性——能够导航到代码可能存在的位置——随着项目规模的扩大变得非常有价值。
- en: 'Importing the integral module works like before, with additional prefixes to
    get to the module of interest:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 导入积分模块的方式与之前相同，但需要额外的前缀来访问感兴趣的模块：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that `from math import calculus.integral` won’t work; you can only import
    a full dotted path using `import ...` or a single name using `from ... import
    ...`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`from math import calculus.integral` 不会工作；你只能使用 `import ...` 或 `from ...
    import ...` 来导入完整的点分路径。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Separation of concerns is a major key to understandable code; many design concepts
    arise directly from this principle.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离是可理解代码的关键；许多设计概念直接源于这一原则。
- en: Functions extract named concepts from procedural code. Clarity and separation
    are the primary objectives of extraction; reuse is a secondary benefit.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数从过程代码中提取命名概念。清晰性和分离是提取的主要目标；重用是次要的好处。
- en: Classes group closely related behaviors and data together into an object.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类将紧密相关的行为和数据组合成一个对象。
- en: Modules group related classes, functions, and data while keeping independent
    concerns separate. Explicitly importing code from other modules makes it clear
    what’s being used where.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块将相关的类、函数和数据分组，同时保持独立关注点的分离。明确从其他模块导入代码可以使使用情况更加清晰。
- en: Packages help create a hierarchy of modules that helps with naming and code
    discovery.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包有助于创建模块层次结构，这有助于命名和代码发现。
- en: Chapter 3\. Abstraction and encapsulation
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章\. 抽象和封装
- en: '*This chapter covers*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding the value of abstraction in large systems
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象在大系统中的价值
- en: Encapsulating related code into classes
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相关代码封装到类中
- en: Using encapsulation, inheritance, and composition in Python
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中使用封装、继承和组合
- en: Recognizing programming styles in Python
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别 Python 中的编程风格
- en: You’ve already seen that organizing your code into functions, classes, and modules
    is a great way to separate *concerns*, but you can also use these techniques to
    separate *complexity* in your code. Because it’s difficult to remember every detail
    about your software at all times, in this chapter you’ll learn to use abstraction
    and encapsulation to create levels of granularity in your code so you can worry
    about the details only when you need to.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，将你的代码组织成函数、类和模块是一种很好的方法来分离*关注点*，但你也可以使用这些技术来分离代码中的*复杂性*。因为很难始终记住软件的所有细节，在本章中，你将学习使用抽象和封装来创建代码的粒度级别，这样你就可以只在需要时关注细节。
- en: 3.1\. What is abstraction?
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 什么是抽象？
- en: When you hear the word *abstract*, what do you think of? Usually a Jackson Pollock
    painting or a Calder sculpture runs through my mind. Abstract art is marked by
    a freedom from concrete form, often only suggestive of a specific subject. *Abstraction*,
    then, would be the process of taking something concrete and stripping it of specifics.
    When speaking about abstraction in software, this is exactly right!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到“抽象”这个词时，你想到的是什么？通常是一幅杰克逊·波洛克的作品或一个考尔德的雕塑会浮现在我的脑海中。抽象艺术的特点是摆脱具体形式，通常只暗示一个特定主题。因此，“抽象”就是将具体事物剥离其具体性的过程。在软件中谈论抽象时，这正是正确的！
- en: 3.1.1\. The “black box”
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. “黑盒”
- en: As you develop software, pieces of it will come to represent concepts in full.
    Once you’ve finished developing a particular function, for example, it can be
    used for its intended purpose over and over again without you having to think
    too hard about how it works. At this point, the function has become a *black box*.
    A black box is a calculation or behavior that “just works”—it doesn’t need to
    be opened up and examined each time you need it (see [figure 3.1](#ch03fig01)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你开发软件，其中的一些部分将代表完整的概念。例如，一旦你完成了一个特定函数的开发，它就可以反复用于其预期目的，而不需要你过多地思考它是如何工作的。在这个时候，该函数已经成为了一个*黑盒*。黑盒是一种“只需工作”的计算或行为——每次需要它时不需要打开和检查（见[figure
    3.1](#ch03fig01)）。
- en: Figure 3.1\. Treating working software as a black box
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 将工作软件视为黑盒
- en: '![](../Images/f0065-01_alt.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0065-01_alt.jpg)'
- en: 'Suppose you’re building a natural-language processing system that determines
    if a product review is positive, negative, or neutral. Such a system has many
    steps along the way, as shown in [figure 3.2](#ch03fig02):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个自然语言处理系统，该系统可以确定产品评论是正面、负面还是中性的。这样的系统在过程中有许多步骤，如图3.2（[figure 3.2](#ch03fig02)）所示：
- en: Break up the review into sentences.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将评论拆分成句子。
- en: Break each sentence into words or phrases, generally called *tokens*.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个句子拆分成单词或短语，通常称为*标记*。
- en: Simplify word variations to their root words, called *lemmatization*.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单词变体简化为其根词，称为*词元化*。
- en: Determine the grammatical structure of the sentence.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定句子的语法结构。
- en: Calculate the polarity of the content by comparing it to manually labeled training
    data.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过与手动标记的训练数据进行比较来计算内容的极性。
- en: Calculate the overall magnitude of polarity.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算极性的整体强度。
- en: Choose a final positive, negative, or neutral determination for the product
    review.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为产品评论选择最终的正面、负面或中性判断。
- en: Figure 3.2\. Determining whether a product review is positive, negative, or
    neutral
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 确定产品评论是正面、负面还是中性的
- en: '![](../Images/f0066-01_alt.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0066-01_alt.jpg)'
- en: Each step in the sentiment analysis workflow is composed of many lines of code.
    By rolling that code up into concepts like “break into sentences” and “determine
    grammatical structure,” the whole workflow becomes easier to follow than if you
    were trying to comprehend all the code at once. If someone wants to know the specifics
    of a particular step in the workflow, they can choose to take a deeper look. This
    idea of abstracting an implementation is useful for human comprehension, but it’s
    also something that can be formalized in code to produce more stable results.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 情感分析工作流程中的每一步都由许多行代码组成。通过将这些代码卷入“拆分成句子”和“确定语法结构”等概念，整个工作流程比试图一次性理解所有代码更容易理解。如果有人想了解工作流程中特定步骤的详细信息，他们可以选择深入了解。这种将实现抽象化的想法对于人类理解是有用的，但它也可以在代码中形式化，以产生更稳定的结果。
- en: In [chapter 2](../Text/kindle_split_012.html#ch02), you learned how to identify
    the concerns of your code and extract them into functions. Abstracting a behavior
    into a function allows you to freely change *how* that function calculates a result,
    as long as the inputs and return data type stay the same. This means if you find
    a bug or a faster or more accurate way of performing the calculation, you can
    swap that behavior in without other code needing to change as a result. This gives
    you flexibility as you iterate on software.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第2章](../Text/kindle_split_012.html#ch02) 中，你学习了如何识别代码的关注点并将它们提取到函数中。将行为抽象成函数允许你自由地更改该函数计算结果的方式，只要输入和返回数据类型保持不变。这意味着如果你发现了一个错误或更快速、更准确执行计算的方法，你可以替换该行为，而无需其他代码因此需要更改。这在你迭代软件时提供了灵活性。
- en: 3.1.2\. Abstraction is like an onion
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. 抽象就像洋葱
- en: You saw in [figure 3.2](#ch03fig02) that each step in a workflow generally represents
    some lower-level code. Some of those steps, though, such as determining the grammatical
    structure of a sentence, are quite involved. Complex code like this will often
    benefit from *layers* of abstraction; low-level utilities support small behaviors,
    which in turn support more involved behaviors. Because of this, writing and reading
    code in large systems is often like peeling an onion, revealing smaller, more
    tightly packed pieces of code underneath ([figure 3.3](#ch03fig03)).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [图3.2](#ch03fig02) 中看到，工作流程中的每一步通常代表一些低级代码。然而，其中一些步骤，比如确定句子的语法结构，相当复杂。这样的复杂代码通常会从
    *抽象层* 中受益；低级实用工具支持小的行为，而这些行为反过来又支持更复杂的行为。正因为如此，在大系统中编写和阅读代码常常像剥洋葱一样，一层层揭示出下面更小、更紧密的代码片段
    ([图3.3](#ch03fig03))。
- en: Figure 3.3\. Abstraction works in layers of complexity.
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 抽象在复杂性的层次上工作。
- en: '![](../Images/f0066-02_alt.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0066-02_alt.jpg)'
- en: Small, focused behaviors that get used again and again sit in the lower layers
    and need to change infrequently. The big concepts, business logic, and complex
    moving parts show up as you go further out; they change more frequently because
    of changing requirements, but they still make use of the smaller behaviors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用的小而专注的行为位于底层，需要很少改变。随着你向外扩展，大概念、业务逻辑和复杂的移动部件会出现；由于需求的变化，它们更频繁地改变，但它们仍然使用较小的行为。
- en: When you’re starting out, it’s common to write one long, procedural program
    that gets a job done. This works fine when prototyping, but it reveals its poor
    maintainability when someone needs to read all 100 lines of code to figure out
    where they need to make a change or fix a bug. Introducing abstraction with features
    of the language makes it easier to pinpoint the relevant code. In Python, features
    like functions, classes, and modules help abstract behavior. Let’s see how using
    functions in Python helps with the first two steps of the sentiment-analysis workflow.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始时，通常会写一个长程序，通过一系列步骤完成任务。这在进行原型设计时效果不错，但当有人需要阅读所有100行代码以确定他们需要在哪里进行更改或修复错误时，它就暴露了其维护性差的缺点。通过语言特性引入抽象可以使定位相关代码更容易。在Python中，函数、类和模块等特性有助于抽象行为。让我们看看使用Python中的函数如何帮助处理情感分析工作流程的前两个步骤。
- en: When working through the code in [listing 3.1](#ch03ex1), you might notice that
    it does some similar work twice—the work of splitting a string up by sentence
    and by individual words in each sentence is quite similar. Each step performs
    the same operation, with different inputs. This is usually an opportunity to factor
    a behavior into its own function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 [列表3.1](#ch03ex1) 中处理代码时，你可能会注意到它做了两次类似的工作——将字符串分割成句子和每个句子中的单个单词的工作相当相似。每个步骤执行相同的操作，但输入不同。这通常是一个将行为分解为其自身函数的机会。
- en: Listing 3.1\. A procedure for splitting a paragraph into sentences and tokens
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. 将段落分割成句子和标记的程序
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* The product review as a string**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 产品评论作为字符串**'
- en: '***2* Matches full sentences ending with a period**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 匹配以句号结尾的完整句子**'
- en: '***3* Finds all sentences in the review**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在评论中找到所有句子**'
- en: '***4* findall returns list of (sentence, white space) pairs**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* findall 返回 (句子，空白) 对的列表**'
- en: '***5* Matches single words**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 匹配单个单词**'
- en: '***6* For each sentence, gets all the words**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 对于每个句子，获取所有单词**'
- en: You can see that the work to find the `sentences` and `words` is similar, with
    the pattern to match against being the distinguishing feature. Some logistics
    also have to be taken care of, like dealing with the output of `findall`, that
    clutter up the code. At a quick glance, the intent of this code might not be obvious.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，找到`句子`和`单词`的工作是相似的，匹配的模式是其区分特征。还有一些后勤工作也需要处理，比如处理`findall`的输出，这些都会使代码变得杂乱。乍一看，这段代码的意图可能并不明显。
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In real natural-language processing, splitting sentences and words is difficult,
    so difficult, in fact, that the software to parse them generally uses *probabilistic
    modeling* to determine the result. Probabilistic modeling uses a large body of
    input testing data to determine the likely correctness of a particular result.
    The result might not always be the same! Natural languages are complex, and it
    shows when we try to make computers understand them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实的自然语言处理中，分割句子和单词是困难的，实际上非常困难，以至于解析它们的软件通常使用*概率模型*来确定结果。概率模型使用大量的输入测试数据来确定特定结果的可能正确性。结果可能并不总是相同的！自然语言是复杂的，当我们试图让计算机理解它们时，这一点就显现出来了。
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: How can abstraction help improve the sentence parsing? With a little help from
    Python functions, you can simplify this a bit. In the following listing, the pattern-matching
    is abstracted into a `get_matches_for_pattern` function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象如何帮助提高句子解析？借助Python函数的一点点帮助，你可以简化这一点。在下面的列表中，模式匹配被抽象成`get_matches_for_pattern`函数。
- en: Listing 3.2\. Refactored sentence parsing
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 重构句子解析
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* A new function to do the pattern-matching**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个用于模式匹配的新函数**'
- en: '***2* Now you can ask the function to do the hard work.**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 现在你可以让函数去做这项艰苦的工作。**'
- en: '***3* You can reuse the function whenever you need to.**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你可以在需要时重用这个函数。**'
- en: In the updated parsing code, it’s more clear that the review is being broken
    into pieces. With well-named variables and a clear, short `for` loop, the two-stage
    structure of the process is also clear. Someone looking at this code later will
    be able to read the main code, only digging into how `get_matches_for_pattern`
    works if they’re curious or want to change it. Abstraction has introduced clarity
    and code reuse into this program.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新的解析代码中，更清楚地表明了审查被分解成几个部分。通过命名良好的变量和清晰简洁的`for`循环，这个过程的两阶段结构也变得清晰。后来查看这段代码的人将能够阅读主要代码，只有在好奇或想要更改它时才会深入研究`get_matches_for_pattern`的工作。抽象引入了清晰性和代码重用。
- en: 3.1.3\. Abstraction is a simplifier
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3\. 抽象是一种简化器
- en: I want to emphasize that abstraction is useful for making code easier to understand;
    it achieves this by keeping the intricacies of some functionality hidden away
    until you want to know more. This is a technique used in writing technical documentation
    as well as designing the interfaces used to interact with code libraries.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调的是，抽象有助于使代码更容易理解；它通过将某些功能的复杂性隐藏起来直到你想要了解更多来实现这一点。这是一种在编写技术文档以及设计用于与代码库交互的接口时使用的技巧。
- en: Understanding code is much like understanding a passage from a book. A passage
    has many sentences, which are like the lines of code. In any given sentence, you
    may find a word with which you’re unfamiliar. In software, this might be a line
    of code that does something new or different than you’re used to. When you find
    such words in books, you might look them up in the dictionary. The only equivalent
    when dealing with lengthy procedures is diligent code commenting.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代码就像理解一本书中的一段文字。一段文字有许多句子，这些句子就像代码的行。在任何给定的句子中，你可能会遇到一个你不熟悉的单词。在软件中，这可能是执行新或不同操作的一行代码。当你在这类书籍中找到这些单词时，你可能会在字典中查找它们。在处理长时间程序时，唯一的等效方法是勤奋地注释代码。
- en: One way you can tackle this is by abstracting related bits of your code into
    functions that clearly state what they do. You saw this in [listings 3.1](#ch03ex1)
    and [3.2](#ch03ex2). The function `get_matches_for_pattern` gets the matches for
    a given pattern from a string. Before it was updated, though, the intent of that
    code was not so clear.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是将相关的代码片段抽象成函数，这些函数清楚地说明了它们的功能。你在[列表 3.1](#ch03ex1)和[3.2](#ch03ex2)中看到了这一点。函数`get_matches_for_pattern`从字符串中获取给定模式的匹配项。然而，在更新之前，这段代码的意图并不那么清晰。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Python, you can add additional context to a module, class, method, or function
    using *docstrings*. Docstrings are special lines near the beginning of these constructs
    that can tell the reader (as well as some automated software) how the code behaves.
    You can read more about docstrings on Wikipedia ([https://en.wikipedia.org/wiki/Docstring](https://en.wikipedia.org/wiki/Docstring)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以使用*文档字符串*为模块、类、方法或函数添加额外的上下文。文档字符串是这些结构开头附近的一些特殊行，可以告诉读者（以及一些自动化软件）代码的行为。你可以在维基百科上了解更多关于文档字符串的信息（[https://en.wikipedia.org/wiki/Docstring](https://en.wikipedia.org/wiki/Docstring)）。
- en: '|  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Abstraction reduces *cognitive load*, the amount of effort required by your
    brain to think about or remember something, so that you can spend your time making
    sure your software does what it needs to do!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象减少了*认知负荷*，即你的大脑思考或记住某件事所需的努力，这样你就可以花时间确保你的软件做它需要做的事情！
- en: 3.1.4\. Decomposition enables abstraction
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.4\. 分解实现抽象
- en: 'As I mentioned in [chapter 2](../Text/kindle_split_012.html#ch02), decomposition
    is the separation of something into its constituent components. In software, that
    means doing the kinds of things you saw earlier: separating sections of code that
    do a single thing into functions. In fact, it also relates to the discussion on
    design and workflow from [chapter 1](../Text/kindle_split_010.html#ch01). The
    common theme here is that software written in small parts that work in tandem
    often leads to more maintainable code than software written in one large blob.
    You’ve seen that this can help reduce cognitive load and make code easier to understand.
    [Figure 3.4](#ch03fig04) shows how a huge system can be decomposed all the way
    down to achievable tasks.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第2章](../Text/kindle_split_012.html#ch02)中提到的，分解是将某物分解为其组成部分的过程。在软件中，这意味着做你之前看到的那种事情：将执行单一功能的代码部分分离成函数。实际上，这也与[第1章](../Text/kindle_split_010.html#ch01)中关于设计和工作流程的讨论有关。这里的共同主题是，用小部分协同工作的软件通常比用一大块写出的软件更容易维护。你已经看到这可以有助于减少认知负荷并使代码更容易理解。[图3.4](#ch03fig04)展示了如何将一个庞大的系统分解成可实现的任务。
- en: Figure 3.4\. Decomposition into granular components eases understanding.
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. 将分解成细粒度组件有助于理解。
- en: '![](../Images/f0069-01_alt.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0069-01_alt.jpg)'
- en: See how the pieces get smaller from left to right? Trying to build something
    big in one piece like the left side is like packing your whole house in a shipping
    container. Building things like the right side is like organizing each room of
    your house into small boxes you can carry. Decomposition helps you handle big
    ideas in small increments.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些块是如何从左到右变得越来越小的吗？试图一次性用一块大东西（如左侧所示）来构建一些东西就像把你的整个房子装进一个货柜里。像右侧那样构建东西就像把你的房子的每个房间组织成你可以携带的小盒子。分解帮助你以小步骤处理大概念。
- en: 3.2\. Encapsulation
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 封装
- en: '*Encapsulation* is the basis for object-oriented programming. It takes decomposition
    one step further: whereas decomposition groups related code into functions, encapsulation
    groups related functions and data into a larger construct. This construct acts
    as a barrier (or capsule) to the outside world. What constructs are available
    in Python?'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装*是面向对象编程的基础。它将分解推进了一步：而分解将相关的代码组合成函数，封装将相关的函数和数据组合成更大的结构。这个结构充当对外界的屏障（或胶囊）。Python中有哪些结构可用？'
- en: 3.2.1\. Encapsulation constructs in Python
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. Python中的封装结构
- en: Most often, encapsulation in Python is done with a class. In classes, functions
    become *methods*; methods are similar to functions, but they are contained in
    a class and often receive an input that is either an instance of the class or
    the class itself.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Python中的封装是用类来完成的。在类中，函数变成*方法*；方法类似于函数，但它们包含在类中，并且通常接收一个输入，这个输入要么是类的实例，要么是类本身。
- en: In Python, *modules* are also a form of encapsulation. Modules are even higher-level
    than classes; they group multiple related classes and functions together. For
    example, a module dealing with HTTP interactions could contain classes for requests
    and responses, as well as utility functions for parsing URLs. Most *.py files
    you encounter would be considered modules.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*模块*也是一种封装形式。模块甚至比类更高层次；它们将多个相关的类和函数组合在一起。例如，处理HTTP交互的模块可以包含用于请求和响应的类，以及用于解析URL的实用函数。你遇到的绝大多数*.py文件都可以被认为是模块。
- en: The largest encapsulation available in Python is a *package*. Packages encapsulate
    related modules into a directory structure. Packages are often distributed on
    the Python Package Index (PyPI) for others to install and reuse.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中可用的最大封装是*包*。包将相关的模块封装到目录结构中。包通常在 Python 包索引（PyPI）上分发，供他人安装和重用。
- en: Take a look at [figure 3.5](#ch03fig05) and notice that the pieces of the shopping
    cart are decomposed into distinct activities. They’re also isolated; they don’t
    depend on each other to perform a task. Any cooperation between activities is
    coordinated at the higher shopping-cart level. The shopping cart itself is isolated
    inside the e-commerce application; any information it needs will be passed into
    it. You can think of encapsulated code as having a castle wall around it, where
    the functions and methods are the drawbridge for getting in or out.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 3.5](#ch03fig05)，注意购物车片段被分解成不同的活动。它们也是独立的；它们在执行任务时互不依赖。活动之间的任何合作都是在更高的购物车级别上协调的。购物车本身在电子商务应用内部是独立的；它所需的信息将被传递给它。你可以将封装的代码想象成一个有城堡墙围绕的地方，其中函数和方法是进入或离开的吊桥。
- en: Figure 3.5\. By decomposing a system into small parts, you can encapsulate behaviors
    and data into isolated pieces. Encapsulation encourages you to reduce the responsibilities
    of any given portion of code, helping you avoid complicated dependencies.
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5\. 通过将系统分解成小部分，你可以将行为和数据封装成独立的片段。封装鼓励你减少任何给定代码部分的职责，帮助你避免复杂的依赖。
- en: '![](../Images/f0070-01.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0070-01.jpg)'
- en: Which of these pieces do you think would be a
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这些片段中的哪一个会是
- en: Method?
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法？
- en: Class?
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类？
- en: Module?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块？
- en: Package?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包？
- en: The three smallest pieces—calculating tax, calculating shipping, and subtracting
    a discount—would likely be methods inside a class that represents the shopping
    cart. The e-commerce system seems like it could have enough functionality to be
    a package because the shopping cart is just one part of that system. Different
    modules within the package could arise depending on how closely related they are
    to each other. But how do they work together if they’re each surrounded by a castle
    wall?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 三个最小的片段——计算税费、计算运费和减去折扣——很可能是代表购物车的类中的方法。电子商务系统似乎有足够的功能可以成为一个包，因为购物车只是该系统的一部分。包内的不同模块可以根据它们之间的相关性紧密程度而出现。但它们如果各自被城堡墙包围，它们是如何一起工作的呢？
- en: 3.2.2\. Expectations of privacy in Python
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. Python 中的隐私期望
- en: Many languages formalize the “castle wall” aspect of encapsulation by introducing
    the concept of *privacy*. Classes can have *private* methods and data that can’t
    be accessed by anyone but instances of the class. This is in contrast to *public*
    methods and data, which are often referred to as the *interface* of the class
    because this is how other classes interface with it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言通过引入*隐私*的概念来形式化封装的“城堡墙”方面。类可以有*私有*的方法和数据，这些方法和数据只能由类的实例访问。这与*公共*的方法和数据形成对比，公共方法和数据通常被称为类的*接口*，因为这是其他类与之交互的方式。
- en: Python has no true support for private methods or data. Instead, it follows
    a philosophy of trusting developers to do the right thing. A common convention
    does help in this arena, though. Methods and variables intended for use within
    a class but not from outside the class are often prefixed with an underscore.
    This provides a hint to future developers that a particular method or variable
    isn’t intended as part of the public interface of the class. Third-party packages
    often state loudly in their documentation that such methods are likely to change
    from version to version and should not be explicitly relied on.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有真正的私有方法或数据支持。相反，它遵循一个信任开发者会做正确事情的理念。尽管如此，在这个领域，一个常见的约定确实有所帮助。旨在类内部使用但不在类外部使用的方法和变量通常以下划线开头。这为未来的开发者提供了一个提示，即特定的方法或变量不是作为类公共接口的一部分。第三方包通常在其文档中明确指出，这些方法可能会随着版本的更新而改变，不应被明确依赖。
- en: In [chapter 2](../Text/kindle_split_012.html#ch02), you learned about coupling
    between classes, and that loose coupling is the desired state. The more methods
    and data a particular class depends on from another class, the more coupled they
    become. This is magnified when a class depends on the *internals* of another class
    because that means most of the class can’t be improved in isolation without the
    risk of breaking other code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第2章](../Text/kindle_split_012.html#ch02) 中，你学习了类之间的耦合，以及松耦合是期望的状态。一个特定的类从另一个类依赖的方法和数据越多，它们之间的耦合就越大。当一个类依赖于另一个类的
    *内部* 时，这种情况会加剧，因为这意味着大多数类不能在孤立的情况下进行改进，否则有破坏其他代码的风险。
- en: Abstraction and encapsulation work together by grouping related functionality
    together and hiding the parts of it that don’t matter to anyone else. This is
    sometimes called “information hiding,” and it allows the internals of a class
    (or system in general) to change rapidly without other code having to change at
    the same rate.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象和封装通过将相关的功能组合在一起并隐藏对其他人无关的部分来共同工作。这有时被称为“信息隐藏”，它允许类的内部（或系统总体）快速变化，而无需其他代码以相同的速度变化。
- en: 3.3\. Try it out
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 尝试一下
- en: 'I’d like you to get some practice with encapsulation now. Suppose you’re writing
    code to greet new customers to an online store. The greeting makes customers feel
    welcome and offers them an incentive to stick around. Write a greeter module that
    contains a single class, `Greeter`, that has three methods:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让你现在练习一下封装。假设你正在编写代码来问候新顾客进入在线商店。问候语能让顾客感到受欢迎，并给他们留下继续停留的动机。编写一个包含单个类 `Greeter`
    的问候模块，该类有三个方法：
- en: '`_day(self)`—Returns the current day (Sunday, for example)'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_day(self)`—返回当前日期（例如，星期日）'
- en: '`_part_of_day(self)`—Returns “morning” if the current hour is before 12 P.M.,
    “afternoon” if the current hour is 12 P.M. or later but before 5 P.M., and “evening”
    from 5 P.M. onward'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_part_of_day(self)`—如果当前小时在中午12点之前，则返回“morning”，如果当前小时是中午12点或之后但不到下午5点，则返回“afternoon”，从下午5点开始返回“evening”'
- en: '`greet(self, store)`—Given the name of a store, `store`, and the output of
    the previous two methods, prints a message of the form'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greet(self, store)`—给定商店名称 `store` 和前两个方法的输出，打印一个类似以下格式的消息'
- en: '[PRE34]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `_day` and `_part_of_day` methods can be signified as private (named with
    a leading underscore) because the only functionality the `Greeter` class needs
    to expose is `greet`. This helps encapsulate the internals of the `Greeter` class
    so that its only public concern is performing the greeting itself.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`_day` 和 `_part_of_day` 方法可以表示为私有（以一个下划线开头命名），因为 `Greeter` 类唯一需要公开的功能是 `greet`。这有助于封装
    `Greeter` 类的内部结构，使其唯一公开的关注点是执行问候本身。'
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use `datetime.datetime.now()` to get the current datetime object, using
    the `.hour` attribute for the time of day and `.strftime('%A')` to get the current
    day of the week.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `datetime.datetime.now()` 获取当前的日期时间对象，使用 `.hour` 属性获取一天中的时间，使用 `.strftime('%A')`
    获取当前星期。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: How did it go? Your solution should look something like the following example.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如何？你的解决方案应该类似于以下示例。
- en: Listing 3.3\. A module to generate greetings for an online store
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 为在线商店生成问候信息的模块
- en: '[PRE35]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Formats the datetime to get the current day name**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 格式化日期时间以获取当前星期名称**'
- en: '***2* Determines the part of day based on the current hour**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 根据当前小时确定一天中的时段**'
- en: '***3* Prints the greeting using all the calculated bits**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用所有计算出的位打印问候语**'
- en: The `Greeter` prints the desired message, so everything’s great, right? If you
    look carefully, though, the `Greeter` knows how to do too much. The `Greeter`
    should only greet people; it shouldn’t be responsible for determining the day
    of the week and what part of the day it is! The encapsulation isn’t ideal. What
    are you to do?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greeter` 打印所需的问候信息，所以一切都很顺利，对吧？不过，如果你仔细观察，会发现 `Greeter` 知道如何做得太多。`Greeter`
    应该只负责问候人们；它不应该负责确定星期几以及现在是白天哪个时段！封装并不理想。你该怎么办呢？'
- en: 3.3.1\. Refactoring
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 重构
- en: Encapsulation and abstraction are often iterative processes. As you write more
    code, constructs that made sense before may seem awkward or forced. I assure you
    that this is totally natural. The feeling that your code is working against you
    might mean it’s time to *refactor*. Refactoring code means updating how it’s structured
    to serve your needs more effectively. When you refactor, you will often need to
    change the ways you represent behaviors and concepts. Moving data and implementations
    around is a necessary part of improving the code. It’s kind of like rearranging
    the living room every few years to fit your current mood.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 封装和抽象通常是迭代过程。随着你编写更多的代码，之前有意义的结构可能会显得笨拙或强制。我向你保证，这是完全自然的。如果你觉得代码在跟你作对，这可能意味着是时候进行*重构*了。重构代码意味着更新其结构，使其更有效地满足你的需求。当你重构时，你通常会需要改变你表示行为和概念的方式。移动数据和实现是改进代码的必要部分。这有点像每隔几年就重新布置客厅，以适应你当前的心情。
- en: Refactor your `Greeter` code now by moving the methods for getting information
    about the day and time out of the `Greeter` class and making them standalone functions
    within the module.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重构你的`Greeter`代码，将获取关于日期和时间的函数从`Greeter`类中移出，并在模块内创建它们作为独立的函数。
- en: 'The functions never used the `self` argument when they were methods, so they’ll
    look pretty much the same but without that argument:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些函数作为方法时，它们从未使用过`self`参数，所以它们看起来几乎一样，只是没有这个参数：
- en: '[PRE36]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Greeter` class can then call these functions by referencing them directly
    instead of with the `self.` prefix:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`Greeter`类可以通过直接引用这些函数来调用它们，而不是使用`self.`前缀：
- en: '[PRE37]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now the `Greeter` only knows the information it needs to make a greeting, without
    worrying about the details of how to get that information. What’s also nice is
    that the `day` and `part_of_day` functions can be used elsewhere if needed, without
    having to reference the `Greeter` class. That’s two benefits in one!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`Greeter`类只知道它需要制作问候语所需的信息，无需担心获取这些信息的细节。另外，如果需要的话，`day`和`part_of_day`函数也可以在其他地方使用，而无需引用`Greeter`类。这真是一举两得！
- en: Eventually, you might develop more datetime-related features, at which point
    it could make sense to refactor all those features into their own module or class.
    I often wait to do this until several functions or classes present a clear relationship,
    but some developers like to do this from the start to be strict about keeping
    things separate.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可能会开发更多与日期时间相关的功能，这时将所有这些功能重构到它们自己的模块或类中可能是有意义的。我通常等到几个函数或类呈现清晰的关联关系时才这样做，但有些开发者喜欢从一开始就严格保持事物分离。
- en: 3.4\. Programming styles are an abstraction too
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 编程风格也是一种抽象
- en: A number of programming styles (or *paradigms*) have become popular over the
    years, often sprouting out of a particular business domain or user base. Python
    supports several styles, and they are abstractions in their own ways. Remember
    that abstraction is the act of storing concepts away so they can be digested easily.
    Each programming style stores information and behavior a bit differently. No one
    style is “right,” but some are better than others at tackling specific problems.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年中，许多编程风格（或*范式*）已经变得流行，通常是从特定的商业领域或用户群体中产生的。Python支持几种风格，它们以自己的方式是抽象的。记住，抽象是将概念存储起来以便容易消化的行为。每种编程风格以不同的方式存储信息和行为。没有一种风格是“正确”的，但有些在解决特定问题时比其他风格更好。
- en: 3.4.1\. Procedural programming
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1. 过程式编程
- en: I’ve discussed and shown some examples of *procedural programming* in this and
    previous chapters. Procedural software prefers to operate using *procedure calls*,
    which we tend to call “functions.” These functions aren’t encapsulated into classes,
    so they often rely only on their inputs and occasionally on some global state.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章和前几章中讨论并展示了一些*过程式编程*的例子。过程式软件更喜欢使用*过程调用*来操作，我们倾向于称之为“函数”。这些函数没有被封装到类中，因此它们通常只依赖于它们的输入，偶尔也依赖于一些全局状态。
- en: '[PRE38]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* A standalone function that relies only on NAMES**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 仅依赖于名称的独立函数**'
- en: If you’re fairly new to programming, this style will likely feel familiar because
    it’s a common jumping-off place. Going from one long procedure to a procedure
    that calls a few functions tends to feel natural, so it’s a good approach to teach
    first. The benefits of procedural programming strongly overlap with those discussed
    in [section 3.1.4](#ch03lev2sec4) because procedural programming focuses heavily
    on functions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你相当新于编程，这种风格可能会让你感到熟悉，因为它是一个常见的起点。从一个长过程到调用几个函数的过程感觉更自然，因此这是一个很好的教学方法。过程式编程的优点与在
    [3.1.4 节](#ch03lev2sec4) 中讨论的优点有很大重叠，因为过程式编程非常重视函数。
- en: 3.4.2\. Functional programming
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 函数式编程
- en: Functional programming *sounds* like it would be the same as procedural programming—*function*
    is right there in the name! But although it’s true that functional programming
    relies heavily on functions as the form of abstraction, the mental model is quite
    different.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程 *听起来* 会和过程式编程一样——*函数* 就在名字中！但尽管函数式编程确实非常依赖函数作为抽象的形式，但思维模型却相当不同。
- en: 'Functional languages require you to think about programs as compositions of
    functions. `for` loops are replaced by functions that operate on lists, for example.
    In Python, you might write the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言要求你将程序视为函数的组合。例如，`for` 循环被操作列表的函数所取代。在 Python 中，你可能会写成以下这样：
- en: '[PRE39]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In a functional language, you might write it like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，你可能写成这样：
- en: '[PRE40]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In functional programming, functions sometimes accept other functions as arguments
    or return them as results. This is seen in the previous snippet; `map` accepts
    an anonymous function that takes one argument and multiplies it by itself.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数有时接受其他函数作为参数或作为结果返回。这在前面的代码片段中可以看到；`map` 接受一个接受一个参数并将其自身相乘的匿名函数。
- en: Python has a number of functional programming tools; many of these are available
    using built-in keywords, and others are imported from built-in modules like functools
    and itertools. Though Python *supports* functional programming, it isn’t often
    a preferred approach. Some common features of functional languages, like the `reduce`
    function, have been moved to functools.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多函数式编程工具；其中许多可以通过内置关键字使用，其他则来自内置模块，如 functools 和 itertools。尽管 Python
    *支持* 函数式编程，但这并不是首选的方法。函数式语言的一些常见特性，如 `reduce` 函数，已经被移动到 functools。
- en: 'Many feel that the imperative Python way of performing some of these operations
    is more clear. Using functional Python features would look like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为，使用命令式 Python 方式执行这些操作更清晰。使用函数式 Python 功能的样子如下：
- en: '[PRE41]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preference in Python would be the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，首选的做法如下：
- en: '[PRE42]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Try each approach and print the variables afterward. You’ll see that they produce
    identical results; it’s up to you to use the style you find most understandable.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试每种方法，并在之后打印变量。你会发现它们产生相同的结果；这取决于你使用哪种你认为是最容易理解的风格。
- en: 'One functional feature of Python I enjoy is `functools.partial`. This function
    allows you to create a new function from an existing function with some of the
    original function’s arguments set. This is sometimes clearer than writing a new
    function that calls the original function, especially in cases where a general-use
    function behaves like a more specifically named function. In the case of raising
    numbers to a power, `x` to the power of 2 is commonly called the *square* of `x`,
    and `x` to the power of 3 is commonly called the *cube* of `x`. You can see how
    this works in Python with the `partial` helper:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢的 Python 函数式特性之一是 `functools.partial`。这个函数允许你从一个现有的函数中创建一个新的函数，并设置一些原始函数的参数。这有时比编写一个调用原始函数的新函数更清晰，尤其是在通用函数表现得像具有特定名称的函数的情况下。在将数字提高到幂的情况下，`x`
    的平方通常称为 `x` 的 *平方*，而 `x` 的立方通常称为 `x` 的 *立方*。你可以在 Python 中使用 `partial` 辅助函数看到这是如何工作的：
- en: '[PRE43]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* A new function, square, that acts like pow(x, power=2)**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个新的函数，square，其行为类似于 pow(x, power=2)**'
- en: '***2* A new function, cube, that acts like pow(x, power=3)**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个新的函数，cube，其行为类似于 pow(x, power=3)**'
- en: Using familiar names for behaviors can help a great deal for those reading your
    code later down the line.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用熟悉的名字来表示行为对于那些稍后阅读你的代码的人来说非常有帮助。
- en: Functional programming used carefully can offer a number of performance benefits
    compared to procedural programming, making it useful in computationally expensive
    areas like mathematics and data simulation.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程如果使用得当，与过程式编程相比可以提供许多性能优势，使其在数学和数据模拟等计算密集型领域非常有用。
- en: 3.4.3\. Declarative programming
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3\. 声明式编程
- en: '*Declarative programming* focuses on declaring the parameters of a task without
    specifying how to accomplish it. The details of accomplishing the task are mostly
    or fully abstracted from the developer. This is useful when you need to repeat
    a highly parametric task with only slight variations to the parameters. Often
    this style of programming is realized via *domain-specific languages* (DSLs).
    DSLs are languages (or language-like markup) that are highly specialized for a
    specific set of tasks. HTML is one such example; developers can describe the structure
    of the page they want to create without saying anything about how a browser should
    convert a `<table>` to lines and characters on a screen. Python, on the other
    hand, is a *general-purpose language* that can be used for many purposes and requires
    direction from a developer.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明式编程*关注于声明任务的参数，而不指定如何完成它。完成任务的具体细节大部分或全部从开发者那里抽象出来。当你需要重复执行一个高度参数化的任务，而参数只有细微变化时，这很有用。通常这种编程风格是通过*领域特定语言*（DSLs）实现的。DSLs是针对特定任务集高度专业化的语言（或类似语言的标记）。HTML就是一个这样的例子；开发者可以描述他们想要创建的页面结构，而不必说明浏览器应该如何将`<table>`转换为屏幕上的行和字符。另一方面，Python是一种*通用语言*，可用于许多目的，并需要开发者的指导。'
- en: Consider exploring declarative programming when your software lets users do
    something highly repetitive, like translating code to another system (SQL, HTML,
    and so on) or creating multiple similar objects for repeated use.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的软件允许用户执行高度重复的任务时，例如将代码翻译到另一个系统（SQL、HTML等）或创建多个类似对象以供重复使用时，可以考虑探索声明式编程。
- en: 'A widely used example of declarative programming in Python is the plotly package.
    Plotly lets you create graphs from data by describing the type of graph you’d
    like. An example from the plotly documentation ([https://plot.ly/python/](https://plot.ly/python/))
    looks like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Python中声明式编程的一个广泛应用的例子是plotly包。Plotly允许你通过描述你想要的图表类型来创建图表。来自plotly文档（[https://plot.ly/python/](https://plot.ly/python/)）的一个例子如下：
- en: '[PRE44]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Declares the intent to build a scatter plot**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明构建散点图的意图**'
- en: '***2* Declares the shape of the x-axis data**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明x轴数据的形状**'
- en: '***3* Declares the shape of the y-axis data; easy to compare to x**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明y轴数据的形状；易于与x轴比较**'
- en: '***4* Declares the line marker appearance**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明线条标记的外观**'
- en: '***5* Declares that markers and lines will be used in the plot**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 声明在图中将使用标记和线条**'
- en: '***6* Declares the tooltip text for each marker**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 声明每个标记的工具提示文本**'
- en: This sets the data for the plot, as well as the visual characteristics. Each
    desired outcome is *declared* instead of being added procedurally.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了图表的数据以及视觉特性。每个期望的结果都是*声明*的，而不是通过程序性添加。
- en: 'For comparison, imagine a procedural approach. Instead of supplying several
    pieces of configuration data to a single function or class, you would instead
    perform each configuration step as an independent line of a longer procedure:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，想象一个程序性的方法。你不会向单个函数或类提供多个配置数据片段，而是将每个配置步骤作为更长过程的一个独立行来执行：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Each piece of information is set explicitly with methods.**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每条信息都通过方法显式设置。**'
- en: Declarative style can provide a more succinct interface when a lot of configuration
    is to be done by the user.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户需要执行大量配置时，声明式风格可以提供一个更简洁的接口。
- en: 3.5\. Typing, inheritance, and polymorphism
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 类型、继承和多态
- en: When I talk about *typing* here, I don’t mean typing on a keyboard. A language’s
    typing, or type system, is how it chooses to manage data types of variables. Some
    languages are compiled and check data types at compilation time. Some check types
    at runtime. Some languages infer the data type of `x = 3` to be an integer, whereas
    others require `int x = 3` explicitly.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当我这里提到*类型*时，我不是指键盘上的输入。一种语言的类型，或类型系统，是它选择如何管理变量数据类型的方式。有些语言在编译时检查数据类型。有些在运行时检查。有些语言将`x
    = 3`的数据类型推断为整数，而有些则要求显式地声明`int x = 3`。
- en: Python is a *dynamically typed* language, meaning that it determines its data
    types at runtime. It also uses a system called *duck typing*, whose name comes
    from the idiom, “If it walks like a duck and it quacks like a duck, then it must
    be a duck.” Whereas many languages will fail to compile your program if it references
    an unknown method on a class instance, Python will always attempt to make the
    method call during execution, raising an `AttributeError` if the method doesn’t
    exist on the instance’s class. Through this mechanism, Python can achieve a degree
    of polymorphism, which is a programming language feature where objects of different
    types provide specialized behavior via a consistent method name.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种*动态类型*语言，这意味着它在运行时确定其数据类型。它还使用一种称为*鸭子类型*的系统，其名称来源于习语，“如果它像鸭子走路，如果它像鸭子嘎嘎叫，那么它一定是一只鸭子。”与许多语言会在程序引用类实例上的未知方法时无法编译不同，Python会在执行期间始终尝试调用该方法，如果实例的类上不存在该方法，则会引发一个`AttributeError`。通过这种机制，Python可以实现一定程度的多态性，这是一种编程语言特性，其中不同类型的对象通过一致的方法名提供专门的行为。
- en: At the advent of object-oriented programming, there was a race to model full
    systems as cascades of inherited classes. `ConsolePrinter` inherited from `Printer`,
    which inherited from `Buffer`, which inherited from `BytesHandler`, and so on.
    Some of these hierarchies made sense, but many resulted in rigid code that was
    difficult to update. Trying to make one change could lead to a massive ripple
    of changes all the way up or down the tree.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程的兴起时期，有一个竞赛是尝试将完整的系统建模为继承类层的级联。`ConsolePrinter`继承自`Printer`，`Printer`继承自`Buffer`，`Buffer`继承自`BytesHandler`，依此类推。其中一些层次结构是有意义的，但许多导致了难以更新的刚性代码。试图进行一个更改可能会导致整个树形结构从上到下或从下到上产生巨大的连锁反应。
- en: Today, the preference has shifted to *composing* behaviors into an object. *Composition*
    is the converse to decomposition; pieces of functionality are brought together
    to realize a complete concept. [Figure 3.6](#ch03fig06) contrasts a more rigid
    inheritance structure with one where objects are composed of many traits. A dog
    is a quadruped, a mammal, and a canine. With inheritance, you would be forced
    to create a hierarchy from these. All canines are mammals, so that seems fine,
    but not all mammals are quadrupeds. Composition frees you from the limitations
    of a hierarchy while still providing the concept of relatedness between two things.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，偏好已经转向将行为*组合*到对象中。*组合*是分解的逆过程；将功能片段组合在一起以实现一个完整的概念。[图3.6](#ch03fig06)对比了更严格的继承结构与由许多特性组成的对象结构。狗是一种四足动物，是一种哺乳动物，也是一种犬科动物。使用继承，你会被迫从这些类别中创建一个层次结构。所有犬科动物都是哺乳动物，这似乎是合理的，但并非所有哺乳动物都是四足动物。组合使你摆脱了层次结构的限制，同时仍然提供了两个事物之间相关性的概念。
- en: Figure 3.6\. Inheritance versus composition
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6\. 继承与组合
- en: '![](../Images/f0078-01_alt.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0078-01_alt.jpg)'
- en: Composition is often done through a language feature called an *interface*.
    Interfaces are formal definitions of methods and data that a particular class
    must implement. A class can implement multiple interfaces to broadcast that it
    has the union of those interfaces’ behaviors.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 组合通常是通过一种称为*接口*的语言特性来完成的。接口是对特定类必须实现的方法和数据的形式定义。一个类可以实现多个接口，以表明它具有这些接口行为的并集。
- en: Python lacks interfaces. Oh no! How can you avoid a deep inheritance hierarchy?
    Fortunately, Python makes this possible through the duck typing system as well
    as *multiple inheritance*. Whereas many statically typed languages allow a class
    to inherit from only one other class, Python can support inheritance from an arbitrary
    number of classes. Something like an interface can be built using this mechanism,
    and in Python it’s often referred to as a *mixin*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Python缺少接口。哦，不！如何避免深层继承层次结构？幸运的是，Python通过鸭子类型系统和*多重继承*实现了这一点。与许多静态类型语言只允许一个类从另一个类继承不同，Python可以支持从任意数量的类继承。可以使用这种机制构建类似于接口的东西，在Python中通常被称为*mixin*。
- en: Suppose you want to create a model for a dog that can speak and roll over. You
    know you’ll eventually want to model other animals that can also do tricks, so
    to make these behaviors into something like an interface, you can name them with
    a `Mixin` suffix to be clear about your intent. With those behavior mixins in
    place, you’ll be able to make a `Dog` class that can `speak` and `roll_over`,
    as shown in the following listing, with the freedom to let your future animals
    `speak` or `roll_over` using the same approach.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个可以说话和打滚的狗的模型。你知道你最终会想要为其他也能做特技的动物建模，所以为了将这些行为变成类似接口的东西，你可以用 `Mixin`
    后缀来明确你的意图。有了这些行为混入，你将能够创建一个 `Dog` 类，它可以 `speak` 和 `roll_over`，如下所示，同时有自由让未来的动物使用相同的方法
    `speak` 或 `roll_over`。
- en: Listing 3.4\. Multiple inheritance providing interface-like behavior
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. 多重继承提供类似接口的行为
- en: '[PRE46]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Speaking behavior is encapsulated in SpeakMixin to show it’s composable.**'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 说话行为被封装在 SpeakMixin 中以展示其可组合性。**'
- en: '***2* The roll-over behavior in RollOverMixin is composable too.**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* RollOverMixin 中的打滚行为也是可组合的。**'
- en: '***3* Your Dog can speak, roll_over, and whatever else you teach it.**'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你的狗可以说话，打滚，以及你教给它的任何其他东西。**'
- en: 'Now that `Dog` has inherited from some mixins, you can check that your dog
    knows a couple of tricks:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Dog` 已经从一些混入中继承，你可以检查你的狗是否知道一些特技：
- en: '[PRE47]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see this output:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE48]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The fact that the dog knows English is suspect, but otherwise this checks out.
    We’ll take a deeper dive into inheritance and some other related concepts in [chapters
    7](../Text/kindle_split_018.html#ch07) and [8](../Text/kindle_split_019.html#ch08),
    so sit tight!
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 狗知道英语的事实令人怀疑，但除此之外，一切正常。我们将在第 7 章 [chapters 7](../Text/kindle_split_018.html#ch07)
    和第 8 章 [8](../Text/kindle_split_019.html#ch08) 中更深入地探讨继承和一些相关概念，所以请耐心等待！
- en: 3.6\. Recognizing the wrong abstraction
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 识别错误抽象
- en: Almost as useful as applying abstraction to new code is recognizing when abstractions
    in existing code aren’t working. This could be because new code has proven that
    the abstraction doesn’t fit all use cases, or it could be that you see a way to
    make the code clearer with a different paradigm. Whatever the case, taking the
    time to care for the code is a task others will appreciate, even if they don’t
    realize it explicitly.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 将抽象应用于新代码和识别现有代码中的抽象不工作几乎同样有用。这可能是因为新代码已经证明该抽象不适合所有用例，或者你可能看到一种用不同范式使代码更清晰的方法。无论哪种情况，花时间关心代码是一项他人会感激的任务，即使他们没有明确意识到这一点。
- en: 3.6.1\. Square pegs in round holes
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1\. 方块插在圆孔里
- en: As I’ve said, abstraction should be leveraged to make sure things are clearer
    and easier. If an abstraction causes you to bend over backward just to make something
    work, consider updating it to remove the friction or replace it with a new approach
    altogether. I’ve gotten pretty far into new code trying to make it work with what
    was in place, only to realize it would be easier to change the environment than
    adapt to it. The trade-offs here are time and effort, both in rewriting the code
    and making sure it still works. That up-front time you spend might save everyone
    time in the long run, though.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，抽象应该被利用来确保事情更清晰、更容易。如果一个抽象让你不得不弯腰驼背才能让某件事工作，考虑更新它以消除摩擦或完全用新方法替换它。我试图用现有的东西使新代码工作，结果发现改变环境比适应它更容易。这里的权衡是时间和精力，包括重写代码和确保它仍然工作。然而，你前期投入的时间可能会在长远上节省大家的时间。
- en: If the interface to a third-party package causes friction, and you’re not in
    a position to spend time or effort updating their code, you can always consider
    creating an abstraction around that interface for your own code to use. This is
    often called an *adapter* in software, and I liken it to using one of those airport
    travel plugs in another country. You certainly can’t change the electrical plugs
    in France (without someone getting angry, anyway) and you don’t have a French
    plug for your devices on-hand. So even though the travel plug costs €48 and your
    first-born, it’s less expensive than finding and buying French power supplies
    for three or four different devices. In software, you can create your own adapter
    class that has the interface your program expects, with code in each of its methods
    that makes calls to the incompatible third-party object behind the scenes.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第三方包的接口导致摩擦，而你又没有时间或精力去更新他们的代码，你总是可以考虑为你的代码创建一个围绕该接口的抽象。这在软件中通常被称为*适配器*，我把它比作在另一个国家使用机场旅行插头。你当然不能改变法国的电源插座（至少会有人生气），而且你也没有为你的设备准备法国插头。所以即使旅行插头要价48欧元和你的第一个孩子，但它比为三四个不同的设备寻找和购买法国电源供应要便宜得多。在软件中，你可以创建自己的适配器类，它具有程序期望的接口，每个方法中的代码都会在幕后调用不兼容的第三方对象。
- en: 3.6.2\. Clever gets the cleaver
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.2. 聪明反被聪明误
- en: I’ve gone on about writing code that’s slick, but overly clever solutions can
    be painful too. If such solutions provide too much magic and not enough granularity,
    you might find that other developers create their own solutions to get their jobs
    done, defeating your effort to provide a single working implementation. Robust
    software must weigh the frequency and impact of use cases to determine which to
    accommodate; common use cases should be as smooth as possible, whereas rare use
    cases can be clunky or explicitly unsupported if needed. Your solution should
    be *just clever enough*, which is an admittedly hard target to hit.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在谈论编写流畅的代码，但过于聪明的解决方案也可能很痛苦。如果这样的解决方案提供了太多的魔法而不是足够的粒度，你可能会发现其他开发者会创建自己的解决方案来完成工作，从而抵消了你提供单一工作实现的努力。健壮的软件必须权衡用例的频率和影响，以确定哪些需要适应；常见用例应该尽可能平滑，而罕见用例如果需要，可以是笨拙的或明确不支持。你的解决方案应该“足够聪明”，这是一个公认很难达到的目标。
- en: That being said, if something feels awkward or cumbersome, give it some time.
    If it still feels awkward or cumbersome after a while, ask others if they agree.
    If they say no but it *still* feels awkward or cumbersome, it’s probably awkward
    or cumbersome. Go forth and make the world a little better with abstraction!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果某件事感觉不自然或笨拙，给它一些时间。如果过了一段时间后它仍然感觉不自然或笨拙，问问别人他们是否同意。如果他们说不同意，但*仍然*感觉不自然或笨拙，那么它可能确实是不自然或笨拙的。用抽象让世界变得更好一点吧！
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Abstraction is a tool for deferring obligatory comprehension of code.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象是推迟代码必要理解的一种工具。
- en: 'Abstraction takes many forms: decomposition, encapsulation, programming style,
    and inheritance versus composition.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象有多种形式：分解、封装、编程风格以及继承与组合。
- en: Each approach to abstraction is useful, but context and extent of use are important
    considerations.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种抽象方法都有用，但上下文和使用范围是重要的考虑因素。
- en: Refactoring is an iterative process; abstraction that once worked may need to
    be revisited later.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构是一个迭代过程；曾经有效的抽象可能需要稍后重新审视。
- en: Chapter 4\. Designing for high performance
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章. 为高性能设计
- en: '*This chapter covers*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding time and space complexity
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解时间和空间复杂度
- en: Measuring the complexity of your code
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量你代码的复杂性
- en: Choosing data types for different activities in Python
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中选择不同活动的数据类型
- en: Once you’ve written working code, there’s usually additional work to do. You
    need your code to not only accomplish its task, but also to accomplish it quickly.
    The *performance* of your code is how well it utilizes resources like memory and
    time. Software that performs at an acceptable level, meaning that it utilizes
    resources efficiently and responds to tasks within a desirable time frame, is
    said to be *performant*.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了工作的代码，通常还需要做额外的工作。你需要你的代码不仅完成它的任务，而且要快速完成。你的代码的*性能*是指它如何有效地利用资源，如内存和时间。在可接受水平上运行的软件，意味着它有效地利用资源，并在期望的时间内响应任务，被称为*性能良好*。
- en: Software performance affects real-world people every day, whether they’re trying
    to upload their latest selfies to Instagram or doing real-time market analysis
    to pick stocks. How performant software should be often comes down to user perception.
    If something *feels* instantaneous, it might be fast enough.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 软件性能每天都会影响现实世界的人们，无论他们是在尝试将最新的自拍照上传到Instagram，还是在进行实时市场分析以挑选股票。软件应该有多高性能通常取决于用户的感知。如果某件事*感觉*是瞬间的，它可能已经足够快了。
- en: Software performance can also affect the bottom line. If your software requires
    you to store something on a disk or in a database, minimizing the amount of storage
    required will save you money. Software that informs money-making decisions can
    net you more money if it runs faster. Performance has real-world impact.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 软件性能也会影响最终结果。如果你的软件需要你在磁盘或数据库中存储某些东西，最小化所需的存储量可以为你节省金钱。如果软件运行得更快，那么能够提供盈利决策信息的软件可以为你赚取更多金钱。性能对现实世界有实际影响。
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Human perception**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**人类感知**'
- en: Humans generally perceive changes faster than 100 ms as instantaneous. If they
    click a button and the screen responds in 50 ms, they’re happy. As responsiveness
    slows beyond 100 ms, people begin to notice the lag.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 人类通常将超过100毫秒的变化感知为瞬间的。如果他们点击一个按钮，屏幕在50毫秒内做出响应，他们会感到满意。当响应速度超过100毫秒时，人们开始注意到延迟。
- en: For long-running activities like downloading large files, lag can’t always be
    helped. In these cases, accurate progress updates are important because they change
    the *perception* of progress so it feels faster.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下载大文件等长时间运行的活动，延迟有时是无法避免的。在这些情况下，准确的进度更新很重要，因为它们改变了*感知*进度，使其感觉更快。
- en: '|  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.1\. Hurtling through time and space
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. 跨越时空
- en: If you read around about high-performing software, you’re likely to encounter
    the phrases *time complexity* and *space complexity*. These terms sound like they’re
    straight out of quantum mechanics or astrophysics, but they have a place in software
    as well.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读有关高性能软件的内容，你可能会遇到*时间复杂度*和*空间复杂度*这样的短语。这些术语听起来像是直接来自量子力学或天体物理学，但它们在软件领域也有其位置。
- en: Time and space complexity are measurements of how much more execution time,
    memory, or disk storage your software needs as its inputs grow. The faster your
    software consumes time or space, the higher its complexity.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度和空间复杂度是衡量你的软件随着输入增长所需的更多执行时间、内存或磁盘存储的量。你的软件消耗时间或空间越快，其复杂度就越高。
- en: Complexity isn’t meant to be an *exact* quantitative measurement; rather, it
    helps you understand qualitatively how fast and big your software will be in the
    worst case. In this section, I’ll help you build an intuition for complexity measurements
    so that you can eke out performance in your work. There is a formal process for
    determining the complexity of your software, though, and I’ll get to that in a
    bit.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度并不是要成为一个*精确*的定量测量；相反，它帮助你定性理解你的软件在最坏情况下将有多快和多大规模。在本节中，我将帮助你建立对复杂度测量的直觉，以便你可以在工作中提高性能。然而，确定软件复杂度有一个正式的过程，我稍后会提到。
- en: 4.1.1\. Complexity is a little . . . complex
  id: totrans-430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1. 复杂度有点复杂
- en: 'I won’t mince any words about this: measuring complexity can be difficult and
    is sometimes confusing. It didn’t make a whole lot of sense to me in school—I’ve
    learned what I know now through repeated practical application. Be ready to do
    the same yourself.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这方面拐弯抹角：测量复杂度可能很困难，有时也令人困惑。在学校时，这对我来说并没有太多意义——我现在所知道的一切都是通过反复的实际应用学到的。准备好自己也要这样做。
- en: Complexity determinations are made through a process called *asymptotic analysis*,
    which involves observing the code and determining the bounds of its worst-case
    performance.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度的确定是通过一种称为*渐近分析*的过程来进行的，它涉及观察代码并确定其最坏情况性能的界限。
- en: '|  |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that complexity measurements are used to contrast ways of achieving
    a particular task; they aren’t so useful for comparing unrelated tasks. It’s useful
    to compare two algorithms for sorting a list of numbers, for example, but you
    can’t compare a list-sorting algorithm to a search tree. Make sure you compare
    apples to apples.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，复杂度测量是用来对比完成特定任务的不同方法的；它们对于比较无关的任务并不那么有用。例如，比较两个排序数字列表的算法是有用的，但你不能将列表排序算法与搜索树进行比较。确保你比较的是苹果对苹果。
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The notation used in asymptotic analysis can seem cryptic at first, but it has
    a plain-English translation. You’ll commonly see complexity written in *big O
    notation*, which signifies the worst-case performance for the code being analyzed.
    Big O notation looks something like *O(n*²*)*—often read as “order n-squared”—where
    *n* is the number of inputs and *n*² is the complexity. This is shorthand for
    “the amount of time the code takes to run increases proportional to the square
    of the number of inputs,” as shown in [figure 4.1](#ch04fig01). *O(n*²*)* is a
    lot faster to write. I’ll use big O notation more in the rest of the chapter.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在渐近分析中使用的符号一开始可能看起来很神秘，但它有一个简单的英文翻译。你通常会看到用*大O符号*表示的复杂度，这表示正在分析的代码的最坏情况性能。大O符号看起来像*O(n*²*)*——通常读作“n的平方阶”——其中*n*是输入数量，*n*²是复杂度。这是“代码运行所需的时间与输入数量的平方成正比”的简写，如图4.1所示。*O(n*²*)*比写出来要快得多。我将在本章的其余部分更多地使用大O符号。
- en: Figure 4.1\. *O*(*n*²) is big O notation shorthand for a *y* } *x*² relationship.
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\. *O*(*n*²)是大O符号的简写，表示*y*与*x*²的关系。
- en: '![](../Images/f0083-01.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0083-01.jpg)'
- en: 4.1.2\. Time complexity
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 时间复杂度
- en: '*Time complexity* is a measure of how quickly your code can perform a task
    in relation to its inputs. As the number of inputs increases, time complexity
    tells you at what rate your code will slow down. This can help you reason about
    how long a task should take as the scale of your inputs grows.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间复杂度*是衡量你的代码相对于其输入执行任务速度的度量。随着输入数量的增加，时间复杂度告诉你代码将以多快的速度变慢。这可以帮助你推理随着输入规模的增加，任务应该花费多长时间。'
- en: LINEARITY
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 线性
- en: Linear complexity is one of the most common complexities to arise from code.
    This complexity is so named because graphing the number of inputs versus time
    produces a straight line. If you think back to the equation for a line in mathematics,
    *y* = *mx* + *b*, you can think of *x* as the number of inputs and *y* as the
    time it takes your program to execute. There may be some overhead for your program
    regardless of input (the *b*, or intercept, in the equation), and each additional
    input adds some amount of execution time (*m*, or the slope). This is illustrated
    in [figure 4.2](#ch04fig02).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 线性复杂度是代码中出现最频繁的复杂度之一。这种复杂度之所以被称为线性，是因为将输入数量与时间的关系绘制成图会产生一条直线。如果你回想一下数学中直线的方程，*y*
    = *mx* + *b*，你可以将*x*视为输入数量，将*y*视为程序执行所需的时间。无论输入如何，你的程序可能都有一些开销（方程中的*b*，或截距），并且每个额外的输入都会增加一些执行时间（*m*，或斜率）。这如图4.2所示。
- en: Figure 4.2\. Visualizing a task with linear complexity
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. 可视化线性复杂度的任务
- en: '![](../Images/f0083-02.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0083-02.jpg)'
- en: 'Linear complexity is frequent in software because many operations need to do
    some task for each item in a list: printing a list of names, summing a list of
    integers, and so on. As the list grows, the amount of time the computer has to
    spend grows proportionally. Summing 1,000 integers takes *about* half as long
    as summing 2,000 integers. For some number of items, *n*, these kinds of activities
    are linear with *n* or, in big O notation, *O*(*n*).'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 线性复杂度在软件中很常见，因为许多操作需要对列表中的每个项目执行一些任务：打印姓名列表、求整数列表的和等等。随着列表的增长，计算机需要花费的时间也会成比例增长。求1000个整数的和大约需要的时间是求2000个整数和所需时间的一半。对于某些数量的项目，*n*，这些活动与*n*线性，或者在大的O符号中，*O*(*n*)。
- en: 'You can spot code that’s likely to be *O*(*n*) in Python by finding `for` loops.
    A single loop over a list, set, or other sequence is likely to be linear:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过寻找`for`循环来在Python中找到可能是*O*(*n*)的代码。对列表、集合或其他序列的单个循环很可能是线性的：
- en: '[PRE49]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This remains true even if you perform multiple steps inside the loop:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在循环内部执行多个步骤，这也依然成立：
- en: '[PRE50]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It *even* remains true if you loop over the same list a set number of times:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在同一个列表上循环固定次数，这依然成立：
- en: '[PRE51]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Although you’re looping over the list of names twice, think about it in terms
    of the equation for a line again. The first loop takes some time, *f*, per item,
    and the second loop takes some time, *g*, per item. The line equation would be
    something like *y* = *fx* + *gx* + *b*, which is equivalent to *y* = (*f* + *g*)*x*
    + *b*. It’s still a line, even if it’s a steeper one.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在姓名列表上循环了两次，但再次从直线的方程的角度来考虑。第一个循环每个项目需要一些时间，*f*，第二个循环每个项目需要一些时间，*g*。直线方程可能类似于*y*
    = *fx* + *gx* + *b*，这相当于*y* = (*f* + *g*)*x* + *b*。即使它是一条更陡的线，它仍然是一条线。
- en: This is where the “asymptotic” part of asymptotic analysis comes in. Even though
    a particular activity may be *steeply* linear, other, more complex operations
    can still outpace it if the inputs are sufficiently many, as shown in [figure
    4.3](#ch04fig03).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是渐近分析中“渐近”部分的作用。尽管特定的活动可能是*陡峭的线性*，但如果输入足够多，其他更复杂的操作仍然可以超过它，如图4.3所示。[图4.3](#ch04fig03)。
- en: Figure 4.3\. Higher-order complexity at large scales
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3\. 大规模的高阶复杂度
- en: '![](../Images/f0084-01_alt.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0084-01_alt.jpg)'
- en: PROPORTIONAL TO THE SQUARE
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与平方成正比
- en: Another type of time complexity is proportional to the *square* of the inputs
    (*O*(*n*²)). This crops up in cases where, for each item in a list, you need to
    look at every other item in the list. As you add more inputs, your code has to
    iterate over the additional items, but it also needs to iterate over those additional
    items on each of *those* iterations. The increase in execution time is compounded.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种时间复杂度是与输入的平方成正比（*O*(*n*²)）。这种情况出现在，对于列表中的每个项目，你需要查看列表中的其他每个项目时。随着输入的增加，你的代码必须遍历额外的项目，但它还需要在每次迭代中遍历这些额外的项目。执行时间的增加是成倍的。
- en: 'You can spot this in Python code by the presence of nested loops. The following
    code checks if a list has any duplicate items:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Python代码中嵌套循环的存在来发现这一点。以下代码检查列表中是否有任何重复项：
- en: '[PRE52]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* The outer loop iterates over every element in the sequence.**'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 外循环遍历序列中的每个元素。**'
- en: '***2* The inner loop iterates over every element again, for each element in
    the outer loop.**'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 内循环再次遍历每个元素，对于外循环中的每个元素。**'
- en: '***3* Checks if two elements are the same value, but not the same specific
    element from the sequence**'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查两个元素是否具有相同的值，但不是序列中的相同特定元素**'
- en: '*O*(*n*²) is the *worst case* for this code because even if only the last items
    are duplicates, or if no duplicates exist, the code still has to iterate over
    all the inputs before it finishes. If the first two items are duplicates, the
    code will be much faster because it can stop immediately, but it’s useful to examine
    the worst case to get a better sense for what the code is capable of. Big O notation
    always measures the worst-case complexity of code for this reason.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*O*(*n*²)是此代码的*最坏情况*，因为即使只有最后的项目是重复的，或者没有重复项存在，代码仍然必须遍历所有输入才能完成。如果前两个项目是重复的，代码将会快得多，因为它可以立即停止，但检查最坏情况对于更好地了解代码的能力是有用的。大O符号总是测量代码的最坏情况复杂度，出于这个原因。'
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Additional notations**'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加符号**'
- en: It’s sometimes useful to calculate not only the *worst* case but also the *average*
    case and the *best* case. Big θ (big omega) notation is used for best-case analysis,
    and big θ (big theta) notation is used to express that the upper and lower bounds
    are of the specified complexity. Usually these can help you choose the approach
    best suited to what you are trying to accomplish from a number of choices. The
    complexity of many algorithms can be found by searching online, such as for “complexity
    of quicksort”. You can also find the time complexity of some common operations
    in the Python docs ([https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，计算不仅是最坏情况，还有平均情况和最好情况是有用的。大θ（大Ω）符号用于最好情况分析，而大θ（大Θ）符号用于表示上界和下界具有指定的复杂度。通常这些可以帮助你从多个选择中选出最适合你想要完成的事情的方法。许多算法的复杂度可以通过在线搜索找到，例如搜索“quicksort的复杂度”。你还可以在Python文档中找到一些常见操作的时空复杂度（[https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)）。
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: CONSTANT TIME
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常数时间
- en: The ideal complexity is constant time (*O*(1)), which doesn’t depend on the
    size of the inputs. Nothing can be better than constant time because that would
    require the software to *speed up* as its input grow! Constant time is realized
    in some of the data types in Python, which I’ll talk more about later.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 理想复杂度是常数时间（*O*(1)），它不依赖于输入的大小。没有什么比常数时间更好，因为这要求软件随着输入的增长而*加速*！Python中的一些数据类型实现了常数时间，我将在稍后详细介绍。
- en: Some problems that would normally be linear (or worse) can be made constant
    after up-front computation. That initial computation may itself be nonconstant,
    but if it allows many subsequent steps to *become* constant, it can be a great
    trade-off.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 一些通常会是线性（或更差）的问题，在前期计算后可以变成常数。这个初始计算本身可能不是常数，但如果它允许许多后续步骤变成常数，那么这可以是一个很好的权衡。
- en: 4.1.3\. Space complexity
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 空间复杂度
- en: Just like time complexity, *space complexity* is a measure of how your code
    uses disk space or memory as its inputs grow. Space complexity is easy to overlook,
    though, because it’s not always something you observe directly. Sometimes inefficient
    use of disk space rears its ugly head only when you get a pop up saying you have
    no disk space left on your computer. It’s good to think about space as you write
    your code so you don’t eat up your resources.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 就像时间复杂度一样，*空间复杂度*是衡量你的代码随着输入增长如何使用磁盘空间或内存的度量。然而，空间复杂度很容易被忽视，因为它并不总是直接观察到的。有时，不高效的磁盘空间使用只有在收到提示说你的电脑上没有剩余磁盘空间时才会显现出来。在编写代码时考虑空间是一个好习惯，这样你就不会耗尽资源。
- en: '|  |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The garbage man**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**垃圾清理工**'
- en: Another thing that makes space complexity more difficult in Python is that you
    don’t often manage memory yourself. In some languages, you must explicitly allocate
    and free up memory, which forces you to manage how your code uses resources. Python
    uses automatic *garbage* *collection*, which frees the memory that holds objects
    that are no longer in use by a running program.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使空间复杂度在Python中更困难的事情是，你通常不自己管理内存。在某些语言中，你必须显式地分配和释放内存，这迫使你管理代码如何使用资源。Python使用自动*垃圾*回收，这释放了运行程序不再使用的对象占用的内存。
- en: '|  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: MEMORY
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 内存
- en: 'A common way programs use too much memory is by reading large data files fully
    into memory when they don’t have to. Suppose you have a text file containing a
    row for each person alive today and their favorite color. You’d like to know the
    number of people who like each color the most. You might consider reading the
    whole file in as a list of rows and operating on the list:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用过多内存的常见方式是在不需要的情况下将大型数据文件完全读入内存。假设你有一个包含每个活着的人及其最喜欢的颜色的文本文件。你想要知道喜欢每种颜色的人数。你可能会考虑将整个文件作为一个行列表读取并操作该列表：
- en: '[PRE53]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Reads the whole file into a list of lines**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将整个文件读入行列表**'
- en: There are a lot of people on planet Earth. Even if the file only contained one
    column of favorite colors and each row used 1 byte of data, the file would still
    be just over 7 GB in size. You might have that much memory on your machine, but
    the task doesn’t require you to have all the row information available at once.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 地球上有很多人。即使文件只包含一列最喜欢的颜色，并且每一行使用1字节的数据，该文件的大小也仍然是超过7 GB。你可能机器上有这么多内存，但任务并不要求你一次性获取所有行信息。
- en: In Python, you can read a file line-by-line in a `for` loop, and on each iteration
    of the loop, the next line will *replace* the current line in memory. Try updating
    the code to read one line from the file at a time, and come back when you’ve got
    it.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以通过`for`循环逐行读取文件，并且每次循环迭代中，下一行将*替换*内存中的当前行。尝试更新代码，每次只从文件中读取一行，并在获取所需内容后返回。
- en: '[PRE54]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Reads only one line at a time**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一次只读取一行**'
- en: '***2* Removes the trailing newline character from each line**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从每行中移除尾随换行符**'
- en: By reading one line at a time and throwing them out after you get what you need,
    your memory usage will go only as high as the largest line in the file. Much better!
    The space complexity has gone from *O*(*n*) to *O*(1).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐行读取并在获取所需内容后丢弃它们，你的内存使用量将仅达到文件中最长行的高度。这要好得多！空间复杂度从*O*(*n*)降低到*O*(1)。
- en: DISK SPACE
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 磁盘空间
- en: I’ve run into disk space issues on long-lived applications in the past. These
    are sometimes hard to see because they don’t always cause an issue immediately.
    It could be weeks or months before you run out of disk space, either because your
    program writes small amounts of data at a time or simply because you have large
    storage available.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我过去在长期运行的应用程序中遇到过磁盘空间问题。这些问题有时很难发现，因为它们并不总是立即引起问题。可能需要几周或几个月，你才会耗尽磁盘空间，这可能是由于你的程序每次写入少量数据，或者简单地因为你有大量的存储空间。
- en: Many big web applications emit logs of their activity so they can be debugged
    or analyzed. If you introduce a log statement in your code that gets called 1,000
    times per minute in production, this could start eating up disk space quickly.
    You might want to remove that line, move it somewhere that gets called less frequently,
    or improve your strategy for storing logs.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型网络应用程序会发出它们的日志，以便进行调试或分析。如果你在代码中引入了一个在生产环境中每分钟被调用1,000次的日志语句，这可能会迅速消耗磁盘空间。你可能想删除该行，将其移动到调用频率较低的地方，或者改进存储日志的策略。
- en: Finding opportunities to shift an approach from a higher-order complexity to
    a lower-order one will almost always yield better performance gains than trying
    to eke performance out of a particular line of code. Use complexity analysis to
    understand where these opportunities lie in your software. Read on to see how
    you can address these opportunities using some of the features built into Python.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找将方法从高阶复杂性转换为低阶复杂性的机会，几乎总是比试图从特定的代码行中挤出性能提升要有效得多。使用复杂性分析来了解这些机会在您的软件中的位置。继续阅读，了解您如何使用Python内置的一些功能来利用这些机会。
- en: 4.2\. Performance and data types
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 性能和数据类型
- en: Although your code should be designed with time and space complexity in mind,
    it will ultimately be built on Python’s existing data types. The following sections
    cover a number of use cases, as well as which data types are best suited for them.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您的代码应该考虑到时间和空间复杂度，但它最终将建立在Python现有的数据类型之上。以下几节涵盖了多个用例，以及最适合它们的数据类型。
- en: 4.2.1\. Data types for constant time
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 常数时间的数据类型
- en: Remember that the ideal performance is one of constant time, which does not
    increase as the number of inputs increases. Python’s `dict` (dictionary) and `set`
    (set) types exhibit this behavior when adding, removing, and accessing items.
    They’re quite similar under the hood, with a main difference being that *dictionaries
    map keys to values*, whereas *sets represent a set of unique, individual items*.
    Iterating through the items in either of these data types is still *O*(*n*) time
    because it depends on the number of items contained in the object. But fetching
    specific items or checking if a specific item exists is speedy regardless of the
    total number of items.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，理想性能是常数时间，不会随着输入数量的增加而增加。Python的`dict`（字典）和`set`（集合）类型在添加、删除和访问项时表现出这种行为。它们在底层相当相似，主要区别在于*字典将键映射到值*，而*集合表示一组唯一的、单独的项*。遍历这两种数据类型中的项仍然是*O*(*n*)时间，因为它取决于对象中包含的项的数量。但是，获取特定项或检查特定项是否存在，无论项的总数是多少，都是快速的。
- en: Suppose that instead of counting the world’s favorite colors, you’re now interested
    in getting the unique set of all favorite colors so you can check if any colors
    aren’t represented. You can still read the file line-by-line as before, but how
    might you represent the data and check it for specific colors?
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您现在对获取所有最喜欢的颜色的唯一集合感兴趣，以便检查是否有颜色没有被表示，而不是计数世界上最喜欢的颜色。您仍然可以像以前一样逐行读取文件，但您如何表示数据并检查特定颜色呢？
- en: Have a go at representing the data and checking it for specific colors. Then
    come back here and compare your work to the following listing to see how you did.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试表示数据并检查特定颜色。然后回到这里，将您的作品与以下列表进行比较，看看您做得如何。
- en: Listing 4.1\. Using Python's features to minimize space
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. 使用Python的功能来最小化空间
- en: '[PRE55]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Iterating over the file is still O(n) time.**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 遍历文件仍然是O(n)时间。'
- en: '***2* Adding to a set is O(1) time, but O(n) space.**'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 向集合中添加元素的时间复杂度为O(1)，但空间复杂度为O(n)。'
- en: '***3* Membership of the set is an O(1) question.**'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 集合的成员资格是一个O(1)问题。'
- en: By using a set to hold a list of the unique colors encountered in the file,
    you can check for specific colors in the set in constant (*O*(1)) time after the
    loop.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用集合来保存文件中遇到的独特颜色列表，您可以在循环之后以常数时间（*O*(1)）检查集合中的特定颜色。
- en: 4.2.2\. Data types for linear time
  id: totrans-504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 线性时间的数据类型
- en: The `list` data type in Python exhibits mainly *O*(*n*) operations; determining
    membership in a list or adding a new item to an arbitrary location in a list is
    slower for lists with more elements. Adding or removing from the *end* of a list
    takes *O*(1) time. Lists are useful when the items being stored aren’t uniquely
    identifiable.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`list`数据类型主要表现出*O*(*n*)操作；在列表中确定成员资格或在列表的任意位置添加新项对于元素较多的列表来说较慢。从列表的*末尾*添加或删除元素需要*O*(1)时间。当存储的项无法唯一标识时，列表很有用。
- en: The `tuple` type is similar to `list` in terms of performance, with the key
    difference being that tuples can’t be changed after they’re created.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`类型在性能上与`list`类似，关键区别在于元组创建后不能被更改。'
- en: 4.2.3\. Space complexity of operations on data types
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 数据类型操作的空间复杂度
- en: Now that you’re familiar with the time complexity of some of Python’s built-in
    data structures, I’ll teach you a couple of tricks for using them. The data types
    we’ve seen so far are all *iterables*—objects that support iteration over their
    contents (in a `for` loop, for example). Iteration over a set of elements is nearly
    always going to be *O*(*n*) in time complexity; going through every element takes
    more time if there are more elements. But what about space complexity?
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 Python 一些内置数据结构的时间复杂度，我将教你一些使用它们的技巧。我们之前看到的数据类型都是 *可迭代的*——支持对其内容进行迭代的对象（例如在
    `for` 循环中）。对一组元素进行迭代的时间复杂度几乎总是 *O*(*n*)；如果有更多元素，遍历每个元素需要更多时间。但空间复杂度如何呢？
- en: For the data types we’ve seen so far, all their contents are stored in memory
    together. If a list has 10 elements, it takes roughly 10 times more space in memory
    than a list with a single element, as shown in [figure 4.4](#ch04fig04). This
    means their *space* complexity is also *O*(*n*). This can be problematic, the
    same way reading 7.6 billion records into memory is problematic. If we don’t need
    all that data at once, we might be able to find a more efficient approach.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们之前看到的数据类型，它们的全部内容都存储在内存中。如果一个列表有 10 个元素，它比只有一个元素的列表在内存中占用大约 10 倍的空间，如图 4.4
    所示。这意味着它们的 *空间* 复杂度也是 *O*(*n*)。这可能会带来问题，就像将 76 亿条记录读入内存一样有问题。如果我们不需要一次性获取所有这些数据，我们可能能够找到一种更有效的方法。
- en: Figure 4.4\. The memory footprint of lists
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 列表内存占用
- en: '![](../Images/f0089-01_alt.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0089-01_alt.jpg)'
- en: Enter *generators*. Generators are constructs in Python that produce a single
    value at a time, pausing until the next value is requested ([figure 4.5](#ch04fig05)).
    This acts a lot like the approach you used earlier to read a file line-by-line.
    By yielding one value at a time, a generator avoids storing all values it produces
    in memory at once.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 *生成器*。生成器是 Python 中的构造，一次产生一个值，直到下一个值被请求时才会暂停（[图 4.5](#ch04fig05)）。这很像你之前按行读取文件的方法。通过逐个产生值，生成器避免了将所有产生的值一次性存储在内存中。
- en: Figure 4.5\. Saving space with generators
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5\. 使用生成器节省空间
- en: '![](../Images/f0089-02_alt.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0089-02_alt.jpg)'
- en: If you’ve used the `range` function in Python before, you’ve already used a
    generator. `range` accepts arguments that specify the bounds of the range you’d
    like. If `range` stored all the numbers of the range in memory, code like `range(100_000_000)`
    would eat up your available memory in short order. Instead, `range` stores only
    the *bounds* of the range and produces values from it one at a time. But how?
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在 Python 中使用过 `range` 函数，那么你已经使用过生成器了。`range` 接受指定你想要的范围边界的参数。如果 `range`
    在内存中存储了范围的所有数字，那么像 `range(100_000_000)` 这样的代码很快就会耗尽你的可用内存。相反，`range` 只存储范围的 *bounds*
    并逐个产生值。但这是如何实现的呢？
- en: To use space efficiently, generators make use of the `yield` Python keyword.
    After producing a value, they yield execution back to the calling code. So `yield`
    yields a value and then yields execution.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地使用空间，生成器使用了 Python 的 `yield` 关键字。在产生一个值之后，它们将执行权交回调用代码。所以 `yield` 产生一个值，然后交回执行权。
- en: '`yield` works a lot like Python’s `return` statement, except that you can perform
    operations *after* you yield a value. This can be used to set up for the next
    value you want to produce. The following listing shows approximately how `range`
    behaves under the hood. Note the use of the `yield` keyword and the increment
    of the `current` value *after* `yield` is used.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` 与 Python 的 `return` 语句非常相似，但不同之处在于你可以在 `yield` 一个值之后执行操作。这可以用来为下一个你想要产生的值做准备。下面的列表展示了
    `range` 在底层是如何工作的。注意 `yield` 关键字的使用以及 `yield` 之后 `current` 值的递增。'
- en: Listing 4.2\. Using `yield` to pause and prepare
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 使用 `yield` 暂停并准备
- en: '[PRE56]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Parses arguments to determine bounds of the range**'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 解析参数以确定范围的边界**'
- en: '***2* yields each value (one at a time)**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 逐个产生每个值**（one at a time））'
- en: '***3* Performs the necessary setup for the next value**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为下一个值执行必要的设置**'
- en: 'There’s a pattern in this implementation you’ll see repeated often in generators:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，你会看到一种模式，在生成器中会经常重复：
- en: Perform the main setup required for producing all values.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行生成所有值所需的主要设置。
- en: Create a loop.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环。
- en: Yield a value on each iteration of the loop.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中产生一个值。
- en: Update the state for the next iteration of the loop.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新循环下一次迭代的状。
- en: Try inspecting the values from your `range` generator now. You can turn it into
    a list using `list(range(5, 10))`, for example. You can also move forward one
    value at a time by saving `range(5, 10)` to a variable and making successive calls
    to `next(my_range)`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试检查你的 `range` 生成器的值。例如，你可以使用 `list(range(5, 10))` 将其转换为列表。你还可以通过将 `range(5,
    10)` 保存到一个变量中，并连续调用 `next(my_range)` 来逐个前进一个值。
- en: Now that you’ve got this pattern handy, I’d like you to write your very own
    generator. Your generator function, `squares`, will take in a list of integers
    and produce the square of each of them. Give it a shot, and come back to the following
    listing to see how you did.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了这个模式，我想让你编写你自己的生成器。你的生成器函数 `squares` 将接受一个整数列表，并产生每个整数的平方。试一试，然后回到以下列表中看看你的成果。
- en: Listing 4.3\. A short generator that yields squared numbers
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 一个生成平方数的简短生成器
- en: '[PRE57]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `squares` function ends up being fairly compact because there’s no setup
    or state management to do. I also said that this function accepts a list, but
    what’s kind of cool about it is that you can pass in another generator instead.
    `squares(range (100_000_000))` works just as well. It will only store one item
    from the range and one squared result at a time, saving even more space (as shown
    in [figure 4.6](#ch04fig06)).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`squares` 函数最终变得相当紧凑，因为没有需要设置或状态管理的事情要做。我也说过这个函数接受一个列表，但真正酷的是你可以传入另一个生成器。`squares(range
    (100_000_000))` 也可以正常工作。它将一次只存储范围中的一个项目和平方结果，从而节省更多的空间（如图 4.6 所示）。'
- en: Figure 4.6\. Memory usage of chained generators
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6\. 连锁生成器的内存使用情况
- en: '![](../Images/f0091-01_alt.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0091-01_alt.jpg)'
- en: I recommend making use of generators over lists wherever you can, because you
    can always build a full list in memory from a generator if needed by writing `list(range(10000))`
    or `list(squares([1, 2, 3, 4]))`. Using generators will save memory, but it can
    also save time because the code consuming the values from the generator may not
    need them all anyway.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议尽可能使用生成器而不是列表，因为如果你需要，你可以通过编写 `list(range(10000))` 或 `list(squares([1, 2,
    3, 4]))` 来从生成器中构建一个完整的列表。使用生成器可以节省内存，而且还可以节省时间，因为消耗生成器值的代码可能根本不需要所有的值。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lazy evaluation**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟评估**'
- en: The idea of producing one value at a time, and that consuming code may not need
    all the values you can produce, is often referred to as *lazy evaluation*. It’s
    *lazy* because you’d like to do as little work as possible, and only once you’ve
    been asked explicitly to do so. Picture your generators letting out an exaggerated
    sigh each time they’re asked to `yield` a value.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 每次产生一个值，并且消耗代码可能不需要你能够产生的所有值，这种想法通常被称为 *延迟评估*。它被称为 *延迟* 是因为你想做尽可能少的工作，并且只有在你被明确要求这样做的时候。想象一下，每次生成器被要求
    `yield` 一个值时，它都会发出夸张的叹息。
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.3\. Make it work, make it right, make it fast
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 让它工作，让它正确，让它快速
- en: The adage “make it work, make it right, make it fast” comes from Kent Beck,
    the creator of extreme programming. On its face, this could mean that you should
    first write working code, *then* rework it to be clear and concise, and only *then*
    make it performant. But I like to think of these three rules as being the steps
    you take on each small iteration as you write code. Remember that design, implementation,
    and refactoring all happen in tight cycles as you code.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: “先让它工作，再让它正确，最后让它快速”这句谚语来自极限编程的创始人肯特·贝克。从表面上看，这可能意味着你应该首先编写可工作的代码，*然后* 重新设计它以使其清晰简洁，最后
    *然后* 使其具有性能。但我喜欢将这些规则看作是在编写代码的每次小迭代中采取的步骤。记住，设计、实现和重构都在编码的紧密循环中发生。
- en: 4.3.1\. Making it work
  id: totrans-542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 让它工作
- en: 'This, frankly, is what developers spend a great deal of their time on. You
    try to turn a problem statement or idea into code that achieves the goal. Developers
    (myself included) often work all the way through a problem before moving on to
    refactoring or performance. It can feel like a chicken and egg problem: *How can
    I make “it” fast if “it” isn’t even* done *yet*?'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是开发者花费大量时间做的事情。你试图将问题陈述或想法转化为实现目标的代码。开发者（包括我自己）经常在重构或性能之前一直工作在问题上。这可以感觉像是一个鸡生蛋的问题：*如果“它”还没有完成，我怎么能让它快起来呢*？
- en: Just as decomposition is useful for software itself, it is also useful as a
    tool in breaking down goals into manageable chunks. Each of those smaller goals
    can be implemented and examined incrementally along the way to achieving the larger
    goal. It’s also much easier in this approach to “make it work,” because “it” is
    a more granular goal. You can sketch some ideas for “calculate the velocity of
    a falling object” more readily than “make a physics engine.”
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 就像分解对于软件本身是有用的，它作为分解目标为可管理块的工具也是很有用的。这些更小的目标中的每一个都可以在实现过程中逐步实现和检查，以实现更大的目标。这种方法中“让它工作”也更容易，因为“它”是一个更细粒度的目标。你更容易为“计算下落物体的速度”构思一些想法，而不是“制作一个物理引擎”。
- en: 4.3.2\. Making it right
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 让它变得正确
- en: Making it work is all about trying to get from point A to point B. If you’re
    clear on the goal of the task, “Does it work?” is a binary answer.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 让它工作，关键在于尝试从A点到B点。如果你清楚任务的目的是什么，“它工作了吗？”这是一个二元答案。
- en: Making it right is all about refactoring. Refactoring seeks to re-implement
    existing code in a clearer or more well adapted way, while providing the same
    consistent outcome.^([[1](#ch04fn01)])
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 让它变得正确，关键在于重构。重构旨在以更清晰或更适应的方式重新实现现有代码，同时提供相同的一致结果.^([[1](#ch04fn01)])
- en: ¹
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is a school of thought that says you can create tests for the code you
    write and, if the tests are sufficient and passing, you can lean on them while
    making changes to ensure you haven’t broken anything. There are a number of fantastic
    texts on this subject. See Harry Percival, Test-Driven Development with Python,
    second edition (O’Reilly, 2017).
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有一种观点认为，你可以为编写的代码编写测试，如果测试足够并且通过，你可以在进行更改时依赖它们，以确保你没有破坏任何东西。关于这个主题有许多优秀的文本。参见哈里·佩尔西瓦尔，Python测试驱动开发，第二版（O’Reilly，2017）。
- en: 'Refactoring has no clear “done” moment. You will find yourself iterating while
    you implement, as well as when you revisit the code to add new functionality.
    For one metric about when you definitely *should* refactor, Martin Fowler’s *rule
    of three* says that around the time you’ve implemented a similar thing three times,
    you should refactor your code to provide an abstraction for that behavior. I like
    this premise because it suggests a balance around refactoring: don’t abstract
    something immediately, or even after you’ve duplicated it twice, because it might
    be premature. Wait to see what use cases arise. They will allow you to generalize
    the solution more effectively and be sure that it’s necessary.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 重构没有明确的“完成”时刻。在实现过程中，你将发现自己会迭代，当重新访问代码以添加新功能时也是如此。关于何时你绝对*应该*重构的一个指标，马丁·福勒的*三法则*说，在你已经实现了类似功能三次左右时，你应该重构你的代码，为这种行为提供一个抽象。我喜欢这个前提，因为它暗示了重构的平衡：不要立即抽象化某物，甚至在你复制了两次之后，因为这可能是过早的。等待看看会出现什么用例。它们将使你能够更有效地概括解决方案，并确保它是必要的。
- en: 'Another aspect to making something right is to use the strengths of the language
    to your advantage. Take a look at the following code, which determines the most
    frequent integer in a list:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 让某物变得正确的一个方面是利用语言的优势。看看以下代码，它确定列表中最频繁出现的整数：
- en: '[PRE58]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Determines the number with the highest count in a dict that maps numbers
    to counts**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确定映射数字到计数的字典中计数最高的数字**'
- en: '***2* Tallies up the occurrence of numbers to see which has the highest count**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 统计数字出现的次数，以查看哪个数字出现次数最多**'
- en: 'I’ve made this *work*, but Python has a few tools for making this easier. The
    first tool helps with the code that increments the count. For each number in the
    list, it has to check if we’ve already seen it to know if it can increment the
    count or if it has to initialize the count. Python has a built-in data type to
    avoid this extra leg work: the `defaultdict`. You can tell a `defaultdict` the
    type of the values it stores, and it will default to a sensible value of that
    type if a new key is accessed:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经让这个*工作*了，但Python有一些工具可以使这更容易。第一个工具帮助处理增加计数的代码。对于列表中的每个数字，它必须检查我们是否已经看到它，以知道是否可以增加计数或是否需要初始化计数。Python有一个内置的数据类型可以避免这种额外的工作：`defaultdict`。你可以告诉`defaultdict`它存储的值的类型，如果访问一个新的键，它将默认为该类型的合理值：
- en: '[PRE59]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Imports defaultdict from the collections module**'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从collections模块导入defaultdict**'
- en: '***2* The counts are integers, so the default type of each value in the defaultdict
    should be int.**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 计数是整数，所以`defaultdict`中每个值的默认类型应该是int。**'
- en: '***3* The default value for int is 0, so the first time we see a number, its
    count will be 0 + 1 = 1.**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 默认的 int 值是 0，所以当我们第一次看到数字时，它的计数将是 0 + 1 = 1。**'
- en: 'Not bad—you saved yourself one line of code, and the spirit of the function
    is a little more clear. But you can do even better. Python also has a helper for
    counting things in a sequence:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错——你节省了一行代码，函数的精神也稍微清晰了一些。但你可以做得更好。Python 还有一个用于在序列中计数事物的辅助工具：
- en: '[PRE60]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Counter is also in the collections module.**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 计数器也位于集合模块中。**'
- en: '***2* Acts nearly identically to the dict of counts you made manually**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 几乎与你自己制作的计数字典的行为相同**'
- en: 'You’ve saved a few more lines, and now the spirit of `most_frequent` is quite
    clear: count the unique numbers, and return the one with the highest count. But
    what about `get_number_with_highest_count`? It’s finding the maximum value in
    a dictionary that maps numbers to their counts. Python provides two tools that
    can simplify this function too.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 你又节省了几行代码，现在 `most_frequent` 的精神相当清晰：计数唯一数字，并返回计数最高的那个。但 `get_number_with_highest_count`
    呢？它是在一个将数字映射到它们的计数的字典中寻找最大值。Python 提供了两个工具可以简化这个函数。
- en: The first is `max`. `max` accepts an iterable (lists, sets, dictionaries, and
    so on) and returns the maximum value from that iterable. In the case of a dictionary,
    `max` returns the maximum value of the *keys* by default. The keys of the `counts`
    dictionary are the numbers themselves, not the counts. `max` accepts a second
    argument, `key`, which is a function that tells `max` what part of the iterable
    to use.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个功能是 `max`。`max` 接受一个可迭代对象（列表、集合、字典等）并返回该可迭代对象中的最大值。在字典的情况下，`max` 默认返回 *键*
    的最大值。`counts` 字典的键是数字本身，而不是计数。`max` 接受第二个参数，`key`，它是一个函数，告诉 `max` 使用可迭代对象的哪一部分。
- en: 'Python will only pass one argument to `key`: the value from the iterable. In
    the case of dictionaries, Python iterates over their keys, so the function passed
    to the `key` argument for `max` will only get the numbers but not their counts.
    You need to tell `key` that, when given a number, it should index the `counts`
    dictionary at that number to get the count value. Writing a separate function
    in the module won’t work because `counts` won’t be available at all in its namespace.
    How can you get around this?'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: Python 只会将一个参数传递给 `key`：可迭代对象的值。在字典的情况下，Python 会遍历它们的键，所以传递给 `max` 的 `key` 参数的函数只会得到数字，而不会得到它们的计数。你需要告诉
    `key`，当给定一个数字时，它应该在该数字处索引 `counts` 字典以获取计数值。在模块中编写一个单独的函数不会起作用，因为 `counts` 在其命名空间中根本不可用。你该如何解决这个问题？
- en: In functional programming, it’s common to pass functions as arguments to other
    functions, and sometimes those passed functions are short and clear enough that
    they don’t need names. Unlike most of the functions you’ve probably written in
    Python, they’re *anonymous* functions and are called *lambdas*. Lambdas are indeed
    functions; they accept arguments and return values. They don’t have names, and
    you can’t call them directly, but you can use them as inline arguments to other
    functions to get things done.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，通常会将函数作为参数传递给其他函数，有时这些传递的函数非常简短且清晰，以至于它们不需要名字。与你在 Python 中可能编写的大多数函数不同，它们是
    *匿名* 函数，被称为 *lambda*。Lambda 确实是函数；它们接受参数并返回值。它们没有名字，你不能直接调用它们，但你可以将它们用作其他函数的行内参数来完成工作。
- en: 'In the case of the `get_number_with_highest_count` function, you can pass a
    lambda to `max` that accepts a number and returns `counts[number]`. This solves
    the namespace issue and provides the behavior you want to give to `max`. Let’s
    see how succinct this will make the code:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get_number_with_highest_count` 函数的情况下，你可以向 `max` 传递一个 lambda 表达式，该表达式接受一个数字并返回
    `counts[number]`。这解决了命名空间问题，并提供了你想要给 `max` 的行为。让我们看看这将如何使代码更加简洁：
- en: '[PRE61]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* When iterating over the numbers in counts, uses counts[number] (that
    number’s count) as the comparison value**'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在迭代 `counts` 中的数字时，使用 `counts[number]`（该数字的计数）作为比较值**'
- en: That’s concise, and still clear. Understanding what tools a language has for
    which activities will often help you produce shorter code.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简洁，而且仍然清晰。了解一种语言为哪些活动提供了哪些工具通常会帮助你编写更短的代码。
- en: Shorter isn’t always better, of course. You could go further and move the `max`
    directly into the `most_frequent` function, but when I’m using functions like
    `max` that aren’t always perfectly clear about their behavior, I like having the
    separate function with a clearer name.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，短小并不总是最好。您可以将`max`直接移动到`most_frequent`函数中，但当我使用像`max`这样的函数，它们的行为并不总是完全清晰时，我喜欢有一个具有更清晰名称的独立函数。
- en: Once you reach a point where the code you’ve written is working, and it’s clear
    enough about *how* it works that someone else could pick it up and use it, you’ve
    made it right.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您写出的代码开始工作，并且足够清晰，其他人可以理解其工作方式并使用它，您就做得正确了。
- en: 4.3.3\. Making it fast
  id: totrans-575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3. 让它变得更快
- en: Tuning the performance of your code can often take as long as writing the code
    in the first place. Complexity analysis and subsequent improvements require care
    and a good long look at the data types and operations in your code. You’ll need
    to weigh the time lost to performance tuning against the need to bring your work
    to market. As mentioned at the beginning of this chapter, you’ll also need to
    decide when the code is performant *enough*. Perfection is the enemy of good enough,
    as they say, so it’s often better to ship something valuable but slow than not
    to ship anything at all.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 调整代码的性能可能需要的时间与最初编写代码所需的时间一样长。复杂性分析和随后的改进需要细心和对代码中的数据类型和操作进行良好的长期审视。您需要权衡性能调整所损失的时间与将您的作品推向市场的需求。正如本章开头提到的，您还需要决定何时代码的表现“足够好”。正如他们所说，完美是足够好的敌人，因此，推出一个有价值但速度较慢的产品通常比完全不推出产品要好。
- en: If your priority is getting something to market, consider setting some performance
    milestones for yourself that you can reach iteratively after your initial release.
    This way, you can focus on making something work, making it work right for ease
    of future improvement, and shipping your product. You’ll likely find new and unexpected
    bottlenecks by running your code in production.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的优先级是尽快将产品推向市场，那么在您的初始发布后，考虑为自己设定一些可以逐步实现的表现里程碑。这样，您可以专注于让某个功能工作，确保它工作得正确以便于未来的改进，并交付您的产品。您可能会在生产环境中运行代码时发现新的和意外的瓶颈。
- en: Your acceptable level of performance will also vary based on your goals. If
    you are displaying a modal to log in to a site after clicking Log In, it needs
    to happen instantaneously, or your users will leave. If you’re trying to build
    an annual reporting system so customers can see their sales, they will likely
    expect to wait a bit.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 您可接受的表现水平也会根据您的目标而有所不同。如果您在点击“登录”后显示一个登录网站的模态窗口，它需要瞬间发生，否则您的用户可能会离开。如果您正在尝试构建一个年度报告系统，以便客户可以看到他们的销售情况，他们可能会期望等待一段时间。
- en: The *architecture* of the system—all the different services, pages, interactions,
    and so on—will inform and affect performance too. Bigger systems require more
    network communication between APIs, databases, and caches. They may also have
    some processes that happen outside of the user’s workflow, like nightly accumulation
    of metrics for analysis. You can examine other services within this architecture
    that perform tasks similar to yours to get an idea of the baseline. From there,
    you can create an informed expectation of your software’s performance and strive
    toward it. The performance of large systems transcends code.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的*架构*——所有不同的服务、页面、交互等等——也会影响性能。更大的系统需要在API、数据库和缓存之间进行更多的网络通信。它们也可能有一些在用户工作流程之外发生的进程，比如夜间累积指标以进行分析。您可以检查这个架构中执行类似任务的其它服务，以获得基线。从那里，您可以创建一个关于您软件性能的明智预期，并努力实现它。大型系统的性能超越了代码本身。
- en: As you write more code, bring what you’ve learned about the performance of data
    types and techniques to bear on your software. You can begin to develop a sense
    for lines of code that might cause performance issues. Nested loops and huge in-memory
    lists will start to jump out at you.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您编写更多的代码，将您关于数据类型和技术性能的知识应用到您的软件中。您可以开始培养一种对可能导致性能问题的代码行的感觉。嵌套循环和巨大的内存列表将开始跳入您的视线。
- en: 4.4\. Tools
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. 工具
- en: Performance testing in the real world needs to follow an evidence-based approach.
    This is a direct result of the fact that systems with real users will inevitably
    experience different behavior; the combination of unexpected inputs, timing, hardware,
    network latency, and more contribute to a system’s performance. As such, poking
    around your code hoping to stumble on huge performance wins may not be the best
    use of your time.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中进行性能测试需要遵循基于证据的方法。这是由于具有真实用户的系统不可避免地会经历不同的行为；意外的输入、时间、硬件、网络延迟等因素共同影响着系统的性能。因此，在代码中随意尝试以偶然发现巨大的性能提升可能不是最好的时间利用方式。
- en: 4.4.1\. timeit
  id: totrans-583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. timeit
- en: The timeit module in Python is a tool for testing the execution time of code
    snippets. It can be used from the command line or directly in your code for more
    control. The timeit module is handy for sanity-checking the performance changes
    you intend to make.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的timeit模块是一个用于测试代码片段执行时间的工具。它可以从命令行或直接在你的代码中使用以获得更多控制。timeit模块对于验证你打算做出的性能更改非常有用。
- en: 'Imagine you’d like to see how much time it takes to sum the integers from 0
    to 999\. To time this activity from the command line, you can invoke the timeit
    module with Python:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想要看到求和从0到999的整数所需的时间。要从命令行计时这个活动，你可以使用Python调用timeit模块：
- en: '[PRE62]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will cause timeit to run the summation code many times, ultimately printing
    some statistics about the execution time:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致timeit多次运行求和代码，最终打印出一些关于执行时间的统计数据：
- en: '[PRE63]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You can conclude from this output that the summation of 0–999 generally takes
    less than 20 microseconds.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，你可以得出结论，求和0–999通常需要少于20微秒。
- en: 'To see how summing 0–4999 affects the outcome, you can change your command
    and rerun it:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看求和0–4999如何影响结果，你可以更改你的命令并重新运行它：
- en: '[PRE64]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: From this, you can conclude that summing the integers 0–4999 takes a little
    over five times longer than 0–999.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个结果中，你可以得出结论，求和整数0–4999所需的时间比0–999多出五倍以上。
- en: Keep in mind that timeit is really running your code, and real-world execution
    has small variations due to many variables. In addition to the code, things like
    your battery level and CPU clock speed can affect the timing. As such, it’s good
    to run your timing commands a few times to see how stable the measurement is,
    and to look for significant improvements from that baseline when making changes.
    So although timeit gives you quantitative measurements, it’s best to use it to
    compare two different implementations qualitatively, focusing on the trend. This
    is where you’ll notice those order-of-magnitude improvements that noticeably speed
    up your code.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，timeit实际上是在运行你的代码，由于许多变量的影响，现实世界的执行会有小的变化。除了代码之外，像电池水平和CPU时钟速度这样的因素也会影响计时。因此，运行你的计时命令几次以查看测量的稳定性是好的，当进行更改时，从基线寻找显著的改进。所以尽管timeit提供了定量测量，但最好用它来定性比较两种不同的实现，关注趋势。这就是你将注意到那些数量级改进的地方，这些改进明显加快了你的代码。
- en: 'The command-line interface for timeit is great, but it can be cumbersome when
    you want to test larger or more complex pieces of code. If you need more control
    over what’s being timed, you can use timeit from within your code. If you’d like
    to time a specific portion of code without timing all of the setup code it requires,
    you can separate the setup step so its execution time isn’t included:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: timeit的命令行界面很棒，但当你想要测试更大的或更复杂的代码片段时，可能会有些繁琐。如果你需要更多控制被计时的内容，你可以在你的代码中使用timeit。如果你想计时代码的特定部分而不计时所需的全部设置代码，你可以将设置步骤分开，这样它的执行时间就不会被包括在内：
- en: '[PRE65]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* This code sets the stage for the timing test.**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此代码为计时测试设置场景。**'
- en: '***2* This code executes within the timer.**'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此代码在计时器内执行。**'
- en: '***3* timeit produces a timing result, in milliseconds.**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* timeit产生的计时结果是毫秒。**'
- en: This will end up timing only the `datetime.now()` call without timing the `import`
    needed to make the call.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只计时`datetime.now()`调用，而不计时执行调用所需的`import`。
- en: Suppose you’d like to prove that checking whether an item is in a set is faster
    than checking if it’s in a list. How would you do that using the timeit module?
    Build your inputs using `set(range(10000))` and `list(range(10000))`, and time
    the task of finding out if `300` is in them. How much faster is the set?
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想证明检查一个元素是否在集合中比检查它是否在列表中更快。你将如何使用timeit模块来做这件事？使用`set(range(10000))`和`list(range(10000))`构建输入，并计时查找`300`是否在其中的任务。集合快了多少？
- en: The timeit module has saved me from going down a rabbit hole a number of times
    by telling me my hypothesis about speeding up some code was wrong. It’s a real
    time-saver (pun absolutely intended).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: timeit模块多次救我于水火之中，因为它告诉我关于加速某些代码的假设是错误的。它真的节省了时间（绝对是有意为之）。
- en: 4.4.2\. CPU profiling
  id: totrans-602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. CPU分析
- en: When you were using timeit, the module was *profiling* your code. Profiling
    means analyzing your code as it runs to gather some metrics about its behavior.
    The timeit module measured how long your code took to run in total, but another
    insightful way to measure the performance of your code is through CPU profiling.
    CPU profiling lets you see which *parts* of your code perform expensive calculations,
    as well as how often they’re called. This kind of output is useful because it
    helps you understand where you might want to look first when trying to speed up
    your code.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用timeit时，该模块正在对你的代码进行*分析*。分析意味着在代码运行时分析它以收集一些关于其行为的指标。timeit模块测量你的代码运行所需的总时间，但衡量你的代码性能的另一种有洞察力的方式是通过CPU分析。CPU分析让你可以看到你的代码中哪些*部分*执行了昂贵的计算，以及它们被调用的频率。这种输出很有用，因为它可以帮助你了解在尝试加速代码时，你首先想看哪里。
- en: Suppose you’ve written a function that isn’t too expensive but is called many
    times in your application. You’ve also written a function that is expensive but
    is only called once. If you only have time to fix one, which will it be? Without
    profiling the code, it’s hard to know which will speed up your code the most.
    You can figure it out using Python’s cProfile module.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你编写了一个函数，它不是特别昂贵，但在你的应用程序中被多次调用。你还编写了一个昂贵的函数，但它只被调用一次。如果你只有时间修复一个，你会选择哪一个？不进行代码分析，很难知道哪个可以最快地加速你的代码。你可以使用Python的cProfile模块来找出答案。
- en: '|  |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you try to import the cProfile module but get an error, you can use the profile
    module instead.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试导入cProfile模块但得到错误，你可以使用profile模块代替。
- en: '|  |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The cProfile module prints a few pieces of information about each method or
    function called while executing your program. For each call, it will show you
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: cProfile模块在执行你的程序时打印出关于每个被调用的方法或函数的一些信息。对于每次调用，它将显示
- en: The number of times the call occurred (`ncalls`)
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用的次数（`ncalls`）
- en: The time spent in that call alone, not including things it calls in turn (`tottime`)
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这次调用中单独花费的时间，不包括它依次调用的东西（`tottime`）
- en: The average time spent in that call alone, across the `ncalls` times it was
    called (`percall`)
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这次调用中平均花费的时间，跨`ncalls`次调用（`每调用一次`）
- en: The cumulative time spent in that call, including any time spent in subcalls
    (`cumtime`)
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这次调用中累积花费的时间，包括在子调用中花费的时间（`cumtime`）
- en: This information is helpful because it will expose things that are slow—that
    have a large `cumtime`—but will also expose things that are fast but called many
    times. The following listing shows a toy program that calls a function 1000 times.
    The function call takes a random amount of time, up to 10 milliseconds, to execute.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信息很有用，因为它会揭示那些运行缓慢的东西——具有大的`cumtime`——但也会揭示那些运行速度快但被多次调用的东西。以下列表显示了一个调用函数1000次的玩具程序。函数调用执行所需的时间是随机的，最多10毫秒。
- en: Listing 4.4\. Profiling the CPU performance of a Python program
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.4\. 分析Python程序的CPU性能
- en: '[PRE66]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* Takes a random amount of time (up to 10 milliseconds) to execute**'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 执行所需时间随机（最多10毫秒）**'
- en: '***2* Runs the function 1000 times**'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 运行函数1000次**'
- en: 'Save this program in a cpu_profiling.py module. Then you can profile it from
    the command line using cProfile:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 将此程序保存在cpu_profiling.py模块中。然后你可以使用cProfile从命令行进行分析：
- en: '[PRE67]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Over a large number of calls, you can expect a function that takes 0–10 milliseconds
    to take about 5 milliseconds on average (`percall`). Calling it 1000 times (`ncalls`),
    you can expect it to take about 5 seconds overall (`cumtime`). Run cProfile on
    the program to see if it meets your expectations. You will see a lot of output,
    but sorting by cumulative time means `an_expensive_function` calls will be near
    the top:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量调用中，你可以预期一个耗时0-10毫秒的函数平均大约需要5毫秒（`每调用一次`）。调用它1000次（`ncalls`），你预计总共需要大约5秒（`cumtime`）。运行cProfile程序以查看它是否符合你的预期。你会看到很多输出，但按累积时间排序意味着`an_expensive_function`的调用将接近顶部：
- en: '[PRE68]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this run, `an_expensive_function` took an average of about 6 milliseconds
    per call over the span of 1000 calls, leading to a cumulative 5.625 seconds spent
    inside that function.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次运行中，`an_expensive_function`在1000次调用中平均每次调用大约花费了6毫秒，导致该函数内部总共花费了5.625秒。
- en: When looking at the output of cProfile, you’ll want to search for calls with
    a high `percall` value or a big jump in `cumtime`. These characteristics mean
    the call takes up a good chunk of your program’s execution time. Speeding up a
    slow function can improve the program speed a fair amount, and cutting the execution
    time of a function that’s called thousands of times can be a really big win.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看cProfile的输出时，你会想要寻找具有高`percall`值或`cumtime`大幅增加的调用。这些特征意味着调用占用了你程序执行时间的好大一部分。加快慢速函数的速度可以显著提高程序速度，而减少被调用数千次的函数的执行时间可以带来巨大的收益。
- en: 4.5\. Try it out
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 尝试一下
- en: Consider the following code. It contains a function, `sort_expensive`, that
    has to sort a list of 1000 integers in the range 0–999,999\. It also contains
    a function, `sort_cheap`, that only has to sort a list of 10 integers in the range
    0–999.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码。它包含一个函数`sort_expensive`，该函数必须对0到999,999范围内的1000个整数进行排序。它还包含一个函数`sort_cheap`，该函数只需要对0到999范围内的10个整数进行排序。
- en: Sorting algorithms are generally more expensive than *O*(1), so the `sort_expensive`
    function will take longer than `sort_cheap`. If you only ran each function once,
    `sort_cheap` would surely win. But if you need to run `sort_cheap` 1,000 times,
    it’s less clear which operation will be fastest.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法通常比*O*(1)更昂贵，所以`sort_expensive`函数将比`sort_cheap`函数耗时更长。如果你只运行每个函数一次，`sort_cheap`肯定能赢。但如果你需要运行`sort_cheap`
    1,000次，哪个操作会更快就不是很明确了。
- en: '[PRE69]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You need to profile the code to understand the performance. See how each task
    fares using the timeit and cProfile modules.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要分析代码以了解性能。使用timeit和cProfile模块查看每个任务的表现。
- en: Summary
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Design for performance both up front and iteratively throughout your development.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中，从一开始就设计性能，并迭代改进。
- en: Think carefully about the right data type for the task.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细考虑适合任务的正确数据类型。
- en: Prefer generators over lists when you don’t need all the values at once, to
    save on memory usage.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你不需要一次性获取所有值时，优先使用生成器而不是列表，以节省内存使用。
- en: Use the timeit and cProfile/profile Python modules to test your hypotheses about
    complexity and performance.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用timeit和cProfile/profile Python模块来测试你对复杂性和性能的假设。
- en: Chapter 5\. Testing your software
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 测试你的软件
- en: '*This chapter covers*'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding the anatomy of a test
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试的构成
- en: Using different testing approaches for your application
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的应用程序使用不同的测试方法
- en: Writing tests with the unittest framework
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用unittest框架编写测试
- en: Writing tests with the pytest framework
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pytest框架编写测试
- en: Adopting test-driven development
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用测试驱动开发
- en: I’ve talked in previous chapters about writing clear code using well-named functions
    for maintainability, but that’s only part of the picture. As you add feature after
    feature, can you be sure the application still does what you meant it to? Any
    application you hope will live on long into the future needs some assurances of
    its longevity. Tests can help you make sure new features are built correctly,
    and you can run these tests again each time you update your code to make sure
    it *stays* correct.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我在之前的章节中谈到了使用具有良好命名的函数编写清晰代码以提高可维护性，但这只是问题的一部分。随着你添加一个又一个功能，你能确保应用程序仍然按照你的意图运行吗？任何希望长期存在的应用程序都需要对其长期性的保证。测试可以帮助你确保新功能被正确构建，并且每次你更新代码时都可以运行这些测试来确保它*保持*正确。
- en: Testing can be a strict, formal process for applications that must not fail,
    like launching shuttles and keeping planes in flight. Such tests are rigorous
    and often mathematically provable. That’s pretty cool, but it goes way beyond
    what’s necessary or practical for most Python applications. In this chapter, you’ll
    learn about the methodology and tools Python developers use to test their code,
    and you’ll get a chance to write some tests yourself.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 对于必须不失败的应用程序，如发射航天器和保持飞机飞行，测试可以是一个严格、正式的过程。这些测试是严格的，并且通常是数学上可证明的。这很酷，但这对大多数Python应用程序来说既不必要也不实用。在本章中，你将了解Python开发者使用的测试方法和工具，并有机会亲自编写一些测试。
- en: 5.1\. What is software testing?
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 什么是软件测试？
- en: Loosely speaking, *software testing* is the practice of verifying that software
    behaves the way you expect. This can range from making sure a function produces
    the expected output when given a specific input to making sure your application
    can handle the stress of 100 users at once. As developers, we constantly do some
    form of this subconsciously. If you’re developing a website, you probably run
    the server locally and check your changes in the browser as you code. This is
    a form of testing.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 通俗地说，*软件测试*是验证软件是否按预期行为的一种实践。这可以从确保一个函数在给定特定输入时产生预期的输出，到确保你的应用程序能够处理100个用户同时的压力。作为开发者，我们不断地无意识地做这种形式的测试。如果你正在开发一个网站，你可能会在本地运行服务器，并在编码时在浏览器中检查你的更改。这是一种测试形式。
- en: You might think that spending more time validating that your code works means
    less time shipping software. In the immediate term, this is true, especially as
    you get acquainted with the tools and processes related to testing. The idea in
    the long term, though, is that testing will *save* you time by limiting the recurrence
    of behavior and performance bugs and by providing a scaffolding you can use to
    confidently refactor code in the future. The more critical a piece of code is
    to your business, the more time you’ll want to spend testing it thoroughly.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为花更多时间验证你的代码是否工作意味着更少的时间来发布软件。在短期内，这是真的，尤其是在你熟悉与测试相关的工具和流程时。但从长远来看，测试将通过限制行为和性能错误的复发，并提供你可以用来在未来自信地重构代码的框架，来为你节省时间。代码对你的业务越关键，你愿意花在彻底测试它上的时间就越多。
- en: 5.1.1\. Does it do what it says on the tin?
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 它是否如其名？
- en: One reason to test a piece of software is to determine whether it really does
    what it claims. A well-named function describes its intent to the reader, but,
    as they say, the road to hell is paved with good intentions. I can’t count the
    number of times I wrote a function, fully believing it was faithfully carrying
    out its intended purpose, only to find out later that I’d made a mistake.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 测试软件的一个原因是要确定它是否真的做了它声称的事情。一个命名良好的函数向读者描述了其意图，但正如人们所说，通往地狱的道路是由好意图铺成的。我无法计算我写了多少次函数，完全相信它忠实于其预期目的，结果却发现我犯了一个错误。
- en: Sometimes these mistakes are easy to catch—a typo or exception in an area of
    code you’re familiar with might be easy to track down. The trickier bugs to find
    are those that don’t cause immediate issues but cascade as the application progresses.
    With good testing, problems can be found early, and you can guard your application
    from similar issues in the future. A number of categories of testing exist, each
    focused on identifying particular kinds of problems. I’ll cover a few here, but
    you can be sure this is not an exhaustive list.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这些错误很容易被发现——在你熟悉的代码区域中的一个打字错误或异常可能很容易追踪。更难发现的错误是那些不会立即引起问题，但随着应用程序的进展而级联的错误。通过良好的测试，可以在早期发现问题，并保护你的应用程序免受未来类似问题的困扰。存在多种测试类别，每个类别都专注于识别特定类型的问题。我将在下面介绍一些，但你可以确信这不是一个详尽的列表。
- en: 5.1.2\. The anatomy of a functional test
  id: totrans-650
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 功能测试的结构
- en: You saw earlier that testing can make sure software produces the right output
    for a given input. This type of testing is called *functional testing* because
    it makes sure that a piece of code *functions* correctly. This is in contrast
    to other types of testing, such as performance testing, which I’ll cover in [section
    5.6](#ch05lev1sec6).
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到，测试可以确保软件为给定的输入产生正确的输出。这种类型的测试被称为*功能测试*，因为它确保代码*功能*正确。这与其他类型的测试形成对比，例如性能测试，我将在[第5.6节](#ch05lev1sec6)中介绍。
- en: 'Although functional testing strategies vary in scale and approach, the basic
    anatomy of a functional test remains consistent. Because they check that software
    gives the right output based on a given input, all functional tests need to perform
    a few specific tasks, including the following:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管功能测试策略在规模和方法上有所不同，但功能测试的基本结构始终保持一致。因为它们检查软件是否根据给定的输入产生正确的输出，所以所有功能测试都需要执行一些特定的任务，包括以下内容：
- en: '*Prepare the inputs* to the software.'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*准备软件的输入*。'
- en: '*Identify the expected output* of the software.'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*确定软件的预期输出*。'
- en: '*Obtain the actual output* of the software.'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*获取软件的实际输出*。'
- en: '*Compare the actual and the expected outputs* to see if they match.'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*比较实际输出和预期输出*，以查看它们是否匹配。'
- en: The preparation of inputs and identification of expected outputs are where most
    of your work as a developer will be when creating tests, whereas obtaining and
    comparing the actual output is a matter of executing your code, as shown in [figure
    5.1](#ch05fig01).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 准备输入和识别预期输出是你在创建测试时作为开发人员的大部分工作，而获取和比较实际输出则是执行你的代码的问题，如图 5.1 所示。
- en: Figure 5.1\. The basic flow of a functional test
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1. 功能测试的基本流程
- en: '![](../Images/f0102-01.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0102-01.jpg)'
- en: 'Structuring your tests this way has another beneficial effect: you can read
    your tests as a specification of how the code works. This pays off when you revisit
    code you wrote long ago (or last week, for me). A good test for a `calculate_mean`
    function might read like this:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建测试还有另一个有益的效果：你可以将测试读作代码工作方式的规范。当你再次回顾你很久以前（或对我来说是上周）编写的代码时，这会很有帮助。一个针对
    `calculate_mean` 函数的良好测试可能如下所示：
- en: '*Given the list of integers* `[1, 2, 3, 4]`, *the expected output of* `calculate_mean`
    *is* `2.5`. *Verify that the actual output of* `calculate_mean` *matches this
    expectation*.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '*给定整数列表* `[1, 2, 3, 4]`，*`calculate_mean` 的预期输出是* `2.5`。*验证 `calculate_mean`
    的实际输出是否与这个预期相符*。'
- en: 'This format scales to larger functional workflows. In an e-commerce system,
    the “input” might be clicking a product and then clicking Add to Cart. The expected
    “output” is the item being added to the cart. A functional test for that workflow
    would read like this:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式可以扩展到更大的功能工作流程。在一个电子商务系统中，“输入”可能是点击一个产品然后点击“添加到购物车”。预期的“输出”是将项目添加到购物车中。对该工作流程的功能测试可能如下所示：
- en: '*Given I visit the page for product* `53-DE-232` *and click Add to Cart, I
    expect to see* `53-DE-232` *in my cart*.'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设我访问了产品页面* `53-DE-232` *并点击“添加到购物车”，我期望看到* `53-DE-232` *出现在我的购物车中*。'
- en: Ultimately, it’s nice when your tests not only verify that your code works,
    but also act as documentation on how to use it. In the next section, you’ll see
    how this recipe for writing a functional test applies to some different testing
    approaches.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当你的测试不仅验证了你的代码是否工作，还充当了如何使用它的文档时，这会很好。在下一节中，你将看到编写功能测试的这种配方如何应用于不同的测试方法。
- en: 5.2\. Functional testing approaches
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2. 功能测试方法
- en: Functional testing takes on many forms in practice. From the constant little
    checks we do as developers to fully automated tests that get kicked off before
    every production deployment, there is a spectrum of practices and capabilities.
    You’ll recognize some of the following types of testing, but I recommend reading
    about each of them to understand the similarities and differences between them.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，功能测试采取了多种形式。从我们作为开发者所做的持续的小检查到在生产部署之前启动的完全自动化测试，存在一系列实践和能力。你将认识到以下测试类型中的一些，但我建议阅读关于它们的每一篇，以了解它们之间的相似性和差异。
- en: 5.2.1\. Manual testing
  id: totrans-667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1. 手动测试
- en: '*Manual testing* is the practice of running your application, giving it some
    inputs, and checking whether it does what you expect. For example, if you’re writing
    a registration workflow for a website, you would enter a username and password
    and make sure a new user is created. If you have password requirements, you would
    want to check that using an invalid password does *not* create a new user. Similarly,
    you’d test for the case where a user with the username you choose already exists.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '*手动测试* 是运行你的应用程序，给它一些输入，并检查它是否按预期工作的实践。例如，如果你正在为网站编写注册工作流程，你会输入用户名和密码，并确保创建了一个新用户。如果你有密码要求，你希望检查使用无效密码不会创建新用户。同样，你会测试你选择的用户名已经存在的情况。'
- en: Registering on a website is generally a small (and one-time) part of the product
    experience for most users, but, as you can see, you already have to verify several
    cases. If any of these things go wrong, your users either can’t register or might
    have their account information overwritten. With this code being so important,
    relying on manual testing for too long will eventually cause you to miss something.
    Manually exploring the application for new bugs or new things to test is still
    a valuable activity, but it should be viewed as a supplement to other types of
    testing.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站上注册通常是大多数用户产品体验中一个小（且一次性）的部分，但正如你所看到的，你已经有几个需要验证的情况。如果其中任何一项出错，你的用户可能无法注册，或者他们的账户信息可能会被覆盖。鉴于这段代码如此重要，长期依赖手动测试最终会导致你错过某些东西。手动探索应用程序以寻找新的错误或新的测试内容仍然是一项有价值的活动，但它应该被视为其他类型测试的补充。
- en: 5.2.2\. Automated testing
  id: totrans-670
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2. 自动化测试
- en: In contrast to manual testing, *automated testing* allows you to write a great
    number of tests that can then be executed as many times as you like, without the
    risk that you’ll miss a check when you’re trying to leave the office the Friday
    of a long weekend. If this hypothetical situation seems overly specific, that’s
    because it’s not hypothetical. I’ve lived it.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动测试相比，*自动化测试*允许你编写大量测试，然后可以执行任意次数，而不会在试图在长周末的周五离开办公室时错过检查。如果这个假设的情况看起来过于具体，那是因为它不是假设的。我经历过。
- en: Automated testing tightens the feedback loop so that you can see quickly whether
    a change you’ve made has broken an expected behavior. The time you’ll save compared
    to manual testing will free you up to do more creative exploratory testing of
    the application. As you uncover things to fix, you should incorporate them into
    your automated tests. You can think of this as locking in a verification that
    will make sure the particular bug doesn’t happen again. Most of the testing you’ll
    see in the rest of this chapter can be, and often is, automated.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试缩小了反馈循环，这样你可以快速看到你所做的更改是否破坏了预期的行为。与手动测试相比，你将节省的时间将使你能够进行更多富有创造性的探索性测试。当你发现需要修复的问题时，你应该将它们纳入你的自动化测试中。你可以将此视为锁定一个验证，以确保特定的错误不再发生。本章其余部分中你将看到的测试大多数可以，并且通常都是自动化的。
- en: 5.2.3\. Acceptance testing
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. 验收测试
- en: Closest in nature to the Add to Cart workflow test, *acceptance testing* verifies
    the high-level requirements of a system. Software that passes these tests is *acceptable*
    based on the specified requirements. As shown in [figure 5.2](#ch05fig02), acceptance
    tests answer questions like, “Can the user successfully go through the purchase
    workflow and buy the product they want?” These are the mission-critical checks
    for the business—things that keep the lights on.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加到购物车工作流程测试最相似的是，*验收测试*验证系统的整体需求。通过这些测试的软件根据指定的要求是*可接受的*。如图5.2所示，验收测试回答了诸如“用户能否成功完成购买工作流程并购买他们想要的产品？”等问题。这些都是业务的关键检查——保持业务运转的事情。
- en: Figure 5.2\. Acceptance tests verify workflows from a user’s perspective.
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 验收测试从用户的角度验证工作流程。
- en: '![](../Images/f0104-01_alt.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0104-01_alt.jpg)'
- en: Acceptance tests are often carried out manually by a business stakeholder, but
    they can also be automated to a degree with *end-to-end testing*. End-to-end testing
    makes sure a set of actions can be carried out (from one end to the other) with
    the appropriate data flowing through where needed. If the workflow is expressed
    from the viewpoint of the user, it begins to look almost exactly like the Add
    to Cart workflow.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试通常由业务利益相关者手动执行，但也可以通过*端到端测试*在一定程度上实现自动化。端到端测试确保一系列操作（从一端到另一端）可以在需要的地方流动适当的数据。如果从用户的角度表达工作流程，它几乎看起来与添加到购物车工作流程完全一样。
- en: '|  |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Testing is for everyone**'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试是每个人的事**'
- en: Libraries like Cucumber (https://cucumber.io) enable you to describe end-to-end
    tests in natural language as high-level actions, like “click the Submit button.”
    These tests are often much easier to understand than a big mess of code. Writing
    steps in natural language documents the system in a way most anyone in the organization
    can understand.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Cucumber（https://cucumber.io）这样的库，允许你使用自然语言描述端到端测试，如高级动作，例如“点击提交按钮”。这些测试通常比一大堆代码更容易理解。在自然语言文档中编写步骤以记录系统，这样组织中的任何人都可以理解。
- en: This idea of *behavior-driven development* (BDD) allows you to collaborate with
    others on end-to-end testing, even if they don’t have experience with software
    development in a coding capacity. BDD is used in many organizations as a way to
    define the desired outcomes first, only implementing the code to make the tests
    pass afterward.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于*行为驱动开发*（BDD）的想法让你能够在端到端测试中与他人协作，即使他们没有在编码能力方面的软件开发经验。许多组织使用BDD作为一种方法，首先定义期望的结果，然后仅实现代码以确保测试通过。
- en: '|  |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: End-to-end tests commonly verify areas of high value for the business—if the
    cart doesn’t work, no one can buy products, and you lose revenue—but they are
    also the most susceptible to breaking because they span such a wide swathe of
    functionality. If any one step in the workflow doesn’t work, the whole end-to-end
    test fails. Creating a set of tests that vary in granularity will help indicate
    not only whether the whole workflow is healthy, but also which steps are failing
    specifically. This allows you to pinpoint problems faster.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试通常验证对业务价值较高的区域——如果购物车不工作，没有人可以购买产品，你将失去收入——但它们也最容易出问题，因为它们跨越了如此广泛的功能范围。如果工作流程中的任何一步不起作用，整个端到端测试都会失败。创建一系列具有不同粒度的测试可以帮助表明整个工作流程是否健康，以及哪些步骤具体失败。这允许你更快地定位问题。
- en: End-to-end tests are some of the *least* granular, so what’s on the other end
    of the spectrum?
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是**最不**细粒度的，那么光谱的另一端是什么呢？
- en: 5.2.4\. Unit testing
  id: totrans-685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4. 单元测试
- en: '*Unit testing* is perhaps the most important thing you can take away from this
    chapter. Unit tests make sure all the little bits of your software are working,
    and they lay a strong foundation for larger testing efforts like end-to-end testing.
    I’ll show you how to get started with unit testing in Python in [section 5.4](#ch05lev1sec4).'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**可能是你可以从这个章节中学到的最重要的东西。单元测试确保你软件的所有小部分都在正常工作，并为更大规模的测试工作，如端到端测试，奠定了坚实的基础。我将在[第5.4节](#ch05lev1sec4)中向你展示如何开始使用Python进行单元测试。'
- en: '|  |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A *unit* is a small, fundamental piece of software—like the “unit” in “unit
    circle.” What constitutes a unit is the source of much philosophical waxing, but
    a good working definition is that it’s a piece of code that can be isolated for
    testing. Functions are generally considered units—they can be executed in isolation
    by calling them with the appropriate inputs. Lines of code within those functions
    can’t be isolated, so they’re smaller than a unit. Classes contain many pieces
    that can be isolated further, so they’re generally bigger than a unit, but they
    are occasionally treated as units.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元**是软件的一个小型、基本的部分——就像“单位圆”中的“单位”。构成单元的是什么，这是许多哲学思考的源头，但一个良好的工作定义是，它是一段可以用于测试的代码。函数通常被认为是单元——它们可以通过使用适当的输入来独立执行。那些函数内的代码行无法独立，所以它们比单元小。类包含许多可以进一步分离的部分，所以它们通常比单元大，但它们偶尔也被视为单元。'
- en: '|  |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Unit testing seeks to verify that all the individual units of code in your application
    work correctly, that each small piece of the software does what it says it does.
    These are the most fundamental tests you can write and are therefore a great place
    to get started with testing.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试旨在验证你应用程序中所有单个代码单元是否正常工作，每个软件的小部分都做它所说的。这些是你能写的最基础的测试，因此是开始测试的绝佳起点。
- en: Functions are the most common target of functional unit tests. “Function” is
    right there in the name, after all. This is because of functions’ input-output
    nature. If you’ve separated the concerns of your code into small functions, testing
    them will be a straightforward application of the functional testing recipe.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是功能单元测试最常见的目标。毕竟，“函数”就在名字中。这是因为函数的输入-输出特性。如果你已经将代码的关注点分离成小的函数，测试它们将是功能测试食谱的直接应用。
- en: It turns out that one of the great benefits of structuring your code using separation
    of concerns, encapsulation, and loose coupling is that it makes code easier to
    test. Testing can feel tedious, so any opportunity to reduce friction is welcome.
    The easier the code is to test, the more likely it is that you’ll *write* those
    tests in the first place, so you can reap the reward of confidence in your software.
    Units are the small, separated pieces you naturally arrive at by sticking with
    the practices you’ve learned so far.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，使用关注点分离、封装和松散耦合来结构化你的代码的一大好处是，这使得代码更容易进行测试。测试可能会感觉枯燥乏味，所以任何减少摩擦的机会都受欢迎。代码越容易测试，你最初就越有可能编写那些测试，从而可以享受到对你软件的信心带来的回报。单元是你在坚持到目前为止学到的实践的基础上自然到达的小型、分离的部分。
- en: 'Most unit tests in Python compare expected and actual outputs using a simple
    equality comparison. You can do one of these yourself right now. Open the Python
    REPL and create this `calculate_mean` function:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python单元测试使用简单的相等比较来比较预期和实际输出。你现在就可以自己做一个。打开Python交互式解释器，创建这个`calculate_mean`函数：
- en: '[PRE70]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now you can test your expectations of this function with a few different inputs,
    comparing the output to your expected results:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过一些不同的输入来测试你对这个函数的预期，比较输出与你的预期结果：
- en: '[PRE71]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Try a few other lists of numbers in the REPL now to verify that `calculate_mean`
    is giving the right results. Think of useful sets of inputs that might change
    the behavior of the function:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 REPL 中尝试一些其他的数字列表，以验证“calculate_mean”是否给出了正确的结果。考虑一些可能改变函数行为的输入集合：
- en: Does it work correctly with negative numbers?
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否正确处理负数？
- en: Does it work when the list of numbers contains `0`?
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数字列表中包含 `0` 时，它是否有效？
- en: Does it work when the list is empty?
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当列表为空时，它是否有效？
- en: These kinds of curiosities are worth writing tests for. They occasionally uncover
    questions you haven’t accounted for in your code, which gives you an opportunity
    to address those questions before someone finds out the hard way that a particular
    use case wasn’t considered.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 这类好奇心值得编写测试。它们偶尔会揭示你在代码中没有考虑到的问题，这给你一个机会在有人通过艰难的方式发现特定用例未考虑之前解决这些问题。
- en: '[PRE72]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* Raises an exception for a case you haven’t considered yet**'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对于尚未考虑的情况抛出异常**'
- en: 'You can fix `calculate_mean` by returning `0` if the list is empty:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过如果列表为空则返回 `0` 来修复“calculate_mean”：
- en: '[PRE73]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Great—`calculate_mean` has passed all the cases we’ve thrown at it. Remember
    that unit tests are the foundation that enables success in larger testing efforts,
    like end-to-end testing. To understand that relationship better, we’ll look at
    two other testing categories in the following sections.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——“calculate_mean”通过了我们向其投掷的所有测试用例。记住，单元测试是使更大测试努力（如端到端测试）成功的基础。为了更好地理解这种关系，我们将在接下来的几节中查看其他两个测试类别。
- en: 5.2.5\. Integration testing
  id: totrans-708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5\. 集成测试
- en: Whereas unit tests are all about making sure the individual pieces of your code
    work as expected, *integration testing* focuses on making sure those units all
    work in tandem to produce the right behavior (see [figure 5.3](#ch05fig03)). You
    may have 10 fully functional units of software, but if they can’t be put together
    to do what you want, they aren’t too useful. Whereas end-to-end workflow tests
    are usually framed from the perspective of a user, integration tests focus more
    on the behavior of the code. They’re at different levels of abstraction.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试都是确保你的代码各个部分按预期工作，但*集成测试*专注于确保这些单元协同工作以产生正确的行为（见[图 5.3](#ch05fig03)）。你可能拥有
    10 个完全功能的软件单元，但如果它们不能组合起来完成你想要的功能，它们就不是很有用。而端到端工作流程测试通常从用户的角度来构建，集成测试则更多地关注代码的行为。它们处于不同的抽象层次。
- en: Figure 5.3\. Integration tests focus on how operations work together.
  id: totrans-710
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3\. 集成测试关注操作如何协同工作。
- en: '![](../Images/f0105-01_alt.jpg)'
  id: totrans-711
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0105-01_alt.jpg)'
- en: Integration testing carries several caveats, though. Because integration tests
    need to thread multiple pieces of code together, it’s common to build tests that
    are structured much like the code they’re testing. This introduces tight coupling
    between the tests and the code—changes in the code that produce the same outcome
    might still cause the tests to break, because the tests are too concerned with
    *how* the outcome is achieved.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管集成测试有几个注意事项。因为集成测试需要将多个代码片段串联起来，所以构建与被测试代码结构相似的测试是很常见的。这会在测试和代码之间引入紧密耦合——产生相同结果的代码更改仍可能导致测试失败，因为测试过于关注*如何*实现结果。
- en: Integration tests may take significantly longer to execute than unit tests.
    They generally do more than execute some functions and check the output; they
    might use a database to create and manipulate records, as an example. The interaction
    being tested is more complex, so the time required to carry it out can grow. For
    these reasons, integration tests are usually fewer in number than unit tests.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可能比单元测试执行时间更长。它们通常不仅仅是执行一些函数并检查输出；例如，它们可能使用数据库来创建和操作记录。被测试的交互更复杂，因此执行所需的时间可能会增加。出于这些原因，集成测试的数量通常比单元测试少。
- en: 5.2.6\. The testing pyramid
  id: totrans-714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.6\. 测试金字塔
- en: Now that you’ve seen manual, unit, and integration testing, let’s recap the
    interplay between them. The idea of a testing pyramid like that in [figure 5.4](#ch05fig04)
    indicates that you should liberally apply functional tests like unit and integration
    tests, but be more conservative with long, brittle, and manual tests.^([[1](#ch05fn01)])
    Each has merit, and your mileage will depend on the application and the resources
    at your disposal, but it’s a decent rule of thumb about where to invest time.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了手动、单元和集成测试，让我们回顾一下它们之间的相互作用。像[图5.4](#ch05fig04)中那样的测试金字塔理念表明，你应该自由地应用功能测试，如单元和集成测试，但对于长、脆弱和手动测试则应更加谨慎。[1](#ch05fn01)]
    每种方法都有其优点，你的效果将取决于应用程序和可用资源，但这是一个关于如何投资时间的合理经验法则。
- en: ¹
  id: totrans-716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Testing pyramids were first described by Mike Cohn in *Succeeding with Agile*
    (Addison-Wesley Professional, 2009).
  id: totrans-718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 测试金字塔最早由Mike Cohn在《Succeeding with Agile》（Addison-Wesley Professional，2009年）中描述。
- en: Figure 5.4\. The testing pyramid
  id: totrans-719
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. 测试金字塔
- en: '![](../Images/f0105-02_alt.jpg)'
  id: totrans-720
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0105-02_alt.jpg)'
- en: You’ll get the most bang for your buck by making sure the little pieces of software
    are all working, then making sure they all work together. Again, automating this
    process will empower you to use the time you’ve freed up to think of new ways
    your software might break. You can then incorporate those ideas as new tests and
    slowly build confidence that will carry you forward.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保软件的各个小部分都正常工作，然后确保它们都能协同工作，你可以获得最大的效益。再次强调，自动化这一过程将使你能够利用节省出来的时间来思考软件可能出错的新方法。然后你可以将这些想法作为新的测试纳入，并逐渐建立信心，这将支持你前进。
- en: 5.2.7\. Regression testing
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.7\. 回归测试
- en: '*Regression testing* is less an approach to testing per se, and more a process
    to follow as you develop your applications. When you write a test, the assumption
    is that you’re saying, “I want to make sure the code keeps working this way.”
    If you change your code in a way that changes the behavior you tested, that would
    be a *regression*. A regression is a shift to an undesirable (or at least unexpected)
    state and is usually A Bad Thing.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '*回归测试*与其说是一种测试方法，不如说是一种在开发应用程序时遵循的过程。当你编写测试时，假设你是在说，“我想确保代码保持这种方式运行。”如果你以改变测试行为的方式更改代码，那将是一个*回归*。回归是一种向不希望（或至少是意外）的状态的转变，通常是不好的事情。'
- en: Regression testing is the practice of running your existing suite of tests after
    each code change before shipping your code to production. A *test suite* is the
    collection of tests you’ve built up over time, either written to verify code as
    unit/integration tests or to fix things found in exploratory manual testing. Many
    development teams run these test suites in a *continuous integration* (CI) environment,
    where changes to an application are frequently combined and tested before being
    released. A full discussion of CI is beyond the scope of this book, but the idea
    is to set yourself up for success by running all your tests against all your changes.
    I highly recommend checking out Travis CI (https://docs.travis-ci.com/user/for-beginners/)
    or CircleCI (https://circleci.com/ docs/2.0/about-circleci/) to learn more.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试是在将代码部署到生产环境之前，运行你现有的测试套件的一种实践。*测试套件*是你随着时间的推移所积累的测试集合，这些测试可能是为了验证代码作为单元/集成测试，或者是为了修复在探索性手动测试中发现的错误。许多开发团队在*持续集成*（CI）环境中运行这些测试套件，在那里应用程序的更改经常被合并并测试，然后再发布。本书不涉及CI的全面讨论，但理念是通过运行所有测试来确保所有更改的成功。我强烈推荐查看Travis
    CI（https://docs.travis-ci.com/user/for-beginners/）或CircleCI（https://circleci.com/docs/2.0/about-circleci/）以了解更多信息。
- en: '|  |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Version control hooks**'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本控制钩子**'
- en: One practice for automating unit tests in source control systems is using a
    precommit hook. Each time you commit your code, the hook triggers the tests to
    run. If any failures occur, the commit fails, and you’re reminded to fix them
    before committing your code. Most unit-testing tools should integrate with this
    approach pretty well. Running the tests again in a continuous integration environment
    makes sure that they pass just before the code is deployed.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码控制系统中自动化单元测试的一种实践是使用precommit钩子。每次你提交代码时，钩子都会触发测试运行。如果发生任何失败，提交将失败，你将被告知在提交代码之前修复它们。大多数单元测试工具都应该很好地与这种方法集成。在持续集成环境中再次运行测试确保在代码部署前测试通过。
- en: '|  |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As new features are added, new tests get added to the test suite. These get
    locked in as regression tests for future changes. Similarly, it’s common to add
    tests for bugs that you find, so that you can build confidence that a particular
    bug won’t reoccur. Like code, test suites won’t always be perfect. But leaning
    on a robust suite to tell you when things go awry can help you focus on other
    areas, like innovation and performance.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新功能的添加，新的测试会被添加到测试套件中。这些测试被锁定为回归测试，以应对未来的更改。同样，添加你发现的错误测试也很常见，这样你可以建立信心，确信特定的错误不会再次发生。就像代码一样，测试套件并不总是完美的。但依靠一个健壮的套件来告诉你事情出错，可以帮助你专注于其他领域，如创新和性能。
- en: With that, let’s see how you can start writing tests in Python.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们看看如何在 Python 中开始编写测试。
- en: 5.3\. Statements of fact
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3. 事实陈述
- en: The next step toward creating real tests is to *assert* that a particular comparison
    holds true. Assertions are statements of fact; if you make an assertion that doesn’t
    hold true, either some assumption you’ve made is incorrect or the assertion itself
    is incorrect. If you assert that “you can see the sun on the horizon every morning,”
    it holds true most of the time. But when there are clouds on the horizon, your
    assertion doesn’t hold true. If you update your assumptions to include that the
    sky is clear, your assertion becomes true again.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 创建真实测试的下一步是*断言*某个特定的比较是否成立。断言是事实的陈述；如果你做出的断言不成立，要么是你的一些假设不正确，要么是断言本身不正确。如果你断言“你每天早上都能在地平线上看到太阳”，大多数时候这是成立的。但当地平线上有云时，你的断言就不成立了。如果你更新你的假设以包括天空晴朗，你的断言就再次成立。
- en: Assertions in software are similar. They assert that some expression must hold
    true, and they fail loudly if that assertion fails. In Python, assertions can
    be written using the `assert` keyword. When assertions fail, they raise an `AssertionError`.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中的断言与此类似。它们断言某些表达式必须成立，如果断言失败，则会大声报错。在 Python 中，可以使用 `assert` 关键字编写断言。当断言失败时，它们会引发
    `AssertionError`。
- en: 'You can test `calculate_mean` with assertions by adding `assert` in front of
    your comparisons. A passing assertion will have no output; a failing one will
    show you the traceback for the `AssertionError`:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在比较前添加 `assert` 来使用断言测试 `calculate_mean`。一个通过断言将没有任何输出；一个失败的断言将显示 `AssertionError`
    的回溯信息：
- en: '[PRE74]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This behavior is what many Python testing tools are built on. Using the recipe
    for a functional test (set up input, identify expected output, obtain actual output,
    and compare), these tools help you do the comparison and provide valuable context
    when your assertions fail. Read on to see how two of the most widely used testing
    tools in Python handle making assertions about your code.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是许多 Python 测试工具的基础。使用功能测试的配方（设置输入，确定预期输出，获取实际输出，并比较），这些工具帮助你进行比较，并在你的断言失败时提供有价值的上下文。继续阅读，了解
    Python 中最广泛使用的两个测试工具如何处理对代码的断言。
- en: 5.4\. Unit testing with unittest
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 单元测试与 unittest
- en: Unittest is Python’s built-in testing framework. Although it’s called unittest,
    it can also be used for integration testing. Unittest provides features for making
    assertions about your code, and also the tool for *running* the tests. In this
    section, you’ll see how tests are organized and how to run them, and you’ll finally
    get some practice writing real tests. Let’s get to it!
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest 是 Python 的内置测试框架。尽管它被称为 unittest，但它也可以用于集成测试。Unittest 提供了关于代码的断言功能，以及运行测试的工具。在本节中，你将了解测试是如何组织的，以及如何运行它们，你最终将有机会练习编写真实的测试。让我们开始吧！
- en: 5.4.1\. Test organization with unittest
  id: totrans-739
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1. 使用 unittest 进行测试组织
- en: Unittest provides a set of features for performing assertions. You previously
    saw how to write raw `assert` statements to test code, but unittest provides a
    `TestCase` class with custom assertion methods for more understandable testing
    output. Your tests will inherit from this class and use methods to make assertions.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest 提供了一组用于执行断言的功能。你之前看到了如何编写原始的 `assert` 语句来测试代码，但 unittest 提供了一个 `TestCase`
    类，它具有自定义断言方法，以便更易于理解的测试输出。你的测试将继承这个类，并使用方法来做出断言。
- en: I encourage you to use these test classes as a strategy for grouping your tests.
    The classes are flexible—you can use them to group any tests you like. If you
    have many tests for a class, putting them in their own `TestCase` is a good idea.
    If you have many tests for a single method within a class, you could even create
    a `TestCase` only for those. You learned to use cohesion, namespacing, and separation
    of concerns for code, and you can apply the same ideas to tests.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你使用这些测试类作为分组测试的策略。这些类很灵活——你可以使用它们来分组任何你喜欢的测试。如果你对一个类有很多测试，将它们放在自己的 `TestCase`
    中是个好主意。如果你对一个类中的单个方法有很多测试，甚至可以只为这些创建一个 `TestCase`。你学习了如何使用内聚性、命名空间和关注点分离来编写代码，你也可以将这些想法应用到测试中。
- en: 5.4.2\. Running tests with unittest
  id: totrans-742
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 使用 unittest 运行测试
- en: Unittest provides a test runner that you can use by typing `python -m unittest`
    in your terminal. When you run the unittest test runner, it will look for tests
    by
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest 提供了一个测试运行器，你可以在终端中通过输入 `python -m unittest` 来使用它。当你运行 unittest 测试运行器时，它将通过以下方式查找测试：
- en: Looking in the current directory (and any subdirectories) for modules named
    `test_*` or `*_test`
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前目录（以及任何子目录）中查找名为 `test_*` 或 `*_test` 的模块
- en: Looking in those modules for classes that inherit from `unittest.TestCase`
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些模块中查找继承自 `unittest.TestCase` 的类
- en: Looking in those classes for methods that start with `test_`
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些类中查找以 `test_` 开头的方法
- en: Some people like to put their tests as close to the relevant code as possible,
    making it easier to find tests for a particular module of interest. Others like
    to put all their tests in a tests/ directory that lives at the root of their project
    to keep them separate from the code. I’ve done it both ways and don’t have a strong
    preference myself. Do what works for you, your team, or the community you’re writing
    software with.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人喜欢将他们的测试尽可能接近相关代码，这样更容易找到特定模块的测试。其他人喜欢将所有测试放在项目根目录下的 tests/ 目录中，以将它们与代码分开。我两种方法都试过，自己没有强烈的偏好。做对你、你的团队或你与之一同编写软件的社区有用的事情。
- en: 5.4.3\. Writing your first test with unittest
  id: totrans-748
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3\. 使用 unittest 编写第一个测试
- en: Now that you’ve got an idea of how unittest does things, you need something
    to test. The following listing lays out a class you’ll use to get some testing
    practice.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 unittest 的工作方式，你需要一些东西来测试。以下列表展示了一个你将使用的类，用于获得一些测试实践。
- en: Listing 5.1\. A product class for an e-commerce system
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 一个电子商务系统的产品类
- en: '[PRE75]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* The product attributes are specified when a Product instance is created.**'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 产品属性在创建 Product 实例时指定。**'
- en: '***2* A SKU uniquely identifies the product attributes.**'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 一个 SKU 唯一标识产品属性。**'
- en: This class represents a product for purchase in an e-commerce system. A product
    has a name and options for size and color, and each combination of these attributes
    produces a *stock keeping unit* (SKU). A SKU is a unique, internal ID used by
    companies for pricing and inventory that often uses an all-uppercase format. Place
    this class definition in a product.py module.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表一个电子商务系统中可购买的产品。一个产品有一个名称和大小、颜色选项，这些属性的每个组合都产生一个 *库存单位* (SKU)。SKU 是公司用于定价和库存的唯一、内部
    ID，通常使用全大写格式。将此类定义放在 product.py 模块中。
- en: 'After you’ve created your product module, you’re ready to start writing your
    first test. Create a test_product.py module in the same directory as product.py.
    Start by importing unittest and creating an empty `ProductTestCase` class that
    inherits from the base `TestCase` class:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了产品模块之后，你就可以开始编写你的第一个测试了。在 product.py 相同目录下创建一个 test_product.py 模块。首先，导入
    unittest 并创建一个空的 `ProductTestCase` 类，该类继承自基本 `TestCase` 类：
- en: '[PRE76]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you run `python -m unittest` at this point, with only product.py and your
    empty test case in test_product.py, it will say that it ran no tests:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你此时运行 `python -m unittest`，只有 product.py 和你的空测试用例在 test_product.py 中，它将表示它没有运行任何测试：
- en: '[PRE77]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It likely found the test_product module and the `ProductTestCase` class, but
    you haven’t written any tests there yet. You can check this by adding an empty
    test method to the class:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能找到了 test_product 模块和 `ProductTestCase` 类，但你还没有在那里编写任何测试。你可以通过向该类添加一个空测试方法来检查这一点：
- en: '[PRE78]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Try running the test runner again; you should see that it ran one test this
    time:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试运行测试运行器；你应该看到这次它运行了一个测试：
- en: '[PRE79]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now you’re ready for the real magic. Remember the anatomy of a functional test:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好进行真正的魔法了。记住功能性测试的结构：
- en: Set up the inputs.
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置输入。
- en: Identify the expected output.
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定预期输出。
- en: Obtain the actual output.
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取实际输出。
- en: Compare the expected and actual outputs.
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较预期输出和实际输出。
- en: If you want to test the `transform_name_for_sku` method from the `Product` class,
    this recipe becomes
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试`Product`类中的`transform_name_for_sku`方法，这个食谱就变成了
- en: Create an instance of `Product` with a name, size, and color.
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有名称、尺寸和颜色的`Product`实例。
- en: Observe that `transform_name_for_sku` returns `name.upper()`; the expected result
    is the name in uppercase.
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到`transform_name_for_sku`返回`name.upper()`；期望的结果是名称的大写形式。
- en: Call the `Product` instance’s `transform_name_for_sku` method and save it in
    a variable.
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Product`实例的`transform_name_for_sku`方法并将其保存在一个变量中。
- en: Compare the expected result to the saved actual result.
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将期望结果与保存的实际结果进行比较。
- en: You can write the first three steps using regular code for creating a `Product`
    instance and getting the value of `transform_name_for_sku`. Using an `assert`
    statement for the fourth step would work, but `AssertionError` doesn’t provide
    much information in its traceback by default. This is where the custom assertion
    methods in unittest come into play. The most common one to use for comparing two
    values is `assertEqual`, which accepts expected and actual values as arguments.
    It raises an `AssertionError` and provides additional information showing the
    difference between the two values if they aren’t equal. This added context can
    help you find issues more easily.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用常规代码编写前三个步骤来创建`Product`实例和获取`transform_name_for_sku`的值。使用`assert`语句进行第四步也可以，但默认情况下`AssertionError`在其跟踪信息中提供的信息不多。这就是unittest中自定义断言方法发挥作用的地方。最常用的一个用于比较两个值的是`assertEqual`，它接受期望值和实际值作为参数。如果不相等，它将抛出一个`AssertionError`，并提供额外的信息，显示两个值之间的差异。这种附加的上下文可以帮助你更容易地找到问题。
- en: 'Here’s what the test might look like on a first pass:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个初步测试可能的样子：
- en: '[PRE80]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Prepares the setup for transform_name_for_sku: the product with its attributes**'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为transform_name_for_sku的转换准备设置：具有其属性的该产品**'
- en: '***2* States the expected result for generate_sku with the given inputs**'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 给定输入时，声明generate_sku的期望结果**'
- en: '***3* Obtains the actual result of generate_sku for comparison**'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取generate_sku的实际结果以进行比较**'
- en: '***4* Uses the special equality assertion method to compare two values**'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用特殊的相等断言方法来比较两个值**'
- en: Running the test runner now should still show `Ran 1 test`, and if the test
    passes (it should), you won’t see much additional output.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试运行器应该仍然显示`Ran 1 test`，如果测试通过（应该是），你不会看到更多的输出。
- en: 'It’s a good idea to see your tests fail to verify that they’ll actually catch
    a problem with your code if one arises. Change the expected value `''SHOES''`
    to `''SHOEZ''` and run the test again. Now, unittest will raise an `AssertionError`
    stating that `''SHOEZ'' != ''SHOES''`:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你的测试失败是个好主意，这样可以验证如果出现问题时，它们实际上能否捕捉到你的代码中的问题。将期望值`'SHOES'`改为`'SHOEZ'`，然后再次运行测试。现在，unittest将抛出一个`AssertionError`，指出`'SHOEZ'
    != 'SHOES'`：
- en: '[PRE81]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Confident that the test is keeping an eye over your code, you can change it
    back to the appropriate value and move on to another test.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 确信测试正在密切关注你的代码，你可以将其改回适当的值，然后继续进行另一个测试。
- en: 5.4.4\. Writing your first integration test with unittest
  id: totrans-784
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.4\. 使用unittest编写你的第一个集成测试
- en: Now that you’ve seen what units are and how they can be tested, it’s time to
    look at how the integration of multiple units can be tested. Unit tests are meant
    to examine the behavior of small pieces of software in isolation, so without integration
    tests it’s difficult to say if these small pieces work together to produce something
    useful as a whole (see [figure 5.5](#ch05fig05)).
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了单元的概念以及如何进行测试，是时候看看如何测试多个单元的集成。单元测试旨在单独检查软件小块的行为，因此如果没有集成测试，就很难说这些小块是否能够作为一个整体协同工作以产生有用的结果（参见[图5.5](#ch05fig05)）。
- en: Figure 5.5\. Unit tests and integration tests
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5\. 单元测试和集成测试
- en: '![](../Images/f0113-01_alt.jpg)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f0113-01_alt.jpg)'
- en: 'Now that you can manage products in your inventory with a SKU system, people
    should be able to start buying them. A new `ShoppingCart` class with the ability
    to add and remove products would be a good first step. The cart stores products
    as a dictionary that looks like this:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用SKU系统管理你的库存产品，人们应该能够开始购买它们。一个具有添加和删除产品功能的新`ShoppingCart`类是一个很好的第一步。购物车将产品存储为一个看起来像这样的字典：
- en: '[PRE82]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* The keys are the product SKUs.**'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 键是产品SKU。**'
- en: '***2* A nested dictionary of metadata about the cart item, like quantity**'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个关于购物车项元数据的嵌套字典，如数量**'
- en: The `ShoppingCart` class contains methods to add and remove a product by managing
    the data in this dictionary.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart`类包含通过管理这个字典中的数据来添加和删除产品的方法。'
- en: '[PRE83]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1* Using defaultdict simplifies the logic for checking if a product is already
    in the cart dictionary.**'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 defaultdict 简化了检查产品是否已在购物车字典中的逻辑。**'
- en: '***2* Adds quantity of a product to the cart**'
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将产品的数量添加到购物车**'
- en: '***3* Removes quantity of a product from the cart**'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从购物车中移除产品的数量**'
- en: 'The `ShoppingCart` behavior now presents a couple of integration points that
    should be tested:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 的行为现在呈现了几个应该进行测试的集成点：'
- en: The cart relies on (*integrates with*) the `Product` instance’s `generate_sku`
    method.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车依赖于（与 `Product` 实例的 `generate_sku` 方法**集成**）。
- en: Adding and removing products must work in tandem; a product that’s been added
    must also be able to be removed.
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和移除产品必须协同工作；已添加的产品也必须能够被移除。
- en: Testing these integrations will look a lot like unit testing; the difference
    is in how much of your software is executed during the test. Where a unit test
    generally only executes the code in one method and asserts that the output is
    as expected, an integration test may run many methods and make assertions about
    a few things along the way.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这些集成的方式将与单元测试非常相似；区别在于测试中执行了多少软件代码。单元测试通常只执行一个方法中的代码，并断言输出符合预期，而集成测试可能会运行多个方法，并在过程中对一些事情进行断言。
- en: In the case of `ShoppingCart`, a useful test would be to initialize the cart,
    add a product, remove it, and make sure the cart is empty, as shown in the following
    listing.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ShoppingCart`，一个有用的测试是将购物车初始化，添加一个产品，移除它，并确保购物车为空，如下所示。
- en: Listing 5.2\. An integration test for a `ShoppingCart` class
  id: totrans-802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 对 `ShoppingCart` 类的集成测试
- en: '[PRE84]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* The test setup is comparable to the earlier unit test.**'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 测试设置与早期的单元测试相似。**'
- en: '***2* Creates a cart to add products to**'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个购物车以添加产品**'
- en: '***3* Creates some small blue shoes**'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一些小蓝色鞋子**'
- en: '***4* Adds shoes to the cart**'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将鞋子添加到购物车**'
- en: '***5* Removes shoes from the cart**'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从购物车中移除鞋子**'
- en: '***6* The cart should be empty!**'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 购物车应该是空的！**'
- en: This test calls the cart’s `__init__` method, the product’s `generate_sku` method,
    and the cart’s `add_product` and `remove_product` methods. There’s a lot going
    on. As you might expect, integration tests are often quite a bit longer as a result.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试调用了购物车的 `__init__` 方法、产品的 `generate_sku` 方法以及购物车的 `add_product` 和 `remove_product`
    方法。发生了很多事情。正如你所预期的，集成测试通常会更长一些。
- en: 5.4.5\. Test doubles
  id: totrans-811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.5\. 测试双倍
- en: You’ll often have to write tests for code that interacts with another system,
    whether it’s a database or an API call. These calls might do destructive things
    to real data, so calling them for real when you run your tests might have bad
    consequences. They may also be slow, with the effect being magnified if your test
    suite executes that area of code multiple times. These other systems may not even
    be under your control. It often makes sense to imitate them instead of using the
    real thing.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会需要为与另一个系统交互的代码编写测试，无论是数据库还是 API 调用。这些调用可能会对真实数据造成破坏性影响，因此在运行测试时调用它们可能会产生不良后果。它们也可能很慢，如果测试套件多次执行该代码区域，效果会更明显。这些其他系统可能甚至不在你的控制之下。通常来说，模仿它们而不是使用真实的东西更有意义。
- en: 'There are several subtly different ways to imitate these systems with *test
    doubles*:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种微妙不同的方式可以使用 *测试双倍* 来模仿这些系统：
- en: '*Faking*—Using a system that behaves a lot like the real one, but avoids expensive
    or destructive actions'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟*—使用与真实系统行为非常相似的系统，但避免昂贵或破坏性行为'
- en: '*Stubbing*—Using a predetermined value as a response instead of getting one
    from a live system'
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存根*—使用预定的值作为响应，而不是从实时系统中获取'
- en: '*Mocking*—Using a system with the same interface as the real one, but that
    also records interactions for later inspection and assertions'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟*—使用与真实系统具有相同接口的系统，但同时也记录交互以便稍后检查和断言'
- en: Faking and stubbing in Python involve writing up your own imitations as functions
    or classes and telling your code to use them during test execution. Mocking, on
    the other hand, is most commonly done using the unittest.mock module.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，模拟和存根涉及编写自己的模仿作为函数或类，并在测试执行期间告诉你的代码使用它们。另一方面，模拟通常使用 unittest.mock
    模块来完成。
- en: 'Suppose your code calls an API endpoint to get some tax information for your
    product sales. You don’t want to really use this endpoint in your test because
    you’ve seen it take a few seconds to respond. On top of that, it returns dynamic
    data, so you can’t be sure what value you should make assertions about in the
    test. If the code looks like this:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的代码调用API端点来获取一些产品销售所需的税率信息。你不想在测试中真正使用这个端点，因为你看到它需要几秒钟才能响应。更不用说，它返回动态数据，所以你无法确定在测试中应该对什么值进行断言。如果代码看起来像这样：
- en: '[PRE85]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'a unit test with mocking could look like this:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有模拟的单元测试可能看起来像这样：
- en: '[PRE86]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* The mock.patch decorator mocks the object or method specified.**'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* The mock.patch decorator mocks the object or method specified.**'
- en: '***2* The test function receives the mocked object or method.**'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* The test function receives the mocked object or method.**'
- en: '***3* The mocked urlopen call will now return the mocked response with the
    expected test tax rate.**'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* The mocked urlopen call will now return the mocked response with the
    expected test tax rate.**'
- en: '***4* Asserts that the add_sales_tax method calculates the new value from the
    tax rate returned by the API**'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Asserts that the add_sales_tax method calculates the new value from the
    tax rate returned by the API**'
- en: Testing in this way allows you to declare, “The code I control behaves in this
    way given these assumptions,” where the assumptions are created using test doubles.
    If you have fair confidence that the requests library works as it says it does,
    you can use test doubles to avoid coupling yourself to it. If you need to use
    a different HTTP client library in the future, or need to change which API you
    get your tax information from, the test will not have to change.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进行测试允许你声明，“在给定的假设下，我控制的代码表现是这样的，”其中假设是通过测试替身创建的。如果你对requests库按其说明工作的信心足够，你可以使用测试替身来避免将其耦合到它。如果你将来需要使用不同的HTTP客户端库，或者需要更改获取税率信息的API，测试将不需要更改。
- en: It’s possible to overuse test doubles. I’m most certainly guilty of this from
    time to time. Usually you’ll want to use test doubles to avoid the slow, expensive,
    or destructive behaviors mentioned before, but sometimes it’s tempting to mock
    your own code to perfectly isolate the unit you’re trying to test. This can lead
    to *brittle* tests that break often when you change your code, in part because
    they mirror the structure of the implementation too closely. Change the implementation,
    and you have to change your tests.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身可能会过度使用。我确实有时会犯这个错误。通常，你想要使用测试替身来避免之前提到的缓慢、昂贵或破坏性的行为，但有时模拟自己的代码以完美隔离你试图测试的单元是很诱人的。这可能导致*脆弱*的测试，当你的代码更改时，它们经常崩溃，部分原因是因为它们与实现的结构过于相似。更改实现，你必须更改测试。
- en: Try to write tests that verify what you need but are flexible regarding changes
    in the underlying implementation. This is loose coupling, once again. Loose coupling
    applies to test code as much as implementation code.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写测试用例来验证你需要的功能，但又要对底层实现的变更保持灵活性。这又是一次松耦合的应用。松耦合不仅适用于实现代码，也适用于测试代码。
- en: 5.4.6\. Try it out
  id: totrans-829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.6\. 尝试一下
- en: How would you test the other methods in the `Product` and `ShoppingCart` classes?
    Keeping in mind the recipe for functional tests, try adding additional tests for
    the remaining methods. A thorough test suite will contain assertions for each
    method and for each different outcome you might expect from the method. You might
    even find a subtle bug! As a hint, try testing what happens when you remove more
    things from the cart than it contains.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何测试`Product`和`ShoppingCart`类中的其他方法？考虑到功能测试的配方，尝试为剩余的方法添加额外的测试。一个全面的测试套件将包含对每个方法的断言，以及你可能从该方法期望的每个不同结果。你甚至可能会发现一个微小的错误！作为一个提示，尝试测试当你从购物车中移除比其包含的更多的物品时会发生什么。
- en: Some of the values you need to test are dictionaries. Unittest has a special
    method, `assertDictEqual`, that provides useful output specific to dictionaries
    when the test fails.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要测试的一些值是字典。Unittest有一个特殊的方法，`assertDictEqual`，当测试失败时，它为字典提供有用的输出。
- en: 'For short tests like the one you wrote already, you can skip saving the expected
    and actual values as variables. Enter the expressions directly as arguments to
    `assertEqual`:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像你已经写过的这样的短测试用例，你可以跳过将预期值和实际值保存为变量。直接将表达式作为`assertEqual`函数的参数传入：
- en: '[PRE87]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: When you’ve given it a try, come back and check the following listing to see
    how you did. Remember to use the unittest test runner after writing or changing
    a test to see if the test continues to pass.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试过后，回来查看以下列表，看看你的表现如何。记住，在编写或更改测试后，使用unittest测试运行器来查看测试是否仍然通过。
- en: Listing 5.3\. A test suite for `Product` and `ShoppingCart`
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. `Product`和`ShoppingCart`的测试套件
- en: '[PRE88]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can fix the bug in the shopping cart by updating `remove_product` to delete
    a product from the cart if its quantity is *less than or equal* to 0:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更新`remove_product`来修复购物车中的错误，使其在数量**小于或等于**0时从购物车中删除产品：
- en: '[PRE89]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 5.4.7\. Writing interesting tests
  id: totrans-839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.7\. 编写有趣的测试
- en: Good tests will use inputs that affect the behavior of the method being tested.
    SKUs are typically all uppercase, and they usually don’t contain spaces either—only
    letters, numbers, and dashes. But what if the product name contains a space? You’ll
    want to remove the spaces before the name gets put in the SKU. A tank top SKU
    should start with `'TANKTOP'`, for example.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 好的测试将使用影响被测试方法行为的数据。SKU通常是全部大写，通常也不包含空格——只有字母、数字和破折号。但如果产品名称中包含空格怎么办？你希望在名称放入SKU之前移除空格。例如，一件T恤的SKU应该以`'TANKTOP'`开头。
- en: This is a new requirement, so you can write a new test that describes how the
    code should behave.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个新的要求，因此你可以编写一个新的测试来描述代码应该如何表现。
- en: '[PRE90]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This test fails because the current code returns `'TANK TOP'`. That’s okay because
    you haven’t built support for products with spaces in the name yet. Seeing this
    test fail for the expected reason means that when you write the code to correctly
    handle spaces, the test should pass.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败是因为当前代码返回了`'TANK TOP'`。这没关系，因为你还没有为名称中包含空格的产品建立支持。看到这个测试因为预期的原因而失败意味着，当你编写代码来正确处理空格时，测试应该会通过。
- en: Thinking of interesting tests like this yourself is valuable because it can
    surface questions like this earlier in the development process. Then you can survey
    other stakeholders and ask, “What are all the possible product name formats we
    might need to support?” If their answer gives you new information, you can incorporate
    it into the code and the tests to deliver better software.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 自己思考有趣的测试是有价值的，因为它可以在开发早期阶段提出类似的问题。然后你可以调查其他利益相关者并询问，“我们可能需要支持的所有可能的产品名称格式是什么？”如果他们的回答给你提供了新的信息，你可以在代码和测试中包含它，以提供更好的软件。
- en: Now that you understand the benefits of unittest, it’s time to learn about pytest.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了unittest的好处，是时候学习pytest了。
- en: 5.5\. Testing with pytest
  id: totrans-846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 使用pytest进行测试
- en: Although unittest is a full-featured and mature framework built into Python,
    it has a few drawbacks. For some, it feels “un-Pythonic” because it uses `camelCase`
    instead of `snake_case` for method names (a relic of its JUnit history). Unittest
    also requires a fair amount of boilerplate that makes the underlying tests a bit
    more difficult to comprehend.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然unittest是一个功能齐全且成熟的框架，它是Python内置的，但它有一些缺点。对于一些人来说，它感觉“非Pythonic”，因为它使用`camelCase`而不是`snake_case`作为方法名称（这是其JUnit历史的遗迹）。Unittest还要求相当多的样板代码，这使得底层测试更难理解。
- en: '|  |'
  id: totrans-848
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pythonic code**'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pythonic代码**'
- en: Code is often said to be *Pythonic* if it uses the features and common style
    guidelines for the Python language. Pythonic code uses `snake_case` for variable
    and method names, list comprehensions instead of simple `for` loops, and so on.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码使用了Python语言的特征和常见的风格指南，那么它通常被称为*Pythonic*。Pythonic代码使用`snake_case`作为变量和方法名称，使用列表推导式而不是简单的`for`循环，等等。
- en: '|  |'
  id: totrans-851
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For those who like succinct, straight-to-the-point tests, pytest is an answer
    (https:// docs.pytest.org/en/latest/getting-started.html). Once you’ve installed
    pytest, you can get back to the raw `assert` statements you saw earlier. Pytest
    performs a bit of hidden magic under the hood to make this work, but it produces
    a smooth experience.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 对于喜欢简洁、直接到点的测试的人来说，pytest是一个解决方案（https://docs.pytest.org/en/latest/getting-started.html）。一旦安装了pytest，你就可以回到之前看到的原始`assert`语句。pytest在底层进行了一些隐藏的魔法操作来实现这一点，但它提供了一个流畅的体验。
- en: 'Pytest produces more readable output by default, telling you about the system,
    the number of tests it finds, the result of individual tests, and a summary of
    the overall test results:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest默认产生更易读的输出，告诉你关于系统、它找到的测试数量、单个测试的结果以及整体测试结果的摘要：
- en: '[PRE91]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* Information about the system**'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 系统信息**'
- en: '***2* The number of tests pytest discovered**'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* pytest发现的测试数量**'
- en: '***3* The status of each test from each module, with an overall progress indicator**'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个模块中每个测试的状态，以及一个整体进度指示器**'
- en: '***4* A summary of the full test suite results**'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 整个测试套件结果的摘要**'
- en: 5.5.1\. Test organization with pytest
  id: totrans-859
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1\. 使用pytest进行测试组织
- en: Pytest does automatic discovery of your tests like unittest does. It will even
    discover any unittest tests you have lying around. One key difference is that
    proper pytest test classes are named `Test*` and don’t need to inherit from a
    base class (like `unittest.TestCase`) to work.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 自动发现你的测试，就像 unittest 一样。它甚至可以发现你周围的任何 unittest 测试。一个关键的区别是，正确的 pytest
    测试类被命名为 `Test*`，并且不需要从基类（如 `unittest.TestCase`）继承即可工作。
- en: 'The command for running tests with pytest is simpler:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 pytest 测试的命令更简单：
- en: '[PRE92]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Because pytest doesn’t require you to inherit from a base class or use any special
    methods, you don’t strictly need to organize your tests into classes. I still
    recommend it, though, because it remains a good organizational tool. Pytest will
    include the test class name in failure output and the like, which can help you
    understand where the tests live and what they’re about. On the whole, pytest tests
    can be organized similarly to those for unittest.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 pytest 不要求你从基类继承或使用任何特殊方法，所以你并不严格需要将你的测试组织到类中。尽管如此，我仍然推荐这样做，因为它仍然是一个很好的组织工具。pytest
    将在失败输出中包含测试类名等，这可以帮助你了解测试所在的位置以及它们的内容。总的来说，pytest 测试可以像 unittest 测试那样组织。
- en: 5.5.2\. Converting unittest tests to pytest
  id: totrans-864
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2\. 将 unittest 测试转换为 pytest
- en: 'Because pytest will discover your existing unittest tests, you can incrementally
    convert your tests to pytest as you wish (and *if* you wish, I suppose). For the
    test suite you’ve written so far, the conversion looks like this:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 pytest 会发现你的现有 unittest 测试，所以你可以根据需要（以及 *如果* 你愿意，我想）逐步将你的测试转换为 pytest。对于你迄今为止编写的测试套件，转换看起来是这样的：
- en: Remove the unittest import from test_product.py.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 test_product.py 中移除 unittest 导入。
- en: Rename the `ProductTestCase` class to `TestProduct` and remove the inheritance
    from `unittest.TestCase`.
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `ProductTestCase` 类重命名为 `TestProduct` 并移除从 `unittest.TestCase` 的继承。
- en: Replace any `self.assertEqual(expected, actual)` with `assert actual == expected`.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任何 `self.assertEqual(expected, actual)` 替换为 `assert actual == expected`。
- en: The test case from earlier looks more like the following under pytest.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pytest 下，之前的测试用例看起来更像是以下这样。
- en: Listing 5.4\. A test case in pytest
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. pytest 中的一个测试用例
- en: '[PRE93]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* No need to inherit from any base class**'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不需要从任何基类继承**'
- en: '***2* self.assertEqual goes away; uses raw assert statements instead**'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* self.assertEqual 被移除；使用原始的 assert 语句代替**'
- en: 'As you can see, pytest leads to shorter and arguably more readable test code.
    It also provides its own framework of features that make setting up the environment
    and dependencies for your tests easier. For a great in-depth look at all pytest
    has to offer, I highly recommend Brian Okken’s book, *Python Testing with pytest:
    Simple, Rapid, Effective, and Scalable* (Pragmatic Bookshelf, 2017).'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，pytest 导致测试代码更短，并且可以说是更易读。它还提供自己的功能框架，这使得设置测试的环境和依赖项更容易。为了深入了解 pytest
    提供的所有功能，我强烈推荐 Brian Okken 的书籍，*Python Testing with pytest: Simple, Rapid, Effective,
    and Scalable*（Pragmatic Bookshelf，2017）。'
- en: You now have some unit and integration testing under your belt; read on to learn
    briefly about non-functional testing.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经有了一些单元和集成测试；继续阅读，简要了解非功能性测试。
- en: 5.6\. Beyond functional testing
  id: totrans-876
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6\. 功能测试之外
- en: You spent the majority of this chapter learning about functional tests. Making
    code work and making it right both come before making it fast, so functional testing
    precedes testing the speed of your code. Once you’ve made sure the code is working,
    making sure it’s performant is a good next step.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章的大部分时间里都在学习功能测试。让代码工作并使其正确都在让代码快速之前，所以功能测试先于测试代码的速度。一旦你确保代码是可工作的，确保它是高效的就成为了下一步的好方法。
- en: 5.6.1\. Performance testing
  id: totrans-878
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1\. 性能测试
- en: Performance testing tells you how the changes you make affect things like memory,
    CPU, and disk usage. In [chapter 4](../Text/kindle_split_014.html#ch04), you learned
    about some of the tools available for performance testing the *units* of your
    code. You used the timeit module, and that’s what I use to see what my options
    are for specific lines of code and functions. These aren’t measurements you’ll
    usually do in an automated way; they’re meant for ad hoc comparison of two approaches,
    and they’re quick to write when you’re trying to see which of two implementations
    is faster.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试会告诉你你所做的更改如何影响内存、CPU 和磁盘使用等方面。在 [第 4 章](../Text/kindle_split_014.html#ch04)
    中，你学习了可用于测试代码 *单元* 的某些性能测试工具。你使用了 timeit 模块，这也是我用来查看特定代码行和函数选项的方法。这些并不是你通常会自动执行的计算；它们是为了对两种方法进行临时比较，当你试图查看两种实现哪个更快时，它们编写起来很快。
- en: As you develop larger applications with a number of critical operations that
    need to remain efficient, it may behoove you to integrate some automated performance
    testing into your process. Automated performance testing looks quite like regression
    testing in practice; if you deploy a change and notice that the application begins
    consuming 20% more memory, it’s a good sign that you should investigate the change.
    It’s also great for celebrating the moments when you fix a slow piece of code
    and can watch your app speed up.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发具有多个需要保持效率的关键操作的大型应用程序时，将一些自动性能测试集成到你的流程中可能是有益的。在实际操作中，自动性能测试看起来很像回归测试；如果你部署了一个更改，并注意到应用程序开始消耗
    20% 的更多内存，那么这是一个很好的迹象，表明你应该调查这个更改。当修复了缓慢的代码并看到应用程序加速时，这也是庆祝的好时机。
- en: Unlike unit testing, which produces binary pass/fail results, performance testing
    is more qualitative. If you see your application trending slower over time (or
    a sudden jump after a deployment), that’s something to look into. The nature of
    this kind of testing makes it a bit more difficult to automate and monitor, but
    solutions are out there.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 与产生二进制通过/失败结果的单元测试不同，性能测试更侧重于定性。如果你看到你的应用程序随着时间的推移而变慢（或部署后的突然跳跃），那就需要关注一下。这种测试的性质使得它自动化和监控起来有点困难，但解决方案是存在的。
- en: 5.6.2\. Load testing
  id: totrans-882
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2. 压力测试
- en: Load testing is a type of performance testing, but it gives you information
    about how far you can push your application until it falls over. Maybe it consumes
    too much CPU, memory, or network bandwidth, or it gets too slow for users to use
    it reliably. Whatever the case, load testing provides metrics you can use to fine-tune
    the resources you give your application. In more substantial cases, it may motivate
    you to change the design of part of the system so it’s more efficient.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试是一种性能测试，但它能告诉你你的应用程序能承受多大的压力直到崩溃。可能它消耗了过多的CPU、内存或网络带宽，或者变得太慢以至于用户无法可靠地使用它。无论哪种情况，压力测试都提供了你可以用来微调分配给应用程序的资源的数据。在更复杂的情况下，它可能促使你改变系统部分的设计，使其更高效。
- en: Load testing entails more infrastructure and strategy than something like unit
    testing. To get a clear picture of performance under load, you need to mimic your
    production environment closely in both architecture and user behavior. Due to
    the complexity of application-level load testing, in my mind it sits somewhere
    above integration testing in the testing pyramid ([figure 5.6](#ch05fig06)).
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试需要比单元测试更多的基础设施和策略。为了清晰地了解负载下的性能，你需要在架构和用户行为上紧密模拟你的生产环境。由于应用级压力测试的复杂性，在我看来，它在测试金字塔中位于集成测试之上（[图
    5.6](#ch05fig06)）。
- en: Figure 5.6\. Load testing in the testing pyramid
  id: totrans-885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6. 压力测试在测试金字塔中的位置
- en: '![](../Images/f0123-01_alt.jpg)'
  id: totrans-886
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0123-01_alt.jpg)'
- en: Load testing helps you performance-test your applications in scenarios that
    more closely mimic real-world user behavior.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试有助于你在更接近现实世界用户行为的场景中对应用程序进行性能测试。
- en: '5.7\. Test-driven development: A primer'
  id: totrans-888
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7. 测试驱动开发：入门
- en: A whole school of thought exists around *driving* development using unit and
    integration testing in software. The general name for these practices is *test-driven
    development* (TDD). TDD can help you commit to testing up front, so you reap the
    benefits of testing that we’ve discussed so far.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕使用单元和集成测试驱动软件开发存在一个完整的思维体系。这些实践的一般名称是 *测试驱动开发*（TDD）。TDD 可以帮助你提前承诺进行测试，从而获得我们之前讨论过的测试的好处。
- en: 5.7.1\. It’s a mindset
  id: totrans-890
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.1. 它是一种心态
- en: For me, the real benefit of TDD is the mindset it puts me in. The stereotype
    of a quality assurance engineer is that they can always find something in your
    code to break. This is generally said with some disdain, but I think it’s remarkable.
    Enumerating all the ways a system can blow up is both useful and impressive.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，TDD 的真正好处是它让我保持的心态。质量保证工程师的典型形象是总能找到你代码中的问题。这通常带有一些轻蔑的语气，但我认为这是值得注意的。列举系统可能崩溃的所有方式既有用又令人印象深刻。
- en: Netflix takes this to an extreme with the idea of chaos engineering. They actively
    think about the ways systems can fail, but they also introduce some amount of
    unpredictable failure.^([[2](#ch05fn02)]) This leads to innovative ways of responding
    to failure.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix 将这种理念推向了极致，即混沌工程。他们积极思考系统可能失败的方式，同时也引入了一定程度的不确定性失败。[^2](#ch05fn02) 这导致了应对失败的创新方法。
- en: ²
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-894
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To learn more about Netflix’s advances in the area of chaos engineering, check
    out their collection of blog posts on the subject: https://medium.com/netflix-techblog/tagged/chaos-engineering.'
  id: totrans-895
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想了解更多关于Netflix在混沌工程领域取得的进展，请查看他们关于该主题的博客文章集合：https://medium.com/netflix-techblog/tagged/chaos-engineering。
- en: As you write tests, try to be a chaos engineer. Deliberately try to think of
    the extremes that your code can endure, and throw them at it. There’s a limit,
    of course—it doesn’t make sense for all code to respond predictably to all inputs.
    But in Python, the exception system allows your code to respond in a predictable
    way to rare or unexpected situations.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试时，尝试成为一个混沌工程师。故意思考代码能够承受的极限，并向其投掷。当然，有一个限制——并不是所有代码都对所有输入都有可预测的反应。但在Python中，异常系统允许你的代码对罕见或意外的情况以可预测的方式做出反应。
- en: 5.7.2\. It’s a philosophy
  id: totrans-897
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.2. 这是一种哲学
- en: TDD has a subculture around it, and the only opinions stronger than how to do
    it correctly are how *not* to do it correctly. It’s an art form that produces
    as many styles and critics as any other movement. I’ve found it useful to learn
    how different teams handle the testing aspects of their process; once you do this,
    you can identify the pieces you like and incorporate them into your own work.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: TDD在其周围有一个子文化，比如何正确做的观点更强烈的，是如何**不**正确做的观点。它是一种艺术形式，就像任何其他运动一样，产生了许多风格和批评。我发现学习不同团队如何处理他们流程中的测试方面是有用的；一旦你这样做，你就可以识别出你喜欢的部分，并将它们融入自己的工作中。
- en: Some TDD literature advocates making sure every line of your code is covered
    by tests. Although it’s good to have strong coverage of the different cases your
    code can handle, increasing the coverage beyond a certain point can have diminishing
    returns. Sometimes covering those last few lines with your tests means introducing
    tighter coupling between the tests and the implementation with an integration
    test.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 一些TDD文献提倡确保你的代码每一行都由测试覆盖。虽然拥有强大的测试覆盖率，能够覆盖代码可以处理的不同情况是好事，但超过一定程度的覆盖率可能会带来递减的回报。有时用测试覆盖最后几行代码意味着测试与实现之间的耦合变得更加紧密，需要通过集成测试来实现。
- en: If you find that testing some aspect of a function’s behavior is awkward or
    difficult, try to determine if it’s because the code’s concerns aren’t well separated
    or if it’s inherently awkward to test. If awkwardness *must* be incorporated,
    it’s better for it to be in the tests than the real code. Don’t refactor code
    *only* to make testing easier or coverage stronger—do it to make testing easier
    *and* to make the code more coherent.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现测试函数行为的一些方面很尴尬或困难，尝试确定这是否是因为代码的关注点没有很好地分离，或者测试本身固有的尴尬。如果必须包含尴尬，最好是在测试中而不是在真实代码中。不要仅仅为了使测试更容易或覆盖率更强而重构代码——这样做是为了使测试更容易，并且使代码更加连贯。
- en: Summary
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Functional tests make sure code produces the expected output from a given input.
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试确保代码从给定的输入产生预期的输出。
- en: Testing saves you time in the long run by catching bugs and making refactoring
    code easier.
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试通过捕捉错误和简化代码重构，从长远来看可以节省你的时间。
- en: Manual testing isn’t scalable and should be used to supplement automated testing.
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试不可扩展，应该用于补充自动化测试。
- en: Unittest and pytest are two popular unit and integration testing frameworks
    for Python.
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unittest和pytest是Python中两个流行的单元和集成测试框架。
- en: Test-driven development puts the tests first, guiding you to a working implementation
    based on the requirements.
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发将测试放在首位，根据需求引导你到一个可工作的实现。
