- en: Chapter 1\. Java basics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章 Java基础知识
- en: '| Exam objectives covered in this chapter | What you need to know |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 本章涵盖的考试目标 | 你需要了解的内容 |'
- en: '| --- | --- |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [[1.2](#ch01lev1sec2)] Define the structure of a Java class. | Structure
    of a Java class, with its components: package and import statements, class declarations,
    comments, variables, and methods. Difference between the components of a Java
    class and that of a Java source code file. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| [[1.2](#ch01lev1sec2)] 定义Java类的结构。 | Java类的结构，包括其组件：包和导入语句、类声明、注释、变量和方法。Java类组件与Java源代码文件组件之间的区别。|'
- en: '| [[1.3](#ch01lev1sec3)] Create executable Java applications with a main method;
    run a Java program from the command line; including console output. | The right
    method signature for the main method to create an executable Java application.
    The arguments that are passed to the main method. |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [[1.3](#ch01lev1sec3)] 使用具有main方法的Java应用程序创建可执行文件；从命令行运行Java程序；包括控制台输出。 |
    创建可执行Java应用程序的main方法的正确方法签名。传递给main方法的参数。|'
- en: '| [[1.4](#ch01lev1sec4)] Import other Java packages to make them accessible
    in your code. | Understand packages and import statements. Get the right syntax
    and semantics to import classes from packages and interfaces in your own classes.
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [[1.4](#ch01lev1sec4)] 将其他Java包导入到你的代码中以便使用。 | 理解包和导入语句。获取从包和接口导入类到自己的类中的正确语法和语义。|'
- en: '| [[6.4](kindle_split_020.html#ch06lev1sec4)] Apply access modifiers. | Application
    of access modifiers (public, protected, default, and private) to a class and its
    members. Determine the accessibility of code with these modifiers. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [[6.4](kindle_split_020.html#ch06lev1sec4)] 应用访问修饰符。 | 将访问修饰符（public、protected、默认和private）应用于类及其成员。确定这些修饰符的代码可访问性。|'
- en: '| [[7.5](kindle_split_021.html#ch07lev1sec6)] Use abstract classes and interfaces.
    | The implication of defining classes, interfaces, and methods as abstract entities.
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [[7.5](kindle_split_021.html#ch07lev1sec6)] 使用抽象类和接口。 | 定义类、接口和方法作为抽象实体的含义。|'
- en: '| [[6.2](kindle_split_019.html#ch06lev1sec2)] Apply the static keyword to methods
    and fields. | The implication of defining fields and methods as static members.
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| [[6.2](kindle_split_019.html#ch06lev1sec2)] 将静态关键字应用于方法和字段。 | 将字段和方法定义为静态成员的含义。|'
- en: '| [[1.5](kindle_split_012.html#ch01lev1sec5)] Compare and contrast the features
    and components of Java such as: platform independence, object orientation, encapsulation,
    etc. | The features and components that are relevant or irrelevant to Java. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [[1.5](kindle_split_012.html#ch01lev1sec5)] 比较和对比Java的特性如：平台无关性、面向对象、封装等。
    | 与Java相关的特性和组件。|'
- en: Imagine you’re setting up a new IT organization that works with multiple developers.
    To ensure smooth and efficient working, you’ll define a structure for your organization
    and a set of departments with separate responsibilities. These departments will
    interact with each other whenever required. Also, depending on confidentiality
    requirements, your organization’s data will be available to employees on an as-needed
    basis, or you may assign special privileges to only some employees of the organization.
    This is an example of how organizations might work with a well-defined structure
    and a set of rules to deliver the best results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在建立一个与多个开发者合作的IT组织。为了确保工作顺利高效，你将为你的组织定义一个结构以及一组具有单独职责的部门。这些部门在需要时将相互协作。此外，根据保密性要求，你的组织的数据将根据需要提供给员工，或者你可以将特殊权限仅分配给组织的某些员工。这是组织如何通过一个明确的结构和一套规则来提供最佳结果的例子。
- en: Similarly, Java has a well-defined structure and hierarchy. The organization’s
    structure and components can be compared with Java’s class structure and components,
    and the organization’s departments can be compared with Java packages. Restricting
    access to some data in the organization can be compared to Java’s access modifiers.
    An organization’s special privileges can be compared to nonaccess modifiers in
    Java.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Java有一个明确的结构和层次。组织的结构和组件可以与Java的类结构和组件进行比较，组织的部门可以与Java包进行比较。限制组织中对某些数据的访问可以与Java的访问修饰符进行比较。组织的特殊权限可以与Java中的非访问修饰符进行比较。
- en: 'In the OCA Java SE 8 Programmer I exam, you’ll be asked questions on the structure
    of a Java class, packages, importing classes, and applying access and nonaccess
    modifiers and features and components of Java. Given that information, this chapter
    will cover the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OCA Java SE 8 程序员 I 考试中，你将被问到 Java 类的结构、包、导入类以及应用访问和非访问修饰符和 Java 的特性和组件。鉴于这些信息，本章将涵盖以下内容：
- en: The structure and components of a Java class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 类的结构和组件
- en: Understanding executable Java applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可执行的 Java 应用程序
- en: Understanding Java packages
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Java 包
- en: Importing Java packages into your code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Java 包导入到你的代码中
- en: Applying access and nonaccess modifiers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用访问和非访问修饰符
- en: Features and components of Java
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 的特性和组件
- en: 1.1\. The structures of a Java class and a source code file
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. Java 类和源代码文件的结构
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[1.2](#ch01lev1sec2)] Define the structure of a Java class'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1.2](#ch01lev1sec2)] 定义 Java 类的结构'
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When you see a certification objective callout such as the preceding one, it
    means that in this section we’ll cover this objective. The same objective may
    be covered in more than one section in this chapter or in other chapters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到像前面那样的认证目标时，这意味着在本节中我们将涵盖这个目标。同一个目标可能在本章或其他章节的多个部分中都有涉及。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This section covers the structures and components of both a Java source code
    file (.java file) and a Java class (defined using the keyword `class`). It also
    covers the differences between a Java source code file and a Java class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了 Java 源代码文件 (.java 文件) 和 Java 类（使用关键字 `class` 定义）的结构和组件。它还涵盖了 Java 源代码文件和
    Java 类之间的区别。
- en: 'First things first. Start your exam preparation with a clear understanding
    of what’s required from you in the certification exam. For example, try to answer
    the following query from a certification aspirant: “I come across the term ‘class’
    with different meanings: class `Person`, the Java source code file (Person.java),
    and Java bytecode stored in Person.class. Which of these structures is on the
    exam?” To answer this question, take a look at [figure 1.1](#ch01fig01), which
    includes the class `Person`, the files Person.java and Person.class, and the relationship
    between them.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，先从对认证考试中对你有什么要求有一个清晰的理解开始准备考试。例如，尝试回答一个认证申请者的以下问题：“我遇到了‘类’这个术语的不同含义：类 `Person`、Java
    源代码文件（Person.java）和存储在 Person.class 中的 Java 字节码。这些结构中哪一个在考试中？”要回答这个问题，请查看[图 1.1](#ch01fig01)，它包括了类
    `Person`、文件 Person.java 和 Person.class 以及它们之间的关系。
- en: Figure 1.1\. Relationship between the class file `Person` and the files Person.java
    and Person.class and how one transforms into another
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1\. 类文件 `Person` 与文件 Person.java 和 Person.class 之间的关系以及它们如何相互转换
- en: '![](01fig01_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig01_alt.jpg)'
- en: As you can see in [figure 1.1](#ch01fig01), a person can be defined as a class
    `Person`. This class should reside in a Java source code file (Person.java). Using
    this Java source code file, the Java compiler (javac.exe on Windows or javac on
    Mac OS X/Linux/UNIX) generates bytecode (compiled code for the Java Virtual Machine)
    and stores it in Person.class. The scope of this exam objective is limited to
    Java classes (class `Person`) and Java source code files (Person.java).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 1.1](#ch01fig01)所示，一个人可以被定义为一个类 `Person`。这个类应该位于一个 Java 源代码文件（Person.java）中。使用这个
    Java 源代码文件，Java 编译器（Windows 上的 javac.exe 或 Mac OS X/Linux/UNIX 上的 javac）生成字节码（Java
    虚拟机的编译代码）并将其存储在 Person.class 中。本考试目标的范围仅限于 Java 类（类 `Person`）和 Java 源代码文件（Person.java）。
- en: 1.1.1\. Structure of a Java class
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. Java 类的结构
- en: The OCA Java SE 8 Programmer I exam will question you on the structure and components
    of a Java source file and the classes or interfaces that you can define in it.
    [Figure 1.2](#ch01fig02) shows the components of a Java class file (interfaces
    are covered in detail in [chapter 6](kindle_split_019.html#ch06)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OCA Java SE 8 程序员 I 考试将就 Java 源文件的结构和组件以及在其中可以定义的类或接口向你提问。[图 1.2](#ch01fig02)
    展示了 Java 类文件的组件（接口将在第 6 章中详细讲解）。
- en: Figure 1.2\. Components of a Java class
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2\. Java 类的组件
- en: '![](01fig02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig02.jpg)'
- en: In this section, I’ll discuss all Java class file components. Let’s get started
    with the `package` statement.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论所有 Java 类文件组件。让我们从 `package` 语句开始。
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The code in this book doesn’t include a lot of spaces—it imitates the kind of
    code that you’ll see on the exam. But when you work on real projects, I strongly
    recommend that you use spaces or comments to make your code readable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码不包含很多空格——它模仿了你在考试中会看到的代码类型。但当你处理实际项目时，我强烈建议你使用空格或注释来使你的代码可读。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: package statement
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包声明
- en: All Java classes are part of a package. A Java class can be explicitly defined
    in a named package; otherwise, it becomes part of a *default* package, which doesn’t
    have a name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 Java 类都是包的一部分。Java 类可以显式地定义在命名包中；否则，它将成为一个**默认**包的一部分，该包没有名称。
- en: 'A `package` statement is used to explicitly define which package a class is
    in. If a class includes a `package` statement, it must be the first statement
    in the class definition:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`package` 语句用于显式地定义类所在的包。如果一个类包含 `package` 语句，它必须是类定义中的第一个语句：'
- en: '![](025fig01_alt.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](025fig01_alt.jpg)'
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Packages are covered in detail in [section 1.3](#ch01lev1sec3) of this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 包的详细内容在本章的 [1.3 节](#ch01lev1sec3) 中介绍。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The `package` statement can’t appear within a class declaration or after the
    class declaration. The following code will fail to compile:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`package` 语句不能出现在类声明中或类声明之后。以下代码将无法编译：'
- en: '![](025fig02_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](025fig02_alt.jpg)'
- en: 'The following code will also fail to compile, because it places the `package`
    statement within the class definition:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将无法编译，因为它在类定义中将 `package` 语句放在了内部：
- en: '![](025fig03_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](025fig03_alt.jpg)'
- en: 'Also, if present, the `package` statement must appear exactly once in a class.
    The following code won’t compile:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果存在，`package` 语句必须恰好出现在类中一次。以下代码将无法编译：
- en: '![](025fig04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](025fig04.jpg)'
- en: import statement
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 导入语句
- en: Classes and interfaces in the same package can use each other without prefixing
    their names with the package name. But to use a class or an interface from another
    package, you must use its fully qualified name, that is, `packageName.anySubpackageName.ClassName`.
    For example, the fully qualified name of class `String` is `java.lang.String`.
    Because using fully qualified names can be tedious and can make your code difficult
    to read, you can use the `import` statement to use the simple name of a class
    or interface in your code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同一包中的类和接口可以相互使用，而无需在它们的名称前加上包名。但为了使用来自另一个包的类或接口，你必须使用它的完全限定名，即 `packageName.anySubpackageName.ClassName`。例如，类
    `String` 的完全限定名是 `java.lang.String`。因为使用完全限定名可能会很繁琐，并且会使你的代码难以阅读，所以你可以使用 `import`
    语句来在你的代码中使用类或接口的简单名称。
- en: Let’s look at this using an example class, `AnnualExam`, which is defined in
    the package `university`. Class `AnnualExam` is associated with the class `certification.ExamQuestion`,
    as shown using the Unified Modeling Language (UML) *class diagram* in [figure
    1.3](#ch01fig03).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例类 `AnnualExam` 来看看这个，该类定义在 `university` 包中。类 `AnnualExam` 与类 `certification.ExamQuestion`
    相关联，如图 1.3 所示的统一建模语言（UML）**类图**所示。
- en: Figure 1.3\. UML representation of the relationship between class `AnnualExam`
    and `ExamQuestion`
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.3\. 类 `AnnualExam` 和 `ExamQuestion` 之间关系的 UML 表示
- en: '![](01fig03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig03.jpg)'
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A UML class diagram represents the static view of an application. It shows entities
    like packages, classes, interfaces, and their attributes (fields and methods)
    and also depicts the relationships between them. It shows which classes and interfaces
    are defined in a package. It depicts the inheritance relationship between classes
    and interfaces. It can also depict the associations between them—when a class
    or an interface defines an attribute of another type. All UML representations
    in this chapter are class diagrams. The exam doesn’t cover UML diagrams. But using
    these quick and simple diagrams simplifies the relationship between Java entities—both
    on the exam and in your real-world projects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: UML 类图表示应用程序的静态视图。它展示了实体，如包、类、接口及其属性（字段和方法），并描绘了它们之间的关系。它显示了哪些类和接口在包中定义。它描述了类和接口之间的继承关系。它还可以描述它们之间的关联——当一个类或接口定义了另一种类型的属性时。本章中所有的
    UML 表示都是类图。考试不涵盖 UML 图。但使用这些快速简单的图可以简化 Java 实体之间的关系——无论是在考试中还是在你的实际项目中。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, **bold font** will be used to indicate specific parts
    of code that we’re discussing, or changes or modifications in code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，**粗体字体**将用于指示我们正在讨论的代码的特定部分，或代码中的更改或修改。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here’s the code for class `AnnualExam`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类`AnnualExam`的代码：
- en: '![](026fig01_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](026fig01_alt.jpg)'
- en: Note that the `import` statement follows the `package` statement but precedes
    the `class` declaration. What happens if the class `AnnualExam` isn’t defined
    in a package? Will there be any change in the code if the classes `AnnualExam`
    and `ExamQuestion` are related, as depicted in [figure 1.4](#ch01fig04)?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`import`语句位于`package`语句之后，但在`class`声明之前。如果类`AnnualExam`未在包中定义，会发生什么？如果`AnnualExam`和`ExamQuestion`类如[图1.4](#ch01fig04)所示相关联，代码会有任何变化吗？
- en: Figure 1.4\. Relationship between the packageless class `AnnualExam` and `ExamQuestion`
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4. 无包的类`AnnualExam`与`ExamQuestion`之间的关系
- en: '![](01fig04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig04.jpg)'
- en: 'In this case, the class `AnnualExam` isn’t part of an explicit package, but
    the class `ExamQuestion` is part of the package `certification`. Here’s the code
    for the class `AnnualExam`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类`AnnualExam`不是显式包的一部分，但类`ExamQuestion`是`certification`包的一部分。以下是类`AnnualExam`的代码：
- en: '![](027fig01_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](027fig01_alt.jpg)'
- en: As you can see in the previous example code, the class `AnnualExam` doesn’t
    define the `package` statement, but it defines the `import` statement to import
    the class `certification.ExamQuestion`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例代码所示，类`AnnualExam`没有定义`package`语句，但它定义了`import`语句来导入`certification.ExamQuestion`类。
- en: 'If a `package` statement is present in a class, the `import` statement must
    follow the `package` statement. It’s important to maintain the order of the occurrence
    of the `package` and `import` statements. Reversing this order will result in
    your code failing to compile:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类中存在`package`语句，则`import`语句必须跟在`package`语句之后。保持`package`和`import`语句出现的顺序很重要。颠倒这个顺序会导致你的代码无法编译：
- en: '![](027fig02_alt.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](027fig02_alt.jpg)'
- en: We’ll discuss `import` statements in detail in [section 1.3](#ch01lev1sec3)
    of this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的[1.3节](#ch01lev1sec3)中详细讨论`import`语句。
- en: Comments
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注释
- en: 'You can also add comments to your Java code. Comments can appear at multiple
    places in a class. A comment can appear before and after a `package` statement,
    before and after the class definition, as well as before and within and after
    a method definition. Comments come in two flavors: multiline comments and end-of-line
    comments.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在Java代码中添加注释。注释可以出现在类中的多个位置。注释可以出现在`package`语句之前和之后，类定义之前和之后，以及方法定义之前和之后。注释有两种类型：多行注释和行尾注释。
- en: 'Multiline comments span multiple lines of code. They start with `/*` and end
    with `*/`. Here’s an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释跨越多行代码。它们以`/*`开始，以`*/`结束。以下是一个示例：
- en: '![](027fig03_alt.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](027fig03_alt.jpg)'
- en: 'Multiline comments can contain special characters. Here’s an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释可以包含特殊字符。以下是一个示例：
- en: '![](027fig04_alt.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](027fig04_alt.jpg)'
- en: 'In the preceding code, the comments don’t start with an asterisk on every line.
    But most of the time when you see a multiline comment in a Java source code file
    (.java file), you’ll notice that it uses an asterisk (`*`) to start the comment
    in the next line. Please note that this isn’t required—it’s done more for aesthetic
    reasons. Here’s an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注释不是每行都以星号开头。但大多数时候，当你看到Java源代码文件（.java文件）中的多行注释时，你会注意到它使用星号（`*`）在下一行开始注释。请注意，这不是必需的——这样做更多的是为了美观。以下是一个示例：
- en: '![](028fig01_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](028fig01_alt.jpg)'
- en: 'End-of-line comments start with `//` and, as evident by their name, they’re
    placed at the end of a line of code or on a blank line. The text between `//`
    and the end of the line is treated as a comment, which you’d normally use to briefly
    describe the line of code. Here’s an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾注释以`//`开头，正如其名称所示，它们放置在代码行末或空白行上。`//`和行尾之间的文本被视为注释，你通常使用它来简要描述代码行。以下是一个示例：
- en: '![](028fig02_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](028fig02_alt.jpg)'
- en: 'Though usage of multiline comments in the following code is uncommon, the exam
    expects you to know that the code is valid:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在以下代码中使用多行注释不常见，但考试要求你了解代码是有效的：
- en: '![](028fig03_alt.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](028fig03_alt.jpg)'
- en: 'Here’s what happens if you include multiline comments within quotes while assigning
    a string value:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在赋字符串值时在引号内包含多行注释，会发生以下情况：
- en: '![](028fig04_alt.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](028fig04_alt.jpg)'
- en: 'When included within double quotes, multiline comments are treated as regular
    characters and not as comments. So the following code won’t compile because the
    value assigned to variable `name` is an unclosed string literal value:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当包含在双引号内时，多行注释被视为普通字符，而不是注释。因此，以下代码无法编译，因为分配给变量 `name` 的值是一个未闭合的字符串字面值：
- en: '![](028fig05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](028fig05.jpg)'
- en: 'In the earlier section on the `package` statement, you read that a `package`
    statement, if present, should be the first line of code in a class. The only exception
    to this rule is the presence of comments. A comment can precede a `package` statement.
    The following code defines a `package` statement, with multiline and end-of-line
    comments:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `package` 语句部分，您了解到如果存在，则 `package` 语句应该是类中代码的第一行。这个规则的唯一例外是注释的存在。注释可以出现在
    `package` 语句之前。以下代码定义了一个 `package` 语句，其中包含多行和行尾注释：
- en: '![](029fig01_alt.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](029fig01_alt.jpg)'
- en: Line ![](num-1.jpg) defines an end-of-line code comment within multiline code.
    This is acceptable. The end-of-line code comment is treated as part of the multiline
    comment, not as a separate end-of-line comment. Lines ![](num-2.jpg) and ![](num-3.jpg)
    define end-of-line code comments. Line ![](num-4.jpg) defines an end-of-line code
    comment at the start of a line, after the class definition.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 行 ![](num-1.jpg) 定义了多行代码中的行尾代码注释。这是可接受的。行尾代码注释被视为多行注释的一部分，而不是单独的行尾注释。行 ![](num-2.jpg)
    和 ![](num-3.jpg) 定义了行尾代码注释。行 ![](num-4.jpg) 定义了行首的行尾代码注释，在类定义之后。
- en: The multiline comment is placed before the `package` statement, which is acceptable
    because comments can appear anywhere in your code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释放置在 `package` 语句之前，这是可接受的，因为注释可以出现在代码的任何位置。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Javadoc comments**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Javadoc 注释**'
- en: Javadoc comments are special comments that start with `/**` and end with `*/`
    in a Java source file. These comments are processed by Javadoc, a JDK tool, to
    generate API documentation for your Java source code files. To see it in action,
    compare the API documentation of the class `String` and its source code file (String.java).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc 注释是 Java 源文件中以 `/**` 开始并以 `*/` 结束的特殊注释。这些注释由 Javadoc 工具处理，以生成您的 Java
    源代码文件的 API 文档。要查看其工作情况，请比较类 `String` 的 API 文档及其源代码文件（String.java）。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Class declaration
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类声明
- en: 'The class declaration marks the start of a class. It can be as simple as the
    keyword `class` followed by the name of a class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明标志着类的开始。它可以像关键字 `class` 后跟类名这样简单：
- en: '![](029fig02_alt.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](029fig02_alt.jpg)'
- en: 'The declaration of a class is composed of the following parts:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类的声明由以下部分组成：
- en: Access modifiers
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: Nonaccess modifiers
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非访问修饰符
- en: Class name
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名
- en: Name of the base class, if the class is extending another class
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类名称，如果该类扩展了另一个类
- en: All implemented interfaces, if the class is implementing any interfaces
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类实现了任何接口，则所有实现的接口
- en: Class body (class fields, methods, constructors), included within a pair of
    curly braces, `{}`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类体（类字段、方法、构造函数），包含在一对大括号 `{}` 内
- en: Don’t worry if you don’t understand this material at this point. We’ll go through
    these details as we move through the exam preparation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在不理解这部分内容，请不要担心。我们将在准备考试的过程中详细讲解这些内容。
- en: 'Let’s look at the components of a class declaration using an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看类声明的组成部分：
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The components of the preceding class declaration can be illustrated as shown
    in [figure 1.5](#ch01fig05).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个类声明的组成部分可以如图 1.5 所示进行说明。
- en: Figure 1.5\. Components of a class declaration
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5. 类声明的组成部分
- en: '![](01fig05_alt.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig05_alt.jpg)'
- en: '[Table 1.1](#ch01table01) summarizes the compulsory and optional components.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1.1](#ch01table01) 总结了必需和可选组件。'
- en: Table 1.1\. Components of a class declaration
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.1. 类声明的组成部分
- en: '| Mandatory | Optional |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 必需 | 可选 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Keyword class | Access modifier, such as public |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 class | 访问修饰符，例如 public |'
- en: '| Name of the class | Nonaccess modifier, such as final |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 非访问修饰符，例如 final |'
- en: '| Class body, marked by the opening and closing curly braces, {} | Keyword
    extends together with the name of the base class |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 类体，由大括号 `{}` 标记 | 关键字 extends 以及基类的名称 |'
- en: '|   | Keyword implements together with the names of the interfaces being implemented
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|   | 关键字 implements 以及实现接口的名称 |'
- en: We’ll discuss the access and nonaccess modifiers in detail in [sections 1.4](#ch01lev1sec4)
    and [1.5](kindle_split_012.html#ch01lev1sec5) in this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的 [1.4 节](#ch01lev1sec4) 和 [1.5 节](kindle_split_012.html#ch01lev1sec5)
    中详细讨论访问和非访问修饰符。
- en: Class definition
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类定义
- en: A *class* is a design used to specify the attributes and behavior of an object.
    The attributes of an object are implemented using *variables*, and the behavior
    is implemented using *methods*. For example, consider a class as being like the
    design or specification of a mobile phone, and a mobile phone as being an object
    of that design. The same design can be used to create multiple mobile phones,
    just as the Java Virtual Machine (JVM) uses a class to create its objects. You
    can also consider a class as being like a mold that you can use to create meaningful
    and useful objects. A class is a design from which an object can be created.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*类* 是用于指定对象属性和行为的设计。对象的属性通过 *变量* 实现，行为通过 *方法* 实现。例如，可以将类视为移动电话的设计或规范，而移动电话是该设计的对象。可以使用相同的设计创建多个移动电话，就像
    Java 虚拟机 (JVM) 使用类来创建其对象一样。你还可以将类视为一个模具，你可以使用它来创建有意义的和有用的对象。类是一个可以从中创建对象的规范。'
- en: 'Let’s define a simple class to represent a mobile phone:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的类来表示移动电话：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Points to remember:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要点：
- en: A class name starts with the keyword `class`. Watch out for the case of the
    keyword `class`. Java is cAsE-sEnSiTivE. `class` (lowercase *c*) isn’t the same
    as `Class` (uppercase *C*). You can’t use the word `Class` (uppercase *C*) to
    define a class.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名以关键字 `class` 开头。注意关键字 `class` 的大小写。Java 是大小写敏感的。`class`（小写 *c*）与 `Class`（大写
    *C*）不同。你不能使用单词 `Class`（大写 *C*）来定义一个类。
- en: The state of a class is defined using attributes or instance variables.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的状态是通过属性或实例变量定义的。
- en: It isn’t compulsory to define all attributes of a class before defining its
    methods (the variable `weight` is defined after `Phone`’s constructor). But this
    is far from being optimal for readability.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义类的方法之前，不一定必须定义所有属性（变量 `weight` 在 `Phone` 构造函数之后定义）。但这对于可读性来说远非最佳。
- en: The behavior is defined using methods, which may include method parameters.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为是通过方法定义的，这些方法可能包括方法参数。
- en: A class definition may also include comments and constructors.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义还可以包括注释和构造函数。
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A class is a design from which an object can be created.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个可以从中创建对象的规范。
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Variables
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 变量
- en: Revisit the definition of the class `Phone` in the previous example. Because
    the variables `model`, `company`, and `weight` are used to store the state of
    an object (also called an *instance*), they’re called *instance variables* or
    *instance attributes*. Each object has its own copy of the instance variables.
    If you change the value of an instance variable for an object, the value for the
    same named instance variable won’t change for another object. The instance variables
    are defined within a class but outside all methods in a class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中重新审视类 `Phone` 的定义。因为变量 `model`、`company` 和 `weight` 用于存储对象的状态（也称为 *实例*），它们被称为
    *实例变量* 或 *实例属性*。每个对象都有自己的实例变量副本。如果你更改一个对象的实例变量的值，则同一名称的实例变量对另一个对象的值不会改变。实例变量是在类中定义的，但位于类中所有方法之外。
- en: A single copy of a *class variable* or `static` variable is shared by all the
    objects of a class. The `static` variables are covered in [section 1.5.3](kindle_split_012.html#ch01lev2sec22)
    with a detailed discussion of the nonaccess modifier `static`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *类变量* 或 `static` 变量的副本被类中的所有对象共享。`static` 变量在 [1.5.3 节](kindle_split_012.html#ch01lev2sec22)中有详细讨论，包括非访问修饰符
    `static`。
- en: Methods
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法
- en: Again, revisit the previous example. The methods `makeCall` and `receiveCall`
    are instance methods, which are generally used to manipulate the instance variables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回顾前面的示例。`makeCall` 和 `receiveCall` 方法是实例方法，通常用于操作实例变量。
- en: A *class method* or *static method* can be used to manipulate the `static` variables,
    as discussed in detail in [section 1.5.3](kindle_split_012.html#ch01lev2sec22).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*类方法* 或 *静态方法* 可以用来操作 `static` 变量。
- en: Constructors
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造函数
- en: Class `Phone` in the previous example defines a single constructor. A class
    constructor is used to create and initialize the objects of a class. A class can
    define multiple constructors that accept different sets of method parameters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Phone`类定义了一个单构造函数。类构造函数用于创建和初始化类的对象。一个类可以定义多个构造函数，这些构造函数接受不同的方法参数集。
- en: 1.1.2\. Structure and components of a Java source code file
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. Java源代码文件的结构和组件
- en: A Java source code file is used to define Java entities such as a class, interface,
    enum, and annotation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码文件用于定义Java实体，例如类、接口、枚举和注解。
- en: '|  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Java annotations are not on the exam and so won’t be discussed in this book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Java注解不在考试范围内，因此本书不会讨论。
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'All your Java code should be defined in Java source code files (text files
    whose names end with .java). The exam covers the following aspects of the structure
    of a Java source code file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有你的Java代码都应该定义在Java源代码文件中（以.java结尾的文本文件）。考试涵盖了Java源代码文件结构的以下方面：
- en: Definition of a class and an interface in a Java source code file
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java源代码文件中定义类和接口
- en: Definition of single or multiple classes and interfaces within the same Java
    source code file
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一Java源代码文件中定义单类或多接口
- en: Application of `import` and `package` statements to all the classes in a Java
    source code file
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`import`和`package`语句应用于Java源代码文件中的所有类
- en: We’ve already covered the detailed structure and definition of classes in [section
    1.1.1](#ch01lev2sec1). Let’s get started with the definition of an interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了[第1.1.1节](#ch01lev2sec1)中类的详细结构和定义。让我们开始定义接口。
- en: Definition of an interface in a Java source code file
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在Java源代码文件中定义接口
- en: An interface specifies a contract for the classes to implement. You can compare
    implementing an interface to signing a contract. An interface is a grouping of
    related methods and constants. Prior to Java 8, interface methods were implicitly
    abstract. But starting with Java version 8, the methods in an interface can define
    a default implementation. With Java 8, interfaces can also define `static` methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接口指定了类需要实现的合约。你可以将实现接口比作签订合同。接口是一组相关方法和常量的组合。在Java 8之前，接口方法默认是抽象的。但从Java 8版本开始，接口中的方法可以定义默认实现。使用Java
    8，接口也可以定义`static`方法。
- en: Here’s a quick example to help you understand the essence of interfaces. No
    matter which brand of television each of us has, every television provides the
    common functionality of changing the channel and adjusting the volume. You can
    compare the controls of a television set to an interface and the design of a television
    set to a class that implements the interface controls.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速例子，帮助你理解接口的本质。无论我们每个人拥有哪个品牌的电视，每台电视都提供了更改频道和调整音量的通用功能。你可以将电视机的控制面板比作接口，将电视机的设计比作实现接口控制的面板类。
- en: 'Let’s define this interface:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义这个接口：
- en: '[PRE2]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The definition of an interface starts with the keyword `interface`. Remember,
    Java is case-sensitive, so you can’t use the word `Interface` (with a capital
    *I*) to define an interface. This section provides a brief overview of interfaces.
    You’ll work with interfaces in detail in [chapter 6](kindle_split_019.html#ch06).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的定义以关键字`interface`开始。记住，Java是区分大小写的，所以你不能使用单词`Interface`（带大写的*I*）来定义接口。本节提供了接口的简要概述。你将在[第6章](kindle_split_019.html#ch06)中详细了解接口。
- en: Definition of single and multiple classes in a single Java source code file
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在单个Java源代码文件中定义单类和多类
- en: 'You can define either a single class or an interface in a Java source code
    file or multiple such entities. Let’s start with a simple example: a Java source
    code file called Single-Class.java that defines a single class `SingleClass`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Java源代码文件中定义一个类或一个接口，或者定义多个这样的实体。让我们从一个简单的例子开始：一个名为Single-Class.java的Java源代码文件，它定义了一个单独的类`SingleClass`：
- en: '![](033fig01_alt.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](033fig01_alt.jpg)'
- en: 'Here’s an example of a Java source code file, Multiple1.java, that defines
    multiple interfaces:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个Java源代码文件的例子，Multiple1.java，它定义了多个接口：
- en: '![](033fig02_alt.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](033fig02_alt.jpg)'
- en: 'You can also define a combination of classes and interfaces in the same Java
    source code file. Here’s an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在同一个Java源代码文件中定义类和接口的组合。以下是一个例子：
- en: '![](033fig03_alt.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](033fig03_alt.jpg)'
- en: No particular order is required to define multiple classes or interfaces in
    a single Java source code file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个Java源代码文件中定义多个类或接口不需要特定的顺序。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The classes and interfaces can be defined in any order of occurrence in a Java
    source code file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类和接口可以在Java源代码文件中以任何顺序定义。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When you define a `public` class or an interface in a Java source file, the
    names of the class or interface and Java source file must match. Also, a source
    code file can’t define more than one `public` class or interface. If you try to
    do so, your code won’t compile, which leads to a small hands-on exercise for you
    that I call *Twist in the Tale*, as mentioned in the preface. The answers to all
    these exercises are provided in the appendix.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Java源文件中定义一个`public`类或接口时，类或接口的名称必须与Java源文件名称匹配。此外，源代码文件不能定义超过一个`public`类或接口。如果你尝试这样做，你的代码将无法编译，这会为你提供一个我称为*故事中的转折*的小型实践练习，如前言中所述。所有这些练习的答案都提供在附录中。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**About the Twist in the Tale exercises**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于*故事中的转折*练习**'
- en: For these exercises, I’ve tried to use modified code from the examples already
    covered in the chapter. The *Twist in the Tale* title refers to modified or tweaked
    code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些练习，我尝试使用本章中已覆盖的示例中的修改后的代码。*故事中的转折*标题指的是修改或调整后的代码。
- en: These exercises will help you understand how even small code modifications can
    change the behavior of your code. They should also encourage you to carefully
    examine all the code in the exam. The reason for these exercises is that in the
    exam, you may be asked more than one question that seems to require the same answer.
    But on closer inspection, you’ll realize that the questions differ slightly, and
    this will change the behavior of the code and the correct answer option!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习将帮助你理解即使是微小的代码修改也能改变代码的行为。它们还应该鼓励你仔细检查考试中的所有代码。这些练习的原因是，在考试中，你可能会被问及多个看似需要相同答案的问题。但仔细检查后，你会发现这些问题略有不同，这将改变代码的行为和正确答案选项！
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Twist in the Tale 1.1
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '*故事中的转折* 1.1'
- en: Modify the contents of the Java source code file Multiple.java, and define a
    public interface in it. Execute the code and see how this modification affects
    your code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 修改Java源代码文件`Multiple.java`的内容，并在其中定义一个公共接口。执行代码并查看这种修改如何影响你的代码。
- en: 'Question: Examine the following content of Java source code file Multiple.java
    and select the correct options:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：检查以下Java源代码文件`Multiple.java`的内容，并选择正确的选项：
- en: '[PRE3]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Options:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 选项：
- en: A Java source code file can’t define multiple interfaces.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java源代码文件不能定义多个接口。
- en: A Java source code file can only define multiple classes.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java源代码文件只能定义多个类。
- en: A Java source code file can define multiple interfaces and classes.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java源代码文件可以定义多个接口和类。
- en: The previous class will fail to compile.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的类将无法编译。
- en: If you need help getting your system set up to write Java, refer to Oracle’s
    “Getting Started” tutorial, [http://docs.oracle.com/javase/tutorial/getStarted/](http://docs.oracle.com/javase/tutorial/getStarted/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助设置系统以编写Java，请参考Oracle的“入门”教程，[http://docs.oracle.com/javase/tutorial/getStarted/](http://docs.oracle.com/javase/tutorial/getStarted/)。
- en: Twist in the Tale 1.2
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '*故事中的转折* 1.2'
- en: 'Question: Examine the content of the following Java source code file, Multiple2.java,
    and select the correct option(s):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：检查以下Java源代码文件`Multiple2.java`的内容，并选择正确的选项（s）：
- en: '[PRE4]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Options:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 选项：
- en: The code fails to compile.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码无法编译。
- en: The code compiles successfully.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码编译成功。
- en: Removing the definition of class `Car` will compile the code.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`Car`类的定义将使代码编译成功。
- en: Changing class `Car` to a nonpublic class will compile the code.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Car`类改为非公共类将使代码编译成功。
- en: Changing interface `Multiple2` to a nonpublic interface will compile the code.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口`Multiple2`改为非公共接口将使代码编译成功。
- en: Application of package and import statements in Java source code files
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Java源代码文件中包和导入语句的应用
- en: In the previous section, I mentioned that you can define multiple classes and
    interfaces in the same Java source code file. When you use a `package` or `import`
    statement within such Java files, both the `package` and `import` statements apply
    to all the classes and interfaces defined in that source code file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我提到你可以在同一个Java源代码文件中定义多个类和接口。当你在这类Java文件中使用`package`或`import`语句时，这两个语句都适用于该源代码文件中定义的所有类和接口。
- en: 'For example, if you include a `package` and an `import` statement in Java source
    code file Multiple.java (as in the following code), `Car`, `Movable`, and `Printable`
    will be become part of the same package `com.manning.code`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在Java源代码文件Multiple.java中包含一个`package`和一个`import`语句（如下面的代码所示），`Car`、`Movable`和`Printable`将变成同一包`com.manning.code`的一部分：
- en: '![](035fig01_alt.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](035fig01_alt.jpg)'
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: Classes and interfaces defined in the same Java source code file *can’t* be
    defined in separate packages. Classes and interfaces imported using the `import`
    statement are available to all the classes and interfaces defined in the same
    Java source code file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一Java源代码文件中定义的类和接口*不能*定义在单独的包中。使用`import`语句导入的类和接口对同一Java源代码文件中定义的所有类和接口都是可用的。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the next section, you’ll create executable Java applications—classes that
    are used to define an entry point of execution for a Java application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将创建可执行Java应用程序——用于定义Java应用程序执行入口点的类。
- en: 1.2\. Executable Java applications
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 可执行Java应用程序
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[1.3](#ch01lev1sec3)] Create executable Java applications with a main method;
    run a Java program from the command line; including console output.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1.3](#ch01lev1sec3)] 使用具有`main`方法的可执行Java应用程序；从命令行运行Java程序；包括控制台输出。'
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The OCA Java SE 8 Programmer I exam requires that you understand the meaning
    of an executable Java application and its requirements, that is, what makes a
    regular Java class an executable Java class. You also need to know how to execute
    a Java program from the command line.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: OCA Java SE 8程序员I级考试要求你理解可执行Java应用程序及其要求的意义，即什么使一个普通Java类成为可执行Java类。你还需要知道如何从命令行执行Java程序。
- en: 1.2.1\. Executable Java classes versus non-executable Java classes
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. 可执行Java类与非可执行Java类
- en: Doesn’t the Java Virtual Machine execute all the Java classes when they are
    used? If so, what is a non-executable Java class?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Java虚拟机在Java类被使用时执行所有Java类吗？如果是这样，什么是非可执行Java类？
- en: An executable Java class, when handed over to the JVM, starts its execution
    at a particular point in the class—the `main` method. The JVM starts executing
    the code that’s defined in the `main` method. You can’t hand over a non-executable
    Java class (class without a `main` method) to the JVM and ask it to execute it.
    In this case, the JVM won’t know which method to execute because no entry point
    is marked.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个可执行Java类交给JVM时，它将在类中的特定点开始执行——即`main`方法。JVM将执行在`main`方法中定义的代码。你不能将一个非可执行Java类（没有`main`方法的类）交给JVM并要求它执行。在这种情况下，JVM将不知道执行哪个方法，因为没有标记入口点。
- en: Typically, an application consists of a number of classes and interfaces that
    are defined in multiple Java source code files. Of all these files, a programmer
    designates one of the classes as an executable class. The programmer can define
    the steps that the JVM should execute as soon as it launches the application.
    For example, a programmer can define an executable Java class that includes code
    to display the appropriate GUI window to a user and to open a database connection.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个应用程序由多个类和接口组成，这些类和接口定义在多个Java源代码文件中。在这些文件中，程序员会将其中一个类指定为可执行类。程序员可以定义JVM启动应用程序时应执行的步骤。例如，程序员可以定义一个包含显示适当GUI窗口给用户和打开数据库连接代码的可执行Java类。
- en: In [figure 1.6](#ch01fig06), the classes `Window`, `UserData`, `ServerConnection`,
    and `UserPreferences` don’t define a `main` method. Class `LaunchApplication`
    defines a `main` method and is an executable class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图1.6](#ch01fig06)中，类`Window`、`UserData`、`ServerConnection`和`UserPreferences`没有定义`main`方法。类`LaunchApplication`定义了一个`main`方法，是一个可执行类。
- en: Figure 1.6\. Class `LaunchApplication` is an executable Java class, but the
    rest of the `classes—Window, UserData, ServerConnection`, and `UserPreferences—aren't`.
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6\. 类`LaunchApplication`是一个可执行Java类，但其余的`类——Window、UserData、ServerConnection`和`UserPreferences`则不是。
- en: '![](01fig06_alt.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig06_alt.jpg)'
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A Java application can define more than one executable class. We choose one
    (and exactly one) when the time comes to start its execution by the JVM.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Java应用程序可以定义多个可执行类。当JVM开始执行时，我们会选择其中一个（并且恰好一个）。
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.2.2\. The main method
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. `main`方法
- en: 'The first requirement in creating an executable Java application is to create
    a class with a method whose signature (name and method arguments) matches the
    `main` method, defined as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可执行Java应用程序的第一个要求是创建一个方法签名（名称和方法参数）与以下定义的`main`方法相匹配的类：
- en: '[PRE5]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This `main` method should comply with the following rules:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此`main`方法应遵守以下规则：
- en: The method must be marked as a `public` method.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法必须被标记为`public`方法。
- en: The method must be marked as a `static` method.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法必须被标记为`static`方法。
- en: The name of the method must be `main`.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称必须是`main`。
- en: The return type of this method must be `void`.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法的返回类型必须是`void`。
- en: The method must accept a method argument of a `String` array or a variable argument
    (varargs) of type `String`.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法必须接受一个`String`数组或`String`类型的可变参数（varargs）作为方法参数。
- en: '[Figure 1.7](#ch01fig07) illustrates the previous code and its related set
    of rules.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.7](#ch01fig07)展示了前面的代码及其相关规则集。'
- en: Figure 1.7\. Ingredients of a correct `main` method
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7\. 正确`main`方法的组成部分
- en: '![](01fig07_alt.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig07_alt.jpg)'
- en: 'It’s valid to define the method parameter passed to the `main` method as a
    variable argument (*varargs*) of type `String`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给`main`方法的参数定义为`String`类型的可变参数（*varargs*）是有效的：
- en: '![](038fig01_alt.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](038fig01_alt.jpg)'
- en: 'To define a variable argument variable, the ellipsis (`...`) must follow the
    type of the variable and not the variable itself (a mistake made by a lot of new
    programmers):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个可变参数变量，省略号（`...`）必须跟在变量类型后面，而不是变量本身（许多新程序员都会犯的错误）：
- en: '![](038fig02_alt.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](038fig02_alt.jpg)'
- en: 'As mentioned previously, the name of the `String` array passed to the `main`
    method need not be `args` to qualify it as the correct `main` method. The following
    examples are also correct definitions of the `main` method:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，传递给`main`方法的`String`数组名称不必是`args`才能使其成为正确的`main`方法。以下也是`main`方法的正确定义示例：
- en: '![](038fig03_alt.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](038fig03_alt.jpg)'
- en: 'To define an array, the square brackets `[]` can follow either the variable
    name or its type. The following is a correct method declaration of the `main`
    method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 定义数组时，方括号`[]`可以跟在变量名或其类型后面。以下也是`main`方法的正确方法声明：
- en: '![](038fig04_alt.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](038fig04_alt.jpg)'
- en: 'It’s interesting to note that the placement of the keywords `public` and `static`
    can be interchanged, which means that the following are both correct method declarations
    of the `main` method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，关键字`public`和`static`的位置可以互换，这意味着以下都是`main`方法的正确方法声明：
- en: '![](038fig05_alt.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](038fig05_alt.jpg)'
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Though both `public static` and `static public` are the valid order of keywords
    to declare the `main` method, `public static` is more common and thus more readable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关键字`public static`和`static public`都是声明`main`方法的合法顺序，但`public static`更常见，因此更易读。
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'On execution, the code shown in [figure 1.7](#ch01fig07) outputs the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，如图1.7所示的代码将输出以下内容：
- en: '[PRE6]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a class defines a `main` method that doesn’t match the signature of *the*
    `main` method, it’s referred to as an *overloaded method* (overloaded methods
    are discussed in detail in [chapter 3](kindle_split_014.html#ch03)). Overloaded
    methods are methods with the same name but different signatures. For a quick example,
    class `HelloExam` can define multiple methods with the method name `main`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类定义了一个与*该*`main`方法签名不匹配的`main`方法，则称为*重载方法*（重载方法将在第3章中详细讨论）。重载方法是具有相同名称但签名不同的方法。例如，`HelloExam`类可以定义多个名为`main`的方法：
- en: '![](039fig01_alt.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](039fig01_alt.jpg)'
- en: On execution, JVM will execute *the* `main` method, resulting in the output
    `Hello exam`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，JVM将执行*该*`main`方法，结果输出`Hello exam`。
- en: 1.2.3\. Run a Java program from the command line
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 从命令行运行Java程序
- en: Almost all Java developers work with an Integrated Development Environment (IDE).
    This exam, however, expects you to understand how to execute a Java application,
    or an executable Java class, using the command prompt. For this reason, I suggest
    you work with a simple text editor and command line (even if this might never
    be the approach you use in the real world).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有Java开发者都使用集成开发环境（IDE）。然而，这个考试要求你理解如何使用命令提示符执行Java应用程序或可执行的Java类。因此，我建议你使用简单的文本编辑器和命令行（即使这可能是你永远不会在现实世界中使用的做法）。
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you need help getting your system set up to compile or execute Java applications
    using the command prompt, refer to Oracle’s detailed instructions at [http://docs.oracle.com/javase/tutorial/getStarted/cupojava/index.html](http://docs.oracle.com/javase/tutorial/getStarted/cupojava/index.html).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要帮助设置系统以使用命令提示符编译或执行Java应用程序，请参阅Oracle的详细说明[http://docs.oracle.com/javase/tutorial/getStarted/cupojava/index.html](http://docs.oracle.com/javase/tutorial/getStarted/cupojava/index.html)。
- en: '|  |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s revisit the code shown in [figure 1.7](#ch01fig07):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[图1.7](#ch01fig07)中显示的代码：
- en: '[PRE7]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To execute the preceding code using a command prompt, issue the command `java
    HelloExam`, as shown in [figure 1.8](#ch01fig08).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令提示符执行前面的代码，请输入命令`java HelloExam`，如图1.8所示。
- en: Figure 1.8\. Using the command prompt to execute a Java application
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8\. 使用命令提示符执行Java应用程序
- en: '![](01fig08_alt.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig08_alt.jpg)'
- en: 'I mentioned that the `main` method accepts an array of `String` as the method
    parameter. But how and where do you pass the array to the `main` method? Let’s
    modify the previous code to access and output values from this array:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到`main`方法接受一个`String`数组作为方法参数。但您如何以及在哪里将数组传递给`main`方法呢？让我们修改之前的代码来访问和输出这个数组中的值：
- en: '[PRE8]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let’s execute the preceding code using the command prompt, as shown in [figure
    1.9](#ch01fig09).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用命令提示符执行前面的代码，如图1.9所示。
- en: Figure 1.9\. Passing command parameters to a `main` method
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9\. 将命令参数传递给`main`方法
- en: '![](01fig09_alt.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig09_alt.jpg)'
- en: As you can see from the output shown in [figure 1.9](#ch01fig09), the keyword
    `java` and the name of the class aren’t passed as command parameters to the `main`
    method. The OCA Java SE 8 Programmer I exam will test you on your knowledge of
    whether the keyword `java` and the class name are passed on to the `main` method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[图1.9](#ch01fig09)所示的输出中可以看到，关键字`java`和类的名称并没有作为命令参数传递给`main`方法。OCA Java
    SE 8程序员I级考试将测试您对关键字`java`和类名是否传递给`main`方法的知识。
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The method parameters that are passed to the `main` method are also called command-line
    parameters or command-line values. As the name implies, these values are passed
    to a method from the command line.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`main`方法的方法参数也称为命令行参数或命令行值。正如其名所示，这些值是从命令行传递给方法的。
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you weren’t able to follow the code with respect to the arrays and the class
    `String`, don’t worry; we’ll cover the class `String` and arrays in detail in
    [chapter 4](kindle_split_015.html#ch04).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在处理数组或`String`类时没有跟上代码，请不要担心；我们将在第4章中详细讲解`String`类和数组。
- en: Here’s the next Twist in the Tale exercise for you. In this exercise, and in
    the rest of the book, you’ll see the names Shreya, Harry, Paul, and Selvan, who
    are hypothetical programmers also studying for this certification exam. The answer
    is provided in the appendix, as usual.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是下一个“故事转折”练习。在这个练习中，以及本书的其余部分，您将看到Shreya、Harry、Paul和Selvan这些名字，他们是假设的程序员，也在为这个认证考试学习。答案通常在附录中提供。
- en: Twist in the Tale 1.3
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折1.3
- en: One of the programmers, Harry, executed a program that gave the output `java
    one`. Now he’s trying to figure out which of the following classes outputs these
    results. Given that he executed the class using the command `java EJava java one
    one`, can you help him figure out the correct option(s)?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一位程序员Harry执行了一个程序，输出了`java one`。现在他正在试图找出以下哪个类输出了这些结果。鉴于他是使用命令`java EJava
    java one one`执行这个类的，你能帮助他找出正确的选项（们）吗？
- en: '[PRE9]'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Confusion with command-line parameters**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**与命令行参数的混淆**'
- en: If you’ve programmed in languages like C, you might get confused by the command-line
    parameters. Programming languages like C pass the name of a *program* as a command-line
    argument to the `main` method. But Java doesn’t pass the name of the *class* as
    an argument to the `main` method.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用过像C这样的语言编程，您可能会对命令行参数感到困惑。像C这样的编程语言会将*程序*的名称作为命令行参数传递给`main`方法。但Java不会将*类*的名称作为参数传递给`main`方法。
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.3\. Java packages
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. Java包
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[1.4](#ch01lev1sec4)] Import other Java packages to make them accessible in
    your code'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1.4](#ch01lev1sec4)] 将其他Java包导入到您的代码中以便使用'
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This exam covers importing packages into other classes. But with more than a
    decade and a half of experience, I’ve learned that before starting to *import*
    other packages into your own code, it’s important to understand what packages
    are, the difference between classes that are defined in a package and the classes
    that aren’t defined in a package, and why you need to import packages in your
    code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这场考试涵盖了将包导入其他类。但凭借超过十五年的经验，我了解到在开始将其他包导入自己的代码之前，了解包是什么，包中定义的类与未定义在包中的类的区别，以及为什么需要在代码中导入包，这些都非常重要。
- en: In this section, you’ll learn what Java packages are and how to create them.
    You’ll use the `import` statement, which enables you to use simple names for classes
    and interfaces defined in separate packages.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习Java包是什么以及如何创建它们。您将使用`import`语句，它允许您为在单独的包中定义的类和接口使用简单名称。
- en: 1.3.1\. The need for packages
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. 需要包的原因
- en: 'Why do you think we need packages? First, answer this question: do you remember
    having known more than one Amit, Paul, Anu, or John in your life? Harry knows
    more than one Paul (six, to be precise), whom he categorizes as managers, friends,
    and cousins. These are subcategorized by their location and relation, as shown
    in [figure 1.10](#ch01fig10).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为为什么我们需要包？首先，回答这个问题：您是否记得在您的生命中认识过不止一个Amit、Paul、Anu或John？Harry认识不止一个Paul（确切地说，是六个），他将他们分类为经理、朋友和堂兄弟。这些根据他们的位置和关系进行了子分类，如图1.10所示。[图1.10](#ch01fig10)。
- en: Figure 1.10\. Harry knows six Pauls!
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.10\. Harry认识六个Paul！
- en: '![](01fig10.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig10.jpg)'
- en: Similarly, you can use a package to group together a related set of classes
    and interfaces (I won’t discuss enums here because they aren’t covered on this
    exam). Packages also provide access protection and namespace management. You can
    create separate packages to define classes for separate projects, such as Android
    games and online healthcare systems. Further, you can create subpackages within
    these packages, such as separate subpackages for GUIs, database access, networking,
    and so on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以使用包将一组相关的类和接口组合在一起（这里不会讨论枚举，因为它们在本考试中未涉及）。包还提供访问保护和命名空间管理。您可以为不同的项目创建单独的包来定义类，例如Android游戏和在线医疗保健系统。此外，您可以在这些包内创建子包，例如用于GUI、数据库访问、网络等的不同子包。
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In real-life projects, you’ll rarely work with a package-less class or interface.
    Almost all organizations that develop software have strict package-naming rules,
    which are often documented.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中，您很少会与没有包的类或接口打交道。几乎所有开发软件的组织都有严格的包命名规则，这些规则通常会被记录下来。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: All classes and interfaces are defined in a package. If you don’t include an
    explicit `package` statement in a class or an interface, it’s part of a *default*
    package.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类和接口都是在包中定义的。如果您在类或接口中没有包含显式的`package`语句，它就是默认包的一部分。
- en: 1.3.2\. Defining classes in a package using the package statement
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. 使用包语句在包中定义类
- en: 'You can indicate that a class or an interface is defined in a package by using
    the `package` statement as the first statement in code. Here’s an example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`package`语句作为代码中的第一个语句来表示一个类或接口是在包中定义的。以下是一个示例：
- en: '![](042fig01.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](042fig01.jpg)'
- en: 'The class in the preceding code defines an `ExamQuestion` class in the `certification`
    package. You can define an interface, `MultipleChoice`, in a similar manner:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的类在`certification`包中定义了一个`ExamQuestion`类。您也可以以类似的方式定义一个接口，例如`MultipleChoice`：
- en: '[PRE13]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Figure 1.11](#ch01fig11) shows a UML class diagram depicting the relationship
    of the package `certification` to the class `ExamQuestion` and the interface `MultipleChoice`.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.11](#ch01fig11)显示了一个UML类图，描述了包`certification`与类`ExamQuestion`和接口`MultipleChoice`之间的关系。'
- en: Figure 1.11\. A UML class diagram showing the relationship shared by package
    `certification, class ExamQuestion`, and interface `MultipleChoice`
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.11\. 显示包`certification`、类`ExamQuestion`和接口`MultipleChoice`之间关系的UML类图
- en: '![](01fig11.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig11.jpg)'
- en: The name of the package in the previous examples is `certification`. You may
    use such names for small projects that contain only a few classes and interfaces,
    but it’s common for organizations to use subpackages to define *all* their classes.
    For example, if the folks at Oracle were to define a class to store exam questions
    for a Java Associate exam, they might use the package name `com.oracle.javacert.associate`.
    [Figure 1.12](#ch01fig12) shows its UML representation, together with the corresponding
    class definition.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，包的名称是`certification`。您可以使用这样的名称为只包含几个类和接口的小项目命名，但组织通常使用子包来定义**所有**它们的类。例如，如果Oracle的人要定义一个用于存储Java
    Associate考试问题的类，他们可能会使用包名`com.oracle.javacert.associate`。[图1.12](#ch01fig12)显示了其UML表示，以及相应的类定义。
- en: Figure 1.12\. A subpackage and its corresponding class definition
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.12\. 子包及其相应的类定义
- en: '![](01fig12_alt.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig12_alt.jpg)'
- en: A package is made of multiple sections that go from the more-generic (left)
    to the more-specific (right). The package name `com.oracle.javacert.associate`
    follows a package-naming convention recommended by Oracle and shown in [table
    1.2](#ch01table02).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 包由多个部分组成，从更通用的（左侧）到更具体的（右侧）。包名 `com.oracle.javacert.associate` 遵循 Oracle 推荐的包命名约定，并在
    [表 1.2](#ch01table02) 中展示。
- en: Table 1.2\. Package-naming conventions used in the package name `com.oracle.javacert.associate`
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.2\. 在包名 `com.oracle.javacert.associate` 中使用的包命名约定
- en: '| Package or subpackage name | Its meaning |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 包或子包名称 | 其含义 |'
- en: '| --- | --- |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| com | Commercial. A couple of the commonly used three-letter package abbreviations
    are'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '| com | 商业。常用的三个字母包缩写之一是'
- en: gov—for government bodies
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gov—for government bodies
- en: edu—for educational institutions
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: edu—for educational institutions
- en: '|'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| oracle | Name of the organization |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| oracle | 组织名称'
- en: '| javacert | Further categorization of the project at Oracle |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| javacert | Oracle 项目进一步分类'
- en: '| associate | Further subcategorization of Java certification |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| associate | Java 认证进一步细分'
- en: Rules to remember
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 需要记住的规则
- en: 'Here are a few of important rules about packages:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 关于包的一些重要规则如下：
- en: Per Java naming conventions, package names should all be in lowercase.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 Java 命名约定，包名应全部小写。
- en: The package and subpackage names are separated using a dot (`.`).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包和子包名称使用点 (`.`) 分隔。
- en: Package names follow the rules defined for valid identifiers in Java.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名遵循 Java 中有效标识符定义的规则。
- en: For classes and interfaces defined in a package, the `package` statement is
    the first statement in a Java source file (a .java file). The exception is that
    comments can appear before or after a `package` statement.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于在包中定义的类和接口，`package` 语句是 Java 源文件（.java 文件）中的第一个语句。例外情况是注释可以出现在 `package`
    语句之前或之后。
- en: There can be a maximum of one `package` statement per Java source code file
    (.java file).
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 Java 源代码文件 (.java 文件) 中最多只能有一个 `package` 语句。
- en: All the classes and interfaces defined in a Java source code file are defined
    in the same package. They can’t be defined in separate packages.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 源代码文件中定义的所有类和接口都在同一个包中定义。它们不能在单独的包中定义。
- en: '|  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A fully qualified name for a class or interface is formed by prefixing its package
    name with its name (separated by a dot). The fully qualified name of the class
    `ExamQuestion` is `certification.ExamQuestion` in [figure 1.11](#ch01fig11) and
    `com.oracle.javacert.associate.ExamQuestion` in [figure 1.12](#ch01fig12).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 类或接口的完全限定名是通过在其包名前加上其名称（用点分隔）来形成的。在图 1.11 中，`ExamQuestion` 类的完全限定名是 `certification.ExamQuestion`，在图
    1.12 中是 `com.oracle.javacert.associate.ExamQuestion`。
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Directory structure and package hierarchy
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 目录结构和包层次结构
- en: The hierarchy of classes and interfaces defined in packages must match the hierarchy
    of the directories in which these classes and interfaces are defined in the code.
    For example, the class `ExamQuestion` in the `certification` package should be
    defined in a directory with the name “certification.” The name of the directory
    “certification” and its location are governed by the rules shown in [figure 1.13](#ch01fig13).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 包中定义的类和接口的层次结构必须与代码中定义这些类和接口的目录层次结构相匹配。例如，`certification` 包中的 `ExamQuestion`
    类应在名为“certification”的目录中定义。目录“certification”的名称和位置由图 1.13 中所示的规则所控制。
- en: Figure 1.13\. Matching directory structure and package hierarchy
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.13\. 匹配的目录结构和包层次结构
- en: '![](01fig13_alt.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig13_alt.jpg)'
- en: For the package example shown in [figure 1.13](#ch01fig13), note that there
    isn’t any constraint on the location of the base directory in which the directory
    structure is defined, as shown in [figure 1.14](#ch01fig14).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图 1.13 中所示的包示例，请注意，定义目录结构的基目录位置没有限制，如图 1.14 所示。
- en: Figure 1.14\. There’s no constraint on the location of the base directory to
    define directories corresponding to package hierarchy.
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.14\. 定义目录结构对应包层次结构的基本目录位置没有限制。
- en: '![](01fig14_alt.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig14_alt.jpg)'
- en: Setting the classpath for packaged classes
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置打包类的类路径
- en: To enable the Java Runtime Environment (JRE) to find your classes, add the base
    directory that contains your packaged Java code to the classpath.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Java 运行时环境 (JRE) 能够找到您的类，请将包含您的打包 Java 代码的基本目录添加到类路径中。
- en: For example, to enable the JRE to locate the `certification.ExamQuestion` class
    from the previous examples, add the directory C:\MyCode to the classpath. To enable
    the JRE to locate the class `com.oracle.javacert.associate.ExamQuestion`, add
    the directory C:\ProjectCode to the classpath.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了使JRE能够定位到前面例子中的`certification.ExamQuestion`类，将C:\MyCode目录添加到classpath中。为了使JRE能够定位到类`com.oracle.javacert.associate.ExamQuestion`，将C:\ProjectCode目录添加到classpath中。
- en: '|  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You needn’t bother setting the classpath if you’re working with an IDE. But
    I strongly encourage you to learn how to work with a simple text editor and how
    to set a classpath. This can be helpful with your projects at work. The exam expects
    you to spot code with compilation errors, which isn’t easy to do if you didn’t
    learn how to do it without an IDE (IDEs usually include code autocorrection or
    autocompletion features).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是IDE，你不需要麻烦设置classpath。但我强烈建议你学习如何使用简单的文本编辑器以及如何设置classpath。这可以在你的工作中有所帮助。考试期望你能够发现带有编译错误的代码，如果你没有学习如何在没有IDE的情况下做到这一点（IDE通常包括代码自动纠正或自动完成功能），这并不容易。
- en: '|  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.3.3\. Using simple names with import statements
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3\. 使用import语句的简单名称
- en: The `import` statement enables you to use *simple names* instead of using *fully
    qualified names* for classes and interfaces defined in separate packages.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句允许你使用*简单名称*而不是使用*完全限定名称*来引用定义在单独包中的类和接口。'
- en: Let’s work with a real-life example. Imagine your home and your office. LivingRoom
    and Kitchen within your home can refer to each other without mentioning that they
    exist within the same home. Similarly, in an office, a Cubicle and a ConferenceHall
    can reference each other without explicitly mentioning that they exist within
    the same office. But Home and Office can’t access each other’s rooms or cubicles
    without stating that they exist in a separate home or office. This situation is
    represented in [figure 1.15](#ch01fig15).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个现实生活中的例子来工作。想象一下你的家和你的办公室。家里的客厅和厨房可以相互引用，而不必提到它们存在于同一个家中。同样，在办公室里，隔间和会议室可以相互引用，而不必明确提到它们存在于同一个办公室。但是，如果没有说明它们存在于不同的家或办公室，Home和Office就不能访问对方的房间或隔间。这种情况在[图1.15](#ch01fig15)中得到了表示。
- en: Figure 1.15\. To refer to each other’s members, Home and Office should specify
    that they exist in separate places.
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.15\. 为了相互引用成员，Home和Office应该指定它们存在于不同的地方。
- en: '![](01fig15_alt.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig15_alt.jpg)'
- en: To refer to the LivingRoom in Cubicle, you *must* specify its complete location,
    as shown in the left part of the [figure 1.16](#ch01fig16). As you can see in
    this figure, repeated references to the location of LivingRoom make the description
    of LivingRoom look tedious and redundant. To avoid this, you can display a notice
    in Cubicle that all occurrences of LivingRoom refer to LivingRoom in Home and
    thereafter use its simple name. Home and Office are like Java packages, and this
    notice is the equivalent of the `import` statement. [Figure 1.16](#ch01fig16)
    shows the difference in using fully qualified names and simple names for LivingRoom
    in Cubicle.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用隔间中的客厅，你必须指定其完整位置，如图[图1.16](#ch01fig16)的左侧所示。正如你可以从这张图中看到的，对客厅位置的重复引用使得对客厅的描述看起来繁琐且重复。为了避免这种情况，你可以在隔间中显示一个通知，说明所有对客厅的引用都指的是家中的客厅，之后可以使用其简单名称。Home和Office就像Java包一样，这个通知相当于`import`语句。[图1.16](#ch01fig16)展示了在隔间中使用完全限定名称和简单名称对客厅的差别。
- en: Figure 1.16\. LivingRoom can be accessed in Cubicle by using its fully qualified
    name. It can also be accessed using its simple name if you also use the `import`
    statement.
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.16\. 在隔间中，可以通过使用其完全限定名称来访问客厅。如果你也使用`import`语句，也可以使用其简单名称来访问。
- en: '![](01fig16_alt.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig16_alt.jpg)'
- en: Let’s implement the preceding example in code, where classes `LivingRoom` and
    `Kitchen` are defined in the package `home` and classes `Cubicle` and `ConferenceHall`
    are defined in the package `office`. Class `Cubicle` uses (is associated to) class
    `LivingRoom` in the package `home`, as shown in [figure 1.17](#ch01fig17).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中实现前面的例子，其中`LivingRoom`和`Kitchen`类定义在`home`包中，而`Cubicle`和`ConferenceHall`类定义在`office`包中。类`Cubicle`使用（关联到）`home`包中的`LivingRoom`类，如图[图1.17](#ch01fig17)所示。
- en: Figure 1.17\. A UML representation of classes `LivingRoom` and `Cubicle`, defined
    in separate packages, with their associations
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.17\. 定义在单独包中的`LivingRoom`和`Cubicle`类的UML表示，以及它们之间的关联
- en: '![](01fig17.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig17.jpg)'
- en: 'Class `Cubicle` can refer to class `LivingRoom` without using an `import` statement:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Cubicle` 可以不使用 `import` 语句来引用类 `LivingRoom`：
- en: '![](046fig01_alt.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](046fig01_alt.jpg)'
- en: 'Class `Cubicle` can use the simple name for class `LivingRoom` by using the
    `import` statement:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Cubicle` 可以通过使用 `import` 语句来使用类 `LivingRoom` 的简单名称：
- en: '![](047fig01_alt.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](047fig01_alt.jpg)'
- en: '|  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `import` statement doesn’t embed the contents of the imported class in your
    class, which means that *importing* more classes doesn’t increase the size of
    your own class.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句不会将导入类的内容嵌入到你的类中，这意味着*导入*更多类不会增加你自己的类的大小。'
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.3.4\. Using packaged classes without using the import statement
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4\. 不使用 `import` 语句使用包类
- en: 'It’s possible to use a packaged class or interface without using the `import`
    statement, by using its fully qualified name:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用完全限定的名称，而不使用 `import` 语句来使用包中的类或接口：
- en: '![](047fig02_alt.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](047fig02_alt.jpg)'
- en: But using a fully qualified class name can clutter your code if you create multiple
    variables of interfaces and classes defined in other packages. *Don’t* use this
    approach in real projects.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你创建了多个在其他包中定义的接口和类的变量，使用完全限定的类名可能会使你的代码变得杂乱。*不要*在实际项目中使用这种方法。
- en: '|  |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You don’t need an explicit `import` statement to use members from the `java.lang`
    package. Classes and interfaces in this package are automatically imported in
    *all* other Java classes, interfaces, or enums.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.lang` 包的成员不需要显式的 `import` 语句。此包中的类和接口在 *所有* 其他 Java 类、接口或枚举中自动导入。
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'For the exam, it’s important to note that you can’t use the `import` statement
    to access multiple classes or interfaces with the same names from different packages.
    For example, the Java API defines class `Date` in two commonly used packages:
    `java.util` and `java.sql`. To define variables of these classes in a class, use
    their fully qualified names with the variable declaration:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于考试，重要的是要注意你不能使用 `import` 语句从不同包中访问具有相同名称的多个类或接口。例如，Java API 在两个常用包中定义了 `Date`
    类：`java.util` 和 `java.sql`。要在类中定义这些类的变量，请使用变量声明中的完全限定名称：
- en: '![](047fig03_alt.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图片](047fig03_alt.jpg)'
- en: 'An attempt to use an `import` statement to import both these classes in the
    same class will not compile:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在同一个类中使用 `import` 语句导入这两个类将无法编译：
- en: '![](048fig01_alt.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图片](048fig01_alt.jpg)'
- en: 'An alternate approach (which works well in real projects) is to use the `import`
    definition with the class or interface that you use more often and fully reference
    the one that you use just from time to time:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法（在实际项目中效果很好）是使用你使用频率较高的类或接口的 `import` 定义，并完全引用你偶尔使用的那个：
- en: '![](048fig02_alt.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图片](048fig02_alt.jpg)'
- en: 1.3.5\. Importing a single member versus all members of a package
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.5\. 导入单个成员与导入包的所有成员
- en: You can import either a single member or all members (classes and interfaces)
    of a package using the `import` statement. First, revisit the UML notation of
    the `certification` package, as shown in [figure 1.18](#ch01fig18).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `import` 语句导入包的单个成员或所有成员（类和接口）。首先，回顾一下 `certification` 包的 UML 表示，如图 1.18
    所示。
- en: Figure 1.18\. A UML representation of the `certification` package
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.18\. `certification` 包的 UML 表示
- en: '![](01fig18.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig18.jpg)'
- en: 'Examine the following code for the class `AnnualExam`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下 `AnnualExam` 类的代码：
- en: '![](048fig03_alt.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](048fig03_alt.jpg)'
- en: 'By using the wildcard character, an asterisk (`*`), you can import all the
    `public` members, classes, and interfaces of a package. Compare the previous class
    definition with the following definition of the class `AnnualExam`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用通配符，星号 (`*`)，你可以导入一个包的所有 `public` 成员、类和接口。比较以下类定义与 `AnnualExam` 类的以下定义：
- en: '![](049fig01_alt.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](049fig01_alt.jpg)'
- en: '|  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When overused, using an asterisk to import all members of a package has a drawback.
    It may be harder to figure out which imported class or interface comes from which
    package.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当过度使用时，使用星号导入一个包的所有成员会有一个缺点。可能更难确定哪个导入的类或接口来自哪个包。
- en: '|  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When you work with an IDE, it may automatically add `import` statements for
    classes and interfaces that you reference in your code.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 IDE 时，它可能会自动添加你在代码中引用的类和接口的 `import` 语句。
- en: 1.3.6\. The import statement doesn’t import the whole package tree
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.6\. `import` 语句不会导入整个包树
- en: You can’t import classes from a subpackage by using an asterisk in the `import`
    statement. For example, the UML notation in [figure 1.19](#ch01fig19) depicts
    the package `com.oracle.javacert` with the class `Schedule` and two subpackages,
    `associate` and `webdeveloper`. Package `associate` contains class `ExamQuestion`,
    and package `webdeveloper` contains class `MarkSheet`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用`import`语句中的星号导入子包中的类。例如，[图1.19](#ch01fig19)中的UML表示法描述了包含`Schedule`类和两个子包`associate`和`webdeveloper`的包`com.oracle.javacert`。包`associate`包含`ExamQuestion`类，而包`webdeveloper`包含`MarkSheet`类。
- en: Figure 1.19\. A UML representation of package `com.oracle.javacert` and its
    subpackages
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.19\. 包`com.oracle.javacert`及其子包的UML表示
- en: '![](01fig19.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig19.jpg)'
- en: 'The following `import` statement will import only the class `Schedule`. It
    won’t import the classes `ExamQuestion` and `MarkSheet`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`import`语句只会导入`Schedule`类。它不会导入`ExamQuestion`和`MarkSheet`类：
- en: '![](049fig02_alt.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](049fig02_alt.jpg)'
- en: 'Similarly, the following `import` statement will import all the classes from
    the packages `associate` and `webdeveloper`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下`import`语句会导入`associate`和`webdeveloper`包中的所有类：
- en: '![](050fig01_alt.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](050fig01_alt.jpg)'
- en: 1.3.7\. Importing classes from the default package
  id: totrans-411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.7\. 从默认包导入类
- en: What happens if you don’t include a package statement in your classes or interfaces?
    In that case, they become part of a *default, no-name* package. This default package
    is automatically imported in the Java classes and interfaces defined within the
    same directory on your system.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在类或接口中不包括包声明，会发生什么？在这种情况下，它们将成为一个*默认、无名称*包的一部分。这个默认包会自动导入你系统同一目录中定义的Java类和接口。
- en: 'For example, the classes `Person` and `Office`, which aren’t defined in an
    explicit package, can use each other if they’re defined in the same directory:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，未在显式包中定义的`Person`和`Office`类，如果它们定义在同一个目录中，则可以相互使用：
- en: '![](050fig02.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](050fig02.jpg)'
- en: A class from a default package can’t be used in any named packaged class, regardless
    of whether they’re defined within the same directory or not.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 来自默认包的类无法在任何命名包的类中使用，无论它们是否定义在同一个目录中。
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Members of a named package can’t access classes and interfaces defined in the
    *default* package.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 命名包的成员无法访问在*默认*包中定义的类和接口。
- en: '|  |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.3.8\. Static imports
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.8\. 静态导入
- en: 'You can import an individual `static` member of a class or all its `static`
    members by using the `import static` statement. Although accessible using an instance,
    the `static` members are better accessed by prefixing their name with the class
    or interface names. By using `static import`, you can drop the prefix and just
    use the name of the `static` variable or method. In the following code, class
    `ExamQuestion` defines a `public static` variable `marks` and a `public static`
    method `print`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`import static`语句导入一个类的单个`static`成员或所有`static`成员。虽然可以通过实例访问，但最好通过在名称前加上类或接口名称来访问`static`成员。通过使用`static
    import`，你可以省略前缀，只需使用`static`变量或方法的名称。在以下代码中，类`ExamQuestion`定义了一个`public static`变量`marks`和一个`public
    static`方法`print`：
- en: '![](050fig03_alt.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![](050fig03_alt.jpg)'
- en: 'The `marks` variable can be accessed in the class `AnnualExam` using the `import
    static` statement. The order of the keywords `import` and `static` can’t be reversed:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`import static`语句，可以在`AnnualExam`类中访问`marks`变量。`import`和`static`关键字的顺序不能颠倒：
- en: '![](051fig01_alt.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](051fig01_alt.jpg)'
- en: '|  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: This feature is called *static imports*, but the syntax is `import static`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性被称为*静态导入*，但其语法是`import static`。
- en: '|  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To access all `public` and `static` members of class `ExamQuestion` in class
    `AnnualExam` without importing each of them individually, you can use an asterisk
    with the `import static` statement:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`AnnualExam`类中访问`ExamQuestion`类的所有`public`和`static`成员，而不需要单独导入每个成员，你可以使用`import
    static`语句中的星号：
- en: '![](051fig02_alt.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](051fig02_alt.jpg)'
- en: Because the variable `marks` and method `print` are defined as `public` members,
    they’re accessible to the class `AnnualExam`. By using the `import static` statement,
    you don’t have to prefix them with their class name.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`marks`变量和方法`print`被定义为`public`成员，它们对`AnnualExam`类是可访问的。通过使用`import static`语句，你不需要在它们前面加上它们的类名。
- en: '|  |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: On real projects, avoid overusing static imports; otherwise, the code might
    become a bit confusing about which imported component comes from which class.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中，避免过度使用静态导入；否则，代码可能会变得有些混乱，不清楚哪个导入组件来自哪个类。
- en: '|  |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The accessibility of a class, an interface, and their methods and variables
    is determined by their access modifiers, which are covered in the next section.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 类、接口及其方法和变量的可访问性由它们的访问修饰符决定，这些将在下一节中介绍。
- en: 1.4\. Java access modifiers
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. Java访问修饰符
- en: '|  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[6.4](kindle_split_020.html#ch06lev1sec4)] Apply access modifiers'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6.4](kindle_split_020.html#ch06lev1sec4)] 应用访问修饰符'
- en: '|  |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, we’ll cover all the access modifiers—`public`, `protected`,
    and `private`—as well as *default access*, which is the result when you don’t
    use an access modifier. We’ll also look at how you can use access modifiers to
    restrict the accessibility of a class and its members in the same and separate
    packages.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖所有访问修饰符——`public`、`protected`和`private`——以及*默认访问*，这是当你不使用访问修饰符时的结果。我们还将探讨如何使用访问修饰符来限制同一包和不同包中类及其成员的可访问性。
- en: 1.4.1\. Access modifiers
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1\. 访问修饰符
- en: Let’s start with an example. Examine the definitions of the classes `House`
    and `Book` in the following code and the UML representation shown in [figure 1.20](#ch01fig20).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始。检查以下代码中`House`和`Book`类的定义以及[图1.20](#ch01fig20)中显示的UML表示。
- en: Figure 1.20\. The nonpublic class `Book` can’t be accessed outside the package
    `library`.
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.20\. 非公共类`Book`不能在包`library`外部访问。
- en: '![](01fig20.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig20.jpg)'
- en: '[PRE14]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the current class definitions, the class `House` can’t access the class
    `Book`. Can you make the necessary changes (in terms of the access modifiers)
    to make the class `Book` accessible to the class `House`?
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前的类定义，`House`类无法访问`Book`类。你能通过访问修饰符（在术语上）进行必要的更改，使`Book`类对`House`类可访问吗？
- en: This one shouldn’t be difficult. From the discussion of class declarations in
    [section 1.1](kindle_split_011.html#ch01lev1sec1), you know that a top-level class
    can be defined only by using the `public` or default access modifiers. If you
    declare the class `Book` using the access modifier `public`, it’ll be accessible
    outside the package in which it is defined.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点不应该很难。从[第1.1节](kindle_split_011.html#ch01lev1sec1)中关于类声明的讨论中，你知道顶层类只能通过使用`public`或默认访问修饰符来定义。如果你使用访问修饰符`public`声明`Book`类，它将在定义它的包外部可访问。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A top-level class is a class that isn’t defined within any other class. A class
    that is defined within another class is called a *nested* or *inner class*. Nested
    and inner classes aren’t on the OCA Java SE 8 Programmer I exam.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层类是指不在任何其他类中定义的类。在另一个类中定义的类称为*嵌套*或*内部类*。嵌套和内部类不在OCA Java SE 8程序员I考试范围内。
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What do they control?
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 它们控制什么？
- en: Access modifiers control the accessibility of a class or an interface, including
    its members (methods and variables), by other classes and interfaces within the
    same or separate packages. By using the appropriate access modifiers, you can
    limit access to your class or interface and their members.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符通过其他类和接口（在同一包或不同包中）控制类或接口的可访问性，包括其成员（方法和变量）。通过使用适当的访问修饰符，您可以限制对类或接口及其成员的访问。
- en: Can access modifiers be applied to all types of Java entities?
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 访问修饰符可以应用于所有类型的Java实体吗？
- en: Access modifiers can be applied to classes, interfaces, and their members (instance
    and class variables and methods). Local variables and method parameters can’t
    be defined using access modifiers. An attempt to do so will prevent the code from
    compiling.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符可以应用于类、接口及其成员（实例和类变量和方法）。局部变量和方法参数不能使用访问修饰符定义。尝试这样做将阻止代码编译。
- en: 'How many access modifiers are there: three or four?'
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有多少种访问修饰符：三种还是四种？
- en: Programmers are frequently confused about the number of access modifiers in
    Java because the *default access* isn’t defined using an explicit keyword. If
    a Java class, interface, method, or variable isn’t defined using an explicit access
    modifier, it is said to be defined using the *default access*, also called *package
    access*.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常对Java中的访问修饰符数量感到困惑，因为*默认访问*不是使用显式关键字定义的。如果一个Java类、接口、方法或变量没有使用显式访问修饰符定义，那么它被认为是使用*默认访问*定义的，也称为*包访问*。
- en: 'Java has four access levels:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Java有四个访问级别：
- en: '`public` (least restrictive)'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`（最不限制）'
- en: '`protected`'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`'
- en: default
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认
- en: '`private` (most restrictive)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`（最限制）'
- en: 'To understand all of these access levels, we’ll use the same set of classes:
    `Book`, `CourseBook`, `Librarian`, `StoryBook`, and `House`. [Figure 1.21](#ch01fig21)
    depicts these classes using UML notation.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解所有这些访问级别，我们将使用相同的类集：`Book`、`CourseBook`、`Librarian`、`StoryBook` 和 `House`。[图
    1.21](#ch01fig21) 使用 UML 表示法描述了这些类。
- en: Figure 1.21\. A set of classes and their relationships to help you understand
    access modifiers
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.21\. 一组类及其关系，以帮助您理解访问修饰符
- en: '![](01fig21_alt.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig21_alt.jpg)'
- en: Classes `Book`, `CourseBook`, and `Librarian` are defined in the package `library`.
    The classes `StoryBook` and `House` are defined in the package `building`. Further,
    classes `StoryBook` and `CourseBook` (defined in separate packages) extend class
    `Book`. Using these classes, I’ll show how the accessibility of a class and its
    members varies with different access modifiers, from unrelated to derived classes,
    across packages.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Book`、`CourseBook` 和 `Librarian` 定义在包 `library` 中。类 `StoryBook` 和 `House`
    定义在包 `building` 中。此外，类 `StoryBook` 和 `CourseBook`（在单独的包中定义）扩展了类 `Book`。使用这些类，我将展示类的可访问性和其成员在不同访问修饰符下的变化，从无关类到派生类，跨包。
- en: As I cover each of the access modifiers, I’ll add a set of instance variables
    and a method to the class `Book` with the relevant access modifier. I’ll then
    define code in other classes to access class `Book` and its members.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍每个访问修饰符时，我将向类 `Book` 添加一组实例变量和具有相关访问修饰符的方法。然后，在其它类中定义代码以访问类 `Book` 和其成员。
- en: 1.4.2\. Public access modifier
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. 公共访问修饰符
- en: This is the least restrictive access modifier. Classes and interfaces defined
    using the `public` access modifier are accessible across all packages, from derived
    to unrelated classes.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最不限制的访问修饰符。使用 `public` 访问修饰符定义的类和接口可以在所有包中访问，从派生类到无关类。
- en: To understand the `public` access modifier, let’s define the class `Book` as
    a `public` class and add a `public` instance variable (`isbn`) and a `public`
    method (`printBook`) to it. [Figure 1.22](#ch01fig22) shows the UML notation.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 `public` 访问修饰符，让我们将类 `Book` 定义为一个 `public` 类，并向其添加一个 `public` 实例变量（`isbn`）和一个
    `public` 方法（`printBook`）。[图 1.22](#ch01fig22) 展示了 UML 表示法。
- en: Figure 1.22\. Understanding the `public` access modifier
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.22\. 理解 `public` 访问修饰符
- en: '![](01fig22_alt.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig22_alt.jpg)'
- en: 'Definition of class `Book`:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Book` 的定义：
- en: '![](054fig01_alt.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](054fig01_alt.jpg)'
- en: The `public` access modifier is said to be the least restrictive, so let’s try
    to access the `public` class `Book` and its `public` members from class `House`.
    We’ll use class `House` because `House` and `Book` are defined in separate packages
    and they’re *unrelated*.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 访问修饰符被认为是限制最少的，因此让我们尝试从类 `House` 访问 `public` 类 `Book` 和其 `public`
    成员。我们将使用类 `House`，因为 `House` 和 `Book` 定义在不同的包中，并且它们是 *无关的*。'
- en: '|  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The term *unrelated classes* in this chapter refers to classes that don’t share
    inheritance relation. For instance, classes `House` and `Book` are unrelated,
    if neither `House` derives from `Book` nor `Book` derives from `House`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提到的“无关类”指的是没有共享继承关系的类。例如，如果 `House` 既不派生自 `Book`，`Book` 也不派生自 `House`，则类
    `House` 和 `Book` 是无关的。
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Class `House` doesn’t enjoy any advantages by being defined in the same package
    or being a derived class.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `House` 在定义在同一个包中或作为派生类的情况下没有获得任何优势。
- en: 'Here’s the code for class `House`:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类 `House` 的代码：
- en: '![](054fig02_alt.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![](054fig02_alt.jpg)'
- en: 'In the preceding example, class `Book` and its `public` members—instance variable
    `isbn` and method `printBook`—are accessible to class `House`. They are also accessible
    to the other classes: `StoryBook`, `Librarian`, `House`, and `CourseBook`. [Figure
    1.23](#ch01fig23) shows the classes that can access a `public` class and its members.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，类 `Book` 和其 `public` 成员——实例变量 `isbn` 和方法 `printBook`——对类 `House` 可访问。它们也对其他类可访问：`StoryBook`、`Librarian`、`House`
    和 `CourseBook`。[图 1.23](#ch01fig23) 展示了可以访问 `public` 类及其成员的类。
- en: Figure 1.23\. Classes that can access a public class and its members
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.23\. 可以访问公共类及其成员的类
- en: '![](01fig23.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig23.jpg)'
- en: 1.4.3\. Protected access modifier
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.3\. 受保护的访问修饰符
- en: The members of a class defined using the `protected` access modifier are accessible
    to
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `protected` 访问修饰符定义的类的成员可被访问
- en: Classes and interfaces defined in the same package
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一包中定义的类和接口
- en: All derived classes, even if they’re defined in separate packages
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有派生类，即使它们定义在单独的包中
- en: Let’s add a `protected` instance variable `author` and a method `modifyTemplate`
    to the class `Book`. [Figure 1.24](#ch01fig24) shows the class representation.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在类`Book`中添加一个`protected`实例变量`author`和一个方法`modifyTemplate`。[图1.24](#ch01fig24)显示了类的表示。
- en: Figure 1.24\. Understanding the `protected` access modifier
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.24\. 理解`protected`访问修饰符
- en: '![](01fig24_alt.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig24_alt.jpg)'
- en: 'Here’s the code for the class `Book` (I’ve deliberately left out its `public`
    members because they aren’t required in this section):'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是类`Book`的代码（我故意省略了其`public`成员，因为在本节中它们不是必需的）：
- en: '![](055fig01_alt.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](055fig01_alt.jpg)'
- en: '[Figure 1.25](#ch01fig25) illustrates how classes from the same and separate
    packages, derived classes, and unrelated classes access the class `Book` and its
    `protected` members.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.25](#ch01fig25)展示了来自同一包和不同包的类、派生类以及无关类如何访问类`Book`及其`protected`成员。'
- en: Figure 1.25\. Access of `protected` members of the class `Book` in unrelated
    and derived classes, from the same and separate packages
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.25\. 从同一包和不同包中的无关和派生类访问类`Book`及其`protected`成员
- en: '![](01fig25_alt.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig25_alt.jpg)'
- en: 'Class `House` fails compilation for trying to access the method `modifyTemplate`
    and the variable `author`. Following is the compilation error message:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 类`House`由于尝试访问方法`modifyTemplate`和变量`author`而无法编译。以下为编译错误信息：
- en: '[PRE15]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Java code fails compilation because of syntax errors. In such a case, the Java
    compiler notifies the offending code with its line number and a short description
    of the error. The preceding code is output from the compilation process. This
    book uses the command prompt to compile all Java code.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码由于语法错误而无法编译。在这种情况下，Java编译器会通过行号和错误简短描述来通知有问题的代码。前面的代码是编译过程输出的。本书使用命令提示符来编译所有Java代码。
- en: '|  |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A derived class inherits the protected members of its base class, irrespective
    of the packages in which they’re defined.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 一个派生类无论这些成员定义在哪个包中，都会继承其基类的`protected`成员。
- en: 'Notice that the derived classes `CourseBook` and `StoryBook` inherit class
    `Book`’s protected member variable `author` and method `modifyTemplate()`. If
    class `StoryBook` tries to instantiate `Book` using a reference variable and then
    tries to access its protected variable `author` and method `modifyTemplate()`,
    it won’t compile:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，派生类`CourseBook`和`StoryBook`继承了类`Book`的`protected`成员变量`author`和方法`modifyTemplate()`。如果类`StoryBook`尝试使用引用变量实例化`Book`，然后尝试访问其`protected`变量`author`和方法`modifyTemplate()`，则无法编译：
- en: '![](056fig01_alt.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](056fig01_alt.jpg)'
- en: '|  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: 'A concise but not too simple way of stating the previous rule is this: A derived
    class can inherit and access `protected` members of its base class, regardless
    of the package in which it’s defined. A derived class in a separate package can’t
    access `protected` members of its base class using reference variables.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简洁但又不失简单的表述前述规则的方式是：一个派生类可以继承并访问其基类中的`protected`成员，无论这些成员定义在哪个包中。一个位于单独包中的派生类不能通过引用变量访问其基类的`protected`成员。
- en: '|  |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 1.26](#ch01fig26) shows the classes that can access `protected` members
    of a class or interface.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.26](#ch01fig26)显示了可以访问类或接口`protected`成员的类。'
- en: Figure 1.26\. Classes that can access protected members
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.26\. 可以访问`protected`成员的类
- en: '![](01fig26.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig26.jpg)'
- en: 1.4.4\. Default access (package access)
  id: totrans-515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.4\. 默认访问（包访问）
- en: The members of a class defined without using any explicit access modifier are
    defined with *package accessibility* (also called *default accessibility*). The
    members with package access are *only* accessible to classes and interfaces defined
    in the same package. The default access is also referred to as *package-private*.
    Think of a package as your home, classes as rooms, and things in rooms as variables
    with default access. These things aren’t limited to one room—they can be accessed
    across all the rooms in your home. But they’re still private to your home—you
    wouldn’t want them to be accessed outside your home. Similarly, when you define
    a package, you might want to make members of classes accessible to all the other
    classes across the same package.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用任何显式访问修饰符定义的类的成员具有`包访问性`（也称为`默认访问性`）。具有包访问的成员仅对定义在同一包中的类和接口是可访问的。默认访问也被称为`包私有`。将包想象成你的家，类想象成房间，房间里的东西想象成具有默认访问性的变量。这些东西并不局限于一个房间——它们可以访问你家中所有房间。但它们仍然属于你的家——你不会希望它们被家外的人访问。同样，当你定义一个包时，你可能希望使类中的成员对所有同一包中的其他类都是可访问的。
- en: '|  |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although the package-private access is as valid as the other access levels,
    in real projects it often appears as the result of inexperienced developers forgetting
    to specify the access mode of Java components.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管包私有访问权限与其他访问级别一样有效，但在实际项目中，它通常是由于经验不足的开发者忘记指定 Java 组件的访问模式而出现的结果。
- en: '|  |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s define an instance variable `issueCount` and a method `issueHistory` with
    default access in class `Book`. [Figure 1.27](#ch01fig27) shows the class representation
    with these new members.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Book` 类中定义一个具有默认访问权限的实例变量 `issueCount` 和一个方法 `issueHistory`。[图 1.27](#ch01fig27)
    显示了包含这些新成员的类表示。
- en: Figure 1.27\. Understanding class representation for default access
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.27。理解默认访问权限的类表示
- en: '![](01fig27_alt.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](01fig27_alt.jpg)'
- en: 'Here’s the code for the class `Book` (I’ve deliberately left out its `public`
    and `protected` members because they aren’t required in this section):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Book` 类的代码（我故意省略了它的 `public` 和 `protected` 成员，因为在本节中不需要它们）：
- en: '![](058fig01_alt.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](058fig01_alt.jpg)'
- en: You can see how classes from the same package and separate packages, derived
    classes, and unrelated classes access the class `Book` and its members (the variable
    `issueCount` and the method `issueHistory`) in [figure 1.28](#ch01fig28).
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到来自同一包和不同包的类、派生类以及无关类如何访问 `Book` 类及其成员（变量 `issueCount` 和方法 `issueHistory`），如图
    1.28 所示。
- en: Figure 1.28\. Access of members with default access to the class `Book` in unrelated
    and derived classes from the same and separate packages
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.28。来自同一包和不同包、派生类以及无关类的默认访问权限成员对 `Book` 类的访问
- en: '![](01fig28_alt.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](01fig28_alt.jpg)'
- en: 'Because the classes `CourseBook` and `Librarian` are defined in the same package
    as the class `Book`, they can access the variables `issueCount` and `issueHistory`.
    Because the classes `House` and `StoryBook` don’t reside in the same package as
    the class `Book`, they can’t access the variables `issueCount` and `issueHistory`.
    The class `StoryBook` throws the following compilation error message:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `CourseBook` 和 `Librarian` 类与 `Book` 类定义在同一个包中，所以它们可以访问 `issueCount` 和 `issueHistory`
    变量。因为 `House` 和 `StoryBook` 类没有与 `Book` 类位于同一个包中，所以它们无法访问 `issueCount` 和 `issueHistory`
    变量。`StoryBook` 类抛出以下编译错误消息：
- en: '[PRE16]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Class `House` is unaware of the existence of `issueHistory()—`it fails compilation
    with the following error message:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `House` 对 `issueHistory()` 的存在一无所知——它将因以下错误消息而无法编译：
- en: '[PRE17]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Defining a class Book with default access
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义具有默认访问权限的类 Book
- en: What happens if we define a class with default access? What will happen to the
    accessibility of its members if the class itself has default (package) accessibility?
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义一个具有默认访问权限的类会发生什么？如果该类本身具有默认（包）访问权限，其成员的可访问性会发生什么变化？
- en: 'Consider this situation: Assume that Superfast Burgers opens a new outlet on
    a beautiful island and offers free meals to people from all over the world, which
    obviously includes inhabitants of the island. But the island is inaccessible by
    all means (air and water). Would awareness of the existence of this particular
    Superfast Burgers outlet make any sense to people who don’t inhabit the island?
    An illustration of this example is shown in [figure 1.29](#ch01fig29).'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：假设 Superfast Burgers 在一个美丽的岛屿上开设了一家新分店，并向来自世界各地的所有人提供免费餐点，这显然包括岛屿居民。但岛屿无法通过任何方式（空中和水路）进入。对于不居住在岛屿上的人来说，对这家特定的
    Superfast Burgers 分店的意识有意义吗？这个例子的说明如图 1.29 所示。
- en: Figure 1.29\. This Superfast Burgers can’t be accessed from outside the island
    because the island is inaccessible by air and water.
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.29。由于岛屿无法通过空中和水路进入，因此 Superfast Burgers 无法从岛屿外部访问。
- en: '![](01fig29.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](01fig29.jpg)'
- en: The island is like a package in Java, and Superfast Burgers is like a class
    defined with default access. In the same way that Superfast Burgers can’t be accessed
    from outside the island in which it exists, a class defined with default (package)
    access is visible and accessible only from within the package in which it’s defined.
    It can’t be accessed from outside the package in which it resides.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 岛屿在 Java 中就像一个包，Superfast Burgers 就像使用默认访问权限定义的类。就像 Superfast Burgers 无法从它存在的岛屿外部访问一样，具有默认（包）访问权限的类只能在定义它的包内部可见和可访问。它无法从其所在的包外部访问。
- en: 'Let’s redefine the class `Book` with default (package) access, as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新定义具有默认（包）访问权限的类 `Book`，如下所示：
- en: '![](060fig01.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](060fig01.jpg)'
- en: The behavior of class `Book` remains the same for the classes `CourseBook` and
    `Librarian`, which are defined in the same package. But class `Book` can’t be
    accessed by classes `House` and `StoryBook`, which reside in a separate package.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 对于定义在同一个包中的类 `CourseBook` 和 `Librarian`，类 `Book` 的行为保持不变。但是，类 `Book` 不能被位于单独包中的类
    `House` 和 `StoryBook` 访问。
- en: 'Let’s start with the class `House`. Examine the following code:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从类 `House` 开始。检查以下代码：
- en: '![](060fig02.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](060fig02.jpg)'
- en: 'Class `House` generates the following compilation error message:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `House` 生成以下编译错误信息：
- en: '[PRE18]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the code of class `StoryBook`:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类 `StoryBook` 的代码：
- en: '![](060fig03_alt.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](060fig03_alt.jpg)'
- en: '[Figure 1.30](#ch01fig30) shows which classes can access members of a class
    or interface with default (package) access.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.30 [图1.30](#ch01fig30) 显示了哪些类可以访问具有默认（包）访问权限的类或接口的成员。
- en: Figure 1.30\. The classes that can access members with default (package) access
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.30\. 可以访问默认（包）访问成员的类
- en: '![](01fig30.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](01fig30.jpg)'
- en: Because a lot of programmers are confused about which members are made accessible
    by using the `protected` and default access modifiers, the exam tip offers a simple
    and interesting rule to help you remember their differences.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多程序员对使用 `protected` 和默认访问修饰符使哪些成员变得可访问感到困惑，考试提示提供了一个简单而有趣的规则来帮助您记住它们之间的区别。
- en: '|  |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: Default access can be compared to package-private (accessible only within a
    package), and `protected` access can be compared to package-private + *kids* (“kids”
    refer to derived classes). Kids can access `protected` methods only by inheritance
    and not by reference (accessing members by using the dot operator on an object).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 默认访问可以与包私有（仅限于包内访问）相比较，而 `protected` 访问可以与包私有 + *子类*（“子类”指的是派生类）相比较。子类只能通过继承而不是通过引用（通过在对象上使用点操作符访问成员）来访问
    `protected` 方法。
- en: '|  |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.4.5\. private access modifier
  id: totrans-556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.5\. 私有访问修饰符
- en: The `private` access modifier is the most restrictive access modifier. The members
    of a class defined using the `private` access modifier are accessible only to
    themselves. It doesn’t matter whether the class or interface in question is from
    another package or has extended the class—`private` members are *not* accessible
    outside the class in which they’re defined. `private` members are accessible only
    to the classes and interfaces in which they’re defined.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 访问修饰符是最具限制性的访问修饰符。使用 `private` 访问修饰符定义的类的成员只能由自身访问。无论相关的类或接口是否来自另一个包或扩展了该类，`private`
    成员在其定义的类之外都是不可访问的。`private` 成员只能由定义它们的类和接口访问。'
- en: Let’s see this in action by adding a `private` method `countPages` to the class
    `Book`. [Figure 1.31](#ch01fig31) depicts the class representation using UML.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向类 `Book` 添加一个 `private` 方法 `countPages` 来看看这个行为。图 1.31 [图1.31](#ch01fig31)
    描述了使用 UML 的类表示。
- en: Figure 1.31\. Understanding the `private` access modifier
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.31\. 理解 `private` 访问修饰符
- en: '![](01fig31_alt.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](01fig31_alt.jpg)'
- en: 'Examine the following definition of the class `Book`:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下 `Book` 类的定义：
- en: '![](061fig01_alt.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](061fig01_alt.jpg)'
- en: 'None of the classes defined in any of the packages (whether derived or not)
    can access the `private` method `countPages`. But let’s try to access it from
    the class `CourseBook`. I chose `CourseBook` because both of these classes are
    defined in the same package, and `CourseBook` extends the class `Book`. Here’s
    the code of `CourseBook`:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何包中定义的任何类（无论是否派生）都不能访问 `private` 方法 `countPages`。但让我们尝试从类 `CourseBook` 中访问它。我选择
    `CourseBook` 是因为这两个类都在同一个包中定义，并且 `CourseBook` 扩展了类 `Book`。以下是 `CourseBook` 的代码：
- en: '![](062fig01_alt.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](062fig01_alt.jpg)'
- en: Because the class `CourseBook` tries to access private members of the class
    `Book`, it won’t compile. Similarly, if any of the other classes (`StoryBook`,
    `Librarian`, `House`, or `Course-Book`) tries to access the `private` method `countPages()`
    of class `Book`, it won’t compile.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类 `CourseBook` 尝试访问类 `Book` 的私有成员，所以它无法编译。同样，如果其他任何类（`StoryBook`、`Librarian`、`House`
    或 `Course-Book`）尝试访问类 `Book` 的 `private` 方法 `countPages()`，它也无法编译。
- en: 'Here’s an interesting situation: do you think a `Book` instance can access
    its private members using a reference variable? The following code won’t compile—even
    though variable `b1` is of type `Book`, it’s trying to access its private method
    `countPages` outside `Book`:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的情况：你认为 `Book` 实例能否使用引用变量来访问其私有成员吗？以下代码无法编译——尽管变量 `b1` 的类型是 `Book`，但它试图在
    `Book` 之外访问其私有方法 `countPages`：
- en: '![](062fig02.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](062fig02.jpg)'
- en: '[Figure 1.32](#ch01fig32) shows the classes that can access the `private` members
    of a class.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.32](#ch01fig32) 展示了可以访问类 `private` 成员的类。'
- en: Figure 1.32\. No classes can access `private` members of another class
  id: totrans-569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.32\. 没有类可以访问另一个类的 `private` 成员
- en: '![](01fig32.jpg)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig32.jpg)'
- en: '|  |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For your real projects, it *is* possible to access private members of a classoutside
    them, using *Java reflection*. But Java reflection isn’t on the exam. So don’t
    consider it when answering questions on the accessibility of private members.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的真实项目，确实可以使用 *Java 反射* 来访问类外部的私有成员。但 Java 反射不在考试范围内。所以在回答关于私有成员可访问性的问题时，不要考虑它。
- en: '|  |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.4.6\. Access modifiers and Java entities
  id: totrans-575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.6\. 访问修饰符和 Java 实体
- en: Can every access modifier be applied to all the Java entities? The simple answer
    is *no*. [Table 1.3](#ch01table03) lists the Java entities and the access modifiers
    that can be used with them.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 每个访问修饰符都可以应用于所有 Java 实体吗？简单的答案是 *不*。 [表 1.3](#ch01table03) 列出了 Java 实体及其可使用的访问修饰符。
- en: Table 1.3\. Java entities and the access modifiers that can be applied to them
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.3\. Java 实体及其可应用的访问修饰符
- en: '| Entity name | public | protected | private |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '| 实体名称 | public | protected | private |'
- en: '| --- | --- | --- | --- |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Top-level class, interface, enum | ✓ | χ | χ |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| 顶级类、接口、枚举 | ✓ | χ | χ |'
- en: '| Class variables and methods | ✓ | ✓ | ✓ |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| 类变量和方法 | ✓ | ✓ | ✓ |'
- en: '| Instance variables and methods | ✓ | ✓ | ✓ |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| 实例变量和方法 | ✓ | ✓ | ✓ |'
- en: '| Method parameter and local variables | χ | χ | χ |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| 方法参数和局部变量 | χ | χ | χ |'
- en: 'What happens if you try to code the combinations for an X in [table 1.3](#ch01table03)?
    None of these combinations will compile. Here’s the code:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在 [表 1.3](#ch01table03) 中为 X 编写组合，会发生什么？这些组合中的任何一个都无法编译。以下是代码：
- en: '![](063fig01_alt.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![](063fig01_alt.jpg)'
- en: Watch out for these combinations on the exam. It’s simple to insert these small
    and invalid combinations in any code snippet and still make you believe that you’re
    being tested on a rather complex topic like threads or concurrency.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中要注意这些组合。在任何一个代码片段中插入这些小而无效的组合，仍然会让你相信你正在接受关于线程或并发等相对复杂主题的测试。
- en: '|  |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Watch out for invalid combinations of a Java entity and an access modifier.
    Such code won’t compile.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Java 实体和访问修饰符的无效组合。这样的代码无法编译。
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Twist in the Tale 1.4
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 1.4
- en: 'The following task was assigned to a group of programmers: “How can you declare
    a class `Curtain` in a package `building` so that it isn’t visible outside the
    package `building`?”'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 以下任务分配给了一组程序员：“如何在包 `building` 中声明一个类 `Curtain`，使其在包 `building` 外不可见？”
- en: These are the answers submitted by Paul, Shreya, Harry, and Selvan. Which of
    these do you think is correct and why? (You can check your Twist in the Tale answers
    in the appendix.)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Paul、Shreya、Harry 和 Selvan 提交的答案。你认为哪个是正确的，为什么？（你可以在附录中检查你的故事转折答案。）
- en: '| Programmer name | Submitted code |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| 程序员姓名 | 提交的代码 |'
- en: '| --- | --- |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Paul | package building; public class Curtain {} |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| Paul | 包 building; 公共类 Curtain {} |'
- en: '| Shreya | package building; protected class Curtain {} |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| Shreya | 包 building; 受保护的类 Curtain {} |'
- en: '| Harry | package building; class Curtain {} |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| Harry | 包 building; 类 Curtain {} |'
- en: '| Selvan | package building; private class Curtain {} |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| Selvan | 包 building; 私有类 Curtain {} |'
- en: Your job title may assign special privileges or responsibilities to you. For
    example, if you work as a Java developer, you may be responsible for updating
    your programming skills or earning professional certifications in Java. Similarly,
    you can assign special privileges, responsibilities, and behaviors to your Java
    entities by using *nonaccess modifiers*, which are covered in the next section.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 你的职位可能赋予你特殊的权限或责任。例如，如果你是一名 Java 开发者，你可能需要更新你的编程技能或在 Java 方面获得专业认证。同样，你可以通过使用
    *非访问修饰符* 来赋予你的 Java 实体特殊的权限、责任和行为，这些内容将在下一节中介绍。
- en: 1.5\. Nonaccess modifiers
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5\. 非访问修饰符
- en: '|  |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[7.5](kindle_split_021.html#ch07lev1sec6)] Use abstract classes and interfaces'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.5](kindle_split_021.html#ch07lev1sec6)] 使用抽象类和接口'
- en: '|  |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[6.2](kindle_split_019.html#ch06lev1sec2)] Apply the static keyword to methods
    and fields'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6.2](kindle_split_019.html#ch06lev1sec2)] 将静态关键字应用于方法和字段'
- en: '|  |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This section discusses the nonaccess modifiers `abstract`, `final`, and `static`.
    Access modifiers control the accessibility of your class and its members outside
    the class and the package. Nonaccess modifiers change the default behavior of
    a Java class and its members.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论非访问修饰符 `abstract`、`final` 和 `static`。访问修饰符控制类及其成员在类外和包外的可访问性。非访问修饰符改变 Java
    类及其成员的默认行为。
- en: For example, if you add the keyword `abstract` to the definition of a class,
    it can’t be instantiated. Such is the magic of the nonaccess modifiers.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你将 `abstract` 关键字添加到类的定义中，它就不能被实例化。这就是非访问修饰符的神奇之处。
- en: 'You can characterize your classes, interfaces, methods, and variables with
    the following nonaccess modifiers (though not all are applicable to each Java
    entity):'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下非访问修饰符来描述你的类、接口、方法和变量（尽管并非所有都适用于每个 Java 实体）：
- en: '`abstract`'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract`'
- en: '`static`'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`'
- en: '`final`'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`final`'
- en: '`synchronized`'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized`'
- en: '`native`'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native`'
- en: '`strictfp`'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictfp`'
- en: '`transient`'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transient`'
- en: '`volatile`'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volatile`'
- en: 'The OCA Java SE 8 Programmer I exam covers only three of these nonaccess modifiers:
    `abstract`, `final`, and `static`, which I’ll cover in detail. To ward off any
    confusion about the rest of the modifiers, I’ll describe them briefly here:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: OCA Java SE 8 程序员 I 考试仅涵盖这些非访问修饰符中的三个：`abstract`、`final` 和 `static`，这些内容我将详细讲解。为了避免对其他修饰符的混淆，我在这里简要描述它们：
- en: '`synchronized`—A `synchronized` method can’t be accessed by multiple threads
    concurrently. You can’t mark classes, interfaces, or variables with this modifier.'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized`—一个 `synchronized` 方法不能被多个线程同时访问。你不能用这个修饰符标记类、接口或变量。'
- en: '`native`—A `native` method calls and makes use of libraries and methods implemented
    in other programming languages such as C or C++. You can’t mark classes, interfaces,
    or variables with this modifier.'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native`—一个 `native` 方法调用并使用其他编程语言（如 C 或 C++）中实现的库和方法。你不能用这个修饰符标记类、接口或变量。'
- en: '`transient`—A `transient` variable isn’t serialized when the corresponding
    object is serialized. The `transient` modifier can’t be applied to classes, interfaces,
    or methods.'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transient`—当相应的对象被序列化时，`transient` 变量不会被序列化。`transient` 修饰符不能应用于类、接口或方法。'
- en: '`volatile`—A `volatile` variable’s value can be safely modified by different
    threads. Classes, interfaces, and methods can’t use this modifier.'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volatile`—一个 `volatile` 变量的值可以被不同的线程安全地修改。类、接口和方法不能使用这个修饰符。'
- en: '`strictfp`—Classes, interfaces, and methods defined using this keyword ensure
    that calculations using floating-point numbers are identical on all platforms.
    This modifier can’t be used with variables.'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictfp`—使用此关键字定义的类、接口和方法确保使用浮点数进行的计算在所有平台上都是相同的。此修饰符不能与变量一起使用。'
- en: Now let’s look at the three nonaccess modifiers that are on the exam.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看考试中的三个非访问修饰符。
- en: 1.5.1\. abstract modifier
  id: totrans-626
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.1\. 抽象修饰符
- en: When added to the definition of a class, interface, or method, the `abstract`
    modifier changes its default behavior. Because it is a nonaccess modifier, `abstract`
    doesn’t change the accessibility of a class, interface, or method.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加到类、接口或方法的定义中时，`abstract` 修饰符会改变其默认行为。因为它是一个非访问修饰符，所以 `abstract` 不会改变类、接口或方法的可访问性。
- en: Let’s examine the behavior of each of these with the `abstract` modifier.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `abstract` 修饰符来检查每个这些行为的特性。
- en: abstract class
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'When the `abstract` keyword is prefixed to the definition of a concrete class,
    it changes it to an `abstract` class, even if the class doesn’t define any `abstract`
    methods. The following code is a valid example of an `abstract` class:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `abstract` 关键字作为具体类定义的前缀时，即使该类没有定义任何抽象方法，它也会将其转换为抽象类。以下代码是一个有效的抽象类示例：
- en: '[PRE19]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An `abstract` class can’t be instantiated, which means that the following code
    will fail to compile:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类不能被实例化，这意味着以下代码将无法编译：
- en: '![](065fig01_alt.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![](065fig01_alt.jpg)'
- en: 'Here’s the compilation error thrown by the previous class:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前一个类抛出的编译错误：
- en: '[PRE20]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: An `abstract` class may or may not define an `abstract` method. But a concrete
    class can’t define an `abstract` method.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 一个抽象类可以或不可以定义一个抽象方法。但一个具体类不能定义一个抽象方法。
- en: '|  |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: abstract interface
  id: totrans-640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象接口
- en: 'An interface is an abstract entity by default. The Java compiler automatically
    adds the keyword `abstract` to the definition of an interface. Thus, adding the
    keyword `abstract` to the definition of an interface is redundant. The following
    definitions of interfaces are the same:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 接口默认是一个抽象实体。Java编译器会自动将`抽象`关键字添加到接口的定义中。因此，将`抽象`关键字添加到接口的定义中是多余的。以下接口的定义是相同的：
- en: '![](065fig02_alt.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![图片](065fig02_alt.jpg)'
- en: abstract method
  id: totrans-643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象方法
- en: 'An `abstract` method doesn’t have a body. Usually, an `abstract` method is
    implemented by a derived class. Here’s an example:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`抽象`方法没有主体。通常，`抽象`方法由派生类实现。以下是一个例子：
- en: '![](066fig01_alt.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![图片](066fig01_alt.jpg)'
- en: '|  |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A method with an empty body isn’t an `abstract` method.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空体的方法不是`抽象`方法。
- en: '|  |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: abstract variables
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象变量
- en: None of the different types of variables (instance, `static`, local, and method
    parameters) can be defined as `abstract`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的变量类型（实例、`静态`、局部和方法的参数）都不能定义为`抽象`。
- en: '|  |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Don’t be tricked by code that tries to apply the nonaccess modifier `abstract`
    to a variable. Such code won’t compile.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被试图将非访问修饰符`抽象`应用于变量的代码所欺骗。这样的代码无法编译。
- en: '|  |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.5.2\. final modifier
  id: totrans-656
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.2\. final修饰符
- en: The keyword `final` can be used with the declaration of a class, variable, or
    method. It can’t be used with the declaration of an interface.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`final`可以与类、变量或方法的声明一起使用。它不能与接口的声明一起使用。
- en: final class
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: final类
- en: 'A class that’s marked `final` can’t be extended by another class. The class
    `Professor` won’t compile if the class `Person` is marked as `final`, as follows:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为`final`的类不能被另一个类扩展。如果`Person`类被标记为`final`，则`Professor`类将无法编译，如下所示：
- en: '![](066fig02.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
  zh: '![图片](066fig02.jpg)'
- en: final interface
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: final接口
- en: 'An interface can’t be marked as `final`. An interface is `abstract` by default
    and marking it with `final` will prevent your interface from compiling:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不能标记为`final`。接口默认是`抽象`的，标记为`final`将阻止你的接口编译：
- en: '![](066fig03.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![图片](066fig03.jpg)'
- en: final variable
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: final变量
- en: 'A `final` variable can’t be reassigned a value. It can be assigned a value
    only once. See the following code:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`变量不能重新赋值。它只能赋值一次。以下代码说明：'
- en: '![](066fig04.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
  zh: '![图片](066fig04.jpg)'
- en: 'Compare the previous example with the following code, which tries to reassign
    a value to a final variable:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的例子与以下尝试重新赋值给final变量的代码进行比较：
- en: '![](067fig01.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![图片](067fig01.jpg)'
- en: 'It’s easy to confuse reassigning a value to a `final` variable with *calling*
    a method on a `final` variable, which might change the state of the object that
    it refers to. If a reference variable is defined as a `final` variable, you can’t
    reassign another object to it, but you can call methods on this variable (that
    modify its state):'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 容易将向`final`变量重新赋值与在`final`变量上*调用*方法混淆，这可能会改变它所引用的对象的状态。如果引用变量被定义为`final`变量，你不能将其重新赋值为另一个对象，但可以调用此变量的方法（这些方法会修改其状态）：
- en: '![](067fig02_alt.jpg)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
  zh: '![图片](067fig02_alt.jpg)'
- en: final method
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: final方法
- en: 'A `final` method defined in a base class can’t be overridden by a derived class.
    Examine the following code:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类中定义的`final`方法不能被派生类重写。检查以下代码：
- en: '![](067fig03_alt.jpg)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![图片](067fig03_alt.jpg)'
- en: If a method in a derived class has the same method signature as its base class’s
    method, it’s referred to as an *overridden method*. Overridden methods are discussed
    along with polymorphism in [chapter 6](kindle_split_019.html#ch06).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 如果派生类中的方法与其基类的方法具有相同的签名，则称为*重写方法*。重写方法将与多态一起在第6章中讨论。
- en: 1.5.3\. static modifier
  id: totrans-675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.3\. 静态修饰符
- en: The nonaccess modifier `static` can be applied to the declarations of variables,
    methods, classes, and interfaces. We’ll examine each of them in following sections.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 非访问修饰符`静态`可以应用于变量、方法、类和接口的声明。我们将在接下来的章节中逐一考察它们。
- en: static variables
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态变量
- en: '`static` variables belong to a class. They’re common to all instances of a
    class and aren’t unique to any instance of a class. `static` attributes exist
    independently of any instances of a class and may be accessed even when no instances
    of the class have been created. You can compare a `static` variable with a shared
    variable. A `static` variable is shared by all the objects of a class.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '`静态`变量属于一个类。它们对所有类的实例都是通用的，并不属于任何单个实例。`静态`属性独立于类的任何实例存在，即使没有创建类的实例也可以访问。你可以将`静态`变量与共享变量进行比较。一个`静态`变量被类中的所有对象共享。'
- en: '|  |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A class and an interface can declare `static` variables. This section covers
    declaration and usage of `static` variables that are defined in a class. [Chapter
    6](kindle_split_019.html#ch06) covers interfaces and their `static` variables
    in detail.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类和一个接口都可以声明 `static` 变量。本节涵盖了在类中定义的 `static` 变量的声明和使用。[第6章](kindle_split_019.html#ch06)
    详细介绍了接口及其 `static` 变量。
- en: '|  |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Think of a `static` variable as being like a common bank vault that’s shared
    by the employees of an organization. Each of the employees accesses the same bank
    vault, so any change made by one employee is visible to all the other employees,
    as illustrated in [figure 1.33](#ch01fig33).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `static` 变量想象成一个由组织中的员工共享的公共银行保险库。每个员工都可以访问相同的银行保险库，因此一个员工所做的任何更改都会对所有其他员工可见，如
    [图1.33](#ch01fig33) 所示。
- en: Figure 1.33\. Comparing a shared bank vault with a `static` variable
  id: totrans-684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.33\. 比较共享银行保险库与 `static` 变量
- en: '![](01fig33_alt.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig33_alt.jpg)'
- en: '[Figure 1.34](#ch01fig34) defines a class `Emp` that defines a non-`static`
    variable `name` and a `static` variable `bankVault`.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.34](#ch01fig34) 定义了一个 `Emp` 类，该类定义了一个非 `static` 变量 `name` 和一个 `static`
    变量 `bankVault`。'
- en: Figure 1.34\. Definition of the class `Emp` with a `static` variable `bankVault`
    and `non-static` variable name
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.34\. `Emp` 类的定义，包含 `static` 变量 `bankVault` 和非 `static` 变量 `name`
- en: '![](01fig34_alt.jpg)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig34_alt.jpg)'
- en: 'It’s time to test what we’ve been discussing up to this point. The following
    `TestEmp` class creates two objects of the class `Emp` (from [figure 1.34](#ch01fig34))
    and modifies the value of the variable `bankVault` using these separate objects:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试我们到目前为止所讨论内容的时候了。下面的 `TestEmp` 类创建了 `Emp` 类（来自 [图1.34](#ch01fig34)）的两个对象，并使用这些单独的对象修改变量
    `bankVault` 的值：
- en: '![](069fig01_alt.jpg)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
  zh: '![](069fig01_alt.jpg)'
- en: 'In the preceding code example, `emp1.bankVault`, `emp2.bankVault`, and `Emp.bank-Vault`
    all refer to the *same* `static` attribute: `bankVault`.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，`emp1.bankVault`、`emp2.bankVault` 和 `Emp.bank-Vault` 都引用了相同的 `static`
    属性：`bankVault`。
- en: '|  |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Even though you can use an object reference variable to access `static` members,
    it’s not advisable to do so. Because `static` members belong to a class and not
    to individual objects, using object reference variables to access `static` members
    may make them appear to belong to an object. The preferred way to access them
    is by using the class name. The `static` and `final` nonaccess modifiers can be
    used together to define *constants* (variables whose value can’t change).
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用对象引用变量来访问 `static` 成员，但这样做并不建议。因为 `static` 成员属于类而不是单个对象，使用对象引用变量来访问 `static`
    成员可能会使它们看起来属于一个对象。访问它们的最佳方式是使用类名。`static` 和 `final` 非访问修饰符可以一起使用来定义 *常量*（值不能改变的变量）。
- en: '|  |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In the following code, the class `Emp` defines the constants `MIN_AGE` and
    `MAX_AGE`:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，类 `Emp` 定义了常量 `MIN_AGE` 和 `MAX_AGE`：
- en: '![](069fig02_alt.jpg)'
  id: totrans-697
  prefs: []
  type: TYPE_IMG
  zh: '![](069fig02_alt.jpg)'
- en: Although you can define a constant as a non-`static` member, it’s common practice
    to define constants as `static` members, because doing so allows the constant
    values to be used across objects and classes.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将常量定义为非 `static` 成员，但通常的做法是将常量定义为 `static` 成员，因为这样做可以使常量值在对象和类之间共享。
- en: static methods
  id: totrans-699
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`static` 方法'
- en: '`static` methods aren’t associated with objects and can’t use any of the instance
    variables of a class. You can define `static` methods to access or manipulate
    `static` variables:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 方法与对象无关，不能使用类的任何实例变量。你可以定义 `static` 方法来访问或操作 `static` 变量：'
- en: '![](069fig03_alt.jpg)'
  id: totrans-701
  prefs: []
  type: TYPE_IMG
  zh: '![](069fig03_alt.jpg)'
- en: 'It’s a common practice to use `static` methods to define *utility methods*,
    which are methods that usually manipulate the method parameters to compute and
    return an appropriate value:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `static` 方法定义 *实用方法* 是一种常见的做法，这些方法是通常操作方法参数以计算并返回适当值的函数：
- en: '[PRE21]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following utility (`static`) method doesn’t define input parameters. The
    method `averageOfFirst100Integers` computes and returns the average of numbers
    `1` to `100`:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的实用 (`static`) 方法没有定义输入参数。方法 `averageOfFirst100Integers` 计算并返回数字 `1` 到 `100`
    的平均值：
- en: '![](070fig01_alt.jpg)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
  zh: '![](070fig01_alt.jpg)'
- en: The nonprivate `static` variables and methods are inherited by derived classes.
    The `static` members aren’t involved in runtime polymorphism. You can’t override
    the `static` members in a derived class, but you can redefine them.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 非私有 `static` 变量和方法会被派生类继承。`static` 成员不参与运行时多态。你无法在派生类中重写 `static` 成员，但可以重新定义它们。
- en: Any discussion of `static` methods and their behavior can be quite confusing
    if you aren’t aware of inheritance and derived classes. But don’t worry if you
    don’t understand all of it. I’ll cover derived classes and inheritance in [chapter
    6](kindle_split_019.html#ch06). For now, note that a `static` method can be accessed
    using the name of the object reference variables and the class in a manner similar
    to `static` variables.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道继承和派生类，关于静态方法和它们行为的讨论可能会相当令人困惑。但如果你不理解所有这些内容，请不要担心。我将在第6章中介绍派生类和继承。现在，请注意，静态方法可以使用对象引用变量的名称和类名以类似于静态变量的方式访问。
- en: What can a static method access?
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态方法可以访问什么？
- en: 'Neither `static` methods nor `static` variables can access the non-`static`
    variables and methods of a class. But the reverse is true: non-`static` variables
    and methods can access `static` variables and methods because the `static` members
    of a class exist even if no instances of the class exist. `static` members are
    forbidden from accessing instance methods and variables, which can exist only
    if an instance of the class is created.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是静态方法还是静态变量都不能访问类的非静态变量和方法。但反之则不然：非静态变量和方法可以访问静态变量和方法，因为类的静态成员即使没有类的实例也存在。静态成员不允许访问实例方法或变量，这些方法或变量只有当创建了类的实例时才存在。
- en: 'Examine the following code:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下代码：
- en: '![](070fig02.jpg)'
  id: totrans-711
  prefs: []
  type: TYPE_IMG
  zh: '![](070fig02.jpg)'
- en: 'This is the compilation error thrown by the previous class:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一个类抛出的编译错误：
- en: '[PRE22]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code is valid:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是有效的：
- en: '![](071fig01_alt.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
  zh: '![](071fig01_alt.jpg)'
- en: '|  |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-717
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: '`static` methods and variables can’t access the instance members of a class.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法和变量不能访问类的实例成员。
- en: '|  |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Table 1.4](#ch01table04) summarizes the access capabilities of `static` and
    non-`static` members.'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '[表1.4](#ch01table04)总结了静态和非静态成员的访问能力。'
- en: Table 1.4\. Access capabilities of `static` and non-`static` members
  id: totrans-721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.4\. 静态和非静态成员的访问能力
- en: '| Member type | Can access static attribute or method? | Can access non-static
    attribute or method? |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| 成员类型 | 是否可以访问静态属性或方法？ | 是否可以访问非静态属性或方法？ |'
- en: '| --- | --- | --- |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| static | Yes | No |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| 静态 | 是 | 否 |'
- en: '| Non-static | Yes | Yes |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '| 非静态 | 是 | 是 |'
- en: Accessing static members from a null reference
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从空引用访问静态成员
- en: 'Because `static` variables and methods belong to a class and not to an instance,
    you can access them using variables, which are initialized to `null`. Watch out
    for such questions in the exam. Such code won’t throw a runtime exception (`NullPointer-Exception`
    to be precise). In the following example, the reference variable `emp` is initialized
    to `null`:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 因为静态变量和方法属于类而不是实例，所以你可以使用初始化为`null`的变量来访问它们。在考试中要注意这类问题。这样的代码不会抛出运行时异常（确切地说，是`NullPointerException`）。在以下示例中，引用变量`emp`被初始化为`null`：
- en: '![](071fig02_alt.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![](071fig02_alt.jpg)'
- en: '|  |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You can access `static` variables and methods using a `null` reference.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用空引用来访问静态变量和方法。
- en: '|  |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**static classes and interfaces**'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态类和接口**'
- en: Certification aspirants frequently ask questions about `static` classes and
    interfaces, so I’ll quickly cover these in this section to ward off any confusion
    related to them. But note that `static` classes and interfaces are types of nested
    classes and interfaces that aren’t covered by the OCA Java 8 Programmer I exam.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 认证考生经常询问有关静态类和接口的问题，所以我会快速在本节中介绍这些内容，以消除与它们相关的任何混淆。但请注意，静态类和接口是嵌套类和接口的类型，这些类型不包括在OCA
    Java 8程序员I考试范围内。
- en: 'You can’t prefix the definition of a top-level class or an interface with the
    keyword `static`. A top-level class or interface is one that isn’t defined within
    another class or interface. The following code will fail to compile:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用关键字`static`来前缀顶级类或接口的定义。顶级类或接口是在另一个类或接口之外定义的。以下代码将无法编译：
- en: '[PRE23]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But you can define a class and an interface as a `static` member of another
    class. The following code is valid:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以定义一个类和一个接口作为另一个类的静态成员。以下代码是有效的：
- en: '![](072fig01_alt.jpg)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
  zh: '![](072fig01_alt.jpg)'
- en: '|  |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The next section covers features of Java that led to its popularity two decades
    ago, and which still hold strong.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍导致Java在二十年前流行，并且至今仍具有强大影响力的Java特点。
- en: 1.6\. Features and components of Java
  id: totrans-742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. Java的特点和组件
- en: '|  |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[1.5](#ch01lev1sec5)] Compare and contrast the features and components of
    Java such as: platform independence, object orientation, encapsulation, etc.'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1.5](#ch01lev1sec5)] 比较和对比 Java 的功能和组件，例如：平台独立性、面向对象、封装等。'
- en: '|  |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Java programming language was released in 1995\. It was developed mainly
    to work with consumer appliances. But it soon became very popular with web browsers,
    to deliver dynamic content (using applets), which didn’t require it to be recompiled
    for separate platforms. Let’s get started with the distinctive features and components
    of Java, which still make it a popular programming language.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: Java 编程语言于 1995 年发布。它主要开发用于与消费电子产品协同工作。但很快它就因为与网络浏览器的结合而变得非常流行，用于提供动态内容（使用小程序），这不需要为不同的平台重新编译。让我们开始了解
    Java 的独特特性和组件，这些特性仍然使它成为一种流行的编程语言。
- en: '|  |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The exam will question you on the features and components of Java that are relevant
    or irrelevant to it.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 考试将询问与 Java 相关或无关的功能和组件。
- en: '|  |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.6.1\. Valid features and components of Java
  id: totrans-751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.1. Java 的有效功能和组件
- en: Java offers multiple advantages over other languages and platforms.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: Java 相比其他语言和平台提供了多项优势。
- en: Platform independence
  id: totrans-753
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 平台独立性
- en: This feature is one of main reasons of Java’s phenomenal rise since its release.
    It’s also referred to as “write once, run anywhere” (WORA)—a slogan created by
    Sun Microsystems^(TM) to highlight Java’s platform independence.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性是 Java 自发布以来取得惊人增长的主要原因之一。它也被称作“一次编写，到处运行”（WORA）——这是 Sun Microsystems^(TM)
    创造的一个口号，用以强调 Java 的平台独立性。
- en: Java code can be executed on multiple systems without recompilation. Java code
    is compiled into *bytecode*, to be executed by a *virtual machine*—the Java Virtual
    Machine (JVM). A JVM is installed on platforms with different OSs like Windows,
    Mac, or Linux. A JVM interprets bytecodes to machine-specific instructions for
    execution. The implementation details of a JVM are machine-dependent and might
    differ across platforms, but all of them interpret the same bytecode in a similar
    manner. Bytecode generated by a Java compiler is supported by all platforms with
    a JVM.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: Java 代码可以在多个系统上执行，而无需重新编译。Java 代码被编译成 *字节码*，由 *虚拟机*——Java 虚拟机（JVM）执行。JVM 安装在不同的操作系统平台上，如
    Windows、Mac 或 Linux。JVM 将字节码解释为特定于机器的指令以执行。JVM 的实现细节取决于机器，可能在不同平台上有所不同，但它们都以类似的方式解释相同的字节码。Java
    编译器生成的字节码被所有带有 JVM 的平台支持。
- en: Other popular programming languages like C and C++ compile their code to a host
    system. So the code must be recompiled for separate platforms.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的编程语言，如 C 和 C++，会将它们的代码编译到宿主系统中。因此，代码必须为不同的平台重新编译。
- en: Object orientation
  id: totrans-757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 面向对象
- en: Java emulates real-life object definition and behavior. In real life, state
    and behavior are tied to an object. Similarly, all Java code is defined within
    classes, interfaces, or enums. You need to create their objects to use them.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: Java 模拟现实生活中的对象定义和行为。在现实生活中，状态和行为与对象相关联。同样，所有 Java 代码都是在类、接口或枚举中定义的。你需要创建它们的对象来使用它们。
- en: Abstraction
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象
- en: Java lets you abstract objects and include only the required properties and
    behavior in your code. For example, if you’re developing an application that tracks
    the population of a country, you’ll record a person’s name, address, and contact
    details. But for a health-tracking system, you might want to include health-related
    details and behavior as well.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: Java 允许你抽象对象，并在代码中只包含所需的属性和行为。例如，如果你正在开发一个跟踪一个国家人口的应用程序，你会记录一个人的姓名、地址和联系详情。但对于一个健康跟踪系统，你可能还想包括与健康相关的细节和行为。
- en: Encapsulation
  id: totrans-761
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 封装
- en: With Java classes, you can encapsulate the state and behavior of an object.
    The state or the fields of a class are protected from unwanted access and manipulation.
    You can control the level of access and modifications to your objects.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 类，你可以封装一个对象的状态和行为。类的状态或字段受到不受欢迎的访问和操作的防护。你可以控制对对象访问和修改的级别。
- en: Inheritance
  id: totrans-763
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 继承
- en: Java enables its classes to inherit other classes and implement interfaces.
    The interfaces can inherit other interfaces. This saves you from redefining common
    code.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: Java 允许其类继承其他类并实现接口。接口可以继承其他接口。这可以节省你重新定义通用代码的时间。
- en: Polymorphism
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多态
- en: The literal meaning of polymorphism is “many forms.” Java enables instances
    of its classes to exhibit multiple behaviors for the same method calls. You’ll
    learn about this in detail in [chapter 6](kindle_split_019.html#ch06).
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 多态的直译意思是“多种形式”。Java 允许其类的实例对同一方法调用表现出多种行为。你将在第 6 章中详细了解这一点。[章节链接](kindle_split_019.html#ch06)。
- en: Type safety
  id: totrans-767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型安全
- en: In Java, you must declare a variable with its data type *before* you can use
    it. This means that you have compile-time checks that ensure you never assign
    to a variable a value of the wrong type.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你必须在使用变量之前声明其数据类型 *before* 你才能使用它。这意味着你有一个编译时检查，确保你永远不会将错误类型的值赋给变量。
- en: Automatic memory management
  id: totrans-769
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自动内存管理
- en: Unlike other programming languages like C or C++, Java uses garbage collectors
    for automatic memory management. They reclaim memory from objects that are no
    longer in use. This frees developers from explicitly managing the memory themselves.
    It also prevents memory leaks.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言如 C 或 C++ 不同，Java 使用垃圾回收器进行自动内存管理。它们从不再使用的对象中回收内存。这使开发者免于显式管理内存。它还防止了内存泄漏。
- en: Multithreading and concurrency
  id: totrans-771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多线程和并发
- en: Java has supported multithreading and concurrency since it was first released—supported
    by classes and interfaces defined in its core API.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: Java 自首次发布以来就支持多线程和并发——由其核心 API 中定义的类和接口提供支持。
- en: Security
  id: totrans-773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安全性
- en: Java includes multiple built-in security features (though not all are covered
    in this exam) to control access to your resources and execution of your programs.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: Java 包含多个内置的安全功能（尽管本考试并未涵盖所有内容），以控制对您资源的访问和程序的执行。
- en: Java is type safe and includes garbage collection. It provides secure class
    loading, and verification ensures execution of legitimate Java code.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是类型安全的，并包括垃圾回收功能。它提供安全的类加载，并且验证确保执行的是合法的 Java 代码。
- en: The Java platform defines multiple APIs, including cryptography and public key
    infrastructure. Java applications that execute under a security manager control
    access to your resources, like reading or writing to file. Access to a resource
    can be controlled using a policy file. Java enables you to define digital signatures,
    certificates, and keystores to secure code and file exchanges. Signed code is
    distributed for execution.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台定义了多个 API，包括加密和公钥基础设施。在安全管理器控制下运行的 Java 应用程序可以控制对您资源的访问，如读取或写入文件。可以通过策略文件来控制对资源的访问。Java
    允许您定义数字签名、证书和密钥库以保护代码和文件交换。已签名的代码用于执行。
- en: With features like encapsulation and data hiding, Java secures the state of
    its objects. Java applets execute in browsers and don’t allow code to be downloaded
    to a system, thus enabling security for browsers and the systems that run them.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: Java 通过封装和数据隐藏等特性，确保了其对象的状态安全。Java 小程序在浏览器中执行，不允许代码下载到系统中，从而为浏览器及其运行系统提供了安全性。
- en: 1.6.2\. Irrelevant features and components of Java
  id: totrans-778
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.2. Java 的无关特性和组件
- en: The exam might also include some terms that are irrelevant.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 考试可能还会包括一些无关的术语。
- en: Single-threaded
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单线程
- en: Java supports multithreading programming with inbuilt classes and interfaces.
    You can create and use single threads, but the Java language isn’t single-threaded.
    Even when you create single threads of execution, Java executes its own processes
    like garbage collection in separate threads. Java isn’t a single-threaded language.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: Java 支持使用内置的类和接口进行多线程编程。你可以创建和使用单线程，但 Java 语言本身不是单线程的。即使你创建了执行的单线程，Java 也会在单独的线程中执行自己的进程，如垃圾回收。Java
    不是一个单线程的语言。
- en: Related to JavaScript
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与 JavaScript 相关
- en: Java isn’t related to JavaScript (except for the similarity in their name).
    JavaScript is a programming language used in web pages to make them interactive.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: Java 与 JavaScript（除了名称相似之外）无关。JavaScript 是一种用于网页的编程语言，用于使网页具有交互性。
- en: 1.7\. Summary
  id: totrans-784
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7. 摘要
- en: This chapter started with a look at the structure of a Java class. Although
    you should know how to work with Java classes, Java source code files (.java files),
    and Java bytecode files (.class files), the OCA Java SE 8 Programmer I exam will
    question you only on the structure and components of the first two—classes and
    source code—not on Java bytecode.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从查看 Java 类的结构开始。尽管你应该知道如何使用 Java 类、Java 源代码文件（.java 文件）和 Java 字节码文件（.class
    文件），但 OCA Java SE 8 程序员 I 考试只会就前两者的结构和组件进行提问——即类和源代码，而不是 Java 字节码。
- en: We discussed the components of a Java class and of Java source code files. A
    class can define multiple components, namely, `import` and `package` statements,
    variables, constructors, methods, comments, nested classes, nested interfaces,
    annotations, and enums. A Java source code file (.java) can define multiple classes
    and interfaces.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了Java类和Java源代码文件的组件。一个类可以定义多个组件，即`import`和`package`语句、变量、构造函数、方法、注释、嵌套类、嵌套接口、注解和枚举。Java源代码文件（.java）可以定义多个类和接口。
- en: We then covered the differences and similarities between executable and non-executable
    Java classes. An executable Java class defines the entry point (`main` method)
    for the JVM to start its execution. The `main` method should be defined with the
    required method signature; otherwise, the class will fail to be categorized as
    an executable Java class.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了可执行和非可执行Java类之间的差异和相似之处。一个可执行Java类定义了JVM启动执行时的入口点（`main`方法）。`main`方法应该使用所需的方法签名定义；否则，该类将无法被分类为可执行Java类。
- en: Packages are used to group together related classes and interfaces. They also
    provide access protection and namespace management. The `import` statement is
    used to import classes and interfaces from other packages. In the absence of an
    `import` statement, classes and interfaces should be referred to by their fully
    qualified names (complete package name plus class or interface name).
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 包用于将相关的类和接口分组在一起。它们还提供访问保护和命名空间管理。`import`语句用于从其他包中导入类和接口。如果没有`import`语句，类和接口应该通过它们的完全限定名（完整的包名加上类或接口名）来引用。
- en: 'Access modifiers control the access of classes and their members within a package
    and across packages. Java defines four access modifiers: `public`, `protected`,
    default, and `private`. When default access is assigned to a class or its member,
    no access modifier is prefixed to it. The absence of an access modifier is equal
    to assigning the class or its members with default access. The least restrictive
    access modifier is `public`, and `private` is the most restrictive. `protected`
    access sits between `public` and default access, allowing access to derived classes
    outside a package.'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符控制类及其成员在包内和包之间的访问。Java定义了四个访问修饰符：`public`、`protected`、默认和`private`。当默认访问被分配给一个类或其成员时，它前面没有前缀。没有访问修饰符的缺失等于将类或其成员分配为默认访问。最不限制的访问修饰符是`public`，而`private`是最限制的。`protected`访问位于`public`和默认访问之间，允许包外派生类访问。
- en: We covered the `abstract` and `static` nonaccess modifiers. A class or a method
    can be defined as an `abstract` member. `abstract` classes can’t be instantiated.
    Methods and variables can be defined as `static` members. All the objects of a
    class share the same copy of `static` variables, which are also known as class-level
    variables.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了`abstract`和`static`非访问修饰符。一个类或一个方法可以被定义为`abstract`成员。`abstract`类不能被实例化。方法和变量可以被定义为`static`成员。一个类的所有对象共享相同的`static`变量副本，这些变量也被称为类级别变量。
- en: Finally, we covered the features and components of Java that make it a popular
    choice.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了Java的特性和组件，使其成为流行的选择。
- en: 1.8\. Review notes
  id: totrans-792
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.8. 复习笔记
- en: This section lists the main points covered in this chapter.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了本章涵盖的主要要点。
- en: 'The structure of a Java class and source code file:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: Java类和源代码文件的结构：
- en: The OCA Java SE 8 Programmer I exam covers the structure and components of a
    Java class and Java source code file (.java file). It doesn’t cover the structure
    and components of Java bytecode files (.class files).
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCA Java SE 8程序员I考试涵盖了Java类和Java源代码文件（.java文件）的结构和组件。它不涵盖Java字节码文件（.class文件）的结构和组件。
- en: 'A class can define multiple components. All the Java components you’ve heard
    of can be defined within a Java class: `import` and `package` statements, variables,
    constructors, methods, comments, nested classes, nested interfaces, annotations,
    and enums.'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以定义多个组件。你听说过的所有Java组件都可以在Java类中定义：`import`和`package`语句、变量、构造函数、方法、注释、嵌套类、嵌套接口、注解和枚举。
- en: This exam doesn’t cover the definitions of nested classes, nested interfaces,
    annotations, and enums.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本考试不涵盖嵌套类、嵌套接口、注解和枚举的定义。
- en: If a class defines a `package` statement, it should be the first statement in
    the class definition.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类定义了`package`语句，它应该是类定义中的第一个语句。
- en: The `package` statement can’t appear within a class declaration or after the
    class declaration.
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`语句不能出现在类声明内或类声明之后。'
- en: If present, the `package` statement should appear exactly once in a class.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在，`package`语句应该在一个类中恰好出现一次。
- en: The `import` statement allows usage of simple names, nonqualified names of classes,
    and interfaces.
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import`语句允许使用简单名称、类的非限定名称和接口。'
- en: The `import` statement can’t be used to import multiple classes or interfaces
    with the same name.
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能使用`import`语句导入具有相同名称的多个类或接口。
- en: A class can include multiple `import` statements.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以包含多个`import`语句。
- en: If a class includes a `package` statement, all the `import` statements should
    follow the `package` statement.
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类包含`package`语句，所有的`import`语句都应该跟在`package`语句之后。
- en: If present, an `import` statement must be placed before any class or interface
    definition.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在，`import`语句必须放在任何类或接口定义之前。
- en: Comments are another component of a class. Comments are used to annotate Java
    code and can appear at multiple places within a class.
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释是类的另一个组成部分。注释用于注释Java代码，并且可以在类中多个位置出现。
- en: A comment can appear before or after a `package` statement, before or after
    the class definition, and before, within, or after a method definition.
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释可以出现在`package`语句之前或之后，类定义之前或之后，以及方法定义之前、之内或之后。
- en: 'Comments come in two flavors: multiline and end-of-line comments.'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释有两种类型：多行注释和行尾注释。
- en: Comments can contain any special characters (including characters from the Unicode
    charset).
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释可以包含任何特殊字符（包括Unicode字符集中的字符）。
- en: Multiline comments span multiple lines of code. They start with `/*` and end
    with `*/`.
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行注释跨越多行代码。它们以`/*`开始，以`*/`结束。
- en: End-of-line comments start with `//` and, as the name suggests, are placed at
    the end of a line of code or a blank line. The text between `//` and the end of
    the line is treated as a comment.
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行尾注释以`//`开始，正如其名所示，放置在代码行或空白行的末尾。`//`和行尾之间的文本被视为注释。
- en: Class declarations and class definitions are components of a Java class.
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类声明和类定义是Java类的一部分。
- en: A Java class may define zero or more instance variables, methods, and constructors.
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Java类可以定义零个或多个实例变量、方法和构造函数。
- en: The order of the definition of instance variables, constructors, and methods
    doesn’t matter in a class.
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中，实例变量、构造函数和方法的定义顺序无关紧要。
- en: A class may define an instance variable before or after the definition of a
    method and still use it.
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以在定义方法之前或之后定义实例变量，并且仍然可以使用它。
- en: A Java source code file (.java file) can define multiple classes and interfaces.
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Java源代码文件（.java文件）可以定义多个类和接口。
- en: A `public` class can be defined only in a source code file with the same name.
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能在与源代码文件同名的文件中定义`public`类。
- en: '`package` and `import` statements apply to all the classes and interfaces defined
    in the same source code file (.java file).'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`和`import`语句适用于同一源代码文件（.java文件）中定义的所有类和接口。'
- en: 'Executable Java applications:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行的Java应用程序：
- en: An executable Java class is a class that, when handed over to the Java Virtual
    Machine (JVM), starts its execution at a particular point in the class. This point
    of execution is the `main` method.
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行的Java类是当传递给Java虚拟机（JVM）时，在类中的特定点开始执行其执行的类。这个执行点是`main`方法。
- en: For a class to be executable, the class should define a `main` method with the
    signature `public static void main(String args[])` or `public static void main(String...
    args)`. The positions of `static` and `public` can be interchanged, and the method
    parameter can use any valid name.
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使一个类可执行，该类应该定义一个签名为`public static void main(String args[])`或`public static
    void main(String... args)`的`main`方法。`static`和`public`的位置可以互换，方法参数可以使用任何有效的名称。
- en: A class can define multiple methods with the name `main`, provided that the
    signature of these methods doesn’t match the signature of the `main` method defined
    in the previous point. These *overloaded* versions aren’t considered the `main`
    method.
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以定义多个名为`main`的方法，只要这些方法的签名与前面提到的`main`方法的签名不匹配。这些*重载*版本不被认为是`main`方法。
- en: The `main` method accepts an array of type `String` containing the method parameters
    passed to it by the JVM.
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`方法接受一个类型为`String`的数组，包含JVM传递给它的方法参数。'
- en: The keyword `java` and the name of the class aren’t passed on as command parameters
    to the `main` method.
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`java`和类的名称不会被作为命令参数传递给`main`方法。
- en: 'Java packages:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: Java包：
- en: You can use packages to group together a related set of classes and interfaces.
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用包将相关的一组类和接口组合在一起。
- en: By default, all classes and interfaces in separate packages and subpackages
    aren’t visible to each other.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，不同包和子包中的所有类和接口对彼此不可见。
- en: The package and subpackage names are separated using a dot.
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包和子包名称使用点分隔。
- en: All classes and interfaces in the same package are visible to each other.
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一包中的所有类和接口对彼此可见。
- en: An `import` statement allows the use of simple names for packaged classes and
    interfaces defined in other packages.
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import` 语句允许使用其他包中定义的包装类和接口的简单名称。'
- en: You can’t use the `import` statement to access multiple classes or interfaces
    with the same names from different packages.
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能使用 `import` 语句访问来自不同包的具有相同名称的多个类或接口。
- en: You can import either a single member or all members (classes and interfaces)
    of a package using the `import` statement.
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `import` 语句导入包的单个成员或所有成员（类和接口）。
- en: You can’t import classes from a subpackage by using the wildcard character,
    an asterisk (`*`), in the `import` statement.
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能在 `import` 语句中使用通配符字符（星号 `*`）导入子包中的类。
- en: A class from a default package can’t be used in any named packaged class, regardless
    of whether it’s defined within the same directory or not.
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自默认包的类不能用于任何命名包装类，无论它是否定义在同一目录中。
- en: You can import an individual `static` member of a class or all its `static`
    members by using a `static import` statement.
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `static import` 语句导入类的单个 `static` 成员或所有 `static` 成员。
- en: An `import` statement can’t be placed before a `package` statement in a class.
    Any attempt to do so will cause the compilation of the class to fail.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中不能将 `import` 语句放在 `package` 语句之前。任何尝试这样做都会导致类编译失败。
- en: The members of default packages are accessible only to classes or interfaces
    defined in the same directory on your system.
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认包的成员只能被定义在同一系统目录上的类或接口访问。
- en: 'Java access modifiers:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: Java 访问修饰符：
- en: The access modifiers control the accessibility of your class and its members
    outside the class and package.
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符控制类及其成员在类和包外部可访问性。
- en: 'Java defines four access levels: `public`, `protected`, default, and `private`.'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 定义了四个访问级别：`public`、`protected`、默认和`private`。
- en: 'Java defines three access modifiers: `public`, `protected`, and `private`.'
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 定义了三个访问修饰符：`public`、`protected` 和 `private`。
- en: The `public` access modifier is the least restrictive access modifier.
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` 访问修饰符是最不限制的访问修饰符。'
- en: Classes and interfaces defined using the `public` access modifier are accessible
    to related and unrelated classes outside the package in which they’re defined.
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `public` 访问修饰符定义的类及其成员对定义它们的包中的相关和不相关的类都是可访问的。
- en: The members of a class defined using the `protected` access modifier are accessible
    to classes and interfaces defined in the same package and to all derived classes,
    even if they’re defined in separate packages.
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `protected` 访问修饰符定义的类的成员对同一包中定义的类和接口以及所有派生类都是可访问的，即使它们定义在不同的包中。
- en: The members of a class defined without using an explicit access modifier are
    defined with package accessibility (also called default accessibility).
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用显式访问修饰符定义的类的成员具有包访问性（也称为默认访问性）。
- en: The members with package access are accessible only to classes and interfaces
    defined in the same package.
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有包访问的成员只能被定义在同一包中的类和接口访问。
- en: A class defined using default access can’t be accessed outside its package.
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认访问定义的类在其包外部不可访问。
- en: The members of a class defined using a `private` access modifier are accessible
    only to the class in which they’re defined. It doesn’t matter whether the class
    or interface in question is from another package or has extended the class. Private
    members are not accessible outside the class in which they’re defined.
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `private` 访问修饰符定义的类的成员只能在其定义的类中访问。无论相关的类或接口是否来自另一个包或扩展了该类，这都不重要。私有成员在其定义的类外部不可访问。
- en: The `private` access modifier is the most restrictive access modifier.
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private` 访问修饰符是最限制的访问修饰符。'
- en: 'Nonaccess modifiers:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 非访问修饰符：
- en: The nonaccess modifiers change the default properties of a Java class and its
    members.
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非访问修饰符改变 Java 类及其成员的默认属性。
- en: The nonaccess modifiers covered by this exam are `abstract`, `final`, and `static`.
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本考试涵盖的非访问修饰符有 `abstract`、`final` 和 `static`。
- en: The `abstract` keyword, when prefixed to the definition of a concrete class,
    can change it to an `abstract` class, even if it doesn’t define any `abstract`
    methods.
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `abstract` 关键字加在具体类的定义之前时，即使它没有定义任何 `abstract` 方法，也可以将其转换为 `abstract` 类。
- en: An `abstract` class can’t be instantiated.
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract` 类不能被实例化。'
- en: An interface is implicitly `abstract`. The Java compiler automatically adds
    the keyword `abstract` to the definition of an interface (which means that adding
    the keyword `abstract` to the definition of an interface is redundant).
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口是隐式 `abstract` 的。Java 编译器自动将 `abstract` 关键字添加到接口的定义中（这意味着在接口定义中添加 `abstract`
    关键字是多余的）。
- en: An `abstract` method doesn’t have a body. When a non-abstract class extends
    a class with an abstract method, it must implement the method.
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract` 方法没有主体。当一个非 `abstract` 类扩展了一个具有 `abstract` 方法的类时，它必须实现该方法。'
- en: A variable can’t be defined as an `abstract` variable.
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量不能定义为 `abstract` 变量。
- en: The `static` modifier can be applied to inner classes, inner interfaces, variables,
    and methods. Inner classes and interfaces aren’t covered in this exam.
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 修饰符可以应用于内部类、内部接口、变量和方法。内部类和接口不包含在本考试中。'
- en: A method can’t be defined as both `abstract` and `static`.
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法不能同时定义为 `abstract` 和 `static`。
- en: '`static` attributes (fields and methods) are common to all instances of a class
    and aren’t unique to any instance of a class.'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 属性（字段和方法）对所有类的实例都是通用的，并不特定于类的任何实例。'
- en: '`static` attributes exist independently of any instances of a class and may
    be accessed even when no instances of the class have been created.'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 属性独立于类的任何实例存在，即使没有创建类的实例也可以访问。'
- en: '`static` attributes are also known as *class fields* or *class methods* because
    they’re said to belong to their class, not to any instance of that class.'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 属性也被称为 *类字段* 或 *类方法*，因为它们被认为属于它们的类，而不是属于该类的任何实例。'
- en: A `static` variable or method can be accessed using the name of a reference
    object variable or the name of a class.
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用引用对象变量的名称或类的名称来访问 `static` 变量或方法。
- en: 'A `static` method or variable can’t access non-`static` variables or methods
    of a class. But the reverse is true: non-`static` variables and methods can access
    `static` variables and methods.'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 方法或变量不能访问类的非 `static` 变量或方法。但反之亦然：非 `static` 变量和方法可以访问 `static` 变量和方法。'
- en: '`static` classes and interfaces are a type of nested classes and interfaces,
    but they aren’t covered in this exam.'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 类和接口是一种嵌套类和接口，但它们不包含在本考试中。'
- en: You can’t prefix the definition of a top-level class or an interface with the
    keyword `static`. A top-level class or interface is one that isn’t defined within
    another class or interface.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能用 `static` 关键字前缀顶级类或接口的定义。顶级类或接口是在另一个类或接口之外定义的。
- en: 'Features and components of Java:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的特性和组件：
- en: '***Object orientation—*** Java emulates real-life object definition and behavior.
    It uses classes, interfaces, or enums to define all its code.'
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***面向对象—*** Java 模拟现实生活中的对象定义和行为。它使用类、接口或枚举来定义所有代码。'
- en: '***Abstraction—*** Java lets you abstract objects and include only the required
    properties and behavior in your code.'
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***抽象—*** Java 允许你抽象对象，并在代码中只包含所需的属性和行为。'
- en: '***Encapsulation—*** The state or the fields of a class are protected from
    unwanted access and manipulation.'
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***封装—*** 类的状态或字段受到不受欢迎的访问和操作的防护。'
- en: '***Inheritance—*** Java enables its classes to inherit other classes and implement
    interfaces. The interfaces can inherit other interfaces.'
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***继承—*** Java 允许其类继承其他类并实现接口。接口可以继承其他接口。'
- en: '***Polymorphism—*** Java enables instances of its classes to exhibit multiple
    behaviors for the same method calls.'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***多态—*** Java 允许其类的实例对同一方法调用表现出多种行为。'
- en: '***Type safety—*** In Java, you must declare a variable with its data type
    before you can use it.'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***类型安全—*** 在 Java 中，在使用变量之前必须声明其数据类型。'
- en: '***Automatic memory management—*** Java uses garbage collectors for automatic
    memory management. They reclaim memory from objects that are no longer in use.'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***自动内存管理—*** Java 使用垃圾回收器进行自动内存管理。它们从不再使用的对象中回收内存。'
- en: '***Multithreading and concurrency—*** Java defines classes and interfaces to
    enable developers to develop multithreaded code.'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***多线程和并发—*** Java 定义了类和接口，以使开发者能够开发多线程代码。'
- en: Java isn’t a single-threaded language.
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 不是一个单线程语言。
- en: 1.9\. Sample exam questions
  id: totrans-877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.9\. 样例考试问题
- en: '**[Q1-1.](#ch01qa2q0a1)**'
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-1.](#ch01qa2q0a1)**'
- en: ''
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given:'
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定：
- en: ''
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ''
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following options will compile?
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个选项可以编译？
- en: ''
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-886
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ''
  id: totrans-887
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-888
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-889
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ''
  id: totrans-890
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-891
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-892
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ''
  id: totrans-893
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-894
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-895
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ''
  id: totrans-896
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-897
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: None of the above
  id: totrans-898
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: '**[Q1-2.](#ch01qa2q0a2)**'
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-2.](#ch01qa2q0a2)**'
- en: ''
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following numbered list of Java class components is not in any particular
    order. Select the acceptable order of their occurrence in any Java class (choose
    all that apply):'
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下编号的Java类组件列表没有特定的顺序。选择它们在任何Java类中出现的可接受顺序（选择所有适用的）：
- en: ''
  id: totrans-902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: comments
  id: totrans-903
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释
- en: '`import` statement'
  id: totrans-904
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import`语句'
- en: '`package` statement'
  id: totrans-905
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`package`语句'
- en: methods
  id: totrans-906
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法
- en: class declaration
  id: totrans-907
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类声明
- en: variables
  id: totrans-908
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量
- en: ''
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1, 3, 2, 5, 6, 4
  id: totrans-910
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1, 3, 2, 5, 6, 4
- en: 3, 1, 2, 5, 4, 6
  id: totrans-911
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3, 1, 2, 5, 4, 6
- en: 3, 2, 1, 4, 5, 6
  id: totrans-912
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3, 2, 1, 4, 5, 6
- en: 3, 2, 1, 5, 6, 4
  id: totrans-913
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3, 2, 1, 5, 6, 4
- en: '**[Q1-3.](#ch01qa2q0a3)**'
  id: totrans-914
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-3.](#ch01qa2q0a3)**'
- en: ''
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following examples defines a correct Java class structure?
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个示例定义了正确的Java类结构？
- en: ''
  id: totrans-917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-918
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ''
  id: totrans-919
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-920
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-921
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ''
  id: totrans-922
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-923
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-924
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ''
  id: totrans-925
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-926
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-927
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ''
  id: totrans-928
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-929
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-930
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ''
  id: totrans-931
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-932
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-933
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**[Q1-4.](#ch01qa2q0a4)**'
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-4.](#ch01qa2q0a4)**'
- en: ''
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following contents of the Java source code file MyClass.java, select
    the correct options:'
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下Java源代码文件MyClass.java的内容，选择正确的选项：
- en: ''
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ''
  id: totrans-939
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The imported class, `java.util.Date`, can be accessed only in the class `Student`.
  id: totrans-940
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入的类`java.util.Date`只能在`Student`类中访问。
- en: The imported class, `java.util.Date`, can be accessed by both the `Student`
    and `Course` classes.
  id: totrans-941
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入的类`java.util.Date`可以被`Student`和`Course`类访问。
- en: Both of the classes `Student` and `Course` are defined in the package `com.ejava-guru`.
  id: totrans-942
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Student`和`Course`两个类都定义在`com.ejava-guru`包中。'
- en: Only the class `Student` is defined in the package `com.ejavaguru`. The class
    `Course` is defined in the default Java package.
  id: totrans-943
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有`Student`类定义在`com.ejavaguru`包中。`Course`类定义在默认的Java包中。
- en: '**[Q1-5.](#ch01qa2q0a5)**'
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-5.](#ch01qa2q0a5)**'
- en: ''
  id: totrans-945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following definition of the class `EJavaGuru`,
  id: totrans-946
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下类`EJavaGuru`的定义，
- en: ''
  id: totrans-947
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ''
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: what is the output of `EJavaGuru`, if it is executed using the following command?
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果使用以下命令执行`EJavaGuru`，它的输出是什么？
- en: ''
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ''
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`one:two:three`'
  id: totrans-954
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`one:two:three`'
- en: '`EJavaGuru:one:two`'
  id: totrans-955
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EJavaGuru:one:two`'
- en: '`java:EJavaGuru:one`'
  id: totrans-956
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java:EJavaGuru:one`'
- en: '`two:three:four`'
  id: totrans-957
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`two:three:four`'
- en: '**[Q1-6.](#ch01qa2q0a6)**'
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-6.](#ch01qa2q0a6)**'
- en: ''
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following options, when inserted at `//INSERT CODE HERE`, will
    print out `EJavaGuru`?
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个选项，当插入到`//INSERT CODE HERE`处时，将打印出`EJavaGuru`？
- en: ''
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ''
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`public void main (String[] args)`'
  id: totrans-964
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public void main (String[] args)`'
- en: '`public void main(String args[])`'
  id: totrans-965
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public void main(String args[])`'
- en: '`static public void main (String[] array)`'
  id: totrans-966
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static public void main (String[] array)`'
- en: '`public static void main (String args)`'
  id: totrans-967
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static void main (String args)`'
- en: '`static public main (String args[])`'
  id: totrans-968
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static public main (String args[])`'
- en: '**[Q1-7.](#ch01qa2q0a7)**'
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-7.](#ch01qa2q0a7)**'
- en: ''
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What is the meaning of “write once, run anywhere”? Select the correct options:'
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “一次编写，到处运行”的含义是什么？选择正确的选项：
- en: ''
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Java code can be written by one team member and executed by other team members.
  id: totrans-973
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java代码可以由一个团队成员编写，并由其他团队成员执行。
- en: It is for marketing purposes only.
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅用于营销目的。
- en: It enables Java programs to be compiled once and can be executed by any JVM
    without recompilation.
  id: totrans-975
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使Java程序能够一次性编译，并且可以在任何JVM上执行而无需重新编译。
- en: Old Java code doesn’t need recompilation when newer versions of JVMs are released.
  id: totrans-976
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧Java代码在发布新版本的JVM时不需要重新编译。
- en: '**[Q1-8.](#ch01qa2q0a8)**'
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-8.](#ch01qa2q0a8)**'
- en: ''
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A class `Course` is defined in a package `com.ejavaguru`. Given that the physical
    location of the corresponding class file is /mycode/com/ejavaguru/Course.class
    and execution takes place within the mycode directory, which of the following
    lines of code, when inserted at `// INSERT CODE HERE`, will import the `Course`
    class into the class `MyCourse`?
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`com.ejavaguru`包中定义了一个`Course`类。考虑到相应的类文件物理位置是/mycode/com/ejavaguru/Course.class，并且执行发生在mycode目录内，以下哪行代码，当插入到`//
    INSERT CODE HERE`处时，将导入`Course`类到`MyCourse`类中？
- en: ''
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ''
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`import mycode.com.ejavaguru.Course;`'
  id: totrans-983
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import mycode.com.ejavaguru.Course;`'
- en: '`import com.ejavaguru.Course;`'
  id: totrans-984
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import com.ejavaguru.Course;`'
- en: '`import mycode.com.ejavaguru;`'
  id: totrans-985
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import mycode.com.ejavaguru;`'
- en: '`import com.ejavaguru;`'
  id: totrans-986
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import com.ejavaguru;`'
- en: '`import mycode.com.ejavaguru*;`'
  id: totrans-987
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import mycode.com.ejavaguru*;`'
- en: '`import com.ejavaguru*;`'
  id: totrans-988
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import com.ejavaguru*;`'
- en: '**[Q1-9.](#ch01qa2q0a9)**'
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-9.](#ch01qa2q0a9)**'
- en: ''
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code:'
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码：
- en: ''
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ''
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements will be true if the variable `courseName`
    is defined as a `private` variable?
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果将变量`courseName`定义为`private`变量，以下哪个语句将是正确的？
- en: ''
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The class `EJavaGuru` will print `Java`.
  id: totrans-997
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类`EJavaGuru`将打印`Java`。
- en: The class `EJavaGuru` will print `null`.
  id: totrans-998
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类`EJavaGuru`将打印`null`。
- en: The class `EJavaGuru` won’t compile.
  id: totrans-999
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类`EJavaGuru`不会编译。
- en: The class `EJavaGuru` will throw an exception at runtime.
  id: totrans-1000
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类`EJavaGuru`将在运行时抛出异常。
- en: '**[Q1-10.](#ch01qa2q0a10)**'
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-10.](#ch01qa2q0a10)**'
- en: ''
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following definition of the class `Course`,
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下`Course`类的定义，
- en: ''
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ''
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: what’s the output of the following code?
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ''
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The class `EJavaGuru` will print `Java`.
  id: totrans-1011
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类`EJavaGuru`将打印`Java`。
- en: The class `EJavaGuru` will print `null`.
  id: totrans-1012
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类`EJavaGuru`将打印`null`。
- en: The class `EJavaGuru` won’t compile.
  id: totrans-1013
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类`EJavaGuru`无法编译。
- en: The class `EJavaGuru` will throw an exception at runtime.
  id: totrans-1014
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类`EJavaGuru`将在运行时抛出异常。
- en: '**[Q1-11.](#ch01qa2q0a11)**'
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-11.](#ch01qa2q0a11)**'
- en: ''
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following code, select the correct options:'
  id: totrans-1017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，选择正确的选项：
- en: ''
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ''
  id: totrans-1020
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can’t define a method argument as a `private` variable.
  id: totrans-1021
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不能将方法参数定义为`private`变量。
- en: A method argument should be defined with either `public` or default accessibility.
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法参数应该使用`public`或默认可访问性定义。
- en: For overridden methods, method arguments should be defined with `protected`
    accessibility.
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于重写的方法，方法参数应该使用`protected`可访问性定义。
- en: None of the above.
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不对。
- en: 1.10\. Answers to sample exam questions
  id: totrans-1025
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.10. 样本考试问题的答案
- en: '**[Q1-1.](#ch01qa1q1)**'
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-1.](#ch01qa1q1)**'
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given:'
  id: totrans-1028
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定：
- en: ''
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-1030
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ''
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following options will compile?
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个选项可以编译？
- en: ''
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-1034
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ''
  id: totrans-1035
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1036
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-1037
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ''
  id: totrans-1038
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1039
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-1040
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ''
  id: totrans-1041
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1042
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-1043
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ''
  id: totrans-1044
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1045
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '**None of the above**'
  id: totrans-1046
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以上都不对**'
- en: ''
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: e'
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：e
- en: ''
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: A class that isn’t defined in a package gets implicitly defined
    in Java’s default package. But such classes can’t be accessed by classes or interfaces,
    which are explicitly defined in a package.'
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：未在包中定义的类在Java中隐式地定义在默认包中。但这样的类不能被显式定义在包中的类或接口访问。
- en: ''
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option a is incorrect. The `EJava` class isn’t defined in a package, so it can’t
    be accessed by the `Guru` class, which is defined in the `java.oca.associate`
    package.
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项a是错误的。`EJava`类未在包中定义，因此无法被定义在`java.oca.associate`包中的`Guru`类访问。
- en: ''
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Options b, c, and d won’t compile. Option b uses invalid syntax in the `import`
    statement. Options c and d try to import classes from nonexistent packages—*java.default*
    and *default*.
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项b、c和d无法编译。选项b在`import`语句中使用了无效的语法。选项c和d尝试从不存在的包中导入类——*java.default*和*default*。
- en: '**[Q1-2.](#ch01qa1q2)**'
  id: totrans-1055
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-2.](#ch01qa1q2)**'
- en: ''
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following numbered list of Java class components is not in any particular
    order. Select the correct order of their occurrence in a Java class (choose all
    that apply):'
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下编号的Java类组件列表没有特定的顺序。选择它们在Java类中出现的正确顺序（选择所有适用的）：
- en: ''
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: comments
  id: totrans-1059
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释
- en: '`import` statement'
  id: totrans-1060
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import`语句'
- en: '`package` statement'
  id: totrans-1061
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`package`语句'
- en: methods
  id: totrans-1062
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法
- en: class declaration
  id: totrans-1063
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类声明
- en: variables
  id: totrans-1064
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量
- en: '**1, 3, 2, 5, 6, 4**'
  id: totrans-1065
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**1, 3, 2, 5, 6, 4**'
- en: '**3, 1, 2, 5, 4, 6**'
  id: totrans-1066
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3, 1, 2, 5, 4, 6**'
- en: 3, 2, 1, 4, 5, 6
  id: totrans-1067
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3, 2, 1, 4, 5, 6
- en: '**3, 2, 1, 5, 6, 4**'
  id: totrans-1068
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3, 2, 1, 5, 6, 4**'
- en: ''
  id: totrans-1069
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, b, d'
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, b, d
- en: ''
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The comments can appear anywhere in a class. They can appear before
    and after `package` and `import` statements. They can appear before or after a
    class, method, or variable declaration.'
  id: totrans-1072
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：注释可以出现在类中的任何位置。它们可以出现在`package`和`import`语句之前和之后。它们可以出现在类、方法或变量声明之前或之后。
- en: ''
  id: totrans-1073
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first statement (if present) in a class should be a `package` statement.
    It can’t be placed after an `import` statement or a declaration of a class.
  id: totrans-1074
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类中第一个语句（如果存在）应该是`package`语句。它不能放在`import`语句或类声明之后。
- en: ''
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `import` statement should follow a `package` statement and be followed by
    a class declaration.
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`import`语句应该跟在`package`语句之后，并跟在类声明之后。'
- en: ''
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The class declaration follows the `import` statements, if present. It’s followed
    by the declaration of the methods and variables.
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类声明跟在`import`语句之后（如果存在）。它后面跟着方法和变量的声明。
- en: ''
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Answer c is incorrect. None of the variables or methods can be defined before
    the definition of a class or interface.
  id: totrans-1080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案c是错误的。在类或接口定义之前不能定义任何变量或方法。
- en: '**[Q1-3.](#ch01qa1q3)**'
  id: totrans-1081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-3.](#ch01qa1q3)**'
- en: ''
  id: totrans-1082
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following examples defines a correct Java class structure?
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个示例定义了正确的Java类结构？
- en: ''
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-1085
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ''
  id: totrans-1086
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1087
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-1088
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ''
  id: totrans-1089
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1090
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-1091
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ''
  id: totrans-1092
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1093
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1094
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ''
  id: totrans-1095
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1096
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-1097
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ''
  id: totrans-1098
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1099
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1100
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ''
  id: totrans-1101
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1102
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-1104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-1105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option a is incorrect because `#connect` isn’t a statement in
    Java. `#` is used to add comments in UNIX.'
  id: totrans-1106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：选项a是错误的，因为`#connect`在Java中不是一个语句。`#`在UNIX中用于添加注释。
- en: ''
  id: totrans-1107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option b is incorrect because a package name (`Java compiler`) can’t contain
    spaces. Also, `java virtual machine` isn’t a valid package name to be imported
    in a class. The package name to be imported can’t contain spaces.
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项b是错误的，因为包名（`Java编译器`）不能包含空格。此外，`java virtual machine`不是一个有效的包名，不能在类中导入。要导入的包名不能包含空格。
- en: ''
  id: totrans-1109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option c is incorrect because a `package` statement (if present) must be placed
    before an `import` statement.
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项c是错误的，因为（如果存在）`package`语句必须放在`import`语句之前。
- en: ''
  id: totrans-1111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option e is incorrect. `#package` and `$import` aren’t valid statements or directives
    in Java.
  id: totrans-1112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 e 是错误的。`#package` 和 `$import` 不是 Java 中的有效语句或指令。
- en: ''
  id: totrans-1113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option f is incorrect. Java is case-sensitive, so the word `class` is not the
    same as the word `Class`. The correct keyword to define a class is `class`.
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 f 是错误的。Java 是区分大小写的，所以单词 `class` 与单词 `Class` 不相同。定义类的正确关键字是 `class`。
- en: '**[Q1-4.](#ch01qa1q4)**'
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-4.](#ch01qa1q4)**'
- en: ''
  id: totrans-1116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following contents of the Java source code file MyClass.java, select
    the correct options:'
  id: totrans-1117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下 Java 源代码文件 MyClass.java 的内容，选择正确的选项：
- en: ''
  id: totrans-1118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ''
  id: totrans-1120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The imported class, `java.util.Date`, can be accessed only in the class `Student`.
  id: totrans-1121
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入的类 `java.util.Date` 只能在 `Student` 类中访问。
- en: '**The imported class, `java.util.Date`, can be accessed by both the `Student`
    and `Course` classes.**'
  id: totrans-1122
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导入的类 `java.util.Date` 可以被 `Student` 和 `Course` 类同时访问。**'
- en: '**Both of the classes `Student` and `Course` are defined in the package `com.ejava-guru`**.'
  id: totrans-1123
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`Student` 和 `Course` 两个类都定义在 `com.ejava-guru` 包中**。'
- en: Only the class `Student` is defined in the package `com.ejavaguru`. The class
    `Course` is defined in the default Java package.
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有 `Student` 类在 `com.ejavaguru` 包中定义。`Course` 类在默认的 Java 包中定义。
- en: ''
  id: totrans-1125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b, c'
  id: totrans-1126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b, c
- en: ''
  id: totrans-1127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: You can define multiple classes, interfaces, and enums in a Java
    source code file.'
  id: totrans-1128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：您可以在一个 Java 源代码文件中定义多个类、接口和枚举。
- en: ''
  id: totrans-1129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option a is incorrect. The `import` statement applies to all the classes, interfaces,
    and enums defined within the same Java source code file.
  id: totrans-1130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 a 是错误的。`import` 语句适用于同一 Java 源代码文件中定义的所有类、接口和枚举。
- en: ''
  id: totrans-1131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option d is incorrect. If a `package` statement is defined in the source code
    file, all the classes, interfaces, and enums defined within it will exist in the
    same Java package.
  id: totrans-1132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 d 是错误的。如果源代码文件中定义了 `package` 语句，那么其中定义的所有类、接口和枚举都将存在于同一个 Java 包中。
- en: '**[Q1-5.](#ch01qa1q5)**'
  id: totrans-1133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-5.](#ch01qa1q5)**'
- en: ''
  id: totrans-1134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following definition of the class `EJavaGuru`,
  id: totrans-1135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下类 `EJavaGuru` 的定义，
- en: ''
  id: totrans-1136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1137
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ''
  id: totrans-1138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: what is the output of the previous class, if it is executed using the following
    command?
  id: totrans-1139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果使用以下命令执行前面的类，它的输出是什么？
- en: ''
  id: totrans-1140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1141
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ''
  id: totrans-1142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`one:two:three`'
  id: totrans-1143
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`one:two:three`'
- en: '`EJavaGuru:one:two`'
  id: totrans-1144
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EJavaGuru:one:two`'
- en: '`java:EJavaGuru:one`'
  id: totrans-1145
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java:EJavaGuru:one`'
- en: '**`two:three:four`**'
  id: totrans-1146
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`two:three:four`**'
- en: ''
  id: totrans-1147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-1148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-1149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The command-line arguments passed to the `main` method of a class
    do not contain the word *Java* and the name of the class.'
  id: totrans-1150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：传递给类 `main` 方法的命令行参数不包含单词 *Java* 和类的名称。
- en: ''
  id: totrans-1151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Because the position of an array is zero-based, the method argument is assigned
    the following values:'
  id: totrans-1152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为数组的位置是从零开始的，方法参数被分配以下值：
- en: ''
  id: totrans-1153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: args[0] -> one
  id: totrans-1154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args[0] -> one
- en: ''
  id: totrans-1155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: args[1] -> two
  id: totrans-1156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args[1] -> two
- en: ''
  id: totrans-1157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: args[2] -> three
  id: totrans-1158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args[2] -> three
- en: ''
  id: totrans-1159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: args[3] -> four
  id: totrans-1160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args[3] -> four
- en: ''
  id: totrans-1161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The class prints `two:three:four`.
  id: totrans-1162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该类打印 `two:three:four`。
- en: '**[Q1-6.](#ch01qa1q6)**'
  id: totrans-1163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-6.](#ch01qa1q6)**'
- en: ''
  id: totrans-1164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following options, when inserted at `//INSERT CODE HERE`, will
    print out `EJavaGuru`?
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个选项插入到 `//INSERT CODE HERE` 处，将打印出 `EJavaGuru`？
- en: ''
  id: totrans-1166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-1167
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ''
  id: totrans-1168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`public void main (String[] args)`'
  id: totrans-1169
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public void main (String[] args)`'
- en: '`public void main(String args[])`'
  id: totrans-1170
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public void main(String args[])`'
- en: '**`static public void main (String[] array)`**'
  id: totrans-1171
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`static public void main (String[] array)`**'
- en: '`public static void main (String args)`'
  id: totrans-1172
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static void main (String args)`'
- en: '`static public main (String args[])`'
  id: totrans-1173
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static public main (String args[])`'
- en: ''
  id: totrans-1174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option a is incorrect. This option defines a valid method but
    not a valid `main` method. The `main` method should be defined as a `static` method,
    which is missing from the method declaration in option a.'
  id: totrans-1177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项 a 是错误的。此选项定义了一个有效的方法，但不是一个有效的 `main` 方法。`main` 方法应该定义为 `static` 方法，但选项
    a 中的方法声明中缺少了这一点。
- en: ''
  id: totrans-1178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option b is incorrect. This option is similar to the method defined in option
    a, with one difference. In this option, the square brackets are placed after the
    name of the method argument. The `main` method accepts an array as a method argument,
    and to define an array, the square brackets can be placed after either the data
    type or the method argument name.
  id: totrans-1179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 b 是错误的。此选项与选项 a 中的方法类似，只有一个区别。在此选项中，方括号放置在方法参数名称之后。`main` 方法接受一个数组作为方法参数，要定义一个数组，方括号可以放置在数据类型或方法参数名称之后。
- en: ''
  id: totrans-1180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option c is correct. Extra spaces in a class are ignored by the Java compiler.
  id: totrans-1181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 c 是正确的。Java 编译器会忽略类中的额外空格。
- en: ''
  id: totrans-1182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option d is incorrect. The `main` method accepts an array of `String` as a method
    argument. The method in this option accepts a single `String` object.
  id: totrans-1183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 d 是错误的。`main` 方法接受一个 `String` 类型的数组作为方法参数。此选项中的方法接受一个单独的 `String` 对象。
- en: ''
  id: totrans-1184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option e is incorrect. It isn’t a valid method definition and doesn’t specify
    the return type of the method. This line of code will not compile.
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 e 是错误的。这不是一个有效的方法定义，并且没有指定方法的返回类型。这一行代码将无法编译。
- en: '**[Q1-7.](#ch01qa1q7)**'
  id: totrans-1186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-7.](#ch01qa1q7)**'
- en: ''
  id: totrans-1187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What is the meaning of “write once, run anywhere”? Select the correct options:'
  id: totrans-1188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “一次编写，到处运行”的含义是什么？选择正确的选项：
- en: ''
  id: totrans-1189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Java code can be written by one team member and executed by other team members.
  id: totrans-1190
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 代码可以由一个团队成员编写，并由其他团队成员执行。
- en: It is for marketing purposes only.
  id: totrans-1191
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这只是为了营销目的。
- en: '**It enables Java programs to be compiled once and can be executed by any JVM
    without recompilation.**'
  id: totrans-1192
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它使 Java 程序能够一次编译，并且可以在任何 JVM 上执行，无需重新编译。**'
- en: Old Java code doesn’t need recompilation when newer versions of JVMs are released.
  id: totrans-1193
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发布新的 JVM 版本时，旧的 Java 代码不需要重新编译。
- en: ''
  id: totrans-1194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Platform independence, or “write once, run anywhere,” enables
    Java code to be compiled once and run on any system with a JVM. It isn’t for marketing
    purposes only.'
  id: totrans-1197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：平台独立性，或“一次编写，到处运行”，使 Java 代码能够一次编译并在任何具有 JVM 的系统上运行。它不仅仅是为了营销目的。
- en: '**[Q1-8.](#ch01qa1q8)**'
  id: totrans-1198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-8.](#ch01qa1q8)**'
- en: ''
  id: totrans-1199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A class `Course` is defined in a package `com.ejavaguru`. Given that the physical
    location of the corresponding class file is /mycode/com/ejavaguru/Course.class
    and execution takes place within the mycode directory, which of the following
    lines of code, when inserted at `// INSERT CODE HERE`, will import the `Course`
    class into the class `MyCourse`?
  id: totrans-1200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在包 `com.ejavaguru` 中定义了一个 `Course` 类。假设相应的类文件物理位置是 /mycode/com/ejavaguru/Course.class，并且执行发生在
    mycode 目录中，以下哪一行代码，当插入到 `// INSERT CODE HERE` 时，将导入 `Course` 类到类 `MyCourse` 中？
- en: ''
  id: totrans-1201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-1202
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ''
  id: totrans-1203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`import mycode.com.ejavaguru.Course;`'
  id: totrans-1204
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import mycode.com.ejavaguru.Course;`'
- en: '**`import com.ejavaguru.Course;`**'
  id: totrans-1205
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`import com.ejavaguru.Course;`**'
- en: '`import mycode.com.ejavaguru;`'
  id: totrans-1206
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import mycode.com.ejavaguru;`'
- en: '`import com.ejavaguru;`'
  id: totrans-1207
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import com.ejavaguru;`'
- en: '`import mycode.com.ejavaguru*;`'
  id: totrans-1208
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import mycode.com.ejavaguru*;`'
- en: '`import com.ejavaguru*;`'
  id: totrans-1209
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import com.ejavaguru*;`'
- en: ''
  id: totrans-1210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b'
  id: totrans-1211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b
- en: ''
  id: totrans-1212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option a is incorrect. The base directory, mycode, in which package
    `com.ejavaguru` is defined, must not be included in the `import` statement.'
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：选项 a 是错误的。定义包 `com.ejavaguru` 的基本目录 mycode 不应包含在 `import` 语句中。
- en: ''
  id: totrans-1214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Options c and e are incorrect. The class’s physical location isn’t specified
    in the `import` statement.
  id: totrans-1215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 c 和 e 是错误的。在 `import` 语句中没有指定类的物理位置。
- en: ''
  id: totrans-1216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Options d and f are incorrect. `ejavaguru` is a package. To import a package
    and its members, the package name should be followed by `.*`, as follows:'
  id: totrans-1217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 d 和 f 是错误的。`ejavaguru` 是一个包。要导入一个包及其成员，包名后应跟 `.*`，如下所示：
- en: ''
  id: totrans-1218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-1219
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**[Q1-9.](#ch01qa1q9)**'
  id: totrans-1220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-9.](#ch01qa1q9)**'
- en: ''
  id: totrans-1221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code:'
  id: totrans-1222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码：
- en: ''
  id: totrans-1223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-1224
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ''
  id: totrans-1225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements will be true if the variable `courseName`
    is defined as a `private` variable?
  id: totrans-1226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果将变量 `courseName` 定义为 `private` 变量，以下哪个陈述将是正确的？
- en: ''
  id: totrans-1227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The class `EJavaGuru` will print Java.
  id: totrans-1228
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `EJavaGuru` 将打印 Java。
- en: The class `EJavaGuru` will print null.
  id: totrans-1229
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `EJavaGuru` 将打印 null。
- en: The **class `EJavaGuru` won’t compile.**
  id: totrans-1230
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类 `EJavaGuru` 不会编译。**'
- en: The class `EJavaGuru` will throw an exception at runtime.
  id: totrans-1231
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `EJavaGuru` 在运行时将抛出异常。
- en: ''
  id: totrans-1232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: If the variable `courseName` is defined as a `private` member,
    it won’t be accessible from the class `EJavaGuru`. An attempt to do so will cause
    it to fail at compile time. Because the code won’t compile, it can’t execute.'
  id: totrans-1235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：如果变量 `courseName` 被定义为 `private` 成员，它将无法从类 `EJavaGuru` 中访问。尝试这样做将在编译时导致失败。因为代码无法编译，所以无法执行。
- en: '**[Q1-10.](#ch01qa1q10)**'
  id: totrans-1236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-10.](#ch01qa1q10)**'
- en: ''
  id: totrans-1237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following definition of the class `Course`,
  id: totrans-1238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下 `Course` 类的定义，
- en: ''
  id: totrans-1239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-1240
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ''
  id: totrans-1241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: what’s the output of the following code?
  id: totrans-1242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-1244
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ''
  id: totrans-1245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The class `EJavaGuru` will print `Java`.
  id: totrans-1246
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `EJavaGuru` 将打印 `Java`。
- en: The class `EJavaGuru` will print `null`.
  id: totrans-1247
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `EJavaGuru` 将打印 `null`。
- en: '**The class `EJavaGuru` will not compile.**'
  id: totrans-1248
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类 `EJavaGuru` 将无法编译。**'
- en: The class `EJavaGuru` will throw an exception at runtime.
  id: totrans-1249
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `EJavaGuru` 在运行时将抛出异常。
- en: ''
  id: totrans-1250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The class will fail to compile because a nonpublic class can’t
    be accessed outside a package in which it’s defined. The class `Course` therefore
    can’t be accessed from within the class `EJavaGuru`, even if it’s explicitly imported
    into it. If the class itself isn’t accessible, there’s no point in accessing a
    public member of a class.'
  id: totrans-1253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：该类将无法编译，因为非公共类不能在其定义的包外部访问。因此，类 `Course` 不能在类 `EJavaGuru` 内部访问，即使它被显式导入。如果类本身不可访问，那么访问类的公共成员就没有意义。
- en: '**[Q1-11.](#ch01qa1q11)**'
  id: totrans-1254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1-11.](#ch01qa1q11)**'
- en: ''
  id: totrans-1255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following code, select the correct options:'
  id: totrans-1256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，选择正确的选项：
- en: ''
  id: totrans-1257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-1258
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ''
  id: totrans-1259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**You can’t define a method argument as a `private` variable.**'
  id: totrans-1260
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你不能将方法参数定义为`private`变量。**'
- en: A method argument should be defined with either `public` or default accessibility.
  id: totrans-1261
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法参数应该使用`public`或默认可访问性定义。
- en: For overridden methods, method arguments should be defined with `protected`
    accessibility.
  id: totrans-1262
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于重写的方法，方法参数应该使用`protected`可访问性定义。
- en: None of the above.
  id: totrans-1263
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非。
- en: ''
  id: totrans-1264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a'
  id: totrans-1265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a
- en: ''
  id: totrans-1266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: You can’t add an explicit accessibility keyword to the method
    parameters. If you do, the code won’t compile.'
  id: totrans-1267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：你不能给方法参数添加显式的可访问性关键字。如果你这样做，代码将无法编译。
