- en: 4 Julia as a spreadsheet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 Julia 作为电子表格
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Working with collections of numbers using the Array and Tuple types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Array 和 Tuple 类型处理数字集合
- en: Useful types to put into collections, such as numbers, characters, and text
    strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于集合的有用类型，如数字、字符和文本字符串
- en: Performing statistics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行统计分析
- en: Transforming lists of numbers with map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 map 函数转换数字列表
- en: Using predicates with the filter function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器函数的谓词
- en: In the second chapter we discussed how to work with Julia as a calculator. However,
    people working with numbers today don’t usually use desk calculators; they use
    spreadsheet tools, such as Microsoft Excel or Apple Numbers (figure 4.1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们讨论了如何将 Julia 作为计算器使用。然而，今天使用数字的人通常不会使用台式计算器；他们使用电子表格工具，如 Microsoft Excel
    或 Apple Numbers（图 4.1）。
- en: '![04-01](../Images/04-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![04-01](../Images/04-01.png)'
- en: Figure 4.1 Apple Numbers is a spreadsheet application for working with rows
    and columns of numbers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 Apple Numbers 是一个用于处理数字行和列的电子表格应用程序。
- en: In these applications, numbers are stored in tables. All serious scientific
    work involves working with large tables of data, including whole columns of numbers.
    Scientists and data analysts get survey data or measurements they want to analyze.
    Julia is excellent for this type of work. You are not literally working with a
    graphical spreadsheet tool, but you are manipulating data in table form, much
    like a modern spreadsheet application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些应用程序中，数字存储在表格中。所有严肃的科学工作都涉及处理大量数据表格，包括整个数字列。科学家和数据分析师获取他们想要分析的调查数据或测量数据。Julia
    对于这类工作非常出色。你实际上并不是在处理图形电子表格工具，但你是在表格形式中操作数据，就像现代电子表格应用程序一样。
- en: You will only scratch the surface of what is possible in this chapter. Instead,
    the main purpose is introducing the Array and Tuple datatypes. Because these are
    containers for other values, you will also touch upon the Char (character) and
    String (text string) types to have something interesting to put in your arrays
    and tuples. In fact, you will put numbers, characters, text strings, and Boolean
    values into these two collection types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中只会触及到可能性的表面。相反，主要目的是介绍 Array 和 Tuple 数据类型。因为这些是其他值的容器，你还将接触到 Char（字符）和
    String（文本字符串）类型，以便在数组中放入一些有趣的内容。实际上，你将把数字、字符、文本字符串和布尔值放入这两种集合类型中。
- en: 4.1 Analyzing pizza sales
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 分析披萨销售
- en: 'To better understand the purpose of different Array operations, I will use
    an example of pizza sales. Table 4.1 shows different types of pizza sold in different
    amounts and at different prices. You will explore how Julia code can be used to
    answer questions such as the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解不同 Array 操作的目的，我将使用披萨销售的例子。表 4.1 显示了不同类型的披萨以不同的数量和价格销售。你将探索如何使用 Julia
    代码来回答以下问题：
- en: How many pizzas were sold in total?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总共卖出了多少披萨？
- en: How much revenue did you get in total from your pizza sales?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你从披萨销售中总共获得了多少收入？
- en: What was the average price of pizzas sold?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卖出的披萨的平均价格是多少？
- en: What was the average number of pizzas sold in each category?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类别中卖出的披萨平均数量是多少？
- en: Table 4.1 Pizza sales data, where each row says how many pizzas of each type
    were sold
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 披萨销售数据，其中每一行说明每种类型的披萨销售数量
- en: '| Pizza | Amount | Price |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 披萨 | 数量 | 价格 |'
- en: '| Pepperoni | 4 | 15.0 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 辣味香肠 | 4 | 15.0 |'
- en: '| Margherita | 1 | 11.5 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 玛格丽塔 | 1 | 11.5 |'
- en: '| BBQ Chicken | 5 | 13.0 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| BBQ 鸡肉 | 5 | 13.0 |'
- en: '| Hawaiian | 3 | 12.75 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 夏威夷 | 3 | 12.75 |'
- en: '| Prosciutto | 2 | 14.25 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 芝士火腿 | 2 | 14.25 |'
- en: 4.2 Different types of arrays
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 不同类型的数组
- en: An array in Julia can represent a row, column, or table of numbers. In fact,
    arrays can contain any type of element, not just numbers. You could have arrays
    of Booleans, characters, or text strings (e.g., elements in an array are ordered).
    You can ask for elements at a specific position, such as, “Give me the third element
    in array A.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中的数组可以表示数字的行、列或表格。实际上，数组可以包含任何类型的元素，而不仅仅是数字。你可以有布尔值、字符或文本字符串的数组（例如，数组中的元素是有序的）。你可以要求特定位置的元素，例如，“给我数组
    A 中的第三个元素。”
- en: 'Let’s create a column of numbers containing the number of pizzas sold. Notice
    how the numbers are listed vertically. This is Julia’s way of telling you that
    you just made a *column vector*. When creating a column vector, separate each
    element with a comma:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含卖出披萨数量的数字列。注意数字是如何垂直列出的。这是 Julia 告诉你你刚刚创建了一个 *列向量*。在创建列向量时，用逗号分隔每个元素：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is also possible to create a *row vector* instead by separating each element
    with a space:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过用空格分隔每个元素来创建一个*行向量*：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of the values in the vector has an associated *element index*, as illustrated
    in figure 4.2\. The index of the first element is 1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 向量中的每个值都有一个相关的*元素索引*，如图4.2所示。第一个元素的索引是1。
- en: '![04-02](../Images/04-02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![04-02](../Images/04-02.png)'
- en: Figure 4.2 Illustration of how elements are organized in a row vector
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 行向量中元素组织的示意图
- en: The word *vector* is commonly used to refer to one-dimensional arrays, while
    a two-dimensional array is called a *matrix*. You can think of a matrix as the
    same as a table in a spreadsheet application. In Julia, you can construct tables
    by stacking row vectors on top of each other.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*向量*通常用来指代一维数组，而二维数组被称为*矩阵*。你可以将矩阵想象成电子表格应用中的表格。在Julia中，你可以通过将行向量堆叠在一起来构建表格。
- en: 'Notice how each row is separated with a semicolon. Here you have a table with
    the amounts and prices columns:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每一行之间用分号分隔。这里你有一个包含数量和价格列的表格：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The new lines are not required; they just make it easier to read the code.
    You would have gotten exactly the same matrix by writing the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 新行不是必需的；它们只是使代码更容易阅读。你通过写下以下内容会得到完全相同的矩阵：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To conceptualize how columns and matrices are organized, you can look at the
    following illustration (figure 4.3). With one-dimensional vectors we normally
    talk about element indices, but for a matrix, both the rows and the columns are
    numbered.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解列和矩阵是如何组织的，你可以查看以下插图（图4.3）。对于一维向量，我们通常谈论元素索引，但对于矩阵，行和列都有编号。
- en: '![04-03](../Images/04-03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![04-03](../Images/04-03.png)'
- en: Figure 4.3 Comparison of column vectors and matrices
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 列向量和矩阵的比较
- en: In this chapter, however, you will focus primarily on column vectors. They correspond
    most closely to what are called *arrays* in other languages. Multidimensional
    arrays are not a central feature in other languages like they are in Julia.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，你将主要关注列向量。它们在其他语言中被称为*数组*的内容最为接近。多维数组在Julia中不是核心特性。
- en: 4.3 Performing operations on arrays
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 在数组上执行操作
- en: 'Lists of numbers aren’t very interesting, unless they allow you to do something
    useful. Fortunately, many functions operate on arrays. For instance, Julia’s sum
    function can be used to add up all the elements in an array. Here you calculate
    the total number of pizzas sold:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列表并不很有趣，除非它们允许你做些有用的事情。幸运的是，许多函数可以操作数组。例如，Julia的sum函数可以用来计算数组中所有元素的总和。这里你计算出售的披萨总数：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to find out how many elements there are in amounts, you can use
    length. This also allows you to calculate the average number of pizzas sold of
    each type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道数量中有多少个元素，你可以使用length。这也允许你计算每种类型售出的披萨的平均数量：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s put the prices in a variable to have something to experiment with:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把价格放入一个变量中，以便进行实验：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To make it easier to get an overview of the different prices you have, you
    can sort them:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地了解你拥有的不同价格，你可以对它们进行排序：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Sorted prices stored in sorted
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 排序后的价格存储在sorted中
- en: ❷ sort did not modify prices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ sort没有修改价格。
- en: 'When you call sort, you create a new vector. The prices vector is not modified.
    By convention, Julia functions never modify any of their inputs. Sometimes it
    is necessary to modify inputs to a function. Julia developers have established
    the convention of tacking on an exclamation mark (!) to the name of any function
    which modifies its input. Hence, many Julia functions that don’t modify their
    inputs have sibling functions that do. For instance, the sort! function will sort
    its input vector rather than returning a new sorted version:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用sort时，你会创建一个新的向量。价格向量不会被修改。按照惯例，Julia函数永远不会修改它们的任何输入。有时修改函数的输入是必要的。Julia开发者已经建立了在函数名称后附加感叹号(!)的惯例，以表示任何修改其输入的函数。因此，许多不修改其输入的Julia函数都有修改输入的兄弟函数。例如，sort!函数将对其输入向量进行排序，而不是返回一个新的排序版本：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Prices were modified by sort!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 价格经过排序修改！
- en: 'What if you live in a country with value-added tax? To figure out the sticker
    price on your pizzas, you need to add the sales tax. If you live in Norway, the
    value added tax is 25%. Let’s calculate new prices with taxes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你生活在一个有增值税的国家呢？为了计算出你披萨的标价，你需要加上销售税。如果你住在挪威，增值税是25%。让我们计算带税的新价格：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But what if you want to find out how much money you made on each type of pizza?
    You could try to multiply the amounts with the prices:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想知道你每种披萨赚了多少钱？你可以尝试将金额与价格相乘：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don’t worry about the error message. I will explain the concepts you need to
    grasp to read it in later chapters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心错误信息。我将在后面的章节中解释你需要掌握的概念来阅读它。
- en: 'For now, what you need to know is that there is no obvious definition of what
    a multiplication between two columns of numbers should produce. One can imagine
    numerous ways of interpreting this. Thus you have to explicitly tell Julia that
    you want elementwise operations. You can achieve this by adding a dot to the mathematical
    operator. +, -, *, and / are for performing arithmetic on individual numbers (scalars).
    To perform elementwise operations on arrays of numbers you need to use the .+,
    .-, .*, and ./ operators:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你需要知道的是，两个数字列之间的乘法没有明显的定义。可以想象出许多解释方式。因此，你必须明确告诉 Julia 你想要逐元素操作。你可以通过在数学运算符上添加一个点来实现这一点。+、-、*
    和 / 用于对单个数字（标量）进行算术运算。要对数字数组执行逐元素运算，你需要使用 .+、.-、.* 和 ./ 运算符：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can feed this result to the sum function to compute your total profit from
    selling pizza:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个结果传递给求和函数，以计算你通过卖披萨获得的总利润：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 4.4 Working with the statistics module
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用统计模块
- en: Professionals doing statistics and data analysis usually work with tables of
    data; you can easily implement your own functions to perform statistics on individual
    columns of data. Following is a basic example of an average function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 做统计和数据分析的专业人士通常与数据表打交道；你可以轻松实现自己的函数来对数据的单个列进行统计分析。以下是一个计算平均值的简单示例。
- en: Listing 4.1 Calculating arithmetic mean
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 计算算术平均值
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of reinventing the wheel, you can use ready-made statistical functions.
    These are bundled with Julia but placed in the Statistics module (see [https://docs.julialang.org/en/v1/stdlib/Statistics/](https://docs.julialang.org/en/v1/stdlib/Statistics/)).
    Modules will be covered more extensively later, but you can think of them as bundles
    of premade functionality that you can use in your programs. To use a module, write
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是重新发明轮子，你可以使用现成的统计函数。这些函数包含在 Julia 中，但位于 Statistics 模块中（见 [https://docs.julialang.org/en/v1/stdlib/Statistics/](https://docs.julialang.org/en/v1/stdlib/Statistics/)）。模块将在稍后更详细地介绍，但你可以把它们看作是预先准备的功能包，你可以在程序中使用它们。要使用模块，请编写
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will cause the functions, types, and constants defined in the module to
    be loaded and made available to you. It will also make documentation available
    for the module. Remember, you can enter Julia’s documentation mode by writing
    a question mark (?) at the beginning of the line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致模块中定义的函数、类型和常量被加载并可供你使用。它还将使模块的文档可用。记住，你可以通过在行首输入一个问号（?）来进入 Julia 的文档模式：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To get an overview of what types and functions exist in the module, write the
    module name and a dot, and then press the Tab key twice. This will show all possible
    completions (I have edited out some of the results for clarity):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解模块中存在哪些类型和函数，请编写模块名称和一个点，然后按两次 Tab 键。这将显示所有可能的完成项（为了清晰起见，我已经编辑掉了一些结果）：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s explore some of the statistics functions in the REPL:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些在 REPL 中的统计函数：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Compute the arithmetic mean of amounts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算金额的算术平均值。
- en: ❷ The middle value when values are sorted
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当值排序时的中间值
- en: ❸ Standard deviation
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 标准差
- en: mean and median are both used to compute averages, but work slightly differently.
    With mean you add up all the values and divide by the number of values. If there
    are a few extreme values, the average can be heavily skewed. Thus, when, for instance,
    calculating the average income of a family, you usually use the median. Median
    income is calculated by sorting all the household incomes and then picking the
    income in the middle of the sorted list. That way, a few ultra-rich families will
    not skew the result.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值和中位数都用于计算平均值，但工作方式略有不同。使用平均值时，你将所有值加起来，然后除以值的数量。如果有几个极端值，平均值可能会严重偏斜。因此，例如，在计算家庭平均收入时，你通常使用中位数。中位数收入是通过对所有家庭收入进行排序，然后选择排序列表中间的收入来计算的。这样，几个非常富裕的家庭就不会使结果偏斜。
- en: With the std function, you find the standard deviation in a collection of values.
    The standard deviation is a measure of how much values differ. If every element
    is the same, then the standard deviation will be zero. Thus far, you have looked
    at dealing with arrays as a whole, but to be able to build your own functionality
    processing arrays, you need to know how to access individual elements in the array.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用std函数，您可以在值集合中找到标准差。标准差是衡量值差异程度的度量。如果每个元素都相同，则标准差将为零。到目前为止，您已经看到了如何处理整个数组，但为了能够构建自己的处理数组的功能，您需要知道如何访问数组中的单个元素。
- en: 4.5 Accessing elements
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 访问元素
- en: Every element in a Julia array is numbered starting from 1\. This is called
    1-based indexing and is very common in numerical and mathematically oriented languages.
    However, mainstream languages, such as Python, C, C++, and Java, use 0-based indexing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Julia数组中的每个元素都是从1开始编号的。这称为基于1的索引，在数值和数学相关的语言中非常常见。然而，主流语言，如Python、C、C++和Java，使用基于0的索引。
- en: 1-based vs. 0-based indexing
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基于1的索引与基于0的索引
- en: The best way to index arrays is a topic developers love to argue about. In mathematics,
    it is a common convention to number elements, rows, and columns using 1-based
    indexing. When discussing hardware details, such as computer memory addresses,
    it is more common to use 0-based indexing. Thus, languages with a numerical focus
    have tended to use 1-based indexing, while languages closer to the hardware, such
    as C, have used 0-based indexing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数组最好的方式是开发者喜欢争论的话题。在数学中，使用基于1的索引对元素、行和列进行编号是一种常见约定。当讨论硬件细节，如计算机内存地址时，更常见的是使用基于0的索引。因此，具有数值关注点的语言倾向于使用基于1的索引，而更接近硬件的语言，如C，则使用基于0的索引。
- en: 'Use square brackets to define array literals as well as to access individual
    elements by index:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号来定义数组字面量，以及通过索引访问单个元素：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Access the first element in the amounts array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问金额数组中的第一个元素。
- en: ❷ Get the fifth (last) element in the amounts array.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取金额数组中的第五（最后一个）元素。
- en: 'Use square brackets both to define an array literal and to access individual
    elements. Of course you also want to be able to change individual elements. This
    is done in identical fashion:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号既可定义数组字面量，也可访问单个元素。当然，您也希望能够更改单个元素。这可以通过相同的方式进行：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each time you change an element, you can print it out to show what the array
    currently looks like. All these examples are neat and tidy. What happens if you
    try to access an element with an invalid index?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更改元素时，您都可以打印它以显示数组当前的形状。所有这些示例都很整洁。如果您尝试通过无效索引访问元素会发生什么？
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The array xs has only two values, so you cannot attempt to set the third element.
    Julia checks if you use valid indices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数组xs只有两个值，因此您不能尝试设置第三个元素。Julia会检查您是否使用了有效的索引。
- en: ❷ Elements start at index 1\. There are no values at index 0.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 元素从索引1开始。索引0处没有值。
- en: The behavior you see here is common across most mainstream languages. However,
    some older popular langauges allow you to set elements at any index, regardless
    of how large you made the array in advance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里看到的行为在大多数主流语言中都很常见。然而，一些较老的流行语言允许您在任意索引处设置元素，无论您事先将数组设置得多大。
- en: 'There are some challenges with the way you have accessed elements in these
    examples:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中访问元素的方式存在一些挑战：
- en: You don’t always know the index of the last element, as arrays can have different
    sizes and can be grown.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您并不总是知道最后一个元素的索引，因为数组可以有不同的大小，并且可以增长。
- en: While 1-based indexing is the standard, it is possible to construct 0-based
    arrays in Julia.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然基于1的索引是标准，但在Julia中可以构建基于0的数组。
- en: 'To deal with the fact that you cannot always know where an array starts or
    ends, use the begin and end keywords to access the first and last element, respectively:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理您无法始终知道数组开始或结束位置的事实，请使用begin和end关键字分别访问第一个和最后一个元素：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Access the first element. [1] and [begin] are identical.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问第一个元素。[1]和[begin]是相同的。
- en: ❷ Access the last element. [5] and [end] are the same.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问最后一个元素。[5]和[end]是相同的。
- en: ❸ By subtracting, you can do things like access the second-last element.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过减法，您可以执行诸如访问倒数第二个元素之类的操作。
- en: 4.6 Creating arrays
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 创建数组
- en: Thus far, you have created arrays using array literals. An *array literal* means
    you literally list each element an array is composed of. For example, [4, 8, 1]
    and [false, false, true] are both examples of array literals. The variable xs
    may refer to an array, but it is not an array literal. However, array literals
    are not very effective at creating large arrays. You have a number of functions,
    such as zeros, ones, fill, and rand, which makes it easier to quickly create arrays
    containing particular values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用数组字面量创建了数组。数组字面量意味着你实际上列出了数组由哪些元素组成。例如，[4, 8, 1] 和 [false, false,
    true] 都是数组字面量的例子。变量 xs 可能指向一个数组，但它不是一个数组字面量。然而，数组字面量在创建大型数组时并不十分有效。你有一系列函数，如 zeros、ones、fill
    和 rand，这使得快速创建包含特定值的数组变得容易。
- en: 'For instance, what if you want an array containing 50 elements, all with the
    value 0? For this you can use the zeros function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要一个包含 50 个元素且所有元素值都为 0 的数组，你可以使用 zeros 函数：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is so common to initialize vectors elements to 1 that there is a function,
    ones, to do that explicitly. The function creates an array of specified length
    with every element set to the value 1:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化向量的元素为 1 是如此常见，以至于有一个专门的函数 ones 来执行此操作。该函数创建一个指定长度的数组，每个元素都设置为值 1：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But it is possible to fill a large array with any value using the fill function.
    Here you create an array with six elements, each set to the value 42:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用 fill 函数可以填充一个大型数组中的任何值。在这里，你创建了一个包含六个元素且每个元素都设置为值 42 的数组：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In many situations you need arrays with large number of random values. rand(n)
    creates a vector holding n random numbers between 0 and 1:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你需要具有大量随机值的数组。rand(n) 创建一个包含 n 个介于 0 和 1 之间的随机数的向量：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you create arrays, the description of the array made in the Julia REPL
    will look something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建数组时，在 Julia REPL 中创建的数组描述将看起来像这样：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This says that the vector you have made contains five elements, and each of
    those elements is of type Float64. But what if you want elements of a different
    type? Say you want 8-bit signed integers instead. How do you do that? The ones,
    zeros, and rand functions allow you to specify element type. Here are some examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示你创建的向量包含五个元素，并且每个元素都是 Float64 类型。但是，如果你想有不同的元素类型呢？比如说，你想要 8 位有符号整数。你该如何做？ones、zeros
    和 rand 函数允许你指定元素类型。以下是一些示例：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Make an array containing signed 8-bit integers with the value 1\. Notice the
    description of the vector says Vector{Int8}.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含有符号 8 位整数且值为 1 的数组。注意向量的描述说 Vector{Int8}。
- en: ❷ Create four zeros of type unsigned 8-bit. Notice how zero is written in hexadecimal
    form, as that is the default way of formatting unsigned integers in Julia.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建四个无符号 8 位的零。注意零是如何以十六进制形式编写的，因为在 Julia 中这是格式化无符号整数的默认方式。
- en: '❸ Create three random 8-bit signed integer values. The values will be randomly
    picked from the full range: -128 to 127.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建三个随机的 8 位有符号整数值。这些值将从完整的范围中随机选择：-128 到 127。
- en: 'Even array literals allow you to specify the element type. Thus, you can indicate
    that you want a vector of 8-bit signed integers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数组字面量也允许你指定元素类型。因此，你可以表明你想要一个 8 位有符号整数的向量：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The array literal is prefixed with the type you want for each element—Int8
    in this case. If you don’t prefix with the type, Julia will infer the element
    type. The details of how that works will become apparent when I discuss types
    in chapter 7\. If you want to check what type each element in an array is, you
    can use the eltype (short for element type) function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 数组字面量前面加上你想要为每个元素指定的类型——在这个例子中是 Int8。如果你没有指定类型，Julia 将推断元素类型。关于它是如何工作的细节，我将在第
    7 章讨论类型时说明。如果你想检查数组中每个元素的类型，你可以使用 eltype（元素类型的简称）函数：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 4.7 Mapping values in an array
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 在数组中映射值
- en: You can do more than simply adding and multiplying values. Across all programming
    languages that support functional style programming, you will find a trio of functions
    called map, reduce, and filter. Let’s explore the map function first by revisiting
    your earlier sine table calculations. Do you remember this function?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的不仅仅是简单地对值进行加法和乘法。在所有支持函数式编程风格的编程语言中，你都会找到一个由 map、reduce 和 filter 组成的三联函数。让我们首先通过回顾你之前的正弦表计算来探索
    map 函数。你还记得这个函数吗？
- en: Listing 4.2 Code for creating a sine table stored in a function
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 存储在函数中的创建正弦表代码
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, instead of printing out the table of sine values, you can create an
    array of all the sine values. For this you use the map function, which is designed
    to transform a collection of values into another array of values. Here an array
    of degrees is transformed to an array of radians using map. map applies the deg2rad
    function to every element in the input arrays:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您不必打印出正弦值的表格，您可以创建一个包含所有正弦值的数组。为此，您可以使用 map 函数，该函数旨在将值集合转换为另一个值数组。这里使用 map
    将度数数组转换为弧度数组。map 将 deg2rad 函数应用于输入数组中的每个元素：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'map is referred to as a *higher order function*. These are functions that take
    other functions as arguments and/or return functions. This is different from the
    functions you have seen thus far, which take numbers as arguments exclusively.
    The basic form of map takes a function f as first argument and applies that function
    to every element in a collection, xs, producing a new collection, ys, as output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: map 被称为**高阶函数**。这些函数接受其他函数作为参数，并且/或者返回函数。这与您迄今为止看到的函数不同，后者仅接受数字作为参数。map 的基本形式将函数
    f 作为第一个参数，并将该函数应用于集合 xs 中的每个元素，生成一个新的集合 ys 作为输出：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second argument, representing a collection, does not need to be an actual
    array. It could be anything one can iterate over and get multiple elements; thus
    you can also use a range object. Here you use a range from 0 to 90, with 15 degrees
    as a step value:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数，表示一个集合，不需要是一个实际的数组。它可以是一切可以迭代并获取多个元素的东西；因此，您也可以使用范围对象。这里您使用从 0 到 90 的范围，以
    15 度为步长值：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can combine this to create a sine table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些组合起来创建一个正弦表：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, this is not normally how you do it. Instead, you collect all transformations
    you want to do into a single function. This is more memory efficient, as every
    call to map produces a new array. Another solution is to preallocate an array
    of the same size as the output and use this array in repeated mappings. The mutating
    map! function allows you to do just that.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这通常不是您这样做的方式。相反，您可以将所有想要进行的转换组合成一个单独的函数。这更节省内存，因为每次调用 map 都会产生一个新的数组。另一个解决方案是预先分配一个与输出大小相同的数组，并在重复映射中使用该数组。mutating
    map! 函数允许您做到这一点。
- en: It writes its outputs straight to the array given as the second argument. The
    third argument is the input, which will not be modified by the map! function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出直接写入作为第二个参数给出的数组。第三个参数是输入，它不会被 map! 函数修改！
- en: 'However, if the input is of the same type and length as required by the output,
    then you can reuse the input argument as your output argument:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果输入与所需的输出类型和长度相同，则可以重用输入参数作为输出参数：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Allocate array to hold results.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 分配数组来存储结果。
- en: ❷ The input and destination array must have equal length.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输入和目标数组必须具有相同的长度。
- en: 'However, this is not an elegant way of writing the code, and mutating function
    calls are best avoided, as they make analyzing data flow much more difficult.
    Thus, you collect all transformations into one function, which reduces the number
    of memory allocations the code has to do and is often easier to read:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不是编写代码的优雅方式，并且最好避免使用可变函数调用，因为它们使数据分析变得更加困难。因此，您将所有转换收集到一个函数中，这减少了代码必须进行的内存分配次数，并且通常更容易阅读：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first line is just a one-liner function definition. You could have used
    a multiline definition instead, but it would take more space:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行只是一个单行函数定义。您也可以使用多行定义，但这会占用更多空间：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A great way of understanding built-in functions is implementing them yourself.
    To better understand map, create your own map function called transform. It contains
    new concepts, which we will discuss in more detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 理解内置函数的一个好方法是自己实现它们。为了更好地理解 map，创建一个名为 transform 的自己的 map 函数。它包含新的概念，我们将在更详细地讨论。
- en: Listing 4.3 Knock-off version of the built-in map function
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 内置 map 函数的简化版本
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ An empty array to hold the final result
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空数组来存储最终结果
- en: ❷ Add a transformed element to the result array ys.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将转换后的元素添加到结果数组 ys 中。
- en: ❸ Return the final result.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回最终结果。
- en: 'transform takes two arguments, fun and xs, where the former is a function,
    and the latter is an array or other iterable collection object. Functions can
    be stored in variables and used. The following is a simple demonstration:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: transform 接受两个参数，fun 和 xs，其中前者是函数，后者是数组或其他可迭代的集合对象。函数可以存储在变量中并使用。以下是一个简单的演示：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Calling the sin function
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 sin 函数
- en: ❷ Remember the plus operator in Julia is a function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记住 Julia 中的加号运算符是一个函数。
- en: This is why you can use fun as a function and call it, despite it being an argument
    to the transform function. The next part that needs some further explanation is
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么你可以将fun用作函数并调用它，尽管它是对transform函数的参数。需要进一步解释的下一部分是
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function adds the element x to the array xs. Remember, the exclamation
    mark warns you that the push! function potentially alters its inputs. In this
    case, the xs argument is modified.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将元素x添加到数组xs中。记住，感叹号警告你push!函数可能会更改其输入。在这种情况下，xs参数被修改。
- en: You must add the exclamation mark to call the right function; the exclamation
    mark is part of the function name, so push and push! would count as two different
    function names. In Julia, there is no function named push. If it had existed,
    you could imagine it would have returned a new array with an extra element.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须添加感叹号来调用正确的函数；感叹号是函数名的一部分，所以push和push!会被视为两个不同的函数名。在Julia中，没有名为push的函数。如果它存在，你可以想象它会返回一个包含额外元素的新数组。
- en: There is no requirement to add the exclamation mark to functions you define,
    but you should get in the habit of doing it to aid fellow developers reading your
    code. This way, it is easy to see where a variable is potentially modified (mutated).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在你定义的函数中添加感叹号不是必需的，但你应该养成这种习惯，以帮助阅读你代码的其他开发者。这样，就可以很容易地看到变量可能被修改（突变）的地方。
- en: Tip To a beginner, mutating functions may not seem like a big deal. However,
    when writing larger programs you will start to notice that functions that mutate
    inputs often make programs harder to read and follow. The exclamation mark helps
    reduce mental load when reading source code. Without it, every function call could
    potentially modify its input, making code analysis much more difficult.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 对于初学者来说，突变函数可能看起来不是什么大问题。然而，当你编写更大的程序时，你将开始注意到，突变输入的函数往往会使程序更难阅读和跟踪。感叹号有助于在阅读源代码时减轻心理负担。没有它，每个函数调用都可能潜在地修改其输入，使代码分析变得更加困难。
- en: 'The following is a simple demonstration of how push! works. You create an empty
    array ys and add numbers to it. Each time you can see how the array grows larger:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的演示，说明push!是如何工作的。你创建一个空数组ys并向其中添加数字。每次你都可以看到数组如何变大：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Create an empty array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空数组。
- en: ❷ Add the number 3 to the array.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将数字3添加到数组中。
- en: 4.8 Introducing characters and strings
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 字符和字符串的介绍
- en: Thus far, you have worked almost exclusively with numbers, but your pizza table
    contains more than just numbers. The table contains text as well, such as the
    names of the pizzas. How do you work with text in Julia?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你几乎只与数字打交道，但你的披萨表包含的不仅仅是数字。表中还包含文本，例如披萨的名称。你在Julia中如何处理文本？
- en: 'Let’s start with the most basic building block. Text is made up of characters,
    and a single character is represented by the Char type in Julia. In computer memory,
    everything is a number, including characters. Here is a little challenge: look
    at the following example, and see if you can make sense of it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的构建块开始。文本由字符组成，单个字符在Julia中由Char类型表示。在计算机内存中，一切都是数字，包括字符。这里有一个小挑战：看看下面的例子，看看你是否能理解它：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Creating an 8-bit signed integer number from the 64-bit number with a value
    of 65
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从64位数值为65的数值中创建一个8位有符号整数
- en: ❷ Creating a character from the number 65
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从数字65创建一个字符
- en: ❸ A character literal
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 字符字面量
- en: ❹ Creating an 8-bit number from a character literal
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从字符字面量创建一个8位数字
- en: You put single quotes around individual characters to create a character literals.^([1](#pgfId-1017507))
    'A' and 'Y' are both character literals.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你用单引号包围单个字符来创建字符字面量.^([1](#pgfId-1017507)) 'A'和'Y'都是字符字面量。
- en: 'This code example shows that characters in Julia are just numbers with a different
    type. Remember how an UInt8 and Int8 consume the same number of bits and can hold
    the same data but interpret it differently? The same thing holds true for characters.
    While in memory they look the same, the type determines what you can do with them.
    For instance, you cannot add two characters, but you can add a number to a character:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例表明，Julia中的字符只是不同类型的数字。记得一个UInt8和一个Int8消耗相同数量的位，可以存储相同的数据，但解释方式不同吗？字符也是如此。虽然在内存中它们看起来相同，但类型决定了你可以对它们做什么。例如，你不能将两个字符相加，但你可以将一个数字加到一个字符上：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can create arrays of characters, just like you can create arrays of numbers
    or Booleans:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建字符数组，就像你可以创建数字或布尔值的数组一样：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note To improve readability and clarity, I occasionally edit the REPL output.
    For example, I remove the (category Lu: Letter, uppercase) description tacked
    on characters, as it creates a lot of visual noise.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了提高可读性和清晰度，我偶尔会编辑REPL输出。例如，我会移除附加在字符上的（类别Lu：大写字母）描述，因为它会产生大量的视觉噪音。
- en: 'A text string is just characters joined together. Notice from the output that
    text strings are identified with double quotes, while individual characters are
    identified with single quotes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字符串只是字符的组合。注意，从输出中可以看出，文本字符串用双引号标识，而单个字符用单引号标识：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'join can take any iterable object (objects you can use in a for loop) as input.
    Hence you can provide a range of characters as well:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: join可以接受任何可迭代的对象（你可以在for循环中使用的对象）作为输入。因此，你可以提供一个字符范围：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Skip every other character by using a step size of ‘2’ in the range object:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围对象中的步长为‘2’跳过每个其他字符：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can collect the individual characters in a text string, so you can get
    back an array of characters:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以收集文本字符串中的单个字符，因此你可以得到一个字符数组：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'collect is a versatile function; it can turn any object that allows iterating
    over many values into an array. Thus you can collect ranges as well:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: collect是一个多功能的函数；它可以将任何允许迭代多个值的对象转换为数组。因此，你可以收集范围：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Strings and characters are very useful for representing pizza data. Let’s a
    look at how you can bundle together information about each pizza.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和字符对于表示披萨数据非常有用。让我们看看你如何将每个披萨的信息捆绑在一起。
- en: 4.9 Storing pizza data in tuples
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 在元组中存储披萨数据
- en: 'To do this you will use a close sibling of arrays called tuples. To write them,
    replace the square brackets [] with parentheses (). Below is an example of a tuple
    describing sales info about pepperoni pizza. It says a small (S) Hawaiian pizza
    was sold for $10.50:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你将使用与数组紧密相关的元组。要编写它们，将方括号[]替换为圆括号()。以下是一个描述胡椒披萨销售信息的元组示例。它表示一个小（S）夏威夷披萨以10.50美元的价格售出：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since a number of popular languages, such as Python and JavaScript, use both
    single quotes and double quotes to denote strings, it is worth reminding the reader
    that in this example ''S'' denotes a character and not a string. You cannot write
    strings in Julia using single quotes:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多流行的语言，如Python和JavaScript，都使用单引号和双引号来表示字符串，因此值得提醒读者，在这个例子中 'S' 表示一个字符，而不是字符串。在Julia中，你不能使用单引号来编写字符串：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Thus there is an important distinction between ''S'' and "S". The latter is
    a string, which you must think of as a collection of characters. The difference
    is similar to the difference between the number 42 and the array [42]. Instead
    of writing a tuple to contain pizza data you could use an array:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，'S' 和 "S" 之间有一个重要的区别。后者是一个字符串，你必须将其视为字符的集合。这种区别类似于数字42和数组[42]之间的区别。与其编写一个元组来包含披萨数据，你还可以使用一个数组：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So what exactly is the difference? Arrays are meant for homogenous data. Every
    element has to be of the same type. But clearly, in this case they are *not* of
    the same type. The result is that the element type of the array becomes the Any
    type:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 那么究竟有什么区别呢？数组是用来存储同质数据的。每个元素都必须是同一类型。但显然，在这个例子中，它们**不是**同一类型的。结果是数组的元素类型变成了Any类型：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You will explore the Julia type system in greater detail later. For now you
    can think of Any as meaning that anything goes. You can put any kind of value
    into the array. This would not have worked if the element type was more specific,
    such as an Int64:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在稍后更详细地探索Julia的类型系统。现在你可以将Any理解为“任何都可以”。你可以将任何类型的值放入数组中。如果元素类型更具体，例如Int64，这将不起作用：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ Julia infers that each element is of type Int64.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Julia推断每个元素都是Int64类型。
- en: ❷ Julia doesn’t know how to turn a string into a number.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 朱莉亚不知道如何将字符串转换为数字。
- en: 'Pizza arrays, in contrast, are completely indiscriminate, meaning they don’t
    care about the object type. You can assign anything to the individual elements
    because the element type of the pizza array is Any:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，披萨数组是完全无差别的，这意味着它们不关心对象类型。你可以将任何东西分配给单个元素，因为披萨数组的元素类型是Any：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Tuples, on the other hand, are much stricter. A tuple keeps track of the type
    of every element; you can see this if you perform a typeof on a tuple:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，元组要严格得多。元组跟踪每个元素的类型；如果你对元组执行typeof操作，你可以看到这一点：
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Secondly, tuples are *immutable*, meaning they cannot be changed. You can only
    read values from them; you cannot change the values.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，元组是**不可变**的，这意味着它们不能被更改。你只能从它们中读取值；你不能更改这些值。
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In other aspects, tuples are very similar to arrays. You can loop over a tuple
    just like an array or range:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，元组与数组非常相似。你可以像数组或范围一样遍历元组：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can pass them to functions such as sum, median, and mean, given they actually
    contain numbers:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将它们传递给 sum、median 和 mean 等函数，前提是它们实际上包含数字：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can look at how to create a list of pizza sales data (table 4.2) by combining
    tuples and arrays. This is the data you want to store in Julia.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过结合元组和数组来查看如何创建披萨销售数据列表（表 4.2），这是你希望在 Julia 中存储的数据。
- en: Table 4.2 Pizza sales data, where each row is a sold pizza
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 披萨销售数据，其中每一行代表一个已售披萨
- en: '| Pizza | Size | Price |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 披萨 | 尺寸 | 价格 |'
- en: '| Hawaiian | S | 10.5 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 夏威夷披萨 | S | 10.5 |'
- en: '| Sicilian | S | 12.25 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 西西里披萨 | S | 12.25 |'
- en: '| Hawaiian | L | 16.5 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 夏威夷披萨 | L | 16.5 |'
- en: '| BBQ chicken | L | 20.75 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 烤鸡披萨 | L | 20.75 |'
- en: '| BBQ chicken | M | 16.75 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 烤鸡披萨 | M | 16.75 |'
- en: 'You want to be able to process this data and find out information such as how
    much you made in total or how many large pizzas you sold. You can represent this
    in Julia in the following manner:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能够处理这些数据并找出诸如你总共赚了多少钱或你卖了多少个大披萨等信息。你可以在 Julia 中用以下方式表示：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You are using floating-point numbers to represent currency data, which is a
    bad choice. If you build software for customers handling currency data, you should
    always use fixed-point numbers,^([2](#pgfId-1018936)) but I am keeping things
    simple for educational purposes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用浮点数来表示货币数据，这是一个不好的选择。如果你为处理货币数据的客户构建软件，你应该始终使用定点数，^([2](#pgfId-1018936))
    但为了教育目的，我保持事情简单。
- en: 'To make it easier to process pizza data, you will define *accessor* functions^([3](#pgfId-1019000))
    for different properties. You will call the accessor for pizza size portion because
    Julia already has a function called size in the standard library:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易处理披萨数据，你将为不同的属性定义 *访问器* 函数^([3](#pgfId-1019000))。你将调用披萨尺寸部分的访问器，因为 Julia
    已经在标准库中有一个名为 size 的函数：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'These are just regular functions. Here I use the Julia one-liner syntax for
    function definitions, but I could have used the multiline definition as well:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是普通函数。在这里，我使用了 Julia 的单行语法来定义函数，但我也可以使用多行定义：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Remember that the last expression in a Julia function is the return value. You
    don’t have to write return pizza[3].
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Julia 函数中的最后一个表达式是返回值。你不需要写 return pizza[3]。
- en: 'What type are these pizza arguments? Are they tuples or arrays? Actually, it
    doesn’t matter what they are because index access works on both in identical fashion.
    These accessor functions are useful with map because they allow you to do things
    like getting the names of all the pizzas:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些披萨参数的类型是什么？是元组还是数组？实际上，它们是什么并不重要，因为索引访问在两者上以相同的方式工作。这些访问器函数与 map 一起使用很有用，因为它们允许你执行诸如获取所有披萨名称的操作：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding code snippet simply applied the name function to every element
    in the sales array and collected all the result values into a new array.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段只是将名称函数应用于销售数组中的每个元素，并将所有结果值收集到一个新的数组中。
- en: 4.10 Filtering pizzas based on predicates
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 基于谓词过滤披萨
- en: 'With some useful data to work with, I can introduce you to the next higher-order
    function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了有用的数据来操作后，我可以向你介绍下一个高级函数：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The filter function takes a collection of values, xs, and returns a subset,
    ys, of those values. The specific values from xs that are included in the resulting
    ys are determined by the predicate p. What is a predicate you ask?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: filter 函数接受一个值集合 xs，并返回这些值的子集 ys。xs 中包含在结果 ys 中的特定值由谓词 p 决定。你问什么是谓词？
- en: Definition A *predicate* is a function that takes some value and always returns
    a Boolean value, such as true or false.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *谓词* 是一个函数，它接受一些值并始终返回一个布尔值，例如 true 或 false。
- en: 'Julia has a number of predicate functions bundled with its standard library.
    Here are some examples:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的标准库中包含了许多谓词函数。以下是一些示例：
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Check if numbers are even (dividable by two).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查数字是否为偶数（能被二整除）。
- en: ❷ Check if numbers are odd (not dividable by two).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查数字是否为奇数（不能被二整除）。
- en: 'Predicates are not limited to numbers. There are also predicates for characters:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词不仅限于数字。还有针对字符的谓词：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ❶ Is the provided character an uppercase letter?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供的字符是否为大写字母？
- en: ❷ Is the character a space? For example, x is a letter, not a blank space.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 字符是否为空格？例如，x 是一个字母，不是一个空白空间。
- en: 'Predicates are very useful with the filter function. The following is an example
    of getting even numbers from a range:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词与 filter 函数结合使用非常有效。以下是从一个范围中获取偶数的示例：
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'But to work with the pizza data you will need to define your own predicates,
    which allows us to retrieve sales of a particular pizza size or type:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但要处理披萨数据，你需要定义自己的谓词，这允许我们检索特定尺寸或类型的披萨的销售情况：
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 4.10.1 Combining higher-order functions
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.1 组合高阶函数
- en: 'You can use the following approach to combine map, accessors, filter, and predicates
    to find out how much money you made selling large pizzas or BBQ chicken pizzas,
    for example. First, find the large pizzas:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方法结合map、访问器、过滤器和谓词来找出你卖大披萨或烧烤鸡肉披萨等赚了多少钱。首先，找到大披萨：
- en: '[PRE69]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, you get the price of the large pizzas:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你得到大披萨的价格：
- en: '[PRE70]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Using sum, you can figure out how much money you made selling large pizzas:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sum，你可以计算出你卖大披萨赚了多少钱：
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the final example, you determine how much money was made selling BBQ chicken
    pizzas:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的例子中，你确定卖烧烤鸡肉披萨赚了多少钱：
- en: '[PRE72]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'It turns out that in programming, mapping many values to another set of values
    and then reducing all these values to 1 is such a common practice that it has
    its own name: mapreduce. In the last case, you were mapping BBQ chicken sales
    items to sales prices and then adding them up. Adding up all the numbers is, in
    functional programming speak, called a *reduction*.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在编程中，将许多值映射到另一组值，然后将所有这些值归一化到1是一种如此常见的做法，以至于它有自己专门的名称：mapreduce。在上一个例子中，你将烧烤鸡肉的销售项目映射到销售价格，然后将它们加起来。在函数式编程中，将所有数字加起来被称为*归约*。
- en: 4.11 Mapping and reducing an array
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11 映射和归约数组
- en: 'With the mapreduce function you could have written the last part as a single
    function call:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mapreduce函数，你可以将最后一部分写成一个单独的函数调用：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'mapreduce is composed of two higher-order functions: map and reduce. To demonstrate
    how this works, create your own variant of mapreduce, called mapcompress, to avoid
    a naming conflict:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: mapreduce由两个高阶函数组成：map和reduce。为了演示它是如何工作的，创建你自己的mapreduce变体，称为mapcompress，以避免命名冲突：
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let me clarify how reduce works: it takes some binary function, g, as the first
    argument, and then uses this function to combine the elements in the collection,
    xs, provided as the second argument.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我澄清reduce是如何工作的：它接受一个二元函数g作为第一个参数，然后使用这个函数将提供的第二个参数集合中的元素组合起来。
- en: '[PRE75]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Unlike map, reduce requires an input function taking *two* arguments. That
    is why it is called a *binary* function. Regular mathematical operators, such
    as +, - and *, are binary functions in Julia. Thus you can use them with reduce
    to perform the equivalent of sum and factorial:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与map不同，reduce需要一个接受*两个*参数的输入函数。这就是为什么它被称为*二元*函数。在Julia中，像+、-和*这样的常规数学运算符是二元函数。因此，你可以使用它们与reduce一起执行求和和阶乘的等效操作：
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note Many developers find the naming of the function reduce unintuitive. Potentially
    better names would have been *accumulate*, *aggregate*, or *compress*. In some
    languages it is called inject.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：许多开发者发现reduce函数的命名不够直观。可能更好的名称是*accumulate*、*aggregate*或*compress*。在某些语言中，它被称为inject。
- en: 4.11.1 Sine table with map and reduce
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.1 使用map和reduce的正弦表
- en: The sine function itself is, in fact, a classic case of mapping and reducing.
    For each argument to sin(x) you get an infinite sequence of numbers, which you
    reduce to one value by adding. This is how you implemented your own sine function,
    called sine, without conflicting with the built-in sin function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦函数本身实际上是一个映射和归约的经典案例。对于sin(x)的每个参数，你得到一个无限序列的数字，通过加法将它们归约为一个值。这就是你实现自己的正弦函数（称为sine）而不与内置的sin函数冲突的方式。
- en: Listing 4.4 Sine function implemented using the Taylor series
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 使用泰勒级数实现的正弦函数
- en: '[PRE77]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can express this calculation more elegantly using the mapreduce higher-order
    function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用mapreduce高阶函数更优雅地表达这个计算。
- en: Listing 4.5 Sine function through mapreduce on a Taylor’s series
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 通过泰勒级数上的mapreduce实现的正弦函数
- en: '[PRE78]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here you are doing something new: inside the sinus function you are defining
    a new function called taylor, which takes a single argument i. The function is
    used to calculate a term in the Taylor series, meaning one of the numbers in the
    Taylor series that gets added up. It is perfectly possible to define a function
    inside other functions.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在做一件新的事情：在正弦函数内部，你定义了一个名为taylor的新函数，它接受单个参数i。该函数用于计算泰勒级数中的一个项，即泰勒级数中要加上的一个数字。在函数内部定义函数是完全可能的。
- en: But why not define this function outside? This is because it uses the x variable,
    and the value of x would not be known outside of the sinus function definition.
    If this makes your head spin, don’t worry. These concepts will be revisited many
    times later in the book and will likely make more sense at that point.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么不在外部定义这个函数呢？这是因为它使用了x变量，而x的值在正弦函数定义之外是未知的。如果你感到困惑，不要担心。这些概念将在本书后面的许多地方被重新审视，并且在那个时刻可能会更有意义。
- en: mapreduce(taylor, +, 0:n) will first apply the taylor function to every value
    in the range 0:n. This will produce an array of values, which will then be combined
    with the + operator, which is the second argument to the mapreduce function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapreduce(taylor, +, 0:n)`将首先将`taylor`函数应用于0到n范围内的每个值。这将产生一个值数组，然后使用加法运算符（`+`，`mapreduce`函数的第二个参数）将它们组合起来。'
- en: 4.12 Counting matches with Boolean arrays
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12 使用布尔数组计数匹配项
- en: In chapter 3, I mentioned it can be useful to treat Boolean values as integers
    0 or 1\. Now that you have been exposed to array we will explore a concrete example.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我提到将布尔值视为整数0或1可能是有用的。现在你已经接触到了数组，我们将探讨一个具体的例子。
- en: Listing 4.6 Counting pizzas matching predicates
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 计数匹配谓词的披萨
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since you are combining a map and sum higher-order function you could replace
    this with a single call to mapreduce. However, adding elements after mapping is
    so common that Julia’s sum function allows mapping and adding. This gives you
    an elegant way to calculate the number of large pizzas, how many are BBQ chicken,
    and so on:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在组合一个映射和求和的高阶函数，你可以用单个`mapreduce`调用替换它。然而，在映射后添加元素是非常常见的，因此Julia的`sum`函数允许映射和加法。这为你提供了一种优雅的方式来计算大型披萨的数量、有多少是烤鸡披萨等等：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: sum will transform all the pizza sales into Boolean values by applying the first
    argument as a predicate. That will produce an array of zeros and ones, which are
    added up by sum.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`函数将通过应用第一个参数作为谓词将所有的披萨销售额转换为布尔值。这将产生一个由零和一组成的数组，这些值将由`sum`函数相加。'
- en: After reading this chapter you have managed to learn about the most fundamental
    concepts in programming. Without control flow and collections of data, programming
    wouldn’t be very useful. The ability to easily work with multiple elements of
    data is what makes computers so versatile and powerful.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完本章后，你已经成功学习了编程中最基本的概念。没有控制流和数据集合，编程将不会非常有用。能够轻松地处理多个数据元素的能力使得计算机如此灵活和强大。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Julia supports many different kinds of arrays. A *vector* is a one-dimensional
    array, while a *matrix* is a two-dimensional array.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia支持许多不同类型的数组。*向量*是一维数组，而*矩阵*是二维数组。
- en: Both in mathematics and in Julia, one distinguishes between *column vectors*
    and *row vectors*. Column vectors most closely resemble what are called arrays
    in other programming languages.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数学和Julia中，人们区分*列向量*和*行向量*。列向量最接近其他编程语言中所谓的数组。
- en: Julia represents row vectors as matrices with only one row, which is why row
    vectors are very different from one-dimensional arrays in other languages.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia将行向量表示为只有一行的矩阵，这就是为什么行向量与其他语言中的一维数组非常不同。
- en: Arrays in Julia default to 1-based indexing. That means the first element starts
    at index 1.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia中的数组默认采用基于1的索引。这意味着第一个元素从索引1开始。
- en: 'Mathematical operation can be performed on whole arrays on every element. To
    do this, prefix the normal math operators with a dot: .+, .-, .*, and ./.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对整个数组中的每个元素执行数学运算。为此，在正常数学运算符前加上一个点：.+, .-, .*, 和 ./。
- en: Operations on arrays can be described as either a mapping, filtering, or reduction
    (e.g., sum and mean perform a reduction, since multiple values are reduced to
    one).
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组上的操作可以描述为映射、过滤或归约（例如，sum和mean执行归约，因为多个值被归约为一个）。
- en: The functions zeros, ones, fill, and rand make it easy to create arrays with
    a large number of elements.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zeros`、`ones`、`fill`和`rand`函数使得创建具有大量元素的数组变得容易。'
- en: An array of Char objects is not quite the same as a String. Characters must
    be joined together to form a string. However, strings behave similarly to arrays.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符对象数组并不完全等同于字符串。字符必须组合在一起才能形成一个字符串。然而，字符串的行为与数组相似。
- en: Tuples have similar behavior to arrays but are immutable, meaning you cannot
    change them.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组的行为与数组类似，但它们是不可变的，这意味着你不能改变它们。
- en: '* * *'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)A character literally is a character from A to Z rather than, for example,
    a variable or constant containing a character.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1.）字符字面意思是A到Z之间的字符，而不是例如包含字符的变量或常量。
- en: ^(2.)Look up the FixedPointDecimals.jl or CurrenciesBase.jl to work with currency
    data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: (2.)查阅FixedPointDecimals.jl或CurrenciesBase.jl以处理货币数据。
- en: ^(3.)Functions used to set and get values within a more complex data structure
    are referred to as *accessor functions*, or simply *accessors*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: (3.)用于在更复杂的数据结构中设置和获取值的函数被称为*访问器函数*，或简称*访问器*。
