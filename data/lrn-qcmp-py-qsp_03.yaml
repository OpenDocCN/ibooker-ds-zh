- en: '2 Qubits: The building blocks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 量子位：构建块
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why random numbers are an important resource
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么随机数是一个重要的资源
- en: What is a qubit?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是量子位？
- en: What basic operations can we perform on a qubit?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在量子位上执行哪些基本操作？
- en: Programming a quantum random number generator in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中编程量子随机数生成器
- en: In this chapter, we’ll start to get our feet wet with some quantum programming
    concepts. The main concept we will explore is the *qubit*, the quantum analogue
    of a classical bit. We’ll use qubits as an abstraction or model to describe the
    new kinds of computing that are possible with quantum physics. Figure 2.1 shows
    a model of using a quantum computer as well as the simulator setup that we use
    in this book. Real or simulated qubits will live on the target machine and interact
    with the quantum programs that we will be writing! Those quantum programs can
    be sent by various host programs that then wait to receive the results from the
    quantum program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始接触一些量子编程概念。我们将探索的主要概念是*量子位*，它是经典比特的量子对应物。我们将使用量子位作为抽象或模型来描述量子物理可能实现的新类型的计算。图2.1展示了使用量子计算机的模型以及我们在本书中使用的模拟器设置。真实或模拟的量子位将存在于目标机器上，并与我们将要编写的量子程序交互！这些量子程序可以通过各种主机程序发送，然后等待从量子程序接收结果。
- en: '![](../Images/2-1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-1.png)'
- en: Figure 2.1 A mental model for how we can use a quantum computer. The top half
    of the figure is the general model for a quantum computer. We will be using local
    simulators for this book, and the bottom half represents what we will be building
    and using.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 我们如何使用量子计算机的心理模型。图的上半部分是量子计算机的一般模型。我们将在这本书中使用本地模拟器，下半部分代表我们将要构建和使用的内容。
- en: 'To help learn about what qubits are and how we interact with them, we will
    use an example of how they are used today: random number generation. While we
    can build up much more interesting devices from qubits, the simple example of
    a *quantum random number generator* (QRNG) is a good way to get familiar with
    the qubit.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助了解量子位是什么以及我们如何与之交互，我们将使用一个例子来说明它们是如何被使用的：随机数生成。虽然我们可以从量子位构建出更多有趣的设备，但一个简单的*量子随机数生成器*（QRNG）的例子是一个熟悉量子位的好方法。
- en: 2.1 Why do we need random numbers?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 为什么我们需要随机数？
- en: 'Humans like certainty. We like it when pressing a key on our keyboard does
    the same thing every time. However, there are some contexts in which we want randomness:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 人类喜欢确定性。我们喜欢按下键盘上的键每次都做同样的事情。然而，在某些情况下，我们希望有随机性：
- en: Playing games
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩游戏
- en: Simulating complex systems (such as the stock market)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟复杂系统（例如股市）
- en: Picking secure secrets (for example, passwords and cryptographic keys)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择安全的秘密（例如，密码和加密密钥）
- en: 'In all of these situations where we want randomness, we can describe the chances
    of each outcome. For random events, describing the chances is all we can say about
    the situation until the die is cast (or the coin is flipped or the password is
    reused). When we describe the chances of each example, we say things like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些需要随机性的情况下，我们可以描述每个结果的概率。对于随机事件，描述概率是我们对这种情况所能说的所有内容，直到骰子掷出（或硬币翻转或密码重用）。当我们描述每个例子的概率时，我们可能会说类似这样的话：
- en: '*If* I roll this die, *then* I will get a six *with probability* 1 out of 6.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果*我掷这个骰子，*那么*我会以1/6的概率得到六。'
- en: '*If* I flip this coin, *then* I will get heads *with probability* 1 out of
    2.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果*我抛这个硬币，*那么*我会以1/2的概率得到正面。'
- en: We can also describe cases where the probabilities aren’t the same for every
    outcome. On *Wheel of Fortune*, (figure 2.2), the probability that *if* we spin
    the wheel, *then* we will get a $1,000,000 prize is much smaller than the probability
    that *if* we spin the wheel, *then* we will go bankrupt.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以描述那些每个结果概率不相同的情况。在《幸运轮盘》（图2.2）中，如果我们转动轮盘，得到$1,000,000奖金的概率远小于我们转动轮盘破产的概率。
- en: '![](../Images/2-2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-2.png)'
- en: Figure 2.2 Probabilities of $1,000,000 and Bankrupt on *Wheel of Fortune*. Before
    spinning the wheel, we don’t know exactly where it will land, but we do know by
    looking at the wheel that the probability of getting Bankrupt is much larger than
    the probability of winning big.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 在《幸运轮盘》中赢得$1,000,000和破产的概率。在转动轮盘之前，我们不知道它将停在哪里，但我们通过观察轮盘知道破产的概率远大于赢得大奖的概率。
- en: As on game shows, there are many contexts in computer science where randomness
    is critical, especially when security is required. If we want to keep some information
    private, cryptography lets us do so by combining our data with random numbers
    in different ways. If our random number generator isn’t very good—that is to say,
    if an attacker can predict what numbers we use to protect our private data—then
    cryptography doesn’t help us much. We can also imagine using a poor random number
    generator to run a raffle or a lottery; an attacker who figures out how our random
    numbers are generated can take us straight to the bank.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就像游戏节目一样，在计算机科学中有很多场景，随机性至关重要，尤其是在需要安全性的情况下。如果我们想保持某些信息私密，密码学通过以不同的方式将我们的数据与随机数结合，让我们能够做到这一点。如果我们的随机数生成器不够好——也就是说，如果攻击者可以预测我们用来保护私人数据的数字——那么密码学对我们帮助不大。我们还可以想象使用一个差的随机数生成器来运行抽奖或彩票；如果攻击者能够弄清楚我们的随机数是如何生成的，他就可以直接把我们带到银行。
- en: What are the odds?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有多大几率？
- en: We can lose a lot of money by using random numbers that our adversaries can
    predict. Just ask the producers of *Press Your Luck!*, a popular 1980s game show.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的对手可以预测的随机数，我们可能会损失大量金钱。只需问问《压你的运气！》节目的制作人，这是一个在20世纪80年代流行的游戏节目。
- en: A contestant found that he could predict where the game’s new electronic “wheel”
    would land, which allowed him to win more than $250,000 in today’s money. To learn
    more, read “The Man Who Got No Whammies” by Zachary Crockett at [https:// priceonomics.com/the-man-who-got-no-whammies](https://priceonomics.com/the-man-who-got-no-whammies).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一名参赛者发现他可以预测游戏的新电子“轮盘”会停在哪个位置，这使他赢得了超过25万美元（按今天的货币计算）。想了解更多信息，请阅读Zachary Crockett所著的《那个没有Whammies的人》一文，[https://priceonomics.com/the-man-who-got-no-whammies](https://priceonomics.com/the-man-who-got-no-whammies)。
- en: As it turns out, quantum mechanics lets us build some really unique sources
    of randomness. If we build them right, the randomness of our results is guaranteed
    by *physics*, not an assumption about how long it would take for a computer to
    solve a difficult problem. This means a hacker or adversary would have to break
    the laws of physics to break the security! This does not mean we should use quantum
    random numbers for everything; humans are still the weakest link in security infrastructure
    ![](../Images/emoji-devil.png).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，量子力学让我们能够构建一些真正独特的随机数源。如果我们构建得当，结果的不确定性是由*物理定律*保证的，而不是基于对计算机解决困难问题所需时间的假设。这意味着黑客或对手必须违反物理定律才能破坏安全性！这并不意味着我们应该在所有事情上都使用量子随机数；在安全基础设施中，人类仍然是最薄弱的环节
    ![表情符号](../Images/emoji-devil.png)。
- en: 'Deep dive: Computational security and information theoretic security'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：计算安全性和信息论安全性
- en: Some ways of protecting private information rely on assumptions about what problems
    are easy or hard for an attacker to solve. For instance, the RSA algorithm is
    a commonly used encryption algorithm and is based on the difficulty of finding
    prime factors for large numbers. RSA is used on the web and in other contexts
    to protect user data, under the assumption that adversaries can’t easily factor
    very large numbers. So far, this has proven to be a good assumption, but it is
    entirely possible that a new factoring algorithm may be discovered, undermining
    the security of RSA. New models of computation like quantum computing also change
    how reasonable or unreasonable it is to make computational assumptions like “factoring
    is hard.” As we’ll see in chapter 11, a quantum algorithm known as *Shor’s algorithm*
    allows for solving some kinds of cryptographic problems much faster than classical
    computers can, challenging the assumptions that are commonly used to promise computational
    security.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些保护私人信息的方法依赖于对攻击者解决某些问题难易程度的假设。例如，RSA算法是一种常用的加密算法，它基于寻找大数质因数的难度。RSA在互联网和其他环境中用于保护用户数据，假设对手不能轻易分解非常大的数。到目前为止，这个假设已经被证明是正确的，但完全有可能发现一种新的分解算法，从而破坏RSA的安全性。新的计算模型，如量子计算，也改变了做出“分解是困难的”这样的计算假设是否合理或不合理。正如我们在第11章中将会看到的，一种名为*Shor算法*的量子算法允许以比经典计算机快得多地解决某些类型的密码学问题，挑战了通常用于保证计算安全性的假设。
- en: By contrast, if an adversary can only ever randomly guess at secrets, even with
    very large amounts of computing power, then a security system provides much better
    guarantees about its ability to protect private information. Such systems are
    said to be *informationally secure*. Later in this chapter, we’ll see that generating
    random numbers in a hard-to-predict fashion allows us to implement an informationally
    secure procedure called a *one-time pad*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果对手只能随机猜测秘密，即使拥有非常大量的计算能力，那么安全系统就能提供更好的保证，关于其保护私人信息的能力。这样的系统被称为*信息安全的*。在本章的后面部分，我们将看到以难以预测的方式生成随机数允许我们实现一个名为*一次性密码*的信息安全程序。
- en: This gives us some confidence that we can use quantum random numbers for vital
    tasks, such as to protect private data, run lotteries, and play *Dungeons and
    Dragons*. Simulating how quantum random number generators work lets us learn many
    of the basic concepts underlying quantum mechanics, so let’s jump right in and
    get started!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们有了信心，我们可以使用量子随机数来完成重要任务，例如保护私人数据、运行彩票和玩*龙与地下城*。模拟量子随机数生成器的工作原理让我们能够学习量子力学背后的许多基本概念，所以让我们直接跳进去开始吧！
- en: 'As mentioned earlier, one great way to get started is to look at an example
    of a quantum program that generates random numbers: a quantum random number generator
    (QRNG). Don’t worry if the following algorithm (also shown in figure 2.3) doesn’t
    make a lot of sense right now—we’ll explain the different pieces as we go through
    the rest of the chapter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一种很好的入门方式是查看一个生成随机数的量子程序示例：量子随机数生成器（QRNG）。如果以下算法（也显示在图2.3中）现在看起来不太明白，请不要担心——我们将在本章的其余部分解释不同的部分：
- en: Ask the quantum device to allocate a qubit.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求量子设备分配一个量子比特。
- en: Apply an instruction called the *Hadamard instruction* to the qubit; we learn
    about this later in the chapter.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对量子比特应用一个名为*Hadamard指令*的指令；我们将在本章后面部分了解这一点。
- en: Measure the qubit, and return the result.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量量子比特，并返回结果。
- en: '![](../Images/2-3.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![2-3.png](../Images/2-3.png)'
- en: Figure 2.3 Quantum random number generator algorithm. To sample random numbers
    with a quantum computer, our program will prepare a fresh qubit and then use a
    Hadamard instruction to prepare the superposition we need. Finally, we can measure
    and return the random result that we get at the end.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3量子随机数生成器算法。要使用量子计算机采样随机数，我们的程序将准备一个新鲜的量子比特，然后使用Hadamard指令来准备所需的叠加。最后，我们可以测量并返回我们在最后得到的随机结果。
- en: In the rest of the chapter, we’ll develop a Python class called `QuantumDevice`
    to let us write programs that implement algorithms like this one. Once we have
    a `QuantumDevice` class, we’ll be able to write QRNG as a Python program similar
    to classical programs that we’re used to.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将开发一个名为`QuantumDevice`的Python类，以便我们可以编写实现此类算法的程序。一旦我们有了`QuantumDevice`类，我们就能像编写我们习惯的经典程序一样编写QRNG作为Python程序。
- en: Note Please see appendix A for instructions on how to set up Python on your
    device to run quantum programs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请参阅附录A，了解如何在您的设备上设置Python以运行量子程序。
- en: Note that the following sample will not run until you have written the simulator
    in this chapter ![](../Images/emoji-happyface.png).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下示例将在您在本章中编写模拟器之前无法运行 ![表情符号-笑脸](../Images/emoji-happyface.png)。
- en: 'Listing 2.1 qrng.py: a quantum program that generates random numbers'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 qrng.py：一个生成随机数的量子程序
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Quantum programs are written just like classical programs. In this case, we’re
    using Python, so our quantum program is a Python function qrng that implements
    a QRNG.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶量子程序编写方式与经典程序相同。在这种情况下，我们使用Python，因此我们的量子程序是一个名为qrng的Python函数，它实现了QRNG。
- en: '❷ Quantum programs work by asking quantum computing hardware for qubits: quantum
    analogues of bits that we can use to perform computations.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❷量子程序通过请求量子计算硬件提供量子比特来工作：我们可以用来执行计算的位量子模拟器。
- en: ❸ Once we have a qubit, we can issue instructions to that qubit. Similar to
    assembly languages, these instructions are often denoted by short abbreviations;
    we’ll see what h() stands for later in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❸一旦我们有一个量子比特，我们就可以向该量子比特发出指令。类似于汇编语言，这些指令通常用简短的缩写表示；我们将在本章后面部分看到h()代表什么。
- en: ❹ To get data back from our qubits, we can measure them. In this case, half
    of the time, our measurement will return True, and the other half of the time,
    we’ll get back False.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❹要从我们的量子比特中获取数据，我们可以测量它们。在这种情况下，一半的时间，我们的测量将返回True，另一半的时间，我们将得到False。
- en: That’s it! Four steps, and we’ve just created our first quantum program. This
    QRNG returns true or false. In Python terms, this means we get a 1 or a 0 each
    time we run `qrng`. It’s not a very sophisticated random number generator, but
    the number it returns is truly random.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！四步，我们就已经创建了我们的第一个量子程序。这个量子随机数生成器返回真或假。用Python的话说，这意味着每次我们运行`qrng`时，我们都会得到一个1或一个0。它不是一个非常复杂的随机数生成器，但它返回的数字确实是随机的。
- en: To run the `qrng` program, we need to give the function a `QuantumDevice` that
    provides access to qubits and implements the different instructions we can send
    to qubits. Although we need only one qubit, to start, we’re going to build our
    own quantum computer simulator. *Existing hardware could be used for this modest
    task, but what we will look at later will be beyond the scope of available hardware.*
    It will run locally on a laptop or desktop and behave like actual quantum hardware.
    Throughout the rest of the chapter, we’ll build the different pieces we need to
    write our own simulator and run `qrng`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`qrng`程序，我们需要给函数提供一个`QuantumDevice`，该设备提供对量子比特的访问并实现我们可以发送给量子比特的不同指令。虽然我们一开始只需要一个量子比特，但我们将构建自己的量子计算机模拟器。*现有的硬件可以用于这项任务，但我们将要看的将超出现有硬件的范围。*
    它将在笔记本电脑或台式机上本地运行，并像实际的量子硬件一样工作。在整个章节的其余部分，我们将构建编写我们自己的模拟器和运行`qrng`所需的不同组件。
- en: 2.2 What are classical bits?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 经典比特是什么？
- en: When learning about the concepts of quantum mechanics, it often helps to step
    back and reexamine *classical* concepts to make the connection to how they are
    expressed in quantum computing. With that in mind, let’s take another look at
    what *bits* are.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习量子力学的概念时，退一步重新审视*经典*概念通常有助于理解它们在量子计算中的表达方式。考虑到这一点，让我们再看看*比特*是什么。
- en: Suppose we’d like to send our dear friend Eve an important message, such as
    “![](../Images/emoji-sparklingheart.png)”. How can we represent our message in
    a way that it can be easily sent?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想向我们亲爱的朋友Eve发送一条重要的消息，比如“![](../Images/emoji-sparklingheart.png)”。我们如何以易于发送的方式表示我们的消息？
- en: 'We might start by making a list of every letter and symbol that we could use
    to write messages. Fortunately, the Unicode Consortium ([https://unicode.org](https://unicode.org))
    has already done this for us and assigned *codes* to an extensive variety of characters
    used for communication around the world. For instance, *I* is assigned the code
    0049, while ![](../Images/emoji-bee.png) is denoted by A66E, ![](../Images/emoji-antena.png) by
    2E0E, and ![](../Images/emoji-sparklingheart.png) by 1F496\. These codes may not
    seem helpful at first glance, but they’re useful recipes for how to send each
    symbol as a message. If we know how to send two messages (let’s call them “0”
    and “1”), these recipes let us build more complicated messages like “![](../Images/emoji-bee.png)”,
    “![](../Images/emoji-antena.png)”, and “![](../Images/emoji-sparklingheart.png)”
    as sequences of “0” and “1” messages:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能首先会列出我们可能用来写消息的每一个字母和符号。幸运的是，Unicode联盟([https://unicode.org](https://unicode.org))已经为我们做了这件事，并为世界上广泛使用的各种字符分配了*代码*。例如，*I*被分配了代码0049，而![](../Images/emoji-bee.png)被表示为A66E，![](../Images/emoji-antena.png)为2E0E，![](../Images/emoji-sparklingheart.png)为1F496。这些代码一开始可能看起来没有帮助，但它们是发送每个符号作为消息的有用方法。如果我们知道如何发送两条消息（让我们称它们为“0”和“1”），这些方法让我们能够构建更复杂的消息，如“![](../Images/emoji-bee.png)”、“![](../Images/emoji-antena.png)”和“![](../Images/emoji-sparklingheart.png)”作为“0”和“1”消息的序列：
- en: '| **0** | 0000 | **8** | 1000 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 0000 | **8** | 1000 |'
- en: '| **1** | 0001 | **9** | 1001 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 0001 | **9** | 1001 |'
- en: '| **2** | 0010 | **A** | 1010 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 0010 | **A** | 1010 |'
- en: '| **3** | 0011 | **B** | 1011 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 0011 | **B** | 1011 |'
- en: '| **4** | 0100 | **C** | 1100 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 0100 | **C** | 1100 |'
- en: '| **5** | 0101 | **D** | 1101 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **5** | 0101 | **D** | 1101 |'
- en: '| **6** | 0110 | **E** | 1110 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **6** | 0110 | **E** | 1110 |'
- en: '| **7** | 0111 | **F** | 1111 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **7** | 0111 | **F** | 1111 |'
- en: 'Now we can send whatever we want if we know how to send just two messages to
    Eve: a “0” message and a “1” message. Using these recipes, our message “![](../Images/emoji-sparklingheart.png)”
    becomes “0001 1111 0100 1001 0110” or Unicode 1F496.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何只向Eve发送两条消息：一条“0”消息和一条“1”消息，我们就可以发送任何我们想要的东西。使用这些方法，我们的消息“![](../Images/emoji-sparklingheart.png)”变成了“0001
    1111 0100 1001 0110”或Unicode 1F496。
- en: Tip Don’t send “0001 1111 0100 1001 0100” by mistake, or Eve will get a ![](../Images/emoji-brokenheart.png)
    from you!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：不要错误地发送“0001 1111 0100 1001 0100”，否则Eve会收到你发来的![](../Images/emoji-brokenheart.png)！
- en: We call each of the two messages “0” and “1” a *bit*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把每个消息“0”和“1”称为一个*比特*。
- en: Note To distinguish bits from the quantum bits we’ll see throughout the rest
    of the book, we’ll often emphasize that we’re talking about *classical* bits.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 为了区分比特和本书其余部分将看到的量子比特，我们通常会强调我们在谈论的是*经典*比特。
- en: 'When we use the word *bit*, we generally mean one of two things:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用“比特”这个词时，我们通常指的是以下两种情况之一：
- en: Any physical system that can be completely described by answering one true/false
    question
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可以通过回答一个真/假问题来完全描述的物理系统
- en: The information stored in such a physical system
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在这样的物理系统中的信息
- en: For example, padlocks, light switches, transistors, the left or right spin on
    a curveball, and wine in wine glasses can all be thought of as bits, as we can
    use all of them to send or record messages (see table 2.1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，挂锁、开关、晶体管、曲线球上的左旋或右旋，以及酒杯中的酒都可以被视为比特，因为我们都可以使用它们来发送或记录信息（见表2.1）。
- en: Table 2.1 Examples of bits
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 比特示例
- en: '| Label | Padlock | Light switch | Transistor | Wine glass | Baseball |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | 挂锁 | 开关 | 晶体管 | 酒杯 | 棒球 |'
- en: '| 0 | Unlocked | Off | Low voltage | Contains white wine | Rotating to the
    left |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 未锁定 | 关闭 | 低压 | 含白葡萄酒 | 向左旋转 |'
- en: '| 1 | Locked | On | High voltage | Contains red wine | Rotating to the right
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 锁定 | 开启 | 高压 | 含红葡萄酒 | 向右旋转 |'
- en: These examples are all bits because we can fully describe them to someone else
    by answering a single true/false question. Put differently, each example lets
    us send either a 0 or a 1 message. Like all conceptual models, a bit has limitations—how
    would we describe a rosé wine, for instance?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子都是比特，因为我们可以通过回答一个单一的真/假问题来完全描述它们。换句话说，每个例子都允许我们发送0或1的信息。像所有概念模型一样，比特也有局限性——例如，我们如何描述桃红酒呢？
- en: That said, a bit is a useful tool because we can describe ways of interacting
    with a bit that are independent of how we actually build the bit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，比特是一个有用的工具，因为我们可以描述与比特交互的方式，这些方式与我们如何实际构建比特无关。
- en: 2.2.1 What can we do with classical bits?
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 我们可以用经典比特做什么？
- en: Now that we have a way of describing and sending classical information, what
    can we do to process and modify it? We describe the ways that we can process information
    in terms of *operations*, which we define as the ways of describing how a model
    can be changed or acted upon.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了描述和发送经典信息的方法，我们可以做些什么来处理和修改它呢？我们用*操作*来描述我们可以处理信息的方式，我们将其定义为描述模型如何被改变或作用的方式。
- en: To visualize the NOT operation, let’s imagine labeling two points as 0 and 1,
    as shown in figure 2.4\. The NOT operation is then any transformation that turns
    0 bits into 1 bits and vice versa. In classical storage devices like hard drives,
    a NOT gate flips the magnetic field that stores our bit value. As shown in figure
    2.5, we can think of NOT as implementing a 180° rotation between the 0 and 1 points
    we drew in figure 2.4.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化NOT操作，让我们想象将两个点标记为0和1，如图2.4所示。NOT操作就是任何将0比特转换为1比特，反之亦然的变换。在经典存储设备如硬盘驱动器中，NOT门翻转存储我们比特值的磁场。如图2.5所示，我们可以将NOT视为在图2.4中绘制的0和1点之间实现180°旋转。
- en: '![](../Images/2-4.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-4.png)'
- en: Figure 2.4 A classical bit can be in one of two different states, typically
    called 0 and 1\. We can depict a classical bit as a black dot in either the 0
    or 1 position.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 一个经典比特可以处于两种不同的状态之一，通常称为0和1。我们可以将经典比特表示为在0或1位置上的一个黑点。
- en: '![](../Images/2-5.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-5.png)'
- en: Figure 2.5 The classical NOT operation flips a classical bit between 0 and 1\.
    For instance, if a bit starts in the 0 state, NOT flips it to the 1 state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 经典的NOT操作在0和1之间翻转一个经典比特。例如，如果一个比特最初处于0状态，NOT操作会将其翻转至1状态。
- en: Visualizing classical bits this way also lets us extend the notion of bits slightly
    to include a way to describe *random* bits (which will be helpful later). If we
    have a *fair coin* (that is, a coin that lands heads half the time and tails the
    other half), then it wouldn’t be correct to call that coin a 0 or a 1\. We only
    know what bit value our coin bit has if we set it with a particular side face
    up on a surface; we can also flip it to get a random bit value. Every time we
    flip a coin, we know that eventually, it will land, and we will get heads or tails.
    Whether it lands heads or tails is governed by a probability called the *bias*
    of the coin. We have to pick a side of the coin to describe the bias, which is
    easy to phrase as a question like “What is the probability that the coin will
    land heads?” Thus a fair coin has a bias of 50% because it lands with the value
    heads half of the time, which is mapped to the bit value 0 in figure 2.6.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式可视化经典比特也让我们稍微扩展了比特的概念，包括描述*随机*比特的方法（这将在以后很有帮助）。如果我们有一枚*公平的硬币*（即，一枚一半时间落在正面，另一半时间落在反面的硬币），那么称那枚硬币为0或1是不正确的。如果我们把硬币的一侧放在表面上，我们才能知道硬币比特的值；我们也可以翻转它以获得随机的比特值。每次我们翻转硬币，我们都知道它最终会落下，我们会得到正面或反面。它落在正面或反面是由称为硬币*偏差*的概率所决定的。我们必须选择硬币的一侧来描述偏差，这可以很容易地用一个问题来表达，比如“硬币落在正面的概率是多少？”因此，一枚公平的硬币的偏差是50%，因为它一半时间落在正面，这在图2.6中被映射到比特值0。
- en: '![](../Images/2-6.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6](../Images/2-6.png)'
- en: Figure 2.6 We can use the same picture as before to extend our concept of a
    bit to describe a coin. Unlike a bit, a coin has a probability of being either
    0 or 1 each time it is tossed. We graphically represent that probability as a
    point between 0 and 1.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 我们可以使用之前的相同图片来扩展我们的比特概念，以描述一枚硬币。与比特不同，硬币每次被掷出时都有可能是0或1。我们用0和1之间的点来图形化地表示这个概率。
- en: 'Using this visualization, we can take our previous two dots indicating the
    bit values 0 and 1 and connect them with a line on which we can plot our coin’s
    bias. It becomes easier to see that a NOT operation (which still works on our
    new probabilistic bit) doesn’t do anything to a fair coin. If 0 and 1 occur with
    the same probability, then it doesn’t matter if we rotate a 0 to a 1 or a 1 to
    a 0: we’ll still wind up with 0 and 1 having the same probability.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种可视化，我们可以将表示比特值0和1的前两个点用一条线连接起来，在这条线上我们可以绘制硬币的偏差。这样我们更容易看到，NOT操作（它仍然适用于我们新的概率比特）对一枚公平的硬币没有任何作用。如果0和1出现的概率相同，那么我们旋转0到1或1到0都没有关系：我们最终还是会得到0和1具有相同的概率。
- en: What if our bias is not in the middle? If we know that someone is trying to
    cheat by using a weighted or modified coin that almost always lands on heads,
    we can say the bias of the coin is 90% and plot it on our line by drawing a point
    much closer to 0 than to 1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的偏差不在中间呢？如果我们知道有人试图通过使用几乎总是落在正面的一枚加权或修改过的硬币来作弊，我们可以说硬币的偏差是90%，并在我们的线上画一个点，这个点比1更接近0。
- en: Definition The point on a line where we would draw each classical bit is the
    *state* of that bit.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 在线上我们绘制每个经典比特的点是该比特的*状态*。
- en: Let’s consider a scenario. Say I want to send you a bunch of bits stored using
    padlocks. What is the cheapest way I can do so?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景。比如说，我想通过密码锁发送给你一些比特。我能以最便宜的方式做到这一点吗？
- en: One approach is to mail a box containing many padlocks that are either open
    or closed and hope that they arrive in the same state in which I sent them. On
    the other hand, we can agree that all padlocks start in the 0 (unlocked) state,
    and I can send you instructions on which padlocks to close. This way, you can
    buy your own padlocks, and I only need to send a *description* of how to prepare
    those padlocks using classical NOT gates. Sending a piece of paper or an email
    is much cheaper than mailing a box of padlocks!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过邮寄一个包含许多开或关的密码锁的盒子，并希望它们以与我发送时相同的状态到达。另一方面，我们可以同意所有密码锁都从0（未锁定）状态开始，我可以给你发送关于哪些密码锁需要锁上的指令。这样，你可以购买自己的密码锁，而我只需要发送一个*描述*，说明如何使用经典NOT门来准备这些密码锁。发送一张纸或一封电子邮件比邮寄一个密码锁盒子便宜得多！
- en: 'This illustrates a principle we will rely on throughout the book: *the state
    of a physical system can also be described in terms of instructions for how to
    prepare that state.* Thus, the operations allowed on a physical system also define
    what states are possible.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了我们在整本书中都将依赖的一个原则：*物理系统的状态也可以用如何准备该状态的指令来描述。*因此，允许在物理系统上进行的操作也定义了可能的状态。
- en: 'Although it may sound completely trivial, there is one more thing we can do
    with classical bits that will turn out to be critical for how we understand quantum
    computing: we can look at them. If I look at a padlock and conclude, “Aha! That
    padlock is unlocked,” then I can now think of my brain as a particularly squishy
    kind of bit. The 0 message is stored in my brain by my thinking, “Aha! That padlock
    is unlocked,” while a 1 message would be stored by my thinking, “Ah, well, that
    padlock is locked ![](../Images/emoji-sadface.png).” In effect, by looking at
    a classical bit, I have *copied* it into my brain. We say that the act of *measuring*
    the classical bit copies that bit.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这听起来可能完全微不足道，但我们还可以用经典比特做一件事，这对我们理解量子计算将变得至关重要：我们可以观察它们。如果我观察一个锁头并得出结论，“啊哈！这个锁头是开着的，”那么我现在可以把我的大脑想象成一种特别柔软的比特。0消息通过我思考“啊哈！这个锁头是开着的”存储在我的大脑中，而1消息将通过我思考“啊，好吧，这个锁头是锁着的！”存储。实际上，通过观察一个经典比特，我已经*复制*它到我的大脑中。我们说测量经典比特的行为是复制那个比特。
- en: More generally, modern life is built around the ease with which we copy classical
    bits by looking at them. We copy classical bits with truly reckless abandon, measuring
    many billions of classical bits every second that we copy data from our video
    game consoles to our TVs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，现代生活是围绕我们通过观察来复制经典比特的便利性构建的。我们复制经典比特时毫无顾忌，每秒测量数十亿个经典比特，从我们的游戏机复制数据到我们的电视。
- en: On the other hand, if a bit is stored as a coin, then the process of measuring
    involves flipping it. Measuring doesn’t quite copy the coin, as I might get a
    different measurement result the next time I flip. If I only have one measurement
    of a coin, I can’t conclude the probability of getting heads or tails. We didn’t
    have this ambiguity with padlock bits because we knew the state of the padlocks
    was either 0 or 1\. If I measured a padlock and found it to be in the 0 state,
    I would know that it would always be in the 0 state unless I did something to
    the padlock.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果比特以硬币的形式存储，那么测量过程就涉及翻转它。测量并不完全复制硬币，因为我下一次翻转时可能会得到不同的测量结果。如果我只有一个硬币的测量结果，我就不能得出得到正面或反面的概率。我们没有在锁头比特上遇到这种歧义，因为我们知道锁头的状态要么是0要么是1。如果我测量一个锁头并发现它处于0状态，我就知道除非我对锁头做了什么，否则它将始终处于0状态。
- en: The situation isn’t precisely the same in quantum computing, as we’ll see later
    in the chapter. While measuring classical information is cheap enough that we
    complain about precisely how many billions of bits a $5 cable lets us measure,
    we have to be much more careful with how we approach quantum measurements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子计算中，情况并不完全相同，正如我们在本章后面将看到的。虽然测量经典信息足够便宜，以至于我们抱怨5美元的电缆能让我们测量多少亿比特，但我们必须对量子测量的方法更加小心。
- en: 2.2.2 Abstractions are our friend
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 抽象是我们的朋友
- en: 'Regardless of how we physically build a bit, we can (fortunately) represent
    them the same way in both math and code. For instance, Python provides the `bool`
    type (short for Boolean, in honor of the logician George Boole), which has two
    valid values: `True` and `False`. We can represent transformations on bits such
    as NOT and OR as operations acting on `bool` variables. Importantly, we can specify
    a classical operation by describing how that operation transforms each possible
    input, often called a *truth table*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何物理地构建比特，我们都可以（幸运的是）以相同的方式在数学和代码中表示它们。例如，Python提供了`bool`类型（简称布尔，以纪念逻辑学家乔治·布尔），它有两个有效值：`True`和`False`。我们可以将NOT和OR等比特变换表示为作用于`bool`变量的操作。重要的是，我们可以通过描述该操作如何变换每个可能的输入来指定一个经典操作，这通常被称为*真值表*。
- en: Definition A *truth table* is a table describing the output of a classical operation
    for every possible combination of inputs. For example, figure 2.7 shows the truth
    table for the AND operation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个*真值表*是一个描述经典运算对于每个可能的输入组合的输出的表格。例如，图2.7显示了AND运算的真值表。
- en: '![](../Images/2-7.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图2-7](../Images/2-7.png)'
- en: Figure 2.7 Truth table for the logical operation AND. If we know the entire
    truth table for a logical operation, then we know what that operation does for
    any possible input.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 逻辑运算AND的真值表。如果我们知道一个逻辑运算的整个真值表，那么我们就知道该运算对任何可能的输入会做什么。
- en: We can find the truth table for the NAND (short for NOT-AND) operation in Python
    by iterating over combinations of `True` and `False`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过迭代`True`和`False`的组合在Python中找到NAND（代表NOT-AND）运算的真值表。
- en: Listing 2.2 Using Python to print out a truth table for NAND
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 使用Python打印出NAND的真值表
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note Describing an operation as a truth table holds for more complicated operations.
    In principle, even an operation like addition between two 64-bit integers can
    be written as a truth table. This isn’t very practical, though, as a truth table
    for two 64-bit inputs would have 2^(128) ≈ × 10^(38) entries and would take 10^(40)
    bits to write. By comparison, recent estimates put the size of the entire internet
    at closer to 10^(27) bits.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：将操作描述为真值表适用于更复杂的操作。原则上，即使是两个64位整数之间的加法操作也可以写成真值表。但这并不实用，因为两个64位输入的真值表将有2^(128)
    ≈ × 10^(38)个条目，需要10^(40)位来编写。相比之下，最近的估计将整个互联网的大小接近于10^(27)位。
- en: Much of the art of classical logic and hardware design is making *circuits*
    that can provide very compact representations of classical operations rather than
    relying on potentially massive truth tables. In quantum computing, we use the
    name *unitary operators* for similar truth tables for quantum bits, which we will
    expand on as we go along.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 经典逻辑和硬件设计的大部分艺术在于制作*电路*，这些电路可以提供经典操作的非常紧凑的表示，而不是依赖于可能巨大的真值表。在量子计算中，我们使用*幺正算子*这个名字来表示量子比特的类似真值表，随着我们继续前进，我们将详细说明这一点。
- en: 'In summary:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：
- en: Classical bits are physical systems that can be in one of two different *states*.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典比特是处于两种不同*状态*之一的物理系统。
- en: Classical bits can be manipulated through *operations* to process information.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典比特可以通过*操作*来处理信息。
- en: The act of *measuring* a classical bit makes a copy of the information contained
    in the state.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量经典比特的行为会复制该状态中包含的信息。
- en: Note In the next section, we’ll use linear algebra to learn about *qubits*,
    the basic unit of information in a quantum computer. If you need a refresher on
    linear algebra, this would be a great time to take a detour to appendix C. We’ll
    refer to an analogy from this appendix throughout the book, where we’ll think
    of vectors as directions on a map. We’ll be right here when you get back!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在下一节中，我们将使用线性代数来了解*量子比特*，这是量子计算机中的基本信息单元。如果您需要线性代数的复习，现在是去附录C走一趟的好时机。我们将在整本书中引用这个附录中的类比，我们将把向量看作地图上的方向。当您回来时，我们在这里等你！
- en: '2.3 Qubits: States and operations'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 量子比特：状态和操作
- en: 'Just as classical bits are the most basic unit of information in a classical
    computer, *qubits* are the basic unit of information in a quantum computer. They
    can be physically implemented by systems that have two states, just like classical
    bits, but they behave according to the laws of quantum mechanics, which allows
    for some behaviors that classical bits are not capable of. Let’s treat qubits
    like we would any other fun new computer part: plug it in and see what happens!'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如经典比特是经典计算机中最基本的信息单元，*量子比特*是量子计算机中的基本信息单元。它们可以通过具有两种状态的系统物理实现，就像经典比特一样，但它们的行为遵循量子力学定律，这允许一些经典比特无法实现的行为。让我们像对待任何其他有趣的新计算机部件一样对待量子比特：插上它，看看会发生什么！
- en: Simulated qubits
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟量子比特
- en: For all of this book, we won’t be using actual qubits. Instead, we will use
    *classical simulations* of qubits. This lets us learn how quantum computers work
    and get started programming small instances of the kinds of problems that quantum
    computers can solve, even if we don’t yet have access to the quantum hardware
    we’d need to solve practical problems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们不会使用实际的量子比特。相反，我们将使用量子比特的*经典模拟*。这让我们能够了解量子计算机的工作原理，并开始编写量子计算机可以解决的问题类型的小实例的编程，即使我们还没有访问解决实际问题的所需量子硬件。
- en: The trouble with this approach is that simulating qubits on classical computers
    takes an exponential amount of classical resources in the number of qubits. The
    most powerful classical computing services can simulate up to about 40 qubits
    before having to simplify or reduce the types of quantum programs being run. For
    comparison, current commercial hardware maxes out at about 70 qubits at the time
    of this writing. Devices with that many qubits are extremely difficult to simulate
    with classical computers, but currently available devices are still too noisy
    to complete most useful computational tasks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的麻烦在于，在经典计算机上模拟量子比特需要指数级数量的经典资源。最强大的经典计算服务在必须简化或减少正在运行的量子程序类型之前，可以模拟大约40个量子比特。相比之下，截至写作时，当前商用硬件的最大容量约为70个量子比特。具有这么多量子比特的设备用经典计算机模拟起来非常困难，但目前可用的设备仍然太嘈杂，无法完成大多数有用的计算任务。
- en: Imagine having to write a classical program with only 40 classical bits to work
    with! While 40 bits is quite small compared to the gigabytes we are used to working
    with in classical programming, we can still do some really interesting things
    with only 40 qubits that will help us prototype what an actual quantum advantage
    might look like.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果只能用40个经典比特来编写经典程序！虽然与我们在经典编程中习惯使用的千兆字节相比，40比特相当小，但我们仍然可以用仅40个量子比特做一些非常有趣的事情，这有助于我们原型化实际量子优势可能的样子。
- en: 2.3.1 State of the qubit
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 量子位的状态
- en: To implement our QRNG, we need to work out how to describe our qubit. We have
    used locks, baseballs, and other classical systems to represent *classical* bit
    values of 0 or 1\. We can use many physical systems to act as our qubit, and *states*
    are the “values” our qubit can have.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的量子随机数生成器（QRNG），我们需要弄清楚如何描述我们的量子位。我们曾使用锁、棒球和其他经典系统来表示*经典*比特值0或1。我们可以使用许多物理系统来充当我们的量子位，而*状态*是量子位可以具有的“值”。
- en: Similar to the 0 and 1 states of classical bits, we can write labels for quantum
    states. The qubit states that are most similar to the classical 0 and 1 are |0〉
    and |1〉, as shown in figure 2.8\. These are referred to as *ket 0* and *ket 1*,
    respectively.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于经典比特的0和1状态，我们可以为量子状态编写标签。与经典0和1最相似的量子位状态是|0〉和|1〉，如图2.8所示。这些分别被称为*基0*和*基1*。
- en: '![](../Images/2-8.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8](../Images/2-8.png)'
- en: Figure 2.8 Using Dirac (bra-ket) notation for qubits, we can graphically represent
    the |0〉 and |1〉 states for qubits the same way as we represented the 0 and 1 states
    of classical bits. In particular, we’ll draw the |0〉 and |1〉 states as opposite
    points along an axis, as shown here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 使用狄拉克（括号-基）符号表示量子位，我们可以以与表示经典比特的0和1状态相同的方式图形化地表示量子位的|0〉和|1〉状态。特别是，我们将|0〉和|1〉状态绘制为轴上的相反点，如图所示。
- en: Ket?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基？
- en: 'The term *ket* comes from a kind of whimsical naming in quantum computing that
    owes its history to a particularly silly pun. As we’ll see when we look at measurements,
    there’s another kind of object called a *bra* that is written 〈0|. When we put
    a bra and a ket together, we get a pair of brackets: 〈〉.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*基*来自量子计算中的一种风趣的命名方式，其历史源于一个特别愚蠢的双关语。当我们查看测量时，还有一种称为*括号*的另一种对象，写作〈0|。当我们把括号和基放在一起时，我们得到一对括号：〈〉。
- en: The use of bras and kets to write out math for quantum mechanics is often called
    *Dirac notation* after Paul Dirac, who invented both the notation and the truly
    groan-worthy pun that we’re now stuck with. We will see more of this style of
    whimsy throughout the book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号和基表示量子力学的数学通常被称为*狄拉克符号*，以纪念保罗·狄拉克，他发明了这种符号以及我们现在不得不忍受的真正令人沮丧的双关语。在整个书中，我们将看到更多这种风格的风趣。
- en: One thing to be mindful of, though, is that a state is a convenient model used
    to predict how a qubit behaves, not an inherent property of the qubit. This distinction
    becomes especially important when we consider measurement later in the chapter—as
    we will see, we cannot directly measure the state of a qubit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的一点是，状态是一个方便的模型，用于预测量子位的行为，而不是量子位的固有属性。当我们考虑本章后面的测量时，这种区别变得尤为重要——正如我们将看到的，我们无法直接测量量子位的状态。
- en: Warning In real systems, we can never extract or perfectly learn the state of
    a qubit given a finite number of copies.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 在实际系统中，我们永远无法从有限数量的副本中提取或完美地学习量子位的状态。
- en: Don’t worry if this doesn’t all make sense yet; we’ll see plenty of examples
    as we go through the book. What’s important to keep in mind for now is that qubits
    aren’t states.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心现在这一切还没有完全理解；随着我们阅读这本书，我们会看到很多例子。现在需要记住的重要一点是，量子位不是状态。
- en: If we want to simulate how a baseball moves once it’s thrown, we might start
    by writing down its current location, how fast it’s going and in what direction,
    which way it’s spinning, and so forth. That list of numbers helps us represent
    a baseball on a piece of paper or in a computer to predict what that baseball
    will do, but we wouldn’t say that the baseball *is* that list of numbers. To get
    our simulation started, we’d have to take a baseball we’re interested in and *measure*
    where it is, how fast it’s going, and so forth.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要模拟投掷后棒球的运动，我们可能会先写下它的当前位置、它的速度和方向、它的旋转方式等等。这个数字列表帮助我们代表一张纸上的棒球或计算机中的棒球，以预测那个棒球会做什么，但我们不会说棒球*就是*那个数字列表。为了开始我们的模拟，我们必须拿一个我们感兴趣的棒球，并*测量*它的位置、它的速度等等。
- en: We say that the full set of data we need to simulate the behavior of a baseball
    accurately is the *state* of that baseball. Similarly, the state of a qubit is
    the full set of data we need to simulate it and to predict what results we’ll
    get when we measure it. Just as we need to update the state of a baseball in our
    simulator as it goes along, we’ll update the state of a qubit when we apply operations
    to it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说，为了准确模拟棒球的行为，我们需要的数据的完整集合是那个棒球的*状态*。同样，量子比特的状态是我们模拟它和预测当我们测量它时会得到什么结果的完整数据集合。正如我们需要在模拟过程中更新棒球的模拟状态一样，当我们对量子比特应用操作时，我们也会更新量子比特的状态。
- en: Tip One way to remember this subtle distinction is that a qubit *is described
    by a* state, but it is not true that a qubit *is a* state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 一种记住这种微妙区别的方法是，量子比特*被一个*状态所描述，但量子比特*不是一个*状态。
- en: Where things get a little more subtle is that while we can measure a baseball
    without doing anything to it other than copying some classical information, as
    we’ll see throughout the rest of the book, we can’t perfectly copy the quantum
    information stored in a qubit—when we measure a qubit, we have an effect on its
    state. This can be confusing, as we record the full state of a qubit when we simulate
    it, such that we can look at the memory in our simulator whenever we want. Nothing
    we can do with actual qubits lets us look at their state, so if we “cheat” by
    looking at the memory of a simulator, we won’t be able to run our program on real
    hardware.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情变得稍微微妙一些时，虽然我们可以通过复制一些经典信息而不对棒球做任何其他事情来测量棒球，但正如我们将在本书的其余部分看到的那样，我们无法完美地复制存储在量子比特中的量子信息——当我们测量量子比特时，我们会对它的状态产生影响。这可能会令人困惑，因为我们记录了量子比特的完整状态，以便我们可以在模拟器中随时查看内存。我们用实际量子比特能做的任何事情都无法让我们查看它们的状态，所以如果我们“作弊”查看模拟器的内存，我们就无法在真实硬件上运行我们的程序。
- en: Put differently, while looking at states directly can be useful for debugging
    classical simulators as we build them, we have to make sure we are only writing
    algorithms based on information we could plausibly learn from real hardware.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，虽然直接查看状态在构建过程中对调试经典模拟器可能很有用，但我们必须确保我们只编写基于从真实硬件中可能学到的信息编写的算法。
- en: Cheating with our eyes shut
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 眼睛一闭就作弊
- en: When we are using a quantum simulator, the simulator must store the state of
    our qubits internally—this is why simulating quantum systems can be so difficult.
    Every qubit could, in principle, be correlated with every other qubit, so we need
    exponential resources in general to write down the state in our simulator (we’ll
    see more about this in chapter 4).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用量子模拟器时，模拟器必须内部存储我们的量子比特的状态——这就是为什么模拟量子系统如此困难的原因。原则上，每个量子比特都可能与其他每个量子比特相关联，因此我们需要指数级资源来在我们的模拟器中写下状态（我们将在第
    4 章中了解更多关于这一点）。
- en: If we “cheat” by looking directly at the state stored by a simulator, then we
    can only ever run our program on a simulator, not on actual hardware. We’ll see
    in later chapters how to cheat more safely by using assertions and making cheating
    unobservable ![](../Images/emoji-devil.png).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过直接查看模拟器存储的状态来“作弊”，那么我们只能在模拟器上运行我们的程序，而不能在实际硬件上运行。我们将在后面的章节中看到如何通过使用断言和使作弊不可见来更安全地“作弊”！[](../Images/emoji-devil.png)。
- en: 2.3.2 The game of operations
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 操作游戏
- en: 'Now that we have names for these states, let’s show how to represent the information
    they contain. With classical bits, we can record the information contained in
    the bit at any time as simply a value on a line: 0 or 1\. This works because the
    only operations we can do consist of flips (or 180° rotations) on this line. Quantum
    mechanics allows us to apply more kinds of operations to qubits, including rotations
    by less than 180°. That is, qubits differ from classical bits in what operations
    we can do with them.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为这些状态起了名字，让我们来看看如何表示它们所包含的信息。对于经典比特，我们可以简单地记录比特在任何时间包含的信息，即一条线上的值：0 或
    1。这是因为我们能够进行的唯一操作就是在这条线上进行翻转（或 180° 旋转）。量子力学允许我们对量子比特应用更多种类的操作，包括小于 180° 的旋转。也就是说，量子比特与经典比特的不同之处在于我们可以对它们进行哪些操作。
- en: Note While operations on classical bits are logical operations that can be made
    by combining NOT, AND, and OR in different ways, quantum operations consist of
    *rotations*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 当前的操作是可以通过以不同的方式组合 NOT、AND 和 OR 来进行的逻辑操作，而量子操作则由*旋转*组成。
- en: For instance, if we want to turn the state of a qubit from |0〉 to |1〉 and vice
    versa, the quantum analogue of a NOT operation, we rotate the qubit clockwise
    by 180°, as shown in figure 2.9.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将量子比特的状态从 |0〉 转换为 |1〉，反之亦然，即 NOT 操作的量子对应物，我们顺时针旋转量子比特 180°，如图 2.9 所示。
- en: '![](../Images/2-9.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-9.png)'
- en: Figure 2.9 A visualization of the quantum equivalent of a NOT operation operating
    on a qubit in the |0〉 state, leaving the qubit in the |1〉 state. We can think
    of this operation as a rotation of 180° about the center of the line connecting
    the |0〉 and |1〉 states.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 NOT 操作在 |0〉 状态的量子比特上操作的视觉表示，将量子比特留在 |1〉 状态。我们可以将这个操作视为围绕连接 |0〉 和 |1〉 状态的线中心的
    180° 旋转。
- en: We have seen how rotation by 180° is the analogue to a NOT gate, but what other
    rotations can we do?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 180° 旋转是 NOT 门的对应物，但我们还能进行哪些其他旋转？
- en: Reversibility
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可逆性
- en: When we rotate a quantum state, we can always get back to the same state we
    started in by rotating backward. This property, known as *reversibility*, turns
    out to be fundamental to quantum computing. With the exception of measurement,
    which we’ll learn more about later in this chapter, all quantum operations must
    be reversible.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们旋转量子状态时，我们总是可以通过反向旋转回到我们开始的状态。这种被称为 *可逆性* 的特性，最终证明是量子计算的基础。除了测量（我们将在本章后面更多地了解测量）之外，所有量子操作都必须是可逆的。
- en: Not all of the classical operations we’re used to are reversible, though. Operations
    like AND and OR aren’t reversible as they are typically written, so they cannot
    be implemented as quantum operations without a little more work. We’ll see how
    to do this in chapter 8 when we introduce the “uncompute” trick for expressing
    other classical operations as rotations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们习惯的所有经典操作并非都是可逆的。像 AND 和 OR 这样的操作在通常的写法中是不可逆的，因此没有一点额外的努力就无法作为量子操作实现。当我们介绍将其他经典操作表示为旋转的“反计算”技巧时，我们将在第
    8 章中看到如何做到这一点。
- en: On the other hand, classical operations like XOR can easily be made reversible,
    so we can write them out as rotations using a quantum operation called *controlled
    NOT*, as we will see in chapter 8.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，像 XOR 这样的经典操作很容易变得可逆，因此我们可以用称为 *controlled NOT* 的量子操作来表示它们作为旋转，正如我们在第 8
    章中将要看到的。
- en: If we rotate a qubit in the |0〉 state clockwise by 90° instead of 180°, we get
    a quantum operation that we can think of as the square root of a NOT operation,
    as shown in figure 2.10.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将处于 |0〉 状态的量子比特顺时针旋转 90° 而不是 180°，我们得到一个量子操作，我们可以将其视为 NOT 操作的平方根，如图 2.10
    所示。
- en: '![](../Images/2-10.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-10.png)'
- en: Figure 2.10 We can also rotate a state by less than 180 degrees. Doing so, we
    get a state that is neither |0〉 nor |1〉 but that lies halfway around the circle
    between them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 我们也可以旋转状态小于 180 度。这样做，我们得到一个既不是 |0〉 也不是 |1〉，但位于它们之间圆周中点的状态。
- en: Just as we earlier defined the square root √*x* of a number *x* as being a number
    *y* such that *y*² = *x*, we can define the square root of a quantum operation.
    If we apply a 90° rotation twice, we get back the NOT operation, so we can think
    of the 90° rotation as the square root of NOT.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前定义一个数的平方根 √*x* 为一个数 *y*，使得 *y*² = *x*，我们可以定义量子操作的平方根。如果我们应用两次 90° 旋转，我们就会得到
    NOT 操作，因此我们可以将 90° 旋转视为 NOT 的平方根。
- en: Halves and halve-nots
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 半数和半非数
- en: Every field has its stumbling blocks. Ask a graphics programmer whether positive
    *y* means “up” or “down,” for instance. In quantum computing, the rich history
    and interdisciplinary nature of the field sometimes come across as a double-edged
    sword in that each different way of thinking about quantum computing comes with
    conventions and notations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每个领域都有其绊脚石。例如，问一个图形程序员正 *y* 是否意味着“向上”或“向下”。在量子计算中，该领域的丰富历史和跨学科性质有时像一把双刃剑，因为对量子计算的不同思考方式都伴随着约定和符号。
- en: One way this manifests is that it’s really easy to make mistakes about where
    to put factors of two. In this book, we’ve chosen to follow the convention used
    by Microsoft’s Q# language.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表现方式之一是，我们很容易弄错将因子 2 放在何处。在这本书中，我们选择了遵循微软 Q# 语言使用的约定。
- en: We now have a new state that is neither |0〉 nor |1〉, but an equal combination
    of them both. In precisely the same sense that we can describe “northeast” by
    adding together the directions “north” and “east,” we can write this new state
    as shown in figure 2.11.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新的状态，它既不是 |0〉 也不是 |1〉，而是它们两者的等量组合。在完全相同的意义上，我们可以通过将“北”和“东”两个方向相加来描述“东北”，我们可以将这个新状态写成如图
    2.11 所示的形式。
- en: '![](../Images/2-11.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-11.png)'
- en: Figure 2.11 We can write the state we get when we rotate by 90° by thinking
    of the |0〉 and |1〉 states as *directions*. Doing so, and using some trigonometry,
    we get that rotating the |0〉 state by 90° gives us a new state, (|0〉 + |1〉) /
    √2. For more details on how to write out the math for this kind of rotation, check
    out appendix B for a refresher on linear algebra.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 我们可以通过将|0〉和|1〉状态视为*方向*来写出当我们旋转90°时得到的状态。这样做，并使用一些三角学知识，我们可以得到旋转|0〉状态90°会得到一个新的状态，即(|0〉
    + |1〉) / √2。关于如何写出这类旋转的数学表达式的更多细节，请查看附录B，以复习线性代数。
- en: '|+〉, |−〉, and superposition'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|+〉, |−〉和叠加'
- en: We call the state that is an equal combination of |0〉 and |1〉 the |+〉 = (|0〉
    + |1〉) / √2 state (due to the sign between the terms). We say that the |+〉 state
    is a *superposition* of |0〉 and |1〉.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称|0〉和|1〉等量组合的状态为|+〉 = (|0〉 + |1〉) / √2状态（由于项之间的符号）。我们说|+〉状态是|0〉和|1〉的*叠加*。
- en: If the rotation is by –90° (counterclockwise), then we call the resulting state
    |−〉 = (|0〉 − |1〉) / √2. Try writing out these rotations using –90° to see that
    we get |−〉!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果旋转是逆时针90°，那么我们称得到的状态为|−〉 = (|0〉 − |1〉) / √2。尝试使用-90°写出这些旋转，看看我们是否得到|−〉！
- en: 'The state of a qubit can be represented as a point on a circle that has two
    labeled states on the poles: |0〉 and |1〉. More generally, we will picture rotations
    using arbitrary angles *θ* between qubit states, as shown in figure 2.12.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特的状态可以表示为一个圆上的点，该圆有两个标记的状态在两极：|0〉和|1〉。更普遍地说，我们将使用任意角度*θ*在量子比特状态之间进行旋转，如图2.12所示。
- en: '![](../Images/2-12.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图2-12](../Images/2-12.png)'
- en: Figure 2.12 If we rotate the |0〉 state by an angle other than 90° or 180°, the
    resulting state can be represented as a point on a circle that has |0〉 and |1〉
    as its top and bottom poles. This gives us a way to visualize the possible states
    that a single qubit can be in.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 如果我们将|0〉状态旋转的角度不是90°或180°，那么得到的状态可以表示为一个圆上的点，该圆有两个标记的状态在两极：|0〉和|1〉。这为我们提供了一种可视化单个量子比特可能处于的状态的方法。
- en: Mathematically, we can write the state of any point on the circle that represents
    our qubit as cos(*θ* / 2) |0〉 + sin(*θ* / 2) |1〉, where |0〉 and |1〉 are different
    ways of writing the vectors [[1], [0]] and [[0], [1]], respectively.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，我们可以将代表我们的量子比特的圆上的任何点的状态写成cos(*θ* / 2) |0〉 + sin(*θ* / 2) |1〉，其中|0〉和|1〉是分别表示向量[[1],
    [0]]和[[0], [1]]的不同方式。
- en: Tip One way to think of ket notation is that it gives *names* to vectors that
    we commonly use. When we write |0〉 = [[1], [0]], we’re saying that [[1], [0]]
    is important enough that we name it after 0\. Similarly, when we write |+〉 = [[1],
    [1]] / √2, we give a name to the vector representation of a state that we will
    use throughout the book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 一种思考基矢量表示法的方式是它为常用的向量赋予*名称*。当我们写|0〉 = [[1], [0]]时，我们是在说[[1], [0]]足够重要，以至于我们用0来命名它。同样，当我们写|+〉
    = [[1], [1]] / √2时，我们为将贯穿本书的状态的向量表示赋予了一个名称。
- en: Another way to say this is that a qubit is generally the *linear combination*
    of the vectors of |0〉 and |1〉 with coefficients that describe the angle that |0〉
    would have to be rotated to get to the state. To be useful for programming, we
    can write how rotating a state affects each of the |0〉 and |1〉 states, as shown
    in figure 2.13.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是，一个量子比特通常是|0〉和|1〉向量的*线性组合*，其系数描述了|0〉需要旋转到该状态的角度。为了在编程中更有用，我们可以写出旋转状态如何影响|0〉和|1〉状态，如图2.13所示。
- en: '![](../Images/2-13.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图2-13](../Images/2-13.png)'
- en: Figure 2.13 Using linear algebra, we can describe the state of a single qubit
    as a two-element vector. In this equation, we show how that way of thinking about
    qubit states relates to our earlier use of Dirac (bra-ket) notation. In particular,
    we show the final state after rotating the |0〉 state by an arbitrary angle *θ*
    using both vector and Dirac notations; both will be helpful at different points
    in our quantum journey.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 使用线性代数，我们可以将单个量子比特的状态描述为一个二维向量。在这个方程中，我们展示了这种关于量子比特状态的想法如何与我们之前使用的狄拉克（内积-外积）表示法相关联。特别是，我们展示了使用向量表示法和狄拉克表示法旋转|0〉状态任意角度*θ*后的最终状态；这两种方法将在我们的量子之旅的不同阶段都有所帮助。
- en: Tip This is precisely the same as when we used a basis of vectors earlier to
    represent a linear function as a matrix.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 这与我们之前使用向量基表示线性函数为矩阵的情况完全相同。
- en: We’ll learn about other quantum operations in this book, but these are the easiest
    to visualize as rotations. Table 2.2 summarizes the states we have learned to
    create from these rotations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中学习其他量子操作，但这些操作最容易通过旋转来可视化。表2.2总结了我们可以从这些旋转中创建的状态。
- en: Table 2.2 State labels, expansions in Dirac notation, and representations as
    vectors
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 状态标签、狄拉克表示法的展开和作为向量的表示
- en: '| State label | Dirac notation | Vector representation |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 状态标签 | 狄拉克表示法 | 向量表示 |'
- en: '| &#124;0〉 | &#124;0〉 | [[1], [0]] |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| &#124;0〉 | &#124;0〉 | [[1], [0]] |'
- en: '| &#124;1〉 | &#124;1〉 | [[0], [1]] |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| &#124;1〉 | &#124;1〉 | [[0], [1]] |'
- en: '| &#124;+〉 | (&#124;0〉 + &#124;1〉) / √2 | [[1 / √2], [1 / √2]] |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| &#124;+〉 | (&#124;0〉 + &#124;1〉) / √2 | [[1 / √2], [1 / √2]] |'
- en: '| &#124;−〉 | (&#124;0〉 − &#124;1〉) / √2 | [[1 / √2], [–1 / √2]] |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| &#124;−〉 | (&#124;0〉 − &#124;1〉) / √2 | [[1 / √2], [–1 / √2]] |'
- en: A mouthful of math
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一大堆数学
- en: At first glance, something like |+〉 = (|0〉 + |1〉) / √2 would be terrible to
    have to say out loud, making it useless in conversation. In practice, however,
    quantum programmers often take some shortcuts when speaking out loud or sketching
    things on a whiteboard.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，像 |+〉 = (|0〉 + |1〉) / √2 这样的东西大声说出来会很糟糕，使得它在对话中变得毫无用处。然而，在实践中，量子程序员在口头表达或在白板上草图时通常会采取一些捷径。
- en: For instance, the “√2” part always has to be there, since vectors representing
    quantum states must always be length one; that means we can sometimes be a little
    casual and write “|+〉 = |0〉 + |1〉,” relying on our audience to remember to divide
    by √2. If we’re giving a talk or discussing quantum computing over some tea, we
    may say, “Ket plus is ket 0 plus ket 1,” but the reuse of the word *plus* gets
    a little confusing without bras and kets to help. To emphasize verbally that addition
    allows us to represent superposition, we might say, “The plus state is an equal
    superposition of zero and one,” instead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，“√2”部分总是必须存在的，因为表示量子状态的向量必须总是长度为 1；这意味着我们有时可以稍微随意一些，写出 “|+〉 = |0〉 + |1〉”，并依赖我们的听众记住除以
    √2。如果我们正在做演讲或在喝茶时讨论量子计算，我们可能会说，“ket plus 是 ket 0 加 ket 1”，但没有 bra 和 ket 的帮助，这个词
    *plus* 的重复使用会有些令人困惑。为了通过口头强调加法可以让我们表示叠加，我们可能会说，“plus 状态是 0 和 1 的等价叠加”，而不是。
- en: 2.3.3 Measuring qubits
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 测量量子比特
- en: When we want to retrieve the information stored in a qubit, we need to measure
    the qubit. Ideally, we would like a measurement device that lets us directly read
    out all the information about the state at once. As it turns out, this is not
    possible by the laws of quantum mechanics, as we’ll see in chapters 3 and 4\.
    That said, measurement *can* allow us to learn information about the state relative
    to particular directions in the system. For instance, if we have a qubit in the
    |0〉 state, and we look to see if it is in the |0〉 state, we’ll always get that
    it is. On the other hand, if we have a qubit in the |+〉 state, and we look to
    see if it is in the |0〉 state, we’ll get a 0 outcome with 50% probability. As
    shown in figure 2.14, this is because the |+〉 state overlaps equally with the
    |0〉 and |1〉 states, such that we’ll get both outcomes with the same probability.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要检索存储在量子比特中的信息时，我们需要测量量子比特。理想情况下，我们希望有一个测量设备能够让我们一次性直接读取关于状态的所有信息。然而，根据量子力学的定律，这不可能，正如我们在第
    3 章和第 4 章中将会看到的。尽管如此，测量**可以**让我们了解相对于系统特定方向的状态信息。例如，如果我们有一个处于 |0〉 状态的量子比特，并且我们检查它是否处于
    |0〉 状态，我们总是会得到它是的答案。另一方面，如果我们有一个处于 |+〉 状态的量子比特，并且我们检查它是否处于 |0〉 状态，我们会有 50% 的概率得到
    0 的结果。如图 2.14 所示，这是因为 |+〉 状态与 |0〉 和 |1〉 状态重叠相同，这样我们就会以相同的概率得到两个结果。
- en: '![](../Images/2-14.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 2-14](../Images/2-14.png)'
- en: Figure 2.14 The |+〉 state overlaps equally with both |0〉 and |1〉 because the
    “shadow” it casts is exactly in the middle. Thus, when we look at our qubit to
    see if it's in the |0〉 or |1〉 state, we'll get both results with equal probability
    if our qubit started in the |+〉 state. We can think of the shadow the |+〉 state
    casts on the line between the |0〉 and |1〉 states as a kind of coin.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 |+〉 状态与 |0〉 和 |1〉 状态重叠相同，因为其“影子”正好位于中间。因此，当我们观察我们的量子比特以确定其处于 |0〉 或 |1〉
    状态时，如果我们的量子比特最初处于 |+〉 状态，我们将以相同的概率获得两个结果。我们可以将 |+〉 状态在 |0〉 和 |1〉 状态之间的“影子”视为一种硬币。
- en: Tip Measurement outcomes of qubits are *always* classical bit values! Put differently,
    whether we measure a classical bit or a qubit, our result is always a classical
    bit.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士量子比特的测量结果**总是**是经典比特值！换句话说，无论我们测量的是经典比特还是量子比特，我们的结果总是经典比特。
- en: 'Most of the time, we will choose to measure whether we have a |0〉 or a |1〉;
    that is, we’ll want to measure along the line between the |0〉 and |1〉. For convenience,
    we give this axis a name: the *Z*-axis. We can visually represent this by *projecting*
    our state vector onto the *Z*-axis (see figure 2.15) using the inner product.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们会选择测量我们是否有|0〉或|1〉；也就是说，我们希望沿着|0〉和|1〉之间的线进行测量。为了方便起见，我们给这个轴起了一个名字：*Z*-轴。我们可以通过使用内积将我们的状态向量*投影*到*Z*-轴上（见图2.15）来直观地表示这一点。
- en: '![](../Images/2-15.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图2-15](../Images/2-15.png)'
- en: Figure 2.15 A visualization of a quantum measurement, which can be thought of
    as projecting the state in a particular direction. For example, if a qubit is
    rotated such that its state is close to the |1〉 state, then measuring it is more
    likely to return 1 than 0.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15展示了量子测量的可视化，这可以被视为将状态投影到特定方向。例如，如果一个量子比特被旋转，使其状态接近|1〉状态，那么测量它更有可能返回1而不是0。
- en: Tip If you need a refresher on inner products, please check out appendix B.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您需要复习内积，请参阅附录B。
- en: Think of shining a flashlight from where we draw the state of a qubit back onto
    the *Z*-axis; the probability of getting a 0 or 1 result is determined by the
    shadow the state leaves on the *Z*-axis.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，从我们绘制量子比特状态的点向*Z*-轴照射手电筒；得到0或1结果的可能性由状态在*Z*-轴上留下的影子决定。
- en: 'Deep dive: Why isn’t measurement linear?'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：为什么测量不是线性的？
- en: After having made such a big deal of the linearity of quantum mechanics, it
    may seem odd that we immediately introduce measurement as being nonlinear. If
    we’re allowed nonlinear operations like measurement, can we also implement other
    nonlinear operations like cloning qubits?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在大谈量子力学的线性之后，我们立即引入测量作为非线性可能看起来有些奇怪。如果我们允许非线性操作如测量，我们也能实现其他非线性操作，如克隆量子比特吗？
- en: The short version is that while everyone agrees on the math behind measurement,
    there’s still a lot of philosophical discussion about the best way to understand
    why quantum measurement acts the way it does. These discussions fall under the
    name of *quantum foundations* and attempt to do more than simply understand what
    quantum mechanics is and what it predicts by also understanding *why*. For the
    most part, foundations explore different ways to *interpret* quantum mechanics.
    In the same way that we can understand classical probability by considering counterintuitive
    thought experiments such as game show strategies or how casinos can win even from
    games that seem to lose money, quantum foundations develops new interpretations
    through small thought experiments that probe different aspects of quantum mechanics.
    Fortunately, some of the results from quantum foundations can help us make sense
    of measurement.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，虽然每个人都同意测量背后的数学，但关于如何最好地理解量子测量为何如此运作的哲学讨论仍然很多。这些讨论属于*量子基础*的范畴，并试图通过理解*为什么*来做到更多，而不仅仅是理解量子力学是什么以及它预测了什么。在理解经典概率时，我们可以通过考虑诸如游戏节目策略或赌场如何从看似会输钱的游戏中赢钱这样的反直觉思维实验，量子基础通过进行小型的思维实验来探索量子力学的不同方面，从而发展新的解释。幸运的是，量子基础的一些结果可以帮助我们理解测量。
- en: In particular, one critical observation is that we can always make quantum measurements
    linear again by including the state of the measurement apparatus in our description;
    we’ll see some of the mathematical tools needed to do so in chapters 4 and 6\.
    When taken to its extreme, this observation leads to interpretations such as the
    *many-worlds interpretation*. The many-worlds interpretation solves the interpretation
    of measurement by insisting that we only consider states that include measurement
    devices, such that the apparent nonlinearity of measurement doesn’t really exist.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其值得注意的是，我们可以通过将测量装置的状态包含在我们的描述中来使量子测量线性化；我们将在第4章和第6章中看到实现这一目标所需的数学工具。当这一观察被推向极致时，它会导致诸如*多世界解释*这样的解释。多世界解释通过坚持只考虑包含测量设备的状态来解决测量的解释问题，这样测量的明显非线性实际上并不存在。
- en: At the other extreme, we can interpret measurement by noting that the nonlinearity
    in quantum measurement is precisely the same as in a branch of statistics known
    as Bayesian inference. Thus, quantum mechanics only appears nonlinear when we
    forget to include that an agent is performing the measurement and learns from
    each result. This observation leads to thinking of quantum mechanics not as a
    description of the world but as a description of what we know about the world.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个极端，我们可以通过注意到量子测量中的非线性与统计学中一个称为贝叶斯推理的分支中的非线性完全相同来解释测量。因此，量子力学只有在我们忘记包括一个代理在进行测量并从每个结果中学习时才显得非线性。这一观察导致我们将量子力学视为对世界的描述，而不是对我们所了解的世界进行描述。
- en: Although these two kinds of interpretations disagree at a philosophical level,
    both offer different ways of resolving how a linear theory such as quantum mechanics
    can sometimes appear to be nonlinear. Regardless of which interpretation helps
    you understand the interaction between measurement and the rest of quantum mechanics,
    you can take solace that the measurement results are always described by the same
    math and simulations. Indeed, relying on simulations (sometimes sarcastically
    called the “shut up and calculate” interpretation) is the oldest and most celebrated
    of all interpretations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两种解释在哲学层面上存在分歧，但它们都提供了不同的方法来解决线性理论如量子力学有时看似非线性的问题。无论哪种解释能帮助你理解测量与量子力学其他部分之间的相互作用，你都可以安心，因为测量结果总是由相同的数学和模拟来描述。实际上，依赖于模拟（有时被讽刺地称为“闭嘴计算”解释）是所有解释中最古老且最被推崇的。
- en: The squared length of each projection *represents* the probability that the
    state we are measuring will be found along that direction. If we have a qubit
    in the |0〉 state and try to measure it along the direction of the |1〉 state, we
    will get a probability of zero because the states are opposite each other when
    we draw them on a circle. Thinking in terms of pictures, the |0〉 state has no
    projection onto the |1〉 state—in the sense of figure 2.15, |0〉 doesn’t leave a
    shadow on |1〉.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个投影的平方长度*代表*我们测量到的状态将沿着该方向被找到的概率。如果我们有一个处于|0〉状态的量子比特并尝试沿着|1〉状态的方向测量它，我们将得到概率为零，因为当我们把它们画在圆上时，状态是相反的。从图像的角度思考，|0〉状态在|1〉状态上没有投影——在图2.15的意义上，|0〉没有在|1〉上留下阴影。
- en: Tip If something happens with probability 1, then that event *always* occurs.
    If something happens with probability 0, then that event is *impossible*. For
    example, the probability that a typical six-sided die rolls a 7 is zero since
    that roll is impossible. Similarly, if a qubit is in the |0〉 state, getting a
    1 result from a *Z*-axis measurement is impossible since |0〉 has no projection
    onto |1〉.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果某事发生的概率为1，那么该事件*总是*会发生。如果某事发生的概率为0，那么该事件是*不可能*的。例如，一个典型的六面骰子掷出7的概率为零，因为这种情况是不可能发生的。同样，如果一个量子比特处于|0〉状态，从*Z*轴测量得到1的结果是不可能的，因为|0〉没有在|1〉上的投影。
- en: If we have a |0〉 and try to measure it along the |0〉 direction, however, we
    will get a probability of 1 because the states are parallel (and of length 1 by
    definition). Let’s walk through measuring a state that is neither parallel nor
    perpendicular.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们有一个|0〉并尝试沿着|0〉方向测量它，我们将得到概率为1，因为状态是平行的（并且根据定义长度为1）。让我们来分析一个既不平行也不垂直的状态的测量。
- en: Example
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: Say we have a qubit in state (|0〉 + |1〉) / √2 (the same as |+〉 from table 2.1),
    and we want to measure it or project it along the *Z*-axis. We can then find the
    probability that the classical result will be a 1 by projecting |+〉 onto |1〉.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个处于状态(|0〉 + |1〉) / √2（与表2.1中的|+〉相同）的量子比特，我们想要测量它或沿着*Z*轴投影它。然后我们可以通过将|+〉投影到|1〉上来找到经典结果为1的概率。
- en: We can find the projection of one state onto another by using the *inner product*
    between their vector representations. In this case, we write the inner product
    of |+〉 and |1〉 as 〈1 | +〉, where 〈1| is the transpose of |1〉 and where butting
    the two bars against each other indicates taking the inner product. Later, we’ll
    see that 〈1| is the conjugate transpose of |1〉 and is referred to as a “bra.”
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用它们向量表示之间的*内积*来找到一个状态到另一个状态的投影。在这种情况下，我们写出|+〉和|1〉的内积为〈1 | +〉，其中〈1|是|1〉的转置，并且将两个竖线并排放置表示取内积。稍后，我们将看到〈1|是|1〉的共轭转置，被称为“bra”。
- en: 'We can write this out as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样写出：
- en: '![](../Images/2-unnumb.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-unnumb.png)'
- en: To turn this projection into a probability, we square it, getting that the probability
    of observing a 1 outcome when we prepare a |+〉 state is 1 / 2.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个投影转换为概率，我们将其平方，得到当我们制备 |+〉 状态时观察到 1 的结果的概率是 1/2。
- en: We often project onto the *Z*-axis because it is convenient in many real experiments,
    but we can also measure along the *X*-axis to see if we have a |+〉 or a |−〉 state.
    Measuring along the *X*-axis, we get |+〉 with certainty and never get |−〉, as
    shown in figure 2.16.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常投影到 *Z*-轴，因为它在许多实际实验中很方便，但我们也可以沿 *X*-轴测量，以查看我们是否有 |+〉 或 |−〉 状态。沿 *X*-轴测量，我们肯定得到
    |+〉，永远不会得到 |−〉，如图 2.16 所示。
- en: '![](../Images/2-16.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 2-16](../Images/2-16.png)'
- en: Figure 2.16 Measuring |+〉 along the *X*-axis always results in |+〉. To see this,
    note that the “shadow” left by the |+〉 state on the *X*-axis (that is, the line
    between the |−〉 and |+〉 states) is precisely the |+〉 state itself.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 沿 *X*-轴测量 |+〉 总是得到 |+〉。为了理解这一点，请注意 |+〉 状态在 *X*-轴上留下的“阴影”（即 |−〉 和 |+〉
    状态之间的线）正是 |+〉 状态本身。
- en: Note We can get a fully certain measurement outcome *only* because we know the
    “right” direction to measure ahead of time in this case—if we are simply handed
    a state with no information about what the “right” measurement direction is, we
    cannot predict any measurement outcome perfectly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们之所以能够得到一个完全确定的测量结果，仅仅是因为我们事先知道了“正确的”测量方向；如果我们只是被 handed 一个没有任何关于“正确的”测量方向的信息的状态，我们就无法完美地预测任何测量结果。
- en: '2.3.4 Generalizing measurement: Basis independence'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 测量泛化：基独立
- en: Sometimes we may not know how our qubit was prepared, so we do not know how
    to measure the bits properly. More generally, any pair of states that don’t overlap
    (are opposite poles) defines a measurement the same way. The actual outcome of
    a measurement is a classical bit value that indicates which pole the state is
    aligned with when we perform the measurement.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能不知道我们的量子比特是如何制备的，因此我们不知道如何正确地测量比特。更普遍地说，任何不重叠（即相对极点）的状态对都定义了相同的测量。测量的实际结果是一个经典比特值，它指示我们在进行测量时状态与哪个极点对齐。
- en: Even more general measurements
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛的测量
- en: Quantum mechanics allows for much more general kinds of measurements—we’ll see
    a few of these as we go along, but mostly we focus in this book on the case of
    checking between two opposite poles. This choice is a pretty convenient way of
    controlling most quantum devices and can be used in almost any of the commercial
    platforms for quantum computing that are currently available.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 量子力学允许进行更多种类的测量——随着我们的深入，我们将看到其中的一些，但本书主要关注的是检查两个相反极点的情况。这种选择是控制大多数量子设备的一种相当方便的方式，并且可以用于目前几乎所有可用的商业量子计算平台。
- en: Mathematically, we use notation like 〈measurement | state〉 to represent measuring
    a qubit. The left component, 〈measurement|, is called a *bra*, and we have already
    seen the *ket* part on the right. Together, they are called a *braket*!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，我们使用像 〈measurement | state〉 这样的符号来表示测量一个量子比特。左边的部分，〈measurement|，被称为 *bra*，我们已经看到了右边的
    *ket* 部分。它们合在一起被称为 *braket*！
- en: 'Bras are very similar to kets, except that to switch from one to the other,
    we have to take the transpose (turn rows to columns and vice versa) of the bra
    or ket we have:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Bra 与 ket 非常相似，但要从其中一个切换到另一个，我们必须取 bra 或 ket 的转置（将行转换为列，反之亦然）：
- en: '![](../Images/equation_2-1.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![方程 2-1](../Images/equation_2-1.png)'
- en: Another way to think of this is that taking the transpose turns column vectors
    (kets) into row vectors (bras).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考方式是，取转置将列向量（ket）转换为行向量（bra）。
- en: Note Since we’re only working with real numbers for now, we won’t need to do
    anything else to go between kets and bras. But when we work with complex numbers
    in the next chapter, we’ll need the complex conjugate as well.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于我们现在只处理实数，我们不需要在 ket 和 bra 之间做任何其他事情。但当我们下一章处理复数时，我们还需要复共轭。
- en: 'Bras let us write down measurements. But to see what measurements actually
    *do*, we need one more thing at our disposal: a rule for how to use a bra and
    a ket together to get the *probability* of seeing that measurement result. In
    quantum mechanics, measurement probabilities are found by looking at the length
    of the projection or shadow that the ket for a state leaves on a bra for a measurement.
    We know from experience that we can find projections and lengths using inner products.
    In Dirac notation, the inner product of a bra and a ket is written as 〈measurement
    | state〉, giving us just the rule we need.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 夸克让我们可以写下测量。但要看到测量实际上*做了什么*，我们需要更多一样东西：一个规则，用来如何将一个*态*的克和另一个测量的克结合使用，以得到看到该测量结果的*概率*。在量子力学中，测量概率是通过观察态的克在测量的克上留下的投影或阴影的长度来找到的。我们从经验中知道，我们可以使用内积来找到投影和长度。在狄拉克符号中，一个克和一个态的内积写作
    〈测量 | 态〉，这正好是我们需要的规则。
- en: For example, if we have prepared a state |+〉 and we want to know the probability
    that we observe a 1 when we measure in the *z* -basis, then projecting as shown
    in figure 2.15, we can find the length we need. The projection of |+〉 onto 〈1|
    tells us that we see a 1 outcome with probability Pr(1|+) = |〈1|+〉|² = |〈1|0〉
    + 〈1|1〉|² / 2 = |0 + 1|² / 2 = 1 / 2. Thus, 50% of the time, we’ll get a 1 outcome.
    The other 50% of the time, we’ll get a 0 outcome.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们准备了一个|+〉态，并且想知道当我们在这个*z*基中进行测量时观察到1的概率，那么按照图2.15所示进行投影，我们可以找到所需的长度。|+〉在〈1|上的投影告诉我们，我们以概率Pr(1|+)
    = |〈1|+〉|² = |〈1|0〉 + 〈1|1〉|² / 2 = |0 + 1|² / 2 = 1 / 2看到1的结果。因此，50%的时间我们会得到1的结果。其他50%的时间，我们会得到0的结果。
- en: Born’s rule
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 玻恩规则
- en: If we have a quantum state |state〉 and we perform a measurement along the 〈measurement|
    direction, we can write the probability that we will observe *measurement* as
    our result as
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个量子态|state〉并且沿着〈测量|方向进行测量，我们可以写出我们观察到*测量*作为结果的概率为
- en: Pr(measurement|state) = |〈measurement | state〉|²
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Pr(测量|态) = |〈测量 | 态〉|²
- en: In other words, the probability is the square of the magnitude of the inner
    product of the measurement bra and the state ket.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，概率是测量克和态克的内积的模长的平方。
- en: This expression is called *Born’s rule*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式被称为*玻恩规则*。
- en: In table 2.3, we’ve listed several other examples of using Born’s rule to predict
    what classical bits we will get when we measure qubits.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在表2.3中，我们列出了使用玻恩规则预测当我们测量量子比特时会得到哪些经典比特的几个其他例子。
- en: Table 2.3 Examples of using Born’s rule to find measurement probabilities
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3 使用玻恩规则寻找测量概率的例子
- en: '| If we prepare... | ...and we measure... | ...then we see that outcome with
    this probability. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|如果我们准备... | ...并且我们测量... | ...那么我们以这个概率看到这个结果。|'
- en: '| &#124;0〉 | 〈0&#124; | &#124;〈0 &#124; 0〉&#124;² = 1 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 〈0| | 〈0| | 〈〈0| 0〉|² = 1|'
- en: '| &#124;0〉 | 〈1&#124; | &#124;〈1 &#124; 0〉&#124;² = 0 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 〈0| | 〈1| | 〈〈1| 0〉|² = 0|'
- en: '| &#124;0〉 | 〈+&#124; | &#124;〈+ &#124; 0〉&#124;² = &#124;(〈0&#124; + 〈1&#124;)
    &#124;0〉 / √2&#124;² = (1 / √2 + 0)² = 1 / 2 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 〈0| | 〈+| | 〈〈+| 0〉|² = |(〈0| + 〈1|) 〈0| / √2|² = (1 / √2 + 0)² = 1 / 2|'
- en: '| &#124;+〉 | 〈+&#124; | &#124;〈+ &#124; +〉&#124;² = &#124;(〈0&#124; + 〈1&#124;)
    (&#124;0〉 + &#124;1〉) / 2&#124;² = &#124; 〈0 &#124; 0〉 + 〈1 &#124; 0〉 + 〈0 &#124;
    1〉 + 〈1 &#124; 1〉 &#124;² / 4 = &#124; 1 + 0 + 0 + 1 &#124;² / 4 = 2² / 4 = 1
    |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 〈+| | 〈+| | 〈〈+| +〉|² = |(〈0| + 〈1|) (〈0| + 〈1|) / 2|² = |〈0|0〉 + 〈1|0〉 +
    〈0|1〉 + 〈1|1〉|² / 4 = |1 + 0 + 0 + 1|² / 4 = 2² / 4 = 1|'
- en: '| &#124;+〉 | 〈–&#124; | &#124;〈– &#124; +〉&#124;² = 0 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 〈+| | 〈–| | 〈〈–| +〉|² = 0|'
- en: '| –&#124;0〉 | 〈0&#124; | &#124;–〈0 &#124; 0〉&#124;² = &#124;−1&#124;² = 1²
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| –〈0| | 〈0| | –〈〈0| 0〉|² = |−1|² = 1²|'
- en: '| –&#124;+〉 | 〈–&#124; | &#124;–〈+ &#124;−〉&#124;² = &#124;(–〈0&#124; − 〈1&#124;)
    (&#124;0〉 − &#124;1〉) / 2&#124;² = &#124; –〈0 &#124; 0〉 − 〈1 &#124; 0〉 + 〈0 &#124;
    1〉 + 〈1 &#124; 1〉 &#124;² / 4 = &#124; –1 − 0 + 0 + 1 &#124;² / 4 = 0² / 4 = 0
    |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| –|+〉 | 〈–| | 〈–|+〉|² = |(–〈0| − 〈1|) (〈0| − 〈1|) / 2|² = |–〈0|0〉 − 〈1|0〉
    + 〈0|1〉 + 〈1|1〉|² / 4 = |–1 − 0 + 0 + 1|² / 4 = 0² / 4 = 0|'
- en: Tip In table 2.3, we use the fact that 〈0 | 0〉 = 〈1 | 1〉 = 1 and 〈0 | 1〉 = 〈1
    | 0〉 = 0. (Try checking this for yourself!) When two states have an inner product
    of zero, we say that they are *orthogonal* (or *perpendicular*). The fact that
    |0〉 and |1〉 are orthogonal makes a lot of calculations easier to do quickly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在表2.3中，我们使用了〈0|0〉 = 〈1|1〉 = 1和〈0|1〉 = 〈1|0〉 = 0的事实。（试着亲自检查一下！）当两个态的内积为零时，我们说它们是*正交的*（或*垂直的*）。|0〉和|1〉的正交性使得许多计算变得容易快速完成。
- en: We have now covered everything we need to know about qubits to be able to simulate
    them! Let’s review the requirements we needed to satisfy to make sure we have
    working qubits.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了关于量子比特所需了解的一切，以便能够模拟它们！让我们回顾一下我们需要满足的要求，以确保我们有工作的量子比特。
- en: Qubit
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特
- en: 'A qubit is any physical system satisfying three properties:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特是任何满足三个特性的物理系统：
- en: The system can be perfectly simulated given knowledge of the vector of numbers
    (the state).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在了解数字向量（状态）的情况下，系统可以被完美模拟。
- en: The system can be transformed using quantum operations (for example, rotations).
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可以使用量子操作（例如，旋转）进行转换。
- en: Any measurement of the system produces a single classical bit of information,
    following Born’s rule.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对系统的测量都会产生一个遵循波恩规则的经典比特信息。
- en: Anytime we have a qubit (a system with the previous three properties), we can
    describe it using the same math or simulation code without further reference to
    what kind of system we are working with. This is similar to how we do not need
    to know whether a bit is defined by the direction of a pinball’s motion or the
    voltage in a transistor to write NOT and AND gates or to write software that uses
    those gates to do interesting computations.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候我们有一个量子比特（具有前三个特性的系统），我们都可以使用相同的数学或模拟代码来描述它，而无需进一步参考我们正在处理的是哪种系统。这类似于我们不需要知道一个比特是由弹球运动的方向还是晶体管的电压定义的，就可以编写NOT和AND门，或者编写使用这些门进行有趣计算软件。
- en: Note Similar to how we use the word *bit* to mean both a physical system that
    stores information and the information stored in a bit, we also use the word *qubit*
    to mean both a quantum device and the quantum information stored in that device.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与我们将单词*比特*用于表示存储信息的物理系统和存储在比特中的信息类似，我们也将单词*量子比特*用于表示量子设备和存储在该设备中的量子信息。
- en: Phase
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 相位
- en: In the last two rows of table 2.3, we saw that multiplying a state by a phase
    of –1 doesn’t affect measurement probabilities. This isn’t a coincidence but rather
    points to one of the more interesting things about qubits. Because Born’s rule
    only cares about the squared absolute value of the inner product of a state and
    a measurement, multiplying a number by (–1) doesn’t affect its absolute value.
    We call numbers such as +1 or –1, whose absolute value is equal to 1, *phases*.
    In the next chapter, we’ll see a lot more about phases when we work more with
    complex numbers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在表2.3的最后两行中，我们看到了将状态乘以-1的相位不会影响测量概率。这不是巧合，而是指向量子比特更有趣的特性之一。因为波恩规则只关心状态与测量之间内积的平方绝对值，乘以一个数（-1）不会影响它的绝对值。我们称绝对值等于1的数，如+1或-1，为*相位*。在下一章中，我们将更多地了解相位，当我们更多地使用复数时。
- en: 'For now, we say that multiplying an entire vector by –1 is an example of applying
    a *global phase*, while changing from |+〉 to |−〉 is an example of applying a relative
    phase between |0〉 and |1〉. While global phases don’t ever affect measurement results,
    there’s a big difference between the states |+〉 = (|0〉 + |1〉) / √2 and |−〉 = (|0〉
    − |1〉) / √2: the coefficients in front of |0〉 and |1〉 are the same in |+〉 and
    are different by a phase of (–1) in |−〉. We will see much more of the difference
    between these two concepts in chapters 3, 4, 6, and 7\.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们说将整个向量乘以-1是应用*全局相位*的一个例子，而从|+〉变为|−〉是应用|0〉和|1〉之间的相对相位的一个例子。虽然全局相位永远不会影响测量结果，但|+〉
    = (|0〉 + |1〉) / √2和|−〉 = (|0〉 − |1〉) / √2这两个状态之间有很大的不同：|+〉和|−〉前面的系数是相同的，而在|−〉中它们相差一个相位（-1）。我们将在第3章、第4章、第6章和第7章中看到这两个概念之间更多的差异。
- en: 2.3.5 Simulating qubits in code
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 在代码中模拟量子比特
- en: Now that we have looked at how we can describe qubit states, operations, and
    measurements, it’s time to see how to represent all of these concepts in code.
    We will use a scenario with our friend Eve to motivate the code we write.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何描述量子比特的状态、操作和测量，是时候看看如何用代码来表示所有这些概念了。我们将使用我们的朋友伊夫的场景来激发我们编写的代码。
- en: Suppose we would like to keep our ![](../Images/emoji-sparklingheart.png) for
    Eve a secret, lest anyone else find out. How can we scramble our message to Eve
    so that only she can read it?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要保守伊夫的**![sparklingheart](../Images/emoji-sparklingheart.png**)的秘密，以免其他人发现。我们如何打乱我们的信息，以便只有伊夫能阅读它？
- en: We’ll explore this application more in the next chapter, but the most basic
    step we need for any good *encryption* algorithm is a source of random numbers
    that’s difficult to predict. Let’s write down exactly how we would combine our
    secret and random bits to make a secure message to send to Eve. Figure 2.17 shows
    that if both you and Eve know the same secret sequence of random classical bits,
    we can use that sequence to communicate securely. At the start of the chapter,
    we saw how to write the message, or *plaintext*, that we want to send to Eve (in
    this case, “![](../Images/emoji-sparklingheart.png)”) as a string of classical
    bits. The one-time pad is a sequence of random classical bits that acts as a way
    to scramble or encrypt our message. This scrambling is done by taking the bitwise
    XOR of the message and one-time pad bits for each position in the sequence. This
    then produces a sequence of classical bits called the *ciphertext*. To anyone
    else trying to read our message, the ciphertext will look like random bits. For
    example, it’s impossible to tell if a bit in the ciphertext is 1 because of the
    plaintext or the one-time pad.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中更深入地探讨这个应用，但任何好的*加密*算法最基本的一步是需要一个难以预测的随机数源。让我们写下确切地如何将我们的秘密和随机比特结合起来，以发送给Eve的安全信息。图2.17显示，如果你和Eve都知道相同的随机经典比特序列，我们可以使用这个序列来安全地通信。在章节开始时，我们看到了如何将我们想要发送给Eve的消息（在这种情况下，“![](../Images/emoji-sparklingheart.png)”）作为经典比特的字符串来编写。一次性密码是一系列随机经典比特，它充当打乱或加密我们消息的方式。这种打乱是通过在每个位置上对消息和一次性密码比特进行位异或操作来完成的。这然后产生了一个称为*密文*的经典比特序列。对于任何试图读取我们消息的人来说，密文看起来像随机比特。例如，无法判断密文中的比特是1是因为明文还是一次性密码。
- en: '![](../Images/2-17.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-17.png)'
- en: Figure 2.17 An example of how to use random bits to encrypt secrets, even over
    the internet or another untrusted network. Here, we’re trying to securely send
    the message “![](../Images/emoji-heart.png)”. If we and Eve start with the shared
    secret “![](../Images/emoji-11.png)”, then we can use that as a *one-time pad*
    to protect our message.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 如何使用随机比特加密秘密的示例，即使是在互联网或另一个不受信任的网络中。在这里，我们试图安全地发送消息“![](../Images/emoji-heart.png)”。如果我们和Eve以共享的秘密“![](../Images/emoji-11.png)”开始，那么我们可以使用它作为*一次性密码*来保护我们的消息。
- en: You may ask how we get the random bit strings for our one-time pad. We can make
    our own QRNG with qubits! It may seem odd, but we will simulate qubits with classical
    bits to make our QRNG. The random numbers it generates won’t be any more secure
    than the computer we use to do our simulation, but this approach gives us a good
    start in understanding how qubits work.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我们如何得到一次性密码的随机比特字符串。我们可以用量子比特来制作自己的量子随机数发生器！这听起来可能有些奇怪，但我们将使用经典比特来模拟量子比特以制作我们的量子随机数发生器。它生成的随机数不会比我们用来进行模拟的计算机更安全，但这种方法让我们对量子比特的工作原理有了良好的理解。
- en: Let’s send Eve our message! Just as a classical bit can be represented in code
    by the values `True` and `False`, we’ve seen that we can represent the two qubit
    states |0〉 and |1〉 as *vectors*. That is, qubit states are represented in code
    as lists of lists of numbers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向Eve发送我们的信息！就像经典比特可以通过代码中的`True`和`False`值来表示一样，我们已经看到我们可以将两个量子比特状态|0〉和|1〉表示为*向量*。也就是说，量子比特状态在代码中以数字的列表形式表示。
- en: Listing 2.3 Representing qubits in code with NumPy
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 使用NumPy在代码中表示量子比特
- en: '[PRE2]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ We use the NumPy library for Python to represent vectors, as NumPy is highly
    optimized and will make our lives much easier.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用Python的NumPy库来表示向量，因为NumPy高度优化，会使我们的工作更加容易。
- en: ❷ We name our variable ket0 after the notation |0〉, in which we label qubit
    states by the ket half of 〈〉 brakets.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将我们的变量ket0命名为|0〉的表示法，其中我们通过〈〉括号的ket半部分来标记量子比特状态。
- en: ❸ NumPy will print 2 × 1 vectors as columns.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ NumPy将以列的形式打印2 × 1向量。
- en: As we saw earlier, we can construct other states such as |+〉 by using linear
    combinations of |0〉 and |1〉. In exactly the same sense, we can use NumPy to add
    the vector representations of |0〉 and |1〉 to construct the vector representation
    of |+〉.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以通过使用|0〉和|1〉的线性组合来构造其他状态，如|+〉。在完全相同的意义上，我们可以使用NumPy将|0〉和|1〉的向量表示相加来构造|+〉的向量表示。
- en: Listing 2.4 The vector representation of |+〉
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 |+〉的向量表示
- en: '[PRE3]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ NumPy uses vectors to store the |+〉 state, which is a linear combination of
    |0〉 and |1〉.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ NumPy使用向量来存储|+〉状态，这是|0〉和|1〉的线性组合。
- en: ❷ We will see the number 0.70710678 a lot in this book, as it is a good approximation
    of √2, the length of the vector [[1], [1]].
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这本书中，我们会经常看到数字0.70710678，因为它是对√2，即向量[[1], [1]]长度的良好近似。
- en: In classical logic, if we wanted to simulate how an operation would transform
    a list of bits, we could use a truth table. Similarly, since quantum operations
    other than measurement are always linear, to simulate how an operation transforms
    the state of a qubit, we can use a matrix that tells us how each state is transformed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典逻辑中，如果我们想模拟一个运算如何转换一个比特列表，我们可以使用真值表。同样，由于量子运算（除了测量）总是线性的，为了模拟一个运算如何转换量子比特的状态，我们可以使用一个矩阵，它告诉我们每个状态是如何转换的。
- en: Linear operators and quantum operations
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 线性算子和量子运算
- en: Describing quantum operations as linear operators is a good start, but not all
    linear operators are valid quantum operations! If we could implement an operation
    described by a linear operator such as 2 × 𝟙 (that is, twice the identity operator),
    then we would be able to violate that probabilities are always numbers between
    zero and one. We also require that all quantum operations other than measurement
    are *reversible*, as this is a fundamental property of quantum mechanics.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将量子运算描述为线性算子是一个好的开始，但并非所有线性算子都是有效的量子运算！如果我们能够实现一个由线性算子（如2 × 𝟙，即两次单位算子）描述的运算，那么我们就能违反概率总是介于零和一之间的规则。我们还要求所有量子运算（除了测量）都是
    *可逆的*，因为这是量子力学的一个基本属性。
- en: It turns out that the operations realizable in quantum mechanics are described
    by matrices *U* whose inverses *U*^(–1) can be computed by taking the conjugate
    transpose, *U*^(–1) = *U*^+. Such matrices are called *unitary matrices*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，量子力学中可实现的运算可以用矩阵 *U* 来描述，其逆矩阵 *U*^(–1) 可以通过取共轭转置来计算，*U*^(–1) = *U*^+. 这样的矩阵被称为
    *单位矩阵*。
- en: '![](../Images/2-unnumb-2_key.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-unnumb-2_key.png)'
- en: Visualizing types of valid quantum operations. All unitary operators are linear,
    but not all linear operators are unitary. Reversible quantum operations (that
    is, other than measurement) are represented by operators that are not just linear
    but unitary.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化有效量子运算的类型。所有单位算子都是线性的，但并非所有线性算子都是单位算子。可逆量子运算（即除了测量之外）由不是仅仅线性而是单位算子表示。
- en: One particularly important quantum operation is the *Hadamard operation*, which
    transforms |0〉 to |+〉 and |1〉 to |−〉. As we saw earlier, measuring |+〉 along the
    *Z*-axis gives either a 0 or a 1 result with equal probability. Since we want
    random bits in order to send secret messages, the Hadamard operation is really
    useful for making our QRNG.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别重要的量子运算就是 *Hadamard运算*，它将 |0〉 转换为 |+〉，将 |1〉 转换为 |−〉。正如我们之前看到的，沿着 *Z*-轴测量
    |+〉 会以相等的概率给出0或1的结果。由于我们想要随机比特来发送秘密消息，Hadamard运算对于制作我们的量子随机数生成器非常有用。
- en: Using vectors and matrices, we can define the Hadamard operation by making a
    table of how it acts on the |0〉 and |1〉 states, as shown in table 2.4.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矢量和矩阵，我们可以通过制作一个表格来定义Hadamard运算，该表格显示了它在 |0〉 和 |1〉 状态上的作用，如表2.4所示。
- en: Table 2.4 Representing the Hadamard operation as a table
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.4 将Hadamard运算表示为表格
- en: '| Input state | Output state |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 输入状态 | 输出状态 |'
- en: '| &#124;0〉 | &#124;+〉 = (&#124;0〉 + &#124;1〉) / √2 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| &#124;0〉 | &#124;+〉 = (&#124;0〉 + &#124;1〉) / √2 |'
- en: '| &#124;1〉 | &#124;−〉 = (&#124;0〉 − &#124;1〉) / √2 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| &#124;1〉 | &#124;−〉 = (&#124;0〉 − &#124;1〉) / √2 |'
- en: Because quantum mechanics is linear, this is a fully complete description of
    the Hadamard operation!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于量子力学是线性的，这是Hadamard运算的完整描述！
- en: In matrix form, we write table 2.4 as `H = np.array([[1, 1], [1, -1]]) / np
    .sqrt(2)`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以矩阵形式，我们将表2.4写为 `H = np.array([[1, 1], [1, -1]]) / np .sqrt(2)`.
- en: Listing 2.5 Defining the Hadamard operation
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 定义Hadamard运算
- en: '[PRE4]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ We define a variable *H* to hold the matrix representation *H* of the Hadamard
    operation that we saw in table 2.4\. We’ll need *H* throughout the rest of this
    chapter, so it’s helpful to define it here.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们定义一个变量 *H* 来保存我们在表2.4中看到的Hadamard运算的矩阵表示 *H*。在整个本章的其余部分，我们都需要 *H*，所以在这里定义它是很有帮助的。
- en: Hadamard operation
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Hadamard运算
- en: 'The Hadamard operation is a quantum operation that can be simulated by this
    linear transformation:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Hadamard运算是一种量子运算，可以通过以下线性变换来模拟：
- en: '![](../Images/equation_2-2K.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_2-2K.png)'
- en: Any operation on quantum data can be written as a matrix in this way. If we
    wish to transform |0〉 to |1〉 and vice versa (the quantum generalization of the
    classical NOT operation that we saw earlier, corresponding to a 180° rotation),
    we do the same thing we did to define the Hadamard operation.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 任何量子数据的运算都可以用这种方式写成矩阵。如果我们想将 |0〉 转换为 |1〉 并反之亦然（这是我们在之前看到的经典非运算的量子推广，对应于180°旋转），我们就做与定义Hadamard运算时相同的事情。
- en: Listing 2.6 Representing the quantum NOT gate
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 表示量子非门
- en: '[PRE5]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The quantum operation corresponding to the classical NOT operation is typically
    called the x operation; we represent the matrix for x with a Python variable X.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对应于经典非操作的经典量子操作通常称为 x 操作；我们用 Python 变量 X 表示 x 的矩阵。
- en: '❷ We can confirm that X transforms |0〉 to |1〉. The NumPy method all() returns
    True if every element of X @ ket0 == ket1 is True: that is, if every element of
    the array X @ ket0 is equal to the corresponding element of ket1.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们可以确认 X 将 |0〉 转换为 |1〉。NumPy 方法 all() 如果 X @ ket0 == ket1 的每个元素都为 True，则返回
    True：也就是说，如果 X @ ket0 数组的每个元素都等于 ket1 的相应元素。
- en: ❸ The x operator doesn’t do anything to *H*|0〉. We can confirm this by using
    the @ operator again to multiply X by a Python value representing the state |+〉
    = *H*|0〉. We can express that value as *H* @ ket0.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 乘法算子对 *H*|0〉没有作用。我们可以再次使用 @ 算子来乘以代表状态 |+〉 = *H*|0〉 的 Python 值。我们可以将这个值表示为
    *H* @ ket0。
- en: 'The `x` operation doesn’t do anything on the last input because the `x` operation
    swaps |0〉 and |1〉. The *H*|0〉 state, also called |+〉, is already a sum of the
    two kets: (|0〉 + |1〉) / √2 = (|1〉 + |0〉) / √2, so a swap action of the `x` operation
    doesn’t do anything.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法算子对最后一个输入没有作用，因为乘法算子交换了 |0〉 和 |1〉。*H*|0〉 状态，也称为 |+〉，已经是两个基矢的和：(|0〉 + |1〉)
    / √2 = (|1〉 + |0〉) / √2，所以乘法算子的交换操作没有作用。
- en: Recalling the map analogy from appendix C, we can think of the matrix *H* as
    a *reflection* about the ![](../Images/emoji-darrow.png) direction, as illustrated
    in figure 2.18.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾附录C中的映射类比，我们可以将矩阵 *H* 视为关于 ![](../Images/emoji-darrow.png) 方向的 *反射*，如图2.18所示。
- en: '![](../Images/2-18.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-18.png)'
- en: Figure 2.18 The `h` operation as a reflection or flip about ![](../Images/emoji-darrow.png).
    Unlike a rotation of 90°, applying `h` twice returns a qubit to the state it started
    in. Another way to think of `h` is that the reflection about ![](../Images/emoji-darrow.png)
    swaps the role of the *X*- and *Z*-axes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 `h` 操作作为关于 ![](../Images/emoji-darrow.png) 的反射或翻转。与90°旋转不同，应用两次 `h` 将量子比特返回到初始状态。另一种思考
    `h` 的方式是，关于 ![](../Images/emoji-darrow.png) 的反射交换了 *X* 轴和 *Z* 轴的作用。
- en: The third dimension awaits!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第三维等待着！
- en: For qubits, the map analogy from appendix C helps us understand how to write
    and manipulate the states of single qubits. So far, however, we’ve only looked
    at states that can be written using real numbers. In general, quantum states can
    use complex numbers. If we rearrange our map and make it three-dimensional, we
    can include complex numbers without any problem. This way of thinking about qubits
    is called the *Bloch sphere* and can be very useful for considering quantum operations
    such as rotations and reflections, as we’ll see in chapter 6.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于量子比特，附录C中的映射类比帮助我们理解如何编写和操作单个量子比特的状态。然而，到目前为止，我们只看了可以用实数表示的状态。通常，量子状态可以使用复数。如果我们调整我们的映射并使其成为三维的，我们就可以毫无问题地包含复数。这种关于量子比特的思考方式被称为
    *布洛赫球面*，在考虑量子操作，如旋转和反射时非常有用，正如我们在第6章中将要看到的。
- en: '![](../Images/2-unnumb-3.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-unnumb-3.png)'
- en: More generally, we can visualize qubit states as points on a sphere, not just
    a circle. Doing so takes using complex numbers, though—we’ll see more about that
    in chapter 6.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，我们可以将量子比特状态可视化为球面上的点，而不仅仅是圆上的点。这样做需要使用复数，我们将在第6章中了解更多。
- en: 'Deep dive: Infinitely many states?'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：无限多个状态？
- en: It may seem from the figure in the previous sidebar that there are infinitely
    many different states of a qubit. For any two different points on a sphere, we
    can always find a point that’s “between” them. While this is true, it can also
    be a little misleading. Thinking of the classical situation for a moment, a coin
    that lands heads 90% of the time is distinct from a coin that lands heads 90.0000000001%
    of the time. In fact, we can always make a coin whose bias is “between” the bias
    of two other coins. Flipping a coin can only ever give us one classical bit of
    information, though. On average, it would take about 1023 flips to tell a coin
    that lands heads 90% of the time apart from one that lands heads 90.0000000001%
    of the time. We can treat these two coins as identical because we cannot do an
    experiment that reliably tells them apart. Similarly, for quantum computing, there
    are limits to our ability to tell apart the infinitely many different quantum
    states that we recognize from the Bloch sphere picture.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一侧栏的图中可能看起来，一个量子比特有无限多种不同的状态。对于球面上的任意两个不同点，我们总能找到一个位于它们“之间”的点。虽然这是真的，但也可能有些误导。暂时考虑一下经典情况，一个90%时间落地正面的硬币与一个90.0000000001%时间落地正面的硬币是不同的。实际上，我们总能制造出一个其偏差“位于”两个其他硬币偏差之间的硬币。抛硬币只能给我们一个经典比特的信息。平均来说，需要抛大约1023次才能区分一个90%时间落地正面的硬币和一个90.0000000001%时间落地正面的硬币。我们可以将这两个硬币视为相同，因为我们无法进行一个可靠地区分它们的实验。同样，对于量子计算，我们区分从Bloch球面图中识别出的无限多种不同量子状态的能力是有限的。
- en: The fact that a qubit has infinitely many states is not what makes it unique.
    Sometimes people say that a quantum system can be “in infinitely many states at
    once,” which is why they say quantum computers can offer speedups. *This is false!*
    As pointed out previously, we can’t distinguish states that are very close together,
    so the “infinitely many” part of the statement can’t be what gives quantum computing
    an advantage. We will talk more about the “at once” part in upcoming chapters,
    but suffice to say it is not the number of states that our qubit can be in that
    makes quantum computers cool!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一个量子比特有无限多种状态并不是它独特的地方。有时人们会说一个量子系统可以“同时处于无限多种状态”，这就是为什么他们会说量子计算机可以提供加速。*这是错误的!*
    如前所述，我们无法区分非常接近的状态，所以“无限多种”这一说法并不能给量子计算带来优势。我们将在接下来的章节中更多地讨论“同时”这一部分，但可以简单地说，并不是我们的量子比特可以处于的状态数量使得量子计算机变得酷！
- en: 2.4 Programming a working QRNG
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 编程一个工作用的量子随机数发生器
- en: Now that we have a few quantum concepts to play with, let’s apply what we’ve
    learned to program a QRNG so that we can send ![](../Images/emoji-sparklingheart.png)s
    with no worries. We are going to build a QRNG that returns either a 0 or a 1.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有几个量子概念可以玩，让我们应用我们所学到的知识来编程一个量子随机数发生器（QRNG），这样我们就可以无忧无虑地发送![../Images/emoji-sparklingheart.png]了。我们将构建一个返回0或1的QRNG。
- en: Random bits or random numbers?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 随机比特或随机数？
- en: 'It may seem limiting that our QRNG can only output one of two numbers, 0 or
    1\. On the contrary: this is enough to generate random numbers in the range 0
    to *N* for any positive integer *N*. It’s easiest to see this starting with the
    special case that *N* is 2^(*n*) − 1 for some positive integer *n*, in which case
    we simply write down our random numbers as *n*-bit strings. For example, we can
    make random numbers between 0 and 7 by generating three random bits *r*[0], *r*[1],
    and *r*[2] and then returning 4*r*[2] + 2*r*[1] + *r*[0].'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我们的QRNG只能输出两个数字中的一个，0或1。相反：这足以生成0到*N*范围内的随机数，其中*N*是任何正整数。最容易看到这一点是从特殊情况开始，即*N*是某个正整数*n*的2^(*n*)
    − 1，在这种情况下，我们只需将我们的随机数写成*n*-比特字符串。例如，我们可以通过生成三个随机比特*r*[0]、*r*[1]和*r*[2]，然后返回4*r*[2]
    + 2*r*[1] + *r*[0]来生成0到7之间的随机数。
- en: The case is slightly more tricky if *N* isn’t given by a power of two, in that
    we have “leftover” possibilities that we need to deal with. For instance, if we
    need to roll a six-sided die but only have an eight-sided die (maybe we played
    a druid at the latest RPG night), then we need to decide what to do when that
    die rolls a 7 or an 8\. The best thing we can do if we want a fair six-sided die
    is to simply reroll when that happens. Using this approach, we can build arbitrary
    fair dice from coin flips—handy for whatever game we want to play. Long story
    short, we aren’t limited by having just two outcomes from our QRNG!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*N*不是2的幂，情况会稍微复杂一些，因为我们有“剩余”的可能性需要处理。例如，如果我们需要掷一个六面的骰子，但我们只有八面的骰子（也许我们在最新的RPG之夜玩了一个德鲁伊），那么当骰子掷出7或8时，我们需要决定怎么办。如果我们想要一个公平的六面骰子，最好的办法就是在那种情况下重新掷骰子。使用这种方法，我们可以从抛硬币中构建任意公平的骰子——这对于我们想要玩的游戏来说非常方便。简而言之，我们并不受QRNG只有两种结果的限制！
- en: 'As with any quantum program, our QRNG program will be a sequence of instructions
    to a device that performs operations on a qubit (see figure 2.19). In pseudocode,
    a quantum program for implementing a QRNG consists of three instructions:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何量子程序一样，我们的QRNG程序将是一系列指令，指示设备对一个量子比特执行操作（见图2.19）。在伪代码中，实现QRNG的量子程序由三个指令组成：
- en: Prepare a qubit in the state |0〉.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个处于|0〉状态的量子比特。
- en: Apply the Hadamard operation to our qubit so it is in the state |+〉 = *H*|0〉.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Hadamard操作应用于我们的量子比特，使其处于状态|+〉 = *H*|0〉。
- en: Measure the qubit to get either a 0 or a 1 result with 50/50 probability.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量量子比特以获得0或1的结果，概率各为50%。
- en: '![](../Images/2-19.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-19.png)'
- en: Figure 2.19 Steps for writing the QRNG program that we want to test. Revisiting
    figure 2.3, we can use what we’ve learned so far to write the state of our qubit
    after each step in the QRNG algorithm.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 我们想要测试的QRNG程序步骤。回顾图2.3，我们可以使用我们迄今为止所学到的知识来编写QRNG算法中每一步后的量子比特状态。
- en: That is, we want a program that looks something like the following.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 即，我们希望程序看起来像以下这样。
- en: Listing 2.7 Example pseudocode for a QRNG program
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 QRNG程序的示例伪代码
- en: '[PRE6]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using matrix multiplication, we can use a classical computer like a laptop to
    simulate how `qrng()` would act on an ideal quantum device. Our `qrng` program
    calls into a software stack (see figure 2.20) that abstracts away whether we’re
    using a classical simulator or an actual quantum device.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵乘法，我们可以使用像笔记本电脑这样的经典计算机来模拟`qrng()`在理想量子设备上的行为。我们的`qrng`程序调用一个软件栈（见图2.20），该软件栈抽象化了我们是使用经典模拟器还是实际量子设备。
- en: '![](../Images/2-20.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-20.png)'
- en: Figure 2.20 An example of what a software stack for a quantum program might
    look like
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 一个量子程序软件栈可能的样子
- en: There are many parts to the stack, but don’t worry—we will talk about them as
    we go. For now, we are focusing on the top section (labeled “Classical computer”
    in the figure) and will start by writing code for a quantum program as well as
    a simulator backend in Python.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 栈有很多部分，但不用担心——我们将随着进展讨论它们。现在，我们专注于图中的顶部部分（标记为“经典计算机”），并将从编写Python中的量子程序以及模拟器后端代码开始。
- en: Note In chapter 7, we’ll pivot to using the simulator backend provided with
    Microsoft’s Quantum Development Kit, instead.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第7章中，我们将转向使用微软量子开发工具包提供的模拟器后端。
- en: With this view of a software stack in mind, then, we can write our simulation
    of a QRNG by first writing a `QuantumDevice` class with abstract methods for allocating
    qubits, performing operations, and measuring qubits. We can then implement this
    class with a simulator and call into that simulator from `qrng()`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中有了对软件栈的这种看法之后，我们可以首先编写一个`QuantumDevice`类，其中包含用于分配量子比特、执行操作和测量量子比特的抽象方法。然后，我们可以用模拟器实现这个类，并在`qrng()`中调用该模拟器。
- en: To design the interface for our simulator in a way that looks like figure 2.20,
    let’s list what we need our quantum device to do. First, users must be able to
    allocate and return qubits.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的模拟器接口看起来像图2.20所示，让我们列出我们需要我们的量子设备执行的操作。首先，用户必须能够分配和返回量子比特。
- en: 'Listing 2.8 interface.py: interface into a quantum device as abstract methods'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 interface.py：量子设备的接口作为抽象方法
- en: '[PRE7]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Any implementation of a quantum device must implement this method, allowing
    users to obtain qubits.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 任何量子设备的实现都必须实现此方法，使用户能够获取量子比特。
- en: ❷ When users are done with a qubit, implementations of deallocate_qubit will
    allow users to return the qubit to the device.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当用户完成对一个量子比特的使用后，`deallocate_qubit`的实现将允许用户将量子比特返回到设备。
- en: ❸ We can provide a Python context manager to make it easy to allocate and deallocate
    qubits safely.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们可以提供一个 Python 上下文管理器，以便安全地分配和释放量子比特。
- en: ❹ The context manager makes sure that no matter what exceptions are raised,
    each qubit is reset and deallocated before being returned to the classical computer.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 上下文管理器确保无论抛出什么异常，每个量子比特在返回到经典计算机之前都会被重置和释放。
- en: 'The qubits themselves can then expose the actual transformations that we need:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特本身可以暴露我们需要的实际转换：
- en: Users must be able to perform Hadamard operations on qubits.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须能够在量子比特上执行哈达玛操作。
- en: Users must be able to measure qubits to get classical data.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须能够测量量子比特以获取经典数据。
- en: 'Listing 2.9 interface.py: interface into the qubits on a quantum device'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 interface.py：量子设备上量子比特的接口
- en: '[PRE8]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The *H* method transforms a qubit in place (not making a copy) using the Hadamard
    operation np.array([[1, 1], [1, –1]]) / np.sqrt(2).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ *H* 方法使用哈达玛操作 np.array([[1, 1], [1, –1]]) / np.sqrt(2) 在原地转换量子比特（不创建副本）。
- en: ❷ The measure method allows users to measure qubits and extract classical data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测量方法允许用户测量量子比特并提取经典数据。
- en: ❸ The reset method makes it easy for users to prepare the qubit from scratch
    again.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 重置方法使用户能够从头开始再次准备量子比特。
- en: With this in place, we can return to our definition of `qrng` using these new
    classes.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以使用这些新类返回到 `qrng` 的定义。
- en: 'Listing 2.10 qrng.py: definition of the `qrng` device'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 qrng.py：`qrng` 设备的定义
- en: '[PRE9]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we implement the `QuantumDevice` interface with a class called `SingleQubitSimulator`,
    then we can pass this to `qrng` to run our QRNG implementation on a simulator.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用名为 `SingleQubitSimulator` 的类实现 `QuantumDevice` 接口，那么我们可以将其传递给 `qrng` 以在模拟器上运行我们的
    QRNG 实现。
- en: 'Listing 2.11 qrng.py: definition of `main` for qrng.py'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 qrng.py：`qrng.py` 的 `main` 定义
- en: '[PRE10]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We now have everything to write `SingleQubitSimulator`. We start by defining
    a couple of constants for the vector |0〉 and the matrix representation of the
    Hadamard operation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了编写 `SingleQubitSimulator` 所需的一切。我们首先为向量 |0〉 和哈达玛操作的矩阵表示定义几个常量。
- en: 'Listing 2.12 simulator.py: defining useful constants'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 simulator.py：定义有用的常量
- en: '[PRE11]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Since we’ll be using |0〉 a lot in our simulator, we define a constant for
    it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于我们将在模拟器中大量使用 |0〉，因此我们为它定义了一个常量。
- en: ❷ Similarly, we’ll use the Hadamard matrix *H* to define how the Hadamard operation
    transforms states, so we define a constant for that as well.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 类似地，我们将使用哈达玛矩阵 *H* 来定义哈达玛操作如何转换状态，因此我们也为它定义一个常量。
- en: Next, we define what a simulated qubit looks like. From the perspective of a
    simulator, a qubit wraps a vector that stores the qubit’s current state. We use
    a NumPy array to represent our qubit’s state.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义模拟量子比特的外观。从模拟器的角度来看，量子比特封装了一个存储量子比特当前状态的向量。我们使用 NumPy 数组来表示量子比特的状态。
- en: 'Listing 2.13 simulator.py: defining a class to represent qubits in our device'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.13 simulator.py：定义表示设备中量子比特的类
- en: '[PRE12]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ As a part of the Qubit interface, we ensure that the reset method prepares
    our qubit in the |0〉 state. We can use that when we create the qubit to ensure
    that qubits always start in the correct state.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为 Qubit 接口的一部分，我们确保重置方法将我们的量子比特准备在 |0〉 状态。我们可以使用它来创建量子比特，以确保量子比特始终从正确的状态开始。
- en: ❷ The Hadamard operation can be simulated by applying the matrix representation
    *H* to the state that we’re storing at the moment and then updating to our new
    state.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过将矩阵表示 *H* 应用到我们当前存储的状态，然后更新到新状态，可以模拟哈达玛操作。
- en: ❸ We stored our qubit’s state as a vector, so we know the inner product with
    |0〉 is simply the first element of that vector. For instance, if the state is
    np.array([[a], [b]]) for some numbers a and b, then the probability of observing
    a 0 outcome is |a|². We can find this using np.abs(a) ** 2\. This gives us the
    probability that a measurement of our qubit returns 0.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们将量子比特的状态存储为向量，因此我们知道与 |0〉 的内积只是该向量的第一个元素。例如，如果状态是 np.array([[a], [b]]) 对于某些数字
    a 和 b，那么观察到 0 的概率是 |a|²。我们可以使用 np.abs(a) ** 2 来找到这个概率。这给出了量子比特测量结果为 0 的概率。
- en: ❹ To turn the probability of getting a 0 into a measurement result, we generate
    a random number between 0 and 1 using np.random.random and check whether it’s
    less than pr0.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为了将得到 0 的概率转换为测量结果，我们使用 np.random.random 生成一个介于 0 和 1 之间的随机数，并检查它是否小于 pr0。
- en: ❺ Finally, we return 0 to the caller if we got a 0 and 1 if we got a 1.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 最后，如果我们得到 0，则返回 0 给调用者，如果得到 1，则返回 1。
- en: 'What random number came first: 0 or 1?'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个随机数先出现：0 还是 1？
- en: 'In making this QRNG, we have to call a *classical* random number generator.
    This may feel a bit circular, but it comes about because our classical simulation
    is just that: a simulation. A simulation of a QRNG is no more random than the
    hardware and software we use to implement that simulator.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作这个量子随机数生成器（QRNG）时，我们必须调用一个**经典**的随机数生成器。这可能会感觉有点循环，但这是因为我们的经典模拟只是那样：一个模拟。对QRNG的模拟并不比我们用来实现该模拟器的硬件和软件更随机。
- en: That said, the quantum program qrng.py itself does not need to call a classical
    RNG but calls into the simulator. If we were to run qrng.py on an actual quantum
    device, the simulator and the classical RNG would be substituted for operations
    on the actual qubit. At that point, we would have a stream of random numbers that
    would be impossible to predict, thanks to the laws of quantum mechanics.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，量子程序qrng.py本身不需要调用经典RNG，而是调用模拟器。如果我们要在实际的量子设备上运行qrng.py，模拟器和经典RNG将被实际比特的操作所取代。到那时，由于量子力学的定律，我们将得到一个无法预测的随机数流。
- en: Running our program, we now get the random numbers we expected!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的程序，我们现在得到了我们预期的随机数！
- en: '[PRE13]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Congratulations! We’ve not only written our first quantum program but also written
    a simulation backend and used it to run our quantum program the same way we’d
    run it on an actual quantum computer.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们不仅编写了我们的第一个量子程序，还编写了模拟后端，并使用它以与实际量子计算机相同的方式运行我们的量子程序。
- en: 'Deep dive: Schrödinger’s cat'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：薛定谔的猫
- en: You may have already seen or heard of this quantum program under a very different
    name. The QRNG program is often described in terms of the *Schrödinger’s cat*
    thought experiment. Suppose a cat is in a closed box with a vial of poison that
    will be released if a particular random particle decays. Before we open the box
    to check, how do we know if it is alive or dead?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经以一个非常不同的名字看到或听说过这个量子项目。QRNG项目通常用**薛定谔的猫**思想实验来描述。假设一只猫在一个封闭的盒子里，盒子里有一个装有毒药的瓶子，如果某个特定的随机粒子发生衰变，毒药就会被释放。在我们打开盒子检查之前，我们如何知道它是活的还是死的？
- en: The [state] of the entire system would express this by having in it the living
    and dead cat (pardon the expression) mixed or smeared out in equal parts.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统的[状态]将通过在其中包含活猫和死猫（请原谅这种表达）以相等部分混合或扩散来表示。
- en: —Erwin Schrödinger
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ——欧文·薛定谔
- en: Historically, Schrödinger proposed this description in 1935 to express his view
    that some implications of quantum mechanics are “ridiculous” by means of a thought
    experiment that highlights how counterintuitive these implications are. Such thought
    experiments, known as *gedankenexperiment*, are a celebrated tradition in physics
    and can help us understand or critique different theories by pushing them to extreme
    or absurd limits.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，薛定谔在1935年提出了这种描述，通过一个强调这些含义如何反直觉的思想实验来表达他的观点，即量子力学的某些含义是“荒谬的”。这类思想实验，被称为**思想实验**，是物理学中的一种著名传统，通过将理论推向极端或荒谬的极限，可以帮助我们理解或批判不同的理论。
- en: Reading about Schrödinger’s cat nearly a century later, however, it’s helpful
    to remember everything that’s happened in the intervening years. Since his original
    letter, the world has seen
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，近一个世纪后阅读关于薛定谔的猫，记住在这期间发生的一切是有帮助的。自从他的原始信件以来，世界已经看到了
- en: War on a scale never before imagined
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象不到规模的战争
- en: The first steps that humanity has taken to explore beyond our planet
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类探索我们星球之外的第一次步骤
- en: The rise of commercial jet travel
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业喷气旅行的兴起
- en: The understanding and first effects of anthropogenic climate change
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类活动引起的气候变化的理解和首次影响
- en: A fundamental shift in how we communicate (from television all the way to the
    internet)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们沟通方式的根本转变（从电视一直到互联网）
- en: A wide availability of affordable computing devices
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便宜的计算设备的广泛可用性
- en: The discovery of a wondrous variety of subatomic particles
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现了各种亚原子粒子的奇妙多样性
- en: The world we live in isn’t the same world in which Schrödinger tried to make
    sense of quantum mechanics! We have many advantages in trying to understand, not
    the least of which is that we can quickly get our hands on quantum mechanics by
    programming simulations using classical computers. For example, the `h` instruction
    we saw earlier puts our qubit in a situation similar to the cat in the gedankenexperiment,
    but with the advantage that it’s much easier to experiment with our program than
    with a thought experiment. Throughout the rest of the book, we’ll use quantum
    programs to learn the parts of quantum mechanics we need to write quantum algorithms.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活的世界与薛定谔试图理解量子力学时的世界并不相同！我们在试图理解方面有很多优势，其中最显著的是，我们可以通过使用经典计算机编程模拟来快速掌握量子力学。例如，我们之前看到的`h`指令将我们的量子比特置于类似于思想实验中猫的状态，但优势在于，与思想实验相比，实验我们的程序要容易得多。在本书的其余部分，我们将使用量子程序来学习编写量子算法所需的量子力学部分。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Random numbers help in a wide range of applications, such as playing games,
    simulating complex systems, and securing data.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数在广泛的应用中都有帮助，例如玩游戏、模拟复杂系统和保护数据。
- en: Classical bits can be in one of two states, which we traditionally call 0 and
    1.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典比特可以处于两种状态之一，我们传统上将其称为0和1。
- en: Quantum analogues to classical bits, called *qubits*, can be in either the |0〉
    or |1〉 state, or in superpositions of |0〉 and |1〉; for example, |+〉 = 1 / √2 (|0〉
    + |1〉).
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子力学中的经典比特的类似物，称为**量子比特**，可以处于|0〉或|1〉状态，或者处于|0〉和|1〉的叠加状态；例如，|+〉 = 1 / √2 (|0〉
    + |1〉)。
- en: By using the Hadamard operation, we can prepare qubits in the |+〉 state; we
    can then measure the qubits to generate numbers that are guaranteed to be random
    by the laws of quantum mechanics.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Hadamard运算，我们可以将量子比特准备在|+〉状态；然后我们可以测量量子比特以生成由量子力学定律保证的随机数。
