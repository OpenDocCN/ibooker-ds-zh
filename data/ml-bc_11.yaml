- en: Appendix B. Introduction to Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. Python 简介
- en: Python is currently the most popular language for building machine learning
    projects, and this is why we use it for doing the projects in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 目前是构建机器学习项目的最流行语言，这就是为什么我们在这本书的项目中使用它。
- en: 'In case you’re not familiar with Python, this appendix covers the basics: the
    syntax and the language features we use in the book. It’s not meant to be an in-depth
    tutorial, but it should give you enough information to start using Python immediately
    after finishing the appendix. Note that it’s brief, and it’s aimed at people who
    already know how to program in any other programming language.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 Python，本附录涵盖了基础知识：本书中使用的语法和语言特性。它不是深入教程，但它应该提供足够的信息，让您在完成附录后立即开始使用 Python。请注意，它很简短，并且针对已经知道如何使用任何其他编程语言进行编程的人。
- en: To get the best of this appendix, create a jupyter notebook, give it a name
    like appendix-b-python, and use it to execute the code from the appendix. Let’s
    start.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用本附录，创建一个 jupyter notebook，给它起一个像 appendix-b-python 这样的名字，并使用它来执行附录中的代码。让我们开始吧。
- en: B.1 Variables
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 变量
- en: 'Python is a dynamic language—so you don’t need to declare types like in Java
    or C++. For example, to create a variable with integer or string, we only need
    to do a simple assignment:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种动态语言——因此您不需要像 Java 或 C++ 那样声明类型。例如，要创建一个整型或字符串类型的变量，我们只需要进行简单的赋值：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ a is an integer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ a 是一个整数。
- en: ❷ b and c are strings.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ b 和 c 是字符串。
- en: ❸ d is a float.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ d 是一个浮点数。
- en: 'To print something to standard output, we can use the `print` function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要将内容打印到标准输出，我们可以使用 `print` 函数：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It prints
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To execute the code, you can put each code snippet in a separate jupyter notebook
    cell and then execute it. For executing the code in the cell, you can press the
    Run button, or use the Shift+Enter hotkey (figure B.1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行代码，您可以将每个代码片段放在单独的 jupyter notebook 单元格中，然后执行它。要执行单元格中的代码，您可以按 Run 按钮，或使用
    Shift+Enter 快捷键（图 B.1）。
- en: '![](../Images/B-01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B-01.png)'
- en: Figure B.1 Code executed in Jupyter Notebook cells. You can see the output immediately
    after executing the code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.1 在 Jupyter Notebook 单元格中执行的字节码。您可以在执行代码后立即看到输出。
- en: When we pass multiple arguments to `print`, like in the previous example, it
    adds a space between the arguments when printing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将多个参数传递给 `print` 时，就像前面的例子一样，它在打印参数之间添加一个空格。
- en: 'We can put multiple variables together with a special construction called *tuple*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一种称为 *元组* 的特殊构造将多个变量组合在一起：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we print `t`, we get the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印 `t` 时，我们得到以下内容：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To unwrap a tuple into multiple variables we use *tuple assignment*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要将元组展开为多个变量，我们使用 *元组赋值*：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now `c` and `d` contain the first value of the tuple, as well as the second
    one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `c` 和 `d` 包含元组的第一个值，以及第二个值：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It prints
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can drop the parentheses when using the tuple assignment:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用元组赋值时，我们可以省略括号：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This produces the same result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生相同的结果。
- en: 'Tuple assignment is quite useful and can make the code shorter. For example,
    we can use it to swap the content of two variables:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 元组赋值非常有用，可以使代码更简洁。例如，我们可以用它来交换两个变量的内容：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Replace a with b and b with a.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 a 替换为 b，将 b 替换为 a。
- en: It will print
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When printing, we can have nicely formatted strings using the `%` operator:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印时，我们可以使用 `%` 操作符来创建格式化的字符串：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Replace %s with the content of a.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 %s 替换为 a 的内容。
- en: ❷ Replace %s with the content of b.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 %s 替换为 b 的内容。
- en: 'It will produce the same output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它将产生相同的输出：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here `%s` is a placeholder: in this case, it means that we want to format the
    passed argument as a string. Other commonly used options are'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里 `%s` 是一个占位符：在这种情况下，它意味着我们想要将传递的参数格式化为字符串。其他常用选项包括
- en: '`%d` to format it as a number'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `%d` 来格式化为数字
- en: '`%f` to format it as a floating-point number'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `%f` 来格式化为浮点数
- en: 'We can pass in multiple arguments to the format operator in a tuple:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个参数传递给元组中的格式化操作符：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first occurrence of the placeholder `%s` will be replaced by `a`, and the
    second by `b`, so it will produce the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符 `%s` 的第一次出现将被替换为 `a`，第二次出现将被替换为 `b`，因此将生成以下内容：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, if we have a floating-point number, we can use special formatting
    for it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们有一个浮点数，我们可以使用特殊的格式化来处理它：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will round the float to the second decimal point when formatting the string,
    so we will see 0.01 when executing the code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在格式化字符串时将浮点数四舍五入到小数点后第二位，因此执行代码时我们将看到 0.01。
- en: There are many options for formatting strings, and also other ways of formatting.
    For example, there’s also the so-called “new” way of formatting using the `string.format`
    method, which we won’t cover in this appendix. You can read more about these formatting
    options at [https://pyformat.info](https://pyformat.info/) or in the official
    documentation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串格式化有许多选项，还有其他格式化方式。例如，还有所谓的“新”格式化方式，使用 `string.format` 方法，我们不会在本附录中介绍。您可以在
    [https://pyformat.info](https://pyformat.info/) 或官方文档中了解更多关于这些格式化选项的信息。
- en: B.1.1 Control flow
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.1 控制流
- en: 'There are three control-flow statements in Python: `if`, `for` and `while`.
    Let’s take a look at each of them.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有三种控制流语句：`if`、`for` 和 `while`。让我们看看每个语句。
- en: Conditions
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 条件
- en: 'A simple way to control the execution flow of a program is the `if` statement.
    In Python the syntax for `if` is the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 控制程序执行流程的简单方法是 `if` 语句。在 Python 中，`if` 的语法如下：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will print the first statement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印第一条语句：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that in Python we use indentation for grouping the code after the `if`
    statement. We can chain multiple `if` statements together using `elif`, which
    is a shortening for `else-if`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Python 中，我们在 `if` 语句之后使用缩进来分组代码。我们可以使用 `elif`（`else-if` 的缩写）将多个 `if` 语句链接在一起：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code will print the second statement:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印第二条语句：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For loop
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于循环
- en: 'When we want to repeat the same piece of code multiple times, we use loops.
    The traditional `for` loop in Python looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要多次重复相同的代码块时，我们使用循环。Python 中的传统 `for` 循环看起来像这样：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code will print numbers from 0 to 9, and 10 is not included:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印从 0 到 9 的数字，不包括 10：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When specifying the range, we can set the starting number, the end number,
    and the increment step:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定范围时，我们可以设置起始数字、结束数字和增量步长：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code will print numbers from 10 to 100 (excluded) with step 5: 10, 15,
    20, ..., 95.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印从 10 到 100（不包括）的数字，步长为 5：10, 15, 20, ..., 95。
- en: 'To exit the loop earlier, we can use the `break` statement:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要提前退出循环，我们可以使用 `break` 语句：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code will print numbers between 0 and 6\. When `i` is 6, it will break
    the loop, so it will not print any numbers after 6:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印从 0 到 6 的数字。当 `i` 为 6 时，它将中断循环，因此它不会打印 6 之后的任何数字：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To skip an iteration of the loop, we use the `continue` statement:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要跳过循环的迭代，我们使用 `continue` 语句：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code will skip the iterations when `i` is 5 or less, so it will print
    only numbers starting from 6:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在 `i` 为 5 或更少时跳过迭代，因此它只会打印从 6 开始的数字：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While loop
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环
- en: 'The `while` loop is also available in Python. It executes while a certain condition
    is `True`. For example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环也适用于 Python。它在某个条件为 `True` 时执行。例如：'
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this code, we repeat the loop while the condition `cnt` `<=` `5` is `True`.
    Once this condition is no longer `True`, the execution stops. This code will print
    numbers between 0 and 5, including 5:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们重复循环直到条件 `cnt` `<=` `5` 为 `True`。一旦这个条件不再为 `True`，执行停止。这段代码将打印从 0 到
    5 的数字，包括 5：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can use the `break` and `continue` statements in `while` loops as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 `while` 循环中使用 `break` 和 `continue` 语句。
- en: B.1.2 Collections
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.2 集合
- en: 'Collections are special containers that allow keeping multiple elements in
    them. We will look at four types of collections: lists, tuples, sets, and dictionaries.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是特殊的容器，允许在其中保持多个元素。我们将查看四种类型的集合：列表、元组、集合和字典。
- en: Lists
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: 'A *list* is an ordered collection with the possibility to access an element
    by index. To create a list, we can simply put elements inside squared brackets:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是一个有序集合，可以通过索引访问元素。要创建列表，我们可以简单地将元素放在方括号内：'
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To get an element by its index, we can use the brackets notation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过索引获取元素，我们可以使用括号表示法：
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Indexing starts at 0 in Python, so when we ask for the element at index 1, we
    get 2.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，索引从 0 开始，因此当我们请求索引为 1 的元素时，我们得到 2。
- en: 'We can also change the values in the list:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以更改列表中的值：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To access the elements from the end, we can use negative indices. For example,
    `-1` will get the last element, `-2`—the one before the last and so on:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要从末尾访问元素，我们可以使用负索引。例如，`-1` 将获取最后一个元素，`-2`——倒数第二个元素，依此类推：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we expect, it prints 13 11.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所期望的，它打印了 13 11。
- en: 'To add elements to the list, use the `append` function. It will append the
    element to the end of the list:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要向列表中添加元素，请使用 `append` 函数。它将元素添加到列表的末尾：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To iterate over the elements of a list, we use a `for` loop:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历列表中的元素，我们使用 `for` 循环：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we execute it, we see all the elements printed:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行它时，我们看到所有元素都被打印出来：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is also known as a `for-each` loop in other languages: we execute the
    body of the loop for each element of the collection. It doesn’t include the indices,
    only the elements themselves. If we also need to have access to the index of each
    element, we can use `range`, as we did previously:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这在其他语言中也称为 `for-each` 循环：我们为集合中的每个元素执行循环体。它不包含索引，只包含元素本身。如果我们还需要访问每个元素的索引，我们可以使用
    `range`，就像我们之前做的那样：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The function `len` returns the length of the list, so this code is roughly
    equivalent to the traditional way of traversing an array in C or Java and accessing
    each element by its index. When we execute it, the code prints the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `len` 返回列表的长度，因此此代码大致等同于在 C 或 Java 中以传统方式遍历数组并按索引访问每个元素。当我们执行它时，代码将打印以下内容：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A more “pythonic” (more common and idiomatic in the Python world) way of achieving
    the same thing is using the `enumerate` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同功能的一种更“Pythonic”（在 Python 世界中更常见和更符合习惯用法）的方法是使用 `enumerate` 函数：
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this code, the `i` variable will get the index, and the `n` variable, the
    respective element from the list. This code will produce the exact same output
    as the previous loop.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`i` 变量将获取索引，而 `n` 变量将获取列表中的相应元素。此代码将产生与上一个循环完全相同的输出。
- en: 'To concatenate multiple lists into one, we can use the plus operator. For example,
    consider two lists:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将多个列表连接成一个，我们可以使用加号运算符。例如，考虑两个列表：
- en: '[PRE39]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can create a third list that contains all the elements from `list1` followed
    by the elements from `list2` by concatenating the two lists:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过连接两个列表来创建一个包含 `list1` 中所有元素后跟 `list2` 中元素的第三个列表：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will produce the following list:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下列表：
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, it’s also possible to create a list of lists: a list whose elements
    are lists as well. To show that, let’s first create three lists with numbers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也可以创建一个列表的列表：一个其元素也是列表的列表。为了展示这一点，让我们首先创建三个包含数字的列表：
- en: '[PRE42]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now let’s put them together in another list:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将它们组合成另一个列表：
- en: '[PRE43]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now `lists` is a list of lists. When we iterate over it with a `for` loop,
    at each iteration we get a list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `lists` 是一个列表的列表。当我们使用 `for` 循环遍历它时，在每次迭代中我们都会得到一个列表：
- en: '[PRE44]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will produce the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE45]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Slicing
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 切片
- en: 'Another useful concept in Python is *slicing*—it’s used for getting a part
    of the list. For example, let’s consider the list of numbers again:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中另一个有用的概念是 *切片*——它用于获取列表的一部分。例如，让我们再次考虑数字列表：
- en: '[PRE46]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we want to select a sublist with the first three elements, we can use the
    colon operator (`:`) for specifying the range for selection:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想选择包含前三个元素的下标列表，我们可以使用冒号运算符（`:`）来指定选择范围：
- en: '[PRE47]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this case, `0:3` means “select elements starting from index 0 till index
    3 (exclusive).” The result contains the first three elements: `[1,` `2,` `3]`.
    Note that it selects elements at the indices 0, 1, and 2, so 3 is not included.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`0:3` 表示“从索引 0 开始选择元素，直到索引 3（不包括 3）。”结果包含前三个元素：`[1, 2, 3]`。请注意，它选择了索引为
    0、1 和 2 的元素，因此不包括 3。
- en: 'If we want to include the beginning of the list, we don’t need to specify the
    first number in the range:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想包含列表的开始部分，我们不需要指定范围中的第一个数字：
- en: '[PRE48]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we don’t specify the second number in the range, we get everything until
    the end of the list:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不指定范围中的第二个数字，我们将得到列表的剩余所有元素：
- en: '[PRE49]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The list `last3` will contain the last three elements: `[3,` `5,` `7]` (figure
    B.2).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 `last3` 将包含最后三个元素：`[3, 5, 7]`（图 B.2）。
- en: '![](../Images/B-02.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/B-02.png)'
- en: Figure B.2 Using the colon operator to select a sublist of a list
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.2 使用冒号运算符选择列表的子列表
- en: Tuples
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 元组
- en: 'We already met tuples previously in the Variables section. Tuples are also
    collections; they are quite similar to lists. The only difference is that they
    are immutable: once you create a tuple, you cannot change the content of the tuple.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在变量部分之前已经遇到过元组。元组也是集合；它们与列表非常相似。唯一的区别是它们是不可变的：一旦创建了一个元组，就不能更改元组的内容。
- en: 'To create a tuple we use parentheses:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组时使用括号：
- en: '[PRE50]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Like with lists, we can get the value by index:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，我们可以通过索引获取值：
- en: '[PRE51]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, we cannot update the values in the tuple. When we try to do it, we
    get an error:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法更新元组中的值。当我们尝试这样做时，我们会得到一个错误：
- en: '[PRE52]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we try to execute this code, we get
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行此代码，我们会得到
- en: '[PRE53]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Likewise, we cannot append a new element to the tuple. However, we can use
    concatenation to achieve the same result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们无法向元组中添加新元素。但是，我们可以使用连接来实现相同的结果：
- en: '[PRE54]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here we create a new tuple that contains the old numbers, and we concatenate
    it with another tuple that contains only one number: 17\. Note that we need to
    add a comma to make a tuple; otherwise Python will treat it as a simple number.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的元组，它包含旧数字，并将其与只包含一个数字（17）的另一个元组连接起来：17\. 注意，我们需要添加一个逗号来创建一个元组；否则，Python
    会将其视为一个简单的数字。
- en: Effectively, the expression on the previous page is the same as writing
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，上一页的表达式等同于以下写法
- en: '[PRE55]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After doing this, we get a new tuple that contains a new element, so when printing
    it, we get
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后，我们得到一个新的包含新元素的元组，因此当打印时，我们得到
- en: '[PRE56]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Set
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 集合
- en: 'Another useful collection is a *set* : it’s an unordered collection that keeps
    only unique elements. Unlike lists, it cannot contain duplicates, and it’s also
    not possible to access an individual element of a set by index.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的集合是*集合*：它是一个无序集合，只保留唯一元素。与列表不同，它不能包含重复项，并且也无法通过索引访问集合中的单个元素。
- en: 'To create a set, we use curly braces:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个集合，我们使用花括号：
- en: '[PRE57]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Note To create an empty set, we need to use `set`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要创建一个空集合，我们需要使用`set`：
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Simply putting empty curly braces will create a dictionary—a collection that
    we cover later in this appendix:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地放置空花括号将创建一个字典——这是一个我们在附录中稍后要讨论的集合：
- en: '[PRE59]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Sets are faster than lists for checking if the collection contains an element.
    We use the `in` operator for checking it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 集合在检查集合是否包含一个元素时比列表更快。我们使用`in`运算符进行检查：
- en: '[PRE60]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Since “1” is in the `numbers` set, this line of code will print `True`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“1”在`numbers`集合中，这一行代码将打印`True`。
- en: 'To add an element to the set, we use the `add` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要向集合中添加一个元素，我们使用`add`方法：
- en: '[PRE61]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To iterate over all the elements of the set we again use a `for` loop:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历集合中的所有元素，我们再次使用`for`循环：
- en: '[PRE62]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When we execute it, it prints
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行它时，它打印
- en: '[PRE63]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Dictionaries
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionary is another extremely useful collection in Python: we use it to build
    a key-value map. To create a dictionary, we use curly braces, and to separate
    the keys and values we use colons (`:`):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是 Python 中另一个极其有用的集合：我们使用它来构建键值映射。要创建字典，我们使用花括号，并使用冒号（`:`）分隔键和值：
- en: '[PRE64]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To retrieve the value by the key, we use brackets:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过键检索值，我们使用方括号：
- en: '[PRE65]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If something is not in the dictionary, Python raises an exception:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个元素不在字典中，Python 会引发异常：
- en: '[PRE66]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When we try to execute it, we get the following error:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试执行它时，我们得到以下错误：
- en: '[PRE67]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To avoid it, we can first check if the key is in the dictionary before attempting
    to get the value. We can use the `in` statement for checking it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免它，我们可以在尝试获取值之前先检查键是否在字典中。我们可以使用`in`语句进行检查：
- en: '[PRE68]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When running this code, we’ll see `not` `in` `the` `dictionary` in the output.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，我们将在输出中看到`not` `in` `the` `dictionary`。
- en: 'Another option is to use the `get` method. It doesn’t raise an exception, but
    returns `None` if the key is not present in the dictionary:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用`get`方法。它不会引发异常，但如果键不在字典中，则返回`None`：
- en: '[PRE69]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'It will print `None`. When using `get`, we can specify the default value in
    case the key is not present in the dictionary:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印`None`。当使用`get`时，我们可以指定默认值，以防键不在字典中：
- en: '[PRE70]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this situation, we’ll get `-1`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将得到`-1`。
- en: 'To iterate over all the keys of a dictionary, we use a `for` loop over the
    results from the `keys` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历字典中的所有键，我们使用`keys`方法的返回结果进行`for`循环：
- en: '[PRE71]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It will print
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印
- en: '[PRE72]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Alternatively, we can directly iterate over the key-value pairs in the dictionary
    using the `items` method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以直接使用`items`方法遍历字典中的键值对：
- en: '[PRE73]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It produces exactly the same output as the previous code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生的输出与之前的代码完全相同。
- en: List comprehension
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导
- en: 'List comprehension is a special syntax for creating and filtering lists in
    Python. Let’s again consider a list with numbers:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导是 Python 中创建和过滤列表的特殊语法。让我们再次考虑一个包含数字的列表：
- en: '[PRE74]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Suppose we want to create another list where all the elements of the original
    list are squared. For that we can use a `for` loop:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建另一个列表，其中包含原始列表中所有元素的平方。为此，我们可以使用`for`循环：
- en: '[PRE75]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can concisely rewrite this code into one single line using list comprehension:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表推导式简洁地重写此代码为单行：
- en: '[PRE76]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'It’s also possible to add an `if` condition inside to process only the elements
    that meet the condition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在其中添加一个`if`条件，以仅处理满足条件的元素：
- en: '[PRE77]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It translates to the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它等价于以下代码：
- en: '[PRE78]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If all we need is to apply the filter and leave the elements as is, we can
    do that as well:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要应用过滤器并保持元素不变，我们也可以这样做：
- en: '[PRE79]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This translates to
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于
- en: '[PRE80]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It’s also possible to use list comprehension for creating other collections
    with a slightly different syntax. For example, for dictionaries we put curly braces
    around the expression and use a colon to separate keys with values:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用列表推导来创建具有稍不同语法的其他集合。例如，对于字典，我们在表达式周围放置花括号，并使用冒号来分隔键和值：
- en: '[PRE81]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is a shortcut for the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对以下代码的快捷方式：
- en: '[PRE82]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Warning When learning about list comprehension, it might be tempting to start
    using it everywhere. Typically it fits best for simple cases, but for more complex
    situations, `for` loops should be preferred over list comprehension for better
    code readability. If in doubt, use `for` loops.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 当学习列表推导时，可能会诱使你开始到处使用它。通常它最适合简单情况，但对于更复杂的情况，为了更好的代码可读性，应优先使用`for`循环而不是列表推导。如果有疑问，请使用`for`循环。
- en: B.1.3 Code reusability
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.3 代码复用
- en: At some point, when we write a lot of code, we need to think about how to organize
    it better. We can achieve that by putting small reusable pieces of code inside
    functions or classes. Let’s take a look at how to do it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，当我们编写了大量代码时，我们需要考虑如何更好地组织它。我们可以通过将小块可重用代码放入函数或类中来实现这一点。让我们看看如何做到这一点。
- en: Functions
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: 'To create a function, we use the `def` keyword:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个函数，我们使用`def`关键字：
- en: '[PRE83]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When we want to exit the function and return some value, we use the `return`
    statement. If we simply put `return` without any value or don’t include `return`
    in the body of the function, the function will return `None`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要退出函数并返回某个值时，我们使用`return`语句。如果我们简单地放置`return`而不带任何值或在函数体中不包括`return`，则函数将返回`None`。
- en: 'For example, we can write a function that prints values from 0 up to a specified
    number:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个函数，该函数打印从0到指定数字的值：
- en: '[PRE84]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '❶ Create a function with one argument: max.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个带有一个参数的函数：max。
- en: ❷ Use the max argument inside the function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在函数内部使用max参数。
- en: 'To call this function, simply add the arguments in parentheses after the name:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此函数，只需在名称后添加括号内的参数：
- en: '[PRE85]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'It’s also possible to provide the names of the arguments when invoking the
    function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，也可以提供参数的名称：
- en: '[PRE86]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Classes
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: 'Classes provide higher-level abstraction than functions: they can have an internal
    state and methods that operate on this state. Let’s consider a class, `NumberPrinter`,
    that does the same thing as the function from the previous section—it prints numbers.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类比函数提供了更高层次的抽象：它们可以有一个内部状态和操作这个状态的方法。让我们考虑一个类，`NumberPrinter`，它和上一节中的函数做同样的事情——打印数字。
- en: '[PRE87]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ❶ The class initializer
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 类初始化器
- en: ❷ Assign the max argument to the max field.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将max参数分配给max字段。
- en: ❸ Method of the class
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 类的方法
- en: ❹ Use the internal state when invoking the method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在调用方法时使用内部状态。
- en: 'In this code, `__init__` is the initializer. It runs whenever we want to create
    an instance of a class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`__init__`是初始化器。每次我们想要创建类的实例时都会运行：
- en: '[PRE88]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Note that inside the class, the `__init__` method has two arguments: `self`
    and `max`. The first argument of all the methods always has to be `self`: this
    way we can use `self` inside the method to access the state of the object.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在类内部，`__init__`方法有两个参数：`self`和`max`。所有方法的第一参数始终必须是`self`：这样我们可以在方法内部使用`self`来访问对象的状态。
- en: 'However, when we invoke the method later, we don’t pass anything to the `self`
    argument: it’s hidden from us. So, when we invoke the `print_number` method on
    the instance of the `NumberPrinter` object, we simply put empty parentheses with
    no parameters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们稍后调用方法时，我们不需要向`self`参数传递任何内容：它对我们来说是隐藏的。因此，当我们对`NumberPrinter`对象的实例调用`print_number`方法时，我们只需简单地放置没有参数的空括号：
- en: '[PRE89]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This code produces the same output as the function from the previous section.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生的输出和上一节中的函数相同。
- en: Importing code
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 导入代码
- en: Now suppose we want to put some code to a separate file. Let’s create a file
    called useful_code.py and place it in the same folder as the notebook.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要将一些代码放入一个单独的文件中。让我们创建一个名为useful_code.py的文件，并将其放置在笔记本所在的同一文件夹中。
- en: 'Open this file with an editor. Inside the file, we can put the function and
    the class we just created. In this way, we create a module with the name `useful_code`.
    To access the function and the class inside the module, we import them using the
    `import` statement:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编辑器打开此文件。在文件内部，我们可以放置我们刚刚创建的函数和类。这样，我们创建了一个名为`useful_code`的模块。要访问模块内部的函数和类，我们使用`import`语句导入它们：
- en: '[PRE90]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Once it’s imported, we can use it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入，我们就可以使用它：
- en: '[PRE91]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'It’s also possible to import a module and give it a short name. For example,
    if instead of writing `useful_code` we want to write `uc`, we can do the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以导入一个模块并给它一个短名。例如，如果我们想用`uc`代替`useful_code`，我们可以这样做：
- en: '[PRE92]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This is a very common idiom in scientific Python. Packages like NumPy and Pandas
    are typically imported with shorter aliases:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在科学Python中一个非常常见的习语。像NumPy和Pandas这样的软件包通常使用较短的别名导入：
- en: '[PRE93]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, if we don’t want to import everything from the module, we can choose
    what exactly to import using `from` `...` `import` syntax:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们不想从模块中导入所有内容，我们可以使用`from ... import`语法选择确切要导入的内容：
- en: '[PRE94]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: B.1.4 Installing libraries
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.4 安装库
- en: It’s possible to put our code into packages that are available to everyone.
    For example, NumPy or Pandas are such packages. They are already available in
    the Anaconda distribution, but typically they don’t come pre-installed with Python.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的代码放入对每个人可用的软件包中。例如，NumPy或Pandas就是这样的软件包。它们已经在Anaconda发行版中可用，但通常它们不会与Python预先安装。
- en: 'To install such external packages, we can use the built-in package installer
    called pip. To use it, open your terminal and execute the `pip` `install` command
    there:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这样的外部软件包，我们可以使用内置的软件包安装器pip。要使用它，打开您的终端并执行那里的`pip install`命令：
- en: '[PRE95]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'After the install command, we list the packages we want to install. It’s also
    possible to specify the version of each package when installing:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装命令之后，我们列出我们想要安装的软件包。在安装时，也可以指定每个软件包的版本：
- en: '[PRE96]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'When we already have a package, but it’s outdated and we want to update it,
    we need to run `pip` `install` with the `-U` flag:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们已经有了一个软件包，但它已经过时，我们想要更新它时，我们需要运行带有`-U`标志的`pip install`：
- en: '[PRE97]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, if we want to remove a package, we use `pip` `uninstall`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想要删除一个软件包，我们使用`pip uninstall`：
- en: '[PRE98]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: B.1.5 Python programs
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.5 Python程序
- en: 'To execute Python code, we can simply call the Python interpreter and specify
    the file we want to execute. For example, to run the code inside our useful_code.py
    script, execute the following command in the command line:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行Python代码，我们可以简单地调用Python解释器并指定我们想要执行的文件。例如，要运行`useful_code.py`脚本中的代码，在命令行中执行以下命令：
- en: '[PRE99]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When we execute it, nothing happens: we only declare a function and a class
    there and don’t actually use them. To see some results, we need to add a few lines
    of code to the file. For example, we can add the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行它时，没有任何事情发生：我们只是在其中声明了一个函数和一个类，实际上并没有使用它们。为了看到一些结果，我们需要在文件中添加几行代码。例如，我们可以添加以下内容：
- en: '[PRE100]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Now when we execute this file, we see the numbers that `NumberPrinter` prints.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们执行这个文件时，我们看到`NumberPrinter`打印的数字。
- en: However, when we import a module, internally Python executes everything inside
    the module. It means that the next time we do `import` `useful_code` in the notebook,
    we’ll see the numbers printed there.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们导入一个模块时，Python内部会执行模块内的所有内容。这意味着下次我们在笔记本中执行`import useful_code`时，我们会看到那里打印的数字。
- en: 'To avoid it, we can tell the Python interpreter that some code needs to run
    only when executed as a script, and not imported. To achieve that, we put our
    code inside the following construction:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们可以告诉Python解释器某些代码只有在作为脚本执行时才需要运行，而不是导入。为了实现这一点，我们将我们的代码放在以下构造中：
- en: '[PRE101]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, we can also pass arguments when running python scripts:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也可以在运行Python脚本时传递参数：
- en: '[PRE102]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '❶ Parse the parameter as an integer: by default, it’s a string.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将参数解析为整数：默认情况下，它是一个字符串。
- en: ❷ Pass the parsed argument to the NumberPrinter instance.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将解析的参数传递给NumberPrinter实例。
- en: 'Now we can run the script with custom parameters:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用自定义参数运行脚本：
- en: '[PRE103]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'As a result, we’ll see numbers from `0` to `5`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们会看到从`0`到`5`的数字：
- en: '[PRE104]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
