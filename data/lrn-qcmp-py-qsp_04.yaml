- en: 3 Sharing secrets with quantum key distribution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 使用量子密钥分发共享秘密
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Recognizing the implications of quantum resources for security
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识量子资源对安全性的影响
- en: Programming a Python simulator for a quantum key distribution protocol
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程Python模拟量子密钥分发协议
- en: Implementing the quantum NOT operation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现量子非操作
- en: In the previous chapter, we started playing around with qubits and used them
    to build a quantum random number generator with a simulator that we built in Python.
    In this chapter, we see that qubits can help us with encryption (or other cryptographic
    tasks) by letting us securely *distribute* secret keys. There are classical methods
    for sharing random keys (e.g., RSA), but they have different guarantees about
    the security of the sharing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始尝试使用量子位，并用它们在Python中构建了一个量子随机数生成器。在这一章中，我们看到量子位可以通过让我们安全地*分发*密钥来帮助我们进行加密（或其他加密任务）。有经典的方法来共享随机密钥（例如，RSA），但它们对共享安全性的保证各不相同。
- en: 3.1 All’s fair in love and encryption
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 爱情和加密无所不能
- en: We have a quantum random number generator from chapter 2, but that’s only half
    of what we need to share secrets with our friends. We need to share those random
    numbers with our friends if we want to use the quantum random numbers to communicate
    securely with them. Those random numbers (often called a *key*) can be used with
    *encryption* algorithms that combine the randomness of the key with information
    people want to keep secret in such a way that only someone else with the key can
    see the information. We can see in figure 3.1 how two people could use a key (here,
    a random binary string) to encrypt and decrypt messages between themselves.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章中有一个量子随机数生成器，但这只是我们与朋友共享秘密所需的一半。如果我们想使用量子随机数与朋友安全通信，我们需要与他们共享这些随机数。这些随机数（通常称为*密钥*）可以与*加密*算法结合使用，该算法将密钥的随机性与人们想要保密的信息结合起来，这样只有拥有密钥的人才能看到信息。我们可以在图3.1中看到两个人如何使用密钥（这里是一个随机二进制字符串）来加密和解密他们之间的消息。
- en: '![](../Images/3-1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-1.png)'
- en: Figure 3.1 Mental model for how we and Eve might use encryption to communicate
    secretly, even over the internet or another untrusted network
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 我们和Eve可能如何使用加密来秘密通信的思维模型，即使是在互联网或其他不受信任的网络中
- en: If we want to get qubits involved, we can show that using *quantum key distribution
    (QKD)* is *provably* secure, whereas classical key distribution methods are often
    *computationally* secure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想涉及量子位，我们可以证明使用*量子密钥分发（QKD）*是*可证明*安全的，而经典密钥分发方法通常是*计算安全*的。
- en: Definition *Quantum key distribution* (QKD) is a communication protocol that
    allows users to share quantum random numbers by exchanging qubits and authenticated
    classical information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *量子密钥分发*（QKD）是一种通信协议，允许用户通过交换量子位和经过身份验证的经典信息来共享量子随机数。
- en: This difference doesn’t matter for most use cases. But if we are a government,
    activist group, bank, journalist, spy, or any other entity where information security
    is a life-and-death matter, this is a huge deal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异对于大多数用例来说并不重要。但如果我们是一个政府、活动团体、银行、记者、间谍或其他任何信息安全是生死攸关的实体，这可就大不相同了。
- en: Computational vs. provable security
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计算安全与可证明安全
- en: 'Provable security for cryptographic protocols is the dream. A method or protocol
    for a cryptographic task is *provably secure* if we can write a proof showing
    it is secure using no assumptions about an adversary: i.e., that they can have
    all the time and computing power in the universe and our protocol is still secure!
    Most of our current cryptographic infrastructure is *computationally secure*,
    which guarantees the security of a method or protocol with reasonable assumptions
    about an adversary’s capabilities. The designer or user of the protocol can choose
    thresholds for what finite computer resources look like (e.g., the largest current
    supercomputer or all the computers on the planet) and what a reasonable time is
    (100 years, 10,000 years, the age of the universe).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 加密协议的可证明安全性是梦想。如果一个加密任务的某个方法或协议可以通过不假设任何关于对手的证明来证明其安全性：即，他们可以拥有宇宙中所有的时间和计算能力，而我们的协议仍然安全！我们当前的加密基础设施大多是*计算安全*的，这保证了在对手能力合理假设下的方法或协议的安全性。协议的设计者或使用者可以选择阈值，例如（例如，最大的当前超级计算机或地球上所有的计算机）以及什么是一个合理的时间（100年，10000年，宇宙的年龄）。
- en: When we share a key using QKD, it does not guarantee that the key will get to
    the other person. This is because someone can always do a denial of service attack
    (such as cutting the optical fiber between sender and receiver), which is the
    same for any other classical protocol. A good analogy for what QKD can promise
    is similar to the tamper-proof seal on food products. When a peanut butter manufacturer
    wants to ensure that when we open the jar, it is exactly as it was when it left
    the factory floor, the company puts a tamper-proof seal on the container. The
    company makes a promise that if the seal makes it to us (the consumer) intact,
    the peanut butter is good and no third party has done anything to it. Transmitting
    a cryptographic key with a QKD protocol is like putting a tamper-proof seal on
    the bits in transit. If someone tries to compromise the key in transit, the receiver
    will know and won’t use that key. However, sealing the bits in transit does *not*
    guarantee that the bits make it to the receiver.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用QKD共享密钥时，并不能保证密钥会到达对方。这是因为有人总是可以进行拒绝服务攻击（例如切断发送者和接收者之间的光纤），这对任何其他经典协议都是一样的。QKD可以承诺的一个好类比是食品产品上的防篡改封条。当花生酱制造商想要确保当我们打开罐子时，它正好是我们离开工厂时的样子，公司就会在容器上贴上防篡改封条。公司承诺，如果封条完好无损地到达我们（消费者），那么花生酱就是好的，没有第三方对其进行过任何篡改。使用QKD协议传输加密密钥就像在传输中的比特上贴上防篡改封条。如果有人试图在传输中破坏密钥，接收者会知道，并且不会使用那个密钥。然而，在传输中封印比特并不能保证比特会到达接收者。
- en: We can use many protocols to implement the general QKD scheme. In this chapter,
    we will be working with one of the most common QKD protocols—BB84—but there are
    many others that we won’t have time to get into. Throughout this chapter, we build
    up to this, but figure 3.2 shows the steps to the BB84 protocol.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用许多协议来实现通用的QKD方案。在本章中，我们将使用最常用的QKD协议之一——BB84，但还有许多其他协议我们没有时间深入探讨。在本章中，我们将逐步构建到这一点，但图3.2显示了BB84协议的步骤。
- en: '![](../Images/3-2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-2.png)'
- en: Figure 3.2 Timing diagram for the BB84 protocol, a variant of a QKD protocol
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 BB84协议的时序图，QKD协议的一个变体](../Images/3-2.png)'
- en: QKD is an example of a quantum program that uses a single qubit and a spin-off
    technology from quantum computing. What makes it attractive to develop is that
    we already have the hardware to implement it today! A number of companies have
    been commercially selling QKD hardware for about 15 years, but the important next
    steps for the technology involve hardware and software security vetting of these
    systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: QKD是一个使用单个量子比特和量子计算衍生技术的量子程序示例。它吸引我们去开发的原因是我们今天已经有硬件来实现它了！一些公司已经商业销售QKD硬件大约15年了，但技术的重要下一步涉及对这些系统的硬件和软件安全审查。
- en: Warning The examples we are implementing and using in this book *simulate* provably
    secure protocols. Given that we are not running the examples on quantum devices,
    they are *not* provably secure. Even when implementing these protocols with real
    quantum hardware, these security proofs do nothing to stop side-channel attacks
    or social engineering from separating us from our key ![](../Images/emoji-devil.png).
    We talk more about these proofs later in this chapter when we discuss the no-cloning
    theorem.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：本书中我们实现和使用的是*模拟*可证明安全协议的例子。鉴于我们没有在量子设备上运行这些例子，它们*不是*可证明安全的。即使使用真实的量子硬件实现这些协议，这些安全证明也无法阻止侧信道攻击或社会工程学使我们与我们的密钥分离![恶魔表情](../Images/emoji-devil.png)。我们将在本章后面讨论无克隆定理时更多地讨论这些证明。
- en: 'Let’s dive into how QKD works! For our purposes, let’s say we and Eve are the
    two people from the previous chapter who want to exchange a key so we can send
    secret messages ![](../Images/emoji-hearteye.png). The scenario is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解QKD是如何工作的！为了我们的目的，让我们假设我们和伊芙是上一章中想要交换密钥以便发送秘密信息的两个人！![爱心眼表情](../Images/emoji-hearteye.png)。场景如下：
- en: We wish to send a secret message to our friend. Using our quantum random number
    generator from chapter 2, the QKD protocol BB84, and one-time pad encryption,
    design a program to send messages that can be provably secure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向我们的朋友发送一个秘密信息。使用第二章中的量子随机数生成器、BB84量子密钥分发协议和一次性密码加密，设计一个程序来发送可以证明是安全的消息。
- en: We can visualize the scenario as a kind of timing diagram, like figure 3.3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将场景可视化为一种时序图，就像图3.3所示。
- en: '![](../Images/3-3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-3.png)'
- en: 'Figure 3.3 The scenario for this chapter: sending a secret message to Eve with
    BB84 and one-time pad encryption. We first have to exchange a secret key with
    Eve so we can use it to encrypt the message we want to send. We can use qubits
    and superposition states to help with the key-exchange step!'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 本章场景：使用BB84和一次性密码加密向Eve发送秘密信息。我们首先必须与Eve交换一个秘密密钥，以便我们可以用它来加密我们想要发送的消息。我们可以使用量子比特和叠加态来帮助进行密钥交换步骤！
- en: Note that the key we need to send is a string of classical bits. How can we
    use qubits to send those classical bits? We start by seeing how to encode classical
    information in qubits and then learn the specific steps of the BB84 protocol.
    In the next section, we’ll look at a new quantum operation that will help us encode
    classical bits with qubits.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要发送的密钥是一串经典比特。我们如何使用量子比特来发送这些经典比特？我们首先看看如何将经典信息编码在量子比特中，然后学习BB84协议的具体步骤。在下一节中，我们将探讨一个新的量子操作，它将帮助我们使用量子比特编码经典比特。
- en: 3.1.1 Quantum NOT operations
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 量子非操作
- en: 'If we have some classical information, say a single binary bit, how can we
    encode it with a quantum resource like a qubit? Take a look at the following algorithm
    for sending a random classical bit string encoded in qubits:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有某些经典信息，比如说一个单一的二进制比特，我们如何使用量子资源（如量子比特）来编码它？看看以下算法，用于发送编码在量子比特中的随机经典比特字符串：
- en: Use a quantum random number generator to generate a random key bit to send.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用量子随机数生成器生成要发送的随机密钥比特。
- en: Start with a qubit in the |0〉 state and then prepare it in a state that represents
    that bit value from step 1\. Here, use |0〉 if the classical bit was a 0 and |1〉
    if the classical bit was a 1.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个|0〉状态的量子比特开始，然后将其准备成表示第1步中比特值的态。在这里，如果经典比特是0，则使用|0〉；如果经典比特是1，则使用|1〉。
- en: That prepared qubit is sent to Eve, who then measures it and records the classical
    bit value.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个准备好的量子比特被发送给Eve，然后她测量它并记录经典比特值。
- en: Repeat steps 1–3 until we and Eve have as much key as we want (usually dictated
    by the cryptographic protocol we want to use after).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1-3，直到我们和Eve拥有我们想要的密钥量（通常由我们想要使用的加密协议决定）。
- en: Figure 3.4 shows a timing diagram for this algorithm.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4显示了此算法的时序图。
- en: '![](../Images/3-4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-4.png)'
- en: Figure 3.4 A visualization of the algorithm for sending a classical bit string
    with qubits. We start by using our QRNG to generate a classical bit value, encode
    that on a fresh qubit, and then send it to Eve. She can then measure it and record
    the classical measurement result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4展示了使用量子比特发送经典比特字符串的算法。我们首先使用我们的量子随机数生成器生成一个经典比特值，将其编码在一个新的量子比特上，然后将其发送给Eve。她可以测量它并记录经典测量结果。
- en: Now, to switch the qubit from |0〉 to |1〉, we need another quantum operation
    in our toolbox. In step 2, we can use a *quantum* NOT operation—which is similar
    to a classical NOT operation—that rotates the qubit from |0〉 to |1〉 (see figure
    2.9).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将量子比特从|0〉切换到|1〉，我们需要工具箱中的另一个量子操作。在第2步中，我们可以使用一个*量子*非操作——它类似于经典非操作——将量子比特从|0〉旋转到|1〉（见图2.9）。
- en: We refer to this quantum NOT operation as the `x` operation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此量子非操作称为`x`操作。
- en: Definition The `x` operation or *quantum NOT* takes a qubit in the |0〉 state
    to the |1〉 state and vice versa.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：`x`操作或*量子非*将|0〉状态的量子比特转换到|1〉状态，反之亦然。
- en: '![](../Images/3-5.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-5.png)'
- en: Figure 3.5 A visualization of the quantum equivalent of a NOT operation operating
    on a qubit in the |0〉 state, leaving the qubit in the |1〉 state
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5展示了在|0〉状态的量子比特上操作的非操作的量子等效，使量子比特处于|1〉状态。
- en: 'Step 2 can be rewritten as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步可以重写如下：
- en: If our classical bit from step 1 was a 0, do nothing. If it was a 1, apply a
    quantum NOT operation (aka `x` operation) to our qubit.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第1步中的经典比特是0，则不执行任何操作。如果它是1，则对我们的量子比特应用量子非操作（也称为`x`操作）。
- en: This algorithm works 100% of the time because when Eve measures the qubit she
    receives, the |0〉 and |1〉 states can be perfectly distinguished with a measurement
    in the *Z*-axis. It may seem like we and Eve have done a lot of work just to share
    some random classical bits, but we will see how adding some quantum behaviors
    to this basic protocol will make it more useful! Let’s look at how we could implement
    this in code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法100%有效，因为当Eve测量她收到的量子比特时，|0〉和|1〉状态可以通过在*Z*-轴上的测量完美地区分。这似乎意味着我们和Eve做了很多工作，只是为了分享一些随机的经典比特，但我们将看到如何添加一些量子行为到这个基本协议中，使其更有用！让我们看看我们如何在代码中实现这一点。
- en: 'Listing 3.1 qkd.py: exchanging classical bits via qubits'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 qkd.py：通过量子比特交换经典比特
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ To prepare our qubit with the classical bit we want to send, we need as input
    the bit value and a qubit to use. This function does not return anything because
    the consequences of the operations we apply to our qubit are tracked in the single-qubit
    simulator.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为了用我们想要发送的经典比特来准备我们的量子比特，我们需要输入比特值和要使用的量子比特。这个函数不返回任何内容，因为我们应用到的量子比特的操作后果是在单量子比特模拟器中跟踪的。
- en: ❷ If we’re sending a 1, we can use the NOT operation x to prepare q in the |1〉
    state because the x operation will rotate |0〉 to |1〉 and vice versa.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果我们发送一个1，我们可以使用NOT操作x来准备处于 |1〉 状态的量子比特，因为x操作将 |0〉 旋转到 |1〉，反之亦然。
- en: ❸ It seems silly to separate measuring as another function, given its one line.
    But we will change how Eve measures the qubit in the future, so this is a helpful
    setup.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将测量作为另一个函数分开似乎有点愚蠢，因为它的代码只有一行。但我们将改变Eve未来如何测量量子比特，所以这是一个有用的设置。
- en: ❹ We can check that measuring q gives the same classical bit we sent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们可以检查测量q是否给出了我们发送的相同经典比特。
- en: 'The simulator we wrote in the previous chapter *almost* has what we need to
    implement this. We just need to add an instruction corresponding to the `x` operation.
    The `x` instruction can be represented with a matrix *x*, just as we represented
    the `h` instruction using the matrix *H*. In the same way we wrote *H* in chapter
    2, we can write the matrix *X* as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章编写的模拟器几乎已经具备了实现这一功能所需的一切。我们只需要添加一个对应于`x`操作的指令。`x`指令可以用矩阵 *x* 来表示，就像我们用矩阵
    *H* 表示`h`指令一样。同样地，我们在第2章中写*H*的方式，我们可以写出矩阵 *X* 如下：
- en: '![](../Images/equation_3-1.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![方程式3-1](../Images/equation_3-1.png)'
- en: 'Exercise 3.1: Truth tables and matrices'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.1：真值表和矩阵
- en: In chapter 2, we saw that unitary matrices play the same role in quantum computing
    that *truth tables* play in classical computing. We can use that to figure out
    what the matrix *X* has to look like to represent the quantum NOT operation, `x`.
    Let’s start by making a table of what the matrix *X* has to do to each input state
    to represent what the `x` instruction does.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们看到了单位矩阵在量子计算中扮演的角色与*真值表*在经典计算中扮演的角色相同。我们可以利用这一点来找出矩阵 *X* 应该是什么样子才能表示量子NOT操作，`x`。让我们首先制作一个表格，说明矩阵
    *X* 需要对每个输入状态做什么，以表示`x`指令的作用。
- en: '| Input | Output |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 输出 |'
- en: '| &#124;0〉 | &#124;1〉 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| &#124;0〉 | &#124;1〉 |'
- en: '| &#124;1〉 | &#124;0〉 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| &#124;1〉 | &#124;0〉 |'
- en: This table tells us that if we multiply the matrix *x* by the vector |0〉, we
    need to get |1〉, and similarly that *X* |1〉 = |0〉.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格告诉我们，如果我们用矩阵 *x* 乘以向量 |0〉，我们需要得到 |1〉，同样地，*X* |1〉 = |0〉。
- en: Either by using NumPy or by hand, check that the matrix
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要么使用NumPy，要么手动检查矩阵
- en: '![](../Images/equation_3-1K.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![方程式3-1K](../Images/equation_3-1K.png)'
- en: matches what we have in the previous truth table.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前真值表中的内容相匹配。
- en: Exercise solutions
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 练习解答
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所有练习题的解答都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需进入你所在章节的文件夹，然后打开提及练习解答的Jupyter笔记本。
- en: 'Let’s go on and add the functionality we need to our simulator to run listing
    3.1\. We will be working with the simulator we wrote in the previous chapter,
    but if you need a refresher, you can find the code in the GitHub repo for this
    book: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    First, we need to update our quantum device’s interface by adding a new method
    our qubit must have.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加我们需要的功能到我们的模拟器，以便运行列表3.1。我们将使用上一章中编写的模拟器，但如果你需要复习，可以在本书的GitHub仓库中找到代码：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。首先，我们需要通过添加一个新方法来更新我们的量子设备接口，这个新方法我们的量子比特必须具备。
- en: 'Listing 3.2 interface.py: adding `x` to the qubit interface'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 interface.py：向量子比特接口添加`x`
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ We can model implementing the quantum NOT operation after the *h* operation
    from chapter 1.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以模仿第1章中的*h*操作来实现量子NOT操作。
- en: Now that our interface for a qubit knows that we want an implementation of the
    `x` operation, let’s add that implementation!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们量子比特的接口知道我们想要实现`x`操作，让我们添加这个实现！
- en: 'Listing 3.3 simulator.py: adding `x` to the qubit simulator'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 simulator.py：向量子比特模拟器添加`x`
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Adds a variable X to store the matrix *X* that we need to represent the x
    operation
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加一个变量X来存储我们需要表示x操作的矩阵*X*
- en: ❷ Just like the h function, we want to implement the quantum operation x by
    applying the matrix stored in X to the state vector.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 正如h函数一样，我们希望通过应用存储在X中的矩阵来执行量子操作x。
- en: 3.1.2 Sharing classical bits with qubits
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 与量子比特共享经典比特
- en: Awesome! Let’s try out using our upgraded Python qubit simulator to share a
    secret classical bit with a qubit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们尝试使用我们升级的Python量子比特模拟器来使用量子比特共享一个秘密经典比特。
- en: Note In the code we will be writing for this chapter, the qubits we and Eve
    share live in the same simulated device. This might make it awkward to think about
    *sending* qubits to each other if we both are using the same device! In reality,
    our devices would be using *photons* (single particles of light) as qubits, and
    those are really easy to send in optical fibers or through the air with telescopes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在我们将要编写的本章代码中，我们和爱娃共享的量子比特生活在同一个模拟设备中。如果我们都使用同一个设备，那么考虑互相“发送”量子比特可能会有些尴尬！在现实中，我们的设备将使用*光子*（光的单个粒子）作为量子比特，这些光子通过光纤或通过望远镜在空中发送是非常容易的。
- en: This is not yet quite the same as a quantum key distribution protocol, but it
    serves as a good foundation for the types of functions and steps that our end
    goal QKD protocol has.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不完全等同于量子密钥分发协议，但它为我们最终目标QKD协议中的函数和步骤提供了一个良好的基础。
- en: Open an IPython session where we keep the code for our simulator by running
    `ipython` in our terminal. After importing the Python files, create an instance
    of the single-qubit simulator and generate a random bit to use as the classical
    bit to send. (Good thing we have a quantum random number generator!) Using a fresh
    qubit, prepare it based on the classical bit value we want to send Eve. Eve then
    measures the qubit, and we can see if we both have the same classical bit value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个IPython会话，我们在终端中运行`ipython`以保存模拟器的代码。在导入Python文件后，创建一个单量子比特模拟器的实例，并生成一个随机比特作为要发送的经典比特。
    (幸好我们有量子随机数发生器！) 使用一个新鲜的量子比特，根据我们想要发送给爱娃的经典比特值来准备它。然后爱娃测量量子比特，我们可以看到我们是否具有相同的经典比特值。
- en: Listing 3.4 Sending classical bits with a single-qubit simulator
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 使用单量子比特模拟器发送经典比特
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ We need a simulated qubit to use for our QRNG.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们需要一个模拟量子比特来用于我们的QRNG。
- en: ❷ Reusing the qrng function that we wrote in chapter 2, we can generate a random
    classical bit to use for our key.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 重新使用我们在第二章中编写的qrng函数，我们可以生成一个随机经典比特作为我们的密钥。
- en: ❸ We’ll are using a new qubit simulator instance here for the key exchange,
    but strictly speaking, we don’t need to. We’ll see in chapter 4 how to expand
    the simulator to work with multiple qubits.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在这里，我们使用一个新的量子比特模拟器实例来进行密钥交换，但严格来说，我们并不需要这样做。在第4章中，我们将看到如何扩展模拟器以支持多个量子比特。
- en: ❹ We encode our classical bit in the qubit provided by qkd_simulator. If the
    classical bit was a 0, we do nothing to qkd_simulator; and if the classical bit
    was a 1, we use the x method to change the qubit to the |1〉 state.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们将我们的经典比特编码在qkd_simulator提供的量子比特中。如果经典比特是0，我们对qkd_simulator不做任何操作；如果经典比特是1，我们使用x方法将量子比特改变到|1〉状态。
- en: ❺ Eve measures the qubit from qkd_simulator and then stores the bit value as
    eve_measurement.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 爱娃测量qkd_simulator中的量子比特，然后将比特值存储为eve_measurement。
- en: Our example of secret sharing with qubits should be deterministic, which is
    to say that every time we’ll prepare and send a bit, Eve will correctly measure
    the same value. Is this secure? If you suspect it is not secure, you are definitely
    onto something. In the next section, we’ll discuss the security of our prototype
    secret-sharing scheme and look at ways to improve it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用量子比特进行秘密共享的示例应该是确定性的，也就是说，每次我们准备和发送一个比特时，爱娃都会正确地测量相同的值。这是安全的吗？如果你怀疑它不安全，你肯定抓住了问题的关键。在下一节中，我们将讨论我们原型秘密共享方案的安全性，并探讨改进它的方法。
- en: 3.2 A tale of two bases
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 两个基的故事
- en: We and Eve now have a way to send classical bits using qubits, but what happens
    if an adversary gets hold of that qubit? They could use the `measure` instruction
    to get the same classical data that Eve does. That’s a huge problem and would
    reasonably make us wonder why anyone would use qubits to share keys in the first
    place.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们和爱娃现在有了使用量子比特发送经典比特的方法，但如果一个对手掌握了那个量子比特怎么办？他们可以使用`measure`指令获取与爱娃相同的经典数据。这是一个大问题，合理地让我们质疑为什么有人一开始会用量子比特来共享密钥。
- en: Fortunately, quantum mechanics offers a way to make this exchange more secure!
    What are some modifications we could make to our protocol? For instance, we could
    represent a classical “0” message with a qubit in the |+〉 state and a “1” message
    with a qubit in the |−〉 state.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，量子力学提供了一种使这种交换更加安全的方法！我们可以在我们的协议中做出哪些修改？例如，我们可以用一个处于|+〉状态的量子比特来表示经典“0”消息，用一个处于|−〉状态的量子比特来表示“1”消息。
- en: 'Listing 3.5 qkd.py: encoding the message with |+〉 / |−〉 states'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 qkd.py：使用|+〉 / |−〉状态编码消息
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Everything before this line of prepare_classical_message_plusminus is the
    same as before with prepare_classical_message. Applying the Hadamard gate at this
    point rotates the |0〉 / |1〉 states to |+〉 / |−〉 states.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在此行`prepare_classical_message_plusminus`之前的所有内容与`prepare_classical_message`相同。在此处应用Hadamard门将|0〉
    / |1〉状态旋转到|+〉 / |−〉状态。
- en: ❷ Uses the h operation to rotate our |+〉 / |−〉 states back to the |0〉 / |1〉
    states because our measure operation is defined to only measure the |0〉 / |1〉
    states correctly
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用h操作将我们的|+〉 / |−〉状态旋转回|0〉 / |1〉状态，因为我们的测量操作只定义了正确测量|0〉 / |1〉状态。
- en: Tip Another way of thinking about the measurement in listing 3.5 is that we
    are rotating the measurement to match the basis we are currently working in (|+〉
    / |−〉). It’s all a matter of perspective!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：关于基的复习，请参阅附录C。
- en: Now we have two different ways of sending qubits that we and Eve could use when
    sending qubits (see table 3.1 for a summary). We call these two different ways
    of sending messages *bases*, and each contains two completely distinguishable
    (orthogonal) states. This is similar to appendix C, where we look at map directions
    (such as North and West) that define a convenient *basis* for describing directions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两种不同的发送量子比特的方式，我们和Eve可以在发送量子比特时使用（见表3.1的总结）。我们称这两种不同的消息发送方式为*基*，每个都包含两个完全可区分（正交）的状态。这与附录C中我们查看的地图方向（如北和西）类似，这些方向定义了一个方便的*基*来描述方向。
- en: Table 3.1 Different classical messages we want to send, and how to encode them
    in the *Z**-* and *X**-*bases
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 我们想要发送的不同经典消息以及如何在*Z**-*和*X**-*基中编码它们
- en: '|  | “0” message | “1” message |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  | “0”消息 | “1”消息 |'
- en: '| **“0” (or** *Z* **) basis** | &#124;0〉 | &#124;1〉 = *X* &#124;0〉 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **“0” (或** *Z* **) 基** | &#124;0〉 | &#124;1〉 = *X* &#124;0〉 |'
- en: '| **“1” (or** *X***) basis** | &#124;+〉 = *H* &#124;0〉 | &#124;−〉 = *H* &#124;1〉
    = *HX*&#124;0〉 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **“1” (或** *X***) 基** | &#124;+〉 = *H* &#124;0〉 | &#124;−〉 = *H* &#124;1〉
    = *HX*&#124;0〉 |'
- en: Tip For a refresher on bases, see appendix C.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：关于基的复习，请参阅附录C。
- en: We have used the |0〉 and |1〉 states as one basis (called the *Z*-basis) and
    |+〉 and |−〉 as another (called the *X*-basis). The names for these bases refer
    to the axis along which we can perfectly distinguish the states (see figure 3.6).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用|0〉和|1〉状态作为一组基（称为*Z*基），使用|+〉和|−〉作为另一组（称为*X*基）。这些基的名称指的是我们可以完美区分状态的轴（见图3.6）。
- en: '![](../Images/3-6.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图3-6](../Images/3-6.png)'
- en: Figure 3.6 Now, in addition to using the *Z*-basis to encode a classical bit
    on a qubit, we can use the *X*-basis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 现在，除了使用*Z*基在量子比特上编码经典比特外，我们还可以使用*X*基。
- en: Note In quantum computing, there is never really a *correct* basis as much as
    there are convenient bases that we choose to use by convention.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在量子计算中，实际上并没有真正的*正确*基，更多的是我们根据惯例选择使用的方便基。
- en: 'If neither we nor Eve knows which way of sending we are using for a particular
    bit, we both have a problem. What happens if we mix sending our messages in the
    *Z*-basis and *X*-basis? Good news: we can use our simulator to try it and see
    what happens.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们和Eve都不知道我们使用的是哪种发送方式，我们都会遇到问题。如果我们混合在*Z*基和*X*基中发送消息会发生什么？好消息是，我们可以使用我们的模拟器来尝试并看看会发生什么。
- en: Listing 3.6 Exchanging bits but not using the same basis
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 交换比特但不使用相同的基
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Uses the method we saw before to prepare our qubit in the *Z*-basis by using
    the hmethod
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用我们之前看到的方法，通过使用hmethod在我们的量子比特上准备*Z*基。
- en: ❷ Eve measures in the *X* -basis because she does a Hadamard gate on her qubit
    before measuring.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Eve在*X*基下测量，因为她测量之前在她自己的量子比特上做了Hadamard门。
- en: ❸ The function does not return anything, so if we and Eve end up with key bits
    that don’t match, it will raise an error.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 函数不返回任何内容，所以如果我们和Eve最终得到不匹配的密钥比特，它将引发错误。
- en: Running the previous code, we can see that if we send in the *Z*-basis and Eve
    measures in the *X*-basis, we may not wind up with matching classical bits at
    the end.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码，我们可以看到，如果我们发送的是*Z*基，而Eve测量的是*X*基，我们最终可能不会得到匹配的经典比特。
- en: Listing 3.7 Sending in the *Z* -basis; measuring in the *X*-basis
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 在*Z*基上发送；在*X*基上测量
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ We picked our bit value as 0\. You may have to run this line a few times before
    you get the error.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将比特值设为0。你可能需要运行这条命令几次才能得到错误信息。
- en: You can try this out experimentally. You will find that you get the `AssertionError`
    (the key exchange failed) about half of the time. Why is that? To start with,
    Eve is measuring in the *X*-basis, so she can only tell |+〉 and |−〉 apart perfectly.
    What will she measure if she is not given a perfectly distinguishable state for
    her basis (as in this case, where she is given a |0〉)? We can write the |0〉 state
    in the *X*-basis as
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试通过实验来验证这一点。你会发现大约一半的时间你会得到`AssertionError`（密钥交换失败）。为什么会这样？首先，爱娃是在*X*-基上测量的，因此她可以完美地区分|+〉和|−〉。如果她没有得到一个可以完美区分的基状态（就像在这个例子中，她得到了|0〉），她会测量什么？我们可以将|0〉状态在*X*-基上表示为
- en: '![](../Images/equation_3-3.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_3-3.png)'
- en: Recall that in chapter 2, we defined |+〉 in a similar way by adding together
    |0〉 and |1〉. The |+〉 state is also called a *superposition* of the |0〉 and |1〉
    states.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在第2章中，我们以类似的方式定义了|+〉，即通过将|0〉和|1〉相加。|+〉状态也被称为|0〉和|1〉状态的**叠加**。
- en: Note Any time a state can be written as a linear combination of states like
    this, it is considered a superposition of the states that are added together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：任何可以写成这种状态线性组合的状态，都被认为是所加状态的叠加。
- en: 'Exercise 3.2: Verifying that |0〉 is a superposition of |+〉 and |−〉'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.2：验证|0〉是|+〉和|−〉的叠加
- en: 'Try using what you learned about vectors in the previous chapter to verify
    that |0〉 = (|+〉 + |−〉) / √2, either by hand or by using Python. Hint: recall that
    |+〉 = (|0〉 + |1〉) / √2 and that |−〉 = (|0〉 − |1〉) / √2.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你在上一章学到的关于向量的知识来验证|0〉 = (|+〉 + |−〉) / √2，无论是手动还是使用Python。提示：回想一下|+〉 = (|0〉
    + |1〉) / √2以及|−〉 = (|0〉 − |1〉) / √2。
- en: 'Now to calculate the actual measurement with Born’s rule from chapter 2\. Recall
    that we can calculate the probability of a measurement outcome by measuring a
    particular state with the following expression:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要使用第2章中的Born规则来计算实际的测量。回想一下，我们可以通过以下表达式计算测量结果的概率：
- en: Pr(measurement|state) = |〈measurement | state〉|²
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Pr(测量|状态) = |〈测量 | 状态〉|²
- en: 'Writing out the measurement of the |0〉 state in the *X*-basis, we can see that
    we will get 0 (or |+〉) half of the time and 1 (or |−〉) the other half:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将|0〉状态在*X*基上的测量写出来，我们可以看到我们将有一半的时间得到0（或|+〉），另一半的时间得到1（或|−〉）：
- en: '![](../Images/equation_3-5.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_3-5.png)'
- en: 'Exercise 3.3: Measuring qubits in different bases'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.3：在不同基上测量量子比特
- en: Using the previous example as a guide,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以之前的例子为指南，
- en: Calculate the probability of getting the measurement outcome |−〉 when measuring
    the |0〉 state in the |−〉 direction.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算在|−〉方向测量|0〉状态时得到测量结果|−〉的概率。
- en: Also calculate the probability of getting the |−〉 measurement outcome with the
    input state of |1〉.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要计算输入状态为|1〉时得到|−〉测量结果的概率。
- en: That tells us that if Eve does not know the right basis to measure in, then
    the measurements she makes are as good as random guesses. This is because, in
    the wrong basis, the qubit is in a superposition of the two states that define
    the basis. One “key” to how QKD works is that without the right additional information
    (the basis the qubit is encoded in), any measurement of the qubit is basically
    useless. To ensure our security, we have to make it difficult for an adversary
    to learn that extra information to know the right basis to measure in. The QKD
    protocol we’ll look at next has a solution for this and a proof (out of scope
    here) that describes the chance that the attacker has any information about the
    key!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，如果爱娃不知道正确的测量基，那么她所做的测量就像随机猜测一样。这是因为，在错误的基上，量子比特处于定义基的两个状态的叠加中。QKD工作原理的一个“关键”是，没有正确的附加信息（量子比特编码的基），任何对量子比特的测量基本上都是无用的。为了确保我们的安全，我们必须让对手难以获得额外的信息，以便知道正确的测量基。我们接下来要讨论的QKD协议为此提供了一个解决方案，以及一个证明（此处不涉及）来描述攻击者对密钥有任何信息的可能性！
- en: '3.3 Quantum key distribution: BB84'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 量子密钥分发：BB84
- en: We have now seen how to share keys in two different bases and what happens if
    we and Eve don’t use the same basis. Again, you might ask why we use this approach
    to make sharing the key to our secret keys more secure. There are a wide variety
    of different QKD protocols, each with specific advantages and use cases (not unlike
    RPG character classes). The most *common* protocol for QKD is called BB84, named
    for an appropriately cryptic encoding of the two authors’ initials and the year
    the protocol was published (Bennet and Brassard 1984).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何在两个不同的基中共享密钥，以及如果我们和Eve没有使用相同的基会发生什么。再次，你可能会问为什么我们使用这种方法来使共享我们的秘密密钥更加安全。有各种各样的不同QKD协议，每个都有其特定的优点和用例（与RPG角色职业类似）。QKD最**常见**的协议被称为BB84，以两位作者首字母的适当隐晦编码和协议发布的年份（Bennet和Brassard
    1984）命名。
- en: BB84 is very similar to what we have worked out so far to share keys but has
    a critical difference in how we and Eve choose our bases. In BB84, both parties
    choose their basis randomly (and independently), which means they will end up
    using the same basis 50% of the time. Figure 3.7 shows the steps of the BB84 protocol.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: BB84与我们迄今为止为共享密钥所做的工作非常相似，但在我们和Eve选择基的方式上有关键的区别。在BB84中，双方都随机（且独立）选择他们的基，这意味着他们将有50%的时间使用相同的基。图3.7显示了BB84协议的步骤。
- en: As a consequence of randomly choosing bases, we and Eve also have to communicate
    over authenticated classical channels (like the internet) to each take our key
    and transform it into a key that we believe is identical to the key our partner
    has. That’s because this is real life, and when the qubits are exchanged, it will
    be possible for both the environment and third-party individuals to manipulate
    or modify the state of the qubit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随机选择基，我们和Eve还必须在认证的经典信道（如互联网）上通信，以便各自将我们的密钥转换成我们相信与我们的合作伙伴相同的密钥。这是因为这是现实生活，当量子比特交换时，环境和第三方个人都有可能操纵或修改量子比特的状态。
- en: Key expansion
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥扩展
- en: 'We glossed over one detail in our description of the classical communication
    channel we and Eve are using: it must be *authenticated*. That is, when we send
    classical messages to Eve as part of running BB84, it’s OK if someone else can
    read them, but we need to make sure it’s really Eve that we’re talking to. To
    prove that someone wrote and sent a particular message, we actually *already*
    need some form of shared secret that we can use to validate the other person’s
    identity. So we must already have a shared secret with the other person in BB84\.
    This secret can be smaller than the message we’re trying to send, so BB84 is technically
    more of a *key expansion* protocol.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述我们和Eve使用的经典通信通道的细节中，我们忽略了一个细节：它必须**认证**。也就是说，当我们作为运行BB84的一部分向Eve发送经典消息时，如果其他人能读到它们是可以的，但我们需要确保我们确实是在和Eve交谈。为了证明有人编写并发送了特定的消息，我们实际上**已经**需要某种形式的共享秘密，我们可以用它来验证对方的身份。因此，在BB84中，我们必须已经与对方有一个共享秘密。这个秘密可以比我们试图发送的消息小，所以BB84在技术上更是一种**密钥扩展**协议。
- en: '![](../Images/3-7.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-7.png)'
- en: Figure 3.7 The steps in the BB84 protocol, a particular version of a QKD protocol
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 BB84协议的步骤，一种特定的QKD协议
- en: 'The steps of the BB84 protocol are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: BB84协议的步骤如下：
- en: Choose a random one-bit message to send by sampling our QRNG.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过采样我们的QRNG选择一个随机的一位消息发送。
- en: We and Eve each choose a random basis with our respective QRNG (no communication
    between them).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们和Eve各自使用各自的量子随机数发生器（QRNG）选择一个随机基（它们之间没有通信）。
- en: Prepare a qubit in the randomly selected basis representing our randomly selected
    message (see table 3.2).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随机选择的基中准备一个量子比特，代表我们随机选择的消息（见表3.2）。
- en: Send our prepared qubit in the quantum channel to Eve.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们准备好的量子比特通过量子信道发送给Eve。
- en: Eve measures the qubit when it arrives, performing the measurement in her randomly
    selected basis and recording the classical bit outcome.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eve在量子比特到达时对其进行测量，在随机选择的基中进行测量，并记录经典比特结果。
- en: Communicate with Eve on an authenticated classical channel, and share which
    bases we used to prepare and measure the qubit. If they match, keep the bit and
    add it to the key. Repeat steps 1–6 until we have as much key as we need.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在认证的经典信道上与Eve通信，并共享我们用于准备和测量量子比特的基。如果它们匹配，保留比特并将其添加到密钥中。重复步骤1-6，直到我们拥有所需的密钥量。
- en: Table 3.2  What state we should send for each random message and basis choice
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2  对于每个随机消息和基选择我们应该发送什么状态
- en: '|  | “0” message | “1” message |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  | “0”消息 | “1”消息 |'
- en: '| **“0” (or** *Z***) basis** | &#124;0〉 | &#124;1〉 = *X* &#124;0〉 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **“0” (或 *Z*) 基底** | &#124;0〉 | &#124;1〉 = *X* &#124;0〉 |'
- en: '| **“1” (or** *X***) basis** | &#124;+〉 = *H* &#124;0〉 | &#124;−〉 = *H* &#124;1〉
    = *H X* &#124;0〉 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **“1” (或 *X*) 基底** | &#124;+〉 = *H* &#124;0〉 | &#124;−〉 = *H* &#124;1〉 =
    *H X* &#124;0〉 |'
- en: An error-free world
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无错误的世界
- en: Since we are simulating the BB84 protocol, we know that the qubit Eve receives
    will be exactly the same as what we sent. BB84 more realistically will be done
    in batches where *n* qubits are exchanged first, followed by a round of sharing
    the basis values (error correction happens). At the end, we have to shrink the
    key even further with privacy amplification algorithms to account for the fact
    that an eavesdropper could have gotten partial information from the errors we
    detected. We omitted these steps in our implementation of BB84 to keep things
    simple, but they *are* critical for real-world security ![](../Images/emoji-happyface.png).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在模拟 BB84 协议，我们知道伊芙收到的量子位将与我们发送的完全相同。BB84 更现实的做法是分批进行，首先交换 *n* 个量子位，然后进行一轮共享基底值（错误纠正发生）。最后，我们必须使用隐私放大算法进一步缩小密钥，以考虑到窃听者可能已经从我们检测到的错误中获得了部分信息。我们在
    BB84 的实现中省略了这些步骤以保持简单，但它们对于现实世界的安全性是至关重要的 ![emoji-happyface.png](../Images/emoji-happyface.png)。
- en: Let’s jump in and implement the BB84 QKD protocol in Python! We will start by
    writing a function that will run the BB84 protocol (assuming lossless transmission)
    for a single-bit transmission. That does not guarantee that we get one key bit
    from this run. However, if we and Eve choose different bases, that exchange will
    have to be thrown out.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现 Python 中的 BB84 QKD 协议！我们将从编写一个函数开始，该函数将运行 BB84 协议（假设无损传输）以进行单比特传输。这并不保证我们从这次运行中获得一个密钥比特。然而，如果我们和伊芙选择不同的基底，那次交换将不得不被丢弃。
- en: First, it helps to set up some functions that will simplify how we write out
    the full BB84 protocol. We and Eve need to do things like sample random bits and
    prepare and measure the message qubit, separated here for clarity.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置一些函数有助于简化我们编写完整 BB84 协议的方式。我们和伊芙需要做一些像采样随机比特和准备以及测量信息量子位的事情，这里分开来以增加清晰度。
- en: 'Listing 3.8 bb84.py: helper functions before the key exchange'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 bb84.py：密钥交换之前的辅助函数
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ sample_random_bit is almost the same as our qrng function before, except here
    we will reset the qubit after measuring as we know we want to be able to use it
    more than once.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ sample_random_bit 函数几乎与我们的 qrng 函数相同，只是在这里，我们在测量后会重置量子位，因为我们知道我们希望能够多次使用它。
- en: ❷ The qubit is encoded with the key bit value in the randomly selected basis.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 量子位被编码在随机选择的基底中的密钥比特值。
- en: ❸ Similar to sample_random_bit after Eve measures the message qubit, she should
    reset it because in the simulator, we will reuse it for the next exchange.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与 Eve 测量信息量子位后的 sample_random_bit 类似，她应该重置它，因为在模拟器中，我们将重用它进行下一次交换。
- en: ❹ To help condense the display of long binary keys, a helper function converts
    the representation to a shorter hex string.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为了帮助压缩长二进制密钥的显示，一个辅助函数将表示转换为更短的十六进制字符串。
- en: 'Listing 3.9 bb84.py: BB84 protocol for sending a classical bit'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 bb84.py：发送经典比特的 BB84 协议
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '❶ We can randomly choose a bit value and basis using our modified QRNG from
    before: here, the sample_random_bit function.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以使用之前修改过的 QRNG 随机选择比特值和基底：这里，sample_random_bit 函数。
- en: ❷ Eve needs to randomly choose a basis with her own qubit, which is why she
    is using a separate QuantumDevice.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 伊芙需要随机选择一个与她的量子位相对应的基，这就是她为什么使用一个单独的 QuantumDevice 的原因。
- en: ❸ With all the preparation done, prepares our qubit to send to Eve
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 准备好所有准备工作后，准备发送给伊芙的量子位。
- en: ❹ Since all the computation happens inside a simulator on our computer, nothing
    needs to be done to “send” the qubit from us to Eve.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 由于所有计算都在我们计算机上的模拟器内部进行，因此不需要对我们从我们到伊芙“发送”量子位进行任何操作。
- en: ❺ Now Eve has our qubit and measures it in the randomly selected basis she chose
    earlier.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 现在，伊芙有了我们的量子位，并按照她之前选择的随机基底对其进行测量。
- en: ❻ Returns the key bit values and bases we and Eve would have at the end of this
    one round
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回我们和伊芙在这一轮结束时将拥有的密钥比特值和基底。
- en: Qubits and no-cloning
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 量子位和无克隆定理
- en: 'From what we’ve seen so far, it seems like our adversary could cheat by eavesdropping
    on the qubits in the quantum channel and making copies. Here’s how: the eavesdropper
    (called Bob here) first would need to (without detection):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们迄今为止所看到的情况来看，我们的对手似乎可以通过监听量子通道中的量子位并复制它们来进行欺骗。以下是方法：窃听者（在这里称为 Bob）首先需要（不被发现）：
- en: Copy qubits as they are being sent between us and Eve, and then store them.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们和伊芙之间发送量子位时复制量子位，然后存储它们。
- en: While we and Eve finish the classical part of the protocol, listen to the bases
    we both announce and keep track of ones we both chose the same.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我和Eve完成协议的经典部分时，要听我们双方宣布的基，并跟踪我们双方选择相同的基。
- en: For the qubits corresponding to bits where we and Eve used the same basis, measure
    the copies of the qubits in the same basis as well.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们和Eve使用相同基的比特对应的量子比特，也要测量这些量子比特的副本，使用相同的基。
- en: 'Ta-da! We, and Eve, *and* Bob would all have the same key! If you think this
    seems like a problem, you are right. Don’t worry, though; quantum mechanics has
    the solution. It turns out the problem with Bob’s plan is in step 1, where he
    needs to make *identical* copies of the qubits we and Eve are exchanging. The
    good news is that making an exact copy of a qubit without knowing what it is beforehand
    is forbidden by quantum mechanics. The rule that qubits cannot be identically
    copied without prior knowledge of the state is called the *no-cloning theorem*
    and is stated as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们、Eve和Bob都会拥有相同的密钥！如果你认为这好像是个问题，你是对的。不过，不用担心；量子力学有解决方案。结果是Bob的计划问题出在第一步，他需要制作**相同**的量子比特副本。好消息是，在不知道量子比特状态的情况下，量子力学禁止制作精确的副本。量子比特不能在没有先验知识的情况下被完全复制的规则被称为**不可克隆定理**，其表述如下：
- en: '*No quantum operation can perfectly copy the state of an arbitrary qubit onto
    another qubit*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有任何量子操作可以完美地将任意量子比特的状态复制到另一个量子比特上**。'
- en: '![](../Images/3-unnumb.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-unnumb.png)'
- en: The no-cloning theorem visualized
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化的不可克隆定理
- en: We will be able to do the simple proof of this in the next chapter, once we
    learn how to describe the state of more than one qubit ![](../Images/emoji-happyface.png).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章学习如何描述多个量子比特的状态后，能够简单地证明这一点！![表情](../Images/emoji-happyface.png)。
- en: As an alternative way of thinking about the no-cloning theorem, if Bob could
    measure a qubit without disturbing it, he could get around needing a copy of the
    qubits he intercepts. This is not possible because once we measure a qubit, it
    “collapses” or changes in a way that Eve could detect as additional noise in the
    measurement results she collects from her qubits. Thus, measuring in transit is
    not something Bob can do without being detected, so his eavesdropping is doomed
    to fail.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对不可克隆定理的另一种思考方式，如果Bob能够在不干扰量子比特的情况下测量它，他就可以绕过需要复制他截获的量子比特的需求。这是不可能的，因为一旦我们测量一个量子比特，它就会“坍缩”或以Eve能够检测到的方式改变，这会作为额外的噪声出现在她从她的量子比特收集的测量结果中。因此，在传输过程中测量是不可能的，Bob无法在不被发现的情况下进行窃听，所以他的窃听注定会失败。
- en: Exchanging one classical key bit will not be sufficient to send a whole key,
    so now we need to use the earlier technique to send multiple bits.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 交换一个经典密钥比特不足以发送整个密钥，因此现在我们需要使用之前的技术来发送多个比特。
- en: 'Listing 3.10 bb84.py: BB84 protocol for exchanging a key with Eve'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 bb84.py：与Eve交换密钥的BB84协议
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ At this point, we and Eve can publicly announce the bases we each used to
    measure this bit. If everything worked right, our results should agree whenever
    our bases agree. We check that here with an assert.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这一点上，我和Eve可以公开宣布我们各自用来测量这个比特的基。如果一切正常，我们的结果应该在基相同时一致。我们在这里使用assert来检查。
- en: The key is now in the bag, so we can move on to using the key and the one-time
    pad encryption algorithm to send a secret message!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在密钥已经到手，我们可以继续使用密钥和一次性密码加密算法来发送秘密消息！
- en: 3.4 Using a secret key to send secret messages
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 使用密钥发送秘密消息
- en: We and Eve have sorted out how to use the BB84 protocol to share a random, binary
    key generated by a QRNG. The last step is using this key to share a secret message
    with Eve. We and Eve previously decided that the best encryption protocol to use
    is a one-time pad to send our secret messages. This turns out to be one of the
    most secure encryption protocols, and given that we are sharing keys in one of
    the most secure ways possible, it makes sense to keep up that standard!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们和Eve已经解决了如何使用BB84协议来共享由QRNG生成的随机二进制密钥。最后一步是使用这个密钥与Eve共享秘密消息。我们和Eve之前决定使用最好的加密协议是一次性密码来发送我们的秘密消息。这实际上是最安全的加密协议之一，鉴于我们是以可能的最安全方式共享密钥，保持这一标准是有意义的！
- en: 'For example, to tell Eve that we like Python, the message we want to send is
    “![](../Images/emoji-three.png)”. Since we are using a binary key, we need to
    convert the representation of our Unicode message to binary, which is the following
    lengthy list of bits:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要告诉爱娃我们喜欢 Python，我们想要发送的消息是“![](../Images/emoji-three.png)”。由于我们使用的是二进制密钥，我们需要将我们的
    Unicode 消息表示转换为二进制，下面是一长串的比特列表：
- en: '"1101100000111101 1101110010010110 1101100000111101 1101110000001101 1101100000111101
    1101110010111011"'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"1101100000111101 1101110010010110 1101100000111101 1101110000001101 1101100000111101
    1101110010111011"'
- en: This binary representation of the message is our *message text*, and now we
    want to combine that with a key to get a ciphertext that is safe to send over
    the network. Once we have the key from the BB84 protocol (at least as long as
    our message), we need to use a one-time pad encryption scheme to encode our message.
    We saw this encryption technique in chapter 2; see figure 3.8 for a quick refresher.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息的二进制表示是我们的*消息文本*，现在我们想要将其与密钥结合，以获得一个安全发送到网络上的密文。一旦我们从 BB84 协议中获得密钥（至少与我们的消息一样长），我们需要使用一次性密码加密方案来编码我们的消息。我们在第
    2 章中看到了这种加密技术；见图 3.8 以快速复习。
- en: '![](../Images/3-8.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-8.png)'
- en: Figure 3.8 An example of one-time pad encryption, which uses random bits to
    encrypt secret messages
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 使用随机比特加密秘密消息的一次性密码加密示例
- en: To implement this, we need to use a classical bitwise XOR (the `^` operator
    in Python) to combine the message and our key to create the ciphertext that we
    can safely send to Eve. To decrypt our message, Eve will do the same bitwise XOR
    operation with the ciphertext and her key (which should be the same as yours).
    This will give her back the message because any time we XOR a bit string with
    another one twice, we are left with the original bit string. Here is what this
    would look like in Python.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要使用经典的按位异或（Python 中的 `^` 运算符）将消息和我们的密钥结合，以创建我们可以安全发送给爱娃的密文。为了解密我们的消息，爱娃将使用相同的按位异或操作对密文和她的密钥（应该是你的密钥）进行操作。这将使她恢复消息，因为每次我们将比特字符串与另一个字符串进行两次异或操作时，我们都会得到原始的比特字符串。以下是
    Python 中的示例。
- en: 'Listing 3.11 bb84.py: BB84 protocol for exchanging a key with Eve'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 bb84.py：与爱娃交换密钥的 BB84 协议
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ The ^ operator is a bitwise XOR in Python. This applies a single bit of our
    key as a one-time pad to our message text.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Python 中，^ 运算符是按位异或。这会将我们的密钥的单个比特作为一次性密码应用于我们的消息文本。
- en: 'Exercise 3.4: One-time pad encryption'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.4：一次性密码加密
- en: If we had the ciphertext `10100101` and the key `00100110`, what message was
    originally sent?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有密文 `10100101` 和密钥 `00100110`，原始发送的消息是什么？
- en: Let’s put it all together and share the message (“![](../Images/emoji-three.png)”)
    with Eve by running the bb84.py file we have been building up.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些放在一起，通过运行我们一直在构建的 bb84.py 文件，与爱娃分享消息（“![](../Images/emoji-three.png)”）。
- en: 'Listing 3.12 bb84.py: using BB84 and one-time pad encryption'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 bb84.py：使用 BB84 和一次性密码加密
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 3.13 Running the full solution to the chapter scenario
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 运行章节场景的完整解决方案
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Since our basis and Eve’s basis will agree roughly half the time, it should
    take about two rounds of BB84 for each bit of key we want to generate.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于我们的基和爱娃的基大约有一半的时间会一致，因此生成每个密钥位大约需要两轮 BB84。
- en: ❷ The exact key we generate will be different every time we run the BB84 simulation—that’s
    a huge part of the point of the protocol, after all!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每次运行 BB84 模拟时生成的确切密钥都会不同——这实际上是协议的一个很大部分！
- en: ❸ The message we get by writing down each of the Unicode code points for “![](../Images/emoji-three.png)”
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过写下“![](../Images/emoji-three.png)”的每个 Unicode 代码点得到的消息
- en: ❹ When we combine our secret message with the key we got earlier, using the
    key as a one-time pad, our message is scrambled.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当我们将我们的秘密消息与之前获得的密钥结合，使用密钥作为一次性密码时，我们的消息会被打乱。
- en: ❺ When Eve uses the same key, she gets back our original secret message.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当爱娃使用相同的密钥时，她会收到我们原始的秘密消息。
- en: Quantum key distribution is one of the most important spin-off technologies
    from quantum computing and has the potential to make a huge impact on our security
    infrastructure. While it is currently quite easy to set up QKD for parties that
    are relatively close to each other (around 200 km or less), there are significant
    challenges to deploying a global system for QKD. Usually, the physical system
    used in QKD is a photon, and it is hard to send single particles of light long
    distances without losing them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 量子密钥分发是量子计算最重要的衍生技术之一，并有可能对我们的安全基础设施产生巨大影响。虽然目前对于相对较近的各方（大约200公里或更短距离）来说，设置QKD相当容易，但在部署全球QKD系统方面存在重大挑战。通常，QKD中使用的物理系统是光子，在没有丢失的情况下很难发送单光子长距离。
- en: Now that we have built up a single-qubit simulator and programmed some single-qubit
    applications, we are ready to start playing around with multiple qubits. In the
    next chapter, we’ll take the simulator we have built and add features to simulate
    multiple qubit states and play nonlocal games with Eve ![](../Images/emoji-sparklingheart.png).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个单量子比特模拟器并编写了一些单量子比特应用程序，我们准备开始与多个量子比特进行实验。在下一章中，我们将对我们构建的模拟器添加功能，以模拟多个量子比特的状态，并与爱娃玩非局域游戏
    ![爱心表情](../Images/emoji-sparklingheart.png)。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Quantum key distribution is a protocol that allows us to randomly generate shared
    keys that we can use to communicate securely and privately.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子密钥分发是一种协议，它允许我们随机生成共享密钥，我们可以使用这些密钥来安全且私密地进行通信。
- en: When measuring qubits, we can do so in different *bases*; if we measure in the
    same basis that we prepare our qubits in, the results will be deterministic, while
    if we measure in different bases, the results will be random.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测量量子比特时，我们可以在不同的**基**中进行测量；如果我们测量与我们准备量子比特相同的基，结果将是确定的，而如果我们测量不同的基，结果将是随机的。
- en: The no-cloning theorem guarantees that eavesdroppers can’t guess the right basis
    to measure in without causing the key distribution protocol to fail.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可克隆定理保证了窃听者无法在不使密钥分发协议失败的情况下猜测正确的测量基。
- en: Once we have used QKD to share a key, we can use the key with a classical algorithm
    called a *one-time pad* to send data securely.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们使用量子密钥分发（QKD）来共享密钥，我们就可以使用这个密钥与一个称为**一次性密码**的经典算法来安全地发送数据。
