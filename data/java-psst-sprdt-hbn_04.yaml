- en: 3 Domain models and metadata
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 领域模型和元数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing the CaveatEmptor example application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍CaveatEmptor示例应用程序
- en: Implementing the domain model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现领域模型
- en: Examining object/relational mapping metadata options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象/关系映射元数据选项
- en: The “Hello World” example in the previous chapter introduced you to Hibernate,
    Spring Data, and JPA, but it isn’t useful for understanding the requirements of
    real-world applications with complex data models. For the rest of the book, we’ll
    use a much more sophisticated example application—CaveatEmptor, an online auction
    system—to demonstrate JPA, Hibernate, and later Spring Data. (*Caveat emptor*
    means “Let the buyer beware.”)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的“Hello World”示例介绍了Hibernate、Spring Data和JPA，但它对于理解具有复杂数据模型的现实世界应用程序的需求并不有用。在本书的其余部分，我们将使用一个更复杂的示例应用程序——CaveatEmptor，一个在线拍卖系统——来展示JPA、Hibernate以及稍后的Spring
    Data。（*Caveat emptor*意味着“让买家小心。”）
- en: Major new features in JPA 2
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2中的主要新功能
- en: A JPA persistence provider now integrates automatically with a Bean Validation
    provider. When data is stored, the provider automatically validates constraints
    on persistent classes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JPA持久化提供程序现在可以自动与Bean Validation提供程序集成。当数据存储时，提供程序会自动验证持久化类上的约束。
- en: The `Metamodel` API has also been added. You can obtain the names, properties,
    and mapping metadata of the classes in a persistence unit.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Metamodel` API也已添加。你可以获取持久单元中类的名称、属性和映射元数据。'
- en: We’ll start our discussion of the CaveatEmptor application by introducing its
    layered application architecture. Then you’ll learn how to identify the business
    entities of a problem domain. You’ll create a conceptual model of these entities
    and their attributes, called a *domain model*, and you’ll implement it in Java
    by creating persistent classes. We’ll spend some time exploring exactly what these
    Java classes should look like and where they fit within a typical layered application
    architecture. We’ll also look at the persistence capabilities of the classes and
    at how this influences the application’s design and implementation. We’ll add
    Bean Validation, which will help you to automatically verify the integrity of
    the domain model data—both the persistent information and the business logic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过对CaveatEmptor应用程序的分层应用架构进行介绍来开始对其的讨论。然后，你将学习如何识别问题域的业务实体。你将创建这些实体及其属性的概念模型，称为*领域模型*，并通过创建持久化类在Java中实现它。我们将花一些时间探讨这些Java类应该是什么样子，以及它们在典型的分层应用架构中的位置。我们还将查看这些类的持久化能力以及这对应用程序的设计和实现有何影响。我们还将添加Bean
    Validation，这将帮助你自动验证领域模型数据的完整性——包括持久化信息和业务逻辑。
- en: We’ll then explore some mapping metadata options—the ways you tell Hibernate
    how the persistent classes and their properties relate to database tables and
    columns. This can be as simple as adding annotations directly in the Java source
    code of the classes or writing XML documents that you eventually deploy along
    with the compiled Java classes that Hibernate accesses at runtime.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨一些映射元数据选项——这些选项是告诉Hibernate持久化类及其属性如何与数据库表和列相关联的方式。这可以简单到直接在类的Java源代码中添加注解，或者编写你最终与Hibernate在运行时访问的编译Java类一起部署的XML文档。
- en: After reading this chapter, you’ll know how to design the persistent parts of
    your domain model in complex real-world projects and what mapping metadata option
    you’ll primarily prefer to use. Let’s start with the example application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你将了解如何在复杂现实世界项目中设计领域模型的持久化部分，以及你将主要偏好使用的映射元数据选项。让我们从示例应用程序开始。
- en: 3.1 The example CaveatEmptor application
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 示例CaveatEmptor应用程序
- en: The CaveatEmptor example is an online auction application that demonstrates
    ORM techniques, JPA, Hibernate, and Spring Data functionality. We won’t pay much
    attention to the user interface in this book (it could be web-based or a rich
    client); we’ll concentrate instead on the data access code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CaveatEmptor示例是一个在线拍卖应用程序，它展示了ORM技术、JPA、Hibernate和Spring Data功能。在这本书中，我们不会过多关注用户界面（它可能是基于Web的或富客户端）；相反，我们将专注于数据访问代码。
- en: To understand the design challenges involved in ORM, let’s pretend the CaveatEmptor
    application doesn’t yet exist and that we’re building it from scratch. Let’s start
    by looking at the architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解ORM中涉及的设计挑战，让我们假设CaveatEmptor应用程序尚不存在，并且我们从零开始构建它。让我们首先看看架构。
- en: 3.1.1 A layered architecture
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 分层架构
- en: With any nontrivial application, it usually makes sense to organize classes
    by concern. Persistence is one concern; others include presentation, workflow,
    and business logic. A typical object-oriented architecture includes layers of
    code that represent these concerns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何非平凡的应用程序，通常按关注点组织类是有意义的。持久性是一个关注点；其他包括表示、工作流和业务逻辑。典型的面向对象架构包括代表这些关注点的代码层。
- en: Cross-cutting concerns
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 跨切面关注点
- en: There are also so-called *cross-cutting concerns*, which may be implemented
    generically, such as by framework code. Typical cross-cutting concerns include
    logging, authorization, and transaction demarcation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在所谓的*跨切面关注点*，这些关注点可以通过框架代码等通用方式实现。典型的跨切面关注点包括日志记录、授权和事务划分。
- en: 'A layered architecture defines interfaces between the code that implements
    the various concerns, allowing changes to be made to the way one concern is implemented
    without significant disruption to code in the other layers. Layering determines
    the kinds of inter-layer dependencies that occur. The rules are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构定义了实现各种关注点的代码之间的接口，允许在不显著干扰其他层代码的情况下更改一个关注点的实现方式。分层决定了层间依赖的类型。规则如下：
- en: Layers communicate from top to bottom. A layer is dependent only on the interface
    of the layer directly below it.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层从上到下进行通信。一个层只依赖于直接位于其下方的层的接口。
- en: Each layer is unaware of any other layers except for the layer just below it
    and eventually of the layer above if it receives explicit requests from it.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个层除了直接位于其下方的层之外，对任何其他层都一无所知，如果它收到来自该层的显式请求，最终也会知道位于其上方的层。
- en: 'Different systems group concerns differently, so they define different layers.
    The typical, proven, high-level application architecture uses three layers: one
    each for presentation, business logic, and persistence, as shown in figure 3.1.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的系统按不同的方式分组关注点，因此它们定义了不同的层。典型的、经过验证的、高级应用程序架构使用三个层：每个层分别用于表示、业务逻辑和持久性，如图3.1所示。
- en: '![](../../OEBPS/Images/CH03_F01_Tudose2.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F01_Tudose2.png)'
- en: Figure 3.1 A persistence layer is the basis of a layered architecture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 持久层是分层架构的基础。
- en: '*Presentation layer*—The user interface logic is topmost. Code responsible
    for the presentation and control of page and screen navigation is in the presentation
    layer. The user interface code may directly access business entities of the shared
    domain model and render them on the screen, along with controls to execute actions.
    In some architectures, business entity instances might not be directly accessible
    by user interface code, such as when the presentation layer isn’t running on the
    same machine as the rest of the system. In such cases, the presentation layer
    may require its own special data-transfer model, representing only a transmittable
    subset of the domain model. A good example of the presentation layer is working
    with a browser to interact with an application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表示层*—用户界面逻辑是最顶层的。负责页面和屏幕导航的表示和控制代码位于表示层。用户界面代码可以直接访问共享领域模型中的业务实体，并在屏幕上渲染它们，同时提供执行动作的控件。在某些架构中，业务实体实例可能无法直接由用户界面代码访问，例如当表示层不在与系统其他部分相同的机器上运行时。在这种情况下，表示层可能需要自己的特殊数据传输模型，仅表示领域模型的可传输子集。表示层的良好例子是与浏览器一起交互以与应用程序进行交互。'
- en: '*Business layer*—The business layer is generally responsible for implementing
    any business rules or system requirements that are part of the problem domain.
    This layer usually includes some kind of controlling component—code that knows
    when to invoke which business rule. In some systems, this layer has its own internal
    representation of the business domain entities. Alternatively, it may rely on
    a domain model implementation that’s shared with the other layers of the application.
    A good example of the business layer is the code responsible for executing the
    business logic.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*业务层*—业务层通常负责实现任何属于问题域的业务规则或系统需求。此层通常包括某种控制组件——知道何时调用哪个业务规则的代码。在某些系统中，此层有自己的业务领域实体的内部表示。或者，它可能依赖于与应用程序其他层共享的领域模型实现。业务层的良好例子是负责执行业务逻辑的代码。'
- en: '*Persistence layer*—The persistence layer is a group of classes and components
    responsible for storing data to, and retrieving it from, one or more data stores.
    This layer needs a model of the business domain entities for which you’d like
    to keep a persistent state. The persistence layer is where the bulk of JPA, Hibernate,
    and Spring Data use takes place.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持久层*——持久层是一组负责将数据存储到、从一个或多个数据存储中检索数据的类和组件。此层需要一个模型来表示你希望保持持久状态的业务领域实体。持久层是JPA、Hibernate和Spring
    Data大量使用的地方。'
- en: '*Database*—The database is usually external. It’s the actual persistent representation
    of the system state. If an SQL database is used, the database includes a schema
    and possibly stored procedures for the execution of business logic close to the
    data. The database is the place where data is persisted for the long term.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库*——数据库通常是外部的。它是系统状态的实际持久表示。如果使用SQL数据库，数据库包括模式，以及可能用于在数据附近执行业务逻辑的存储过程。数据库是数据长期持久化的地方。'
- en: '*Helper and utility classes*—Every application has a set of infrastructural
    helper or utility classes that are used in every layer of the application. These
    may include general-purpose classes or cross-cutting concern classes (for logging,
    security, and caching). These shared infrastructural elements don’t form a layer
    because they don’t obey the rules for inter-layer dependency in a layered architecture.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*辅助和实用类*——每个应用程序都有一组基础设施辅助或实用类，这些类在应用程序的每一层都被使用。这些可能包括通用类或横切关注类（如日志记录、安全和缓存）。这些共享的基础设施元素不构成一层，因为它们不遵循分层架构中层间依赖的规则。'
- en: Now that we have a high-level architecture, we can focus on the business problem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了高级架构，我们可以专注于业务问题。
- en: 3.1.2 Analyzing the business domain
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 分析业务领域
- en: At this stage, you, with the help of domain experts, should analyze the business
    problems your software system needs to solve, identifying the relevant main entities
    and their interactions. The main goal behind the analysis and design of a domain
    model is to capture the essence of the business information for the application’s
    purpose.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该在领域专家的帮助下，分析你的软件系统需要解决的业务问题，识别相关的主要实体及其交互。领域模型分析和设计的背后主要目标是捕捉业务信息的核心，以适应应用程序的目的。
- en: '*Entities* are usually notions understood by users of the system: payment,
    customer, order, item, bid, and so forth. Some entities may be abstractions of
    less concrete things the user thinks about, such as a pricing algorithm, but even
    these are usually understandable to the user. You can find all these entities
    in the conceptual view of the business, sometimes called an *information model*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*实体*通常是系统用户理解的概念：支付、客户、订单、项目、出价等等。一些实体可能是用户思考的更不具体事物的抽象，例如定价算法，但这些通常对用户来说是可理解的。你可以在业务的概念视图中找到所有这些实体，有时也称为*信息模型*。'
- en: From this business model, engineers and architects of object-oriented software
    create an object-oriented model, still at the conceptual level (no Java code).
    This model may be as simple as a mental image that exists only in the mind of
    the developer, or it may be as elaborate as a UML class diagram. Figure 3.2 shows
    a simple model expressed in UML.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个业务模型中，面向对象软件的工程师和架构师创建了一个面向对象模型，仍然处于概念层面（没有Java代码）。此模型可能只是一个存在于开发者心中的心理图像，或者它可能像UML类图一样复杂。图3.2展示了用UML表达的一个简单模型。
- en: '![](../../OEBPS/Images/CH03_F02_Tudose2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F02_Tudose2.png)'
- en: Figure 3.2 A class diagram of a typical online auction model
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 典型在线拍卖模型的类图
- en: 'This model contains entities that you’re bound to find in any typical e-commerce
    system: category, item, and user. This domain model represents all the entities
    and their relationships (and perhaps their attributes). This kind of object-oriented
    model of entities from the problem domain, encompassing only those entities that
    are of interest to the user, is called a *domain model*. It’s an abstract view
    of the real world.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型包含你在任何典型的电子商务系统中都可能会找到的实体：类别、项目和用户。此领域模型表示所有实体及其关系（以及可能它们的属性）。这种从问题域中提取的实体面向对象模型，仅包含对用户感兴趣的实体，被称为*领域模型*。它是对现实世界的抽象视图。
- en: Instead of using an object-oriented model, engineers and architects may start
    the application design with a data model. This can be expressed with an entity-relationship
    diagram, and it will contain the `CATEGORY`, `ITEM`, and `USER` entities, together
    with the relationships between them. We usually say that, concerning persistence,
    there is little difference between the two types of models; they’re merely different
    starting points. In the end, which modeling language you use is secondary; we’re
    most interested in the structure of and relationships between the business entities.
    We care about the rules that have to be applied to guarantee the integrity of
    the data (for example, the multiplicity of relationships included in the model)
    and the code procedures used to manipulate the data (usually not included in the
    model).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用面向对象模型不同，工程师和架构师可能从数据模型开始应用设计。这可以用实体关系图来表示，它将包含 `CATEGORY`、`ITEM` 和 `USER`
    实体，以及它们之间的关系。我们通常说，在持久性方面，这两种模型之间几乎没有区别；它们只是不同的起点。最终，你使用哪种建模语言是次要的；我们最感兴趣的是业务实体的结构和关系。我们关心必须应用以确保数据完整性的规则（例如，模型中包含的关系多重性）以及用于操作数据的代码过程（通常不包括在模型中）。
- en: In the next section we’ll complete our analysis of the CaveatEmptor problem
    domain. The resulting domain model will be the central theme of this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将完成对 CaveatEmptor 问题领域的分析。生成的领域模型将成为本书的中心主题。
- en: 3.1.3 The CaveatEmptor domain model
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 CaveatEmptor 领域模型注意事项
- en: 'The CaveatEmptor site will allow users to auction many different kinds of items,
    from electronic equipment to airline tickets. Auctions proceed according to the
    English auction strategy: users continue to place bids on an item until the bid
    period for that item expires, and the highest bidder wins.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CaveatEmptor 网站将允许用户拍卖多种不同类型的物品，从电子设备到机票。拍卖按照英语拍卖策略进行：用户继续对该物品进行出价，直到该物品的出价期结束，最高出价者获胜。
- en: In any store, goods are categorized by type and grouped with similar goods into
    sections and onto shelves. The auction catalog requires some kind of hierarchy
    of item categories so that a buyer can browse the categories or arbitrarily search
    by category and item attributes. Lists of items will appear in the category browser
    and search result screens. Selecting an item from a list will take the buyer to
    an item-detail view where an item may have images attached to it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何商店中，商品都按类型分类，并按相似商品分组到区域和货架上。拍卖目录需要某种物品类别的层次结构，以便买家可以浏览类别或任意按类别和物品属性搜索。物品列表将出现在类别浏览器和搜索结果屏幕上。从列表中选择一个物品将带买家到物品详情视图，其中物品可能附有图片。
- en: An auction consists of a sequence of bids, and one is the winning bid. User
    details will include name, address, and billing information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 拍卖由一系列出价组成，其中一个是获胜出价。用户详细信息将包括姓名、地址和账单信息。
- en: '![](../../OEBPS/Images/CH03_F03_Tudose2.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F03_Tudose2.png)'
- en: Figure 3.3 Persistent classes of the CaveatEmptor domain model and their relationships
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 CaveatEmptor 领域模型的持久化类及其关系
- en: 'The result of this analysis, the high-level overview of the domain model, is
    shown in figure 3.3\. Let’s briefly discuss some interesting features of this
    model:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本分析的结果，即领域模型的高级概述，如图 3.3 所示。让我们简要讨论一下这个模型的一些有趣特性：
- en: Each item can be auctioned only once, so you don’t need to make `Item` distinct
    from any auction entities. Instead, you have a single auction item entity named
    `Item`. Thus, `Bid` is associated directly with `Item`. You model the `Address`
    information of a `User` as a separate class—a `User` may have three addresses
    for home, billing, and shipping. You allow the user to have many `BillingDetails`.
    Subclasses of an abstract class represent the various billing strategies (allowing
    for future extension).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个物品只能拍卖一次，因此你不需要将 `Item` 与任何拍卖实体区分开来。相反，你有一个名为 `Item` 的单一拍卖物品实体。因此，`Bid` 直接与
    `Item` 相关联。你将 `User` 的 `Address` 信息建模为一个单独的类——一个 `User` 可能有三个地址，分别是家庭、账单和配送。你允许用户拥有多个
    `BillingDetails`。抽象类的子类代表各种账单策略（允许未来扩展）。
- en: The application may nest a `Category` inside another `Category`, and so on.
    A recursive association, from the `Category` entity to itself, expresses this
    relationship. Note that a single `Category` may have multiple child categories
    but at most one parent. Each `Item` belongs to at least one `Category`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以在一个`Category`内部嵌套另一个`Category`，依此类推。从`Category`实体到自身的递归关联表达了这种关系。请注意，一个单独的`Category`可以有多个子类别，但最多只有一个父类别。每个`Item`至少属于一个`Category`。
- en: This representation isn’t the *complete* domain model; it’s only the classes
    for which you need persistence capabilities. You’ll want to store and load instances
    of `Category`, `Item`, `User`, and so on. We have simplified this high-level overview
    a little; we’ll make modifications to these classes when needed for more complex
    examples.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种表示法并不是一个完整的领域模型；它只是那些需要持久化能力的类。你将需要存储和加载`Category`、`Item`、`User`等类的实例。我们对这个高级概述进行了一些简化；在需要更复杂的示例时，我们会修改这些类。
- en: The entities in a domain model should encapsulate state and behavior. For example,
    the `User` entity should define the name and address of a customer *and* the logic
    required to calculate the shipping costs for items (to this particular customer).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型中的实体应该封装状态和行为。例如，`User`实体应该定义客户的姓名和地址*以及*计算特定客户物品的运费所需的逻辑。
- en: There might be other classes in the domain model that only have transient runtime
    instances. Consider a `WinningBidStrategy` class encapsulating the fact that the
    highest bidder wins an auction. This might be called by the business layer (controller)
    code when checking the state of an auction. At some point you might have to figure
    out how the tax should be calculated for sold items or how the system should approve
    a new user account. We don’t consider such business rules or domain model behavior
    to be unimportant; rather, those concerns are mostly orthogonal to the problem
    of persistence.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型中可能还有其他只有瞬态运行时实例的类。考虑一个封装最高出价者赢得拍卖事实的`WinningBidStrategy`类。这可能在业务层（控制器）代码检查拍卖状态时被调用。在某个时候，你可能需要弄清楚如何计算已售物品的税费或系统如何批准新的用户账户。我们不认为这样的业务规则或领域模型行为是不重要的；相反，这些关注点大多与持久性问题正交。
- en: Now that you have a (rudimentary) application design with a domain model, the
    next step is to implement it in Java.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个（初步的）具有领域模型的应用程序设计，下一步是将它用Java实现。
- en: ORM without a domain model
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无领域模型的ORM
- en: Object persistence with full ORM is most suitable for applications based on
    a rich domain model. If your application doesn’t implement complex business rules
    or complex interactions between entities, or if you have few entities, you may
    not need a domain model. Many simple and some not-so-simple problems are perfectly
    suited to table-oriented solutions, where the application is designed around the
    database data model instead of around an object-oriented domain model and the
    logic is often executed in the database (with stored procedures).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整的ORM进行对象持久化最适合基于丰富领域模型的应用程序。如果你的应用程序没有实现复杂的业务规则或实体之间的复杂交互，或者如果你有很少的实体，你可能不需要领域模型。许多简单的问题和一些不那么简单的问题非常适合面向表解决方案，其中应用程序是围绕数据库数据模型设计的，而不是围绕面向对象的领域模型，逻辑通常在数据库（使用存储过程）中执行。
- en: 'It’s also worth considering the learning curve: once you’re proficient with
    Hibernate and Spring Data, you’ll use them for all applications—even something
    as a simple SQL query generator and result mapper. If you’re just learning ORM,
    a trivial use case may not justify the time and overhead involved.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 值得考虑的还有学习曲线：一旦你精通Hibernate和Spring Data，你将使用它们来处理所有应用程序——甚至是一个简单的SQL查询生成器和结果映射器。如果你刚开始学习ORM，一个简单的用例可能不足以证明所涉及的时间和开销。
- en: 3.2 Implementing the domain model
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 实现领域模型
- en: 'Let’s start with an issue that any implementation must deal with: the separation
    of concerns—which layer is concerned with what responsibility. The domain model
    implementation is usually a central, organizing component; it’s reused heavily
    whenever you implement new application functionality. For this reason, you should
    go to some lengths to ensure that non-business concerns don’t leak into the domain
    model implementation.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从任何实现都必须处理的任何问题开始：关注点的分离——哪一层负责什么责任。领域模型实现通常是中心、组织性的组件；在实现新的应用程序功能时，它被大量重用。因此，你应该采取一些措施来确保非业务关注点不会渗入领域模型实现。
- en: 3.2.1 Addressing leakage of concerns
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 解决关注点泄漏问题
- en: When concerns such as persistence, transaction management, or authorization
    start to appear in the domain model classes, this is an example of leakage of
    concerns. The domain model implementation is important code that shouldn’t depend
    on orthogonal APIs. For example, code in the domain model shouldn’t call the database
    directly or through an intermediate abstraction. This will allow you to reuse
    the domain model classes virtually anywhere.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当持久性、事务管理或授权等关注点开始出现在领域模型类中时，这是一个关注点泄漏的例子。领域模型实现是重要的代码，不应依赖于正交API。例如，领域模型中的代码不应直接调用数据库或通过中间抽象调用。这将允许你在几乎任何地方重用领域模型类。
- en: 'The architecture of the application includes the following layers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的架构包括以下层：
- en: The presentation layer can access instances and attributes of domain model entities
    when rendering views. The user may use the front end (such as a browser) to interact
    with the application. This concern should be separate from the concerns of the
    other layers.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现层在渲染视图时可以访问领域模型实体的实例和属性。用户可以使用前端（如浏览器）与应用程序交互。这个关注点应该与其他层的关注点分开。
- en: The controller components in the business layer can access the state of domain
    model entities and call methods of these entities. This is where the business
    calculations and logic are executed. This concern should be separate from the
    concerns of the other layers.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务层中的控制器组件可以访问领域模型实体的状态并调用这些实体的方法。这是执行业务计算和逻辑的地方。这个关注点应该与其他层的关注点分开。
- en: The persistence layer can load instances of domain model entities from and store
    them to the database, preserving their state. This is where the information is
    persisted for a long time. This concern should also be separate from the concerns
    of the other layers.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化层可以从数据库加载领域模型实体的实例并将它们存储到数据库中，保留其状态。这是信息长期持久化的地方。这个关注点也应该与其他层的关注点分开。
- en: Preventing the leakage of concerns makes it easy to unit test the domain model
    without the need for a particular runtime environment or container or for mocking
    any service dependencies. You can write unit tests that verify the correct behavior
    of your domain model classes without any special test harness. (Here we’re talking
    about unit tests such as “calculate the shipping cost and tax,” not performance
    and integration tests such as “load from the database” and “store in the database.”)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 防止关注点泄漏使得在不需要特定运行时环境或容器或模拟任何服务依赖的情况下，可以轻松地对领域模型进行单元测试。你可以编写单元测试来验证领域模型类的正确行为，而无需任何特殊的测试框架。（这里我们谈论的是像“计算运费和税费”这样的单元测试，而不是像“从数据库加载”和“存储到数据库”这样的性能和集成测试。）
- en: The Jakarta EE standard solves the problem of leaky concerns with metadata such
    as annotations within your code or external XML descriptors. This approach allows
    the runtime container to implement some predefined cross-cutting concerns—security,
    concurrency, persistence, transactions, and remoteness—in a generic way by intercepting
    calls to application components.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE标准通过代码中的元数据（如注解）或外部XML描述符解决了关注点泄漏的问题。这种方法允许运行时容器通过拦截对应用程序组件的调用以通用方式实现一些预定义的横切关注点——安全性、并发性、持久性、事务性和远程性。
- en: JPA defines the *entity class* as the primary programming artifact. This programming
    model enables transparent persistence, and a JPA provider such as Hibernate also
    offers automated persistence. Hibernate isn’t a Jakarta EE runtime environment,
    and it’s not an application server. It’s an implementation of the ORM technique.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JPA将*实体类*定义为主要的编程工件。这种编程模型实现了透明持久化，并且JPA提供者（如Hibernate）也提供了自动化持久化。Hibernate不是一个Jakarta
    EE运行时环境，也不是一个应用程序服务器。它是ORM技术的实现。
- en: 3.2.2 Transparent and automated persistence
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 透明和自动持久化
- en: We use the term *transparent* to refer to a complete separation of concerns
    between the persistent classes of the domain model and the persistence layer.
    The persistent classes are unaware of—and have no dependency on—the persistence
    mechanism. From inside the persistent classes, there is no reference to the outside
    persistence mechanism. We use the term *automatic* to refer to a persistence solution
    (your annotated domain, the layer, and the mechanism) that relieves you of handling
    low-level mechanical details, such as writing most SQL statements and working
    with the JDBC API. As a real-world use case, let’s analyze how transparent and
    automated persistence is reflected at the level of the `Item` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语*透明*来指代领域模型持久化类和持久化层之间的关注点完全分离。持久化类对持久化机制一无所知，并且没有依赖。从持久化类内部，没有对外部持久化机制的引用。我们使用术语*自动*来指代一个持久化解决方案（你的注解领域、层和机制），它让你摆脱处理低级机械细节，例如编写大多数SQL语句和与JDBC
    API交互。作为一个现实世界的用例，让我们分析透明和自动化的持久化如何在`Item`类级别得到体现。
- en: The `Item` class of the CaveatEmptor domain model shouldn’t have any runtime
    dependency on any Jakarta Persistence or Hibernate API. Furthermore, JPA doesn’t
    require that any special superclasses or interfaces be inherited or implemented
    by persistent classes. Nor are any special classes used to implement attributes
    and associations. You can reuse persistent classes outside the context of persistence,
    such as in unit tests or in the presentation layer. You can create instances in
    any runtime environment with the regular Java `new` operator, preserving testability
    and reusability.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CaveatEmptor领域模型的`Item`类不应该对Jakarta Persistence或Hibernate API有任何运行时依赖。此外，JPA也不要求持久化类继承或实现任何特殊的超类或接口。也不使用任何特殊类来实现属性和关联。你可以在任何运行时环境中使用常规的Java
    `new`操作符创建实例，从而保持可测试性和可重用性。
- en: In a system with transparent persistence, instances of entities aren’t aware
    of the underlying data store; they need not even be aware that they’re being persisted
    or retrieved. JPA externalizes persistence concerns to a generic persistence manager
    API. Hence, most of your code, and certainly your complex business logic, doesn’t
    have to concern itself with the current state of a domain model entity instance
    in a single thread of execution. We regard transparency as a requirement because
    it makes an application easier to build and maintain. Transparent persistence
    should be one of the primary goals of any ORM solution.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有透明持久化的系统中，实体实例对底层数据存储一无所知；它们甚至不需要知道它们正在被持久化或检索。JPA将持久化关注点外部化到一个通用的持久化管理器API。因此，你的大部分代码，当然包括你的复杂业务逻辑，不需要关心单个执行线程中领域模型实体实例的当前状态。我们将透明性视为一个要求，因为它使得应用程序更容易构建和维护。透明持久化应该是任何ORM解决方案的主要目标之一。
- en: 'Clearly, no automated persistence solution is completely transparent: every
    automated persistence layer, including JPA and Hibernate, imposes some requirements
    on the persistent classes. For example, JPA requires that collection-valued attributes
    be typed to an interface such as `java.util.Set` or `java.util.List` and not to
    an actual implementation such as `java.util.HashSet` (this is good practice anyway).
    Similarly, a JPA entity class has to have a special attribute, called the *database
    identifier* (which is also less of a restriction but is usually convenient).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，没有自动化的持久化解决方案是完全透明的：每个自动化的持久化层，包括JPA和Hibernate，都对持久化类提出了一些要求。例如，JPA要求集合类型的属性被类型化为接口，如`java.util.Set`或`java.util.List`，而不是实际的实现，如`java.util.HashSet`（这本身就是一种好习惯）。同样，JPA实体类必须有一个特殊属性，称为*数据库标识符*（这虽然不是限制，但通常很方便）。
- en: You now know that the persistence mechanism should have minimal effect on how
    you implement a domain model and that transparent and automated persistence is
    required. Our preferred programming model for achieving this is POJO.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道持久化机制应该对如何实现领域模型的影响最小化，并且需要透明和自动化的持久化。我们实现这一目标的首选编程模型是POJO。
- en: Note POJO is the acronym for *Plain Old Java Objects*. Martin Fowler, Rebecca
    Parsons, and Josh Mackenzie coined this term in 2000.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，POJO是*Plain Old Java Objects*的缩写。马丁·福勒（Martin Fowler）、丽贝卡·帕森斯（Rebecca Parsons）和乔希·麦肯齐（Josh
    Mackenzie）在2000年提出了这个术语。
- en: At the beginning of the 2000s, many developers started talking about POJO, a
    back-to-basics approach that essentially revives JavaBeans, a component model
    for UI development, and reapplies it to the other layers of a system. Several
    revisions of the EJB and JPA specifications brought us new lightweight entities,
    and it would be appropriate to call them *persistence-capable JavaBeans*. Java
    engineers often use all these terms as synonyms for the same basic design approach.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2000 年代初，许多开发者开始讨论 POJO，这是一种回归基础的方法，本质上复兴了 JavaBeans，一个用于 UI 开发的组件模型，并将其重新应用于系统的其他层。EJB
    和 JPA 规范的几个版本带来了新的轻量级实体，我们可以称它们为 *持久化能力 JavaBeans*。Java 工程师通常将这些术语用作相同基本设计方法的同义词。
- en: You shouldn’t be too concerned about which terms we use in this book; our ultimate
    goal is to apply the persistence aspect as transparently as possible to Java classes.
    Almost any Java class can be persistence-capable if you follow some simple practices.
    Let’s see what this looks like in code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必太在意我们在本书中使用哪些术语；我们的最终目标是尽可能透明地将持久化方面应用于 Java 类。如果您遵循一些简单的实践，几乎任何 Java 类都可以成为持久化能力类。让我们看看代码中的样子。
- en: 'Note To be able to execute the examples from the chapter’s source code, you’ll
    need first to run the Ch03.sql script. The examples use a MySQL server with the
    default credentials: a username of *root* and no password.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要能够执行章节源代码中的示例，您首先需要运行 Ch03.sql 脚本。这些示例使用默认凭据的 MySQL 服务器：用户名为 *root*，无密码。
- en: 3.2.3 Writing persistence-capable classes
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 编写持久化能力类
- en: Supporting fine-grained and rich domain models is a major Hibernate objective.
    This is one reason we work with POJOs. In general, using fine-grained objects
    means having more classes than tables.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 支持细粒度和丰富的领域模型是 Hibernate 的一个主要目标。这是我们与 POJO 一起工作的原因之一。一般来说，使用细粒度对象意味着比表更多的类。
- en: A persistence-capable plain old Java class declares attributes, which represent
    state, and business methods, which define behavior. Some attributes represent
    associations to other persistence-capable classes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个持久化能力的普通 Java 类声明了属性，这些属性代表状态，以及业务方法，这些方法定义了行为。一些属性代表与其他持久化能力类的关联。
- en: The following listing shows a POJO implementation of the `User` entity of the
    domain model (example 1 in the `domainmodel` folder in the source code). Let’s
    walk through this code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了领域模型中 `User` 实体的 POJO 实现（源代码中 `domainmodel` 文件夹中的示例 1）。让我们来分析这段代码。
- en: Listing 3.1 POJO implementation of the `User` class
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 `User` 类的 POJO 实现
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The class can be abstract and, if needed, extend a non-persistent class or implement
    an interface. It must be a top-level class, not be nested within another class.
    The persistence-capable class and any of its methods *shouldn’t* be final (this
    is a requirement of the JPA specification). Hibernate is not so strict, and it
    will allow you to declare final classes as entities or as entities with final
    methods that access persistent fields. However, this is not a good practice, as
    this will prevent Hibernate from using the proxy pattern for performance improvement.
    In general, you should follow the JPA requirements if you would like your application
    to remain portable between different JPA providers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该类可以是抽象的，如果需要，可以扩展非持久化类或实现一个接口。它必须是一个顶级类，不能嵌套在其他类内部。持久化能力类及其任何方法 *不应* 是最终的（这是
    JPA 规范的要求）。Hibernate 不那么严格，它将允许您声明最终类作为实体或具有最终方法的实体，这些方法访问持久化字段。然而，这不是一个好的实践，因为这将阻止
    Hibernate 使用代理模式来提高性能。一般来说，如果您希望应用程序能够在不同的 JPA 提供商之间保持可移植性，您应该遵循 JPA 要求。
- en: Hibernate and JPA require a constructor with no arguments for every persistent
    class. Alternatively, if you do not write a constructor at all, Hibernate will
    use the default Java constructor. Hibernate calls classes using the Java Reflection
    API on such no-argument constructors to create instances. The constructor need
    not be public, but it has to be at least package-visible for Hibernate to use
    runtime-generated proxies for performance optimization.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 和 JPA 要求每个持久化类都必须有一个无参数的构造函数。或者，如果您根本不编写构造函数，Hibernate 将使用默认的 Java
    构造函数。Hibernate 通过 Java 反射 API 调用此类无参数构造函数来创建实例。构造函数不需要是公共的，但它至少必须是包可见的，以便 Hibernate
    使用运行时生成的代理进行性能优化。
- en: 'The properties of the POJO implement the attributes of the business entities,
    such as the `username` of `User`. You’ll usually implement properties as private
    or protected member fields, together with public or protected property accessor
    methods: for each field you’ll need a method for retrieving its value and another
    for setting its value. These methods are known as the *getter* and *setter*, respectively.
    The example POJO in listing 3.1 declares getter and setter methods for the `username`
    property.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: POJO 的属性实现了业务实体的属性，例如 `User` 的 `username`。你通常会实现属性作为私有或受保护的成员字段，以及公共或受保护的属性访问器方法：对于每个字段，你需要一个用于获取其值的方法，另一个用于设置其值。这些方法分别被称为
    *获取器* 和 *设置器*。列表 3.1 中的示例 POJO 声明了 `username` 属性的获取器和设置器方法。
- en: The JavaBean specification defines the guidelines for naming accessor methods;
    this allows generic tools like Hibernate to easily discover and manipulate property
    values. A getter method name begins with `get`, followed by the name of the property
    (with the first letter in uppercase). A setter method name begins with `set` and
    similarly is followed by the name of the property. You may begin getter method
    names for Boolean properties with `is` instead of `get`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JavaBean 规范定义了访问器方法的命名指南；这允许像 Hibernate 这样的通用工具轻松发现和操作属性值。获取器方法名称以 `get` 开头，后跟属性名称（首字母大写）。设置器方法名称以
    `set` 开头，并类似地后跟属性名称。对于布尔属性，你可以用 `is` 而不是 `get` 开头来命名获取器方法。
- en: Hibernate doesn’t require accessor methods. You can choose how the state of
    an instance of your persistent classes should be persisted. Hibernate will either
    directly access fields or call accessor methods. Your class design isn’t disturbed
    much by these considerations. You can make some accessor methods non-public or
    completely remove them and then configure Hibernate to rely on field access for
    these properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 不需要访问器方法。你可以选择如何持久化你的持久化类实例的状态。Hibernate 将直接访问字段或调用访问器方法。这些考虑不会在很大程度上干扰你的类设计。你可以使一些访问器方法非公共的，或者完全删除它们，然后配置
    Hibernate 依赖于字段访问这些属性。
- en: Making property fields and accessor methods private, protected, or package visible
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性字段和访问器方法设置为私有、受保护或包可见
- en: Typically you will not allow direct access to the internal state of your class,
    so you won’t make attribute fields public. If you make fields or methods private,
    you’re effectively declaring that nobody should ever access them; only you are
    allowed to do that (or a service like Hibernate). This is a definitive statement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会允许直接访问类的内部状态，因此你不会使属性字段公共的。如果你使字段或方法私有，你实际上是在声明没有人应该永远访问它们；只有你被允许这样做（或像
    Hibernate 这样的服务）。这是一个明确的声明。
- en: There are often good reasons for someone to access your “private” internals—usually
    to fix one of your bugs—and you only make people angry if they have to fall back
    to reflection access in an emergency. Instead, you might assume or know that the
    engineer who comes after you has access to your code and knows what they’re doing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，有人访问你的“私有”内部结构往往有很好的理由——通常是为了修复你的一个错误——如果你让他们在紧急情况下不得不回退到反射访问，你只会让人感到愤怒。相反，你可能会假设或知道接替你的工程师可以访问你的代码，并且知道他们在做什么。
- en: 'Although trivial accessor methods are common, one of the reasons we like to
    use JavaBeans-style accessor methods is that they provide encapsulation: you can
    change the hidden internal implementation of an attribute without making any changes
    to the public interface. If you configure Hibernate to access attributes through
    methods, you abstract the internal data structure of the class—the instance variables—from
    the design of the database.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的访问器方法很常见，但我们喜欢使用 JavaBeans 风格的访问器方法之一的原因是它们提供了封装：你可以更改属性的隐藏内部实现，而无需对公共接口进行任何更改。如果你配置
    Hibernate 通过方法访问属性，你将类的内部数据结构（实例变量）从数据库的设计中抽象出来。
- en: For example, if your database stores the name of a user as a single `NAME` column,
    but your `User` class has `firstname` and `lastname` fields, you can add the following
    persistent `name` property to the class (this is example 2 from the `domainmodel`
    folder source code).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的数据库将用户名称存储为单个 `NAME` 列，但你的 `User` 类有 `firstname` 和 `lastname` 字段，你可以在类中添加以下持久的
    `name` 属性（这是来自 `domainmodel` 文件夹源代码的示例 2）。
- en: Listing 3.2 POJO implementation of the `User` class with logic in accessor methods
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 `User` 类的 POJO 实现，其中包含访问器方法中的逻辑
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Later you’ll see that a custom type converter in the persistence service is
    a better way to handle many of these kinds of situations. It helps to have several
    options.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 后续你将看到，在持久化服务中有一个自定义的类型转换器是处理这些情况的一个更好的方法。有几个选项可供选择。
- en: 'Another issue to consider is *dirty checking*. Hibernate automatically detects
    state changes so that it can synchronize the updated state with the database.
    It’s usually safe to return a different instance from the getter method than the
    instance passed by Hibernate to the setter. Hibernate compares them by value—not
    by object identity—to determine whether the attribute’s persistent state needs
    to be updated. For example, the following getter method doesn’t result in unnecessary
    SQL `UPDATE`s:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是*脏检查*。Hibernate自动检测状态变化，以便它能将更新的状态与数据库同步。通常，从获取器方法返回一个与Hibernate传递给设置器方法的实例不同的实例是安全的。Hibernate通过值而不是通过对象身份来比较它们，以确定属性是否需要更新其持久状态。例如，以下获取器方法不会导致不必要的SQL
    `UPDATE`：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is an important point to note about *dirty checking* when persisting
    collections. If you have an `Item` entity with a `Set<Bid>` field that’s accessed
    through the `setBids` setter, this code will result in an unnecessary SQL `UPDATE`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久化集合时，关于*脏检查*有一个重要的问题需要注意。如果你有一个`Item`实体，它有一个通过`setBids`设置器访问的`Set<Bid>`字段，这段代码将导致不必要的SQL
    `UPDATE`：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This happens because Hibernate has its own collection implementations: `PersistentSet`,
    `PersistentList``,` or `PersistentMap`. Providing setters for an entire collection
    is not good practice anyway.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Hibernate有自己的集合实现：`PersistentSet`、`PersistentList`、`PersistentMap`。提供整个集合的设置器在任何情况下都不是一个好的做法。
- en: How does Hibernate handle exceptions when your accessor methods throw them?
    If Hibernate uses accessor methods when loading and storing instances, and a `RuntimeException`
    (unchecked) is thrown, the current transaction is rolled back, and the exception
    is yours to handle in the code that called the Jakarta Persistence (or native
    Hibernate) API. If you throw a checked application exception, Hibernate wraps
    the exception into a `RuntimeException`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的访问器方法抛出异常时，Hibernate如何处理这些异常？如果Hibernate在加载和存储实例时使用访问器方法，并且抛出了一个`RuntimeException`（未检查的异常），则当前事务将回滚，异常将由调用Jakarta
    Persistence（或原生Hibernate）API的代码处理。如果你抛出一个检查的应用程序异常，Hibernate会将异常包装成一个`RuntimeException`。
- en: Next we’ll focus on the relationships between entities and the associations
    between persistent classes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注实体之间的关系以及持久化类之间的关联。
- en: 3.2.4 Implementing POJO associations
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 实现POJO关联
- en: 'Let’s now look at how you can associate and create different kinds of relationships
    between objects: one-to-many, many-to-one, and bidirectional relationships. We’ll
    look at the scaffolding code needed to create these associations, how you can
    simplify relationship management, and how you can enforce the integrity of these
    relationships.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何关联和创建对象之间不同类型的关系：一对一、多对一和双向关系。我们将查看创建这些关联所需的脚手架代码，如何简化关系管理，以及如何强制执行这些关系的完整性。
- en: You can create properties to express associations between classes, and you will
    (typically) call accessor methods to navigate from instance to instance at runtime.
    Let’s consider the associations defined by the `Item` and `Bid` persistent classes,
    as shown in figure 3.4.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建属性来表示类之间的关联，并且你将在运行时通过访问器方法从实例导航到实例。让我们考虑由`Item`和`Bid`持久化类定义的关联，如图3.4所示。
- en: '![](../../OEBPS/Images/CH03_F04_Tudose2.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F04_Tudose2.png)'
- en: Figure 3.4 Associations between the `Item` and `Bid` classes
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 `Item`和`Bid`类之间的关联
- en: 'We left the association-related attributes, `Item#bids` and `Bid#item`, out
    of figure 3.4\. These properties and the methods that manipulate their values
    are called *scaffolding code*. This is what the scaffolding code for the `Bid`
    class looks like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图3.4中省略了与关联相关的属性，`Item#bids` 和 `Bid#item`。这些属性及其操作值的函数被称为*脚手架代码*。以下是`Bid`类的脚手架代码示例：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `item` property allows navigation from a `Bid` to the related `Item`. This
    is an association with *many-to-one* multiplicity; users can make many bids for
    each item.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`item`属性允许从`Bid`导航到相关的`Item`。这是一个具有*多对一*多重性的关联；用户可以为每个物品投多个标。'
- en: 'Here is the `Item` class’s scaffolding code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Item`类的脚手架代码：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This association between the two classes allows for *bidirectional* navigation:
    the *many-to-one* is from this perspective a *one-to-many* multiplicity. One item
    can have many bids—they are of the same type but were generated during the auction
    by different users and with different amounts, as shown in table 3.1.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类之间的关联允许进行**双向**导航：从这一角度看，**多对一**是多对一多重性的。一个项目可以有多个出价——它们是同一类型，但在拍卖过程中由不同的用户以不同的金额生成，如表3.1所示。
- en: Table 3.1 One `Item` has many `Bid`s generated during the auction
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 一个`Item`在拍卖期间生成了多个`Bid`
- en: '| Item | Bid | User | Amount |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | 出价 | 用户 | 金额 |'
- en: '| 1 | 1 | John | 100 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | John | 100 |'
- en: '| 1 | 2 | Mike | 120 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | Mike | 120 |'
- en: '| 1 | 3 | John | 140 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 3 | John | 140 |'
- en: The scaffolding code for the `bids` property uses a collection interface type,
    `java.util.Set`. JPA requires interfaces for collection-typed properties, where
    you must use `java.util.Set`, `java.util.List`, or `java.util.Collection` rather
    than `HashSet`, for example. It’s good practice to program to collection interfaces
    anyway, rather than concrete implementations, so this restriction shouldn’t bother
    you.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`bids`属性的脚手架代码使用集合接口类型，`java.util.Set`。JPA要求集合类型属性使用接口，您必须使用`java.util.Set`、`java.util.List`或`java.util.Collection`，而不是例如`HashSet`。无论如何，编写针对集合接口的代码而不是具体实现是良好的编程习惯，所以这个限制不应该让您感到烦恼。'
- en: You can choose a `Set` and initialize the field to a new `HashSet`, because
    the application disallows duplicate bids. This is good practice, because you’ll
    avoid any `NullPointer-Exception`s when someone is accessing the property of a
    new `Item`, which will have an empty set of bids. The JPA provider is also required
    to set a non-empty value on any mapped collection-valued property, such as when
    an `Item` without bids is loaded from the database. (It doesn’t have to use a
    `HashSet`; the implementation is up to the provider. Hibernate has its own collection
    implementations with additional capabilities, such as dirty checking.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择一个`Set`并将字段初始化为一个新的`HashSet`，因为应用程序不允许重复的出价。这是一个好习惯，因为当有人访问一个新`Item`的属性时，该`Item`将有一个空的出价集合，这样可以避免任何`NullPointer-Exception`。JPA提供者还必须在任何映射的集合值属性上设置非空值，例如，当从数据库中加载没有出价的`Item`时。（它不必使用`HashSet`；实现由提供者决定。Hibernate有自己的集合实现，具有额外的功能，例如脏检查。）
- en: Shouldn’t bids on an item be stored in a list?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的出价不应该存储在列表中吗？
- en: The first reaction is often to preserve the order of elements as they’re entered
    by users, because this may also be the order in which you will show them later.
    Certainly, in an auction application, there has to be a defined order in which
    the user sees bids for an item, such as the highest bid first or the newest bid
    last. You might even work with a `java.util.List` in your user interface code
    to sort and display bids for an item.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个反应通常是保留用户输入元素顺序，因为这也可能是您稍后显示它们的顺序。当然，在拍卖应用程序中，用户看到出价的顺序必须是有定义的，例如，最高的出价首先显示或最新的出价最后显示。您甚至可以在用户界面代码中使用`java.util.List`来对出价进行排序和显示。
- en: That doesn’t mean this display order should be durable, however. The data integrity
    isn’t affected by the order in which bids are displayed. You’ll need to store
    the amount of each bid, so you can always find the highest bid, and you’ll need
    to store a timestamp for when each bid is created, so you can always find the
    newest bid. When in doubt, keep your system flexible, and sort the data when it’s
    retrieved from the data store (in a query) or shown to the user (in Java code),
    not when it’s stored.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着这种显示顺序应该是持久的。数据完整性不受出价显示顺序的影响。您需要存储每个出价的金额，这样您总能找到最高的出价，并且您需要存储每个出价创建的时间戳，这样您总能找到最新的出价。当有疑问时，请保持您的系统灵活，在从数据存储（在查询中）或向用户显示（在Java代码中）数据时对其进行排序，而不是在存储时排序。
- en: Accessor methods for associations need to be declared `public` only if they’re
    part of the external interface of the persistent class used by the application
    logic to create a link between two instances. We’ll now focus on this issue, because
    managing the link between an `Item` and a `Bid` is much more complicated in Java
    code than it is in an SQL database, with declarative foreign key constraints.
    In our experience, engineers are often unaware of this complication, which arises
    from a network object model with bidirectional references (pointers). Let’s walk
    through the issue step by step.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关联的访问器方法需要声明为 `public`，仅当它们是应用程序逻辑用于在两个实例之间创建链接的持久化类的公共接口的一部分时。我们现在将关注这个问题，因为在
    Java 代码中管理 `Item` 和 `Bid` 之间的链接比在具有声明性外键约束的 SQL 数据库中要复杂得多。根据我们的经验，工程师们往往没有意识到这种复杂性，它源于具有双向引用（指针）的网络对象模型。让我们一步一步地解决这个问题。
- en: 'The basic procedure for linking a `Bid` with an `Item` looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Bid` 与 `Item` 链接的基本步骤如下：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Whenever you create this bidirectional link, two actions are required:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建这种双向链接时，需要执行两个操作：
- en: You must add the `Bid` to the `bids` collection of the `Item` (shown in figure
    3.5).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须将 `Bid` 添加到 `Item` 的 `bids` 集合中（如图 3.5 所示）。
- en: '![](../../OEBPS/Images/CH03_F05_Tudose2.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F05_Tudose2.png)'
- en: 'Figure 3.5 Step 1 of linking a `Bid` with an `Item`: adding a `Bid` to the
    set of `Bids` from the `Item`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 链接 `Bid` 与 `Item` 的第一步：将 `Bid` 添加到 `Item` 的 `Bids` 集合中
- en: The `item` property of the `Bid` must be set (shown in figure 3.6).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bid` 的 `item` 属性必须设置（如图 3.6 所示）。'
- en: '![](../../OEBPS/Images/CH03_F06_Tudose2.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F06_Tudose2.png)'
- en: 'Figure 3.6 Step 2 of linking a `Bid` with an `Item`: setting the `Item` on
    the `Bid` side'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 链接 `Bid` 与 `Item` 的第二步：在 `Bid` 方面设置 `Item`
- en: JPA doesn’t manage persistent associations. If you want to manipulate an association,
    you must write the same code you would write without Hibernate. If an association
    is bidirectional, you must consider both sides of the relationship. If you ever
    have problems understanding the behavior of associations in JPA, just ask yourself,
    “What would I do without Hibernate?” Hibernate doesn’t change the regular Java
    semantics.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 不管理持久化关联。如果您想操作一个关联，您必须编写与不使用 Hibernate 时的相同代码。如果一个关联是双向的，您必须考虑关系的两个方面。如果您在理解
    JPA 中关联的行为时遇到问题，只需问自己，“没有 Hibernate 我会怎么做？”Hibernate 不会改变常规的 Java 语义。
- en: We recommend that you add convenience methods to group these operations, allowing
    reuse and helping ensure correctness, and in the end guaranteeing data integrity
    (a `Bid` *is required* to have a reference to an `Item`). The next listing shows
    such a convenience method in the `Item` class (this is example 3 from the `domainmodel`
    folder source code).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您添加便利方法来分组这些操作，以便重用并帮助确保正确性，最终保证数据完整性（`Bid` 必须有一个对 `Item` 的引用）。下面的列表显示了
    `Item` 类中的一个此类便利方法（这是来自 `domainmodel` 文件夹源代码的示例 3）。
- en: Listing 3.3 A convenience method simplifies relationship management
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 一个便利方法简化了关系管理
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `addBid()` method not only reduces the lines of code when dealing with
    `Item` and `Bid` instances but also enforces the cardinality of the association.
    You avoid errors that arise from leaving out one of the two required actions.
    You should always provide this kind of grouping of operations for associations,
    if possible. If you compare this with the relational model of foreign keys in
    an SQL database, you can easily see how a network and a pointer model complicate
    a simple operation: instead of a declarative constraint, you need procedural code
    to guarantee data integrity.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`addBid()` 方法不仅减少了处理 `Item` 和 `Bid` 实例时的代码行数，还强制了关联的基数。您避免了由于遗漏两个必需操作之一而引起的错误。如果可能，您应该始终为关联提供这种操作分组。如果您将其与
    SQL 数据库中外键的关系模型进行比较，您就可以很容易地看到网络和指针模型如何使一个简单的操作复杂化：您需要一个程序性代码来保证数据完整性，而不是一个声明性约束。'
- en: Because you want `addBid()` to be the only externally visible mutator method
    for the bids of an item (possibly in addition to a `removeBid()` method), consider
    making the `Bid#setItem()` method package-visible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您希望 `addBid()` 是唯一的外部可见的修改器方法，用于修改一个项目的出价（可能还包括一个 `removeBid()` 方法），考虑使 `Bid#setItem()`
    方法对包可见。
- en: The `Item#getBids()` getter method should not return a modifiable collection,
    so that clients can’t use the collection to make changes that aren’t reflected
    on the other side. Bids added directly to the collection may belong to an item,
    but they wouldn’t have a reference to that item, which would create an inconsistent
    state, according to the database constraints. To prevent this problem, you can
    wrap the internal collection before returning it from the getter method with `Collections.unmodifiableCollection(c)`
    and `Collections.unmodifiableSet(s)`. The client will then get an exception if
    it tries to modify the collection You can therefore force every modification to
    go through the relationship management method, guaranteeing integrity. It is always
    good practice to return an unmodifiable collection from your classes so that the
    client does not have direct access to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item#getBids()`获取器方法不应返回一个可修改的集合，这样客户端就不能使用该集合进行更改，而这些更改在另一侧没有反映出来。直接添加到集合中的出价可能属于一个项目，但它们不会对该项目有引用，这会根据数据库约束创建一个不一致的状态。为了防止这个问题，你可以在从获取器方法返回之前用`Collections.unmodifiableCollection(c)`和`Collections.unmodifiableSet(s)`包装内部集合。然后，如果客户端尝试修改集合，它将得到一个异常。因此，你可以强制每个修改都通过关系管理方法进行，从而保证完整性。始终返回不可修改的集合是良好的实践，这样客户端就没有直接访问它的权限。'
- en: An alternative strategy is to use immutable instances. For example, you could
    enforce integrity by requiring an `Item` argument in the constructor of `Bid`,
    as shown in the following listing (example 4 from the `domainmodel` folder source
    code).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是使用不可变实例。例如，你可以在`Bid`构造函数中要求一个`Item`参数来强制完整性，如下面的列表所示（来自`domainmodel`文件夹源代码的示例4）。
- en: Listing 3.4 Enforcing the integrity of relationships with a constructor
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 使用构造函数强制关系的完整性
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this constructor, the `item` field is set; no further modification of the
    field value should occur. The collection on the other side is also updated for
    a bidirectional relationship, while the `bids` field from the `Item` class is
    now package-private. There is no `Bid#setItem()` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构造函数中，设置了`item`字段；不应进一步修改字段值。另一侧的集合也更新以实现双向关系，而`Item`类的`bids`字段现在是包私有。没有`Bid#setItem()`方法。
- en: There are several problems with this approach, however. First, Hibernate can’t
    call this constructor. You need to add a no-argument constructor for Hibernate,
    and it needs to be at least package-visible. Furthermore, because there is no
    `setItem()` method, Hibernate would have to be configured to access the `item`
    field directly. This means the field can’t be `final`, so the class isn’t guaranteed
    to be immutable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有几个问题。首先，Hibernate不能调用这个构造函数。你需要为Hibernate添加一个无参数构造函数，并且它至少需要是包可见的。此外，因为没有`setItem()`方法，Hibernate必须配置为直接访问`item`字段。这意味着字段不能是`final`，所以类不能保证是不可变的。
- en: It’s up to you how many convenience methods and layers you want to wrap around
    the persistent association properties or fields, but we recommend being consistent
    and applying the same strategy to all your domain model classes. For the sake
    of readability, we won’t always show our convenience methods, special constructors,
    and other such scaffolding in future code samples; you should add them according
    to your own taste and requirements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 至于你想要围绕持久关联属性或字段包裹多少便利方法和层，这取决于你，但我们建议保持一致，并将相同的策略应用于所有领域模型类。为了可读性，我们不会在未来的代码示例中始终显示我们的便利方法、特殊构造函数和其他类似的脚手架；你应该根据自己的品味和需求添加它们。
- en: 'You now have seen domain model classes and how to represent their attributes
    and the relationships between them. Next we’ll increase the level of abstraction:
    we’ll add metadata to the domain model implementation and declare aspects such
    as validation and persistence rules.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了领域模型类以及如何表示它们的属性和它们之间的关系。接下来，我们将提高抽象级别：我们将在领域模型实现中添加元数据，并声明诸如验证和持久性规则等方面。
- en: 3.3 Domain model metadata
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 领域模型元数据
- en: Metadata is data about data, so domain model metadata is information about your
    domain model. For example, when you use the Java Reflection API to discover the
    names of classes in your domain model or the names of their attributes, you’re
    accessing domain model metadata.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据是关于数据的数据，因此领域模型元数据是关于你的领域模型的信息。例如，当你使用Java反射API来发现领域模型中类的名称或它们的属性名称时，你正在访问领域模型元数据。
- en: ORM tools also require metadata to specify the mapping between classes and tables,
    properties and columns, associations and foreign keys, Java types and SQL types,
    and so on. This object/relational mapping metadata governs the transformation
    between the different type systems and relationship representations in object-oriented
    and SQL systems. JPA has a metadata API that you can call to obtain details about
    the persistence aspects of your domain model, such as the names of persistent
    entities and attributes. It’s your job as an engineer to create and maintain this
    information.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ORM工具也需要元数据来指定类和表、属性和列、关联和外键、Java类型和SQL类型之间的映射，等等。这种对象/关系映射元数据控制着面向对象和SQL系统中的不同类型系统和关系表示之间的转换。JPA有一个元数据API，你可以调用它来获取关于你的领域模型持久化方面的详细信息，例如持久化实体和属性的名称。作为工程师，你的任务是创建和维护这些信息。
- en: 'JPA standardizes two metadata options: annotations in Java code and externalized
    XML descriptor files. Hibernate has some extensions for native functionality,
    also available as annotations or XML descriptors. We usually prefer annotations
    as the primary source of mapping metadata. After reading this section, you’ll
    have the information to make an informed decision for your own project.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JPA标准化了两种元数据选项：Java代码中的注解和外部化的XML描述符文件。Hibernate为原生功能提供了一些扩展，这些扩展也作为注解或XML描述符提供。我们通常更喜欢将注解作为映射元数据的主要来源。阅读本节后，你将拥有足够的信息来为你的项目做出明智的决定。
- en: We’ll also discuss *Bean Validation* (JSR 303) in this section, and how it provides
    declarative validation for your domain model (or any other) classes. The reference
    implementation of this specification is the *Hibernate Validator* project. Most
    engineers today prefer Java annotations as the primary mechanism for declaring
    metadata.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在本节中讨论*Bean Validation*（JSR 303），以及它是如何为你的领域模型（或任何其他）类提供声明性验证的。本规范的参考实现是*Hibernate
    Validator*项目。如今，大多数工程师更喜欢将Java注解作为声明元数据的主要机制。
- en: 3.3.1 Annotation-based metadata
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 基于注解的元数据
- en: 'The big advantage of annotations is that they put metadata, such as `@Entity`,
    next to the information it describes, instead of separating it in a different
    file. Here’s an example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注解的一个主要优势是它们将元数据，如`@Entity`，放置在它所描述的信息旁边，而不是将其分离到不同的文件中。以下是一个示例：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can find the standard JPA mapping annotations in the `javax.persistence`
    package. This example declares the `Item` class as a persistent entity using the
    `@javax .persistence.Entity` annotation. All of its attributes are now automatically
    made persistent with a default strategy. That means you can load and store instances
    of `Item`, and all the properties of the class are part of the managed state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`javax.persistence`包中找到标准的JPA映射注解。此示例使用`@javax.persistence.Entity`注解将`Item`类声明为持久化实体。现在，它的所有属性都自动使用默认策略实现持久化。这意味着你可以加载和存储`Item`的实例，并且该类的所有属性都是管理状态的一部分。
- en: Annotations are type-safe, and the JPA metadata is included in the compiled
    class files. The annotations are still accessible at runtime, and Hibernate reads
    the classes and metadata with Java reflection when the application starts. The
    IDE can also easily validate and highlight annotations—they’re regular Java types,
    after all. When you refactor your code, you rename, delete, and move classes and
    properties. Most development tools and editors can’t refactor XML elements and
    attribute values, but annotations are part of the Java language and are included
    in all refactoring operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是类型安全的，JPA元数据包含在编译后的类文件中。注解在运行时仍然可访问，当应用程序启动时，Hibernate使用Java反射读取类和元数据。IDE也可以轻松验证和突出显示注解——毕竟，它们是常规的Java类型。当你重构代码时，你会重命名、删除和移动类和属性。大多数开发工具和编辑器无法重构XML元素和属性值，但注解是Java语言的一部分，并包含在所有重构操作中。
- en: Is my class now dependent on JPA?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我的类现在是否依赖于JPA？
- en: You need JPA libraries on your classpath when you compile the source of your
    domain model class. JPA isn’t required on the classpath when you create an instance
    of the class, such as in a client application that doesn’t execute any JPA code.
    Only when you access the annotations through reflection at runtime (as Hibernate
    does internally when it reads your metadata) will you need the packages on the
    classpath.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译领域模型类的源代码时，需要在类路径上包含JPA库。在创建类的实例时，例如在客户端应用程序中（该应用程序不执行任何JPA代码），类路径上不需要JPA。只有当你通过反射在运行时访问注解（如Hibernate在读取你的元数据时内部所做的那样）时，你才需要在类路径上包含这些包。
- en: When the standardized Jakarta Persistence annotations are insufficient, a JPA
    provider may offer additional annotations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当标准化的Jakarta Persistence注解不足时，JPA提供者可能会提供额外的注解。
- en: Using vendor extensions
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用供应商扩展
- en: Even if you map most of your application’s model with JPA-compatible annotations
    from the `javax.persistence` package, you may have to use vendor extensions at
    some point. For example, some performance-tuning options you’d expect to be available
    in high-quality persistence software are only available as Hibernate-specific
    annotations. This is how JPA providers compete, so you can’t avoid annotations
    from other packages—there’s a reason why you chose to use Hibernate.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用来自`javax.persistence`包的与JPA兼容的注解映射了应用程序的大部分模型，你可能在某些时候不得不使用供应商扩展。例如，一些你期望在高质量持久化软件中可用的性能调整选项，仅作为Hibernate特定注解提供。这就是JPA供应商竞争的方式，因此你无法避免其他包中的注解——你选择使用Hibernate的原因是有其道理。
- en: 'The following snippet shows the `Item` entity source code again with a Hibernate-only
    mapping option:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段再次显示了`Item`实体源代码，并带有Hibernate特有的映射选项：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We prefer to prefix Hibernate annotations with the full `org.hibernate.annotations`
    package name. Consider this good practice, because it enables you to easily see
    which metadata for this class is from the JPA specification and which is vendor-specific.
    You can also easily search your source code for `org.hibernate.annotations` and
    get a complete overview of all nonstandard annotations in your application in
    a single search result.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢使用完整的`org.hibernate.annotations`包名作为Hibernate注解的前缀。这是一个好的做法，因为它使你能够轻松地看到这个类的哪些元数据来自JPA规范，哪些是供应商特定的。你还可以轻松地在源代码中搜索`org.hibernate.annotations`，并通过单个搜索结果获得应用程序中所有非标准注解的完整概述。
- en: If you switch your Jakarta Persistence provider, you’ll only have to replace
    the vendor-specific extensions, and you can expect a similar feature set to be
    available from most mature JPA implementations. Of course, we hope you’ll never
    have to do this, and it doesn’t often happen in practice—just be prepared.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换到Jakarta Persistence提供者，你只需替换供应商特定的扩展，并且可以期待从大多数成熟的JPA实现中获得类似的功能集。当然，我们希望你永远不需要这样做，实际上这种情况很少发生——只是做好准备。
- en: Annotations on classes only cover metadata that applies to that particular class.
    You’ll often also need metadata at a higher level for an entire package or even
    the whole application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类上的注解仅覆盖适用于该特定类的元数据。你通常还需要更高层次的元数据，用于整个包或整个应用程序。
- en: Global annotation metadata
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 全局注解元数据
- en: The `@Entity` annotation maps a particular class. JPA and Hibernate also have
    annotations for global metadata. For example, a `@NamedQuery` has a global scope;
    you don’t apply it to a particular class. Where should you place this annotation?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity`注解映射一个特定的类。JPA和Hibernate也有用于全局元数据的注解。例如，`@NamedQuery`有一个全局作用域；你不需要将其应用于特定的类。这个注解应该放在哪里？'
- en: Although it’s possible to place such global annotations in the source file of
    a class (at the top of any class), we prefer to keep global metadata in a separate
    file. Package-level annotations are a good choice; they’re in a file called package-info.java
    in a particular package directory. You will be able to look for them in a single
    place instead of browsing through several files. The following listing shows an
    example of global named query declarations (example 5 from the `domainmodel` folder
    source code).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将此类全局注解放置在类的源文件中（任何类的顶部）是可能的，但我们更喜欢将全局元数据保存在单独的文件中。包级别注解是一个不错的选择；它们位于特定包目录下的名为`package_info.java`的文件中。你将能够在单个位置找到它们，而不是浏览多个文件。以下列表显示了一个全局命名查询声明的示例（来自`domainmodel`文件夹源代码的第5个示例）。
- en: Listing 3.5 Global metadata in a package-info.java file
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 包含在package_info.java文件中的全局元数据
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Unless you’ve used package-level annotations before, the syntax of this file
    with the package and import declarations at the bottom is probably new to you.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你之前使用过包级别注解，否则这个文件中包含包和导入声明的语法可能对你来说很陌生。
- en: Annotations will be our primary tool for ORM metadata throughout this book,
    and there is much to learn about this subject. Before we look at the alternative
    mapping style using XML files, let’s use some simple annotations to improve our
    domain model classes with validation rules.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，注解将是我们的主要ORM元数据工具，关于这个主题有很多东西要学习。在我们查看使用XML文件替代的映射风格之前，让我们使用一些简单的注解来通过验证规则改进我们的领域模型类。
- en: 3.3.2 Applying constraints to Java objects
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 将约束应用于Java对象
- en: Most applications contain a multitude of data integrity checks. When you violate
    one of the simplest data-integrity constraints, you may get a `NullPointerException`
    because a value isn’t available. You may similarly get this exception when a string-
    valued property shouldn’t be empty (an empty string isn’t `null`), when a string
    has to match a particular regular expression pattern, or when a number or date
    value must be within a certain range.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都包含大量的数据完整性检查。当你违反了最简单的数据完整性约束之一时，你可能会得到一个`NullPointerException`，因为某个值不可用。当字符串值的属性不应该为空（空字符串不是`null`）时，当字符串必须匹配特定的正则表达式模式时，或者当数字或日期值必须在某个范围内时，你也可能会得到这个异常。
- en: 'These business rules affect every layer of an application: The user interface
    code has to display detailed and localized error messages. The business and persistence
    layers must check input values received from the client before passing them to
    the data store. The SQL database must be the final validator, guaranteeing the
    integrity of durable data.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些业务规则影响应用程序的每一层：用户界面代码必须显示详细和本地化的错误消息。业务和持久化层必须在将值传递给数据存储之前检查从客户端接收到的输入值。SQL数据库必须是最终的验证器，保证持久数据的完整性。
- en: The idea behind Bean Validation is that declaring rules such as “This property
    can’t be null” or “This number has to be in the given range” is much easier and
    less error-prone than repeatedly writing if-then-else procedures. Furthermore,
    declaring these rules on the central component of your application, the domain
    model implementation, enables integrity checks in every layer of the system. The
    rules are then available to the presentation and persistence layers. And if you
    consider how data-integrity constraints affect not only your Java application
    code but also your SQL database schema—which is a collection of integrity rules—you
    might think of Bean Validation constraints as additional ORM metadata.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation背后的理念是，声明规则，例如“这个属性不能为null”或“这个数字必须在给定的范围内”，比反复编写if-then-else过程要容易得多，且错误率更低。此外，在应用程序的核心组件——领域模型实现上声明这些规则，使得可以在系统的每一层进行完整性检查。这些规则随后对表示层和持久层都是可用的。如果你考虑到数据完整性约束不仅影响你的Java应用程序代码，还影响你的SQL数据库模式——这是一个完整性规则的集合——你可能会将Bean
    Validation约束视为额外的ORM元数据。
- en: Look at the following extended `Item` domain model class from the `validation`
    folder source code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`validation`文件夹源代码中的以下扩展的`Item`领域模型类。
- en: Listing 3.6 Applying validation constraints on `Item` entity fields
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 在`Item`实体字段上应用验证约束
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We add two attributes when an auction concludes: the `name` of an item and
    the `auctionEnd` date. Both are typical candidates for additional constraints.
    First, we want to guarantee that the name is always present and human-readable
    (one-character item names don’t make much sense) but not too long—your SQL database
    will be most efficient with variable-length strings up to 255 characters, and
    your user interface will also have some constraints on visible label space. Second,
    the ending time of an auction should obviously be in the future. If we don’t provide
    an error message for a constraint, a default message will be used. Messages can
    be keys to external property files for internationalization.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当拍卖结束时，我们添加两个属性：物品的`name`和`auctionEnd`日期。这两个都是添加额外约束的典型候选者。首先，我们想要保证名称始终存在且可读（单字符的物品名称没有太多意义），但不要太长——你的SQL数据库在长度最多为255个字符的变长字符串上效率最高，而且你的用户界面也会对可见标签空间有一些约束。其次，拍卖的结束时间显然应该在将来。如果我们没有为约束提供错误消息，将使用默认消息。消息可以是外部属性文件中的国际化键。
- en: The validation engine will access the fields directly if you annotate the fields.
    If you prefer to use calls through accessor methods, annotate the getter method
    with validation constraints, not the setter (annotations on setters are not supported).
    Then the constraints will be part of the class’s API and will be included in its
    Javadoc, making the domain model implementation easier to understand. Note that
    constraints being part of the class’s API is independent of access by the JPA
    provider; for example, Hibernate Validator may call accessor methods, whereas
    Hibernate ORM may call fields directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注解了字段，验证引擎将直接访问字段。如果你更喜欢通过访问器方法进行调用，请用验证约束注解getter方法，而不是setter（setter上的注解不受支持）。然后，约束将成为类API的一部分，并包含在其Javadoc中，这使得领域模型实现更容易理解。请注意，约束作为类API的一部分与JPA提供者的访问无关；例如，Hibernate
    Validator可能会调用访问器方法，而Hibernate ORM可能会直接调用字段。
- en: Bean Validation isn’t limited to built-in annotations; you can create your own
    constraints and annotations. With a custom constraint, you can even use class-level
    annotations and validate several attribute values at the same time on an instance
    of a class. The following test code shows how you could manually check the integrity
    of an `Item` instance.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 不仅限于内置注解；您可以创建自己的约束和注解。使用自定义约束，您甚至可以使用类级别的注解，并在类的实例上同时验证多个属性值。以下测试代码展示了如何手动检查
    `Item` 实例的完整性。
- en: Listing 3.7 Testing an `Item` instance for constraint violations
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 测试 `Item` 实例的约束违规
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’re not going to explain this code in detail but offer it for you to explore.
    You’ll rarely write this kind of validation code; usually this validation is automatically
    handled by your user interface and persistence framework. It’s therefore important
    to look for Bean Validation integration when selecting a UI framework.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细解释此代码，但提供给您探索。您很少会编写这种验证代码；通常这种验证是由您的用户界面和持久化框架自动处理的。因此，在选择 UI 框架时寻找 Bean
    Validation 集成是很重要的。
- en: 'Hibernate, as required from any JPA provider, also automatically integrates
    with Hibernate Validator if the libraries are available on the classpath, and
    it offers the following features:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate，如任何 JPA 提供程序所要求的，如果类路径上有库，也会自动与 Hibernate Validator 集成，并提供了以下功能：
- en: You don’t have to manually validate instances before passing them to Hibernate
    for storage.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将实例传递给 Hibernate 进行存储之前，您不需要手动验证实例。
- en: Hibernate recognizes constraints on persistent domain model classes and triggers
    validation before database insert or update operations. When validation fails,
    Hibernate throws a `ConstraintViolationException` containing the failure details
    to the code calling persistence-management operations.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate 识别持久化领域模型类上的约束，并在数据库插入或更新操作之前触发验证。当验证失败时，Hibernate 会抛出一个包含失败详情的 `ConstraintViolationException`
    异常给调用持久化管理操作的代码。
- en: The Hibernate toolset for automatic SQL schema generation understands many constraints
    and generates SQL DDL-equivalent constraints for you. For example, a `@NotNull`
    annotation translates into an SQL `NOT` `NULL` constraint, and a `@Size(n)` rule
    defines the number of characters in a `VARCHAR(n)`-typed column.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate 自动 SQL 模式生成工具集理解许多约束，并为您生成 SQL DDL 等价的约束。例如，`@NotNull` 注解转换为 SQL 的
    `NOT NULL` 约束，而 `@Size(n)` 规则定义了 `VARCHAR(n)` 类型列中的字符数。
- en: You can control this behavior of Hibernate with the `<validation-mode>` element
    in your persistence.xml configuration file. The default mode is `AUTO`, so Hibernate
    will only validate if it finds a Bean Validation provider (such as Hibernate Validator)
    on the classpath of the running application. With the `CALLBACK` mode, validation
    will always occur, and you’ll get a deployment error if you forget to bundle a
    Bean Validation provider. The `NONE` mode disables automatic validation by the
    JPA provider.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用持久化.xml 配置文件中的 `<validation-mode>` 元素来控制 Hibernate 的此行为。默认模式是 `AUTO`，因此
    Hibernate 只有在运行应用程序的类路径上找到 Bean Validation 提供程序（如 Hibernate Validator）时才会进行验证。使用
    `CALLBACK` 模式，验证将始终发生，如果您忘记捆绑 Bean Validation 提供程序，则会收到部署错误。`NONE` 模式禁用了 JPA 提供程序的自动验证。
- en: You’ll see Bean Validation annotations again later in this book; you’ll also
    find them in the example code bundles. We could write much more about Hibernate
    Validator, but we’d only repeat what is already available in the project’s excellent
    reference guide ([http://mng.bz/ne65)](http://mng.bz/ne65). Take a look and find
    out more about features such as validation groups and the metadata API for the
    discovery of constraints.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本书后面的内容中再次看到 Bean Validation 注解；您也会在示例代码包中找到它们。我们本可以写更多关于 Hibernate Validator
    的内容，但我们只会重复项目优秀参考指南中已有的内容（[http://mng.bz/ne65](http://mng.bz/ne65)）。请查看并了解更多关于验证组以及约束发现元数据
    API 的功能。
- en: 3.3.3 Externalizing metadata with XML files
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 使用 XML 文件外部化元数据
- en: You can replace or override every annotation in JPA with an XML descriptor element.
    In other words, you don’t have to use annotations if you don’t want to, or if
    keeping mapping metadata separate from source code is advantageous to your system
    design for whatever reason. Keeping the mapping metadata separate has the benefit
    of not cluttering the JPA annotations with Java code and of making your Java classes
    more reusable, though you lose the type-safety. This approach is less in use nowadays,
    but we’ll analyze it anyway, as you may still encounter it or choose this approach
    for your own projects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用 XML 描述符元素替换或覆盖 JPA 中的每个注解。换句话说，如果您不想使用注解，或者出于某种原因将映射元数据与源代码分开对您的系统设计有利，您不必使用注解。将映射元数据分开的好处是避免在
    JPA 注解中混入 Java 代码，并使您的 Java 类更具可重用性，尽管您会失去类型安全性。这种方法现在使用较少，但我们仍将分析它，因为您可能仍然会遇到它或选择这种方法用于您自己的项目。
- en: XML metadata with JPA
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 JPA 的 XML 元数据
- en: The following listing shows a JPA XML descriptor for a particular persistence
    unit (the `metadataxmljpa` folder source code).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个特定持久化单元的 JPA XML 描述符（`metadataxmljpa` 文件夹源代码）。
- en: Listing 3.8 JPA XML descriptor containing the mapping metadata of a persistence
    unit
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 包含持久化单元映射元数据的 JPA XML 描述符
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ⓐ Declare the global metadata.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 声明全局元数据。
- en: Ⓑ Ignore all mapping annotations. If we include the `<xml-mapping-metadata-
    complete>` element, the JPA provider ignores all annotations on the domain model
    classes in this persistence unit and relies only on the mappings as defined in
    the XML descriptors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 忽略所有映射注解。如果我们包含 `<xml-mapping-metadata-complete>` 元素，JPA 提供商将忽略此持久化单元中域模型类上的所有注解，并仅依赖于在
    XML 描述符中定义的映射。
- en: Ⓒ The default settings escape all SQL columns, tables, and other names.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 默认设置会转义所有 SQL 列、表和其他名称。
- en: Ⓓ Escaping is useful if the SQL names are actually keywords (a "USER" table,
    for example).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 如果 SQL 名称实际上是关键字（例如，“USER”表），则转义很有用。
- en: Ⓔ Declare the `Item` class as an entity with field access.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 将 `Item` 类声明为一个具有字段访问权限的实体。
- en: Ⓕ Its attributes are the `id`, which is autogenerated, the `name`, and the `auctionEnd`,
    which is a temporal field.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 它的属性包括自动生成的 `id`、`name` 和时间字段 `auctionEnd`。
- en: 'The JPA provider automatically picks up this descriptor if you place it in
    a META-INF/ orm.xml file on the classpath of the persistence unit. If you prefer
    to use a different filename or several files, you’ll have to change the configuration
    of the persistence unit in your META-INF/persistence.xml file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此描述符放置在持久化单元类路径上的 `META-INF/orm.xml` 文件中，JPA 提供商将自动获取此描述符。如果您希望使用不同的文件名或多个文件，您必须更改您
    `META-INF/persistence.xml` 文件中的持久化单元配置：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you don’t want to ignore the annotation metadata but override it instead,
    don’t mark the XML descriptors as “complete,” and name the class and property
    you want to override:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想忽略注解元数据而是覆盖它，不要将 XML 描述符标记为“完整”，并命名您想要覆盖的类和属性：
- en: '[PRE16]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we map the `name` property to the `ITEM_NAME` column; by default, the property
    would map to the `NAME` column. Hibernate will now ignore any existing annotations
    from the `javax.persistence.annotation` and `org.hibernate.annotations` packages
    on the `name` property of the `Item` class. But Hibernate won’t ignore Bean Validation
    annotations and still applies them for automatic validation and schema generation!
    All other annotations on the `Item` class are also recognized. Note that we don’t
    specify an access strategy in this mapping, so field access or accessor methods
    are used, depending on the position of the `@Id` annotation in `Item`. (We’ll
    get back to this detail in the next chapter.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `name` 属性映射到 `ITEM_NAME` 列；默认情况下，属性会映射到 `NAME` 列。Hibernate 现在将忽略 `Item`
    类的 `name` 属性上来自 `javax.persistence.annotation` 和 `org.hibernate.annotations` 包的任何现有注解。但
    Hibernate 不会忽略 Bean Validation 注解，并且仍然应用它们进行自动验证和模式生成！`Item` 类上的其他所有注解也被识别。请注意，我们在此映射中没有指定访问策略，因此根据
    `@Id` 注解在 `Item` 中的位置，将使用字段访问或访问器方法。（我们将在下一章中回到这个细节。）
- en: 'We won’t talk much about JPA XML descriptors in this book. The syntax of these
    documents is the same as the JPA annotation syntax, so you shouldn’t have any
    problems writing them. We’ll focus on the important aspect: the mapping strategies.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会过多地讨论 JPA XML 描述符。这些文档的语法与 JPA 注解语法相同，因此您在编写它们时不应有任何问题。我们将关注重要方面：映射策略。
- en: 3.3.4 Accessing metadata at runtime
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 在运行时访问元数据
- en: The JPA specification provides programming interfaces for accessing the metamodel
    (information about the model) of persistent classes. There are two flavors of
    the API. One is more dynamic in nature and similar to basic Java reflection. The
    second option is a static metamodel. For both options, access is read-only; you
    can’t modify the metadata at runtime.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 规范提供了访问持久类（模型信息）的编程接口。该 API 有两种类型。一种在本质上更动态，类似于基本的 Java 反射。第二种选项是静态元模型。对于这两种选项，访问都是只读的；你无法在运行时修改元数据。
- en: The dynamic Metamodel API in Jakarta Persistence
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Persistence 中的动态元模型 API
- en: Sometimes you’ll want to get programmatic access to the persistent attributes
    of an entity, such as when you want to write custom validation or generic UI code.
    You’d like to know dynamically what persistent classes and attributes your domain
    model has. The code in the following listing shows how you can read metadata with
    Jakarta Persistence interfaces (from the `metamodel` folder source code).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能会想要以编程方式访问实体的持久属性，例如当你想要编写自定义验证或通用 UI 代码时。你希望动态地知道你的领域模型有哪些持久类和属性。以下列表中的代码展示了如何使用
    Jakarta Persistence 接口（来自 `metamodel` 文件夹的源代码）读取元数据。
- en: Listing 3.9 Obtaining entity type information with the Metamodel API
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 使用元模型 API 获取实体类型信息
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can get the `Metamodel` object from either the `EntityManagerFactory`,
    of which you’ll typically have only one instance per data source in an application,
    or, if it’s more convenient, by calling `EntityManager#getMetamodel()`. The set
    of managed types contains information about all persistent entities and embedded
    classes (which we’ll discuss in the next chapter). In this example, there’s only
    one managed type: the `Item` entity. This is how you can dig deeper and find out
    more about each attribute.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 `EntityManagerFactory` 获取 `Metamodel` 对象，通常在应用程序中每个数据源只有一个实例，或者，如果更方便的话，通过调用
    `EntityManager#getMetamodel()`。管理类型集合包含有关所有持久实体和嵌入类的信息（我们将在下一章中讨论）。在这个例子中，只有一个管理类型：`Item`
    实体。这就是你可以深入了解并获取每个属性更多信息的方法。
- en: Listing 3.10 Obtaining entity attribute information with the Metamodel API
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 使用元模型 API 获取实体属性信息
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ⓐ The attributes of the entity are accessed with a string: the `id`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 实体的属性通过字符串访问：`id`。
- en: Ⓑ Check that the `id` attribute is not optional. This means that it cannot be
    NULL, since it is the primary key.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 检查 `id` 属性不是可选的。这意味着它不能为 NULL，因为它是主键。
- en: ⒸThe `name.`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ`name.`
- en: ⒹCheck that the `name` attribute has the `String` Java type and the basic persistent
    attribute type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 检查 `name` 属性是否具有 `String` Java 类型以及基本持久属性类型。
- en: Ⓔ The `auctionEnd` date. This obviously isn’t type-safe, and if you change the
    names of the attributes, this code will be broken and obsolete. The strings aren’t
    automatically included in the refactoring operations of your IDE.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `auctionEnd` 日期。这显然不是类型安全的，如果你更改属性的名称，此代码将损坏并过时。字符串不会自动包含在你的 IDE 的重构操作中。
- en: Ⓕ Check that the `auctionEnd` attribute has the `Date` Java type and that it
    is not a collection or an association.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 检查 `auctionEnd` 属性是否具有 `Date` Java 类型，并且它不是一个集合或关联。
- en: JPA also offers a static type-safe metamodel.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 还提供了静态类型安全的元模型。
- en: Using a static metamodel
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态元模型
- en: 'In Java (at least up to version 17), you can’t access the fields or accessor
    methods of a bean in a type-safe fashion—only by their names, using strings. This
    is particularly inconvenient with JPA criteria querying, which is a type-safe
    alternative to string-based query languages. Here’s an example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java（至少到版本 17），你不能以类型安全的方式访问 bean 的字段或访问器方法——只能通过它们的名称，使用字符串。这对于 JPA 条件查询来说尤其不方便，它是一种基于字符串查询语言的类型安全替代品。以下是一个例子：
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Ⓐ The query is the equivalent of `select i from Item i`. This query returns
    all items in the database, and there are two in this case. If you want to restrict
    this result and only return items with a particular name, you will have to use
    a `like` expression, comparing the `name` attribute of each item with the pattern
    set in a parameter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 查询等同于 `select i from Item i`。此查询返回数据库中的所有项目，在这个例子中有两个。如果你想要限制这个结果并只返回具有特定名称的项目，你必须使用
    `like` 表达式，将每个项目的 `name` 属性与参数中设置的模式进行比较。
- en: 'The following code introduces a filter on the read operation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在读取操作上引入了一个过滤器：
- en: '[PRE20]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ⓐ The query is the equivalent of `select` `i` `from` `Item` `i` `where` `i.name`
    `like` `:pattern`. Notice that the `namePath` lookup requires the `name` string.
    This is where the type-safety of the criteria query breaks down. You can rename
    the `Item` entity class with your IDE’s refactoring tools, and the query will
    still work. But as soon as you touch the `Item#name` property, manual adjustments
    are necessary. Luckily, you’ll catch this when the test fails.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 查询相当于 `select` `i` `from` `Item` `i` `where` `i.name` `like` `:pattern`。请注意，`namePath`
    查询需要 `name` 字符串。这就是类型安全的查询条件查询崩溃的地方。你可以使用你的 IDE 的重构工具重命名 `Item` 实体类，查询仍然会工作。但是，一旦你触及
    `Item#name` 属性，就需要手动调整。幸运的是，你会在测试失败时捕捉到这一点。
- en: 'A much better approach that’s safe for refactoring and that detects mismatches
    at compile time and not runtime is the type-safe static metamodel:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的方法，它对重构是安全的，并在编译时而不是运行时检测不匹配的是类型安全的静态元模型：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The special class here is `Item_`; note the underscore. This class is a metadata
    class, and it lists all the attributes of the `Item` entity class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的特殊类是 `Item_`；注意下划线。这个类是一个元数据类，它列出了 `Item` 实体类的所有属性：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This class will be automatically generated. The Hibernate JPA 2 Metamodel Generator
    (a subproject of the Hibernate suite) takes care of this. Its only purpose is
    to generate static metamodel classes from your managed persistent classes. You
    need to add this Maven dependency to your pom.xml file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将自动生成。Hibernate JPA 2 Metamodel Generator（Hibernate 套件的一个子项目）负责此操作。它的唯一目的是从你的受管理持久化类中生成静态元模型类。你需要在
    pom.xml 文件中添加此 Maven 依赖项：
- en: '[PRE23]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It will run automatically whenever you build your project and will generate
    the appropriate `Item_` metadata class. You will find the generated classes in
    the target\ generated-sources folder.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你构建项目时，它将自动运行并生成适当的 `Item_` 元数据类。你将在目标\ generated-sources 文件夹中找到生成的类。
- en: This chapter discussed the construction of the domain model and the dynamic
    and static metamodel. Although you’ve seen some mapping constructs in the previous
    sections, we haven’t introduced any more sophisticated class and property mappings
    so far. You should now decide which mapping metadata strategy you’d like to use
    in your project—we recommend the more commonly used annotations, instead of the
    already less used XML. Then you can read more about class and property mappings
    in part 2 of this book, starting with chapter 5.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了领域模型的构建以及动态和静态元模型。尽管你在前面的部分中看到了一些映射结构，但我们还没有介绍任何更复杂的类和属性映射。现在你应该决定在你的项目中想使用哪种映射元数据策略——我们建议使用更常用的注解，而不是已经较少使用的
    XML。然后你可以阅读本书的第二部分，从第 5 章开始，了解更多关于类和属性映射的内容。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We analyzed different abstract notions like the information model and data model,
    and then jumped into JPA/Hibernate so that we could work with databases from Java
    programs.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们分析了不同的抽象概念，如信息模型和数据模型，然后跳入 JPA/Hibernate，以便我们可以在 Java 程序中与数据库一起工作。
- en: You can implement persistent classes free of any cross-cutting concerns like
    logging, authorization, and transaction demarcation.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以无任何跨切面关注点（如日志记录、授权和事务划分）地实现持久化类。
- en: The persistent classes only depend on JPA at compile time.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化类仅在编译时依赖于 JPA。
- en: Persistence-related concerns should not leak into the domain model implementation.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与持久化相关的关注点不应泄漏到领域模型实现中。
- en: Transparent persistence is important if you want to execute and test the business
    objects independently.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明持久化对于你想要独立执行和测试业务对象来说非常重要。
- en: 'The POJO concept and the JPA entity programming model have several things in
    common, arising from the old JavaBean specification: they implement properties
    as private or protected member fields, while property accessor methods are generally
    public or protected.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POJO 概念和 JPA 实体编程模型有几个共同点，这些共同点源于旧的 JavaBean 规范：它们将属性实现为私有或受保护的成员字段，而属性访问方法通常是公共或受保护的。
- en: We can access the metadata using either the dynamic metamodel or the static
    metamodel.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用动态元模型或静态元模型来访问元数据。
