- en: Unit 8\. Deploying and managing code in production
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8单元：在生产环境中部署和管理代码
- en: At just about any stage of your application development, you likely wonder when
    people can start using what you’ve built. The eagerness is justified. Luckily,
    you have many ways to get your application online. Deploying an application is
    one of the most daunting tasks for new developers building web applications. Part
    of the struggle is understanding the resources and services that assist with deployment.
    The deployment process is much more than uploading your application code somewhere,
    at least during your first attempt. If done correctly, making changes in a production
    application can be simple. Some problems with making changes in your production
    application include running into restrictions that limit the database content
    that you can modify, accidentally removing code used to verify incoming data,
    and making changes in your local environment that don’t work in your production
    environment, such as configuration changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在您应用程序开发的任何阶段，您可能都会想知道人们何时可以开始使用您所构建的内容。这种渴望是合理的。幸运的是，您有多种方法可以使您的应用程序上线。对于构建网络应用程序的新开发者来说，部署应用程序是其中最令人畏惧的任务之一。部分挑战在于理解有助于部署的资源和服务。部署过程远不止是将您的应用程序代码上传到某个地方，至少在您的第一次尝试中是这样的。如果操作得当，对生产应用程序进行更改可以变得简单。在您的生产应用程序中进行更改时可能遇到的问题包括遇到限制，这些限制限制了您可以修改的数据库内容，意外删除用于验证传入数据的代码，以及在本地环境中进行更改，这些更改在生产环境中不起作用，例如配置更改。
- en: In this unit, you set up your application to deploy on Heroku, a cloud service
    that hosts and runs your application for you. First, you prepare your application’s
    configuration files to ensure that functionality will work locally and in production.
    Then you follow a few steps to launch your application on Heroku and set up your
    MongoDB database. After a short lesson, you’ll have your recipe application running
    under a URL that you can share with family and friends. In a subsequent lesson,
    you explore ways to improve your code for future refinement. I talk about *linting*
    your code, a process used to identify inefficient code with the help of an external
    package. At the end of the unit, you’ll get a chance to apply unit and integration
    testing to your code. These tests provide fundamental protection against accidentally
    breaking your code in the future. You install the mocha and chai packages to help
    set up tests for Express.js actions and routes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本单元中，您将设置应用程序以便在 Heroku 上部署，Heroku 是一种云服务，可为您托管和运行应用程序。首先，您准备应用程序的配置文件，以确保功能可以在本地和在生产环境中正常工作。然后，您遵循几个步骤在
    Heroku 上启动应用程序并设置 MongoDB 数据库。经过简短的课程学习后，您的食谱应用程序将在一个您可以与家人和朋友分享的 URL 下运行。在随后的课程中，您将探索改进代码以供未来改进的方法。我谈论了*代码检查*，这是一个使用外部包来识别低效代码的过程。在本单元结束时，您将有机会对您的代码进行单元和集成测试。这些测试提供了对未来可能意外破坏代码的基本保护。您安装
    mocha 和 chai 包以帮助设置 Express.js 动作和路由的测试。
- en: 'This unit covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本单元涵盖了以下主题：
- en: '[Lesson 34](../Text/kindle_split_053.html#ch34) guides you through the preparation
    steps to complete before your application is production-ready. In this lesson,
    you set up your application to deploy to Heroku along with a new MongoDB database
    provided as a plugin on Heroku’s services.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第34课](../Text/kindle_split_053.html#ch34)将引导您完成在应用程序准备就绪之前需要准备的工作步骤。在本课中，您将设置应用程序以便部署到
    Heroku，同时使用 Heroku 上的服务插件提供的新的 MongoDB 数据库。'
- en: '[Lesson 35](../Text/kindle_split_054.html#ch35) shows how to catch small bugs
    in your code through the linting process and how to correct those bugs with the
    help of a debugging tool. By the end of this lesson, you’ll have a set of tricks
    to pull out of your back pocket whenever you need to clean up your code.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第35课](../Text/kindle_split_054.html#ch35)展示了如何通过代码检查过程捕捉代码中的小错误，以及如何借助调试工具纠正这些错误。在本课结束时，您将掌握一整套技巧，以便在需要清理代码时随时使用。'
- en: '[Lesson 36](../Text/kindle_split_055.html#ch36) introduces testing concepts
    in Node.js. This lesson touches the surface of test code you can write to ensure
    that functionality in your application doesn’t break over time.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第36课](../Text/kindle_split_055.html#ch36)介绍了 Node.js 中的测试概念。本课触及了您可以编写的测试代码的表面，以确保您应用程序的功能不会随着时间的推移而损坏。'
- en: '[Lesson 37](../Text/kindle_split_056.html#ch37) (the capstone lesson) walks
    through using the deployment steps you learned in this unit to deploy the Confetti
    Cuisine application.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第37课](../Text/kindle_split_056.html#ch37)（总结课程）将指导您如何使用在本单元中学到的部署步骤来部署 Confetti
    Cuisine 应用程序。'
- en: Lesson 34\. Deploying your application
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第34课\. 部署您的应用程序
- en: At this stage, you’ve completed a few iterations of your application, and it’s
    time to make it available to the World Wide Web. This lesson introduces application
    deployment with Heroku. First, you set up your application to work with Heroku’s
    services and plugins. In a few easy steps, you’ll have your application live,
    with a unique URL that you can share with your friends. Next, you see how to set
    up your MongoDB database and populate your application with content. Last, you
    learn about tools you can use with Heroku to monitor your application in production,
    as well as guidelines for making future changes in your production code and Heroku
    plugins worth exploring further.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您已经完成了应用程序的几个迭代，现在是时候让它对整个互联网开放了。本课介绍了使用Heroku的应用程序部署。首先，您设置您的应用程序以与Heroku的服务和插件协同工作。在几个简单的步骤中，您将使您的应用程序上线，并拥有一个独特的URL，您可以与您的朋友分享。接下来，您将了解如何设置您的MongoDB数据库，并用内容填充您的应用程序。最后，您将了解可以使用Heroku的工具来监控生产中的应用程序，以及关于在您的生产代码中进行未来更改和值得进一步探索的Heroku插件的指南。
- en: This lesson covers
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Configuring a Node.js application for Heroku
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Heroku配置Node.js应用程序
- en: Deploying a Node.js application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署Node.js应用程序
- en: Setting up a remote MongoDB database
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置远程MongoDB数据库
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You’ve spent countless hours adding features and functionality to your application,
    only to have it run locally on your personal computer. It’s about time that you
    expose your work on the recipe application to the public. The final step in the
    development process is deployment. In this lesson, I discuss the necessary steps
    to get your application ready for production.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经花费了无数小时为您的应用程序添加功能和功能，结果它只在本地的个人计算机上运行。是时候将您的食谱应用程序的工作公之于众了。开发过程的最后一步是部署。在本课中，我将讨论使您的应用程序为生产准备所需的步骤。
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)34.1\. Preparing for deployment'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)34.1\. 部署准备'
- en: '*Deployment* is the process of taking your application code from your development
    environment and publishing and running it on the internet to make it accessible
    to the public. Until this point, you’ve been developing your application in a
    local environment. Developers would refer to the application running at http://`localhost:3000`
    as running in your development environment.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署*是将您的应用程序代码从开发环境带到互联网上发布和运行的过程，使其对公众可访问。到目前为止，您一直在本地环境中开发您的应用程序。开发者会将运行在http://`localhost:3000`的应用程序称为运行在您的开发环境中。'
- en: 'One option is to set up a new environment. You need to re-create the system
    settings and resources that made it possible to run your application on your own
    machine: a physical computer with Node.js installed, the ability to install any
    external packages, and a JavaScript engine to run the application. There’s no
    escaping the fact that your application depends on physical hardware to function.
    For this reason, deploying your application to a *production environment*, somewhere
    accessible to others online, requires some machine or service to run your application.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是设置一个新的环境。您需要重新创建使您的应用程序在您的机器上运行所需的系统设置和资源：安装了Node.js的物理计算机、安装任何外部包的能力以及运行应用程序的JavaScript引擎。您的应用程序依赖于物理硬件来运行这一事实是无法避免的。因此，将您的应用程序部署到*生产环境*，即其他人可以在线访问的地方，需要某种机器或服务来运行您的应用程序。
- en: You could set up your own computer to run your application and configure your
    home network to permit users to reach your application via your home’s external
    IP address. The configuration steps are a bit involved, though; they might pose
    security threats to your home internet network; and they’re beyond the scope of
    this book. Also, if your computer shut down, your application would be unreachable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置自己的计算机来运行您的应用程序，并配置您的家庭网络以允许用户通过您家的外部IP地址访问您的应用程序。尽管配置步骤有些复杂；它们可能对您的家庭互联网网络构成安全威胁；并且它们超出了本书的范围。此外，如果您的计算机关闭，您的应用程序将无法访问。
- en: The popular alternative is to use one of many cloud services to host and run
    your application. These services often come at a cost, but for demonstration purposes,
    you can deploy your application through Heroku’s free account services. Heroku
    is a cloud-based platform that offers servers—the physical processing computers
    and memory—to run your application. What’s more, these computers often come prepackaged
    with the installation of Node.js that you need and require very little setup on
    the developer’s part.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的替代方案是使用许多云服务之一来托管和运行你的应用程序。这些服务通常需要付费，但为了演示目的，你可以通过Heroku的免费账户服务来部署你的应用程序。Heroku是一个基于云的平台，它提供服务器——物理处理计算机和内存——来运行你的应用程序。更重要的是，这些计算机通常预装了你需要安装的Node.js，并且对开发者的设置要求非常少。
- en: To get started with deployment, ensure that you have the Heroku command-line
    interface installed by running `heroku --version` in terminal (`heroku version`
    in the Windows command line). Also make sure that you have Git installed by running
    `git --version`. If you see some version of these tools printed on the screen,
    you can continue to the deployment steps.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始部署，请确保你已经通过在终端中运行`heroku --version`（在Windows命令行中为`heroku version`）安装了Heroku命令行界面。同时，确保你已经通过运行`git
    --version`安装了Git。如果你在屏幕上看到这些工具的某个版本，你可以继续到部署步骤。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you haven’t yet created your Heroku account, set up the command-line interface
    (CLI), or installed Git, please follow the instructions in [lesson 2](../Text/kindle_split_013.html#ch02).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有创建你的Heroku账户，设置命令行界面（CLI），或者安装Git，请按照[课程2](../Text/kindle_split_013.html#ch02)中的说明进行操作。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Before you can deploy to Heroku, you need to make a couple of changes to your
    application to make it compatible with the services that Heroku provides. Heroku
    will run your application by using the application’s `PORT` environment variable,
    so you need to have your application ready to listen at both ports, as shown in
    the next listing. In this code, you create a constant, `port`, and assign it to
    the `PORT` environmental variable, if it exists. Otherwise, the port defaults
    to 3000\. This port number should remain the same as in previous lessons.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将应用程序部署到Heroku之前，你需要对应用程序进行一些更改，使其与Heroku提供的服务兼容。Heroku将通过使用应用程序的`PORT`环境变量来运行你的应用程序，因此你需要让你的应用程序准备好在两个端口上监听，如下一列表所示。在这段代码中，你创建了一个常量`port`，并将其分配给`PORT`环境变量，如果它存在的话。否则，端口默认为3000。这个端口号应该与之前的课程中的一致。
- en: Listing 34.1\. Changing the application’s port in main.js
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表34.1\. 在main.js中更改应用程序的端口
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Assign the port constant.**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **分配端口号常量。**'
- en: '***2*** **Listen at the port assigned to port.**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **监听分配给端口的端口。**'
- en: 'Similar to the way that Heroku specifies the application’s port, the database
    you’ll use also can be defined in an environmental variable. In main.js, change
    the database connection line to `mongoose.connect(process.env.MONGODB_URI || "mongodb://localhost:27017/recipe_db",
    {useNewUrlParser: true})`. This line tells Mongoose to connect to the database
    defined in `MONGODB_URI` or to default to your local `recipe_db` database location.
    (See section 3 for details on why this environmental variable exists.)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '与Heroku指定应用程序端口的类似方式，你将要使用的数据库也可以在环境变量中定义。在main.js中，将数据库连接行更改为`mongoose.connect(process.env.MONGODB_URI
    || "mongodb://localhost:27017/recipe_db", {useNewUrlParser: true})`。这一行告诉Mongoose连接到`MONGODB_URI`中定义的数据库，或者默认连接到你的本地`recipe_db`数据库位置。（参见第3节了解为什么存在这个环境变量。）'
- en: 'Last, create a new file called Procfile at the application’s root. This file
    has no extensions or suffix, and its name is case-sensitive. Heroku uses this
    file to find out how to launch your application. Add `web: node main.js` to this
    file. This single line tells Heroku to create a new server, called a *dyno*, intended
    for web interaction, and to use `node main.js` to start the application.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，在应用程序的根目录下创建一个名为Procfile的新文件。此文件没有扩展名或后缀，并且其名称区分大小写。Heroku使用此文件来确定如何启动你的应用程序。将`web:
    node main.js`添加到此文件。这一行告诉Heroku创建一个新的服务器，称为*dyno*，用于网络交互，并使用`node main.js`来启动应用程序。'
- en: With these three changes in place, you can finally deploy the application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个更改到位后，你终于可以部署应用程序了。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 34.1**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查34.1**'
- en: '**[Q1:](#ch34qa2q0a1)**'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch34qa2q0a1)**'
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you need the Procfile in your project folder?
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么你的项目文件夹中需要Procfile？
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 34.1 answer**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 34.1 答案**'
- en: '**[1:](#ch34qa1q1)**'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch34qa1q1)**'
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Heroku uses the Procfile as a configuration file to start your application.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Heroku使用Procfile作为配置文件来启动你的应用程序。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)34.2\. Deploying your application'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)34.2\. 部署你的应用程序'
- en: With the appropriate configurations in place, you can use Git and the Heroku
    CLI to deploy your application. Throughout this book, you haven’t used Git for
    version control. Although versioning your code isn’t necessary in your development
    environment, it’s good practice, and in the case of deployment, it’s required
    to get your application to its production environment on Heroku. If you’re using
    Git for the first time, go to your project’s root directory in terminal, and initialize
    the project with Git by running `git init`. In the next step, you add the files
    that you want in your Git repo, but you don’t want some files in this repo.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当配置的情况下，你可以使用Git和Heroku CLI来部署你的应用程序。在整个这本书中，你没有使用Git进行版本控制。尽管在你的开发环境中对代码进行版本控制不是必需的，但这是一个好习惯，在部署的情况下，这是必需的，以便将你的应用程序部署到Heroku的生产环境。如果你是第一次使用Git，请在终端中转到你的项目根目录，通过运行`git
    init`来使用Git初始化项目。在下一步中，你添加你想要添加到Git仓库的文件，但你不想在这个仓库中添加某些文件。
- en: You may recall that the `node_modules` folder gets created when you run `npm
    install`. This folder can get pretty large, and adding it to your Git repo isn’t
    recommended. To ignore this folder, create a new file called .gitignore at the
    root of your application directory. Add `/node_modules` to that file in your text
    editor, and save. That’s all you need to do for Git to know not to add those files
    within this folder.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，当你运行`npm install`时，会创建一个`node_modules`文件夹。这个文件夹可能相当大，不建议将其添加到你的Git仓库中。为了忽略这个文件夹，在你的应用程序目录的根目录下创建一个新的文件名为`.gitignore`。在你的文本编辑器中将`/node_modules`添加到该文件中，并保存。这就是Git知道不要添加这个文件夹内文件的所有操作。
- en: To bundle your application code into a specific version, add the rest of the
    application’s files to Git’s staging level by running `git add .` (including the
    period). Then run the command `git commit -m "Initial application commit"` to
    save and commit this version of your code and receive a feedback message.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的应用程序代码捆绑到特定版本，通过运行`git add .`（包括点号）将应用程序的其余文件添加到Git的暂存区。然后运行命令`git commit
    -m "Initial application commit"`来保存并提交此版本的代码，并接收一条反馈信息。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Any other changes you make that aren’t added and committed following the same
    process won’t appear in your production environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你所做的任何其他更改，如果没有按照相同的过程添加和提交，将不会出现在你的生产环境中。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: With your code in version control, you can use the `heroku` keyword in terminal
    to initiate a new application for deployment. Run the command `heroku create`
    in your project directory in terminal to generate a new URL for your project.
    The response detailing the name of your Heroku application, its URL, and Git repository
    should resemble the following listing. This command also creates a connection
    to Heroku’s remote Git repository for your code. You can run the command `git
    remote -v` to reveal the URL to that repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用版本控制中的代码，你可以在终端中使用`heroku`关键字来启动一个新的应用程序进行部署。在终端中运行`heroku create`命令，在你的项目目录中生成一个新的项目URL。详细说明你的Heroku应用程序名称、URL和Git仓库的响应应该类似于以下列表。此命令还会创建一个连接到你的代码在Heroku的远程Git仓库。你可以运行`git
    remote -v`命令来查看该仓库的URL。
- en: Listing 34.2\. Creating a new Heroku app
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表34.2\. 创建新的Heroku应用程序
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **Display the results of creating a new Heroku app.**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示创建新Heroku应用程序的结果。**'
- en: Next, push your latest versioned code from your computer to the Heroku repository
    you set up. Publishing your code is the same as uploading your code to a server
    that will host your application on the internet. You can publish by running the
    command `git push heroku master`. This step is the most important part of the
    process because it’s where all your code gets uploaded and published on Heroku’s
    services. This step is also when Heroku runs `npm install` to download all your
    application’s package dependencies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将你的最新版本代码从计算机推送到你设置的Heroku仓库。发布你的代码就像是将你的代码上传到服务器一样，该服务器将在互联网上托管你的应用程序。你可以通过运行命令`git
    push heroku master`来发布。这一步是整个过程中最重要的部分，因为这是所有代码上传和发布到Heroku服务的地方。这一步也是Heroku运行`npm
    install`来下载所有应用程序包依赖的时候。
- en: This process may take about a minute, depending on your internet connection.
    If you experience any issue or notice an error in the process, make sure that
    you can still run your application locally before trying again.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能需要大约一分钟，具体取决于你的互联网连接。如果你在过程中遇到任何问题或注意到错误，在再次尝试之前，请确保你仍然可以在本地运行你的应用程序。
- en: If your application didn’t depend on a database, you could go directly to the
    URL provided after the `heroku create` command in your browser. If you try visiting
    your application’s `/courses` URL, you may see an error page ([figure 34.1](#ch34fig01)).
    Because your home page doesn’t depend on any persistent data, however, that page
    should load without any errors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序不依赖于数据库，你可以直接在浏览器中访问 `heroku create` 命令后面的URL。如果你尝试访问应用程序的 `/courses`
    URL，你可能会看到一个错误页面（[图34.1](#ch34fig01)）。然而，由于你的主页不依赖于任何持久数据，因此该页面应该能够无错误地加载。
- en: Figure 34.1\. Displaying the Heroku error page
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图34.1. 显示Heroku错误页面
- en: '![](../Images/34fig01_alt.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/34fig01_alt.jpg)'
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you still have remnants of the `bcrypt` package in your project, you might
    run into issues with deployment to heroku depending on your version of Node.js.
    Try unninstalling `bcrypt` and replacing it with `bcrypt` in usersController.js.
    In terminal you’ll need to run `npm uninstall bcrypt && npm i bcrypt -S`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你项目中仍然有 `bcrypt` 包的残留，根据你的Node.js版本，你可能会在部署到Heroku时遇到问题。尝试卸载 `bcrypt` 并在 usersController.js
    中替换为 `bcrypt`。在终端中，你需要运行 `npm uninstall bcrypt && npm i bcrypt -S`。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This error likely has to do with the fact that you haven’t set up your database
    yet. You can verify, though, by running the command `heroku logs --tail` in your
    project’s terminal window. This command provides a live feed of logs from the
    application online. You’ll find a lot of messages here, and it’s the first place
    I recommend checking if you experience any issue with your application in the
    future. Suppose that you see an error for a missing database. You can fix the
    problem by connecting to a MongoDB database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误很可能是因为你还没有设置你的数据库。不过，你可以在项目的终端窗口中运行命令 `heroku logs --tail` 来验证。这个命令提供了应用程序在线日志的实时流。你在这里会找到很多消息，如果你在未来的应用程序中遇到任何问题，我推荐你首先检查这里。假设你看到一个关于缺失数据库的错误。你可以通过连接到一个MongoDB数据库来修复这个问题。
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you need some assistance with your Heroku CLI commands, run the command -`heroku
    help` in terminal or visit https:`/`/devcenter.heroku.com/articl`es/heroku-cli--commands`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一些关于Heroku CLI命令的帮助，请在终端中运行命令 `-`heroku help`，或者访问 https:`/`/devcenter.heroku.com/articl`es/heroku-cli--commands`。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 34.2**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查34.2**'
- en: '**[Q1:](#ch34qa4q0a1)**'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch34qa4q0a1)**'
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the `heroku create` command do?
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`heroku create` 命令的作用是什么？'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 34.2 answer**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 34.2 答案**'
- en: '**[1:](#ch34qa3q1)**'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch34qa3q1)**'
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`heroku create` registers a new application name and code repository for your
    application on Heroku’s services. It also links your local Git repository to the
    remote repository by the name of `heroku`.'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`heroku create` 命令会为你的应用程序在Heroku的服务上注册一个新的应用程序名称和代码仓库。它还会通过名为 `heroku` 的远程仓库将你的本地Git仓库链接起来。'
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)34.3\. Setting up your database in production'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png)34.3. 在生产中设置你的数据库'
- en: Because you don’t have direct access to the server on which your production
    application is running, you can’t download, install, and run a MongoDB database
    on the same server, as you do in development. Heroku provides a free plugin, however,
    that you can use to set up a small MongoDB database. To add this plugin from terminal,
    run the command `heroku addons:create mongolab:sandbox`. This line provisions
    a sandbox database from MongoLab (mLab).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你无法直接访问运行生产应用程序的服务器，你不能像在开发中那样在该服务器上下载、安装和运行MongoDB数据库。然而，Heroku提供了一个免费的插件，你可以使用它来设置一个小型的MongoDB数据库。要从终端添加此插件，请运行命令
    `heroku addons:create mongolab:sandbox`。这一行从MongoLab（mLab）配置了一个沙盒数据库。
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'References to deploy your application to heroku with the mLab [https://docs.mlab.com/shutdown-of-heroku-add-on/](https://docs.mlab.com/shutdown-of-heroku-add-on/)
    add-on no longer work; mLab has been deprecated and removed from the Heroku options.
    For instructions on how to migrate your database to the new MongoDB Atlas free
    tier, follow this link: [https://docs.mlab.com/how-to-migrate-sandbox-heroku-addons-to-atlas/](https://docs.mlab.com/how-to-migrate-sandbox-heroku-addons-to-atlas/).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mLab [https://docs.mlab.com/shutdown-of-heroku-add-on/](https://docs.mlab.com/shutdown-of-heroku-add-on/)
    插件部署你的应用程序到Heroku的引用不再有效；mLab已被弃用并从Heroku选项中移除。有关如何将数据库迁移到新的MongoDB Atlas免费层的说明，请点击此链接：[https://docs.mlab.com/how-to-migrate-sandbox-heroku-addons-to-atlas/](https://docs.mlab.com/how-to-migrate-sandbox-heroku-addons-to-atlas/)。
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With the help of other cloud services such as Amazon and Google, mLab provides
    databases and MongoDB servers that can be accessed remotely via a URL. The URL
    you get is added to your application as the environmental variable `MONGODB_URI`.
    This variable means that your application can use the variable `MONGODB_URI` to
    get the URL of the database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Amazon和Google等其他云服务的帮助下，mLab提供了可以通过URL远程访问的数据库和MongoDB服务器。您获得的URL被添加到您的应用程序中作为环境变量
    `MONGODB_URI`。这个变量意味着您的应用程序可以使用变量 `MONGODB_URI` 来获取数据库的URL。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: The URL provided by mLab is a direct link to your application’s data. Only your
    application on Heroku should use this URL; otherwise, you risk database-security
    vulnerabilities.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: mLab提供的URL是您应用程序数据的直接链接。只有您在Heroku上的应用程序应该使用此URL；否则，您可能会面临数据库安全漏洞的风险。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You previously set up your application to use this variable. You can verify
    that it exists in your application by running the `heroku config` command in terminal.
    The result of running this command is a list of configuration variables used by
    the application. You should see only one variable for your database at this time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前已设置应用程序使用此变量。您可以通过在终端中运行 `heroku config` 命令来验证它在您的应用程序中是否存在。运行此命令的结果是应用程序使用的配置变量列表。此时您应该只看到一个数据库变量。
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can add new environmental variables by running the command `heroku config:set
    NAME=VALUE`, where `Name` is the name of the variable you want to set and `VALUE`
    is its value. I might set `heroku config:set` AUTHOR_EMAIL=jon@jonwexler.com.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行命令 `heroku config:set NAME=VALUE` 来添加新的环境变量，其中 `Name` 是您想要设置的变量的名称，而
    `VALUE` 是其值。我可能会设置 `heroku config:set` AUTHOR_EMAIL=jon@jonwexler.com。
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: After a few minutes, your application should be ready to view. In your web browser,
    visit the URL provided earlier by Heroku, and add the `/courses` path to see an
    empty table, as shown in [figure 34.2](#ch34fig02). You should see the home page
    of your application. Try creating new user accounts, subscribers, and groups through
    the forms you created in past lessons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，您的应用程序应该准备好查看。在您的网页浏览器中，访问Heroku之前提供的URL，并添加 `/courses` 路径以查看一个空表，如图34.2所示。您应该看到您应用程序的主页。尝试通过您在之前的课程中创建的表单创建新的用户账户、订阅者和组。
- en: Figure 34.2\. Displaying the Heroku courses page
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图34.2\. 显示Heroku课程页面
- en: '![](../Images/34fig02_alt.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![34fig02_alt.jpg](../Images/34fig02_alt.jpg)'
- en: You may be wondering whether there’s an easier way to populate your new database
    online with data than manually entering information in the browser forms. There
    is! I show you that technique, and some other tools and tips, in [lesson 35](../Text/kindle_split_054.html#ch35).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道是否有比手动在浏览器表单中输入信息更简单的方法来在线填充您的新数据库。确实有！我在[第35课](../Text/kindle_split_054.html#ch35)中向您展示了这种方法，以及其他一些工具和技巧。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 34.3**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查34.3**'
- en: '**[Q1:](#ch34qa6q0a1)**'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch34qa6q0a1)**'
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you view and set environmental variables on your Heroku application?
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您如何在Heroku应用程序中查看和设置环境变量？
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 34.3 answer**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 34.3 答案**'
- en: '**[1:](#ch34qa5q1)**'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch34qa5q1)**'
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To view environmental variables on your Heroku application, run `heroku config`
    in your project’s terminal window. You can set new variables by using `heroku
    config:set`.
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要在您的Heroku应用程序中查看环境变量，请在项目终端窗口中运行 `heroku config`。您可以通过使用 `heroku config:set`
    来设置新变量。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![总结](../Images/sectionFig.png)'
- en: In this lesson, you learned about preparing your application for production
    and deploying it to Heroku. First, you changed some application configurations
    to help your Heroku dyno handle and run your application. Next, you deployed the
    application through your terminal Heroku CLI. Last, you set up a remote MongoDB
    database by using the mLab plugin through Heroku. In [lesson 35](../Text/kindle_split_054.html#ch35),
    you discover how to manage your application in production, add data, and debug
    problems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您学习了如何为您的应用程序准备生产环境并将其部署到Heroku。首先，您更改了一些应用程序配置以帮助Heroku dyno处理和运行您的应用程序。接下来，您通过终端Heroku
    CLI部署了应用程序。最后，您通过使用Heroku的mLab插件设置了远程MongoDB数据库。在[第35课](../Text/kindle_split_054.html#ch35)中，您将了解如何管理生产环境中的应用程序，添加数据以及调试问题。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这样做**'
- en: With your application on Heroku, test all the functionality to make sure that
    it works. Everything may seem to work as intended at first, but keep in mind that
    the environment is different, and sometimes your code may not work as expected.
    Try opening one terminal window with `heroku logs --tail` running alongside a
    browser window with your production application, and watch the log messages that
    Heroku prints.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Heroku上运行你的应用程序，测试所有功能以确保其正常工作。一开始，一切可能看起来都按预期进行，但请记住，环境是不同的，有时你的代码可能不会按预期工作。尝试打开一个终端窗口，运行`heroku
    logs --tail`，同时打开一个包含你的生产应用程序的浏览器窗口，并观察Heroku打印的日志消息。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Lesson 35\. Managing in production
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第35课\. 生产环境管理
- en: Your application is finally online, and you want to ensure that it stays there,
    fully functional. In this lesson, I discuss ways of getting data into your application
    even before any forms are used. You may want to add some of the course data you
    used in development so that your application has a fresh start online with data
    to view. Adding course data to your live application will reduce the time it takes
    to make the pages of your site presentable. Then I discuss some ways to improve
    your code quality and make sure that you don’t make mistakes that could cause
    your application to crash in production. Last, I talk about ways to log, debug,
    and monitor your application in production to help you investigate when things
    begin to break.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序终于上线了，你想要确保它保持完全功能的状态。在本节课中，我将讨论在表单使用之前将数据放入应用程序的方法。你可能想要添加一些你在开发中使用的课程数据，以便你的应用程序在上线时有一个数据丰富的起点。将课程数据添加到你的实时应用程序中将减少使网站页面呈现所需的时间。然后，我将讨论一些提高代码质量的方法，确保你不会犯可能导致应用程序在生产环境中崩溃的错误。最后，我将讨论在生产环境中记录、调试和监控应用程序的方法，以帮助你调查问题开始出现时的情况。
- en: This lesson covers
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课涵盖
- en: Loading seed data into your production application
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将种子数据加载到你的生产应用程序中
- en: Setting up linting for you code
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的代码设置代码检查
- en: Debugging your application
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试你的应用程序
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下内容**'
- en: Your application is finally online, and it’s a proud moment, except that your
    client quickly discovers bugs that went undetected in development. What protocol
    do you follow to fix your code locally and upload to production?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序终于上线了，这是一个值得骄傲的时刻，但你的客户很快发现了在开发过程中未被发现的错误。你遵循什么协议来在本地修复代码并将其上传到生产环境？
- en: In this lesson, you learn how to maintain your application in production with
    a few tools.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你将学习如何使用一些工具来维护你的生产环境中的应用程序。
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)35.1\. Loading seed data'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)35.1\. 加载种子数据'
- en: In [lesson 34](../Text/kindle_split_053.html#ch34), you got your database set
    up, but you may be wondering whether there’s a simple way to populate your production
    application with data. You can upload data into your application on Heroku in
    a few ways.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第34课](../Text/kindle_split_053.html#ch34)中，你已经设置了数据库，但你可能想知道是否有简单的方法来用数据填充你的生产应用程序。你可以在Heroku上通过几种方式将数据上传到你的应用程序。
- en: '*Seed data* is the database records you feed into your application when you
    first set it up in a new environment. Other languages and platforms have conventions
    for loading a file with seed data in different environments. In Node.js, you can
    create a JavaScript file containing the data you’d like to load. You may want
    to populate your application with recipe courses before any users even sign up,
    for example. To do so, you can use an existing seed file or create a new file
    in your application directory called seed.js. This file defines and creates new
    records that communicate with your Mongoose plugin. For that reason, you need
    to require Mongoose and the models you intend to use, as shown in [listing 35.1](#ch35ex01).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*种子数据*是在你首次在新环境中设置应用程序时输入应用程序的数据库记录。其他语言和平台有不同的约定，用于在不同环境中加载包含种子数据的文件。在Node.js中，你可以创建一个包含你想要加载的数据的JavaScript文件。例如，你可能在任何用户注册之前就想要用食谱课程填充你的应用程序。为此，你可以使用现有的种子文件或在应用程序目录中创建一个名为seed.js的新文件。此文件定义并创建与你的Mongoose插件通信的新记录。因此，你需要引入Mongoose以及你打算使用的模型，如[列表35.1](#ch35ex01)所示。'
- en: To avoid conflict with a preexisting seed file, create courseSeed.js. In this
    example, you include the necessary modules needed for creating new data objects
    with Mongoose. Then you create multiple records with values that you’d like to
    see in your production application. When this file contains the data that you
    want to use, run the code in this file, using the Heroku command-line interface
    (CLI).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与现有的种子文件冲突，创建 courseSeed.js。在这个例子中，你包括创建新数据对象所需的必要模块。然后，你创建多个具有你希望在生产应用程序中看到的值的记录。当这个文件包含你想要使用的数据时，使用
    Heroku 命令行界面（CLI）运行此文件中的代码。
- en: Listing 35.1\. Adding content through seed data in courseSeed.js
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 35.1\. 在 courseSeed.js 中通过种子数据添加内容
- en: '[PRE2]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Require models for seeding data.**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要模型来生成数据。**'
- en: '***2*** **Remove all existing documents.**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **删除所有现有文档。**'
- en: '***3*** **Run code to create new database documents.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行代码以创建新的数据库文档。**'
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: As an alternative, you could use the mLab URL to load seed data directly into
    your production database. Although this approach is quick, I don’t recommend it
    because it exposes your production database to security risks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，你可以使用 mLab URL 直接将种子数据加载到你的生产数据库中。尽管这种方法很快，但我不建议这样做，因为它会使你的生产数据库面临安全风险。
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Two other alternatives are using Heroku CLI tools to launch your production
    application’s REPL or terminal environment. You may recall that REPL has access
    to the files and folders in your projects directory, so it’s a great way to insert
    data from terminal. Launch REPL by running the command `heroku run node` in your
    project’s terminal window. With this REPL-like environment for your production
    application, you can simply copy and paste the contents of courseSeed.js into
    terminal. The other approach is to run `heroku run bash` in your project’s terminal
    window. This command brings up a prompt where you can run `node courseSeed` to
    load all the contents directly. First, you’ll need to commit your courseSeed.js
    file to git and push to heroku.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两种方法是使用 Heroku CLI 工具启动你的生产应用程序的 REPL 或终端环境。你可能还记得，REPL 可以访问你的项目目录中的文件和文件夹，因此它是从终端插入数据的好方法。通过在你的项目终端窗口中运行命令
    `heroku run node` 来启动 REPL。有了这个为你生产应用程序提供的类似 REPL 的环境，你可以简单地复制并粘贴 courseSeed.js
    中的内容到终端。另一种方法是，在你的项目终端窗口中运行 `heroku run bash`。这个命令会弹出一个提示符，你可以在其中运行 `node courseSeed`
    以直接加载所有内容。首先，你需要将 courseSeed.js 文件提交到 git 并推送到 Heroku。
- en: If you’re successful, you should see the log outputs of each course created,
    which also appear immediately on the `/courses` route in your application online
    ([figure 35.1](#ch35fig01)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你操作成功，你应该会看到每个课程创建的日志输出，这些输出也会立即出现在你应用程序在线的 `/courses` 路由中（[图 35.1](#ch35fig01)）。
- en: Figure 35.1\. Display of the populated courses page
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 35.1\. 已填充的课程页面显示
- en: '![](../Images/35fig01_alt.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/35fig01_alt.jpg)'
- en: '|  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To upload new changes to your project, run git add . followed by git commit
    -m “some commit message” and git push heroku master.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要上传项目的新更改，运行 git add . 然后运行 git commit -m “一些提交信息” 和 git push heroku master。
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, I discuss ways to maintain the integrity of your code and
    ensure that new errors don’t pop up.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将讨论维护代码完整性的方法，并确保不会出现新的错误。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 35.1**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 35.1**'
- en: '**[Q1:](#ch35qa2q0a1)**'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch35qa2q0a1)**'
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens when you run `heroku run node`?
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你运行 `heroku run node` 时会发生什么？
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 35.1 answer**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 35.1 答案**'
- en: '**[1:](#ch35qa1q1)**'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch35qa1q1)**'
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`heroku run node` opens a new REPL window for you within the context of your
    production application. From there, you can run JavaScript commands and load application-specific
    modules as you would locally, with access to your production database.'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`heroku run node` 在你的生产应用程序上下文中为你打开一个新的 REPL 窗口。从那里，你可以像本地一样运行 JavaScript 命令并加载特定于应用程序的模块，同时可以访问你的生产数据库。'
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)35.2\. Linting'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)35.2\. Linting'
- en: Bugs and coding mistakes are part of the development process. What can you do
    to prevent the inevitable mistakes that halt production? Along with code quality,
    the process of linting to hold your code to a particular standard is a way to
    reduce errors. *Linting* involves running a program to read through your code
    and notify you of bugs or errors that you may not have caught. You also might
    miss (and some browsers might ignore) syntax errors during development that could
    break your application in a different environment. To lint your code, globally
    install a package called `eslint` by running `npm install -g eslint`. ESLint is
    an open-source tool used in terminal to run static analysis on your code. Through
    this analysis, you can identify code style and structure problems. Other linting
    libraries that you can use include JSLint and JSHint. You can learn more about
    ESLint at [https://eslint.org/](https://eslint.org/).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷和编码错误是开发过程的一部分。你能做些什么来预防那些不可避免地会阻碍生产的错误？除了代码质量外，通过执行特定的标准来执行代码检查的过程也是减少错误的一种方式。*代码检查*涉及运行一个程序来阅读你的代码，并通知你那些你可能没有捕捉到的错误或问题。你可能在开发过程中也会错过（某些浏览器可能会忽略）可能导致应用程序在不同环境中崩溃的语法错误。要检查你的代码，通过在终端中运行
    `npm install -g eslint` 全局安装一个名为 `eslint` 的包。ESLint 是一个开源工具，用于在终端中运行代码的静态分析。通过这种分析，你可以识别代码风格和结构问题。你还可以使用其他代码检查库，例如
    JSLint 和 JSHint。你可以在 [https://eslint.org/](https://eslint.org/) 上了解更多关于 ESLint
    的信息。
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You could also install the package for this project by running `npm install
    eslint --save-dev` within your project directory in terminal. The `--save-dev`
    flag signifies that this package doesn’t need to be installed in your production
    environment; it will be marked that way in your application’s package.json. To
    use `eslint` after installing it as a development dependency, you need to access
    it from `./node_modules/.bin/eslint`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在终端中运行 `npm install eslint --save-dev` 在你的项目目录中安装这个项目的包。`--save-dev` 标志表示这个包不需要在生产环境中安装；它将在你的应用程序的
    package.json 中被标记为这种方式。要使用已作为开发依赖项安装的 `eslint`，你需要从 `./node_modules/.bin/eslint`
    访问它。
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As you initialized a new package.json file with `npm init`, initialize a .eslintrc.js
    file by running `eslint --init` in your project’s terminal window. Choose to set
    up your file by answering the questions in terminal, as shown in [listing 35.2](#ch35ex02).
    You need to let the linter know to look for ES6 syntax and methods because you
    use them throughout your application. You also tell the linter to analyze your
    code on the server and client because you’ve written JavaScript for both.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `npm init` 初始化一个新的 package.json 文件时，通过在你的项目终端窗口中运行 `eslint --init` 来初始化一个
    .eslintrc.js 文件。选择通过在终端中回答问题来设置你的文件，如 [列表 35.2](#ch35ex02) 中所示。你需要让代码检查器知道要查找
    ES6 语法和方法，因为你会在整个应用程序中使用它们。你还告诉代码检查器在服务器和客户端上分析你的代码，因为你为两者都编写了 JavaScript。
- en: Listing 35.2\. Setting up your .eslintrc.js file in terminal
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 35.2\. 在终端中设置你的 .eslintrc.js 文件
- en: '[PRE3]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Answers to questions to set up your linter**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置代码检查器的问题答案**'
- en: Take a look at the .eslintrc.js file that’s produced at the end of this prompt
    in [listing 35.3](#ch35ex03). Notice that you’re formatting the linter’s configurations
    in JavaScript, not JSON, like your package.json file. As in your other JavaScript
    modules, these configurations are assigned to `module.exports`. Most of the configurations
    that follow are fairly straightforward. Your environments are specified to include
    node, web browsers, and ES6 syntax. Then there are `eslint` rules, which define
    when to warn you of inconsistencies. In this case, you throw a linter error when
    spaces are used instead of tabs, semicolons are missing at the end of statements,
    or single quotation marks are used around text. You can change these configurations
    to suit your preferences.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 查看在提示末尾生成的 .eslintrc.js 文件，如 [列表 35.3](#ch35ex03) 中所示。注意，你正在格式化代码检查器的配置为 JavaScript，而不是像你的
    package.json 文件那样的 JSON。就像你的其他 JavaScript 模块一样，这些配置被分配给 `module.exports`。接下来的大多数配置都是相当直接的。你的环境被指定为包括
    node、网络浏览器和 ES6 语法。然后是 `eslint` 规则，它们定义了何时警告你不一致性。在这种情况下，当你使用空格而不是制表符、在语句末尾缺少分号或文本周围使用单引号时，你会抛出一个代码检查器错误。你可以根据你的偏好更改这些配置。
- en: Listing 35.3\. Example .eslintrc.js configuration file
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 35.3\. 示例 .eslintrc.js 配置文件
- en: '[PRE4]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Specify the environments to analyze.**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **指定要分析的环境。**'
- en: '***2*** **Define eslint rules.**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **定义 ESLint 规则。**'
- en: Test your linter on the main.js file by running `eslint main.js`. I hope that
    you don’t see any errors up front. Try deleting a semicolon or defining a variable
    that you don’t use later. Notice how `eslint` outputs errors with line numbers
    so that you can correct your code easily. Clean code helps ensure the integrity
    and readability of your application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`eslint main.js`在main.js文件上测试你的代码检查器。我希望你一开始不会看到任何错误。尝试删除一个分号或定义一个后来不再使用的变量。注意`eslint`如何输出带有行号的错误，这样你可以轻松地纠正代码。干净的代码有助于确保应用程序的完整性和可读性。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that some linter rules are stricter than others. The rules are
    intended to maintain consistency in your code. If you see errors referring to
    spaces versus tabs, those errors don’t mean that your code is bad—only that it
    could use a cleanup.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一些代码检查规则比其他规则更严格。这些规则旨在保持你代码的一致性。如果你看到有关空格与制表符的错误，这些错误并不意味着你的代码有问题——只是它可能需要清理。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The output of errors in your terminal window details which files and line numbers
    you need to visit to correct your syntax or code structure.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你终端窗口中错误的输出详细说明了你需要访问哪些文件和行号来纠正你的语法或代码结构。
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 35.2**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 35.2**'
- en: '**[Q1:](#ch35qa4q0a1)**'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch35qa4q0a1)**'
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does .eslintrc.js do?
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .eslintrc.js的作用是什么？
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 35.2 answer**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 35.2 答案**'
- en: '**[1:](#ch35qa3q1)**'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch35qa3q1)**'
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Like package.json, .eslintrc.js stores the configuration settings for `eslint`
    that you set up in the initialization process in terminal. This file contains
    rules by which the linter determines whether your code needs to be fixed.
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与package.json类似，.eslintrc.js存储了你在终端初始化过程中设置的`eslint`配置设置。此文件包含规则，根据这些规则，代码检查器会确定你的代码是否需要修复。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)35.3\. Debugging your application'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)35.3. 调试你的应用程序'
- en: You looked at a few ways to debug your application earlier in the book. You
    used `console.log` to print custom messages, error messages, and request/response-specific
    data in your Express.js middleware functions. Then you used the logs in your terminal
    window to determine where to fix certain problems. If an error occurred while
    saving a user to the database, for example, you caught the error in your promise
    chain and logged it to the console.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面部分，你了解了几种调试应用程序的方法。你使用了`console.log`在Express.js中间件函数中打印自定义消息、错误消息和请求/响应特定数据。然后你使用终端窗口中的日志来确定要修复的问题的位置。例如，如果保存用户到数据库时发生错误，你会在你的promise链中捕获错误并将其记录到控制台。
- en: Logging is helpful when it’s used correctly. Logs provide a recorded history
    of transactions and interaction with your application. Even if your application
    is running smoothly, you want your development logs to tell you more about the
    application’s performance, and you want your production logs to inform you of
    suspicious activity.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，日志记录很有帮助。日志提供了事务和与你的应用程序交互的记录历史。即使你的应用程序运行顺利，你也希望你的开发日志告诉你更多关于应用程序性能的信息，并且你希望你的生产日志通知你可疑活动。
- en: Locally, you can get more information about the request-response cycle by starting
    your application in debug mode. In your project’s terminal window, type the command
    `DEBUG=* node main` to set the `DEBUG` environment variable to logging from all
    elements of your application as it runs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地，你可以通过以调试模式启动应用程序来获取有关请求-响应周期的更多信息。在你的项目终端窗口中，输入命令`DEBUG=* node main`来设置`DEBUG`环境变量，以便在应用程序运行时记录其所有元素的日志。
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: On Windows machines, first set the environment variable and then run the application
    by running the command `set DEBUG=* & node main`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上，首先设置环境变量，然后通过运行命令`set DEBUG=* & node main`来运行应用程序。
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You’ll notice right away that the number of log lines in your terminal window
    reflects the operations Express.js performs to register your routes, along with
    some configurations it makes before your web server launches ([listing 35.4](#ch35ex04)).
    Now when you visit any page in your application locally, the debug logs stream
    down your terminal window. Conveniently, Express.js also tells you how much time
    each operation takes in its log messages. During development, this information
    can help you determine whether some parts of the application aren’t performing
    well so that you can investigate further.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即注意到，你的终端窗口中的日志行数反映了 Express.js 注册你的路由所执行的操作，以及它在你的 web 服务器启动前所做的某些配置（[列表
    35.4](#ch35ex04)）。现在，当你在本地的应用程序中访问任何页面时，调试日志会流到你的终端窗口。方便的是，Express.js 还会在其日志消息中告诉你每个操作花费了多少时间。在开发过程中，这些信息可以帮助你确定应用程序的某些部分是否表现不佳，以便你可以进一步调查。
- en: Listing 35.4\. Example of log messages through Express.js in terminal
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 35.4\. 在终端中通过 Express.js 的日志消息示例
- en: '[PRE5]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Log Express.js route registration in debug mode.**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 在调试模式下记录 Express.js 路由注册。'
- en: 'If you find it helpful to run your application with debug logs, you can add
    a start script in your package.json file to avoid writing the whole command each
    time. Add `"debug": "DEBUG=* node main"` after your start script. Then, whenever
    you want to see these logs, run the `npm run debug` command.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你发现运行带有调试日志的应用程序很有帮助，你可以在 package.json 文件中添加一个启动脚本，以避免每次都编写整个命令。在你的启动脚本后添加
    `"debug": "DEBUG=* node main"`。然后，无论何时你想查看这些日志，只需运行 `npm run debug` 命令。'
- en: These logs can be valuable in production as well, though you don’t want to run
    your production application in debug mode. Instead, install another package to
    handle logging the important data that you want to see in production. Install
    a package called `morgan` to provide your Node.js application better console log
    messages.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在生产环境中你不想以调试模式运行你的应用程序，但这些日志在生产环境中同样有价值。相反，安装另一个包来处理你希望在生产中看到的重要数据的记录。安装一个名为
    `morgan` 的包，以提供更好的 Node.js 应用程序控制台日志消息。
- en: Install the `morgan` package by running the command `npm i morgan -S`. Then,
    in main.js, require the `morgan` module by adding `const morgan = require("morgan")`.
    Then the process is as simple as telling your Express.js application to use `morgan`
    and passing in some formatting options. You can add `app.use(morgan(":method :url
    :status * :response-time ms"))` to log the request method, URL, status code, and
    time taken to process a response, for example.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行命令 `npm i morgan -S` 安装 `morgan` 包。然后，在 main.js 中，通过添加 `const morgan = require("morgan")`
    来引入 `morgan` 模块。然后，这个过程就像告诉你的 Express.js 应用程序使用 `morgan` 并传递一些格式化选项一样简单。例如，你可以添加
    `app.use(morgan(":method :url :status * :response-time ms"))` 来记录请求方法、URL、状态码和响应处理所需的时间。
- en: This output should immediately resemble the logs that Express.js generated in
    debug mode. Launch your application with `npm start`, and notice the logs for
    each request made, as shown in the next listing. I recommend using the `morgan("combined")`
    format, in which the combined formatting options provides a lot of the information
    you’ll need to monitor the request-response cycle in your production application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出应立即类似于 Express.js 在调试模式下生成的日志。通过运行 `npm start` 启动你的应用程序，并注意每个请求的日志，如下一列表所示。我建议使用
    `morgan("combined")` 格式，其中组合的格式化选项提供了你监控生产应用程序中的请求-响应周期所需的大部分信息。
- en: Listing 35.5\. Example of log messages with `morgan`
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 35.5\. 使用 `morgan` 的日志消息示例
- en: '[PRE6]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Log custom messages with morgan.**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 使用 morgan 记录自定义消息。'
- en: With logging set up, the best approach to debugging problems is to pause your
    application where issues occur and analyze the code surrounding those issues.
    This practice is easier said than done, but tools are available to help you identify
    the troubled code. Built into Node.js is a debug tool that lets you step through
    your code one line at a time. After each line of code, you can evaluate the variables
    and data to determine whether their values are what you expect.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好日志记录后，调试问题的最佳方法是在问题发生的地方暂停你的应用程序，并分析周围的代码。这种做法说起来容易做起来难，但有一些工具可以帮助你识别有问题的代码。Node.js
    内置了一个调试工具，允许你逐行执行代码。在每一行代码之后，你可以评估变量和数据，以确定它们的值是否如你所期望。
- en: To run the built-in debugger, run the `node inspect main.js` command in your
    project’s terminal window. After running this command, you’ll immediately see
    the first lines of your main.js file display in your terminal window. The tool
    pauses as soon as your application starts, stating `Break on start in main.js:1`.
    You can start evaluating your code by typing `n` to go to the next line, incrementally
    jumping over a single line at a time, or typing `c` to continue running your application.
    If you type `c`, your application runs as usual. The debugger becomes particularly
    useful when you have an idea of where your code isn’t working properly. If you
    think that your code isn’t finding users correctly on the user’s show page, for
    example, you may want to pause the code within that controller action. To pause
    in specific locations, add `debugger;` at that location in your code, as shown
    in [listing 35.6](#ch35ex06).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行内置调试器，请在项目终端窗口中运行 `node inspect main.js` 命令。运行此命令后，你将立即看到你的 main.js 文件的第一行显示在终端窗口中。工具会在你的应用程序启动时立即暂停，显示
    `Break on start in main.js:1`。你可以通过输入 `n` 跳到下一行，逐行增量跳过，或者输入 `c` 继续运行你的应用程序。如果你输入
    `c`，你的应用程序将像平常一样运行。当你认为你的代码在某些地方没有正确工作时，调试器特别有用。例如，如果你认为你的代码在用户的展示页面中没有正确找到用户，你可能想要暂停该控制器动作中的代码。要在特定位置暂停，请在你的代码中添加
    `debugger;`，如 [列表 35.6](#ch35ex06) 所示。
- en: By adding this line, running the debugger again in terminal, and typing `c`
    to let your application run, you’re setting the application up to stop for you
    when it queries the database for a user in the `show` action before the view is
    rendered.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加此行，再次在终端中运行调试器，并输入 `c` 让应用程序运行，你正在设置应用程序在渲染视图之前查询数据库中的用户时为你停止。
- en: Listing 35.6\. Debugging the `show` action in usersController.js
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 35.6\. 在 usersController.js 中调试 `show` 动作
- en: '[PRE7]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **Add a debugger breakpoint when a user is found in the database.**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在数据库中找到用户时添加调试器断点。**'
- en: 'As soon as you visit a user’s show page in your browser, the page pauses, and
    your terminal window displays the code where you placed your `debugger;`. From
    there, you can investigate the variables within this code by entering the REPL
    environment. By typing `repl` in the debugger window in terminal, you can run
    normal REPL commands within the context of the code that’s being debugged. In
    this example, you’re checking whether the user being retrieved from the database
    has a valid email address, so run the following statement: `console.log(user.email)`.
    If you get `undefined` or some value other than the user’s email address, you
    know that the issue has to do with the email, and you can investigate further.
    When you’re done debugging, type `c` to continue and press Ctrl-D to exit. For
    more information about this debugger, visit [https://nodejs.org/api/debugger.html](https://nodejs.org/api/debugger.html).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中访问用户的展示页面时，页面会暂停，你的终端窗口会显示你放置 `debugger;` 的代码位置。从那里，你可以通过进入 REPL 环境来调查这段代码中的变量。在终端的调试器窗口中输入
    `repl`，你可以在被调试的代码上下文中运行正常的 REPL 命令。在这个例子中，你正在检查从数据库检索到的用户是否有有效的电子邮件地址，因此运行以下语句：`console.log(user.email)`。如果你得到
    `undefined` 或用户电子邮件地址以外的某些值，你知道问题与电子邮件有关，并且可以进一步调查。当你完成调试后，输入 `c` 继续执行，并按 Ctrl-D
    退出。有关此调试器的更多信息，请访问 [https://nodejs.org/api/debugger.html](https://nodejs.org/api/debugger.html)。
- en: The built-in debugging tool can be a helpful way to analyze the data in your
    application as it runs. Fully debugging your code this way involves a few steps,
    however, so I recommend exploring other debugging tools, such as `node-inspector`,
    which lets you use the console in Google Chrome to debug. You can also use Node.js
    with an integrated development environment like TernJS in Atom, which offers debugging
    tools while you edit your code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 内置调试工具可以是有助于分析应用程序运行时数据的有用方式。然而，完全以这种方式调试你的代码涉及几个步骤，所以我建议探索其他调试工具，例如 `node-inspector`，它允许你使用
    Google Chrome 中的控制台进行调试。你还可以使用 Node.js 与集成开发环境（如 Atom 中的 TernJS）一起使用，它在你编辑代码时提供调试工具。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 35.3**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 35.3**'
- en: '**[Q1:](#ch35qa6q0a1)**'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch35qa6q0a1)**'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens when you add `debugger` to your application code?
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你在应用程序代码中添加 `debugger` 时会发生什么？
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 35.3 answer**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 35.3 答案**'
- en: '**[1:](#ch35qa5q1)**'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch35qa5q1)**'
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Adding `debugger` to your code allows the debugging tool in Node.js to pause
    at that specific location as your application runs. Outside the debug tool, this
    addition won’t prevent your application from running normally.
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在您的代码中添加 `debugger` 允许 Node.js 的调试工具在应用程序运行时暂停在该特定位置。在调试工具之外，此添加不会阻止您的应用程序正常运行。
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)总结'
- en: In this lesson, you learned how to add data to your production application through
    the Heroku console. Then you installed `eslint` to lint your application for errors
    or syntactic inconsistencies in your code. Last, I introduced some debugging tips
    to help you identify production errors and know immediately where to go to fix
    them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，您学习了如何通过 Heroku 控制台向您的生产应用程序添加数据。然后，您安装了 `eslint` 来检查您的应用程序中的错误或代码中的语法不一致性。最后，我介绍了一些调试技巧，以帮助您识别生产错误并立即知道去哪里修复它们。
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试以下操作**'
- en: Try using the debugger in Node.js to evaluate the values of different variables
    in your application. Try running your application in debug mode and breaking within
    the user’s `create` action to evaluate the incoming request parameters.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 Node.js 的调试器来评估应用程序中不同变量的值。尝试以调试模式运行您的应用程序，并在用户的 `create` 动作中中断以评估传入的请求参数。
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Lesson 36\. Testing your application
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 36 课：测试您的应用程序
- en: Continual maintenance of your application in production requires fixing bugs.
    Fixing bugs means writing new code. Writing new code has the unforgiving tendency
    to break existing functionality. In this lesson, you take some steps to prevent
    the breaking of working code by implementing tests on your Node.js application.
    Writing tests in Node.js is similar to testing in other platforms and languages.
    First, you learn how to write simple tests for a function in your application.
    Then you implement tests for the controller actions and models to cover the bulk
    of your application’s code. By the end of this lesson, you’ll have the fundamental
    skills you need to get started testing your Node.js application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中持续维护您的应用程序需要修复错误。修复错误意味着编写新代码。编写新代码往往会导致现有功能中断。在本节课中，您将采取一些步骤，通过在您的 Node.js
    应用程序上实施测试来防止现有代码的破坏。在 Node.js 中编写测试与其他平台和语言的测试类似。首先，您将学习如何为应用程序中的函数编写简单的测试。然后，您将实现控制器操作和模型的测试，以覆盖您应用程序代码的大部分内容。在本节课结束时，您将具备开始测试您的
    Node.js 应用程序所需的基本技能。
- en: This lesson covers
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课涵盖
- en: Using core modules to write assertion tests
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用核心模块编写断言测试
- en: Writing a Node.js test with `mocha` and `chai`
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `mocha` 和 `chai` 编写 Node.js 测试
- en: Building and running tests for controller actions with `chai-http`
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `chai-http` 构建和运行控制器操作的测试
- en: Implementing tests for your API
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的 API 实现测试
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下情况**'
- en: Your recipe application is looking great in production, and you’ve gained development
    support from some local developers. Your application code is being worked on by
    multiple people, and the new developers don’t necessarily know how their implementation
    of new features will affect the features you’ve already built.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您的食谱应用程序在生产环境中看起来很棒，您已经从一些当地开发者那里获得了开发支持。您的应用程序代码正在由多个人共同工作，新开发者并不一定知道他们实现的新功能将如何影响您已经构建的功能。
- en: A new developer adds a new `index` action on the users controller. This new
    action doesn’t respond with all the user data you originally planned for, which
    affects your API and views. If you write tests for your `index` action specifying
    what data you expect it to return, new developers will have a point of reference
    regarding what functionality is allowed to change with their modifications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 新开发者向用户控制器添加了一个新的 `index` 动作。这个新动作没有响应您最初计划的所有用户数据，这影响了您的 API 和视图。如果您为 `index`
    动作编写测试，指定您期望它返回的数据，新开发者将有一个参考点，了解他们的修改允许哪些功能发生变化。
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)36.1\. Basic testing with core modules'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)36.1. 使用核心模块进行基本测试'
- en: 'In the tech industry, application testing is a standard practice. When you
    write some code with explicit functionality, you want to make sure that functionality
    doesn’t change unless it’s intended to change. To help ensure that your code isn’t
    accidentally affected by changes and new features that you implement (or that
    another developer implements), you can write tests. Tests contain three components:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术行业中，应用程序测试是一种标准做法。当您编写具有明确功能的一些代码时，您想确保该功能不会改变，除非它是打算改变的。为了帮助确保您的代码不会意外地受到您实现（或另一位开发者实现）的更改和新功能的影响，您可以编写测试。测试包含三个组件：
- en: Test data representing sample data that you’d expect to receive in your application
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数据表示您在应用程序中预期接收到的样本数据
- en: Expectations detailing what a function or series of operations should output,
    given your test data and application code
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望详细说明在您的测试数据和应用程序代码下，一个函数或一系列操作应该输出什么
- en: A testing framework to run your tests and determine whether your defined expectations
    were met
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试框架来运行您的测试并确定您定义的期望是否得到满足
- en: Before learning about some external tools that you can use to test your application,
    you can use a core module that comes with Node.js. The `assert` module offers
    some basic functions that you can use to confirm the equality of two values. You
    can think of these functions as being conditional statements wrapped in testing
    language.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解您可以使用的一些外部工具来测试您的应用程序之前，您可以使用 Node.js 附带的核心模块。`assert` 模块提供了一些基本函数，您可以使用它们来确认两个值的相等性。您可以将这些函数视为被测试语言包裹的条件语句。
- en: You can use this module by navigating to a new project folder called simple_test
    and creating a new file called test.js with the code shown in [listing 36.1](#ch36ex01).
    In this example, you require the `assert` module. Then you write an assertion
    test by using `assert.equal` to determine whether the first value, the result
    of a call to your custom `add` function, equals the second argument, 0\. Last,
    you write the `add` function to take two values and return their sum. In this
    example, you expect the addition of 5 and 4 to equal 0\. As you’d expect, this
    test should fail, and when it fails, the message in the final argument should
    appear in terminal.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到一个名为 simple_test 的新项目文件夹，并创建一个名为 test.js 的新文件，其中包含[列表 36.1](#ch36ex01)中显示的代码来使用此模块。在这个例子中，您需要引入
    `assert` 模块。然后，您通过使用 `assert.equal` 来编写一个断言测试，以确定第一个值，即对您自定义的 `add` 函数的调用结果，是否等于第二个参数，0。最后，您编写
    `add` 函数来接受两个值并返回它们的和。在这个例子中，您期望 5 和 4 的相加等于 0。正如您所期望的，这个测试应该失败，并且当它失败时，最终参数中的消息应该出现在终端中。
- en: 'Run this file to see the assertion error in terminal by entering `node test`
    within the `simple_test` project directory. That error should read `AssertionError
    [ERR_ASSERTION]: 5 plus 4 should equal 9`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `simple_test` 项目目录中输入 `node test` 来运行此文件，以在终端中查看断言错误。该错误应读取为 `AssertionError
    [ERR_ASSERTION]: 5 plus 4 should equal 9`。'
- en: Listing 36.1\. Simple assertion test in test.js
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 36.1\. test.js 中的简单断言测试
- en: '[PRE8]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Require the assert module.**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 引入 `assert` 模块。'
- en: '***2*** **Write the assertion test.**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 编写断言测试。'
- en: '***3*** **Implement the function specified in your test.**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 实现测试中指定的函数。'
- en: To correct this test, you need to change 0 to 9\. You could also add another
    assertion test here to specify what your `add` function shouldn’t return. You
    could write `assert.notEqual (add(5, 4), 0)`, for example. If this test ever fails,
    you’ll know that something is wrong with your `add` function that needs modification.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个测试，您需要将 0 改为 9。您也可以在这里添加另一个断言测试来指定您的 `add` 函数不应该返回什么。例如，您可以编写 `assert.notEqual
    (add(5, 4), 0)`。如果这个测试失败，您就会知道您的 `add` 函数有问题需要修改。
- en: The `assert` module is a great way to start writing tests for Node.js. For your
    application, however, you’ll benefit from external packages that test more-complicated
    functionality. For more information about the `assert` module, visit [https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 模块是开始编写 Node.js 测试的绝佳方式。然而，对于您的应用程序，您将从测试更复杂功能的外部包中受益。有关 `assert`
    模块的更多信息，请访问 [https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html)。'
- en: '|  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Test-driven development**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**'
- en: '*Test-driven development* (TDD) is an application development strategy in which
    tests specifying the expectations of your code are written first, followed by
    the feature implementation designed to pass your initial tests.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试驱动开发*（TDD）是一种应用程序开发策略，其中首先编写指定代码期望的测试，然后是实现功能以通过初始测试的设计。'
- en: You want to make sure that your tests comprehensively cover your application’s
    functionality, which means writing tests that specify how your application should
    work when it’s provided valid and invalid data. Sometimes, when you write your
    tests after you’ve already implemented the application code, it’s easy to miss
    edge cases that aren’t accounted for in your test suite. For this reason, TDD
    can offer a more wholesome development experience.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要确保你的测试全面覆盖应用程序的功能，这意味着编写测试来指定当应用程序提供有效和无效数据时应该如何工作。有时，当你已经实现了应用程序代码后编写测试时，很容易错过测试套件中没有考虑到的边缘情况。因此，TDD
    可以提供更全面的开发体验。
- en: 'TDD involves the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 包括以下步骤：
- en: Write your tests with sample data and expectations of the results, using that
    sample data through some method or function that you’ll build later.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用样本数据和预期的结果编写测试，使用你稍后将要构建的方法或函数通过该样本数据。
- en: Run your tests. At this point, all your tests should fail.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的测试。此时，所有测试应该都失败。
- en: Implement code for your testing to behave according to the expectations you
    defined in your tests.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现代码，以便你的测试按照你在测试中定义的期望执行。
- en: Run your tests again. At this point, all your tests should pass.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行你的测试。此时，所有测试应该都通过。
- en: If your tests don’t pass after you’ve written your application’s code, it could
    mean that your application code isn’t perfected yet.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写了应用程序代码后测试没有通过，这可能意味着你的应用程序代码还没有完善。
- en: 'If you were using TDD to implement a function called reverse that takes a string
    as a parameter and reverses it, for example, you might follow these steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 TDD 来实现一个名为 reverse 的函数，该函数接受一个字符串作为参数并反转它，例如，你可能遵循以下步骤：
- en: Write a test for the `reverse` function, using a test string, `var s =` "`Hello`",
    such that when you run `reverse(s)`, you expect the result to be "`olleH`".
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `reverse` 函数编写一个测试，使用测试字符串 `var s = "Hello"`，当你运行 `reverse(s)` 时，你期望结果是 `"olleH"`。
- en: Run the tests, and expect them to fail.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试，并预期它们会失败。
- en: Write the code to reverse strings.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写反转字符串的代码。
- en: Rerun the tests until all of them pass.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试，直到所有测试都通过。
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 36.1**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 36.1**'
- en: '**[Q1:](#ch36qa2q0a1)**'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch36qa2q0a1)**'
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is an assertion test?
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是断言测试？
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 36.1 answer**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 36.1 答案**'
- en: '**[1:](#ch36qa1q1)**'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch36qa1q1)**'
- en: ''
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An *assertion test* is code that you write to express your expectations of how
    some sample data might change, equal, or otherwise relate to another value. This
    test could be a comparison of two pieces of raw data or a comparison of data resulting
    from a function call or series of operations.
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*断言测试* 是你编写的代码，用于表达你对某些样本数据可能如何变化、相等或以其他方式与另一个值相关联的期望。这个测试可以是两块原始数据之间的比较，或者是一个函数调用或一系列操作产生的数据之间的比较。'
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)36.2\. Testing with mocha and chai'
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)36.2\. 使用 mocha 和 chai 进行测试'
- en: To start testing your application, install the `mocha` and `chai` packages in
    your recipe-application terminal window by running the command `npm i mocha -g`
    and `npm i chai -S`. `mocha` is a testing framework. Much like Express.js, `mocha`
    offers a structure and methods that can be used in conjunction to test your application
    code. You install `mocha` globally because you need to use the `mocha` keyword
    in terminal, and you’ll likely test other projects. `chai` should be installed
    as a development dependency because you’ll be testing your code only locally;
    you don’t need this package to be installed in your production environment.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始测试你的应用程序，请在 recipe-application 终端窗口中通过运行命令 `npm i mocha -g` 和 `npm i chai
    -S` 安装 `mocha` 和 `chai` 包。`mocha` 是一个测试框架。与 Express.js 类似，`mocha` 提供了结构和方法，可以一起使用来测试你的应用程序代码。你全局安装
    `mocha`，因为你需要在终端中使用 `mocha` 关键字，并且你可能会测试其他项目。`chai` 应该作为开发依赖项安装，因为你只会在本地测试你的代码；你不需要在这个生产环境中安装此包。
- en: To use the `mocha` module, run `mocha` in your project’s directory in terminal.
    Running this command directs `mocha` to look for a test folder within your project
    folder. As with any framework, a conventional directory structure is used to keep
    your tests organized and separate from your other code files, so you need to create
    that test folder at the root of your application directory.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `mocha` 模块，请在终端中运行项目目录下的 `mocha`。运行此命令将 `mocha` 指向项目文件夹内的测试文件夹。与任何框架一样，使用传统的目录结构来保持你的测试组织良好，并与其他代码文件分开，因此你需要在应用程序目录的根目录下创建该测试文件夹。
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Visit [https://mochajs.org](https://mochajs.org) for more information about
    the `mocha` framework, from installation to use in terminal.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://mochajs.org](https://mochajs.org) 获取有关 `mocha` 框架的更多信息，从安装到在终端中使用。
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`mocha` helps you describe and run tests, but it doesn’t provide the tools
    you need to determine whether the outcomes of your code are what you expected.
    For that purpose, you need an assertion engine to run assertions, which describe
    how code should output a specified value.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`mocha` 帮助你描述和运行测试，但它不提供你确定代码输出是否符合预期所需的工具。为此目的，你需要一个断言引擎来运行断言，这些断言描述了代码应该如何输出指定的值。'
- en: '`chai` is the assertion engine that you’ll use in this lesson. To use `chai`,
    require it in each test file you plan to run. Then, like the `assert` method from
    your core module, you can use `expect`, `should`, or `assert` as function verbs
    to check whether your code returns the intended results in your tests. For the
    following examples, use the `expect` function. `chai` also has descriptive functions
    to help you explain your tests before the assertions themselves. You’ll use the
    `describe` function to specify the module and function you’re testing.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`chai` 是你将在本课中使用的断言引擎。为了使用 `chai`，在每个你计划运行的测试文件中引入它。然后，就像你的核心模块中的 `assert`
    方法一样，你可以使用 `expect`、`should` 或 `assert` 作为函数动词来检查你的代码是否在测试中返回了预期的结果。对于以下示例，使用
    `expect` 函数。`chai` 还有一些描述性函数，可以帮助你在断言本身之前解释你的测试。你将使用 `describe` 函数来指定你正在测试的模块和函数。'
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`describe` functions can be nested.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 函数可以嵌套。'
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'For the actual tests, use the `it` function to explain what you expect to happen
    in the test. Semantically, this function allows your test to read this way: In
    a specific module, for a specific function, your code (it) should behave in a
    certain way when it’s provided with some specific data. You take a closer look
    at this semantic structure in the next example.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际测试，使用 `it` 函数来解释你在测试中期望发生什么。从语义上讲，这个函数允许你的测试以这种方式阅读：在特定的模块中，对于特定的函数，当提供一些特定数据时，你的代码（it）应该以某种方式表现。你将在下一个示例中更详细地了解这种语义结构。
- en: The last steps in using these packages are creating the test file, requiring
    any custom modules with methods you want to test, and providing sample data within
    your tests. Write a simple test for your recipe application, using `mocha` and
    `chai`. Create a new file called usersControllerSpec.js in the test folder within
    your project’s directory. Per development convention, Spec is used in filenames
    to indicate a test suite.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些包的最后几个步骤是创建测试文件，引入任何包含你想要测试的方法的自定义模块，并在你的测试中提供样本数据。为你的食谱应用程序编写一个简单的测试，使用
    `mocha` 和 `chai`。在你的项目目录中的测试文件夹内创建一个名为 usersControllerSpec.js 的新文件。按照开发惯例，Spec
    用于文件名以表示测试套件。
- en: Within this file, test the `getUserParams` function used in your user’s controller
    from the capstone exercise in [lesson 25](../Text/kindle_split_041.html#ch25).
    For testing purposes, add the `getUserParams` function to usersController.js,
    as shown in [listing 36.2](#ch36ex02).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，测试你在第 25 节的基石练习中使用的 `getUserParams` 函数。为了测试目的，将 `getUserParams` 函数添加到
    usersController.js 中，如 [列表 36.2](#ch36ex02) 所示。
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can make use of this function in the `create` action by creating a new
    `User` instance with the following line: `let newUser = new User(module.exports.getUserParams(req.body))`.
    You can reference the `getUserParams`through `module.exports`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `create` 动作中使用此函数，通过以下行创建一个新的 `User` 实例：`let newUser = new User(module.exports.getUserParams(req.body))`。你可以通过
    `module.exports` 来引用 `getUserParams`。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Unless you export this function, there’s no way for any other module to access
    the function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你导出这个函数，否则其他模块无法访问该函数。
- en: Listing 36.2\. Exporting the `getUserParams` function
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 36.2\. 导出 `getUserParams` 函数
- en: '[PRE9]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Export getUserParams in usersController.js.**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在 usersController.js 中导出 getUserParams。**'
- en: In usersControllerSpec.js, require `chai` along with usersController.js. The
    code for your test file resembles the code in [listing 36.3](#ch36ex03). Because
    you use the `expect` assertion function, you can require it directly from the
    `chai` module; you won’t need `chai` for anything else. Then define your first
    `describe` block by stating the module you’re testing. The following `describe`
    block specifies the function you’re testing. Within that nested `describe`, you
    can run multiple tests that pertain to `getUserParams`. In this case, you’re testing
    whether `getUserParams` returns data that includes your `name` properties when
    provided a sample request body. The second test ensures that a blank request body
    results in an empty object. You use `deep.include` to compare the contents of
    one JavaScript object with another. For more information about `chai` assertion
    methods, visit [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在usersControllerSpec.js中，需要`chai`和usersController.js。你的测试文件中的代码类似于[列表36.3](#ch36ex03)中的代码。因为你使用了`expect`断言函数，你可以直接从`chai`模块中引入它；你不需要`chai`做其他任何事情。然后通过声明你要测试的模块来定义你的第一个`describe`块。接下来的`describe`块指定了你正在测试的函数。在这个嵌套的`describe`块内部，你可以运行多个与`getUserParams`相关的测试。在这种情况下，你正在测试`getUserParams`在提供样本请求体时是否返回包含你的`name`属性的数据。第二个测试确保空白请求体导致空对象。你使用`deep.include`来比较两个JavaScript对象的内容。有关`chai`断言方法的更多信息，请访问[http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/)。
- en: Listing 36.3\. Exporting the `getUserParams` function in usersControllerSpec.js
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表36.3\. 在usersControllerSpec.js中导出`getUserParams`函数
- en: '[PRE10]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Require the expect function.**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入expect函数。**'
- en: '***2*** **Define the focus of your test in a describe block.**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在describe块中定义你的测试焦点。**'
- en: '***3*** **Detail your test expectations.**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **详细说明你的测试期望。**'
- en: '***4*** **Provide sample input data.**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **提供示例输入数据。**'
- en: '***5*** **Expect some object to be included in the results.**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **期望结果中包含某些对象。**'
- en: To run this test, enter the `mocha` command in your project’s terminal window.
    You should see an indication that both tests passed ([figure 36.1](#ch36fig01)).
    If you get an error or if a test fails, make sure that your modules are accessible
    from each other and that your code matches the code listings.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此测试，请在你的项目终端窗口中输入`mocha`命令。你应该会看到两个测试都通过（[图36.1](#ch36fig01)）。如果你遇到错误或测试失败，请确保你的模块可以相互访问，并且你的代码与代码列表匹配。
- en: Figure 36.1\. Displaying passing tests in terminal
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图36.1\. 在终端显示通过测试
- en: '![](../Images/36fig01_alt.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/36fig01_alt.jpg)'
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To exit your mocha test in terminal, press Ctrl-D.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端退出你的mocha测试，请按Ctrl-D。
- en: '|  |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, you implement a test that covers more than a single function.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一节中，你将实现一个覆盖多个函数的测试。  '
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 36.2**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查36.2**'
- en: '**[Q1:](#ch36qa4q0a1)**'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch36qa4q0a1)**'
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between `describe` and it?
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`describe`和`it`之间的区别是什么？'
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 36.2 answer**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 36.2 答案**'
- en: '**[1:](#ch36qa3q1)**'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch36qa3q1)**'
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`describe` wraps the tests that relate to a particular module or function,
    which makes it easier to categorize your test results as they appear in terminal.
    `it` blocks contain the actual assertion tests that you write.'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`describe`将相关于特定模块或函数的测试包裹起来，这使得在终端中显示测试结果时更容易分类。`it`块包含你实际编写的断言测试。'
- en: '|  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)36.3\. Testing with a database and server'
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)36.3\. 使用数据库和服务器进行测试'
- en: To test a web framework, you need more than some sample data and access to the
    modules you’re testing. Ideally, you want to re-create the environment in which
    your application normally runs, which means providing a functioning web server,
    database, and all the packages your application uses.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个Web框架，你需要比一些样本数据和访问你正在测试的模块更多。理想情况下，你希望重新创建你的应用程序通常运行的环境，这意味着提供一个功能性的Web服务器、数据库以及你的应用程序使用的所有包。
- en: You aim to set up an environment in addition to your development environment.
    You can define a test environment through the `process.env.NODE_ENV` environment
    variable. At the top of any test file, add `process.env.NODE_ENV = "test"` to
    let Node.js know that you’re running your application in a testing environment.
    This distinction can help you differentiate between databases and server ports.
    If you’re running your application in the test environment, you can tell the application
    to use a `recipe_test_db` database and run on port 3001, for example. This way,
    you can test saving and retrieving data from a database without interfering with
    your development data or development server.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您的目标是在开发环境之外设置一个环境。您可以通过`process.env.NODE_ENV`环境变量定义测试环境。在任何测试文件顶部添加`process.env.NODE_ENV
    = "test"`，以便让Node.js知道您正在测试环境中运行应用程序。这种区分可以帮助您区分数据库和服务器端口。如果您在测试环境中运行应用程序，您可以告诉应用程序使用`recipe_test_db`数据库并在端口3001上运行，例如。这样，您可以测试从数据库中保存和检索数据，而不会干扰您的开发数据或开发服务器。
- en: Now indicate to your application to use the `recipe_test_db` test database in
    the test environment and to otherwise default to the production and development
    databases, as shown in the next listing. In this example, you define a `db` variable
    earlier in the code and assign it to a local database. If the environmental variable,
    `process.env.NODE_ENV`, tells you that you’re in the test environment, the `db`
    variable points to your test database URL.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，指示您的应用程序在测试环境中使用`recipe_test_db`测试数据库，在其他情况下默认使用生产环境和开发数据库，如下一列表所示。在此示例中，您在代码中较早定义了一个`db`变量并将其分配给本地数据库。如果环境变量`process.env.NODE_ENV`告诉您您处于测试环境，则`db`变量指向您的测试数据库URL。
- en: Listing 36.4\. Separating environment databases in main.js
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表36.4\. 在main.js中分离环境数据库
- en: '[PRE11]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Assign to your test database while in the test environment.**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 在测试环境中将端口分配给您的测试数据库。'
- en: '***2*** **Default to the production and development databases.**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 默认使用生产环境和开发数据库。'
- en: '|  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB creates this test database for you if it doesn’t exist.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，MongoDB会为您创建这个测试数据库。
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You apply the same logic to your server port, as shown in the following listing.
    Here, you use port 3001 if you’re in the test environment. Otherwise, you use
    the normal ports that you’ve used so far.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您将相同的逻辑应用于您的服务器端口，如下所示列表所示。在此，如果您处于测试环境，则使用端口3001。否则，您将使用迄今为止使用的常规端口。
- en: Listing 36.5\. Setting up a test server port in main.js
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表36.5\. 在main.js中设置测试服务器端口
- en: '[PRE12]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Assign the port to 3001 (test), default to port 3000 (production).**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将端口分配给3001（测试），默认端口为3000（生产）。'
- en: Last, you need to export your application contained in `app` by adding `module.exports
    = app` to the bottom of main.js. Exporting your application allows you to access
    it from the test files you write. Also, in your controller tests, you need the
    help of another package to make requests to your server. Install the `chai-http`
    package by running the `npm i chai-http -S` command to save this package as a
    development dependency.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要通过在main.js底部添加`module.exports = app`来导出包含在`app`中的应用程序。导出应用程序允许您从您编写的测试文件中访问它。此外，在您的控制器测试中，您需要另一个包的帮助来向您的服务器发送请求。通过运行`npm
    i chai-http -S`命令安装`chai-http`包，将其保存为开发依赖项。
- en: With these changes in place, you’re ready to write a comprehensive test on your
    models and controllers. In the following examples, you test the user’s controller
    actions and User model. First, test the User model by creating a file called userSpec.js
    in your test folder with the code in [listing 36.6](#ch36ex06).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这些更改后，您就可以编写对模型和控制器进行全面测试了。在以下示例中，您测试用户的控制器操作和User模型。首先，通过在您的测试文件夹中创建一个名为userSpec.js的文件并包含[列表36.6](#ch36ex06)中的代码来测试User模型。
- en: In this file, you can create multiple tests on the User model. The first tests
    you write are to ensure that users can be created and saved to your database.
    You need to require the User module, `mongoose`, and `chai`. From `chai`, pull
    the `expect` function into its own constant so that your tests are more readable.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，您可以在User模型上创建多个测试。您编写的第一个测试是为了确保用户可以被创建并保存到您的数据库中。您需要引入User模块、`mongoose`和`chai`。从`chai`中提取`expect`函数到其自己的常量中，以便您的测试更易于阅读。
- en: Next, implement the `beforeEach` function provided by `mocha` to remove any
    and all users from your test database before you run each test. This function
    ensures that the results of previous tests don’t affect other tests in this file.
    Your `describe` block indicates that you’re testing the save functionality on
    the User model. Your `it` block contains two expectations to determine whether
    you can successfully save a single user to the database. First, provide some sample
    data that your application might naturally receive as input data. Then set up
    two promises to save the user and find all users in the database. The inner nested
    promise is where you run your expectations.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现`mocha`提供的`beforeEach`函数，在您运行每个测试之前从您的测试数据库中删除任何用户。此函数确保先前测试的结果不会影响此文件中的其他测试。您的`describe`块表明您正在测试用户模型上的保存功能。您的`it`块包含两个期望，以确定您是否可以成功将单个用户保存到数据库中。首先，提供一些您的应用程序可能自然接收作为输入数据的一些样本数据。然后设置两个承诺来保存用户并在数据库中查找所有用户。内部嵌套的承诺是您运行期望的地方。
- en: Last, create two assertions where you expect the results of your promises to
    yield an array, where the second item contains all the users in your database.
    Because you created a single user, you expect the size of the array of users to
    be `1`. Similarly, you expect the only user in that array to have an `_id` property,
    indicating that it has been saved to your MongoDB database. When your test is
    complete, call `done` to indicate that the tests are complete and promises are
    resolved.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建两个断言，您期望您的承诺的结果产生一个数组，其中第二个项目包含您数据库中的所有用户。因为您创建了一个单个用户，所以您期望用户数组的长度为`1`。同样，您期望该数组中的唯一用户具有`_id`属性，这表明它已保存到您的MongoDB数据库中。当您的测试完成时，调用`done`以指示测试完成且承诺已解决。
- en: Listing 36.6\. Testing saving a Mongoose user in userSpec.js
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 36.6\. 在 userSpec.js 中测试保存 Mongoose 用户
- en: '[PRE13]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Require necessary modules and set the environment as test.**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入必要的模块并将环境设置为测试。**'
- en: '***2*** **Assign a variable to the chai.expect function.**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将变量分配给 chai.expect 函数。**'
- en: '***3*** **Remove all users from the database before each test.**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在每个测试之前从数据库中删除所有用户。**'
- en: '***4*** **Describe a series of tests for saving users.**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **描述一系列保存用户的测试。**'
- en: '***5*** **Define a test for saving a single user.**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **定义一个保存单个用户的测试。**'
- en: '***6*** **Set up promises to save a user with sample data, and fetch all users
    from the database thereafter.**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **设置使用样本数据保存用户并随后从数据库中检索所有用户的承诺。**'
- en: '***7*** **Expect one user with an ID to exist in the database.**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **期望数据库中存在一个具有ID的用户。**'
- en: '***8*** **Call done to complete the test with promises.**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **使用 promises 完成测试的调用。**'
- en: Run your tests by running the `mocha` command in your project’s terminal window.
    This command starts your MongoDB test database and saves a test user. If your
    test doesn’t pass, make sure that your modules are connected correctly and that
    users are saving in your application in the browser. It’s helpful to know that
    the user model works correctly, and you can add more tests to this file. You can
    use sample data that shouldn’t save or try saving two users with the same email
    address, for example. Your validations should prevent both users from saving.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目终端窗口中运行`mocha`命令来运行您的测试。此命令启动MongoDB测试数据库并保存一个测试用户。如果您的测试未通过，请确保您的模块连接正确，并且用户在浏览器中的应用程序中已保存。了解用户模型是否正确工作是有帮助的，并且您可以为此文件添加更多测试。您可以使用不应保存的示例数据，或者尝试保存具有相同电子邮件地址的两个用户，例如。您的验证应该防止两个用户都保存。
- en: Next, test a controller action. After all, the controller action connects your
    models and views, providing a lot more of the experience you’d like to preserve
    in your application. In the following example, you test the user index action,
    which fetches all the users in the database and sends those users to your view
    in the response body.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，测试一个控制器操作。毕竟，控制器操作连接了您的模型和视图，提供了您希望在应用程序中保留的更多体验。在以下示例中，您测试用户索引操作，该操作从数据库中检索所有用户并将这些用户发送到您的视图的响应体中。
- en: For this test file, you need to require `chai-http` by adding `const chaiHTTP
    = require ("chai-http")` and your main `app` module by adding `const app = require("../main")`.
    Then tell `chai` to use `chaiHTTP` by adding `chai.use(chaiHTTP)`, and you’re
    ready to make server requests. In the following example, you use `chai.request(app)`
    to communicate with the server. To test the index action specifically, add the
    code in [listing 36.7](#ch36ex07) to users-ControllerSpec.js in your test folder.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此测试文件，您需要通过添加 `const chaiHTTP = require ("chai-http")` 来引入 `chai-http`，并通过添加
    `const app = require("../main")` 来引入您的主 `app` 模块。然后通过添加 `chai.use(chaiHTTP)` 告诉
    `chai` 使用 `chaiHTTP`，这样您就可以准备进行服务器请求了。在以下示例中，您使用 `chai.request(app)` 与服务器进行通信。要特别测试索引操作，请将
    [列表 36.7](#ch36ex07) 中的代码添加到您的测试文件夹中的 users-ControllerSpec.js 文件中。
- en: You can wrap your tests with a `describe` block indicating that the tests are
    for `users-Controller`. Another `describe` block specifies that the tests are
    for `GET` requests to `/users`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用表示 `users-Controller` 测试的 `describe` 块来包装您的测试，另一个 `describe` 块指定测试是针对 `/users`
    的 `GET` 请求。
- en: '|  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The first argument in `describe` is any string of your choice that explains
    what the tests are testing. You don’t need to follow the text shown in this example.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 的第一个参数是您选择的任何字符串，用于解释测试正在测试什么。您不需要遵循此示例中显示的文本。'
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Your test to show all users in the database uses `chai.request` to communicate
    with your application, which in turn sets up a web server running at port 3001\.
    Then you chain a `get` request with a `chai` helper method to reach the `/users`
    route. In your application, this should take you to the users index action in
    the users controller. You end your request with `end` and write your expectations
    on the response that’s returned from the server. You expect the response to have
    a status code of 200 and no errors.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您用于显示数据库中所有用户的测试使用 `chai.request` 与您的应用程序通信，这反过来设置了一个在端口 3001 上运行的网络服务器。然后您使用
    `chai` 的辅助方法链式一个 `get` 请求以到达 `/users` 路由。在您的应用程序中，这应该带您到用户控制器中的用户索引操作。您使用 `end`
    结束请求，并在从服务器返回的响应上写下您的期望。您期望响应的状态码为 200 且没有错误。
- en: Listing 36.7\. Testing the users index action
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 36.7\. 测试用户索引操作
- en: '[PRE14]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Describe your test block for the users index action.**'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **描述您的用户索引操作测试块。**'
- en: '***2*** **Make a GET request to your test server.**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **向您的测试服务器发送一个 GET 请求。**'
- en: '***3*** **End the request with a callback to run your expectations.**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用回调结束请求以运行您的期望。**'
- en: '***4*** **Expect your application’s response status to be 200.**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **期望您的应用程序响应状态为 200。**'
- en: '***5*** **Call done to complete the server interaction in your test.**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在您的测试中调用 done 以完成服务器交互。**'
- en: Run this test by entering `mocha` in your project’s terminal window to see two
    tests pass. Your test suite contains all the tests contained in files in the test
    folder. If you want to test only usersControllerSpec, you can run `mocha test/usersControllerSpec`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目终端窗口中输入 `mocha` 来运行此测试，以查看两个测试通过。您的测试套件包含测试文件夹中所有文件的测试。如果您只想测试 usersControllerSpec，可以运行
    `mocha test/usersControllerSpec`。
- en: '|  |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 36.3**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 36.3**'
- en: '**[Q1:](#ch36qa6q0a1)**'
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch36qa6q0a1)**'
- en: ''
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does `chai.request` do?
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`chai.request` 做了什么？'
- en: '|  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 36.3 answer**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 36.3 答案**'
- en: '**[1:](#ch36qa5q1)**'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch36qa5q1)**'
- en: ''
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`chai.request` takes a Node.js web server and allows your test environment
    to make requests. These requests mimic the ones in your production application,
    allowing for a more integrated, comprehensive test of your code.'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`chai.request` 接受一个 Node.js 网络服务器，并允许您的测试环境进行请求。这些请求模仿了生产应用程序中的请求，允许对您的代码进行更集成、更全面的测试。'
- en: '|  |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned about testing your Node.js application. You started
    with the `assert` core module and quickly jumped into testing your models and
    controllers with `chai`, `mocha`, and `chai-http`. With these tools and others,
    you’ll be able to re-create most of the actual experiences that users have with
    your application. If you can stay ahead by predicting user experiences and edge
    cases, and testing them before they go to production, you’ll face far fewer production
    crashes.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您学习了如何测试 Node.js 应用程序。您从 `assert` 核心模块开始，并迅速跳转到使用 `chai`、`mocha` 和 `chai-http`
    测试您的模型和控制器。有了这些工具和其他工具，您将能够重新创建用户与您的应用程序的实际体验的大部分。如果您能够通过预测用户体验和边缘情况并在它们进入生产之前进行测试来领先，那么您将面临的生产崩溃将少得多。
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试以下操作**'
- en: Writing a test suite isn’t a simple task, because you can write an endless number
    of tests. You want to make sure that you cover most scenarios in your application,
    using a variety of sample data.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试套件并不是一项简单的任务，因为你可以编写无数个测试。你想要确保使用各种样本数据覆盖你应用程序中的大多数场景。
- en: Create a test module for each controller and model in your application. Then
    try to build `describe` blocks and tests for each action.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 为你应用程序中的每个控制器和模型创建一个测试模块。然后尝试为每个动作构建`describe`块和测试。
- en: '|  |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lesson 37\. Capstone: Deploying Confetti Cuisine'
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第37课：综合项目：部署Confetti Cuisine
- en: It’s time to move my application to production. I’ve coordinated with Confetti
    Cuisine on original expectations and feature changes along the way. The result
    is a Node.js application running with Express.js, MongoDB, and a variety of packages
    to connect users with the Confetti Cuisine cooking school. I’ve had multiple opportunities
    to deploy this application without a database or the ability to save meaningful
    data. Now that I’ve cleaned up my code and written a few tests, I turn to Heroku
    to demo the effect of my application on the world.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我的应用程序迁移到生产环境了。我在过程中与Confetti Cuisine就原始期望和功能变更进行了协调。结果是运行在Express.js、MongoDB和各种连接用户与Confetti
    Cuisine烹饪学校的包上的Node.js应用程序。我多次有机会在没有数据库或保存有意义数据的能力的情况下部署这个应用程序。现在，我已经清理了代码并编写了一些测试，我将转向Heroku来展示我的应用程序对世界的影响。
- en: Although the steps are short and don’t involve much more coding, I want to be
    careful not to make any mistakes in the deployment process. Troubleshooting in
    development is a lot simpler than in production.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然步骤很短，并且不涉及更多的编码，但我想要小心，不要在部署过程中犯任何错误。开发中的故障排除比生产中简单得多。
- en: I’ll start by preparing my application for Heroku. Then I’ll create a new Heroku
    application through the Heroku command-line interface (CLI) in terminal. After
    using Git to save and version my changes locally, I’ll push my code up to Heroku.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先为我的应用程序准备部署到Heroku。然后，我将在终端的Heroku命令行界面（CLI）中创建一个新的Heroku应用程序。在本地使用Git保存和版本控制我的更改后，我将把我代码推送到Heroku。
- en: Next, I’ll set up my application’s MongoDB database, and add some seed data
    to start. When those tasks are complete, I’ll use a couple of production tools
    to monitor my application’s logs and prepare for meaningful user data and interaction
    with my application to roll in.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将设置我的应用程序的MongoDB数据库，并添加一些种子数据以开始。当这些任务完成时，我将使用一些生产工具来监控我的应用程序日志，并为有意义的数据和与我的应用程序的交互做好准备。
- en: '![](../Images/sectionFig.png)37.1\. Linting and logging'
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)37.1. 代码检查和日志记录'
- en: Before I deploy my application, I want to ensure that I’m not submitting code
    with any bugs or inefficiencies. Although I’ve made a point to code consciously,
    there’s always the possibility that a mistake could affect my application in production.
    To prevent potential issues in the deployment process, I install `eslint` globally
    to lint my code by running `npm install -g eslint`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我的应用程序之前，我想确保我没有提交带有任何错误或低效性的代码。尽管我已经有意识地编写代码，但总有可能出现错误影响我的生产环境中的应用程序。为了防止部署过程中的潜在问题，我全局安装`eslint`以通过运行`npm
    install -g eslint`来对我的代码进行代码检查。
- en: Linting my code provides me a list of lines in my application code that could
    be fixed, which range from removing unused variables to not properly handling
    promises and asynchronous functions. I initialize `eslint` by running the command
    `eslint --init` in my project’s terminal window. Following the prompts in terminal,
    I choose to lint for ES6 syntax and both server-side and client-side JavaScript.
    Running `eslint` in terminal creates a .eslintrc.js configuration file that `eslint`
    uses to evaluate my code. I run the global `eslint` keyword in my project’s terminal
    window to see where my code can be improved.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对我的代码进行代码检查（Linting）为我提供了一个列表，列出了我应用程序代码中可能需要修复的行，这些行从删除未使用的变量到没有正确处理承诺和异步函数。我在项目的终端窗口中通过运行命令`eslint
    --init`来初始化`eslint`。在终端的提示下，我选择对ES6语法以及服务器端和客户端JavaScript进行代码检查。在终端中运行`eslint`会创建一个`.eslintrc.js`配置文件，`eslint`使用该文件来评估我的代码。我在项目的终端窗口中运行全局`eslint`关键字，以查看我的代码可以改进的地方。
- en: I’d also like to have better logging in my application before it goes to production.
    I decide to use `morgan` to log request and response information. First, I install
    the package locally by running `npm i morgan -S` to save it as an application
    dependency. Then I require `morgan` in main.js by adding `const morgan = require("morgan")`.
    Last, I want to use a specific configuration of `morgan` that combines meaningful
    data from the request in the logs. I add `app.use(morgan("combined"))` to main.js
    to let my Express.js application know to use `morgan` with the `combined` logging
    format.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我还希望在应用程序进入生产之前有更好的日志记录。我决定使用 `morgan` 来记录请求和响应信息。首先，我通过运行 `npm i morgan -S`
    在本地安装该包，将其保存为应用程序依赖项。然后我在 main.js 中通过添加 `const morgan = require("morgan")` 来引入
    `morgan`。最后，我想使用 `morgan` 的特定配置，该配置将请求中的有意义数据结合到日志中。我在 main.js 中添加了 `app.use(morgan("combined"))`，以便让我的
    Express.js 应用程序知道使用 `morgan` 的 `combined` 日志格式。
- en: With my code cleaned up, I run my application one last time in development to
    make sure that no persistent errors prevent my application from launching. Then
    I move on to prepare my application for deployment.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的代码清理完毕后，我在开发环境中最后一次运行我的应用程序，以确保没有持续的错误阻止我的应用程序启动。然后我继续准备我的应用程序以进行部署。
- en: '![](../Images/sectionFig.png)37.2\. Preparing for production'
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![准备生产](../Images/sectionFig.png)37.2\. 准备生产'
- en: Confetti Cuisine has given me the choice of production platform to use. Because
    I’m comfortable with Heroku, I decide to begin preparing my application to live
    on Heroku’s servers.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Confetti Cuisine 给了我选择生产平台的选择。因为我熟悉 Heroku，所以我决定开始准备我的应用程序，使其能够在 Heroku 服务器上运行。
- en: '|  |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The following steps allow me to work with Heroku, but they don’t prevent my
    application from working with other services.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤允许我使用 Heroku，但它们不能阻止我的应用程序与其他服务一起工作。
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I start by verifying that Heroku CLI and Git are installed on my machine. Running
    `heroku --version` and `git --version` in terminal should let me know whether
    they’re installed and what versions they are. I need Heroku to allow the server’s
    port to use an environmental variable in production, not just port 3000\. I’ll
    make sure in main.js that my port is set by `app.set("port", process.env.PORT
    || 3000)`. The port number will initially be assigned to the port number at `process.env.PORT`
    if such a value exists. Otherwise, the port will default to 3000.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先验证我的机器上已安装了 Heroku CLI 和 Git。在终端中运行 `heroku --version` 和 `git --version`
    应该能让我知道它们是否已安装以及它们的版本。我需要 Heroku 允许服务器端口在生产中使用环境变量，而不仅仅是端口 3000。我会在 main.js 中确保我的端口通过
    `app.set("port", process.env.PORT || 3000)` 设置。如果存在这样的值，端口号最初将被分配给 `process.env.PORT`
    中的端口号。否则，端口将默认为 3000。
- en: 'Next, I modify my database connect to use the `MONGODB_URI` environmental variable
    if it’s present. I add `mongoose.connect(process.env.MONGODB_URI || "mongodb://localhost:27017/confetti_cuisine"`,`{
    useNewUrlParser: true })` to main.js. Later, when I provision a database for my
    production application, `MONGODB_URI` appears as one of the application’s configuration
    variable set to the database’s external URL.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我修改了我的数据库连接，以便如果存在，使用 `MONGODB_URI` 环境变量。我在 main.js 中添加了 `mongoose.connect(process.env.MONGODB_URI
    || "mongodb://localhost:27017/confetti_cuisine", { useNewUrlParser: true })`。稍后，当我为我的生产应用程序配置数据库时，`MONGODB_URI`
    将作为应用程序的配置变量之一出现，设置为数据库的外部 URL。'
- en: 'The last step is creating a Procfile, a file that Heroku uses as a starting
    point to launch my application. Heroku can work with a few internet protocols.
    I’ll be setting this application to work over HTTP, so I add `web: node main.js`
    to the Procfile. This line of code tells Heroku to run my application as a web
    server that should expect requests and responses over HTTP. Additionally, I’m
    telling Heroku to use main.js to start the application.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一步是创建一个 Procfile，这是一个 Heroku 用来作为启动我的应用程序的起点文件。Heroku 可以与几种互联网协议一起工作。我将设置此应用程序通过
    HTTP 工作，所以我将 `web: node main.js` 添加到 Procfile 中。这一行代码告诉 Heroku 将我的应用程序作为应该通过 HTTP
    接收请求和响应的 Web 服务器运行。此外，我还告诉 Heroku 使用 main.js 来启动应用程序。'
- en: My code is almost ready to deploy. I need to save my changes and follow a few
    more steps to send my code to production.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我的代码几乎准备好部署了。我需要保存我的更改并遵循几个更多步骤，将我的代码发送到生产环境。
- en: '![](../Images/sectionFig.png)37.3\. Deploying to Heroku'
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![部署到 Heroku](../Images/sectionFig.png)37.3\. 部署到 Heroku'
- en: Now that I’m happy with the state of my code, I’ll add and commit my changes
    to Git. First, I want to run `git init` to initialize my project with Git. If
    I’ve already performed this line, Git harmlessly reinitializes the project; none
    of my previous changes are affected. Git bundles all my code together, so I want
    to make sure that nothing gets bundled that I don’t want to send across the internet,
    including passwords, sensitive data of any kind, and my node_modules folder. I’ve
    kept sensitive data out of my application, so I want to keep my node_modules folder
    from going to production; the folder can get pretty large, slowing my deployment
    process. Also, Heroku runs `npm install` for me, once deployed. I create a file
    called .gitignore and add node_modules to that file.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我对我的代码状态感到满意，我将添加并提交我的更改到Git。首先，我想运行`git init`来使用Git初始化我的项目。如果我已执行过这一行，Git会无害地重新初始化项目；我的先前更改不受影响。Git将我的所有代码捆绑在一起，因此我想确保不会捆绑我不希望通过互联网发送的内容，包括密码、任何类型的敏感数据以及我的node_modules文件夹。我已经将敏感数据排除在我的应用之外，因此我想确保我的node_modules文件夹不会进入生产环境；该文件夹可能相当大，会减慢我的部署过程。此外，一旦部署，Heroku会为我运行`npm
    install`。我创建了一个名为.gitignore的文件，并将node_modules添加到该文件中。
- en: Next, I run `git add .` to add all my files to a staging area, ready to be committed.
    I run `git status` to confirm the files that will be committed and run `git commit
    -m "first production deployment"` to indicate this version of my code before going
    to production. With my code saved, I use the `heroku` keyword in terminal to register
    my application with Heroku. From my project’s directory in terminal, I run `heroku
    create confetti-cuisine`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我运行`git add .`将所有文件添加到暂存区，准备提交。我运行`git status`以确认将要提交的文件，并运行`git commit
    -m "first production deployment"`来指示在生产之前这一版本的代码。将我的代码保存后，我在终端中使用`heroku`关键字来将我的应用注册到Heroku。在终端中，从我的项目目录运行`heroku
    create confetti-cuisine`。
- en: '|  |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If the name `confetti-cuisine` isn’t already used by another application on
    Heroku, this command generates a URL through which I’ll be able to access my application.
    Anyone following my steps will need to choose a different name for their heroku
    app in this command.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名称`confetti-cuisine`在Heroku上尚未被其他应用使用，此命令将生成一个URL，通过该URL我可以访问我的应用。遵循我的步骤的人需要在此命令中为他们的heroku应用选择一个不同的名称。
- en: '|  |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That URL is [https://confetti-cuisine.herokuapp.com](https://confetti-cuisine.herokuapp.com).
    This command also creates a remote Git repository on Heroku for me. This configuration
    allows me to submit my local Git repository to that address; from there, Heroku
    will install and run my application. I can verify the URL of the remote repository
    by running `git remote -v`. I see that my remote repository is referenced by the
    name `heroku`, so when I’m ready, I can use the name `heroku` to push my code
    to production.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 那个URL是[https://confetti-cuisine.herokuapp.com](https://confetti-cuisine.herokuapp.com)。此命令还为我创建了一个远程Git仓库。这种配置允许我将我的本地Git仓库提交到该地址；从那里，Heroku将安装并运行我的应用。我可以通过运行`git
    remote -v`来验证远程仓库的URL。我看到我的远程仓库被命名为`heroku`，所以当我准备好时，我可以使用名称`heroku`将我的代码推送到生产环境。
- en: Making sure that I have a reliable internet connection, I run `git push heroku
    master` .`master` is the name of the container holding my code within Git, and
    I’m uploading the code in that container to a similarly named container at the
    URL associated with `heroku`. Running this command initiates a series of operations
    that Heroku uses to set up the application and install its package dependencies.
    The whole process takes less than a minute for my application. When it’s complete,
    I can run `heroku open` to launch my production URL in a web browser.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我有一个可靠的互联网连接，然后运行`git push heroku master`。`master`是Git中包含我的代码的容器名称，我将该容器中的代码上传到与`heroku`关联的URL上的同名容器。运行此命令将启动一系列操作，Heroku使用这些操作来设置应用并安装其包依赖项。对于我的应用，整个过程不到一分钟。完成之后，我可以运行`heroku
    open`在网页浏览器中启动我的生产URL。
- en: Right away, I notice that the application isn’t working ([figure 37.1](#ch37fig01))
    because my database isn’t set up yet, and my application depends on a database
    for any page to load.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我立刻注意到应用没有工作（[图37.1](#ch37fig01)），因为我的数据库尚未设置，而我的应用需要数据库才能加载任何页面。
- en: Figure 37.1\. Application not loading on Heroku
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图37.1\. 在Heroku上应用无法加载
- en: '![](../Images/37fig01_alt.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/37fig01_alt.jpg)'
- en: In the next section, I set up a MongoDB database for my production application.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我为我的生产应用设置一个MongoDB数据库。
- en: '![](../Images/sectionFig.png)37.4\. Setting up the database'
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)37.4\. 设置数据库'
- en: I chose to use MongoDB as my application’s database for a few reasons. One reason
    is that it’s so simple to set up in production. Setting up a development and test
    database is an effortless task. Now I need to add a Heroku plugin to associate
    a database service, and in a single step, my application will start working.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用MongoDB作为我应用程序的数据库有几个原因。其中一个原因是它在生产环境中设置非常简单。设置开发和测试数据库是一项轻松的任务。现在我需要添加一个Heroku插件来关联数据库服务，然后通过一步操作，我的应用程序就可以开始工作了。
- en: I run `heroku addons:create mongolab:sandbox` in my project’s terminal window
    to create an mLab MongoDB database for my application. Because I’ve associated
    my local project with my registered Heroku application, I can continue to use
    the Heroku CLI in terminal to manage my production application. This command provides
    a free-tier database hosted by mLab. This sandbox database isn’t recommended for
    use in production, however, because of its size and availability limitations.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的项目终端窗口中运行`heroku addons:create mongolab:sandbox`来为我的应用程序创建一个mLab MongoDB数据库。因为我已经将我的本地项目与我的注册Heroku应用程序关联起来，所以我可以在终端中继续使用Heroku
    CLI来管理我的生产应用程序。此命令提供了一个由mLab托管的免费层数据库。然而，由于其大小和可用性限制，此沙盒数据库不建议用于生产。
- en: '|  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If Confetti Cuisine likes the way that my application looks and behaves on
    Heroku, I can increase my mLab plan at a cost by running `heroku addons:create
    mongolab: shared-cluster-1`.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Confetti Cuisine喜欢我在Heroku上应用程序的外观和行为，我可以通过运行`heroku addons:create mongolab:shared-cluster-1`来以成本增加我的mLab计划。
- en: '|  |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: I don’t want to upgrade my database account until I’m sure that I need the extra
    space. Upgrading from terminal may incur fees in my Heroku account.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想在确定需要额外空间之前升级我的数据库账户。从终端升级可能会在我的Heroku账户中产生费用。
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Alternatively, I can set up my MongoDB database at any external location and
    set the `MONGODB_URI` variable to that external database’s URL.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我可以在任何外部位置设置我的MongoDB数据库，并将`MONGODB_URI`变量设置为该外部数据库的URL。
- en: I verify the database URL setup with Heroku by running `heroku config:get MONGODB_URI`.
    This command responds with my mLab database URL, along with the security credentials
    I need to use to access the database. If I want to view the contents of my database
    on a web browser, I can run `heroku addons:open mongolab` to open a new web page
    pointing to my database on mLab’s site through Heroku ([figure 37.2](#ch37fig02)).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过运行`heroku config:get MONGODB_URI`来验证与Heroku的数据库URL设置。此命令会响应我的mLab数据库URL，以及我需要用于访问数据库的安全凭据。如果我想在网页浏览器中查看我的数据库内容，我可以运行`heroku
    addons:open mongolab`来打开一个新网页，通过Heroku指向我的mLab站点上的数据库（[图37.2](#ch37fig02)）。
- en: Figure 37.2\. Displaying contents of mLab database
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图37.2\. 显示mLab数据库的内容
- en: '![](../Images/37fig02_alt.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/37fig02_alt.jpg)'
- en: Now when I visit [https://confetti-cuisine.herokuapp.com/](https://confetti-cuisine.herokuapp.com/),
    I finally see my home page load ([figure 37.3](#ch37fig03)).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我访问[https://confetti-cuisine.herokuapp.com/](https://confetti-cuisine.herokuapp.com/)时，我终于看到我的主页加载了（[图37.3](#ch37fig03)）。
- en: Figure 37.3\. Loading the home page
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图37.3\. 加载主页
- en: '![](../Images/37fig03_alt.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/37fig03_alt.jpg)'
- en: With my application in production, I’d like to make it more presentable by preloading
    it with some data. I have a few ways to load seed data into my application, including
    linking directly to my mLab database and pushing data into my database. Instead,
    I’m going to run `heroku run node` in my project’s terminal window to enter the
    production REPL environment. As with REPL in development, I can interact with
    my Node.js application here and even save to my database. I’ve prepared some courses
    that I want to save, so I copy the lines of code where those courses are created
    and paste them into this REPL shell. First, I need to copy the lines requiring
    the modules I need, such as `mongoose` and the Course model itself. I enter the
    code in [listing 37.1](#ch37ex01) into my terminal window and watch as courses
    are populated into my application. I can click my Ajax courses modal to see those
    new listings.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的应用程序投入生产后，我想通过预先加载一些数据来使其更具吸引力。我有几种方法可以将种子数据加载到我的应用程序中，包括直接链接到我的mLab数据库和将数据推送到我的数据库。相反，我将在项目终端窗口中运行`heroku
    run node`以进入生产REPL环境。与开发中的REPL一样，我可以在这里与我的Node.js应用程序交互，甚至将其保存到数据库中。我已经准备了一些我想保存的课程，所以我复制了创建这些课程的代码行并将其粘贴到这个REPL
    shell中。首先，我需要复制需要模块的行，例如`mongoose`和Course模型本身。我将[列表37.1](#ch37ex01)中的代码输入到我的终端窗口中，并观察课程如何填充到我的应用程序中。我可以点击Ajax课程模态来查看这些新列表。
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It may help to first format the code into your text editor before pasting into
    your terminal window.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码粘贴到终端窗口之前，首先将代码格式化到您的文本编辑器中可能会有所帮助。
- en: '|  |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 37.1\. Adding seed data to my production application
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 37.1. 向我的生产应用程序添加种子数据
- en: '[PRE15]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Require the necessary modules and database connection for REPL.**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要为 REPL 请求必要的模块和数据库连接。**'
- en: '***2*** **Create new courses for my production database.**'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为我的生产数据库创建新课程。**'
- en: With this data loaded, I can finally show the finished application to Confetti
    Cuisine. I need to keep an eye on the logs, though, in case any new users experience
    an issue with the live application.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 加载这些数据后，我终于可以向 Confetti Cuisine 展示完成的应用程序。不过，我需要密切关注日志，以防任何新用户在使用实时应用程序时遇到问题。
- en: '![](../Images/sectionFig.png)37.5\. Debugging in production'
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)37.5. 生产环境中的调试'
- en: My role has transitioned from developer to bug-fixer and maintainer. I need
    to make sure that the code I’ve written preserves the functionality I’ve promised,
    and I’ll quickly repair the code that doesn’t uphold that promise.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我的角色已经从开发者转变为错误修复者和维护者。我需要确保我编写的代码保留了承诺的功能，并且我会迅速修复不履行承诺的代码。
- en: Because my code isn’t running from my personal computer, I need to access the
    logs from Heroku by running `heroku logs --tail` in my project’s terminal window.
    This command communicates with Heroku to provide a live stream of logs. The logs
    tell me when an error occurs, whether my application crashes, and everything I
    need to know about the incoming requests and outgoing responses.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我的代码不是从我的个人电脑上运行的，所以我需要通过在项目的终端窗口中运行 `heroku logs --tail` 来访问 Heroku 的日志。此命令与
    Heroku 通信，提供日志的实时流。日志告诉我何时发生错误，我的应用程序是否崩溃，以及我需要了解的所有关于传入请求和传出响应的信息。
- en: As I make sense of the log messages, if I come across an issue, I can try to
    reproduce it locally on my computer. I can run `heroku local web` in my project’s
    terminal window to launch my application code that’s in production locally. This
    command runs my application at http://localhost:5000/. If I see the error occur
    while testing here, I can get a better sense of what needs to be fixed. Last,
    I can use the Node.js debug tool by adding a breakpoint on the line of code that
    I suspect is causing the error. By adding `debugger` to my code, I can step through
    my running application, pause, and analyze the values in specific functions.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当我理解日志消息时，如果遇到问题，我可以在我的电脑上尝试本地重现。我可以在项目的终端窗口中运行 `heroku local web` 来启动本地生产环境中的应用代码。此命令在我的
    http://localhost:5000/ 上运行我的应用程序。如果我在这里测试时看到错误发生，我可以更好地了解需要修复的内容。最后，我可以在我怀疑导致错误的代码行上设置断点来使用
    Node.js 调试工具。通过在我的代码中添加 `debugger`，我可以逐步执行运行中的应用程序，暂停，并分析特定函数中的值。
- en: I’m confident that this application will experience few issues and offer Confetti
    Cuisine a great new way to interact with its audience. Meanwhile, I’ll be around
    in case the company needs my help. I’m only a `git add .`, `git commit -m "<some
    message>"`, and `git push heroku master` away from deploying an update.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信这个应用程序将遇到很少的问题，并为 Confetti Cuisine 提供一种与观众互动的新方式。同时，如果公司需要我的帮助，我会在这里。我只需
    `git add .`，`git commit -m "<some message>"` 和 `git push heroku master` 就可以部署更新。
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)摘要'
- en: In this final capstone exercise, I deployed my application to be accessible
    to the public. With the right configurations in place and a working Node.js application,
    I was able to upload my application to a production server. From this server,
    incoming requests will be handled and queries made to an external database. My
    application now depends on a variety of resources that may incur fees as my application
    collects more data and popularity. As traffic and demand increase on my application,
    more resources will be required, and I’ll need to consider the costs of hosting
    my Node.js application somewhere that can support its growing database and popularity.
    Scalability, high availability, and performance improvements are all topics of
    my next iteration with this application, and I hope that Confetti Cuisine will
    be happy to collaborate as I implement future improvements.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的综合练习中，我将我的应用程序部署为可供公众访问。通过设置正确的配置并运行一个有效的Node.js应用程序，我能够将我的应用程序上传到生产服务器。从这个服务器，将处理传入的请求并对外部数据库进行查询。我的应用程序现在依赖于各种可能产生费用的资源，随着我的应用程序收集更多数据和受欢迎程度，这些费用可能会增加。随着我的应用程序的流量和需求增加，将需要更多的资源，我需要考虑将我的Node.js应用程序托管在能够支持其不断增长的数据库和受欢迎程度的场所的成本。可扩展性、高可用性和性能改进都是我接下来对这个应用程序的迭代中的主题，我希望Confetti
    Cuisine在实施未来的改进时能够乐意合作。
