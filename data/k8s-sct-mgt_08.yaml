- en: 6 Accessing cloud secrets stores
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 访问云秘密存储库
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using the Container Storage Interface (CSI) and the Secrets Store CSI Driver
    to inject secrets as volumes from cloud secrets stores
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器存储接口（CSI）和秘密存储 CSI 驱动程序从云秘密存储库注入秘密作为卷
- en: Populating cloud secrets into Kubernetes clusters as Kubernetes Secrets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将云秘密填充到 Kubernetes 集群作为 Kubernetes Secrets
- en: Using auto rotation of secrets in the Secret Storage CSI Driver to improve security
    posture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用秘密存储 CSI 驱动程序中的秘密自动轮换来提高安全态势
- en: Consuming sensitive information from cloud secrets stores
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从云秘密存储库中消费敏感信息
- en: Chapter 5 introduced HashiCorp Vault, which can be used for securely storing
    and managing sensitive assets for applications deployed to Kubernetes and demonstrated
    how both applications and Vault can be configured to provide seamless integration
    with one another. This chapter expands the idea introduced in the previous chapter
    of using an external secrets management tool to store secrets and injecting them
    inside the Pod, either as a volume or as an environment variable. But in this
    chapter we’ll focus on cloud secrets stores, like Google Secret Manager, Azure
    Key Vault, and AWS Secrets Manager.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5 章介绍了 HashiCorp Vault，它可以用于安全地存储和管理部署到 Kubernetes 的应用程序的敏感资产，并演示了如何配置应用程序和
    Vault 以提供彼此的无缝集成。本章扩展了上一章中介绍的想法，即使用外部秘密管理工具存储秘密并将它们注入 Pod 内，无论是作为卷还是作为环境变量。但在这章中，我们将重点关注云秘密存储库，如
    Google Secret Manager、Azure Key Vault 和 AWS Secrets Manager。
- en: First you’ll learn about the Container Storage Interface (CSI) and the Secrets
    Store CSI Driver, using them to inject secrets stored in HashiCorp Vault. Then
    you’ll learn about injecting Kubernetes Secrets using the Secrets Store CSI Driver
    as well as secret auto rotation. Finally, we’ll discuss the integration between
    the CSI driver and Google Secret Manager, Azure Key Vault, and AWS Secrets Manager,
    so secrets can be injected directly from the secrets store to the Pod.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将了解容器存储接口（CSI）和秘密存储 CSI 驱动程序，并使用它们将存储在 HashiCorp Vault 中的秘密注入。然后，您将了解如何使用秘密存储
    CSI 驱动程序注入 Kubernetes Secrets 以及秘密自动轮换。最后，我们将讨论 CSI 驱动程序与 Google Secret Manager、Azure
    Key Vault 和 AWS Secrets Manager 之间的集成，以便可以从秘密存储库直接将秘密注入 Pod。
- en: 6.1 The Container Storage Interface and Secrets Store CSI Driver
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 容器存储接口和秘密存储 CSI 驱动程序
- en: As you have seen thus far, the `etcd` database stores the Kubernetes Secrets
    either unencrypted (by default) or encrypted, as shown in chapter 4\. But what
    if you don’t want to store your secrets in the `etcd` and instead would like to
    store and manage them outside of the Kubernetes cluster? One option, shown in
    chapter 5, is using HashiCorp Vault and HashiCorp Vault Agent to store secrets
    and inject them into a Pod.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如您迄今为止所见，`etcd` 数据库以未加密（默认情况下）或加密的形式存储 Kubernetes Secrets，如第 4 章所示。但如果你不想在 `etcd`
    中存储你的秘密，而是想将它们存储和管理在 Kubernetes 集群之外呢？第 5 章中展示的一个选项是使用 HashiCorp Vault 和 HashiCorp
    Vault Agent 存储秘密并将它们注入 Pod。
- en: HashiCorp Vault is an option, but nowadays cloud providers also offer their
    key vaults; for example, Google offers Google Secret Manager, and Amazon offers
    AWS Secrets Manager. What would happen if you wanted to use them to store secrets
    instead of `etcd` or Hashicorp Vault? Could you use the same approach previously
    but inject secrets as volume or environment variables from an external cloud store
    instead of `etcd`?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Vault 是一个选项，但如今云提供商也提供了它们自己的密钥保管库；例如，Google 提供了 Google Secret Manager，而
    Amazon 提供了 AWS Secrets Manager。如果你想使用它们来存储秘密而不是 `etcd` 或 Hashicorp Vault 会发生什么？你能使用之前相同的方法，但将秘密作为卷或环境变量从外部云存储库注入而不是
    `etcd` 吗？
- en: The answer is yes! But before we show you how to do it, we need to introduce
    the CSI initiative—a standard for exposing arbitrary block and file storage systems
    to containerized workloads like Kubernetes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的！但在我们向您展示如何做之前，我们需要介绍 CSI 创新计划——一个用于将任意块和文件存储系统暴露给容器化工作负载（如 Kubernetes）的标准。
- en: 6.1.1 Container Storage Interface
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 容器存储接口
- en: 'As you’ve seen in chapter 2, a Kubernetes `volume` is a directory containing
    some data access to the containers running inside Pods. The physical storage of
    the volume is determined by the volume type used, and the volume is mapped during
    Pod initialization, executing the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在第 2 章中所见，Kubernetes `volume` 是一个包含对运行在 Pod 内的容器中某些数据访问的目录。卷的物理存储由所使用的卷类型确定，卷在
    Pod 初始化期间进行映射，执行以下步骤：
- en: The API server receives a command to create a new Pod in the Kubernetes cluster.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 服务器收到在 Kubernetes 集群中创建新 Pod 的命令。
- en: The scheduler finds a node that meets the desired criteria and sends the Pod
    definition to the node.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度器找到一个满足所需标准的节点，并将 Pod 定义发送到该节点。
- en: The node kubelet reads the Pod definition, sees that you want to attach a volume
    to the Pod container, and creates the volume via the volume plugin. This volume
    plugin is responsible for connecting to the configured persistence storage.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点 kubelet 读取 Pod 定义，看到您想要将卷附加到 Pod 容器，并通过卷插件创建卷。这个卷插件负责连接到配置的持久存储。
- en: Figure 6.1 summarizes all these steps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 总结了所有这些步骤。
- en: '![](../Images/CH06_F01_Sotobueno3.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F01_Sotobueno3.png)'
- en: Figure 6.1 Process of creating a Volume from Pod perspective
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 从 Pod 视角创建卷的过程
- en: 'As you can see, the *volume plugins* belong to the Kubernetes core. However,
    this approach has the following drawbacks:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，*卷插件*属于 Kubernetes 核心。然而，这种方法有以下缺点：
- en: Volume plugin development is coupled to the Kubernetes development and release
    cycle. Any new supported volume (and volume plugin) requires a new version of
    Kubernetes.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷插件开发与 Kubernetes 开发和发布周期相关联。任何新的受支持的卷（和卷插件）都需要 Kubernetes 的新版本。
- en: Any correction in a volume plugin (e.g., a fix bug or improvement) requires
    a new release of Kubernetes.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在卷插件（例如，修复错误或改进）中的任何更正都需要发布新的 Kubernetes 版本。
- en: Since volume plugins are inside Kubernetes, the source code is open; this is
    not a problem, until you need to make the plugin private.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于卷插件在 Kubernetes 内部，源代码是开放的；这并不是问题，直到您需要将插件私有化。
- en: CSI is an initiative that can be used to unify the storage interface of container
    orchestrator (CO) systems, like Kubernetes, Mesos, Docker Swarm, and so on, combined
    with storage vendors, like Ceph, Azure Disk, GCE persistent disk, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 是一个可以用来统一容器编排器（CO）系统（如 Kubernetes、Mesos、Docker Swarm 等）的存储接口的倡议，结合了存储供应商（如
    Ceph、Azure Disk、GCE 持久磁盘等）。
- en: The first implication of CSI is that any implementation is guaranteed to work
    with all COs. The second implication is the location of the CSI elements; they
    are outside the CO core (i.e., the Kubernetes core), making them free to develop
    and release independently of the CO. Figure 6.2 shows a brief overview of the
    CSI.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 的第一个含义是任何实现都保证与所有 CO 一起工作。第二个含义是 CSI 元素的定位；它们位于 CO 核心（即 Kubernetes 核心）之外，这使得它们可以独立于
    CO 进行开发和发布。图 6.2 展示了 CSI 的简要概述。
- en: '![](../Images/CH06_F02_Sotobueno3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F02_Sotobueno3.png)'
- en: Figure 6.2 CSI schema
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 CSI 架构
- en: 'The CSI driver is the bridge between container clusters and the persistent
    storage implementing the operations required by the CSI specification for the
    specific storage. CSI drivers provide the following functionality:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 驱动程序是容器集群和实现 CSI 规范所需操作的持久存储之间的桥梁。CSI 驱动程序提供以下功能：
- en: Creating persistent external storage
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建持久的外部存储。
- en: Configuring persistent external storage
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置持久的外部存储。
- en: Managing all input/output (I/O) between cluster and storage
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理集群和存储之间的所有输入/输出（I/O）。
- en: Providing advanced disk features, such as snapshots and cloning
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供高级磁盘功能，如快照和克隆。
- en: CSI drivers include AliCloud Disk, AWS Elastic Block Storage, Azure Disk Storage,
    CephFS, DigitalOcean Block Storage, and GCE Persistent Disk.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 驱动程序包括阿里云磁盘、AWS 弹性块存储、Azure 磁盘存储、CephFS、DigitalOcean 块存储和 GCE 持久磁盘。
- en: 6.1.2 Container Storage Interface and Kubernetes
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 容器存储接口和 Kubernetes
- en: CSI gained general availability (GA) status at version 1.13 of Kubernetes and
    can be used with Kubernetes volumes components (e.g., persistent volumes, persistent
    volumes claims, and storage classes). Kubernetes has some components that don’t
    belong to the core that interact with the external pluggable container storage.
    This interaction occurs via Google Remote Procedure Calls (gRPCs) on domain sockets.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 在 Kubernetes 1.13 版本中获得了一般可用性（GA）状态，并且可以与 Kubernetes 卷组件（例如，持久卷、持久卷声明和存储类）一起使用。Kubernetes
    有一些不属于核心的组件，它们与外部可插拔容器存储进行交互。这种交互是通过 Google 远程过程调用（gRPCs）在域套接字上发生的。
- en: 'A Kubernetes cluster with CSI installed has the following components:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 CSI 的 Kubernetes 集群具有以下组件：
- en: '*Kubernetes core*—This is the core of Kubernetes, where most of the elements
    introduced in this book live.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes 核心*——这是 Kubernetes 的核心，本书中介绍的大部分元素都生活在这里。'
- en: '*CSI external components*—This is a set of Linux containers, which contains
    common logic to trigger appropriate Kubernetes events to the CSI driver. Although
    these containers aren’t mandatory, they help reduce the amount of boilerplate
    code required to implement the CSI driver.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CSI外部组件*——这是一组Linux容器，其中包含触发适当Kubernetes事件到CSI驱动程序的通用逻辑。尽管这些容器不是必需的，但它们有助于减少实现CSI驱动程序所需的样板代码量。'
- en: '*Third-party external components*—These are vendor-specific implementations
    to communicate with the persistent storage solution.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三方外部组件*——这是与持久化存储解决方案通信的供应商特定实现。'
- en: Each of these components has subcomponents, and the most important ones can
    be seen in figure 6.3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件中每个都有子组件，其中最重要的可以在图6.3中看到。
- en: '![](../Images/CH06_F03_Sotobueno3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F03_Sotobueno3.png)'
- en: Figure 6.3 Kubernetes cluster with CSI
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 带有CSI的Kubernetes集群
- en: For the scope of this book, this is all you need to know about CSI specification
    and its integration with Kubernetes. A deep understanding of the system would
    be required to implement a specific CSI driver for a persistent storage system.
    Thanks to this separation of concerns, you can now write and deploy plugins, exposing
    new storage systems in Kubernetes without having to touch the Kubernetes core,
    so no further release of Kubernetes is required.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的范围，这就是您需要了解的关于CSI规范及其与Kubernetes集成的所有内容。要实现特定持久化存储系统的特定CSI驱动程序，需要深入了解该系统。感谢这种关注点的分离，您现在可以编写和部署插件，在Kubernetes中暴露新的存储系统，而无需触及Kubernetes核心，因此不需要进一步发布Kubernetes。
- en: 6.1.3 CSI and secrets
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 CSI和密钥
- en: CSI is designed to create a standard manner of exposing all the different storage
    systems to Kubernetes and container workloads. With this standard in place, all
    you have to do is deploy the plugin (CSI driver) on your cluster. Can this be
    extended to other kinds of systems, such as secrets stores?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: CSI旨在以标准方式将所有不同的存储系统暴露给Kubernetes和容器工作负载。有了这个标准，您只需在您的集群上部署插件（CSI驱动程序）即可。这能否扩展到其他类型的系统，如密钥存储？
- en: The Secrets Store CSI Driver is no different from any other CSI driver, allowing
    Kubernetes to attach a secret placed in an external secrets store into Pods as
    a volume. After the Volume is attached, the secret is available in the container’s
    file system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets Store CSI驱动程序与其他任何CSI驱动程序没有区别，允许Kubernetes将放置在外部密钥存储中的密钥附加到Pod作为卷。卷附加后，密钥在容器的文件系统中可用。
- en: One of the elements that makes the Secrets Store CSI Driver extensible is the
    Secrets Store CSI provider. Instead of connecting to a secrets store directly,
    the driver has a new level of abstraction in the form of a provider, so depending
    on the secrets store used, the only element you need to install is the specific
    provider.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets Store CSI驱动程序可扩展性的一个要素是Secrets Store CSI提供者。驱动程序不是直接连接到密钥存储，而是通过提供者这一新的抽象级别，因此，根据所使用的密钥存储，您只需要安装特定的提供者。
- en: 'At the time of writing, the following secrets stores are supported:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，以下密钥存储得到支持：
- en: AWS Secrets Manager Systems Manager Parameter Store (AWS Provider)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Secrets Manager Systems Manager Parameter Store（AWS提供者）
- en: Azure Key Vault (Azure Provider)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Key Vault（Azure提供者）
- en: Google Secret Manager (GCP Provider)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Secret Manager（GCP提供者）
- en: HashiCorp Vault (Vault Provider)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vault（Vault提供者）
- en: Figure 6.4 shows an overview of the Secrets Store CSI architecture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4展示了Secrets Store CSI架构的概览。
- en: '![](../Images/CH06_F04_Sotobueno3.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F04_Sotobueno3.png)'
- en: Figure 6.4 Kubernetes cluster with CSI
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 带有CSI的Kubernetes集群
- en: Before you use CSI and the Secrets Store CSI Driver, you will need to create
    a Kubernetes cluster and install CSI and the Secrets Store CSI Driver. We detail
    this process in the following sections.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用CSI和Secrets Store CSI驱动程序之前，您需要创建一个Kubernetes集群并安装CSI和Secrets Store CSI驱动程序。我们将在以下部分详细说明此过程。
- en: 6.1.4 Installing prerequisites
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 安装先决条件
- en: Start a new minikube instance by running the following command in a terminal
    window.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中运行以下命令以启动一个新的minikube实例。
- en: Listing 6.1 Start minkube
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 启动minkube
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Creates a Kubernetes cluster under the CSI profile
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在CSI配置文件下创建一个Kubernetes集群
- en: 6.1.5 Installing the Secrets Store CSI Driver
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.5 安装Secrets Store CSI驱动程序
- en: The latest version of the Secrets Store CSI Driver at this time is `0.1.0`;
    although you might think it’s an immature project, the truth is that it has been
    under development for a long time. Run the commands shown in the following listing
    to install Secrets Store CSI.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 Secrets Store CSI 驱动程序的最新版本是 `0.1.0`；尽管您可能认为它是一个不成熟的项目，但事实是它已经开发很长时间了。运行以下列表中显示的命令来安装
    Secrets Store CSI。
- en: Listing 6.2 Install the Secrets Store CSI Driver
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 安装 Secrets Store CSI 驱动程序
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Configures RBAC for the secret provider
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为密钥提供程序配置 RBAC
- en: ② Configures the CSI driver
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ② 配置 CSI 驱动程序
- en: ③ Registers Secrets Store CRDs
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 注册 Secrets Store CRDs
- en: ④ Installs the Secrets Store CSI Driver
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 安装 Secrets Store CSI 驱动程序
- en: Since we’ll be using the mapping between secrets-store content as Kubernetes
    Secrets and autorotation of secrets later, some additional RBAC permissions are
    required to enable it, as shown.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在密钥存储库内容与 Kubernetes 密钥之间的映射以及密钥自动轮换中使用，因此需要一些额外的 RBAC 权限来启用它，如下所示。
- en: Listing 6.3 Installing RBAC
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 安装 RBAC
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Sync secrets-store content as Kubernetes Secrets.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 secrets-store 内容同步为 Kubernetes 密钥。
- en: ② Additional RBAC permissions for secret rotation
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ② 密钥轮换的额外 RBAC 权限
- en: 'NOTE If you are running Kubernetes in Windows Nodes (notice that minikube runs
    inside a Linux VM, so you don’t need to run the command), you’ll need to run the
    following command too:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您正在 Windows 节点上运行 Kubernetes（请注意，minikube 运行在一个 Linux 虚拟机中，因此您不需要运行该命令），您还需要运行以下命令：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Use this command if you are running Windows Nodes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果您正在运行 Windows 节点，请使用此命令。
- en: To validate the installation of the Secrets Store CSI Driver, run the commands
    shown in the following listing to validate that Pods are running correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 Secrets Store CSI 驱动程序的安装，运行以下列表中显示的命令以验证 Pods 是否正在正确运行。
- en: Listing 6.4 Validating the Secrets Store CSI Driver
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 验证 Secrets Store CSI 驱动程序
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Get Pods from the kube-system namespace
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 kube-system 命名空间获取 Pods
- en: 'You should see the Secrets Store CSI Driver Pods running on each agent node:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到 Secrets Store CSI 驱动程序 Pods 在每个代理节点上运行：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that you’ve installed the Secrets Store CSI Driver into the Kubernetes cluster,
    it’s time to select a Secrets Store CSI provider and deploy it. In the first example,
    you’ll use HashiCorp Vault, as it’s an agnostic secrets store, and you’ve already
    used it in the previous chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将 Secrets Store CSI 驱动程序安装到 Kubernetes 集群中，是时候选择一个 Secrets Store CSI 提供程序并将其部署了。在第一个示例中，您将使用
    HashiCorp Vault，因为它是一个无差别的密钥存储库，您已经在上一章中使用过它。
- en: The most significant deviation from your previous use of HashiCorp Vault is
    how a secret will be injected into the Pod. In one of the examples in chapter
    5, you saw the HashiCorp Vault agent in charge of performing the injection; figure
    6.5 contains a recap of how HashiCorp Vault Agent works. However, in this chapter,
    no agent will be used, and the Secrets Store CSI Driver will inject the secrets.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与您之前使用 HashiCorp Vault 的最大不同之处在于密钥将如何注入到 Pod 中。在第 5 章的一个示例中，您看到了负责执行注入的 HashiCorp
    Vault 代理；图 6.5 包含了 HashiCorp Vault Agent 的工作回顾。然而，在本章中，将不会使用代理，而是 Secrets Store
    CSI 驱动程序将注入密钥。
- en: '![](../Images/CH06_F05_Sotobueno3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F05_Sotobueno3.png)'
- en: Figure 6.5 A Pod being modified by the `MutatingWebhookConfiguration` to inject
    the Vault Agent Injector at admission time
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 Pod 在 admission 时间被 `MutatingWebhookConfiguration` 修改以注入 Vault Agent Injector
- en: 6.1.6 Consuming HashiCorp Vault secrets via the Secrets Store CSI Driver and
    the HashiCorp Vault provider
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.6 通过 Secrets Store CSI 驱动程序和 HashiCorp Vault 提供程序消费 HashiCorp Vault 密钥
- en: In this section, you will use HashiCorp Vault as a secrets store and consume
    the secrets using the Secrets Store CSI Driver and the HashiCorp Vault provider.
    Figure 6.6 shows an overview of what you will implement in this section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用 HashiCorp Vault 作为密钥存储库，并通过 Secrets Store CSI 驱动程序和 HashiCorp Vault
    提供程序来消费密钥。图 6.6 展示了您在本节中将实现的内容概述。
- en: '![](../Images/CH06_F06_Sotobueno3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F06_Sotobueno3.png)'
- en: Figure 6.6 The Secrets Store CSI Driver with the HashiCorp Vault provider
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 带有 HashiCorp Vault 提供程序的 Secrets Store CSI 驱动程序
- en: The first thing you’ll need is a HashiCorp Vault instance running in the Kubernetes
    cluster. You’ve already deployed a HashiCorp Vault instance in Kubernetes in chapter
    5; now you’ll do it again in the current cluster. To get started, first add the
    HashiCorp repository to Helm as follows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要的是一个在 Kubernetes 集群中运行的 HashiCorp Vault 实例。您已经在第 5 章中部署了一个 HashiCorp Vault
    实例；现在您将在当前集群中再次部署。要开始，首先按照以下步骤将 HashiCorp 仓库添加到 Helm。
- en: Listing 6.5 Adding Helm chart
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 添加 Helm 图表
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Adds HashiCorp Helm repository
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ① 添加 HashiCorp Helm 仓库
- en: 'Then retrieve the latest updates from the remote repositories:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从远程仓库检索最新更新：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Updates the chart repositories
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ① 更新图表仓库
- en: Execute the command in the following listing to install the chart in development
    mode with Vault CSI provider enabled.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下列表中的命令以启用Vault CSI提供者并安装开发模式下的图表。
- en: Listing 6.6 Deploying HashiCorp Vault with a Secrets Store CSI provider
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6使用Secrets Store CSI提供者部署HashiCorp Vault
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Installs the latest Vault
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ① 安装最新的Vault
- en: ② Enables dev-mode for quick start
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ② 启用dev模式以快速启动
- en: ③ Disables Vault Agent, as it’s not required when using the CSI provider
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 禁用Vault Agent，因为在使用CSI提供者时不需要它
- en: ④ Enables the Vault CSI Provider Pod
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 启用Vault CSI提供者Pod
- en: Run the command shown in the following listing to wait until HashiCorp Vault
    deployment is up and running.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下列表中的命令以等待HashiCorp Vault部署启动并运行。
- en: Listing 6.7 Waiting until HashiCorp Vault is ready
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7等待HashiCorp Vault就绪
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Wait until Vault is up.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ① 等待Vault启动。
- en: Creating a secret inside HashiCorp Vault
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在HashiCorp Vault内部创建一个密钥
- en: Now create a key–value secret inside Vault by opening an interactive shell session
    on the Vault Pod.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在Vault Pod上打开交互式shell会话，在Vault内部创建一个键值密钥。
- en: Listing 6.8 Opening an interactive shell
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8打开交互式shell
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Opens an interactive shell against the Vault container
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ① 对Vault容器打开交互式shell
- en: From this point forward, the commands issued will be executed on the Vault container.
    Now create the secret at the secret/pass path with a `my_secret_password` value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，发出的命令将在Vault容器上执行。现在在secret/pass路径下创建一个具有`my_secret_password`值的密钥。
- en: Listing 6.9 Creating a secret
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9创建密钥
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Creates a new secret in the Vault secrets store
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在Vault密钥存储中创建一个新的密钥
- en: Configuring Kubernetes authentication
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Kubernetes认证
- en: The primary authentication method for Vault when using the Vault CSI Provider
    is the service account attached to the Pod. For this reason, you need to enable
    the Kubernetes authentication method and configure it, so it can be used by the
    Vault CSI Driver. Still inside the Vault container, run the commands shown in
    the following listing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Vault CSI提供者时，Vault的主要认证方法是Pod关联的服务账户。因此，您需要启用Kubernetes认证方法并对其进行配置，以便Vault
    CSI驱动程序可以使用它。仍然在Vault容器内部，运行以下列表中的命令。
- en: Listing 6.10 Enabling and configuring the Kubernetes auth method
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.10启用和配置Kubernetes认证方法
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Enables the Kubernetes auth method
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ① 启用Kubernetes认证方法
- en: ② Sets the issuer field
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置发行者字段
- en: ③ Kubernetes writes a token in that location.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ③ Kubernetes在该位置写入令牌。
- en: ④ A reference to the internal network address of the Kubernetes host
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 指向Kubernetes主机内部网络地址的引用
- en: ⑤ Kubernetes writes a certificate in that location.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ Kubernetes在该位置写入证书。
- en: Reading secrets using the Secrets Store CSI Driver requires read permissions
    for all mounts and access to the secret itself. Create a policy named `csi-internal-app`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Secrets Store CSI驱动读取密钥需要所有挂载的读取权限以及访问密钥本身。创建一个名为`csi-internal-app`的策略。
- en: Listing 6.11 Applying the Vault policy
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11应用Vault策略
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Sets the policy name
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置策略名称
- en: ② The data of kv-v2 requires an additional path element of data after the mount
    path.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: kv-v2的数据需要在挂载路径之后添加一个额外的数据路径元素。
- en: ③ Read permission
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 读取权限
- en: Finally, create a Kubernetes authentication role named `my-app` that binds this
    policy with a Kubernetes service account named `app-sa` as in the following listing.
    The role is used in the Vault CSI provider configuration (you’ll see this in the
    following section), and the service account is used to run the Pod.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`my-app`的Kubernetes认证角色，将此策略与名为`app-sa`的Kubernetes服务账户绑定，如以下列表所示。该角色用于Vault
    CSI提供者配置（您将在下一节中看到），服务账户用于运行Pod。
- en: Listing 6.12 Creating the Kubernetes authentication role
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.12创建Kubernetes认证角色
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Sets the role name
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置角色名称
- en: ② app-sa service account linked with the role
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与角色关联的app-sa服务账户
- en: ③ Namespace
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 命名空间
- en: ④ Vault policy
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ④ Vault策略
- en: ⑤ The tokens returned after authentication are valid for 120 minutes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 认证后返回的令牌有效期为120分钟。
- en: Lastly, exit the Vault Pod to come back to the computer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，退出Vault Pod返回到计算机。
- en: Listing 6.13 Exiting the shell session
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.13退出shell会话
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Define a SecretProviderClass resource
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个SecretProviderClass资源
- en: 'The `SecretProviderClass` Kubernetes custom resource describes the configuration
    parameters given to the Secrets Store CSI Driver. The Vault CSI provider requires
    the following parameters:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecretProviderClass` Kubernetes自定义资源描述了提供给Secrets Store CSI驱动的配置参数。Vault CSI提供者需要以下参数：'
- en: The address of the Vault server
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault服务器的地址
- en: The name of the Vault Kubernetes authentication role
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault Kubernetes身份验证角色的名称
- en: The secrets to inject into the Pod
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要注入Pod中的机密
- en: The `SecretProviderClass` definition to connect to Vault installation is shown
    in the following listing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了连接到Vault安装的`SecretProviderClass`定义。
- en: Listing 6.14 vault-spc.yaml
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.14 vault-spc.yaml
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Name of resource
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ① 资源名称
- en: ② Provider to set the configuration
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置配置的提供者
- en: ③ Vault URL
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 保管库URL
- en: ④ Role set in the Kubernetes auth method
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在Kubernetes身份验证方法中设置的角色
- en: ⑤ Symbolic name for that secret. This represents the filename containing the
    secret value within the volume.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 该机密的符号名称。这代表包含机密值的文件名，位于卷内。
- en: ⑥ The path of the secret in Vault
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 机密在Vault中的路径
- en: ⑦ The key name of the secret to inject
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 要注入的机密的关键名称
- en: Apply the vault-secrets `SecretProviderClass` by running the following command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令应用vault-secrets `SecretProviderClass`。
- en: Listing 6.15 Applying the Vault secrets `SecretProviderClass`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.15 应用Vault机密`SecretProviderClass`
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Registers the service provider class
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ① 注册服务提供者类
- en: Deploying a Pod with a secret mounted
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 部署一个挂载机密的Pod
- en: With everything in place, it’s time to create a service account with the name
    `app-sa` (the same name configured in the section “Configuring Kubernetes authentication”
    section) and one Pod creating a volume from the secrets store created by CSI as
    shown in the following listing. The volume configuration now contains a `csi`
    section, where you will set the CSI driver to use—in this case, secrets store
    one (`secrets-store.csi.k8s .io`) as well as the previously created `SecretProviderClass`
    name (`vault-secrets`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，是时候创建一个名为`app-sa`的服务账户（与“配置Kubernetes身份验证”部分中配置的名称相同）以及一个Pod，该Pod使用由CSI创建的机密存储创建卷，如下所示。卷配置现在包含一个`csi`部分，其中你将设置要使用的CSI驱动程序——在这种情况下，是机密存储一个（`secrets-store.csi.k8s.io`）以及之前创建的`SecretProviderClass`名称（`vault-secrets`）。
- en: Listing 6.16 vault-app-pod.yaml
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.16 vault-app-pod.yaml
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Service account set in Kubernetes auth method
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在Kubernetes身份验证方法中设置的服务账户
- en: ② Service account used to run the Pod
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ② 用于运行Pod的服务账户
- en: ③ Volume mount section
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 卷挂载部分
- en: ④ Path where secrets are mounted
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 存储机密的路径
- en: ⑤ Starts csi section
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 开始csi部分
- en: ⑥ Sets the secrets store driver
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 设置机密存储驱动程序
- en: ⑦ References SecretProviderClass
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 参考SecretProviderClass
- en: Figure 6.7 shows the relationship between all these elements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7显示了所有这些元素之间的关系。
- en: '![](../Images/CH06_F07_Sotobueno3.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F07_Sotobueno3.png)'
- en: Figure 6.7 The relationship between the secret provider, Pod, and Vault
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 机密提供者、Pod和Vault之间的关系
- en: Deploy the Pod by running the following command.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令部署Pod。
- en: Listing 6.17 Applying the Pod with CSI volume
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.17 应用带有CSI卷的Pod
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Deploys the service account and the application
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ① 部署服务账户和应用程序
- en: When the Pod is deployed, it will contain a volume with all the Vault secrets
    mounted as files. Then wait until the Pod is running, as shown.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pod部署时，它将包含一个卷，其中挂载了所有Vault机密作为文件。然后等待Pod运行，如下所示。
- en: Listing 6.18 Waiting until the greeting Pod is running
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.18 等待问候Pod运行
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Waiting until the application is ready
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ① 等待应用程序准备就绪
- en: Finally, validate that the secret is mounted in /mnt/secrets-vault, as specified
    in `volumesMount` section, and the file containing the secret is `my-password`,
    as set in the `objectName` field. Run the command shown in the following listing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，验证机密是否已挂载在`volumesMount`部分指定的`/mnt/secrets-vault`，并且包含机密的文件名为`my-password`，如`objectName`字段中设置的那样。运行以下列表中显示的命令。
- en: Listing 6.19 Reading the injected secret
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.19 读取注入的机密
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① The value displayed matches the password value for the secret.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ① 显示的值与机密的密码值匹配。
- en: To recap, you’ve seen how to install CSI and the Secrets Store CSI Driver and
    created a `SecretProviderClass` resource to configure the Secrets Store CSI Driver
    to use HashiCorp Vault as secret storage. You should now understand how the Secrets
    Store CSI Driver works, and you’ve seen that the secret is mounted as a volume
    to disk. But in some cases, you may need to mount these secrets as Kubernetes
    Secrets. Let’s explore how this is done.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，你已经看到了如何安装CSI和Secrets Store CSI驱动程序，并创建了一个`SecretProviderClass`资源来配置Secrets
    Store CSI驱动程序以使用HashiCorp Vault作为机密存储。你现在应该理解Secrets Store CSI驱动程序是如何工作的，并且你已经看到机密被挂载为磁盘上的卷。但在某些情况下，你可能需要将这些机密挂载为Kubernetes机密。让我们来探讨一下这是如何完成的。
- en: 6.2 Synchronizing CSI secrets as Kubernetes Secrets
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 同步CSI机密为Kubernetes机密
- en: Synchronization is especially useful when the application (usually legacy application)
    needs to read secrets either as an environment variable or directly using the
    Kubernetes API server. The Secrets Store CSI Driver mounts the secrets to disk
    using Kubernetes Volumes, but mirroring these secrets to Kubernetes Secrets is
    supported too by using the optional `secretObjects` field in the `SecretProviderClass`
    custom resource (figure 6.8).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 同步在应用程序（通常是遗留应用程序）需要以环境变量或直接使用 Kubernetes API 服务器读取秘密时特别有用。Secrets Store CSI
    驱动使用 Kubernetes Volumes 将秘密挂载到磁盘，但通过在 `SecretProviderClass` 自定义资源（图 6.8）中使用可选的
    `secretObjects` 字段，也支持将这些秘密镜像到 Kubernetes Secrets。
- en: '![](../Images/CH06_F08_Sotobueno3.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F08_Sotobueno3.png)'
- en: Figure 6.8 The Secrets Store CSI Driver mirrors secrets as Kubernetes Secrets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 Secrets Store CSI 驱动将秘密作为 Kubernetes Secrets 镜像。
- en: ImportanT The volume mount is still required and must be defined to sync with
    Kubernetes Secrets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：卷挂载仍然需要，并且必须定义以与 Kubernetes Secrets 同步。
- en: You will expand the previous HashiCorp Vault example by also mapping the secret
    as a Kubernetes Secret.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您将通过将秘密也映射为 Kubernetes Secret 来扩展之前的 HashiCorp Vault 示例。
- en: 6.2.1 Preparing the namespace
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 准备命名空间
- en: Before mapping the secrets as Kubernetes Secrets, you may delete the `SecretProviderClass`
    resource and undeploy the `greeting-demo` Pod to have a clean environment. In
    a terminal window, run the following commands.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在将秘密映射为 Kubernetes Secrets 之前，您可能需要删除 `SecretProviderClass` 资源并卸载 `greeting-demo`
    Pod 以获得一个干净的环境。在终端窗口中，运行以下命令。
- en: Listing 6.20 Cleaning up the environment
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.20 清理环境
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Undeploy the Pod.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ① 卸载 Pod。
- en: ② Delete the SecretProviderClass resource.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ② 删除 SecretProviderClass 资源。
- en: With the example undeployed, you can start the synchronization example.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例卸载后，您可以开始同步示例。
- en: 6.2.2 Defining a SecretProviderClass resource with secretObjects
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 使用 secretObjects 定义 SecretProviderClass 资源
- en: To mount the secrets from secret storage using the Secrets Store CSI Driver,
    modify the `SecretProviderClass` resource, adding the `secretObjects` field. This
    field is used to define how to map a secret from a secrets store to a Kubernetes
    Secret.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Secrets Store CSI 驱动挂载秘密存储中的秘密，修改 `SecretProviderClass` 资源，添加 `secretObjects`
    字段。此字段用于定义如何将秘密存储中的秘密映射到 Kubernetes Secret。
- en: 'In the following snippet, you will see how the value of a secret placed at
    the secrets store with the name `foo` is mapped into a key named `bar` of an `opaque`
    Kubernetes Secret with the name `foosecret`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下片段中，您将看到如何将名为 `foo` 的秘密存储中的秘密值映射到名为 `bar` 的键，该键属于名为 `foosecret` 的 `opaque`
    Kubernetes Secret：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① The key name used to look up a secret value in the secret resource
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ① 用于在秘密资源中查找秘密值的密钥名称
- en: ② The name of the mounted content to sync
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ② 要同步的挂载内容名称
- en: ③ The name of the Kubernetes secret object
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ③ Kubernetes 秘密对象名称
- en: ④ The type of secret
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 秘密类型
- en: Figure 6.9 shows the relationship between the secret storage, the `SercretProviderClass`
    definition, and the Kubernetes Secret.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 显示了秘密存储、`SercretProviderClass` 定义和 Kubernetes Secret 之间的关系。
- en: '![](../Images/CH06_F09_Sotobueno3.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F09_Sotobueno3.png)'
- en: Figure 6.9 Secret store, SecretProviderClass, and Kubernetes Secrets
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 秘密存储、SecretProviderClass 和 Kubernetes Secrets
- en: About supported secret types
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 关于支持的秘密类型
- en: 'At the time of writing this book the following secret types are supported:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，以下秘密类型受到支持：
- en: Opaque
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opaque
- en: kubernetes.io/basic-auth
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubernetes.io/basic-auth
- en: bootstrap.kubernetes.io/token
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bootstrap.kubernetes.io/token
- en: kubernetes.io/dockerconfigjson
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubernetes.io/dockerconfigjson
- en: kubernetes.io/dockercfg
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubernetes.io/dockercfg
- en: kubernetes.io/ssh-auth
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubernetes.io/ssh-auth
- en: kubernetes.io/service-account-token
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubernetes.io/service-account-token
- en: kubernetes.io/tls
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubernetes.io/tls
- en: Open the `vault-spc.yaml` created previously, and add the `secretObjects` section
    to make the data stored in the HashiCorp Vault a Kubernetes Secret.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 打开之前创建的 `vault-spc.yaml` 文件，并添加 `secretObjects` 节来使存储在 HashiCorp Vault 中的数据成为
    Kubernetes Secret。
- en: Listing 6.21 vault-spc.yaml
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.21 vault-spc.yaml
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① Defines the synchronization between secrets and Kubernetes Secrets
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义秘密与 Kubernetes Secrets 之间的同步
- en: ② objectName is defined in the parameters section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在参数部分定义 objectName。
- en: ③ The name of the Kubernetes Secret
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ③ Kubernetes 秘密名称
- en: ④ Defines the creation of the volume with the secret as a file
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 定义使用秘密作为文件的卷创建
- en: Apply the following resource.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用以下资源。
- en: Listing 6.22 Applying the `SecretProviderClass`
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.22 应用 `SecretProviderClass`
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Deploys the SecretProviderClass
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ① 部署 SecretProviderClass
- en: With `SecretProviderClass` deployed, it’s time to deploy the Pod.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了 `SecretProviderClass` 后，是时候部署 Pod 了。
- en: Deploy a Pod with a secret mounted and secret objects
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 部署一个挂载了机密和机密对象的 Pod
- en: The secrets will only sync once you start a Pod mounting the secrets. List the
    current secrets in the default namespace before deploying the Pod.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在启动一个挂载了机密的 Pod 后，机密才会同步。在部署 Pod 之前，先列出默认命名空间中的当前机密。
- en: Listing 6.23 Listing secrets
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.23 列出机密
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① Listing secrets
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ① 列出机密
- en: With everything in place, it’s time to redeploy the Pod defined in the previous
    section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，是时候重新部署上一节定义的 Pod 了。
- en: Listing 6.24 Applying the Pod with a CSI volume
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.24 使用 CSI 卷应用 Pod
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① Deploying a Pod using the CSI driver
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 CSI 驱动程序部署 Pod
- en: Wait until the Pod is running.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 Pod 运行。
- en: Listing 6.25 Waiting until the greeting Pod is running
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.25 等待问候 Pod 运行
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① Waiting until it is deployed
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ① 等待 Pod 部署完成
- en: List the secret after the Pod has been deployed to confirm the secret is now
    created.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 部署后列出机密以确认机密现在已创建。
- en: Listing 6.26 Listing secrets
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.26 列出机密
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① A secret is created with the name set in the secretName field.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 secretName 字段设置的名称创建了一个机密。
- en: Describe the secret to validate it is created correctly.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 描述机密以验证其是否正确创建。
- en: Listing 6.27 Describing the secret
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.27 描述机密
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① The name set in the secretName field
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在 secretName 字段中设置的名称
- en: ② The label to set the secret is managed by the Secrets Store CSI
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置机密的标签由 Secrets Store CSI 管理
- en: ③ The type, as defined in the type field
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在 type 字段中定义的类型
- en: ④ The secret key name, as defined in the key field
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如 key 字段中定义的机密密钥名称
- en: The equivalent `kubectl` command to create a secret like the one created by
    Secrets Store CSI would be
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 创建与 Secrets Store CSI 创建的机密等效的 `kubectl` 命令
- en: '[PRE31]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, delete the Pod to validate it is automatically deleted, since no Pods
    are consuming the secret.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，删除 Pod 以验证它是否会被自动删除，因为没有任何 Pod 消耗机密。
- en: Listing 6.28 Deleting the Pod
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.28 删除 Pod
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① Delete the Pod.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ① 删除 Pod。
- en: List the secrets again, and you’ll see the `my-secret` secret is removed, as
    no Pod is using it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 再次列出机密，你会看到 `my-secret` 机密已被删除，因为没有 Pod 使用它。
- en: Listing 6.29 Listing secrets
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.29 列出机密
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'TIP Once the secret is created, you may set it as an environment variable with
    any Kubernetes Secret:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：一旦创建了机密，你可以将其设置为任何 Kubernetes Secret 的环境变量：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remember you are creating Kubernetes Secrets, and as such, they need to be managed
    as shown in chapters 3 and 4 (i.e., encrypting them in the Git repository and
    enabling KMS to store them in Kubernetes encrypted rather than encoded). So far,
    you’ve seen how to mount secrets from secrets stores as Kubernetes volumes and
    Kubernetes Secrets using the Secrets Store CSI Driver. But what happens when the
    secret is updated in the secrets store? The Secrets Store CSI Driver supports
    secret autorotation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你正在创建 Kubernetes Secrets，因此它们需要像第 3 章和第 4 章中所示那样进行管理（即在 Git 仓库中加密它们，并启用 KMS
    以在 Kubernetes 中加密存储而不是编码）。到目前为止，你已经看到了如何使用 Secrets Store CSI 驱动程序将机密从机密存储库挂载为
    Kubernetes 卷和 Kubernetes Secrets。但是，当机密在机密存储库中更新时会发生什么？Secrets Store CSI 驱动程序支持机密自动轮换。
- en: 6.3 Autorotating secrets to improve security posture
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 通过自动轮换机密来提高安全态势
- en: Imagine you receive an attack to your system, and some of your secret data is
    compromised; one of the first things you should do is to regenerate secrets to
    new values (rotation of the secrets). The Secrets Store CSI Driver can detect
    an update of a secret in the external secrets store after the Pod is running and
    populate this change in the corresponding volume content and into the Kubernetes
    Secrets object if they are used as shown in figure 6.10.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你收到针对系统的攻击，并且一些机密数据被泄露；你应该做的第一件事之一是重新生成机密到新的值（机密的轮换）。Secrets Store CSI 驱动程序可以在
    Pod 运行后检测外部机密存储库中机密的更新，并将此更改填充到相应的卷内容和 Kubernetes Secrets 对象中，如果它们被使用，如图 6.10
    所示。
- en: '![](../Images/CH06_F10_Sotobueno3.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F10_Sotobueno3.png)'
- en: Figure 6.10 The Secrets Store CSI Driver mirrors secrets as Kubernetes Secrets
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 Secrets Store CSI 驱动程序将机密镜像为 Kubernetes Secrets
- en: '*Autorotating secrets* is the process of automatically changing secrets data
    periodically. There are two big wins from changing secret data: The first is that
    it makes it more difficult for an attacker to get a value and able to decrypt
    it with a possible stolen key. The second is that if there is a secret data leak,
    you’ll need to rotate the secrets as quickly as possible to avoid major problems.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动轮换密钥* 是指定期自动更改密钥数据的过程。从更改密钥数据中可以获得两个重要优势：第一个优势是，这使得攻击者更难获取值，并且使用可能被窃取的密钥来解密它变得更加困难。第二个优势是，如果发生密钥数据泄露，您需要尽可能快地轮换密钥，以避免出现重大问题。'
- en: It’s important to keep in mind the Secrets Store CSI Driver only updates the
    location the secret is stored (volume or Kubernetes Secret), but the application
    consuming these secrets needs to implement some logic to react to these changes
    and read the new secret value. For example, when mounting the secret as a volume,
    the application will need to watch for changes. If the secret is injected as an
    environment variable, then the Pod needs to be restarted to get the latest secret
    as an environment variable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Secrets Store CSI 驱动程序仅更新密钥存储位置（卷或 Kubernetes 密钥），但消耗这些密钥的应用程序需要实现一些逻辑来对这些更改做出反应并读取新的密钥值。例如，当将密钥作为卷挂载时，应用程序将需要监视更改。如果密钥作为环境变量注入，那么
    Pod 需要重新启动以获取最新的密钥作为环境变量。
- en: TIP Projects like Reloader ([https://github.com/stakater/Reloader](https://github.com/stakater/Reloader))
    help you push out rolling upgrades on Pods automatically when a change on the
    associated ConfigMap or Secret is detected.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：像 Reloader ([https://github.com/stakater/Reloader](https://github.com/stakater/Reloader))
    这样的项目在检测到关联的 ConfigMap 或 Secret 发生更改时，会自动在 Pod 上推送滚动升级。
- en: 6.3.1 Preparing the namespace
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 准备命名空间
- en: You may undeploy the `greeting-demo` Pod (although it shouldn’t be necessary)
    before using the autorotation feature to have a brand new Pod, for example. If
    you have not deleted the Pod previously, run the following command in a terminal
    window.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用自动轮换功能之前，您可能需要卸载 `greeting-demo` Pod（尽管这不是必需的），以便有一个全新的 Pod，例如。如果您之前没有删除
    Pod，请在终端窗口中运行以下命令。
- en: Listing 6.30 Cleaning up the environment
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.30 清理环境
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① Undeploy the Pod.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ① 卸载 Pod。
- en: The autorotation feature is disabled by default when the Secrets Store CSI Driver
    is installed. To enable this feature, the Secrets Store CSI Driver Pod should
    start with the `--enable-secret-rotation` flag set to `true` and the rotation
    poll interval (i.e., the frequency of checking if a secret has changed) set using
    the `rotation-poll-interval` flag. To enable autorotation, stop the previous deployment
    by running the following command in a terminal.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Secrets Store CSI 驱动程序安装时，自动轮换功能默认是禁用的。要启用此功能，Secrets Store CSI 驱动程序 Pod 应该以
    `--enable-secret-rotation` 标志设置为 `true` 并使用 `rotation-poll-interval` 标志设置轮换轮询间隔（即检查密钥是否已更改的频率）的方式启动。要启用自动轮换，请在终端中运行以下命令停止之前的部署。
- en: Listing 6.31 Undeploying the Secrets Store CSI Driver
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.31 卸载 Secrets Store CSI 驱动程序
- en: '[PRE36]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next modify the deployment file of the Secrets Store CSI Driver to configure
    `--enable-secret-rotation` and `rotation-poll-interval` flags. In this example,
    set the `rotation-poll-interval` time to `1 minute`, which means every minute,
    the driver will query the secrets store, checking if the value has been changed
    or not.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来修改 Secrets Store CSI 驱动程序的部署文件，以配置 `--enable-secret-rotation` 和 `rotation-poll-interval`
    标志。在这个例子中，将 `rotation-poll-interval` 时间设置为 `1 分钟`，这意味着每分钟，驱动程序将查询密钥存储，检查值是否已更改。
- en: Listing 6.32 install-csi-polling.yaml
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.32 install-csi-polling.yaml
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① DaemonSet deploys the driver in all Kubernetes nodes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ① DaemonSet 在所有 Kubernetes 节点上部署驱动程序。
- en: ② Enables secret rotation
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ② 启用密钥轮换
- en: ③ Sets polling time to 1 minute
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置轮询时间为 1 分钟
- en: Finally, deploy the Secrets Store CSI Driver with the previous modification.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用之前的修改部署 Secrets Store CSI 驱动程序。
- en: Listing 6.33 Deploying the Secrets Store CSI Driver with autorotation enabled
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.33 启用自动轮换的 Secrets Store CSI 驱动程序部署
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① Installing Secret Storage CSI with polling enabled
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ① 启用轮询功能的 Secret 存储 CSI 安装
- en: Now wait until the Pod is running.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在等待 Pod 运行。
- en: Listing 6.34 Waiting until the driver Pod is running
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.34 等待驱动程序 Pod 运行
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Waiting until the Pod is deployed
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ① 等待 Pod 部署完成
- en: 6.3.2 Deploying the Pod with a secret mounted
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 部署挂载密钥的 Pod
- en: Now redeploy the Pod defined in the previous section to inject the secret rotation
    example.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新部署上一节中定义的 Pod，以注入密钥轮换示例。
- en: Listing 6.35 Applying the Pod with CSI volume
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.35 应用带有 CSI 卷的 Pod
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① Deploying the Pod to the default namespace
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 Pod 部署到默认命名空间
- en: Wait until the Pod is running.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 Pod 运行。
- en: Listing 6.36 Waiting until the greeting Pod is running
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.36 等待问候 Pod 运行
- en: '[PRE41]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Waiting until the Pod is ready
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ① 等待 Pod 准备就绪。
- en: Finally, validate that the secret is mounted in `/mnt/secrets-vault`, as specified
    in the `volumesMount` section, and the file containing the secret is `my-password`,
    as set in the `objectName` field. Run the command shown in the following listing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，验证秘密是否已挂载在 `/mnt/secrets-vault`，如 `volumesMount` 部分所述，并且包含秘密的文件是 `my-password`，如
    `objectName` 字段所设置。运行以下列表中所示的命令。
- en: Listing 6.37 Reading the injected secret
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.37 读取注入的秘密
- en: '[PRE42]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ① The current value of the secret
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ① 打印秘密的当前值。
- en: 6.3.3 Updating the secret
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 更新秘密
- en: Now update the key with a new secret value inside Vault by opening an interactive
    shell session on the Vault Pod.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在 Vault Pod 上打开交互式 shell 会话，在 Vault 中更新密钥的新秘密值。
- en: Listing 6.38 Opening an interactive shell
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.38 打开交互式 shell
- en: '[PRE43]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① Starting an interactive shell against the Vault container
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ① 对 Vault 容器启动交互式 shell
- en: From this point forward, the commands issued will be executed on the Vault container.
    Update the secret at the secret/pass path with the `my_new_secret_password` value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，发出的命令将在 Vault 容器上执行。使用 `my_new_secret_password` 值更新秘密/pass 路径上的秘密。
- en: Listing 6.39 Updating the secret
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.39 更新秘密
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① The value is updated.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ① 值已更新。
- en: ② The version is incremented by 1.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ② 版本增加 1。
- en: Type `exit` to quit the `kubectl` `exec` command. Wait at least one minute until
    the Secrets Store CSI Driver polls the secret, detects the change, and populates
    it to the Pod, and then run the command again to print the secret value.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `exit` 以退出 `kubectl` `exec` 命令。至少等待一分钟，直到 Secrets Store CSI 驱动程序轮询秘密，检测到更改，并将其填充到
    Pod 中，然后再次运行命令以打印秘密值。
- en: Listing 6.40 Read the injected secret
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.40 读取注入的秘密
- en: '[PRE45]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① The new version of the secret is printed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ① 打印新的秘密版本。
- en: Type `exit` to quit the `kubectl` `exec` command. Notice that the secret value
    has been injected without having to restart the Pod.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `exit` 以退出 `kubectl` `exec` 命令。注意，秘密值已注入，无需重新启动 Pod。
- en: Now you should understand how the Secrets Store CSI Driver works; however, no
    cloud secrets stores were used in the example. We’ll expand this example to cover
    store secrets in a public cloud secret storage in the following section.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该理解 Secrets Store CSI 驱动程序的工作方式；然而，示例中没有使用任何云秘密存储。在下一节中，我们将扩展此示例，以涵盖在公共云秘密存储中存储秘密。
- en: 6.4 Consuming secrets from cloud secrets stores
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 从云秘密存储中消费秘密
- en: So far, you’ve used HashiCorp Vault as secret storage in this chapter and chapter
    5\. But if you’re using a public cloud as a platform to deploy the Kubernetes
    cluster, you might want to use the secret storage service they provide in their
    infrastructure. For example, if you were using Azure Cloud Services, you might
    want to use Azure Key Vault as a secrets store. In this section, you’ll see how
    to consume secrets from a cloud secret store using the Secrets Store CSI Driver.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你在这个章节和第 5 章中使用了 HashiCorp Vault 作为秘密存储。但是，如果你使用公共云作为部署 Kubernetes 集群的平台，你可能希望使用他们在基础设施中提供的秘密存储服务。例如，如果你使用
    Azure 云服务，你可能希望使用 Azure Key Vault 作为秘密存储。在本节中，你将了解如何使用 Secrets Store CSI 驱动程序从云秘密存储中消费秘密。
- en: The Secret Storage CSI Driver supports AWS Secrets Manager and the AWS Systems
    Manager Parameter Store; Azure Key Vault; and Google Secret Manager. You’ll implement
    the same example as the previous section but consume the secrets from public cloud
    secrets stores instead of HashiCorp Vault. You’ll start by integrating the secrets
    store CSI driver to Azure Key Vault.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Secret Storage CSI 驱动程序支持 AWS Secrets Manager 和 AWS 系统管理器参数存储；Azure Key Vault；以及
    Google Secret Manager。你将实现与上一节相同的示例，但将从公共云秘密存储中获取秘密，而不是从 HashiCorp Vault 获取。你将首先将秘密存储
    CSI 驱动程序集成到 Azure Key Vault。
- en: 'ImportanT The process of integrating a secret store and the Secrets Store CSI
    is the same in all cases:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 无论是哪种情况，集成秘密存储和 Secrets Store CSI 的过程都是相同的：
- en: Install and configure the secrets store.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装和配置秘密存储。
- en: Install the Secrets Store CSI Provider according to the secrets store used (e.g.,
    Vault, AWS, or Azure).
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据所使用的秘密存储安装 Secrets Store CSI 提供程序（例如，Vault、AWS 或 Azure）。
- en: Configure the `SecretProviderClass` with the secrets store configuration parameters.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用秘密存储配置参数配置 `SecretProviderClass`。
- en: The biggest difference between the two is the installation and configuration
    of the secrets store. In this section, we’ll show you how to integrate cloud secrets
    stores with CSI, but we’re assuming you have an account with the cloud providers
    to deploy the secrets store and a basic knowledge of how they work.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间最大的区别是秘密存储库的安装和配置。在本节中，我们将向您展示如何将云秘密存储库与 CSI 集成，但我们假设您有云提供商的账户来部署秘密存储库，并且对它们的工作方式有基本的了解。
- en: 6.4.1 Azure Key Vault
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 Azure 密钥保管库
- en: Azure Key Vault is an Azure cloud service that provides a secure store for secrets
    (e.g., keys, passwords, and certificates). To run Azure Key Vaults you need an
    Azure account with at least the free services subscription, as Azure Key Vault
    cannot run outside of the Azure Cloud.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 密钥保管库是 Azure 云服务，提供秘密（例如，密钥、密码和证书）的安全存储。要运行 Azure 密钥保管库，您需要一个至少具有免费服务订阅的
    Azure 账户，因为 Azure 密钥保管库不能在 Azure 云之外运行。
- en: Installing and Configuring Azure Key Vault
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和配置 Azure 密钥保管库
- en: To install Azure Key Vault, log in to your Azure subscription to create a service
    principal with policies to access the key vault.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Azure 密钥保管库，请登录到您的 Azure 订阅以创建一个具有访问密钥保管库策略的服务主体。
- en: Listing 6.41 Azure login
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.41 Azure 登录
- en: '[PRE46]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ① Log in to Azure.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ① 登录到 Azure。
- en: Once logged in to Azure, you can create a service principal executing the command
    shown in the following listing.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到 Azure 后，您可以执行以下列表中的命令来创建服务主体。
- en: Listing 6.42 Creating an Azure service principal
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.42 创建 Azure 服务主体
- en: '[PRE47]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ① Creates a service principal with the name alex
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建名为 alex 的服务主体
- en: 'The command returns a JSON document with some sensitive parameters you’ll need
    to configure the CSI driver later on:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 命令返回一个 JSON 文档，其中包含一些您稍后配置 CSI 驱动程序所需的敏感参数：
- en: '[PRE48]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ① This is the client ID required by the CSI driver.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这是 CSI 驱动程序所需的客户端 ID。
- en: ② This is the client secret required by the CSI driver.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这是 CSI 驱动程序所需客户端密钥。
- en: TIP Creating a specific service principal for Azure Key Vault isn’t mandatory,
    and you could instead use the default service principal.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为 Azure 密钥保管库创建特定的服务主体不是强制性的，您也可以使用默认服务主体。
- en: Next you’ll need to create the Azure Key Vault through the Azure portal. Visit
    [https://portal.azure.com/](https://portal.azure.com/), and log in with your account.
    In the portal, go to the top search bar, type `Key Vault`, and click the Azure
    Key Vault resource, as shown in figure 6.11.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要通过 Azure 门户创建 Azure 密钥保管库。访问 [https://portal.azure.com/](https://portal.azure.com/)，并使用您的账户登录。在门户中，转到顶部搜索栏，输入“密钥保管库”，然后点击如图
    6.11 所示的 Azure 密钥保管库资源。
- en: '![](../Images/CH06_F11_Sotobueno3.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F11_Sotobueno3.png)'
- en: Figure 6.11 Azure portal
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 Azure 门户
- en: In the Key Vaults section, click the Create Key Vault button to start creating
    an Azure Key Vault instance (figure 6.12).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在“密钥保管库”部分，点击“创建密钥保管库”按钮以开始创建 Azure 密钥保管库实例（图 6.12）。
- en: '![](../Images/CH06_F12_Sotobueno3.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F12_Sotobueno3.png)'
- en: Figure 6.12 Azure Key Vault portal; cloud providers tweak their web interfaces
    on a ongoing basis.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 Azure 密钥保管库门户；云提供商持续调整他们的网络界面。
- en: Fill the Create Key Vault wizard with the parameters shown in figure 6.13.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图 6.13 中显示的参数填写创建密钥保管库向导。
- en: '![](../Images/CH06_F13_Sotobueno3.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F13_Sotobueno3.png)'
- en: Figure 6.13 Creating the Azure Key Vault
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 创建 Azure 密钥保管库
- en: The `Key` `vault` `name` in this example is `alexvault`, but it could be any
    other name, `region`, and `pricing tier`. Click Review + Create, review the values,
    and click Create.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`密钥` `保管库` `名称` 为 `alexvault`，但可以是任何其他名称、`区域` 和 `定价层`。点击“审查 + 创建”，审查值，然后点击“创建”。
- en: The overview of the created key vault should now be shown (figure 6.14). At
    this point, click the JSON View link, which will show the same content, but in
    JSON format, and the tenant ID of the key vault.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该显示创建的密钥保管库概述（图 6.14）。在此阶段，点击 JSON 视图链接，它将显示相同的内容，但以 JSON 格式显示，以及密钥保管库的租户
    ID。
- en: '![](../Images/CH06_F14_Sotobueno3.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F14_Sotobueno3.png)'
- en: Figure 6.14 Overview of Azure Key Vault
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 Azure 密钥保管库概述
- en: You need to create the secret to be injected into the Pod. Click the Secrets
    section in the left menu, and click the Generate/Import button in the top-left
    menu, as shown in figure 6.15.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建要注入到 Pod 中的秘密。点击左侧菜单中的“秘密”部分，然后点击如图 6.15 所示的左上角菜单中的“生成/导入”按钮。
- en: '![](../Images/CH06_F15_Sotobueno3.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F15_Sotobueno3.png)'
- en: Figure 6.15 Creating the Azure Key Vault secret
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 创建 Azure 密钥保管库秘密
- en: Fill the `name` field with the `password` value and the `value` field with `my_password`;
    then click Create, as shown in figure 6.16.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `name` 字段中填写 `password` 值，在 `value` 字段中填写 `my_password`；然后点击创建，如图 6.16 所示。
- en: '![](../Images/CH06_F16_Sotobueno3.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F16_Sotobueno3.png)'
- en: Figure 6.16 Creating the Azure Key Vault secret
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 创建 Azure Key Vault 秘密
- en: NOTE A secret can be created using the `az` CLI tool by running `az keyvault
    secret` `set` `--vault-name` `"alexvault"` `--name` `"password"` `--value "my_
    password"`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 可以通过运行 `az keyvault secret set --vault-name "alexvault" --name "password"
    --value "my_password"` 命令使用 `az` CLI 工具创建一个秘密。
- en: Finally, you need to assign the permissions from the previously created service
    principal to the key vault you just created. Return to the terminal window, and
    execute the following commands.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要将之前创建的服务主体权限分配给您刚刚创建的密钥库。返回终端窗口，并执行以下命令。
- en: Listing 6.43 Assigning permissions
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.43 分配权限
- en: '[PRE49]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ① $KEYVAULT_NAME is the name assigned to the key vault. In this case, it is
    alexvault.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ① `KEYVAULT_NAME` 是分配给密钥库的名称。在本例中，它是 alexvault。
- en: ② $AZURE_CLIENT_ID is the appId field of the service principal. In this case,
    it is 7d3498f8-633e-4c58-bbaa5-1b2a015017a7.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ② `$AZURE_CLIENT_ID` 是服务主体的 `appId` 字段。在本例中，它是 7d3498f8-633e-4c58-bbaa5-1b2a015017a7。
- en: You are now ready to return to Kubernetes! In the next section, you will learn
    how to configure it for consuming secrets from Azure Key Vault.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好返回 Kubernetes！在下一节中，您将学习如何配置它以从 Azure Key Vault 消费秘密。
- en: Azure Key Vault CSI Driver
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Key Vault CSI 驱动程序
- en: First install and configure the Azure Key Vault CSI Driver. You’ll need to create
    a new Kubernetes namespace to deploy the Azure example.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装并配置 Azure Key Vault CSI 驱动程序。您需要创建一个新的 Kubernetes 命名空间来部署 Azure 示例。
- en: Listing 6.44 Creating an Azure namespace
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.44 创建 Azure 命名空间
- en: '[PRE50]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ① Create a namespace.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个命名空间。
- en: ② Switch to the created namespace.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ② 切换到创建的命名空间。
- en: Install the Azure Secrets Store CSI Provider to inject secrets from Azure Key
    Vault into Pods using the CSI interface.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Azure Secrets Store CSI 提供程序，以使用 CSI 接口将 Azure Key Vault 中的秘密注入到 Pod 中。
- en: Listing 6.45 Installing the Azure Secrets Store CSI provider
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.45 安装 Azure Secrets Store CSI 提供程序
- en: '[PRE51]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: TIP For Windows Nodes, you need to apply the `provider-azure-installer-windows.yaml`
    file.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 对于 Windows 节点，您需要应用 `provider-azure-installer-windows.yaml` 文件。
- en: Check that the provider is running by executing the following command.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令来检查提供程序是否正在运行。
- en: Listing 6.46 Checking the Azure Secrets Store CSI provider
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.46 检查 Azure Secrets Store CSI 提供程序
- en: '[PRE52]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ① List Pods.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ① 列出 Pod。
- en: WarninG For AKS clusters, the provider needs to be installed in the `kube-system`
    namespace to establish connection with the Kube API Server.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Warning 对于 AKS 集群，提供程序需要安装到 `kube-system` 命名空间，以与 Kube API 服务器建立连接。
- en: Then you will set the service principal credentials as Kubernetes Secrets accessible
    by the Azure Secrets Store CSI Driver. The driver uses this secret to log in to
    the remote Azure Key Vault. The secret must contain `clientid` and `clientsecret`
    keys set to the service principal `app ID` and `password` fields, respectively.
    Figure 6.17 shows an overview of the authentication steps.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将设置服务主体凭据作为 Kubernetes Secrets，使其可通过 Azure Secrets Store CSI 驱动程序访问。驱动程序使用此秘密登录到远程
    Azure Key Vault。该秘密必须包含 `clientid` 和 `clientsecret` 键，分别设置为服务主体的 `app ID` 和 `password`
    字段。图 6.17 展示了认证步骤的概述。
- en: '![](../Images/CH06_F17_Sotobueno3.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F17_Sotobueno3.png)'
- en: Figure 6.17 The authentication process of the Azure Secrets Store CSI provider
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 Azure Secrets Store CSI 提供程序的认证过程
- en: The following listing shows the creation of a Kubernetes Secret with the Azure
    credentials.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用 Azure 凭据创建 Kubernetes 秘密的示例。
- en: Listing 6.47 Creating a Kubernetes Secret
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.47 创建 Kubernetes 秘密
- en: '[PRE53]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ① $AZURE_CLIENT_ID is the appId field of service principal. In this case, it
    is 7d3498f8-633e-4c58-bbaa5-1b2a015017a7\. $AZURE_CLIENT_SECRET is the password
    field of service principle. In this case, it is 2CAT7NvT9OzrLneTdi3..rYnU.M4_qGIMP.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ① `$AZURE_CLIENT_ID` 是服务主体的 `appId` 字段。在本例中，它是 7d3498f8-633e-4c58-bbaa5-1b2a015017a7。`$AZURE_CLIENT_SECRET`
    是服务主体的 `password` 字段。在本例中，它是 2CAT7NvT9OzrLneTdi3..rYnU.M4_qGIMP。
- en: ImportanT Secrets must be created in the same namespace as the application Pod.
    Moreover, as with any Kubernetes Secret, it needs to be managed as discussed in
    chapters 3 and 4.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Important 秘密必须与应用程序 Pod 在同一命名空间中创建。此外，与任何 Kubernetes 秘密一样，它需要按照第 3 章和第 4 章中讨论的方式进行管理。
- en: Moreover, you can label the secrets (like the one created just above) used in
    the `nodePublishSecretRef` section to limit the amount of memory used by the CSI
    driver.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以标记在 `nodePublishSecretRef` 部分中使用的秘密（如刚刚创建的那个），以限制CSI驱动程序使用的内存量。
- en: Listing 6.48 Creating a Kubernetes Secret
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.48 创建Kubernetes秘密
- en: '[PRE54]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ① To limit the amount of memory consumed for the CSI driver, you may label the
    secret.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ① 要限制CSI驱动程序消耗的内存量，您可以标记秘密。
- en: Before creating a Pod with the secret, the last step is configuring the `SecretProviderClass`
    with the Azure Key Vault name and the Azure Key Vault tenant ID.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建包含秘密的Pod之前，最后一步是使用Azure Key Vault名称和Azure Key Vault租户ID配置 `SecretProviderClass`。
- en: Listing 6.49 azure-spc.yaml
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.49 azure-spc.yaml
- en: '[PRE55]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ① Name of the resource
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ① 资源名称
- en: ② Provider to set the configuration
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置配置的提供者
- en: ③ Azure Key Vault name
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ③ Azure Key Vault名称
- en: ④ Key name of the secret to inject
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 要注入的秘密的密钥名称
- en: ⑤ Azure Key Vault tenant ID
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ Azure Key Vault租户ID
- en: 'Apply the `azure-manningSecretProviderClass` by running the following command:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令应用 `azure-manningSecretProviderClass`：
- en: Listing 6.50 Applying the `azure-manningSecretProviderClass`
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.50 应用 `azure-manningSecretProviderClass`
- en: '[PRE56]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ① Registering the Azure SercretProviderClass
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ① 注册Azure SercretProviderClass
- en: Deploying a Pod with a secret mounted
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 部署挂载秘密的Pod
- en: The configuration is similar to what you saw in the HashiCorp Vault example;
    you have the `csi` section, where you set the CSI driver to `secrets-store.csi.k8s.io`,
    as well as the `SecretProviderClass` name just created (`azure-manning`). But
    in this case, set the `nodePublishSecretRef` pointing out the previously created
    Kubernetes secret with the Azure service principal credentials (`secrets-store-creds`)
    to access the Azure Key Vault.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 配置类似于您在HashiCorp Vault示例中看到的配置；您有 `csi` 部分，其中将CSI驱动程序设置为 `secrets-store.csi.k8s.io`，以及刚刚创建的
    `SecretProviderClass` 名称（`azure-manning`）。但在此情况下，设置 `nodePublishSecretRef` 指向之前创建的包含Azure服务主体凭据的Kubernetes秘密（`secrets-store-creds`），以访问Azure
    Key Vault。
- en: Listing 6.51 azure-app-pod.yaml
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.51 azure-app-pod.yaml
- en: '[PRE57]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ① Volume mount section
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ① 卷挂载部分
- en: ② Path where secrets are mounted
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ② 秘密挂载的路径
- en: ③ References the SecretProviderClass
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 引用SecretProviderClass
- en: ④ Required when using the service principal as a secret
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用服务主体作为秘密时需要。
- en: Deploy the Pod by running the following command.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令部署Pod。
- en: Listing 6.52 Applying the Pod with a CSI volume
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.52 应用带有CSI卷的Pod
- en: '[PRE58]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ① Deploy a Pod configured to use the Azure Secrets Store CSI provider.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ① 部署配置为使用Azure Secrets Store CSI提供者的Pod。
- en: Now wait until the Pod is running.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在等待Pod运行。
- en: Listing 6.53 Waiting until the greeting Pod is running
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.53 等待问候Pod运行
- en: '[PRE59]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ① Wait until the Pod is ready.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ① 等待Pod就绪。
- en: In the following snippet, a complete `SecretProviderClass` object is provided,
    so you see all possible options.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下片段中，提供了一个完整的 `SecretProviderClass` 对象，因此您可以看到所有可能的选项。
- en: '[PRE60]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ① Set to true to use the aad-pod-identity to access the key vault (false).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置为true以使用aad-pod-identity访问密钥保管库（false）。
- en: ② Specify the access mode to enable the use of User-assigned managed identity
    (false).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ② 指定访问模式以启用用户分配的托管身份的使用（false）。
- en: ③ The user assigned the identity ID is required for User-assigned Managed Identity
    mode.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在User-assigned Managed Identity模式下，需要分配给身份ID的用户。
- en: ④ The name of the Azure cloud based on Azure Go SDK (AzurePublicCloud)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 根据Azure Go SDK指定的Azure云名称（AzurePublicCloud）
- en: ⑤ Path to the file to be used while populating the Azure environment
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 填充Azure环境时使用的文件路径
- en: ⑥ Array of secrets to inject
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 要注入的秘密数组
- en: ⑦ Specify the filename of the object when written to disk (objectName value).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在写入磁盘时指定对象的文件名（objectName 值）。
- en: '⑧ Type of object: secret, key, or cert'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 对象类型：秘密、密钥或证书
- en: ⑨ Version of the object (latest)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 对象版本（最新版）
- en: ⑩ The format object; supported types are pem and pfx
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 格式对象；支持类型为 pem 和 pfx
- en: ⑪ The encoding of the secret object; supported types are UTF-8, HEX, and BASE64
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 对秘密对象的编码；支持类型为 UTF-8、HEX 和 BASE64
- en: Providing the identity for accessing Key Vault
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 提供访问密钥保管库的标识
- en: 'In this section, we’ve given the identity access to Key Vault using a service
    principal. At the time of writing, this is the only way to connect to Azure Key
    Vault from a non-Azure environment. But if you are in an Azure environment (i.e.,
    AKS), then these other authentication modes are supported:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已通过服务主体授予身份对密钥保管库的访问权限。在编写本文时，这是从非Azure环境连接到Azure Key Vault的唯一方式。但如果您处于Azure环境中（即AKS），则支持以下其他身份验证模式：
- en: AAD pod identity
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AAD Pod身份
- en: User-assigned managed identity
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户分配的托管身份
- en: System-assigned managed identity
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统分配的托管身份
- en: You know how to use Secrets Store CSI Driver to inject secrets stored in Azure
    Key Vault. As mentioned earlier, Secrets Store CSI Driver supports providers other
    than Azure. In the following section, you will review the same example—this time
    storing the secret in GCP Secret Manager.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道如何使用Secrets Store CSI驱动程序注入存储在Azure Key Vault中的秘密。如前所述，Secrets Store CSI驱动程序支持除Azure之外的其他提供程序。在下一节中，您将回顾相同的示例——这次将秘密存储在GCP秘密管理器中。
- en: 6.4.2 GCP Secret Manager
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 GCP秘密管理器
- en: GCP Secret Manager is a Google cloud service that provides a secure store for
    secrets (e.g., keys, passwords, and certificates). To run GCP Secret Manager,
    you need a GCP account with Secret Manager installed, as it cannot run outside
    of the Google cloud.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: GCP秘密管理器是Google云服务，它为秘密（例如，密钥、密码和证书）提供了一个安全的存储库。要运行GCP秘密管理器，您需要一个安装了秘密管理器的GCP账户，因为它不能在Google云之外运行。
- en: Installing and configuring GCP Secret Manager
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和配置GCP秘密管理器
- en: To install GCP Secret Manager, log in to GCP console ([https://console.cloud.google.com/home](https://console.cloud.google.com/home))
    with your GCP account, and enable Secret Manager. In the search bar at the top
    of the page, search for *Secret Manager*, and click it on the search results,
    as shown in figure 6.18.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装GCP秘密管理器，请使用您的GCP账户登录到GCP控制台([https://console.cloud.google.com/home](https://console.cloud.google.com/home))，并启用秘密管理器。在页面顶部的搜索栏中搜索*秘密管理器*，然后在搜索结果中点击它，如图6.18所示。
- en: '![](../Images/CH06_F18_Sotobueno3.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F18_Sotobueno3.png)'
- en: Figure 6.18 Searching for GCP Secret Manager
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 搜索GCP秘密管理器
- en: Then enable GCP Secret Manager by clicking on the Enable button (figure 6.19).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过点击启用按钮（图6.19）来启用GCP秘密管理器。
- en: '![](../Images/CH06_F19_Sotobueno3.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F19_Sotobueno3.png)'
- en: Figure 6.19 Enabling Secret Manager
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 启用秘密管理器
- en: With Secret Manager enabled, create a new secret to be injected into the Pod
    using CSI. Select the Secret Manager resource from the Security section in the
    left menu, and click the Create Secret button, as shown in figure 6.20.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 启用秘密管理器后，创建一个新的秘密，使用CSI将其注入Pod。从左侧菜单的安全部分选择秘密管理器资源，然后点击创建秘密按钮，如图6.20所示。
- en: '![](../Images/CH06_F20_Sotobueno3.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F20_Sotobueno3.png)'
- en: Figure 6.20 Creating the secret
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 创建秘密
- en: Fill out the Create Secret form with Name as `app-secret` and Value as `my_password`,
    as shown in figure 6.21.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称为`app-secret`和值为`my_password`的创建秘密表单，如图6.21所示填写。
- en: '![](../Images/CH06_F21_Sotobueno3.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F21_Sotobueno3.png)'
- en: Figure 6.21 Creating the secret
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 创建秘密
- en: A list of all created secrets is shown when you create a secret. Now click on
    the name of the created secret to inspect its details and get the resource name,
    as you will need it later on for the GCP Secrets Store CSI provider configuration
    (figure 6.22).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 创建秘密时，会显示所有创建的秘密列表。现在点击创建的秘密的名称，以检查其详细信息并获取资源名称，因为您稍后需要它来配置GCP Secrets Store
    CSI提供程序（图6.22）。
- en: '![](../Images/CH06_F22_Sotobueno3.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F22_Sotobueno3.png)'
- en: Figure 6.22 Selecting the created secret
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 选择创建的秘密
- en: Write down the `Resource ID` value (`projects/466074950013/secrets/app-secret`),
    since you will need it as a parameter when the `SecretProviderClass` is created.
    Figure 6.23 shows an example of the overview of a secret.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 记录`资源ID`值（`projects/466074950013/secrets/app-secret`），因为当创建`SecretProviderClass`时，您将需要它作为参数。图6.23显示了秘密概述的示例。
- en: '![](../Images/CH06_F23_Sotobueno3.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F23_Sotobueno3.png)'
- en: Figure 6.23 Overview of the created secret
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23 创建的秘密概述
- en: The final step before leaving GCP console is exporting the GCP service account
    credential keys to authenticate against the Secret Manager instance. Typically
    this JSON file is downloaded automatically when the keys are added to the service
    account. If you don’t have a key, you can add a new one by clicking the Service
    Accounts menu and then the Add Key button, as shown in figure 6.24.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开GCP控制台之前的最后一步是导出GCP服务账户凭证密钥以验证秘密管理器实例。通常，当密钥添加到服务账户时，此JSON文件会自动下载。如果您没有密钥，可以通过点击服务账户菜单然后点击添加密钥按钮来添加一个新的密钥，如图6.24所示。
- en: '![](../Images/CH06_F24_Sotobueno3.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F24_Sotobueno3.png)'
- en: Figure 6.24 Overview of the created secret
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24 创建的秘密概述
- en: It’s important to generate a key in JSON format and with enough permissions
    to access GCP Secret Manager. Finally go back to the secret overview page, click
    the Permissions tab and the Add button to add the previous service account as
    an account that can consume the secret. This process is shown in figure 6.25.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个 JSON 格式的密钥，并具有足够的权限访问 GCP Secret Manager 非常重要。最后回到机密概览页面，点击权限选项卡和添加按钮，将之前的服务账户添加为可以消费机密的账户。此过程如图
    6.25 所示。
- en: '![](../Images/CH06_F25_Sotobueno3.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F25_Sotobueno3.png)'
- en: Figure 6.25 Give the service account permissions to access the secret
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25 给服务账户赋予访问机密的权限
- en: GCP Secret Manager CSI Driver
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: GCP Secret Manager CSI 驱动程序
- en: Let’s install and configure the GCP Secret Manager CSI Driver. First of all,
    create a new Kubernetes namespace to deploy the GCP example.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装和配置 GCP Secret Manager CSI 驱动程序。首先，创建一个新的 Kubernetes 命名空间以部署 GCP 示例。
- en: Listing 6.54 Create GCP namespace
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.54 创建 GCP 命名空间
- en: '[PRE61]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ① Create a namespace.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个命名空间。
- en: ② Switch to the created namespace.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ② 切换到创建的命名空间。
- en: Install the GCP Secrets Store CSI Provider, as shown in listing 6.55, to inject
    secrets from GCP Secret Manager into Pods using the CSI interface.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 按照列表 6.55 的说明安装 GCP Secrets Store CSI Provider，以便使用 CSI 接口将 GCP Secret Manager
    中的机密注入到 Pods 中。
- en: Listing 6.55 Installing the GCP Secrets Store CSI provider
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.55 安装 GCP Secrets Store CSI 提供程序
- en: '[PRE62]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ① Installs the GCP Secrets Store CSI provider
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: ① 安装 GCP Secrets Store CSI 提供程序
- en: Check that the provider is running by executing the following command.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令检查提供程序是否正在运行。
- en: Listing 6.56 Checking the GCP Secrets Store CSI provider
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.56 检查 GCP Secrets Store CSI 提供程序
- en: '[PRE63]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ① List the Pods in the kube-system namespace.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ① 列出 kube-system 命名空间中的 Pods。
- en: WARNING The provider is installed in the `kube-system` namespace to establish
    connection with the Kube API Server.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：提供程序安装在 `kube-system` 命名空间中，以建立与 Kube API 服务器的连接。
- en: Then set the service account credentials as Kubernetes Secrets accessible by
    the GCP Secrets Store CSI Driver, as shown in listing 6.57\. The driver uses this
    secret to log in to the remote GCP Secret Manager. The secret must have a key
    `key.json` with a value of an exported GCP service account credential.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将服务账户凭据设置为 Kubernetes Secrets，使其可通过 GCP Secrets Store CSI Driver 访问，如列表 6.57
    所示。驱动程序使用此机密登录远程 GCP Secret Manager。该机密必须有一个 `key.json` 密钥，其值为导出的 GCP 服务账户凭据。
- en: Listing 6.57 Creating a Kubernetes Secret namespace
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.57 创建 Kubernetes 机密命名空间
- en: '[PRE64]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ① $AKEY_GCP is the service account JSON file downloaded in the previous step.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: ① $AKEY_GCP 是上一步中下载的服务账户 JSON 文件。
- en: ② A secret is created with the key.json key and value of the GCP key.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 key.json 密钥和 GCP 密钥的值创建一个机密。
- en: ImportanT Secrets must be created in the same namespace as the application Pod.
    Moreover, as with any Kubernetes Secret, it needs to be managed as shown in chapters
    3 and 4.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 重要机密必须在与应用程序 Pod 相同的命名空间中创建。此外，与任何 Kubernetes 机密一样，它需要按照第 3 章和第 4 章所述进行管理。
- en: Before creating a Pod with the secret, the last step is configuring the `SecretProviderClass`
    with the secret resource ID and the filename where the content of the secret is
    written.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建包含机密的 Pod 之前，最后一步是配置 `SecretProviderClass`，包括机密资源 ID 和机密内容存储的文件名。
- en: Listing 6.58 gcp-spc.yaml
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.58 gcp-spc.yaml
- en: '[PRE65]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '① Refers to a secret version in the following format: <Resource ID>//versions/'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ① 指的是以下格式的机密版本：<Resource ID>//versions/
- en: ② The filename where the secret content is written
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ② 存储机密内容的文件名
- en: Apply the gcp-manning `SecretProviderClass` by running the following command.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令应用 gcp-manning 的 `SecretProviderClass`。
- en: Listing 6.59 Applying the gcp-manning `SecretProviderClass`
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.59 应用 gcp-manning 的 `SecretProviderClass`
- en: '[PRE66]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ① Registers the GCP SecretProviderClass
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ① 注册 GCP SecretProviderClass
- en: Deploying a Pod with a secret mounted
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 部署挂载机密的 Pod
- en: The configuration in this example is similar to what you saw in the HashiCorp
    Vault example; you have the `csi` section, where you set the CSI driver to `secrets-store.csi.k8s.io`,
    as well as the `SecretProviderClass` name created previously (`gcp-manning`).
    But in this case, set the `nodePublishSecretRef` pointing out the Kubernetes secret
    created previously with the GCP service account credentials (`secrets-store-creds`)
    to access the GCP Secret Manager.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '此示例中的配置与您在 HashiCorp Vault 示例中看到的内容类似；您有 `csi` 部分，其中将 CSI 驱动程序设置为 `secrets-store.csi.k8s.io`，以及之前创建的
    `SecretProviderClass` 名称（`gcp-manning`）。但在此情况下，设置 `nodePublishSecretRef` 指向之前创建的、使用
    GCP 服务账户凭据（`secrets-store-creds`）访问 GCP Secret Manager 的 Kubernetes 机密。 '
- en: Listing 6.60 gcp-app-pod.yaml
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.60 gcp-app-pod.yaml
- en: '[PRE67]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ① Volume mount section
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: ① 卷挂载部分
- en: ② Path where secrets are mounted
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: ② 秘密挂载的路径
- en: ③ References to SecretProviderClass
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 对 SecretProviderClass 的引用
- en: ④ Required when using the service account as a secret
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 当使用服务账户作为秘密时需要
- en: Deploy the Pod by running the following command.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令部署 Pod。
- en: Listing 6.61 Applying the Pod with the CSI volume
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.61 应用带有 CSI 卷的 Pod
- en: '[PRE68]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ① Deploy a Pod configured to use the GCP Secrets Store CSI provider.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: ① 部署一个配置为使用 GCP Secrets Store CSI 提供者的 Pod。
- en: Wait until the Pod is running.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 Pod 运行。
- en: Listing 6.62 Waiting until the greeting Pod is running
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.62 等待问候 Pod 运行
- en: '[PRE69]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ① Wait until the Pod is ready.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: ① 等待 Pod 准备就绪。
- en: Finally, validate that the secret is mounted in `/mnt/secrets-gcp`, as specified
    in the `volumesMount` section, and the file containing the secret is named `app-secret`,
    as specified in `fileName` field. Run the command shown in the following listing.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，验证秘密是否已挂载在 `volumesMount` 部分指定的 `/mnt/secrets-gcp`，并且包含秘密的文件名为 `app-secret`，如
    `fileName` 字段所述。运行以下列表中显示的命令。
- en: Listing 6.63 Reading the injected secret
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.63 读取注入的秘密
- en: '[PRE70]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ① The value displayed matches the previously set password value for the secret.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: ① 显示的值与之前设置的密码值匹配。
- en: Providing Identity to the GCP Secret Manager
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 向 GCP Secret Manager 提供身份
- en: 'In this section, you’ve provided the identity access to GCP Secret Manager
    using a service account. At the time of writing, this is the only way to connect
    to GCP Secret Manager from a non-GCP environment. The following authentication
    modes are also supported:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已使用服务账户提供了对 GCP Secret Manager 的身份访问权限。在撰写本文时，这是从非 GCP 环境连接到 GCP Secret
    Manager 的唯一方法。以下认证模式也得到支持：
- en: Pod workload identity
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 工作负载身份
- en: GCP provider identity
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP 提供者身份
- en: You now know how to use secrets store CSI drivers to inject secrets stored in
    GCP Secret Manager. In the following section, you will see the same example—this
    time for storing secrets in AWS Secrets Manager.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何使用秘密存储 CSI 驱动程序注入存储在 GCP Secret Manager 中的秘密。在下一节中，你将看到相同的示例——这次是存储在
    AWS Secrets Manager 中的秘密。
- en: 6.4.3 AWS Secrets Manager
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 AWS Secrets Manager
- en: AWS Secrets Manager is an AWS cloud service that provides a secure store for
    secrets (e.g., keys, passwords, certificates). To run AWS Secrets Manager, you
    need an AWS account with AWS Secrets Manager installed; it cannot run outside
    of the AWS cloud. Moreover, at time of writing, AWS Secrets Manager can run in
    an Amazon Elastic Kubernetes Service (EKS) 1.17+.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Secrets Manager 是一种 AWS 云服务，它为秘密（例如，密钥、密码、证书）提供了一个安全的存储库。要运行 AWS Secrets
    Manager，你需要一个安装了 AWS Secrets Manager 的 AWS 账户；它不能在 AWS 云之外运行。此外，在撰写本文时，AWS Secrets
    Manager 可以在 Amazon Elastic Kubernetes Service (EKS) 1.17+ 上运行。
- en: We won’t explain the whole process of preparing an EKS cluster in this book.
    We’ll also assume that an EKS cluster is up and configured and the `eksctl` CLI
    tool is installed on your machine.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会解释准备 EKS 集群的整个过程。我们还将假设 EKS 集群已启动并配置，并且 `eksctl` CLI 工具已安装在你的机器上。
- en: Creating a secret in AWS Secrets Manager
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS Secrets Manager 中创建秘密
- en: As you’ve done in the previous sections, you need to store a secret into the
    secrets store—in this case AWS Secrets Manager—to be consumed by the secrets store
    CSI driver. Use the `aws` CLI tool ([http://mng.bz/ZpaR](http://mng.bz/ZpaR))
    to create a secret named `AppSecret` and with the value `my_secret`.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，你需要将一个秘密存储到秘密存储中——在本例中为 AWS Secrets Manager——以便由秘密存储 CSI 驱动程序使用。使用 `aws`
    CLI 工具（[http://mng.bz/ZpaR](http://mng.bz/ZpaR)）创建一个名为 `AppSecret` 且值为 `my_secret`
    的秘密。
- en: Listing 6.64 Creating the Secret
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.64 创建秘密
- en: '[PRE71]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ① The region where the Kubernetes cluster is running
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: ① Kubernetes 集群运行的区域
- en: ② Creating a secret in the secret manager
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在秘密管理器中创建秘密
- en: Then create an IAM access policy to access the secret created in the previous
    step. This step is important, as you’ll associate this access policy with the
    Kubernetes service account running the `greeting-demo` Pod in a similar way as
    in the HashiCorp Vault Kubernetes authentication mode.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个 IAM 访问策略来访问之前步骤中创建的秘密。这一步很重要，因为你将以类似于在 HashiCorp Vault Kubernetes 认证模式中的方式将此访问策略与运行
    `greeting-demo` Pod 的 Kubernetes 服务账户关联起来。
- en: Run the command shown in listing 6.65 to create an access policy with the name
    `greeting-deployment-policy` to access to the `AppSecret` secret. The policy name
    is important, as you’ll need to make a link between the policy and the Kubernetes
    service account.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表 6.65 中显示的命令，创建一个名为 `greeting-deployment-policy` 的访问策略来访问 `AppSecret` 秘密。策略名称很重要，因为你需要在这项策略和
    Kubernetes 服务账户之间建立联系。
- en: Listing 6.65 Creating the access policy
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.65 创建访问策略
- en: '[PRE72]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ① Creates a policy with the name greeting-deployment-policy
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个名为 greeting-deployment-policy 的策略
- en: ② Allows the operations described in the Action field
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: ② 允许操作字段中描述的操作
- en: ③ Permits getting and describing secrets
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 允许获取和描述机密
- en: ④ Sets the policy for secrets with the name AppSecret
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 为名为 AppSecret 的机密设置策略
- en: ⑤ The command returns the policy ARN ID.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 命令返回策略 ARN ID。
- en: You need an IAM OIDC provider for the cluster to create the association between
    the IAM access policy and the Kubernetes service account. If you don’t already
    have one, create one by running the following command.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个 IAM OIDC 提供者，以便在集群中创建 IAM 访问策略与 Kubernetes 服务账户之间的关联。如果您还没有一个，可以通过运行以下命令来创建一个。
- en: Listing 6.66 Creating an IAM OIDC provider
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.66 创建 IAM OIDC 提供者
- en: '[PRE73]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ① $CLUSTERNAME is the name of your cluster.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ① `$CLUSTERNAME` 是您集群的名称。
- en: Finally create an IAM service account to be used by the Pod, and associate it
    with the IAM access policy (`arn:aws:iam::aws:policy/greeting-deployment-policy`)
    created previously. In this case, use `greeting-deployment-sa` as the service
    account name and the Kubernetes service account name.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 最后创建一个 IAM 服务账户，该账户将被 Pod 使用，并将其与之前创建的 IAM 访问策略（`arn:aws:iam::aws:policy/greeting-deployment-policy`）关联。在这种情况下，使用
    `greeting-deployment-sa` 作为服务账户名称和 Kubernetes 服务账户名称。
- en: Listing 6.67 Creating the access policy
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.67 创建访问策略
- en: '[PRE74]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ① Creates an IAM service account
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建 IAM 服务账户
- en: ② Attaches to the policy to access secrets
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将策略附加到以访问机密
- en: The process is summarized in figure 6.26\.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程总结在图 6.26 中。
- en: '![](../Images/CH06_F26_Sotobueno3.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F26_Sotobueno3.png)'
- en: Figure 6.26 Pod-Volume connection
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26 Pod-Volume 连接
- en: AWS Secrets Manager CSI Driver
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Secrets Manager CSI 驱动程序
- en: Now install and configure the AWS Secret Manager CSI Driver. First create a
    new Kubernetes namespace to deploy the AWS example.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装和配置 AWS Secret Manager CSI 驱动程序。首先创建一个新的 Kubernetes 命名空间来部署 AWS 示例。
- en: Listing 6.68 Creating an AWS namespace
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.68 创建 AWS 命名空间
- en: '[PRE75]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ① Create a namespace.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个命名空间。
- en: ② Switch to the created namespace.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: ② 切换到创建的命名空间。
- en: Install the AWS Secrets Store CSI Provider, as shown in listing 6.69, to inject
    secrets from AWS Secret Manager into Pods using the CSI interface.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 按照列表 6.69 中的说明安装 AWS Secrets Store CSI 提供者，以使用 CSI 接口将 AWS Secret Manager 中的机密注入到
    Pod 中。
- en: Listing 6.69 Installing the AWS Secrets Store CSI Provider
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.69 安装 AWS Secrets Store CSI 提供者
- en: '[PRE76]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ① Installs the AWS Secrets Store CSI provider
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: ① 安装 AWS Secrets Store CSI 提供者
- en: 'Check that the provider is running by executing the following command:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令来检查提供者是否正在运行：
- en: Listing 6.70 Checking the GCP Secrets Store CSI provider
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.70 检查 GCP Secrets Store CSI 提供者
- en: '[PRE77]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ① List the Pods in the kube-system namespace.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: ① 列出 kube-system 命名空间中的 Pod。
- en: WARNING The provider is installed in the `kube-system` namespace to establish
    connectivity to the Kube API Server.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：提供者安装在 `kube-system` 命名空间中，以建立与 Kube API 服务器的连接。
- en: The last step before creating a Pod with a secret is configuring the `SecretProviderClass`
    with the secret’s name.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建包含机密的 Pod 之前，最后一步是使用机密名称配置 `SecretProviderClass`。
- en: Listing 6.71 aws-spc.yaml
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.71 aws-spc.yaml
- en: '[PRE78]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ① Sets the secret’s name created earlier
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置之前创建的机密名称
- en: Apply the `aws-manningSecretProviderClass` by running the following command.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令应用 `aws-manningSecretProviderClass`。
- en: Listing 6.72 Applying the aws-manning `SecretProviderClass`
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.72 应用 aws-manning `SecretProviderClass`
- en: '[PRE79]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: ① Registers AWS SecretProviderClass
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ① 注册 AWS SecretProviderClass
- en: Deploying a Pod with a secret mounted
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 部署挂载机密的 Pod
- en: The configuration in this example is similar to what you saw in the HashiCorp
    Vault example. You have the `csi` section, where you set the CSI driver to `secrets-store
    .csi.k8s.io`, as well as the `SecretProviderClass` name created previously (`aws-
    manning`). In this case, set the service account name to the service account created
    in the previous step (`greeting-deployment-sa`) to access the AWS Secrets Manager.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的配置与您在 HashiCorp Vault 示例中看到的内容类似。您有 `csi` 部分，其中将 CSI 驱动程序设置为 `secrets-store.csi.k8s.io`，以及之前创建的
    `SecretProviderClass` 名称（`aws-manning`）。在这种情况下，将服务账户名称设置为之前步骤中创建的服务账户（`greeting-deployment-sa`）以访问
    AWS Secrets Manager。
- en: Listing 6.73 aws-app-pod.yaml
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.73 aws-app-pod.yaml
- en: '[PRE80]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: ① Volume mount section
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: ① 卷挂载部分
- en: ② Path where secrets are mounted
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: ② 机密挂载的路径
- en: ③ eferences the SecretProviderClass
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 引用 SecretProviderClass
- en: Deploy the Pod by running the following command.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令部署 Pod。
- en: Listing 6.74 Applying the Pod with the CSI volume
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.74 应用带有 CSI 卷的 Pod
- en: '[PRE81]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ① Deploy a Pod configured to use the AWS Secrets Store CSI provider.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: ① 部署一个配置为使用 AWS Secrets Store CSI 提供者的 Pod。
- en: Wait until the Pod is running.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 Pod 运行。
- en: Listing 6.75 Wait until the greeting Pod is running
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.75 等待问候 Pod 运行
- en: '[PRE82]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: ① Wait until the Pod is ready.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: ① 等待 Pod 准备就绪。
- en: Finally, validate the secret is mounted in `/mnt/secrets-aws`, as specified
    in the `volumesMount` section, and the file containing the secret is named as
    set in `objectName`. Run the command shown in the following listing.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，验证密钥是否已挂载在 `volumesMount` 部分指定的 `/mnt/secrets-aws`，并且包含密钥的文件名称与 `objectName`
    中设置的一致。运行以下列表中显示的命令。
- en: Listing 6.76 Read the injected secret
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.76 读取注入的密钥
- en: '[PRE83]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ① The value displayed matches the previously set password value for the secret
    set.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: ① 显示的值与之前设置的密钥集的密码值匹配。
- en: Other configuration parameters
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 其他配置参数
- en: AWS CSI provider has other configuration parameters not shown in the previous
    example; in the following snippet, you can see a `SecretProviderClass` example
    with all possible parameters.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CSI 提供商还有其他配置参数，在之前的示例中没有显示；在下面的代码片段中，您可以看到一个包含所有可能参数的 `SecretProviderClass`
    示例。
- en: '[PRE84]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ① Secret type one of secretsmanager or ssmparameter
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ① 密钥类型之一为 secretsmanager 或 ssmparameter
- en: ② Optional base filename in which to store the secret
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: ② 可选的基础文件名，用于存储密钥
- en: ③ Optional version ID of the secret
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 可选的密钥版本 ID
- en: ④ Optional version/stage label of the secret
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 可选的密钥版本/阶段标签
- en: Global security considerations when using secrets store CSI drivers
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥存储 CSI 驱动时的全局安全考虑
- en: 'As we mentioned in chapter 2, mounting secrets as volumes or injecting them
    as environment variables exposes you to some threats worth considering:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 2 章中提到的，将密钥作为卷挂载或注入为环境变量会使您面临一些值得考虑的威胁：
- en: When the secret is mounted on the filesystem, potential vulnerabilities—like
    directory traversal attack, unforbidden access to the node disk, or gaining access
    to the Pod—can become a problem, as the attacker may gain access to the secret
    data. You need to protect against these problems at the application level (e.g.,
    for directory traversal) and Kubernetes level (e.g., for disabling `kubectl exec`).
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当密钥在文件系统中挂载时，潜在的漏洞——如目录遍历攻击、未经授权访问节点磁盘或访问 Pod——可能成为问题，因为攻击者可能能够访问密钥数据。您需要在应用级别（例如，针对目录遍历）和
    Kubernetes 级别（例如，禁用 `kubectl exec`）保护这些问题。
- en: When the secret is injected through environment variables, potential vulnerabilities,
    like logging environment data at the application level or gaining access to the
    Pod, can become a problem, as the attacker may read the secret data.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当密钥通过环境变量注入时，潜在漏洞，如应用级别记录环境数据或访问 Pod，可能成为问题，因为攻击者可能读取密钥数据。
- en: When syncing secrets to the Kubernetes Secrets store, remember to apply all
    the security considerations learned in chapter 4\. You may have the secrets securely
    placed in the external secrets store but lose all these confidentialities when
    moved to Kubernetes secrets.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将密钥同步到 Kubernetes 密钥存储时，请记住应用在第 4 章中学到的所有安全考虑。您可能已经将密钥安全地放置在外部密钥存储中，但将其移动到
    Kubernetes 密钥时可能会丢失所有这些机密性。
- en: There are different tools and projects that can help us detect security threats
    automatically and provide some guidance for solving the security issue. In our
    opinion, there are two tools that, combined together, can best help you detect
    and audit security misconfigurations as well as unusual behvior in your containers.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的工具和项目可以帮助我们自动检测安全威胁并提供一些解决安全问题的指导。在我们看来，有两个工具结合使用可以最好地帮助您检测和审计容器中的安全配置错误以及异常行为。
- en: The first project is KubeLinter ([https://docs.kubelinter.io/](https://docs.kubelinter.io/)).
    The project is a static code analysis tool that analyzes Kubernetes YAML files
    and Helm charts, checking for security misconfigurations and best practices. Some
    of the issues it detects include running containers in privileged mode, exposing
    privileged ports, exposing SSH’d ports, unsetting resource requirements, and reading
    secrets from environment variables.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目是 KubeLinter ([https://docs.kubelinter.io/](https://docs.kubelinter.io/))。该项目是一个静态代码分析工具，它分析
    Kubernetes YAML 文件和 Helm 图表，检查安全配置错误和最佳实践。它检测的一些问题包括以特权模式运行容器、暴露特权端口、暴露 SSH 端口、未设置资源需求以及从环境变量读取密钥。
- en: The second project is Falco ([https://falco.org/](https://falco.org/)). This
    project works at runtime, parsing Linux sytem calls from the Kernel and checking
    them against a list of rules to validate whether they are permitted. In the case
    of a violation of a rule, an alert is triggered, and some actions can be taken
    as a response. Falco comes with a set of rules; some of them include notifying
    read/writes to well-known directories, such as `/etc`, `/usr/bin`, and `/usr/sbin`;
    ownership and mode changes; and executing SSH binaries, such as `ssh`, `scp`,
    and `sftp`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目是Falco ([https://falco.org/](https://falco.org/))。该项目在运行时工作，解析来自内核的Linux系统调用，并将它们与一系列规则进行比对，以验证它们是否被允许。如果违反了规则，则会触发警报，并可以采取一些行动作为响应。Falco附带一组规则；其中一些包括通知对知名目录的读写操作，例如
    `/etc`、`/usr/bin` 和 `/usr/sbin`；所有者和模式更改；以及执行SSH二进制文件，如 `ssh`、`scp` 和 `sftp`。
- en: It’s safe to say that now you know why CSI and secrets store CSI drivers are
    perfect abstractions for dealing with multiple secret managers.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，现在你知道为什么CSI和秘密存储CSI驱动程序是处理多个秘密管理器的完美抽象。
- en: Summary
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The Container Storage Interface is an initiative to unify the storage interface
    of container orchestrators.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器存储接口是一个旨在统一容器编排器存储接口的倡议。
- en: Secrets Store CSI is an implementation of the CSI spec to consume secrets from
    external data stores.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secrets Store CSI 是一个实现CSI规范的方案，用于从外部数据存储中消费机密。
- en: Secrets Store CSI allows us to inject secrets into Pods from HashiCorp Vault,
    AWS Secret Manager, GCP Secret Manager, and Azure Key Vault.
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secrets Store CSI允许我们从HashiCorp Vault、AWS Secret Manager、GCP Secret Manager和Azure
    Key Vault将机密注入到Pod中。
- en: Although Secrets Store CSI supports key rotation, the application needs to support
    it by either watching disk changes or reloading the Pod.
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然Secrets Store CSI支持密钥轮换，但应用程序需要通过监视磁盘更改或重新加载Pod来支持它。
