- en: 18 An introduction to graph theory and network analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 图论和网络分析简介
- en: This section covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖
- en: Representing diverse datasets as networks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多样化的数据集表示为网络
- en: Network analysis with the NetworkX library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetworkX库进行网络分析
- en: Optimizing travel paths in a network
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络中优化旅行路径
- en: 'The study of connections can potentially yield billions of dollars. In the
    1990s, two graduate students analyzed the properties of interconnected web pages.
    Their insights led them to found Google. In the early 2000s, an undergraduate
    began to digitally track connections between people. He went on to launch Facebook.
    Connection analysis can lead to untold riches, but it can also save countless
    lives. Tracking the connections between proteins in cancer cells can generate
    drug targets that will wipe out that cancer. Analyzing connections between suspected
    terrorists can uncover and prevent devious plots. These seemingly disparate scenarios
    have one thing in common: they can be studied using a branch of mathematics called
    *network theory* by some and *graph theory* by others.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 研究联系可能产生数十亿美元的价值。在20世纪90年代，两名研究生分析了相互连接的网页属性。他们的洞察力使他们创立了谷歌。在21世纪初，一名本科生开始追踪人与人之间的联系。他继续推出了Facebook。联系分析可能导致无法估量的财富，但它也可以拯救无数的生命。追踪癌细胞中蛋白质之间的联系可以产生药物靶点，从而消除那种癌症。分析疑似恐怖分子之间的联系可以揭露并预防狡猾的阴谋。这些看似不同的场景有一个共同点：它们可以使用被称为*网络理论*（有些人称之为）或*图论*（有些人称之为）的数学分支进行研究。
- en: '*Network theory* is the study of connections between objects. These objects
    can be anything: people connected by relationships, web pages connected by web
    links, or cities connected by roads. A collection of objects and their dispersed
    connections is called either a *network* or a *graph*, depending on whom you ask.
    Engineers prefer to use the term *network*, while mathematicians prefer *graph*.
    For our intents and purposes, we’ll use the two terms interchangeably. Graphs
    are simple abstractions that capture the complexity of our entangled, interconnected
    world. Properties of graphs remain surprisingly consistent across systems in society
    and nature. Graph theory is a framework for mathematically tracking these consistencies.
    It combines ideas from diverse branches of mathematics, including probability
    theory and matrix analysis. These ideas can be used to gain useful real-world
    insights ranging from search engine page rankings to social circle clustering,
    so some knowledge of graph theory is indispensable to doing good data science.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络理论*是研究对象之间联系的研究。这些对象可以是任何东西：通过关系连接的人，通过网页链接连接的网页，或通过道路连接的城市。一组对象及其分散的连接被称为*网络*或*图*，这取决于你问的是谁。工程师更喜欢使用术语*网络*，而数学家更喜欢*图*。就我们的目的而言，我们将交替使用这两个术语。图是简单的抽象，它捕捉了我们错综复杂、相互关联的世界的复杂性。图的性质在社会和自然系统之间保持惊人的一致性。图论是一个用于数学上跟踪这些一致性的框架。它结合了来自不同数学分支的想法，包括概率理论和矩阵分析。这些想法可以用来获得有用的现实世界见解，从搜索引擎页面排名到社交圈聚类，因此对图论的了解对于做好数据科学是必不可少的。'
- en: In the next two sections, we learn the fundamentals of graph theory by building
    on previously studied data science concepts and libraries. We start slowly by
    addressing basic problems while exploring graphs of web page links and roads.
    Later, in section 19, we utilize more advanced techniques to detect clusters of
    friends in social graphs. However, we begin with a much simpler data science task
    of ranking websites by popularity.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两节中，我们通过构建之前学习的数据科学概念和库，学习图论的基础。我们通过解决基本问题并探索网页链接和道路的图开始缓慢学习。稍后，在第19节中，我们利用更高级的技术来检测社交图中的朋友集群。然而，我们首先从一项更简单的数据科学任务开始，即按流行度对网站进行排名。
- en: 18.1 Using basic graph theory to rank websites by popularity
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 使用基本的图论按流行度对网站进行排名
- en: 'There are many data science websites on the internet. Some sites are more popular
    than others. Suppose you wish to estimate the most popular data science website
    using data that is publicly available. This precludes privately tracked traffic
    data. What should you do? Network theory offers us a simple way of ranking websites
    based on their public links. To see how, let’s build a simple network composed
    of two data science websites: a NumPy tutorial and a SciPy tutorial. In graph
    theory, these websites are referred to as the *nodes* in the graph. Nodes are
    network points that can form connections with each other; these connections are
    called *edges*. Our two website nodes will form an edge if one site links to the
    other or vice versa.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多数据科学网站。有些网站比其他网站更受欢迎。假设你想使用公开可用的数据来估计最受欢迎的数据科学网站。这排除了私人跟踪的流量数据。你应该怎么做？网络理论为我们提供了一种简单的方法，可以根据网站的公开链接对网站进行排名。为了了解如何，让我们构建一个由两个数据科学网站组成的简单网络：一个
    NumPy 教程和一个 SciPy 教程。在图论中，这些网站被称为图中的 *节点*。节点是网络点，可以相互形成连接；这些连接被称为 *边*。如果其中一个网站链接到另一个网站或反之亦然，我们的两个网站节点将形成一个边。
- en: We begin by storing our two nodes in a two-element list. These elements equal
    `'NumPy'` and `'SciPy'`, respectively.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将我们的两个节点存储在一个包含两个元素的列表中。这些元素分别等于 `'NumPy'` 和 `'SciPy'`。
- en: Listing 18.1 Defining a node list
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.1 定义节点列表
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Suppose the SciPy website is discussing NumPy dependencies. This discussion
    includes a web link to the NumPy page. Clicking that link will take the reader
    from the website represented by `nodes[1]` to the website represented by `nodes[0]`.
    We treat this connection as an edge that goes from index 1 to index 0, as shown
    in figure 18.1\. The edge can be expressed as the tuple `(1, 0)`. Here, we form
    an edge by storing `(1, 0)` in an `edges` list.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 SciPy 网站正在讨论 NumPy 的依赖关系。这次讨论包括指向 NumPy 页面的网页链接。点击该链接将读者从由 `nodes[1]` 表示的网站带到由
    `nodes[0]` 表示的网站。我们将这种连接视为从索引 1 到索引 0 的边，如图 18.1 所示。边可以用元组 `(1, 0)` 来表示。在这里，我们通过在
    `edges` 列表中存储 `(1, 0)` 来形成一个边。
- en: Listing 18.2 Defining an edge list
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.2 定义边列表
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/18-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/18-01.png)'
- en: Figure 18.1 Two websites, NumPy and SciPy, are represented as circular nodes.
    A directed edge points from SciPy to NumPy, indicating a directed link between
    the sites. If NumPy and SciPy are stored as node indices `0` and `1`, we can represent
    the edge as tuple `(1, 0)`. Later in this section, we learn how to generate the
    network diagram in this figure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1 NumPy 和 SciPy 这两个网站被表示为圆形节点。一个有向边从 SciPy 指向 NumPy，表示这两个网站之间的有向链接。如果 NumPy
    和 SciPy 被存储为节点索引 `0` 和 `1`，我们可以将边表示为元组 `(1, 0)`。在本节后面的内容中，我们将学习如何生成图中所示的网络图。
- en: Our single edge `(1, 0)` represents a link that directs a user from `nodes[1]`
    to `nodes[0]`. This edge has a specific direction and is referred to as a *directed
    edge*. Graphs containing directed edges are referred to as *directed graphs*.
    In a directed graph, edge `(i, j)` is treated differently from edge `(j, i)`.
    The presence of `(i, j)` in an `edges` list does not imply the presence of `(j,
    i).` For instance, in our network, the NumPy page does not yet link to the SciPy
    page, so edge tuple `(0, 1)` is not present in the `edges` list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单个边 `(1, 0)` 表示一个将用户从 `nodes[1]` 指向 `nodes[0]` 的链接。这条边具有特定的方向，被称为 *有向边*。包含有向边的图被称为
    *有向图*。在有向图中，边 `(i, j)` 与边 `(j, i)` 的处理方式不同。`edges` 列表中存在 `(i, j)` 并不意味着存在 `(j,
    i)`。例如，在我们的网络中，NumPy 页面尚未链接到 SciPy 页面，因此边元组 `(0, 1)` 不存在于 `edges` 列表中。
- en: Given our directed `edges` list, we can easily check if a web page at index
    `i` links to a web page at index `j`. That connection exists if `(i, j) in edges`
    equals `True`. Thus, we can define a one-line `edge_exists` function, which checks
    for edges between indices `i` and `j`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的有向 `edges` 列表，我们可以轻松地检查索引 `i` 的网页是否链接到索引 `j` 的网页。如果 `(i, j) in edges` 等于
    `True`，则存在这种连接。因此，我们可以定义一个单行的 `edge_exists` 函数，该函数检查索引 `i` 和 `j` 之间是否存在边。
- en: Listing 18.3 Checking for the existence of an edge
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.3 检查边的存在性
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our `edge_exists` function works, but it’s not efficient. The function must
    traverse a list to check the presence of an edge. This traversal is not an issue
    for an edge list of size 1\. However, if we were to increase our network size
    to 1,000 web pages, then our edge list size might increase to as many as 1 million
    edges. Traversing a million-edge list is not computationally justifiable. We need
    an alternative solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `edge_exists` 函数是有效的，但效率不高。该函数必须遍历一个列表来检查边的存在。对于大小为 1 的边列表，这种遍历不是问题。然而，如果我们把我们的网络规模增加到
    1,000 个网页，那么我们的边列表大小可能会增加到多达 1 百万条边。遍历一百万条边的计算成本是不合理的。我们需要一个替代方案。
- en: One alternative approach is to store the presence or absence of each edge `(i,
    j)` in the *i*th row and *j*th column of a table. Essentially, we can construct
    a table `t` in which `t[i][j] = edge_exists(i, j)`, so edge lookup will become
    instantaneous. Furthermore, we can represent this table as a 2D binary array if
    we store `not edge_ exists(i, j)` as 0 and `edge_exists(i, j)` as 1, so we can
    represent our graph as a binary matrix `M`, where `M[i][j] = 1` if an edge exists
    between node `i` and node `j`. This matrix representation of a network is known
    as an *adjacency matrix*. We now compute and print an adjacency matrix for our
    two-node single-edge directed graph. Initially, that matrix contains just 0s.
    Then we iterate each edge `(i, j)` in `edges` and set `adjacency_matrix[i][j]`
    to 1.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法是将每条边 `(i, j)` 的存在或不存在存储在表格的第 *i* 行和第 *j* 列中。本质上，我们可以在一个表格 `t` 中构造一个，其中
    `t[i][j] = edge_exists(i, j)`，这样边查找将变得即时。此外，如果我们把 `not edge_exists(i, j)` 存储为
    0 而 `edge_exists(i, j)` 存储为 1，那么我们可以将这个表格表示为一个二维二进制数组，因此我们可以将我们的图表示为一个二进制矩阵 `M`，其中
    `M[i][j] = 1` 如果节点 `i` 和节点 `j` 之间存在边。这种网络矩阵表示称为 *邻接矩阵*。我们现在计算并打印出我们两个节点单边有向图的邻接矩阵。最初，这个矩阵只包含
    0。然后我们遍历 `edges` 中的每个边 `(i, j)` 并将 `adjacency_matrix[i][j]` 设置为 1。
- en: Listing 18.4 Tracking nodes and edges using a matrix
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.4 使用矩阵跟踪节点和边
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our matrix printout permits us to view the edges present in the network. Additionally,
    we can observe potential edges that are missing from the network. For instance,
    we can clearly see an edge from Node 1 to Node 0\. Meanwhile, possible edges `(0,
    0)`, `(0, 1)`, and `(1, 1)` are not present in the graph. Neither is there a link
    going from Node 0 to Node 0\. The NumPy page does not link to itself, although
    theoretically, it could! We can imagine a poorly designed web page in which a
    hyperlink points to itself—the link would be useless since clicking it would take
    you right back where you started, but this type of self-linkage is possible. In
    graph theory, such self-referential edges are called *self-loops* or *buckles*.
    In the next section, we encounter an algorithm that is improved if we incorporate
    self-loops. However, for the time being, we limit our analysis to edges between
    different pairs of nodes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的矩阵打印输出使我们能够查看网络中存在的边。此外，我们还可以观察到网络中缺失的潜在边。例如，我们可以清楚地看到从节点 1 到节点 0 的边。同时，可能的边
    `(0, 0)`、`(0, 1)` 和 `(1, 1)` 都不在图中。也没有从节点 0 到节点 0 的链接。NumPy 页面不会链接到自身，尽管从理论上讲，它可以！我们可以想象一个设计糟糕的网页，其中超链接指向自身——点击该链接将毫无用处，因为它会直接把你带回到起点，但这种自我链接是可能的。在图论中，这种自我引用的边被称为
    *自环* 或 *环扣*。在下一节中，我们将遇到一个如果包含自环则改进的算法。然而，目前，我们将我们的分析限制在不同节点对之间的边。
- en: Let’s add the missing edge from Node 0 to Node 1\. This will imply that the
    NumPy page now links to the SciPy page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加从节点 0 到节点 1 的缺失边。这将意味着 NumPy 页面现在链接到 SciPy 页面。
- en: Listing 18.5 Adding an edge to the adjacency matrix
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.5 向邻接矩阵添加边
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Suppose we wish to expand our website network by adding two more data science
    sites that discuss Pandas and Matplotlib. Adding them will increase our node count
    from two to four, so we need to expand the adjacency matrix dimensions from two-by-two
    to four-by-four. During that expansion, we’ll also maintain all existing relationships
    between Node 0 and Node 1\. Unfortunately, in NumPy, it’s hard to resize a matrix
    while maintaining all existing matrix values—NumPy is not designed to easily handle
    growing arrays whose shape is constantly expanding. This conflicts with the expanding
    nature of the internet, where new websites are constantly being added. Therefore,
    NumPy is not the best tool for analyzing expanding networks. What should we do?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望通过添加两个讨论 Pandas 和 Matplotlib 的数据科学网站来扩展我们的网站网络。添加它们将使我们的节点数量从两个增加到四个，因此我们需要将邻接矩阵的维度从二维扩展到四维。在扩展过程中，我们还将保持节点
    0 和节点 1 之间所有现有的关系。不幸的是，在 NumPy 中，在保持所有现有矩阵值的同时调整矩阵大小是很困难的——NumPy 并未设计为轻松处理形状不断扩展的动态数组。这与互联网不断扩展的本质相冲突，因为新的网站不断被添加。因此，NumPy
    并不是分析扩展网络的最佳工具。我们应该怎么办？
- en: Note NumPy is inconvenient for tracking newly added nodes and edges. However,
    as we previously discussed, it is indispensable for efficiently executing matrix
    multiplication. In the next section, we multiply the adjacency matrix to analyze
    social graphs. Thus, our use of NumPy will prove essential for advanced network
    analysis. But for the time being, we rely on an alternative Python library to
    more easily construct our networks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 NumPy 在跟踪新添加的节点和边方面不太方便。然而，正如我们之前讨论的，它在高效执行矩阵乘法方面是必不可少的。在下一节中，我们将乘以邻接矩阵来分析社交图。因此，我们使用
    NumPy 的做法对于高级网络分析至关重要。但就目前而言，我们依赖于一个替代的 Python 库来更轻松地构建我们的网络。
- en: We need to switch to a different Python library. NetworkX is an external library
    that allows for easy network modification. It also provides additional useful
    features, including network visualization. Let’s proceed with our website analysis
    using NetworkX.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要切换到不同的 Python 库。NetworkX 是一个外部库，它允许轻松修改网络。它还提供了其他有用的功能，包括网络可视化。让我们使用 NetworkX
    继续进行我们的网站分析。
- en: 18.1.1 Analyzing web networks using NetworkX
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.1 使用 NetworkX 分析网络
- en: We begin by installing NetworkX. Then we import `networkx` as `nx`, per the
    common NetworkX usage convention.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装 NetworkX。然后按照常见的 NetworkX 使用惯例，我们将 `networkx` 导入为 `nx`。
- en: Note Call `pip install networkx` from the command line terminal to install the
    NetworkX library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 从命令行终端调用 `pip install networkx` 以安装 NetworkX 库。
- en: Listing 18.6 Importing the NetworkX library
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.6 导入 NetworkX 库
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we will utilize `nx` to generate a directed graph. In NetworkX, directed
    graphs are tracked using the `nx.DiGraph` class. Calling `nx.DiGraph()` initializes
    a new directed graph object containing zero nodes and zero edges. The following
    code initializes that directed graph; per NetworkX convention, we refer to the
    initialized graph as `G`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将利用 `nx` 生成一个有向图。在 NetworkX 中，有向图是通过 `nx.DiGraph` 类来跟踪的。调用 `nx.DiGraph()`
    初始化一个新的有向图对象，该对象包含零个节点和零条边。以下代码初始化了该有向图；按照 NetworkX 的惯例，我们将初始化的图称为 `G`。
- en: Listing 18.7 Initializing a directed graph object
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.7 初始化有向图对象
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s slowly expand the directed graph. To start, we add a single node. Nodes
    can be added to a NetworkX graph object using the `add_node` method. Calling `G.add_
    node(0)` creates a single node whose adjacency matrix index is 0\. We can view
    this adjacency matrix by running `nx.to_numpy_array(G)`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步扩展有向图。首先，我们添加一个单独的节点。可以使用 `add_node` 方法将节点添加到 NetworkX 图对象中。调用 `G.add_node(0)`
    创建一个节点，其邻接矩阵索引为 0。我们可以通过运行 `nx.to_numpy_array(G)` 来查看这个邻接矩阵。
- en: Warning The `add_node` method always expands the graph’s adjacency matrix by
    a single node. This expansion happens regardless of the method input. Hence, `G.add_node(1000)`
    also creates a node whose adjacency matrix index is 0\. However, that node will
    also be tracked using a secondary index of 1000, which of course can lead to confusion.
    It’s a good practice to ensure that numeric inputs into `add_node` correspond
    to added adjacency matrix indices.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 `add_node` 方法始终通过单个节点扩展图的邻接矩阵。这种扩展无论输入方法如何都会发生。因此，`G.add_node(1000)` 也会创建一个邻接矩阵索引为
    0 的节点。然而，该节点还将使用 1000 的次级索引进行跟踪，这当然可能导致混淆。确保 `add_node` 中的数值输入与添加的邻接矩阵索引相对应是一个好习惯。
- en: Listing 18.8 Adding a single node to a graph object
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.8 向图对象添加单个节点
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our single node is associated with a NumPy web page. We can explicitly record
    this association by executing `G.nodes[0]['webpage'] = 'NumPy'`. The `G.nodes`
    datatype is a special class intended to track all the nodes in `G`. It is structured
    like a list. Running `G[i]` returns a dictionary of attributes associated with
    the node at `i`. These attributes are intended to help us track the identity of
    the node. In our case, we wish to assign a web page to the node, so we map a value
    to `G.nodes[i]['webpage']`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单一节点与NumPy网页相关联。我们可以通过执行`G.nodes[0]['webpage'] = 'NumPy'`显式记录这种关联。`G.nodes`数据类型是一个特殊类，旨在跟踪`G`中的所有节点。它类似于列表。运行`G[i]`返回与节点`i`关联的属性字典。这些属性旨在帮助我们跟踪节点的身份。在我们的情况下，我们希望将网页分配给节点，因此我们将值映射到`G.nodes[i]['webpage']`。
- en: 'The following code iterates across `G.nodes` and prints the attribute dictionary
    at `G.nodes[i]`. Our initial output represents a single node whose attribute dictionary
    is empty: we assign a web page to that node and print its dictionary again.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码遍历`G.nodes`并打印`G.nodes[i]`处的属性字典。我们的初始输出代表一个单独的节点，其属性字典为空：我们分配一个网页给该节点，然后再次打印其字典。
- en: Listing 18.9 Adding an attribute to an existing node
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.9 向现有节点添加属性
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can assign attributes directly while inserting a node into the graph. We
    just need to pass `attribute=some_value` into the `G.add_node` method. For instance,
    we are about to insert a node with an index of 1, which is associated with a SciPy
    web page. Executing `G.add_node(1, webpage='SciPy')` adds the node and its attribute.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在将节点插入图中时直接分配属性。我们只需要将`attribute=some_value`传递给`G.add_node`方法。例如，我们即将插入一个索引为1的节点，它与SciPy网页相关联。执行`G.add_node(1,
    webpage='SciPy')`将添加节点及其属性。
- en: Listing 18.10 Adding a node with an attribute
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.10 添加具有属性的节点
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we can output all the nodes together with their attributes simply
    by running `G.nodes(data=True)`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过简单地运行`G.nodes(data=True)`来输出所有节点及其属性。
- en: Listing 18.11 Outputting nodes together with their attributes
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.11 输出节点及其属性
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let’s add a web link from Node 1 (SciPy) to Node 0 (NumPy). Given a directed
    graph, we can insert an edge from `i` to `j` by running `G.add_edge(i, j)`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从节点1（SciPy）到节点0（NumPy）添加一个网页链接。给定一个有向图，我们可以通过运行`G.add_edge(i, j)`从`i`到`j`插入一条边。
- en: Listing 18.12 Adding a single edge to a graph object
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.12 向图形对象添加单条边
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From the printed adjacency matrix, we can observe an edge going from Node 1
    to Node 0\. Unfortunately, our matrix printouts will grow cumbersome as other
    nodes are added. Tracking 1s and 0s in a 2D table is not the most intuitive way
    to display a network. What if, instead, we plotted the network directly? Our two
    nodes could be plotted as two points in 2D space, and our single edge could be
    plotted as a line segment connecting these points. Such a plot can easily be generated
    using Matplotlib. That is why our `G` object has a built-in `draw()` method for
    plotting the graph with the Matplotlib library. We call `G.draw()` to visualize
    our graph (figure 18.2).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从打印的邻接矩阵中，我们可以观察到一条从节点1到节点0的边。不幸的是，随着其他节点的添加，我们的矩阵打印将变得繁琐。在二维表中跟踪1和0并不是显示网络的直观方式。如果我们直接绘制网络会怎么样呢？我们的两个节点可以绘制为二维空间中的两个点，而我们的单条边可以绘制为连接这些点的线段。这样的图可以使用Matplotlib轻松生成。这就是为什么我们的`G`对象有一个内置的`draw()`方法，用于使用Matplotlib库绘制图形。我们调用`G.draw()`来可视化我们的图形（图18.2）。
- en: '![](../Images/18-02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图18-02](../Images/18-02.png)'
- en: Figure 18.2 A visualized two-node directed graph. A barely visible directed
    arrow points from the lower node to the upper node.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2 一个可视化的两个节点的有向图。一个几乎看不见的有向箭头从下节点指向上节点。
- en: Listing 18.13 Plotting a graph object
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.13 绘制图形对象
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ The locations of the nodes are determined using a randomized algorithm. We
    seed that randomization to ensure consistent visualization.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 节点的位置使用随机算法确定。我们播种随机化以确保一致的可视化。
- en: ❷ Per Matplotlib requirements, we must call plt.show() to display the plotted
    results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据Matplotlib的要求，我们必须调用plt.show()来显示绘制的图形。
- en: 'Our plotted graph could clearly use some improvement. First, we need to make
    our arrow bigger. This can be accomplished using the `arrowsize` parameter: passing
    `arrowsize=20` into `G.draw` will double the length and width of the plotted arrow.
    We should also add labels to the nodes; labels can be plotted with the `labels`
    parameter, which takes as input a dictionary mapping between node IDs and the
    intended labels. Listing 18.14 generates the mapping by running `{i: G.nodes[i][''webpage'']
    for i in G.nodes}` and then replots our network with the node labels and larger
    arrow (figure 18.3).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '我们绘制的图形显然需要一些改进。首先，我们需要使箭头更大。这可以通过使用`arrowsize`参数来实现：将`arrowsize=20`传递给`G.draw`将使绘制的箭头的长度和宽度加倍。我们还应该给节点添加标签；标签可以通过`labels`参数绘制，该参数接受一个将节点ID映射到预期标签的字典。列表
    18.14 通过运行`{i: G.nodes[i][''webpage''] for i in G.nodes}`生成映射，然后使用节点标签和更大的箭头重新绘制我们的网络（图
    18.3）。'
- en: '![](../Images/18-03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片 18-03](../Images/18-03.png)'
- en: Figure 18.3 A visualized two-node directed graph. A directed arrow points from
    the lower node to the upper node. Both nodes are labeled, but the labels are hard
    to see.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.3 一个可视化的两个节点的有向图。一个指向上节点的有向箭头从下节点指向。两个节点都有标签，但标签难以看清。
- en: Note Additionally, we can modify the node size by passing a `node_size` parameter
    into `nx.draw`. But for the time being, our nodes are appropriately sized at their
    default value of 300.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此外，我们可以通过将`node_size`参数传递给`nx.draw`来修改节点大小。但就目前而言，我们的节点大小设置为默认值300，大小适中。
- en: Listing 18.14 Tweaking the graph visualization
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.14 调整图形可视化
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The arrow is now bigger, and the node labels are partially visible. Unfortunately,
    these labels are obscured by the dark node color. We can make the labels more
    visible by changing the node color to something lighter, like cyan. We adjust
    the node color by passing `node_color="cyan"` into `G.draw` (figure 18.4).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在箭头更大了，节点标签部分可见。不幸的是，这些标签被深色的节点颜色所遮挡。我们可以通过将节点颜色改为更浅的颜色（如青色）来使标签更易于识别。我们通过将`node_color="cyan"`传递给`G.draw`来调整节点颜色（图
    18.4）。
- en: '![](../Images/18-04.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片 18-04](../Images/18-04.png)'
- en: Figure 18.4 A visualized two-node directed graph. Both nodes are labeled. The
    color of the nodes has been adjusted so that the labels are clearly visible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.4 一个可视化的两个节点的有向图。两个节点都有标签。节点的颜色已经调整，以便标签清晰可见。
- en: Listing 18.15 Altering the node color
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.15 修改节点颜色
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In our latest plot, the labels are much more visible. We see the directed link
    from SciPy to NumPy. Now, let’s add a reverse web link from NumPy to SciPy (figure
    18.5).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最新的图表中，标签更加清晰可见。我们看到从SciPy到NumPy的定向链接。现在，让我们添加一个从NumPy到SciPy的反向网页链接（图 18.5）。
- en: '![](../Images/18-05.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片 18-05](../Images/18-05.png)'
- en: Figure 18.5 A visualized two-node directed graph. Pointed arrows are present
    at both ends of the edge between the nodes, indicating that the edge is bidirectional.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5 一个可视化的两个节点的有向图。在节点之间的边两端都有指向的箭头，表示该边是双向的。
- en: Listing 18.16 Adding a back-link between web pages
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.16 在网页之间添加反向链接
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are now ready to expand our network by adding two more web pages: Pandas
    and Matplotlib. These web pages will correspond to nodes with IDs `2` and `3`,
    respectively. We can insert the two nodes individually by calling `G.add_node(2)`
    and then `G.add_node(3)`. Alternatively, we can insert the nodes simultaneously
    using the `G.add_ nodes_from` method, which takes a list of nodes to be inserted
    into a graph. Thus, running `G.add_nodes_from([2, 3])` will add the proper node
    IDs to our network. However, these new nodes will lack any web page attribute
    assignments. Fortunately, the `G.add_nodes_from` method allows us to pass attribute
    values along with the node IDs. We simply need to pass `[(2, attributes_2), [(3,
    attributes_3)]` into the method. Essentially, we must pass a list of tuples corresponding
    to both node IDs and attributes. The attributes are stored in a dictionary that
    maps attribute names with attribute values. For instance, the Pandas `attributes_2`
    dictionary will equal `{''webpage'': ''Pandas'')`. Let’s insert these nodes, together
    with their attributes, and output `G.nodes(data=True)` to verify that the new
    nodes are present.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '我们现在准备通过添加两个更多的网页：Pandas 和 Matplotlib 来扩展我们的网络。这些网页将分别对应于 ID 为 `2` 和 `3` 的节点。我们可以通过调用
    `G.add_node(2)` 然后调用 `G.add_node(3)` 单独插入这两个节点。或者，我们可以使用 `G.add_nodes_from` 方法同时插入节点，该方法接受一个要插入图中的节点列表。因此，运行
    `G.add_nodes_from([2, 3])` 将将适当的节点 ID 添加到我们的网络中。然而，这些新节点将缺少任何网页属性分配。幸运的是，`G.add_nodes_from`
    方法允许我们传递属性值以及节点 ID。我们只需将 `[(2, attributes_2), [(3, attributes_3)]` 传递给该方法。本质上，我们必须传递一个与节点
    ID 和属性相对应的元组列表。属性存储在一个将属性名称映射到属性值的字典中。例如，Pandas 的 `attributes_2` 字典将等于 `{''webpage'':
    ''Pandas''}`。让我们插入这些节点，包括它们的属性，并输出 `G.nodes(data=True)` 以验证新节点是否存在。'
- en: Listing 18.17 Adding multiple nodes to a graph object
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.17 向图形对象添加多个节点
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve added two more nodes. Let’s visualize the updated graph (figure 18.6).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了两个更多的节点。让我们可视化更新后的图形（图 18.6）。
- en: '![](../Images/18-06.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/18-06.png)'
- en: Figure 18.6 A visualized web-page directed graph. The Pandas and Matplotlib
    pages remain disconnected.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.6 一个可视化的网页有向图。Pandas 和 Matplotlib 页面仍然未连接。
- en: Listing 18.18 Plotting the updated four-node graph
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.18 绘制更新的四节点图
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our current web link network is disconnected. We add two more web links: a
    link from Matplotlib (Node 3) to NumPy (Node 0), and a link from NumPy (Node 0)
    to Pandas (Node 2). These links can be added by calling `G.add_edge(3, 0)` and
    then `G.add_edge(0, 2)`. Alternatively, we can add the edges simultaneously using
    the `G.add_edges_from` method: this method takes as input a list of edges, where
    each edge is a tuple of the form `(i, j)`. Hence, running `G.add_edges_from([(0,
    2), (3, 0)])` should insert the two new edges into our graph. The following code
    inserts these edges and regenerates our plot (figure 18.7).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的网页链接网络是断开的。我们添加了两个更多的网页链接：从 Matplotlib（节点 3）到 NumPy（节点 0），以及从 NumPy（节点
    0）到 Pandas（节点 2）。这些链接可以通过调用 `G.add_edge(3, 0)` 然后调用 `G.add_edge(0, 2)` 来添加。或者，我们可以使用
    `G.add_edges_from` 方法同时添加边：该方法接受一个边列表作为输入，其中每个边都是一个形式为 `(i, j)` 的元组。因此，运行 `G.add_edges_from([(0,
    2), (3, 0)])` 应该将两个新边插入我们的图中。以下代码插入这些边并重新生成我们的图表（图 18.7）。
- en: '![](../Images/18-07.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/18-07.png)'
- en: Figure 18.7 A visualized web page directed graph. Two inbound links point at
    the NumPy page. All the other pages have at most one inbound link.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.7 一个可视化的网页有向图。有两个入链指向 NumPy 页面。所有其他页面最多只有一个入链。
- en: Listing 18.19 Adding multiple edges to a graph object
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.19 向图形对象添加多个边
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note In our graph visualization, the nodes have been spread apart to emphasize
    the connectivity of their respective edges. This effect was achieved using a technique
    known as a *force-directed layout* visualization. A force-directed layout is based
    on physics. The nodes are modeled as negatively charged particles that are repelled
    by one another, and the edges are modeled as springs connecting the particles.
    As the connected nodes move apart, the springs begin to pull them back together.
    Modeling the physics equations in this system produces our graph visualization.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在我们的图形可视化中，节点已经被分散开来以强调它们各自边的连接性。这种效果是通过一种称为*力导向布局*的可视化技术实现的。力导向布局基于物理原理。节点被建模为相互排斥的带负电荷的粒子，而边被建模为连接粒子的弹簧。当连接的节点相互远离时，弹簧开始将它们拉回。在这个系统中建模物理方程产生了我们的图形可视化。
- en: 'The NumPy web page appears in the center of our updated graph. Two web pages,
    SciPy and Matplotlib, have links that point to NumPy. All the other web pages
    have at most a single inbound link. More web content creators took the effort
    to reference the NumPy page than any other website: we can infer that NumPy is
    our most popular site since it has more inbound links than any other page. We’ve
    basically developed a simple metric for ranking websites on the internet. That
    metric equals the number of inbound edges pointing toward the site, also known
    as the *in-degree*. This is the opposite of the *out-degree*, which equals the
    number of edges pointing away from a site. By looking at our plotted graph, we
    can infer each website’s in-degree automatically. However, we can also compute
    the in-degree directly from the graph’s adjacency matrix. To demonstrate how,
    we first print our updated adjacency matrix.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 网页出现在我们更新的图的中心。两个网页，SciPy 和 Matplotlib，有指向 NumPy 的链接。所有其他网页最多只有一个入链。更多的网页内容创作者努力引用
    NumPy 页面，比任何其他网站都多：我们可以推断出 NumPy 是我们最受欢迎的网站，因为它比任何其他页面有更多的入链。我们基本上开发了一个简单的指标来衡量互联网上的网站排名。该指标等于指向网站的入链数量，也称为
    *入度*。这是 *出度* 的对立面，出度等于指向网站的边的数量。通过查看我们绘制的图，我们可以自动推断每个网站的入度。然而，我们也可以直接从图的邻接矩阵中计算入度。为了演示如何做到这一点，我们首先打印我们的更新后的邻接矩阵。
- en: Listing 18.20 Printing the updated adjacency matrix
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.20 打印更新的邻接矩阵
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As a reminder, the *i*th column in the matrix tracks the inbound edges of node
    `i`. The total number of inbound edges equals the number of ones in that column.
    Therefore, the sum of values in the column is equal to the node’s in-degree. For
    instance, Column 0 of our matrix equals `[0, 1, 0, 1]`. The sum of these values
    reveals an in-degree of 2, corresponding to the NumPy page. In general, executing
    `adjacency_matrix .sum(axis=0)` returns a vector of in-degrees. That vector’s
    largest element corresponds to the most popular page in our internet graph.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，矩阵中的第 *i* 列跟踪节点 `i` 的入边。入边的总数等于该列中 1 的数量。因此，该列值的总和等于节点的入度。例如，我们的矩阵的第 0
    列等于 `[0, 1, 0, 1]`。这些值的总和揭示了一个入度为 2，对应于 NumPy 页面。一般来说，执行 `adjacency_matrix .sum(axis=0)`
    返回一个入度向量。该向量的最大元素对应于我们互联网图中最受欢迎的页面。
- en: Note Our simple ranking system assumes that all inbound links have equal weight,
    but this is not the case. An inbound link from a very popular website carries
    more weight since it drives more traffic to the site. In the next section, we
    present a more sophisticated ranking algorithm called PageRank that incorporates
    the popularity of traffic-directing websites.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们的简单排名系统假设所有入链都拥有相同的权重，但这并不成立。来自非常受欢迎网站的入链具有更大的权重，因为它为该网站带来了更多的流量。在下一节中，我们将介绍一个更复杂的排名算法，称为
    PageRank，该算法结合了流量导向网站的受欢迎程度。
- en: Listing 18.21 Computing in-degrees using the adjacency matrix
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.21 使用邻接矩阵计算入度
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Alternatively, we can compute all in-degrees using the NetworkX `in_degree`
    method. Calling `G.in_degree(i)` returns the in-degree of node `i`, so we expect
    `G.in_degree(0)` to equal 2\. Let’s confirm.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 NetworkX 的 `in_degree` 方法来计算所有入度。调用 `G.in_degree(i)` 返回节点 `i` 的入度，因此我们期望
    `G.in_degree(0)` 等于 2。让我们来验证一下。
- en: Listing 18.22 Computing in-degrees using NetworkX
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.22 使用 NetworkX 计算入度
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code, we had to remember that `G.nodes[0]` corresponds to the NumPy
    page. Tracking the mapping between node IDs and page names can be slightly inconvenient,
    but we can bypass that inconvenience by assigning string IDs to individual nodes.
    For instance, given an empty graph `G2`, we insert our node IDs as strings by
    running `G2.add_nodes_from(['NumPy', 'SciPy', 'Matplotlib', 'Pandas'])`. Then
    calling `G2.in_degree('NumPy')` returns the in-degree of the NumPy page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们必须记住 `G.nodes[0]` 对应于 NumPy 页面。跟踪节点 ID 和页面名称之间的映射可能有些不便，但我们可以通过为单个节点分配字符串
    ID 来绕过这种不便。例如，给定一个空图 `G2`，我们通过运行 `G2.add_nodes_from(['NumPy', 'SciPy', 'Matplotlib',
    'Pandas'])` 将我们的节点 ID 作为字符串插入。然后调用 `G2.in_degree('NumPy')` 返回 NumPy 页面的入度。
- en: Note Storing node IDs as strings makes it more convenient to access certain
    nodes in the graph. However, the price of that convenience is a lack of correspondence
    between node IDs and indices in the adjacency matrix. As we’ll learn, the adjacency
    matrix is indispensable for certain network tasks, so it is usually good practice
    to store the node IDs as indices and not strings.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意将节点 ID 存储为字符串可以更方便地访问图中的某些节点。然而，这种便利的代价是节点 ID 与邻接矩阵中的索引之间缺乏对应关系。正如我们将学到的，邻接矩阵对于某些网络任务来说是必不可少的，因此通常将节点
    ID 存储为索引而不是字符串是良好的实践。
- en: Listing 18.23 Using strings as node IDs in a graph
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.23 在图中使用字符串作为节点 ID
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Given a set of node attributes and a set of edges, we can generate the graph
    in just three lines of code. This pattern proves useful in many network problems.
    Commonly, when dealing with graph data, data scientists are provided with two
    files: one containing all the node attributes and another containing the linkage
    information. For instance, in this case study, we are provided with a table of
    FriendHook profiles as well as a table of existing friendships. These friendships
    serve as edges, which can be loaded by calling `add_edges_from`. Meanwhile, the
    profile information depicts attributes of each user in the friendship graph. After
    proper preparation, the profiles can be mapped back to the nodes by calling `add_nodes_from`.
    Thus, it’s very straightforward to load the FriendHook graph into NetworkX for
    further analysis.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组节点属性和一组边，我们只需三行代码就能生成图。这种模式在许多网络问题中非常有用。通常，当处理图数据时，数据科学家会提供两个文件：一个包含所有节点属性，另一个包含链接信息。例如，在本案例研究中，我们提供了一个
    FriendHook 个人资料表以及一个现有友谊表。这些友谊作为边，可以通过调用 `add_edges_from` 来加载。同时，个人资料信息描述了友谊图中每个用户的属性。经过适当的准备，这些个人资料可以通过调用
    `add_nodes_from` 映射回节点。因此，将 FriendHook 图加载到 NetworkX 进行进一步分析非常直接。
- en: Introductory NetworkX graph methods
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 网络X图方法入门
- en: '`G = nx.DiGraph()`—Initializes a new directed graph.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G = nx.DiGraph()`—初始化一个新的有向图。'
- en: '`G.add_node(i)`—Creates a new node with index `i`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.add_node(i)`—创建一个索引为 `i` 的新节点。'
- en: '`G.nodes[i][''attribute''] = x`—Assigns an attribute `x` to node `i`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.nodes[i][''attribute''] = x`—将属性 `x` 分配给节点 `i`。'
- en: '`G.add_node(i, attribute=x)`—Creates a new node `i` with attribute `x`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.add_node(i, attribute=x)`—创建一个具有属性 `x` 的新节点 `i`。'
- en: '`G.add_nodes_from([i, j])`—Creates new nodes with indices `i` and `j`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.add_nodes_from([i, j])`—创建索引为 `i` 和 `j` 的新节点。'
- en: '`G.add_nodes_from([(i, {''a'': x}), (j, {''a'': y})]`—Creates new nodes with
    indices `i` and `j`. The attribute `a` of each new node is set to `x` and `y`,
    respectively.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.add_nodes_from([(i, {''a'': x}), (j, {''a'': y})]`—创建具有索引 `i` 和 `j` 的新节点。每个新节点的属性
    `a` 分别设置为 `x` 和 `y`。'
- en: '`G.add_edge(i, j)`—Creates an edge going from node `i` to node `j`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.add_edge(i, j)`—创建从节点 `i` 到节点 `j` 的边。'
- en: '`G.add_edges_from([(i, j), (k, m)])`—Creates new edges going from `i` to `j`
    and from `k` to `m`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.add_edges_from([(i, j), (k, m)])`—创建从 `i` 到 `j` 和从 `k` 到 `m` 的新边。'
- en: '`nx.draw(G)`—Plots graph `G`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.draw(G)`—绘制图 `G`。'
- en: So far, we’ve focused on directed graphs, in which traversal between nodes is
    limited. Each directed edge is like a one-way street that forbids travel in a
    certain direction. What if, instead, we treated every edge as though it were a
    two-way street? Our edges would be *undirected*, and we’d obtain an *undirected
    graph*. In an undirected graph, we can traverse connected nodes in either direction.
    This paradigm doesn’t apply to the directed network underlying the internet, but
    it applies to the undirected network of roads connecting cities throughout the
    world. In the next subsection, we analyze road travel using undirected graphs.
    Later, we’ll utilize these graphs to optimize the travel time between towns.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注有向图，其中节点之间的遍历是有限的。每个有向边就像一条单行道，禁止向某个方向行驶。如果我们把每条边都当作双向道来处理会怎样？我们的边就会是**无向的**，从而得到一个**无向图**。在无向图中，我们可以以任意方向遍历连接的节点。这种模式不适用于互联网背后的有向网络，但它适用于连接世界各地的城市的无向道路网络。在下一个小节中，我们将使用无向图分析道路旅行。稍后，我们将利用这些图来优化城镇之间的旅行时间。
- en: 18.2 Utilizing undirected graphs to optimize the travel time between towns
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 利用无向图优化城镇间的旅行时间
- en: In business logistics, product delivery time can impact certain critical decisions.
    Consider the following scenario, in which you’ve opened your own kombucha brewery.
    Your plan is to deliver batches of the delicious fermented tea to all the towns
    within a reasonable driving radius. More specifically, you’ll only deliver to
    a town if it’s within a two-hour driving distance of the brewery; otherwise, the
    gas costs won’t justify the revenue from that delivery. A grocery store in a neighboring
    county is interested in regular deliveries. What is the fastest driving time between
    your brewery and that store?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业物流中，产品交付时间可能会影响某些关键决策。考虑以下场景，您已经开设了自己的 kombucha 酿酒厂。您的计划是将美味的发酵茶批量运送到合理驾驶半径内的所有城镇。更具体地说，只有当城镇在酿酒厂两小时驾驶距离内时，您才会向该城镇运送；否则，汽油成本将无法证明该次运送的收益。邻县的一家杂货店对定期送货感兴趣。您的酿酒厂和该商店之间的最快驾驶时间是多少？
- en: Normally, you could obtain the answer by searching for directions on a smartphone,
    but we’ll assume that existing tech solutions are not available (perhaps the area
    is remote and the local maps have not been scanned into an online database). In
    other words, you need to replicate the travel time computations carried out by
    existing smartphone tools. To do this, you consult a printed map of the local
    area. On the map, roads zigzag between towns, and some towns connect directly
    via a road. Conveniently, the travel times between connected towns are illustrated
    clearly on the map. We can model these connections using undirected graphs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以通过在智能手机上搜索路线来获得答案，但我们将假设现有的技术解决方案不可用（可能该地区偏远，当地地图尚未扫描到在线数据库中）。换句话说，您需要复制现有智能手机工具执行的计算旅行时间。为此，您需要查阅当地地区的印刷地图。在地图上，道路在城镇之间蜿蜒，一些城镇通过道路直接相连。方便的是，连接城镇之间的旅行时间在地图上被清楚地表示出来。我们可以使用无向图来模拟这些连接。
- en: Suppose that a road connects two towns, Town 0 and Town 1\. The driving time
    between the towns is 20 minutes. Let’s record this information in an undirected
    graph. First, we generate the graph in NetworkX by running `nx.Graph()`. Next
    we add an undirected edge to that graph by executing `G.add_edge(0, 1)`. Finally,
    we add the drive time as an attribute of the inserted edge by running `G[0][1]['travel_time']
    = 20`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一条道路连接了两个城镇，城镇0和城镇1。这两个城镇之间的驾驶时间是20分钟。让我们将这个信息记录在一个无向图中。首先，我们通过运行`nx.Graph()`在NetworkX中生成图。接下来，我们通过执行`G.add_edge(0,
    1)`向该图添加一个无向边。最后，我们通过运行`G[0][1]['travel_time'] = 20`将驾驶时间作为插入边的属性。
- en: Listing 18.24 Creating a two-node undirected graph
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.24 创建一个两节点无向图
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our travel time is an attribute of the edge `(0, 1)`. Given an attribute `k`
    of edge `(i, j)`, we can access that attribute by running `G[i][j][k]`, so we
    can access the travel time by running `G[0][1]['travel_time']`. In our undirected
    graph, the travel time between towns is not dependent on direction, so `G[1][0]['travel_time']`
    also equals 20.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅行时间是边`(0, 1)`的一个属性。给定边`(i, j)`的属性`k`，我们可以通过运行`G[i][j][k]`来访问该属性，因此我们可以通过运行`G[0][1]['travel_time']`来访问旅行时间。在我们的无向图中，城镇之间的旅行时间不依赖于方向，所以`G[1][0]['travel_time']`也等于20。
- en: Listing 18.25 Checking the edge attribute of a graph
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.25 检查图的边属性
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Towns 1 and 0 are connected on our map. However, not all towns are directly
    connected. Imagine an additional Town 2 that is connected to Town 1 but not Town
    0\. There is no road between Town 0 and Town 2, but there *is* a road between
    Town 1 and Town 2\. The travel time on that road is 15 minutes. Let’s add this
    new connection to our graph. We add the edge and travel time in a single line
    of code by executing `G.add_edge(1, 2, travel_time=15)`, and then we visualize
    the graph using `nx.draw`. We set the visualized node labels to equal the node
    IDs by passing `with_labels=True` into the `draw` function (figure 18.8).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的地图上，城镇1和城镇0是相连的。然而，并非所有城镇都是直接相连的。想象一下有一个额外的城镇2，它与城镇1相连，但与城镇0不相连。城镇0和城镇2之间没有道路，但城镇1和城镇2之间有道路。这条路上的旅行时间是15分钟。让我们将这个新的连接添加到我们的图中。我们通过执行单行代码`G.add_edge(1,
    2, travel_time=15)`来添加边和旅行时间，然后使用`nx.draw`可视化图形。我们将可视化的节点标签设置为等于节点ID，通过将`with_labels=True`传递给`draw`函数（图18.8）。
- en: '![](../Images/18-08.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/18-08.png)'
- en: Figure 18.8 A visualized travel path from Town 0 to Town 2 by way of Town 1
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.8 通过城镇1从城镇0到城镇2的可视化旅行路径
- en: Listing 18.26 Visualizing a path between multiple towns
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.26 可视化多个城镇之间的路径
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Traveling from Town 0 to Town 2 requires us to first traverse Town 1\. Hence,
    the total travel time is equal to the sum of `G[0][1]['travel_time']` and `G[1][2]['travel_
    time']`. Let’s compute that travel time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从城镇0到城镇2的旅行需要我们首先穿越城镇1。因此，总旅行时间等于`G[0][1]['travel_time']`和`G[1][2]['travel_time']`的和。让我们计算那个旅行时间。
- en: Listing 18.27 Computing the travel time between towns
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.27 计算城镇之间的旅行时间
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We’ve computed the fastest travel time between the two towns. Our computation
    was trivial since there is just one route between Town 0 and Town 2\. However,
    in real life, many routes can exist between localized towns. Optimizing driving
    times between multiple towns is not so simple. To illustrate this point, let’s
    build a graph containing more than a dozen towns spread across multiple counties.
    In our graph model, the travel time between towns will increase when towns are
    in different counties. We’ll assume the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经计算了两个城镇之间的最快旅行时间。我们的计算很简单，因为城镇0和城镇2之间只有一条路线。然而，在现实生活中，在局部城镇之间可能存在许多路线。优化多个城镇之间的驾驶时间并不简单。为了说明这一点，让我们构建一个包含十几个城镇的图，这些城镇分布在多个县。在我们的图模型中，当城镇位于不同的县时，城镇之间的旅行时间会增加。我们将假设以下情况：
- en: Our towns are located in six different counties.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的城市位于六个不同的县。
- en: Each county contains 3 to 10 towns.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个县包含3到10个城镇。
- en: 90% of the towns in a single county are directly connected by roads. The average
    travel time on a county road is 20 minutes.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个县中的90%的城镇直接通过道路连接。县内道路的平均旅行时间为20分钟。
- en: 5% of the towns across different counties are directly connected by a road.
    The average travel time on an intra-county road is 45 minutes.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同县之间的城镇中有5%直接通过道路连接。县内道路的平均旅行时间为45分钟。
- en: We’ll now model this scenario. Then we’ll devise an algorithm to compute the
    fastest travel time between any two towns in our complex network.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将模拟这个场景。然后我们将设计一个算法来计算我们复杂网络中任意两个城镇之间的最快旅行时间。
- en: Common NetworkX methods and attribute assignments
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的NetworkX方法和属性分配
- en: '`G = nx.Graph()`—Initializes a new undirected graph'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G = nx.Graph()`—初始化一个新的无向图'
- en: '`G.nodes[i][''attribute''] = x`—Assigns an attribute `x` to node `i`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.nodes[i][''attribute''] = x`—将属性`x`分配给节点`i`'
- en: '`G[i][j][''attribute''] = x`—Assigns an attribute `x` to edge `(i, j)`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G[i][j][''attribute''] = x`—将属性`x`分配给边`(i, j)`'
- en: 18.2.1 Modeling a complex network of towns and counties
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.1 建模城镇和县的网络
- en: Let’s start by modeling a single county that contains five towns. First, we
    insert five nodes into an empty graph. Each node is assigned a `county_id` attribute
    of 0, indicating that all nodes belong to the same county.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先模拟一个包含五个城镇的单个县。首先，我们将五个节点插入到空图中。每个节点都被分配一个`county_id`属性为0，表示所有节点都属于同一个县。
- en: Listing 18.28 Modeling five towns in the same county
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.28 在同一县建模五个城镇
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we assign random roads to our five towns (figure 18.9). We iterate over
    each combination of node pairs and flip a biased coin. The coin lands on heads
    90% of the time: whenever we see heads, we add an edge between the pair of nodes.
    Each edge’s `travel_time` parameter is chosen at random by sampling from a normal
    distribution whose mean is 20.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将随机道路分配给我们的五个城镇（图18.9）。我们遍历节点对的每个组合并抛一个有偏的硬币。硬币有90%的概率落在正面：每次我们看到正面，我们就在这对节点之间添加一个边。每条边的`travel_time`参数是通过从均值为20的正态分布中采样随机选择的。
- en: '![](../Images/18-09.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-09.png)'
- en: Figure 18.9 A randomly generated road network in a five-town county
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.9 在五个城镇县中随机生成的道路网络
- en: Note As a reminder, the normal distribution is a bell-shaped curve commonly
    used to analyze random processes in probability and statistics. Refer back to
    section 6 for a more detailed discussion of that curve.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：作为提醒，正态分布是一种钟形曲线，常用于分析概率和统计学中的随机过程。请参阅第6节以获取对该曲线的更详细讨论。
- en: Listing 18.29 Modeling random intra-county roads
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.29 建模县内的随机道路
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The function attempts to generate a random edge between node1 and node2 in
    graph G. The probability of edge insertion is equal to prob_road. If an edge is
    inserted, a randomized travel time attribute is assigned. The travel time is chosen
    from a normal distribution with a mean of mean_travel_time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数尝试在图G中生成节点1和节点2之间的随机边。边插入的概率等于prob_road。如果插入边，则分配一个随机的旅行时间属性。旅行时间是从均值为mean_travel_time的正态分布中选择的。
- en: ❷ Flips a coin to determine whether an edge is inserted
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 抛硬币以确定是否插入边缘
- en: ❸ Chooses the travel time from a normal distribution
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从正态分布中选择旅行时间
- en: 'We’ve connected most of the towns in County 0\. In this same manner, we can
    randomly generate roads and towns for a second county: County 1\. Here, we generate
    County 1 and store that output in a separate graph (figure 18.10). The number
    of towns in County 1 is a randomly chosen value between 3 and 10.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经连接了县0中的大多数城镇。以同样的方式，我们可以为第二个县：县1随机生成道路和城镇。在这里，我们生成县1并将其输出存储在单独的图中（图18.10）。县1中的城镇数量是在3到10之间随机选择的值。
- en: Listing 18.30 Modeling a second random county
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.30 建模第二个随机县
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Generates a random county graph
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成一个随机的县图
- en: ❷ Chooses the number of towns in the county at random from an integer range
    of 3 to 10
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从3到10的整数范围内随机选择县中的城镇数量
- en: ❸ Randomly adds intra-county roads
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 随机添加县内道路
- en: '![](../Images/18-10.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-10.png)'
- en: Figure 18.10 A randomly generated road network in a second county. The number
    of towns in the county has also been chosen at random.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.10 第二个县中随机生成的道路网络。县中的城镇数量也已被随机选择。
- en: 'Currently, County 1 and County 2 are stored in two separate graphs: `G` and
    `G2`. We need to somehow combine these graphs. Merging the graphs is made more
    difficult by the shared IDs of nodes in `G` and `G2`. Fortunately, our task is
    simplified by the `nx.disjoint_union` function, which takes as input two graphs:
    `G` and `G2`. It then resets each node ID to a unique value between 0 and the
    total node count. Finally, it merges the two graphs. Here, we execute `nx.disjoint_union(G,
    G2)` and then plot the results (figure 18.11).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，县1和县2存储在两个独立的图中：`G`和`G2`。我们需要以某种方式合并这些图。由于`G`和`G2`中节点的共享ID，合并图变得更加困难。幸运的是，`nx.disjoint_union`函数简化了我们的任务，它接受两个图作为输入：`G`和`G2`。然后它将每个节点ID重置为0到总节点数之间的唯一值。最后，它合并这两个图。在这里，我们执行`nx.disjoint_union(G,
    G2)`然后绘制结果（图18.11）。
- en: '![](../Images/18-11.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-11.png)'
- en: Figure 18.11 Two county networks merged together
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.11 两个县网络合并在一起
- en: Listing 18.31 Merging two separate graphs
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.31 合并两个独立的图
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our two counties appear in the same graph. Each town in the graph is assigned
    a unique ID. Now it’s time to generate random roads between the counties (figure
    18.12). We iterate over all the pairs of inter-county nodes (in which `G[n1]['county_id']
    != G[n2]['county_id']`. For each node pair, we apply `add_random_edge`. The probability
    of the edge is set low to 0.05, and the average travel time is set high to 90
    minutes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个县出现在同一个图中。图中的每个城镇都被分配了一个唯一的ID。现在是我们生成县之间的随机道路的时候了（图18.12）。我们遍历所有跨县节点对（其中`G[n1]['county_id']
    != G[n2]['county_id']`）。对于每个节点对，我们应用`add_random_edge`。边的概率设置为低，为0.05，平均旅行时间设置为高，为90分钟。
- en: '![](../Images/18-12.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-12.png)'
- en: Figure 18.12 Two county networks connected by random roads
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.12 通过随机道路连接的两个县网络
- en: Listing 18.32 Adding random inter-county roads
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.32 添加随机跨县道路
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Adds random edges between nodes in graph G whose county IDs do not match
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在图G中添加不匹配县ID的节点之间的随机边
- en: ❷ Iterates over every node and its associated attributes
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历每个节点及其关联的属性
- en: ❸ Iterates over node pairs that we have not yet compared
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历我们尚未比较的节点对
- en: ❹ Attempts to add a random inter-county edge
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 尝试添加一个随机的跨县边
- en: We’ve successfully simulated two interconnected counties. Now we simulate six
    interconnected counties (figure 18.13).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地模拟了两个相互连接的县。现在我们模拟六个相互连接的县（图18.13）。
- en: '![](../Images/18-13.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-13.png)'
- en: Figure 18.13 Six county networks connected by random roads
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.13 通过随机道路连接的六个县网络
- en: Listing 18.33 Simulating six interconnected counties
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.33 模拟六个相互连接的县
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ve visualized our six-county graph, but individual counties are tricky to
    decipher in the visualization. Fortunately, we can improve our plot by coloring
    each node based on county ID. Doing so requires that we modify our input into
    the `node_color` parameter: rather than passing a single color string, we’ll pass
    a list of color strings. The *i*th color in the list will correspond to the assigned
    color of the node at index `i`. The following code ensures that nodes in different
    counties receive different color assignments, while nodes that share a county
    are assigned the same color (figure 18.14).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可视化了我们的六个县图，但在可视化中区分各个县是困难的。幸运的是，我们可以通过根据县ID着色每个节点来改进我们的绘图。这样做需要我们修改输入到`node_color`参数：而不是传递一个单独的颜色字符串，我们将传递一个颜色字符串列表。列表中的第*i*个颜色将对应于索引`i`的节点的分配颜色。以下代码确保不同县的节点接收不同的颜色分配，而共享同一个县的节点分配相同的颜色（图18.14）。
- en: '![](../Images/18-14.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-14.png)'
- en: Figure 18.14 Six county networks connected by random roads. The individual towns
    have been colored based on county ID.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.14 六个通过随机道路连接的县网络。各个城镇根据县ID着色。
- en: Listing 18.34 Coloring nodes by county
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.34 根据县对节点进行着色
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The individual counties are now visible. Most counties form tight clumps in
    the network. Later, we extract these clumps automatically using network clustering.
    For now, we focus our attention on computing the fastest travel time between nodes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以清楚地看到各个县。大多数县在网络中形成紧密的簇。稍后，我们将自动提取这些簇使用网络聚类。现在，我们专注于计算节点之间的最快旅行时间。
- en: Common NetworkX graph visualization functions
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的NetworkX图可视化函数
- en: '`nx.draw(G)`—Plots graph `G`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.draw(G)`—绘制图`G`。'
- en: '`nx.draw(G, labels=True)`—Plots graph `G` with node labels. The labels equal
    the node IDs.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.draw(G, labels=True)`—绘制带有节点标签的图`G`。标签等于节点ID。'
- en: nx`.draw(G, labels=ids_to_labels)`—Plots graph `G` with node labels. The nodes
    are labeled using a mapping between nodes IDs and labels. That mapping is specified
    by the `ids_to_labels` dictionary.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.draw(G, labels=ids_to_labels)`—绘制带有节点标签的图`G`。节点使用节点ID和标签之间的映射进行标记。该映射由`ids_to_labels`字典指定。'
- en: '`nx.draw(G, node_color=c)`—Plots graph `G`. All nodes are colored using `color
    c`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.draw(G, node_color=c)`—绘制图`G`。所有节点都使用`color c`着色。'
- en: '`nx.draw(G, node_color=ids_to_colors)`—Plots graph `G`. All nodes are colored
    using a mapping between node IDs and colors. That mapping is specified by the
    `ids_to_colors` dictionary.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.draw(G, node_color=ids_to_colors)`—绘制图`G`。所有节点都使用节点ID和颜色之间的映射进行着色。该映射由`ids_to_colors`字典指定。'
- en: '`nx.draw(G, arrowsize=20)`—Plots directed graph `G` while increasing the arrow
    size of the graph’s directed edges.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.draw(G, arrowsize=20)`—绘制带有增加的箭头大小的有向图`G`。'
- en: '`nx.draw(G, node_size=20)`—Plots graph `G` while decreasing the node size from
    a default value of 300 to 20\.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.draw(G, node_size=20)`—绘制图`G`，将节点大小从默认值300减小到20。'
- en: 18.2.2 Computing the fastest travel time between nodes
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.2 计算节点之间的最快旅行时间
- en: 'Suppose our brewery is located in Town 0 and our potential client is located
    in Town 30\. We want to determine the fastest travel time between Town 0 and Town
    30\. In the process, we need to compute the fastest travel time between Town 0
    and every other town. How do we do this? Initially, all we know is the trivial
    travel time between Town 0 and itself: 0 minutes. Let’s record this travel time
    in a `fastest_times` dictionary. Later, we populate this dictionary with the travel
    times to every town.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的酿酒厂位于城镇0，我们的潜在客户位于城镇30。我们想要确定城镇0和城镇30之间的最快旅行时间。在这个过程中，我们需要计算城镇0和每个其他城镇之间的最快旅行时间。我们如何做到这一点？最初，我们所知道的是城镇0与其自身的平凡旅行时间：0分钟。让我们将这个旅行时间记录在`fastest_times`字典中。稍后，我们将这个字典填充到每个城镇的旅行时间。
- en: Listing 18.35 Tracking the fastest-known travel times
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.35 跟踪已知的最快旅行时间
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we can answer a simple question: what is the known travel distance between
    Town 0 and its neighboring towns? Neighbors, in this context, are towns with roads
    connecting to Town 0\. In NetworkX, we can access the neighbors of Town 0 by executing
    `G.neighbors(0)`. That method call returns an iterable over the IDs of nodes connecting
    to node 0\. Alternatively, we can access the neighbors by running `G[0]`. Here,
    we output the IDs of all the neighboring towns.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以回答一个简单的问题：已知从城镇0到其相邻城镇的旅行距离是多少？在这个上下文中，“相邻”是指与城镇0相连的城镇。在NetworkX中，我们可以通过执行`G.neighbors(0)`来访问城镇0的邻居。这个方法调用返回一个包含连接到节点0的节点ID的可迭代对象。或者，我们也可以通过运行`G[0]`来访问邻居。在这里，我们输出所有相邻城镇的ID。
- en: Listing 18.36 Accessing the neighbors of Town 0
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.36 访问城镇0的邻居
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we record the travel times between Town 0 and each of its five neighbors
    and use these times to update `fastest_times`. Additionally, we output the travel
    times in sorted order for further analysis.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们记录城镇0与其五个邻居之间的旅行时间，并使用这些时间来更新`fastest_times`。此外，我们以排序顺序输出旅行时间，以便进行进一步分析。
- en: Listing 18.37 Tracking the travel times to neighboring towns
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.37 跟踪到相邻城镇的旅行时间
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It takes approximately 45 minutes to drive from Town 0 to Town 13\. Is this
    the fastest travel time between these two towns? Not necessarily! A detour through
    another town may speed up travel, as shown in figure 18.15.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从城镇0开车到城镇13大约需要45分钟。这是这两个城镇之间最快的旅行时间吗？不一定！通过另一个城镇绕行可能会加快旅行速度，如图18.15所示。
- en: '![](../Images/18-15.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-15.png)'
- en: Figure 18.15 The roads connecting Town 0 to its neighbors are highlighted with
    thick, dark edges. The travel times across these five roads are known. It is possible
    that faster travel routes exist, but these routes would require additional detours.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.15 使用粗黑边突出显示了连接城镇0与其邻居的道路。这些五条道路的旅行时间是已知的。可能存在更快的旅行路线，但这些路线将需要额外的绕行。
- en: 'Consider, for instance, a detour through Town 7\. It’s our most proximate town,
    with a drive time of only 18 minutes. What if there’s a road between Town 7 and
    Town 13? If that road exists, and its travel time is under 27 minutes, then a
    faster route to Town 13 is possible! The same logic applies to Towns 3, 4, and
    6\. We can potentially shave minutes off our travel time if we examine the neighbors
    of Town 7\. Let’s carry out that examination like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑通过城镇7的绕行。这是我们最近的城镇，驾驶时间仅为18分钟。如果城镇7和城镇13之间存在一条道路，并且其旅行时间低于27分钟，那么前往城镇13的路线可能会更快！相同的逻辑也适用于城镇3、4和6。如果我们检查城镇7的邻居，我们可能可以减少旅行时间。让我们这样进行考察：
- en: Obtain the neighbors of Town 7.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取城镇7的邻居。
- en: Obtain the travel time between Town 7 and every neighboring Town *N*.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取城镇7与每个相邻城镇*N*之间的旅行时间。
- en: Add 18.04 minutes to the travel time obtained in the previous step. This represents
    the travel time between Town 0 and Town *N* when we take a detour through Town
    7.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上一步获得的旅行时间增加18.04分钟。这代表当我们通过城镇7绕行时，从城镇0到城镇*N*的旅行时间。
- en: If *N* is present in `fastest_times`, check whether the detour is faster than
    `fastest_times[N]`. If an improvement is discovered, update `fastest_times` and
    print the faster travel time.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*N*在`最快时间`中，检查绕行是否比`最快时间[N]`更快。如果发现改进，则更新`最快时间`并打印更快的旅行时间。
- en: If *N* is not present in `fastest_times`, update that dictionary with the travel
    time computed in step 3\. This represents the travel time between Town 0 and Town
    *N* when a direct road does not link the two towns.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*N*不在`最快时间`中，则使用步骤3中计算的旅行时间更新该字典。这代表当两个城镇之间没有直接道路连接时，从城镇0到城镇*N*的旅行时间。
- en: The following code executes these steps.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行这些步骤。
- en: Listing 18.38 Searching for faster detours through Town 7
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.38 通过城镇7寻找更快的绕行路线
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Checks whether a detour through town_id alters the fastest known travel times
    from Town 0 to other towns
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查通过town_id的绕行是否改变了从城镇0到其他城镇的最快已知旅行时间
- en: ❷ The travel time between Town 0 and town_id
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 城镇0和town_id之间的旅行时间
- en: ❸ The detour time from Town 0 to a neighbor of town_id
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从城镇0到town_id邻居的绕行时间
- en: ❹ Checks if the detour improved the fastest known travel time from Town 0 to
    n
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查绕行是否改善了从城镇0到n的最快已知旅行时间
- en: ❺ Records the fastest known travel time from Town 0 to n
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 记录从城镇0到n的最快已知旅行时间
- en: ❻ Checks how many new towns have been added to fastest_times in addition to
    the six towns that were initially present in the dictionary
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查除了字典中最初存在的六个城镇外，还有多少新城镇被添加到最快时间中
- en: 'We’ve uncovered travel times to three additional towns, but we have not found
    any faster detours for travel to neighbors of Town 0\. Still, those detours might
    exist. Let’s choose another viable detour candidate. We’ll select a town that’s
    proximate to Town 0, whose neighbors we have not examined. Doing so requires that
    we do the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经发现了前往三个额外城镇的旅行时间，但我们还没有找到前往城镇0邻居的更快的绕行路线。然而，这些绕行路线可能存在。让我们选择另一个可行的绕行候选者。我们将选择一个靠近城镇0的城镇，其邻居我们尚未检查。这样做需要我们执行以下操作：
- en: Combine the neighbors of Town 0 and Town 7 into a pool of detour candidates.
    Note that both Town 0 and Town 7 will be present in that pool, thus necessitating
    the next step.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将城镇0和城镇7的邻居合并为一个绕行候选者池。请注意，城镇0和城镇7将存在于该池中，因此需要下一步。
- en: Remove Town 0 and Town 7 from the pool of candidates, leaving behind a set of
    unexamined towns.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从候选者池中移除城镇0和城镇7，留下未检查的城镇集合。
- en: Select an unexamined town with the fastest known travel time to Town 0.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个具有前往城镇0最快已知旅行时间的未检查城镇。
- en: Let’s run these steps to choose our next detour candidate, using the logic visualized
    in figure 18.16.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这些步骤来选择我们的下一个绕行候选者，使用图18.16中可视化的逻辑。
- en: '![](../Images/18-16.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图18-16](../Images/18-16.png)'
- en: Figure 18.16 Direct detours taken through Town 7 to reach the neighbors of Town
    0 are highlighted with thick, dark edges. The detours did not improve our driving
    times. Perhaps an additional detour through Town 3 will yield improved results.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.16 通过城镇7直接绕行到城镇0的邻居用粗黑边突出显示。这些绕行并没有改善我们的驾驶时间。也许通过城镇3的额外绕行会产生更好的结果。
- en: Listing 18.39 Selecting an alternative detour candidate
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.39 选择替代绕行候选
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ The pool of detour candidates combines the neighbors of Town 0 and Town 7\.
    Note that both of these towns are neighbors of each other. Thus, they need to
    be removed from the candidate set.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绕行候选池结合了城镇0和城镇7的邻居。请注意，这两个城镇都是彼此的邻居。因此，它们需要从候选集中删除。
- en: ❷ Removes all previously examined towns from the candidate set
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从候选集中删除所有先前检查的城镇
- en: ❸ Selects a detour candidate with the fastest known travel time to Town 0
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择到城镇0最快的已知旅行时间的绕行候选
- en: 'Our next detour candidate is Town 3\. We check Town 3 for detours: examining
    this town’s neighbors may reveal new, unexamined towns. We insert all such towns
    into `unexaminedTowns`, which will allow us to track the remaining detour candidates
    for further analysis. Note that candidate tracking requires us to shift Town 3
    from `unexaminedTowns` to `examinedTowns` after examination.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个绕行候选是城镇3。我们检查城镇3的绕行情况：检查这个城镇的邻居可能会揭示新的、未检查的城镇。我们将所有这样的城镇插入到`unexaminedTowns`中，这将使我们能够跟踪剩余的绕行候选以进行进一步分析。请注意，候选跟踪要求我们在检查后，将城镇3从`unexaminedTowns`转移到`examinedTowns`。
- en: Listing 18.40 Searching for faster detours through Town 3
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.40 通过城镇3寻找更快的绕行路线
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Examines Town 3 for possible detours
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查城镇3的可能的绕行
- en: ❷ This helper function obtains the neighbors of Town 3 that are not yet included
    in our set of detour candidates.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此辅助函数获取尚未包含在我们绕行候选集的城镇3的邻居。
- en: ❸ This helper shifts Town 3 to examinedTowns after examination.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在检查后，此辅助函数将城镇3转移到`examinedTowns`。
- en: 'Once again, no detours were discovered. However, nine detour candidates remain
    in our `unexaminedTowns` set. Let’s examine the remaining candidates. Listing
    18.41 iteratively does the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，没有发现绕行路线。然而，我们的`unexaminedTowns`集中还有九个绕行候选。让我们检查剩余的候选。列表18.41 逐个检查每个城镇以寻找更快的绕行路线：
- en: Select an unexamined town with the fastest known travel time to Town 0.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个到城镇0最快的已知旅行时间的未检查城镇。
- en: Check that town for detours using `examine_detour`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`examine_detour`检查该城镇的绕行。
- en: Shift the town’s ID from `unexaminedTowns` to `examinedTowns`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将城镇的ID从`unexaminedTowns`转移到`examinedTowns`。
- en: Repeat step 1 if any unexamined towns remain. Terminate otherwise.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还有未检查的城镇，请重复步骤1。否则终止。
- en: Listing 18.41 Examining every town for faster detours
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.41 检查每个城镇以寻找更快的绕行路线
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ The iteration continues until every possible town has been examined.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 迭代继续，直到检查了每个可能的城镇。
- en: ❷ Selects a new detour candidate based on the fastest travel time to Town 0
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据到城镇0最快的旅行时间选择新的绕行候选
- en: ❸ Examines the candidate for detours
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查候选绕行
- en: ❹ Removes the candidate from unexamined-Towns
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从未检查的城镇中删除候选
- en: ❺ Adds previously unseen neighbors of the candidate to unexaminedTowns
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将候选的先前未见过的邻居添加到`unexaminedTowns`
- en: 'We’ve examined the travel time to every single town and discovered five possible
    detours. Two of the detours are directed through Town 28: they reduce the travel
    times to Towns 29 and 30 from 2.1 hours to 1.8 hours, so both towns fall in a
    viable driving range for our kombucha brewery.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了每个城镇的旅行时间，并发现了五个可能的绕行路线。其中两条绕行路线是通过城镇28进行的：它们将城镇29和30的旅行时间从2.1小时减少到1.8小时，因此这两个城镇都落在我们
    kombucha 酿酒厂的可行驾驶范围内。
- en: How many other towns are within two hours of Town 0? Let’s find out.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少其他城镇在城镇0的两小时内？让我们找出答案。
- en: Listing 18.42 Counting all the towns within a two-hour driving range
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.42 计算所有两小时驾驶范围内的城镇数量
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'All but two of our towns are within two hours of the brewery. We’ve figured
    this out by solving the *shortest path length problem*. The problem applies to
    graphs whose edges contain numeric attributes, which are called *edge weights*.
    Additionally, a sequence of node transitions in the graph is called a *path*.
    Each path traverses a sequence of edges. The sum of edge weights in that sequence
    is called the *path length*. The problem asks us to compute the shortest path
    lengths between a node *N* and every node in the graph. If all the edge weights
    are positive, we can compute these path lengths like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个城镇外，我们的所有城镇都在酿酒厂两小时之内。我们是通过解决*最短路径长度问题*得出这个结论的。这个问题适用于包含数值属性的图，这些属性被称为*边权重*。此外，图中节点转换的序列被称为*路径*。每个路径遍历一系列边。该序列中边权重的总和被称为*路径长度*。这个问题要求我们计算节点*N*与图中每个节点之间的最短路径长度。如果所有边权重都是正数，我们可以这样计算这些路径长度：
- en: 'Create a dictionary of shortest path lengths. Initially, that dictionary equals
    `{N: 0}`.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个最短路径长度的字典。最初，该字典等于`{N: 0}`。'
- en: Create a set of examined nodes. Initially, it is empty.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个检查节点集。最初，它是空的。
- en: Create a set of nodes we wish to examine. Initially, it contains just *N*.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组我们希望检查的节点。最初，它只包含*N*。
- en: Remove an unexamined node *U* from our set of unexamined nodes. We pick a *U*
    whose path length to *N* is minimized.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的未检查节点集中移除一个未检查的节点*U*。我们选择一个到*N*的路径长度最小的*U*。
- en: Obtain all neighbors of *U*.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取*U*的所有邻居。
- en: Compute the path length between each neighbor and *N*. Update the dictionary
    of shortest path lengths accordingly.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个邻居与*N*之间的路径长度。相应地更新最短路径长度字典。
- en: Add every neighbor that has not yet been examined to our set of unexamined nodes.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有尚未检查的邻居添加到我们的未检查节点集中。
- en: Add *U* to our set of examined nodes.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*U*添加到我们的检查节点集中。
- en: Repeat step 4 if any unexamined nodes remain. Terminate otherwise.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还有未检查的节点，则重复步骤4。否则终止。
- en: This shortest path length algorithm is included in NetworkX. Given graph *G*
    with an edge weight attribute of `weight`, we can compute all shortest path lengths
    from node *N* by running `nx.shortest_path_length(G, weight='weight', source=N)`.
    Here, we utilize the `shortest_path_length` function to compute `fastest_times`
    in a single line of code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最短路径长度算法包含在NetworkX中。给定具有`weight`边权重属性的图*G*，我们可以通过运行`nx.shortest_path_length(G,
    weight='weight', source=N)`来计算从节点*N*到图中的所有节点的所有最短路径长度。在这里，我们使用`shortest_path_length`函数通过一行代码计算`fastest_times`。
- en: Listing 18.43 Computing shortest path lengths with NetworkX
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.43 使用NetworkX计算最短路径长度
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our shortest path length algorithm doesn’t actually return the shortest path.
    However, in real-world circumstances, we want to know the path that minimizes
    the distance between nodes. For instance, simply knowing the fastest travel time
    between Town 0 and Town 30 is insufficient: we also need the driving directions
    that will get us there in under two hours. Fortunately, the shortest path length
    algorithm can be easily modified to track the shortest path. All we need to do
    is add a dictionary structure that tracks the transition between nodes. The actual
    sequence of traversed nodes can be represented by a list. For brevity’s sake,
    we forgo defining a shortest path tracker from scratch; however, you are encouraged
    to code a shortest path function and compare its outputs to the built-in NetworkX
    `shortest_path` function. Calling `nx.shortest_path_length(G, weight=''weight'',
    source=N)` computes all shortest paths from node `N` to every node in `G`. Hence,
    executing `nx.shortest_path(G, weight=''travel_time'', source=0)[30]` should return
    the fastest travel route between Town 0 and Town 30\. We’ll now print that route,
    which is also displayed in figure 18.17.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最短路径长度算法实际上并不返回最短路径。然而，在现实世界的情境中，我们希望知道最小化节点之间距离的路径。例如，仅仅知道城镇0和城镇30之间的最快旅行时间是不够的：我们还需要得到在两小时内到达那里的驾驶方向。幸运的是，最短路径长度算法可以很容易地修改以追踪最短路径。我们只需要添加一个跟踪节点之间转换的字典结构。实际遍历的节点序列可以用一个列表来表示。为了简洁起见，我们省略了从头开始定义最短路径追踪器的步骤；然而，我们鼓励你编写一个最短路径函数，并将其输出与内置的NetworkX
    `shortest_path`函数进行比较。调用`nx.shortest_path_length(G, weight='weight', source=N)`计算从节点`N`到`G`中每个节点的所有最短路径。因此，执行`nx.shortest_path(G,
    weight='travel_time', source=0)[30]`应该返回城镇0和城镇30之间的最快旅行路线。我们现在将打印出这条路线，它也在图18.17中显示。
- en: '![](../Images/18-17.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/18-17.png)'
- en: 'Figure 18.17 The shortest path between Town 0 and Town 30 is highlighted on
    the graph with thick, dark edges. The path goes from Town 0 to Town 13, followed
    by Towns 28 and 30\. It’s worth noting that alternative paths exist in the graph:
    for example, we can travel from Town 13 to Town 25 and then to Town 30\. However,
    our highlighted path is guaranteed to have the shortest possible path length.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.17 在图中用粗黑边突出显示了城镇 0 和城镇 30 之间的最短路径。路径从城镇 0 到城镇 13，然后是城镇 28 和 30。值得注意的是，图中存在替代路径：例如，我们可以从城镇
    13 旅行到城镇 25，然后到城镇 30。然而，我们突出显示的路径保证具有可能的最短路径长度。
- en: Listing 18.44 Computing shortest paths with NetworkX
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.44 使用 NetworkX 计算最短路径
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Driving time is minimized if we travel from Town 0 to Town 13 to Town 28 and
    finally to Town 30\. We expect that travel time to equal `fastest_times[30]`.
    Let’s confirm.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从城镇 0 开车到城镇 13，再到城镇 28，最后到城镇 30，行驶时间将最小化。我们预计旅行时间将与 `fastest_times[30]`
    相等。让我们来确认一下。
- en: Listing 18.45 Verifying the length of a shortest path
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.45 验证最短路径长度
- en: '[PRE44]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Basic network theory allows us to optimize the travel paths between geolocations.
    In the following section, we build on that theory to develop more advanced techniques.
    More precisely, we simulate the traffic flow across the network of towns. The
    simulation will allow us to uncover the most central towns in the graph. Later,
    we use these traffic simulations to cluster the towns into distinct counties and
    illustrate how this clustering technique can be used to identify friend groups
    in a social graph.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 基本网络理论使我们能够优化地理位置之间的旅行路径。在下一节中，我们将在此基础上开发更高级的技术。更确切地说，我们将模拟城镇网络中的交通流量。这种模拟将使我们能够揭示图中最中心的城镇。稍后，我们将使用这些交通模拟将城镇聚类成不同的县，并说明这种聚类技术如何用于识别社交图中的朋友群体。
- en: Common NetworkX path-related techniques
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 NetworkX 路径相关技术
- en: '`G.neighbors(i)`—Returns all neighbors of node `i`.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.neighbors(i)`—返回节点 `i` 的所有邻居。'
- en: '`G[i]`—Returns all neighbors of node `i`.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G[i]`—返回节点 `i` 的所有邻居。'
- en: '`G[i][j][''weight'']`—Returns the length of a single transition path between
    neighboring nodes `i` and `j`.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G[i][j][''weight'']`—返回相邻节点 `i` 和 `j` 之间单条过渡路径的长度。'
- en: '`nx.shortest_path_length(G, weight=''weight'', source=N)`—Returns the dictionary
    of shortest path lengths from node `N` to all accessible nodes in the graph. The
    `weight` attribute is used to measure the path length.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.shortest_path_length(G, weight=''weight'', source=N)`—返回从节点 `N` 到图中所有可访问节点的最短路径长度的字典。`weight`
    属性用于测量路径长度。'
- en: '`nx.shortest_path(G, weight=''weight'', source=N)`—Returns the dictionary of
    shortest paths from node `N` to all accessible nodes in the graph.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.shortest_path(G, weight=''weight'', source=N)`—返回从节点 `N` 到图中所有可访问节点的最短路径字典。'
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '*Network theory* is the study of connections between objects. A collection
    of objects and their dispersed connections is called either a *network* or a *graph*.
    The objects are called *nodes*, and the connections are called *edges*.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络理论* 是研究对象之间连接的学科。一组对象及其分散的连接被称为 *网络* 或 *图*。这些对象被称为 *节点*，而连接被称为 *边*。'
- en: If an edge has a specific direction, it is called a *directed edge*. Graphs
    with directed edges are called *directed graphs*. If a graph is not directed,
    it is called an *undirected graph*.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一条边具有特定的方向，则称为 *有向边*。具有有向边的图称为 *有向图*。如果图不是有向的，则称为 *无向图*。
- en: We can represent a graph as a binary matrix `M`, where `M[i][j] = 1` if an edge
    exists between node `i` and node `j`. This matrix representation of a graph is
    known as an *adjacency matrix*.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将一个图表示为一个二进制矩阵 `M`，其中 `M[i][j] = 1` 如果节点 `i` 和节点 `j` 之间存在边。这种图的矩阵表示称为 *邻接矩阵*。
- en: In a directed graph, we can count the inbound and outbound edges for each node.
    The number of inbound edges is called the *in-degree*, and the number of outbound
    edges is called the *out-degree*. In certain graphs, the in-degree serves as a
    measure of a node’s popularity. We can compute the in-degree by summing over the
    rows in the adjacency matrix.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有向图中，我们可以计算每个节点的入边和出边。入边的数量称为 *入度*，出边的数量称为 *出度*。在某些图中，入度作为节点流行度的衡量标准。我们可以通过在邻接矩阵的行上求和来计算入度。
- en: We can use graph theory to optimize travel between nodes. A sequence of node
    transitions is called a *path*. A length can be associated with that path if each
    edge has a numeric attribute assigned. That numeric attribute is called an *edge
    weight*. The sum of edge weights across the node sequence in a path is called
    the *path length*. The *shortest path length* problem attempts to minimize the
    path lengths from node *N* to all other nodes in the graph. If the edge weights
    are positive, the path lengths can be minimized algorithmically.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用图论来优化节点之间的旅行。一系列节点转换被称为*路径*。如果每条边都分配了一个数值属性，则可以与该路径关联一个长度。这个数值属性被称为*边权重*。路径中节点序列上边权重的总和被称为*路径长度*。*最短路径长度问题*试图最小化从节点*N*到图中所有其他节点的路径长度。如果边权重为正，则可以通过算法最小化路径长度。
