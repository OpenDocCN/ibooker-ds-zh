- en: 6 Automating code quality tooling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 自动化代码质量工具
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using static analysis tools to find common issues early in the development process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态分析工具在开发早期阶段发现常见问题
- en: Automating dependency and command management for code quality tooling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化依赖和命令管理以提升代码质量工具
- en: Enforcing standards as code is committed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码提交时强制执行标准
- en: As you continue marketing your tools to a variety of car manufacturers, you
    start to get the feeling you’re going to need some help. You need to hire another
    developer to pick up a large share of the development work so you can continue
    developing the business. You also realize that you need to find a way to onboard
    your new partner effectively but quickly so they can be productive from day one.
    Looking at the latest code you’re writing, you see that it would benefit from
    some basic quality standards and conventions to continue delivering value to CarCorp
    and your future additional clients.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续向各种汽车制造商推广你的工具，你开始感觉到你需要一些帮助。你需要雇佣另一位开发者来承担大部分的开发工作，这样你才能继续发展业务。你也意识到你需要找到一种方法，有效地但快速地让新伙伴加入，以便他们可以从第一天开始就变得高效。看看你最新编写的代码，你会发现它将受益于一些基本的质量标准和约定，以便继续为CarCorp和你的未来更多客户创造价值。
- en: 'If you were paying attention in the previous chapter, you’re probably wondering
    how much code quality tooling you can automate instead of doing it all by hand.
    Reviewing code for quality and formatting issues distracts from the core value
    of what you’re trying to deliver, and it can create tension between developers,
    especially when opinions differ. In the worst cases, arguments over unimportant
    details can cause you to overlook more pressing performance or security issues
    in a state of perceptual blindness (see Steven B. Most, “How Not to Be Seen: The
    Contribution of Similarity and Selective Ignoring to Sustained Inattentional Blindness,”
    [https://doi.org/10.1111/1467-9280.00303](https://doi.org/10.1111/1467-9280.00303)).
    It’s often better for everyone involved to let a machine do the pedantic work
    and to reach an agreement that consistency is better than perfection for things
    that aren’t directly creating impactful outcomes for your work. In this chapter,
    you’ll learn the value of having an arsenal of code quality tools and how to integrate
    them effectively into your package.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了上一章的内容，你可能想知道你可以自动化多少代码质量工具，而不是全部手动完成。审查代码的质量和格式问题会分散你试图交付的核心价值，并且它可能会在开发者之间造成紧张关系，尤其是当意见不同时。在最坏的情况下，关于不重要细节的争论可能会导致你在感知盲视的状态下忽视更紧迫的性能或安全问题（参见Steven
    B. Most的“如何不被看到：相似性和选择性忽视对持续注意盲的贡献”，[https://doi.org/10.1111/1467-9280.00303](https://doi.org/10.1111/1467-9280.00303)）。对于不直接为你的工作创造有影响的结果的事情，对所有人来说，让机器做繁琐的工作，并达成一致，认为一致性比完美更重要，通常是更好的选择。在本章中，你将了解拥有一系列代码质量工具的价值，以及如何有效地将它们集成到你的包中。
- en: Important You can use the code companion ([http://mng.bz/69A5](http://mng.bz/69A5))
    to check your work for the exercises in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：你可以使用代码伴侣（[http://mng.bz/69A5](http://mng.bz/69A5)）来检查本章中的练习。
- en: 6.1 The true power of tox environments
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 tox环境的真正力量
- en: tox isn’t just a testing tool. Through the course of this chapter, you’ll use
    tox to manage several different code quality tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: tox不仅仅是一个测试工具。在本章的整个过程中，你将使用tox来管理几个不同的代码质量工具。
- en: In the previous chapter, you learned how to use the `envlist` key and the `[testenv]`
    section to configure a list of environments for tox to create and run. The value
    of `envlist` defines the list of tox environments that should run by default when
    you run the `tox` command without specifying a particular environment, and the
    `[testenv]` section defines the default configuration for those environments.
    When you run the `tox` command, the environments in `envlist` are used by default.
    These are most useful for the things you’ll check most often—typically, unit tests.
    If you’re diligent about careful development and refactoring, you’ll run your
    tests after almost every change. These test environments make a lot of sense as
    the default because of their speed and frequency of use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用 `envlist` 键和 `[testenv]` 部分来配置 tox 创建和运行的多个环境列表。`envlist` 的值定义了当你运行
    `tox` 命令而不指定特定环境时应默认运行的 tox 环境，而 `[testenv]` 部分定义了这些环境的默认配置。当你运行 `tox` 命令时，默认使用
    `envlist` 中的环境。这些环境对于你将最常检查的事情非常有用——通常，是单元测试。如果你在谨慎开发和重构方面非常勤奋，你几乎会在每次更改后运行你的测试。由于它们的速度和使用频率，这些测试环境作为默认环境非常有意义。
- en: 'You also saw that you can use the `-e` argument to specify a single environment.
    In addition to the environments in `envlist`, you can configure arbitrary environments
    for tasks other than testing: you can create an environment for building your
    project’s documentation, formatting the code, and more. These activities aren’t
    always as fast as unit tests, and they aren’t something you need to verify after
    each and every change you make. Adding them to the default list of environments
    could slow down your feedback cycle when you’re trying to move through some development
    quickly.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了，你可以使用 `-e` 参数来指定一个单独的环境。除了 `envlist` 中的环境之外，你还可以为除了测试之外的任务配置任意环境：你可以创建一个用于构建你的项目文档、格式化代码等的环境。这些活动并不总是像单元测试那样快，而且它们也不是你在每次更改后都需要验证的事情。将它们添加到默认环境列表中可能会在尝试快速开发时减慢你的反馈周期。
- en: You need an approach that can be configured in a homogeneous way, enabling you
    to manage each of your different maintenance activities while keeping turnaround
    time as low as possible. Once again, tox proves to be an invaluable tool on this
    front. If you haven’t already recognized the power of tox for automation, the
    following sections demonstrate the time it can save you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个可以以统一方式配置的方法，使你能够在尽可能低的周转时间内管理你所有的不同维护活动。再次证明，tox 在这个方面是一个无价的工具。如果你还没有认识到
    tox 在自动化方面的力量，以下章节将展示它可以为你节省多少时间。
- en: 6.1.1 Creating nondefault tox environments
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 创建非默认的 tox 环境
- en: In the previous chapter, you added a `[testenv]` section in the setup.cfg file
    that includes the dependencies to install and the commands to run. These are some
    of the basic ingredients for any environment you might want to create. The `[testenv]`
    section is used by default for any environment specified in `envlist`, but you
    can configure specific environments with their own section as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你在 setup.cfg 文件中添加了一个 `[testenv]` 部分，其中包含了要安装的依赖项和要运行的命令。这些是创建任何环境的基本成分。默认情况下，`[testenv]`
    部分用于 `envlist` 中指定的任何环境，但你也可以为具有自己部分的特定环境进行配置。
- en: When configuring a tox environment that you don’t want to run by default, you
    need to add a section to the setup.cfg file named `[testenv:<name>]`, where `name`
    is the name you want for the environment. When you run `tox -e <name>`, tox uses
    the `[testenv:<name>]` section for that environment. This environment accepts
    all the same options as `[testenv]` does, including the `deps` and `commands`
    keys. You can provide explicit configuration for an environment that is in `envlist`
    as well; in this case, tox uses the `[testenv]` section as a base for configuration,
    adding to or overriding the base configuration with any keys it finds in `[testenv:<name>]`
    (see figure 6.1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置一个你不想默认运行的 tox 环境时，你需要在 setup.cfg 文件中添加一个名为 `[testenv:<name>]` 的部分，其中 `name`
    是你想要的环境名称。当你运行 `tox -e <name>` 时，tox 使用该环境的 `[testenv:<name>]` 部分。此环境接受与 `[testenv]`
    相同的所有选项，包括 `deps` 和 `commands` 键。你还可以为 `envlist` 中的环境提供显式的配置；在这种情况下，tox 使用 `[testenv]`
    部分作为配置的基础，通过在 `[testenv:<name>]` 中找到的任何键添加到或覆盖基本配置（见图 6.1）。
- en: Exercise 6.1
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.1
- en: 'Add a new tox environment called `get_my_ip` that does the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的名为 `get_my_ip` 的 tox 环境，该环境执行以下操作：
- en: Installs the `requests` package as a dependency
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `requests` 包作为依赖项
- en: Runs a command that uses requests to get the IP address of the machine where
    tox is running and prints it
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个使用requests获取tox运行所在机器的IP地址并打印出来的命令
- en: You can use `requests.get("https:/ /canhazip.com").text` to get the IP address,
    and you can use `python -c "# some python code here"` to run Python code as a
    command. When you’re finished, the command `tox -e get_my_ip` should print your
    IP address.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`requests.get("https:/ /canhazip.com").text`来获取IP地址，并且你可以使用`python -c "#
    some python code here"`来作为命令运行Python代码。当你完成时，命令`tox -e get_my_ip`应该会打印出你的IP地址。
- en: '![](../../OEBPS/Images/06-01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1](../../OEBPS/Images/06-01.png)'
- en: Figure 6.1 tox environments can be configured in a layered manner with default
    and explicit configuration sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 tox环境可以通过默认和显式配置部分以分层方式配置。
- en: Now you can run the `tox` command to use the environments listed in `envlist`,
    which uses the `[testenv]` section for configuration. You can also run `tox -e
    get_my_ip` to use the `get_my_ip` environment, which uses the `[testenv:get_my_ip]`
    section for configuration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行`tox`命令来使用`envlist`中列出的环境，它使用`[testenv]`部分进行配置。你也可以运行`tox -e get_my_ip`来使用`get_my_ip`环境，它使用`[testenv:get_my_ip]`部分进行配置。
- en: You might have noticed that the `get_my_ip` environment still performs the installation
    of your package, even though the environment doesn’t need your package to perform
    its activities. In the future, you might also manage several environments that
    need the same base set of dependencies but that each need different additional
    dependencies. tox provides for these situations with some additional configuration
    options.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，即使`get_my_ip`环境不需要你的包来执行其活动，它仍然会安装你的包。在未来，你也可能需要管理几个需要相同基础依赖集但每个需要不同附加依赖的环境。tox为这些情况提供了一些额外的配置选项。
- en: 6.1.2 Managing dependencies across tox environments
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 在tox环境中管理依赖关系
- en: Whereas unit tests execute your real code and need it to be installed in the
    environment to run, some maintenance that you do transcends the code and doesn’t
    need it be installed to run successfully. Imagine that one of your maintenance
    activities focuses on generating a change log or printing some diagnostic stats
    about the project. These activities may not depend on your package’s code at all,
    so installing the package only gets in the way of getting the task done. In these
    cases, you can skip installing your package into the relevant tox environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试执行你的真实代码并需要在环境中安装以运行不同，你进行的某些维护活动超越了代码，并且不需要安装即可成功运行。想象一下，你的维护活动之一是生成变更日志或打印有关项目的某些诊断统计信息。这些活动可能根本不依赖于你的包代码，因此安装包只会妨碍任务的完成。在这些情况下，你可以跳过将你的包安装到相关的tox环境中。
- en: When you want to skip the installation step in a given tox environment, you
    must add the `skip_install` key to that environment’s configuration section with
    a value of `True`. You may still install any additional dependencies needed for
    that environment’s activities, but your package won’t be installed into the environment.
    This provides a speed boost and also makes it clear which activities do or don’t
    rely on your package being installed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在给定的tox环境中跳过安装步骤时，你必须将`skip_install`键添加到该环境的配置部分，并设置值为`True`。你仍然可以安装该环境活动所需的任何额外依赖项，但你的包不会安装到环境中。这提供了速度提升，并且也清楚地表明哪些活动依赖于或不需要安装你的包。
- en: Whereas `skip_install` is all about reducing installed dependencies, you may
    also want to install additional dependencies in some environments without polluting
    others. Imagine that one of your maintenance activities uses a tool to verify
    that your import statements are all valid. The environment for analyzing imports
    should install your package so that it can validate code that imports it. The
    environment also needs to install the package for the analysis tool. If you want
    the tool to check your tests as well, it also needs to install any packages you
    import in your tests. How can you accomplish this without repeating yourself?
    You’ll use a special tox syntax that allows you to reference other configuration
    sections and keys.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`skip_install`主要是关于减少已安装的依赖项，但你可能也想要在某些环境中安装额外的依赖项，而不污染其他环境。想象一下，你的维护活动之一使用一个工具来验证你的导入语句是否全部有效。用于分析导入的环境应该安装你的包，以便它可以验证导入它的代码。该环境还需要安装分析工具的包。如果你想让工具检查你的测试，它还需要安装你在测试中导入的任何包。你如何在不重复自己的情况下完成这项任务？你将使用一个特殊的tox语法，允许你引用其他配置部分和键。
- en: Note You can find the full configuration specification in the tox documentation
    ([https://tox.wiki/en/latest/config.xhtml](https://tox.wiki/en/latest/config.xhtml)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在 tox 文档中找到完整的配置规范（[https://tox.wiki/en/latest/config.xhtml](https://tox.wiki/en/latest/config.xhtml)）。
- en: Imagine that the import analysis tool is in a package called `shipyard` (shipyards
    are where imports are checked). You could configure tox to install your package
    and the other packages imported in your tests, but this will result in a fair
    amount of duplication as your project grows. Notice how `pytest` and `requests`
    are repeated in the dependency list for the environments shown in listing 6.1\.
    In large projects with many dependencies, this duplication can grow and lead you
    to add any new dependency to each of your environments “just in case” it’s needed,
    because that’s easier than determining the specific environments that need the
    dependency to run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设导入分析工具在一个名为 `shipyard`（船坞是检查导入的地方）的包中。你可以配置 tox 来安装你的包和测试中导入的其他包，但这会导致随着项目增长而出现大量的重复。注意在列表
    6.1 中显示的环境的依赖项列表中 `pytest` 和 `requests` 的重复。在具有许多依赖项的大项目中，这种重复可能会增长，导致你“以防万一”将任何新的依赖项添加到每个环境中，因为这样做比确定需要依赖项来运行的具体环境要容易。
- en: Listing 6.1 A naive configuration for dependencies with a fair amount of repetition
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 具有相当多重复的依赖项的简单配置
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ This is imported in tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是在测试中导入的。
- en: ❷ This isn’t imported, so it doesn’t need to be installed to check imports.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这没有导入，因此不需要安装来检查导入。
- en: ❸ You may have additional imported dependencies throughout your code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 你可能在代码的各个部分有额外的导入依赖项。
- en: ❹ In a naive configuration, you’ll end up repeating dependencies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在简单的配置中，你最终会重复依赖项。
- en: ❺ This is unique to the check-imports environment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这仅适用于检查导入的环境。
- en: Instead of enumerating all dependencies in each environment, you can use tox
    to extract and give names to subsets of dependencies. This reduces repetition
    and centralizes dependency lists, making it more likely that each of your environments
    receives all the dependencies it needs each time you update a dependency list.
    To reference configuration from another section with tox, you specify the full
    section name—including square brackets—followed immediately by the key name, all
    in curly braces (see figure 6.2).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在每个环境中列举所有依赖项，你可以使用 tox 提取并给依赖项的子集命名。这减少了重复并集中了依赖项列表，使得每次更新依赖项列表时，每个环境更有可能接收到它需要的所有依赖项。要使用
    tox 从另一个章节引用配置，你指定完整的章节名称——包括方括号——后跟键名，所有这些都放在大括号中（见图 6.2）。
- en: '![](../../OEBPS/Images/06-02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/06-02.png)'
- en: Figure 6.2 The tox syntax to reference a configuration key from another section
    in setup.cfg
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 从 setup.cfg 中的另一个章节引用配置键的 tox 语法
- en: You could reference the dependency list from the `testenv` environment in the
    `testenv:check-imports` environment, which would install all the necessary dependencies
    to check imports across your code and tests. But this would also install the `pytest-cov`
    package, which isn’t imported anywhere and is, therefore, a bit of a waste. To
    maximize the efficiency of what you’re installing, you can separate the minimal
    set of necessary dependencies into its own named section and reference that everywhere
    else instead. Listing 6.2 shows how you could update the configuration by extracting
    a `[testimports]` section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 `testenv` 环境在 `testenv:check-imports` 环境中引用依赖项列表，这将安装检查代码和测试中导入所需的所有必要依赖项。但这也将安装
    `pytest-cov` 包，它没有被导入任何地方，因此有点浪费。为了最大限度地提高你安装的效率，你可以将所需的最小依赖项集分离到自己的命名章节中，并在其他地方引用它。列表
    6.2 展示了如何通过提取 `[testimports]` 章节来更新配置。
- en: The new section has a `deps` key with a list of dependencies, just like the
    previous sections did. It lists only the dependencies that are needed in all the
    other environments. Then, each section references the new section’s dependencies
    using the `{[testimports]deps}` reference. This makes it clear that each environment
    needs `pytest` and `requests`, and that each environment needs additional, unique
    dependencies.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 新的章节包含一个名为 `deps` 的键，其中列出了依赖项，就像之前的章节一样。它只列出了所有其他环境中需要的依赖项。然后，每个章节都使用 `{[testimports]deps}`
    引用来引用新章节的依赖项。这使得每个环境需要 `pytest` 和 `requests`，以及每个环境需要额外的、独特的依赖项变得清晰。
- en: Listing 6.2 Extracting and referencing named configurations to reduce repetition
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 提取和引用命名配置以减少重复
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This section lists packages that are imported in tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 本节列出了在测试中导入的包。
- en: ❷ This environment depends on the same things listed in testimports.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此环境依赖于在 `testimports` 中列出的相同事项。
- en: ❸ This environment also extends the list of dependencies further.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此环境还进一步扩展了依赖项列表。
- en: ❹ The list from testimports can be reused many places.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从 `testimports` 获取的列表可以在许多地方重用。
- en: This configuration is a few lines longer than the naive approach, but that may
    not always be true. If your tests import a large handful of packages, they’ll
    be listed only in the `[testimports]` section, and the other sections don’t need
    to change. As your package gains complexity over time, you continue to reap the
    savings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置比简单方法多几行，但这并不总是正确的。如果你的测试导入了大量包，它们只会在 `[testimports]` 部分列出，其他部分不需要更改。随着你的包随着时间的推移变得更加复杂，你将继续获得节省。
- en: Exercise 6.2
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.2
- en: Given the following configuration, which are true?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下配置，以下哪些是正确的？
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A) Running the `tox` command uses two environments.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: A) 运行 `tox` 命令使用两个环境。
- en: B) Running the `tox` command uses three environments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: B) 运行 `tox` 命令使用三个环境。
- en: C) Running the `tox` command uses four environments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C) 运行 `tox` 命令使用四个环境。
- en: D) The `py39` environment has the `requests` package installed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: D) `py39` 环境已安装了 `requests` 包。
- en: E) The `myenv` environment has the `requests` package installed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: E) `myenv` 环境已安装了 `requests` 包。
- en: F) The `check-imports` environment has the `requests` package installed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: F) `check-imports` 环境已安装了 `requests` 包。
- en: G) The `myenv` environment is the only environment that skips installation of
    your package.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: G) `myenv` 环境是唯一一个跳过安装你的包的环境。
- en: H) Adding a package to `[testimports]deps` impacts three environments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: H) 将包添加到 `[testimports]deps` 影响三个环境。
- en: I) Adding a package to `[testimports]deps` impacts four environments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: I) 将包添加到 `[testimports]deps` 影响四个环境。
- en: Now that you’ve got a handle on dependency management across a few tox environments,
    you’re ready to dig into using it for code quality tasks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了在几个 `tox` 环境中管理依赖项的方法，你就可以深入挖掘它用于代码质量任务的应用了。
- en: 6.2 Analyzing type safety
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 分析类型安全
- en: 'Python is a *dynamically typed language*—the type of an object is evaluated
    at run time, and as a result, it’s possible for the object to be the wrong type
    for the intended operation. Further, Python has *duck typing*. If an object “looks
    like a duck and quacks like a duck, then it’s a duck”—that is, if an object can
    perform the intended operation successfully, then it can be treated as if it were
    the type intended by the author of the operation. This flexibility makes Python
    one of the most productive languages today. The type system stays out of your
    way a lot of the time, letting you focus on that quick thing you’re trying to
    get done. Consider the following function, which returns `True` if the argument
    passed to it is too long:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种 *动态类型语言*——对象的类型在运行时评估，因此对象可能对于预期的操作是错误的类型。此外，Python 有 *鸭子类型*。如果一个对象“看起来像鸭子，叫起来像鸭子，那么它就是鸭子”——也就是说，如果一个对象可以成功执行预期的操作，那么它可以被视为作者意图的操作类型。这种灵活性使得
    Python 成为当今最具生产力的语言之一。类型系统大部分时间都不会妨碍你，让你可以专注于快速完成的事情。考虑以下函数，该函数如果传入的参数太长则返回 `True`：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The author of this function may have intended for callers to pass in a list,
    but the function also works without error on sets, dictionaries, strings, and
    more. In fact, any object that defines a `__len__` method can be passed into a
    call to `too_long` without error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的作者可能希望调用者传入一个列表，但该函数在没有错误的情况下也可以在集合、字典、字符串等上正常工作。实际上，任何定义了 `__len__` 方法的对象都可以在调用
    `too_long` 时传入而不会出错。
- en: This flexibility also presents challenges. As a code base scales, it becomes
    increasingly likely that someone somewhere will call a function, method, or initializer
    with an unintended data type. In the worst cases, this might even work at the
    time of writing, only to break later when you update the called code in a way
    that no longer accommodates the unexpected use case. When you’re creating a package
    that you want others to use, their expectations of backward compatibility carry
    even more weight.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性也带来了挑战。随着代码库的扩展，越来越有可能有人在某个地方以不期望的数据类型调用函数、方法或初始化器。在最坏的情况下，这可能在编写时工作，但后来当你以不再适应意外用例的方式更新被调用的代码时，可能会出错。当你创建一个希望其他人使用的包时，他们对向后兼容性的期望就更加重要了。
- en: Type hinting, first proposed in 2014 and added to Python 3.5 ([https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)),
    provides a way to more strongly suggest types in signatures for functions, methods,
    and so on. With these hints, someone reading through the code base and trying
    to use a function is able to readily see what expectations the author of the function
    has about its use. Further, tooling like IDEs often use these hints to suggest
    to someone that they’ve used a function incorrectly when the type they use doesn’t
    agree with the type hint given. Your new teammate would benefit a great deal from
    type hints and type checks, especially early on as they become familiar with the
    project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示，首次在2014年提出，并于Python 3.5中添加（[https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)），为函数、方法等签名中的类型提供了更强烈建议的方式。有了这些提示，阅读代码库并尝试使用函数的人可以轻松地看到函数作者对其使用的期望。此外，IDE等工具通常使用这些提示来向用户建议他们可能错误地使用了函数，当使用的类型与提供的类型提示不一致时。您的新同事将从类型提示和类型检查中受益匪浅，尤其是在他们熟悉项目早期。
- en: 'A safer version of `too_long` might explicitly define the input argument as
    a list, like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`too_long`的一个更安全的版本可能明确地将输入参数定义为列表，如下所示：'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or, if the author realizes that they really do want the function to be usable
    for any object that defines a `__len__` method, they might choose to specify that
    any input argument of the `Sized` type is sufficient as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果作者意识到他们确实希望函数对定义了`__len__`方法的任何对象都可用，他们可能会选择指定任何`Sized`类型的输入参数都足够，如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then sets, dictionaries, and strings would be acceptable, but scalar values
    like integers or floats would not. Type checking tools can find situations where
    a call is made that doesn’t match the type hints for the called function and presents
    an error to the developer to fix the calls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后集合、字典和字符串将被接受，但整数或浮点数这样的标量值则不行。类型检查工具可以找到调用不匹配调用函数类型提示的情况，并向开发者显示错误以修复调用。
- en: These types of *static analysis*, or analysis that doesn’t need to execute your
    code, are helpful because you can often run them quickly and frequently during
    development. They can also be integrated as part of your continuous integration
    pipeline, which you’ll learn more about in chapter 7.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这类*静态分析*，或者不需要执行您的代码的分析，是有帮助的，因为您可以在开发过程中快速频繁地运行它们。它们也可以集成到您的持续集成管道中，您将在第7章中了解更多关于持续集成的内容。
- en: The Python Code Quality Authority
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码质量权威机构
- en: Code quality, and, in particular, static analysis tooling that doesn’t need
    to run your code to perform checks on it, is a quickly growing space. The Python
    Code Quality Authority (PyCQA) ([https://pycqa.org](https://pycqa.org)) adopts
    and maintains projects in this space to ensure they remain updated as Python and
    other areas of the ecosystem evolve. A few of the tools suggested in this chapter
    are maintained by the PyCQA.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量，特别是无需运行代码即可进行检查的静态分析工具，是一个快速增长的领域。Python代码质量权威机构（PyCQA）([https://pycqa.org](https://pycqa.org)）采用并维护该领域的项目，以确保它们随着Python和其他生态系统领域的演变而保持更新。本章中建议的一些工具由PyCQA维护。
- en: To check your code’s type hints, you’ll use the `mypy` package.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的代码的类型提示，您将使用`mypy`包。
- en: 6.2.1 Creating a tox environment for type checking
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 为类型检查创建tox环境
- en: mypy ([https://github.com/python/mypy](https://github.com/python/mypy)) is one
    of a number of available static analysis tools for verifying type safety in your
    code base. mypy can detect common bugs in Python code without type hints and verifies
    that all calls agree with any type hints you or any of your dependencies have
    added. This makes for a fluid experience when adding it into an existing code
    base, because you can incrementally add and check type hints to make your code
    safer instead of trying to update it all at once.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: mypy ([https://github.com/python/mypy](https://github.com/python/mypy)) 是可用于验证代码库中类型安全性的多种静态分析工具之一。mypy可以在没有类型提示的Python代码中检测到常见错误，并验证所有调用是否与您或您的任何依赖项添加的类型提示一致。这使得将其添加到现有代码库中的体验更加流畅，因为您可以通过增量添加和检查类型提示来使代码更安全，而不是一次性尝试更新它。
- en: 'Start by adding a section for a new tox environment called `typecheck` in the
    setup.cfg file. This environment needs to install the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`setup.cfg`文件中添加一个名为`typecheck`的新tox环境部分。此环境需要安装以下内容：
- en: Your package, so imports of your code can be followed properly
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的包，这样您的代码导入可以被正确地跟踪
- en: The `pytest` package, so imports in your tests can be followed properly
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`包，以便在测试中正确导入'
- en: The `mypy` package, so you can use it to check type safety
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mypy`包，以便你可以用它来检查类型安全'
- en: The `types-termcolor` package, so mypy can better verify your usage of the `termcolor`
    package
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`types-termcolor`包，以便mypy能更好地验证你对`termcolor`包的使用'
- en: 'Configure the environment to run the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 配置环境以运行以下命令：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This tells mypy to follow as many imports as it can, ignoring the ones for
    which it can’t analyze types. mypy defaults to analyzing all the code in your
    src/ and test/ directories, but you can pass specific files as positional arguments
    to the `tox` command if you want to check a subset of your project. Recall that
    you can use tox’s `-e` flag followed by a tox environment name to run only that
    environment. Run the environment now using the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉mypy尽可能多地跟随导入，忽略它无法分析类型的导入。mypy默认分析src/和test/目录中的所有代码，但如果你想检查项目的一部分，你可以将特定文件作为位置参数传递给`tox`命令。回想一下，你可以使用tox的`-e`标志后跟一个tox环境名称来仅运行该环境。现在使用以下命令运行环境：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see something similar to the following at the end of the command
    output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出的末尾你应该看到以下类似的内容：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This confirms that your code is currently safe with regard to types. From a
    test-driven development perspective, you’re in a “green” state which you can use
    to refactor your code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了你的代码在类型方面目前是安全的。从测试驱动开发的角度来看，你处于“绿色”状态，你可以用它来重构你的代码。
- en: Exercise 6.3
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.3
- en: 'The `main` function in the `src/imppkg/harmony.py` module is a bit long and
    handles a number of concerns, shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/imppkg/harmony.py`模块中的`main`函数有点长，处理了多个问题，如下所示：'
- en: Parses the input from the command line into a list of floating-point numbers
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令行输入解析为浮点数列表
- en: Calculates the harmonic mean if possible, defaulting to `0.0` otherwise
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，计算调和平均值，否则默认为`0.0`
- en: Formats and prints the output
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化并打印输出
- en: 'Right now, there’s no good juncture for type checking either, because the `main`
    function doesn’t accept any arguments or return a value. Split the body of the
    `main` function into three helper functions with the following signatures:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，也没有合适的时机进行类型检查，因为`main`函数不接受任何参数也不返回任何值。将`main`函数的主体拆分为三个具有以下签名的辅助函数：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `main` function should then use these three functions and print the final
    result. You can use the `termcolor.colored` instead of `termcolor.cprint` to get
    formatted text as a string without printing it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`main`函数应该使用这三个函数并打印最终结果。你可以使用`termcolor.colored`而不是`termcolor.cprint`来获取格式化文本作为字符串，而不打印它。
- en: When you’re done, the `typecheck` environment should still run successfully.
    Your unit tests should remain unchanged and continue to pass. After you’re done,
    change some of the type hints to disagree with each other, and rerun type checking
    to see how it behaves in response; mypy should raise an error for each type disagreement.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`typecheck`环境仍然应该成功运行。你的单元测试应该保持不变并继续通过。完成后，更改一些类型提示以相互矛盾，并重新运行类型检查以查看其响应；mypy应该为每个类型矛盾引发错误。
- en: Now that you have mypy working, you’ll configure it for some additional productivity.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经让mypy工作，你将配置它以获得额外的生产力。
- en: 6.2.2 Configuring mypy
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 配置mypy
- en: 'You can configure mypy by adding a `[mypy]` section to your setup.cfg file.
    The mypy configuration documentation ([http://mng.bz/096E](http://mng.bz/096E))
    covers a wide variety of available configuration options. A few of the most important
    follow:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`setup.cfg`文件中添加一个`[mypy]`部分来配置mypy。mypy配置文档([http://mng.bz/096E](http://mng.bz/096E))涵盖了广泛的可用配置选项。以下是一些最重要的选项：
- en: '`python_version`—Set this to the lowest version of Python your package supports.
    As an example, if you want to support Python 3.8, 3.9, and 3.10, set this to `3.8`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python_version`—将此设置为你的包支持的最低Python版本。例如，如果你想支持Python 3.8、3.9和3.10，则将其设置为`3.8`。'
- en: '`warn_unused_configs`—Set this to `True` so that mypy alerts you if you’ve
    added other configuration sections that have no effect.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warn_unused_configs`—将此设置为`True`，以便mypy在添加了没有效果的其它配置部分时提醒你。'
- en: '`show_error_context`—Set this to `True` for mypy to show you the code surrounding
    the line where it finds an issue; this can be helpful in understanding the issue
    without having to repeatedly switch between the command line and the file.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show_error_context`—将此设置为`True`，以便mypy显示它发现问题的代码周围的代码；这有助于在不反复在命令行和文件之间切换的情况下理解问题。'
- en: '`pretty`—Set this to `True` for mypy to output more human-readable error messages.
    In particular, mypy gives a visual indication of the column of your code where
    the error occurs, which can help you more quickly identify issues that arise.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pretty`—将此设置为 `True` 以使 mypy 输出更多易于阅读的错误信息。特别是，mypy 会显示你代码中错误发生的列，这可以帮助你更快地识别出现的问题。'
- en: '`namespace_packages`—Set this to `True` so mypy can find a wider array of potential
    package configurations—namely, it finds implicit namespace packages as defined
    in PEP 420 ([https://www.python.org/dev/peps/pep-0420/](https://www.python.org/dev/peps/pep-0420/)).
    This future-proofs your type checking configuration as you install more packages
    that have the potential to be implicit namespace packages.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace_packages`—将此设置为 `True` 以使 mypy 能够找到更广泛的潜在包配置——即，它找到 PEP 420 中定义的隐式命名空间包（[https://www.python.org/dev/peps/pep-0420/](https://www.python.org/dev/peps/pep-0420/)）。随着你安装更多可能成为隐式命名空间包的包，这为你的类型检查配置提供了未来保障。'
- en: '`check_untyped_defs`—By default, mypy will only check the types of things to
    which you’ve explicitly added type hints. It can miss cases where you forgot to
    add type hints and used a function incorrectly. Set this to `True` so mypy will
    check type agreement in as many places as possible.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_untyped_defs`—默认情况下，mypy 只会检查你明确添加了类型注解的项的类型。它可能会错过你忘记添加类型注解并错误使用函数的情况。将此设置为
    `True` 以使 mypy 在尽可能多的地方检查类型一致性。'
- en: Add each of these keys to the `[mypy]` section in your setup.cfg file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些键添加到你的 setup.cfg 文件中的 `[mypy]` 部分。
- en: A case study in type safety
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全案例研究
- en: The `urllib3` package is a widely used Python package; GitHub’s dependency graph
    indicates that over 5,000 other packages depend on it ([http://mng.bz/K0xg](http://mng.bz/K0xg)).
    The `urllib3` team undertook an effort to introduce type hints as widely and strictly
    as possible in the project without breaking the code for its consumers. They found
    that adding type hints uncovered bugs and design flaws that their extensive test
    coverage hadn’t. Read about the different kinds of improvements they were able
    to identify in a large project in the wild at [http://mng.bz/82Ez](http://mng.bz/82Ez).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib3` 包是一个广泛使用的 Python 包；GitHub 的依赖关系图表明，超过 5,000 个其他包依赖于它 ([http://mng.bz/K0xg](http://mng.bz/K0xg))。`urllib3`
    团队努力在尽可能广泛和严格的项目中引入类型注解，而不破坏其消费者的代码。他们发现添加类型注解揭示了他们广泛的测试覆盖范围没有发现的错误和设计缺陷。关于他们在野外大型项目中能够识别的不同类型的改进，请参阅
    [http://mng.bz/82Ez](http://mng.bz/82Ez)。'
- en: At this point, you’re set up to catch any type-related issues in your package
    as they arise. You can also help people who use your package to ensure they’re
    using it with the right types. To do so, create an empty py.typed file in the
    src/imppkg/ directory. This file, when present in the contents of a package installed
    in a project, tells mypy to check usages of code from that package for type-related
    issues as well. This extends the type safety you add out to anyone who consumes
    your work in their applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经设置好了捕捉你包中出现的任何类型相关问题的功能。你还可以帮助使用你包的人确保他们使用正确的类型。为此，在 src/imppkg/ 目录中创建一个空的
    py.typed 文件。当这个文件存在于一个项目安装的包的内容中时，它会告诉 mypy 检查该包代码的使用情况，以查找类型相关问题。这扩展了你为任何在其应用程序中使用你工作的人添加的类型安全性。
- en: Note The py.typed file will be automatically included in your package because
    of the `graft` directive you added to the MANIFEST.in file in chapter 4.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于你在第 4 章中添加到 MANIFEST.in 文件的 `graft` 指令，py.typed 文件将自动包含在你的包中。
- en: Next, you’ll create a tox environment to automatically check and update the
    formatting of your code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个 tox 环境，以自动检查和更新你代码的格式。
- en: Alternative type checkers
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 替代类型检查器
- en: 'mypy, first developed at Dropbox, is one of the most widely used type checking
    tools, but many others are out there. If you’d like to explore the landscape further,
    check out these type checkers that each have their respective corporate backing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: mypy，最初在 Dropbox 开发，是最广泛使用的类型检查工具之一，但还有许多其他工具。如果你想进一步探索这个领域，可以查看这些各自有相应公司支持的类型检查器：
- en: pyright ([https://github.com/Microsoft/pyright](https://github.com/Microsoft/pyright))
    from Microsoft
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Microsoft 的 pyright ([https://github.com/Microsoft/pyright](https://github.com/Microsoft/pyright))
- en: pyre ([https://github.com/facebook/pyre-check](https://github.com/facebook/pyre-check))
    from Facebook
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Facebook 的 pyre ([https://github.com/facebook/pyre-check](https://github.com/facebook/pyre-check))
- en: pytype ([https://google.github.io/pytype/](https://google.github.io/pytype/))
    from Google
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Google 的 pytype ([https://google.github.io/pytype/](https://google.github.io/pytype/))
- en: 6.3 Creating a tox environment for code formatting
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 为代码格式化创建tox环境
- en: Code is read many more times than it’s written, so it stands to reason that
    code should be *readable*. Often, what one developer believes is readable doesn’t
    agree with what another developer believes. This can lead to wasting time during
    review discussing levels of indentation, where newlines should occur, whether
    to use single or double quotes, and so on. Although readability for a given piece
    of code can be fairly objective in some cases, even then you can waste time remembering
    to format the code that way as you’re writing. PEP 8 ([https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))
    defines a style guide for Python code. Most Python code formatting tools adhere
    to the suggestions laid out in PEP 8, but PEP 8 doesn’t cover all formatting decisions
    a Python developer ever needs to make. Each formatter introduces its own additional
    rules, some of which can become burdensome to remember and address manually.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被阅读的次数远多于被编写的次数，因此代码应该是*可读的*。通常，一个开发者认为可读的代码并不一定与另一个开发者认为的可读性一致。这可能导致在审查过程中浪费时间讨论缩进级别、换行位置、是否使用单引号或双引号等问题。尽管在某些情况下，给定代码的可读性可能是相当客观的，但即使在这种情况下，你也会在编写代码时浪费时间记住以这种方式格式化代码。PEP
    8（[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/））为Python代码定义了一个风格指南。大多数Python代码格式化工具都遵循PEP
    8中提出的建议，但PEP 8并不涵盖Python开发者需要做出的所有格式化决策。每个格式化器都引入了自己的附加规则，其中一些可能难以记住并手动处理。
- en: To alleviate these pressures, let an automated process do the formatting for
    you. Many developers use their IDE to perform this task. Some developers even
    have the IDE automatically format their code each time they save the file, tightening
    the loop on the code they’re working in. The formatting style can differ between
    IDEs, or even between two developers using the same IDE with differing preferences
    set. Using a consistent formatting style ensures that your team’s pull requests
    don’t continually include reformatting code back and forth depending on which
    developer most recently updated the code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这些压力，让自动化过程为你进行格式化。许多开发者使用他们的集成开发环境（IDE）来执行此任务。一些开发者甚至让IDE在每次保存文件时自动格式化他们的代码，从而在正在工作的代码上形成一个更紧密的循环。不同的IDE之间或使用相同IDE但设置不同偏好的两个开发者之间，格式化风格可能不同。使用一致的格式化风格可以确保你的团队的拉取请求不会因为哪个开发者最近更新了代码而不断地包括来回重新格式化代码。
- en: 'The `black` package ([https://black.readthedocs.io/en/stable/](https://black.readthedocs.io/en/stable/))
    seeks to format Python code uniformly, with few configuration options, such that
    the vast majority of Python project code is readable after formatting. It can
    automatically update code that doesn’t adhere to the style, making it fast to
    reformat an entire codebase and any new code as it’s added. `black` also prefers
    code that results in short diffs when changed, such as always using trailing commas
    in multiline lists or dictionaries. Consider the following code that assigns a
    list of strings to a variable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`black` 包（[https://black.readthedocs.io/en/stable/](https://black.readthedocs.io/en/stable/））旨在以很少的配置选项对Python代码进行统一格式化，以便在格式化后，绝大多数Python项目代码都是可读的。它可以自动更新不符合风格的代码，使整个代码库和新代码的重新格式化变得快速。`black`
    还更喜欢在更改时产生短差异的代码，例如在多行列表或字典中始终使用尾随逗号。考虑以下将字符串列表赋值给变量的代码：'
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ The last item doesn’t include a trailing comma.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 最后一个项目没有包含尾随逗号。
- en: 'Because this code doesn’t use a trailing comma for the last item in the list,
    adding a fourth string to the list results in a diff like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这段代码在列表的最后一个项目后没有使用尾随逗号，向列表中添加第四个字符串会导致以下差异：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Because a comma was added, this line shows as removed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为添加了逗号，这一行显示为已删除。
- en: ❷ The added line includes the comma.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加的行包含了逗号。
- en: ❸ The new line with the new string shows as added.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 包含新字符串的新行显示为已添加。
- en: 'Notice that the diff shows a removed line and two added lines, even though
    the spirit of the change was adding a single new item to the list. `black` prefers
    to use trailing commas so that diffs reflect this more faithfully. Now consider
    the case where a trailing comma is included after the third list item. When adding
    the fourth item with a trailing comma of its own, the diff would look like this
    instead:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到差异显示删除了一行并添加了两行，尽管变化的本质是向列表中添加一个新项目。`black` 倾向于使用尾随逗号，以便差异更忠实地反映这一点。现在考虑在第三个列表项之后包含尾随逗号的情况。当添加带有自己尾随逗号的第四个项目时，差异将看起来像这样：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ With an existing trailing comma, this line is unchanged.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果存在现有的尾随逗号，则此行保持不变。
- en: ❷ Only the new string shows as added.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只有新的字符串显示为已添加。
- en: Because the punctuation of the code didn’t change, the diff is now simpler.
    When making larger changes to code, these small simplifications can add up to
    a much easier review for the team.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码的标点符号没有改变，diff现在变得更简单。在修改代码时，这些小的简化可以大大简化团队的审查工作。
- en: One of the best features of the `black` package is that, by default, it ensures
    that the code before and after formatting has the same *abstract syntax tree*
    ([https://docs.python.org/3/library/ast.xhtml](https://docs.python.org/3/library/ast.xhtml)).
    That is, the code before and after the change remains functionally equivalent.
    You can have high confidence that the changes `black` makes are strictly nonfunctional.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`black` 包最好的特性之一是，默认情况下，它确保格式化前后的代码具有相同的*抽象语法树* ([https://docs.python.org/3/library/ast.xhtml](https://docs.python.org/3/library/ast.xhtml))。也就是说，格式化前后的代码在功能上保持等效。你可以有很高的信心，`black`
    所做的更改完全是功能性的。'
- en: Exercise 6.4
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.4
- en: 'In your setup.cfg file, configure a new tox environment called `format` for
    checking and formatting your code. This environment has one dependency—the `black`
    package. The environment should run one command, `black`, with the following default
    options, using tox’s `posargs` syntax you learned earlier:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的setup.cfg文件中，配置一个新的tox环境，称为`format`，用于检查和格式化你的代码。此环境有一个依赖项——`black`包。环境应运行一个命令`black`，使用以下默认选项，并使用你之前学到的tox的`posargs`语法：
- en: '`--check`—Checks the formatting of the code without actually changing the formatting'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--check`—检查代码的格式，而不实际更改格式'
- en: '`--diff`—Outputs the changes `black` would make if it formatted the code'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--diff`—输出`black`格式化代码时所做的更改'
- en: '`src test`—The areas of code for which to check the formatting'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src test`—需要检查格式的代码区域'
- en: When you’re finished, you should be able to run `tox -e format` to check the
    formatting of your package code and `tox -e format src test` to reformat the code.
    Run the checks to determine whether `black` finds any opportunities to change
    the formatting of your code. If it does, use the environment to make the changes
    automatically.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你应该能够运行`tox -e format`来检查你的包代码的格式，并运行`tox -e format src test`来重新格式化代码。运行检查以确定`black`是否发现任何可以更改你的代码格式的机会。如果发现了，请使用该环境自动进行更改。
- en: 6.3.1 Configuring black
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 配置black
- en: 'You can configure the `black` package using the pyproject.toml file in a new
    section called `[tool.black]`. Note that `black` does not support using the setup.cfg
    file. As mentioned earlier in this chapter, `black` has very few options for configuration
    ([http://mng.bz/9V5q](http://mng.bz/9V5q)). The two most notable follow:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用新创建的`[tool.black]`部分中的pyproject.toml文件来配置`black`包。请注意，`black`不支持使用setup.cfg文件。如本章前面所述，`black`的配置选项非常少
    ([http://mng.bz/9V5q](http://mng.bz/9V5q))。最值得注意的是以下两点：
- en: '`line-length`—The maximum line length allowed, defaulting to `80`. Lines longer
    than this are reformatted to span two or more lines if possible.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line-length`—允许的最大行长度，默认为`80`。如果行长度超过这个值，则尽可能将行重新格式化，使其跨越两个或更多行。'
- en: '`target-version`—The list of Python versions your code should be compatible
    with. This stops `black` from using syntax that is too new for your supported
    Python versions.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target-version`—你的代码应与之兼容的Python版本列表。这阻止`black`使用对于你支持的Python版本来说太新的语法。'
- en: You should set the `line-length` to whatever you find most readable for the
    majority of your code. As an example, I prefer to use a line length of 100 or
    120 because the length of 80 results in a lot of multiline wrapping in big projects
    in which longer, descriptive variable and method names are used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将`line-length`设置为大多数代码中最易读的长度。例如，我更喜欢使用100或120的行长度，因为80的长度在大项目中会导致很多多行换行，而在这些项目中，使用了更长、更具描述性的变量和方法名。
- en: 'For consistency, the `target-version` list should match the list of Python
    versions you support and test against. In chapter 5, you specified an `envlist`
    with at least two Python versions. These same Python versions should be reflected
    in your `black` configuration as well. As an example, if you need to support Python
    3.8 and 3.9, your black configuration might look like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，`target-version`列表应与您支持的Python版本列表相匹配。在第5章中，你指定了一个包含至少两个Python版本的`envlist`。这些相同的Python版本也应反映在你的`black`配置中。例如，如果你需要支持Python
    3.8和3.9，你的`black`配置可能看起来如下：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the `format` environment again with this new configuration to see whether
    `black` should reformat anything with the new configuration, and reformat the
    code if so.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`format`环境，使用这个新的配置来查看`black`是否应该使用新配置重新格式化任何内容，如果是，则重新格式化代码。
- en: Finally, you can speed up the `format` environment by skipping the package installation
    step. Because `black` statically checks your code and doesn’t perform any work
    based on `import` statements or other knowledge of the code’s functionality, you
    can avoid installing the package in the tox environment. Add tox’s `skip_install`
    key with a value of `True` in the `[testenv:format]` section you created earlier
    to skip the package installation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过跳过包安装步骤来加快`format`环境。因为`black`对您的代码进行静态检查，并不基于`import`语句或其他关于代码功能的知识执行任何工作，所以您可以在tox环境中避免安装包。在您之前创建的`[testenv:format]`部分中添加tox的`skip_install`键，并将其值设置为`True`以跳过包安装。
- en: Alternative code formatters
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 替代代码格式化工具
- en: '`black` is quickly becoming one of the most popular formatters, and has been
    adopted under the umbrella of the Python Software Foundation for further development.
    That being said, its opinionation and lack of configurability isn’t for everyone.
    If you want to explore further, check out these other popular formatters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`black`正迅速成为最受欢迎的格式化工具之一，并且已被Python软件基金会采用以进行进一步开发。尽管如此，它的主观性和缺乏可配置性并不适合每个人。如果您想进一步探索，请查看这些其他流行的格式化工具：'
- en: autopep8 ([https://github.com/hhatto/autopep8](https://github.com/hhatto/autopep8))
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: autopep8 ([https://github.com/hhatto/autopep8](https://github.com/hhatto/autopep8))
- en: yapf ([https://github.com/google/yapf](https://github.com/google/yapf)), from
    Google
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: yapf ([https://github.com/google/yapf](https://github.com/google/yapf))，来自谷歌
- en: Now you’re able to keep your code in a consistent format with a single command.
    In the next section, you’ll learn to configure automated checks for common bugs
    in your code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用单个命令保持代码的一致格式。在下一节中，您将学习如何配置对代码中常见错误的自动检查。
- en: 6.4 Creating a tox environment for linting
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 创建用于linting的tox环境
- en: 'Some bugs and extraneous code in Python are incredibly common. Those that can
    be detected by their abstract syntax tree or other static analysis can be automatically
    scanned for. Consider the following function that uses an empty dictionary as
    the default value for an input argument, which is updated in the body of the function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的一些错误和多余的代码非常常见。那些可以通过其抽象语法树或其他静态分析检测到的错误可以自动扫描。考虑以下使用空字典作为输入参数默认值的函数，该值在函数体中被更新：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Uses a default dictionary if one isn’t supplied
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果未提供，则使用默认字典
- en: ❷ The dictionary, whether supplied or default, is updated and returned.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 无论提供与否，字典都会被更新并返回。
- en: This may look innocuous enough, but it turns out that mutable default argument
    values are dangerous. A mutable default argument value is initialized once at
    module import time and then remains for the duration of the Python process. That
    means that you could call `remove_params(["default_key"])` once, removing the
    `"default_key"` key from the default dictionary argument. But subsequent calls
    to the `remove_params` function will fail with a `KeyError`, because the default
    argument doesn’t get reinitialized and the `"default_key"` key has already been
    removed from the dictionary.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来无害，但结果是可变默认参数值是危险的。可变默认参数值在模块导入时初始化一次，并在整个Python进程期间保持不变。这意味着您可以调用一次`remove_params(["default_key"])`，从默认字典参数中删除`"default_key"`键。但随后的`remove_params`函数调用将因`KeyError`而失败，因为默认参数不会重新初始化，且`"default_key"`键已经被从字典中删除。
- en: Like code formatting, checking for this kind of common issue is often the default
    behavior in IDEs, but depending on your IDE, it may be easy to overlook errors
    or warnings if they aren’t currently causing runtime exceptions or test failures.
    To ensure these situations don’t go unnoticed, you can incorporate a tool to do
    this kind of scanning—often called *linting*—into your tox setup. Linting keeps
    your project free of unused code, such as unused imports. Linting also identifies
    things that may not cause immediate bugs or exceptions but may do so later in
    ways that are difficult to identify, like using a duplicate key in a long dictionary.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代码格式化一样，在 IDE 中检查这类常见问题通常是默认行为，但根据你的 IDE，如果它们目前没有导致运行时异常或测试失败，可能会很容易忽略错误或警告。为了确保这些情况不会被人忽视，你可以在
    tox 设置中集成一个进行此类扫描的工具——通常称为 *linting*。Linting 可以保持你的项目没有未使用的代码，例如未使用的导入。Linting
    还可以识别那些可能不会立即引起错误或异常，但可能在以后以难以识别的方式引起，比如在长字典中使用重复键。
- en: 'The flake8 package ([https://flake8.pycqa.org/en/latest/](https://flake8.pycqa.org/en/latest/))
    is another project maintained by the PyCQA that combines several other smaller
    code quality tools into one command-line interface. flake8 has been praised for
    providing strong coverage without being too tedious to manage. flake8 combines
    the powers of the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: flake8 包 ([https://flake8.pycqa.org/en/latest/](https://flake8.pycqa.org/en/latest/))
    是 PyCQA 维护的另一个项目，它将几个较小的代码质量工具组合成一个命令行界面。flake8 因其提供强大的覆盖范围且管理起来不繁琐而受到赞誉。flake8
    结合了以下工具的力量：
- en: pyflakes ([https://github.com/PyCQA/pyflakes](https://github.com/PyCQA/pyflakes))
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pyflakes ([https://github.com/PyCQA/pyflakes](https://github.com/PyCQA/pyflakes))
- en: pycodestyle ([https://github.com/PyCQA/pycodestyle](https://github.com/PyCQA/pycodestyle))
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pycodestyle ([https://github.com/PyCQA/pycodestyle](https://github.com/PyCQA/pycodestyle))
- en: mccabe ([https://github.com/PyCQA/mccabe](https://github.com/PyCQA/mccabe))
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mccabe ([https://github.com/PyCQA/mccabe](https://github.com/PyCQA/mccabe))
- en: Tip The `mccabe` package measures code complexity. Automating code complexity
    thresholds has proven finnicky for me at best. And when I do want to measure complexity,
    I like to use radon ([https://radon.readthedocs.io/en/latest/](https://radon.readthedocs.io/en/latest/))
    because it measures a wider variety of metrics in addition to the McCabe metrics.
    Although flake8 includes it, you don’t need to deal with mccabe unless you’d like
    to.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：`mccabe` 包测量代码复杂度。对我来说，自动化代码复杂度阈值在最好情况下也很棘手。当我确实想测量复杂度时，我喜欢使用 radon ([https://radon.readthedocs.io/en/latest/](https://radon.readthedocs.io/en/latest/))，因为它除了
    McCabe 指标外，还测量了更广泛的指标。尽管 flake8 包含它，但你不需要处理 mccabe，除非你想要这样做。
- en: 'flake8 is also built as a plugin-based architecture, with many extensions to
    the code behavior available from the community. As an example, flake8-bugbear
    ([https://github.com/PyCQA/flake8-bugbear](https://github.com/PyCQA/flake8-bugbear))
    catches a few common issues that flake8 doesn’t by default, such as the use of
    mutable default arguments (see “Mutable Default Arguments,” *Real Python*, [http://mng.bz/jA28](http://mng.bz/jA28)).
    flake8 uses flake8-bugbear’s functionality so long as flake8-bugbear is installed.
    Together, flake8 and its extensions find a wide variety of common issues, listing
    them in an actionable format. Each issue flake8 identifies is printed with the
    following information:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: flake8 也构建为基于插件的架构，社区提供了许多对代码行为的扩展。例如，flake8-bugbear ([https://github.com/PyCQA/flake8-bugbear](https://github.com/PyCQA/flake8-bugbear))
    捕获了一些 flake8 默认不捕获的常见问题，例如使用可变默认参数（参见“可变默认参数”，*Real Python*，[http://mng.bz/jA28](http://mng.bz/jA28)）。只要安装了
    flake8-bugbear，flake8 就会使用 flake8-bugbear 的功能。flake8 和其扩展一起发现了许多常见问题，并以可操作的形式列出。flake8
    识别的每个问题都会打印以下信息：
- en: The name of the file where the error was found
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到错误的文件名
- en: The line and column number in the file where the issue arose
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题出现的文件中的行号和列号
- en: The error code for the issue
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题错误代码
- en: A message indicating what went wrong, most often giving enough information for
    corrective action
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示出了什么问题的消息，通常提供足够的信息以进行纠正操作
- en: Exercise 6.5
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.5
- en: 'In your setup.cfg file, configure a new tox environment called `lint` for linting
    your project code. This environment has two dependencies—the `flake8` and `flake8-bugbear`
    packages. The environment should run one command, `flake8`, using tox’s `posargs`
    syntax you learned earlier, with the following default option: `src test`. This
    will indicate to flake8 which areas of code to lint.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的setup.cfg文件中，为你的项目代码配置一个新的tox环境，称为`lint`，用于代码风格检查。此环境有两个依赖项——`flake8`和`flake8-bugbear`包。该环境应运行一个命令`flake8`，使用你之前学到的tox的`posargs`语法，以下为默认选项：`src
    test`。这将指示flake8要检查哪些代码区域。
- en: When you’re finished, you should be able to run `tox -e lint` to lint your package
    code. Run the checks to determine whether flake8 finds any issues with your code.
    If you see an issue related to line length, continue to the next section before
    fixing. Fix any other issues that flake8 identifies.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你应该能够运行`tox -e lint`来对你的包代码进行代码风格检查。运行检查以确定flake8是否发现了你的代码中的任何问题。如果你看到与行长度相关的问题，在修复之前继续到下一节。修复flake8识别出的任何其他问题。
- en: 6.4.1 Configuring flake8
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 配置flake8
- en: You can configure flake8 using a new `[flake8]` section in your setup.cfg file.
    The main configuration options for flake8 ([http://mng.bz/WMxl](http://mng.bz/WMxl))
    involve fine-tuning some of the checks it performs, as well as ignoring some of
    the checks altogether. You should start by running all checks and learning which
    of them aren’t valuable to you.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用setup.cfg文件中的新`[flake8]`部分来配置flake8。flake8的主要配置选项（[http://mng.bz/WMxl](http://mng.bz/WMxl)）包括对它执行的一些检查进行微调，以及完全忽略一些检查。你应该从运行所有检查并学习其中哪些对你来说没有价值开始。
- en: For now, start by ensuring that flake8 is configured to allow the same maximum
    line length you set for `black`. Whereas the option for `black` was `line-length`,
    the option for flake8 is `max-line-length`. Once you’ve configured the line length,
    run flake8 again and ensure that it finds no remaining issues.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，首先确保flake8配置为允许与`black`设置相同的最大行长度。`black`的选项是`line-length`，而flake8的选项是`max-line-length`。一旦你配置了行长度，再次运行flake8并确保它没有发现任何剩余的问题。
- en: Alternative linters
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其他代码风格检查工具
- en: 'You might find that flake8 is just right, but it can be extended a bit to get
    you what you want. If you’re looking for something much more intensive, something
    that stays out of your way a bit more, or just something different, you can have
    a look at the following linters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现flake8正好适合你的需求，但它可以稍作扩展以满足你的需求。如果你在寻找更加强大、不那么干扰你的工具，或者只是想尝试不同的工具，你可以查看以下代码风格检查工具：
- en: pylint ([https://github.com/PyCQA/pylint/](https://github.com/PyCQA/pylint/))
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pylint ([https://github.com/PyCQA/pylint/](https://github.com/PyCQA/pylint/))
- en: prospector ([https://github.com/PyCQA/prospector](https://github.com/PyCQA/prospector))
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: prospector ([https://github.com/PyCQA/prospector](https://github.com/PyCQA/prospector))
- en: bandit ([https://github.com/PyCQA/bandit](https://github.com/PyCQA/bandit)),
    which has a specific eye toward security
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bandit ([https://github.com/PyCQA/bandit](https://github.com/PyCQA/bandit))，它专注于安全性
- en: vulture ([https://github.com/jendrikseipp/vulture](https://github.com/jendrikseipp/vulture)),
    which has a specific eye toward cleaning out unused code
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vulture ([https://github.com/jendrikseipp/vulture](https://github.com/jendrikseipp/vulture))，它专注于清理未使用的代码
- en: You can also use pyflakes, pycodestyle, or mccabe on their own as well.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以单独使用pyflakes、pycodestyle或mccabe。
- en: By augmenting your unit tests with linting, you can develop high confidence
    that your code behaves as you expect, without any lurking issues waiting to jump
    out later down the line.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在单元测试中增加代码风格检查，你可以开发出高度自信的代码，确保你的代码按照预期运行，而不会出现任何潜伏的问题等待在后续阶段跳出来。
- en: 'If you’ve made it here, you’ve successfully configured tox environments for
    checking the types, formatting, and linting of your code. Although you’ve put
    some important configuration in place that gives you a uniform way of performing
    static analysis, you might see that it can still be tedious to run these on a
    regular basis. With each change to your code, you’d need to run the following
    to fully exercise all the checks you’ve built:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达这里，你已经成功配置了tox环境来检查代码的类型、格式和代码风格。尽管你已经放置了一些重要的配置，为你提供了一个执行静态分析的一致方式，但你可能会发现定期运行这些检查仍然很繁琐。每次对你的代码进行更改时，你都需要运行以下命令来完全执行你构建的所有检查：
- en: '`tox` to test the code'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tox`来测试代码
- en: '`tox -e typecheck` to type check the code'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tox -e typecheck`来检查代码的类型
- en: '`tox -e format` and sometimes `tox -e format src test` to format the code'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tox -e format`和有时使用`tox -e format src test`来格式化代码
- en: '`tox -e lint` to check the code for common bugs'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tox -e lint`来检查代码中的常见错误
- en: 'You can always speed up the process by running all the commands in parallel
    using a command like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用以下命令之类的命令并行运行所有命令来加快这个过程：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But even this can be tedious, and you may still forget a step on occasion. Continuous
    integration practices help address these gaps by running important checks on each
    change you make. Continue to the next chapter to jump in when you’re ready.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使这样也可能很繁琐，你有时可能还是会忘记一个步骤。持续集成实践通过在每个更改上运行重要检查来帮助解决这些差距。当你准备好时，继续到下一章。
- en: Answers to exercises
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习答案
- en: '**6.1**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.1**'
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**6.2**—Answer: A, D, E, F, G, I'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.2**—答案：A, D, E, F, G, I'
- en: '(A), B, and C: tox uses the environments in `envlist` by default. `envlist`
    lists two environments.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(A), B, 和 C: tox 默认使用 `envlist` 中的环境。`envlist` 列出了两个环境。'
- en: '(D): Yes, because it’s in `[testimports]deps`, which `[testenv]deps` extends—and
    `py39` uses `[testenv]` for configuration.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(D): 是的，因为它在 `[testimports]deps` 中，而 `[testenv]deps` 扩展了它，并且 `py39` 使用 `[testenv]`
    进行配置。'
- en: '(E): Yes, because it’s explicitly listed.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(E): 是的，因为它被明确列出。'
- en: '(F): Yes, because it’s in `[testimports]deps`, which `[testenv:check-imports]
    deps` extends.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(F): 是的，因为它在 `[testimports]deps` 中，而 `[testenv:check-imports] deps` 扩展了它。'
- en: '(G): Yes, because installation always happens unless you explicitly opt out.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(G): 是的，因为安装总是发生，除非你明确选择退出。'
- en: 'H and (I): There is a total of four environments—the two environments in `envlist`
    (that use `[testenv]deps`, which extends `[testimports]deps`), the `myenv` environment,
    and the `check-imports` environment. The `myenv` environment doesn’t reference
    `[testimports]deps`, so it is unimpacted, leaving a total of three impacted environments.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'H 和 (I): 总共有四个环境——`envlist` 中的两个环境（使用 `[testenv]deps`，它扩展了 `[testimports]deps`），`myenv`
    环境，以及 `check-imports` 环境。`myenv` 环境不引用 `[testimports]deps`，因此不受影响，总共影响三个环境。'
- en: '**6.3**—Answer: See the code companion for this chapter.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.3**—答案：参见本章的代码伴侣。'
- en: '**6.4**—Answer: See the code companion for this chapter.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.4**—答案：参见本章的代码伴侣。'
- en: '**6.5**—Answer: See the code companion for this chapter.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.5**—答案：参见本章的代码伴侣。'
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Although commonly used for testing, tox is a productive general-use task management
    tool.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然通常用于测试，但 tox 是一个多用途的生产力任务管理工具。
- en: Type checking builds higher confidence that the intended interfaces for code
    are being used properly.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查可以增加对代码预期接口被正确使用的信心。
- en: Automate or obviate decisions unrelated to the core value of what you want to
    deliver.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化或消除与您想要交付的核心价值无关的决策。
- en: Leverage linting tools to find common issues your unit tests may not uncover.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用代码检查工具来查找单元测试可能未发现的常见问题。
