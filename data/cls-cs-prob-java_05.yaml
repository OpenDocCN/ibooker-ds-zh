- en: 4 Graph problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 图问题
- en: A graph is an abstract mathematical construct that is used for modeling a real-world
    problem by dividing the problem into a set of connected nodes. We call each of
    the nodes a vertex and each of the connections an edge. For instance, a subway
    map can be thought of as a graph representing a transportation network. Each of
    the dots represents a station, and each of the lines represents a route between
    two stations. In graph terminology, we would call the stations “vertices” and
    the routes “edges.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一种抽象的数学结构，通过将问题划分为一组连接的节点来模拟现实世界的问题。我们称每个节点为一个顶点，每个连接为一个边。例如，地铁图可以被视为表示交通网络的图。每个点代表一个车站，每条线代表两个车站之间的路线。在图术语中，我们会称车站为“顶点”，路线为“边”。
- en: Why is this useful? Not only do graphs help us think abstractly about a problem,
    but they also let us apply several well-understood and performant search and optimization
    techniques. For instance, in the subway example, suppose we want to know the shortest
    route from one station to another. Or suppose we want to know the minimum amount
    of track needed to connect all of the stations. Graph algorithms that you will
    learn in this chapter can solve both of those problems. Further, graph algorithms
    can be applied to any kind of network problem--not just transportation networks.
    Think of computer networks, distribution networks, and utility networks. Search
    and optimization problems across all of these spaces can be solved using graph
    algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么用呢？图不仅帮助我们抽象地思考问题，而且让我们能够应用几种被广泛理解和性能良好的搜索和优化技术。例如，在地铁示例中，假设我们想知道从一个车站到另一个车站的最短路线。或者假设我们想知道连接所有车站所需的最小轨道量。本章中你将学习的图算法可以解决这两个问题。此外，图算法可以应用于任何类型的网络问题——不仅仅是交通网络。想想计算机网络、分销网络和公用事业网络。所有这些空间中的搜索和优化问题都可以使用图算法来解决。
- en: 4.1 A map as a graph
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 地图作为图
- en: In this chapter, we’ll work with a graph of, not subway stations, but cities
    of the United States and potential routes between them. Figure 4.1 is a map of
    the continental United States and the 15 largest metropolitan statistical areas
    (MSAs) in the country, as estimated by the US Census Bureau.[1](#pgfId-1155483)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理一个图，不是地铁车站，而是美国的城市及其之间的潜在路线。图4.1是大陆美国的地图，以及美国人口普查局估计的该国前15个最大的都会统计区（MSA）。[1](#pgfId-1155483)
- en: '![4-1](../Images/4-1.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![4-1](../Images/4-1.png)'
- en: Figure 4.1 A map of the 15 largest MSAs in the United States
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 美国前15大都会统计区（MSA）的地图
- en: Famous entrepreneur Elon Musk has suggested building a new high-speed transportation
    network composed of capsules traveling in pressurized tubes. According to Musk,
    the capsules would travel at 700 miles per hour and be suitable for cost-effective
    transportation between cities less than 900 miles apart.[2](#pgfId-1155493) He
    calls this new transportation system the “Hyperloop.” In this chapter we will
    explore classic graph problems in the context of building out this transportation
    network.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 著名企业家埃隆·马斯克曾建议建立一个由胶囊在加压管道中旅行的新的高速交通网络。据马斯克所说，这些胶囊将以每小时700英里的速度行驶，适合于900英里以内的城市之间的成本效益交通。[2](#pgfId-1155493)
    他将这个新的交通系统称为“超级高铁”。在本章中，我们将探讨在构建这个交通网络背景下的经典图问题。
- en: Musk initially proposed the Hyperloop idea for connecting Los Angeles and San
    Francisco. If one were to build a national Hyperloop network, it would make sense
    to do so between America’s largest metropolitan areas. In figure 4.2, the state
    outlines from figure 4.1 are removed. In addition, each of the MSAs is connected
    with some of its neighbors. To make the graph a little more interesting, those
    neighbors are not always the MSA’s closest neighbors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 马斯克最初提出超级高铁的想法是为了连接洛杉矶和旧金山。如果建立一个全国性的超级高铁网络，那么在美洲最大的都会区之间进行建设是有意义的。在图4.2中，图4.1中的州轮廓被移除。此外，每个MSA都与一些邻居相连。为了使图更有趣，这些邻居不总是MSA最近的邻居。
- en: Figure 4.2 is a graph with vertices representing the 15 largest MSAs in the
    United States and edges representing potential Hyperloop routes between cities.
    The routes were chosen for illustrative purposes. Certainly, other potential routes
    could be part of a new Hyperloop network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2是一个图，顶点代表美国的15个最大都会统计区，边代表城市之间的潜在超级高铁路线。这些路线是为了说明目的而选择的。当然，其他潜在的路线也可能成为新的超级高铁网络的一部分。
- en: '![4-2](../Images/4-2.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![4-2](../Images/4-2.png)'
- en: Figure 4.2 A graph with vertices representing the 15 largest MSAs in the United
    States and edges representing potential Hyperloop routes between them
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 一个图，顶点代表美国最大的15个MSA，边代表它们之间的潜在Hyperloop路线
- en: This abstract representation of a real-world problem highlights the power of
    graphs. With this abstraction, we can ignore the geography of the United States
    and concentrate on thinking about the potential Hyperloop network simply in the
    context of connecting cities. In fact, as long as we keep the edges the same,
    we can think about the problem with a different-looking graph. In figure 4.3,
    for example, the location of Miami has moved. The graph in figure 4.3, being an
    abstract representation, can address the same fundamental computational problems
    as the graph in figure 4.2, even if Miami is not where we would expect it. But
    for our sanity, we will stick with the representation in figure 4.2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对现实世界问题的抽象表示突出了图的力量。通过这种抽象，我们可以忽略美国的地理，只需在连接城市的背景下思考潜在的Hyperloop网络。事实上，只要我们保持边不变，我们就可以用不同外观的图来思考这个问题。例如，在图4.3中，迈阿密的地理位置已移动。图4.3作为一个抽象表示，可以解决与图4.2相同的根本计算问题，即使迈阿密不在我们预期的位置。但为了我们的理智，我们将坚持图4.2中的表示。
- en: '![4-3](../Images/4-3.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![4-3](../Images/4-3.png)'
- en: Figure 4.3 A graph equivalent to that in figure 4.2, with the location of Miami
    moved
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 与图4.2中相同的图，但迈阿密的地理位置已移动
- en: 4.2 Building a graph framework
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 构建图框架
- en: 'In this section, we will define two different types of graphs: unweighted and
    weighted. Weighted graphs, which we will discuss later in the chapter, associate
    a weight (read number, such as a length in the case of our example) with each
    edge.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义两种不同类型的图：无向图和有向图。有向图，我们将在本章后面讨论，将一个权重（读作数字，例如在我们的例子中是一个长度）与每条边关联。
- en: At its heart, Java is an object-oriented programming language. We will make
    use of the inheritance model, fundamental to Java’s object-oriented class hierarchies,
    so we do not duplicate our effort. The classes for both unweighted and weighted
    graphs will be derived from an abstract base class known as Graph. This will allow
    them to inherit much of their functionality, with small tweaks for what makes
    a weighted graph distinct from an unweighted graph.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，Java是一种面向对象的编程语言。我们将利用Java面向对象类层次结构的基本继承模型，这样我们就不需要重复我们的努力。无向图和有向图的类都将从称为Graph的抽象基类派生。这将使它们继承大部分功能，并对使有向图与无向图区分开来的特性进行小的调整。
- en: We want this graph framework to be as flexible as possible so that it can represent
    as many different problems as possible. To achieve this goal, we will use generics
    to abstract away the type of the vertices. Every vertex will ultimately be assigned
    an integer index, but it will be stored as the user-defined generic type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个图框架尽可能灵活，以便它可以表示尽可能多的不同问题。为了实现这个目标，我们将使用泛型来抽象顶点的类型。每个顶点最终都将被分配一个整数索引，但它将以用户定义的泛型类型存储。
- en: Let’s start work on the framework by defining the Edge class, which is the simplest
    machinery in our graph framework.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义Edge类开始构建框架，这是我们的图框架中最简单的机制。
- en: Listing 4.1 Edge.java
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 Edge.java
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An Edge is defined as a connection between two vertices, each of which is represented
    by an integer index. By convention, u is used to refer to the first vertex, and
    v is used to represent the second vertex. You can also think of u as “from” and
    v as “to.” In this chapter, we are only working with undirected graphs (graphs
    with edges that allow travel in both directions), but in directed graphs, also
    known as digraphs, edges can also be one-way. The reversed() method is meant to
    return an Edge that travels in the opposite direction of the edge it is applied
    to.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 边被定义为两个顶点之间的连接，每个顶点都由一个整数索引表示。按照惯例，u用于指代第一个顶点，v用于表示第二个顶点。你也可以把u看作“从”，v看作“到”。在本章中，我们只处理无向图（允许双向旅行的边），但在有向图，也称为有向图（digraphs）中，边也可以是单向的。reversed()方法旨在返回一个与应用于其上的边相反方向的边。
- en: 'The Graph abstract class focuses on the essential role of a graph: associating
    vertices with edges. Again, we want to let the actual types of the vertices be
    whatever the user of the framework desires. We do this by making the vertex type
    generic (V). This lets the framework be used for a wide range of problems without
    needing to make intermediate data structures that glue everything together. For
    example, in a graph like the one for Hyperloop routes, we might define the type
    of the vertices to be String, because we would use strings like “New York” and
    “Los Angeles” as the vertices. The type of the edges in the graph (E) is also
    generic, so that it can be set by the subclasses to be an unweighted or weighted
    edge type. Let’s begin the Graph class.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图的抽象类关注图的基本角色：将顶点与边关联起来。再次强调，我们希望让框架的使用者能够定义顶点的实际类型。我们通过使顶点类型泛型（V）来实现这一点。这使得框架能够用于广泛的领域，而无需创建将所有内容粘合在一起的中介数据结构。例如，在Hyperloop路线的图中，我们可能会将顶点的类型定义为String，因为我们可能会使用像“纽约”和“洛杉矶”这样的字符串作为顶点。图中边的类型（E）也是泛型的，因此子类可以将其设置为无权边或有权边类型。让我们开始介绍Graph类。
- en: Listing 4.2 Graph.java
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 Graph.java
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The vertices list is the heart of a Graph. Each vertex will be stored in the
    list, but we will later refer to them by their integer index in the list. The
    vertex itself may be a complex data type, but its index will always be an int,
    which is easy to work with. On another level, by putting this index between graph
    algorithms and the vertices list, it allows us to have two vertices that are equal
    in the same graph. (Imagine a graph with a country’s cities as vertices, where
    the country has more than one city named “Springfield.”) Even though they are
    the same, they will have different integer indices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点列表是图的核心。每个顶点都将存储在列表中，但我们将稍后通过列表中的整数索引来引用它们。顶点本身可能是一个复杂的数据类型，但它的索引始终是int类型，这很容易处理。在另一个层面上，通过在图算法和顶点列表之间放置这个索引，它允许我们在同一个图中有两个相等的顶点。（想象一个以一个国家的城市为顶点的图，这个国家有多个名为“斯普林菲尔德”的城市。）即使它们是相同的，它们也将有不同的整数索引。
- en: There are many ways to implement a graph data structure, but the two most common
    are to use a vertex matrix or adjacency lists. In a vertex matrix, each cell of
    the matrix represents the intersection of two vertices in the graph, and the value
    of that cell indicates the connection (or lack thereof) between them. Our graph
    data structure uses adjacency lists. In this graph representation, every vertex
    has a list of vertices that it is connected to. Our specific representation uses
    a list of lists of edges, so for every vertex there is a list of edges via which
    the vertex is connected to other vertices. edges is this list of lists.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实现图数据结构的方法有很多，但最常见的是使用顶点矩阵或邻接表。在顶点矩阵中，矩阵的每个单元格代表图中两个顶点的交集，该单元格的值表示它们之间的连接（或没有连接）。我们的图数据结构使用邻接表。在这种图表示中，每个顶点都有一个与它相连的顶点列表。我们特定的表示使用边列表的列表，因此对于每个顶点，都有一个通过它连接到其他顶点的边列表。这个列表就是边列表。
- en: The rest of the Graph class is now presented in its entirety. You will notice
    the use of short, mostly one-line methods, with verbose and clear method names.
    This should make the rest of the class largely self-explanatory, but short comments
    are included so that there is no room for misinterpretation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Graph类的其余部分现在完整呈现。你会注意到使用了简短、大多为单行的方法，方法名称详细且清晰。这应该使得类的其余部分大部分可以自我解释，但仍然包含了简短的注释，以确保没有误解的空间。
- en: Listing 4.3 Graph.java continued
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 Graph.java 继续部分
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s step back for a moment and consider why this class has two versions of
    most of its methods. We know from the class definition that the list vertices
    is a list of elements of type V, which can be any Java class. So we have vertices
    of type V that are stored in the vertices list. But if we want to retrieve or
    manipulate them later, we need to know where they are stored in that list. Hence,
    every vertex has an index in the list (an integer) associated with it. If we don’t
    know a vertex’s index, we need to look it up by searching through vertices. That
    is why there are two versions of every method. One operates on int indices, and
    one operates on V itself. The methods that operate on V look up the relevant indices
    and call the index-based function. Therefore, they can be considered convenience
    methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时退一步，考虑为什么这个类的大多数方法有两个版本。从类定义中我们知道，vertices 列表是类型 V 的元素列表，V 可以是任何 Java 类。因此，我们有存储在
    vertices 列表中的类型为 V 的顶点。但如果我们想稍后检索或操作它们，我们需要知道它们在列表中的位置。因此，每个顶点在列表中都有一个与之关联的索引（一个整数）。如果我们不知道一个顶点的索引，我们需要通过在
    vertices 中搜索来查找它。这就是为什么每个方法都有两个版本的原因。一个操作整数索引，另一个操作 V 本身。操作 V 的方法查找相关的索引并调用基于索引的函数。因此，它们可以被认为是便利方法。
- en: 'Most of the functions are fairly self-explanatory, but neighborsOf() deserves
    a little unpacking. It returns the neighbors of a vertex. A vertex’s neighbors
    are all of the other vertices that are directly connected to it by an edge. For
    example, in figure 4.2, New York and Washington are the only neighbors of Philadelphia.
    We find the neighbors for a vertex by looking at the ends (the vs) of all of the
    edges going out from it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数都是相当直观的，但 neighborsOf() 方法值得稍作解释。它返回一个顶点的邻居。一个顶点的邻居是所有通过边直接连接到它的其他顶点。例如，在图
    4.2 中，纽约和华盛顿是费城的唯一邻居。我们通过查看从该顶点出发的所有边的末端（即 vs）来找到顶点的邻居：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: edges.get(index) returns the adjacency list, the list of edges through which
    the vertex in question is connected to other vertices. In the stream passed to
    the map() call, edge represents one particular edge, and edge.v represents the
    index of the neighbor that the edge is connected to. map() will return all of
    the vertices (as opposed to just their indices), because map() applies the vertexAt()
    method on every edge.v.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: edges.get(index) 返回邻接表，即通过这些边连接到其他顶点的边的列表。在传递给 map() 调用的流中，edge 代表一条特定的边，而 edge.v
    代表边连接到的邻居的索引。map() 将返回所有顶点（而不是仅仅它们的索引），因为 map() 在每个 edge.v 上应用 vertexAt() 方法。
- en: Now that we have the basic functionality of a graph implemented in the Graph
    abstract class, we can define a concrete subclass. Beyond being undirected or
    directed, graphs can also be unweighted or weighted. A weighted graph is one that
    has some comparable value, usually numeric, associated with each of its edges.
    We could think of the weights in our potential Hyperloop network as being the
    distances between the stations. For now, though, we will deal with an unweighted
    version of the graph. An unweighted edge is simply a connection between two vertices;
    hence, the Edge class is unweighted. Another way of putting it is that in an unweighted
    graph we know which vertices are connected, whereas in a weighted graph we know
    which vertices are connected and also know something about those connections.
    UnweightedGraph represents a graph that has no values associated with its edges.
    In other words, it’s the combination of Graph with the other class we’ve defined,
    Edge.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 Graph 抽象类中实现了图的基本功能，我们可以定义一个具体的子类。除了是无向或是有向之外，图还可以是无权或有权的。一个有权重的图是指其每条边都关联着某种可比较的值，通常是数值。我们可以将我们潜在的超环网络中的权重视为站点之间的距离。然而，目前我们将处理图的未加权版本。未加权边仅仅是两个顶点之间的连接；因此，Edge
    类是无权重的。另一种说法是，在无权图中，我们知道哪些顶点是相连的，而在有权图中，我们知道哪些顶点是相连的，并且还知道一些关于这些连接的信息。UnweightedGraph
    表示一个没有与边关联值的图。换句话说，它是 Graph 与我们定义的另一个类 Edge 的组合。
- en: Listing 4.4 UnweightedGraph.java
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 UnweightedGraph.java
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One detail worth pointing out is the way addEdge() works. addEdge() first adds
    an edge to the adjacency list of the “from” vertex (u) and then adds a reversed
    version of the edge to the adjacency list of the “to” vertex (v). The second step
    is necessary because this graph is undirected. We want every edge to be added
    in both directions; this means that u will be a neighbor of v in the same way
    that v is a neighbor of u. You can think of an undirected graph as being bidirectional
    if it helps you remember that it means any edge can be traversed in either direction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的一点是addEdge()的工作方式。addEdge()首先将边添加到“from”顶点的邻接列表中，然后添加边的反向版本到“to”顶点的邻接列表中。第二步是必要的，因为此图是无向的。我们希望每条边都向两个方向添加；这意味着u将是v的邻居，就像v是u的邻居一样。如果你觉得这有助于记忆，你可以将无向图视为双向的。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As was mentioned earlier, we are only dealing with undirected graphs in this
    chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们本章只处理无向图。
- en: 4.2.1 Working with Edge and UnweightedGraph
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 使用Edge和UnweightedGraph
- en: Now that we have concrete implementations of Edge and Graph, we can create a
    representation of the potential Hyperloop network. The vertices and edges in cityGraph
    correspond to the vertices and edges represented in figure 4.2\. Using generics,
    we can specify that vertices will be of type String (UnweightedGraph<String>).
    In other words, the String type fills in for the type variable V.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了Edge和Graph的具体实现，我们可以创建一个潜在Hyperloop网络的表示。cityGraph中的顶点和边对应于图4.2中表示的顶点和边。使用泛型，我们可以指定顶点将是String类型（UnweightedGraph<String>）。换句话说，String类型填充了类型变量V。
- en: Listing 4.5 UnweightedGraph.java continued
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 UnweightedGraph.java的继续
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'cityGraph has vertices of type String, and we indicate each vertex with the
    name of the MSA that it represents. It is irrelevant in what order we add the
    edges to cityGraph. Because we implemented toString() with a nicely printed description
    of the graph, we can now pretty-print (that’s a real term!) the graph. You should
    get output similar to the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: cityGraph的顶点是String类型，我们用代表该MSA（大都市统计区）的名字来表示每个顶点。我们添加边到cityGraph的顺序无关紧要。因为我们实现了toString()，它以一个漂亮的图形描述来打印，我们现在可以很好地打印（这是一个真正的术语！）图形。你应该得到类似以下内容的输出：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 4.3 Finding the shortest path
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 寻找最短路径
- en: The Hyperloop is so fast that for optimizing travel time from one station to
    another, it probably matters less how long the distances are between the stations
    and more how many hops it takes (how many stations need to be visited) to get
    from one station to another. Each station may involve a layover, so just like
    with flights, the fewer stops, the better.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperloop的速度如此之快，以至于在优化从一个车站到另一个车站的旅行时间时，车站之间的距离可能不如需要多少跳（需要访问多少个车站）重要。每个车站可能涉及转机，所以就像航班一样，停靠站越少越好。
- en: In graph theory, a set of edges that connects two vertices is known as a path.
    In other words, a path is a way of getting from one vertex to another vertex.
    In the context of the Hyperloop network, a set of tubes (edges) represents the
    path from one city (vertex) to another (vertex). Finding optimal paths between
    vertices is one of the most common problems that graphs are used for.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，连接两个顶点的边集被称为路径。换句话说，路径是从一个顶点到另一个顶点的一种方式。在Hyperloop网络的情况下，一组管道（边）代表从一个城市（顶点）到另一个（顶点）的路径。在顶点之间寻找最优路径是图应用中最常见的问题之一。
- en: Informally, we can also think of a list of vertices sequentially connected to
    one another by edges as a path. This description is really just another side of
    the same coin. It is like taking a list of edges, figuring out which vertices
    they connect, keeping that list of vertices, and throwing away the edges. In this
    brief example, we will find such a list of vertices that connects two cities on
    our Hyperloop.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，我们也可以将通过边顺序连接的顶点列表视为一条路径。这种描述实际上只是同一枚硬币的另一面。这就像取一个边的列表，找出它们连接的顶点，保留这个顶点列表，然后丢弃边。在这个简短的例子中，我们将找到连接我们Hyperloop上两个城市的顶点列表。
- en: 4.3.1 Revisiting breadth-first search (BFS)
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 重新审视广度优先搜索（BFS）
- en: In an unweighted graph, finding the shortest path means finding the path that
    has the fewest edges between the starting vertex and the destination vertex. To
    build out the Hyperloop network, it might make sense to first connect the furthest
    cities on the highly populated seaboards. That raises the question, “What is the
    shortest path between Boston and Miami?”
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在无权图中，找到最短路径意味着找到起点顶点和目标顶点之间边数最少的路径。为了构建Hyperloop网络，首先连接高度人口密集的海岸线上的最远城市可能是有意义的。这提出了问题：“波士顿和迈阿密之间的最短路径是什么？”
- en: Tip This section assumes that you have read chapter 2\. Before continuing, ensure
    that you are comfortable with the material on breadth-first search in chapter
    2.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：本节假设您已经阅读了第2章。在继续之前，请确保您对第2章中关于广度优先搜索的内容感到舒适。
- en: Luckily, we already have an algorithm for finding shortest paths, and we can
    reuse it to answer this question. Breadth-first search, introduced in chapter
    2, is just as viable for graphs as it is for mazes. In fact, the mazes we worked
    with in chapter 2 really are graphs. The vertices are the locations in the maze,
    and the edges are the moves that can be made from one location to another. In
    an unweighted graph, a breadth-first search will find the shortest path between
    any two vertices.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经有了一个用于找到最短路径的算法，并且我们可以重用它来回答这个问题。在第2章中引入的广度优先搜索（Breadth-first search）对于图来说，就像对于迷宫一样可行。实际上，我们在第2章中处理的迷宫实际上真的是图。顶点是迷宫中的位置，边是从一个位置移动到另一个位置的动作。在一个无权图中，广度优先搜索将找到任何两个顶点之间的最短路径。
- en: We can reuse the breadth-first search implementation from chapter 2 to work
    with Graph. In fact, we can reuse it completely unchanged. This is the power of
    writing code generically!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用第2章中的广度优先搜索实现来与图（Graph）一起工作。实际上，我们可以完全不变地重用它。这就是编写通用代码的力量！
- en: 'Recall that bfs() in chapter 2 requires three parameters: an initial state,
    a Predicate (read function that returns a boolean) for testing for a goal, and
    a Function that finds the successor states for a given state. The initial state
    will be the vertex represented by the string “Boston.” The goal test will be a
    lambda that checks if a vertex is equivalent to “Miami.” Finally, successor vertices
    can be generated by the Graph method neighborsOf().'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，第2章中的bfs()需要三个参数：一个初始状态、一个用于测试目标（即返回布尔值的函数）的谓词（Predicate），以及一个用于找到给定状态的后续状态的函数。初始状态将是表示字符串“波士顿”的顶点。目标测试将是一个检查顶点是否等同于“迈阿密”的lambda表达式。最后，可以通过Graph方法neighborsOf()生成后续顶点。
- en: With this plan in mind, we can add code to the end of the main() method of UnweightedGraph.java
    to find the shortest route between Boston and Miami on cityGraph.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个计划的基础上，我们可以在UnweightedGraph.java的主()方法末尾添加代码，以找到cityGraph上波士顿和迈阿密之间的最短路线。
- en: NOTE Listing 4.4 (earlier in the chapter where UnweightedGraph was first defined)
    included imports that support this section (i.e., chapter2.GenericSearch, chapter2.genericSearch.Node).
    These imports will only work if the chapter2 package is accessible from the chapter4
    package. If you did not configure your development environment in this way, you
    should be able to copy the GenericSearch class directly into the chapter4 package
    and eliminate the imports.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：列表4.4（本章中首次定义UnweightedGraph的地方）包含了支持本节（即，chapter2.GenericSearch，chapter2.genericSearch.Node）的导入。这些导入只有在chapter2包可以从chapter4包访问时才会工作。如果您没有以这种方式配置您的开发环境，您应该能够将GenericSearch类直接复制到chapter4包中，并消除导入。
- en: Listing 4.6 UnweightedGraph.java continued
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 UnweightedGraph.java 续
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output should look something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Boston to Detroit to Washington to Miami, composed of three edges, is the shortest
    route between Boston and Miami in terms of the number of edges. Figure 4.4 highlights
    this route.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 波士顿到底特律到华盛顿再到迈阿密，由三个边组成，这是从波士顿到迈阿密在边数意义上的最短路线。图4.4突出了这条路线。
- en: '![4-4](../Images/4-4.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![4-4](../Images/4-4.png)'
- en: Figure 4.4 The shortest route between Boston and Miami, in terms of the number
    of edges, is highlighted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 以边数来衡量，波士顿和迈阿密之间的最短路线被突出显示。
- en: 4.4 Minimizing the cost of building the network
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 最小化网络构建的成本
- en: Imagine that we want to connect all 15 of the largest MSAs to the Hyperloop
    network. Our goal is to minimize the cost of rolling out the network, so that
    means using a minimum amount of track. Then the question is, “How can we connect
    all of the MSAs using the minimum amount of track?”
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将所有15个最大的MSA连接到Hyperloop网络。我们的目标是使网络的推广成本最小化，这意味着使用最少的轨道。那么问题就是，“我们如何使用最少的轨道将所有MSA连接起来？”
- en: 4.4.1 Working with weights
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 处理权重
- en: To understand the amount of track that a particular edge may require, we need
    to know the distance that the edge represents. This is an opportunity to reintroduce
    the concept of weights. In the Hyperloop network, the weight of an edge is the
    distance between the two MSAs that it connects. Figure 4.5 is the same as figure
    4.2 except that it has a weight added to each edge, representing the distance
    in miles between the two vertices that the edge connects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解特定边可能需要的轨道数量，我们需要知道边所代表的距离。这是重新引入权重概念的机会。在Hyperloop网络中，边的权重是它连接的两个MSA之间的距离。图4.5与图4.2相同，只是它为每条边添加了一个权重，表示连接的两个顶点之间的距离（以英里为单位）。
- en: '![4-5](../Images/4-5.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![4-5](../Images/4-5.png)'
- en: Figure 4.5 A weighted graph of the 15 largest MSAs in the United States, where
    each of the weights represents the distance between two MSAs in miles
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5展示了美国15个最大都市统计区（MSA）的加权图，其中每个权重代表两个MSA之间的距离（以英里为单位）
- en: To handle weights, we will need a subclass of Edge (WeightedEdge) and a subclass
    of Graph (WeightedGraph). Every WeightedEdge will have a double associated with
    it, representing its weight. Jarník’s algorithm, which we will cover later in
    the chapter, requires the ability to compare one edge with another to determine
    the edge with the lowest weight. This is easy to do with numeric weights.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理权重，我们需要Edge的子类（WeightedEdge）和Graph的子类（WeightedGraph）。每个WeightedEdge都将有一个与其关联的双精度浮点数，表示其权重。我们将在本章后面介绍的Jarník算法需要能够比较一条边与另一条边，以确定具有最低权重的边。使用数值权重来做这件事很容易。
- en: Listing 4.7 WeightedEdge.java
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 WeightedEdge.java
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The implementation of WeightedEdge is not immensely different from that of Edge.
    It only differs in the addition of a weight property and the implementation of
    the Comparable interface via compareTo(), so that two WeightedEdges are comparable.
    The compareTo() method is only interested in looking at weights (as opposed to
    including the inherited properties u and v), because Jarník’s algorithm needs
    to find the smallest edge by weight.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: WeightedEdge的实现与Edge的实现没有很大区别。它只是在添加了一个权重属性并通过compareTo()方法实现Comparable接口，以便两个WeightedEdge可以进行比较。compareTo()方法只关注查看权重（而不是包括继承的属性u和v），因为Jarník算法需要通过权重找到最小的边。
- en: A WeightedGraph inherits much of its functionality from Graph. Other than that,
    it has a constructor, it has convenience methods for adding WeightedEdges, and
    it implements its own version of toString().
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: WeightedGraph从Graph继承了大部分功能。除此之外，它有一个构造函数，它有添加WeightedEdges的便利方法，并实现了自己的toString()版本。
- en: Listing 4.8 WeightedGraph.java
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 WeightedGraph.java
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is now possible to actually define a weighted graph. The weighted graph we
    will work with is a representation of figure 4.5 called cityGraph2.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以实际定义加权图了。我们将要处理的加权图是图4.5的表示，称为cityGraph2。
- en: Listing 4.9 WeightedGraph.java continued
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 WeightedGraph.java（续）
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because WeightedGraph implements toString(), we can pretty-print cityGraph2.
    In the output, you will see both the vertices that each vertex is connected to
    and the weights of those connections:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为WeightedGraph实现了toString()，所以我们可以格式化打印cityGraph2。在输出中，您将看到每个顶点连接到的顶点以及这些连接的权重：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 4.4.2 Finding the minimum spanning tree
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 寻找最小生成树
- en: 'A tree is a special kind of graph that has one, and only one, path between
    any two vertices. This implies that there are no cycles in a tree (which is sometimes
    called acyclic). A cycle can be thought of as a loop: if it is possible to traverse
    a graph from a starting vertex, never repeat any edges, and get back to the same
    starting vertex, then it has a cycle. Any connected graph that is not a tree can
    become a tree by pruning edges. Figure 4.6 illustrates pruning an edge to turn
    a graph into a tree.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种特殊的图，它在任何两个顶点之间只有一个路径。这意味着树中没有环（有时也称为无环）。环可以被视为一个循环：如果可以从一个起始顶点遍历图，不重复任何边，并回到相同的起始顶点，那么它就有环。任何不是树的连通图都可以通过剪枝变成树。图4.6说明了剪枝将图变成树的过程。
- en: '![4-6](../Images/4-6.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![4-6](../Images/4-6.png)'
- en: Figure 4.6 In the left graph, a cycle exists between vertices B, C, and D, so
    it is not a tree. In the right graph, the edge connecting C and D has been pruned,
    so the graph is a tree.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 在左图中，顶点 B、C 和 D 之间存在一个循环，因此它不是一个树。在右图中，连接 C 和 D 的边已被修剪，因此该图是一个树。
- en: A connected graph is a graph that has some way of getting from any vertex to
    any other vertex. (All of the graphs we are looking at in this chapter are connected.)
    A spanning tree is a tree that connects every vertex in a graph. A minimum spanning
    tree is a tree that connects every vertex in a weighted graph with the minimum
    total weight (compared to other spanning trees). For every connected weighted
    graph, it is possible to efficiently find its minimum spanning tree.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个连通图是一个有从任何顶点到任何其他顶点的方法的图。（我们本章中查看的所有图都是连通的。）一个生成树是一个连接图中每个顶点的树。一个最小生成树是一个连接加权图中每个顶点且总权重最小的树（与其他生成树相比）。对于每个连通加权图，都可以高效地找到其最小生成树。
- en: 'Whew--that was a lot of terminology! The point is that finding a minimum spanning
    tree is the same as finding a way to connect every vertex in a weighted graph
    with the minimum weight. This is an important and practical problem for anyone
    designing a network (transportation network, computer network, and so on): how
    can every node in the network be connected for the minimum cost? That cost may
    be in terms of wire, track, road, or anything else. For instance, for a telephone
    network, another way of posing the problem is, “What is the minimum length of
    cable one needs to connect every phone?”'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 呼——这有很多术语！重点是，寻找最小生成树与找到一种以最小权重连接加权图中每个顶点的方法相同。这对于任何设计网络（交通网络、计算机网络等）的人来说都是一个重要且实际的问题：如何以最低成本连接网络中的每个节点？这种成本可能是线缆、轨道、道路或其他任何东西。例如，对于电话网络，提出问题的另一种方式是，“连接每个电话需要多少最小长度的电缆？”
- en: Calculating the total weight of a weighted path
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 计算加权路径的总权重
- en: Before we develop a method for finding a minimum spanning tree, we will develop
    a function we can use to test the total weight of a solution. The solution to
    the minimum spanning tree problem will consist of a list of weighted edges that
    compose the tree. For our purposes, we will think about a weighted path as a list
    of WeightedEdges. We will define a totalWeight() method that takes a list of WeightedEdges
    and finds the total weight that results from adding all of its edges’ weights
    together. Note that this method, and the rest in this chapter, will be added to
    the existing WeightedGraph class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发寻找最小生成树的方法之前，我们将开发一个函数，我们可以用它来测试解决方案的总权重。最小生成树问题的解决方案将包括构成树的加权边列表。为了我们的目的，我们将加权路径视为加权边列表。我们将定义一个
    totalWeight() 方法，它接受一个加权边列表并找出所有边的权重相加后的总权重。请注意，这个方法以及本章中的其他方法将被添加到现有的 WeightedGraph
    类中。
- en: Listing 4.10 WeightedGraph.java continued
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 WeightedGraph.java 续
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Jarník’s algorithm
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Jarník 算法
- en: 'Jarník’s algorithm for finding a minimum spanning tree works by dividing a
    graph into two parts: the vertices in the still-being-assembled minimum spanning
    tree and the vertices not yet in the minimum spanning tree. It takes the following
    steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Jarník 寻找最小生成树的算法通过将图分为两部分来实现：正在组装的最小生成树中的顶点和尚未包含在最小生成树中的顶点。它采取以下步骤：
- en: Pick an arbitrary vertex to include in the minimum spanning tree.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个任意顶点包含在最小生成树中。
- en: Find the lowest-weight edge connecting the minimum spanning tree to the vertices
    not yet in the minimum spanning tree.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到连接最小生成树到尚未包含在最小生成树中的顶点的最低权重边。
- en: Add the vertex at the end of that minimum edge to the minimum spanning tree.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该最小边的末尾顶点添加到最小生成树中。
- en: Repeat steps 2 and 3 until every vertex in the graph is in the minimum spanning
    tree.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2 和 3，直到图中的每个顶点都在最小生成树中。
- en: Note Jarník’s algorithm is commonly referred to as Prim’s algorithm. Two Czech
    mathematicians, Otakar Boru˚vka and Vojteˇch Jarník, interested in minimizing
    the cost of laying electric lines in the late 1920s, came up with algorithms to
    solve the problem of finding a minimum spanning tree. Their algorithms were “rediscovered”
    decades later by others.[3](#pgfId-1156040)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Jarník 算法通常被称为 Prim 算法。两位捷克数学家，Otakar Boruška 和 Vojtěch Jarník，在 20 世纪 20
    年代后期对铺设电线的成本最小化感兴趣，提出了求解最小生成树问题的算法。他们的算法在几十年后被其他人“重新发现”。[3](#pgfId-1156040)
- en: To run Jarník’s algorithm efficiently, a priority queue is used (see chapter
    2 for more on priority queues). Every time a new vertex is added to the minimum
    spanning tree, all of its outgoing edges that link to vertices outside the tree
    are added to the priority queue. The lowest-weight edge is always popped off the
    priority queue, and the algorithm keeps executing until the priority queue is
    empty. This ensures that the lowest-weight edges are always added to the tree
    first. Edges that connect to vertices already in the tree are ignored when they
    are popped.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效运行 Jarník 算法，使用了一个优先队列（有关优先队列的更多信息，请参阅第 2 章）。每次将新顶点添加到最小生成树时，都会将其所有指向树外顶点的出边添加到优先队列中。总是从优先队列中弹出权重最低的边，算法持续执行，直到优先队列为空。这确保了权重最低的边总是首先添加到树中。当弹出时，连接到树中已存在顶点的边将被忽略。
- en: The following code for mst() is the full implementation of Jarník’s algorithm,[4](#pgfId-1156046)
    along with a utility function for printing a weighted path.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `mst()` 的代码是 Jarník 算法的完整实现，[4](#pgfId-1156046) 以及一个用于打印加权路径的实用函数。
- en: Warning Jarník’s algorithm will not necessarily work correctly in a graph with
    directed edges. It also will not work in a graph that is not connected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Jarník 算法在具有有向边的图中不一定能正确工作。它也不适用于不连通的图。
- en: Listing 4.11 WeightedGraph.java continued
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 WeightedGraph.java 继续如下
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s walk through mst(), line by line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析 `mst()`：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The algorithm returns a weighted path (List<WeightedEdge>) representing the
    minimum spanning tree. If it so happens that the start is invalid, mst() returns
    an empty list as its result. result will ultimately hold the weighted path containing
    the minimum spanning tree. This is where we will add WeightedEdges, as the lowest-weight
    edge is popped off and takes us to a new part of the graph.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 算法返回一个表示最小生成树的加权路径（List<WeightedEdge>）。如果起始点无效，`mst()` 将返回一个空列表作为其结果。结果最终将包含包含最小生成树的加权路径。这就是我们将添加
    WeightedEdges 的地方，因为权重最低的边被弹出并带我们到图的另一个部分。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Jarník’s algorithm is considered a greedy algorithm because it always selects
    the lowest-weight edge. pq is where newly discovered edges are stored and the
    next-lowest-weight edge is popped. visited keeps track of vertex indices that
    we have already been to. This could also have been accomplished with a Set, similar
    to explored in bfs().
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Jarník 算法被认为是一种贪婪算法，因为它总是选择权重最低的边。pq 是存储新发现的边的地方，并弹出下一个最低权重的边。visited 跟踪我们已访问过的顶点索引。这也可以通过类似于
    bfs() 中的 explored 使用 Set 来完成。
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: visit is an inner convenience function that marks a vertex as visited and adds
    all of its edges that connect to vertices not yet visited to pq. visit is implemented
    as an IntConsumer, which is just a Function that takes an int as its only parameter.
    In this case, that int will be the index of the vertex to be visited. Note how
    easy the adjacency-list model makes finding edges belonging to a particular vertex.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit` 是一个内部便利函数，它将顶点标记为已访问，并将所有连接到尚未访问顶点的边添加到 pq 中。`visit` 被实现为 IntConsumer，它只是一个接受
    int 作为唯一参数的 Function。在这种情况下，那个 int 将是待访问顶点的索引。注意邻接表模型如何简化找到特定顶点的边。'
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: accept() is the IntConsumer method that causes its associated function to be
    run with the int parameter provided. It does not matter which vertex is visited
    first unless the graph is not connected. If the graph is not connected, but is
    instead made up of disconnected components, mst() will return a tree that spans
    the particular component that the starting vertex belongs to.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept()` 是 IntConsumer 方法，它会导致其关联的函数在提供 int 参数的情况下运行。除非图不连通，否则访问哪个顶点首先并不重要。如果图不连通，而是由不连通的组件组成，`mst()`
    将返回一个包含起始顶点所属特定组件的树的树。'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While there are still edges on the priority queue, we pop them off and check
    if they lead to vertices not yet in the tree. Because the priority queue is ascending,
    it pops the lowest-weight edges first. This ensures that the result is indeed
    of minimum total weight. Any edge popped that does not lead to an unexplored vertex
    is ignored. Otherwise, because the edge is the lowest seen so far, it is added
    to the result set, and the new vertex it leads to is explored. When there are
    no edges left to explore, the result is returned.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当优先队列中仍有边缘时，我们将它们弹出并检查它们是否指向树中尚未出现的顶点。因为优先队列是升序的，所以它首先弹出权重最低的边缘。这确保了结果确实是总权重最小的。任何没有指向未探索顶点的弹出边缘都被忽略。否则，因为边缘是迄今为止看到的最低的，所以它被添加到结果集中，并且它指向的新顶点被探索。当没有更多边缘可探索时，返回结果。
- en: As promised, let’s return to the problem of connecting all 15 of the largest
    MSAs in the United States by Hyperloop, using a minimum amount of track. The route
    that accomplishes this is simply the minimum spanning tree of cityGraph2. Let’s
    try running mst() on cityGraph2 by adding code to main().
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，让我们回到通过Hyperloop连接美国最大的15个MSA的问题，使用最少的轨道。完成这一目标的路线仅仅是cityGraph2的最小生成树。让我们通过在main()中添加代码来尝试在cityGraph2上运行mst()。
- en: Listing 4.12 WeightedGraph.java continued
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 WeightedGraph.java继续
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Thanks to the pretty-printing printWeightedPath() method, the minimum spanning
    tree is easy to read:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了漂亮的打印方法printWeightedPath()，最小生成树很容易阅读：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In other words, this is the cumulatively shortest collection of edges that connects
    all of the MSAs in the weighted graph. The minimum length of track needed to connect
    all of them is 5,372 miles. Figure 4.7 illustrates the minimum spanning tree.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这是连接加权图中所有MSA的累积最短边缘集合。连接所有这些MSA所需的轨道最小长度是5,372英里。图4.7说明了最小生成树。
- en: '![4-7](../Images/4-7.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![4-7](../Images/4-7.png)'
- en: Figure 4.7 The highlighted edges represent a minimum spanning tree that connects
    all 15 MSAs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 高亮显示的边缘代表了一个连接所有15个MSA的最小生成树。
- en: 4.5 Finding shortest paths in a weighted graph
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 在加权图中寻找最短路径
- en: As the Hyperloop network gets built, it is unlikely the builders will have the
    ambition to connect the whole country at once. Instead, it is likely the builders
    will want to minimize the cost to lay track between key cities. The cost to extend
    the network to particular cities will obviously depend on where the builders start.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Hyperloop网络的建造，建造者不太可能一开始就有连接整个国家的雄心。相反，建造者可能希望最小化铺设关键城市之间轨道的成本。将网络扩展到特定城市的成本显然取决于建造者的起始点。
- en: Finding the cost to any city from some starting city is a version of the “single-source
    shortest path” problem. That problem asks, “What is the shortest path (in terms
    of total edge weight) from some vertex to every other vertex in a weighted graph?”
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个起始城市找到任何城市的成本是“单源最短路径”问题的一个版本。该问题询问，“在加权图中，从某个顶点到每个其他顶点的最短路径（以总边权重计）是什么？”
- en: 4.5.1 Dijkstra’s algorithm
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 Dijkstra算法
- en: Dijkstra’s algorithm solves the single-source shortest path problem. It is provided
    a starting vertex, and it returns the lowest-weight path to any other vertex on
    a weighted graph. It also returns the minimum total weight to every other vertex
    from the starting vertex. Dijkstra’s algorithm starts at the single-source vertex
    and then continually explores the closest vertices to the starting vertex. For
    this reason, like Jarník’s algorithm, Dijkstra’s algorithm is greedy. When Dijkstra’s
    algorithm encounters a new vertex, it keeps track of how far it is from the starting
    vertex and updates this value if it ever finds a shorter path. It also keeps track
    of which edge got it to each vertex.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法解决单源最短路径问题。它提供了一个起始顶点，并返回加权图中任何其他顶点的最低权重路径。它还返回从起始顶点到每个其他顶点的最小总权重。Dijkstra算法从单源顶点开始，然后不断探索距离起始顶点最近的顶点。因此，像Jarník算法一样，Dijkstra算法是贪婪的。当Dijkstra算法遇到一个新顶点时，它会跟踪它距离起始顶点的距离，并在找到更短的路径时更新此值。它还会跟踪将每个顶点带到每个顶点的边。
- en: 'Here are all of the algorithm’s steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是算法的所有步骤：
- en: Add the starting vertex to a priority queue.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将起始顶点添加到优先队列中。
- en: Pop the closest vertex from the priority queue (at the beginning, this is just
    the starting vertex); we’ll call it the current vertex.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从优先队列中弹出最近的顶点（一开始这只是起始顶点）；我们将它称为当前顶点。
- en: Look at all of the neighbors connected to the current vertex. If they have not
    previously been recorded, or if the edge offers a new shortest path to them, then
    for each of them record its distance from the start, record the edge that produced
    this distance, and add the new vertex to the priority queue.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看连接到当前顶点的所有邻居。如果它们之前没有被记录，或者如果边提供了到达它们的更短路径，那么对于它们中的每一个，记录其从起点到距离，记录产生这个距离的边，并将新顶点添加到优先队列中。
- en: Repeat steps 2 and 3 until the priority queue is empty.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2 和 3，直到优先队列为空。
- en: Return the shortest distance to every vertex from the starting vertex and the
    path to get to each of them.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回从起始顶点到每个顶点的最短距离以及到达每个顶点的路径。
- en: Our code for Dijkstra’s algorithm includes DijkstraNode, a simple data structure
    for keeping track of costs associated with each vertex explored so far and for
    comparing them. This is similar to the Node class in chapter 2\. It also includes
    DijkstraResult, a class for pairing the distances calculated by the algorithm
    and the paths calculated by the algorithm. And, finally, it includes utility functions
    for converting the returned array of distances to something easier to use for
    looking up by vertex and for calculating a shortest path to a particular destination
    vertex from the path dictionary returned by dijkstra().
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 Dijkstra 算法编写的代码包括 DijkstraNode，这是一个简单的数据结构，用于跟踪到目前为止每个探索的顶点相关的成本，以及用于比较。这与第
    2 章中的 Node 类类似。它还包括 DijkstraResult，这是一个用于配对算法计算的距离和路径的类。最后，它还包括将返回的距离数组转换为更容易通过顶点查找以及从
    dijkstra() 返回的路径字典计算特定目标顶点最短路径的实用函数。
- en: Without further ado, here is the code for Dijkstra’s algorithm. We will go over
    it line by line after. All of this code is again going within WeightedGraph.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，以下是 Dijkstra 算法的代码。我们将在之后逐行讲解。所有这些代码都再次在 WeightedGraph 中进行。
- en: Listing 4.13 WeightedGraph.java continued
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 WeightedGraph.java 继续显示
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first few lines of dijkstra() use data structures you have become familiar
    with, except for distances, which is a placeholder for the distances to every
    vertex in the graph from the root. Initially all of these distances are 0, because
    we do not yet know how far each of them is; that is what we are using Dijkstra’s
    algorithm to figure out!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: dijkstra() 的前几行使用了您已经熟悉的数据结构，除了距离，它是从根到图中每个顶点的距离的占位符。最初，这些距离都是 0，因为我们还不知道它们有多远；这正是我们使用
    Dijkstra 算法要弄清楚的事情！
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first node pushed on to the priority queue contains the root vertex.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 推送到优先队列的第一个节点包含根顶点。
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We keep running Dijkstra’s algorithm until the priority queue is empty. u is
    the current vertex we are searching from, and distU is the stored distance for
    getting to u along known routes. Every vertex explored at this stage has already
    been found, so it must have a known distance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会一直运行 Dijkstra 算法，直到优先队列为空。u 是我们当前正在搜索的顶点，distU 是通过已知路线到达 u 的存储距离。在这个阶段探索的每个顶点都已经找到，因此它必须有一个已知的距离。
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, every edge connected to u is explored. distV is the distance to any known
    vertex attached by an edge from u. pathWeight is the distance using the new route
    being explored.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，探索与 u 相连的每条边。distV 是通过从 u 连接的边到达的任何已知顶点的距离。pathWeight 是使用正在探索的新路线的距离。
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we have found a vertex that has not yet been explored (!visited[we.v]), or
    we have found a new, shorter path to it (distV > pathWeight), we record that new
    shortest distance to v and the edge that got us there. Finally, we push any vertices
    that have new paths to them to the priority queue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个尚未探索的顶点 (!visited[we.v])，或者我们找到了到达该顶点的更短路径 (distV > pathWeight)，我们将记录到达
    v 的新最短距离以及到达那里的边。最后，我们将任何具有新路径的顶点推送到优先队列中。
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: dijkstra() returns both the distances to every vertex in the weighted graph
    from the root vertex and the pathMap that can unlock the shortest paths to them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: dijkstra() 返回从根顶点到加权图中每个顶点的距离以及可以解锁到达它们的最短路径的 pathMap。
- en: It is safe to run Dijkstra’s algorithm now. We will start by finding the distance
    from Los Angeles to every other MSA in the graph. Then we will find the shortest
    path between Los Angeles and Boston. Finally, we will use printWeightedPath()
    to pretty-print the result. The following can go into main().
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 Dijkstra 算法是安全的。我们首先将找到洛杉矶到图中每个其他 MSA 的距离。然后我们将找到洛杉矶和波士顿之间的最短路径。最后，我们将使用
    printWeightedPath() 来格式化打印结果。以下可以放入 main() 中。
- en: Listing 4.14 WeightedGraph.java continued
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 WeightedGraph.java 继续显示
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Your output should look something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该看起来像这样：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You may have noticed that Dijkstra’s algorithm has some resemblance to Jarník’s
    algorithm. They are both greedy, and it is possible to implement them using quite
    similar code if one is sufficiently motivated. Another algorithm that Dijkstra’s
    algorithm resembles is A* from chapter 2\. A* can be thought of as a modification
    of Dijkstra’s algorithm. Add a heuristic and restrict Dijkstra’s algorithm to
    finding a single destination, and the two algorithms are the same.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到迪杰斯特拉算法与贾尼克算法有相似之处。它们都是贪婪的，如果一个人足够有动力，就可以使用相当相似的代码来实现。另一个与迪杰斯特拉算法相似的算法是第2章中的A*算法。A*可以被视为迪杰斯特拉算法的一种修改。添加启发式方法并将迪杰斯特拉算法限制在寻找单个目的地，这两个算法就相同了。
- en: NOTE Dijkstra’s algorithm is designed for graphs with positive weights. Graphs
    with negatively weighted edges can pose a challenge for Dijkstra’s algorithm and
    will require modification or an alternative algorithm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：迪杰斯特拉算法是为具有正权重的图设计的。具有负权边重的图可能会对迪杰斯特拉算法构成挑战，需要修改或使用替代算法。
- en: 4.6 Real-world applications
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 现实世界应用
- en: 'A huge amount of our world can be represented using graphs. You have seen in
    this chapter how effective they are for working with transportation networks,
    but many other kinds of networks have the same essential optimization problems:
    telephone networks, computer networks, utility networks (electricity, plumbing,
    and so on). As a result, graph algorithms are essential for efficiency in the
    telecommunications, shipping, transportation, and utility industries.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的世界中很大一部分可以用图来表示。在本章中，你已经看到了它们在处理交通网络方面的有效性，但许多其他类型的网络也有相同的本质优化问题：电话网络、计算机网络、公用事业网络（电力、管道等）。因此，图算法对于电信、航运、交通和公用事业行业的效率至关重要。
- en: 'Retailers must handle complex distribution problems. Stores and warehouses
    can be thought of as vertices and the distances between them as edges. The algorithms
    are the same. The internet itself is a giant graph, with each connected device
    a vertex and each wired or wireless connection being an edge. Whether a business
    is saving fuel or wire, minimum spanning tree and shortest path problem-solving
    are useful for more than just games. Some of the world’s most famous brands became
    successful by optimizing graph problems: think of Walmart building out an efficient
    distribution network, Google indexing the web (a giant graph), and FedEx finding
    the right set of hubs to connect the world’s addresses.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 零售商必须处理复杂的分配问题。商店和仓库可以被视为顶点，它们之间的距离作为边。算法是相同的。互联网本身就是一个巨大的图，每个连接的设备都是一个顶点，每个有线或无线连接都是一个边。无论是节省燃料还是节省电线，最小生成树和最短路径问题求解对于游戏以外的用途也是很有用的。世界上一些最著名的品牌通过优化图问题而取得成功：想想沃尔玛构建高效的分配网络，谷歌索引网络（一个巨大的图），以及联邦快递找到连接世界各地地址的正确的一组枢纽。
- en: Some obvious applications of graph algorithms are social networks and map applications.
    In a social network, people are vertices, and connections (friendships on Facebook,
    for instance) are edges. In fact, one of Facebook’s most prominent developer tools
    is known as the Graph API ([https://developers.facebook.com/docs/graph-api](https://developers.facebook.com/docs/graph-api)).
    In map applications like Apple Maps and Google Maps, graph algorithms are used
    to provide directions and calculate trip times.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图算法的一些明显应用是社交网络和地图应用。在社交网络中，人们是顶点，连接（例如Facebook上的友谊）是边。事实上，Facebook最著名的开发者工具之一就是名为Graph
    API的（[https://developers.facebook.com/docs/graph-api](https://developers.facebook.com/docs/graph-api)）。在像Apple
    Maps和Google Maps这样的地图应用中，图算法用于提供路线和计算行程时间。
- en: Several popular video games also make explicit use of graph algorithms. Mini-Metro
    and Ticket to Ride are two examples of games that closely mimic the problems solved
    in this chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 几种流行的视频游戏也明确使用了图算法。Mini-Metro和Ticket to Ride是两个模仿本章所解决问题的高仿真游戏例子。
- en: 4.7 Exercises
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 练习
- en: Add support to the graph framework for removing edges and vertices.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为图框架添加移除边和顶点的支持。
- en: Add support to the graph framework for directed graphs (digraphs).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为图框架添加对有向图（有向图）的支持。
- en: 'Use this chapter’s graph framework to prove or disprove the classic Seven Bridges
    of Königsberg problem, as described on Wikipedia: [https://en.wikipedia.org/ wiki/Seven_Bridges_of_Königsberg](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%83%C6%92%C3%82%C2%B6nigsberg).'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章的图框架来证明或反驳维基百科上描述的经典七桥问题，[https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%83%C6%92%C3%82%C2%B6nigsberg](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%83%C6%92%C3%82%C2%B6nigsberg)。
- en: '* * *'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1. Data is from the United States Census Bureau, [https://www.census.gov/](https://www.census.gov/).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 数据来自美国人口普查局，[https://www.census.gov/](https://www.census.gov/).
- en: 2. Elon Musk, “Hyperloop Alpha,” [https://www.tesla.com/sites/default/files/blog_images/hyperloop-alpha.pdf](https://www.tesla.com/sites/default/files/blog_images/hyperloop-alpha.pdf).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 埃隆·马斯克，“Hyperloop Alpha”，[https://www.tesla.com/sites/default/files/blog_images/hyperloop-alpha.pdf](https://www.tesla.com/sites/default/files/blog_images/hyperloop-alpha.pdf).
- en: 3. Helena Durnová, “Otakar Boru˚vka (1899-1995) and the Minimum Spanning Tree”
    (Institute of Mathematics of the Czech Academy of Sciences, 2006), [http://mng.bz/O2vj](http://mng.bz/O2vj).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 3. Helena Durnová，“奥塔卡·博鲁夫卡（1899-1995）和最小生成树”（捷克科学院数学研究所，2006年），[http://mng.bz/O2vj](http://mng.bz/O2vj).
- en: 4. Inspired by a solution by Robert Sedgewick and Kevin Wayne, Algorithms, 4th
    ed. (Addison-Wesley Professional, 2011), p. 619.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 受罗伯特·赛德威克和凯文·韦恩解决方案的启发，算法，第4版（Addison-Wesley Professional，2011年），第619页。
