- en: Chapter 11\. Python programs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章\. Python程序
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating a very basic program
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个非常基本的程序
- en: Making a program directly executable on Linux/UNIX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux/UNIX上直接使程序可执行
- en: Writing programs on macOS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS上编写程序
- en: Selecting execution options in Windows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows中选择执行选项
- en: Combining programs and modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合程序和模块
- en: Distributing Python applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发Python应用程序
- en: Up until now, you’ve been using the Python interpreter mainly in interactive
    mode. For production use, you’ll want to create Python programs or scripts. Several
    of the sections in this chapter focus on command-line programs. If you come from
    a Linux/UNIX background, you may be familiar with scripts that can be started
    from a command line and given arguments and options that can be used to pass in
    information and possibly redirect their input and output. If you’re from a Windows
    or Mac background, these things may be new to you, and you may be more inclined
    to question their value.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要在交互模式下使用Python解释器。对于生产使用，你将想要创建Python程序或脚本。本章的几个部分专注于命令行程序。如果你来自Linux/UNIX背景，你可能熟悉可以从命令行启动的脚本，并可以提供用于传递信息和可能重定向输入输出的参数和选项。如果你来自Windows或Mac背景，这些可能对你来说是新的，你可能更倾向于质疑它们的价值。
- en: It’s true that command-line scripts are sometimes less convenient to use in
    a GUI environment, but the Mac has the option of a UNIX command-line shell, and
    Windows also offers enhanced command-line options. It will be well worth your
    time to read the bulk of this chapter at some point. You may find occasions when
    these techniques are useful, or you may run across code you need to understand
    that uses some of them. In particular, command-line techniques are very useful
    when you need to process large numbers of files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在GUI环境中，命令行脚本有时不太方便使用，但Mac有UNIX命令行shell的选项，Windows也提供了增强的命令行选项。花时间阅读本章的大部分内容将非常值得。你可能会发现这些技术有用，或者你可能会遇到需要理解使用其中一些技术的代码。特别是，当需要处理大量文件时，命令行技术非常有用。
- en: 11.1\. Creating a very basic program
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 创建一个非常基本的程序
- en: Any group of Python statements placed sequentially in a file can be used as
    a program, or *script*. But it’s more standard and useful to introduce additional
    structure. In its most basic form, this task is a simple matter of creating a
    controlling function in a file and calling that function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一组按顺序放置在文件中的Python语句都可以用作程序或*脚本*。但引入额外的结构更为标准和有用。在最基本的形式中，这项任务只是简单地在一个文件中创建一个控制函数并调用该函数。
- en: Listing 11.1\. File script1.py
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. 文件script1.py
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Controlling function main**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 控制函数main**'
- en: '***2* Calls main**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用main**'
- en: In this script, `main` is the controlling—and only—function. First, it’s defined,
    and then it’s called. Although it doesn’t make much difference in a small program,
    this structure can give you more options and control when you create larger applications,
    so it’s a good idea to make using it a habit from the beginning.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`main`是控制函数——也是唯一的函数。首先，它被定义，然后被调用。虽然在小程序中这没有太大区别，但这种结构在创建更大的应用程序时可以给你更多的选项和控制，所以从一开始就养成使用它的习惯是个好主意。
- en: 11.1.1\. Starting a script from a command line
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1\. 从命令行启动脚本
- en: 'If you’re using Linux/UNIX, make sure that Python is on your path and you’re
    in the same directory as your script. Then type the following on your command
    line to start the script:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Linux/UNIX，请确保Python在你的路径上，并且你与你的脚本在同一个目录中。然后，在你的命令行上输入以下内容以启动脚本：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you’re using a Macintosh running OS X, the procedure is the same as for other
    UNIX systems. You need to open a terminal program, which is in the Utilities folder
    of the Applications folder. You have several other options for running scripts
    on OS X, which I discuss shortly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是运行OS X的Macintosh，程序与其它UNIX系统相同。你需要打开一个终端程序，它在应用程序文件夹的实用工具文件夹中。你还有其他几种在OS
    X上运行脚本的选择，我将在稍后讨论。
- en: 'If you’re using Windows, open Command Prompt (this can be found in different
    menu locations depending on the version of Windows; in Windows 10, it’s in the
    Windows System menu) or PowerShell. Either of these opens in your home folder,
    and if necessary, you can use the `cd` command to change to a subdirectory. Running
    script1.py if it was saved on your desktop would look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，打开命令提示符（这可以在不同的菜单位置找到，取决于Windows的版本；在Windows 10中，它在Windows系统菜单中），或者PowerShell。这两个都可以打开到你的主目录，如果需要，你可以使用`cd`命令来更改到子目录。如果script1.py保存在你的桌面上，运行它的样子如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Changes to Desktop folder**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更改为桌面文件夹**'
- en: '***2* Runs script1.py**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 运行 script1.py**'
- en: '***3* Output of script1.py**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* script1.py 的输出**'
- en: I look at other options for calling scripts later in this chapter, but stick
    with this option for now.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章后面部分探讨其他调用脚本的选项，但现在我们坚持使用这个选项。
- en: 11.1.2\. Command-line arguments
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. 命令行参数
- en: A simple mechanism is available for passing in command-line arguments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种简单的机制来传递命令行参数。
- en: Listing 11.2\. File script2.py
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.2\. 文件 script2.py
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you call this with the line
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用以下行调用它
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: you get
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that the command-line arguments have been stored in `sys.argv` as
    a list of strings.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，命令行参数已经被存储在 `sys.argv` 中，作为一个字符串列表。
- en: 11.1.3\. Redirecting the input and output of a script
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.3\. 重定向脚本的输入和输出
- en: You can redirect the input and/or the output for a script by using command-line
    options. To show this technique, I use this short script.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用命令行选项来重定向脚本的输入和/或输出。为了展示这项技术，我使用了这个简短的脚本。
- en: Listing 11.3\. File replace.py
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 文件 replace.py
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Reads from stdin into contents**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 stdin 读取到内容**'
- en: '***2* Replaces first argument with second**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 用第二个参数替换第一个参数**'
- en: 'This script reads its standard input and writes to its standard output whatever
    it reads, with all occurrences of its first argument replaced with its second
    argument. Called as follows, the script places in `outfile` a copy of `infile`
    with all occurrences of `zero` replaced by `0`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本读取其标准输入，并将读取到的内容写入其标准输出，其中所有出现第一个参数的地方都被第二个参数替换。按照以下方式调用脚本，脚本将 `infile` 的副本放置在
    `outfile` 中，其中所有 `zero` 的出现都被替换为 `0`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this script works on UNIX, but on Windows, redirection of input and/or
    output works only if you start a script from a command-prompt window.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此脚本在 UNIX 上工作，但在 Windows 上，如果从命令提示符窗口启动脚本，则输入和/或输出重定向才有效。
- en: In general, the line
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，该行
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'has the effect of having any `input` or `sys.stdin` operations directed out
    of `infile` and any `print` or `sys.stdout` operations directed into `outfile`.
    The effect is as though you set `sys.stdin` to `infile` with `''r''` (read) mode
    and `sys.stdout` to `outfile` with `''w''` (write):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的效果是将任何 `input` 或 `sys.stdin` 操作重定向到 `infile`，并将任何 `print` 或 `sys.stdout`
    操作重定向到 `outfile`。效果就像你将 `sys.stdin` 设置为以 `'r'`（读取）模式打开的 `infile`，将 `sys.stdout`
    设置为以 `'w'`（写入）模式打开的 `outfile`：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line causes the output to be appended to `outfile` rather than to overwrite
    it, as happened in the previous example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码导致输出被追加到 `outfile` 而不是覆盖它，正如前一个示例中发生的那样。
- en: 'You can also *pipe* in the output of one command as the input of another command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个命令的输出作为另一个命令的输入进行 *管道*：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code results in `outfile` containing the contents of `infile`, with all
    occurrences of `0` changed to `zero` and all occurrences of `1` changed to `one`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码导致 `outfile` 包含 `infile` 的内容，其中所有 `0` 的出现都被更改为 `zero`，所有 `1` 的出现都被更改为 `one`。
- en: 11.1.4\. The argparse module
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.4\. argparse 模块
- en: You can configure a script to accept command-line options as well as arguments.
    The `argparse` module provides support for parsing different types of arguments
    and can even generate usage messages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置脚本以接受命令行选项以及参数。`argparse` 模块提供了解析不同类型参数的支持，甚至可以生成用法消息。
- en: To use the `argparse` module, you create an instance of `ArgumentParser`, populate
    it with arguments, and then read both the optional and positional arguments. This
    listing illustrates the module’s use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `argparse` 模块，你需要创建一个 `ArgumentParser` 实例，用参数填充它，然后读取可选和位置参数。以下列表展示了模块的使用。
- en: Listing 11.4\. File opts.py
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. 文件 opts.py
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code creates an instance of `ArgumentParser` and then adds two positional
    arguments, `indent` and `input_file`, which are the arguments entered after all
    of the optional arguments have been parsed. *Positional arguments* are those without
    a prefix character (usually (`"-"`) and are required, and in this case, the `indent`
    argument must also be parsable as an `int` ***1***.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个 `ArgumentParser` 实例，然后添加了两个位置参数，`indent` 和 `input_file`，这些参数是在解析所有可选参数之后输入的。*位置参数*
    是没有前缀字符（通常是 `"-"`）的参数，并且是必需的，在这种情况下，`indent` 参数也必须可解析为 `int` ***1***。
- en: The next line adds an optional filename argument with either `'-f'` or `'--file'`
    ***2***. The final option added, the `"quiet"` option, also adds the ability to
    turn off the verbose option, which is `True` by default (`action="store_false"`).
    The fact that these options begin with the prefix character `"-"` tells the parser
    that they’re optional.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行添加了一个可选的文件名参数，可以是`'-f'`或`'--file'` ***2***。最后添加的选项，“quiet”选项，还增加了关闭默认的详细选项（`True`，`action="store_false"`）的能力。这些选项以前缀字符“-”开头，这告诉解析器它们是可选的。
- en: The final argument, “`-q`”, also has a default value (`True`, in this case)
    that will be set if the option isn’t specified. The `action="store_false"` parameter
    specifies that if the argument *is* specified, a value of `False` will be stored
    in the destination. ***3***
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数，“`-q`”，也有一个默认值（在这种情况下为`True`），如果未指定该选项，则会被设置。`action="store_false"`参数指定，如果该参数被指定，则会在目标位置存储`False`值。***3***
- en: The `argparse` module returns a Namespace object containing the arguments as
    attributes. You can get the values of the arguments by using dot notation. If
    there’s no argument for an option, its value is `None`. Thus, if you call the
    previous script with the line
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`模块返回一个包含参数作为属性的Namespace对象。你可以通过点符号获取参数的值。如果没有为选项指定参数，其值是`None`。因此，如果你用以下行调用前面的脚本，'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Options come after script name.**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 选项跟在脚本名称之后。**'
- en: 'the following output results:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出结果：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If an invalid argument is found, or if a required argument isn’t given, `parse_args`
    raises an error:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现无效参数，或者没有提供必需的参数，`parse_args`会引发错误：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This line results in the following response:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将产生以下响应：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 11.1.5\. Using the fileinput module
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.5\. 使用 fileinput 模块
- en: The `fileinput` module is sometimes useful for scripts. It provides support
    for processing lines of input from one or more files. It automatically reads the
    command-line arguments (out of `sys.argv`) and takes them as its list of input
    files. Then it allows you to sequentially iterate through these lines. The simple
    example script in this listing (which strips out any lines starting with `##`)
    illustrates the module’s basic use.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileinput`模块有时对脚本很有用。它提供了从一个或多个文件中处理输入行的支持。它自动读取命令行参数（来自`sys.argv`）并将它们作为其输入文件列表。然后它允许你顺序遍历这些行。本列表中的简单示例脚本（该脚本移除了以`##`开头的任何行）说明了模块的基本用法。'
- en: Listing 11.5\. File script4.py
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 文件 script4.py
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now assume that you have the data files shown in the next two listings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你有下一两个列表中显示的数据文件。
- en: Listing 11.6\. File sole1.tst
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.6\. 文件 sole1.tst
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 11.7\. File sole2.tst
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.7\. 文件 sole2.tst
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Also assume that you make this call:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 也假设你进行以下调用：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You obtain the following result with the comment lines stripped out and the
    data from the two files combined:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 移除注释行并将两个文件中的数据合并后，你将得到以下结果：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If no command-line arguments are present, the standard input is all that is
    read. If one of the arguments is a hyphen (-), the standard input is read at that
    point.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有命令行参数，则只读取标准输入。如果其中一个参数是连字符（-），则在该点读取标准输入。
- en: The module provides several other functions. These functions allow you at any
    point to determine the total number of lines that have been read (`lineno`), the
    number of lines that have been read out of the current file (`filelineno`), the
    name of the current file (`filename`), whether this is the first line of a file
    (`isfirstline`), and/or whether standard input is currently being read (`isstdin`).
    You can at any point skip to the next file (`nextfile`) or close the whole stream
    (`close`). The short script in the following listing (which combines the lines
    in its input files and adds file-start delimiters) illustrates how you can use
    these functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还提供了其他几个函数。这些函数允许你在任何时刻确定已读取的总行数（`lineno`）、从当前文件中读取的行数（`filelineno`）、当前文件的名称（`filename`）、是否是文件的第一个行（`isfirstline`），以及/或是否正在读取标准输入（`isstdin`）。你可以在任何时刻跳到下一个文件（`nextfile`）或关闭整个流（`close`）。以下列表中的简短脚本（该脚本将其输入文件中的行合并并添加文件起始分隔符）说明了如何使用这些函数。
- en: Listing 11.8\. File script5.py
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.8\. 文件 script5.py
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the call
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下调用
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'results in the following (where the dotted lines indicate the lines in the
    original files):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下（其中虚线表示原始文件中的行）：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, if you call `fileinput.input` with an argument of a single filename
    or a list of filenames, they’re used as its input files rather than the arguments
    in `sys.argv`. `fileinput.input` also has an `inplace` option that leaves its
    output in the same file as its input while optionally leaving the original around
    as a backup file. See the documentation for a description of this last option.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你用单个文件名或文件名列表作为参数调用`fileinput.input`，它们将用作其输入文件，而不是`sys.argv`中的参数。`fileinput.input`还有一个`inplace`选项，它将输出留在与输入相同的文件中，同时可选地保留原始文件作为备份文件。请参阅文档以了解此最后选项的描述。
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Scripts and arguments'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：脚本和参数
- en: 'Match the following ways of interacting with the command line and the correct
    use case for each:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '匹配以下与命令行交互的方式以及每个用例的正确使用： '
- en: '| Multiple argurments and options | sys.agrv |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 多个参数和选项 | sys.argv |'
- en: '| No arguments or just one argument | Use file_input module |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 没有参数或只有一个参数 | 使用file_input模块 |'
- en: '| Processing multiple files | Redirect standard input and output |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 处理多个文件 | 重定向标准输入和输出 |'
- en: '| Using the script as a filter | Use argparse module |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 将脚本用作过滤器 | 使用argparse模块 |'
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.2\. Making a script directly executable on UNIX
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 在UNIX上直接使脚本可执行
- en: 'If you’re on UNIX, you can easily make a script directly executable. Add the
    following line to its top, and change its mode appropriately (that is, `chmod
    +x replace.py`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在UNIX上，你可以轻松地将脚本直接设置为可执行。在其顶部添加以下行，并适当地更改其模式（即，`chmod +x replace.py`）：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that if Python 3.x isn’t your default version of Python, you may need to
    change the `python` in the snippet to `python3, python3.6`, or something similar
    to specify that you want to use Python 3.x instead of an earlier default version.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你使用的不是Python 3.x作为默认的Python版本，你可能需要将代码片段中的`python`更改为`python3`、`python3.6`或类似的内容，以指定你想要使用Python
    3.x而不是较早的默认版本。
- en: 'Then if you place your script somewhere on your path (for example, in your
    bin directory), you can execute it regardless of the directory you’re in by typing
    its name and the desired arguments:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你将你的脚本放在你的路径上的某个位置（例如，在你的bin目录中），你可以在任何目录中通过键入其名称和所需的参数来执行它：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On UNIX, you’ll have input and output redirection and, if you’re using a modern
    shell, command history and completion.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX上，你将拥有输入和输出重定向，如果你使用的是现代shell，那么还有命令历史和自动完成功能。
- en: If you’re writing administrative scripts on UNIX, several library modules are
    available that you may find useful. These modules include `grp` for accessing
    the group database, `pwd` for accessing the password database, `resource` for
    accessing resource usage information, `syslog` for working with the syslog facility,
    and `stat` for working with information about a file or directory obtained from
    an `os.stat` call. You can find information on these modules in the *Python Library
    Reference.*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在UNIX上编写管理脚本，有几个库模块可供使用，你可能觉得它们很有用。这些模块包括`grp`用于访问组数据库，`pwd`用于访问密码数据库，`resource`用于访问资源使用信息，`syslog`用于与syslog设施一起工作，以及`stat`用于处理从`os.stat`调用获取的文件或目录信息。你可以在*Python库参考*中找到有关这些模块的信息。
- en: 11.3\. Scripts on macOS
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. macOS上的脚本
- en: In many ways, Python scripts on macOS behave the same way as they do on Linux/UNIX.
    You can run Python scripts from a terminal window exactly the same way as on any
    UNIX box. But on the Mac, you can also run Python programs from the Finder, either
    by dragging the script file to the Python Launcher app or by configuring Python
    Launcher as the default application for opening your script (or, optionally, all
    files with a .py extension.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，macOS上的Python脚本与Linux/UNIX上的行为相同。你可以像在任何UNIX盒子上一样，从终端窗口运行Python脚本。但在Mac上，你也可以通过拖动脚本文件到Python启动器应用，或者将Python启动器配置为打开你的脚本（或者可选地，所有以.py扩展名的文件）的默认应用程序来运行Python程序。
- en: You have several options for using Python on a Mac. The specifics of all the
    options are beyond the scope of this book, but you can get a full explanation
    by going to the [www.python.org](http://www.python.org) website and checking out
    the Mac section of the “Using Python” section of the documentation for your version
    of Python. You should also see [section 11.6](#ch11lev1sec6) of the documentation,
    “[Distributing Python applications](#ch11lev1sec6),” for more information on how
    to distribute Python applications and libraries for the Mac platform.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上使用Python有几种选择。所有这些选项的详细信息超出了本书的范围，但你可以通过访问[www.python.org](http://www.python.org)网站并查看Python文档中“使用Python”部分的Mac部分来获得完整的解释。你还应该查看文档中的[第11.6节](#ch11lev1sec6)，即“分发Python应用程序”（#ch11lev1sec6），以获取有关如何在Mac平台上分发Python应用程序和库的更多信息。
- en: If you’re interested in writing administrative scripts for macOS, you should
    look at packages that bridge the gap between Apple’s Open Scripting Architectures
    (OSA) and Python. Two such packages are `appscript` and `PyOSA`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣的是编写macOS的管理脚本，你应该查看那些在Apple的Open Scripting Architectures (OSA)和Python之间架起桥梁的包。两个这样的包是`appscript`和`PyOSA`。
- en: 11.4\. Script execution options in Windows
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4. Script execution options in Windows
- en: If you’re on Windows, you have several options for starting a script that vary
    in their capability and ease of use. Unfortunately, exactly what those options
    might be and how they are configured can vary considerably across the various
    versions of Windows currently in use. This book focuses on running Windows from
    a command prompt or PowerShell. For information on the other options for running
    Python on your system, you should consult the online Python documentation for
    your version of Python and look for “Using Python on Windows.”
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，你有几种启动脚本的选择，这些选择的性能和易用性各不相同。不幸的是，这些选项可能是什么以及它们的配置方式可能因当前使用的各种Windows版本而大相径庭。本书专注于从命令提示符或PowerShell运行Windows。有关在您的系统上运行Python的其他选项的信息，您应查阅您版本Python的在线Python文档，并查找“在Windows上使用Python”。
- en: 11.4.1\. Starting a script from a command window or PowerShell
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1. 从命令窗口或PowerShell启动脚本
- en: 'To run a script from a command window or PowerShell window, open a command
    prompt or PowerShell window. When you’re at the command prompt and have navigated
    to the folder where your scripts are located, you can use Python to run your scripts
    in much the same way as on UNIX/Linux/MacOS systems:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令窗口或PowerShell窗口运行脚本，打开命令提示符或PowerShell窗口。当你处于命令提示符并已导航到包含你的脚本的文件夹时，你可以使用Python以与UNIX/Linux/MacOS系统上相同的方式运行你的脚本：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Python doesn’t run?**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python没有运行？**'
- en: If Python doesn’t run when you enter `python` at the Windows command prompt,
    it probably means that the location of the Python executable isn’t on your command
    path. You either need to add the Python executable to your system’s PATH environment
    variable manually or rerun the installer to have it do the job. To get more help
    on setting up Python on Windows, refer to the Python Setup and Usage section of
    the online Python documentation. There, you’ll find a section on using Python
    on Windows, with instructions for installing Python.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入`python`后Windows命令提示符没有运行Python，这可能意味着Python可执行文件的位置不在你的命令路径上。你可能需要手动将Python可执行文件添加到系统PATH环境变量中，或者重新运行安装程序以完成这项工作。有关在Windows上设置Python的更多帮助，请参阅在线Python文档的Python设置和使用部分。在那里，你可以找到一个关于在Windows上使用Python的部分，包括安装Python的说明。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is the most flexible of the ways to run a script on Windows because it
    allows you to use input and output redirection.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Windows上运行脚本最灵活的方法，因为它允许你使用输入和输出重定向。
- en: 11.4.2\. Other Windows options
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.2. 其他Windows选项
- en: Other options are available to explore. If you’re familiar with writing batch
    files, you can wrap your commands in them. A port of the GNU BASH shell comes
    with the Cygwin tool set, which you can read about at [www.cygwin.com](http://www.cygwin.com)
    and which provides UNIX-like shell capability for Windows.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项可供探索。如果你熟悉编写批处理文件，你可以将你的命令包装在它们中。Cygwin工具集包含GNU BASH shell的移植版，你可以在[www.cygwin.com](http://www.cygwin.com)上了解更多信息，它为Windows提供了类似UNIX的shell功能。
- en: 'On Windows, you can edit the environment variables (see the previous section)
    to add .py as a magic extension, making your scripts automatically executable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，你可以编辑环境变量（参见上一节）以将.py作为魔法扩展名添加，使你的脚本自动可执行：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Making a script executable'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：使脚本可执行
- en: Experiment with executing scripts on your platform. Also try to redirect input
    and output into and out of your scripts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的平台上执行脚本进行实验。还尝试将输入和输出重定向到脚本中。
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.5\. Programs and modules
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5\. 程序和模块
- en: For small scripts that contain only a few lines of code, a single function works
    well. But if the script grows beyond this size, separating your controlling function
    from the rest of the code is a good option to take. The rest of this section illustrates
    this technique and some of its benefits. I start with an example using a simple
    controlling function. The script in the next listing returns the English-language
    name for a given number between 0 and 99.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只包含几行代码的小脚本，一个函数就足够好了。但如果脚本的大小超出了这个范围，将控制函数与代码的其他部分分离是一个不错的选择。本节剩余部分将说明这种技术及其一些好处。我先从一个简单的控制函数的例子开始。下一列表中的脚本返回0到99之间给定数字的英语名称。
- en: Listing 11.9\. File script6.py
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.9\. 文件 script6.py
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Pads on left in case it’s a single-digit number**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 左侧填充，以防它是单个数字**'
- en: If you call it with
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'you get this result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到这个结果：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The controlling function here calls the function `num2words` with the appropriate
    argument and prints the result ***2***. It’s standard to have the call at the
    bottom, but sometimes you’ll see the controlling function’s definition at the
    top of the file. I prefer this function at the bottom, just above the call, so
    that I don’t have to scroll back up to find it after going to the bottom to find
    out its name. This practice also cleanly separates the scripting plumbing from
    the rest of the file, which is useful when combining scripts and modules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的控制函数调用`num2words`函数并打印结果 ***2***。通常，调用放在底部，但有时你会在文件的顶部看到控制函数的定义。我更喜欢将这个函数放在底部，紧挨着调用，这样我就不必滚动回顶部去找它，在找到它的名字后再回到底部。这种做法也清楚地将脚本管道与文件的其他部分分开，这在将脚本和模块结合使用时很有用。
- en: People combine scripts with modules when they want to make functions they’ve
    created in a script available to other modules or scripts. Also, a module may
    be instrumented so it can run as a script either to provide a quick interface
    to it for users or to provide hooks for automated module testing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们想要将他们创建在脚本中的函数提供给其他模块或脚本时，他们会将脚本与模块结合使用。此外，模块可以被配置为可以作为一个脚本运行，以便为用户提供快速接口或提供自动化模块测试的钩子。
- en: 'Combining a script and a module is a simple matter of putting the following
    conditional test around the controlling function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本和模块结合在一起是一个简单的问题，只需在控制函数周围放置以下条件测试即可：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If it’s called as a script, it will be run with the name `__main__`, and the
    controlling function, `main`, will be called. If the test has been imported into
    an interactive session or another module, its name will be its filename.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它被当作脚本调用，它将以`__main__`的名字运行，并且将调用控制函数`main`。如果测试被导入到交互会话或另一个模块中，它的名字将是它的文件名。
- en: When creating a script, I often set it as a module as well right from the start.
    This practice allows me to import it into a session and interactively test and
    debug my functions as I create them. Only the controlling function needs to be
    debugged externally. If the script grows, or if I find myself writing functions
    I might be able to use elsewhere, I can separate those functions into their own
    module or have other modules import this module.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建脚本时，我经常从一开始就将其设置为模块。这种做法允许我将它导入到会话中，并在创建函数时交互式地测试和调试它们。只需要调试控制函数。如果脚本变大，或者我发现自己在写可能在其他地方使用的函数，我可以将这些函数分离成它们自己的模块，或者让其他模块导入这个模块。
- en: The script in [listing 11.10](#ch11ex10) is an extension of the previous script
    but modified to be used as a module. The functionality has also been expanded
    to allow the entry of a number from 0 to 999999999999999 rather than just from
    0 to 99\. The controlling function (`main`) does the checking of the validity
    of its argument and also strips out any commas in it, allowing more user-readable
    input like 1,234,567.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.10](#ch11ex10) 中的脚本是对上一个脚本的扩展，但修改为用作模块。功能也得到了扩展，允许输入从0到999999999999999的数字，而不仅仅是0到99。控制函数（`main`）检查其参数的有效性，并从中删除任何逗号，允许更易读的输入，如1,234,567。'
- en: Listing 11.10\. File n2w.py
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10\. 文件 n2w.py
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Usage message; includes example**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用说明；包括示例**'
- en: '***2* Conversion mappings**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 转换映射**'
- en: '***3* Handles special conditions (number is zero or too large)**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 处理特殊条件（数字为零或过大）**'
- en: '***4* Removes commas from number**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从数字中移除逗号**'
- en: '***5* Pads number on left**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在数字左侧填充**'
- en: '***6* Creates string containing number**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 创建包含数字的字符串**'
- en: '***7* Initiates string for number**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 为数字初始化字符串**'
- en: '***8* Function for module test mode**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 模块测试模式的函数**'
- en: '***9* Gathers all values for that argument into a list**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 将该参数的所有值收集到一个列表中**'
- en: '***10* Runs in test mode if test variable is set**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 如果设置了测试变量，则以测试模式运行**'
- en: '***11* Catches KeyErrors due to argument containing nondigits**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 捕获由于参数包含非数字而引起的KeyErrors**'
- en: If it’s called as a script, the name will be `__main__`. If it’s imported as
    a module, it will be named `n2w` ***12***.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作为脚本调用，名称将是`__main__`。如果作为模块导入，名称将是`n2w` ***12***。
- en: 'This `main` function illustrates the purpose of a controlling function for
    a command-line script, which in effect is to create a simple UI for the user.
    It may handle the following tasks:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`main`函数说明了命令行脚本的控制器函数的目的，实际上是为用户创建一个简单的用户界面。它可能处理以下任务：
- en: Ensure that there’s the right number of command-line arguments and that they’re
    of the right types. Inform the user, giving usage information if not. Here, the
    function ensures that there is a single argument, but it doesn’t explicitly test
    to ensure that the argument contains only digits.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保命令行参数的数量正确，并且它们的类型正确。如果没有，通知用户并提供使用信息。在这里，函数确保只有一个参数，但它并没有明确测试以确保参数只包含数字。
- en: Possibly handle a special mode. Here, a `'--test'` argument puts you in a test
    mode.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能处理特殊模式。在这里，`--test`参数将你置于测试模式。
- en: Map the command-line arguments to those required by the functions, and call
    them in the appropriate manner. Here, commas are stripped out, and the single
    function `num2words` is called.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令行参数映射到函数所需的参数，并以适当的方式调用它们。在这里，逗号被移除，并且只调用单个函数`num2words`。
- en: Possibly catch and print a more user-friendly message for exceptions that may
    be expected. Here, `KeyErrors` are caught, which occurs if the argument contains
    nondigits.^([[1](#ch11fn1)])
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会捕获并打印出更友好的错误信息，以处理可能预期的异常。在这里，捕获了`KeyErrors`，这发生在参数包含非数字时.^([[1](#ch11fn1)])
- en: ¹
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: A better way to do this would be to explicitly check for nondigits in the argument
    using the regular expression module that will be introduced later. This would
    ensure that we don’t hide `KeyErrors` that occur due to other reasons.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种更好的方法是显式检查参数中的非数字，使用稍后将要介绍的正则表达式模块。这将确保我们不会隐藏由于其他原因发生的`KeyErrors`。
- en: Map the output if necessary to a more user-friendly form, which is done here
    in the `print` statement. If this were a script to run on Windows, you’d probably
    want to let the user open it with the double-click method—that is, to use the
    `input` to query for the parameter, rather than have it as a command-line option
    and keep the screen up to display the output by ending the script with the line
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，可以将输出映射到更用户友好的形式，这里在`print`语句中进行了映射。如果这是一个要在Windows上运行的脚本，你可能希望允许用户通过双击方法打开它——也就是说，使用`input`查询参数，而不是将其作为命令行选项，并通过在脚本末尾添加行来保持屏幕显示输出
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But you may still want to leave the test mode in as a command-line option.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但你可能仍然希望将测试模式作为命令行选项保留。
- en: The test mode in the following listing provides a regression test capability
    for the module and its `num2words` function. In this case, you use it by placing
    a set of numbers in a file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试模式为模块及其`num2words`函数提供了回归测试功能。在这种情况下，你可以通过将一组数字放置在文件中来使用它。
- en: Listing 11.11\. File n2w.tst
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.11\. 文件 n2w.tst
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then type
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后输入
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output file can be easily checked for correctness. This example was run
    several times during its creation and can be rerun any time `num2words` or any
    of the functions it calls are modified. And yes, I’m aware that full exhaustive
    testing certainly didn’t occur. I admit that well over 999 trillion valid inputs
    for this program haven’t been checked!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件可以轻松地检查其正确性。此示例在其创建过程中被运行了多次，并且可以在`num2words`或其调用的任何函数被修改时重新运行。是的，我清楚全面彻底的测试肯定没有发生。我承认，对于这个程序，有超过999万亿个有效的输入还没有被检查过！
- en: Often, the provision of a test mode for a module is the only function of a script.
    I know of at least one company in which part of the development policy is to always
    create one for every Python module developed. Python’s built-in data object types
    and methods usually make this process easy, and those who practice this technique
    seem to be unanimously convinced that it’s well worth the effort. See [chapter
    21](kindle_split_034.html#ch21) to find out more about testing your Python code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为模块提供测试模式是脚本的唯一功能。我知道至少有一家公司将创建每个开发的 Python 模块的测试模式作为其开发政策的一部分。Python 内置的数据对象类型和方法通常使这个过程变得简单，而且实践这种技术的似乎都一致认为这是值得的。参见[第
    21 章](kindle_split_034.html#ch21)了解更多关于测试 Python 代码的信息。
- en: Another option is to create a separate file with only the portion of the `main`
    function that handles the argument and import `n2w` into this file. Then only
    the test mode would be left in the `main` function of `n2w.py`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是创建一个只包含 `main` 函数处理参数部分的单独文件，并将 `n2w` 导入到这个文件中。然后，`n2w.py` 的 `main` 函数中只剩下测试模式。
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Programs and modules'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：程序和模块
- en: What issue is the use of `if __name__ == "__main__":` meant to prevent, and
    how does it do that? Can you think of any other way to prevent this issue?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if __name__ == "__main__":` 的目的是防止什么问题，它是如何做到这一点的？你能想到其他防止这种问题的方法吗？
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.6\. Distributing Python applications
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6\. 分发 Python 应用程序
- en: You can distribute your Python scripts and applications in several ways. You
    can share the source files, of course, probably bundled in a zip or tar file.
    Assuming that the applications were written portably, you could also ship only
    the bytecode as .pyc files. Both of those options, however, usually leave a lot
    to be desired.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式分发你的 Python 脚本和应用程序。当然，你可以分享源文件，可能打包在一个 zip 或 tar 文件中。假设应用程序是可移植的，你也可以只发送
    .pyc 文件的字节码。然而，这两种选项通常都存在很多不足。
- en: 11.6.1\. Wheels packages
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.1\. 轮子包
- en: The current standard way of packaging and distributing Python modules and applications
    is to use packages called wheels. Wheels are designed to make installing Python
    code more reliable and to help manage dependencies. The details of how to create
    wheels are beyond the scope of this chapter, but full details about the requirements
    and the process for creating wheels are in the Python Packaging User Guide at
    [https://packaging.python.org](https://packaging.python.org).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当前打包和分发 Python 模块和应用程序的标准方式是使用名为 wheels 的包。Wheels 设计用于使安装 Python 代码更加可靠，并帮助管理依赖关系。创建
    wheels 的详细内容超出了本章的范围，但有关创建 wheels 的要求和过程的完整详细信息可以在 Python 打包用户指南中找到，网址为 [https://packaging.python.org](https://packaging.python.org)。
- en: 11.6.2\. zipapp and pex
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.2\. zipapp 和 pex
- en: If you have an application that’s in multiple modules, you can also distribute
    it as an executable zip file. This format relies on two facts about Python.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个在多个模块中的应用程序，你也可以将其作为可执行 zip 文件分发。这种格式依赖于 Python 的两个事实。
- en: First, if a zip file contains a file named `__main__.py`, Python can use that
    file as the entry point to the archive and execute the `__main__.py` file directly.
    In addition, the zip file’s contents are added to `sys.path`, so they’re available
    to be imported and executed by `__main__.py`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果一个 zip 文件包含一个名为 `__main__.py` 的文件，Python 可以使用该文件作为存档的入口点并直接执行 `__main__.py`
    文件。此外，zip 文件的内容会被添加到 `sys.path` 中，因此它们可以被 `__main__.py` 导入和执行。
- en: Second, zip files allow arbitrary contents to be added to the beginning of the
    archive. If you add a shebang line pointing to a Python interpreter, such as `#!/usr/bin/env
    python3`, and give the file the needed permissions, the file can become a self-contained
    executable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，zip 文件允许将任意内容添加到存档的开头。如果你添加一个指向 Python 解释器的 shebang 行，例如 `#!/usr/bin/env
    python3`，并给予文件所需的权限，该文件就可以成为一个自包含的可执行文件。
- en: In fact, it’s not that difficult to manually create an executable zipapp. Create
    a zip file containing a `__main__.py`, add the shebang line to the beginning,
    and set the permissions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，手动创建可执行的 zipapp 并不难。创建一个包含 `__main__.py` 的 zip 文件，在开头添加 shebang 行，并设置权限。
- en: Starting with Python 3.5, the zipapp module is included in the standard library;
    it can create zipapps either from the command line or via the library’s API.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.5 开始，zipapp 模块包含在标准库中；它可以从命令行或通过库的 API 创建 zipapp。
- en: A more powerful tool, pex, isn’t in the standard library but is available from
    the package index via pip. pex does the same basic job but offers many more features
    and options, and it’s available for Python 2.7, if needed. Either way, zip file
    apps are convenient ways to package and distribute multifile Python apps ready
    to run.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更强大的工具，pex，不在标准库中，但可以通过pip从包索引中获取。pex执行相同的基本任务，但提供了更多功能和选项，并且对于需要Python 2.7的情况，它是可用的。无论如何，zip文件应用程序是方便打包和分发多文件Python应用程序以便运行的好方法。
- en: 11.6.3\. py2exe and py2app
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.3\. py2exe 和 py2app
- en: Although it’s not the purpose of this book to dwell on platform-specific tools,
    it’s worth mentioning that `py2exe` creates standalone Windows programs and that
    `py2app` does the same on the macOS platform. By *standalone*, I mean that they’re
    single executables that can run on machines that don’t have Python installed.
    In many ways, standalone executables aren’t ideal, because they tend to be larger
    and less flexible than native Python applications. But in some situations, they’re
    the best—and sometimes the only—solution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书的目的不是深入探讨特定平台的工具，但值得一提的是，`py2exe`可以创建独立的Windows程序，而`py2app`在macOS平台上也能做到同样的事情。这里的“独立”是指它们是单个可执行文件，可以在没有安装Python的机器上运行。在许多方面，独立可执行文件并不理想，因为它们通常比原生Python应用程序更大、更不灵活。但在某些情况下，它们是最好的——有时甚至是唯一的——解决方案。
- en: 11.6.4\. Creating executable programs with freeze
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.4\. 使用 freeze 创建可执行程序
- en: It’s also possible to create an executable Python program that runs on machines
    that don’t have Python installed by using the `freeze` tool. You’ll find the instructions
    for this in the Readme file inside the freeze directory in the Tools subdirectory
    of the Python source directory. If you’re planning to use `freeze`, you’ll probably
    need to download the Python source distribution.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`freeze`工具创建在未安装Python的机器上运行的可执行Python程序。你可以在Python源目录的Tools子目录下的freeze目录中的Readme文件中找到这些说明。如果你打算使用`freeze`，你可能需要下载Python源代码分发版。
- en: In the process of “freezing” a Python program, you create C files, which are
    then compiled and linked using a C compiler, which you need to have installed
    on your system. The frozen application will run only on the platform for which
    the C compiler you use provides its executables.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在“冻结”Python程序的过程中，你会创建C文件，然后使用C编译器编译和链接这些文件，你需要确保你的系统上已经安装了C编译器。冻结后的应用程序将仅在C编译器提供的可执行文件的平台运行。
- en: Several other tools try in one way or another to convert and package a Python
    interpreter/environment with an application in a standalone application. In general,
    however, this path is still difficult and complex, and you probably want to avoid
    it unless you have a strong need and the time and resources to make the process
    work.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 几种其他工具试图以某种方式将Python解释器/环境与应用程序一起转换和打包为独立应用程序。然而，总的来说，这条路径仍然困难且复杂，除非你有强烈的需求，并且有时间和资源使这个过程可行，否则你可能会想避免它。
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 11: Creating a program'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室11：创建程序
- en: In [chapter 8](kindle_split_019.html#ch08), you created a version of the UNIX
    `wc` utility to count the lines, words, and characters in a file. Now that you
    have more tools at your disposal, refactor that program to make it work more like
    the original. In particular, the program should have options to show only lines
    (`-l`), only words (`-w`), and only characters (`-c`). If none of those options
    is given, all three stats are displayed. But if any of these options is present,
    only the specified stats are shown.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_019.html#ch08)中，你创建了一个UNIX `wc`实用程序的版本，用于统计文件中的行数、单词数和字符数。现在你有更多的工具可以使用，重构这个程序使其更像原始程序。特别是，程序应该有选项来显示仅行（`-l`）、仅单词（`-w`）和仅字符（`-c`）。如果没有给出这些选项中的任何一个，则显示所有三个统计信息。但如果这些选项中的任何一个存在，则只显示指定的统计信息。
- en: For an extra challenge, have a look at the `man` page for `wc` on a Linux/UNIX
    system, and add the `-L` to show the longest line length. Feel free to try to
    implement the complete behavior as listed in the man page and test it against
    your system’s `wc` utility.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加挑战性，请在Linux/UNIX系统上查看`wc`的`man`页面，并添加`-L`来显示最长行长度。你可以自由尝试实现man页面中列出的完整行为，并使用你系统上的`wc`实用程序进行测试。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Python scripts and modules in their most basic form are just sequences of Python
    statements placed in a file.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python脚本和模块在最基本的形式下，只是放置在文件中的Python语句序列。
- en: Modules can be instrumented to run as scripts, and scripts can be set up so
    that they can be imported as modules.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块可以被配置为作为脚本运行，脚本也可以被设置以便它们可以作为模块导入。
- en: Scripts can be made executable on the UNIX, macOS, or Windows command lines.
    They can be set up to support command-line redirection of their input and output,
    and with the `argparse` module, it’s easy to parse out complex combinations of
    command-line arguments.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本可以在 UNIX、macOS 或 Windows 命令行上设置为可执行。它们可以配置为支持输入和输出的命令行重定向，并且使用 `argparse`
    模块，解析复杂的命令行参数组合变得非常容易。
- en: On macOS, you can use the Python Launcher to run Python programs, either individually
    or as the default application for opening Python files.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上，您可以使用 Python Launcher 运行 Python 程序，无论是单独运行还是作为打开 Python 文件的默认应用程序。
- en: 'On Windows, you can call scripts in several ways: by opening them with a double-click,
    using the Run window, or using a command-prompt window.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，您可以通过多种方式调用脚本：通过双击打开它们，使用运行窗口，或使用命令提示符窗口。
- en: Python scripts can be distributed as scripts, as bytecode, or in special packages
    called wheels.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 脚本可以作为脚本、字节码或称为 wheels 的特殊包进行分发。
- en: '`py2exe`, `py2app`, and the `freeze` tool provide an executable Python program
    that runs on machines that don’t contain a Python interpreter.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`py2exe`, `py2app` 和 `freeze` 工具提供了一种可执行 Python 程序，该程序可以在不包含 Python 解释器的机器上运行。'
- en: Now that you have an idea of the ways to create scripts and applications, the
    next step is looking at how Python can interact with and manipulate filesystems.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 既然您已经了解了创建脚本和应用程序的方法，下一步就是了解 Python 如何与文件系统交互和操作。
