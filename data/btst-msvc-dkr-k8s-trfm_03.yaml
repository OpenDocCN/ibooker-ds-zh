- en: 3 Publishing your first microservice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 发布你的第一个微服务
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Learning the difference between Docker images and containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Docker镜像和容器之间的区别
- en: Using Docker in your development environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的开发环境中使用Docker
- en: Packaging your microservice as a Docker image
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的微服务打包成Docker镜像
- en: Creating a private Docker registry
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个私有Docker注册库
- en: Publishing your microservice to your Docker registry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的微服务发布到你的Docker注册库
- en: Instantiating your microservice in a Docker container
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker容器中实例化你的微服务
- en: 'By the end of this book, we’ll have deployed multiple microservices to our
    production environment: a Kubernetes cluster. But before we can deploy an entire
    microservices application, we must first be able to package and publish a single
    microservice! In this chapter, we’ll take the video-streaming microservice we
    created in chapter 2 and publish it so that it’s ready for deployment to our cluster.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书结束时，我们将将多个微服务部署到我们的生产环境：一个Kubernetes集群。但在我们可以部署整个微服务应用程序之前，我们必须首先能够打包和发布单个微服务！在本章中，我们将把我们在第2章中创建的视频流微服务发布出来，以便它可以部署到我们的集群中。
- en: In order to deploy a microservice to a cluster running in the cloud, we have
    to publish it somewhere accessible. To achieve this, we must first package our
    code, assets, and dependencies into a single bundle. We’ll then need a location
    in the cloud to host this package. For that, we’ll create a container registry.
    If you haven’t heard of containers yet, this will be explained soon.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将微服务部署到在云中运行的集群，我们必须将其发布到某个可访问的地方。为了实现这一点，我们必须首先将我们的代码、资源和依赖项打包成一个单一包。然后，我们需要在云中找到一个位置来托管这个包。为此，我们将创建一个容器注册库。如果你还没有听说过容器，这将在不久后解释。
- en: In this book, we want to emulate the building of a proprietary application for
    a private company. Security and privacy are important, and that’s why we’ll create
    a private container registry as opposed to a public one. We’ll create this container
    registry manually on Azure, but later in chapter 6, we’ll learn how we can build
    our registry with code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们希望模拟为一家私营公司构建专有应用程序的过程。安全和隐私非常重要，这就是为什么我们将创建一个私有容器注册库而不是公共注册库。我们将在Azure上手动创建这个容器注册库，但在第6章中，我们将学习如何使用代码构建我们的注册库。
- en: At the end of this chapter, we’ll test that we can instantiate our published
    microservice directly from the remote container registry. This allows us to test
    our published microservice on our development workstation (or personal computer).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将测试我们能否直接从远程容器注册库实例化我们发布的微服务。这允许我们在我们的开发工作站（或个人电脑）上测试我们发布的微服务。
- en: 3.1 New tools
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 新工具
- en: 'This chapter introduces an important new tool: Docker. In this chapter, we
    lay some necessary groundwork. That’s because from here on in, we’ll use Docker
    extensively, and you will need some basic skills in place to understand how it
    works. That’s going to help you troubleshoot when things go wrong.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一个重要的新工具：Docker。在本章中，我们奠定了一些必要的基础。这是因为从现在开始，我们将广泛使用Docker，你需要具备一些基本技能才能理解它是如何工作的。这将有助于你在出现问题时进行故障排除。
- en: Table 3.1 Tools introduced in chapter 3
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1本章介绍的工具
- en: '| Tool | Version | Purpose |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 版本 | 目的 |'
- en: '| Docker | 19.03.12 | We use Docker to package, publish, and test our microservices.
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Docker | 19.03.12 | 我们使用Docker来打包、发布和测试我们的微服务。|'
- en: Docker works on Linux, MacOS, and Windows 10\. If you are working on Windows
    10 Home edition, you’ll first need to install WSL2 (the Windows integrated Linux
    kernel), and see section 3.7.1 for a link to download it for Windows 10 Home.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在Linux、MacOS和Windows 10上运行。如果你在Windows 10家庭版上工作，你首先需要安装WSL2（Windows集成的Linux内核），并在3.7.1节中查看下载链接。
- en: 3.2 Getting the code
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 获取代码
- en: This chapter has only one example project, which is based on example 2 from
    chapter 2\. It’s the video-streaming microservice we created in that chapter.
    To follow along in this chapter, you need to download the code or clone the repository.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只有一个示例项目，它基于第2章的示例2。它是我们在那一章中创建的视频流微服务。为了在本章中跟随，你需要下载代码或克隆存储库。
- en: 'You can download a zip file of the code from here:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从这里下载代码的zip文件：
- en: '[https://github.com/bootstrapping-microservices/chapter-3](https://github.com/bootstrapping-microservices/chapter-3)'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/bootstrapping-microservices/chapter-3](https://github.com/bootstrapping-microservices/chapter-3)'
- en: 'You can clone the code using Git like this:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Git像这样克隆代码：
- en: '`git clone https://github.com/bootstrapping-microservices/chapter-3.git`'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/bootstrapping-microservices/chapter-3.git`'
- en: For help on installing and using Git, see chapter 2\. If you have problems with
    the code, log an issue against the repository in GitHub.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如需安装和使用 Git 的帮助，请参阅第 2 章。如果您在代码方面遇到问题，请在 GitHub 上的存储库中记录一个问题。
- en: 3.3 What is a container?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 什么是容器？
- en: Simply put, a container (as the name implies) is something that contains something
    else. What does it contain? In this situation, we’ll use it to contain (or host)
    a microservice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，容器（正如其名称所暗示的）是包含其他东西的东西。它包含什么？在这种情况下，我们将用它来包含（或托管）微服务。
- en: Definition A *container* is a way of virtualizing a server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个 *容器* 是虚拟化服务器的一种方式。
- en: More formally, a container provides a way of virtualizing both the operating
    system and the hardware. This allows us to abstract (or *virtualize*) the resources
    required by our microservice. Containers provide a way to divide up the resources
    on one computer so that we can share these among many such services. Containers
    are one of the modern technologies that help make it cost-effective to run microservices.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，容器提供了一种虚拟化操作系统和硬件的方法。这使我们能够抽象（或虚拟化）微服务所需资源。容器提供了一种在单台计算机上划分资源的方法，以便我们可以将这些资源在许多此类服务之间共享。容器是帮助使运行微服务具有成本效益的现代技术之一。
- en: Containers are often compared to virtual machines (VMs). Both VMs and containers
    allow us to isolate our microservices to prevent them from interfering with each
    other. Before containers were invented, we ran our services in virtual machines,
    and indeed, these days we can still choose to do that when appropriate. Figure
    3.1 compares virtual machines to containers so you can visualize the differences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通常与虚拟机（VM）进行比较。虚拟机和容器都允许我们将微服务隔离，以防止它们相互干扰。在容器被发明之前，我们在虚拟机上运行我们的服务，实际上，在适当的情况下，我们仍然可以选择这样做。图
    3.1 比较了虚拟机和容器，以便您可以可视化它们之间的差异。
- en: '![](../Images/CH03_F01_Davis4.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F01_Davis4.png)'
- en: Figure 3.1 Comparing virtual machines to containers
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 比较虚拟机和容器
- en: As you can see in figure 3.1, virtual machines are more heavy-weight than containers.
    A virtual machine contains a complete copy of its operating system that’s running
    on fully virtualized hardware. A container, on the other hand, virtualizes the
    operating system as well as the hardware. A container is therefore smaller and
    does less work, which makes for more efficient use of our computing resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在图 3.1 中所看到的，虚拟机比容器更重量级。虚拟机包含其操作系统在完全虚拟化硬件上运行的完整副本。另一方面，容器虚拟化了操作系统以及硬件。因此，容器更小，工作更少，这使得我们能够更有效地使用计算资源。
- en: Ultimately, we’ll have many containers running on our Kubernetes cluster. But
    for now, we are aiming to instantiate just a single container to host the video-streaming
    microservice we created in the previous chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将在我们的 Kubernetes 集群上运行许多容器。但到目前为止，我们的目标是实例化一个容器来托管我们在上一章中创建的视频流微服务。
- en: 3.4 What is an image?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 什么是镜像？
- en: An image is a snapshot of something. The word image is used in many different
    scenarios. We could be talking about an image that’s a photograph, or we could
    be talking about an image that’s a snapshot of the hard drive for a virtual machine.
    In this book, we are talking about Docker images.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是对某物的快照。单词“镜像”在许多不同的场景中使用。我们可能正在谈论一张照片，或者我们可能正在谈论虚拟机的硬盘快照。在这本书中，我们谈论的是 Docker
    镜像。
- en: Definition An *image* is a bootable snapshot of a server (in our case, a microservice)
    including all the code, dependencies, and assets that it needs to run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个 *镜像* 是一个服务器的可启动快照（在我们的情况下，是一个微服务），包括它运行所需的所有代码、依赖项和资产。
- en: In the example for this chapter, we create a snapshot of our video-streaming
    microservice. Images are *immutable*, which means an image that has been produced
    cannot be modified. That’s an important thing to know. We might have applied tests
    or security checks to an image, and because we know the image can’t be tampered
    with, we know that our tests and security checks will remain valid.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们创建了一个视频流微服务的快照。镜像是不可变的，这意味着一旦生成，就无法修改。这是需要知道的重要事情。我们可能已经对一个镜像应用了测试或安全检查，因为我们知道镜像不能被篡改，我们知道我们的测试和安全检查将保持有效。
- en: You can think of an image as being a dormant version of a microservice, a way
    of storing it prior to running it. It’s in a state waiting to be booted as a container,
    ready for when we need to instantiate it into our application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将镜像视为微服务的休眠版本，是它在运行之前存储的一种方式。它处于等待启动为容器的状态，准备在我们需要将其实例化到应用程序中时使用。
- en: 'Figure 3.2 shows how a container is booted from an image. The image itself
    contains everything needed to instantiate a container: the code for the microservice,
    its dependencies, and any other assets and resources that our microservice needs
    to do its job.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2展示了如何从一个镜像启动容器。镜像本身包含创建容器所需的一切：微服务的代码、其依赖项以及微服务执行其工作所需的其他资产和资源。
- en: '![](../Images/CH03_F02_Davis4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02_Davis4.png)'
- en: Figure 3.2 To run our microservice in the cloud, we’ll instantiate its Docker
    image in a container.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 要在云中运行我们的微服务，我们将在容器中实例化其Docker镜像。
- en: Soon, we’ll build an image for our microservice and run it as a container. Before
    that, let’s learn more about Docker.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将为我们的微服务构建一个镜像，并以容器的方式运行它。在那之前，让我们更多地了解Docker。
- en: 3.5 Why Docker?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 为什么选择Docker？
- en: Surely you have already heard about Docker? It’s probably one of the reasons
    you bought this book. Almost everyone who is building cloud-based applications
    is using Docker or wanting to use it. Let’s look at why this is.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定已经听说过Docker了？这可能是你购买这本书的原因之一。几乎每个构建基于云的应用程序的人都在使用Docker或想要使用它。让我们看看为什么这是这样。
- en: Docker is quasi-ubiquitous in the software industry. There are alternatives
    to Docker, but Docker as a technology for packaging and deploying containers has
    captured mainstream attention. It’s well-known and well-supported.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在软件行业中几乎是无处不在。虽然有一些Docker的替代品，但作为打包和部署容器的技术，Docker已经吸引了主流的关注。它广为人知，并且得到了良好的支持。
- en: Docker is even making inroads in other areas. For example, I’ve heard of people
    using Docker to deploy applications to IoT devices. It does the job we need. But
    what exactly is the job it’s doing for us?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Docker甚至在其他领域也取得了进展。例如，我听说有人使用Docker将应用程序部署到物联网设备上。它完成了我们需要的任务。但它究竟为我们做了什么？
- en: Docker is the tool we’ll use to package and publish our microservices. Although
    there is a lot you can learn about Docker, we’ll learn the minimum we need to
    get this show on the road. At the end of this chapter, I’ll provide references
    for you to dig deeper to understand Docker more broadly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是我们用来打包和发布微服务的工具。尽管你可以从Docker中学到很多东西，但我们将学习我们完成这项任务所需的最少知识。在本章末尾，我将提供一些参考资料，供你深入研究，更广泛地了解Docker。
- en: 'I like to think of Docker as the *universal package manager* : the one package
    manager to rule them all! Normally, you wouldn’t think of Docker in this way,
    but if you think it through, it makes some kind of sense. The *package manager*
    part is fairly obvious; we use Docker to package and publish our work. I say that
    it is *universal* because it supports many different technology stacks. Docker
    is open source and you can find the code for the CLI tool here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将Docker视为**通用包管理器**：统治所有包管理器的那个！通常，你不会这样考虑Docker，但如果你仔细思考，这确实有些道理。**包管理器**这部分相当明显；我们使用Docker来打包和发布我们的工作。我说它是**通用**的，因为它支持许多不同的技术栈。Docker是开源的，你可以在以下位置找到CLI工具的代码：
- en: '[https://github.com/docker/cli](https://github.com/docker/cli)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/docker/cli](https://github.com/docker/cli)'
- en: 'You can see other open-source projects from the makers of Docker here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置看到Docker制造商的其他开源项目：
- en: '[https://www.docker.com/community/open-source](https://www.docker.com/community/open-source)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.docker.com/community/open-source](https://www.docker.com/community/open-source)'
- en: Standardize your environment
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化你的环境
- en: Docker is also really good for standardizing your environments, ensuring that
    all your developers run the same development environment. This, in turn, is the
    same as the production environment. It maximizes the probability that code that
    works in development also works in production and that gives developers a better
    chance to find problems before the code gets to the customer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Docker也非常适合标准化你的环境，确保所有开发者运行的是相同的发展环境。这反过来又意味着与生产环境相同。它最大化了代码在开发环境中工作，同时在生产环境中也能工作的概率，这给了开发者更好的机会在代码到达客户之前发现问题。
- en: 3.6 What are we doing with Docker?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 我们用Docker做什么？
- en: Let’s break this question down. We will use Docker to
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个问题。我们将使用Docker来
- en: Package our microservice into a Docker image
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的微服务打包成Docker镜像
- en: Publish our image to our private container registry
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的镜像发布到我们的私有容器注册库
- en: Run our microservice in a container
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行我们的微服务
- en: It’s the last bullet point that’s most important. We want to have our microservice
    running in our production environment, but we can only do that if we have first
    packaged and published it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要点最为重要。我们希望微服务在我们的生产环境中运行，但我们只能在我们首先打包并发布它之后做到这一点。
- en: We aren’t ready to deploy our microservice to production just yet, so instead,
    we’ll focus on learning the Docker commands that we need to package, publish,
    and test our image on our development workstation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有准备好将微服务部署到生产环境，因此我们将专注于学习在开发工作站上打包、发布和测试镜像所需的 Docker 命令。
- en: Figure 3.3 gives you the general picture of what we need to do here. We’ll take
    the Node.js project for our video-streaming microservice (on the left of figure
    3.3), package it as a Docker image, and then publish it to our private container
    registry. From there, we can deploy the microservice to our Kubernetes cluster;
    although, that’s a job we’ll save for chapter 7.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 展示了我们需要在这里完成的一般步骤。我们将使用视频流微服务的 Node.js 项目（图 3.3 左侧），将其打包成 Docker 镜像，然后发布到我们的私有容器注册库。从那里，我们可以将微服务部署到我们的
    Kubernetes 集群；尽管如此，这项工作我们将留到第 7 章进行。
- en: '![](../Images/CH03_F03_Davis4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Davis4.png)'
- en: Figure 3.3 In this chapter, we will learn how to publish Docker images to our
    private container registry in the cloud.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 在本章中，我们将学习如何将 Docker 镜像发布到云中的私有容器注册库。
- en: 3.7 Extending our development environment with Docker
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 使用 Docker 扩展我们的开发环境
- en: Before we can use Docker, we must upgrade our development environment. To follow
    along with this chapter, you’ll need to have Docker installed on your own computer.
    In this section, we’ll install Docker and make sure it’s ready to go.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用 Docker 之前，我们必须升级我们的开发环境。为了跟随本章内容，您需要在您的电脑上安装 Docker。在本节中，我们将安装 Docker
    并确保其准备就绪。
- en: Figure 3.4 shows what our development environment will look like with Docker
    installed. Even though you can see that we’ll run our Node.js microservice under
    Docker, you won’t always have to run your microservices this way. When you are
    testing an individual microservice, however, you’ll just run it directly on your
    host operating system like we did in chapter 2.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 展示了安装 Docker 后我们的开发环境将看起来是什么样子。尽管您可以看到我们将运行 Node.js 微服务，但您并不总是需要以这种方式运行微服务。然而，当您测试单个微服务时，您只需像我们在第
    2 章中做的那样直接在宿主操作系统上运行它即可。
- en: '![](../Images/CH03_F04_Davis4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F04_Davis4.png)'
- en: Figure 3.4 Extending our development to run our microservice in a container
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 将我们的开发环境扩展到在容器中运行微服务
- en: Because we need to be able to package our microservice using Docker, it’s useful
    to be able to test it locally, both before and after we publish it. The ability
    to test will be useful later for any microservice that is misbehaving on Kubernetes.
    We’ll talk more about this in chapter 10.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要能够使用 Docker 打包我们的微服务，因此能够在发布前后本地测试它是很有用的。对于在 Kubernetes 上表现不佳的任何微服务，测试能力将非常有用。我们将在第
    10 章中进一步讨论这一点。
- en: 3.7.1 Installing Docker
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.1 安装 Docker
- en: To install Docker, go to the Docker website at [https://docs.docker.com](https://docs.docker.com).
    Once there, find the download/install link and follow the instructions to install
    Docker for your platform. Table 3.2 provides the details for installing Docker
    for your particular platform.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Docker，请访问 Docker 网站 [https://docs.docker.com](https://docs.docker.com)。到达网站后，找到下载/安装链接，按照说明安装适用于您平台的
    Docker。表 3.2 提供了安装 Docker 的具体细节。
- en: If you are using Windows 10, be aware that there are separate instructions for
    installing Docker on Home vs. the Pro/Enterprise versions. On Windows 10 Home
    edition, you need WSL2 (the Windows integrated Linux kernel) installed before
    you install Docker. Follow the instructions in table 3.2 to do that.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Windows 10，请注意，对于 Home 版本与 Pro/Enterprise 版本安装 Docker 的说明是分开的。在 Windows
    10 Home 版本上，您需要在安装 Docker 之前安装 WSL2（Windows 集成的 Linux 内核）。按照表 3.2 中的说明进行操作。
- en: Table 3.2 Platforms supported by Docker
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 Docker 支持的平台
- en: '| Platform | Description |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | 描述 |'
- en: '| Linux/MacOS/Windows 10 Pro/ Enterprise | Go to the Docker website at [https://docs.docker.com](https://docs.docker.com/).
    Click the download/install link and follow the instructions to install Docker
    on your system. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Linux/MacOS/Windows 10 Pro/Enterprise | 请访问 Docker 网站 [https://docs.docker.com](https://docs.docker.com/)。点击下载/安装链接，按照说明在您的系统上安装
    Docker。 |'
- en: '| Windows 10 Home | WSL2 must be installed before you can install and use Docker.To
    install WSL2 follow the instructions here:[https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)After
    installing WSL2 you can now install Docker with the instructions here:[https://docs.docker.com/docker-for-windows/install-windows-home/](https://docs.docker.com/docker-for-windows/install-windows-home/)You
    can also run Docker on Windows 10 Home edition using a virtual machine as noted
    in the following sidebar. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| Windows 10 Home | 在您安装和使用Docker之前，必须安装WSL2。要安装WSL2，请按照以下说明操作：[https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)
    安装WSL2后，您现在可以按照以下说明安装Docker：[https://docs.docker.com/docker-for-windows/install-windows-home/](https://docs.docker.com/docker-for-windows/install-windows-home/)
    您还可以使用虚拟机在Windows 10 Home版上运行Docker，如以下侧边栏中所述。|'
- en: 3.7.2 Checking your Docker installation
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.2 检查您的Docker安装
- en: 'Once you have Docker installed, you can use the terminal to check that it’s
    OK by printing the version:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了Docker，您可以使用终端通过打印版本来检查它是否正常：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you have the same version installed as I do (as of this writing), the output
    will look like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装的版本与我安装的版本相同（截至本文写作时），输出将如下所示：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But don’t worry if you are using a later version of Docker. Most likely, it
    will be backward compatible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Docker的较新版本，请不要担心。它很可能与旧版本向后兼容。
- en: Running Docker under a virtual machine (VM)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机（VM）下运行Docker
- en: You might have noticed that the chapter 3 repository ([https://github.com/bootstrapping
    -microservices/chapter-3](https://github.com/bootstrapping-microservices/chapter-3))
    includes a Vagrantfile. This is a Vagrant script that boots a pre-configured Ubuntu
    Linux virtual machine (VM) that automatically has Docker installed. To use it,
    you must first install Vagrant and VirtualBox.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，第3章的仓库([https://github.com/bootstrapping-microservices/chapter-3](https://github.com/bootstrapping-microservices/chapter-3))包含一个Vagrantfile。这是一个Vagrant脚本，它会启动一个预先配置的、自动安装了Docker的Ubuntu
    Linux虚拟机（VM）。要使用它，您必须首先安装Vagrant和VirtualBox。
- en: This is a convenient way for you to boot an instant and throwaway development
    environment. Well, it’s not quite instant, but invoking `vagrant up` to build
    a VM for development is much quicker than creating it manually. I say that it’s
    throwaway because invoking `vagrant destroy` removes the VM and leaves your development
    workstation in a clean state. This makes Vagrant a good way to try out new software
    (like Docker) without cluttering up your computer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种方便的方式来启动一个即时且可丢弃的开发环境。嗯，它并不完全即时，但通过调用`vagrant up`来构建用于开发的VM比手动创建要快得多。我说它是可丢弃的，因为调用`vagrant
    destroy`会删除VM，并将您的开发工作站保持在一个干净的状态。这使得Vagrant成为尝试新软件（如Docker）的好方法，而不会使您的电脑变得杂乱。
- en: 'Each code repository for other chapters in the book also include a Vagrantfile.
    You can conveniently create a VM to try out the examples in this book if that’s
    the way you’d like to follow along. To learn more about Vagrant, see appendix
    A or visit the Vagrant website:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 书中其他章节的每个代码仓库也包含一个Vagrantfile。如果您想按照这种方式跟随示例，您可以方便地创建一个VM来尝试这本书中的示例。要了解更多关于Vagrant的信息，请参阅附录A或访问Vagrant网站：
- en: '[https://www.vagrantup.com/](https://www.vagrantup.com/)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.vagrantup.com/](https://www.vagrantup.com/)'
- en: 3.8 Packaging our microservice
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 打包我们的微服务
- en: 'Now that we have Docker installed, we can start to think about using it to
    package our microservice for deployment. Ultimately, we want to deploy our microservice
    to production. But first, we need everything bundled and ready to ship. We’ll
    package our microservice with the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Docker，我们可以开始考虑使用它来打包我们的微服务以进行部署。最终，我们希望将微服务部署到生产环境中。但首先，我们需要将所有内容打包并准备好发货。我们将按照以下步骤打包我们的微服务：
- en: Create a Dockerfile for our microservice
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的微服务创建Dockerfile
- en: Package our microservice as a Docker image
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的微服务打包成Docker镜像
- en: Test the published image by booting it as a container
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过作为容器启动已发布的镜像来测试它
- en: 3.8.1 Creating a Dockerfile
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.1 创建Dockerfile
- en: For every Docker image we want to create, we must create a Dockerfile. The *Dockerfile*
    is a specification for an image created by Docker. I like to think of the Dockerfile
    as a script file with instructions on how to construct the image. You can see
    this illustrated in figure 3.5.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要创建的每个Docker镜像，我们必须创建一个Dockerfile。*Dockerfile*是Docker创建的镜像的规范。我喜欢将Dockerfile想象成一个包含构建镜像指令的脚本文件。您可以在图3.5中看到这一点的说明。
- en: The lines in the Dockerfile define our microservice, its dependencies, and any
    supporting assets. Different lines in the Dockerfile cause different files to
    be copied across to the image. To the Dockerfile, we’ll add instructions for copying
    across our Node.js project and for installing our npm dependencies.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile中的行定义了我们的微服务、其依赖项以及任何支持资产。Dockerfile中的不同行会导致不同的文件被复制到镜像中。对于Dockerfile，我们将添加复制我们的Node.js项目和安装我们的npm依赖项的指令。
- en: Also notice in figure 3.5 that we are copying an example video into our image.
    Baking the video into the image isn’t something we’ll want to do in the final
    production version, but it’s useful in this example-we don’t yet have any other
    way of storing this video.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意图3.5中，我们将一个示例视频复制到了我们的镜像中。将视频烘焙到镜像中并不是我们在最终生产版本中想要做的事情，但在本例中它是有用的——我们还没有其他方式来存储这个视频。
- en: '![](../Images/CH03_F05_Davis4.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F05_Davis4.png)'
- en: Figure 3.5 The Dockerfile is a script that specifies how to build our Docker
    image.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 Dockerfile是一个脚本，它指定了如何构建我们的Docker镜像。
- en: Having only a single video would make for a pretty boring video-streaming application,
    but fixing that will have to wait until chapter 4\. For now, this actually serves
    as a good example to show that it’s not just code we can include in our image.
    Including other types of assets presents no problem for Docker!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个视频会让视频流应用显得相当无聊，但解决这个问题将留到第4章。现在，这实际上是一个很好的例子，表明我们不仅可以包含代码到我们的镜像中。包含其他类型的资产对Docker来说没有任何问题！
- en: Listing 3.1 shows the Dockerfile for our video-streaming microservice. There’s
    not much to it, and it’s a good example of a Dockerfile for a Node.js application.
    Have a read and try to visualize what each line adds to the resulting image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1显示了我们的视频流微服务的Dockerfile。它并不复杂，是Node.js应用程序Dockerfile的一个好例子。请阅读并尝试想象每一行是如何添加到最终镜像中的。
- en: Listing 3.1 A Dockerfile for our video-streaming microservice (chapter-3/example-1/
    Dockerfile)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 为我们的视频流微服务（chapter-3/example-1/Dockerfile）的Dockerfile
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Sets the base image for our new image. This allows us to produce new images
    based on existing images.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为我们的新镜像设置基础镜像。这允许我们基于现有镜像生成新镜像。
- en: ② Sets the directory in our image. Other paths are relative to this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置镜像中的目录。其他路径相对于此。
- en: ③ Copies the Node.js package.json file into the image
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将Node.js的package.json文件复制到镜像中
- en: ④ Installs only the production dependencies using npm
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用npm仅安装生产依赖项
- en: ⑤ Copies the source code for our microservices
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 复制我们的微服务的源代码
- en: ⑥ Copies our sample video
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 复制我们的示例视频
- en: ⑦ Starts the microservice using the “npm start” convention (see the previous
    chapter)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用“npm start”约定启动微服务（参见上一章）
- en: In listing 3.1, the first line includes the `FROM` instruction. This specifies
    the *base image* from which we derive our new image. By saying our base image
    is node:12.18.1-alpine, we are stating that our derived image should include Node.js
    version 12.18.1\. (If you are wondering what alpine means, see the following sidebar.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表3.1中，第一行包含了`FROM`指令。这指定了我们新镜像的基础镜像。通过说我们的基础镜像为node:12.18.1-alpine，我们是在声明我们的衍生镜像应包含Node.js版本12.18.1。（如果你想知道alpine是什么意思，请参见以下边栏。）
- en: If you are working with languages or frameworks other than JavaScript and Node.js,
    then you’ll choose a different base image. Choose one that is appropriate to your
    own tech stack.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用除JavaScript和Node.js之外的语言或框架，那么你将选择不同的基础镜像。选择一个适合你自己的技术栈的镜像。
- en: Being able to choose the base image is extremely useful. We might choose to
    use any of the many public images available on Docker Hub ([https://hub.docker.com](https://hub.docker.com)),
    or we can even create our own custom base image. This means we can reuse existing
    images, and by the end of this book, we’ll also have seen several examples of
    reusing third-party images.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 能够选择基础镜像非常实用。我们可以选择使用Docker Hub上可用的众多公共镜像之一（[https://hub.docker.com](https://hub.docker.com)），或者甚至创建我们自己的自定义基础镜像。这意味着我们可以重用现有镜像，到本书结束时，我们还将看到几个重用第三方镜像的示例。
- en: Also in listing 3.1 are various lines with the `COPY` instruction. These lines
    copy files into our image. You can see that package.json, our code, and the example
    video are all copied into the image.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表3.1中还有各种包含`COPY`指令的行。这些行将文件复制到我们的镜像中。你可以看到package.json、我们的代码和示例视频都被复制到了镜像中。
- en: The `RUN` instruction is worth noting too. You can run software within the image
    during the build process to make changes to the image, install dependencies, and
    perform other setup tasks. In this example, we use `RUN` to install our npm dependencies
    and bake those into the image.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令也值得注意。你可以在构建过程中在镜像内运行软件，以更改镜像、安装依赖项和执行其他设置任务。在这个例子中，我们使用`RUN`来安装我们的npm依赖项并将它们嵌入到镜像中。'
- en: The last and most important line in listing 3.1 is the `CMD` instruction. This
    sets the command that is invoked when our container is instantiated. This is how
    we tell it to run our Node.js application using the npm start script we added
    to our package.json file in chapter 2\. For a refresher on that, reread section
    2.6.7.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1中最后且最重要的一行是`CMD`指令。这个指令设置在容器实例化时调用的命令。这就是我们告诉它使用我们在第2章中添加到package.json文件的npm
    start脚本来运行我们的Node.js应用程序的方式。关于这一点，可以重新阅读2.6.7节。
- en: 'Alpine vs. non-alpine: Part 1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine与非Alpine：第1部分
- en: When you see “alpine” in the name of an image (e.g., node:12.18.1-alpine), it
    indicates that the image is based on Alpine Linux. Alpine is a lightweight Linux
    distribution that includes only the bare minimum, so it is much smaller than a
    regular distribution. Alpine images are great for production because of the size,
    which makes better use of your infrastructure and cloud resources.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在镜像的名称中看到“alpine”（例如，node:12.18.1-alpine）时，这表明该镜像基于Alpine Linux。Alpine是一个轻量级的Linux发行版，只包含最基本的东西，因此它比常规发行版小得多。由于尺寸小，Alpine镜像非常适合生产，因为它能更好地利用你的基础设施和云资源。
- en: 3.8.2 Packaging and checking our Docker image
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.2 打包和检查我们的Docker镜像
- en: Now that we have created our Dockerfile, we can package our microservice as
    a *ready-to-run* image. We’ll build the image using the `docker build` command.
    It takes as input our Dockerfile, which contains the instructions to build the
    image. Figure 3.6 shows this process in action.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了Dockerfile，我们可以将我们的微服务打包成一个*可运行*的镜像。我们将使用`docker build`命令来构建这个镜像。它以输入我们的Dockerfile，其中包含构建镜像的指令。图3.6显示了这一过程。
- en: '![](../Images/CH03_F06_Davis4.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F06_Davis4.png)'
- en: Figure 3.6 The `docker` `build` command produces a Docker image as specified
    by our Dockerfile.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 `docker build`命令根据我们的Dockerfile生成Docker镜像。
- en: Note Before we can deploy our microservice to production, we must be able to
    package it in a Docker image.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在我们可以将微服务部署到生产之前，我们必须能够将其打包成Docker镜像。
- en: Now comes the fun part. It’s time to create an image from our microservice.
    To follow along, you’ll need a Dockerfile like the one shown in listing 3.1 and
    a Node.js project. You can create your own or use example-1 from the chapter-3
    code repository on GitHub (see section 3.1).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了有趣的部分。是时候从我们的微服务中创建一个镜像了。为了跟上进度，你需要一个像列表3.1中显示的Dockerfile，以及一个Node.js项目。你可以自己创建一个，或者使用GitHub上第3章代码仓库中的example-1（见3.1节）。
- en: 'When you are ready, open a terminal and change directory to chapter-3/example-1
    (or whichever directory where you have your code and Dockerfile). Now invoke `docker
    build` as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好了，打开一个终端并切换到chapter-3/example-1目录（或者你存放代码和Dockerfile的任何目录）。现在按照以下方式调用`docker
    build`：
- en: '![](../Images/CH03_UN01_Davis4.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_UN01_Davis4.png)'
- en: 'When you run this code, you’ll see the various pieces of the base image being
    downloaded. This download only happens the first time; subsequently, you’ll already
    have the base image cached on your workstation. It won’t be downloaded again (at
    least not until you delete all your local images as we’ll do later in section
    3.9.3). Once it completes, you should see something like this at the end of the
    output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你会看到基础镜像的各个部分正在下载。这个下载只会在第一次发生；随后，你已经在你的工作站上缓存了基础镜像。它不会再次下载（至少在我们稍后在3.9.3节中删除所有本地镜像之前不会下载）。一旦完成，你应该在输出的末尾看到类似以下内容：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tells you that the image was successfully built. It also gives you the
    unique ID for your image and displays the tag that you set for it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明镜像已成功构建。它还提供了你镜像的唯一ID，并显示了为它设置的标签。
- en: Note When you invoke this command for yourself, you will see a different output
    because the ID allocated to your image will be different from the ID that was
    allocated to my image.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你自己调用此命令时，你会看到不同的输出，因为分配给你的镜像的ID将不同于分配给我的镜像的ID。
- en: Because it’s a unique ID, it’s going to be different for *every* new image that
    you create. You can take note of this ID if you want and use it to reference the
    image in future Docker commands. You don’t really need to do that, however, because
    we tagged it with a meaningful name (video-streaming). We can use that name instead
    of the ID.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个唯一的ID，所以它将随着你创建的每个新图像而不同。如果你想的话，你可以记下这个ID，并在未来的Docker命令中使用它来引用图像。然而，你实际上并不需要这样做，因为我们已经用有意义的名称（video-streaming）标记了它。我们可以使用这个名称而不是ID。
- en: 'Note also in the output that the version was automatically set to `latest`
    because we didn’t specify anything for it. In chapter 7, we’ll set this version
    automatically as part of our continuous delivery process. This will distinguish
    each new version of the image we produce as we iteratively update our code and
    build new images. Some other points to note are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中版本被自动设置为`latest`，因为我们没有为它指定任何内容。在第7章中，我们将自动设置这个版本作为我们持续交付过程的一部分。这将区分我们随着代码迭代更新和构建新图像而产生的每个新版本。以下是一些其他需要注意的点：
- en: '*The* `-t` *argument* *allows us to tag or name our image.* You’ll want to
    do this; otherwise, you’ll have to reference your image by its unique ID. It’s
    a big ugly string of numbers (as you saw in the previous output), so it’s not
    the best option.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*The* `-t` *argument* *允许我们标记或命名我们的图像。* 你会想要这样做；否则，你将不得不通过其唯一的ID来引用你的图像。它是一长串难看的数字（正如你在前面的输出中看到的），所以这不是最佳选择。'
- en: '*The* `--file` *argument* *specifies the name of the Dockerfile to use.* Technically,
    this is unnecessary because it defaults to the file named Dockerfile anyway. I’m
    including this explicitly so that you know about it, and it’s something we’ll
    make use of later in chapter 5\. In that chapter, we will separate our Dockerfiles
    to have different versions in development and production.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*The* `--file` *argument* *指定要使用的Dockerfile的名称。* 从技术上讲，这是不必要的，因为默认情况下它总是命名为Dockerfile。我明确地包括这一点是为了让你知道，我们将在第5章中利用它。在第5章中，我们将分离我们的Dockerfile，以便在开发和生产中有不同的版本。'
- en: '*Don’t forget the period at the end!* It’s easy to miss. It tells the `build`
    command to operate against the current directory. This means that any instructions
    in the Dockerfile are relative to the current working directory. Changing this
    directory makes it possible to store our Dockerfile in a different directory from
    our project’s assets. This can be useful at times, but it’s not a feature we need
    right now.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要忘记句号！* 很容易忽略。它告诉`build`命令针对当前目录操作。这意味着Dockerfile中的任何指令都是相对于当前工作目录的。更改此目录使得将Dockerfile存储在项目资产的不同目录中成为可能。这在某些时候可能很有用，但不是我们现在需要的特性。'
- en: 'Here’s the general format for the `docker build` command when building your
    own image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建你自己的图像时`docker build`命令的一般格式：
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can plugin in the particular name of your microservice as the image name,
    the path to its Dockerfile, and the path to its project folder. After building
    our image, we should now check it to make sure it’s OK. We can list our local
    images using this command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的微服务的特定名称作为图像名称、其Dockerfile的路径以及其项目文件夹的路径插入其中。构建我们的图像后，我们现在应该检查它以确保一切正常。我们可以使用以下命令列出我们的本地图像：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This lists the images on our local workstation. If our `docker build` command
    from the previous section completed successfully, we now see at least two images
    listed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这列出了我们本地工作站上的图像。如果上一节中的`docker build`命令成功完成，我们现在可以看到至少列出两个图像：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might see other images in this list if you have already been using Docker
    to create other images locally or if you have been exploring the many publicly
    available images on Docker Hub (see the sidebar entitled “Exploring other containers”).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用Docker在本地创建其他图像，或者如果你已经探索了Docker Hub上许多公开可用的图像，你可能会在这个列表中看到其他图像（参见标题为“探索其他容器”的侧边栏）。
- en: Note the columns in the preceding output. Under the `REPOSITORY` column, you
    can see `video-streaming` and `node`, where `video-streaming` is the image for
    our microservice that we just created, and `node` is the base image that we referenced
    in our Dockerfile in listing 3.1.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面的输出中的列。在`REPOSITORY`列下，你可以看到`video-streaming`和`node`，其中`video-streaming`是我们刚刚创建的微服务的图像，而`node`是我们第3.1列表中引用的基础图像。
- en: '`TAG` is the next column, and it usually shows the image’s version number.
    Because we didn’t specifically choose a version for our video-streaming image,
    it was automatically allocated the version `latest`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`TAG`是下一列，通常显示镜像的版本号。因为我们没有为我们的视频流镜像指定版本，所以它自动分配了版本`latest`。'
- en: The next column is `IMAGE ID` and shows the unique ID for each image. Note here
    that the ID for our video-streaming image is the same as in the output from the
    `build` command. Again, expect the unique ID for your image to be different to
    what you see here. Other columns in this output include `CREATED`, which tells
    you when the image was created, and `SIZE`, which shows you the size of the image.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列是`IMAGE ID`，显示了每个镜像的唯一ID。请注意，我们的视频流图像的ID与`build`命令的输出中的ID相同。再次强调，您镜像的唯一ID可能与这里看到的不同。输出中的其他列包括`CREATED`，它告诉您镜像是在何时创建的，以及`SIZE`，它显示了镜像的大小。
- en: 'Alpine vs. non-alpine: Part 2'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine与非Alpine：第二部分
- en: In this section, you can see in the output from `docker image list` that the
    size of our video-streaming image is 74.3 MB. This size is due to selecting an
    Alpine image as our base image.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您可以在`docker image list`的输出中看到我们的视频流图像大小为74.3 MB。这个大小是由于我们选择了Alpine图像作为我们的基础镜像。
- en: Want to know the size if instead we use a non-alpine image? Well, it weighs
    in at a whopping 902 MB for the non-alpine image. That’s over 10 times the size!
    You can clearly see why we want to use Alpine images in production.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道如果我们使用非Alpine镜像的大小是多少吗？嗯，非Alpine镜像的重量达到了惊人的902 MB。这是大小的10倍以上！您可以清楚地看到为什么我们想在生产中使用Alpine镜像。
- en: 3.8.3 Booting our microservice in a container
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8.3 在容器中启动我们的微服务
- en: Before we publish our newly created Docker image, we should do a test run on
    our development workstation to make sure everything is in working order. Once
    we have packaged our microservice as a Docker image, we can use the `docker` `run`
    command to instantiate it as a container as shown in figure 3.7\. This creates
    an instance of our video-streaming microservice on our development workstation
    that we can then test using a web browser.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发布新创建的Docker镜像之前，我们应该在我们的开发工作站上对其进行测试运行，以确保一切正常工作。一旦我们将微服务打包成Docker镜像，我们就可以使用`docker
    run`命令将其实例化为容器，如图3.7所示。这将在我们的开发工作站上创建一个我们的视频流微服务的实例，然后我们可以使用网页浏览器对其进行测试。
- en: '![](../Images/CH03_F07_Davis4.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F07_Davis4.png)'
- en: Figure 3.7 The `docker` `run` command produces an instance of our microservice
    running in a container.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 `docker run`命令生成了我们的微服务在容器中运行的实例。
- en: 'When you are ready, open a terminal and invoke the following command to instantiate
    your microservice from the image:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好时，打开一个终端并调用以下命令来从镜像实例化您的微服务：
- en: '![](../Images/CH03_UN02_Davis4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_UN02_Davis4.png)'
- en: 'As output, you should see the unique ID for the container printed. Here is
    the output from when I invoked the command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，您应该看到打印出的容器的唯一ID。以下是我调用命令时的输出：
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Seeing such output means your microservice started successfully. When you run
    this command, you will see different output. That’s because your container is
    going to have a different unique ID to mine. You’ll still see a big long string
    of numbers like that shown, but again, it’s going to be different. You’ll need
    this ID to invoke future Docker commands that relate to the container.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这样的输出意味着您的微服务已成功启动。当您运行此命令时，您将看到不同的输出。这是因为您的容器将有一个与我不同的唯一ID。您仍然会看到一个很长的一串数字，但再次强调，它将是不同的。您需要这个ID来调用与容器相关的未来的Docker命令。
- en: Don’t worry about trying to remember it (unless you have a photographic memory)
    because we can easily recall this and other details of the container on demand,
    as you’ll soon see. More points to note here are listed next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心试图记住它（除非您有 photographic memory），因为我们可以很容易地按需回忆起这个和其他容器的细节，正如您很快就会看到的。下面列出了更多需要注意的点。
- en: '*The* `-d` *argument* *causes our container to run in detached mode**.* This
    means it runs in the background and we can’t directly see its logs. If we omitted
    this, our container would run in the foreground, and we’d see its output directly;
    although, it would also be tying up our terminal.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`-d`参数使我们的容器以分离模式运行**。这意味着它在后台运行，我们无法直接看到其日志。如果我们省略了它，我们的容器将在前台运行，我们可以直接看到其输出；尽管如此，它也会占用我们的终端。*'
- en: '*The* `-p` *argument* *binds the port between the host operating system and
    our container.* This is like port forwarding, network traffic sent to port 3000
    on our development workstation is *forwarded* to port 3000 inside our container.
    We set it up that way because we originally hard-coded our microservice to listen
    on port 3000.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`-p`参数*将主机操作系统和我们的容器之间的端口绑定。这就像端口转发一样，发送到我们开发工作站上端口3000的网络流量将被*转发*到容器内的端口3000。我们这样设置是因为我们最初将微服务硬编码为监听端口3000。'
- en: The number 3000 itself isn’t important here. We could have used almost any number
    for this, but 3000 is often used by convention when developing/testing individual
    HTTP servers.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字3000本身在这里并不重要。我们可以使用几乎任何数字，但根据惯例，在开发/测试单个HTTP服务器时通常使用3000。
- en: '*The last argument,* `video-streaming`*, is the name we gave our image.* This
    is how we specify which image (we could have many) will be instantiated. This
    relates to the name we gave the image using `docker` `build` and the `-t` argument
    back in section 3.8.2.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最后一个参数*，`video-streaming`，是我们给我们的图像取的名字。这是我们指定哪个图像（我们可能有多个）将被实例化的方式。这与我们在3.8.2节中使用的`docker
    build`命令和`-t`参数所指定的图像名称相关。'
- en: 'A common error at this point is when the port we are using (e.g., port 3000)
    is already allocated to another application. If this happens, you’ll need to either
    shut down the other application, or if you can’t do that, you’ll have to choose
    a port other than 3000\. You can do this by using a PORT environment variable
    as we did in section 2.6.6 in chapter 2\. Here is the general format for the `docker
    run` command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上常见的错误是当我们使用的端口（例如，端口3000）已经被另一个应用程序分配时。如果发生这种情况，您需要关闭该应用程序，或者如果您不能这样做，您将不得不选择一个不同于3000的端口。您可以通过使用我们在第2章2.6.6节中使用的PORT环境变量来完成此操作。以下是`docker
    run`命令的一般格式：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can use this to boot other microservices by plugging in the particular name
    for each image that you create.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此方法通过插入您创建的每个图像的特定名称来启动其他微服务。
- en: Checking the container
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 检查容器
- en: 'We have a running container now, but let’s check to make sure it’s in working
    order. To show the containers you have, invoke this command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个正在运行的容器，但让我们检查一下它是否处于正常工作状态。要显示您拥有的容器，请调用此命令：
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s a cutdown version of the output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出的一部分：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Your output will look different from that shown because to make it fit, I removed
    the columns `COMMAND`, `CREATED`, and `NAMES`. But you can run the command yourself
    to see those.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出将不同于显示的输出，因为为了使其适应，我移除了`COMMAND`、`CREATED`和`NAMES`列。但您可以直接运行该命令以查看这些信息。
- en: Note the `CONTAINER ID` column. This shows you the unique ID of the container.
    It is a reduced version of the longer ID that was output from the `docker run`
    command in the previous section. Both are the unique IDs of your container, and
    as you’ll see in a moment, we’ll use the ID to identify the container when we
    run Docker commands against it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`CONTAINER ID`列。这显示了容器的唯一ID。它是从上一节中`docker run`命令输出的较长ID的简化版本。两者都是您容器的唯一ID，如您一会儿将看到的，我们将使用ID在运行Docker命令时识别容器。
- en: Checking your microservice
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您的微服务
- en: 'We have successfully instantiated a container from our image, and we checked
    that it is running. But how do we know if our microservice inside the container
    is functional? It could be throwing up all sorts of errors and, as yet, we wouldn’t
    know about it. Let’s check the output of the microservice and see what it tells
    us:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功从我们的图像中实例化了一个容器，并检查了它是否正在运行。但我们如何知道容器内的微服务是否功能正常？它可能会抛出各种错误，而我们目前还不知道。让我们检查微服务的输出并看看它告诉我们什么：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Whoa, hold up! You can’t just invoke that command and use the unique ID for
    my container. Remember, the ID will be different for the container created on
    your workstation. You’ll get an error if you invoke it exactly like this. So note
    the ID of *your* container as demonstrated in the previous section and invoke
    the command like this, plugging in your own container ID:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，等等！您不能只是调用那个命令并使用我的容器的唯一ID。记住，您的工站上创建的容器的ID将是不同的。如果您这样调用，将会得到一个错误。所以请注意您自己的容器ID，如前节所示，并像这样调用命令，插入您自己的容器ID：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now you should see the output from your microservice. If you run the code from
    example-1 in the chapter-3 code repository, you should see something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到微服务的输出。如果您从第3章代码库中的example-1运行代码，您应该看到类似以下内容：
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Success! We built an image. We instantiated it as a container, and we confirmed
    that our microservice is operational. Now let’s test this in the web browser.
    Open your browser and point it at http://localhost:3000/video. You should see
    the streaming video, and the result should look the same as what we tested in
    chapter 2.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们构建了一个镜像。我们将其实例化为一个容器，并确认我们的微服务正在运行。现在让我们在网页浏览器中测试一下。打开你的浏览器，将其指向http://localhost:3000/video。你应该能看到流媒体视频，结果应该和我们在第2章中测试的相同。
- en: Why does this work? It works because we used the `-p` argument with the `docker
    run` command to forward port 3000 on our workstation (assuming that this port
    wasn’t already allocated) to port 3000 in the container. Our microservice was
    listening on port 3000 and it responded!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这能工作？这是因为我们使用了`docker run`命令中的`-p`参数，将我们的工作站上的端口3000（假设这个端口还没有被分配）转发到容器中的端口3000。我们的微服务正在监听端口3000，并做出了响应！
- en: There’s obviously more we could do to test our code. But we’ll save that for
    later. In chapter 8*,* we’ll look at how we can apply automated code-driven testing
    to our microservices. Then in chapter 10, we’ll see how to monitor our microservices,
    how to debug them when problems are found, and what techniques we can use for
    building fault-tolerant systems. But now, we are ready to publish our image!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们还可以做更多的事情来测试我们的代码。但我们将把那留到以后。在第8章*中，我们将探讨如何将自动化的代码驱动测试应用到我们的微服务中。然后在第10章中，我们将看到如何监控我们的微服务，当发现问题时要如何调试它们，以及我们可以用于构建容错系统的技术。但现在，我们已经准备好发布我们的镜像了！
- en: Exploring other containers
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 探索其他容器
- en: Did you know that you can easily run any public image using the `docker run`
    command? Two images we’ll use later in the book are mongodb and rabbitmq. Try
    running these for yourself to get an instant database available on localhost:27017\.
    For example
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你可以轻松地使用`docker run`命令运行任何公共镜像吗？本书后面我们将使用的两个镜像分别是mongodb和rabbitmq。试着运行这些镜像，以便在localhost:27017上获得一个即时可用的数据库。例如
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are many public images available online, and you don’t need an account
    to access these. Search Docker Hub to find more at [https://hub.docker.com](https://hub.docker.com).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有许多公共镜像可供使用，你不需要账户就可以访问这些镜像。在Docker Hub上搜索以找到更多[https://hub.docker.com](https://hub.docker.com)。
- en: 3.9 Publishing our microservice
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9 发布我们的微服务
- en: We are close now to having our first microservice ready for production deployment.
    We have packaged it in a Docker image, but currently, that image resides locally
    on our development workstation. That’s great for our own testing and experimentation,
    but we still need to have our image published somewhere, so that we can later
    deploy it to our Kubernetes cluster. Figure 3.8 illustrates how we will now publish
    our image to a private container registry hosted in the cloud.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎已经准备好将我们的第一个微服务用于生产部署。我们已经将其打包成一个Docker镜像，但目前这个镜像仅存在于我们的开发工作站上。这对我们的测试和实验来说很好，但我们仍然需要将我们的镜像发布到某个地方，以便我们以后可以将其部署到我们的Kubernetes集群中。图3.8展示了我们现在如何将我们的镜像发布到云中托管的私有容器注册库。
- en: '![](../Images/CH03_F08_Davis4.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F08_Davis4.png)'
- en: Figure 3.8 Publishing our Docker image to a private container registry in the
    cloud
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 将我们的Docker镜像发布到云中的私有容器注册库
- en: 'We’ll publish our microservice with the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤发布我们的微服务：
- en: We create our own private container registry on Microsoft Azure. We only need
    to do this the first time we publish an image. Later, when we publish new versions
    of the image and images for other microservices, we’ll simply reuse this same
    registry.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Microsoft Azure上创建了自己的私有容器注册库。我们只需要在第一次发布镜像时做这件事。以后，当我们发布镜像的新版本和其他微服务的镜像时，我们将简单地重用这个相同的注册库。
- en: Before publishing, we must authenticate with the registry using the `docker
    login` command.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发布之前，我们必须使用`docker login`命令对注册库进行身份验证。
- en: We use the `docker push` command to upload our image to the registry. (This
    is the step that actually publishes our microservice.)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`docker push`命令将我们的镜像上传到注册库。（这是实际发布我们的微服务的步骤。）
- en: We use `docker run` again to check that we can boot our microservice from the
    published image.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次使用`docker run`来检查我们是否可以从发布的镜像启动我们的微服务。
- en: 3.9.1 Creating a private container registry
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.1 创建私有容器注册库
- en: Creating a private container registry turns out to be pretty simple. We’ll create
    our registry on Microsoft Azure, but all the major cloud vendors have support
    for this. Why publish to a private registry? In this book, we are learning how
    to build proprietary applications for a private company, so it makes sense to
    publish our images privately instead of using a public registry such as Docker
    Hub.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建私有容器注册库实际上非常简单。我们将在 Microsoft Azure 上创建我们的注册库，但所有主要的云服务提供商都支持这项功能。为什么选择发布到私有注册库？在这本书中，我们正在学习如何为私有公司构建专有应用，因此将镜像私下发布而不是使用像
    Docker Hub 这样的公共注册库是有意义的。
- en: I’m using Azure for this book because I have found it to be the simplest cloud
    platform to use, and it’s a great starting point for learning how to build cloud-native
    applications. Azure provides a good deal for new signups, with free credit for
    your first month. That gives you some time where you can try out the cloud infrastructure
    demonstrated in this book for free.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Azure 来写这本书，因为我发现它是最简单的云平台之一，并且它是学习如何构建云原生应用的绝佳起点。Azure 为新注册用户提供了一些优惠，包括第一个月免费信用额度。这为您提供了尝试本书中展示的云基础设施的机会，而且无需付费。
- en: 'Make sure you destroy all your resources later so you don’t end up unnecessarily
    paying for them. Incidentally, this is another reason to use Azure: Microsoft
    has made it easy to find and destroy cloud resources so that we don’t forget about
    something and end up paying for unused infrastructure. For now, we’ll create our
    container registry manually. But in chapter 6, we’ll return to this and learn
    how to create it with code.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您稍后销毁所有资源，以免不必要地支付费用。顺便说一句，这也是使用 Azure 的另一个原因：微软已经使查找和销毁云资源变得容易，这样我们就不会忘记某些事情，最终为未使用的基础设施付费。现在，我们将手动创建我们的容器注册库。但在第
    6 章，我们将回到这个话题，学习如何使用代码创建它。
- en: 'Open your browser and load the Azure web site: [https://azure.microsoft.com](https://azure.microsoft.com).
    Go through the steps to sign up. After signing up you should be able to sign in
    to the Azure portal at [https://portal.azure.com](https://portal.azure.com).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的浏览器并加载 Azure 网站：[https://azure.microsoft.com](https://azure.microsoft.com)。按照步骤进行注册。注册后，您应该能够登录到
    Azure 门户：[https://portal.azure.com](https://portal.azure.com)。
- en: Once in the Azure portal, you should see the Create a Resource option in the
    menu on the left. Click this and then in the Search input box, enter `container
    registry` and press Enter. You’ll see matching options as shown in figure 3.9\.
    Click the option Container Registry by Microsoft.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入 Azure 门户，您应该在左侧菜单中看到“创建资源”选项。点击此选项，然后在搜索输入框中输入“container registry”并按 Enter。您将看到如图
    3.9 所示的匹配选项。点击“Container Registry by Microsoft”选项。
- en: '![](../Images/CH03_F09_Davis4.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 戴维斯 4](../Images/CH03_F09_Davis4.png)'
- en: Figure 3.9 Creating a new private container registry in the Azure portal
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 在 Azure 门户中创建新的私有容器注册库]'
- en: You should now see a page that explains more about the Microsoft Container Registry.
    Have a read if you like before clicking the Create button.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该看到一个页面，它解释了更多关于 Microsoft 容器注册库的信息。如果您愿意，在点击创建按钮之前先阅读一下。
- en: 'Next, we fill in some details about the registry we are creating. Figure 3.10
    shows that we first need to provide a name. The name is important because that
    creates a URL that we’ll use later to communicate with the registry. The name
    I chose for my registry is bmdk1, and this results in having a URL for the container
    registry like this: *bmdk1.azurecr.io**.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们填写一些关于我们正在创建的注册库的详细信息。图 3.10 显示，我们首先需要提供一个名称。名称很重要，因为它创建了一个我们将用于以后与注册库通信的
    URL。我为我的注册库选择的名称是 bmdk1，这导致容器注册库的 URL 如此：*bmdk1.azurecr.io**.*
- en: '![](../Images/CH03_F10_Davis4.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 戴维斯 4](../Images/CH03_F10_Davis4.png)'
- en: Figure 3.10 Filling out the details for our new private container registry
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 为我们的新私有容器注册库填写详细信息]'
- en: Because the name chosen for the registry generates the URL, it must be globally
    unique. That means you can’t choose a name that someone else has already taken-choose
    your own unique name. You should take note of the URL because you’ll need that
    soon when you invoke Docker commands against your registry.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因为为注册库选择的名称会生成 URL，所以它必须是全局唯一的。这意味着您不能选择别人已经使用的名称——选择您自己的唯一名称。您应该注意 URL，因为您很快将需要它来在您的注册库上执行
    Docker 命令。
- en: Before clicking Create, we need to select or create a *resource group*. As its
    name implies, resource groups in Azure allow cloud resources to be collected into
    groups for easier management. Figure 3.11 shows that I’m creating a new resource
    group to contain the new registry that I call bmdk1\. To create a new resource
    group, click Create New, type a name, and click OK.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击“创建”之前，我们需要选择或创建一个**资源组**。正如其名称所暗示的，Azure中的资源组允许将云资源收集到组中以方便管理。图3.11显示，我正在创建一个新的资源组来包含我称为bmdk1的新注册表。要创建一个新的资源组，请点击“创建新”，输入一个名称，然后点击“确定”。
- en: '![](../Images/CH03_F11_Davis4.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F11_Davis4.png)'
- en: Figure 3.11 Creating a new resource group to contain the private container registry
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 创建新的资源组以包含私有容器注册表
- en: This name doesn’t matter. We can use the same name as before or we can use any
    other name we like. It doesn’t need the same name as the container registry, and
    it doesn’t have to be globally unique. Just make sure you give it a name that’s
    meaningful to you so that when you see it again later, you are reminded of its
    purpose.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字不重要。我们可以使用之前相同的名字，或者我们可以使用我们喜欢的任何其他名字。它不需要与容器注册表有相同的名字，也不需要是全球唯一的。只需确保您给它一个对您有意义的名字，这样当您稍后再次看到它时，您会想起它的用途。
- en: Now click the Review + Create button. On the next page, click Create to create
    your registry.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击“审查 + 创建”按钮。在下一页，点击“创建”以创建您的注册表。
- en: To follow up on the creation of our registry, we’ll need to watch the notifications
    in the Azure Portal. Click the Notification icon to open the Notifications sidebar
    and watch the progress of our deployment. This might take some time, but when
    completed, we’ll see a Deployment Succeeded notification in the sidebar as figure
    3.12 shows.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟进我们的注册表创建，我们需要在Azure门户中查看通知。点击通知图标以打开通知侧边栏并监视部署进度。这可能需要一些时间，但完成时，我们将在侧边栏中看到“部署成功”通知，如图3.12所示。
- en: '![](../Images/CH03_F12_Davis4.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F12_Davis4.png)'
- en: Figure 3.12 The deployment of our new container registry was successful!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 我们新容器注册表的部署已成功！
- en: From the Deployment Succeeded notification, we can click Go to Resource to view
    details of the new registry. Otherwise, if we need to find our registry again
    later, click All Resources on the left-hand menu. Figure 3.13 shows that this
    lists all our resources (if you have created any others), along with our new container
    registry.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从“部署成功”通知中，我们可以点击“转到资源”来查看新注册表的详细信息。否则，如果我们稍后需要再次找到我们的注册表，请点击左侧菜单中的“所有资源”。图3.13显示，这将列出我们所有的资源（如果您创建了其他资源），以及我们的新容器注册表。
- en: '![](../Images/CH03_F13_Davis4.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F13_Davis4.png)'
- en: Figure 3.13 You can find your container registry in the All Resources list.
    At this stage we only have a single resource, the registry itself.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 您可以在“所有资源”列表中找到您的容器注册表。在这个阶段，我们只有一个资源，即注册表本身。
- en: Next, click your container registry in the list to drill down to see its details,
    then click Access Keys in the menu on the left. You can see what this looks like
    in figure 3.14\. Note here that we can see the registry’s URL.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在列表中点击您的容器注册表以深入查看其详细信息，然后在左侧菜单中点击“访问密钥”。您可以在图3.14中看到它的样子。注意，在这里我们可以看到注册表的URL。
- en: Note It’s important that we enable the Admin User option. We need this enabled
    to authenticate with our registry when pushing and pulling our images.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：启用“管理员用户”选项非常重要。我们需要启用此选项才能在推送和拉取镜像时对注册表进行认证。
- en: Now take note of your registry’s username and password (you only need the first
    password). Don’t bother noting the ones you see in figure 3.14\. These are the
    details for my registry, and it won’t exist by the time you read this. Be sure
    to use the details for your own registry!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意您的注册表的用户名和密码（您只需要第一个密码）。不要麻烦记录图3.14中看到的那些。这些是我注册表的详细信息，并且在你阅读这段文字时它将不存在。请确保使用您自己的注册表的详细信息！
- en: '![](../Images/CH03_F14_Davis4.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F14_Davis4.png)'
- en: Figure 3.14 Viewing the authentication details of our new private container
    registry
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 查看我们新的私有容器注册表的认证详情
- en: That’s all there is to it! If you followed these instructions, you now have
    your own private container registry. You can push your images to the registry,
    and from there, you can deploy these to production. So let’s get our first image
    published!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！如果您遵循了这些说明，现在您已经有了自己的私有容器注册表。您可以将镜像推送到注册表，然后从这里，您可以将其部署到生产环境中。所以让我们发布我们的第一个镜像吧！
- en: Public vs. private
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 公共与私有
- en: For this book, we are only interested in publishing private Docker images. But
    you might also be interested to know that you can also publish public images.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们只对发布私有 Docker 镜像感兴趣。但您可能也想知道，您还可以发布公共镜像。
- en: For example, let’s say you create an open-source microservice. Create a Docker
    image for it and then publish it publicly to Docker Hub. That can help your users
    get it running quickly!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您创建了一个开源微服务。为它创建一个 Docker 镜像，然后将其公开发布到 Docker Hub。这可以帮助您的用户快速运行它！
- en: To publish to Docker Hub, you’ll have to sign up at [https://hub.docker.com](https://hub.docker.com).
    Then you can use the `docker` `push` command to push your image to Docker Hub.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布到 Docker Hub，您必须在 [https://hub.docker.com](https://hub.docker.com) 注册。然后您可以使用
    `docker push` 命令将您的镜像推送到 Docker Hub。
- en: Docker Hub also allows you to publish private images. Although to publish more
    than one of those, you’ll need to upgrade to a paid account.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 还允许您发布私有镜像。尽管要发布多个这样的镜像，您需要升级到付费账户。
- en: 3.9.2 Pushing our microservice to the registry
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.2 将我们的微服务推送到注册库
- en: Now that we have a private container registry, we have a place to publish our
    first microservice. We’ll publish our image by invoking the `docker push` command
    as shown in figure 3.15.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了私有容器注册库，我们有一个地方可以发布我们的第一个微服务。我们将通过调用如图 3.15 所示的 `docker push` 命令来发布我们的镜像。
- en: '![](../Images/CH03_F15_Davis4.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F15_Davis4.png)'
- en: Figure 3.15 The `docker` `push` command uploads our Docker image to our private
    container registry.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 `docker push` 命令将我们的 Docker 镜像上传到我们的私有容器注册库。
- en: Authenticating with the registry
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注册库进行身份验证
- en: Before we can push to our registry, we must first login. We have authentication
    enabled because we don’t want just anyone to be able to publish images to our
    registry.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以向我们的注册库推送之前，我们必须首先登录。我们启用了身份验证，因为我们不希望任何人都能将镜像发布到我们的注册库。
- en: 'In the last section, you created your private container registry, and you took
    note of its details. To communicate with the registry, you must know its URL.
    To push and pull images, you need the username and password. If you can’t remember
    those, refer back to section 3.9.1 to find your registry in the Azure portal and
    recall these details. To authenticate, we’ll invoke the `docker login` command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您创建了您的私有容器注册库，并记下了其详细信息。要与注册库通信，您必须知道其 URL。要推送和拉取镜像，您需要用户名和密码。如果您记不住这些，请参阅第
    3.9.1 节，在 Azure 门户中找到您的注册库并回忆这些详细信息。要进行身份验证，我们将调用 `docker login` 命令：
- en: '![](../Images/CH03_UN03_Davis4.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_UN03_Davis4.png)'
- en: I could have shown you the full command I used complete with the URL, username,
    and password of my own registry. But that won’t fit on the page! Also, it wouldn’t
    help you because, at this point, you have to use the details of your own registry.
    When you invoke `docker` `login`, be sure to use your own URL, username, and password.
    After authenticating with `docker` `login`, you can now invoke other Docker commands
    against your registry.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以向您展示我使用的完整命令，包括我的注册库的 URL、用户名和密码。但这不会适合页面！而且，这也不会对您有帮助，因为在这个时候，您必须使用您自己的注册库的详细信息。当您调用
    `docker login` 时，请确保使用您自己的 URL、用户名和密码。在通过 `docker login` 进行身份验证后，您现在可以调用针对您的注册库的其他
    Docker 命令。
- en: Tagging our image
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 标记我们的镜像
- en: 'Before we can publish our image to the registry, we must tell Docker where
    the image is being pushed. We do this by tagging the image with the URL of the
    registry with the command `docker tag` as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以将我们的镜像发布到注册库之前，我们必须告诉 Docker 镜像被推送到哪里。我们通过使用 `docker tag` 命令对镜像进行标记来实现，如下所示：
- en: '![](../Images/CH03_UN04_Davis4.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_UN04_Davis4.png)'
- en: 'Of course, you can’t just type that command verbatim. You have to use the URL
    for your own registry! The `docker tag` command has the following general format:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不能直接输入该命令。您必须使用您自己的注册库的 URL！`docker tag` 命令具有以下通用格式：
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We set the name of an existing image to be tagged and then the new tag to apply
    to it. We are tagging in this case, only because we want to push to our registry.
    For this reason, we are including the registry’s URL in the tag we are applying.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了现有镜像的名称以进行标记，然后是应用于它的新的标记。在这种情况下，我们之所以进行标记，仅仅是因为我们想要将镜像推送到我们的注册库。因此，我们在应用的标记中包括了注册库的
    URL。
- en: We can check that our new tag was applied by invoking `docker image list`. Try
    doing that after applying the new tag. You should see a new entry in the table
    for the new tag. Note that Docker hasn’t created a new image; it has simply applied
    a new tag to the existing image. We can check that this is the case by inspecting
    the image’s unique ID, and we see that it is the same for both of the tagged versions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`docker image list`来检查我们的新标签是否已应用。在应用新标签后尝试这样做。您应该在表格的新标签部分看到一个新条目。请注意，Docker并没有创建一个新的图像；它只是给现有的图像添加了一个新的标签。我们可以通过检查图像的唯一ID来确认这一点，我们看到它对于标记的两个版本都是相同的。
- en: Pushing our image to the registry
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的图像推送到注册表
- en: 'Finally, we are ready to publish our image to the registry. To do that, we’ll
    invoke the `docker push` command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已准备好将我们的图像发布到注册表。为此，我们将调用`docker push`命令：
- en: '![](../Images/CH03_UN05_Davis4.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_UN05_Davis4.png)'
- en: 'Again, make sure that you use the URL of your own registry here; otherwise,
    this command won’t work for you. Here is the general format for `docker push`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，请确保在这里使用您自己的注册表的URL；否则，这个命令对您将不起作用。以下是`docker push`命令的一般格式：
- en: '[PRE16]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The part of the command after the `docker push` identifies the image to push.
    And it’s also that part that identifies the registry to push to.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker push`命令后面的命令部分用于标识要推送的图像。这也是标识要推送到的注册表的部分。'
- en: If you are thinking this is a bit awkward, then I’d agree with you. It seems
    to me, there should be a one-step process for pushing an existing image to a registry
    without having to go through the malarky of tagging it first. But there isn’t,
    and this is the way it’s done. After starting the image uploading, sit tight and
    wait for it to complete.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为这有点尴尬，那么我会同意您的看法。在我看来，应该有一个一步到位的过程来将现有图像推送到注册表，而不必先进行标记。但这并不是这样，这就是它的操作方式。在开始图像上传后，请耐心等待其完成。
- en: Checking that our image made it to the registry
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的图像是否已成功推送到注册表
- en: After we’ve pushed our image to the registry, we now want to check that it made
    it there OK. How do we know that it was successful? The first clue was in the
    output. It should have said that the push was successful, and we can trust that’s
    correct. But let’s go back to the registry in the Azure portal anyway and see
    what it looks like now.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将图像推送到注册表后，我们现在想检查它是否已成功到达。我们如何知道它是成功的？第一个线索在输出中。它应该会说推送是成功的，我们可以相信这是正确的。但无论如何，让我们回到Azure门户中的注册表，看看现在看起来如何。
- en: In the Azure portal, navigate to All Resources, find your registry, and click
    it. Click Repositories from the menu on the left. As you can see in figure 3.16,
    you should be able to see your video-streaming image in the list of repositories.
    If you look inside the repository (on the right of figure 3.16), you can see a
    list of versions here. There’s only a single version at the moment (tagged as
    *latest*), but in the future, after you have pushed updates to this image, you
    can return here and see the other versions that are listed as well.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure门户中，导航到所有资源，找到您的注册表，然后点击它。从左侧菜单中选择仓库。如图3.16所示，您应该能够在仓库列表中看到您的视频流图像。如果您查看仓库内部（如图3.16右侧所示），您会看到这里有一个版本列表。目前只有一个版本（标记为*latest*），但在将来，在您推送更新到这个图像之后，您可以返回这里并看到列出的其他版本。
- en: '![](../Images/CH03_F16_Davis4.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F16_Davis4.png)'
- en: Figure 3.16 Viewing the image pushed to the container registry via the Azure
    portal
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 通过Azure门户查看推送到容器注册表的图像
- en: You can drill down even further through the latest tag to see the details about
    the image, including a manifest of its files. I encourage you to explore this
    interface more to see what you can find out about the image you just published.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过最新的标签进一步深入查看图像的详细信息，包括其文件清单。我鼓励您更多地探索这个界面，看看您能发现关于您刚刚发布的图像的哪些信息。
- en: 3.9.3 Booting our microservice from the registry
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9.3 从注册表启动我们的微服务
- en: Congratulations, you just published your first image to your very own private
    registry. We could now deploy this image to our production environment, although
    we can’t do that because we haven’t yet built our Kubernetes cluster. We’ll build
    that in chapter 6\. But before then, we still have more work to do and more things
    to learn.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您，您刚刚成功将您的第一个图像发布到了您自己的私有注册表。我们现在可以将这个图像部署到我们的生产环境中，尽管我们无法这样做，因为我们还没有构建我们的Kubernetes集群。我们将在第6章中构建它。但在那之前，我们还有更多的工作要做，还有更多的事情要学习。
- en: Before moving on, we should confirm that our published image works. What I mean
    is that we should be able to instantiate the image as a container directly from
    the registry in the cloud. Just because we don’t have a production environment
    yet doesn’t mean we can’t simulate a deployment on our development workstation.
    This isn’t difficult, and it actually isn’t anything different to what we already
    learned in this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该确认我们的发布镜像是否正常工作。我的意思是，我们应该能够直接从云端的仓库实例化镜像作为容器。仅仅因为我们还没有生产环境并不意味着我们不能在我们的开发工作站上模拟部署。这并不困难，实际上这与我们在本章中学到的并没有什么不同。
- en: Running a container from an image is basically the same regardless of whether
    the image is one we built locally or one that is available in a remote registry.
    We’ll return to the `docker run` command to test our published image as shown
    in figure 3.17.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从镜像运行容器基本上是相同的，无论这个镜像是我们本地构建的还是远程仓库中可用的。我们将回到`docker run`命令来测试我们发布的镜像，如图3.17所示。
- en: '![](../Images/CH03_F17_Davis4.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17](../Images/CH03_F17_Davis4.png)'
- en: Figure 3.17 We can test our published image by running it on our development
    workstation; in this case, the `docker` `run` command must first pull the image
    from the registry.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 我们可以通过在我们的开发工作站上运行它来测试我们的发布镜像；在这种情况下，`docker run`命令必须首先从仓库拉取镜像。
- en: Cleaning up our mess
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 清理我们的混乱
- en: Before we can test our image from the registry, there’s one thing standing in
    our way. We must first remove the local versions of our image. We have to do this;
    otherwise, when we invoke `docker` `run`, it will boot the container from the
    local version of the image that we already have. This isn’t what we want!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够从仓库测试我们的镜像之前，有一件事阻碍了我们。我们必须首先删除我们镜像的本地版本。我们必须这样做；否则，当我们调用`docker run`时，它将从我们已有的本地镜像版本启动容器。这不是我们想要的！
- en: Instead, we want to test that we can *pull* the image from the remote registry.
    If we have a version of the image already cached locally it doesn’t need to pull
    the remote version. This is also a good excuse for us to learn how to remove local
    containers and images.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们想要测试我们是否可以从远程仓库中*拉取*镜像。如果我们已经有一个本地缓存的镜像版本，它就不需要拉取远程版本。这也是我们学习如何删除本地容器和镜像的好借口。
- en: Containers don’t go away by themselves. When we create containers for long-lived
    servers, the containers usually hang around! We need to shut them down when we
    are done so they don’t continue to consume our system resources.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 容器不会自行消失。当我们为长期运行的服务器创建容器时，容器通常会保留在那里！当我们完成时，我们需要关闭它们，以免它们继续消耗我们的系统资源。
- en: Note Before we can remove images, we must first remove any containers instantiated
    from them. Attempting to remove images that have running containers will result
    in an error.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在我们能够删除镜像之前，我们必须首先删除从它们实例化的任何容器。尝试删除有运行中容器的镜像将导致错误。
- en: 'We’ll invoke `docker` `ps` from our terminal. It’s like `docker` `container`
    `list`, but it shows *both* running and stopped containers. If you see your video-streaming
    microservice in the list of containers, that’s the one you want to remove. Take
    a note of its container ID. You’ll remember from earlier that the ID for my own
    container was 460a19946689\. Yours will be different, of course, so don’t expect
    to see that particular ID in your list of containers. I removed my container with
    the following commands:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在终端中调用`docker ps`。它就像`docker container list`，但它显示了*运行中*和*已停止*的容器。如果你在容器列表中看到了你的视频流微服务，那就是你想要删除的。记下它的容器ID。你可能会记得，我自己的容器ID是460a19946689。当然，你的将不同，所以不要期望在你的容器列表中看到那个特定的ID。我用以下命令删除了我的容器：
- en: '[PRE17]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Just remember to use the container ID for your container. Here’s the general
    format:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住使用你的容器ID。以下是一般格式：
- en: '[PRE18]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After removing the container, we can invoke `docker ps` again and check that
    the container is no longer in the list. After removing any container(s), we can
    now proceed with removing the image(s).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除容器后，我们可以再次调用`docker ps`并检查容器是否不再在列表中。在删除任何容器后，我们现在可以继续删除镜像。
- en: Invoke `docker image list`. We can see at least three images in the list. There
    are the Node.js base image and the two tagged versions of our video-streaming
    microservice. We only need to remove the image for our microservice. There’s no
    need to remove the Node.js base image because that doesn’t really matter for this
    test run.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`docker image list`。我们可以看到列表中至少有三个镜像。有Node.js的基础镜像和我们的视频流微服务的两个标记版本。我们只需要删除我们的微服务的镜像。没有必要删除Node.js的基础镜像，因为这对这次测试运行来说并不重要。
- en: 'Note that both tagged versions of our image have the same image ID, and these
    are actually just the same image referenced multiple times. We can remove both
    by invoking the `docker` `rmi` command with the `--force` argument as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的镜像的两个标记版本具有相同的镜像ID，实际上这只是多次引用的同一镜像。我们可以通过使用带有`--force`参数的`docker rmi`命令来删除这两个镜像：
- en: '[PRE19]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course, you need to run this with your particular image ID (which you can
    find from the output of `docker image list`). The general format is
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要用你特定的镜像ID（你可以从`docker image list`的输出中找到）来运行这个命令。一般格式是
- en: '[PRE20]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use `--force` here because, otherwise, we’d be stopped with an error message
    like `Image` `is` `referenced` `in` `multiple` `repositories`. That’s because
    we have multiple tagged versions of our image. We can use `--force` to make sure
    these are all removed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`--force`是因为，否则，我们会因为错误消息`Image is referenced in multiple repositories`而停止。这是因为我们有多个标记版本的我们的镜像。我们可以使用`--force`来确保这些都被删除。
- en: After removing the image, invoke `docker` `image` `list` again to check that
    this worked properly and that our image is no longer in the list. It’s OK to see
    the Node.js base image in the list because there’s no need to remove that for
    this test run.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 删除镜像后，再次调用`docker image list`以检查这是否正确执行，并且我们的镜像不再在列表中。看到列表中的Node.js基础镜像是可以的，因为在这个测试运行中不需要删除它。
- en: Running a container directly from the registry
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从注册库运行容器
- en: 'With local containers and images cleaned up, we can now instantiate a new container
    directly from the image in the remote registry. We’ll use `docker run` again like
    this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理了本地容器和镜像之后，我们现在可以直接从远程注册库中的镜像实例化一个新的容器。我们再次使用`docker run`，如下所示：
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As always, you must use the URL for your own registry. Here’s the general format:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你必须使用你自己的注册库的URL。这里是一般格式：
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This time when we invoke `docker run`, we use all the same arguments that we
    did back in section 3.8.3\. There’s `-d` for detached mode and `-p` to bind the
    port. The only thing we have changed here is the tag that we use to identify the
    image. In this case, the tag also identifies the remote registry from which to
    pull the image.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们调用`docker run`时，我们使用了与第3.8.3节中相同的所有参数。这里有`-d`用于分离模式，`-p`用于绑定端口。我们在这里唯一改变的是用来识别镜像的标记。在这种情况下，标记也标识了拉取镜像的远程注册库。
- en: When you invoke `docker run` in your terminal give it some time to download.
    It first has to pull your image. You probably already have the Node.js base image
    cached locally (unless you decided to remove it in the previous section), and
    in that case, it shouldn’t take long.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在终端中调用`docker run`时，给它一些时间下载。它首先必须拉取你的镜像。你可能已经本地缓存了Node.js基础镜像（除非你决定在上一个部分中删除它），在这种情况下，这不会花费很长时间。
- en: When this process has completed, you should have a running container. But this
    time, the image for it has been pulled *on-demand* from your private container
    registry in the cloud. When the `docker run` command has completed, you should
    see the container ID printed. We can also check that the container is running
    using the steps outlined earlier in section 3.8.3\. Or we can test it directly
    by pointing our web browser at http://localhost:3000/video to see the video.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个过程完成后，你应该有一个正在运行的容器。但这次，它的镜像已经从云中的私有容器注册库中按需拉取了。当`docker run`命令完成后，你应该看到打印出的容器ID。我们也可以使用第3.8.3节中概述的步骤来检查容器是否正在运行。或者，我们可以直接通过将我们的网络浏览器指向http://localhost:3000/video来测试它。
- en: 3.10 Docker review
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.10 Docker回顾
- en: Wow! What a trip. Docker seems simple until you try and explain it in a single
    chapter! What did we just do?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！真是一次旅行。Docker看起来很简单，直到你试图在单章中解释它！我们刚才做了什么？
- en: We created a Dockerfile for our microservice that instructs Docker how to build
    an image for it.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为我们的微服务创建了一个Dockerfile，它指导Docker如何构建它的镜像。
- en: We invoked `docker build` to package our microservice as an image.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用了`docker build`来将我们的微服务打包成镜像。
- en: After creating our private container registry on Azure, we then invoked `docker
    tag`, `docker login`, and `docker push` to publish our image.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们在 Azure 上创建我们的私有容器仓库之后，我们随后调用了 `docker tag`、`docker login` 和 `docker push`
    来发布我们的图像。
- en: We finished with a test run of our published image using `docker run`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `docker run` 完成了我们发布的图像的测试运行。
- en: The complete pipeline we pieced together is shown in figure 3.18\. Peruse this
    diagram with care and revel in what you have learned so far.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拼凑的完整管道如图 3.18 所示。仔细查看此图，并享受你迄今为止所学到的内容。
- en: '![](../Images/CH03_F18_Davis4.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F18_Davis4.png)'
- en: Figure 3.18 A complete Docker build pipeline showing where build, push, and
    run fit within the process.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 完整的 Docker 构建管道图，显示了构建、推送和运行在过程中的位置。
- en: Before moving on, let’s do a quick review of the commands we added to our toolbelt
    in this chapter. Table 3.3 shows these.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们快速回顾一下我们在本章中添加到工具包中的命令。表 3.3 显示了这些命令。
- en: Table 3.3 Review of Docker commands
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.3 Docker 命令概览
- en: '| Command | Description |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `docker --version` | Checks that Docker is installed and prints the version
    number |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `docker --version` | 检查 Docker 是否已安装并打印版本号 |'
- en: '| `docker container list` | Lists running containers |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `docker container list` | 列出正在运行的容器 |'
- en: '| `docker ps` | Lists all containers (running and stopped) |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `docker ps` | 列出所有容器（正在运行和已停止的）。 |'
- en: '| `docker image list` | Lists local images |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `docker image list` | 列出本地图像 |'
- en: '| `docker build -t <tag> --file`➥ `<docker-file``> .` | Builds an image from
    assets in the current directory according to the instructions in `docker-file`.
    The `-t` argument tags the image with a name you specify. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `docker build -t <tag> --file`➥ `<docker-file``> .` | 根据当前目录中 `docker-file`
    中的说明从资产构建图像。`-t` 参数使用你指定的名称标记图像。 |'
- en: '| `docker run -d -p <host-`➥ `port>:<container-port>`➥ `<tag>` | Instantiates
    a container from an image. If the image isn’t available locally, it can be pulled
    from a remote registry (assuming the tag specifies the URL of the registry).The
    `-d` argument runs the container in detached mode, so it won’t be bound to the
    terminal and you won’t see the output. Omit this argument to see output directly,
    but this also locks your terminal.The `-p` argument allows you to bind a port
    on the host to a port in the container. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `docker run -d -p <host-`➥ `port>:<container-port>`➥ `<tag>` | 从图像实例化一个容器。如果图像在本地不可用，可以从远程仓库拉取（假设标记指定了仓库的
    URL）。`-d` 参数以分离模式运行容器，因此它不会绑定到终端，你将看不到输出。省略此参数可以直接看到输出，但这也锁定你的终端。-`p` 参数允许你将主机上的端口绑定到容器中的端口。
    |'
- en: '| `docker logs <container-id>` | Retrieves output from a particular container.
    You need this to see the output when running a container in detached mode. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `docker logs <container-id>` | 从特定的容器检索输出。你需要这个输出，以便在分离模式下运行容器时查看输出。 |'
- en: '| `docker login <url>`➥ `--username <username>`➥ `--password <password>` |
    Authenticates with your private Docker registry so that you can run other commands
    against it. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `docker login <url>`➥ `--username <username>`➥ `--password <password>` |
    使用你的私有 Docker 仓库进行身份验证，以便你可以运行针对它的其他命令。 |'
- en: '| `docker tag <existing-tag>`➥ `<new-tag>` | Adds a new tag to an existing
    image. To push an image to your private container registry, you must first tag
    it with the URL of your registry. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `docker tag <existing-tag>`➥ `<new-tag>` | 向现有图像添加新标记。要将图像推送到你的私有容器仓库，你必须首先使用你的仓库的
    URL 标记它。 |'
- en: '| `docker push <tag>` | Pushes an appropriately tagged image to your private
    Docker registry. The image should be tagged with the URL of your registry. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `docker push <tag>` | 将适当标记的图像推送到你的私有 Docker 仓库。图像应该使用你的仓库的 URL 进行标记。 |'
- en: '| `docker kill <container-id>` | Stops a particular container locally. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `docker kill <container-id>` | 在本地停止特定的容器。 |'
- en: '| `docker rm <container-id>` | Removes a particular container locally (it must
    be stopped first). |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `docker rm <container-id>` | 在本地删除特定的容器（必须先停止）。 |'
- en: '| `docker rmi <image-id>`➥ `--force` | Removes a particular image locally (any
    containers must be removed first). The `--force` argument removes images even
    when they have been tagged multiple times. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `docker rmi <image-id>`➥ `--force` | 在本地删除特定的图像（必须先删除任何容器）。`--force` 参数即使图像被标记多次也会删除图像。
    |'
- en: 3.11 Continue your learning
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.11 继续学习
- en: 'This chapter moved quickly. The aim is to give you the minimum you need to
    bootstrap your application, but there’s so much more you could learn about Docker.
    Here are some references to other books that will help you go deeper into Docker:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本章进展迅速。目标是给你启动应用程序所需的最小内容，但还有更多关于 Docker 的内容可以学习。以下是一些其他书籍的参考，这些书籍将帮助你更深入地了解
    Docker：
- en: '*Learn Docker in a Month of Lunches* by Elton Stoneman (Manning, 2020)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《一个月午餐学会Docker》由Elton Stoneman著（Manning, 2020）
- en: '*Docker in Practice* by Aidan Hobson Sayers and Ian Miell (Manning, 2016)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《实践中的Docker》由Aidan Hobson Sayers和Ian Miell著（Manning, 2016）
- en: '*Docker in Action* by Jeff Nickoloff (Manning, 2016)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Docker实战》由Jeff Nickoloff著（Manning, 2016）
- en: Docker also has good online documentation. It’s worth having a browse at
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Docker也有良好的在线文档。值得浏览一下
- en: '[https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)'
- en: In this chapter, we explored how to use Docker to build and publish a single
    microservice. We’ll build on these skills in future chapters as we roll out more
    microservices and create our application. In the next chapter, we will scale up
    to multiple microservices, and we’ll learn how we can easily run multiple Docker-based
    microservices on our development workstation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用Docker构建和发布单个微服务。随着我们推出更多微服务并创建我们的应用程序，我们将在未来的章节中继续利用这些技能。在下一章中，我们将扩展到多个微服务，并学习如何在我们的开发工作站上轻松运行多个基于Docker的微服务。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned about Docker images and containers and how they relate to virtual
    machines.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了Docker镜像和容器以及它们与虚拟机的关系。
- en: You installed Docker into your development environment and checked the version
    number
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已将Docker安装到您的开发环境中并检查了版本号
- en: We created a Dockerfile and used the `docker build` command to package our microservice
    in a Docker image.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个Dockerfile，并使用`docker build`命令将我们的微服务打包到Docker镜像中。
- en: We instantiated our microservice in a Docker container using the `docker run`
    command.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`docker run`命令在Docker容器中实例化了我们的微服务。
- en: You created your own private Docker registry in the cloud.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在云中创建了自己的私有Docker注册库。
- en: You published your microservice to your Docker registry.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已将微服务发布到您的Docker注册库。
- en: You cleaned up all your local containers and images before instantiating your
    microservice from the published image in the registry using the `docker run` command.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用`docker run`命令从注册库中发布的镜像实例化微服务之前，您清理了所有本地容器和镜像。
