- en: Chapter 5\. Go’s type system
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章\. Go 的类型系统
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章*'
- en: Declaring new user-defined types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明新的用户定义类型
- en: Adding behavior to types with methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法向类型添加行为
- en: Knowing when to use pointers and values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解何时使用指针和值
- en: Implementing polymorphism with interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口实现多态
- en: Extending and changing types through composition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合扩展和更改类型
- en: Exporting and unexporting identifiers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出和非导出标识符
- en: Go is a statically typed programming language. What that means is the compiler
    always wants to know what the type is for every value in the program. When the
    compiler knows the type information ahead of time, it can help to make sure that
    the program is working with values in a safe way. This helps to reduce potential
    memory corruption and bugs, and provides the compiler the opportunity to produce
    more performant code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种静态类型编程语言。这意味着编译器总是想要知道程序中每个值的数据类型。当编译器提前知道类型信息时，它可以帮助确保程序以安全的方式处理值。这有助于减少潜在的内存损坏和错误，并为编译器提供了生成更高效代码的机会。
- en: 'A value’s type provides the compiler with two pieces of information: first,
    how much memory to allocate—the *size of the value*—and second, what that memory
    represents. In the case of many of the built-in types, size and representation
    are part of the type’s name. A value of type `int64` requires 8 bytes of memory
    (64 bits) and represents an integer value. A `float32` requires 4 bytes of memory
    (32 bits) and represents an IEEE-754 binary floating-point number. A `bool` requires
    1 byte of memory (8 bits) and represents a Boolean value of `true` or `false`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 值的类型为编译器提供两份数据：首先，分配多少内存——即值的*大小*——其次，该内存表示什么。对于许多内置类型，大小和表示是类型名称的一部分。`int64`
    类型的值需要 8 字节内存（64 位）并表示一个整数值。`float32` 需要占用 4 字节内存（32 位）并表示一个 IEEE-754 二进制浮点数。`bool`
    需要占用 1 字节内存（8 位）并表示布尔值 `true` 或 `false`。
- en: Some types get their representation based on the architecture of the machine
    the code is built for. A value of type `int`, for example, can either have a size
    of 8 bytes (64 bits) or 4 bytes (32 bits), depending on the architecture. There
    are other architecture-specific types as well, such as all the reference types
    in Go. Luckily, you don’t need to know this information to create or work with
    values. But if the compiler doesn’t know this information, it can’t protect you
    from doing things that could cause harm inside your programs and the machines
    they run on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型的表示是基于为代码构建的机器的架构。例如，`int` 类型的值可以是 8 字节（64 位）或 4 字节（32 位），这取决于架构。还有其他特定于架构的类型，例如
    Go 中的所有引用类型。幸运的是，你不需要知道这些信息来创建或使用值。但如果编译器不知道这些信息，它就无法保护你免受在程序及其运行的机器上可能造成损害的操作。
- en: 5.1\. User-defined types
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 用户定义类型
- en: Go allows you the ability to declare your own types. When you declare a new
    type, the declaration is constructed to provide the compiler with size and representation
    information, similar to how the built-in types work. There are two ways to declare
    a user-defined type in Go. The most common way is to use the keyword `struct`,
    which allows you to create a composite type.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你声明自己的类型。当你声明一个新类型时，声明被构造为向编译器提供大小和表示信息，类似于内置类型的工作方式。在 Go 中声明用户定义类型有两种方式。最常见的方式是使用关键字
    `struct`，这允许你创建一个复合类型。
- en: Struct types are declared by composing a fixed set of unique fields. Each field
    in a struct is declared with a known type, which could be a built-in type or another
    user-defined type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体类型是通过组合一组唯一的字段声明的。结构体中的每个字段都声明了一个已知类型，这可以是内置类型或另一个用户定义类型。
- en: Listing 5.1\. Declaration of a struct type
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 结构体类型的声明
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In [listing 5.1](#ch05ex01) you see the declaration of a struct type. The declaration
    starts with the keyword `type`, then a name for the new type, and finally the
    keyword `struct`. This struct type contains four fields, each based on a different
    built-in type. You can see how the fields come together to compose a structure
    of data. Once you have a type declared, you can create values from the type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.1](#ch05ex01) 中，你可以看到结构体类型的声明。声明从关键字 `type` 开始，然后是新类型的名称，最后是关键字 `struct`。这个结构体类型包含四个字段，每个字段基于不同的内置类型。你可以看到字段是如何组合在一起来构成数据结构的。一旦声明了类型，就可以从该类型创建值。
- en: Listing 5.2\. Declaration of a variable of the struct type set to its zero value
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 声明结构体类型的变量并设置为它的零值
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On line 10 in [listing 5.2](#ch05ex02), the keyword `var` creates a variable
    named `bill` of type `user`. When you declare variables, the value that the variable
    represents is always initialized. The value can be initialized with a specific
    value or it can be initialized to its zero value, which is the default value for
    that variable’s type. For numeric types, the zero value would be `0`; for strings
    it would be empty; and for Booleans it would be `false`. In the case of a struct,
    the zero value would apply to all the different fields in the struct.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.2](#ch05ex02) 的第 10 行，关键字 `var` 创建了一个名为 `bill` 的类型为 `user` 的变量。当你声明变量时，变量所代表的值总是被初始化。该值可以用特定的值初始化，也可以初始化为其零值，这是该变量类型的默认值。对于数值类型，零值将是
    `0`；对于字符串，它将是空字符串；对于布尔值，它将是 `false`。在结构的情况下，零值将适用于结构中的所有不同字段。
- en: Any time a variable is created and initialized to its zero value, it’s idiomatic
    to use the keyword `var`. Reserve the use of the keyword `var` as a way to indicate
    that a variable is being set to its zero value. If the variable will be initialized
    to something other than its zero value, then use the short variable declaration
    operator with a struct literal.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '任何时间创建并初始化为零值的变量时，使用关键字 `var` 是惯用的。保留关键字 `var` 的使用，以表示变量正在被设置为它的零值。如果变量将被初始化为非零值，则使用带有结构字面量的短变量声明运算符。 '
- en: Listing 5.3\. Declaration of a variable of the struct type using a struct literal
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 使用结构字面量声明结构类型变量的声明
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Listing 5.3](#ch05ex03) shows how to declare a variable of type `user` and
    initialize the value to something other than its zero value. On line 13, we provide
    a variable name followed by the short variable declaration operator. This operator
    is the colon with the equals sign (`:=`). The short variable declaration operator
    serves two purposes in one operation: it both declares and initializes a variable.
    Based on the type information on the right side of the operator, the short variable
    declaration operator can determine the type for the variable.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.3](#ch05ex03) 展示了如何声明一个类型为 `user` 的变量，并将其值初始化为非零值。在第 13 行，我们提供了一个变量名，后面跟着短变量声明运算符。这个运算符是带有等号的冒号（`:=`）。短变量声明运算符在一个操作中完成两个目的：它既声明又初始化一个变量。根据运算符右侧的类型信息，短变量声明运算符可以确定变量的类型。'
- en: Since we’re creating and initializing a struct type, we use a struct literal
    to perform the initialization. The struct literal takes the form of curly brackets
    with the initialization declared within them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建和初始化结构类型，我们使用结构字面量来执行初始化。结构字面量的形式是带有初始化声明在其内的花括号。
- en: Listing 5.4\. Creating a struct type value using a struct literal
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 使用结构字面量创建结构类型值
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The struct literal can take on two forms for a struct type. [Listing 5.4](#ch05ex04)
    shows the first form, which is to declare each field and value from the struct
    to be initialized on a separate line. A colon is used to separate the two, and
    it requires a trailing comma. The order of the fields doesn’t matter. The second
    form is without the field names and just declares the values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 结构字面量对于结构类型可以采用两种形式。[列表 5.4](#ch05ex04) 展示了第一种形式，即在每个单独的行上声明结构要初始化的字段和值。使用冒号来分隔两者，并且需要一个尾随逗号。字段的顺序不重要。第二种形式没有字段名，只是声明值。
- en: Listing 5.5\. Creating a struct type value without declaring the field names
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 不声明字段名创建结构类型值
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The values can also be placed on separate lines, but traditionally values are
    placed on the same line with no trailing comma when using this form. The order
    of the values does matter in this case and needs to match the order of the fields
    in the struct declaration. When declaring a struct type, you’re not limited to
    just the built-in types. You can also declare fields using other user-defined
    types.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值也可以放在单独的行上，但传统上，使用这种形式时，值通常放在同一行上，且后面没有逗号。在这种情况下，值的顺序很重要，需要与结构声明中字段的顺序相匹配。在声明结构类型时，你不仅限于使用内置类型。你还可以使用其他用户定义的类型来声明字段。
- en: Listing 5.6\. Declaring fields based on other struct types
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 基于其他结构类型声明字段
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Listing 5.6](#ch05ex06) shows a new struct type named `admin`. This struct
    type has a field named `person` of type `user`, and then declares a second field
    named `level` of type `string`. When creating a variable of a struct type that
    has a field like `person`, initializing the type with a struct literal changes
    a little.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.6](#ch05ex06) 展示了一个名为 `admin` 的新结构体类型。这个结构体类型有一个名为 `person` 的字段，其类型为
    `user`，然后声明了一个名为 `level` 的第二个字段，其类型为 `string`。当创建具有类似 `person` 字段的结构体类型的变量时，使用结构体字面量初始化类型会有所不同。'
- en: Listing 5.7\. Using struct literals to create values for fields
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 使用结构体字面量创建字段值
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to initialize the `person` field, we need to create a value of type
    `user`. This is exactly what we do on line 28 in [listing 5.7](#ch05ex07). Using
    the struct literal form, a value of type `user` is created and assigned to the
    `person` field.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化 `person` 字段，我们需要创建一个 `user` 类型的值。这正是我们在 [listing 5.7](#ch05ex07) 的第 28
    行所做的事情。使用结构体字面量形式，创建了一个 `user` 类型的值并将其赋给 `person` 字段。
- en: A second way to declare a user-defined type is by taking an existing type and
    using it as the type specification for the new type. These types are great when
    you need a new type that can be represented by an existing type. The standard
    library uses this type declaration to create high-level functionality from the
    built-in types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 声明用户定义类型的第二种方式是使用现有类型并将其用作新类型的类型规范。当你需要一个可以由现有类型表示的新类型时，这些类型非常出色。标准库使用这种类型声明从内置类型创建高级功能。
- en: Listing 5.8\. Declaration of a new type based on an `int64`
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8\. 基于 `int64` 声明的新类型
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Listing 5.8](#ch05ex08) shows the declaration of a type from the `time` package
    of the standard library. `Duration` is a type that represents the duration of
    time down to the nano-second. The type takes its representation from the built-in
    type `int64`. In the declaration of `Duration`, we say that `int64` is the base
    type of `Duration`. Even though `int64` is acting at the base type, it doesn’t
    mean Go considered them to be the same. `Duration` and `int64` are two distinct
    and different types.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.8](#ch05ex08) 展示了从标准库的 `time` 包中声明的一个类型。`Duration` 是一个表示时间持续到纳秒级别的类型。该类型从内置类型
    `int64` 获取其表示形式。在 `Duration` 的声明中，我们说 `int64` 是 `Duration` 的基本类型。尽管 `int64` 作为基本类型，但这并不意味着
    Go 将它们视为相同。`Duration` 和 `int64` 是两个不同且不同的类型。'
- en: To better clarify what this means, look at this small program that doesn’t compile.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地阐明这意味着什么，请看这个无法编译的小程序。
- en: Listing 5.9\. Compiler error assigning value of different types
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. 分配不同类型值的编译器错误
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The program in [listing 5.9](#ch05ex09) declares a type on line 03 called `Duration`.
    Then on line 06, a variable named `dur` of type `Duration` is declared and set
    to its zero value. Then on line 07, we write code that produces the following
    compiler error when the program is built.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [listing 5.9](#ch05ex09) 中的程序在第 03 行声明了一个名为 `Duration` 的类型。然后在第 06 行，声明了一个名为
    `dur` 的 `Duration` 类型的变量并将其设置为它的零值。然后在第 07 行，我们编写了当程序构建时会产生以下编译器错误的代码。
- en: Listing 5.10\. Actual compiler error
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 实际编译器错误
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The compiler is clear as to what the problem is. Values of type `int64` can’t
    be used as values of type `Duration`. In other words, even though type `int64`
    is the base type for `Duration`, `Duration` is still its own unique type. Values
    of two different types can’t be assigned to each other, even if they’re compatible.
    The compiler doesn’t implicitly convert values of different types.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器清楚地说明了问题所在。`int64` 类型的值不能用作 `Duration` 类型的值。换句话说，尽管 `int64` 类型是 `Duration`
    的基本类型，但 `Duration` 仍然是它自己的独特类型。不同类型的值不能相互赋值，即使它们是兼容的。编译器不会隐式转换不同类型的值。
- en: 5.2\. Methods
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 方法
- en: Methods provide a way to add behavior to user-defined types. Methods are really
    functions that contain an extra parameter that’s declared between the keyword
    `func` and the function name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方法提供了一种向用户定义类型添加行为的方式。方法实际上是包含一个额外参数的函数，该参数在关键字 `func` 和函数名之间声明。
- en: Listing 5.11\. listing11.go
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. listing11.go
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lines 16 and 23 of [listing 5.11](#ch05ex11) show two different methods. The
    parameter between the keyword `func` and the function name is called a *receiver*
    and binds the function to the specified type. When a function has a receiver,
    that function is called a *method*. When you run the program, you get the following
    output.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[listing 5.11](#ch05ex11) 的第 16 行和第 23 行展示了两种不同的方法。关键字 `func` 和函数名之间的参数被称为
    *接收者*，它将函数绑定到指定的类型。当一个函数有接收者时，该函数被称为 *方法*。当你运行程序时，你会得到以下输出。'
- en: Listing 5.12\. Output for listing11.go
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12\. 列表 11.go 的输出
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s examine what the program is doing. On line 10, the program declares a
    struct type named `user` and then declares a method named `notify`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看程序在做什么。在第 10 行，程序声明了一个名为 `user` 的结构体类型，然后声明了一个名为 `notify` 的方法。
- en: 'Listing 5.13\. listing11.go: lines 09–20'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.13\. listing11.go: 行 09–20'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are two types of receivers in Go: *value* receivers and *pointer* receivers.
    In [listing 5.13](#ch05ex13) on line 16, the `notify` method is declared with
    a value receiver.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中有两种接收者类型：*值* 接收者和 *指针* 接收者。在 [列表 5.13](#ch05ex13) 的第 16 行，`notify` 方法声明了一个值接收者。
- en: Listing 5.14\. Declaration of a method with a value receiver
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. 声明具有值接收者的方法
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The receiver for `notify` is declared as a value of type `user`. When you declare
    a method using a value receiver, the method will always be operating against a
    copy of the value used to make the method call. Let’s skip to line 32 of the program
    in [listing 5.11](#ch05ex11) to see a method call on `notify`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify` 的接收者被声明为 `user` 类型的值。当你使用值接收者声明一个方法时，该方法将始终针对用于创建方法调用的值的副本进行操作。让我们跳到程序
    [列表 5.11](#ch05ex11) 的第 32 行，看看对 `notify` 的方法调用。'
- en: 'Listing 5.15\. listing11.go: lines 29–32'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.15\. listing11.go: 行 29–32'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Listing 5.15](#ch05ex15) shows a call to the `notify` method using a value
    of type `user`. On line 31, a variable named `bill` of type `user` is declared
    and initialized with a name and email address. Then on line 32, the `notify` method
    is called using the variable `bill`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.15](#ch05ex15) 展示了使用 `user` 类型的值调用 `notify` 方法。在第 31 行，声明了一个名为 `bill`
    的 `user` 类型变量，并用一个名字和电子邮件地址进行初始化。然后在第 32 行，使用变量 `bill` 调用了 `notify` 方法。'
- en: Listing 5.16\. Calling a method from a variable
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.16\. 从变量调用方法
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The syntax looks similar to when you call a function from a package. In this
    case however, `bill` is not a package name but a variable name. When we call the
    `notify` method in this case, the value of `bill` is the receiver value for the
    call and the `notify` method is operating on a copy of this value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 语法看起来与从包中调用函数时的语法相似。然而，在这种情况下，`bill` 不是一个包名，而是一个变量名。当我们在这种情况下调用 `notify` 方法时，`bill`
    的值是调用时的接收者值，而 `notify` 方法是在这个值的副本上操作的。
- en: You can also call methods that are declared with a value receiver using a pointer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用指针调用声明为值接收者的方法。
- en: 'Listing 5.17\. listing11.go: lines 34–37'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.17\. listing11.go: 行 34–37'
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Listing 5.17](#ch05ex17) shows a call to the `notify` method using a pointer
    of type `user`. On line 36, a variable named `lisa` of pointer type `user` is
    declared and initialized with a name and email address. Then on line 37, the `notify`
    method is called using the pointer variable. To support the method call, Go adjusts
    the pointer value to comply with the method’s receiver. You can imagine that Go
    is performing the following operation.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.17](#ch05ex17) 展示了使用 `user` 类型的指针调用 `notify` 方法。在第 36 行，声明了一个名为 `lisa`
    的指针类型 `user` 变量，并用一个名字和电子邮件地址进行初始化。然后在第 37 行，使用指针变量调用了 `notify` 方法。为了支持方法调用，Go
    调整指针值以符合方法的接收者。你可以想象 Go 正在执行以下操作。'
- en: Listing 5.18\. What Go is doing underneath the code
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.18\. Go 在代码之下所做的工作
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Listing 5.18](#ch05ex18) shows essentially what the Go compiler is doing to
    support the method call. The pointer value is dereferenced so the method call
    is in compliance with the value receiver. Once again, `notify` is operating against
    a copy, but this time a copy of the value that the `lisa` pointer points to.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.18](#ch05ex18) 展示了 Go 编译器为了支持方法调用所做的基本工作。指针值被解引用，使得方法调用符合值接收者的要求。再次强调，`notify`
    是在副本上操作的，但这次是 `lisa` 指针所指向的值的副本。'
- en: You can also declare methods with pointer receivers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明具有指针接收者的方法。
- en: 'Listing 5.19\. listing11.go: lines 22–25'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.19\. listing11.go: 行 22–25'
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Listing 5.19](#ch05ex19) shows the declaration of the `changeEmail` method,
    which is declared with a pointer receiver. This time, the receiver is not a value
    of type `user` but a pointer of type `user`. When you call a method declared with
    a pointer receiver, the value used to make the call is shared with the method.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.19](#ch05ex19) 展示了 `changeEmail` 方法的声明，该方法使用指针接收者。这次，接收者不是一个 `user` 类型的值，而是一个
    `user` 类型的指针。当你调用声明为指针接收者的方法时，用于调用的值与方法共享。'
- en: 'Listing 5.20\. listing11.go: lines 36, 44–46'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.20\. listing11.go: 行 36, 44–46'
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In [listing 5.20](#ch05ex20) you see the declaration of the `lisa` pointer variable
    followed by the method call to `changeEmail` on line 46\. Once the call to `changeEmail`
    returns, any changes to the value that the `lisa` pointer points to will be reflected
    after the call. This is thanks to the pointer receiver. Value receivers operate
    on a copy of the value used to make the method call and pointer receivers operate
    on the actual value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.20](#ch05ex20) 中，您可以看到 `lisa` 指针变量的声明，随后是第 46 行对 `changeEmail` 方法的调用。一旦
    `changeEmail` 的调用返回，对 `lisa` 指针所指向的值的任何更改将在调用之后反映出来。这要归功于指针接收者。值接收者操作的是用于进行方法调用的值的副本，而指针接收者操作的是实际值。
- en: You can also call methods that are declared with a pointer receiver using a
    value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用值调用声明为指针接收者的方法。
- en: 'Listing 5.21\. listing11.go: line 31'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.21\. listing11.go: 第 31 行'
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In [listing 5.21](#ch05ex21), you see the declaration of the variable `bill`
    and then a call to the `changeEmail` method, which is declared with a pointer
    receiver. Once again, Go adjusts the value to comply with the method’s receiver
    to support the call.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.21](#ch05ex21) 中，您可以看到变量 `bill` 的声明，然后是对具有指针接收者的 `changeEmail` 方法的调用。同样，Go
    调整了值以符合方法接收者，以支持调用。
- en: Listing 5.22\. What Go is doing underneath the code
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.22\. Go 在代码底下的操作
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Listing 5.22](#ch05ex22) shows essentially what the Go compiler is doing to
    support the method call. In this case, the value is referenced so the method call
    is in compliance with the receiver type. This is a great convenience Go provides,
    allowing method calls with values and pointers that don’t match a method’s receiver
    type natively.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.22](#ch05ex22) 展示了 Go 编译器为了支持方法调用所做的基本操作。在这种情况下，值被引用，因此方法调用符合接收者类型。这是
    Go 提供的一个极大的便利，允许使用与方法接收者类型不匹配的值和指针进行方法调用。'
- en: Determining whether to use a value or pointer receiver can sometimes be confusing.
    There are some basic guidelines you can follow that come directly from the standard
    library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确定是否使用值或指针接收者有时可能会令人困惑。您可以遵循一些基本准则，这些准则直接来自标准库。
- en: 5.3\. The nature of types
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 类型本质
- en: After declaring a new type, try to answer this question before declaring methods
    for the type. Does adding or removing something from a value of this type need
    to create a new value or mutate the existing one? If the answer is create a new
    value, then use value receivers for your methods. If the answer is mutate the
    value, then use pointer receivers. This also applies to how values of this type
    should be passed to other parts of your program. It’s important to be consistent.
    The idea is to not focus on what the method is doing with the value, but to focus
    on what the nature of the value is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在为类型声明方法之前，尝试回答这个问题。从这种类型的值中添加或删除某些内容是否需要创建一个新的值或修改现有值？如果答案是创建新值，那么为您的函数使用值接收者。如果答案是修改值，那么使用指针接收者。这也适用于如何将此类型的值传递到程序的其它部分。保持一致性很重要。这个想法是不要关注方法对值做了什么，而要关注值的本质。
- en: 5.3.1\. Built-in types
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. 内置类型
- en: Built-in types are the set of types that are provided by the language. We know
    them as the set of numeric, string, and Boolean types. These types have a primitive
    nature to them. Because of this, when adding or removing something from a value
    of one of these types, a new value should be created. Based on this, when passing
    values of these types to functions and methods, a copy of the value should be
    passed. Let’s look at a function from the standard library that works with built-in
    values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 内置类型是语言提供的一组类型。我们将其称为数值、字符串和布尔类型的集合。这些类型具有原始性质。正因为如此，当从这些类型之一的值中添加或删除某些内容时，应该创建一个新的值。基于这一点，当将这些类型的值传递给函数和方法时，应该传递值的副本。让我们看看标准库中的一个处理内置值的函数。
- en: 'Listing 5.23\. golang.org/src/strings/strings.go: lines 620–625'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.23\. golang.org/src/strings/strings.go: 第 620–625 行'
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In [listing 5.23](#ch05ex23), you see the `Trim` function, which comes from
    the `strings` package in the standard library. The `Trim` function is passed a
    string value to operate on and a string value with characters to find. It then
    returns a new string value that’s the result of the operation. The function operates
    on copies of the caller’s original string values and returns a copy of the new
    string value. Strings, just like integers, floats, and Booleans, are primitive
    data values and should be copied when passed in and out of functions or methods.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 5.23](#ch05ex23)中，你看到了来自标准库中`strings`包的`Trim`函数。`Trim`函数接收一个要操作的字符串值和一个要查找的字符字符串值。然后它返回一个新的字符串值，这是操作的结果。该函数在调用者的原始字符串值的副本上操作，并返回新字符串值的副本。字符串，就像整数、浮点数和布尔值一样，是原始数据值，应该在传入和传出函数或方法时进行复制。
- en: Let’s look at a second example of how the built-in types are treated as having
    a primitive nature.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看内置类型被视为具有原始性质的第二个例子。
- en: 'Listing 5.24\. golang.org/src/os/env.go: lines 38–44'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.24\. golang.org/src/os/env.go: 行 38–44'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Listing 5.24](#ch05ex24) shows the `isShellSpecialVar` function from the `env`
    package. This function is passed a value of type `uint8` and returns a value of
    type `bool`. Note how pointers aren’t being used to share the value for the parameter
    or return value. The caller passes a copy of their `uint8` value and receives
    a value of `true` or `false`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.24](#ch05ex24)展示了来自`env`包的`isShellSpecialVar`函数。这个函数接收一个类型为`uint8`的值，并返回一个类型为`bool`的值。注意，没有使用指针来共享参数或返回值的值。调用者传递了他们的`uint8`值的副本，并接收了`true`或`false`的值。'
- en: 5.3.2\. Reference types
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 引用类型
- en: Reference types in Go are the set of slice, map, channel, interface, and function
    types. When you declare a variable from one of these types, the value that’s created
    is called a *header* value. Technically, a string is also a reference type value.
    All the different header values from the different reference types contain a pointer
    to an underlying data structure. Each reference type also contains a set of unique
    fields that are used to manage the underlying data structure. You never share
    reference type values because the header value is designed to be copied. The header
    value contains a pointer; therefore, you can pass a copy of any reference type
    value and share the underlying data structure intrinsically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的引用类型包括切片、映射、通道、接口和函数类型。当你从这些类型中声明一个变量时，创建的值被称为*头值*。技术上，字符串也是一种引用类型值。所有不同引用类型的不同头值都包含一个指向底层数据结构的指针。每个引用类型还包含一组用于管理底层数据结构的唯一字段。你永远不会共享引用类型值，因为头值被设计为可复制的。头值包含一个指针；因此，你可以传递任何引用类型值的副本，并内在地共享底层数据结构。
- en: Let’s look at a type from the `net` package.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`net`包中的一个类型。
- en: 'Listing 5.25\. golang.org/src/net/ip.go: line 32'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.25\. golang.org/src/net/ip.go: 行 32'
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Listing 5.25](#ch05ex25) shows a type called `IP` which is declared as a slice
    of bytes. Declaring a type like this is useful when you want to declare behavior
    around a built-in or reference type. The compiler will only let you declare methods
    for user-defined types that are named.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.25](#ch05ex25)展示了名为`IP`的类型，它被声明为一个字节数组切片。当你想要声明围绕内置或引用类型的行为时，声明此类类型是有用的。编译器只允许你为命名用户定义类型声明方法。'
- en: 'Listing 5.26\. golang.org/src/net/ip.go: lines 329–337'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.26\. golang.org/src/net/ip.go: 行 329–337'
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `MarshalText` method in [listing 5.26](#ch05ex26) has been declared using
    a value receiver of type `IP`. A value receiver is exactly what you expect to
    see since you don’t share reference type values. This also applies to passing
    reference type values as parameters to functions and methods.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.26](#ch05ex26)中的`MarshalText`方法使用类型为`IP`的值接收器声明。正如你所期望的，这是一个值接收器，因为你不会共享引用类型值。这也适用于将引用类型值作为参数传递给函数和方法。'
- en: 'Listing 5.27\. golang.org/src/net/ip.go: lines 318–325'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.27\. golang.org/src/net/ip.go: 行 318–325'
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In [listing 5.27](#ch05ex27) you see the `ipEmptyString` function. This function
    is passed a value of the type `IP`. Once again, you can see how the caller’s reference
    type value for this parameter is not shared with the function. The function is
    passed a copy of the caller’s reference type value. This also applies to return
    values. In the end, reference type values are treated like primitive data values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 5.27](#ch05ex27)中，你看到了`ipEmptyString`函数。这个函数接收一个类型为`IP`的值。再次，你可以看到调用者为此参数的引用类型值没有与函数共享。函数传递了调用者的引用类型值的副本。这也适用于返回值。最终，引用类型值被处理得像原始数据值一样。
- en: 5.3.3\. Struct types
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3\. 结构类型
- en: Struct types can represent data values that could have either a primitive or
    nonprimitive nature. When the decision is made that a struct type value should
    not be mutated when something needs to be added or removed from the value, then
    it should follow the guidelines for the built-in and reference types. Let’s start
    with looking at a struct implemented by the standard library that has a primitive
    nature.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型可以表示可能具有原始或非原始性质的数据值。当决定结构类型值在需要向值中添加或从值中删除某些内容时不应被修改时，它应遵循内置和引用类型的指南。让我们先看看标准库实现的一个具有原始性质的结构类型。
- en: 'Listing 5.28\. golang.org/src/time/time.go: lines 39–55'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.28\. golang.org/src/time/time.go: 行 39–55'
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Time` struct in [listing 5.28](#ch05ex28) comes from the `time` package.
    When you think about time, you realize that any given point in time is not something
    that can change. This is exactly how the standard library implements the `Time`
    type. Let’s look at the `Now` function that creates values of type `Time`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.28](#ch05ex28) 中的 `Time` 结构来自 `time` 包。当你想到时间时，你会意识到任何给定的时间点都不是可以改变的东西。这正是标准库实现
    `Time` 类型的样子。让我们看看创建 `Time` 类型值的 `Now` 函数。'
- en: 'Listing 5.29\. golang.org/src/time/time.go: lines 781–784'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.29\. golang.org/src/time/time.go: 行 781–784'
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code in [listing 5.29](#ch05ex29) shows the implementation of the `Now`
    function. This function creates a value of type `Time` and returns a copy of that
    `Time` value back to the caller. A pointer is not used to share the `Time` value
    created by the function. Next, let’s look at a method declared against the `Time`
    type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.29](#ch05ex29) 中的代码显示了 `Now` 函数的实现。此函数创建一个 `Time` 类型的值，并将该 `Time` 值的副本返回给调用者。没有使用指针来共享函数创建的
    `Time` 值。接下来，让我们看看针对 `Time` 类型声明的某个方法。'
- en: 'Listing 5.30\. golang.org/src/time/time.go: lines 610–622'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.30\. golang.org/src/time/time.go: 行 610–622'
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method `Add` in [listing 5.30](#ch05ex30) is a great example of how the
    standard library treats the `Time` type as having a primitive nature. The method
    is declared using a value receiver and returns a new `Time` value. The method
    is operating on its own copy of the caller’s `Time` value and returns a copy of
    its local `Time` value back to the caller. It’s up to the caller whether they
    want to replace their `Time` value with what’s returned or declare a new `Time`
    variable to hold the result.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.30](#ch05ex30) 中的 `Add` 方法是标准库如何将 `Time` 类型视为具有原始性质的一个很好的例子。该方法使用值接收者声明，并返回一个新的
    `Time` 值。该方法在其自己的副本上操作调用者的 `Time` 值，并将其本地 `Time` 值的副本返回给调用者。调用者决定是否用返回的值替换他们的
    `Time` 值，或者声明一个新的 `Time` 变量来保存结果。'
- en: In most cases, struct types don’t exhibit a primitive nature, but a nonprimitive
    one. In these cases, adding or removing something from the value of the type should
    mutate the value. When this is the case, you want to use a pointer to share the
    value with the rest of the program that needs it. Let’s take a look at a struct
    type implemented by the standard library that has a nonprimitive nature.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，结构类型不表现出原始性质，而是非原始性质。在这些情况下，向类型值中添加或从值中删除某些内容应该会改变值。当这种情况发生时，你想要使用指针与需要它的程序的其他部分共享值。让我们看看标准库实现的一个具有非原始性质的结构类型。
- en: 'Listing 5.31\. golang.org/src/os/file_unix.go: lines 15–29'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.31\. golang.org/src/os/file_unix.go: 行 15–29'
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In [listing 5.31](#ch05ex31) you see the declaration of the `File` type from
    the standard library. The nature of this type is nonprimitive. Values of this
    type are actually unsafe to be copied. The comments for the unexported type make
    this clear. Since there’s no way to prevent programmers from making copies, the
    implementation of the `File` type uses an embedded pointer of an unexported type.
    We’ll talk about embedding types later in this chapter, but this extra level of
    indirection provides protection from copies. Not every struct type requires or
    should be implemented with this extra protection. Programmers should respect the
    nature of each type and use it accordingly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.31](#ch05ex31) 中，你可以看到标准库中 `File` 类型的声明。这种类型的性质是非原始的。这种类型的值实际上是不安全的进行复制的。未导出类型的注释清楚地说明了这一点。由于无法阻止程序员进行复制，`File`
    类型的实现使用了一个未导出类型的嵌入指针。我们将在本章后面讨论嵌入类型，但这一额外的间接层提供了对复制的保护。并非每个结构类型都需要或应该使用这种额外的保护来实现。程序员应该尊重每种类型的性质，并相应地使用它。
- en: Let’s look at the implementation of the `Open` function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Open` 函数的实现。
- en: 'Listing 5.32\. golang.org/src/os/file.go: lines 238–240'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.32\. golang.org/src/os/file.go: 行 238–240'
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The implementation of the `Open` function in [listing 5.32](#ch05ex32) shows
    how a pointer is used to share `File` type values with the caller of the function.
    `Open` creates a value of type `File` and returns a pointer to that value. When
    a factory function returns a pointer, it’s a good indication that the nature of
    the value being returned is nonprimitive.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.32](#ch05ex32) 中 `Open` 函数的实现展示了如何使用指针来与函数的调用者共享 `File` 类型的值。`Open`
    创建了一个 `File` 类型的值并返回对该值的指针。当工厂函数返回一个指针时，这是一个很好的迹象，表明返回值的本质是非原始的。
- en: Even if a function or method is never going to directly change the state of
    a nonprimitive value, it should still be shared.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个函数或方法永远不会直接改变非原始值的状体，它仍然应该被共享。
- en: 'Listing 5.33\. golang.org/src/os/file.go: lines 224–232'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.33\. golang.org/src/os/file.go: 行 224–232'
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `Chdir` method in [listing 5.33](#ch05ex33) shows how a pointer receiver
    is declared even though no changes are made to the receiver value. Since values
    of type `File` have a nonprimitive nature, they’re always shared and never copied.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.33](#ch05ex33) 中的 `Chdir` 方法展示了即使在接收器值上没有进行任何修改，也声明了指针接收器。由于 `File`
    类型的值具有非原始的本质，它们总是被共享，而不是被复制。
- en: The decision to use a value or pointer receiver should not be based on whether
    the method is mutating the receiving value. The decision should be based on the
    nature of the type. One exception to this guideline is when you need the flexibility
    that value type receivers provide when working with interface values. In these
    cases, you may choose to use a value receiver even though the nature of the type
    is nonprimitive. It’s entirely based on the mechanics behind how interface values
    call methods for the values stored inside of them. In the next section, you’ll
    learn about what interface values are and the mechanics behind using them to call
    methods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用值接收器或指针接收器的决定不应基于方法是否正在修改接收的值。这个决定应该基于类型的本质。这个指导原则的一个例外是当你需要值类型接收器在处理接口值时提供的灵活性。在这些情况下，即使类型的本质是非原始的，你也可以选择使用值接收器。这完全基于接口值调用存储在其内部的值的方法的机制。在下一节中，你将了解接口值是什么以及如何使用它们调用方法的机制。
- en: 5.4\. Interfaces
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 接口
- en: Polymorphism is the ability to write code that can take on different behavior
    through the implementation of types. Once a type implements an interface, an entire
    world of functionality can be opened up to values of that type. The standard library
    is a great example of this. The `io` package provides an incredible set of interfaces
    and functions that make streaming data easy to apply to our code. Just by implementing
    two interfaces, we can take advantage of all the engineering behind the `io` package.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是能够通过类型的实现来展现不同行为的代码能力。一旦一个类型实现了接口，就可以为该类型的值打开一个全新的功能世界。标准库是一个很好的例子。`io`
    包提供了一套令人难以置信的接口和函数，使得将数据流应用到我们的代码中变得容易。只需实现两个接口，我们就可以利用 `io` 包背后的所有工程。
- en: But a lot of details go into declaring and implementing interfaces for use in
    our own programs. Even the implementation of existing interfaces requires an understanding
    of how interfaces work. Before we get into the details of how interfaces work
    and how to implement them, let’s look at a quick example of the use of interfaces
    from the standard library.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在声明和实现接口以供我们自己的程序使用时，有很多细节需要考虑。即使是现有接口的实现也需要理解接口是如何工作的。在我们深入了解接口的工作原理和实现方法之前，让我们快速看一下标准库中接口使用的一个例子。
- en: 5.4.1\. Standard library
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 标准库
- en: Let’s start by looking at a sample program that implements a version of a popular
    program named curl.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一个实现了一个名为 curl 的流行程序版本的示例程序开始。
- en: Listing 5.34\. listing34.go
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.34\. listing34.go
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Listing 5.34](#ch05ex34) shows the power of interfaces and their use in the
    standard library. In a few lines of code, we have a curl program by leveraging
    two functions that work with interface values. On line 23, we call the `Get` function
    from the `http` package. The `http.Get` function returns a pointer of type `http.Request`
    after it successfully communicates with the server. The `http.Request` type contains
    a field named `Body`, which is an interface value of type `io.ReadCloser`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.34](#ch05ex34) 展示了接口及其在标准库中的使用的力量。在几行代码中，我们通过利用两个与接口值一起工作的函数，创建了一个 curl
    程序。在第 23 行，我们调用 `http` 包中的 `Get` 函数。`http.Get` 函数在成功与服务器通信后返回一个 `http.Request`
    类型的指针。`http.Request` 类型包含一个名为 `Body` 的字段，它是一个类型为 `io.ReadCloser` 的接口值。'
- en: On line 30, the `Body` field is passed into the `io.Copy` function as the second
    parameter. The `io.Copy` function accepts values of interface type `io.Reader`
    for its second parameter, and this value represents a source of data to stream
    from. Luckily, the `Body` field implements the `io.Reader` interface, so we can
    pass the `Body` field into `io.Copy` and use a web server as our source.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 30 行，将 `Body` 字段作为第二个参数传递给 `io.Copy` 函数。`io.Copy` 函数接受接口类型 `io.Reader` 的值作为其第二个参数，这个值代表数据流出的源。幸运的是，`Body`
    字段实现了 `io.Reader` 接口，因此我们可以将 `Body` 字段传递给 `io.Copy` 并使用网络服务器作为我们的源。
- en: The first parameter for `io.Copy` represents the destination and must be a value
    that implements the `io.Writer` interface. For our destination, we pass a special
    interface value from the `os` package called `Stdout`. This interface value represents
    the standard out device and already implements the `io.Writer` interface. When
    we pass the `Body` and `Stdout` values to the `io.Copy` function, the function
    streams data from the web server to the terminal window in small chunks. Once
    the last chunk is read and written, the `io.Copy` function returns.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Copy` 的第一个参数代表目的地，必须是一个实现了 `io.Writer` 接口的值。对于我们的目的地，我们传递了来自 `os` 包的一个特殊接口值，称为
    `Stdout`。这个接口值代表标准输出设备，并且已经实现了 `io.Writer` 接口。当我们将 `Body` 和 `Stdout` 值传递给 `io.Copy`
    函数时，该函数以小数据块的形式将来自网络服务器的数据流式传输到终端窗口。一旦读取并写入最后一个数据块，`io.Copy` 函数返回。'
- en: The `io.Copy` function can perform this work flow for many different types that
    already exist in the standard library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Copy` 函数可以为标准库中许多已存在的不同类型执行此工作流程。'
- en: Listing 5.35\. listing35.go
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.35\. listing35.go
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Listing 5.35](#ch05ex35) shows a program that uses interfaces to concatenate
    and then stream data to standard out. On line 14, a variable of type `Buffer`
    from the `bytes` package is created, and then the `Write` method is used on line
    17 to add the string `Hello` to the buffer. On line 20, the `Fprintf` function
    from the `fmt` package is called to append a second string to the buffer.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.35](#ch05ex35) 展示了一个使用接口来拼接并将数据流式传输到标准输出的程序。在第 14 行，创建了一个来自 `bytes` 包的
    `Buffer` 类型的变量，然后在第 17 行使用 `Write` 方法将字符串 `Hello` 添加到缓冲区中。在第 20 行，调用 `fmt` 包中的
    `Fprintf` 函数将第二个字符串追加到缓冲区中。'
- en: The `fmt.Fprintf` function accepts an interface value of type `io.Writer` as
    its first parameter. Since pointers of type `bytes.Buffer` implement the `io.Writer`
    interface, it can be passed in and the `fmt.Fprintf` function performs the concatenation.
    Finally, on line 23 the `io.Copy` function is used once again to write characters
    to the terminal window. Since pointers of type `bytes.Buffer` also implement the
    `io.Reader` interface, the `io.Copy` function can be used to display the contents
    of the buffer to the terminal window.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Fprintf` 函数接受一个类型为 `io.Writer` 的接口值作为其第一个参数。由于 `bytes.Buffer` 类型的指针实现了
    `io.Writer` 接口，因此它可以被传入，并且 `fmt.Fprintf` 函数执行拼接操作。最后，在第 23 行再次使用 `io.Copy` 函数将字符写入终端窗口。由于
    `bytes.Buffer` 类型的指针也实现了 `io.Reader` 接口，因此可以使用 `io.Copy` 函数将缓冲区的内容显示到终端窗口。'
- en: These two small examples hopefully show you some of the benefits of interfaces
    and how they’re used in the standard library. Next, let’s explore in greater detail
    how interfaces are implemented.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个小例子可能希望向您展示接口的一些好处以及它们在标准库中的使用方式。接下来，让我们更详细地探讨接口是如何实现的。
- en: 5.4.2\. Implementation
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 实现
- en: Interfaces are types that just declare behavior. This behavior is never implemented
    by the interface type directly but instead by user-defined types via methods.
    When a user-defined type implements the set of methods declared by an interface
    type, values of the user-defined type can be assigned to values of the interface
    type. This assignment stores the value of the user-defined type into the interface
    value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是仅声明行为的类型。这种行为不是由接口类型直接实现，而是通过用户定义的类型通过方法实现的。当用户定义的类型实现了接口类型声明的集合方法时，用户定义类型的值可以被赋值给接口类型的值。这种赋值将用户定义类型的值存储到接口值中。
- en: If a method call is made against an interface value, the equivalent method for
    the stored user-defined value is executed. Since any user-defined type can implement
    any interface, method calls against an interface value are polymorphic in nature.
    The user-defined type in this relationship is often called a *concrete type*,
    since interface values have no concrete behavior without the implementation of
    the stored user-defined value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对接口值进行方法调用，则执行存储的用户定义值的等效方法。由于任何用户定义类型都可以实现任何接口，因此对接口值的方法调用在本质上具有多态性。在这个关系中，用户定义类型通常被称为
    *具体类型*，因为接口值在没有存储的用户定义值实现的情况下没有具体的行为。
- en: There are rules around whether values or pointers of a user-defined type satisfy
    the implementation of an interface. Not all values are created equal. These rules
    come from the specification under the section called method sets. Before you begin
    to investigate the details of method sets, it helps to understand what interface
    type values look like and how user-defined type values are stored inside them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户定义类型的值或指针是否满足接口实现，有一些规则。并非所有值都是平等的。这些规则来自名为方法集的章节下的规范。在您开始调查方法集的细节之前，了解接口类型值的外观以及用户定义类型值如何在其中存储是有帮助的。
- en: In [figure 5.1](#ch05fig01) you see what the value of the interface variable
    looks like after the assignment of the `user` type value. Interface values are
    two-word data structures. The first word contains a pointer to an internal table
    called an *iTable*, which contains type information about the stored value. The
    iTable contains the type of value that has been stored and a list of methods associated
    with the value. The second word is a pointer to the stored value. The combination
    of type information and pointer binds the relationship between the two values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5.1](#ch05fig01) 中，您可以看到 `user` 类型值赋值后接口变量的值。接口值是双字数据结构。第一个字包含指向一个称为 *iTable*
    的内部表的指针，该表包含存储值的类型信息。iTable 包含已存储的值的类型以及与该值相关的方法列表。第二个字是指向存储值的指针。类型信息和指针的组合将两个值之间的关系绑定在一起。
- en: Figure 5.1\. A simple view of an interface value after concrete type value assignment
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. 具体类型值赋值后接口值的简单视图
- en: '![](05fig01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1](05fig01.jpg)'
- en: '[Figure 5.2](#ch05fig02) shows what happens when a pointer is assigned to an
    interface value. In this case, the type information will reflect that a pointer
    of the assigned type has been stored, and the address being assigned is stored
    in the second word of the interface value.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.2](#ch05fig02) 展示了将指针赋值给接口值时发生的情况。在这种情况下，类型信息将反映已存储的分配类型的指针，并且被分配的地址存储在接口值的第二个字中。'
- en: Figure 5.2\. A simple view of an interface value after concrete type pointer
    assignment
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 指针赋值后接口值的简单视图
- en: '![](05fig02.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2](05fig02.jpg)'
- en: 5.4.3\. Method sets
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3\. 方法集
- en: Method sets define the rules around interface compliance. Take a look at the
    following code to help you understand how method sets play an important role with
    interfaces.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 方法集定义了接口合规性的规则。看看以下代码，以帮助您理解方法集在接口中扮演的重要角色。
- en: Listing 5.36\. listing36.go
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.36\. listing36.go
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In [listing 5.36](#ch05ex36) you see code that you would expect to compile,
    but it doesn’t. On line 10, we declare an interface named `notifier` with a single
    method named `notify`. Then on line 15, we have the declaration of our concrete
    type named `user` and the implementation of the `notifier` interface via the method
    declaration on line 21\. The method is implemented with a pointer receiver of
    type `user`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.36](#ch05ex36) 中，您会看到您预期可以编译的代码，但它却不能编译。在第 10 行，我们声明了一个名为 `notifier`
    的接口，它有一个名为 `notify` 的单一方法。然后在第 15 行，我们有名为 `user` 的具体类型的声明以及通过第 21 行的方法声明来实现 `notifier`
    接口。该方法使用 `user` 类型的指针接收器来实现。
- en: 'Listing 5.37\. listing36.go: lines 40–44'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.37\. listing36.go: 行 40–44'
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: On line 42 in [listing 5.37](#ch05ex37), a function named `sendNotification`
    is declared and accepts a single value of the interface type `notifier`. Then
    the interface value is used to call the `notify` method against the stored value.
    Any value that implements the `notifier` interface can be passed into the `sendNotification`
    function. Now let’s look at the `main` function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.37](#ch05ex37) 的第 42 行，声明了一个名为 `sendNotification` 的函数，它接受一个接口类型 `notifier`
    的单一值。然后使用接口值调用 `notify` 方法来针对存储的值。任何实现了 `notifier` 接口的值都可以传递给 `sendNotification`
    函数。现在让我们看看 `main` 函数。
- en: 'Listing 5.38\. listing36.go: lines 28–38'
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.38\. listing36.go: 行 28–38'
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `main` function, a value of the concrete type `user` is created and assigned
    to the variable `u` on line 30 in [listing 5.38](#ch05ex38). Then the value of
    `u` is passed to the `send-Notification` function on line 32\. But the call to
    `sendNotification` results in a compiler error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，创建了一个具体类型 `user` 的值，并将其分配给变量 `u`，在 [listing 5.38](#ch05ex38) 中的第
    30 行。然后，将 `u` 的值传递给 `send-Notification` 函数，在第 32 行。但 `sendNotification` 的调用导致编译器错误。
- en: Listing 5.39\. Compiler error storing a value of type `user` to the interface
    value
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.39\. 将类型 `user` 的值存储到接口值中的编译器错误
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So why do we receive a compiler error when the `user` type implements the `notify`
    method on line 21? Let’s take a look at that code again.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们在第 21 行实现 `notify` 方法时收到编译器错误呢？让我们再次查看那段代码。
- en: 'Listing 5.40\. listing36.go: lines 08–12, 21–25'
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.40\. listing36.go: 行 08–12, 21–25'
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Listing 5.40](#ch05ex40) shows how the interface has been implemented, yet
    the compiler tells us that a value of type `user` doesn’t implement the interface.
    If you look closer at the compiler message, it actually tells us why.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.40](#ch05ex40) 展示了接口是如何实现的，但编译器告诉我们类型 `user` 的值不实现接口。如果你仔细查看编译器消息，它实际上告诉我们原因。'
- en: Listing 5.41\. Closer look at compiler error
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.41\. 编译器错误的更详细查看
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To understand why values of type `user` don’t implement the interface when an
    interface is implemented with a pointer receiver, you need to understand what
    *method sets* are. Method sets define the set of methods that are associated with
    values or pointers of a given type. The type of receiver used will determine whether
    a method is associated with a value, pointer, or both.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么在用指针接收器实现接口时，类型 `user` 的值不实现该接口，你需要了解什么是 *方法集*。方法集定义了与给定类型的值或指针相关联的方法集合。使用的接收器类型将决定一个方法是否与值、指针或两者相关联。
- en: Let’s start with explaining the rules for method sets as it’s documented by
    the Go specification.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Go 规范中记录的方法集规则开始解释。
- en: Listing 5.42\. Method sets as described by the specification
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.42\. 规范中描述的方法集
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[Listing 5.42](#ch05ex42) shows how the specification describes method sets.
    It says that a value of type `T` only has methods declared that have a value receiver,
    as part of its method set. But pointers of type `T` have methods declared with
    both value and pointer receivers, as part of its method set. Looking at these
    rules from the perspective of the value is confusing. Let’s look at these rules
    from the perspective of the receiver.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.42](#ch05ex42) 展示了规范如何描述方法集。它说，类型 `T` 的值只具有声明了值接收器的方法，作为其方法集的一部分。但类型
    `T` 的指针具有声明了值和指针接收器的方法，作为其方法集的一部分。从值的角度看这些规则是令人困惑的。让我们从接收器的角度看看这些规则。'
- en: Listing 5.43\. Method sets from the perspective of the receiver type
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.43\. 从接收器类型的角度看方法集
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Listing 5.43](#ch05ex43) shows the same rules, but from the perspective of
    the receiver. It says that if you implement an interface using a pointer receiver,
    then only pointers of that type implement the interface. If you implement an interface
    using a value receiver, then both values and pointers of that type implement the
    interface. If you look at the code in [listing 5.36](#ch05ex36) again, you now
    have the context to understand the compiler error.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.43](#ch05ex43) 展示了相同的规则，但是从接收器的角度。它说，如果你使用指针接收器实现接口，那么只有该类型的指针实现该接口。如果你使用值接收器实现接口，那么该类型的值和指针都实现该接口。如果你再次查看
    [listing 5.36](#ch05ex36) 中的代码，你现在有了理解编译器错误的上下文。'
- en: 'Listing 5.44\. listing36.go: lines 28–38'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.44\. listing36.go: 行 28–38'
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We implemented the interface using a pointer receiver and attempted to pass
    a value of type `user` to the `sendNotification` function. Lines 30 and 32 in
    [listing 5.44](#ch05ex44) show this clearly. But if we pass the address of the
    `user` value instead, you’ll see that it now compiles and works.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用指针接收器实现了接口，并尝试将类型 `user` 的值传递给 `sendNotification` 函数。在 [listing 5.44](#ch05ex44)
    中的第 30 和 32 行清楚地展示了这一点。但如果我们将 `user` 值的地址传递过去，你会看到现在它可以编译并正常工作。
- en: 'Listing 5.45\. listing36.go: lines 28–35'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.45\. listing36.go: 行 28–35'
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In [listing 5.45](#ch05ex45), we now have a program that compiles and runs.
    Only pointers of type `user` can be passed to the `sendNotification` function,
    since a pointer receiver was used to implement the interface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [listing 5.45](#ch05ex45) 中，我们现在有一个可以编译和运行的程序。只有类型 `user` 的指针可以传递给 `sendNotification`
    函数，因为接口是用指针接收器实现的。
- en: The question now is why the restriction? The answer comes from the fact that
    it’s not always possible to get the address of a value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是为什么有这种限制？答案来自于这样一个事实，即并不总是能够获取到一个值的地址。
- en: Listing 5.46\. listing46.go
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.46\. listing46.go
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The code in [listing 5.46](#ch05ex46) attempts to get the address of a value
    of type `duration` and can’t. This shows that it’s not always possible to get
    the address of a value. Let’s look at the method set rules again.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[listing 5.46](#ch05ex46) 中的代码尝试获取类型为 `duration` 的值的地址，但无法做到。这表明并不总是能够获取到一个值的地址。让我们再次查看方法集规则。'
- en: Listing 5.47\. Second look at the method set rules
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.47\. 再次查看方法集规则
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Because it’s not always possible to get the address of a value, the method set
    for a value only includes methods that are implemented with a value receiver.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为并不总是能够获取到一个值的地址，所以为值设置的方法只包括使用值接收器实现的方法。
- en: 5.4.4\. Polymorphism
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.4\. 多态
- en: Now that you understand the mechanics behind interfaces and method sets, let’s
    look at one final example that shows the polymorphic behavior of interfaces.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了接口和方法集背后的机制，让我们来看一个最终的例子，展示接口的多态行为。
- en: Listing 5.48\. listing48.go
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.48\. listing48.go
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In [listing 5.48](#ch05ex48), we have a final example of how interfaces provide
    polymorphic behavior. On line 10, we have the same `notifier` interface that we
    declared in previous listings. Then on lines 15 through 25, we have the declaration
    of a struct named `user` with the implementation of the `notifier` interface using
    a pointer receiver. On lines 28 through 38, we have the declaration of a struct
    named `admin` with the implementation of the `notifier` interface as well. We
    have two concrete types implementing the `notifier` interface.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [listing 5.48](#ch05ex48) 中，我们有一个接口如何提供多态行为的最终示例。在第 10 行，我们有之前列表中声明的相同的 `notifier`
    接口。然后在第 15 到 25 行，我们有名为 `user` 的结构体的声明，它使用指针接收器实现了 `notifier` 接口。在第 28 到 38 行，我们有名为
    `admin` 的结构体的声明，它同样实现了 `notifier` 接口。我们有两个具体类型实现了 `notifier` 接口。
- en: On line 53, we have our polymorphic `sendNotification` function again that accepts
    values that implement the `notifier` interface. Since any concrete type value
    can implement the interface, this function can execute the `notify` method for
    any concrete type value that’s passed in, thus providing polymorphic behavior.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 53 行，我们再次看到了多态的 `sendNotification` 函数，它接受实现了 `notifier` 接口值的参数。由于任何具体的类型值都可以实现接口，这个函数可以执行传入的任何具体类型值的
    `notify` 方法，从而提供多态行为。
- en: 'Listing 5.49\. listing48.go: lines 40–49'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.49\. listing48.go: 行 40–49'
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, in [listing 5.49](#ch05ex49) you see it all come together. A value
    of type `user` is created on line 43 in the `main` function, and then the address
    of that value is passed into `send-Notification` on line 44\. This causes the
    `notify` method declared by the `user` type to be executed. Then we do the same
    with a value of type `admin` on lines 47 and 48\. In the end, because `sendNotification`
    accepts interface values of type `notifier`, the function can execute the behavior
    implemented by both `user` and `admin`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [listing 5.49](#ch05ex49) 中，你看到所有内容都汇集在一起。在 `main` 函数的第 43 行创建了一个类型为 `user`
    的值，然后在该值的地址在第 44 行传递给 `send-Notification`。这导致 `user` 类型声明的 `notify` 方法被执行。然后我们在第
    47 和 48 行对类型为 `admin` 的值做同样的操作。最后，因为 `sendNotification` 接受类型为 `notifier` 的接口值，所以函数可以执行
    `user` 和 `admin` 都实现的行为。
- en: 5.5\. Type embedding
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 类型嵌入
- en: Go allows you to take existing types and both extend and change their behavior.
    This capability is important for code reuse and for changing the behavior of an
    existing type to suit a new need. This is accomplished through *type embedding*.
    It works by taking an existing type and declaring that type within the declaration
    of a new struct type. The type that is embedded is then called an *inner* type
    of the new *outer* type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你使用现有的类型，并扩展和改变它们的行为。这种能力对于代码重用以及为了满足新的需求而改变现有类型的行为非常重要。这是通过 *类型嵌入* 实现的。它的工作原理是，通过在新的结构体类型声明中声明一个现有类型，从而使用现有类型。然后，被嵌入的类型被称为新的
    *外部* 类型的 *内部* 类型。
- en: Through inner type promotion, identifiers from the inner type are promoted up
    to the outer type. These promoted identifiers become part of the outer type as
    if they were declared explicitly by the type itself. The outer type is then composed
    of everything the inner type contains, and new fields and methods can be added.
    The outer type can also declare the same identifiers as the inner type and override
    any fields or methods it needs to. This is how an existing type can be both extended
    and changed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过内部类型提升，内部类型的标识符被提升到外部类型。这些提升的标识符成为外部类型的一部分，就像它们被类型本身显式声明一样。然后外部类型由内部类型包含的所有内容组成，可以添加新的字段和方法。外部类型还可以声明与内部类型相同的标识符，并覆盖它需要的任何字段或方法。这就是现有类型如何被扩展和更改的方式。
- en: Let’s start with a sample program that shows the basics of type embedding.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从展示类型嵌入基本原理的示例程序开始。
- en: Listing 5.50\. listing50.go
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.50\. listing50.go
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In [listing 5.50](#ch05ex50), we have a program that shows how to embed a type
    and access the embedded identifiers. We start with the declaration of two struct
    types on lines 10 and 24.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 5.50](#ch05ex50)中，我们有一个程序，展示了如何嵌入类型并访问嵌入的标识符。我们从第 10 行和第 24 行声明两个结构体类型开始。
- en: 'Listing 5.51\. listing50.go: lines 09–13, 23–27'
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.51\. listing50.go: 行 09–13, 23–27'
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: On line 10 in [listing 5.51](#ch05ex51), we have the declaration of a struct
    type named `user`, and then on line 24 we have the declaration of a second struct
    type named `admin`. Inside the declaration of the `admin` type on line 25, we
    have the embedding of the `user` type as an inner type of `admin`. To embed a
    type, all that needs to happen is for the type name to be declared. One line 26,
    we have the declaration of a field named `level`. Notice the difference between
    declaring a field and embedding a type.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 5.51](#ch05ex51)的第 10 行，我们声明了一个名为`user`的结构体类型，然后在第 24 行我们声明了第二个名为`admin`的结构体类型。在`admin`类型的声明（第
    25 行）中，我们将`user`类型作为`admin`的内部类型嵌入。要嵌入一个类型，只需声明类型名即可。在第 26 行，我们声明了一个名为`level`的字段。注意声明字段和嵌入类型之间的区别。
- en: Once we embed the `user` type inside of `admin`, we can say that `user` is an
    inner type of the outer type `admin`. The concept of having an inner and outer
    type makes it easier to understand the relationship between the two.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`admin`内部嵌入`user`类型，我们就可以说`user`是外部类型`admin`的内部类型。拥有内部和外部类型的概念使得理解两者之间的关系变得更容易。
- en: 'Listing 5.52\. listing50.go: lines 15–21'
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.52\. listing50.go: 行 15–21'
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[Listing 5.52](#ch05ex52) shows the declaration of a method named `notify`
    using a pointer receiver of type `user`. The method just displays a friendly message
    stating an email is being sent to a specific user and email address. Now let’s
    look at the `main` function.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.52](#ch05ex52)展示了使用类型`user`的指针接收器声明了一个名为`notify`的方法。该方法仅显示一条友好的消息，说明正在向特定的用户和电子邮件地址发送电子邮件。现在让我们看看`main`函数。'
- en: 'Listing 5.53\. listing50.go: lines 30–45'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.53\. listing50.go: 行 30–45'
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `main` function in [listing 5.53](#ch05ex53) shows the mechanics behind
    type embedding. On line 32, a value of type `admin` is created. The initialization
    of the inner type is performed using a struct literal, and to access the inner
    type we just need to use the type’s name. Something special about an inner type
    is that it always exists in and of itself. This means the inner type never loses
    its identity and can always be accessed directly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.53](#ch05ex53)中的`main`函数展示了类型嵌入的机制。在第 32 行，创建了一个类型为`admin`的值。内部类型的初始化是通过结构体字面量来执行的，要访问内部类型，我们只需使用类型的名称。关于内部类型的一个特殊之处在于，它始终独立存在。这意味着内部类型永远不会失去其身份，并且始终可以直接访问。'
- en: 'Listing 5.54\. listing50.go: lines 40–41'
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.54\. listing50.go: 行 40–41'
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: On line 41 in [listing 5.54](#ch05ex54), you see a call to the `notify` method.
    This call is made by accessing the `user` inner type directly through the `admin`
    outer type variable `ad`. This shows how the inner type exists in and of itself
    and is always accessible. But thanks to inner type promotion, the `notify` method
    can also be accessed directly from the `ad` variable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 5.54](#ch05ex54)的第 41 行，你可以看到一个对`notify`方法的调用。这个调用是通过直接通过`admin`外部类型变量`ad`访问`user`内部类型来实现的。这展示了内部类型如何独立存在并且始终可访问。但多亏了内部类型提升，`notify`方法也可以直接从`ad`变量中访问。
- en: 'Listing 5.55\. listing50.go: lines 43–45'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.55\. listing50.go: 行 43–45'
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Listing 5.55](#ch05ex55) on line 44 shows the method call to `notify` from
    the outer type variable. Since the identifiers of the inner type are promoted
    up to the outer type, we can access the inner type’s identifiers through values
    of the outer type. Let’s change the sample by adding an interface.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.55](#ch05ex55) 在第 44 行显示了从外部类型变量调用 `notify` 方法。由于内部类型的标识符被提升到外部类型，我们可以通过外部类型的价值访问内部类型的标识符。让我们通过添加一个接口来修改示例。'
- en: Listing 5.56\. listing56.go
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.56\. listing56.go
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The sample code in [listing 5.56](#ch05ex56) uses the same code from before
    but with a few changes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.56](#ch05ex56) 中的示例代码使用了之前的相同代码，但做了一些修改。'
- en: 'Listing 5.57\. listing56.go: lines 08–12, 51–55'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.57\. listing56.go: 第 08–12 行，第 51–55 行'
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: On line 08 in [listing 5.57](#ch05ex57), we have the declaration of the `notifier`
    interface. Then on line 53, we have the `sendNotification` function that accepts
    an interface value of type `notifier`. We know from the code before that the `user`
    type has declared a method named `notify` that implements the `notifier` interface
    with a pointer receiver. Therefore, we can move on to the changes made to the
    `main` function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.57](#ch05ex57) 的第 08 行，我们有 `notifier` 接声明的声明。然后在第 53 行，我们有 `sendNotification`
    函数，它接受一个类型为 `notifier` 的接口值。从之前的代码中我们知道，`user` 类型声明了一个名为 `notify` 的方法，该方法使用指针接收器实现了
    `notifier` 接口。因此，我们可以继续到对 `main` 函数所做的修改。
- en: 'Listing 5.58\. listing56.go: lines 35–49'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.58\. listing56.go: 第 35–49 行'
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is where things get interesting. On line 37 in [listing 5.58](#ch05ex58),
    we create the `admin` outer type variable `ad`. Then on line 48, we pass the address
    of the outer type variable to the `sendNotification` function. The compiler accepts
    the assignment of the outer type pointer as a value that implements the `notifier`
    interface. But if you look at the entire sample program, you won’t see the `admin`
    type implement the interface.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事情变得有趣的地方。在 [列表 5.58](#ch05ex58) 的第 37 行，我们创建了 `admin` 外部类型变量 `ad`。然后在第 48
    行，我们将外部类型变量的地址传递给 `sendNotification` 函数。编译器接受将外部类型指针赋值为一个实现了 `notifier` 接口的价值。但如果你查看整个示例程序，你不会看到
    `admin` 类型实现了接口。
- en: Thanks to inner type promotion, the implementation of the interface by the inner
    type has been promoted up to the outer type. That means the outer type now implements
    the interface, thanks to the inner type’s implementation. When we run this sample
    program, we get the following output.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了内部类型提升，内部类型对接口的实现已经提升到外部类型。这意味着外部类型现在实现了接口，这是由于内部类型的实现。当我们运行这个示例程序时，我们得到以下输出。
- en: Listing 5.59\. Output for listing56.go
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.59\. 列表 56.go 的输出
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can see in [listing 5.59](#ch05ex59) that the inner type’s implementation
    of the interface was called.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [列表 5.59](#ch05ex59) 中看到调用了内部类型的接口实现。
- en: What if the outer type doesn’t want to use the inner type’s implementation because
    it needs an implementation of its own? Let’s look at another sample program that
    solves that problem.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部类型不想使用内部类型的实现，因为它需要自己的实现，那会怎样呢？让我们看看另一个示例程序，它解决了这个问题。
- en: Listing 5.60\. listing60.go
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.60\. listing60.go
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The sample code in [listing 5.60](#ch05ex60) uses the same code from before,
    but with a few more changes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.60](#ch05ex60) 中的示例代码使用了之前的相同代码，但做了一些修改。'
- en: 'Listing 5.61\. listing60.go: lines 35–41'
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.61\. listing60.go: 第 35–41 行'
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This code sample adds an implementation of the `notifier` interface by the `admin`
    type. When the `admin` type’s implementation is called, it will display `"Sending
    admin email"` as opposed to the `user` type’s implementation that displays `"Sending
    user email"`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例通过 `admin` 类型添加了 `notifier` 接口的实现。当调用 `admin` 类型的实现时，它将显示 `"Sending admin
    email"`，而不是显示 `"Sending user email"` 的 `user` 类型实现。
- en: There are some more changes to the `main` function as well.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `main` 函数也有一些其他修改。
- en: 'Listing 5.62\. listing60.go: lines 43–64'
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.62\. listing60.go: 第 43–64 行'
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: On line 46 in [listing 5.62](#ch05ex62), we have the creation of the outer type
    `ad` variable again. On line 57 the address of the `ad` variable is passed to
    the `sendNotification` function, and the value is accepted as implementing the
    interface. On line 60 the code calls the `notify` method from accessing the `user`
    inner type directly. Finally, on line 63 the `notify` method is called using the
    outer type variable `ad`. When you look at the output of this sample program,
    you see a different story.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表5.62](#ch05ex62)的第46行，我们再次创建了外部的`ad`类型变量。在第57行，将`ad`变量的地址传递给`sendNotification`函数，并且该值被接受为实现了接口。在第60行，代码直接从`user`内部类型调用`notify`方法。最后，在第63行使用外部类型变量`ad`调用`notify`方法。当你查看这个示例程序的输出时，你会看到不同的故事。
- en: Listing 5.63\. Output for listing60.go
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.63. listing60.go的输出
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This time you see how the `admin` type’s implementation of the `notifier` interface
    was executed both by the `sendNotification` function and through the use of the
    outer type variable `ad`. This shows how the inner type’s implementation was not
    promoted once the outer type implemented the `notify` method. But the inner type
    is always there, in and of itself, so the code is still able to call the inner
    type’s implementation directly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你看到了`admin`类型实现`notifier`接口是如何通过`sendNotification`函数和通过使用外部类型变量`ad`来执行的。这表明一旦外部类型实现了`notify`方法，内部类型的实现就不会被提升。但内部类型始终存在，因此代码仍然可以直接调用内部类型的实现。
- en: 5.6\. Exporting and unexporting identifiers
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6. 导出和未导出标识符
- en: The ability to apply visibility rules to the identifiers you declare is critical
    for good API design. Go supports the exporting and unexporting of identifiers
    from a package to provide this functionality. In [chapter 3](kindle_split_011.html#ch03),
    we talked about packaging and how to import the identifiers from one package into
    another. Sometimes, you may not want identifiers such as types, functions, or
    methods to be a part of the public API for a package. In these cases, you need
    a way to declare those identifiers so they’re unknown outside the package. You
    need to declare them to be unexported.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将可见性规则应用于你声明的标识符的能力对于良好的API设计至关重要。Go支持从包中导出和未导出标识符以提供此功能。在[第3章](kindle_split_011.html#ch03)中，我们讨论了打包以及如何从一个包中导入标识符到另一个包。有时，你可能不希望类型、函数或方法等标识符成为包的公共API的一部分。在这些情况下，你需要一种方法来声明这些标识符，使它们在包外部未知。你需要声明它们为未导出。
- en: Let’s start with a sample program that shows how to unexport identifiers from
    a package.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从展示如何从包中未导出标识符的示例程序开始。
- en: Listing 5.64\. listing64/
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.64. listing64/
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this example we have two code files. One is named counters.go and lives inside
    its own package named `counters`. The second code file is named listing64.go and
    is importing the `counters` package. Let’s start with the code inside the `counters`
    package.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个代码文件。一个是名为`counters.go`，位于名为`counters`的独立包中。第二个代码文件名为`listing64.go`，它导入了`counters`包。让我们从`counters`包内部的代码开始。
- en: Listing 5.65\. `counters`/counters.go
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.65. `counters`/counters.go
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[Listing 5.65](#ch05ex65) isolates the code for just the `counters` package.
    The first thing you should notice is on line 02\. Up until now, all the code samples
    have used `package main`, but here you see `package counters`. When you’re writing
    code that will live in its own package, it’s good practice to name the package
    the same as the folder the code is in. All the Go tooling expects this convention,
    so it’s a good practice to follow.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.65](#ch05ex65)将`counters`包的代码单独列出。你应该注意到的第一件事是第02行。到目前为止，所有代码示例都使用了`package
    main`，但在这里你看到了`package counters`。当你编写的代码将存在于自己的包中时，将包的名称与代码所在的文件夹名称相同是一个好习惯。所有的Go工具都期望这种约定，因此遵循它是一个好习惯。'
- en: In package `counters`, we’ve declared a single identifier named `alertCounter`
    on line 06\. This identifier is a type using `int` as its base type. An important
    aspect of this identifier is that it has been unexported.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在`counters`包中，我们在第06行声明了一个名为`alertCounter`的单个标识符。这个标识符是一个使用`int`作为其基本类型的类型。这个标识符的一个重要方面是它已经被未导出。
- en: When an identifier starts with a lowercase letter, the identifier is unexported
    or unknown to code outside the package. When an identifier starts with an uppercase
    letter, it’s exported or known to code outside the package. Let’s look at the
    code that imports this package.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个标识符以小写字母开头时，该标识符是未导出的或对包外部的代码来说是未知的。当一个标识符以大写字母开头时，它是导出的或对包外部的代码来说是已知的。让我们看看导入这个包的代码。
- en: Listing 5.66\. listing64.go
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.66\. `listing64.go`
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The code in listing64.go from [listing 5.66](#ch05ex66) is declaring the `main`
    package on line 03, and then on line 08 the `counters` package is imported. With
    the `counters` package imported, we move to the `main` function and line 15.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.66 中的 `listing64.go` 代码在第 03 行声明了 `main` 包，然后在第 08 行导入了 `counters` 包。导入
    `counters` 包后，我们转到 `main` 函数的第 15 行。
- en: 'Listing 5.67\. listing64.go: lines 13–19'
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.67\. `listing64.go`: 行 13–19'
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: On line 15 in [listing 5.67](#ch05ex67), the code attempts to create a value
    of the unexported type `alertCounter`. But this code produces a compiler error
    that states that the code at line 15 can’t refer to the unexported identifier
    `counters.alertCounter`. This identifier is undefined.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 5.67 的第 15 行，代码尝试创建一个未导出类型 `alertCounter` 的值。但这段代码产生了编译器错误，指出第 15 行的代码不能引用未导出的标识符
    `counters.alertCounter`。这个标识符是未定义的。
- en: Since the `alertCounter` type from the `counters` package was declared using
    a lowercase letter, it was unexported and therefore unknown to the code in listing64.go.
    If we change the type to start with a capital letter, then the compiler error
    will go away. Let’s look at a new sample program that implements a factory function
    for the `counters` package.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `counters` 包中的 `alertCounter` 类型是用小写字母声明的，因此它是未导出的，因此在列表 64 中的代码中是未知的。如果我们将类型改为以大写字母开头，那么编译器错误就会消失。让我们看看实现
    `counters` 包工厂函数的新示例程序。
- en: Listing 5.68\. listing68/
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.68\. `listing68/`
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This example has been changed to use a factory function to create values of
    the unexported `alertCounter` type. Let’s look at the code in the `counters` package
    first.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子已经被修改为使用工厂函数来创建未导出的 `alertCounter` 类型的值。让我们首先看看 `counters` 包中的代码。
- en: Listing 5.69\. `counters`/counters.go
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.69\. `counters`/`counters.go`
- en: '[PRE68]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[Listing 5.69](#ch05ex69) shows the changes we made to the `counters` package.
    The `alertCounter` type is still unexported, but now on line 10 we have a function
    called `New`. It’s a convention in Go to give factory functions the name of `New`.
    This `New` function does something interesting: it creates a value of the unexported
    type and returns that value back to the caller. Let’s look at the `main` function
    from listing68.go.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.69](#ch05ex69) 展示了我们针对 `counters` 包所做的修改。`alertCounter` 类型仍然未导出，但现在在第
    10 行我们有一个名为 `New` 的函数。在 Go 中，给工厂函数命名通常使用 `New`。这个 `New` 函数做了一些有趣的事情：它创建了一个未导出类型的值，并将该值返回给调用者。让我们看看列表
    68 中的 `main` 函数。'
- en: Listing 5.70\. listing68.go
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.70\. `listing68.go`
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: On line 15 in [listing 5.70](#ch05ex70), you see a call to the `New` function
    from the `counters` package. The value returned by the `New` function is then
    assigned to a variable named `counter`. This program compiles and runs, but why?
    The `New` function is returning a value of the unexported type `alertCounter`,
    yet `main` is able to accept that value and create a variable of the unexported
    type.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 5.70 的第 15 行，你可以看到对 `counters` 包中 `New` 函数的调用。`New` 函数返回的值被分配给一个名为 `counter`
    的变量。这个程序可以编译和运行，但为什么？`New` 函数返回的是一个未导出类型 `alertCounter` 的值，而 `main` 能够接受这个值并创建一个未导出类型的变量。
- en: This is possible for two reasons. First, identifiers are exported or unexported,
    not values. Second, the short variable declaration operator is capable of inferring
    the type and creating a variable of the unexported type. You can never explicitly
    create a variable of an unexported type, but the short variable declaration operator
    can.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为两个原因。首先，标识符是导出或未导出的，而不是值。其次，短变量声明运算符能够推断类型并创建一个未导出类型的变量。你永远不能显式创建一个未导出类型的变量，但短变量声明运算符可以。
- en: Let’s look at a new sample program that shows how fields from a struct type
    are affected by these visibility rules.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个新的示例程序，它展示了结构体类型的字段如何受到这些可见性规则的影响。
- en: Listing 5.71\. listing71/
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.71\. `listing71/`
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The code in [listing 5.71](#ch05ex71) changed things a bit. Now we have a package
    called `entities` that declares a struct type named `User`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.71 中的代码做了一些改变。现在我们有一个名为 `entities` 的包，它声明了一个名为 `User` 的结构体类型。
- en: Listing 5.72\. `entities`/entities.go
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.72\. `entities`/`entities.go`
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `User` type on line 06 in [listing 5.72](#ch05ex72) is declared to be exported.
    Two fields are declared with the `User` type, an exported field named `Name` and
    an unexported field named `email`. Let’s look at the code in `listing71.go`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 5.72 的第 06 行，`User` 类型被声明为导出。声明了两个具有 `User` 类型的字段，一个名为 `Name` 的导出字段和一个名为
    `email` 的未导出字段。让我们看看 `listing71.go` 中的代码。
- en: Listing 5.73\. listing71.go
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.73\. `listing71.go`
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `entities` package is imported on line 08 in [listing 5.73](#ch05ex73).
    On line 14 a variable named `u` of the exported type `User` from the `entities`
    package is declared and its fields initialized. But there’s a problem. On line
    16 the code attempts to initialize the unexported field `email`, and the compiler
    complains the field is unknown. That identifier can’t be accessed outside the
    `entities` package, since it has been unexported.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 08 行，`entities` 包被导入到 [列表 5.73](#ch05ex73) 中。在第 14 行，声明了一个名为 `u` 的变量，它是来自
    `entities` 包的导出类型 `User`，并初始化了其字段。但是有一个问题。在第 16 行，代码尝试初始化未导出的字段 `email`，编译器抱怨该字段未知。该标识符无法在
    `entities` 包外部访问，因为它已被未导出。
- en: Let’s look at one final example to show how the exporting and unexporting of
    embedded types work.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个最终的例子，以展示嵌入式类型的导出和非导出是如何工作的。
- en: Listing 5.74\. listing74/
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.74\. listing74/
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, in [listing 5.74](#ch05ex74) the `entities` package contains two struct
    types.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 [列表 5.74](#ch05ex74) 中，`entities` 包包含两个结构体类型。
- en: Listing 5.75\. `entities`/entities.go
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.75\. `entities`/entities.go
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: On line 06 in [listing 5.75](#ch05ex75), an unexported struct type named `user`
    is declared. It contains two exported fields named `Name` and `Email`. On line
    12 an exported struct type named `Admin` is declared. `Admin` has an exported
    field named `Rights`, but it also embeds the unexported `user` type. Let’s look
    at the code in the `main` function for listing74.go.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.75](#ch05ex75) 的第 06 行，声明了一个未导出的结构体类型 `user`。它包含两个名为 `Name` 和 `Email`
    的导出字段。在第 12 行，声明了一个名为 `Admin` 的导出结构体类型。`Admin` 有一个名为 `Rights` 的导出字段，但它还嵌入了一个未导出的
    `user` 类型。让我们看看列表74.go中的 `main` 函数中的代码。
- en: 'Listing 5.76\. listing74.go: lines 11–24'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 5.76\. listing74.go: 行 11–24'
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `main` function starts out on line 14 in [listing 5.76](#ch05ex76) by creating
    a value of type `Admin` from the `entities` package. Since the `user` inner type
    is unexported, this code can’t access the inner type to initialize it inside the
    struct literal. Even though the inner type is unexported, the fields declared
    within the inner type are exported. Since the identifiers from the inner type
    are promoted to the outer type, those exported fields are known through a value
    of the outer type.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数从第 14 行开始，在 [列表 5.76](#ch05ex76) 中创建了一个来自 `entities` 包的 `Admin` 类型的值。由于
    `user` 内部类型未导出，此代码无法访问内部类型并在结构字面量内部初始化它。尽管内部类型未导出，但内部类型中声明的字段是导出的。由于内部类型的标识符提升到外部类型，因此通过外部类型的值可以知道这些导出字段。'
- en: Therefore, on line 20 and 21 the `Name` and `Email` fields from the unexported
    inner type can be accessed and initialized through the outer type variable `a`.
    There’s no access to the inner type directly, since the `user` type is unexported.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第 20 行和第 21 行，可以通过未导出的内部类型 `user` 的 `Name` 和 `Email` 字段通过外部类型变量 `a` 访问和初始化。由于
    `user` 类型未导出，因此无法直接访问内部类型。
- en: 5.7\. Summary
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7\. 摘要
- en: User-defined types can be declared using the keyword `struct` or by specifying
    an existing type.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用关键字 `struct` 或指定现有类型来声明用户定义类型。
- en: Methods provide a way to add behavior to user-defined types.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法提供了一种向用户定义类型添加行为的方式。
- en: Think of types as having one of two natures, primitive or non-primitive.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型视为具有两种性质之一：原始或非原始。
- en: Interfaces are types that declare behavior and provide polymorphism.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口是声明行为并提供多态性的类型。
- en: Type embedding provides the ability to extend types without the need for inheritance.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型嵌入提供了一种在不使用继承的情况下扩展类型的能力。
- en: Identifiers are either exported or unexported from packages.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符要么从包中导出，要么未导出。
