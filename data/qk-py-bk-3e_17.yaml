- en: Chapter 15\. Classes and object-oriented programming
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章. 类和面向对象编程
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Defining classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义类
- en: Using instance variables and `@property`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实例变量和`@property`
- en: Defining methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义方法
- en: Defining class variables and methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义类变量和方法
- en: Inheriting from other classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他类继承
- en: Making variables and methods private
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使变量和方法私有
- en: Inheriting from multiple classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个类继承
- en: In this chapter, I discuss Python classes, which can be used to hold both data
    and code. Although most programmers are probably familiar with classes or objects
    in other languages, I make no particular assumptions about knowledge of a specific
    language or paradigm. In addition, this chapter is a description only of the constructs
    available in Python; it’s not an exposition on object-oriented programming (OOP)
    itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了Python类，它可以用来存储数据和代码。尽管大多数程序员可能熟悉其他语言中的类或对象，但我对特定语言或范式的知识没有做出任何特定的假设。此外，本章仅描述Python中可用的构造，而不是面向对象编程（OOP）本身的阐述。
- en: 15.1\. Defining classes
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1. 定义类
- en: 'A *class* in Python is effectively a data type. All the data types built into
    Python are classes, and Python gives you powerful tools to manipulate every aspect
    of a class’s behavior. You define a class with the `class` statement:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的*类*实际上是一种数据类型。Python中构建的所有数据类型都是类，Python为您提供了强大的工具来操纵类的每个方面。您使用`class`语句定义类：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`body` is a list of Python statements—typically, variable assignments and function
    definitions. No assignments or function definitions are required. The body can
    be just a single `pass` statement.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`是Python语句的列表——通常是变量赋值和函数定义。不需要任何赋值或函数定义。主体可以只是一个单独的`pass`语句。'
- en: 'By convention, class identifiers are in CapCase—that is, the first letter of
    each component word is capitalized, to make the identifiers stand out. After you
    define the class, you can create a new object of the class type (an instance of
    the class) by calling the class name as a function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，类标识符使用CapCase——即每个组成部分的首字母大写，以便使标识符突出。定义类后，您可以通过将类名作为函数调用来创建该类类型的新对象（类的实例）：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 15.1.1\. Using a class instance as a structure or record
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.1. 使用类实例作为结构或记录
- en: 'Class instances can be used as structures or records. Unlike C structures or
    Java classes, the data fields of an instance don’t need to be declared ahead of
    time; they can be created on the fly. The following short example defines a class
    called `Circle`, creates a `Circle` instance, assigns a value to the `radius`
    field of the circle, and then uses that field to calculate the circumference of
    the circle:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 类实例可以用作结构或记录。与C结构或Java类不同，实例的数据字段不需要提前声明；它们可以即时创建。以下简短示例定义了一个名为`Circle`的类，创建了一个`Circle`实例，将值赋给圆的`radius`字段，然后使用该字段计算圆的周长：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As in Java and many other languages, the fields of an instance/structure are
    accessed and assigned to by using dot notation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如同Java和许多其他语言一样，实例/结构的字段通过点符号进行访问和赋值。
- en: 'You can initialize fields of an instance automatically by including an `__init__`
    initialization method in the class body. This function is run every time an instance
    of the class is created, with that new instance as its first argument, `self`.
    The `__init__` method is similar to a constructor in Java, but it doesn’t really
    *construct* anything; it *initializes* fields of the class. Also unlike those
    in Java and C++, Python classes may only have one `__init__` method. This example
    creates circles with a radius of `1` by default:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在类体中包含一个`__init__`初始化方法来自动初始化实例的字段。每当创建类的实例时，都会运行此函数，并将新实例作为其第一个参数，即`self`。`__init__`方法类似于Java中的构造函数，但它实际上并不*构建*任何东西；它*初始化*类的字段。此外，与Java和C++不同，Python类可能只有一个`__init__`方法。以下示例通过默认半径为`1`创建圆形：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By convention, `self` is always the name of the first argument of `__init__`.
    `self` is set to the newly created circle instance when `__init__` is run ***1***.
    Next, the code uses the class definition. You first create a `Circle` instance
    object ***2***. The next line makes use of the fact that the radius field is already
    initialized ***3***. You can also overwrite the radius field ***4***; as a result,
    the last line prints a different result from the previous `print` statement ***5***.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`self`总是`__init__`的第一个参数的名称。当`__init__`运行时，`self`被设置为新创建的圆实例 ***1***。接下来，代码使用类定义。你首先创建一个`Circle`实例对象
    ***2***。下一行利用了半径字段已经初始化的事实 ***3***。你也可以覆盖半径字段 ***4***；因此，最后一行打印的结果与之前的`print`语句不同
    ***5***。
- en: 'Python also has something more like a constructor: the `__new__` method, which
    is what is called on object creation and returns an uninitialized object. Unless
    you’re subclassing an immutable type, like `str` or `int`, or using a metaclass
    to modify the object creation process, it’s rare to override the existing `__new__`
    method.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有一个类似于构造函数的东西：`__new__`方法，它在对象创建时被调用，并返回一个未初始化的对象。除非你正在子类化不可变类型，如`str`或`int`，或者使用元类来修改对象创建过程，否则很少会覆盖现有的`__new__`方法。
- en: You can do a great deal more by using true OOP, and if you’re not familiar with
    it, I urge you to read up on it. Python’s OOP constructs are the subject of the
    remainder of this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用真正的面向对象编程（OOP），你可以做更多的事情，如果你不熟悉它，我强烈建议你查阅相关资料。Python的OOP构造是本章剩余部分的主题。
- en: 15.2\. Instance variables
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2\. 实例变量
- en: 'Instance variables are the most basic feature of OOP. Take a look at the `Circle`
    class again:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量是OOP中最基本的功能。再次查看`Circle`类：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`radius` is an *instance variable* of `Circle` instances. That is, each instance
    of the `Circle` class has its own copy of `radius`, and the value stored in that
    copy may be different from the values stored in the `radius` variable in other
    instances. In Python, you can create instance variables as necessary by assigning
    to a field of a class instance:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`radius`是`Circle`实例的*实例变量*。也就是说，`Circle`类的每个实例都有自己的`radius`副本，其中存储的值可能与其他实例中存储在`radius`变量中的值不同。在Python中，你可以根据需要通过将值赋给类实例的字段来创建实例变量：'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the variable doesn’t already exist, it’s created automatically, which is
    how `__init__` creates the `radius` variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量尚未存在，它将自动创建，这就是`__init__`创建`radius`变量的方式。
- en: All uses of instance variables, both assignment and access, require *explicit
    mention* of the containing instance—that is, `instance.variable`. A reference
    to `variable` by itself is a reference not to an instance variable, but to a local
    variable in the executing method. This is different from C++ and Java, where instance
    variables are referred to in the same manner as local method function variables.
    I rather like Python’s requirement for explicit mention of the containing instance
    because it clearly distinguishes instance variables from local function variables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实例变量的使用，无论是赋值还是访问，都需要*明确指出*包含的实例——即`instance.variable`。仅通过`variable`引用不是对实例变量的引用，而是对执行方法中的局部变量的引用。这与C++和Java不同，在C++和Java中，实例变量以与局部方法函数变量相同的方式引用。我非常喜欢Python要求明确指出包含实例的要求，因为它清楚地区分了实例变量和局部函数变量。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Instance Variables'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：实例变量
- en: What code would you use to create a `Rectangle` class?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你会用什么代码来创建一个`Rectangle`类？
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 15.3\. Methods
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3\. 方法
- en: 'A *method* is a function associated with a particular class. You’ve already
    seen the special `__init__` method, which is called on a new instance when that
    instance is created. In the following example, you define another method, `area`,
    for the `Circle` class; this method can be used to calculate and return the area
    for any `Circle` instance. Like most user-defined methods, `area` is called with
    a *method invocation syntax* that resembles instance variable access:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是与特定类相关联的函数。你已经看到了特殊的`__init__`方法，当创建新实例时，会调用该方法。在下面的示例中，你为`Circle`类定义了另一个方法，`area`；此方法可以用于计算并返回任何`Circle`实例的面积。像大多数用户定义的方法一样，`area`使用类似于实例变量访问的*方法调用语法*来调用：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Method invocation syntax consists of an instance, followed by a period, followed
    by the method to be invoked on the instance. When a method is called in this way,
    it’s a *bound* method invocation. However, a method *can* also be invoked as an
    *unbound* method by accessing it through its containing class. This practice is
    less convenient and is almost never done, because when a method is invoked in
    this manner, its first argument must be an instance of the class in which that
    method is defined and is less clear:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用语法由一个实例、一个点号以及要调用实例上的方法组成。以这种方式调用方法时，它是一个 *绑定* 方法调用。然而，方法也可以通过其包含的类来作为 *未绑定*
    方法调用。这种做法不太方便，几乎从不这样做，因为以这种方式调用方法时，其第一个参数必须是定义该方法的类的一个实例，并且不太清晰：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Like `__init__`, the `area` method is defined as a function within the body
    of the class definition. The first argument of any method is the instance it was
    invoked by or on, named `self` by convention. In many languages the instance,
    often called `this`, is implicit and is never explicitly passed, but Python’s
    design philosophy prefers to make things explicit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `__init__` 类似，`area` 方法是在类定义体内部定义为一个函数。任何方法的第一个参数都是调用该方法的实例或在其上调用，按照惯例命名为
    `self`。在许多语言中，实例，通常称为 `this`，是隐式的，并且永远不会显式传递，但 Python 的设计哲学更倾向于使事物明确。
- en: 'Methods can be invoked with arguments if the method definitions accept those
    arguments. This version of `Circle` adds an argument to the `__init__` method
    so that you can create circles of a given radius without needing to set the radius
    after a circle is created:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法定义接受这些参数，则可以使用参数调用方法。这个版本的 `Circle` 给 `__init__` 方法添加了一个参数，这样你就可以创建给定半径的圆，而无需在创建圆之后设置半径：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the two uses of `radius` here. `self.radius` is the instance variable called
    `radius`. `radius` by itself is the local function parameter called `radius`.
    The two aren’t the same! In practice, you’d probably call the local function parameter
    something like `r` or `rad` to avoid any possibility of confusion.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里对 `radius` 的两种用法。`self.radius` 是名为 `radius` 的实例变量。`radius` 单独使用时是名为 `radius`
    的局部函数参数。这两个不是同一个！在实际应用中，你可能会将局部函数参数命名为 `r` 或 `rad` 以避免任何混淆的可能性。
- en: 'Using this definition of `Circle`, you can create circles of any radius with
    one call on the `Circle` class. The following creates a `Circle` of radius 5:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `Circle` 的定义，你可以通过一次调用 `Circle` 类来创建任何半径的圆。以下创建了一个半径为 5 的 `Circle`：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All the standard Python function features—default argument values, extra arguments,
    keyword arguments, and so forth—can be used with methods. You could have defined
    the first line of `__init__` to be
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准的 Python 函数特性——默认参数值、额外参数、关键字参数等——都可以与方法一起使用。你本可以将 `__init__` 的第一行定义为
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then calls to `circle` would work with or without an extra argument; `Circle()`
    would return a circle of radius 1, and `Circle(3)` would return a circle of radius
    3.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用 `circle` 时，无论是否有额外的参数都可以工作；`Circle()` 会返回半径为 1 的圆，而 `Circle(3)` 会返回半径为
    3 的圆。
- en: 'There’s nothing magical about method invocation in Python, which can be considered
    to be shorthand for normal function invocation. Given a method invocation `instance.method(arg1,
    arg2, . . .)`, Python transforms it into a normal function call by using the following
    rules:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的方法调用没有魔法，可以被认为是正常函数调用的简写。给定一个方法调用 `instance.method(arg1, arg2, . .
    .)`，Python 通过以下规则将其转换为正常函数调用：
- en: Look for the method name in the instance namespace. If a method has been changed
    or added for this instance, it’s invoked in preference over methods in the class
    or superclass. This lookup is the same sort of lookup discussed in [section 15.4.1](#ch15lev2sec2)
    later in this chapter.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例命名空间中查找方法名。如果为该实例更改或添加了方法，则优先调用类或超类中的方法。这种查找与本章后面 [15.4.1 节](#ch15lev2sec2)
    中讨论的查找类似。
- en: If the method isn’t found in the instance namespace, look up the class type
    `class` of `instance`, and look for the method there. In the previous examples,
    `class` is `Circle`—the type of the instance `c`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在实例命名空间中没有找到方法，查找 `instance` 的类类型 `class`，并在那里查找方法。在先前的例子中，`class` 是 `Circle`——实例
    `c` 的类型。
- en: If the method still isn’t found, look for the method in the superclasses.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果仍然没有找到方法，则在超类中查找方法。
- en: When the method has been found, make a direct call to it as a normal Python
    function, using the `instance` as the first argument of the function and shifting
    all the other arguments in the method invocation one space over to the right.
    So `instance.method(arg1, arg2, . . .)` becomes `class.method (instance, arg1,
    arg2, . . .)`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当找到该方法后，就像调用一个普通的Python函数一样直接调用它，使用`instance`作为函数的第一个参数，并将方法调用中的所有其他参数向右移动一个空格。因此，`instance.method(arg1,
    arg2, . . .)`变为`class.method (instance, arg1, arg2, . . .)`。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Instance variables and Methods'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：实例变量和方法
- en: Update the code for a `Rectangle` class so that you can set the dimensions when
    an instance is created, just as for the `Circle` class above. Also, add an `area()`
    method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Rectangle`类的代码，以便在创建实例时可以设置尺寸，就像上面的`Circle`类一样。还要添加一个`area()`方法。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 15.4\. Class variables
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4. 类变量
- en: A *class variable* is a variable associated with a class, not an instance of
    a class, and is accessible by *all* instances of the class. A class variable might
    be used to keep track of some class-level information, such as how many instances
    of the class have been created at any point. Python provides class variables,
    although using them requires slightly more effort than in most other languages.
    Also, you need to watch out for an interaction between class and instance variables.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量是与类相关联的变量，而不是类的实例，并且可以被类的所有实例访问。类变量可能用于跟踪某些类级别的信息，例如在任何时候创建了多少个类的实例。Python提供了类变量，尽管使用它们比在其他大多数语言中需要付出更多的努力。此外，你需要注意类变量和实例变量之间的交互。
- en: 'A class variable is created by an assignment in the *class* body, not in the
    `__init__` function. After it has been created, it can be seen by all instances
    of the class. You can use a class variable to make a value for `pi` accessible
    to all instances of the `Circle` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量是通过在类体中赋值创建的，而不是在`__init__`函数中。一旦创建，它就可以被类的所有实例看到。你可以使用类变量来使`Circle`类的所有实例都能访问到`pi`的值：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the definition entered, you can type
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输入定义后，你可以输入
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example is exactly how you’d expect a class variable to act; it’s associated
    with and contained in the class that defines it. Notice in this example that you’re
    accessing `Circle.pi` before any circle instances have been created. Obviously,
    `Circle.pi` exists independently of any specific instances of the `Circle` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子正是你期望类变量如何表现；它与定义它的类相关联并包含在其中。注意在这个例子中，你在创建任何圆实例之前就访问了`Circle.pi`。显然，`Circle.pi`独立于`Circle`类的任何特定实例存在。
- en: 'You can also access a class variable from a method of a class, through the
    class name. You do so in the definition of `Circle.area`, where the `area` function
    makes specific reference to `Circle.pi`. In operation, this has the desired effect;
    the correct value for `pi` is obtained from the class and used in the calculation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过类名从类的方法中访问类变量。你在`Circle.area`的定义中这样做，其中`area`函数对`Circle.pi`进行了特定引用。在操作中，这产生了预期的效果；从类中获取了正确的`pi`值并在计算中使用：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may object to hardcoding the name of a class inside that class’s methods.
    You can avoid doing so through use of the special `__class__` attribute, available
    to all Python class instances. This attribute returns the class of which the instance
    is a member, for example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会反对在类的方法中硬编码类的名称。你可以通过使用对所有Python类实例都可用的高级`__class__`属性来避免这样做。此属性返回实例所属的类，例如：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The class named `Circle` is represented internally by an abstract data structure,
    and that data structure is exactly what is obtained from the `__class__` attribute
    of `c`, an instance of the `Circle` class. This example lets you obtain the value
    of `Circle.pi` from `c` without ever explicitly referring to the `Circle` class
    name:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 内部表示名为`Circle`的类是通过一个抽象数据结构实现的，而这个数据结构正是从`Circle`类的实例`c`的`__class__`属性中获得的。这个例子让你能够从`c`中获取`Circle.pi`的值，而不需要显式地引用`Circle`类的名称：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You could use this code internally in the `area` method to get rid of the explicit
    reference to the `Circle` class; replace `Circle.pi` with `self.__class__.pi`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`area`方法内部使用此代码，以消除对`Circle`类的显式引用；将`Circle.pi`替换为`self.__class__.pi`。
- en: 15.4.1\. An oddity with class variables
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.4.1. 类变量的一个特性
- en: There’s a bit of an oddity with class variables that can trip you up if you
    aren’t aware of it. When Python is looking up an instance variable, if it can’t
    find an instance variable of that name, it tries to find and return the value
    in a class variable of the same name. Only if it can’t find an appropriate class
    variable will Python signal an error. Class variables make it efficient to implement
    default values for instance variables; just create a class variable with the same
    name and appropriate default value, and avoid the time and memory overhead of
    initializing that instance variable every time a class instance is created. But
    this also makes it easy to inadvertently refer to an instance variable rather
    than a class variable without signaling an error. In this section, I look at how
    class variables operate in conjunction with the previous example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量有一些奇怪的特性，如果你不知道，可能会让你感到困惑。当 Python 查找实例变量时，如果找不到该名称的实例变量，它会尝试查找并返回同名类变量中的值。只有当它找不到合适的类变量时，Python
    才会发出错误信号。类变量使得为实例变量实现默认值变得高效；只需创建一个具有相同名称和适当默认值的类变量，并避免每次创建类实例时初始化该实例变量的时间和内存开销。但这也使得在不发出错误信号的情况下，意外地引用实例变量而不是类变量变得容易。在本节中，我将探讨类变量如何与前面的示例一起工作。
- en: 'First, you can refer to the variable `c.pi`, even though `c` doesn’t have an
    associated instance variable named `pi`. Python first tries to look for such an
    instance variable; when it can’t find an instance variable, Python looks for and
    finds a class variable `pi` in `Circle`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以参考变量 `c.pi`，即使 `c` 没有名为 `pi` 的关联实例变量。Python 首先尝试查找这样的实例变量；当它找不到实例变量时，Python
    会查找并找到 `Circle` 中的类变量 `pi`：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This result may or may not be what you want. This technique is convenient but
    can be prone to error, so be careful.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结果可能不是你想要的。这种技术很方便，但容易出错，所以请小心。
- en: 'Now, what happens if you attempt to use `c.pi` as a true class variable by
    changing it from one instance with the intention that all instances should see
    the change? Again, you use the earlier definition for `Circle`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试将 `c.pi` 作为真正的类变量使用，通过从一个实例更改它，意图让所有实例都能看到这个变化，会发生什么？再次，你使用之前定义的 `Circle`：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example doesn’t work as it would for a true class variable; `c1` now has
    its own copy of `pi`, distinct from the `Circle.pi` accessed by `c2`. This happens
    because the assignment to `c1.pi` *creates* an instance variable in `c1`; it doesn’t
    affect the class variable `Circle.pi` in any way. Subsequent lookups of `c1.pi`
    return the value in that instance variable, whereas subsequent lookups of `c2.pi`
    look for an instance variable `pi` in `c2`, fail to find it, and resort to returning
    the value of the class variable `Circle.pi`. If you want to change the value of
    a class variable, access it through the class name, not through the instance variable
    `self`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子不会像真正的类变量那样工作；`c1` 现在有自己的 `pi` 复制，与通过 `c2` 访问的 `Circle.pi` 区分开来。这是因为对 `c1.pi`
    的赋值在 `c1` 中 *创建* 了一个实例变量；它以任何方式都不会影响类变量 `Circle.pi`。随后的 `c1.pi` 查找返回该实例变量的值，而随后的
    `c2.pi` 查找 `c2` 中的实例变量 `pi`，找不到它，然后回退到返回类变量 `Circle.pi` 的值。如果你想更改类变量的值，通过类名访问它，而不是通过实例变量
    `self`。
- en: 15.5\. Static methods and class methods
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5\. 静态方法和类方法
- en: Python classes can also have methods that correspond explicitly to static methods
    in a language such as Java. In addition, Python has *class* methods, which are
    a bit more advanced.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python 类也可以有与 Java 等语言中的静态方法相对应的方法。此外，Python 还有 *类* 方法，这要复杂一些。
- en: 15.5.1\. Static methods
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.1\. 静态方法
- en: Just as in Java, you can invoke static methods even though no instance of that
    class has been created, although you *can* call them by using a class instance.
    To create a static method, use the `@staticmethod` decorator, as shown here.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Java 中一样，即使没有创建该类的实例，你也可以调用静态方法，尽管你可以通过类实例来调用它们。要创建静态方法，使用 `@staticmethod`
    装饰器，如下所示。
- en: Listing 15.1\. File circle.py
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.1\. 文件 circle.py
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Class variable containing list of all circles that have been created**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含所有已创建圆的列表的类变量**'
- en: '***2* When an instance is initialized, it adds itself to the all_circles list.**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当实例初始化时，它会将自己添加到 all_circles 列表中。**'
- en: 'Now interactively type the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在交互式地输入以下内容：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also notice that documentation strings are used. In a real module, you’d probably
    put in more informative strings, indicating in the class docstring what methods
    are available and including usage information in the method docstrings:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，使用了文档字符串。在实际模块中，你可能会放入更多信息性的字符串，在类的文档字符串中说明可用的方法，并在方法的文档字符串中包含使用信息：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 15.5.2\. Class methods
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.2\. 类方法
- en: Class methods are similar to static methods in that they can be invoked before
    an object of the class has been instantiated or by using an instance of the class.
    But class methods are implicitly passed the class they belong to as their first
    parameter, so you can code them more simply, as here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法与静态方法类似，可以在创建类的对象之前调用，或者通过使用类的实例来调用。但类方法隐式地将它们所属的类作为第一个参数传递，因此你可以更简单地编写它们，如下所示。
- en: Listing 15.2\. File circle_cm.py
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.2\. 文件 circle_cm.py
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Variable containing list of all circles that have been created**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含所有已创建圆的列表的变量**'
- en: The `@classmethod` decorator is used before the method `def` ***2***. The class
    parameter is traditionally `cls` ***3***. You can use `cls` instead of `self.__class__`
    ***4***.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `def` 前使用 `@classmethod` 装饰器 ***2***。类参数传统上是 `cls` ***3***。你可以使用 `cls` 而不是
    `self.__class__` ***4***。
- en: By using a class method instead of a static method, you don’t have to hardcode
    the class name into `total_area`. As a result, any subclasses of `Circle` can
    still call `total_area` and refer to their own members, not those in `Circle`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类方法而不是静态方法，你不必将类名硬编码到 `total_area` 中。因此，`Circle` 的任何子类都可以调用 `total_area` 并引用它们自己的成员，而不是
    `Circle` 中的成员。
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Class methods'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：类方法
- en: Write a class method similar to `total_area()` that returns the total circumference
    of all circles.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个类似于 `total_area()` 的类方法，返回所有圆的总周长。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 15.6\. Inheritance
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.6\. 继承
- en: Inheritance in Python is easier and more flexible than inheritance in compiled
    languages such as Java and C++ because the dynamic nature of Python doesn’t force
    as many restrictions on the language.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的继承比编译语言（如 Java 和 C++）中的继承更容易、更灵活，因为 Python 的动态特性不会对语言施加太多限制。
- en: 'To see how inheritance is used in Python, start with the `Circle` class discussed
    earlier in this chapter, and generalize. You might want to define an additional
    class for squares:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Python 中如何使用继承，可以从本章前面讨论的 `Circle` 类开始，并进行泛化。你可能还想定义一个额外的类用于正方形：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Length of any side of square**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 正方形的任意一边长度**'
- en: 'Now, if you want to use these classes in a drawing program, they must define
    some sense of where on the drawing surface each instance is. You can do so by
    defining an `x` coordinate and a `y` coordinate in each instance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想在绘图程序中使用这些类，它们必须定义每个实例在绘图表面上的位置。你可以通过在每个实例中定义 `x` 坐标和 `y` 坐标来实现这一点：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This approach works but results in a good deal of repetitive code as you expand
    the number of shape classes, because you presumably want each shape to have this
    concept of position. No doubt you know where I’m going here; this situation is
    a standard one for using inheritance in an object-oriented language. Instead of
    defining the `x` and `y` variables in each shape class, you can abstract them
    out into a general `Shape` class and have each class defining a specific shape
    inherit from that general class. In Python, that technique looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但随着形状类数量的增加，会产生大量重复的代码，因为你可能希望每个形状都有这种位置的概念。毫无疑问，你知道我在这里想什么；这种情况是面向对象语言中使用继承的标准情况。你不必在每个形状类中定义
    `x` 和 `y` 变量，可以将它们抽象成一个通用的 `Shape` 类，并让每个定义特定形状的类从这个通用类继承。在 Python 中，这种技术看起来是这样的：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Says Square inherits from Shape**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 说明 Square 继承自 Shape**'
- en: '***2* Must call __init__ method of Shape**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 必须调用 Shape 的 __init__ 方法**'
- en: '***3* Says Circle inherits from Shape**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 说明 Circle 继承自 Shape**'
- en: '***4* Must call __init__ method of Shape**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 必须调用 Shape 的 __init__ 方法**'
- en: There are (generally) two requirements in using an inherited class in Python,
    both of which you can see in the bolded code in the `Circle` and `Square` classes.
    The first requirement is defining the inheritance hierarchy, which you do by giving
    the classes inherited from, in parentheses, immediately after the name of the
    class being defined with the `class` keyword. In the previous code, `Circle` and
    `Square` both inherit from `Shape`. The second and more subtle element is the
    necessity to explicitly call the `__init__` method of inherited classes. Python
    doesn’t automatically do this for you, but you can use the `super` function to
    have Python figure out which inherited class to use. This task is accomplished
    in the example code by the `super().__init__(x,y)` lines. This code calls the
    `Shape` initialization function with the instance being initialized and the appropriate
    arguments. Otherwise, in the example, instances of `Circle` and `Square` wouldn’t
    have their `x` and `y` instance variables set.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中使用继承类时，通常有两个要求，这两个要求都可以在 `Circle` 和 `Square` 类中加粗的代码中看到。第一个要求是定义继承层次结构，这是通过在
    `class` 关键字定义类名后立即给出继承的类来完成的。在上面的代码中，`Circle` 和 `Square` 都继承自 `Shape`。第二个且更为微妙的要求是必须显式调用继承类的
    `__init__` 方法。Python 不会自动为你做这件事，但你可以使用 `super` 函数让 Python 确定使用哪个继承类。这个任务在示例代码中是通过
    `super().__init__(x,y)` 行完成的。这段代码调用 `Shape` 初始化函数，并传递正在初始化的实例和适当的参数。否则，在示例中，`Circle`
    和 `Square` 的实例将不会设置它们的 `x` 和 `y` 实例变量。
- en: Instead of using `super`, you could call `Shape`’s `__init__` by explicitly
    naming the inherited class using `Shape.__init__(self, x, y)`, which would also
    call the `Shape` initialization function with the instance being initialized.
    This technique wouldn’t be as flexible in the long run because it hardcodes the
    inherited class’s name, which could be a problem later if the design and the inheritance
    hierarchy change. On the other hand, the use of `super` can be tricky in more
    complex cases. Because the two methods don’t exactly mix well, clearly document
    whichever approach you use in your code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `super` 不同，你可以通过显式地使用 `Shape.__init__(self, x, y)` 来调用 `Shape` 的 `__init__`
    方法，这样也会调用正在初始化的实例的 `Shape` 初始化函数。然而，这种技术在长期使用中可能不够灵活，因为它硬编码了继承类的名称，如果设计和继承层次结构发生变化，这可能会成为问题。另一方面，在更复杂的情况下使用
    `super` 可能会遇到困难。由于这两种方法并不完全兼容，因此请在代码中清楚地记录你使用的方法。
- en: Inheritance also comes into effect when you attempt to use a method that isn’t
    defined in the base classes but is defined in the superclass. To see this effect,
    define another method in the `Shape` class called `move`, which moves a shape
    by a given displacement. This method modifies the `x` and `y` coordinates of the
    shape by an amount determined by arguments to the method. The definition for `Shape`
    now becomes
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用在基类中未定义但在超类中定义的方法时，继承也会生效。为了看到这个效果，在 `Shape` 类中定义另一个名为 `move` 的方法，该方法通过给定位移来移动形状。这个方法通过方法参数确定的数量修改形状的
    `x` 和 `y` 坐标。现在 `Shape` 的定义变为
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you enter this definition for `Shape` and the previous definitions for `Circle`
    and `Square`, you can engage in the following interactive session:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入 `Shape` 的这个定义以及 `Circle` 和 `Square` 的先前定义，你可以进行以下交互式会话：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you try this code in an interactive session, be sure to reenter the `Circle`
    class after the redefinition of the `Shape` class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个交互式会话中尝试这段代码，请确保在重新定义 `Shape` 类之后重新进入 `Circle` 类。
- en: The `Circle` class in the example didn’t define a `move` method immediately
    within itself, but because it inherits from a class that implements `move`, all
    instances of `Circle` can make use of `move`. In more traditional OOP terms, you
    could say that all Python methods are virtual—that is, if a method doesn’t exist
    in the current class, the list of superclasses is searched for the method, and
    the first one found is used.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的 `Circle` 类没有立即在其自身内部定义 `move` 方法，但由于它继承自实现了 `move` 的类，所以 `Circle` 的所有实例都可以使用
    `move` 方法。在更传统的面向对象术语中，可以说所有 Python 方法都是虚拟的——也就是说，如果当前类中没有方法，则会搜索超类列表以找到该方法，并使用找到的第一个。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Inheritance'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试以下方法：继承
- en: Rewrite the code for a `Rectangle` class to inherit from `Shape`. Because squares
    and rectangles are related, would it make sense to inherit one from the other?
    If so, which would be the base class, and which would inherit?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Rectangle` 类的代码重写为从 `Shape` 继承。由于正方形和矩形是相关的，从其中一个继承另一个是否有意义？如果有，哪个应该是基类，哪个应该继承？
- en: How would you write the code to add an `area()` method for the `Square` class?
    Should the `area` method be moved into the base `Shape` class and inherited by
    circle, square, and rectangle? If so, what issues would result?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '你将如何编写代码为 `Square` 类添加一个 `area()` 方法？是否应该将 `area` 方法移动到基类 `Shape` 中，并由圆、正方形和矩形继承？如果是这样，会产生什么问题？ '
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 15.7\. Inheritance with class and instance variables
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7. 类和实例变量的继承
- en: Inheritance allows an instance to inherit attributes of the class. Instance
    variables are associated with object instances, and only one instance variable
    of a given name exists for a given instance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许实例继承类的属性。实例变量与对象实例相关联，并且对于给定的实例，只有一个具有给定名称的实例变量。
- en: Consider the following example. Using these class definitions,
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。使用这些类定义，
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'execute the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The object `c` in this example is an instance of class `C`. `C` inherits from
    `P` but `c` doesn’t inherit from some invisible instance of class `P`. It inherits
    methods and class variables directly from `P`. Because there is only one instance
    (`c`), any reference to the instance variable `x` in a method invocation on `c`
    must refer to `c.x`. This is true regardless of which class defines the method
    being invoked on `c`. As you can see, when they’re invoked on `c`, both `set_p`
    and `print_p`, defined in class `P`, and refer to the same variable, which is
    referred to by `set_c` and `print_c` when they’re invoked on `c`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对象 `c` 是类 `C` 的一个实例。`C` 从 `P` 继承，但 `c` 并不是从某个不可见的 `P` 类实例继承。它直接从 `P`
    继承方法和类变量。因为只有一个实例（`c`），在 `c` 的方法调用中对实例变量 `x` 的任何引用都必须指向 `c.x`。这适用于调用 `c` 上任何类定义的方法。正如你所看到的，当在
    `c` 上调用时，`set_p` 和 `print_p`（在类 `P` 中定义）都引用相同的变量，当在 `c` 上调用时，`set_c` 和 `print_c`
    引用相同的变量。
- en: In general, this behavior is what is desired for instance variables, because
    it makes sense that references to instance variables of the same name should refer
    to the same variable. Occasionally, somewhat different behavior is desired, which
    you can achieve by using private variables (see [section 15.9](#ch15lev1sec9)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是对实例变量的期望行为，因为同名的实例变量应该引用相同的变量是有意义的。偶尔，你可能会希望有稍微不同的行为，你可以通过使用私有变量来实现（见[第15.9节](#ch15lev1sec9)）。
- en: 'Class variables are inherited, but you should take care to avoid name clashes
    and be aware of a generalization of the behavior you saw in the subsection on
    class variables. In the example, a class variable `z` is defined for the superclass
    `P` and can be accessed in three ways: through the instance `c`, through the derived
    class `C`, or directly through the superclass `P`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量是继承的，但你应小心避免名称冲突，并注意你在类变量子节中看到的行为的泛化。在示例中，为超类 `P` 定义了一个类变量 `z`，可以通过三种方式访问它：通过实例
    `c`，通过派生类 `C`，或者直接通过超类 `P`：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But if you try setting the class variable `z` through the class `C`, a new
    class variable is created for the class `C`. This result has no effect on `P`’s
    class variable itself (as accessed through `P`). But future accesses through the
    class `C` or its instance `c` will see this new variable rather than the original:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你尝试通过类 `C` 设置类变量 `z`，将为类 `C` 创建一个新的类变量。这个结果对 `P` 的类变量本身（通过 `P` 访问）没有影响。但未来通过类
    `C` 或其实例 `c` 的访问将看到这个新变量而不是原始变量：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similarly, if you try setting `z` through the instance `c`, a new instance
    variable is created, and you end up with three different variables:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你尝试通过实例 `c` 设置 `z`，将创建一个新的实例变量，你最终会有三个不同的变量：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '15.8\. Recap: Basics of Python classes'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.8. 回顾：Python 类的基础
- en: The points I’ve discussed so far are the basics of using classes and objects
    in Python. Before I go any farther, I’ll bring the basics together in a single
    example. In this section, you create a couple of classes with the features discussed
    earlier, and then you see how those features behave.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我到目前为止讨论的点是在 Python 中使用类和对象的基础。在我继续之前，我将这些基础知识汇总到一个单独的例子中。在本节中，你将创建几个具有前面讨论的功能的类，然后你将看到这些功能是如何表现的。
- en: 'First, create a base class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个基类：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* __init__ method takes instance (self) and two parameters**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `__init__` 方法接受实例（self）和两个参数**'
- en: '***2* Instance variables accessed through self.**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过 `self` 访问实例变量。**'
- en: '***3* move method takes instance (self) and two parameters**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* `move` 方法接受实例（self）和两个参数**'
- en: '***4* Instance variable set inside move method**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在 `move` 方法中设置的实例变量**'
- en: 'Next, create a subclass that inherits from the base class `Shape`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个从基类 `Shape` 继承的子类：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Circle class inherits from Shape class**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Circle 类继承自 Shape 类**'
- en: '***2* pi and all_circles are class variables for Circle.**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* pi 和 all_circles 是 Circle 的类变量。**'
- en: '***3* Circle’s __init__ takes instance (self) and 3 parameters, all with defaults**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Circle 的 __init__ 方法接受实例（self）和 3 个参数，它们都有默认值**'
- en: '***4* Circle’s __init__ uses super() to call Shape’s __init__**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Circle 的 __init__ 方法使用 super() 调用 Shape 的 __init__**'
- en: '***5* In the __init__ method the instance adds itself to all_circles list**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在 __init__ 方法中，实例将自己添加到 all_circles 列表中**'
- en: '***6* total_area is a class method and takes the class itself (cls) as parameter.**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* total_area 是一个类方法，它接受类本身（cls）作为参数。**'
- en: '***7* Uses the cls parameter to access static method circle_area**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用 cls 参数访问 Circle 的静态方法 circle_area**'
- en: '***8* circle_area is a static method that doesn’t get self or cls as parameters.**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* circle_area 是一个静态方法，它不接收 self 或 cls 作为参数。**'
- en: '***9* Accesses class variable pi; could also use __class__.pi**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 访问类变量 pi；也可以使用 __class__.pi**'
- en: 'Now you can create some instances of the `Circle` class and put them through
    their paces. Because `Circle`’s `__init__` method has default parameters, you
    can create a `Circle` without giving any parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建一些 `Circle` 类的实例并将它们进行测试。因为 `Circle` 的 `__init__` 方法有默认参数，所以您可以在不提供任何参数的情况下创建一个
    `Circle`：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you do give parameters, they are used to set the instance’s values:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实提供了参数，它们将用于设置实例的值：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you call the `move()` method, Python doesn’t find a `move()` in the `Circle`
    class, so it moves up the inheritance hierarchy and uses `Shape`’s `move()` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您调用 `move()` 方法，Python 在 `Circle` 类中找不到 `move()`，因此它会沿着继承层次结构向上移动并使用 `Shape`
    的 `move()` 方法：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Also, because part of what the `__init__` method does is add each instance
    to a list that is a class variable, you get the `Circle` instances:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为 `__init__` 方法的一部分是将每个实例添加到一个列表中，该列表是类变量，所以您会得到 `Circle` 实例：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also call the `Circle` class’s `total_area()` class method, either
    through the class itself or through an instance:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过类本身或通过一个实例来调用 `Circle` 类的 `total_area()` 类方法：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, you can call the static method `circle_area()`, again either via the
    class itself or an instance. As a static method, `circle_area` doesn’t get passed
    the instance or the class, and it behaves more like an independent function that’s
    inside the class’s namespace. In fact, quite often, static methods are used to
    bundle utility functions with a class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以再次通过类本身或一个实例调用静态方法 `circle_area()`。作为一个静态方法，`circle_area` 不会传递实例或类，它更像是一个位于类命名空间内的独立函数。事实上，静态方法通常用于将实用函数捆绑到类中：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These examples show the basic behavior of classes in Python. Now that you’ve
    got the basics of classes down, you can move on to more advanced topics.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了 Python 中类的基本行为。现在您已经掌握了类的基础知识，可以继续学习更高级的主题。
- en: 15.9\. Private variables and private methods
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.9\. 私有变量和私有方法
- en: 'A *private variable* or *private method* is one that can’t be seen outside
    the methods of the class in which it’s defined. Private variables and methods
    are useful for two reasons: They enhance security and reliability by selectively
    denying access to important or delicate parts of an object’s implementation, and
    they prevent name clashes that can arise from the use of inheritance. A class
    may define a private variable and inherit from a class that defines a private
    variable of the same name, but this doesn’t cause a problem, because the fact
    that the variables are private ensures that separate copies of them are kept.
    Private variables make it easier to read code, because they explicitly indicate
    what’s used only internally in a class. Anything else is the class’s interface.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*私有变量* 或 *私有方法* 是指在定义它的类的其他方法中不可见的变量或方法。私有变量和方法有两个用途：它们通过选择性地拒绝访问对象实现的重要或脆弱部分来增强安全性和可靠性，并防止由于继承的使用而出现的名称冲突。一个类可以定义一个私有变量并从定义了具有相同名称的私有变量的类继承，但这不会引起问题，因为变量是私有的这一事实确保了它们有独立的副本。私有变量使代码更容易阅读，因为它们明确指出仅在类内部使用的部分。其他任何东西都是类的接口。'
- en: Most languages that define private variables do so through the use of the keyword
    “private” or something similar. The convention in Python is simpler, and it also
    makes it easier to immediately see what is private and what isn’t. Any method
    or instance variable whose name begins—but doesn’t end—with a *double underscore*
    (`__`) is private; anything else isn’t private.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数定义私有变量的语言都是通过使用关键字“private”或类似的东西来实现的。Python 的约定更简单，也更易于立即看出什么是私有的，什么不是。任何以双下划线
    (`__`) 开头但不是以双下划线结尾的方法或实例变量都是私有的；其他都不是私有的。
- en: 'As an example, consider the following class definition:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下类定义：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Defines __y as private by using leading double underscores**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用前导双下划线将 `y` 定义为私有**'
- en: 'Using this definition, create an instance of the class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，创建一个类的实例：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`x` isn’t a private variable, so it’s directly accessible:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 不是一个私有变量，所以它是直接可访问的：'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`__y` is a private variable. Trying to access it directly raises an error:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`__y` 是一个私有变量。直接尝试访问它将引发错误：'
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `print_y` method isn’t private, and because it’s in the `Mine` class, it
    can access `__y` and print it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_y` 方法不是私有的，因为它在 `Mine` 类中，所以它可以访问 `__y` 并打印它：'
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, you should note that the mechanism used to provide privacy *mangles*
    the name of private variables and private methods when the code is compiled to
    bytecode. What specifically happens is that `_classname` is prepended to the variable
    name:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该注意，用于提供隐私的机制在代码编译为字节码时会将私有变量和私有方法的名字进行混淆。具体发生的情况是，`_classname` 被添加到变量名之前：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The purpose is to prevent any accidental accesses. If someone wanted to, he
    could deliberately simulate the mangling and access the value. But performing
    the mangling in this easily readable form makes debugging easy.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是防止任何意外的访问。如果有人想的话，他可以故意模拟混淆并访问值。但以这种易于阅读的形式进行混淆使得调试变得容易。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Private instance variables'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：私有实例变量
- en: Modify the `Rectangle` class’s code to make the dimension variables private.
    What restriction will this modification impose on using the class?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `Rectangle` 类的代码以使尺寸变量私有。这种修改会对使用该类施加什么限制？
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 15.10\. Using @property for more flexible instance variables
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.10\. 使用 @property 来实现更灵活的实例变量
- en: Python allows you as the programmer to access instance variables directly, without
    the extra machinery of the getter and setter methods often used in Java and other
    object-oriented languages. This lack of getters and setters makes writing Python
    classes cleaner and easier, but in some situations, using getter and setter methods
    can be handy. Suppose that you want a value before you put it into an instance
    variable or where it would be handy to figure out an attribute’s value on the
    fly. In both cases, getter and setter methods would do the job, but at the cost
    of losing Python’s easy instance-variable access.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你作为程序员直接访问实例变量，而不需要像 Java 和其他面向对象语言中常用的 getter 和 setter 方法那样的额外机制。这种缺乏
    getter 和 setter 方法使得编写 Python 类更加简洁和容易，但在某些情况下，使用 getter 和 setter 方法可能很有用。假设你需要在将值放入实例变量之前获取该值，或者需要即时确定属性的值。在这两种情况下，getter
    和 setter 方法都会完成工作，但代价是失去了 Python 的简单实例变量访问。
- en: The answer is to use a property. A *property* combines the ability to pass access
    to an instance variable through methods like getters and setters and the straightforward
    access to instance variables through dot notation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用属性。属性结合了通过像 getters 和 setters 这样的方法传递对实例变量的访问权限的能力，以及通过点符号进行实例变量的直接访问。
- en: 'To create a property, you use the property decorator with a method that has
    the property’s name:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个属性，你使用 property 装饰器与一个具有属性名的方法：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Without a setter, such a property is read-only. To change the property, you
    need to add a setter:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 没有设置器，这样的属性是只读的。要更改属性，你需要添加一个设置器：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now you can use standard dot notation to both get and set the property `temp`.
    Notice that the name of the method remains the same, but the decorator changes
    to the property name (`temp`, in this case), plus `.setter` indicates that a setter
    for the `temp` property is being defined:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用标准的点符号来获取和设置属性 `temp`。注意，方法名保持不变，但装饰器改为属性名（在这种情况下是 `temp`），加上 `.setter`
    表示正在定义 `temp` 属性的设置器：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `0` in `_temp_fahr` is converted to centigrade before it’s returned ***1***.
    The `34` is converted back to Fahrenheit by the setter ***2***.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`_temp_fahr` 中的 `0` 在返回之前转换为摄氏度 ***1***。`34` 通过设置器 ***2*** 转换回华氏度。'
- en: One big advantage of Python’s ability to add properties is that you can do initial
    development with plain-old instance variables and then seamlessly change to properties
    whenever and wherever you need to without changing any client code. The access
    is still the same, using dot notation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Python 能够添加属性的一大优点是，你可以在使用普通的实例变量进行初始开发后，无缝地更改到属性，无论何时何地，而无需更改任何客户端代码。访问方式仍然是相同的，使用点符号。
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Properties'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：属性
- en: Update the dimensions of the `Rectangle` class to be properties with getters
    and setters that don’t allow negative sizes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Rectangle` 类的维度更新为具有获取器和设置器的属性，这些获取器和设置器不允许负尺寸。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 15.11\. Scoping rules and namespaces for class instances
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.11\. 类实例的作用域规则和命名空间
- en: Now you have all the pieces to put together a picture of the scoping rules and
    namespaces for a class instance.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了拼凑出类实例的作用域规则和命名空间图画的全部部件。
- en: 'When you’re in a method of a class, you have direct access to the *local namespace*
    (parameters and variables declared in the method), the *global namespace* (functions
    and variables declared at the module level), and the *built-in namespace* (built-in
    functions and built-in exceptions). These three namespaces are searched in the
    following order: local, global, and built-in (see [figure 15.1](#ch15fig01)).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类的某个方法中时，你可以直接访问局部命名空间（在方法中声明的参数和变量）、全局命名空间（在模块级别声明的函数和变量），以及内置命名空间（内置函数和内置异常）。这三个命名空间按以下顺序搜索：局部、全局和内置（见[图
    15.1](#ch15fig01)）。
- en: Figure 15.1\. Direct namespaces
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.1\. 直接命名空间
- en: '![](images/15fig01.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](images/15fig01.jpg)'
- en: You also have access through the `self` variable to the *instance’s namespace*
    (instance variables, private instance variables, and superclass instance variables),
    its *class’s namespace* (methods, class variables, private methods, and private
    class variables), and its *superclass’s namespace* (superclass methods and superclass
    class variables). These three namespaces are searched in the order instance, class,
    and then superclass (see [figure 15.2](#ch15fig02)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 `self` 变量访问实例的命名空间（实例变量、私有实例变量和超类实例变量）、其类的命名空间（方法、类变量、私有方法和私有类变量），以及其超类的命名空间（超类方法和超类类变量）。这三个命名空间按以下顺序搜索：实例、类和超类（见[图
    15.2](#ch15fig02)）。
- en: Figure 15.2\. `self` variable namespaces
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.2\. `self` 变量命名空间
- en: '![](images/15fig02_alt.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](images/15fig02_alt.jpg)'
- en: Private superclass instance variables, private superclass methods, and private
    superclass class variables can’t be accessed by using `self`. A class is able
    to hide these names from its children.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `self` 无法访问私有超类实例变量、私有超类方法和私有超类类变量。一个类能够将其子类隐藏这些名称。
- en: The module in [listing 15.3](#ch15ex03) puts these two examples together to
    concretely demonstrate what can be accessed from within a method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15.3](#ch15ex03) 中的模块将这些两个例子结合起来，具体演示了在方法内部可以访问的内容。'
- en: Listing 15.3\. File cs.py
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.3\. 文件 cs.py
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Parameter**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 参数***'
- en: '***2* Local variable**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 局部变量***'
- en: '***3* Module variable**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 模块变量***'
- en: '***4* Module function**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 模块函数***'
- en: '***5* Instance variable**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 实例变量***'
- en: '***6* Private instance variable**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 私有实例变量***'
- en: '***7* Superclass instance variable**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 超类实例变量***'
- en: '***8* Class variable**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 类变量***'
- en: '***9* Method**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 方法***'
- en: '***10* Private class variable**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 私有类变量***'
- en: '***11* Private method**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 私有方法***'
- en: '***12* Superclass method**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12* 超类方法***'
- en: '***13* Superclass class variable through instance**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***13* 通过实例访问超类类变量***'
- en: This output is considerable, so we’ll look at it in pieces.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出相当多，所以我们将分部分来看。
- en: 'In the first part, class `C''`s method `m`’s local namespace contains the parameters
    `self` (which is the instance variable) and `p` along with the local variable
    `lv` (all of which can be accessed directly):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，类 `C'` 的方法 `m` 的局部命名空间包含参数 `self`（它是实例变量）和 `p`，以及局部变量 `lv`（所有这些都可以直接访问）：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, method `m`’s global namespace contains the module variable `mv` and the
    module function `mf` (which, as described in a previous section, you can use to
    provide a class method functionality). There are also the classes defined in the
    module (the class `C` and the superclass `SC`). All these classes can be directly
    accessed:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，方法 `m` 的全局命名空间包含模块变量 `mv` 和模块函数 `mf`（正如前一个章节所述，你可以使用它来提供类方法功能）。还包括模块中定义的类（类
    `C` 和超类 `SC`）。所有这些类都可以直接访问：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Instance `C`’s namespace contains instance variable `iv` and the superclass’s
    instance variable `siv` (which, as described in a previous section, is no different
    from the regular instance variable). It also has the mangled name of private instance
    variable `__piv` (which you can access through `self`) and the mangled name of
    the superclass’s private instance variable `__psiv` (which you can’t access):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实例`C`的命名空间包含实例变量`iv`和超类的实例变量`siv`（正如前一部分所描述的，它与常规实例变量没有区别）。它还包括私有实例变量`__piv`的混淆名称（您可以通过`self`访问它）和超类私有实例变量`__psiv`的混淆名称（您无法访问它）：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Class `C`’s namespace contains the class variable `cv` and the mangled name
    of the private class variable `__pcv`. Both can be accessed through `self`, but
    to assign to them, you need to use class `C`. Class `C` also has the class’s two
    methods `m` and `m2`, along with the mangled name of the private method `__pm`
    (which can be accessed through `self`):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 类`C`的命名空间包含类变量`cv`和私有类变量`__pcv`的混淆名称。两者都可以通过`self`访问，但要对它们进行赋值，您需要使用类`C`。类`C`还有类的两个方法`m`和`m2`，以及私有方法`__pm`的混淆名称（可以通过`self`访问）：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, superclass `SC`’s namespace contains superclass class variable `scv`
    (which can be accessed through `self`, but to assign to it, you need to use the
    superclass `SC`) and superclass method `sm`. It also contains the mangled names
    of private superclass method `__spm` and private superclass class variable `__pscv`,
    neither of which can be accessed through `self`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，超类`SC`的命名空间包含超类类变量`scv`（可以通过`self`访问，但要对它进行赋值，您需要使用超类`SC`）和超类方法`sm`。它还包括私有超类方法`__spm`和私有超类类变量`__pscv`的混淆名称，这两个名称都无法通过`self`访问：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This example is a rather full one to decipher at first. You can use it as a
    reference or a base for your own exploration. As with most other concepts in Python,
    you can build a solid understanding of what’s going on by playing around with
    a few simplified examples.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子一开始可能相当复杂，难以理解。您可以用它作为参考或您自己探索的基础。与Python中的大多数其他概念一样，您可以通过玩一些简化的例子来建立对正在发生的事情的稳固理解。
- en: 15.12\. Destructors and memory management
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.12\. 析构函数和内存管理
- en: You’ve already seen class initializers (the `__init__` methods). A destructor
    can be defined for a class as well. But unlike in C++, creating and calling a
    destructor isn’t necessary to ensure that the memory used by your instance is
    freed. Python provides automatic memory management through a reference-counting
    mechanism. That is, it keeps track of the number of references to your instance;
    when this number reaches zero, the memory used by your instance is reclaimed,
    and any Python objects referenced by your instance have their reference counts
    decremented by one. *You almost never need to define a destructor*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了类初始化器（`__init__`方法）。可以为类定义析构函数。但与C++不同，创建和调用析构函数并不是确保释放实例使用的内存所必需的。Python通过引用计数机制提供自动内存管理。也就是说，它跟踪对实例的引用数量；当这个数量达到零时，实例使用的内存被回收，并且任何由实例引用的Python对象都将它们的引用计数减一。*您几乎不需要定义析构函数*。
- en: You may occasionally encounter a situation in which you need to deallocate an
    external resource explicitly when an object is removed. In such a situation, the
    best practice is to use a context manager, as discussed in [chapter 14](kindle_split_025.html#ch14).
    As mentioned there, you can use the `contextlib` module from the standard library
    to create a custom context manager for your situation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会偶尔遇到需要在对象被移除时显式地释放外部资源的情况。在这种情况下，最佳实践是使用上下文管理器，如第14章所述。如前所述，您可以使用标准库中的`contextlib`模块为您的情况创建自定义上下文管理器。
- en: 15.13\. Multiple inheritance
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.13\. 多重继承
- en: Compiled languages place severe restrictions on the use of *multiple inheritance*—the
    ability of objects to inherit data and behavior from more than one parent class.
    The rules for using multiple inheritance in C++, for example, are so complex that
    many people avoid using it. In Java, multiple inheritance is disallowed, although
    Java does have the interface mechanism.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编译型语言对*多重继承*的使用施加了严格的限制——对象从多个父类继承数据和行为的特性。例如，在C++中使用多重继承的规则非常复杂，以至于许多人避免使用它。在Java中，多重继承是不允许的，尽管Java确实有接口机制。
- en: 'Python places no such restrictions on multiple inheritance. A class can inherit
    from any number of parent classes in the same way that it can inherit from a single
    parent class. In the simplest case, none of the involved classes, including those
    inherited indirectly through a parent class, contains instance variables or methods
    of the same name. In such a case, the inheriting class behaves like a synthesis
    of its own definitions and all of its ancestors’ definitions. Suppose that class
    `A` inherits from classes `B`, `C`, and `D`; class `B` inherits from classes `E`
    and `F`; and class `D` inherits from class `G` (see [figure 15.3](#ch15fig03)).
    Also suppose that none of these classes shares method names. In this case, an
    instance of class `A` can be used as though it were an instance of any of the
    classes `B`–`G`, as well as `A`; an instance of class `B` can be used as though
    it were an instance of class `E` or `F` as well as class `B`; and an instance
    of class `D` can be used as though it were an instance of class `G` as well as
    class `D`. In terms of code, the class definitions look like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对多重继承没有这样的限制。一个类可以像继承单个父类一样从任意数量的父类中继承。在最简单的情况下，涉及的任何类（包括通过父类间接继承的类），都不包含相同名称的实例变量或方法。在这种情况下，继承的类就像其自己的定义和所有祖先的定义的合成。假设类
    `A` 从类 `B`、`C` 和 `D` 继承；类 `B` 从类 `E` 和 `F` 继承；类 `D` 从类 `G` 继承（见[图 15.3](#ch15fig03)）。还假设这些类中没有共享方法名称。在这种情况下，类
    `A` 的一个实例可以用作类 `B`–`G` 以及 `A` 的实例；类 `B` 的一个实例可以用作类 `E` 或 `F` 以及类 `B` 的实例；类 `D`
    的一个实例可以用作类 `G` 以及类 `D` 的实例。从代码的角度来看，类定义看起来像这样：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Figure 15.3\. Inheritance hierarchy
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.3\. 继承层次结构
- en: '![](images/15fig03.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](images/15fig03.jpg)'
- en: The situation is more complex when some of the classes share method names, because
    Python must decide which of the identical names is the correct one. Suppose that
    you want to resolve a method invocation `a.f()` on an instance `a` of class `A`,
    where `f` isn’t defined in `A` but is defined in all of `F`, `C`, and `G`. Which
    of the various methods will be invoked?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当一些类共享方法名称时，情况会更复杂，因为 Python 必须决定哪个相同名称是正确的。假设你想要在类 `A` 的实例 `a` 上解析方法调用 `a.f()`，其中
    `f` 在 `A` 中未定义，但在 `F`、`C` 和 `G` 中都有定义。各种方法中的哪一个将被调用？
- en: 'The answer lies in the order in which Python searches base classes when looking
    for a method not defined in the original class on which the method was invoked.
    In the simplest cases, Python looks through the base classes of the original class
    in left-to-right order, but it always looks through all of the ancestor classes
    of a base class before looking in the next base class. In attempting to execute
    `a.f()`, the search goes something like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于 Python 在寻找在原始类中未定义的方法时，搜索基类的顺序。在最简单的情况下，Python 会按照从左到右的顺序遍历原始类的基类，但在查看下一个基类之前，它总是先遍历基类的所有祖先类。在尝试执行
    `a.f()` 时，搜索过程大致如下：
- en: Python first looks in the class of the invoking object, class `A`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 首先查看调用对象所在的类，即类 `A`。
- en: Because `A` doesn’t define a method `f`, Python starts looking in the base classes
    of `A`. The first base class of `A` is `B`, so Python starts looking in `B`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `A` 没有定义方法 `f`，Python 开始在 `A` 的基类中搜索。`A` 的第一个基类是 `B`，所以 Python 开始在 `B` 中搜索。
- en: Because `B` doesn’t define a method `f`, Python continues its search of `B`
    by looking in the base classes of `B`. It starts by looking in the first base
    class of `B`, class `E`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `B` 没有定义方法 `f`，Python 继续在 `B` 的基类中搜索。它首先查看 `B` 的第一个基类，即类 `E`。
- en: '`E` doesn’t define a method `f` and also has no base classes, so there’s no
    more searching to be done in `E`. Python goes back to class `B` and looks in the
    next base class of `B`, class `F`.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`E` 没有定义方法 `f`，也没有基类，所以在 `E` 中没有更多的搜索要做。Python 返回到类 `B` 并查看 `B` 的下一个基类，即类 `F`。'
- en: Class `F` does contain a method `f`, and because it was the first method found
    with the given name, it’s the method used. The methods called `f` in classes `C`
    and `G` are ignored.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `F` 包含一个名为 `f` 的方法，并且因为它是最先找到的具有该名称的方法，所以它被使用。类 `C` 和 `G` 中名为 `f` 的方法被忽略。
- en: Using internal logic like this isn’t likely to lead to the most readable or
    maintainable of programs, of course. And with more complex hierarchies, other
    factors come into play to make sure that no class is searched twice and to support
    cooperative calls to `super`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种内部逻辑不太可能导致最易读或易维护的程序，当然。随着更复杂的层次结构，其他因素也会介入以确保没有类被搜索两次，并支持对`super`的协作调用。
- en: But this hierarchy is probably more complex than you’d expect to see in practice.
    If you stick to the more standard uses of multiple inheritance, as in the creation
    of mixin or addin classes, you can easily keep things readable and avoid name
    clashes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个层次结构可能比你预期的在实际中看到的要复杂。如果你坚持使用多重继承的更标准用法，比如创建mixin或addin类，你可以轻松地保持代码的可读性并避免名称冲突。
- en: Some people have a strong conviction that multiple inheritance is a bad thing.
    It can certainly be misused, and nothing in Python forces you to use it. One of
    the biggest dangers seems to be creating inheritance hierarchies that are too
    deep, and multiple inheritance can sometimes be used to help keep this problem
    from happening. That issue is beyond the scope of this book. The example I use
    here only illustrates how multiple inheritance works in Python and doesn’t attempt
    to explain the use cases for it (such as in mixin or addin classes).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人坚信多重继承是一件坏事。它确实可能被误用，Python中没有强制要求你使用它。最大的危险之一似乎是创建过深的继承层次结构，多重继承有时可以用来帮助防止这个问题发生。这个问题超出了本书的范围。这里使用的例子只是说明了Python中多重继承的工作方式，并没有尝试解释它的用例（例如在mixin或addin类中）。
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 15: HTML classes'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验15：HTML类
- en: In this lab, you create classes to represent an HTML document. To keep things
    simple, assume that each element can contain only text and one subelement. So
    the `<html>` element contains only a `<body>` element, and the `<body>` element
    contains (optional) text and a `<p>` element that contains only text.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你创建类来表示HTML文档。为了简化，假设每个元素只能包含文本和一个子元素。所以`<html>`元素只包含一个`<body>`元素，而`<body>`元素包含（可选）文本和一个只包含文本的`<p>`元素。
- en: The key feature to implement is the `__str__()` method, which in turn calls
    its subelement’s `__str__()` method, so that the entire document is returned when
    the `str()` function is called on an `<html>` element. You can assume that any
    text comes before the subelement.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现的关键特性是`__str__()`方法，它反过来调用其子元素的`__str__()`方法，这样当在`<html>`元素上调用`str()`函数时，就会返回整个文档。你可以假设任何文本都在子元素之前。
- en: 'Here’s example output from using the classes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这些类的示例输出：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Defining a class in effect creates a new data type.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个类实际上创建了一个新的数据类型。
- en: '`__init__` is used to initialize data when a new instance of a class is created,
    but it isn’t a constructor.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`用于在创建类的新的实例时初始化数据，但它不是一个构造函数。'
- en: The `self` parameter refers to the current instance of the class and is passed
    as the first parameter to methods of a class.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self`参数指向类的当前实例，并且作为类的方法的第一个参数传递。'
- en: Static methods can be called without creating an instance of the class, so they
    don’t receive a `self` parameter.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法可以在不创建类的实例的情况下调用，因此它们不接收`self`参数。
- en: Class methods are passed a `cls` parameter, which is a reference to the class,
    instead of `self`.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法传递一个`cls`参数，它是对类的引用，而不是`self`。
- en: All Python methods are virtual. That is, if a method isn’t overridden in the
    subclass or private to the superclass, it’s accessible by all subclasses.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有Python方法都是虚拟的。也就是说，如果一个方法在子类中没有重写或者对超类是私有的，那么它对所有子类都是可访问的。
- en: Class variables are inherited from superclasses unless they begin with two underscores
    `(__)`, in which case they’re private and can’t be seen by subclasses. Methods
    can be made private in the same way.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类变量从超类继承，除非它们以两个下划线`(__)`开头，在这种情况下它们是私有的，子类无法看到。方法也可以用同样的方式设置为私有。
- en: Properties let you have attributes with defined getter and setter methods, but
    they still behave like plain instance attributes.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性让你可以有具有定义的getter和setter方法的属性，但它们仍然像普通实例属性一样表现。
- en: Python allows multiple inheritance, which is often used with mixin classes.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python允许多重继承，这通常与mixin类一起使用。
