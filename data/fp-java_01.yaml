- en: Chapter 2\. Using functions in Java
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. 在Java中使用函数
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Understanding functions in the real world
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中理解函数
- en: Representing functions in Java
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中表示函数
- en: Using lambdas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda表达式
- en: Working with higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶函数
- en: Using curried functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用柯里化函数
- en: Programming with functional interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数式接口进行编程
- en: To understand how functional programming works, we could use functional components
    provided by some functional library, or even the few that have been made available
    in the Java 8 library. But instead, we’ll look at how you can construct things
    rather than how to use these provided components. Once you’ve mastered the concepts,
    it will be up to you to choose between your own functions and the standard Java
    8 ones, or to rely on one of the existing external libraries. In this chapter
    you’ll create a `Function` very similar to the Java 8 `Function`. It will be a
    bit simplified in how it handles type parameters (avoiding wildcards) in order
    to make the code easier to read, but it will have some powerful capacities that
    are absent from the Java 8 version. Apart from those differences, they’ll be interchangeable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解函数式编程是如何工作的，我们可以使用某些函数式库提供的函数组件，或者甚至那些在Java 8库中已经可用的一些组件。但相反，我们将探讨如何构建事物，而不是如何使用这些提供的组件。一旦你掌握了这些概念，选择使用你自己的函数还是标准的Java
    8函数，或者依赖现有的外部库，就取决于你了。在本章中，你将创建一个与Java 8的`Function`非常相似的`Function`。在处理类型参数（避免使用通配符）方面，它将略有简化，以便代码更容易阅读，但它将具有Java
    8版本中缺少的一些强大功能。除了这些差异之外，它们是可以互换的。
- en: You might have trouble understanding some parts of the code presented in this
    chapter. That’s to be expected, because it’s very difficult to introduce functions
    without using other functional constructs such as `List`, `Option`, and others.
    Be patient. All the unexplained components will be discussed in the following
    chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能难以理解本章中展示的一些代码部分。这是可以预料的，因为在不使用其他函数式结构（如`List`、`Option`等）的情况下介绍函数是非常困难的。请耐心等待。所有未解释的组件将在接下来的章节中讨论。
- en: I’ll now explain in greater detail what a function is, both in the real world
    and in a programming language. Functions aren’t only a mathematical or programming
    entity. Functions are part of everyday life. We’re constantly modeling the world
    in which we live, and this is true not only for programming. We construct representations
    of the world around us, and these representations are often based on objects that
    mutate their state as time changes. Seeing things this way is human nature. Going
    from state A to state B takes time, and it has a cost in terms of time, effort,
    or money.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将更详细地解释什么是函数，无论是在现实世界还是在编程语言中。函数不仅仅是数学或编程实体。函数是日常生活的一部分。我们不断地在构建我们生活的世界的模型，这不仅适用于编程。我们构建我们周围世界的表示，而这些表示通常基于随时间改变其状态的对象。以这种方式看待事物是人的天性。从状态A到状态B的转变需要时间，并且在时间、努力或金钱方面都有成本。
- en: Consider addition as an example. Most of us see it as a computation that takes
    time (and sometimes intellectual effort!). It has a starting state, a transition
    (the computation), and a resulting state (the result of the addition).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以加法为例。我们大多数人将其视为需要时间（有时甚至需要智力努力）的计算！它有一个起始状态，一个过渡（计算），以及一个结果状态（加法的结果）。
- en: To add 345, 765, and 34,524, we certainly need to perform a computation. Some
    of us can do it in little time, and others will take longer. Some might never
    succeed, or will get an erroneous result. Some will make the computation in their
    head; others will need to write it down on paper. All will probably mutate some
    state to achieve this, whether it’s a sheet of paper or some part of their brain.
    But to add 2 and 3, we don’t need all this. Most of us have memorized the answer
    and can give the result immediately, without doing any computation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要将345、765和34,524相加，我们当然需要进行计算。有些人可以在很短的时间内完成，而有些人则需要更长的时间。有些人可能永远无法成功，或者会得到错误的结果。有些人会在脑海中进行计算；其他人则需要将它们写在纸上。所有这些都会在某种程度上改变状态以实现这一点，无论是纸张还是他们大脑的一部分。但要将2和3相加，我们不需要所有这些。我们大多数人已经记住了答案，可以立即给出结果，而无需进行任何计算。
- en: This example shows that computation isn’t the essential element here. It’s just
    a means to calculate the result of a function. But this result existed before
    we made the computation. We just generally don’t know what this result is beforehand.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，计算并不是这里的关键要素。它只是计算函数结果的一种手段。但这个结果在我们进行计算之前就已经存在了。我们只是通常不知道这个结果是什么。
- en: Functional programming is just programming using functions. To be able to do
    this, we first need to know what a function is, both in the real world and in
    our programming language of choice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程就是使用函数进行编程。为了能够做到这一点，我们首先需要知道什么是函数，无论是在现实世界还是在我们所选择的编程语言中。
- en: 2.1\. What is a function?
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 什么是函数？
- en: A *function* is generally known as a mathematical object, although the concept
    is also ubiquitous in everyday life. Unfortunately, in everyday life, we often
    confuse functions and effects. And what is even more unfortunate is that we also
    make this mistake when working with many programming languages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数* 通常被称为数学对象，尽管这个概念在日常生活中的应用也非常普遍。不幸的是，在日常生活中，我们经常混淆函数和效果。更不幸的是，我们在使用许多编程语言时也会犯这个错误。'
- en: 2.1.1\. Functions in the real world
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 现实世界中的函数
- en: In the real world, a function is primarily a mathematic concept. It’s a relation
    between a source set, called the function *domain*, to a target set, called the
    function *codomain*. The domain and the codomain need not be distinct. A function
    can have the same set of integer numbers for its domain and its codomain, for
    example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，函数主要是一个数学概念。它是一个称为函数 *定义域* 的源集合与称为函数 *值域* 的目标集合之间的关系。定义域和值域不必是不同的。例如，一个函数可以具有与其定义域和值域相同的整数集合。
- en: What makes a relation between two sets a function
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么使得两个集合之间的关系成为函数
- en: 'To be a function, a relation must fulfill one condition: all elements of the
    domain must have one and only one corresponding element in the codomain, as shown
    in [figure 2.1](#ch02fig01).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一个函数，一个关系必须满足一个条件：定义域中的所有元素必须在值域中有一个且仅有一个对应的元素，如图 2.1 所示。
- en: Figure 2.1\. All elements of a function’s domain must have one and only one
    corresponding element in the codomain.
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 函数定义域中的所有元素必须在值域中有一个且仅有一个对应的元素。
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01_alt.jpg)'
- en: 'This has some interesting implications:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些有趣的含义：
- en: There cannot exist elements in the domain with no corresponding value in the
    codomain.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在域中不能存在没有在值域中对应值的元素。
- en: There cannot exist two elements in the codomain corresponding to the same element
    of the domain.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在值域中不能存在两个与域中的相同元素对应的元素。
- en: There may be elements in the codomain with no corresponding element in the source
    set.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值域中可能有元素在源集中没有对应元素。
- en: There may be elements in the codomain with more than one corresponding element
    in the source set.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值域中可能有元素在源集中对应多个元素。
- en: The set of elements of the codomain that have a corresponding element in the
    domain is called the *image* of the function.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值域中具有域中对应元素的元素集合被称为函数的 *像*。
- en: '[Figure 2.1](#ch02fig01) illustrates a function.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.1](#ch02fig01) 展示了一个函数。'
- en: You can, for example, define the function
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义函数，例如
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where `x` is a positive integer. This function represents the relationship between
    each positive integer and its successor. You can give any name to this function.
    In particular, you can give it a name that will help you remember what it is,
    such as
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `x` 是一个正整数。这个函数代表了每个正整数与其后继之间的关系。你可以给这个函数起任何名字。特别是，你可以给它起一个能帮助你记住它是什么的名字，比如
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This may seem like a good idea, but you shouldn’t blindly trust a function
    name. You could alternatively have defined the function as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是个好主意，但你不应该盲目地相信函数名。你还可以将函数定义为以下内容：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: No error occurs here, because no mandatory relationship exists between a function
    name and the definition of the function. But, obviously, it would be a bad idea
    to use such a name.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有发生错误，因为没有强制的关系存在于函数名和函数定义之间。但，显然，使用这样的名字是不明智的。
- en: Note that we’re talking about what a function is (its definition) and not what
    it does. A function does nothing. The `successor` function doesn’t add 1 to its
    argument. *You* can add 1 to an integer to calculate its successor, but *you*
    aren’t a function. The function
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里讨论的是函数的定义（它的定义），而不是它所做的事情。函数什么也不做。`successor` 函数不会将其参数加 1。*你*可以给一个整数加
    1 来计算它的后继，但*你*不是一个函数。函数
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: doesn’t add `1` to `x`. It is only equivalent to `x + 1`, which simply means
    that each time you encounter the expression `successor(x)`, you can replace it
    with `(x + 1)`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 并不将`1`加到`x`上。它仅与`x + 1`等价，这意味着每次遇到表达式`successor(x)`时，都可以将其替换为`(x + 1)`。
- en: Note the parentheses that are used to isolate the expression. They aren’t needed
    when the expression is used alone, but they might be necessary on some occasions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意用来隔离表达式的括号。当表达式单独使用时，不需要括号，但在某些情况下可能需要。
- en: Inverse functions
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 逆函数
- en: A function may or may not have an inverse function. If `f(x)` is a function
    from `A` to `B` (`A` being the domain and `B` the codomain), the inverse function
    is noted as `f`^(-1)`(x)` and has `B` as its domain and `A` as its codomain. If
    you represent the type of the function as `A –> B`, the inverse function (if it
    exists) has the type `B –> A`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可能或可能没有逆函数。如果`f(x)`是从`A`到`B`的函数（`A`是定义域，`B`是陪域），则逆函数记作`f`^(-1)`(x)`，其定义域是`B`，陪域是`A`。如果你将函数的类型表示为`A
    –> B`，则逆函数（如果存在）的类型是`B –> A`。
- en: 'The inverse of a function is a function if it fulfills the same requirement
    as any function: having one and only one target value for each source value. As
    a result, the inverse of `successor(x)`, a relation that you’ll call `predecessor(x)`
    (although you could just as well call it `xyz`), isn’t a function in `N` (the
    set of positive integers including 0) because 0 has no predecessor in `N`. Conversely,
    if `successor(x)` is considered with the set of signed integers (positive and
    negative, noted as `Z`), the inverse of `successor` is a function.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的逆如果满足任何函数相同的条件：对于每个源值只有一个目标值，则是一个函数。因此，关系`successor(x)`（你可以称之为`predecessor(x)`，尽管你也可以称之为`xyz`）的逆，在`N`（包括0的正整数集）上不是一个函数，因为0在`N`中没有前驱。相反，如果将`successor(x)`考虑为整数集（正数和负数，记为`Z`），则`successor`的逆是一个函数。
- en: Some other simple functions have no inverse. For example, the function
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他简单的函数没有逆函数。例如，函数
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: has no inverse if defined from `N` to `N`. It has an inverse if you define it
    as a function from `N` to the set of even integers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义为从`N`到`N`，则没有逆函数。如果你将其定义为从`N`到偶数整数的函数，则它有逆函数。
- en: Partial functions
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部分函数
- en: A relation that isn’t defined for all elements of the domain but that fulfills
    the rest of the requirement (no element of the domain can have a relationship
    with more than one element of the codomain) is often called a *partial function*.
    The relation `predecessor(x)` is a partial function on `N` (the set of positive
    integers plus 0), but it’s a total function on `N*`, which is the set of positive
    integers without 0, and its codomain is `N`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义域中并非所有元素都有定义但满足其他要求（定义域中的任何元素都不能与陪域中的多个元素有关系）的关系通常被称为*部分函数*。关系`前驱(x)`在`N`（正整数集加上0）上是部分函数，但在`N*`（不带0的正整数集）上是全函数，其陪域是`N`。
- en: Partial functions are important in programming because many bugs are the result
    of using a partial function as if it were a total one. For example, the relation
    `f(x) = 1/x` is a partial function from `N` to `Q` (the rational numbers) because
    it isn’t defined for 0\. It’s a total function from `N*` to `Q`, but it’s also
    a total function from `N` to (`Q` plus `error`). By adding an element to the codomain
    (the error condition), you can transform the partial function into a total one.
    But to do this, the function needs a way to return an error. Can you see an analogy
    with computer programs? You’ll see that turning partial functions into total ones
    is an important part of functional programming.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数在编程中很重要，因为许多错误是由于将部分函数当作全函数使用而产生的。例如，关系`f(x) = 1/x`是从`N`到`Q`（有理数）的部分函数，因为它在0处没有定义。它是从`N*`到`Q`的全函数，但也是从`N`到（`Q`加上`error`）的全函数。通过向陪域（错误条件）添加一个元素，可以将部分函数转换为全函数。但要做到这一点，函数需要一种返回错误的方式。你能看到与计算机程序的类比吗？你会发现将部分函数转换为全函数是函数式编程的一个重要部分。
- en: Function composition
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数组合
- en: Functions are building blocks that can be composed to build other functions.
    The composition of functions `f` and `g` is noted as `f ˚ g`, which reads as `f`
    *round* `g`. If `f(x) = x + 2` and `g(x) = x * 2`, then
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是构建其他函数的基石，可以组合起来构建其他函数。函数`f`和`g`的组合记作`f ˚ g`，读作`f` *round* `g`。如果`f(x) =
    x + 2`且`g(x) = x * 2`，那么
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the two notations `f ˚ g (x)` and `f(g(x))` are equivalent. But writing
    a composition as `f(g(x))` implies using `x` as a placeholder for the argument.
    Using the `f ˚ g` notation, you can express a function composition without using
    this placeholder.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两种表示法 `f ˚ g (x)` 和 `f(g(x))` 是等价的。但将复合函数写作 `f(g(x))` 意味着使用 `x` 作为参数的占位符。使用
    `f ˚ g` 表示法，你可以不使用这个占位符来表达函数复合。
- en: 'If you apply this function to `5`, you’ll get the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个函数应用到 `5`，你会得到以下结果：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s interesting to note that `f ˚ g` is generally different from `g ˚ f`,
    although they may sometimes be equivalent. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是要注意 `f ˚ g` 通常与 `g ˚ f` 不同，尽管它们有时可能是等价的。例如：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the functions are applied in the inverse of the writing order. If
    you write `f ˚ g`, you first apply `g`, and then `f`. Standard Java 8 functions
    define the `compose()` method and the `andThen()` method to represent both cases
    (which, by the way, isn’t necessary because `f.andThen(g)` is the same as `g.compose(f)`,
    or `g ˚ f`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数是按照书写顺序的逆序应用的。如果你写 `f ˚ g`，你首先应用 `g`，然后是 `f`。标准的 Java 8 函数定义了 `compose()`
    方法和 `andThen()` 方法来表示这两种情况（顺便说一下，这并不是必要的，因为 `f.andThen(g)` 与 `g.compose(f)` 相同，或者
    `g ˚ f`）。
- en: Functions of several arguments
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多参数函数
- en: So far, we’ve talked only about functions of one argument. What about functions
    of several arguments? Simply said, there’s no such thing as a function of several
    arguments. Remember the definition? A function is a relation between a source
    set and a target set. It isn’t a relation between two or more source sets and
    a target set. A function can’t have several arguments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了单参数函数。那么多参数函数呢？简单地说，没有多参数函数这回事。还记得定义吗？函数是源集合和目标集合之间的关系。它不是两个或更多源集合与目标集合之间的关系。函数不能有多个参数。
- en: 'But the product of two sets is itself a set, so a function from such a product
    of sets into a set may appear to be a function of several arguments. Let’s consider
    the following function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但两个集合的乘积本身也是一个集合，因此从这样一个集合乘积到集合的函数可能看起来是多个参数的函数。让我们考虑以下函数：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This may be a relation between `N x N` and `N`, in which case, it’s a function.
    But it has only one argument, which is an element of `N x N`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是在 `N x N` 和 `N` 之间的一个关系，在这种情况下，它是一个函数。但它只有一个参数，即 `N x N` 的一个元素。
- en: '`N x N` is the set of all possible pairs of integers. An element of this set
    is a pair of integers, and a pair is a special case of the more general *tuple*
    concept used to represent combinations of several elements. A pair is a tuple
    of two elements.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`N x N` 是所有可能的整数对的集合。这个集合的元素是一对整数，而一对是更一般的概念 *元组* 的一个特例，用于表示几个元素的组合。一对是两个元素的元组。'
- en: 'Tuples are noted between parentheses, so `(3, 5)` is a tuple and an element
    of `N x N`. The function `f` can be applied to this tuple:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 元组用括号表示，所以 `(3, 5)` 是一个元组，也是 `N x N` 的一个元素。函数 `f` 可以应用于这个元组：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In such a case, you may, by convention, simplify writing by removing one set
    of parentheses:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，按照惯例，你可以通过移除一组括号来简化写作：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Nevertheless, it’s still a function of one tuple, and not a function of two
    arguments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，它仍然是一个元组的函数，而不是两个参数的函数。
- en: Function currying
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数柯里化
- en: Functions of tuples can be thought of differently. The function `f(3, 5)` might
    be considered as a function from `N` to a set of functions of `N`. So the previous
    example could be rewritten as
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的函数可以有不同的理解方式。函数 `f(3, 5)` 可能被视为从 `N` 到 `N` 的函数集合的函数。因此，前面的例子可以重写为
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In such a case, you can write
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以写成
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'which means that the result of applying the function `f` to the argument `x`
    is a new function `g`. Applying this `g` function to `y` gives the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着将函数 `f` 应用到参数 `x` 的结果是一个新的函数 `g`。将这个 `g` 函数应用到 `y` 上，得到以下结果：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When applying `g`, `x` is no longer a variable. It doesn’t depend on the argument
    or on anything else. It’s a constant. If you apply this to `(3, 5)`, you get the
    following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用 `g` 时，`x` 已不再是变量。它不依赖于参数或任何其他东西。它是一个常数。如果你将这个应用到 `(3, 5)`，你会得到以下结果：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only new thing here is that the codomain of `f` is a set of functions instead
    of a set of numbers. The *result* of applying `f` to an integer is a function.
    The *result* of applying this function to an integer is an integer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新东西是 `f` 的陪域是一个函数集合而不是一个数字集合。将 `f` 应用到整数的结果是一个函数。将这个函数应用到整数的结果是一个整数。
- en: '`f(x)(y)` is the *curried* form of the function `f(x, y)`. Applying this transformation
    to a function of a tuple (which you can call a function of several arguments if
    you prefer) is called *currying*, after the mathematician Haskell Curry (although
    he wasn’t the inventor of this transformation).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`f(x)(y)` 是函数 `f(x, y)` 的 *柯里化* 形式。将这种转换应用于元组函数（如果你更喜欢，可以将其称为多个参数的函数）称为 *柯里化*，以数学家
    Haskell Curry 的名字命名（尽管他并不是这种转换的发明者）。'
- en: Partially applied functions
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部分应用函数
- en: The curried form of the addition function may not seem natural, and you might
    wonder if it corresponds to something in the real world. After all, with the curried
    version, you’re considering both arguments separately. One of the arguments is
    considered first, and applying the function to it gives you a new function. Is
    this new function useful by itself, or is it simply a step in the global calculation?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 加法函数的柯里化形式可能看起来不太自然，你可能会想知道它是否对应于现实世界中的某个东西。毕竟，在柯里化版本中，你是分别考虑这两个参数的。其中一个参数首先被考虑，将函数应用到它上会给你一个新的函数。这个新函数本身有用，还是它只是全局计算的一个步骤？
- en: In the case of an addition, it doesn’t seem useful. And by the way, you could
    start with either of the two arguments and it would make no difference. The intermediate
    function would be different, but not the end result.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在加法的情况下，这似乎没有用。顺便说一句，你可以从两个参数中的任何一个开始，这不会有什么区别。中间函数会不同，但最终结果不会变。
- en: 'Now consider a new function of a pair of values:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一对值的新函数：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That function seems to be equivalent to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那个函数看起来似乎等同于这个：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s now consider the curried versions of these two functions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在考虑这两个函数的柯里化版本：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You know that `f` and `g` are functions. But what are `f(rate)` and `g(price)`?
    Yes, for sure, they’re the results of applying `f` to `rate` and `g` to `price`.
    But what are the types of these results?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道 `f` 和 `g` 是函数。但 `f(rate)` 和 `g(price)` 是什么意思呢？当然，它们是将 `f` 应用到 `rate` 和 `g`
    应用到 `price` 的结果。但这些结果的类型是什么呢？
- en: '`f(rate)` is a function of a price to a price. If `rate = 9`, this function
    applies a tax of 9% to a price, giving a new price. You could call the resulting
    function `apply9-percentTax(price)`, and it would probably be a useful tool because
    the tax rate doesn’t change often.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`f(rate)` 是一个将价格映射到价格的函数。如果 `rate = 9`，这个函数将对价格应用9%的税，得到一个新的价格。你可以把这个结果函数称为
    `apply9-percentTax(price)`，这可能会是一个有用的工具，因为税率不经常变化。'
- en: On the other hand, `g(price)` is a function of a rate to a price. If the price
    is $100, it gives a new function applying a price of $100 to a variable tax. What
    could you call this function? If you can’t think of a meaningful name, that usually
    means that it’s useless, though this depends on the problem you have to solve.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`g(price)` 是一个将比率映射到价格的函数。如果价格是100美元，它将给出一个新的函数，将100美元的价格应用到可变税率上。你能给这个函数起个名字吗？如果你想不出一个有意义的名字，那通常意味着它是无用的，尽管这取决于你要解决的问题。
- en: Functions like `f(rate)` and `g(price)` are sometimes called *partially applied
    functions*, in reference to the forms `f(rate, price)` and `g(price, rate)`. Partially
    applying functions can have huge consequences regarding argument evaluation. We’ll
    come back to this subject in a later section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `f(rate)` 和 `g(price)` 的函数有时被称为 *部分应用函数*，这指的是 `f(rate, price)` 和 `g(price,
    rate)` 的形式。部分应用函数在参数评估方面可能产生巨大的影响。我们将在后面的章节中回到这个话题。
- en: If you have trouble understanding the concept of currying, imagine you’re traveling
    in a foreign country, using a handheld calculator (or your smartphone) to convert
    from one currency to another. Would you prefer having to type the conversion rate
    each time you want to compute a price, or would you rather put the conversion
    rate in memory? Which solution would be less error prone?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解柯里化的概念有困难，想象你正在外国旅行，使用手持计算器（或你的智能手机）将一种货币转换成另一种货币。你更喜欢每次计算价格时都要输入汇率，还是更愿意将汇率存储在内存中？哪种解决方案的错误概率会更低？
- en: Functions have no effects
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数没有效果
- en: Remember that pure functions only return a value and do nothing else. They don’t
    mutate any element of the outside world (with *outside* being relative to the
    function itself), they don’t mutate their arguments, and they don’t explode (or
    throw an exception, or anything else) if an error occurs. They can return an exception
    or anything else, such as an error message. But they must return it, not throw
    it, nor log it, nor print it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，纯函数只返回一个值，不做其他任何事情。它们不会修改外部世界的任何元素（*外部*相对于函数本身而言），它们不会修改它们的参数，并且在发生错误时不会爆炸（或抛出异常，或任何其他事情）。它们可以返回异常或任何其他内容，例如错误消息。但它们必须返回它，而不是抛出它，记录它，或打印它。
- en: 2.2\. Functions in Java
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. Java中的函数
- en: In [chapter 1](kindle_split_008.xhtml#ch01), you used what I called *functions*
    but were in fact methods. Methods are a way to represent (to a certain extent)
    functions in traditional Java.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](kindle_split_008.xhtml#ch01) 中，你使用了我认为的 *函数*，但实际上是方法。方法是在传统 Java 中表示（在某种程度上）函数的一种方式。
- en: 2.2.1\. Functional methods
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 有功能的函数
- en: 'A method can be functional if it respects the requirements of a pure function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以是有功能的，如果它遵守纯函数的要求：
- en: It must not mutate anything outside the function. No internal mutation may be
    visible from the outside.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不得修改函数外部的内容。没有任何内部修改可以从外部看到。
- en: It must not mutate its argument.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不得修改其参数。
- en: It must not throw errors or exceptions.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不得抛出错误或异常。
- en: It must always return a value.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须始终返回一个值。
- en: When called with the same argument, it must always return the same result.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用相同的参数调用时，它必须始终返回相同的结果。
- en: Let’s look at an example.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。
- en: Listing 2.1\. Functional methods
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 有功能的函数
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Can you say which of these methods represent pure functions? Think for a few
    minutes before reading the answer that follows. Think about all the conditions
    and all the processing done inside the methods. Remember that what counts is what’s
    visible from the outside. Don’t forget to consider exceptional conditions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你能说出哪些方法代表了纯函数吗？在阅读答案之前，先思考几分钟。考虑所有条件以及方法内部进行的所有处理。记住，重要的是从外部可以看到的内容。不要忘记考虑异常情况。
- en: 'Consider the first method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第一个方法：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`add` is a function because it always returns a value that depends only on
    its arguments. It doesn’t mutate its arguments and doesn’t interact in any way
    with the outside world. This method may cause an error if the sum `a + b` overflows
    the maximum `int` value. But this won’t throw an exception. The result will be
    erroneous (a negative value), but this is another problem. The result must be
    the same each time the function is called with the same arguments. This doesn’t
    mean that the result must be exact!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 是一个函数，因为它总是返回一个只依赖于其参数的值。它不修改其参数，并且不与外部世界以任何方式交互。如果 `a + b` 的和超过最大 `int`
    值，此方法可能会引发错误。但这不会抛出异常。结果将是错误的（一个负值），但这又是另一个问题。每次函数使用相同的参数调用时，结果必须相同。这并不意味着结果必须是精确的！'
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exactness
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 精确性
- en: The term *exact* doesn’t mean anything by itself. It generally means that it
    fits what is expected, so to say whether the result of a function implementation
    is exact, you must know the intention of the implementer. Usually you’ll have
    nothing but the function name to determine the intention, which can be a source
    of misunderstanding.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *精确* 本身没有意义。它通常意味着它符合预期，因此要判断函数实现的输出是否精确，你必须知道实现者的意图。通常你只有函数名来确定意图，这可能是误解的来源。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Consider the second method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第二个方法：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `mult` method is a pure function for the same reason as `add`. This may
    surprise you, because it seems to be mutating its arguments. But arguments in
    Java methods are passed by value, which means that values reassigned to them aren’t
    visible from outside the method. This method will always return `10`, which isn’t
    useful because it doesn’t depend on the arguments, but this doesn’t break the
    requirements. When the method is called several times with the same arguments,
    it will return the same value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`mult` 方法与 `add` 方法一样，是一个纯函数。这可能让你感到惊讶，因为它似乎在修改其参数。但 Java 方法中的参数是通过值传递的，这意味着重新分配给它们的值在方法外部是不可见的。此方法始终返回
    `10`，这并不实用，因为它不依赖于参数，但这并不违反要求。当方法多次使用相同的参数调用时，它将返回相同的值。'
- en: 'By the way, this method is equivalent to a method with no argument. This is
    a special case of function: `f(x) = 10`. It’s a constant.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，此方法与无参数的方法等价。这是函数的一个特殊情况：`f(x) = 10`。它是一个常数。
- en: 'Now consider the `div`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 `div`：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `div` method isn’t a pure function because it will throw an exception if
    the divisor is `0`. To make it a function, you could test the second parameter
    and return a value if it’s `null`. It would have to be an `int`, so it would be
    difficult to find a meaningful value, but that’s another problem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`div`方法不是一个纯函数，因为它会在除数为`0`时抛出异常。为了使其成为一个函数，你可以测试第二个参数，如果它是`null`则返回一个值。它必须是一个`int`，因此很难找到一个有意义的值，但这又是另一个问题。'
- en: 'Consider the fourth method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第四个方法：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `applyTax1` method seems not to be a pure function because its result depends
    on the value of `percent1`, which is public and can be modified between two function
    calls. As a consequence, two function calls with the same argument could return
    different values. `percent1` may be considered an implicit parameter, but this
    parameter isn’t evaluated at the same time as the method argument. This isn’t
    a problem if you use the `percent1` value only once inside the method, but if
    you read it twice, it could change between the two read operations. If you need
    to use the value twice, you must read it once and keep it in a local variable.
    This means the method `applyTax1` is a pure function of the tuple `(a, percent1)`,
    but it’s not a pure function of `a`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyTax1`方法似乎不是一个纯函数，因为它的结果依赖于`percent1`的值，而`percent1`是公开的，可以在两次函数调用之间被修改。因此，具有相同参数的两个函数调用可能会返回不同的值。`percent1`可能被视为一个隐含参数，但这个参数不是与方法参数同时评估的。如果你只在方法内部使用一次`percent1`的值，这不是问题，但如果读取两次，它可能在两次读取操作之间发生变化。如果你需要使用该值两次，你必须先读取一次并将其保存在局部变量中。这意味着`applyTax1`方法是一个纯函数，其参数为`(a,
    percent1)`元组，但它不是`a`的纯函数。'
- en: 'Compare that with the `applyTax2` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与`applyTax2`方法进行比较：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `applyTax2` method is no different. You might see it as a function, because
    the `percent2` property is private. But it’s mutable, and it’s mutated by the
    `setPercent2` method. Because `percent2` is accessed only once, `applyTax2` can
    be considered a pure function of the tuple `(a, percent2)`. But if considered
    as a function of `a`, it’s not a pure function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyTax2`方法没有不同。你可能会将其视为一个函数，因为`percent2`属性是私有的。但它是可以变的，并且被`setPercent2`方法修改。因为`percent2`只被访问一次，所以`applyTax2`可以被视为一个纯函数，其参数为`(a,
    percent2)`元组。但如果将其视为`a`的函数，它就不是一个纯函数。'
- en: 'Now consider the sixth method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第六个方法：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The method `applyTax3` is somewhat special. Given the same argument, the method
    will always return the same value, because it depends only on its arguments and
    on the `percent3` final property, which can’t be mutated. You might think that
    `applyTax3` isn’t a pure function because the result doesn’t depend only on the
    method’s arguments (the result of a pure function must depend only on its arguments).
    But no contradiction exists here if you consider `percent3` as a supplemental
    argument. In fact, the class itself may be considered a supplemental implicit
    argument, because all its properties are accessible from inside the method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyTax3`方法有些特殊。给定相同的参数，该方法总是会返回相同的值，因为它只依赖于其参数和`percent3`最终属性，该属性不能被修改。你可能会认为`applyTax3`不是一个纯函数，因为结果不只依赖于方法参数（纯函数的结果必须只依赖于其参数）。但如果将`percent3`视为一个补充参数，这里就没有矛盾。实际上，类本身也可以被视为一个补充的隐含参数，因为所有属性都可以在方法内部访问。'
- en: This is an important notion. All instance methods can be replaced with static
    methods by adding an argument of the type of the enclosing class. So the `applyTax3`
    method may be rewritten as
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的概念。所有实例方法都可以通过添加一个封装类类型的参数来替换为静态方法。因此，`applyTax3`方法可以被重写为
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method may be called from inside the class, passing a reference to `this`
    for the arguments, such as `applyTax3(this, a)`. It can also be called from outside,
    because it’s public, provided a reference to a `FunctionalMethods` instance is
    available. Here, `applyTax3` is a pure function of the tuple `(this, a)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以从类内部调用，传递对`this`的引用作为参数，例如`applyTax3(this, a)`。它也可以从外部调用，因为它是公开的，只要有一个`FunctionalMethods`实例的引用。在这里，`applyTax3`是`(this,
    a)`元组的纯函数。
- en: 'And finally, our last method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的最后一个方法：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `append` method mutates its argument before returning it, and this mutation
    is visible from outside the method, so it isn’t a pure function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`方法在返回之前会修改其参数，并且这种修改可以从方法外部看到，因此它不是一个纯函数。'
- en: Object notation vs. functional notation
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对象表示法与函数表示法
- en: You’ve seen that instance methods accessing class properties may be considered
    as having the enclosing class instance as an implicit parameter. Methods that
    don’t access the enclosing class instance may be safely made static. Methods accessing
    the enclosing instance may also be made static if their implicit parameter (the
    enclosing instance) is made explicit.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，访问类属性的实例方法可能被认为是具有封装类实例的隐式参数。不访问封装类实例的方法可以安全地定义为静态。如果它们的隐式参数（封装实例）被显式化，访问封装实例的方法也可以定义为静态。
- en: 'Consider the `Payment` class from [chapter 1](kindle_split_008.xhtml#ch01):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑来自第 1 章 [的 `Payment` 类](kindle_split_008.xhtml#ch01)：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `combine` method accesses the enclosing class’s `cc` and `amount` fields.
    As a result, it can’t be made static. This method has the enclosing class as an
    implicit parameter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`combine` 方法访问封装类的 `cc` 和 `amount` 字段。因此，它不能被定义为静态的。这个方法将封装类作为隐式参数。'
- en: 'You could make this parameter explicit, which would allow you to make the method
    static:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个参数显式化，这样就可以将方法定义为静态的：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A static method enables you to make sure no unwanted access exists to the enclosing
    scope. But it changes the way the method can be used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法使你能够确保不存在对封装作用域的不希望有的访问。但它改变了方法的使用方式。
- en: 'If used from inside the class, the static method can be called, passing it
    the `this` reference:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在类内部使用，静态方法可以被调用，并传递 `this` 引用：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the method is called from outside the class, you must use the class name:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从类外部调用该方法，必须使用类名：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This makes little difference, but it all changes when you need to compose method
    calls. If you need to combine several payments, an instance method written as
    follows
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎没有什么区别，但当需要组合方法调用时，一切都会改变。如果你需要组合几个支付，可以这样编写的实例方法
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'may be used with object notation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用对象表示法：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That’s much easier to read than this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这比下面更容易阅读：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Combining one more charge in the first case is also simpler.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，再添加一个费用也更简单。
- en: 2.2.2\. Java functional interfaces and anonymous classes
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2. Java 函数式接口和匿名类
- en: 'Methods can be made functional, but they’re missing something that keeps them
    from being able to represent functions in functional programming: they can’t be
    manipulated besides being applied to arguments. You can’t pass a method as an
    argument to another method. The consequence is that you can’t compose methods
    without applying them. You can compose method applications, but not the methods
    themselves. A Java method belongs to the class where it’s defined, and it stays
    there.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以被定义为函数式的，但它们缺少一些使它们能够代表函数式编程中的函数的特性：除了应用于参数之外，它们不能被操作。你不能将一个方法作为参数传递给另一个方法。结果是，你不能在不应用它们的情况下组合方法。你可以组合方法应用，但不能组合方法本身。Java
    方法属于定义它的类，并且它将停留在那里。
- en: You can compose methods by calling them from other methods, but this must be
    done while writing the program. If you want different compositions depending on
    particular conditions, you have to lay out these compositions at writing time.
    You can’t write a program in such a way that the program itself will change during
    execution. Or can you?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他方法中调用它们来组合方法，但必须在编写程序时这样做。如果你想要根据特定条件有不同的组合，你必须在编写时安排这些组合。你不能编写一个在执行过程中自身会改变的程序。或者可以吗？
- en: Yes, you can! Sometimes you register handlers at runtime to handle specific
    cases. You can add handlers to handler collections, or remove them, or change
    the order in which they’ll be used. How can you do this? By using classes containing
    the methods you want to manipulate.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以！有时你会在运行时注册处理程序来处理特定情况。你可以向处理程序集合中添加处理程序，或删除它们，或改变它们将被使用的顺序。你如何做到这一点？通过使用包含你想要操作的方法的类。
- en: In a GUI, you often use listeners to handle specific events such as moving the
    mouse, resizing a window, or typing text. These listeners are generally created
    as anonymous classes implementing a specific interface. You can use the same principle
    to create functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GUI 中，你经常使用监听器来处理特定事件，例如移动鼠标、调整窗口大小或输入文本。这些监听器通常作为实现特定接口的匿名类创建。你可以使用相同的原则来创建函数。
- en: 'Let’s say you want to create a method to triple an integer value. First, you
    have to define an interface with a single method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要创建一个将整数值乘以三的方法。首先，你必须定义一个只有一个方法的接口：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You then implement this method to create your function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后实现此方法以创建你的函数：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This function can then be applied to an argument:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将此函数应用于一个参数：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I must admit that this isn’t spectacular. A good old method would have been
    easier to use. If you want to create another function, you can process it exactly
    the same way:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，这并不引人注目。一个老式的方法可能会更容易使用。如果你想创建另一个函数，你可以用完全相同的方式处理它：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So far, so good, but what’s the benefit of this?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但这样做有什么好处呢？
- en: 2.2.3\. Composing functions
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 组合函数
- en: 'If you think about functions as methods, composing them seems simple:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把函数看作是方法，那么组合它们看起来很简单：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But this isn’t function composition. In this example, you’re composing function
    applications. Function composition is a binary operation on functions, just as
    addition is a binary operation on numbers. So you can compose functions programmatically,
    using a method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是函数组合。在这个例子中，你是在组合函数应用。函数组合是函数上的二元操作，就像加法是数字上的二元操作一样。所以你可以通过一个方法来程序化地组合函数：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now you can start seeing how powerful this concept is! But two big problems
    remain. The first is that our functions can only take integer (`int`) arguments
    and return integers. Let’s deal with this first.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始看到这个概念有多强大了！但还有两个大问题。第一个是，我们的函数只能接受整数 (`int`) 参数并返回整数。让我们先解决这个问题。
- en: 2.2.4\. Polymorphic functions
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4\. 多态函数
- en: 'To make our function more reusable, you can change it into a polymorphic function
    by using parameterized types, which are implemented in Java using generics:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的函数更具可重用性，你可以通过使用参数化类型将其改为多态函数，这些类型在 Java 中通过泛型实现：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Given this new interface, you can rewrite our functions as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个新接口，你可以将我们的函数重写如下：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you see, we switched from `int` to `Integer` because `int` can’t be used
    as a type parameter in Java. Hopefully, auto-boxing and auto-unboxing will make
    the conversion transparent.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们已从 `int` 切换到 `Integer`，因为 `int` 在 Java 中不能用作类型参数。希望自动装箱和自动拆箱会使转换变得透明。
- en: Exercise 2.1
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.1
- en: Write the `compose` method by using these two new functions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个新函数编写 `compose` 方法。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Solutions follow each exercise, but you should first try to solve the exercise
    by yourself without looking at the solution. The solution code also appears on
    the book’s website. This exercise is simple, but some will be quite hard, so it
    might be difficult to refrain from cheating. Remember that the harder you search,
    the more you learn.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个练习的解答都紧随其后，但你应该先尝试自己解决问题，不要看解答。解答代码也出现在本书的网站上。这个练习很简单，但有些可能会相当困难，所以你可能很难抵制作弊的诱惑。记住，你搜索得越努力，你学到的就越多。
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Solution 2.1
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 2.1
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Problem with function compositions**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数组合的问题**'
- en: Function composition is a powerful concept, but when implemented in Java, it
    presents a big danger. Composing a couple of functions is harmless. But think
    about building a list of 10,000 functions and composing them into a single one.
    (This could be done through a fold, an operation you’ll learn about in [chapter
    3](kindle_split_010.xhtml#ch03).)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是一个强大的概念，但在 Java 中实现时，它带来了很大的风险。组合几个函数是无害的。但想想看，构建一个包含 10,000 个函数的列表并将它们组合成一个单一的函数。（这可以通过折叠操作完成，你将在第
    3 章中了解到这个操作。[chapter 3](kindle_split_010.xhtml#ch03)）
- en: 'In imperative programming, each function is evaluated before the result is
    passed as the input of the next function. But in functional programming, composing
    functions means building the resulting function without evaluating anything. Composing
    functions is powerful because functions can be composed without being evaluated.
    But as a consequence, applying the composed function results in numerous embedded
    method calls that will eventually overflow the stack. This can be demonstrated
    with a simple example (using lambdas, which will be introduced in the next section):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，每个函数在将结果传递给下一个函数作为输入之前都会被评估。但在函数式编程中，组合函数意味着在没有任何评估的情况下构建结果函数。组合函数之所以强大，是因为函数可以在不进行评估的情况下组合。但作为后果，应用组合函数会导致嵌套的方法调用数量增加，最终可能会溢出栈。这可以通过一个简单的例子（使用将在下一节中介绍的
    lambda 表达式）来演示：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This program will overflow the stack when `fnum` is around 7,500\. Hopefully
    you won’t usually compose several thousand functions, but you should be aware
    of this.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `fnum` 大约是 7,500 时，这个程序将会溢出栈。希望你通常不会组合几千个函数，但你应该意识到这一点。
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.2.5\. Simplifying the code by using lambdas
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.5\. 使用 lambda 表达式简化代码
- en: The second problem you have is that functions defined using anonymous classes
    are cumbersome to use in coding. If you’re using Java 5 to 7, you’re out of luck,
    because there’s no other way to go. Fortunately, Java 8 introduced lambdas.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你遇到的第二个问题是使用匿名类定义的函数在编码中使用起来很麻烦。如果你使用的是Java 5到7，那么你就没有其他选择了。幸运的是，Java 8引入了Lambda表达式。
- en: 'Lambdas don’t change the way the `Function` interface is defined, but they
    make implementing it much simpler:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式不会改变`Function`接口的定义方式，但它们使得实现它变得更加简单：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Lambdas aren’t just a syntax simplification. Lambdas have some consequences
    in terms of code compilation. One of the main differences between lambdas and
    the traditional way of writing anonymous classes is that the types on the right
    side of the equals sign can be omitted. This is possible because Java 8 comes
    with new capabilities regarding type inference.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式不仅仅是语法简化。Lambda表达式在代码编译方面有一些影响。Lambda表达式与传统匿名类编写方式的主要区别之一是等号右侧的类型可以被省略。这是因为Java
    8带来了关于类型推断的新功能。
- en: 'Prior to Java 7, type inference was possible only when chaining identifier
    dereferencing, such as this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7之前，类型推断只有在链式标识符解引用时才可能，例如这样：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, you don’t need to specify the type of `out`, and Java is able to find
    it. If you were to write this without chaining, you’d have to specify the type:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你不需要指定`out`的类型，Java能够找到它。如果你不使用链式写法，你将不得不指定类型：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Java 7 added a bit of type inference with the *diamond syntax*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7通过*菱形语法*增加了一点点类型推断：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, you don’t need to repeat the type parameter `String` for the `ArrayList`
    because Java is able to infer it by looking at the declaration. The same thing
    is possible with lambdas:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你不需要重复`ArrayList`的`String`类型参数，因为Java能够通过查看声明来推断它。同样的事情也可以用Lambda表达式实现：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this example, the type of `x` is inferred by Java. But this isn’t always
    possible. When Java complains that it isn’t able to infer the type, you have to
    write it explicitly. Then you must use parentheses:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`x`的类型是由Java推断的。但这并不总是可能的。当Java抱怨它无法推断类型时，你必须显式地写出它。然后你必须使用括号：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Specifying function types
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指定函数类型
- en: Although Java 8 introduced lambdas to ease function implementation, it’s missing
    the same kind of tool to simplify writing function types. The type of a function
    from an `Integer` to an `Integer` is
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java 8引入了Lambda表达式来简化函数实现，但它缺少简化编写函数类型的工具。从`Integer`到`Integer`的函数类型是
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'and the function implementation is written like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 函数实现是这样写的：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It would be nice to be able to apply the same simplification to the type, which
    would allow you to write the whole thing as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够将相同的简化应用到类型上，这将允许你这样写整个表达式：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Unfortunately, this isn’t possible in Java 8, and it’s something you can’t add
    yourself.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在Java 8中这是不可能的，而且这也不是你可以自己添加的。
- en: Exercise 2.2
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.2
- en: Write a new version of the `compose` method by using lambdas.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lambda表达式编写`compose`方法的新版本。
- en: Solution 2.2
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案2.2
- en: 'Replacing anonymous classes with lambdas is straightforward. Here’s the code
    of the first version of the `compose` method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 用Lambda表达式替换匿名类很简单。以下是`compose`方法的第一版代码：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'All you have to do is replace the return value of the `compose` method with
    the argument of the anonymous class’s `apply` method, followed by an arrow (`->`)
    and the return value of the `apply` method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要将`compose`方法的返回值替换为匿名类的`apply`方法的参数，然后是一个箭头（`->`）和`apply`方法的返回值：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can use any name for the argument. [Figure 2.2](#ch02fig02) shows this process.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为参数使用任何名称。[图2.2](#ch02fig02)显示了此过程。
- en: Figure 2.2\. Replacing anonymous classes with lambdas
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2. 用Lambda表达式替换匿名类
- en: '![](Images/02fig02_alt.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/02fig02_alt.jpg)'
- en: 2.3\. Advanced function features
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 高级函数特性
- en: 'You’ve seen how to create `apply` and `compose` functions. You’ve also learned
    that functions can be represented by methods or by objects. But you haven’t answered
    a fundamental question: why do you need function objects? Couldn’t you simply
    use methods? Before answering this question, you have to consider the problem
    of the functional representation of multiargument methods.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何创建`apply`和`compose`函数。你也已经了解到函数可以由方法或对象表示。但你还没有回答一个基本问题：为什么你需要函数对象？你难道不能简单地使用方法吗？在回答这个问题之前，你必须考虑多参数方法的函数表示问题。
- en: 2.3.1\. What about functions of several arguments?
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1. 几个参数的函数怎么办？
- en: 'In [section 2.1.1](#ch02lev2sec1), I said that there are no functions of several
    arguments. There are only functions of one tuple of arguments. The cardinality
    of a tuple may be whatever you need, and there are specific names for tuples with
    a few arguments: pair, triplet, quartet, and so on. Other possible names exist,
    and some prefer to call them tuple2, tuple3, tuple4, and so forth. But I also
    said that arguments can be applied one by one, each application of one argument
    returning a new function, except for the last one.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2.1.1节](#ch02lev2sec1)中，我说过没有多个参数的函数。只有一组参数的函数。元组的基数可以是任何你需要的大小，并且有一些特定的名称用于具有少量参数的元组：pair（对）、triplet（三元组）、quartet（四元组）等等。其他可能的名称也存在，有些人喜欢称它们为tuple2、tuple3、tuple4等等。但我还说过，参数可以逐个应用，每个参数的应用都会返回一个新的函数，除了最后一个参数。
- en: 'Let’s try to define a function for adding two integers. You’ll apply a function
    to the first argument, and this will return a function. The type will be as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试定义一个用于加两个整数的函数。你将对第一个参数应用一个函数，这将返回一个新的函数。其类型如下：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This may seem a bit complicated, particularly if you think that it could have
    been written like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点复杂，尤其是如果你认为它本可以写成这样：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that because of associativity, this is equivalent to
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于结合律，这等价于
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'where the left `Integer` is the type of the argument, and the element between
    parentheses is the return type, which obviously is a function type. If you remove
    the word `Function` from `Function<Integer, Function<Integer, Integer>>`, you
    get this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其中左边的`Integer`是参数的类型，括号内的元素是返回类型，显然是函数类型。如果你从`Function<Integer, Function<Integer,
    Integer>>`中移除单词`Function`，你得到的是这个：
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is exactly the same. The Java way of writing function types is much more
    verbose but not more complex.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全一样。Java编写函数类型的方式更加冗长，但并不更复杂。
- en: Exercise 2.3
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.3
- en: Write a function to add two `Integers`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个用于加两个整数的函数。
- en: Solution 2.3
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 2.3
- en: 'This function will take an `Integer` as its argument and return a function
    from `Integer` to `Integer`, so the type will be `Function<Integer, Function<Integer,
    Integer>>`. Let’s give it the name `add`. It will be implemented using lambdas.
    The end result is shown here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将接受一个`Integer`作为其参数，并返回一个从`Integer`到`Integer`的函数，因此其类型将是`Function<Integer,
    Function<Integer, Integer>>`。让我们给它命名为`add`。它将通过lambda表达式实现。最终结果如下所示：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can see that you’ll soon have problems with the length of the lines! Java
    has no type aliases, but you can achieve the same result through inheritance.
    If you have many functions to define with the same type, you can extend it with
    a much shorter identifier, like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，你很快就会遇到行长的限制！Java没有类型别名，但你可以通过继承来实现相同的结果。如果你有很多具有相同类型的函数要定义，你可以通过一个更短的标识符来扩展它，如下所示：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The number of arguments isn’t limited. You can define functions with as many
    arguments as you need. As I said in the first part of this chapter, functions
    such as the `add` function or the `mult` function you just defined are said to
    be the *curried* form of the equivalent functions of tuples.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的数量不受限制。你可以定义具有所需数量参数的函数。正如我在本章的第一部分所说，像`add`函数或你刚刚定义的`mult`函数这样的函数被称为元组等价函数的*柯里化*形式。
- en: 2.3.2\. Applying curried functions
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 应用柯里化函数
- en: 'You’ve seen how to write curried function types and how to implement them.
    But how do you apply them? Well, just like any function. You apply the function
    to the first argument, and then apply the result to the next argument, and so
    on until the last one. For example, you can apply the `add` function to `3` and
    `5`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何编写柯里化函数类型以及如何实现它们。但你是如何应用它们的呢？嗯，就像任何函数一样。你将对第一个参数应用函数，然后将结果应用于下一个参数，依此类推，直到最后一个参数。例如，你可以将`add`函数应用于`3`和`5`：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, you’re again missing some syntactic sugar. It would be great if you could
    apply a function just by writing its name followed by its argument. It would allow
    coding, as in Scala:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你又遗漏了一些语法糖。如果能直接通过写出函数名后跟其参数来应用一个函数那就太好了。这将允许像Scala那样的编码：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Or even better, as in Haskell:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至更好，像Haskell那样：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Perhaps in a future version of Java?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 或许在Java的将来版本中？
- en: 2.3.3\. Higher-order functions
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 高阶函数
- en: In section 2.14, you wrote a method to compose functions. That method was a
    functional one, taking as its argument a tuple of two functions and returning
    a function. But instead of using a method, you could use a function! This special
    kind of function, taking functions as its arguments and returning functions, is
    called a *higher-order function* (HOF).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.14 节中，你编写了一个组合函数的方法。这种方法是一个函数式方法，它接受两个函数的元组作为参数，并返回一个函数。但你可以使用一个函数而不是方法！这种特殊的函数，接受函数作为参数并返回函数，被称为
    *高阶函数*（HOF）。
- en: Exercise 2.4
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.4
- en: Write a function to compose the two functions `square` and `triple` used in
    exercise 2.2.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数来组合练习 2.2 中使用的两个函数 `square` 和 `triple`。
- en: Solution 2.4
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 2.4
- en: 'This exercise is easy if you follow the right procedure. The first thing to
    do is to write the type. This function will work on two arguments, so it’ll be
    a curried function. The two arguments and the return type will be functions from
    `Integer` to `Integer`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循正确的程序，这个练习就很容易。首先要做的事情是编写类型。这个函数将作用于两个参数，所以它将是一个柯里化函数。两个参数和返回类型将是 `Integer`
    到 `Integer` 的函数：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can call this `T`. You want to create a function taking an argument of
    type `T` (the first argument) and returning a function from `T` (the second argument)
    to `T` (the return value). The type of the function is then as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以称这个为 `T`。你想要创建一个接受类型 `T`（第一个参数）的函数，并返回一个从 `T`（第二个参数）到 `T`（返回值）的函数。函数的类型如下所示：
- en: '[PRE66]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you replace `T` with its value, you obtain the real type:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `T` 替换为其值，你将获得实际类型：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The main problem here is the line length! Let’s now add the implementation,
    which is much easier than the type:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要问题是行长度！现在让我们添加实现，这比类型要简单得多：
- en: '[PRE68]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The complete code is shown here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码如下所示：
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can write this code on a single line! Let’s test this code with the `square`
    and `triple` functions:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此代码写在一行上！让我们用 `square` 和 `triple` 函数测试此代码：
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this code, you start by applying the first argument, which gives you a new
    function to apply to the second argument. The result is a function, which is the
    composition of the two function arguments. Applying this new function to (for
    example) `2` gives you the result of first applying `triple` to `2` and then applying
    `square` to the result (which corresponds to the definition of function composition):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你首先应用第一个参数，这将给你一个应用于第二个参数的新函数。结果是函数，它是两个函数参数的组合。将这个新函数应用于（例如）`2`，这将给出首先将
    `triple` 应用于 `2`，然后将 `square` 应用于结果（这对应于函数组合的定义）：
- en: '[PRE71]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Pay attention to the order of the parameters: `triple` is applied first, and
    then `square` is applied to the result returned by `triple`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数的顺序：`triple` 首先应用，然后 `square` 应用于 `triple` 返回的结果。
- en: 2.3.4\. Polymorphic higher-order functions
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4. 多态高阶函数
- en: Our `compose` function is fine, but it can compose only functions from `Integer`
    to `Integer`. It would be much more interesting if you could compose any types
    of functions, such as `String` to `Double` or `Boolean` to `Long`. But that’s
    only the beginning. A fully polymorphic `compose` function would allow you to
    compose `Function<Integer, Function<Integer, Integer>>`, such as the `add` and
    `mult` you wrote in exercise 2.3\. It should also allow you to compose functions
    of different types, provided that the return type of one is the same as the argument
    type of the other.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `compose` 函数很好，但它只能组合 `Integer` 到 `Integer` 的函数。如果你能组合任何类型的函数，比如 `String`
    到 `Double` 或 `Boolean` 到 `Long`，那就更有趣了。但这只是开始。一个完全多态的 `compose` 函数将允许你组合 `Function<Integer,
    Function<Integer, Integer>>`，比如你在练习 2.3 中编写的 `add` 和 `mult`。它还应该允许你组合不同类型的函数，只要一个函数的返回类型与另一个函数的参数类型相同。
- en: Exercise 2.5 (hard)
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.5（难度较高）
- en: Write a polymorphic version of the `compose` function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `compose` 函数的多态版本。
- en: Hint
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You may face two problems in trying to solve this exercise. The first is the
    lack of polymorphic properties in Java. In Java, you can create polymorphic classes,
    interfaces, and methods, but you can’t define polymorphic properties. The solution
    is to store the function in a method, class, or interface, instead of in a property.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试解决这个练习时，你可能会遇到两个问题。第一个问题是 Java 中缺乏多态属性。在 Java 中，你可以创建多态类、接口和方法，但你不能定义多态属性。解决方案是将函数存储在方法、类或接口中，而不是在属性中。
- en: The second problem is that Java doesn’t handle variance, so you may find yourself
    trying to cast a `Function<Integer, Integer>` to a `Function<Object, Object>`,
    which will result in a compiler error. In this case, you’ll have to help Java
    by specifying the type explicitly.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是 Java 不处理可变性，所以你可能会发现自己试图将 `Function<Integer, Integer>` 强制转换为 `Function<Object,
    Object>`，这将导致编译器错误。在这种情况下，你必须通过明确指定类型来帮助 Java。
- en: Solution 2.5
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解决方案 2.5**'
- en: 'The first step seems to be to “generify” the example of exercise 2.4:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步似乎是“泛化”练习 2.4 的例子：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'But this isn’t possible, because Java doesn’t allow standalone generic properties.
    To be generic, a property must be created in a scope defining the type parameters.
    Only classes, interfaces, and methods can define type parameters, so you have
    to define your property inside one of these elements. The most practical is a
    static method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是不可能的，因为 Java 不允许独立的泛型属性。要成为泛型，属性必须在定义类型参数的作用域内创建。只有类、接口和方法可以定义类型参数，所以你必须在这些元素之一内部定义你的属性。最实用的方法是静态方法：
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Variance**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变性**'
- en: Variance describes how parameterized types behave in relation to subtyping.
    *Covariance* means that `Matcher<Red>` is considered a subtype of `Matcher<Color>`
    if `Red` is a subtype of `Color`. In such case, `Matcher<T>` is said to be covariant
    on `T`. If, on the contrary, `Matcher<Color>` is considered a subtype of `Matcher<Red>`,
    then `Matcher<T>` is said to be contravariant on `T`. In Java, although an `Integer`
    is a subtype of `Object`, a `List<Integer>` is not a subtype of `List<Object>`.
    You may find this strange, but a `List<Integer>` is an `Object`, but it is not
    a `List<Object>`. And a `Function<Integer, Integer>` is not a `Function<Object,
    Object>`. (This is much less surprising!)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 可变性描述了参数化类型相对于子类型的行为。*协变*意味着如果 `Red` 是 `Color` 的子类型，则 `Matcher<Red>` 被认为是 `Matcher<Color>`
    的子类型。在这种情况下，`Matcher<T>` 被说成在 `T` 上是协变的。相反，如果 `Matcher<Color>` 被认为是 `Matcher<Red>`
    的子类型，那么 `Matcher<T>` 被说成在 `T` 上是逆变。在 Java 中，尽管 `Integer` 是 `Object` 的子类型，但 `List<Integer>`
    不是一个 `List<Object>` 的子类型。你可能觉得这很奇怪，但 `List<Integer>` 是一个 `Object`，但它不是一个 `List<Object>`。同样，`Function<Integer,
    Integer>` 不是一个 `Function<Object, Object>`。（这并不那么令人惊讶！）
- en: In Java, all parameterized types are said to be invariant on their parameter.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，所有参数化类型都被说成在其参数上是不可变的。
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE73]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that the method called `higherCompose()` takes no parameter and always
    returns the same value. It’s a constant. The fact that it’s defined as a method
    is irrelevant from this point of view. It isn’t a method for composing functions.
    It’s only a method returning a function to compose functions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，名为 `higherCompose()` 的方法不接受任何参数，并且总是返回相同的值。它是一个常量。从这一角度看，它被定义为方法并不重要。它不是一个用于组合函数的方法。它只是一个返回用于组合函数的函数的方法。
- en: Beware of the order of the type parameters and how they correspond to the implementation
    lambda parameters, as shown in [figure 2.3](#ch02fig03).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类型参数的顺序以及它们如何对应于实现 lambda 参数，如图 2.3 所示。
- en: Figure 2.3\. Pay attention to the order of type parameters.
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3\. 注意类型参数的顺序。
- en: '![](Images/02fig03_alt.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig03_alt.jpg)'
- en: 'You could give the lambda parameters more-meaningful names, such as `uvFunction`
    and `tuFunction`, or more simply `uv` and `tu`, but you should refrain from doing
    so. Names aren’t reliable. They show the intention (of the programmer) and nothing
    else. You could easily switch the names without noticing any change:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 lambda 参数提供更有意义的名称，例如 `uvFunction` 和 `tuFunction`，或者更简单一些，`uv` 和 `tu`，但你应该避免这样做。名称并不可靠。它们显示了（程序员的）意图，但没有其他。你可能会轻易地更改名称而不会注意到任何变化：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this example, `tuFunc` is a function from `U` to `V`, and `uvFunc` is a function
    from `T` to `U`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`tuFunc` 是从 `U` 到 `V` 的函数，而 `uvFunc` 是从 `T` 到 `U` 的函数。
- en: 'If you need more information about the types, you can simply write them in
    front of each lambda parameter, enclosing the type and the parameter between parentheses:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于类型的信息，你可以在每个 lambda 参数前简单地写出它们，将类型和参数括在括号内：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now you might want to use this function in the following way:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想以下这种方式使用这个函数：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'But this doesn’t compile, producing the following error:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不会编译，产生以下错误：
- en: '[PRE77]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The compiler is saying that it couldn’t infer the real types for the `T`, `U`,
    and `V` type parameters, so it used `Object` for all three. But the `square` and
    `triple` functions have types `Function<Integer, Integer>`. If you think that
    this is enough information to infer the `T`, `U`, and `V` types, then you’re smarter
    than Java! Java tried to go the other way around, casting a `Function<Integer,
    Integer>` into a `Function<Object, Object>`. And although an `Integer` is an `Object`,
    a `Function<Integer, Integer>` isn’t a `Function <Object, Object>`. These two
    types aren’t related because types are invariant in Java. For the cast to work,
    the types should have been covariant, but Java doesn’t know about variance.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器表示它无法推断 `T`、`U` 和 `V` 类型参数的实际类型，因此它为所有三个使用了 `Object`。但是，`square` 和 `triple`
    函数的类型是 `Function<Integer, Integer>`。如果你认为这足以推断 `T`、`U` 和 `V` 类型，那么你比Java更聪明！Java试图反过来，将
    `Function<Integer, Integer>` 强制转换为 `Function<Object, Object>`。尽管 `Integer` 是 `Object`
    的子类，但 `Function<Integer, Integer>` 并不是 `Function<Object, Object>` 的子类。这两种类型不相关，因为在Java中类型是不变的。为了使转换工作，类型应该是协变的，但Java不知道关于协变的信息。
- en: 'The solution is to revert to the original problem and help the compiler by
    telling it what real types `T`, `U`, and `V` are. This can be done by inserting
    the type information between the dot and the method name:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是回到原始问题，并帮助编译器通过告诉它 `T`、`U` 和 `V` 的实际类型。这可以通过在点和方法名之间插入类型信息来完成：
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This is somewhat impractical, but that isn’t the main problem. More often,
    you’ll group functions such as `higherCompose` in a library class, and you may
    wish to use static import to simplify the code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点不切实际，但这不是主要问题。更常见的是，你会在库类中将像 `higherCompose` 这样的函数分组，你可能希望使用静态导入来简化代码：
- en: '[PRE79]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Unfortunately, this won’t compile!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不会编译！
- en: Exercise 2.6 (easy now!)
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.6（现在容易多了！）
- en: Write the `higherAndThen` function that composes the functions the other way
    around, which means that `higherCompose(f, g)` is equivalent to `higherAndThen(g,
    f)`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `higherAndThen` 函数，以相反的方式组合函数，这意味着 `higherCompose(f, g)` 等价于 `higherAndThen(g,
    f)`。
- en: Solution 2.6
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 2.6
- en: '[PRE80]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Testing function parameters**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试函数参数**'
- en: 'If you have any doubt concerning the order of the parameters, you should test
    these higher-order functions with functions of different types. Testing with functions
    from `Integer` to `Integer` will be ambiguous, because you’ll be able to compose
    the functions in both orders, so an error will be difficult to detect. Here’s
    a test using functions of different types:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对参数的顺序有疑问，你应该使用不同类型的函数来测试这些高阶函数。使用从 `Integer` 到 `Integer` 的函数进行测试将是模糊的，因为你将能够以两种顺序组合函数，因此错误将难以检测。以下是一个使用不同类型函数的测试示例：
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note that Java is unable to infer the types, so you have to provide them when
    calling the `higherCompose` function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Java 无法推断类型，因此在调用 `higherCompose` 函数时你必须提供它们。
- en: '|  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.3.5\. Using anonymous functions
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.5\. 使用匿名函数
- en: Until now, you’ve been using named functions. These functions were implemented
    as anonymous classes, but the instances you created were named and had explicit
    types. Often you won’t define names for functions, and you’ll use them as anonymous
    instances. Let’s look at an example.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你一直在使用命名函数。这些函数被实现为匿名类，但你创建的实例被命名并且具有显式类型。通常你不会为函数定义名称，而是将它们用作匿名实例。让我们来看一个例子。
- en: Instead of writing
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是写
- en: '[PRE82]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'you can use anonymous functions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用匿名函数：
- en: '[PRE83]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, you use the `compose` method statically defined in the `Function` class.
    But this also applies to higher-order functions:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你使用了在 `Function` 类中静态定义的 `compose` 方法。但这同样适用于高阶函数：
- en: '[PRE84]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Method references**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法引用**'
- en: Beside lambdas, Java 8 also brings method references, which is a syntax that
    can be used to replace a lambda when the lambda implementation consists of a method
    call with a single argument. For example,
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了lambda表达式之外，Java 8 还引入了方法引用，这是一种可以用来替换lambda表达式的语法，当lambda实现仅包含一个参数的方法调用时。例如，
- en: '[PRE85]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'is equivalent to this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于以下内容：
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here, `sin` is a static method in the `Math` class. If it was an instance method
    in the current class, you could have written the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sin` 是 `Math` 类中的静态方法。如果它是当前类中的实例方法，你可以这样写：
- en: '[PRE87]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This kind of code will be often used in this book to make a function out of
    a method.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这类代码将经常在这本书中用来将方法转换为函数。
- en: '|  |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When to use anonymous and when to use named functions
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 何时使用匿名函数和命名函数
- en: Apart from special cases when anonymous functions can’t be used, it’s up to
    you to choose between anonymous and named functions. As a general rule, functions
    that are used only once are defined as anonymous instances. But *used once* means
    that you write the function once. It doesn’t mean that it’s instantiated only
    once.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 除了匿名函数无法使用的一些特殊情况外，选择匿名函数和命名函数取决于你。一般来说，只使用一次的函数被定义为匿名实例。但“只使用一次”意味着你只写一次函数。这并不意味着它只实例化一次。
- en: 'In the following example, you define a method to compute the cosine of a `Double`
    value. The method implementation uses two anonymous functions because you’re using
    a lambda expression and a method reference:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，你定义了一个计算`Double`值余弦的方法。该方法实现使用了两个匿名函数，因为你使用了lambda表达式和方法引用：
- en: '[PRE88]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Don’t worry about the creation of anonymous instances. Java won’t always create
    new objects each time the function is called. And anyway, instantiating such objects
    is cheap. Instead, you should decide whether to use anonymous or named functions
    by considering only the clarity and maintainability of your code. If you’re concerned
    with performance and reusability, you should be using method references as often
    as possible.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心匿名实例的创建。Java不总是在函数被调用时创建新对象。而且，实例化这样的对象成本很低。相反，你应该只考虑代码的清晰性和可维护性来决定是否使用匿名或命名函数。如果你关心性能和可重用性，你应该尽可能频繁地使用方法引用。
- en: Type inference
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Type inference can also be an issue with anonymous functions. In the previous
    example, the types of the two anonymous functions can be inferred by the compiler
    because it knows that the `compose` methods take two functions as arguments:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断也可能与匿名函数有关。在先前的示例中，编译器可以推断出两个匿名函数的类型，因为它知道`compose`方法接受两个函数作为参数：
- en: '[PRE89]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: But this won’t always work. If you replace the second argument with a lambda
    instead of a method reference,
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不总是有效。如果你用lambda代替方法引用来替换第二个参数，
- en: '[PRE90]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'the compiler is lost and displays the following error message:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器迷失方向，显示以下错误信息：
- en: '[PRE91]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The compiler is so confused that it even finds a nonexistent error in column
    44! But the error in column 63 is real. As strange as it may seem, Java is unable
    to guess the type of the second argument. To make this code compile, you have
    to add type annotations:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器如此困惑，甚至在第44列找到了一个不存在的错误！但第63列的错误是真实的。尽管这看起来很奇怪，Java无法猜测第二个参数的类型。为了使这段代码编译，你必须添加类型注解：
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is a good reason to prefer method references.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有理由更喜欢方法引用的。
- en: 2.3.6\. Local functions
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.6\. 局部函数
- en: You just saw that you can define functions locally in methods, but you can’t
    define methods within methods.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到你可以在方法中局部定义函数，但你不能在方法内定义方法。
- en: 'On the other hand, functions can be defined inside functions without any problem
    through lambdas. The most frequent case you’ll encounter is embedded lambdas,
    shown here:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数可以通过lambda在函数内部定义，没有任何问题。你将遇到的最常见情况是嵌套lambda，如下所示：
- en: '[PRE93]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Don’t worry if you don’t understand what this code does. You’ll learn about
    this kind of code in later chapters. Note, however, that the `flatMap` method
    takes a function as its argument (in the form of a lambda), and that the implementation
    of this function (the code after the `->`) defines a new lambda, which corresponds
    to a locally embedded function.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解这段代码的功能，不要担心。你将在后面的章节中学习这类代码。然而，请注意，`flatMap`方法接受一个函数作为其参数（以lambda的形式），而这个函数的实现（`->`之后的代码）定义了一个新的lambda，这对应于一个局部嵌入的函数。
- en: 'Local functions aren’t always anonymous. They’re generally named when used
    as *helper functions*. In traditional Java, using helper methods is common practice.
    These methods allow you to simplify the code by abstracting portions of it. The
    same technique is used with functions, although you may not notice it because
    it’s made implicit when using anonymous lambdas. But using explicitly declared
    local functions is always possible, as in the following example, which is nearly
    equivalent to the previous one:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数不总是匿名的。当它们用作*辅助函数*时，通常会有名字。在传统的Java中，使用辅助方法是常见的做法。这些方法允许你通过抽象代码的部分来简化代码。同样的技术也用于函数，尽管你可能没有注意到，因为在使用匿名lambda时，它是隐式的。但显式声明局部函数总是可能的，如下面的示例所示，它与前面的示例几乎等价：
- en: '[PRE94]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: As mentioned previously, these two forms (with or without local named functions)
    have a little difference that can sometimes become important. When it comes to
    type inference, using named functions implies writing types explicitly, which
    can be necessary when the compiler can’t infer types correctly.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这两种形式（有或没有局部命名函数）之间有一点细微的差别，有时可能会变得很重要。当涉及到类型推断时，使用命名函数意味着必须显式写出类型，这在编译器无法正确推断类型时可能是必要的。
- en: It’s not only useful to the compiler, but also a tremendous help to the programmer
    having trouble with types. Explicitly writing the expected types can help locate
    the exact place where expectations aren’t met.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅对编译器有用，而且对于在类型问题上遇到麻烦的程序员来说也是一个巨大的帮助。明确写出期望的类型可以帮助定位期望未得到满足的确切位置。
- en: 2.3.7\. Closures
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.7. 闭包
- en: You’ve seen that pure functions must not depend on anything other than their
    arguments to evaluate their return values. Java methods often access class members,
    either to read or even write them. Methods may even access static members of other
    classes. I’ve said that *functional* methods are methods that respect referential
    transparency, which means they have no observable effects besides returning a
    value. The same is true for functions. Functions are pure if they don’t have observable
    side effects.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，纯函数必须不依赖于其参数以外的任何东西来评估它们的返回值。Java 方法通常会访问类成员，无论是读取还是甚至写入它们。方法甚至可以访问其他类的静态成员。我曾经说过，*函数式*方法是指尊重引用透明性的方法，这意味着除了返回一个值之外，它们没有可观察的效果。对于函数来说，也是如此。如果函数没有可观察的副作用，它们就是纯函数。
- en: But what about functions (and methods) with return values depending not only
    on their arguments, but on elements belonging to the enclosing scope? You’ve already
    seen this case, and these elements of the enclosing scope could be considered
    implicit parameters of the functions or methods using them.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于返回值不仅依赖于它们的参数，还依赖于封装作用域中元素的函数（和方法）怎么办？你已经看到了这种情况，这些封装作用域中的元素可以被视为使用它们的函数或方法的隐含参数。
- en: 'Lambdas carry an additional requirement: a lambda can access a local variable
    only if it’s final. This requirement isn’t new to lambdas. It was already a requirement
    for anonymous classes prior to Java 8, and lambdas must respect the same condition,
    although it has been made a little less strict. Starting with Java 8, elements
    accessed from anonymous classes or lambdas can be implicitly final; they don’t
    need to be declared `final`, provided they aren’t modified. Let’s look at an example:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式有一个额外的要求：Lambda 表达式只能访问标记为 final 的局部变量。这个要求对 Lambda 表达式来说并不新鲜。在 Java
    8 之前，匿名类就已经有这个要求了，Lambda 表达式必须遵守相同的条件，尽管这个条件已经变得稍微宽松一些。从 Java 8 开始，从匿名类或 Lambda
    表达式中访问的元素可以隐式地被视为 final；如果它们没有被修改，就不需要显式声明为 `final`。让我们来看一个例子：
- en: '[PRE95]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In this example, the `addTax` function “closes” over the `taxRate` local variable.
    This will compile successfully as long as the `taxRate` variable is not modified,
    and there’s no need to explicitly declare the variable `final`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`addTax` 函数“封闭”了 `taxRate` 局部变量。只要 `taxRate` 变量没有被修改，并且不需要显式声明该变量为 `final`，这个程序就可以成功编译。
- en: 'The following example won’t compile because the `taxRate` variable is no longer
    implicitly final:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例无法编译，因为 `taxRate` 变量不再隐式地被视为 final：
- en: '[PRE96]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Note that this requirement only applies to local variables. The following will
    compile without a problem:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个要求仅适用于局部变量。以下代码可以无问题编译：
- en: '[PRE97]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It’s important to note that, in this case, `addTax` is not a function of `price`,
    because it won’t always give the same result for the same argument. It may, however,
    be seen as a function of the tuple `(price, taxRate)`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在这种情况下，`addTax` 不是 `price` 的函数，因为它不会总是对相同的参数给出相同的结果。然而，它可以被视为元组 `(price,
    taxRate)` 的函数。
- en: Closures are compatible with pure functions if you consider them as additional
    implicit arguments. They can, however, cause problems when refactoring the code,
    and also when functions are passed as parameters to other functions. This can
    result in programs that are difficult to read and maintain.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它们视为额外的隐含参数，闭包与纯函数是兼容的。然而，在重构代码时，以及当函数作为参数传递给其他函数时，它们可能会引起问题。这可能导致难以阅读和维护的程序。
- en: 'One way to make programs more modular is to use functions of tuples of arguments:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 使程序更加模块化的一种方法是通过使用参数元组的函数：
- en: '[PRE98]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'But using tuples is cumbersome, because Java doesn’t offer a simple syntax
    for this, except for function arguments, where the parentheses notation can be
    used. You’d have to define a special interface for a function of tuples, such
    as this:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用元组比较麻烦，因为Java没有提供简单的语法来支持这一点，除了函数参数，那里可以使用括号表示法。您必须为元组函数定义一个特殊的接口，例如：
- en: '[PRE99]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This interface can be used in lambdas:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口可以在lambda表达式中使用：
- en: '[PRE100]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note that the lambda is the only place where Java allows you to use the `(x,
    y)` notation for tuples. Unfortunately, it can’t be used in any other cases, such
    as returning a tuple from a function.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，lambda表达式是Java允许您使用`(x, y)`表示元组的唯一地方。不幸的是，它不能用于其他任何情况，例如从函数返回一个元组。
- en: 'You could also use the class `BiFunction` defined in Java 8, which simulates
    a function of a tuple of two arguments, or even `BinaryOperator`, which corresponds
    to a function of a tuple of two arguments of the same type, or even `DoubleBinaryOperator`,
    which is a function of a tuple of two `double` primitives. All these possibilities
    are fine, but what if you need three arguments or more? You could define `Function3`,
    `Function4`, and so on. But currying is a much better solution. That’s why it’s
    absolutely necessary to learn to use currying, which, as you already saw, is extremely
    simple:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Java 8中定义的`BiFunction`类，它模拟了两个参数元组的函数，或者甚至是`BinaryOperator`，它对应于相同类型两个参数的元组函数，或者甚至是`DoubleBinaryOperator`，它是一个两个`double`原始值的元组函数。所有这些可能性都是可行的，但如果你需要三个或更多的参数呢？你可以定义`Function3`、`Function4`等等。但柯里化是一个更好的解决方案。这就是为什么学习如何使用柯里化是绝对必要的，正如您已经看到的，柯里化非常简单：
- en: '[PRE101]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 2.3.8\. Partial function application and automatic currying
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.8. 部分函数应用和自动柯里化
- en: The closure and curried versions in the previous example give the same results
    and may be seen as equivalent. In fact, they are “semantically” different. As
    I’ve already said, the two parameters play totally different roles. The tax rate
    isn’t supposed to change often, whereas the price is supposed to be different
    on each invocation. This appears clearly in the closure version. The function
    closes over a parameter that doesn’t change (because it’s final). In the curried
    version, both arguments may change on each invocation, although the tax rate won’t
    change more often than in the closure version.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的闭包和柯里化版本给出了相同的结果，并且可能被视为等价。实际上，它们在“语义上”是不同的。正如我之前所说的，两个参数扮演着完全不同的角色。税率不经常改变，而价格在每次调用时都应该是不同的。这在闭包版本中表现得非常明显。函数覆盖了一个不改变的参数（因为它被声明为final）。在柯里化版本中，两个参数在每次调用时都可能改变，尽管税率不会比闭包版本改变得更频繁。
- en: 'It’s common to need a changing tax rate, such as when you have several tax
    rates for different categories of products or for different shipping destinations.
    In traditional Java, this could be accommodated by turning the class into a parameterized
    “tax computer”:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 需要变化的税率是很常见的，例如，当你有不同产品类别或不同配送目的地的多个税率时。在传统的Java中，可以通过将类转换为参数化的“税率计算器”来适应这种情况：
- en: '[PRE102]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This class allows you to instantiate several `TaxComputer` instances for several
    tax rates, and these instances can be reused as often as needed:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许您为多个税率创建多个`TaxComputer`实例，并且这些实例可以根据需要重复使用：
- en: '[PRE103]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The same thing can be achieved with a function by partially applying it:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部分应用函数也可以实现相同的效果：
- en: '[PRE104]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Here, the `addTax` function is the one from the end of [section 2.3.7](#ch02lev2sec25).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`addTax`函数是来自[第2.3.7节](#ch02lev2sec25)的结尾。
- en: You can see that currying and partial application are closely related. Currying
    consists of replacing a function of a tuple with a new function that you can partially
    apply, one argument after the other. This is the main difference between a curried
    function and a function of a tuple. With a function of a tuple, all arguments
    are evaluated before the function is applied. With the curried version, all arguments
    must be known before the function is totally applied, but a single argument can
    be evaluated before the function is partially applied to it. You aren’t obliged
    to totally curry the function. A function of three arguments can be curried into
    a function of a tuple that produces a function of a single argument.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，柯里化和部分应用密切相关。柯里化包括用一个可以部分应用的新函数替换一个元组函数，你可以逐个参数地部分应用。这是柯里化函数和元组函数之间的主要区别。在元组函数中，所有参数在函数应用之前都被评估。在柯里化版本中，所有参数必须在函数完全应用之前都已知，但在部分应用之前，单个参数可以被评估。你没有义务完全柯里化函数。一个有三个参数的函数可以被柯里化为一个产生单个参数的元组函数。
- en: 'In functional programming, currying and partially applying functions is done
    so often that it’s useful to abstract these operations in order to be able to
    do this automatically. In the preceding sections, you used only curried functions
    and not functions of tuples. This presents a great advantage: partially applying
    this kind of function is absolutely straightforward.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，柯里化和部分应用函数非常常见，因此抽象这些操作以便能够自动执行是有用的。在前面的章节中，你只使用了柯里化函数而没有使用元组函数。这带来了巨大的优势：部分应用这类函数绝对简单明了。
- en: Exercise 2.7 (very easy)
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.7（非常简单）
- en: Write a functional method to partially apply a curried function of two arguments
    to its first argument.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数式方法，将两个参数的柯里化函数部分应用到它的第一个参数上。
- en: Solution 2.7
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 2.7
- en: 'You have nothing to do! The signature of this method is as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你什么也不用做！这个方法的结构如下：
- en: '[PRE105]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can see immediately that partially applying the first argument is as simple
    as applying the second argument (a function) to the first one:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看出，部分应用第一个参数就像将第二个参数（一个函数）应用到第一个参数上一样简单：
- en: '[PRE106]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: (If you’d like to see an example of how `partialA` may be used, please look
    at the unit test for this exercise, in the accompanying code.)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你想看看`partialA`如何使用的一个例子，请查看这个练习的单元测试，在附带的代码中。）
- en: You may note that the original function was of type `Function<A, Function<B,
    C>>`, which means `A` → `B` → `C`. What if you want to partially apply this function
    to the second argument?
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到原始函数的类型是`Function<A, Function<B, C>>`，这意味着`A` → `B` → `C`。如果你想将这个函数部分应用到第二个参数上怎么办？
- en: Exercise 2.8
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.8
- en: Write a method to partially apply a curried function of two arguments to its
    second argument.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个方法，将两个参数的柯里化函数部分应用到它的第二个参数上。
- en: Solution 2.8
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 2.8
- en: 'With our previous function, the answer to the problem would be a method with
    the following signature:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的函数，这个问题的答案将是一个具有以下签名的函数：
- en: '[PRE107]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This exercise is slightly more difficult, but still simple if you carefully
    consider the types. Remember, you should always trust the types! They won’t give
    you an immediate solution in all cases, but they will lead you to the solution.
    This function has only one possible implementation, so if you find an implementation
    that compiles, you can be sure it’s correct!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习稍微难一些，但如果仔细考虑类型，仍然很简单。记住，你应该始终相信类型！它们不会在所有情况下立即给你解决方案，但它们会引导你找到解决方案。这个函数只有一个可能的实现，所以如果你找到一个可以编译的实现，你可以确信它是正确的！
- en: 'What you know is you must return a function from `A` to `C`. So you can start
    the implementation by writing this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你必须从一个`A`返回一个函数到`C`。所以你可以通过写下这个来开始实现：
- en: '[PRE108]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Here, `a` is a variable of type `A`. After the right arrow, you must write
    an expression that’s composed of the function `f` and the variables `a` and `b`,
    and it must evaluate to a function from `A` to `C`. The function `f` is a function
    from `A` to `B -> C`, so you can start by applying it to the `A` you have:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a`是一个类型为`A`的变量。在右箭头之后，你必须写一个由函数`f`和变量`a`和`b`组成的表达式，并且它必须评估为一个从`A`到`C`的函数。函数`f`是一个从`A`到`B
    -> C`的函数，所以你可以从应用到已有的`A`开始：
- en: '[PRE109]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This gives you a function from `B` to `C`. You need a `C`, and you already
    have a `B`, so once again, the answer is straightforward:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你一个从`B`到`C`的函数。你需要一个`C`，你已经有一个`B`，所以答案再次简单明了：
- en: '[PRE110]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: That’s it! In fact, you had nearly nothing to do but to follow the types.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！实际上，你几乎什么都没做，只是遵循了类型。
- en: As I said, the most important thing is that you had a curried version of the
    function. You’ll probably learn quickly how to write curried functions directly.
    One task that comes back frequently when starting to write functional Java programs
    is converting methods with several arguments into curried functions. This is extremely
    simple.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，最重要的是你有一个函数的curry版本。你可能会很快学会如何直接编写curry函数。当开始编写功能Java程序时，一个经常出现的任务是转换具有多个参数的方法为curry函数。这非常简单。
- en: Exercise 2.9 (very easy)
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9（非常简单）
- en: 'Convert the following method into a curried function:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法转换为curry函数：
- en: '[PRE111]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: (I agree that this method is totally useless, but it’s just an exercise.)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: （我同意这种方法完全无用，但这只是一个练习。）
- en: Solution 2.9
  id: totrans-430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 2.9
- en: Once again, you don’t have much to do besides replacing the commas with right
    arrows. Remember, however, that you must define this function in a scope that
    accepts type parameters, which isn’t the case for a property. You must then define
    it in a class, an interface, or a method with all needed type parameters.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，除了将逗号替换为右箭头外，你不需要做太多。然而，请记住，你必须在一个接受类型参数的作用域中定义此函数，而对于属性来说并不是这样。因此，你必须在类、接口或具有所有所需类型参数的方法中定义它。
- en: 'You’ll do it with a method. First, write the method type parameters:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用一个方法来完成它。首先，写下方法类型参数：
- en: '[PRE112]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Then, add the return type. It seems difficult at first, but it’s only difficult
    to read. Just write the word `Function<` followed by the first parameter type
    and a comma:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加返回类型。一开始可能觉得困难，但实际上只是阅读起来困难。只需写下单词`Function<`，然后是第一个参数类型和一个逗号：
- en: '[PRE113]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Then do the same thing with the second parameter type:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对第二个参数类型做同样的事情：
- en: '[PRE114]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Then continue until no parameters are left:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然后继续，直到没有参数为止：
- en: '[PRE115]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Add the return type and close all opened brackets:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 添加返回类型并关闭所有打开的括号：
- en: '[PRE116]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Add the name of the function and the braces:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 添加函数名称和大括号：
- en: '[PRE117]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'For the implementation, list as many parameters as needed, separating them
    with right arrows (ending with an arrow):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，列出所需的所有参数，用右箭头分隔（以箭头结束）：
- en: '[PRE118]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Finally, add the implementation, which is the same as in the original method:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加实现，与原始方法相同：
- en: '[PRE119]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The same principle can be applied to curry a function of a tuple.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则可以应用于将元组的函数curry。
- en: Exercise 2.10
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.10
- en: Write a method to curry a function of a `Tuple<A, B>` to `C`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个将`Tuple<A, B>`类型的函数curry到`C`类型的方法。
- en: Solution 2.10
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 2.10
- en: 'Again, you just have to follow the types. You know the method will take a parameter
    of type `Function<Tuple<A, B>, C>` and will return `Function<A, Function<B, C>>`,
    so the signature is as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你只需要遵循类型。你知道该方法将接受类型为`Function<Tuple<A, B>, C>`的参数，并将返回`Function<A, Function<B,
    C>>`，因此签名如下：
- en: '[PRE120]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, for the implementation, you’ll have to return a curried function of two
    arguments, so you can start with this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于实现，你将需要返回一个具有两个参数的curry函数，所以你可以从以下开始：
- en: '[PRE121]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Eventually, you need to evaluate the return type. For this, you can use the
    function `f` and apply it to a new `Tuple` built with parameters `a` and `b`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你需要评估返回类型。为此，你可以使用函数`f`并将其应用于使用参数`a`和`b`构建的新`Tuple`：
- en: '[PRE122]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Once again, if it compiles, it can’t be wrong. This certainty is one of the
    numerous benefits of functional programming! (This isn’t always true, but you’ll
    learn in the next chapter how to make this happen more often.)
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果它编译成功，那么它就不会出错。这种确定性是函数式编程的众多好处之一！（这并不总是正确的，但你将在下一章中学习如何更频繁地实现这一点。）
- en: 2.3.9\. Switching arguments of partially applied functions
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.9\. 将部分应用函数的参数进行切换
- en: 'If you have a function of two arguments, you might want to apply only the first
    argument to get a partially applied function. Let’s say you have the following
    function:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个接受两个参数的函数，你可能只想应用第一个参数以得到一个部分应用函数。假设你有一个以下函数：
- en: '[PRE123]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'You might want to first apply the tax to get a new function of one argument
    that you can then apply to any price:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先想应用税，得到一个只有一个参数的新函数，然后你可以将其应用于任何价格：
- en: '[PRE124]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Then, when you want to add tax to a price, you can do this:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你想对价格加税时，你可以这样做：
- en: '[PRE125]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This is fine, but what if the initial function was as follows?
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但如果初始函数如下呢？
- en: '[PRE126]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In this case, the price is the first argument. Applying the price only is probably
    useless, but how can you apply the tax only? (You suppose you don’t have access
    to the implementation.)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，价格是第一个参数。仅应用价格可能没有用，但如何只应用税呢？（假设你没有访问实现。）
- en: Exercise 2.11
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.11
- en: Write a method to swap the arguments of a curried function.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个方法来交换柯里化函数的参数。
- en: Solution 2.11
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案2.11
- en: 'The following method returns a curried function with the arguments in reverse
    order. It could be generalized to any number of arguments and to any arrangement
    of them:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法返回一个参数顺序相反的柯里化函数。它可以推广到任意数量的参数和它们的任意排列：
- en: '[PRE127]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Given this method, you can partially apply any of the two arguments. For example,
    if you have a function computing the monthly payment for a loan from an interest
    rate and an amount:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个方法，你可以部分应用任意一个参数。例如，如果你有一个从利率和金额计算贷款月供的函数：
- en: '[PRE128]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: You can very easily create a function of one argument to compute the payment
    for a fixed amount and a varying rate, or a function computing the payment for
    a fixed rate and a varying amount.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以非常容易地创建一个只有一个参数的函数，用于计算固定金额和变动利率的付款，或者创建一个计算固定利率和变动金额的付款的函数。
- en: 2.3.10\. Recursive functions
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.10\. 递归函数
- en: Recursive functions are a ubiquitous feature in most functional programming
    languages, although recursion and functional programming aren’t connected. Some
    functional programmers even say that recursion is the goto feature of functional
    programming, and thus should be avoided as much as possible. Nevertheless, as
    functional programmers, you must master recursion, even if eventually you decide
    to avoid it.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数是大多数函数式编程语言中普遍存在的特性，尽管递归和函数式编程并不相关。一些函数式程序员甚至说递归是函数式编程的goto特性，因此应尽可能避免。尽管如此，作为函数式程序员，你必须掌握递归，即使你最终决定避免它。
- en: As you may know, Java is limited in terms of recursion. Methods can call themselves
    recursively, but this implies that the state of the computation is pushed on the
    stack for each recursive call, until a terminal condition is reached, at which
    time all preceding states of the computation are popped out of the stack, one
    after the other, and evaluated. The size of the stack can be configured, but all
    threads will use the same size. The default size varies according to the implementation
    of Java, from 320 KB for a 32-bit version to 1,064 KB for a 64-bit implementation,
    both of which are very small compared to the size of the heap, where objects are
    stored. The end result is that the number of recursive steps is limited.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Java在递归方面有限制。方法可以递归调用自身，但这意味着计算状态在每次递归调用时都会推入栈中，直到达到终止条件，此时所有先前的计算状态都会依次从栈中弹出并评估。栈的大小可以配置，但所有线程都将使用相同的大小。默认大小根据Java的实现而变化，32位版本的默认大小为320
    KB，64位实现的默认大小为1,064 KB，这两个大小与存储对象的数据堆的大小相比都非常小。结果是递归步骤的数量受到限制。
- en: Determining how many recursive steps Java can handle is difficult, because it
    depends on the size of the data that’s pushed on the stack, and also on the state
    of the stack when the recursive process starts. In general, Java can handle about
    5,000 to 6,000 steps.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 确定Java可以处理多少递归步骤是困难的，因为这取决于推入栈中的数据大小，以及递归过程开始时的栈状态。一般来说，Java可以处理大约5,000到6,000步。
- en: Pushing this limit artificially is possible because Java uses memoization internally.
    This technique consists of storing the results of functions or methods in memory
    to speed up future access. Instead of reevaluating a result, Java can retrieve
    it from memory if it has previously been stored. Besides speeding access, this
    can allow you to partly avoid recursion by finding a terminal state much quicker.
    We’ll come back to this subject in [chapter 4](kindle_split_011.xhtml#ch04), where
    you’ll learn how to create heap-based recursion in Java. For the rest of this
    section, you’ll pretend Java’s standard recursion isn’t broken.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 通过人工提高这个限制是可能的，因为Java内部使用了记忆化。这种技术包括将函数或方法的结果存储在内存中，以加快未来的访问速度。Java不需要重新评估结果，如果它已经被存储在内存中，可以直接从内存中检索。除了加快访问速度外，这还可以通过更快地找到终止状态来部分避免递归。我们将在[第4章](kindle_split_011.xhtml#ch04)中回到这个话题，你将学习如何在Java中创建基于堆的递归。在本节的其余部分，你将假装Java的标准递归没有损坏。
- en: 'A recursive method is simple to define. The method `factorial(int n)` can be
    defined as returning `1` if its argument is 0, and `n * factorial(n – 1)` otherwise:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 递归方法定义简单。方法`factorial(int n)`可以定义为当其参数为0时返回`1`，否则返回`n * factorial(n – 1)`：
- en: '[PRE129]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Recall that this will overflow the stack for `n` being somewhere between 5,000
    and 6,000, so don’t use this kind of code in production.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当`n`在5,000到6,000之间时，这会导致栈溢出，所以不要在生产环境中使用这种代码。
- en: So writing recursive methods is easy. What about recursive functions?
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 所以编写递归方法很容易。递归函数呢？
- en: Exercise 2.12
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.12
- en: Write a recursive factorial function.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个递归阶乘函数。
- en: Hint
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You shouldn’t try to write an anonymous recursive function, because for the
    function to be able to call itself, it must have a name, and it must be defined
    under that name before calling itself. Because it should already be defined when
    it calls itself, that implies that it should be defined before you try to define
    it!
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该尝试编写匿名递归函数，因为为了函数能够调用自己，它必须有一个名字，并且必须在调用自己之前以那个名字定义它。因为它在调用自己时应该已经定义，这意味着它应该在尝试定义它之前就已经定义了！
- en: Solution 2.12
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 2.12
- en: 'Put aside this chicken-and-egg problem for the moment. Converting a single
    argument method into a function is straightforward. The type is `Function<Integer,
    Integer>`, and the implementation should be the same as for the method:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时放下这个鸡生蛋的问题。将单参数方法转换为函数很简单。类型是`Function<Integer, Integer>`，实现应该与方法相同：
- en: '[PRE130]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Now for the tricky part. This code won’t compile because the compiler will complain
    about an `Illegal self reference`. What does this mean? Simply that when the compiler
    reads this code, it’s in the process of defining the `factorial` function. During
    this process, it encounters a call to the `factorial` function, which isn’t yet
    defined.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是棘手的部分。这段代码无法编译，因为编译器会抱怨`非法自引用`。这是什么意思？简单来说，当编译器读取这段代码时，它正在定义`factorial`函数。在这个过程中，它遇到了对`factorial`函数的调用，而这个函数尚未定义。
- en: 'As a consequence, defining a local recursive function isn’t possible. But can
    you declare this function as a member variable or as a static variable? This wouldn’t
    solve the self-reference problem, because it would be equivalent to defining a
    numeric variable such as this:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义一个局部递归函数是不可能的。但是你能把这个函数声明为成员变量或静态变量吗？这并不能解决自引用问题，因为它相当于定义了一个数值变量，例如这样的：
- en: '[PRE131]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'This problem can be solved by first declaring the variable, and then changing
    its value, which can be done in the constructor or in any method but is much more
    convenient in an initializer, such as the following:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过首先声明变量，然后更改其值来解决，这可以在构造函数或任何方法中完成，但在初始化器中更方便，如下所示：
- en: '[PRE132]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'This works because members are defined before initializers are executed, so
    the variable will first be initialized to the default value (`0` for an `int`,
    `null` for a function). The fact that the variable is `null` for some time shouldn’t
    be a real problem because initializers are executed before the constructor, so
    unless some other initializer uses this variable, you’re safe. This trick can
    be used to define your function:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为成员变量是在初始化器执行之前定义的，所以变量首先会被初始化为默认值（对于`int`是`0`，对于函数是`null`）。变量在一段时间内为`null`不应该是一个真正的问题，因为初始化器是在构造函数之前执行的，所以除非其他初始化器使用了这个变量，否则你是安全的。这个技巧可以用来定义你的函数：
- en: '[PRE133]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This can also be used for statically defined functions:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用来定义静态函数：
- en: '[PRE134]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The only problem with this trick is that the field may not be declared `final`,
    which is annoying because functional programmers love immutability. Fortunately,
    another trick is available for this:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧的唯一问题是字段可能没有被声明为`final`，这很烦人，因为函数式程序员喜欢不可变性。幸运的是，还有另一个技巧可用：
- en: '[PRE135]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'By adding `this.` before the variable name, it’s possible to self-reference
    it while making it final. For the `static` implementation, you just have to replace
    `this` with the name of the including class:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量名前添加`this.`，可以在将其声明为`final`的同时进行自引用。对于`static`实现，只需将`this`替换为包含类的名称即可：
- en: '[PRE136]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 2.3.11\. The identity function
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.11. 同一函数
- en: You’ve seen that in functional programming, functions are treated as data. They
    can be passed as arguments to other functions, can be returned by functions, and
    can be used in operations, exactly like integers or doubles. In future programs,
    you’ll apply operations to functions, and you’ll need a neutral element, or identity
    element, for these operations. A neutral element will act as the 0 for addition,
    or 1 for multiplication, or the empty string for string concatenation.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到在函数式编程中，函数被当作数据来处理。它们可以作为其他函数的参数传递，可以被函数返回，也可以在操作中使用，就像整数或双精度浮点数一样。在未来的程序中，你将对函数应用操作，你需要这些操作的中性元素，或者称为单位元素。中性元素将作为加法的0，乘法的1，或者字符串连接的空字符串。
- en: 'The identity function can be added to the definition of our `Function` class
    in the form of a method named `identity`, returning the identity function:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将恒等函数添加到我们的 `Function` 类的定义中，形式为一个名为 `identity` 的方法，返回恒等函数：
- en: '[PRE137]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: With this additional method, our `Function` interface is now complete, as shown
    in the following listing.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个额外的方法，我们的 `Function` 接口现在已经完整，如下所示。
- en: Listing 2.2\. The complete `Function` interface
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 完整的 `Function` 接口
- en: '[PRE138]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 2.4\. Java 8 functional interfaces
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. Java 8 功能接口
- en: Lambdas are used in places where a specific interface is expected. This is how
    Java can determine which method to call. Java doesn’t impose any constraints on
    naming, as may be the case in other languages. The only constraint is that the
    interface used must not be ambiguous, which generally means it should have only
    one abstract method. (In reality, it’s a bit more complex, because some methods
    don’t count.) Such interfaces are said to be *SAM type, for single abstract method*,
    and are called *functional interfaces*.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 适用于需要特定接口的地方。这就是 Java 如何确定调用哪个方法。Java 不对命名施加任何约束，这在其他语言中可能是常见的情况。唯一的约束是所使用的接口不得模糊，这通常意味着它应该只有一个抽象方法。（实际上，这要复杂一些，因为有些方法不计入在内。）这样的接口被称为
    *SAM 类型，即单抽象方法类型*，并被称为 *功能接口*。
- en: 'Note that lambdas aren’t used only for functions. In standard Java 8, many
    functional interfaces are available, although they aren’t all related to functions.
    The most important ones are listed here:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，lambda 并不仅仅用于函数。在标准的 Java 8 中，有许多功能接口可用，尽管它们并不都与函数相关。最重要的接口在此列出：
- en: '`java.util.function.Function` is close to the `Function` developed in this
    chapter. It adds a wildcard to the method parameter types to make them more useful.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.function.Function` 几乎与本章中开发的 `Function` 相同。它为方法参数类型添加了一个通配符，使它们更有用。'
- en: '`java.util.function.Supplier` is equivalent to a function with no argument.
    In functional programming, it’s a constant, so it might not look useful at first,
    but it has two specific uses: First, if it’s not referentially transparent (not
    a pure function), it can be used to supply variable data, such as time or random
    numbers. (We won’t use such nonfunctional things!) The second use, much more interesting,
    is to allow lazy evaluation. We’ll come back to this subject often in the next
    chapters.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.function.Supplier` 等同于一个无参数的函数。在功能编程中，它是一个常量，所以一开始可能看起来没有用，但它有两个特定的用途：首先，如果它不是引用透明的（不是一个纯函数），它可以用来提供变量数据，例如时间或随机数。（我们不会使用这样的非功能事物！）第二个用途，更有趣，是允许延迟评估。我们将在下一章经常回到这个主题。'
- en: '`java.util.function.Consumer` isn’t at all for functions, but for effects.
    (Here, it’s not a *side* effect, because the effect is the only result you get
    with a `Consumer`, since it doesn’t return anything.)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.function.Consumer` 完全不是用于函数，而是用于效果。（在这里，它不是一个 *副作用*，因为 `Consumer`
    的效果是唯一的结果，因为它不返回任何内容。）'
- en: '`java.lang.Runnable` can also be used for effects that don’t take any parameters.
    It’s often preferable to create a special interface for this, because `Runnable`
    is supposed to be used with threads, and most syntax-checking tools will complain
    if it’s used in another context.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Runnable` 也可以用于不需要任何参数的效果。通常最好为此创建一个特殊的接口，因为 `Runnable` 应用于线程，如果它在其他上下文中使用，大多数语法检查工具都会抱怨。'
- en: Java defines many other functional interfaces (43 in the `java.util.function`
    package) that are mostly useless for functional programming. Many of them deal
    with primitives and others with functions of two arguments, and there are special
    versions for operations (functions of two arguments of the same type).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: Java 定义了许多其他功能接口（`java.util.function` 包中有 43 个），它们对于功能编程来说大多是无用的。其中许多处理原始数据类型，其他处理两个参数的函数，还有针对操作（相同类型两个参数的函数）的特殊版本。
- en: In this book, I don’t talk much about standard Java 8 functions. This is intentional.
    This isn’t a book about Java 8\. It’s a book about functional programming, and
    it happens to use Java for the examples. You’re learning how to construct things
    rather than to use provided components. After you master the concepts, it’ll be
    up to you to choose between your own functions or the standard Java 8 ones. Our
    `Function` is similar to the Java 8 `Function`. It doesn’t use a wildcard for
    its argument in order to simplify the code shown in the book. On the other hand,
    the Java 8 `Function` doesn’t define `compose` and `andThen` as higher-order functions,
    but only as methods. Other than these differences, these `Function` implementations
    are interchangeable.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我并没有过多地讨论标准的Java 8函数。这是故意的。这不是一本关于Java 8的书。这是一本关于函数式编程的书，恰好使用了Java作为示例。你正在学习如何构建事物，而不是使用提供的组件。在你掌握这些概念之后，选择使用自己的函数还是标准的Java
    8函数将取决于你。我们的`Function`与Java 8的`Function`类似。它为了简化书中展示的代码，没有为其参数使用通配符。另一方面，Java
    8的`Function`没有将`compose`和`andThen`定义为高阶函数，而只是作为方法。除了这些差异之外，这些`Function`实现是可以互换的。
- en: 2.5\. Debugging with lambdas
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 使用lambda进行调试
- en: 'Using lambdas promotes a new style of code writing. Code that was once written
    in several short lines is often replaced with one-liners such as this:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda促进了代码编写的新风格。曾经需要写多条短行的代码，现在通常被一行代码所替代，如下所示：
- en: '[PRE139]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: (Here, the implementation of the `ifElse` method is split over two lines because
    of the book margins, but in a code editor it could be on a single line.)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: （在这里，由于书籍的页边距，`ifElse`方法的实现被拆分到两行，但在代码编辑器中它可以在一行中完成。）
- en: In Java 5 to 7, this code would be written without using lambdas, as shown in
    the following listing.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 5到7版本中，这段代码会不使用lambda来编写，如下所示。
- en: Listing 2.3\. A one-liner lambda-based method converted to previous Java versions
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.3\. 将基于lambda的一行代码方法转换为之前的Java版本
- en: '[PRE140]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Obviously, reading and writing the lambda version is much easier. The pre-Java
    8 versions were often considered too complicated to be acceptable. But when it
    comes to debugging, the lambda version is much more of a problem. If a single
    line is equivalent to 20 lines of traditional code, how can you put breakpoints
    in it to find potential errors? The problem is that not all debuggers are powerful
    enough to be used easily with lambdas. This will eventually change, but in the
    meantime you might have to find other solutions. One simple solution is to break
    the one-line version into several lines, such as this:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，阅读和编写lambda版本要容易得多。Java 8之前的版本通常被认为过于复杂，难以接受。但是，当涉及到调试时，lambda版本却是一个更大的问题。如果一行代码等同于20行传统代码，你如何在其上设置断点来查找潜在的错误呢？问题是，并非所有调试器都有足够强大的功能来轻松地与lambda一起使用。这最终会改变，但在此期间，你可能需要找到其他解决方案。一个简单的解决方案是将一行代码拆分成多行，如下所示：
- en: '[PRE141]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This allows you to set breakpoints on each physical line. It’s certainly useful
    and it makes the code easier to read (and easier to publish in books). But it
    doesn’t solve our problem because each line still contains many elements that
    can’t always be investigated through traditional debuggers.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在每一行物理代码上设置断点。这当然很有用，它使得代码更容易阅读（并且更容易在书中发布）。但这并没有解决我们的问题，因为每一行仍然包含许多元素，这些元素并不能总是通过传统的调试器来调查。
- en: To make this problem less crucial, it’s important to extensively unit test each
    component, which means each method and each function passed as an argument to
    each method. Here, it’s easy. The methods used are (in order of appearance) `List.zip`,
    `Option.flatMap`, `List.first`, `Option.map`, and `Option.getOrElse`. Whatever
    these methods are doing, they can be extensively tested. You don’t know about
    them yet, but you’ll build the `Option` and `List` components in the next chapters,
    and also write the implementations of the `map`, `flatMap`, `first`, `zip`, and
    `getOrElse` methods (as well as many others). As you’ll see, these methods are
    purely functional. They can’t throw any exceptions and they always return the
    intended result without doing anything else. So, after they’re fully tested, nothing
    bad can happen.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个问题不那么关键，对每个组件进行广泛的单元测试非常重要，这意味着每个方法和每个作为方法参数传递的函数。在这里，这很容易。使用的方法（按出现顺序）是
    `List.zip`、`Option.flatMap`、`List.first`、`Option.map` 和 `Option.getOrElse`。无论这些方法做什么，都可以进行广泛的测试。你可能还不知道它们，但你在下一章中将会构建
    `Option` 和 `List` 组件，并编写 `map`、`flatMap`、`first`、`zip` 和 `getOrElse` 方法的实现（以及许多其他方法）。正如你将看到的，这些方法是纯函数式的。它们不能抛出任何异常，并且总是返回预期的结果，而不做任何其他事情。因此，在它们完全测试之后，就不会发生任何坏事。
- en: 'Regarding the functions, the preceding example uses three of them:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数，前面的例子使用了其中三个：
- en: '`x` → `x.first`'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` → `x.first`'
- en: '`y` → `y._1`'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y` → `y._1`'
- en: '`x` → `x._2`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` → `x._2`'
- en: The first one can’t throw any exceptions because `x` can’t be `null` (you’ll
    see why in [chapter 5](kindle_split_012.xhtml#ch05)), and method `first` can’t
    throw an exception either.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数不能抛出任何异常，因为 `x` 不能为 `null`（你将在第 5 章中看到原因），并且 `first` 方法也不能抛出异常。
- en: The second and third functions can’t throw a `NullPointerException` because
    you’ve ensured that a `Tuple` couldn’t be constructed with `null` arguments. (See
    [chapter 1](kindle_split_008.xhtml#ch01) for the code of the `Tuple` class.) [Figure
    2.4](#ch02fig04) shows these functions in their anonymous form.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个函数不能抛出 `NullPointerException`，因为你已经确保 `Tuple` 不能用 `null` 参数构造。（参见第 1
    章中的 `Tuple` 类代码。）[图 2.4](#ch02fig04) 展示了这些函数的匿名形式。
- en: Figure 2.4\. Functions in their anonymous form
  id: totrans-539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.4\. 匿名形式的函数
- en: '![](Images/02fig04_alt.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig04_alt.jpg)'
- en: 'This is one area where functional programming shines: if no components can
    break, the whole program can’t either. In imperative programming, components might
    work fine in tests but break in production because of some nondeterministic behavior.
    If the behavior of a component depends on external conditions, you have no way
    to fully test it. And even if no component has any problem as a unit, the composition
    of several components could create conditions for the program to be ill-behaved.
    This can’t happen with functional programming. If the components have a deterministic
    behavior, the whole composition will be deterministic too.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在函数式编程中表现出色的一个领域：如果没有任何组件可以崩溃，整个程序也无法崩溃。在命令式编程中，组件可能在测试中运行良好，但在生产中由于某些非确定性行为而崩溃。如果组件的行为依赖于外部条件，你将无法完全测试它。即使没有任何组件作为单元有问题，多个组件的组合也可能为程序的不当行为创造条件。这种情况在函数式编程中是不会发生的。如果组件具有确定性行为，整个组合也将是确定性的。
- en: Many spots remain open for errors. The program might not do what is expected,
    because the components may be composed the wrong way. But implementation errors
    can’t cause an unwanted crash. If this program crashes, it will be, for example,
    because a `null` reference has been passed to the `Tuple` constructor. You don’t
    need a debugger to catch this kind of error.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 许多地方仍然存在错误的可能性。程序可能不会按预期执行，因为组件可能被错误地组合。但是实现错误不会导致意外的崩溃。如果这个程序崩溃，那可能是由于将 `null`
    引用传递给了 `Tuple` 构造函数。你不需要调试器来捕获这类错误。
- en: So, yes, debugging functional programs that use lambdas extensively is somewhat
    more difficult than debugging imperative programs, but debugging is much less
    necessary, provided all the components have been validated. Keep in mind that
    this is true only if a thrown exception crashes the program. We’ll come back to
    this in [chapter 6](kindle_split_013.xhtml#ch06). But for now, remember that by
    default, an exception or an error thrown will only crash the thread in which it
    happened, and not the whole application. Even an `OutOfMemoryError` might not
    crash the application, so you, as the programmer, have to handle this.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是的，与调试命令式程序相比，广泛使用Lambda表达式的函数式程序调试要困难一些，但只要所有组件都经过验证，调试就变得不那么必要了。请记住，这只有在抛出的异常导致程序崩溃时才成立。我们将在第6章中回到这一点。但就目前而言，请记住，默认情况下，抛出的异常或错误只会崩溃发生异常的线程，而不会影响整个应用程序。即使是`OutOfMemoryError`也可能不会使应用程序崩溃，因此，作为程序员，你必须处理这种情况。
- en: 2.6\. Summary
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6. 概述
- en: A function is a relation between a source set and a target set. It establishes
    a correspondence between the elements of the source set (the domain) and the elements
    of the target set (the codomain).
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是源集合和目标集合之间的关系。它建立了源集合（定义域）的元素与目标集合（值域）的元素之间的对应关系。
- en: Pure functions have no visible effects beside returning a value.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数除了返回值外没有其他可见的效果。
- en: Functions have only one argument, which may be a tuple of several elements.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数只有一个参数，这可能是一个包含多个元素的元组。
- en: Functions of tuples may be curried in order to apply them to one element of
    the tuple at a time.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组函数可以通过柯里化来逐个应用其元组的一个元素。
- en: When a curried function is applied to only some of its arguments, we say that
    it’s partially applied.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当柯里化函数只应用其部分参数时，我们称其为部分应用。
- en: In Java, functions may be represented by methods, lambdas, method references,
    or anonymous classes.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，函数可以通过方法、Lambda表达式、方法引用或匿名类来表示。
- en: Method references are the preferred representation for functions.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用是函数的首选表示形式。
- en: Functions may be composed to create new functions.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以组合起来创建新的函数。
- en: Functions can call themselves recursively, but the recursion depth is limited
    by the size of the stack.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以递归地调用自身，但递归深度受栈大小的限制。
- en: Lambdas and method references can be used in places where a functional interface
    is expected.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式和方法引用可以在预期使用函数式接口的地方使用。
