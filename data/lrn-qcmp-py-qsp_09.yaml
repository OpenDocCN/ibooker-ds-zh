- en: '7 Changing the odds: An introduction to Q#'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 改变概率：Q#简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using the Quantum Development Kit to write quantum programs in Q#
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用量子开发工具包用Q#编写量子程序
- en: Using Jupyter Notebook to work with Q#
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jupyter Notebook与Q#一起工作
- en: Running Q# programs using a classical simulator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用经典模拟器运行Q#程序
- en: Up to this point, we’ve used Python to implement our own software stack to simulate
    quantum programs. If you recall, figure 2.1 (appearing again as figure 7.1), was
    a good model for how the programs we are writing interact with the quantum simulator
    and devices that we use and build as quantum developers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用Python来实现自己的软件栈来模拟量子程序。如果你还记得，图2.1（再次出现作为图7.1），是一个很好的模型，说明了我们编写的程序如何与量子模拟器和作为量子开发者使用和构建的设备交互。
- en: '![](../Images/7-1.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-1.png)'
- en: Figure 7.1 A mental model for how we can use a quantum computer. The top half
    of the figure is the general model for a quantum computer. Given we are using
    local simulators for this book, the bottom half represents what we are building
    and using.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 我们如何使用量子计算机的心理模型。图的上半部分是量子计算机的一般模型。鉴于我们在这本书中使用本地模拟器，下半部分代表我们正在构建和使用的部分。
- en: Moving forward, we’ll be writing more intricate quantum programs that will benefit
    from specialized language features that are hard to implement by embedding our
    software stack in Python. Especially as we explore quantum algorithms, it’s helpful
    to have a language tailor-made for quantum programming at our disposal. In this
    chapter, we’ll get started with Q#, Microsoft’s domain-specific language for quantum
    programming, included with the Quantum Development Kit.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将编写更复杂的量子程序，这些程序将受益于通过在Python中嵌入我们的软件栈难以实现的专业语言特性。特别是当我们探索量子算法时，拥有一种专门为量子编程量身定制的语言是非常有帮助的。在本章中，我们将开始使用Q#，这是量子开发工具包中包含的微软为量子编程定制的领域特定语言。
- en: 7.1 Introducing the Quantum Development Kit
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 介绍量子开发工具包
- en: The Quantum Development Kit provides a new language, Q#, to write quantum programs
    and simulate them using classical resources. Quantum programs written in Q# are
    run by thinking of quantum devices as a kind of accelerator, similar to how we
    might run code on a graphics card.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 量子开发工具包提供了一种新的语言Q#，用于编写量子程序并使用经典资源进行模拟。用Q#编写的量子程序通过将量子设备视为一种加速器来运行，类似于我们可能在图形卡上运行代码的方式。
- en: Tip If you’ve ever used a graphics card programming framework like CUDA or OpenCL,
    this is a very similar model.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你曾经使用过CUDA或OpenCL这样的图形卡编程框架，这个模型非常相似。
- en: Let’s take a look at the software stack for Q# in figure 7.2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看图7.2中的Q#软件栈。
- en: '![](../Images/7-2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-2.png)'
- en: Figure 7.2 The Microsoft Quantum Development Kit software stack on a classical
    computer. We can write a Q# program consisting of functions and operations, referencing
    any Q# libraries we want to include. A host program can then coordinate communication
    between our Q# program and the target machine (e.g., a simulator running locally
    on our computer).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 在经典计算机上的Microsoft量子开发工具包软件栈。我们可以编写一个由函数和操作组成的Q#程序，引用我们想要包含的任何Q#库。然后，宿主程序可以协调我们的Q#程序与目标机器（例如，在我们的计算机上本地运行的模拟器）之间的通信。
- en: A Q# program consists of operations and functions that instruct quantum and
    classical hardware to do certain things. There are also many libraries provided
    with Q# that have helpful, premade operations and functions to use in our programs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Q#程序由操作和函数组成，这些操作和函数指导量子和经典硬件执行某些操作。Q#还提供了许多库，其中包含许多有用的预定义操作和函数，可以在我们的程序中使用。
- en: Once the Q# program is written, we need a way for it to pass instructions to
    the hardware. A classical program sometimes called a *driver* or *host program*
    is responsible for allocating a target machine and running a Q# operation on that
    machine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了Q#程序，我们需要一种方法让它将指令传递给硬件。一个经典程序有时被称为*驱动程序*或*宿主程序*，它负责分配目标机器并在该机器上运行Q#操作。
- en: The Quantum Development Kit includes a plugin for Jupyter Notebook called IQ#
    that makes it easy to get started with Q# by providing host programs automatically.
    In chapter 9, we’ll see how to write host programs using Python, but for now,
    we’ll focus on Q#. See appendix A for instructions on setting up your Q# environment
    to work with Jupyter Notebook.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 量子开发工具包包括一个名为IQ#的Jupyter Notebook插件，它通过自动提供宿主程序来简化Q#的入门。在第9章中，我们将看到如何使用Python编写宿主程序，但在此阶段，我们将专注于Q#。有关设置Q#环境以与Jupyter
    Notebook一起使用的说明，请参阅附录A。
- en: Using the IQ# plugin for Jupyter Notebook, we can use one of two different target
    machines to run Q# code. The first is the `QuantumSimulator` target machine, which
    is very similar to the Python simulator we have been developing. It will be a
    lot faster than our Python code for simulating qubits.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jupyter Notebook的IQ#插件，我们可以使用两种不同的目标机器来运行Q#代码。第一个是`QuantumSimulator`目标机器，它与我们所开发的Python模拟器非常相似。它将比我们的模拟量子比特的Python代码快得多。
- en: The second is the `ResourcesEstimator` target machine, which will allow us to
    estimate how many qubits and quantum instructions we would need to run it without
    fully simulating it. This is especially useful for getting an idea of the resources
    we would need to run a Q# program for our application, as we’ll see when we look
    at larger Q# programs later in the book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`ResourcesEstimator`目标机器，它将允许我们估计运行它需要多少量子比特和量子指令，而无需完全模拟它。这在我们查看本书后面的较大Q#程序时，将特别有用，因为它可以帮助我们了解运行Q#程序所需资源的情况。
- en: 'To get a sense of how everything works, let’s start by writing a purely classical
    Q# “hello, world” application. First, start Jupyter Notebook by running the following
    in a terminal:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解一切是如何工作的，让我们先写一个纯经典的Q#“hello, world”应用程序。首先，通过在终端中运行以下命令来启动Jupyter Notebook：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This automatically opens a new tab in our browser with the home page for our
    Jupyter Notebook session. From the New ↓ menu, select Q# to make a new Q# notebook.
    Type the following into the first empty cell in the notebook, and press Ctrl-Enter
    or ⌘-Enter to run it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的浏览器中自动打开一个新标签页，显示我们的Jupyter Notebook会话的主页。从“新建”↓菜单中选择Q#来创建一个新的Q#笔记本。将以下内容输入笔记本的第一个空单元格中，然后按Ctrl-Enter或⌘-Enter来运行：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Defines a new function that takes no arguments and returns the empty tuple,
    whose type is written as Unit
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义了一个新的函数，该函数不接受任何参数，并返回空元组，其类型写为Unit。
- en: ❷ Tells the target machine to collect a diagnostic message. The QuantumSimulator
    target machine prints all diagnostics to the screen, so we can use Message like
    print in Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 告诉目标机器收集诊断信息。QuantumSimulator目标机器将所有诊断信息打印到屏幕上，因此我们可以使用类似于Python中的print的Message。
- en: You should get something that looks like figure 7.3.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个类似于图7.3的图形。
- en: '![](../Images/7-3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-3.png)'
- en: Figure 7.3 Getting started with IQ# and Jupyter Notebook. Here, a new Q# function
    called `HelloWorld` is defined as the first cell in a Jupyter Notebook, and the
    results from simulating that function are in the second cell.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 使用IQ#和Jupyter Notebook入门。在这里，一个名为`HelloWorld`的新Q#函数被定义为Jupyter Notebook的第一个单元格，该函数的模拟结果在第二个单元格中。
- en: Tip Unlike Python, Q# uses semicolons rather than newlines to end statements.
    If you get a lot of compiler errors, make sure you remembered your semicolons.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：与Python不同，Q#使用分号而不是换行符来结束语句。如果你遇到了很多编译错误，请确保你记得你的分号。
- en: You should get a response that the `HelloWorld` function was successfully compiled.
    To run the new function, we can use the `%simulate` command in a new cell.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个响应，表明`HelloWorld`函数已成功编译。要运行新函数，我们可以在新的单元格中使用`%simulate`命令。
- en: Listing 7.1 Using the `%simulate` magic command in Jupyter
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 在Jupyter中使用`%simulate`魔法命令
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A bit of classical magic
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一点经典的魔法
- en: The `%simulate` command is an example of a *magic command*, in that it’s not
    actually part of Q# but is an instruction to the Jupyter Notebook environment.
    If you’re familiar with the IPython plugin for Jupyter, you may have used similar
    magic commands to tell Jupyter how to handle Python plotting functionality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`%simulate`命令是一个*魔法命令*的例子，因为它实际上不是Q#的一部分，而是对Jupyter Notebook环境的指令。如果你熟悉Jupyter的IPython插件，你可能已经使用过类似的魔法命令来告诉Jupyter如何处理Python绘图功能。'
- en: In this book, the magic commands we use all start with `%` to make them easy
    to tell apart from Q# code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用的所有魔法命令都以`%`开头，以便于与Q#代码区分开来。
- en: In this example, `%simulate` allocates a target machine for us and sends a Q#
    function or operation to that new target machine. In chapter 9, we’ll see how
    to accomplish something similar using Python host programs instead of using Jupyter
    Notebook.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`%simulate`为我们分配了一个目标机器，并将一个Q#函数或操作发送到那个新目标机器。在第9章中，我们将看到如何使用Python主机程序而不是使用Jupyter
    Notebook来完成类似的事情。
- en: The Q# program is sent to the simulator, but in this case, the simulator just
    runs the classical logic since there are no quantum instructions to worry about
    yet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Q#程序被发送到模拟器，但在这个情况下，模拟器只是运行经典逻辑，因为还没有量子指令需要担心。
- en: 'Exercise 7.1: Changing the greeting'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 练习7.1：更改问候语
- en: Change the definition of `HelloWorld` to include your name instead of “classical
    world,” and then run `%simulate` again using your new definition.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将`HelloWorld`的定义改为包含你的名字而不是“经典世界”，然后再次使用`%simulate`运行你的新定义。
- en: Exercise solutions
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题解
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有练习题解都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需进入你所在章节的文件夹，然后打开提及练习题解的Jupyter笔记本。
- en: 7.2 Functions and operations in Q#
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 Q#中的函数和操作
- en: Now that we have the Quantum Development Kit up and running with Jupyter Notebook,
    let’s use Q# to write some quantum programs. Back in chapter 2, we saw that a
    useful thing to do with a qubit is to generate random numbers one classical bit
    at a time. Revisiting that application makes a great place to start with Q#, especially
    since random numbers are useful if we want to play games.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用Jupyter Notebook启动了量子开发工具包，让我们用Q#编写一些量子程序。回到第2章，我们看到了如何使用量子比特一次生成一个经典比特的随机数。回顾这个应用是开始使用Q#的好地方，尤其是随机数在玩游戏时很有用。
- en: 7.2.1 Playing games with quantum random number generators in Q#
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 在Q#中使用量子随机数生成器玩游戏
- en: 'Long ago, in Camelot, Morgana shared our love for playing games. Being a clever
    mathematician with skills well beyond her own day, Morgana was even known to use
    qubits from time to time as a part of her games. One day, as Sir Lancelot lay
    sleeping under a tree, Morgana trapped him and challenged him to a little game:
    each of them must try to guess the outcome of measuring one of Morgana’s qubits.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，在卡美洛，莫甘娜分享了我们玩游戏的爱。作为一个聪明且技能远超她那个时代的数学家，莫甘娜甚至有时会把她游戏中的一部分用到量子比特上。有一天，当兰斯洛特爵士在树下睡觉时，莫甘娜把他困住，并挑战他玩一个小游戏：他们每个人都必须尝试猜测测量莫甘娜量子比特的结果。
- en: Two sides of the same ... qubit?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个量子比特的两个方面？
- en: In chapter 2, we saw how to generate random numbers one bit at a time by preparing
    and measuring qubits. That is, qubits can be used to implement *coins*. We’ll
    use the same kind of idea in this chapter and think of a coin as a kind of interface
    that allows its user to “flip” it and get a random bit. That is, we can implement
    the coin interface by preparing and measuring qubits.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们看到了如何通过准备和测量量子比特一次生成一个经典比特的随机数。也就是说，量子比特可以用来实现*硬币*。我们将在本章使用同样的想法，把硬币看作是一种允许用户“抛掷”它并获得一个随机比特的接口。也就是说，我们可以通过准备和测量量子比特来实现硬币接口。
- en: If the result of measuring along the *Z*-axis is a 0, then Lancelot wins their
    game and gets to return to Guinevere. If the result is a 1, though, Morgana wins,
    and Lancelot has to stay and play again. Notice the similarity to our earlier
    QRNG program. Just as in chapter 2, we’ll measure a qubit to generate random numbers,
    this time to play a game. Of course, Morgana and Lancelot could flip a more traditional
    coin, but where is the fun in that?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果沿着*Z*-轴测量的结果是0，那么兰斯洛特赢得游戏并可以回到桂妮薇尔那里。但如果结果是1，那么莫甘娜就赢了，兰斯洛特必须留下来再玩一次。注意这与我们之前的QRNG程序有相似之处。就像在第2章中一样，我们将测量一个量子比特来生成随机数，这次是为了玩游戏。当然，莫甘娜和兰斯洛特可以抛一个更传统的硬币，但那样有什么乐趣呢？
- en: 'Here are the steps of Morgana’s side game:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是莫甘娜小游戏步骤：
- en: Prepare a qubit in the |0〉 state.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个处于|0〉状态的量子比特。
- en: Apply the Hadamard operation (recall that the unitary operator *H* takes |0〉
    to |+〉 and vice versa).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用Hadamard操作（回想一下，单位算子*H*将|0〉转换为|+〉，反之亦然）。
- en: Measure the qubit in the *Z*-axis. If the measurement result is a 0, then Lancelot
    can go home. Otherwise, he has to stay and play again!
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*Z*-轴上测量量子比特。如果测量结果是0，那么兰斯洛特可以回家。否则，他必须留下来再玩一次！
- en: Sitting at a coffee shop watching the world go by, we can use our laptops to
    predict what will happen in Morgana’s game with Lancelot by writing a quantum
    program in Q#. Unlike the `HelloWorld` function that we wrote earlier, our new
    program will need to work with qubits, so let’s take a moment to see how to do
    so with the Quantum Development Kit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 坐在咖啡馆里看着世界过去，我们可以用我们的笔记本电脑通过在Q#中编写量子程序来预测莫甘娜与兰斯洛特的游戏会发生什么。与之前我们写的`HelloWorld`函数不同，我们的新程序需要与量子比特一起工作，所以让我们花点时间看看如何使用量子开发工具包来做这件事。
- en: 'The primary way we interact with qubits in Q# is by calling *operations* that
    represent quantum instructions. For instance, the `H` operation in Q# represents
    the Hadamard instruction we saw in chapter 2\. To understand how these operations
    work, it’s helpful to know the difference between Q# operations and the functions
    we saw in the `HelloWorld` example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Q#中与量子比特交互的主要方式是通过调用代表量子指令的*操作*。例如，Q#中的`H`操作代表我们在第2章中看到的Hadamard指令。为了了解这些操作是如何工作的，了解Q#操作和我们在`HelloWorld`示例中看到的函数之间的区别是有帮助的：
- en: '*Functions* in Q# represent *predictable* classical logic: things like mathematical
    functions (`Sin`, `Log`). Functions always return the same output when given the
    same input.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q#中的*函数*代表*可预测*的经典逻辑：像数学函数（`Sin`、`Log`）这样的东西。函数在给定相同的输入时总是返回相同的输出。
- en: '*Operations* in Q# represent code that can have *side effects*, such as sampling
    random numbers or issuing quantum instructions that modify the state of one or
    more qubits.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q#中的*操作*代表可能具有*副作用*的代码，例如采样随机数或发出修改一个或多个量子比特状态的量子指令。
- en: This separation helps the compiler figure out how to automatically transform
    our code as a part of larger quantum programs; we’ll see more about this later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离有助于编译器确定如何自动将我们的代码作为更大量子程序的一部分进行转换；我们将在后面了解更多关于这一点。
- en: Another perspective on functions vs. operations
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与操作的区别的另一种视角
- en: Another way of thinking of the difference between functions and operations is
    that functions compute things but cannot cause anything to *happen*. No matter
    how many times we call the square root function `Sqrt`, nothing about our Q# program
    changes. In contrast, if we run the `X` operation, then an `X` instruction is
    sent to our quantum device, which causes a change in the state of the device.
    Depending on the initial state of the qubit the `X` instruction was applied to,
    we can then tell that the `X` instruction has been applied by measuring the qubit.
    Because functions don’t *do* anything in this sense, we can always predict their
    output exactly, given the same input.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考函数和操作之间区别的方式是，函数计算事物但不能导致任何事物*发生*。无论我们多少次调用平方根函数`Sqrt`，我们的Q#程序都不会有任何改变。相比之下，如果我们运行`X`操作，那么一个`X`指令就会被发送到我们的量子设备，这会导致设备状态的改变。根据`X`指令应用的初始量子比特状态，我们可以通过测量量子比特来知道`X`指令已被应用。因为在这种意义上函数不*做*任何事情，所以我们可以根据相同的输入精确预测它们的输出。
- en: One important consequence is that functions cannot call operations, but operations
    can call functions. This is because we can have an operation that is not necessarily
    predictable call a predictable function, and we still have something that may
    or may not be predictable. However, a predictable function cannot call a potentially
    unpredictable operation and still be predictable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的后果是，函数不能调用操作，但操作可以调用函数。这是因为我们可以有一个不一定可预测的操作调用一个可预测的函数，我们仍然可能有一个可能或不可能可预测的东西。然而，一个可预测的函数不能调用一个可能不可预测的操作并仍然保持可预测。
- en: We’ll see more about the difference between Q# functions and operations as we
    use them throughout the book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在整本书中使用Q#函数和操作，我们将更多地了解它们之间的区别。
- en: Since we want quantum instructions to affect our quantum devices (and Lancelot’s
    fate), all quantum operations in Q# are defined as operations (hence the name).
    For instance, suppose that Morgana and Lancelot prepare their qubit in the |+〉
    state using the Hadamard instruction. Then we can predict the outcome of their
    game by writing the quantum random number generator (QRNG) example from chapter
    2 as a Q# operation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望量子指令影响我们的量子设备（以及Lancelot的命运），Q#中的所有量子操作都被定义为操作（因此得名）。例如，假设Morgana和Lancelot使用Hadamard指令将他们的量子比特准备在|+〉状态。然后我们可以通过将第2章中的量子随机数生成器（QRNG）示例作为Q#操作编写来预测他们游戏的结局。
- en: There may be side effects to this operation...
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作可能会有副作用...
- en: 'When we want to send instructions to our target machine to do something with
    our qubits, we need to do so from an operation since sending an instruction is
    a kind of *side effect*. That is, when we run an operation, we aren’t just computing
    something: we’re *doing* something. Running an operation twice isn’t the same
    as running it once, even if we get the same output both times. Side effects aren’t
    deterministic or predictable, so we can’t use functions to send instructions for
    manipulating our qubits.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要向目标机器发送指令以对我们的量子位执行某些操作时，我们必须从操作中这样做，因为发送指令是一种 *副作用*。也就是说，当我们运行一个操作时，我们不仅仅是计算某物：我们是在
    *做* 某事。运行一个操作两次并不等同于运行一次，即使两次都得到了相同的输出。副作用不是确定性的或可预测的，因此我们不能使用函数来发送操纵我们的量子位的指令。
- en: In listing 7.2, we do just that, starting with writing an operation called `GetNextRandomBit`
    to simulate each round of Morgana’s game. Note that since `GetNextRandomBit` needs
    to work with qubits, it must be an operation and not a function. We can ask the
    target machine for one or more fresh qubits with the `use` statement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 7.2 中，我们正是这样做的，从编写一个名为 `GetNextRandomBit` 的操作开始，以模拟 Morgana 游戏的每一轮。请注意，由于
    `GetNextRandomBit` 需要与量子位一起工作，它必须是一个操作而不是一个函数。我们可以使用 `use` 语句向目标机器请求一个或多个新的量子位。
- en: Allocating qubits in Q#
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Q# 中分配量子位
- en: The `use` statement is one of the only two ways to ask the target machine for
    qubits. There’s no limit to the number of `use` statements we can have in Q# programs,
    other than the number of qubits that each target machine can allocate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 语句是请求目标机器提供量子位的唯一两种方式之一。在 Q# 程序中，我们可以有的 `use` 语句数量没有限制，除了每个目标机器可以分配的量子位数量。'
- en: At the end of a block (i.e., an `operation`, `for`, or `if` body) containing
    a `use` statement, the qubits go back to the target machine. Often, qubits are
    allocated this way at the start of an operation body, so one way to think of `use`
    statements is to make sure each qubit that is allocated is “owned” by a particular
    operation. This makes it impossible to “leak” qubits within a Q# program, which
    is very helpful given that qubits are likely to be very expensive resources on
    actual quantum hardware.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含 `use` 语句的块的末尾（即 `operation`、`for` 或 `if` 体）中，量子位会返回到目标机器。通常，量子位在操作体的开始时以这种方式分配，因此一种思考
    `use` 语句的方式是确保每个分配的量子位都“属于”特定的操作。这使得在 Q# 程序中“泄漏”量子位成为不可能，这对于量子位可能是实际量子硬件上非常昂贵的资源来说非常有帮助。
- en: If we need more control over when qubits are deallocated, `use` statements can
    also optionally be followed by a block, denoted with `{` and `}`. In that case,
    qubits are deallocated at the end of the block instead of at the end of the operation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要对量子位的释放有更多的控制，`use` 语句也可以可选地后面跟一个块，用 `{` 和 `}` 表示。在这种情况下，量子位在块的末尾而不是在操作的末尾释放。
- en: Q# also offers one other way to allocate qubits, known as *borrowing*. Unlike
    when we allocate qubits with `use` statements, the `borrow` statement lets us
    borrow qubits owned by different operations without knowing what state they start
    in. We won’t see much borrowing in this book, but the `borrow` statement works
    very similarly to the `use` statement in that it makes it impossible to forget
    that we’ve borrowed a qubit.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Q# 还提供了一种分配量子位的方式，称为 *借用*。与使用 `use` 语句分配量子位不同，`borrow` 语句让我们可以借用不同操作拥有的量子位，而无需知道它们开始时的状态。在这本书中，我们不会看到很多借用，但
    `borrow` 语句与 `use` 语句非常相似，它使得我们不可能忘记我们已经借用了量子位。
- en: By convention, all qubits start in the |0〉 state right after we get them, and
    we promise the target machine that we’ll put them back into the |0〉 state at the
    end of the block so they’re ready for the target machine to give to the next operation
    that needs them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，所有量子位在我们得到它们后立即处于 |0〉 状态，我们向目标机器承诺，在块的末尾将它们放回 |0〉 状态，以便它们可以为需要它们的下一个操作做好准备。
- en: 'Listing 7.2 Operation.qs: Q# to simulate a round of Morgana’s game'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 Operation.qs：Q# 模拟 Morgana 游戏的一轮
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Declares an operation, as we want to use qubits and return a measurement Result
    to its caller
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明一个操作，因为我们想使用量子位并返回一个测量结果给调用者
- en: ❷ The use keyword in Q# asks the target machine for one or more qubits. Here,
    we ask for a single value of type Qubit, which we store in the new variable qubit.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Q# 中的 `use` 关键字请求目标机器提供一个或多个量子位。在这里，我们请求一个类型为 Qubit 的单个值，并将其存储在新的变量 qubit
    中。
- en: ❸ After calling H, qubit is in the *H*|0〉 = |+〉 state.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在调用 H 之后，量子位处于 *H*|0〉 = |+〉 状态。
- en: ❹ Uses the M operation to measure our qubit in the *Z*-basis. The result will
    be either Zero or One with equal probability. After measuring, we can return that
    classical data back to the caller.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 M 操作在 *Z*-基下测量我们的量子比特。结果将是零或一，概率相等。测量后，我们可以将经典数据返回给调用者。
- en: Here, we use the `M` operation to measure our qubit in the *z* -basis, saving
    the result to the `result` variable we declared earlier. Since the state of the
    qubit is in an equal superposition of |0〉 and |1〉, `result` will be either `Zero`
    or `One` with equal probability.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `M` 操作在 *z*-基下测量我们的量子比特，并将结果保存到我们之前声明的 `result` 变量中。由于量子比特的状态是 |0〉
    和 |1〉 的等概率叠加，`result` 将是 `Zero` 或 `One`，概率相等。
- en: Standalone Q# applications
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 独立 Q# 应用程序
- en: We can also write Q# applications like the QRNG as standalone applications,
    rather than calling them from Python or IQ# notebooks. To do so, we can designate
    one of the Q# operations in the quantum application as an *entry point*, which
    is then called automatically when we run our application from the command line.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像 QRNG 一样编写 Q# 应用程序作为独立应用程序，而不是从 Python 或 IQ# 笔记本中调用它们。为此，我们可以指定量子应用程序中的一个
    Q# 操作作为 *入口点*，然后当我们从命令行运行应用程序时，它会自动调用。
- en: For this book, we’ll stick with Jupyter and Python to work with Q#. But check
    out the sample at [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp/tree/master/ch07/Qrng](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp/tree/master/ch07/Qrng)
    for information on writing standalone Q# applications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将坚持使用 Jupyter 和 Python 来与 Q# 一起工作。但请查看[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp/tree/master/ch07/Qrng](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp/tree/master/ch07/Qrng)
    中的示例，了解如何编写独立的 Q# 应用程序。
- en: 'In listing 7.2, we also see our first example of opening a *namespace* in Q#.
    Like namespaces in C++ and C# or packages in Java, Q# namespaces help keep functions
    and operations organized. For example, the `H` operation called in listing 7.2
    is defined in the Q# standard library as `Microsoft.Quantum.Intrinsic.H`; that
    is, it lives in the `Microsoft.Quantum.Intrinsic` namespace. To use `H`, we can
    either use its full name, `Microsoft.Quantum.Intrinsic.H`, or an `open` statement
    to make all of the operations and functions in a namespace available:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 7.2 中，我们还看到了 Q# 中打开 *命名空间* 的第一个例子。与 C++ 和 C# 中的命名空间或 Java 中的包类似，Q# 命名空间有助于保持函数和操作的有序。例如，在列表
    7.2 中调用的 `H` 操作是在 Q# 标准库中定义的 `Microsoft.Quantum.Intrinsic.H`；也就是说，它位于 `Microsoft.Quantum.Intrinsic`
    命名空间中。要使用 `H`，我们可以使用它的完整名称 `Microsoft.Quantum.Intrinsic.H`，或者使用 `open` 语句使一个命名空间中的所有操作和函数可用：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Makes all of the functions and operations provided in Microsoft.Quantum.Intrinsic
    available to use within a Q# notebook or source file without having to specify
    their full names
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使 Microsoft.Quantum.Intrinsic 中提供的所有函数和操作在 Q# 笔记本或源文件中使用时可用，无需指定它们的完整名称。
- en: Tip When writing Q# in Jupyter Notebook, the `Microsoft.Quantum.Intrinsic` and
    `Microsoft.Quantum.Canon` namespaces from the Q# standard library are always opened
    automatically for us, as they’re used in most Q# code. For example, when we called
    `Message` earlier, that function was provided in the `Microsoft.Quantum.Intrinsic`
    namespace that the Q# kernel opened automatically. To check which namespaces are
    open in a Q# notebook, we can use the `%lsopen` magic command.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在 Jupyter Notebook 中编写 Q# 时，Q# 标准库中的 `Microsoft.Quantum.Intrinsic` 和 `Microsoft.Quantum.Canon`
    命名空间会自动为我们打开，因为它们在大多数 Q# 代码中都会用到。例如，当我们之前调用 `Message` 函数时，该函数是由 Q# 内核自动打开的 `Microsoft.Quantum.Intrinsic`
    命名空间提供的。要检查 Q# 笔记本中打开了哪些命名空间，我们可以使用 `%lsopen` 魔法命令。
- en: 'Exercise 7.2: Generating more bits'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.2：生成更多比特
- en: Use the `%simulate` magic command to run the `GetNextRandomBit` operation a
    few times. Do you get the results you’d expect?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `%simulate` 魔法命令运行 `GetNextRandomBit` 操作几次。你得到的是预期的结果吗？
- en: Next, we’ll see how many rounds it takes for Lancelot to get the `Zero` he needs
    to go home. Let’s write an operation to play rounds until we get a `Zero`. Since
    this operation simulates playing Morgana’s game, we’ll call it `PlayMorganasGame`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到兰斯洛特需要多少轮才能得到他回家的 `Zero`。让我们编写一个操作来玩直到我们得到一个 `Zero`。由于这个操作模拟了玩 Morgana
    的游戏，我们将称之为 `PlayMorganasGame`。
- en: Tip All Q# variables are immutable by default.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：所有 Q# 变量默认都是不可变的。
- en: 'Listing 7.3 Operations.qs: Simulating many rounds of Morgana’s game using Q#'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 Operations.qs：使用 Q# 模拟 Morgana 游戏的多轮游戏
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Uses the mutable keyword to declare a variable indicating how many rounds
    have passed. We can change the value of this variable later with the “set” keyword.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用可变关键字声明一个变量来指示已通过多少轮。我们可以稍后使用“设置”关键字来更改此变量的值。
- en: ❷ Q# allows operations to use a repeat-until-success (RUS) loop.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Q# 允许操作使用重复直到成功（RUS）循环。
- en: ❸ Inside our loop, we call the QRNG that we wrote earlier as the GetNextRandomBit
    operation. We check to see if the result is a Zero and, if it is, set “done” to
    true.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在我们的循环内部，我们调用我们之前编写的 QRNG 作为 GetNextRandomBit 操作。我们检查结果是否为零，如果是，则将“完成”设置为
    true。
- en: ❹ If we got a Zero, then we can stop the loop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果我们得到一个零，那么我们可以停止循环。
- en: ❺ We use Message again to print the number of rounds to the screen. To do so,
    we use $"" strings, which let us include variables in the diagnostic message by
    using {} placeholders inside the string.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们再次使用消息来将轮数打印到屏幕上。为此，我们使用 `$""` 字符串，它允许我们通过在字符串内部使用 `{}` 占位符将变量包含在诊断消息中。
- en: Tip Q# strings denoted with `$""` are called *interpolated strings* and work
    very similarly to `f""` strings in Python.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 Q# 中用 `$""` 标记的字符串称为*插值字符串*，其工作方式与 Python 中的 `f""` 字符串非常相似。
- en: Listing 7.3 includes a Q# control flow called a repeat-until-success (RUS) loop.
    Unlike a `while` loop, RUS loops also allow us to specify a “fixup” that runs
    if the condition to exit the loop isn’t met.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 包含一个名为重复直到成功（RUS）循环的 Q# 控制流。与`while`循环不同，RUS 循环还允许我们指定一个“修复”操作，如果退出循环的条件未满足，则运行该操作。
- en: When do we need to reset qubits?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们何时需要重置量子比特？
- en: In Q#, when we allocate a new qubit with `use`, we promise the target machine
    that we will put it back in the |0〉 state before deallocating it. At first glance,
    this seems unnecessary, as the target machine could just reset the state of qubits
    when they are deallocated—after all, we often call the `Reset` operation at the
    end of an operation or `use` block. Indeed, this happens automatically when a
    qubit is measured, right before it is released!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Q# 中，当我们使用 `use` 分配一个新的量子比特时，我们向目标机器承诺在释放之前将其放回 |0〉 状态。乍一看，这似乎是不必要的，因为目标机器可以在量子比特释放时重置其状态——毕竟，我们经常在操作或
    `use` 块的末尾调用 `Reset` 操作。确实，当量子比特被测量时，这会自动发生，就在它被释放之前！
- en: It is important to note that the `Reset` operation works by making a measurement
    in the *Z*-basis and flipping the qubit with an `X` operation if the measurement
    returns `One`. *In many quantum devices, measurement is much more expensive than
    other operations*, so if we can avoid calling `Reset`, we can reduce the cost
    of our quantum programs. Especially given the limitations of medium-term devices,
    this kind of optimization can be critical in making a quantum program practically
    useful.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`重置`操作是通过在*Z*基中进行测量，并在测量返回`One`时使用`X`操作翻转量子比特来工作的。在许多量子设备中，测量比其他操作要昂贵得多，因此如果我们能避免调用`重置`，我们就可以降低量子程序的成本。特别是考虑到中期设备的限制，这种优化对于使量子程序具有实际用途至关重要。
- en: Later in the chapter, we will see examples where we know the state of a qubit
    when it needs to be deallocated, such that we can “unprepare” the qubit instead
    of measuring it. We don’t have a final measurement in those cases, so the Q# compiler
    doesn’t add an automatic reset for us, avoiding the need for a potentially expensive
    measurement operation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到一些示例，其中我们知道量子比特在需要释放时所处的状态，这样我们就可以“取消准备”量子比特而不是对其进行测量。在这些情况下，我们没有最终的测量，因此
    Q# 编译器不会为我们添加自动重置，从而避免了可能昂贵的测量操作。
- en: 'We can run this new operation with the `%simulate` command in a fashion very
    similar to the `HelloWorld` example. When we do so, we can see how long Lancelot
    has to stay:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`%simulate`命令运行这个新操作，其方式与`HelloWorld`示例非常相似。当我们这样做时，我们可以看到兰斯洛特需要停留多长时间：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Looks like Lancelot got lucky that time! Or perhaps unlucky, if he was bored
    hanging round the table in Camelot.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来兰斯洛特那次运气不错！或者也许是不幸，如果他无聊地在卡美洛的桌子旁闲逛。
- en: 'Deep dive: open vs. import'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：打开与导入
- en: 'At first glance, the `open` statement in Q# may feel a lot like the `import`
    statement in Python, JavaScript, or TypeScript. Both `open` and `import` make
    code from libraries available to use in our programs and applications. The main
    difference is that opening a namespace with the `open` statement only does just
    that: it opens a namespace and makes it available, but it doesn’t cause any code
    to run and doesn’t change the way our code compiles and finds libraries.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，Q# 中的 `open` 语句可能非常类似于 Python、JavaScript 或 TypeScript 中的 `import` 语句。`open`
    和 `import` 都使库中的代码可用于我们的程序和应用程序。主要区别在于，使用 `open` 语句打开命名空间只是这样做：它打开一个命名空间并使其可用，但它不会导致任何代码运行，也不会改变我们的代码编译和查找库的方式。
- en: In principle, we could write every Q# program without a single `open` statement
    by explicitly referring to each function and operation by its full name, including
    its namespace (i.e., calling `Microsoft.Quantum.Intrinsic.H` instead of just `H`).
    In that sense, `open` is similar to the `using` statement in C++ or C#, the `open`
    statement in F#, and the `import` statement in Java.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，我们可以不使用单个 `open` 语句编写每个 Q# 程序，通过显式地使用每个函数和操作的完整名称（包括其命名空间）来引用它们（即调用 `Microsoft.Quantum.Intrinsic.H`
    而不是仅仅 `H`）。从这个意义上讲，`open` 语句类似于 C++ 或 C# 中的 `using` 语句，F# 中的 `open` 语句，以及 Java
    中的 `import` 语句。
- en: In contrast, `import` in Python, JavaScript, and TypeScript not only makes the
    names from a library available to our code but also causes parts of those libraries
    to run. When a Python module is first imported, the Python interpreter uses the
    module’s name to look for where that module is defined and then runs the module
    along with any initialization code it has. Often, to use these modules, we need
    to first install one or more *packages* using a tool like pip or conda for Python
    packages or npm for JavaScript and TypeScript.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Python、JavaScript 和 TypeScript 中的 `import` 不仅使库中的名称可用于我们的代码，还会导致那些库的部分运行。当一个
    Python 模块首次导入时，Python 解释器使用模块的名称来查找该模块的定义位置，然后运行该模块及其初始化代码。通常，为了使用这些模块，我们需要首先使用
    pip 或 conda 等工具安装一个或多个 *包*，对于 Python 包或 npm 对于 JavaScript 和 TypeScript。
- en: The same concept can be used to add new libraries to our Q# programs with the
    *NuGet package manager*. In a Q# notebook, the `%package` command instructs the
    Q# kernel to download a given Q# library and add it to our session. For example,
    when we open a new notebook, the Q# standard library is automatically downloaded
    and installed from the `Microsoft.Quantum.Standard` package on nuget.org ([https://www.nuget.org/packages/Microsoft.Quantum.Standard](https://www.nuget.org/packages/Microsoft.Quantum.Standard)).
    Similarly, when writing command-line Q# applications, running `dotnet add package`
    adds the needed metadata to our project’s Q# compiler to find the package we need.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的概念可以用来将新的库添加到我们的 Q# 程序中，使用 *NuGet 包管理器*。在一个 Q# 笔记本中，`%package` 命令指示 Q# 内核下载一个给定的
    Q# 库并将其添加到我们的会话中。例如，当我们打开一个新的笔记本时，Q# 标准库会自动从 nuget.org 上的 `Microsoft.Quantum.Standard`
    包下载并安装([https://www.nuget.org/packages/Microsoft.Quantum.Standard](https://www.nuget.org/packages/Microsoft.Quantum.Standard))。同样，当编写命令行
    Q# 应用程序时，运行 `dotnet add package` 会将所需的元数据添加到我们的项目 Q# 编译器中，以便找到我们需要的包。
- en: For more details, check out the Quantum Development Kit documentation at [https://docs.microsoft.com/azure/quantum/user-guide/libraries/additional-libraries](https://docs.microsoft.com/azure/quantum/user-guide/libraries/additional-libraries).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请查看量子开发工具包文档，[https://docs.microsoft.com/azure/quantum/user-guide/libraries/additional-libraries](https://docs.microsoft.com/azure/quantum/user-guide/libraries/additional-libraries)。
- en: 7.3 Passing operations as arguments
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 将操作作为参数传递
- en: Suppose that, in Morgana’s game, we were interested in sampling random bits
    with non-uniform probability. After all, Morgana didn’t promise Lancelot *how*
    she prepared the qubit they measure; she can keep him playing longer if she makes
    a biased coin with their qubit instead of a fair coin.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们对 Morgana 的游戏中，我们感兴趣的是以非均匀概率采样随机比特。毕竟，Morgana 没有承诺 Lancelot 他们测量的量子比特是如何准备的；如果她用带有他们量子比特的偏硬币而不是公平硬币来让他玩得更久，她可以让他玩得更久。
- en: 'The easiest way to modify Morgana’s game is to, instead of calling `H` directly,
    take as an input an operation representing what Morgana does to prepare for their
    game. To take an operation as input, we need to write the *type* of the input,
    just as we can write `qubit : Qubit` to declare an input `qubit` of type `Qubit`.
    Operation types are indicated by thick arrows (`=>`) from their input type to
    their output type. For instance, `H` has type `Qubit => Unit` since `H` takes
    a single qubit as input and returns an empty tuple as its output.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '修改 Morgana 的游戏最简单的方法是，而不是直接调用 `H`，将表示 Morgana 为游戏做准备的操作作为输入。要接受一个操作作为输入，我们需要编写输入的
    *类型*，就像我们可以编写 `qubit : Qubit` 来声明类型为 `Qubit` 的输入 `qubit` 一样。操作类型由从输入类型到输出类型的粗箭头
    (`=>`) 表示。例如，`H` 的类型是 `Qubit => Unit`，因为 `H` 接受单个量子比特作为输入，并返回一个空元组作为其输出。'
- en: Tip In Q#, functions are denoted by thin arrows (`->`), while operations are
    denoted by thick arrows (`=>`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在 Q# 中，函数用细箭头 (`->`) 表示，而操作用粗箭头 (`=>`) 表示。
- en: Listing 7.4 Using operations as inputs to predict Morgana’s game
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 使用操作作为输入预测 Morgana 的游戏
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ We’ve added a new input called statePreparation to GetNextRandomBit, representing
    the operation we want to use to prepare the state we use as a coin. In this case,
    Qubit => Unit is the type of any operation that takes a single qubit and returns
    the empty tuple type Unit.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们为 GetNextRandomBit 添加了一个新的输入，称为 statePreparation，表示我们想要用来准备作为硬币使用的状态的运算。在这种情况下，Qubit
    => Unit 是任何接受单个量子比特并返回空元组类型 Unit 的运算的类型。
- en: ❷ In GetNextRandomBit, the operation passed as statePreparation can be called
    like any other operation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 GetNextRandomBit 中，作为 statePreparation 传递的运算可以像任何其他运算一样调用。
- en: ❸ The Q# standard libraries provide Microsoft.Quantum.Measurement.MResetZ as
    a convenience for measuring and resetting a qubit in one step. In this case, the
    MResetZ operation does the same thing as the return M(qubit); statement in the
    previous example. The difference is that MResetZ always resets its input qubit,
    not just when it is used before a qubit is released. We’ll see more about this
    operation later in the chapter, as well as how to use a shorter name when calling
    this operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Q# 标准库提供了 Microsoft.Quantum.Measurement.MResetZ，以便在一步中测量和重置量子比特。在这种情况下，MResetZ
    操作与上一个例子中的 return M(qubit); 语句做的是同样的事情。区别在于 MResetZ 总是重置其输入量子比特，而不仅仅是当它在释放量子比特之前使用时。我们将在本章后面更多地了解这个操作，以及如何调用此操作时使用更短的名字。
- en: 'Exercise 7.3: Type of GetNextRandomBit'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.3：GetNextRandomBit 的类型
- en: What’s the type of our new definition of `GetNextRandomBit`?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新定义的 `GetNextRandomBit` 的类型是什么？
- en: Tuple in, tuple out
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输入元组，输出元组
- en: 'All functions and operations in Q# take a single *tuple* as an input and return
    a single *tuple* as an output. For instance, a function declared as `function
    Pow(x : Double, y : Double) : Double {...}` takes as input a tuple `(Double, Double)`
    and returns a tuple `(Double)` as its output. This works because of a property
    known as *singleton-tuple equivalence*. For any type `''T`, the tuple `(''T)`
    containing a single `''T` is equivalent to `''T` itself. In the example of `Pow`,
    we can think of the output as a tuple `(Double)` that is equivalent to `Double`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'Q# 中的所有函数和操作都接受单个 *元组* 作为输入，并返回单个 *元组* 作为输出。例如，声明为 `function Pow(x : Double,
    y : Double) : Double {...}` 的函数接受一个 `(Double, Double)` 类型的元组作为输入，并返回一个 `(Double)`
    类型的元组作为其输出。这是因为一个称为 *单元素元组等价性* 的属性。对于任何类型 `''T''`，包含单个 `''T''` 的元组 `(''T)` 与 `''T''`
    本身等价。在 `Pow` 的例子中，我们可以将输出视为一个等价于 `Double` 的元组 `(Double)`。'
- en: '![](../Images/7-unnumb-1.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-unnumb-1.png)'
- en: Representing operations with a single input and a single output
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个输入和单个输出的操作表示
- en: 'With this in mind, a function or operation that returns no outputs can be thought
    of as returning a tuple with no elements, `()`. The type of such tuples is called
    `Unit`, similar to other tuple-based languages such as F#. If we think of a tuple
    as a kind of box, then this is distinct from `void` as used in C, C++, or C# because
    there still is *something* there: a box with nothing in it.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，返回无输出的函数或操作可以被视为返回一个没有元素的元组，`()`。这种元组的类型称为 `Unit`，类似于其他基于元组的语言，如 F#。如果我们将元组视为一种盒子，那么这与
    C、C++ 或 C# 中的 `void` 不同，因为那里仍然有 *一些东西*：一个空盒。
- en: In Q#, we always return a box, *even if that box is empty*. There’s no meaning
    in Q# for a function or operation that returns “nothing.” For more details, see
    section 7.2 of *Get Programming with F#* by Isaac Abraham (Manning, 2018).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Q# 中，我们总是返回一个盒子，*即使那个盒子是空的*。在 Q# 中没有“无”的意义。有关更多详细信息，请参阅 Isaac Abraham 所著的
    *Get Programming with F#*（Manning，2018）的第 7.2 节。
- en: '![](../Images/7-unnumb-2.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-unnumb-2.png)'
- en: '`Unit` vs. `void`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit`与`void`'
- en: In listing 7.4, we see that `GetNextRandomBit` treats its input `statePreparation`
    as a “black box.” The only way to learn anything about Morgana’s preparation strategy
    is to *run* it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表7.4中，我们看到`GetNextRandomBit`将其输入`statePreparation`视为一个“黑盒”。了解Morgana的态准备策略的唯一方法就是运行它。
- en: Put differently, we don’t want to do anything with `statePreparation` that implies
    we know what it does or what it is. The only way that `GetNextRandomBit` can interact
    with `statePreparation` is by calling it, passing it a `Qubit` to act on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们不想对`statePreparation`做任何表明我们知道它做什么或它是什么的事情。`GetNextRandomBit`与`statePreparation`交互的唯一方式是通过调用它，并传递一个`Qubit`来对其操作。
- en: This allows us to reuse the logic in `GetNextRandomBit` for many different kinds
    of state preparation procedures that Morgana might use to cause Lancelot a bit
    of trouble. For example, suppose she wants a biased coin that returns a `Zero`
    three-quarters of the time and a `One` one-quarter of the time. We might run something
    like the following to predict this new strategy.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们重用`GetNextRandomBit`中的逻辑，以处理Morgana可能用来给Lancelot制造一些麻烦的许多不同类型的态准备程序。例如，假设她想要一个三分之四返回`Zero`，四分之一返回`One`的偏硬币。我们可能会运行以下内容来预测这种新策略。
- en: Listing 7.5 Passing different state preparation strategies to `PlayMorganasGame`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 将不同的态准备策略传递给`PlayMorganasGame`
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Classical math functions such as Sin, Cos, Sqrt, and ArcCos as well as constants
    like PI() are provided by the Microsoft.Quantum.Math namespace.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Microsoft.Quantum.Math命名空间提供了如Sin、Cos、Sqrt和ArcCos等经典数学函数以及PI()等常量。
- en: ❷ The Ry operation implements a *Y*-axis rotation. Q# uses radians rather than
    degrees to express rotations, so this is a rotation of 120° about the *Y*-axis.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Ry操作实现了Y轴旋转。Q#使用弧度而不是度来表示旋转，因此这是一个围绕Y轴的120°旋转。
- en: The `Ry` operation implements the *Y*-axis rotation that we saw in chapter 2\.
    Thus, when we rotate the state of `qubit` by 120° in listing 7.5, if `qubit` starts
    in the |0〉 state, that prepares `qubit` in the state *Ry*(120°)|0〉 = √3/4 |0〉
    + √1/4 |1〉. As a result, the probability of observing 1 when we measure `qubit`
    is √1/4² = 1 / 4.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Ry操作实现了我们在第2章中看到的Y轴旋转。因此，当我们在列表7.5中将量子比特的状态旋转120°时，如果量子比特从|0〉状态开始，那么它将量子比特准备在状态*Ry*(120°)|0〉
    = √3/4 |0〉 + √1/4 |1〉。结果，当我们测量量子比特时观察到1的概率是√1/4² = 1 / 4。
- en: We can make this example even more general, allowing Morgana to specify an arbitrary
    bias for her coin (which is implemented by their shared qubit).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使这个例子更加通用，允许Morgana为她（通过共享量子比特实现的）的硬币指定任意偏置。
- en: Listing 7.6 Passing operations to implement arbitrary coin biases
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 将操作传递以实现任意的硬币偏置
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Finds out what angle to rotate the input qubit by to get the right probability
    of seeing a One as our result. This takes a bit of trigonometry; see the next
    sidebar for details.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确定旋转输入量子比特的角度，以获得看到One作为结果的正确概率。这需要一点三角学知识；有关详细信息，请参阅下一侧边栏。
- en: ❷ This operation has the right type signature (Qubit => Unit), and we can see
    that the probability Morgana will win each round is 62%.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个操作具有正确的类型签名（Qubit => Unit），我们可以看到Morgana在每个回合获胜的概率是62%。
- en: Working out the trigonometry
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 解析三角函数
- en: 'As we’ve seen several times, quantum computing deals extensively with *rotations*.
    To figure out what angles we need for our rotations, we rely on trigonometry (literally,
    “the study of triangles”): a branch of mathematics that describes rotation angles.
    For instance, as we saw in chapter 2, rotating |0〉 by an angle *θ* about the *Y*-axis
    results in a state cos(–*θ* / 2) |0〉 + sin(–*θ* / 2) |1〉. We know we want to choose
    *θ* such that cos(–*θ* / 2) = ![](../Images/equation_7-1.png) so we get a 62%
    probability of a `One` result. That means we need to “undo” the cosine function
    to figure out what *θ* needs to be.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次看到的，量子计算广泛地处理旋转。为了确定我们旋转所需的角，我们依赖于三角学（字面上，“三角形的研究”）：这是描述旋转角度的数学分支。例如，正如我们在第2章中看到的，绕Y轴旋转|0〉角度θ会导致状态cos(–θ
    / 2) |0〉 + sin(–θ / 2) |1〉。我们知道我们需要选择θ，使得cos(–θ / 2) = ![](../Images/equation_7-1.png)，这样我们就能得到62%的One结果概率。这意味着我们需要“反转”余弦函数来确定θ需要是多少。
- en: In trigonometry, the inverse of the cosine function is the arccosine function
    and is written arccos. Taking the arccosine of both sides of cos(–*θ* / 2) = ![](../Images/equation_7-1.png)
    gives us arccos(cos(–*θ* / 2)) = arccos(![](../Images/equation_7-1.png)). We can
    cancel out arccos and cos to find a rotation angle that gives us what we need,
    –*θ* / 2 = arccos(![](../Images/equation_7-1.png)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在三角学中，余弦函数的倒数是反余弦函数，写作 arccos。对 cos(–*θ* / 2) = ![](../Images/equation_7-1.png)
    的两边取反余弦，我们得到 arccos(cos(–*θ* / 2)) = arccos(![](../Images/equation_7-1.png))。我们可以消去
    arccos 和 cos，找到一个旋转角度，得到我们需要的值，–*θ* / 2 = arccos(![](../Images/equation_7-1.png))。
- en: Finally, we multiply both sides by –2 to get the equation used in line 4 of
    listing 7.6\. We can see this argument visually in the following figure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将两边乘以 –2 来得到列表 7.6 第 4 行使用的方程。我们可以在以下图中直观地看到这个论点。
- en: '![](../Images/7-unnumb-3.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-unnumb-3.png)'
- en: How Morgana can choose *θ* to control the game. The closer to *π* she picks
    *θ* to be, the longer Morgana can keep poor Lancelot playing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Morgana 如何选择 *θ* 来控制游戏。她选择的 *θ* 越接近 *π*，Morgana 就能越长时间让可怜的 Lancelot 玩下去。
- en: 'This is somewhat unsatisfying, though, because the operation `PrepareMorganasCoin`
    introduces a lot of boilerplate just to lock down the value of `0.62` for the
    input argument `morganaWinProbability` to `PrepareBiasedCoin`. If Morgana changes
    her strategy to have a different bias, then using this approach, we’ll need another
    boilerplate operation to represent it. Taking a step back, let’s look at what
    `PrepareMorganasCoin` actually *does*. It starts with an operation `PrepareBiasedCoin
    : (Double, Qubit) => Unit` and wraps it into an operation of type `Qubit => Unit`
    by locking down the `Double` argument as `0.62`. That is, it removes one of the
    arguments to `PrepareBiasedCoin` by fixing the value of that input to `0.62`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这多少有些令人不满意，因为操作 `PrepareMorganasCoin` 引入了很多样板代码，只是为了锁定输入参数 `morganaWinProbability`
    传递给 `PrepareBiasedCoin` 的 `0.62` 值。如果 Morgana 改变她的策略，使其具有不同的偏差，那么使用这种方法，我们需要另一个样板操作来表示它。退一步来看，让我们看看
    `PrepareMorganasCoin` 实际上 *做什么*。它从一个操作 `PrepareBiasedCoin : (Double, Qubit) =>
    Unit` 开始，并通过锁定 `Double` 参数为 `0.62` 来将其包装成一个类型为 `Qubit => Unit` 的操作。也就是说，它通过将输入值固定为
    `0.62` 来移除了 `PrepareBiasedCoin` 的一个参数。'
- en: 'Fortunately, Q# provides a convenient shorthand for making new functions and
    operations by locking down some (but not all!) of the inputs. Using this shorthand,
    known as *partial application*, we can rewrite `PrepareMorganasCoin` from listing
    7.6 in a more readable form:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Q# 提供了一种方便的缩写方式来创建新的函数和操作，通过锁定一些（但不是全部！）输入。使用这种缩写，称为 *偏应用*，我们可以将列表 7.6
    中的 `PrepareMorganasCoin` 重写为一个更易读的形式：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `_` indicates that part of the input to `PrepareBiasedCoin` is *missing*.
    We say `PrepareBiasedCoin` has been partially applied. Whereas `PrepareBiasedCoin`
    had type `(Double, Qubit) => Unit`, because we filled in the `Double` part of
    the input, `PrepareBiasedCoin(0.62, _)` has type `Qubit => Unit`, making it compatible
    with our modifications to `GetNextRandomBit`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`_` 表示 `PrepareBiasedCoin` 的输入部分 *缺失*。我们说 `PrepareBiasedCoin` 已经被部分应用。而 `PrepareBiasedCoin`
    的类型是 `(Double, Qubit) => Unit`，因为我们填充了输入的 `Double` 部分，`PrepareBiasedCoin(0.62,
    _)` 的类型变为 `Qubit => Unit`，使其与我们对 `GetNextRandomBit` 的修改兼容。'
- en: Tip Partial application in Q# is similar to `functools.partial` in Python and
    the `_` keyword in Scala.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：Q# 中的偏应用与 Python 中的 `functools.partial` 和 Scala 中的 `_` 关键字类似。
- en: Another way to think of partial application is as a way to make new functions
    and operations by specializing existing functions and operations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考偏应用的方式是将其视为通过特化现有函数和操作来创建新函数和操作的方法。
- en: Listing 7.7 Using partial application to specialize an operation
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 使用偏应用来特化一个操作
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The output type is an operation that takes a qubit and returns the empty tuple.
    That is, BiasedPreparation is a function that makes new operations!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 输出类型是一个操作，它接受一个量子比特并返回空元组。也就是说，BiasedPreparation 是一个创建新操作的功能！
- en: ❷ Makes the new operation by passing headsProbability but leaving a blank (_)
    for the target qubit. This gives us an operation that takes a single Qubit and
    substitutes in the blank.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过传递 `headsProbability` 但为目标量子比特留空（_），创建新的操作。这给我们一个操作，它接受单个量子比特并填充空白。
- en: 'Tip In listing 7.7, we return `PrepareBiasedCoin(headsProbability, _)` as a
    value in its own right, just as we may return `42` from a function or operation
    with `Int` as its output type. In Q#, functions and operations are values in precisely
    the same sense that `42`, `true`, and `(3.14, "hello")` are all values in Q#,
    and just as the Python function `(lambda x: x ** 2)` is a value in Python. Formally,
    we say that functions and operations are *first-class* values in Q#.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '提示：在列表 7.7 中，我们将 `PrepareBiasedCoin(headsProbability, _)` 作为其自身的值返回，就像我们可能从具有
    `Int` 输出类型的函数或操作中返回 `42` 一样。在 Q# 中，函数和操作与 `42`、`true` 和 `(3.14, "hello")` 都是 Q#
    中的值，就像 Python 函数 `(lambda x: x ** 2)` 是 Python 中的值一样。正式地说，我们在 Q# 中说函数和操作是 *一等*
    值。'
- en: It may seem a bit confusing that `BiasedPreparation` returns an operation from
    a function, but this is completely consistent with the split between functions
    and operations described previously since `BiasedPreparation` is still predictable.
    In particular, `BiasedPreparation(p)` always returns the same operation for a
    given `p`, no matter how many times we call the function. We can assure ourselves
    that this is the case by noticing that `BiasedPreparation` only partially applies
    operations but never calls them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有些令人困惑，`BiasedPreparation` 从一个函数返回一个操作，但这与之前描述的函数和操作之间的划分完全一致，因为 `BiasedPreparation`
    仍然是可预测的。特别是，`BiasedPreparation(p)` 对于给定的 `p` 总是返回相同的操作，无论我们调用函数多少次。我们可以通过注意到 `BiasedPreparation`
    只部分应用操作但从不调用它们来确保这一点。
- en: 'Exercise 7.4: Partial application'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.4：部分应用
- en: Partial application works for functions as well as operations! Try it by writing
    a function `Plus` that adds two integers, `n` and `m`, and another function `PartialPlus`
    that takes an input `n` and returns a function that adds `n` to its input.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用适用于函数和操作！尝试编写一个函数 `Plus`，它将两个整数 `n` 和 `m` 相加，并编写另一个函数 `PartialPlus`，它接受一个输入
    `n` 并返回一个函数，该函数将 `n` 加到其输入上。
- en: '*Hint*: You can get started using the following code snippet as a template:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：您可以使用以下代码片段作为模板开始：'
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 7.4 Playing Morgana’s game in Q#
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 在 Q# 中玩 Morgana 的游戏
- en: With first-class operations and partial application at the ready, we can now
    make a more complete version of Morgana’s game.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好一等操作和部分应用后，我们现在可以制作一个更完整的 Morgana 的游戏版本。
- en: The Q# standard libraries
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Q# 标准库
- en: The Quantum Development Kit comes with various standard libraries that we’ll
    see throughout the rest of the book. In listing 7.8, for example, we use an `MResetZ`
    operation that both measures a qubit (similar to `M`) and resets it (similar to
    `Reset`). This operation is offered by the `Microsoft.Quantum.Measurement` namespace,
    one of the main standard libraries that come with the Quantum Development Kit.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 量子开发工具包附带各种标准库，我们将在本书的其余部分看到这些库。例如，在列表 7.8 中，我们使用了一个 `MResetZ` 操作，它既测量量子比特（类似于
    `M`），又将其重置（类似于 `Reset`）。此操作由 `Microsoft.Quantum.Measurement` 命名空间提供，这是量子开发工具包附带的主要标准库之一。
- en: A full list of the operations and functions available in that namespace can
    be found at [https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.measurement](https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.measurement).
    For now, though, don’t worry too much about it; we’ll see more of the Q# standard
    libraries as we go.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在该命名空间中找到所有操作和函数的完整列表，请参阅 [https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.measurement](https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.measurement)。不过，现在不必过于担心它；随着我们的深入，我们将看到更多的
    Q# 标准库。
- en: Listing 7.8 Complete Q# listing for biased `PlayMorganasGame`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 完整的 Q# 列表，用于偏置的 `PlayMorganasGame`
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Opens namespaces from the Q# standard library to help with classical math
    and measuring qubits
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打开 Q# 标准库中的命名空间，以帮助进行经典数学和测量量子比特
- en: ❷ The rotation angle chooses the coin’s bias.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 旋转角度选择硬币的偏差。
- en: ❸ Uses the operation we passed in as statePreparation and applies it to the
    qubit.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用我们传递的操作作为状态准备，并将其应用于量子比特。
- en: ❹ The MResetZ operation is defined in the Microsoft.Quantum.Measurement namespace
    that we open at the beginning of the sample. It measures the qubit in the *Z*-basis
    and then applies the operations needed to return the qubit to the |0〉 state.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ MResetZ 操作定义在我们在示例开头打开的 Microsoft.Quantum.Measurement 命名空间中。它测量在 *Z*-基下的量子比特，然后应用将量子比特返回到
    |0〉 状态所需的操作。
- en: ❺ Uses partial application to specify the bias for our state preparation procedure
    but not the target qubit. While PrepareBiasedCoin has type (Double, Qubit) =>
    Unit, PrepareBiasedCoin(0.2, _) “fills in” one of the two inputs, leaving an operation
    with type Qubit => Unit, as expected by EstimateBias.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用部分应用来指定状态准备过程中的偏差，但不指定目标量子比特。虽然 `PrepareBiasedCoin` 有类型 (Double, Qubit)
    => Unit，但 `PrepareBiasedCoin(0.2, _)` “填充”了两个输入中的一个，留下一个类型为 Qubit => Unit 的操作，正如
    EstimateBias 所期望的那样。
- en: Providing documentation for Q# functions and operations
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Q# 函数和操作提供文档
- en: Documentation can be provided for Q# functions and operations by writing small,
    specially formatted text documents in triple-slash (`///`) comments before a function
    or operation declaration. These documents are written in Markdown, a simple text-formatting
    language used on sites like GitHub, Azure DevOps, Reddit, and Stack Exchange and
    by site generators like Jekyll. The information in `///` comments is shown when
    we hover over calls to that function or operation and can be used to make API
    references similar to those at [https://docs.microsoft.com/qsharp/api/](https://docs.microsoft.com/qsharp/api/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在函数或操作声明之前编写小型的、特别格式化的文本文档（在 `///` 注释中）来为 Q# 函数和操作提供文档。这些文档使用 Markdown 编写，Markdown
    是一种简单的文本格式化语言，在 GitHub、Azure DevOps、Reddit 和 Stack Exchange 等网站上使用，并由 Jekyll 等网站生成器使用。当我们将鼠标悬停在函数或操作的调用上时，会显示
    `///` 注释中的信息，并且可以使用这些信息来创建类似于 [https://docs.microsoft.com/qsharp/api/](https://docs.microsoft.com/qsharp/api/)
    中的 API 参考。
- en: 'Different parts of `///` comments are indicated with section headers such as
    `/// # Summary`. For example, we can document the `PrepareBiasedCoin` operation
    from listing 7.8 with the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`///` 注释的不同部分通过如 `/// # Summary` 这样的部分标题来指示。例如，我们可以使用以下内容来记录 7.8 列表中的 `PrepareBiasedCoin`
    操作：'
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When using IQ#, we can look up documentation comments by using the `?` command.
    For instance, we can look up the documentation for the `X` operation by running
    `X?` in an input cell.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 IQ# 时，我们可以通过使用 `?` 命令来查找文档注释。例如，我们可以在输入单元格中运行 `X?` 来查找 `X` 操作的文档。
- en: For a full reference, see
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的参考，请参阅
- en: '[https://docs.microsoft.com/azure/quantum/user-guide/language/statements/iterations#documentation-comments](https://docs.microsoft.com/azure/quantum/user-guide/language/statements/iterations#documentation-comments).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/azure/quantum/user-guide/language/statements/iterations#documentation-comments](https://docs.microsoft.com/azure/quantum/user-guide/language/statements/iterations#documentation-comments)。'
- en: 'To estimate the bias of a particular state preparation operation, we can run
    the `PlayMorganasGame` operation repeatedly and count how many times we get a
    `Zero`. Let’s pick a value for `winProbability` and run the `PlayMorganasGame`
    operation with that value to see how long Lancelot will be stuck:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了估计特定状态准备操作的偏差，我们可以重复运行 `PlayMorganasGame` 操作，并计算我们得到多少次 `Zero`。让我们选择一个 `winProbability`
    值，并使用该值运行 `PlayMorganasGame` 操作，看看兰斯洛特会卡住多久：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ We can pass inputs to operations using the %simulate command by specifying
    them after the name of the operation we want to simulate.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以通过指定在要模拟的操作名称之后来使用 `%simulate` 命令将输入传递给操作。
- en: 'Try playing around with different values of `winProbability`. Note that if
    Morgana really tips the scales, we can confirm that it will take Lancelot quite
    a long time to make it back to Guinevere:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的 `winProbability` 值进行实验。注意，如果 Morgana 真的改变了天平，我们可以确认兰斯洛特将需要相当长的时间才能回到圭尼维尔：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the next chapter, we’ll build on the skills we learned here by going back
    to Camelot to find our first example of a quantum algorithm: the Deutsch–Jozsa
    algorithm.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过回到卡美洛来找到我们第一个量子算法的例子：Deutsch–Jozsa 算法。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Q# is a quantum programming language provided with the open source Quantum Development
    Kit from Microsoft.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q# 是由微软提供的开源量子开发工具包的一部分量子编程语言。
- en: Quantum programs in Q# are broken down into *functions* representing classical
    and deterministic logic, and *operations* that can have side effects such as sending
    instructions to quantum devices.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q# 中的量子程序被分解为表示经典和确定逻辑的 *函数*，以及可能产生副作用（如向量子设备发送指令）的 *操作*。
- en: Functions and operations are first-class values in Q# and can be passed as inputs
    to other functions and operations. We can use this to combine different parts
    of quantum programs.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和操作是 Q# 中的第一类值，可以作为输入传递给其他函数和操作。我们可以利用这一点来组合量子程序的不同部分。
- en: By passing Q# operations in our program, we can extend our QRNG example from
    chapter 2 to allow passing in operations that prepare states other than |+〉; this
    in turn allows for making biased random numbers.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在我们的程序中传递 Q# 操作，我们可以将第 2 章中的 QRNG 示例扩展，允许传递准备其他状态的操作，除了 |+〉；这反过来又允许生成有偏的随机数。
