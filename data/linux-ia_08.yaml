- en: Chapter 9\. Securing your web server
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章\. 保护你的Web服务器
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Securing your infrastructure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护你的基础设施
- en: Controlling access to your server using firewalls
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用防火墙控制对服务器的访问
- en: Using encryption to protect your data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密来保护你的数据
- en: Tightening the authentication process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧缩认证过程
- en: Controlling software and processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制软件和进程
- en: 'The *web* part of *web server* is a bit misleading. After all, most of the
    security tools I’m going to discuss in this chapter are important no matter what
    kind of server you’re running. In fact, *server* is also kind of redundant, as
    all computers need securing. Still, because by definition they’re exposed to significant
    external traffic, the security of your web servers should be a particularly high
    priority. So the best way to test the things you’re going to learn about in this
    chapter is to have an Apache web server running. Consider putting one together
    right now: `apt install apache2`.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web服务器*中的*Web*部分有点误导。毕竟，我在本章中将要讨论的大多数安全工具无论你运行什么类型的服务器都是重要的。实际上，*服务器*这个词也有点多余，因为所有计算机都需要保护。然而，由于它们按定义暴露于大量的外部流量，因此你的Web服务器的安全性应该是一个特别高的优先级。所以，测试本章中将要学习的内容的最佳方式是运行一个Apache
    Web服务器。考虑现在就把它组装起来：`apt install apache2`。'
- en: In an IT context, *security* is the protection of hardware, software, data,
    and digital services from unauthorized access and corruption. Given that networked
    computer resources are designed to be exposed to client users of one sort or another,
    ensuring that only the right clients are able to perform only the right operations
    is a challenge.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT环境中，*安全*是指保护硬件、软件、数据和数字服务免受未经授权的访问和破坏。鉴于网络计算机资源被设计成要向各种客户端用户暴露，确保只有正确的客户端能够执行正确的操作是一个挑战。
- en: You can think of security as the fine art of balancing value against risk. When
    you consider how many kinds of security threats already exist, and how frequently
    new ones appear, you’ll probably understand that the balance will never be perfect.
    It will most certainly need to be reassessed often.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将安全性视为权衡价值与风险的精细艺术。当你考虑到已经存在多少种安全威胁，以及新的威胁出现得有多频繁时，你可能会理解到这种平衡永远不会完美。它肯定需要经常重新评估。
- en: 'There’s no single tool or practice that can cover every aspect of security.
    Although it’s not a bad idea to build yourself a checklist of key security to-dos,
    that’s not enough. The most successful administrators I’ve known were all deeply
    skilled and knowledgeable, and they also seemed to share a particular attitude:
    no software, vendor, government agency, co-worker, or even close friend can ever
    be completely trusted. They may mean you no harm, but it’s too easy to make a
    mistake and leave an important window open to attack. Everything and everyone
    can use a second pair of eyes and some double checking.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何单一的工具或实践可以涵盖安全性的各个方面。虽然为自己制定一个关键安全待办事项清单并不是一个坏主意，但这还远远不够。我所知道的最为成功的管理员都是技艺精湛且知识渊博的，而且他们似乎还共享一种特定的态度：没有任何软件、供应商、政府机构、同事，甚至亲密的朋友可以完全信赖。他们可能对你并无恶意，但犯错误并留下一个容易被攻击的重要漏洞实在太容易了。每一件事和每一个人都可以使用一双额外的眼睛和一些双重检查。
- en: What can you do to secure your servers? It’s really about the small things.
    Lots and lots of small things. So many, in fact, that a couple of them are going
    to spill over into the next chapter. In this chapter, however, we’ll begin with
    some basics before diving into using firewalls to control network access, protecting
    website data transfers with SSL/TLS encryption, and limiting what can be done
    with server resources through the strategic use of tools like Security-Enhanced
    Linux (SELinux) and system groups.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做些什么来保护你的服务器？这实际上关乎许多小事。事实上，有很多小事，其中一些可能会溢出到下一章。然而，在这一章中，我们将在深入探讨如何使用防火墙来控制网络访问、使用SSL/TLS加密保护网站数据传输以及通过战略性地使用像安全增强Linux
    (SELinux) 和系统组这样的工具来限制对服务器资源的使用之前，先从一些基础知识开始。
- en: 9.1\. The obvious stuff
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 显而易见的事情
- en: 'Let’s start by picking some low-hanging fruit. A lot of security is common
    sense, considering the many security best practices you’ve seen so far in this
    book. But, simple as it may be, you can’t afford to ignore these basics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从选择一些容易解决的问题开始。考虑到你在本书中已经看到了许多安全最佳实践，许多安全都是常识。但是，尽管它可能很简单，你也不能忽视这些基础知识：
- en: Back up your data. Today. No matter what the bad guys do to your server, if
    you can rebuild it from a reliable backup, then you’re still in the game. Take
    another look at [chapters 4](kindle_split_012.xhtml#ch04) and [5](kindle_split_013.xhtml#ch05)
    and then script yourself a regular, automated, comprehensive, and verifiable backup
    regimen that covers everything of any value that you’ve got. Make sure that there’s
    more than one archival version available at all times and that at least one archive
    is stored off site.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天就备份你的数据。无论坏人对你服务器做了什么，如果你能从可靠的备份中重建它，那么你仍然在游戏中。再次查看[第4章](kindle_split_012.xhtml#ch04)和[第5章](kindle_split_013.xhtml#ch05)，然后为自己编写一个定期、自动化、全面且可验证的备份计划，涵盖你拥有的任何有价值的东西。确保始终有多个存档版本可用，并且至少有一个存档存储在异地。
- en: 'Apply all software updates to your system. No excuse. Oh, there are always
    excuses: you’re afraid that updates might break something your application depends
    on or it might require a reboot that could end up being disruptive. But do it
    anyway. Don’t get me wrong. I understand that those are real concerns. It’s that
    the alternatives are worse. Here’s your friendly reminder for updating your system:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有软件更新应用到你的系统上。没有借口。哦，总是有借口：你害怕更新可能会破坏你的应用程序所依赖的东西，或者它可能需要重启，这可能会造成中断。但无论如何都要做。不要误会我。我理解那些是真实的问题。问题是替代方案更糟糕。这是你友好的系统更新提醒：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or (on Ubuntu):'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者（在Ubuntu上）：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t forget that package managers only update packages that were installed
    through managed repositories. Any applications you added manually will remain
    *unpatched* (and potentially unsafe) until you either manually apply patches or
    disable them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，包管理器只更新通过管理仓库安装的软件包。任何你手动添加的应用程序将保持*未修补*（并且可能不安全），直到你手动应用补丁或禁用它们。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You could avoid most of the risk of disruption by building test (or *staging*)
    environments ([figure 9.1](#ch09fig01)) that run mirror images of your applications
    that are safely protected from public networks. Applying updates and patches to
    your staging infrastructure should give you an excellent idea of how it’ll work
    in the real world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建测试（或*预发布*）环境（[图9.1](#ch09fig01)），其中运行着你的应用程序的镜像，并且安全地保护免受公共网络的影响，你可以避免大多数中断的风险。对你的预发布基础设施应用更新和补丁应该能给你一个很好的想法，了解它在现实世界中的工作情况。
- en: Figure 9.1\. You can replicate server infrastructure in a protected staging
    environment to safely perform maintenance.
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1。你可以在受保护的预发布环境中复制服务器基础设施，以安全地进行维护。
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig01_alt.jpg)'
- en: Even better, you could use the infrastructure as the code configuration management
    software you’ll see in [chapter 16](kindle_split_024.xhtml#ch16) to automate your
    whole deployment process. That way, once you confirm that the staging environment
    you patched is running properly, it can become your production infrastructure.
    But that’s a discussion we’ll leave until later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你可以使用[第16章](kindle_split_024.xhtml#ch16)中提到的代码配置管理软件作为基础设施来自动化你的整个部署流程。这样，一旦你确认你修补的预发布环境运行正常，它就可以成为你的生产基础设施。但这是一个我们稍后再讨论的话题。
- en: 9.2\. Controlling network access
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 控制网络访问
- en: Think of your server’s connection to the network and the big, bad internet beyond
    as your first line of defense. Networking protocols are designed to be flexible
    to help you closely control what traffic makes it through. The trick is understanding
    how the protocols work, and then properly using that knowledge to set things up
    right.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的服务器连接到网络以及外面的广阔、危险的互联网视为你的第一道防线。网络协议被设计成灵活的，以帮助你严格控制哪些流量能够通过。关键是理解这些协议是如何工作的，然后正确地使用这些知识来设置正确的事情。
- en: 9.2.1\. Configuring a firewall
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 配置防火墙
- en: A *firewall* is a set of rules. When a data packet moves into or out of a protected
    network space, its contents (in particular, information about its origin, its
    target, and the protocol it plans to use) are tested against the firewall rules
    to see if it should be allowed through. Here’s a simple example as illustrated
    in [figure 9.2](#ch09fig02).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*防火墙*是一组规则。当数据包进入或离开受保护的网络空间时，其内容（特别是关于其来源、目标以及它计划使用的协议的信息）将根据防火墙规则进行测试，以确定是否允许通过。以下是一个简单示例，如图9.2所示。'
- en: Figure 9.2\. A firewall can filter requests based on protocol or target-based
    rules.
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2。防火墙可以根据协议或基于目标的规则过滤请求。
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig02_alt.jpg)'
- en: Let’s say that your company’s web server has to be open to incoming web traffic
    from anywhere on earth using either the insecure HTTP or secure HTTPS protocol.
    Because your developers and admins will need to get into the backend from time
    to time to do their work, you’ll also want to allow SSH traffic, but only for
    those people who’ll need it. Requests for any other services should be automatically
    refused. Let’s see how that’s done.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的公司的网络服务器需要对外开放，接受来自地球上任何地方的HTTP或HTTPS协议的Web流量。因为你的开发人员和管理员有时需要进入后端进行工作，你也会希望允许SSH流量，但仅限于那些需要它的人。对任何其他服务的请求应自动拒绝。让我们看看如何实现这一点。
- en: A Linux machine can be configured to apply firewall rules at the kernel level
    through a program called *iptables*. Creating iptables rules isn’t all that difficult;
    the syntax can be learned without too much fuss. But, in the interest of simplifying
    your life, many Linux distributions have added their own higher-level tools for
    abstracting the job. In this section, you’re going to see CentOS’s firewalld and
    Ubuntu’s UncomplicatedFirewall (ufw).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过名为*iptables*的程序在内核级别配置Linux机器以应用防火墙规则。创建iptables规则并不困难；语法可以在不太麻烦的情况下学习。但是，为了简化你的生活，许多Linux发行版已经添加了自己的高级工具来抽象化这项工作。在本节中，你将看到CentOS的firewalld和Ubuntu的UncomplicatedFirewall（ufw）。
- en: Firewall functionality is also available through hardware appliances manufactured
    by companies like Juniper and Cisco. Those proprietary devices run on their own
    operating systems with unique syntax and design. For larger enterprise deployments
    involving hundreds of servers spread across multiple networks, such tools will
    often make a lot of sense, but there’s a remarkable amount that you can accomplish
    with any old Linux box for a tiny fraction of the cost. Having said that, this
    section will introduce you to only a small subset of the full functionality of
    Linux firewalls. Naturally, if you want to learn more, stick around for a bit
    more depth in [chapter 10](kindle_split_018.xhtml#ch10) and consult the usual
    sources of Linux wisdom, like man files and online guides.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙功能也通过Juniper和Cisco等公司制造的硬件设备提供。这些专有设备运行在自己的操作系统上，具有独特的语法和设计。对于涉及数百台服务器的大型企业部署，这些工具通常非常有意义，但你可以用任何旧的Linux机器以极小的成本完成大量工作。话虽如此，本节将仅介绍Linux防火墙功能的一小部分。当然，如果你想了解更多，请稍作停留，以便在[第10章](kindle_split_018.xhtml#ch10)中了解更多深度内容，并咨询Linux智慧的常规来源，如man文件和在线指南。
- en: firewalld
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: firewalld
- en: 'As you might have guessed from its name, firewalld is part of the systemd family.
    firewalld can be installed on Debian/Ubuntu machines, but it’s there by default
    on Red Hat and CentOS. If you’re just too excited by firewalld to even consider
    trying anything else, here’s how to install it and get it running on Ubuntu:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的，firewalld是systemd家族的一部分。firewalld可以安装在Debian/Ubuntu机器上，但在Red Hat和CentOS上默认存在。如果你对firewalld的热情如此之高，以至于甚至不考虑尝试其他任何东西，这里是如何在Ubuntu上安装它并使其运行的方法：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To confirm that the firewall is working, try browsing to your server’s web root.
    If the site is unreachable, then firewalld is doing its job.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认防火墙是否正常工作，尝试浏览到服务器的Web根目录。如果网站无法访问，那么firewalld正在执行其工作。
- en: 'You’ll use the `firewall-cmd` tool to manage firewalld settings from the command
    line. Adding the `--state` argument returns the current firewall status:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`firewall-cmd`工具从命令行管理firewalld设置。添加`--state`参数会返回当前的防火墙状态：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A few important terms**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些重要术语**'
- en: To be sure no one’s left out, let’s define a few important terms. The *Hypertext
    Transfer Protocol* (HTTP) coordinates the exchange of resources between web clients
    and web servers over a network. A browser might, for instance, request a web page
    written in the *Hypertext Markup Language* (HTML), to which the server can respond
    by transferring the page contents. *Metadata* (contextual information attached
    to a packet) containing information about session status is generated by each
    data transfer event and consumed later by admins trying to figure out what went
    wrong. The HTTPS variation of the protocol ensures that data transfers are securely
    encrypted using the *Transport Layer Security* (TLS) protocol.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保没有人被遗漏，让我们定义一些重要的术语。*超文本传输协议*（HTTP）在网络中协调客户端和服务器之间资源的交换。例如，浏览器可能会请求一个用*超文本标记语言*（HTML）编写的网页，服务器可以通过传输页面内容来响应。每个数据传输事件都会生成包含有关会话状态信息的*元数据*（附加到数据包上的上下文信息），随后由管理员在试图找出问题所在时使用。HTTPS协议的变体确保使用*传输层安全性*（TLS）协议安全地加密数据传输。
- en: A *packet* is a small unit of data that might have been carved out of a larger
    data file or archive. After transmission, packets can be reassembled into their
    original form. When the *Transmission Control Protocol* (TCP) is used for a network
    data transfer, packets being transferred across a network are checked for errors
    when received and, if necessary, resent. Transfers using the *User Datagram Protocol*
    (UDP) will complete more quickly than TCP but, because they don’t include error
    correction, they’re only appropriate for operations that are highly tolerant of
    error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据包*是可能从较大的数据文件或存档中分离出来的一小部分数据。传输后，数据包可以被重新组装成其原始形式。当使用*传输控制协议*（TCP）进行网络数据传输时，接收到的数据包会在接收时进行检查，并在必要时重新发送。使用*用户数据报协议*（UDP）的传输将比TCP更快完成，但由于它们不包含错误纠正，因此仅适用于对错误高度容忍的操作。'
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'By default, firewalld will be active and will reject all incoming traffic with
    a couple of exceptions, like SSH. That means your website won’t be getting too
    many visitors, which will certainly save you a lot on data transfer costs. As
    that’s probably not what you had in mind for your web server, you’ll want to open
    the HTTP and HTTPS ports that, by convention, are designated as 80 and 443, respectively.
    firewalld offers two ways to do that. One is through the `--add-port` argument
    that references the port number directly along with the network protocol it’ll
    use (TCP in this case). The `--permanent` argument tells firewalld to load this
    rule each time the server boots:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，firewalld 将处于活动状态，并将拒绝除SSH之外的所有传入流量。这意味着你的网站不会吸引太多访客，这无疑会为你节省大量的数据传输成本。既然这很可能不是你为你的Web服务器所设想的情况，你将想要打开HTTP和HTTPS端口，按照惯例，分别被指定为80和443。firewalld提供了两种方法来实现这一点。一种是通过`--add-port`参数直接引用端口号以及它将使用的网络协议（在这种情况下是TCP）。`--permanent`参数告诉firewalld在服务器启动时加载此规则：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `--reload` argument will apply those rules to the current session:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`--reload` 参数将应用这些规则到当前会话：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That approach will work for any complicated or customized configuration you
    can come up with. But if you’ve got simpler needs, you can use one of firewalld’s
    predefined values for many of the more commonly used services. Those values are
    drawn from the data kept in the /etc/services file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于你所能想到的任何复杂或定制配置。但如果你有更简单的需求，你可以使用firewalld为许多常用服务预定义的值。这些值是从`/etc/services`文件中保留的数据中提取的。
- en: The `--add-service` argument, when it refers to your HTTP and HTTPS services,
    would open ports 80 and 443\. This may not seem like a big deal in this case,
    but when push comes to shove and time is short, are you sure you’ll remember that
    the default MySQL port happens to be 3306? Wouldn’t it be easier to just type
    `mysql`?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`--add-service`参数，当它指的是你的HTTP和HTTPS服务时，将打开80和443端口。在这种情况下，这看起来可能不是什么大问题，但当紧急情况发生且时间紧迫时，你确定你会记得默认MySQL端口号恰好是3306吗？直接输入`mysql`不是更容易吗？'
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Curious as to the current settings on your firewall? Run `--list-services`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对你防火墙上的当前设置感到好奇吗？运行 `--list-services`：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Assuming you’ve added browser access as described earlier, the HTTP, HTTPS,
    and SSH ports are all open, along with `dhcpv6-client`, which allows Linux to
    request an IPv6 IP address from a local DHCP server. You’ll learn more about that
    in [chapter 14](kindle_split_022.xhtml#ch14).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经按照前面描述的方式添加了浏览器访问，HTTP、HTTPS和SSH端口都是开放的，还有`dhcpv6-client`，它允许Linux从本地DHCP服务器请求IPv6
    IP地址。你将在第14章中了解更多关于这个内容。
- en: You certainly don’t want just anyone getting SSH access to your server, so let’s
    put firewalld to work securing it. You’ll restrict SSH access so that only sessions
    originating from a particular IP address will be allowed. To do that, I’m going
    to show you how to cut off all SSH access and then open it for only a single IP.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然不希望任何人都能访问你的服务器SSH，所以让我们让firewalld来保护它。你将限制SSH访问，只允许来自特定IP地址的会话。为此，我将向你展示如何切断所有SSH访问，然后只为单个IP地址开放。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'I should warn you that playing around with firewalls while logged in to an
    SSH session is a bit dangerous. You could end up locked out of your own server.
    If this happens, there are some tricks (coming later in this chapter) for getting
    back in. In any case, if you’re using a disposable LXC container or VM, you shouldn’t
    have all that much to worry about one way or the other: if something breaks, destroy
    it and fire up a clean one.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该警告你，在SSH会话中玩弄防火墙是有点危险的。你可能会被锁在自己的服务器外面。如果发生这种情况，有一些技巧（在本章后面介绍）可以帮助你重新进入。无论如何，如果你使用的是可丢弃的LXC容器或VM，你不必太担心：如果出了问题，销毁它并启动一个干净的。
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To shut down the existing SSH access, use `--remove-service` and then reload
    firewalld (`--remove-port` will work the same way if you’re referring to the port
    number):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭现有的SSH访问，使用`--remove-service`然后重新加载firewalld（如果你指的是端口号，`--remove-port`将起到相同的作用）：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Test your new configuration to make sure it worked. Open a new terminal on
    any other machine with network access, and try to log in to your server using
    SSH. Your attempt should fail:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的新配置以确保它已经生效。在任何其他有网络访问的机器上打开一个新的终端，并尝试使用SSH登录到你的服务器。你的尝试应该失败：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Allowing root login via SSH is not a good idea and can be forbidden in
    the /etc/ssh/sshd.conf file through the PermitRootLogin setting with a value of
    no.**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过SSH允许root登录不是一个好主意，可以在`/etc/ssh/sshd.conf`文件中通过PermitRootLogin设置禁止，设置为no。**'
- en: 'Now, back on your firewalld machine, add a new rule that will accept TCP traffic
    on port 22 (the default SSH port), but only from clients using the IP address
    192.168.1.5 (or whatever the IP address of your client machine is). The `--add-rich-rule`
    argument tells `firewall-cmd` that this command uses the *Rich Language* set,
    a high-level syntax designed to simplify the creation of complex firewall rules
    (see [http://mng.bz/872B](http://mng.bz/872B) for more details):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的firewalld机器上，添加一个新规则，该规则将接受来自使用IP地址192.168.1.5（或你的客户端机器的IP地址）的客户端的22端口（默认SSH端口）的TCP流量。`--add-rich-rule`参数告诉`firewall-cmd`这个命令使用的是*Rich
    Language*集，这是一种高级语法，旨在简化复杂防火墙规则的创建（有关更多详细信息，请参阅[http://mng.bz/872B](http://mng.bz/872B)）：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now try logging in once again from a terminal originating in the specified IP
    address. It should work. Because you didn’t make this rule permanent, everything
    should go back to normal the next time you boot.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试从指定IP地址的终端再次登录。应该可以登录。因为你没有使这个规则永久化，下次启动时一切应该恢复正常。
- en: UncomplicatedFirewall (ufw)
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: UncomplicatedFirewall (ufw)
- en: 'Let’s see how you can similarly control SSH access on an Ubuntu machine using
    ufw. The ufw program might not come installed on new Ubuntu installations and,
    in any case, will be disabled by default, so you’ll want to get it running:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用ufw在Ubuntu机器上以类似的方式控制SSH访问。ufw程序可能不会在新安装的Ubuntu上安装，并且在任何情况下，默认情况下都会被禁用，所以你需要让它运行：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because ufw starts with all ports closed, enabling it prevents you from opening
    a new SSH session. Any existing sessions shouldn’t be affected but, still, it’s
    probably a good idea to add a rule allowing SSH even before enabling ufw:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ufw默认所有端口都是关闭的，启用它会阻止你打开新的SSH会话。现有的会话不应该受到影响，但仍然，添加一个允许SSH的规则在启用ufw之前可能是个好主意：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Use the ufw deny ssh command to disable SSH.**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用ufw deny ssh命令来禁用SSH。**'
- en: '***2* Starts the firewall. When necessary, use the ufw disable command to shut
    down ufw.**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 启动防火墙。当需要时，使用ufw disable命令来关闭ufw。**'
- en: '***3* A warning that existing or new remote connections might be affected by
    this action**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 警告：现有或新的远程连接可能会受到影响** '
- en: 'If you’re running ufw on an LXC container, those commands probably didn’t work.
    Instead, this rather frightening error message was probably displayed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在LXC容器上运行ufw，那些命令可能没有起作用。相反，您可能看到了以下相当令人恐惧的错误信息：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* With IPv6 support disabled on the host system, you may encounter this
    error message.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在主机系统上禁用了IPv6支持，您可能会遇到此错误信息。**'
- en: This is related to the fact that LXC containers might not have IPv6 support
    enabled by default. Fixing that might be complicated, given that containers lack
    full access to their host’s kernel. If you’re not planning to include IPv6 in
    your network configuration (which, in any case, fits the vast majority of use
    cases), then it’ll be simplest to disable IPv6 support in your /etc/default/ufw
    configuration file by editing the `IPV6=yes` line to read `IPV6=no`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这与LXC容器可能默认未启用IPv6支持的事实有关。考虑到容器无法完全访问其宿主机的内核，解决这个问题可能很复杂。如果您不打算将IPv6包含在网络配置中（无论如何，这符合绝大多数用例），那么最简单的方法是在您的/etc/default/ufw配置文件中将`IPV6=yes`行编辑为`IPV6=no`。
- en: Listing 9.1\. Part of the /etc/default/ufw configuration file
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. /etc/default/ufw配置文件的一部分
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Change the value of IPV6 from yes to no to disable IPv6 support and avoid
    the ufw error.**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将IPV6的值从yes更改为no以禁用IPv6支持并避免ufw错误。**'
- en: 'Enabling ufw, adding a rule for SSH, and running `ufw enable` should now work:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 启用ufw、添加SSH规则并运行`ufw enable`现在应该可以正常工作：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Like firewalld, ufw lets you create rules using either port numbers or service
    names (like the `ufw allow ssh` you just used). The following two commands will
    open HTTP and HTTPS access for your web server:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与firewalld类似，ufw允许您使用端口号或服务名称（如您刚刚使用的`ufw allow ssh`）来创建规则。以下两个命令将为您的Web服务器打开HTTP和HTTPS访问：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `ufw status` command shows you that the service is running and that the
    three rules you need are now active. Go ahead and test this against your web server:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ufw status`命令显示服务正在运行，并且您需要的三个规则现在都是活动的。请继续测试您的Web服务器：'
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To properly test web server access through a firewall, don’t forget that your
    browser caches page data. This means that the browser might be able to load a
    page it’s previously visited even though there’s now a firewall rule that’s supposed
    to make that impossible. To make sure you’re testing the current state of your
    website, flush the browser cache or refresh your browser page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确测试通过防火墙访问Web服务器，别忘了您的浏览器缓存页面数据。这意味着即使现在有防火墙规则应该阻止这种情况，浏览器仍然可能加载它之前访问过的页面。为了确保您正在测试网站当前的状态，请清除浏览器缓存或刷新浏览器页面。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'One more piece of fine-tuning will limit SSH access to your team members sitting
    behind a specific IP address. If it’s safe (meaning your web server isn’t exposed
    to internet traffic right now), it’s a good idea to disable ufw before making
    these changes. Then remove your allow-SSH rule using `delete 2` (which refers
    to the rule as the second in the ufw list) and reopen it only for traffic coming
    from 10.0.3.1\. (In my case, because I was logging in to the LXC container from
    my LXC host, that happens to be the IP I’ll use; your mileage may vary.) Finally,
    restart ufw and check its new state:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再进行一项微调将限制SSH访问仅限于坐在特定IP地址后的团队成员。如果现在安全（意味着您的Web服务器目前没有暴露在互联网流量中），在做出这些更改之前禁用ufw是一个好主意。然后使用`delete
    2`（这指的是ufw列表中的第二个规则）删除您的允许SSH规则，并且只为来自10.0.3.1的流量重新打开它。（在我这个例子中，因为我从我的LXC主机登录到LXC容器，所以这个IP地址是我将使用的；您的结果可能会有所不同。）最后，重新启动ufw并检查其新状态：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Deletes the second firewall rule displayed by ufw status**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 删除ufw状态显示的第二个防火墙规则**'
- en: '***2* Permits SSH traffic from only the specified IP and nowhere else**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 仅允许从指定的IP地址进行SSH流量，而不允许其他任何地方**'
- en: '***3* A new rule permitting SSH traffic only from the specified IP**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一个新的规则，仅允许从指定的IP进行SSH流量**'
- en: You can test your configuration by logging in from both the machine using the
    permitted IP and from any other machine. The first one should work, but the second
    one had better not!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从允许的IP地址的机器和任何其他机器登录来测试您的配置。第一个应该可以工作，但第二个最好不要工作！
- en: With that, you’ve now seen how to use both firewalld and ufw to securely configure
    access to a simple web server. Even though firewalls can control traffic using
    any protocol or port, we’ve only covered HTTP, HTTPS, and SSH. It’s worth also
    mentioning that, as you’ll see a bit later in this chapter, you can use nonstandard
    network ports for your applications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你现在已经看到了如何使用firewalld和ufw来安全地配置对简单Web服务器的访问。尽管防火墙可以使用任何协议或端口来控制流量，但我们只介绍了HTTP、HTTPS和SSH。也值得提到的是，正如你将在本章稍后看到的那样，你可以为你的应用程序使用非标准网络端口。
- en: Recovering a locked VM
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 恢复被锁定的虚拟机
- en: 'If you do manage to lock yourself out of an LXC container, you can use `chroot`
    (as you did back in [chapter 6](kindle_split_014.xhtml#ch06)) to disable or even
    reconfigure your firewall. First of all, stop the container and then run `chroot`
    against the rootfs directory that’s within the directory hierarchy used by your
    LXC container (/var/lib/lxc/your-container-name/). The command prompt you’ll get
    lets you execute commands as if the container was actually running. Now disable
    ufw or, if you prefer, run the necessary commands to fix the problem and then
    exit the `chroot` shell. When you start the container up again, you should have
    SSH access:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的把自己锁在了LXC容器外面，你可以使用`chroot`（就像你在[第6章](kindle_split_014.xhtml#ch06)中做的那样）来禁用或重新配置你的防火墙。首先，停止容器，然后对LXC容器使用的目录层次结构中的rootfs目录（/var/lib/lxc/your-container-name/）运行`chroot`。你将得到的命令提示符让你可以像容器实际运行时一样执行命令。现在禁用ufw，或者如果你更喜欢，运行必要的命令来解决问题，然后退出`chroot`外壳。当你再次启动容器时，你应该有SSH访问：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Stops a running LXC container**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 停止运行的LXC容器**'
- en: '***2* Mounts your container’s file system as chroot**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将你的容器文件系统挂载为chroot**'
- en: '***3* Closes the chroot shell session**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 关闭chroot外壳会话**'
- en: 'What if it’s a VirtualBox VM that’s locked you out? That’s an easy one: log
    in through the original terminal that opened when you launched the VM in the first
    place. That’s the equivalent of sitting at a keyboard that’s plugged into a physical
    server and won’t require any network connectivity for access.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是一个VirtualBox虚拟机锁住了你呢？这很简单：通过最初启动VM时打开的原始终端登录。这相当于坐在连接到物理服务器的键盘上，不需要任何网络连接即可访问。
- en: 9.2.2\. Using nonstandard ports
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 使用非标准端口
- en: One advantage of being able to set network ports by number is that it lets you
    configure applications to use nonstandard ports. You could, for instance, set
    port 53987 for SSH rather than 22\. The advantage of nonstandard ports it that
    they let you implement *security through obscurity*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 能够通过数字设置网络端口的一个优点是，它让你可以配置应用程序使用非标准端口。例如，你可以将SSH设置为端口53987而不是22。非标准端口的优势在于，它们让你能够实现*通过隐蔽性来提高安全性*。
- en: 'Let me explain. In and of itself, port 53987 isn’t any more secure than port
    22: exploiting it is simply a matter of updating the SSH client with the new setting.
    But it can, nevertheless, add a layer of protection.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来解释一下。本身来说，端口53987并不比端口22更安全：利用它只是更新SSH客户端的新设置的问题。但无论如何，它还是可以增加一层保护。
- en: 'Imagine there’s a hacker poking away at your infrastructure, trying to find
    a way in. Perhaps that person has discovered that one of your admins has a bad
    habit of reusing the same password for multiple accounts—and one of those accounts
    has already been compromised. The hacker has quite a lot of valuable information
    from that breach: your server’s IP address (it’s often the same as the one used
    by your website) and your admin’s user name and password. Assuming you permit
    password login to your SSH accounts (which, as you know from [chapter 3](kindle_split_011.xhtml#ch03),
    is not a good idea), there’s nothing stopping the hacker from logging in and injecting
    some mayhem into your life. Except no one told the hacker that port 22 is shut
    tight and SSH access is only available through some obscure high-range port (like
    53987). Because you reset the default port, you’ve made it a little bit harder
    to break through your defenses, and that little bit might one day make a big difference.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有一个黑客正在对你的基础设施进行攻击，试图找到进入的方法。也许那个人发现你的管理员有一个坏习惯，就是为多个账户重复使用相同的密码——其中一个账户已经被攻破。黑客从那次入侵中获得了大量有价值的信息：你的服务器的IP地址（通常与你的网站使用的相同）以及你的管理员的用户名和密码。假设你允许通过密码登录你的SSH账户（正如你在[第3章](kindle_split_011.xhtml#ch03)中知道的，这并不是一个好主意），那么黑客登录并给你的生活带来混乱就没有什么阻碍。除非没有人告诉黑客端口22已经关闭，SSH访问只能通过一些神秘的较高端口号（如53987）进行。因为你重置了默认端口，这使得突破你的防御变得更加困难，而这小小的困难可能会在未来的某一天产生重大影响。
- en: How does it work? First, you’ll need to edit the /etc/ssh/sshd_conf configuration
    file on your server (the computer that will host your SSH sessions). The file
    will contain a line that, by default, reads `Port 22`. You’ll want to edit that
    to use whichever port you plan to use.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？首先，你需要在服务器上编辑`/etc/ssh/sshd_conf`配置文件（将托管你的SSH会话的计算机）。该文件将包含一个默认情况下读取为`Port
    22`的行。你需要将其编辑为使用你计划使用的任何端口。
- en: Listing 9.2\. Port setting line from the ssh_d.conf file on an SSH host
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 来自SSH主机ssh_d.conf文件的端口号设置行
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Change this value to the port number you want to use.**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将此值更改为你想要使用的端口号。**'
- en: 'When you’re done, and you’re sure you’ll be able to get back into your server
    should your current SSH session go down, restart the SSH service. If you’ve got
    a firewall going, you’ll need to tell it to allow access on your new port...that’s
    coming soon:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，并且你确信即使当前的SSH会话中断，你也能重新进入你的服务器，请重新启动SSH服务。如果你有一个防火墙，你需要告诉它允许在新端口上进行访问……这即将到来：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, when you want to log in from a remote machine, add `-p` followed by the
    new port number. Your SSH client will then be able to request a session over the
    new port:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你想从远程机器登录时，请添加`-p`后跟新的端口号。然后，你的SSH客户端将能够通过新端口请求会话：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you’re logging in using a different SSH client (like PuTTY), you’ll need
    to similarly tell the client about the nonstandard port number. Let’s look at
    that next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用不同的SSH客户端（如PuTTY），你也需要同样告诉客户端关于非标准端口号的信息。让我们接下来看看这一点。
- en: Configuring a ufw firewall to allow traffic through a nonstandard port
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置ufw防火墙以允许通过非标准端口传输流量
- en: 'Opening up a port by number is fairly straightforward, but you’ll need to explicitly
    specify the protocol you’ll be using (TCP or UDP). This example uses the TCP protocol:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数字打开端口相对简单，但你需要明确指定你将使用的协议（TCP或UDP）。此示例使用TCP协议：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also open a range of ports with a single command using the colon (:)
    character. This can be useful for infrastructure planning when, say, you know
    your developers will be pushing out new applications and will need access to multiple
    ports. Giving them a range to play with now can save time and frustration later.
    This particular example opens all the ports between 52900 and 53000:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用单个命令通过冒号（:）字符打开一系列端口。这在基础设施规划中可能很有用，比如当你知道你的开发人员将推出新的应用程序并需要访问多个端口时。现在给他们一个可以玩耍的范围可以节省时间和挫折。这个特定的示例打开了52900和53000之间的所有端口：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Network ports**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络端口**'
- en: 'The 65,535 available network ports are divided into three categories:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 65,535个可用的网络端口分为三类：
- en: Ports between 1 and 1023 are designated as well-known and have been set aside
    for recognized services like SSH (22) and HTTP (80). You should never use a well-known
    port number for your own applications, as you’re likely to cause a conflict.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介于1和1023之间的端口被指定为知名端口，并已留出供已识别服务使用，如SSH（22）和HTTP（80）。你不应该为你的应用程序使用知名端口号，因为你可能会引起冲突。
- en: Ports between 1024 and 49151 are *registered*, meaning companies and organizations
    have requested that specific ports in this range be set aside for their applications
    even if they haven’t become universally adopted. Examples of this are port 1812,
    which is used for the RADIUS authentication protocol, and 3306, MySQL’s dedicated
    port.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介于1024和49151之间的端口是*已注册*的，这意味着公司和组织已经请求在这个范围内的特定端口被留出供他们的应用程序使用，即使它们还没有被普遍采用。例如，1812端口用于RADIUS身份验证协议，3306端口是MySQL的专用端口。
- en: Ports between 49152 and 65535 are *unregistered* and are considered dynamic
    (or private). These ports are available for any temporary or ad hoc use, particularly
    on private networks. You can be confident that they won’t clash with known applications
    or services.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介于49152和65535之间的端口是*未注册*的，被认为是动态的（或私有的）。这些端口可用于任何临时或即兴使用，尤其是在私有网络上。你可以确信它们不会与已知的应用程序或服务冲突。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Choosing a nonstandard port number
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择非标准端口号
- en: 'What port number should you choose? Well let’s first of all get one thing clear:
    you should never let outsiders (like me) influence such decisions! But, to avoid
    possible conflicts with active network applications, you’ll want to stick to values
    in the unregistered range between 49152 and 65535\. That should give you enough
    to work with.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该选择哪个端口号呢？首先，让我们明确一点：你绝对不应该让外人（像我这样的人）影响这样的决定！但是，为了避免与正在运行的网络安全应用发生冲突，你将希望坚持使用49152和65535之间的未注册范围内的值。这应该会给你足够的工作空间。
- en: 'Working with nonstandard ports is, of course, not only for SSH. You should
    consider using this trick for any application that you’ve either written yourself
    or can control through configuration files. And remember: like most of the tools
    in this chapter, this won’t be all that effective on its own, but it’s a powerful
    element when used as part of a larger set of security protocols.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用非标准端口不仅限于SSH。你应该考虑为任何你自己编写的或可以通过配置文件控制的程序使用这个技巧。记住：就像本章中的大多数工具一样，仅靠它本身可能不会非常有效，但作为更大安全协议集的一部分，它是一个强大的元素。
- en: 9.3\. Encrypting data in transit
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 传输中的数据加密
- en: 'For two reasons, website encryption is a really big deal:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个原因，网站加密非常重要：
- en: Unencrypted sites dangerously expose their data and place their users at significant
    risk.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未加密的网站危险地暴露了它们的数据，并将用户置于重大风险之中。
- en: Unencrypted sites generate significantly less business.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未加密的网站产生的商业价值显著较低。
- en: The first problem stems from the fact that unencrypted sites display and handle
    everything in plain text. That means all transfers involving passwords and personal
    and financial information (like credit cards) are visible to any curious observer
    with access to the network. This is obviously a horrible idea.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题源于未加密网站以纯文本形式显示和处理所有内容的事实。这意味着涉及密码、个人和财务信息（如信用卡）的所有传输都对任何有权访问网络的好奇观察者可见。这显然是一个糟糕的想法。
- en: The second problem is the product of a decision made by Google back in January,
    2017\. Google decided to penalize unencrypted websites by ranking them lower in
    internet search results. This made it much harder for users to find content that’s
    not secure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题源于谷歌在2017年1月做出的一个决定。谷歌决定通过在互联网搜索结果中将未加密的网站排名降低来惩罚它们。这使得用户很难找到不安全的内容。
- en: Why should Google (along with other powerful internet companies) care? And why
    should you care? Because the stability of the internet and everything we all do
    with it can’t survive if we can’t trust its content and the way sites handle our
    private information. Even if your site doesn’t process credit card purchases,
    the fact that it’s unencrypted means that it’s much more likely to be compromised,
    with its resources hijacked for use as part of zombie attacks against other sites.
    Any single weak site makes the whole internet weaker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么谷歌（以及其他强大的互联网公司）会关心？你为什么应该关心？因为如果我们不能信任互联网的内容以及网站处理我们私人信息的方式，互联网的稳定性和我们所有人用它所做的一切都无法生存。即使你的网站不处理信用卡购买，它未加密的事实意味着它更有可能被入侵，其资源被劫持用于对其他网站的僵尸攻击。任何一个薄弱的网站都会使整个互联网变得更弱。
- en: If you want to secure your website (which is what this chapter is about, after
    all), then encryption is a significant part of the process. Mind you, don’t think
    that encryption *guarantees* that your data is safe. It just makes it a great
    deal more difficult for the wrong people to get at it. To make this work, you’ll
    need a *certificate*, which is a file containing information identifying the domain,
    owner, key, and a reliable digital signature.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要保护你的网站（毕竟，这是本章的主题），那么加密是这个过程的重要组成部分。请注意，不要认为加密*保证*你的数据是安全的。它只是让错误的人更难接触到它。为了使这起作用，你需要一个*证书*，这是一个包含有关域名、所有者、密钥和可靠数字签名的信息的文件。
- en: 'Once you have a certificate, browsers can authenticate the security of your
    site and exchange only encrypted data throughout a session. All widely used modern
    browsers come with public root certificates preinstalled, so they can authenticate
    connections with any site using a private Certificate Authority (CA) certificate.
    Here’s how it works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了证书，浏览器就可以验证你站点的安全性，并在整个会话中仅交换加密数据。所有广泛使用的现代浏览器都预装了公共根证书，因此它们可以使用私有证书颁发机构（CA）证书验证与任何站点的连接。以下是工作原理：
- en: A client browser requests the server identity so the two can perform a *handshake*.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端浏览器请求服务器身份，以便两者可以执行*握手*。
- en: The server responds by sending a copy of the certificate it received from a
    CA.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器通过发送从CA接收到的证书副本进行响应。
- en: The browser compares the certificate against its list of root certificates and
    confirms that your certificate hasn’t expired or been revoked.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器将证书与其根证书列表进行比较，并确认你的证书尚未过期或被撤销。
- en: If satisfied, the browser encrypts a symmetric session key using the public
    key your server sent, and transmits the key to the server.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果浏览器满意，它将使用服务器发送的公钥加密对称会话密钥，并将密钥传输到服务器。
- en: All transmissions will be encrypted using the session key.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有传输都将使用会话密钥进行加密。
- en: The process is illustrated in [figure 9.3](#ch09fig03).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程在[图9.3](#ch09fig03)中进行了说明。
- en: Figure 9.3\. The exchange of identifying data, certificates, and session keys
    for a TLS encrypted browser session
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3. TLS加密浏览器会话中标识数据、证书和会话密钥的交换
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig03_alt.jpg)'
- en: Until 2016, generating and then installing encryption certificates from trusted
    CAs using the SSL/TLS standard took time and cost money. On Linux, you would use
    the OpenSSL command-line interface tool to generate a key pair and then put together
    a specially formatted Certificate Signing Request (CSR) package containing the
    public half of the pair along with site profile information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2016年，使用SSL/TLS标准从受信任的CA生成和安装加密证书需要时间和金钱。在Linux上，你会使用OpenSSL命令行界面工具生成密钥对，然后组装一个包含对的一半以及站点配置信息的特殊格式证书签名请求（CSR）包。
- en: The CSR would then be sent to a CA. If the request was approved, the CA would
    send a certificate for you to install in your file system. You would also need
    to update web server configuration files (/etc/apache2/sites-available/default-ssl.conf,
    in the case of Apache on Ubuntu) so the software would know where in your file
    system the certificate was kept. That was then.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将CSR发送给CA。如果请求被批准，CA会发送一个证书供你在文件系统中安装。你还需要更新Web服务器配置文件（例如，在Ubuntu上的Apache，为/etc/apache2/sites-available/default-ssl.conf），以便软件知道证书存储在文件系统的哪个位置。那已经是过去了。
- en: Since 2016, Let’s Encrypt has been issuing certificates as a CA for free. Let’s
    Encrypt ([https://letsencrypt.org](https://letsencrypt.org)) is sponsored by the
    Electronic Frontier Foundation along with a large number of corporate partners
    including Cisco, Chrome, Shopify, and Digital Ocean. Its mandate is to promote
    website encryption by making it cheaper and, just as important, simpler.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自2016年以来，Let’s Encrypt作为一个免费CA一直在发放证书。Let’s Encrypt ([https://letsencrypt.org](https://letsencrypt.org))由电子前沿基金会赞助，同时还有包括思科、Chrome、Shopify和Digital
    Ocean在内的众多企业合作伙伴。其使命是通过降低成本和，同样重要的是，简化流程来推广网站加密。
- en: 'Forget about configuring files and using OpenSSL to generate CSRs: Let’s Encrypt’s
    Certbot ACME client will do pretty much the whole thing for you. Let’s Encrypt
    certificates are valid for 90 days and can be set to automatically renew.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记配置文件和使用OpenSSL生成CSRs吧：Let’s Encrypt的Certbot ACME客户端会为你完成大部分工作。Let’s Encrypt证书有效期为90天，并可以设置为自动续订。
- en: 9.3.1\. Preparing your website domain
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1. 准备你的网站域名
- en: Before you can install a certificate to encrypt your website domain, you’ll
    need to have a domain. That will involve purchasing a name from a domain registrar
    like GoDaddy or Amazon’s Route 53\. For more on how that works, you can read [chapter
    5](kindle_split_013.xhtml#ch05) in my book *Learn Amazon Web Services in a Month
    of Lunches* (Manning, 2017).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够安装证书以加密你的网站域名之前，你需要拥有一个域名。这涉及到从像GoDaddy或Amazon的Route 53这样的域名注册商那里购买一个名称。关于如何操作的更多信息，你可以阅读我书中关于“在一个月的午餐时间学习Amazon
    Web Services”的第5章（Manning，2017年）。
- en: As you’ll want Apache to handle domain-specific requests from external clients,
    you’ll also need to add a section to the /etc/apache2/sites-available/000-default.conf
    file (on a CentOS machine, it’s the settings in the /etc/httpd/conf/httpd.conf
    file that you’ll edit). Here’s how it might look on my bootstrap-it.com server.
    Note how, at this point, it’s only configured to accept traffic on the insecure
    HTTP port 80.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你希望Apache处理来自外部客户端的特定域名请求，你还需要在`/etc/apache2/sites-available/000-default.conf`文件中添加一个部分（在CentOS机器上，你将编辑`/etc/httpd/conf/httpd.conf`文件中的设置）。以下是我bootstrap-it.com服务器上的示例。注意，在这个阶段，它仅配置为接受不安全的HTTP端口80的流量。
- en: Listing 9.3\. Possible domain section from an Apache configuration file
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. 来自Apache配置文件的可能的域名部分
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* This configuration only listens for traffic on port 80.**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此配置只监听80端口的流量。**'
- en: '***2* Your domain name is used as the value for ServerName.**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你的域名用作ServerName的值。**'
- en: '***3* This ServerAlias line adds www as a valid domain prefix.**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这条ServerAlias行将www添加为有效的域名前缀。**'
- en: 9.3.2\. Generating certificates using Let’s Encrypt
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 使用Let’s Encrypt生成证书
- en: From this point, it’s quite simple. Browse to the Getting Started page of the
    Electronic Frontier Foundation Certbot website ([https://certbot.eff.org](https://certbot.eff.org))
    and, as you can see in [figure 9.4](#ch09fig04), specify the web server software
    and OS you’re using.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，操作非常简单。浏览到电子前沿基金会Certbot网站的“入门”页面（[https://certbot.eff.org](https://certbot.eff.org)），正如你在[图9.4](#ch09fig04)中看到的，指定你正在使用的Web服务器软件和操作系统。
- en: Figure 9.4\. Once you select your web server software and OS on the Certbot
    home page, you’ll be shown installation instructions.
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. 一旦你在Certbot主页上选择了你的Web服务器软件和操作系统，你将看到安装说明。
- en: '![](Images/09fig04_alt.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig04_alt.jpg)'
- en: 'From the Certbot home page, you’ll be redirected to a page with some brief
    instructions. For Apache on Ubuntu 16.04, which includes commands to install the
    software-properties-common repository management tool, add the Certbot repository
    to your APT list, and then install the Python-based Certbot software for Apache:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从Certbot主页，你将被重定向到一个包含一些简要说明的页面。对于Ubuntu 16.04上的Apache，它包括安装软件属性管理工具的命令，将Certbot存储库添加到你的APT列表中，然后安装Apache的基于Python的Certbot软件：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, you’ll launch the Certbot program as admin (using `--apache` as an
    argument, in my case). Certbot will read your web server config files to get a
    feel for the domains you’re likely to want to register:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将以管理员身份启动Certbot程序（在我的情况下，使用`--apache`作为参数）。Certbot将读取你的Web服务器配置文件，以了解你可能会想要注册的域名：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After answering a few questions about contact information and Let’s Encrypt’s
    terms of services, you’ll be presented with a list of possible domain names that
    might look like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答有关联系信息和Let’s Encrypt服务条款的一些问题后，你将看到一个可能看起来像这样的可能域名列表：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once you respond, the bot will try to confirm that your selected domains exist
    and are registered with a publicly accessible DNS server. The certificate server
    will finally try to connect to your site. If that’s successful, a Let’s Encrypt
    certificate will be automatically installed and any necessary additional sections
    will be added to your configuration files.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做出回应，机器人将尝试确认你选择的域名存在并且已注册在公开可访问的DNS服务器上。证书服务器最终将尝试连接到你的网站。如果成功，Let’s Encrypt证书将被自动安装，并在配置文件中添加任何必要的附加部分。
- en: 'If something goes wrong with the process, Certbot will display useful error
    messages that you can use to seed your research for a solution. Plus Let’s Encrypt
    hosts an active community help forum where users of all skill levels can safely
    plead for help: [https://community.letsencrypt.org](https://community.letsencrypt.org).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在过程中出现问题，Certbot将显示有用的错误信息，你可以使用这些信息来寻找解决方案。此外，Let’s Encrypt还提供了一个活跃的社区帮助论坛，所有技能水平的用户都可以在这里安全地寻求帮助：[https://community.letsencrypt.org](https://community.letsencrypt.org)。
- en: Up to now in this busy chapter you’ve learned how to enhance website security
    by keeping your applications patched and updated, use firewall rules to control
    access to your network, add security through obscurity to your mix, and encrypt
    data as it moves between your website and its visitors. We’re not done with security.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这章繁忙的内容中，你已经学会了如何通过保持应用程序修补和更新来增强网站安全性，使用防火墙规则来控制对网络的访问，将隐蔽性添加到你的组合中，以及加密在网站和访客之间传输的数据。我们的安全工作还没有结束。
- en: 'Still to come: toughening up your login protocols, using the SELinux kernel
    module and groups to more closely control the trouble your users can get themselves
    into, and keeping track of your running processes to make sure there’s nothing
    inappropriate going on in the background when no one’s looking.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来：加强登录协议，使用SELinux内核模块和组来更紧密地控制用户可能陷入的麻烦，以及跟踪你的运行进程以确保在没有人注意时后台没有发生不适当的事情。
- en: 9.4\. Hardening the authentication process
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 强化认证过程
- en: Using secure connectivity solutions, especially SSH, is great. But it’s also
    a good idea to give some attention to the way your team members use SSH. Here
    are a couple of suggestions for improving your remote-access security. It may
    not be practical to enforce them in every environment (particularly while you’re
    in the process of setting things up), but they should at least be familiar to
    you.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用安全的连接解决方案，特别是SSH，是很好的。但也要注意你的团队成员如何使用SSH。这里有一些建议来提高你的远程访问安全性。在每种环境中强制执行它们可能并不实用（尤其是在你设置事情的过程中），但至少你应该熟悉它们。
- en: 'Avoid logging in to servers as the root user. It’s always better to use `sudo`
    whenever admin privileges are necessary. In fact, you can prevent incoming root
    logins using SSH altogether by editing the `PermitRootLogin` line in the /etc/ssh/sshd_conf
    file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 避免以root用户登录服务器。在需要管理员权限时，始终使用`sudo`更好。实际上，你可以通过编辑`/etc/ssh/sshd_conf`文件中的`PermitRootLogin`行来完全防止root登录：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* The root-login-control line in /etc/ssh/sshd_conf**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* /etc/ssh/sshd_conf中的root登录控制行**'
- en: 'You can also encourage your admins to use only passwordless SSH access through
    key pairs (the way you saw back in [chapter 3](kindle_split_011.xhtml#ch03)).
    This, too, can be enforced from the sshd_conf file, this time on the `PasswordAuthentication`
    line. With no password authentication, users will be forced to use key pairs:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以鼓励你的管理员只通过密钥对（就像你在[第3章](kindle_split_011.xhtml#ch03)中看到的那样）使用无密码SSH访问。这也可以从`sshd_conf`文件中强制执行，这次是在`PasswordAuthentication`行上。没有密码认证，用户将被迫使用密钥对：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* The password-authentication control line in /etc/ssh/sshd_conf**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* /etc/ssh/sshd_conf中的密码认证控制行**'
- en: 'After each of those edits, make sure you reload SSH; otherwise, the new settings
    won’t take effect until the next boot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次编辑后，确保重新加载SSH；否则，新设置将不会在下次启动前生效：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Those are important steps in any environment. But if your deployment needs some
    industrial-strength isolation, consider enabling SELinux.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在任何环境中都非常重要的步骤。但如果你的部署需要一些工业级的隔离，考虑启用SELinux。
- en: 9.4.1\. Controlling file system objects with SELinux
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1. 使用SELinux控制文件系统对象
- en: Remember when we discussed object permissions back in [chapter 4](kindle_split_012.xhtml#ch04)?
    The context was the need to make sure users can access and edit their own files.
    But the flip side of that coin is ensuring that the wrong users can’t get their
    dirty fingers into other people’s files.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前在[第4章](kindle_split_012.xhtml#ch04)讨论对象权限吗？当时的背景是需要确保用户可以访问和编辑自己的文件。但硬币的另一面是确保错误用户无法染指他人的文件。
- en: You’ll recall that a common permissions profile for an object might give the
    owner full read-write-execute powers, but gives the object’s group and others
    only the permission to read. That would translate as 744 in our numeric notation,
    or `rwx r-- r--` otherwise.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，一个对象常见的权限配置可能给所有者提供完全的读写执行权限，但只给对象组和其他人读取权限。在我们的数字表示法中，这将是744，或者说是`rwx
    r-- r--`。
- en: 'Giving your users full power over their own resources is sometimes described
    as a *discretionary access control* (DAC) system. A DAC will make a lot of sense
    if you want your users to be productive, but it comes with a price: having full
    control carries the risk that they’ll apply it without being fully aware of the
    consequences.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的用户完全控制他们自己的资源的做法有时被称为*自主访问控制*（DAC）系统。如果你希望用户能够高效工作，DAC将非常有意义，但它也有代价：完全控制的风险是他们可能会在不完全了解后果的情况下使用它。
- en: 'Here’s a practical example of what I mean. Suppose a couple of the developers
    diligently slaving away for your company run into a problem: testing their software
    locally always fails when trying to write to a data file. Debugging reveals that
    it’s a permissions issue caused by the fact that the application is being run
    by one user, but the data file belongs to another.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个我所说的实际例子。假设有几位开发者辛勤地为你的公司工作，遇到了一个问题：在本地测试软件时，尝试写入数据文件总是失败。调试发现，这是由于应用程序由一个用户运行，但数据文件属于另一个用户导致的权限问题。
- en: 'Because this has happened more than once, and to more than one data file (or
    SSH key file for that matter), the developers take the quick and lazy route: they
    open up permissions on the data files and on all the files in those directories
    to 777—fully accessible to the entire world. Now that’s a significant security
    problem. There’s also an excellent chance that the application they’re working
    on will eventually be moved out to production with the same system settings. This
    is the kind of mistake that lies at the root of a lot of the major data breaches
    you hear about from time to time.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种情况已经发生不止一次，而且涉及多个数据文件（或者说是SSH密钥文件），开发者选择了快捷而懒惰的方法：他们打开了数据文件以及那些目录下所有文件的权限，设置为777——对整个世界完全开放。这确实是一个重大的安全问题。还有很大的可能性，他们正在开发的应用程序最终会以相同的系统设置移至生产环境。这种错误正是导致你时不时听到的一些重大数据泄露事件的原因。
- en: SELinux is another one of those complex topics that, although critically important
    for many Linux workloads, doesn’t have to play a major role in this book’s projects.
    Once again, feel free to skip right past it to our discussion of system groups
    if you like.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux是那些复杂主题之一，虽然对于许多Linux工作负载至关重要，但在这个书的工程项目中不必扮演主要角色。再次提醒，如果你喜欢，可以直接跳过它，进入系统组的讨论。
- en: When installed and activated, the SELinux kernel module applies *mandatory access
    control* (MAC) to file system objects, regardless of a particular object’s owner.
    In effect, as illustrated in [figure 9.5](#ch09fig05), it imposes carefully defined,
    system-wide limits on what a user can do, making it impossible to set inherently
    dangerous configurations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装并激活时，SELinux内核模块会对文件系统对象应用*强制访问控制*（MAC），无论特定对象的拥有者是谁。实际上，如图9.5所示，它对用户可以做什么设定了仔细定义的、系统范围内的限制，使得设置固有的危险配置变得不可能。
- en: Figure 9.5\. The process flow following a request for resource access through
    the filter of SELinux policies
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5。通过SELinux策略过滤器请求资源访问后的流程
- en: '![](Images/09fig05_alt.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig05_alt.jpg)'
- en: Had SELinux been active, those two developers could have applied 777 permissions
    to their data files over and over again until their poor little fingers fell off,
    but it wouldn’t have helped. Instead, they’d have been forced to look for a more
    appropriate and effective solution. They might, for instance, have considered
    creating a system group with authority over the data and then adding appropriate
    user accounts to the group. You’ll learn more about that a bit later in this chapter.
    Sounds great. What’s not to love about security?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SELinux是激活的，那两位开发者可能会不断地将777权限应用于他们的数据文件，直到他们的手指累得酸痛，但这并不能解决问题。相反，他们被迫寻找更合适和有效的解决方案。例如，他们可能会考虑创建一个拥有数据权限的系统组，然后将适当的用户账户添加到该组中。你将在本章稍后了解更多关于这方面的内容。听起来很棒。关于安全性，有什么不喜欢的呢？
- en: Well, there’s a problem. SELinux has a dark and scary relationship with application
    compatibility. So dark and so scary that many admins disable it rather than trying
    to make it work. The problem is that many applications, both off-the-shelf and
    custom apps you’re building locally, need to access and edit system resources.
    As a result, running such applications within an unmodified SELinux environment
    will often fail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这里有个问题。SELinux与应用兼容性有着黑暗而可怕的关系。如此黑暗和可怕，以至于许多管理员宁愿禁用它，也不愿尝试让它工作。问题是许多应用程序，无论是现成的还是本地构建的定制应用程序，都需要访问和编辑系统资源。因此，在未经修改的SELinux环境中运行此类应用程序通常会失败。
- en: I have it on good authority that there are solutions to all those conflicts
    and that they’re not impossible to apply. But just as often, the conflicts can
    be avoided altogether through a better understanding of file system design and
    security principles. In particular, you should remember *the principle of least
    privilege*, which seeks to permit all users and processes only the access they
    need and nothing more. In any case, you’ll need to know your way around SELinux,
    so the following sections introduce the basics.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我有可靠的消息说，所有这些冲突都有解决方案，并且它们并非不可能实施。但同样经常的是，通过更好地理解文件系统设计和安全原则，可以完全避免冲突。特别是，您应该记住*最小权限原则*，该原则旨在仅允许所有用户和进程访问他们需要的权限，而不需要更多。在任何情况下，您都需要了解SELinux，因此以下章节介绍了基础知识。
- en: 9.4.2\. Installing and activating SELinux
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2\. 安装和激活SELinux
- en: 'Perhaps because SELinux was developed by and for Red Hat Linux (and CentOS),
    it comes installed and active by default on those systems. Running it on other
    distros, including Ubuntu, is definitely possible (although AppArmor is a more
    common choice for Ubuntu), but I can’t guarantee that it will always go smoothly.
    (Don’t even think about trying it on an LXC container; go with VirtualBox for
    testing, instead.) On Ubuntu, you’ll need three packages: selinux, setools, and
    policycoreutils. Here’s how that would look:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是因为SELinux是由Red Hat Linux（和CentOS）开发和为它们设计的，所以默认情况下，这些系统上已经安装并激活了SELinux。在其他发行版上运行它，包括Ubuntu，绝对可能（尽管AppArmor在Ubuntu上是一个更常见的选择），但我不能保证它总是能顺利运行。（甚至不要考虑在LXC容器上尝试；相反，使用VirtualBox进行测试。）在Ubuntu上，您需要三个软件包：selinux、setools和policycoreutils。以下是它的样子：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once they’re nicely tucked in, reboot Ubuntu, and run `sestatus` for a snapshot
    of the current SELinux status, including important file system locations and policy.
    With luck, you should see something like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦妥善设置，重启Ubuntu，并运行`sestatus`以获取当前SELinux状态的快照，包括重要的文件系统位置和政策。如果有幸，您应该看到类似以下内容：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* The current SELinux status is enabled.**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当前SELinux状态是启用的。**'
- en: '***2* The default policy being used is targeted.**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 正在使用的默认策略是目标型。**'
- en: 'You might sometimes have to run the `selinux-activate` command to incorporate
    SELinux settings into the boot process:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您有时可能需要运行`selinux-activate`命令，以便将SELinux设置纳入启动过程：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* True to its name, selinux-activate sets SELinux as active following the
    next boot.**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如其名所示，selinux-activate在下次启动后会将SELinux设置为活动状态。**'
- en: '***2* SELinux-friendly flags are added to the launch command for each image
    controlled by GRUB.**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为GRUB控制的每个映像的启动命令添加了SELinux友好标志。**'
- en: '***3* Because SELinux relies on kernel-level settings, changes often require
    a reboot.**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 因为SELinux依赖于内核级设置，更改通常需要重启。**'
- en: Like the man says, you may need to reboot for the changes to take effect.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那个人说的，你可能需要重启才能使更改生效。
- en: You can control SELinux behavior through the configuration file in /etc/selinux/.
    The file contains two settings, SELinux state and SELinux type. [Table 9.1](#ch09table01)
    gives a brief overview of the possible values.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过位于/etc/selinux/的配置文件来控制SELinux的行为。该文件包含两个设置，SELinux状态和SELinux类型。[表9.1](#ch09table01)提供了可能值的简要概述。
- en: Table 9.1\. The configuration settings for SELinux in /etc/selinux/config
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.1\. /etc/selinux/config中SELinux的配置设置
- en: '| Category | Value | Description | Use |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 值 | 描述 | 使用 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| State | disabled | SELinux is off. |   |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | disabled | SELinux已关闭。 |   |'
- en: '|   | enforcing | Security policy is enforced. |   |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|   | enforcing | 安全策略正在执行。 |   |'
- en: '|   | permissive | Policy breaches trigger only logged warnings. | Useful for
    testing configurations |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|   | permissive | 策略违规只会触发记录警告。 | 适用于测试配置 |'
- en: '| Policy type | targeted | Enables a domain whose processes are “unconfined”
    by SELinux restrictions. | Useful for mixed-use systems where not all processes
    require restrictions |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 策略类型 | targeted | 启用了一个由SELinux限制“不受限制”的域的进程。 | 适用于不是所有进程都需要限制的混合使用系统 |'
- en: '|   | minimum | Only minimal processes are restricted by SELinux. | Can allow
    finer tuning for experimental systems |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|   | minimum | 只有最小进程受到SELinux的限制。 | 可以允许对实验系统进行更精细的调整 |'
- en: '|   | mls | Policies are applied based on sensitivity level and capability.
    |   |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|   | mls | 根据敏感级别和能力应用策略。 |   |'
- en: 'Besides the config file, you can also set the SELinux state from the command
    line using `setenforce`, where `setenforce 1` enables the enforcing state, and
    `setenforce 0` sets SELinux to the permissive state. When in a permissive state,
    rule violations are permitted but logged. This is a good way to troubleshoot or
    test a configuration without turning everything upside down in the process:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置文件外，您还可以使用 `setenforce` 命令从命令行设置 SELinux 状态，其中 `setenforce 1` 启用强制状态，而 `setenforce
    0` 将 SELinux 设置为宽容状态。在宽容状态下，规则违规是被允许的，但会被记录下来。这是一种在不完全打乱过程中调试或测试配置的好方法：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How about an SELinux example to illustrate how you can control access to an
    individual file? Consider it done. You should definitely try the example in the
    next section (or something like it) yourself.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 SELinux 示例，说明您如何控制对单个文件的访问？任务完成。您绝对应该尝试下一节中的示例（或类似的内容）。
- en: 9.4.3\. Applying SELinux policies
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3\. 应用 SELinux 策略
- en: Say that you’re the sysadmin responsible for those two developers with the lazy
    streak you met earlier. Based on past experience, you suspect that they might
    be tempted to open access to a data file a bit too widely. Here’s how you might
    protect your data no matter what the developers try.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是负责那些之前遇到的两个懒惰开发者的系统管理员。根据以往的经验，你怀疑他们可能会被诱惑过于广泛地开放对数据文件的访问。以下是无论开发者尝试什么，你都可以如何保护你的数据的方法。
- en: 'You can use SELinux to control the way any file or process is consumed, but
    to keep this example simple, let’s work with a machine with Apache (or httpd)
    installed and an index.html file in the document root at /var/www/html/. The file
    will, by default, be accessible at least to local requests (via `wget localhost`
    from the command line of the server). Here’s how that will normally look:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 SELinux 来控制任何文件或进程的访问方式，但为了使这个例子简单，让我们以安装了 Apache（或 httpd）并包含在文档根目录 /var/www/html/
    中的 index.html 文件的服务器为例。默认情况下，该文件至少对本地请求（通过从服务器命令行运行 `wget localhost`）是可访问的。以下是它通常看起来是怎样的：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* wget successfully saved the index.html file to the local directory.**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* wget 成功将 index.html 文件保存到本地目录。**'
- en: 'Now, check out the permissions status of the index.html file using `ls -Z`
    (`-Z` will display the file’s security context):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `ls -Z`（`-Z` 将显示文件的安全上下文）检查 index.html 文件的权限状态：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, note the regular permissions (`-rw-r--r--`) that make the file readable
    (`r`) by anyone. This is standard for website resources. The SELinux status of
    the file is displayed as `unconfined_u:object_r:httpd_sys_content_t:s0`. You can
    use `chcon -t` to change the context type of a file. This command replaces the
    Apache `httpd_sys_content_t` type with the Samba-related `samba_share_t` type.
    I’m not sure you’d ever want to do this in real life, but it should nicely demonstrate
    one way you can balance the authority you give your users against their potential
    to mess things up:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意使文件可读（`r`）的常规权限（`-rw-r--r--`）。这对于网站资源来说是标准的。文件的 SELinux 状态显示为 `unconfined_u:object_r:httpd_sys_content_t:s0`。您可以使用
    `chcon -t` 来更改文件上下文类型。此命令将 Apache 的 `httpd_sys_content_t` 类型替换为与 Samba 相关的 `samba_share_t`
    类型。我不确定你真的想在现实生活中这样做，但这应该很好地演示了您可以如何平衡您授予用户的权限与他们的潜在破坏能力：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A second shot of `ls -Z` shows that the file is now associated with the `samba_share_t`
    type:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次运行 `ls -Z` 显示文件现在与 `samba_share_t` 类型相关联：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How will another round of `wget localhost` handle the new SELinux context?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次运行 `wget localhost` 将如何处理新的 SELinux 上下文？
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Apache responds to the request with a 403: Forbidden fail message.**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Apache 以 403：禁止访问的失败消息响应请求。**'
- en: It’s no go. Apache is forced to disappoint you (or, rather, the developers),
    as Apache itself has no power over the file in its current context. This is true
    despite the fact that the file attributes include read permissions for all users.
    No matter how desperately your developers might want to open access to a protected
    file, they’ll be spinning their wheels and getting nowhere.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不行的。Apache 被迫让你（或者更确切地说，开发者）失望，因为在这个上下文中，Apache 本身对文件没有控制权。尽管文件属性包括所有用户的读取权限，但这仍然是正确的。无论你的开发者多么渴望打开对受保护文件的访问，他们都会徒劳无功。
- en: 9.4.4\. System groups and the principle of least privilege
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.4\. 系统组和最小权限原则
- en: 'Those two developers finally got the message. They understand that they’ve
    been blocked from opening access too widely. But now they’re asking you to help
    them solve the original problem: how to make files containing sensitive data accessible
    to multiple accounts without opening those up to everyone.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 那两个开发者终于明白了。他们明白自己被阻止了，不能过于广泛地开放访问权限。但现在他们正在请求你的帮助来解决原始问题：如何在不对所有人开放的情况下，使包含敏感数据的文件可供多个账户访问。
- en: The short answer is groups. (And the long answer is g—r—o—u—p—s.) A *group*
    is a system object much the same as a user, except that no one will ever log in
    to the system as a group. The power of groups is in how they, like users, can
    be assigned to files or directories, allowing any group members to share the group
    powers. This is illustrated in [figure 9.6](#ch09fig06).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是组。（而长一点的回答是 g—r—o—u—p—s。）一个 *组* 是一个系统对象，与用户非常相似，只是没有人会以组的形式登录到系统中。组的强大之处在于，它们像用户一样可以被分配给文件或目录，允许任何组成员共享组权限。这可以在[图9.6](#ch09fig06)中看到。
- en: Figure 9.6\. Developers who are members of the Developers group can be given
    access to a particular directory, as opposed to those individuals who aren’t part
    of the group.
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6\. 开发者组成员可以访问特定的目录，而那些不是组成员的个人则不行。
- en: '![](Images/09fig06.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig06.jpg)'
- en: 'Try this yourself: use nano to create a new file. Add some Hello World text
    so you’ll be able to easily tell when you can successfully access it. Now edit
    its permissions using `chmod 770` so that the file’s owner and group have full
    rights over the file, but others can’t read it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己操作：使用nano创建一个新文件。添加一些Hello World文本，这样你就可以轻松地判断你是否能够成功访问它。现在使用`chmod 770`编辑其权限，这样文件的所有者和组对文件拥有完全权限，但其他人不能读取它：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If your system doesn’t already have an extra user besides your account, create
    one using either `adduser` (the Debian/Ubuntu way) or `useradd` (if you’re on
    CentOS). Note that `useradd` will also work on Ubuntu:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统除了你的账户外还没有其他额外用户，你可以使用`adduser`（Debian/Ubuntu的方式）或`useradd`（如果你在CentOS上）来创建一个。请注意，`useradd`在Ubuntu上也可以使用：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* The useradd command (as opposed to the Debian adduser command) requires
    you to generate a user password separately.**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用户添加命令（与Debian的adduser命令相反）要求你单独生成用户密码。**'
- en: 'Use `su` to switch to your new user. Once you enter the user’s password, all
    the commands you execute will be run as that user. You’ll be working with only
    that user’s authority: no more and no less. If you try reading the datafile.txt
    file (using `cat`), you’ll have no luck because, as you remember, others were
    denied read permission. When you’re done, type `exit` to leave the new user shell
    and return to your original shell:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`su`切换到你的新用户。一旦你输入了用户的密码，你执行的所有命令都将以该用户身份运行。你将只使用该用户的权限：不多也不少。如果你尝试读取datafile.txt文件（使用`cat`），你将不会成功，因为你记得，其他人被拒绝读取权限。完成操作后，输入`exit`离开新用户shell并返回到原始shell：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All this is expected and easy to understand. And, as you’ve seen, not being
    able to read the file belonging to a different reader can sometimes be a problem.
    Let’s see what you can do about that by associating the file with a group and
    then properly configuring the file’s permissions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是预期之中且容易理解的。而且，正如你所看到的，无法读取属于不同读者的文件有时可能是一个问题。让我们看看通过将文件与组关联并正确配置文件权限，你能做些什么。
- en: 'Create a new group you can use to manage your application data, and then edit
    the properties of your data file using `chown`. The `ubuntu:app-data-group` argument
    leaves the file ownership in the hands of the ubuntu user, but changes its group
    to your new app-data-group:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个你可以用来管理你的应用程序数据的新组，然后使用`chown`编辑你的数据文件属性。`ubuntu:app-data-group`参数将文件所有权留给了ubuntu用户，但将其组更改为你的新app-data-group：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run `ls` with long output (`-l`) against the file to view its new permissions
    and status. Note that, as expected, ubuntu is the file’s owner and app-data-group
    is its group:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有长输出（`-l`）的`ls`命令针对文件查看其新的权限和状态。请注意，正如预期的那样，ubuntu是文件的所有者，app-data-group是其所属组：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can use `usermod` to add your user to app-data-group and then, once again,
    `su` to switch to a shell deploying the other user’s account. This time, even
    though the file’s permissions lock others out, and you’re definitely acting as
    an “other” right now, you should be able to read it...thanks to your group membership:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`usermod`将你的用户添加到app-data-group，然后再次使用`su`切换到另一个用户的shell。这次，尽管文件的权限阻止了其他人，而且你现在确实是以“其他”的身份行事，但你应该能够读取它...多亏了你的组成员资格：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Use the su command to switch between user accounts.**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用su命令在用户账户之间切换。**'
- en: '***2* This happened to be the contents of my datafile.txt file.**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这正是我的datafile.txt文件的内容。**'
- en: 'This kind of organization is the correct and effective way to deal with many
    of the complicated permissions issues that will arise on a multiuser system. In
    fact, not only is it used to give individual users the access they need, but many
    system processes couldn’t do their jobs without special group memberships. Take
    a quick look through the /etc/group file and note how many system processes have
    their own groups:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织方式是正确且有效处理多用户系统上出现的许多复杂权限问题的方法。实际上，它不仅用于给个别用户提供他们需要的访问权限，而且许多系统进程没有特殊的组成员资格就无法完成工作。快速浏览一下`/etc/group`文件，注意有多少系统进程有自己的组：
- en: Listing 9.4\. Partial listing of the contents of the /etc/group file
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. `/etc/group`文件内容的部分列表
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I’ll close out the chapter with a few quick but vital protocols you can incorporate
    into your security practices.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以几个快速但至关重要的协议结束本章，您可以将这些协议融入您的安全实践中。
- en: 9.4.5\. Isolating processes within containers
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.5\. 在容器内隔离进程
- en: Worried that the multiple services you’ve got running on a single server will,
    should one service be breached, all be at risk? One way to limit the damage that
    careless or malicious users can cause is by isolating system resources and processes.
    That way, even if someone might want to expand their reach beyond a set limit,
    they won’t have physical access.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 担心您在单个服务器上运行的多个服务，如果其中一个服务被入侵，所有服务都会处于风险之中？限制粗心或恶意用户可能造成的损害的一种方法是通过隔离系统资源和进程。这样，即使有人可能想要超出设定的限制范围，他们也不会有物理访问权限。
- en: The old approach to the problem was provisioning a separate physical machine
    for each service. But virtualization can make it a lot easier, and more affordable,
    to build a *siloed* infrastructure. This architecture is often referred to as
    *microservices* and would have you launch multiple containers with one, perhaps,
    running only a database, another Apache, and a third containing media files that
    might be embedded in your web pages. In addition to the many performance and efficiency
    benefits associated with microservices architectures, this can greatly reduce
    each individual component’s risk exposure.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以前处理这个问题的方法是为每个服务分配一个单独的物理机器。但虚拟化可以使构建**隔离**的基础设施变得更加容易和更经济。这种架构通常被称为**微服务**，您将启动多个容器，其中可能只有一个运行数据库，另一个运行Apache，第三个包含可能嵌入到您的网页中的媒体文件。除了与微服务架构相关的许多性能和效率优势外，这还可以大大降低每个单独组件的风险暴露。
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: By *containers* I don’t necessarily mean those of the LXC persuasion. These
    days, for this kind of deployment, Docker containers are far more popular. If
    you’re interested in learning more, check out Manning’s *Microservices in Action*
    (Morgan Bruce and Paulo A. Pereira, 2018), *Microservice Patterns* (Chris Richardson,
    2018), or *Docker in Practice, 2nd ed.* (Ian Miell and Aidan Hobson Sayers, 2018).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我提到**容器**时，并不一定是指LXC类型的容器。如今，对于这种部署，Docker容器要更为流行。如果您想了解更多信息，可以查看Manning出版的《*Microservices
    in Action*》（Morgan Bruce 和 Paulo A. Pereira，2018年），《*Microservice Patterns*》（Chris
    Richardson，2018年），或者《*Docker in Practice, 2nd ed.*》（Ian Miell 和 Aidan Hobson Sayers，2018年）。
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.4.6\. Scanning for dangerous user ID values
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.6\. 检查危险的用户ID值
- en: While any admin user will be able to temporarily assume root authority using
    `sudo`, only *root* is actually root. As you’ve seen already, it isn’t safe to
    perform regular functions as root. But it can happen, whether by innocent accident
    or malicious tampering, and a regular user can effectively get admin rights full-time.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何管理员用户都可以使用`sudo`临时假定root权限，但只有**root**才是真正的root。如您所见，以root身份执行常规操作并不安全。但这种情况可能发生，无论是由于无辜的意外还是恶意的篡改，普通用户可以有效地获得全职的管理权限。
- en: 'The good news is that it’s easy to spot imposters: their user and/or group
    ID numbers will, like root, be zero (0). Take a look at the passwd file in /etc/.
    This file contains a record for each regular and system user account that currently
    exists. The first field contains the account name (root and ubuntu, in this case),
    and the second field might contain an *x* in place of a password (which, if it
    exists, will appear encrypted in the /etc/shadow file). But the next two fields
    contain the user and group IDs. In the case of ubuntu in this example, both IDs
    are 1000\. And, as you can see, root has zeroes:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，很容易发现冒名顶替者：它们的用户和/或组ID号，就像root一样，将是零（0）。看看`/etc/`中的passwd文件。此文件包含每个当前存在的普通和系统用户账户的记录。第一个字段包含账户名称（在这个例子中是root和ubuntu），第二个字段可能包含一个*x*代替密码（如果存在，它将在`/etc/shadow`文件中加密显示）。但接下来的两个字段包含用户和组ID。在这个例子中，ubuntu的这两个ID都是1000。而且，正如你所看到的，root是零：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you ever see a regular user with a user or group ID of 0, then you know
    there’s something nasty going on, and you should get to work fixing it. The quick
    and easy way to spot a problem is to run this `awk` command against the passwd
    file, which prints any line whose third field contains only a 0\. In this case,
    to my great relief, the only result was root. You can run it a second time substituting
    `$4` for `$3` to pick up the group ID field:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到任何普通用户具有用户或组ID为0，那么你就知道有些事情很糟糕，你应该开始修复它。快速简单地发现问题的方式是运行这个`awk`命令针对passwd文件，它打印出任何第三个字段只包含0的行。在这种情况下，让我非常欣慰的是，唯一的结果是root。你可以再次运行它，用`$4`替换`$3`以获取组ID字段：
- en: '[PRE49]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* The awk command is discussed in greater detail in [chapter 11](kindle_split_019.xhtml#ch11).**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* awk命令将在第11章中更详细地讨论。**'
- en: 9.5\. Auditing system resources
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5. 审计系统资源
- en: The more things you’ve got running, the greater the odds of something breaking,
    so it makes sense that you’ll want to keep track of what’s running. This applies
    to network ports (if they’re open, then by definition, there must be a way in),
    services (if they’re active, then people can run them), and installed software
    (if it’s installed, it can be executed).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你运行的东西越多，出现问题的可能性就越大，所以你想要跟踪正在运行的内容是有道理的。这适用于网络端口（如果它们是开放的，那么根据定义，必须有进入的方法），服务（如果它们是活跃的，那么人们可以运行它们），以及安装的软件（如果它已安装，则可以执行）。
- en: For audits to be useful, you’ll have to remember to run them once in a while.
    Because you know you’re going to forget, you’ll be much better off incorporating
    your auditing tools into a script that not only executes regularly but, ideally,
    also parses the results to make them more readable. In this section, I’ll focus
    on introducing you to three key audit tools to help you scan for open ports, active
    services, and unnecessary software packages. Getting it all implemented will be
    your job.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使审计有用，你必须记得偶尔运行它们。因为你知道你会忘记，所以将你的审计工具集成到一个脚本中会更好，这个脚本不仅定期执行，而且理想情况下还会解析结果以使其更易于阅读。在本节中，我将重点介绍三个关键的审计工具，以帮助您扫描开放端口、活跃服务和不必要的软件包。实现这一切将是你的工作。
- en: 9.5.1\. Scanning for open ports
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.1. 扫描开放端口
- en: A port is considered *open* if there’s some process running on the host that’s
    listening on that port for requests. Keeping an eye on your open ports can keep
    you plugged into what’s going on with your server.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机上有一个进程正在监听该端口的请求，则该端口被认为是*开放的*。关注你的开放端口可以帮助你了解服务器上正在发生的事情。
- en: You already know that a regular web server is probably going to have HTTP (80)
    and SSH (22) ports open, so it shouldn’t come as a surprise to find those. But
    you’ll want to focus on other, unexpected results. The `netstat` command displays
    open ports along with a wealth of information about how those ports are being
    used.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道，一个普通的Web服务器可能会有HTTP（80）和SSH（22）端口开放，所以发现这些端口并不令人惊讶。但你需要关注其他意外结果。`netstat`命令显示了开放端口以及有关这些端口如何使用的丰富信息。
- en: 'In this example, run against a fairly typical multipurpose server, `-n` tells
    `netstat` to include the numeric ports and addresses, `-l` includes only listening
    sockets, and `-p` adds the process ID of the listening program. Naturally, if
    you see something, do something:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，针对一个相当典型的多功能服务器，`-n`告诉`netstat`包括数字端口和地址，`-l`仅包括监听套接字，而`-p`添加监听程序的进程ID。自然地，如果你看到什么，就要采取行动：
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* The MySQL process is running on port 3306.**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* MySQL进程正在3306端口上运行。**'
- en: '***2* The SSH process has a process ID of 333.**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* SSH进程的进程ID为333。**'
- en: 'In recent years, `ss` has begun to replace `netstat` for many uses. In case
    you find yourself at a party one day and someone asks you about `ss`, this example
    (which lists all established SSH connections) should give you enough information
    to save you from truly deep embarrassment:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，`ss`已经开始取代`netstat`用于许多用途。如果您有一天在聚会上有人问您关于`ss`的问题，这个例子（列出所有建立的SSH连接）应该会为您提供足够的信息，让您免受真正的尴尬：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Displays all TCP sockets**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示所有TCP套接字**'
- en: 9.5.2\. Scanning for active services
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.2\. 扫描活动服务
- en: 'Getting a quick snapshot of the systemd-managed services currently enabled
    on your machine can also help you spot activity that doesn’t belong. `systemctl`
    can list all existing services, which can then be narrowed down to only those
    results whose descriptions include `enabled`. This code returns only active services:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看当前系统上启用的systemd管理的服务也可以帮助您发现不属于那里的活动。`systemctl`可以列出所有现有服务，然后可以缩小到仅包含`enabled`描述的结果。以下代码仅返回活动服务：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* sshd is the SSH server; ssh is the client software.**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* sshd是SSH服务器；ssh是客户端软件。**'
- en: 'If you do find something that shouldn’t be there, you can use `systemctl` to
    both stop the service and make sure it doesn’t start up again with the next boot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实发现了一些不应该存在的东西，您可以使用`systemctl`来停止服务并确保它不会在下次启动时启动：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There’s actually nothing dark and sinister about the haveged service I’m stopping
    in this example. It’s a small tool I often install to generate random background
    system activity when I’m creating encryption keys.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我在这个例子中停止的haveged服务并没有什么黑暗和邪恶。这是一个我经常安装的小工具，用于在创建加密密钥时生成随机的后台系统活动。
- en: 9.5.3\. Searching for installed software
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.3\. 搜索已安装的软件
- en: 'Could someone or something have installed software on your system without you
    knowing? Well, how would you know if you don’t look? To get the whole briefing,
    use `yum list installed` or, on Debian/Ubuntu, `dpkg --list`. To delete any packages
    that don’t belong, use `remove <packagename>`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有人或某物在您不知情的情况下安装了软件？好吧，如果您不查看，您怎么知道？要获取完整简报，请使用`yum list installed`或Debian/Ubuntu上的`dpkg
    --list`。要删除任何不属于的包，请使用`remove <packagename>`：
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here’s how it goes on Ubuntu:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在Ubuntu上操作的：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Outputs a long list of packages that you’ll have to visually scan as
    quickly as you can. I’m not aware of any shortcuts.**'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 输出长长的包列表，您需要尽可能快地视觉扫描。我不了解任何快捷方式。**'
- en: It’s also a good idea to be aware of changes to your system configuration files.
    That’s something you’ll learn about in [chapter 11](kindle_split_019.xhtml#ch11).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 也要注意您的系统配置文件的变化。这是您将在第11章中学到的东西。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Using firewalls, you control network traffic by protocol, port, and source or
    destination.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用防火墙，您可以通过协议、端口、源或目的地来控制网络流量。
- en: Configure applications to listen in on nonstandard network ports to add *security
    through obscurity* to your infrastructure.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应用程序监听非标准网络端口，以向您的基础设施添加*隐蔽性安全*。
- en: Using certificates received from a CA, client-host browser sessions are encrypted,
    greatly reducing the chances of the transferred data being compromised.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从CA接收到的证书，客户端主机浏览器会话被加密，大大减少了传输数据被泄露的风险。
- en: Global controls are enforced on a multiuser file system using SELinux.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多用户文件系统中使用SELinux强制执行全局控制。
- en: Access to resources is closely managed using groups to allow users and processes
    exactly the access they need.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组来严格控制对资源的访问，以允许用户和进程获得他们需要的精确访问权限。
- en: Regular (scripted) audits of running processes, installed software, and open
    ports are critical to ongoing server security.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期（脚本）审计运行进程、已安装软件和开放端口对于持续的服务器安全至关重要。
- en: Key terms
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键术语
- en: You can administer firewall rules on Linux using *iptables* or simpler, high-level
    tools.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用*iptables*或更简单的高级工具在Linux上管理防火墙规则。
- en: The *Hypertext Transfer Protocol* (HTTP) manages browser-based data transfers
    over a network.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（HTTP）管理通过网络进行的基于浏览器的数据传输。'
- en: The *Transport Layer Security* (TLS) protocol enforces data encryption for host-client
    network data transfers.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层安全性**（TLS）协议强制执行主机-客户端网络数据传输的数据加密。'
- en: '*Discretionary access control systems* (DACs) allow users control over file
    system resources.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主访问控制系统**（DACs）允许用户控制文件系统资源。'
- en: Control over resources on *mandatory access control systems* (MACs) is ultimately
    managed by system-wide policies.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*强制访问控制系统*（MACs）上的资源控制最终由系统级策略管理。
- en: '*Microservices* are individual computer services run from individual containers
    as part of a larger single application infrastructure spanning multiple containers.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*微服务* 是作为跨越多个容器的单个大型应用程序基础设施的一部分，从单个容器中运行的独立计算机服务。'
- en: Command-line review
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行审查
- en: '`firewall-cmd --permanent --add-port=80/tcp` opens port 80 to incoming HTTP
    traffic and configures it to reload at boot time.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewall-cmd --permanent --add-port=80/tcp` 打开80端口以允许传入HTTP流量，并配置它在启动时重新加载。'
- en: '`firewall-cmd --list-services` lists the currently active rules on a firewalld
    system.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewall-cmd --list-services` 列出firewalld系统上的当前活动规则。'
- en: '`ufw allow ssh` opens port 22 for SSH traffic using UncomplicatedFirewall (ufw)
    on Ubuntu.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ufw allow ssh` 使用Ubuntu上的UncomplicatedFirewall (ufw) 打开22端口以允许SSH流量。'
- en: '`ufw delete 2` removes the second ufw rule as listed by the `ufw status` command.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ufw delete 2` 根据由 `ufw status` 命令列出的第二个 ufw 规则来删除。'
- en: '`ssh -p53987 username@remote_IP_or_domain` logs in to an SSH session using
    a non-default port.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh -p53987 username@remote_IP_or_domain` 使用非默认端口登录SSH会话。'
- en: '`certbot --apache` configures an Apache web server to use Let’s Encrypt encryption
    certificates.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`certbot --apache` 配置Apache Web服务器使用Let’s Encrypt加密证书。'
- en: '`selinux-activate` activates SELinux on an Ubuntu machine.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selinux-activate` 在Ubuntu机器上激活SELinux。'
- en: '`setenforce 1` toggles enforcing mode in an SELinux configuration.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setenforce 1` 在SELinux配置中切换强制模式。'
- en: '`ls -Z /var/www/html/` displays the security context of the files in a specified
    directory.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -Z /var/www/html/` 显示指定目录中文件的网络安全上下文。'
- en: '`usermod -aG app-data-group otheruser` adds the otheruser user to the app-data-group
    system group.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermod -aG app-data-group otheruser` 将otheruser用户添加到app-data-group系统组。'
- en: '`netstat -npl` scans for open (listening) network ports on a server.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netstat -npl` 在服务器上扫描打开（监听）的网络端口。'
- en: Test yourself
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自己
- en: '**[1](#ch09qa2q0a1)**'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch09qa2q0a1)**'
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You’re concerned that hackers might have gained access to your server, and you
    want to make sure they aren’t able to escalate their permissions to root powers.
    Which of the following commands might help?
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你担心黑客可能已经访问了你的服务器，并想确保他们无法将权限提升到root权限。以下哪个命令可能有所帮助？
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`firewall-cmd --list-services`'
  id: totrans-342
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`firewall-cmd --list-services`'
- en: '`netstat -npl`'
  id: totrans-343
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`netstat -npl`'
- en: '`certbot --apache`'
  id: totrans-344
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`certbot --apache`'
- en: '`awk -F: ''($3 == "0") {print}'' /etc/passwd`'
  id: totrans-345
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`awk -F: ''($3 == "0") {print}'' /etc/passwd`'
- en: '**[2](#ch09qa2q0a2)**'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch09qa2q0a2)**'
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You noticed that there are network ports open on your server that you can’t
    explain. Which of the following tools can be used to close them?
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你注意到你的服务器上有一些你无法解释的网络端口是开放的。以下哪个工具可以用来关闭它们？
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: firewalld
  id: totrans-350
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: firewalld
- en: netstat
  id: totrans-351
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: netstat
- en: certbot --apache
  id: totrans-352
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: certbot --apache
- en: awk
  id: totrans-353
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: awk
- en: '**[3](#ch09qa2q0a3)**'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch09qa2q0a3)**'
- en: ''
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What security advantage can there be in splitting a single application’s services
    among multiple containers?
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在多个容器中分割单个应用程序的服务有什么安全优势？
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A failure in one won’t necessarily affect the performance of the others.
  id: totrans-358
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个失败不会必然影响其他人的性能。
- en: A vulnerability in one won’t necessarily spread to the others.
  id: totrans-359
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个漏洞不会必然传播到其他。
- en: Such a design pushes authentication further away from the servers.
  id: totrans-360
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种设计将身份验证进一步推离服务器。
- en: Such a design increases process visibility.
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种设计增加了进程可见性。
- en: '**[4](#ch09qa2q0a4)**'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch09qa2q0a4)**'
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following commands will allow SSH access to a server from only
    a single IP address?
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令将允许从单个IP地址访问服务器的SSH？
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`firewall-cmd allow from 10.0.3.1 to any port 22`'
  id: totrans-366
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`firewall-cmd allow from 10.0.3.1 to any port 22`'
- en: '`ufw allow from 10.0.3.1 to port 22`'
  id: totrans-367
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ufw allow from 10.0.3.1 to port 22`'
- en: '`ufw allow from 10.0.3.1 to any port 22`'
  id: totrans-368
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ufw allow from 10.0.3.1 to any port 22`'
- en: '`firewall-cmd --allow from 10.0.3.1 to any port 22`'
  id: totrans-369
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`firewall-cmd --allow from 10.0.3.1 to any port 22`'
- en: '**[5](#ch09qa2q0a5)**'
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch09qa2q0a5)**'
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Requesting a TLS certificate from a CA allows you to
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从CA请求TLS证书允许你
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prevent unauthorized users from accessing your web server’s backend
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止未经授权的用户访问你的Web服务器后端
- en: Secure data at rest on a web server
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web服务器上确保静态数据的安全
- en: Secure data in transit between a web server and clients
  id: totrans-376
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web服务器和客户端之间传输数据时确保数据安全
- en: Permit passwordless SSH access to your web server’s backend
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许无密码SSH访问你的Web服务器后端
- en: '**[6](#ch09qa2q0a6)**'
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6](#ch09qa2q0a6)**'
- en: ''
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following settings in the /etc/ssh/sshd_conf file will force SSH
    clients to use key pairs?
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个/etc/ssh/sshd_conf文件中的设置将强制SSH客户端使用密钥对？
- en: ''
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PermitRootLogin no
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: PermitRootLogin no
- en: PermitRootLogin yes
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: PermitRootLogin yes
- en: '#PasswordAuthentication no'
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#PasswordAuthentication no'
- en: PasswordAuthentication no
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: PasswordAuthentication no
- en: '**[7](#ch09qa2q0a7)**'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7](#ch09qa2q0a7)**'
- en: ''
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following commands will set SELinux to permissive mode?
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令将设置SELinux为宽容模式？
- en: ''
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`setenforce 0`'
  id: totrans-390
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setenforce 0`'
- en: '`chcon -t samba_share_t /var/www/html/index.html`'
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chcon -t samba_share_t /var/www/html/index.html`'
- en: '`setenforce 1`'
  id: totrans-392
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setenforce 1`'
- en: '`selinux-activate`'
  id: totrans-393
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`selinux-activate`'
- en: '**[8](#ch09qa2q0a8)**'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8](#ch09qa2q0a8)**'
- en: ''
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following commands will make the app-data-group the group of the
    datafile.txt file?
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令将使app-data-group成为datafile.txt文件的组？
- en: ''
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`chown app-data-group,ubuntu datafile.txt`'
  id: totrans-398
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chown app-data-group,ubuntu datafile.txt`'
- en: '`chown app-data-group datafile.txt`'
  id: totrans-399
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chown app-data-group datafile.txt`'
- en: '`chown app-data-group:ubuntu datafile.txt`'
  id: totrans-400
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chown app-data-group:ubuntu datafile.txt`'
- en: '`chown ubuntu:app-data-group datafile.txt`'
  id: totrans-401
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chown ubuntu:app-data-group datafile.txt`'
- en: Answer key
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 答案键
- en: '**[1.](#ch09qa1q1)**'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1.](#ch09qa1q1)**'
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[2.](#ch09qa1q2)**'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2.](#ch09qa1q2)**'
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[3.](#ch09qa1q3)**'
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3.](#ch09qa1q3)**'
- en: ''
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[4.](#ch09qa1q4)**'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4.](#ch09qa1q4)**'
- en: ''
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[5.](#ch09qa1q5)**'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5.](#ch09qa1q5)**'
- en: ''
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[6.](#ch09qa1q6)**'
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6.](#ch09qa1q6)**'
- en: ''
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[7.](#ch09qa1q7)**'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7.](#ch09qa1q7)**'
- en: ''
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[8.](#ch09qa1q8)**'
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8.](#ch09qa1q8)**'
- en: ''
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
