- en: 1 An introduction to automated testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 自动化测试简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What an automated test is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试是什么
- en: The goal of writing automated tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自动化测试的目标
- en: How automated tests can help you write better code, in less time, with more
    confidence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试如何帮助你更快、更自信地编写更好的代码
- en: When everything runs on software, from your uncle’s bakery to the country’s
    economy, the demand for new capabilities grows exponentially, and the more critical
    it becomes to ship software that works and ship it frequently—hopefully, multiple
    times a day. That’s what automated tests are here for. Long gone is the time when
    programmers could afford themselves the luxury of manually testing their software
    every once in a while. At this point, writing tests is not only good practice,
    it’s an industry standard. If you search job postings at this very moment, almost
    all of them require some degree of knowledge about automated software testing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当从你叔叔的面包店到国家的经济，所有事情都运行在软件上时，对新能力的需求呈指数级增长，而频繁交付能够正常工作的软件变得愈发关键——希望是每天多次。这正是自动化测试存在的目的。程序员偶尔手动测试软件的奢侈时代已经一去不复返了。现在，编写测试不仅是一种良好的实践，而且已成为行业标准。如果你现在搜索职位发布，几乎所有的职位都要求具备一定程度的自动化软件测试知识。
- en: It doesn’t matter how many customers you have or the volume of data you deal
    with. Writing effective tests is a valuable practice for companies of every size
    from venture-capital-backed Silicon Valley giants to your own recently bootstrapped
    startup. Tests are advisable for projects of all sizes because they facilitate
    communication among developers and help you avoid defects. Because of these reasons,
    the importance of having tests grows proportionally to the number of developers
    involved in a project and to the cost of failure associated with it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你有多少客户或你处理的数据量有多大，编写有效的测试对于任何规模的公司来说都是一项有价值的实践，从风险投资支持的硅谷巨头到你自己最近刚刚起步的初创公司。对于所有规模的项目，测试都是推荐的，因为它们促进了开发者之间的沟通，并帮助你避免缺陷。由于这些原因，拥有测试的重要性与参与项目的开发者数量和与之相关的失败成本成比例增长。
- en: This book is targeted at professionals who can already write software but can’t
    yet write tests or don’t know why it’s critical to do so. While writing these
    pages, I had in mind people who are fresh out of bootcamps or recently got their
    first development job and want to grow into seniority. I expect readers to know
    the basics of JavaScript and understand concepts like promises and callbacks.
    You don’t need to be a JavaScript specialist. If you can write programs that work,
    that’s enough. In case the shoes fit, and you’re concerned about producing the
    most valuable kind of software—software that works—this book is for you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书面向的是那些已经能够编写软件但尚未编写测试或不知道为什么这样做至关重要的专业人士。在编写这些页面时，我脑海中想的是那些刚刚从训练营毕业或最近获得第一份开发工作，并希望成长为资深人员的人。我期望读者了解JavaScript的基础知识，并理解像承诺（promises）和回调（callbacks）这样的概念。你不需要成为JavaScript专家。如果你能编写出能够正常运行的程序，那就足够了。如果你恰好适合这个角色，并且关心生产最有价值的软件——能够正常运行的软件——这本书就是为你而写的。
- en: This book is **not** targeted at quality assurance professionals or nontechnical
    managers. It covers topics from a developer’s point of view, focusing on how they
    can use tests’ feedback to produce higher-quality code at a faster pace. I *will
    not* talk about how to perform manual or exploratory testing, nor about how to
    write bug reports or manage testing workflows. These tasks *can’t* be automated
    yet. If you want to learn more about them, it’s advisable to look a book targeted
    at QA roles instead.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书**不是**针对质量保证专业人士或非技术经理。它从开发者的角度覆盖了主题，侧重于他们如何利用测试的反馈以更快的速度生产更高质量的代码。**我不会**讨论如何执行手动或探索性测试，也不会讨论如何编写错误报告或管理测试工作流程。这些任务**还不能**自动化。如果你想了解更多关于它们的信息，建议你寻找针对QA角色的书籍。
- en: Throughout the book, the primary tool you will use is Jest. You will learn by
    writing practical automated tests for a few small applications. For these applications,
    you’ll use plain JavaScript and popular libraries like Express and React. It helps
    to be familiar with Express, and especially with React, but even if you are not,
    brief research should suffice. I’ll build all of the examples from scratch and
    assume as little knowledge as possible, so I recommend to research as you go instead
    of doing so up-front.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将主要使用 Jest 工具。你将通过为几个小型应用程序编写实际的自动化测试来学习。对于这些应用程序，你将使用纯 JavaScript 和流行的库，如
    Express 和 React。熟悉 Express 有帮助，尤其是熟悉 React，但即使你不熟悉，简要的研究也应该足够。我会从头开始构建所有示例，并尽可能少地假设知识，所以我建议你在进行之前进行研究。
- en: In chapter 1, we’ll cover the concepts that will permeate all further practice.
    I find that the single most prominent cause of bad tests can be traced back to
    a misunderstanding of what tests are and what they can and should achieve, so
    that’s what I’m going to start with.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，我们将介绍将渗透到所有后续实践的概念。我发现，糟糕的测试的最主要原因可以追溯到对测试是什么以及它们可以和应该实现什么的不理解，所以这就是我要从哪里开始的地方。
- en: Once we have covered what tests are and the goal of writing them, we will talk
    about the multiple cases where writing tests can help us produce better software
    in less time and facilitate collaboration among various developers. Having these
    conceptual foundations will be crucial when we start writing our first tests in
    chapter 2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了测试是什么以及编写测试的目标，我们就会讨论多个案例，其中编写测试可以帮助我们在更短的时间内生产出更好的软件，并促进各种开发者之间的协作。当我们开始编写第2章中的第一个测试时，这些概念基础将至关重要。
- en: 1.1 What is an automated test?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 自动化测试是什么？
- en: 'Uncle Louis didn’t stand a chance in New York, but in London, he’s well-known
    for his vanilla cheesecakes. Because of his outstanding popularity, it didn’t
    take long for him to notice that running a bakery on pen and paper doesn’t scale.
    To keep up with the booming orders, he decided to hire the best programmer he
    knows to build his online store: you.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯叔叔在纽约没有机会，但在伦敦，他因其香草芝士蛋糕而闻名。由于他卓越的受欢迎程度，他很快就注意到，仅用笔和纸经营面包店是无法扩展的。为了跟上激增的订单，他决定雇佣他认识的最好的程序员来建立他的在线商店：你。
- en: 'His requirements are simple: customers must be able to order items from the
    bakery, enter the delivery address, and check out online. Once you implement these
    features, you decide to make sure the store works appropriately. You create the
    databases, seed them, spin up the server, and access the website on your machine
    to try ordering a few cakes. During this process, suppose you find a bug. You
    notice, for example, that you can have only one unit of an item in your cart at
    a time.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 他的要求很简单：客户必须能够从面包店订购商品，输入送货地址，并在网上结账。一旦你实现了这些功能，你决定确保商店能够适当地工作。你创建了数据库，初始化它们，启动服务器，并在你的机器上访问网站以尝试订购一些蛋糕。在这个过程中，假设你发现了一个错误。例如，你注意到你一次只能有一个商品单位在你的购物车中。
- en: For Louis, it would be disastrous if the website went live with such a defect.
    Everyone knows that it’s impossible to eat a single macaroon at a time, and therefore,
    no macaroons—one of Louis’s specialties—would sell. To avoid that happening again,
    you decide that adding multiple units of an item is a use case that *always* needs
    to be tested.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路易斯来说，如果网站带着这样的缺陷上线，那将是一场灾难。众所周知，一次只能吃一个马卡龙，因此，路易斯的拿手好菜——马卡龙将无人问津。为了避免这种情况再次发生，你决定认为添加多个商品单位是一个始终需要测试的场景。
- en: You could decide to manually inspect every release, like old assembly lines
    used to do. But that’s an unscalable approach. It takes too long, and, as in any
    manual process, it’s also easy to make mistakes. To solve this problem, you must
    replace yourself, the customer, with code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择手动检查每个发布版本，就像旧式的流水线那样。但这不是一个可扩展的方法。这需要太长时间，而且在任何手动过程中，都很容易出错。为了解决这个问题，你必须用代码来代替你自己，即客户。
- en: Let’s think about how a user tells your program to add something to the cart.
    This exercise is useful to identify which parts of the action flow need to be
    replaced by automated tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下用户是如何告诉你的程序将某物添加到购物车中的。这个练习有助于确定哪些动作流程的部分需要被自动化测试所取代。
- en: Users interact with your application through a website, which sends an HTTP
    request to the backend. This request informs the `addToCart` function which item
    and how many units they want to add to their cart. The customer’s cart is identified
    by looking at the sender’s session. Once the items were added to the cart, the
    website updates according to the server’s response. This process is shown in figure
    1.1.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过网站与您的应用程序交互，该网站向后端发送HTTP请求。此请求通知`addToCart`函数他们想要将哪些项目和多少单位添加到购物车中。通过查看发送者的会话来识别客户的购物车。一旦项目被添加到购物车中，网站会根据服务器的响应进行更新。此过程如图1.1所示。
- en: '![](../Images/CH01_F01_DaCosta.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F01_DaCosta.png)'
- en: Figure 1.1 An order’s action flow
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 订单的动作流程
- en: NOTE The `f(x)` notation is simply the icon I’ve chosen to represent functions
    throughout this book’s diagrams. It doesn’t necessarily indicate what the function’s
    parameters are.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`f(x)`表示法只是我选择用于本书图表中代表函数的图标。它并不一定表示函数的参数是什么。
- en: Let’s replace the customer with a piece of software that can call the `addToCartFunction`.
    Now, you don’t depend on someone to manually add items to a cart and look at the
    response. Instead, you have a piece of code that does the verification for you.
    That’s an automated test.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用可以调用`addToCartFunction`的软件组件替换客户。现在，您不需要依赖某人手动添加项目到购物车并查看响应。相反，您有一段代码为您执行验证。那是一个自动化测试。
- en: Automated test Automated tests are programs that automate the task of testing
    your software. They interface with your application to perform actions and compare
    the actual result with the expected output you have previously defined.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试 自动化测试是自动执行测试软件任务的程序。它们与您的应用程序接口，执行操作，并将实际结果与您之前定义的预期输出进行比较。
- en: Your testing code creates a cart and tells `addToCart` to add items to it. Once
    it gets a response, it checks whether the requested items are there, as shown
    in figure 1.2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试代码创建了一个购物车，并告诉`addToCart`向其中添加项目。一旦收到响应，它会检查请求的项目是否已存在，如图1.2所示。
- en: '![](../Images/CH01_F02_DaCosta.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F02_DaCosta.png)'
- en: Figure 1.2 The action flow for testing `addToCart`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 测试`addToCart`的动作流程
- en: 'Within your test, you can simulate the exact scenario in which users would
    be able to add only a single macaroon to their cart:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试中，您可以模拟用户只能向购物车添加单个马卡龙的精确场景：
- en: Create an instance of a cart.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个购物车实例。
- en: Call `addToCart` and tell it to add a macaroon to that cart.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`addToCart`并告诉它向该购物车添加一个马卡龙。
- en: Check whether the cart contains two macaroons.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查购物车是否包含两个马卡龙。
- en: By making your test reproduce the steps that would cause the bug to happen,
    you can prove that this specific bug doesn’t happen anymore.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使您的测试重现导致错误发生的步骤，您可以证明这个特定的错误不再发生。
- en: The next test we will write is to guarantee that it’s possible to add multiple
    macaroons to the cart. This test creates its own instance of a cart and uses the
    `addToCart` function to try adding two macaroons to it. After calling the `addToCart`
    function, your test checks the contents of the cart. If the cart’s contents match
    your expectations, it tells you that everything worked properly. We’re now sure
    it’s possible to add two macaroons to the cart, as shown in figure 1.3.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的下一个测试是确保能够将多个马卡龙添加到购物车中。这个测试创建了自己的购物车实例，并使用`addToCart`函数尝试向其中添加两个马卡龙。在调用`addToCart`函数后，您的测试会检查购物车的内容。如果购物车的内容符合您的预期，它会告诉您一切正常。我们现在可以确信可以添加两个马卡龙到购物车中，如图1.3所示。
- en: '![](../Images/CH01_F03_DaCosta.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F03_DaCosta.png)'
- en: Figure 1.3 The action flow for a test that checks whether you can add multiple
    macaroons to a cart
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 检查是否可以将多个马卡龙添加到购物车中的测试动作流程
- en: 'Now that customers can have as many macaroons as they want—as it should be—let’s
    say you try to simulate a purchase your customer would make: 10,000 macaroons.
    Surprisingly, the order goes through, but Uncle Louis doesn’t have that many macaroons
    in stock. As his bakery is still a small business, he also can’t fulfill humongous
    orders like this on such short notice. To make sure that Louis can deliver flawless
    desserts to everyone on time, he asks you to make sure that customers can order
    only what’s in stock.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户可以拥有他们想要的任意数量的马卡龙——正如它应该的那样——让我们假设您尝试模拟客户会进行的购买：10,000个马卡龙。令人惊讶的是，订单通过了，但路易叔叔没有那么多马卡龙库存。由于他的面包店仍然是一家小企业，他也不能在这么短的时间内完成如此巨大的订单。为了确保路易可以准时向每个人提供完美的甜点，他要求您确保客户只能订购库存中的商品。
- en: To identify which parts of the action flow need to be replaced by automated
    tests, let’s define what should happen when customers add items to their carts
    and adapt our application correspondingly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定哪些操作流程的部分需要由自动化测试替换，让我们定义当客户将商品添加到购物车时应发生什么，并相应地调整我们的应用程序。
- en: When customers click the “Add to Cart” button on the website, as shown in figure
    1.4, the client should send an HTTP request to the server telling it to add 10,000
    macaroons to the cart. Before adding them to the cart, the server must consult
    a database to check if there are enough in stock. If the amount in stock is smaller
    or equal to the quantity requested, the macaroons will be added to the cart, and
    the server will send a response to the client, which updates accordingly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户点击网站上的“添加到购物车”按钮，如图1.4所示，客户端应向服务器发送一个HTTP请求，告诉它将10,000个马卡龙添加到购物车。在将它们添加到购物车之前，服务器必须咨询数据库以检查库存是否足够。如果库存量小于或等于请求的数量，马卡龙将被添加到购物车，服务器将向客户端发送响应，相应地更新。
- en: NOTE You should use a separate testing database for your tests. Do not pollute
    your production database with testing data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你应该为你的测试使用单独的测试数据库。不要用测试数据污染你的生产数据库。
- en: Tests will add and manipulate all kinds of data, which can lead to data being
    lost or to the database being in an inconsistent state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将添加和操作各种数据，这可能导致数据丢失或数据库处于不一致状态。
- en: Using a separate database also makes it easier to determine a bug’s root cause.
    Because you are fully in control of the test database’s state, customers’ actions
    won’t interfere with your tests’ results.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的数据库也更容易确定错误的根本原因。因为你完全控制测试数据库的状态，客户的操作不会干扰你的测试结果。
- en: '![](../Images/CH01_F04_DaCosta.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4](../Images/CH01_F04_DaCosta.png)'
- en: Figure 1.4 The desired action flow for adding only available items to a cart
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 添加仅可用的商品到购物车的期望操作流程
- en: This bug is even more critical, so you need to be twice as careful. To be more
    confident about your test, you can write it before actually fixing the bug, so
    that you can see if it fails as it should.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误甚至更加关键，所以你需要加倍小心。为了使你的测试更有信心，你可以在实际修复错误之前编写它，这样你就可以看到它是否按预期失败。
- en: '**The only useful kind of test is a test that will fail when your application
    doesn’t work**.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**唯一有用的测试类型是当你的应用程序不工作时会导致失败的测试**。'
- en: 'This test is just like the one from earlier: it replaces the user with a piece
    of software and simulates its actions. The difference is that, in this case, you
    need to add one extra step to remove all macaroons from the inventory. The test
    must set up the scenario *and* simulate the actions that would cause the bug to
    happen; see figure 1.5.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试就像之前的那个一样：它用一段软件代码替换用户，并模拟其操作。不同的是，在这种情况下，你需要额外添加一步，从库存中移除所有马卡龙。测试必须设置场景并模拟导致错误发生的操作；参见图1.5。
- en: Once the test is in place, it’s also much quicker to fix the bug. Every time
    you make a change, your test will tell you whether the bug is gone. You don’t
    need to manually log in to the database, remove all macaroons, open the website,
    and try to add them to your cart. The test can do it for you much quicker.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试到位，修复错误也会更快。每次你进行更改时，你的测试都会告诉你错误是否已消失。你不需要手动登录数据库，移除所有马卡龙，打开网站，并尝试将它们添加到你的购物车。测试可以为你更快地完成这些操作。
- en: Because you have also written a test to check whether customers can add multiple
    items to the cart, if your fix causes the other bug to reappear, that test will
    warn you. Tests provide quick feedback and make you more confident that your software
    works.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你也编写了一个测试来检查客户是否可以将多个商品添加到购物车，如果你的修复导致其他错误再次出现，该测试会警告你。测试提供快速反馈，并使你更有信心软件能正常工作。
- en: '![](../Images/CH01_F05_DaCosta.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5](../Images/CH01_F05_DaCosta.png)'
- en: Figure 1.5 The necessary steps for a test to check whether we can add sold-out
    items to the cart
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 测试检查我们是否可以将售罄商品添加到购物车的必要步骤
- en: I must warn you, however, that automated tests are not the panacea for producing
    software that works. **Tests can’t prove your software works; they can only prove
    it doesn’t**. If adding 10,001 macaroons to the cart still caused their availability
    to be ignored, you wouldn’t know unless you tested this specific input.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我必须警告你，自动化测试并不是生产出能正常工作的软件的万能药。**测试不能证明你的软件能工作；它们只能证明它不能工作**。如果你在购物车中添加10,001个马卡龙仍然导致其可用性被忽略，除非你测试了这个特定的输入，否则你不会知道。
- en: Tests are like experiments. You encode our expectations about how the software
    works into your tests, and because they passed in the past, you choose to believe
    your application will behave the same way in the future, even though that’s not
    always true. The more tests you have, and the closer these tests resemble what
    real users do, the more guarantees they give you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试就像实验。你将我们对软件如何工作的期望编码到你的测试中，因为它们在过去通过了，你选择相信你的应用程序在未来将以相同的方式表现，尽管这并不总是正确的。你拥有的测试越多，这些测试越接近真实用户的行为，它们给你的保证就越多。
- en: Automated tests also don’t eliminate the need for manual testing. Verifying
    your work as end users would do and investing time into exploratory testing are
    still indispensable. Because this book is targeted at software developers instead
    of QA analysts, in the context of this chapter, I’ll refer to the *unnecessary*
    manual testing process often done during development just as *manual testing*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试也不能消除手动测试的需求。像最终用户那样验证你的工作，并投入时间进行探索性测试仍然是必不可少的。因为本书的目标读者是软件开发人员而不是质量保证分析师，所以在本章的上下文中，我将经常将开发过程中经常进行的*不必要的*手动测试过程称为*手动测试*。
- en: 1.2 Why automated tests matter
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 自动化测试的重要性
- en: Tests matter because they give you quick and fail-proof feedback. In this chapter,
    we’ll look in detail at how swift and precise feedback improves the software development
    process by making the development workflow more uniform and predictable, making
    it easy to reproduce issues and document tests cases, easing the collaboration
    among different developers or teams, and shortening the time it takes to deliver
    high-quality software.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很重要，因为它们能给你快速且可靠的反馈。在本章中，我们将详细探讨如何通过使开发工作流程更加统一和可预测，以及便于重现问题和记录测试用例，来提高软件开发过程的速度和精确度，从而缩短交付高质量软件所需的时间。
- en: 1.2.1 Predictability
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 可预测性
- en: Having a predictable development process means preventing the introduction of
    unexpected behavior during the implementation of a feature or the fixing of a
    bug. Reducing the number of surprises during development also makes tasks easier
    to estimate and causes developers to revisit their work less often.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可预测的开发过程意味着在实现功能或修复错误的过程中防止意外行为的引入。减少开发过程中的惊喜数量也使得任务更容易估计，并导致开发者更少地回顾他们的工作。
- en: Manually ensuring that your entire software works as you expect is a time-consuming
    and error-prone process. Tests improve this process because they decrease the
    time it takes to get feedback on the code you write and, therefore, make it quicker
    to fix mistakes. **The smaller the distance between the act of writing code and
    receiving feedback, the more predictable development becomes**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 手动确保你的整个软件按预期工作是一个耗时且容易出错的过程。测试通过减少你编写代码并获得反馈所需的时间来改进这个过程，因此可以更快地修复错误。**编写代码和收到反馈之间的距离越小，开发过程就越可预测**。
- en: To illustrate how tests can make development more predictable, let’s imagine
    that Louis has asked you for a new feature. He wants customers to be able to track
    the status of their orders. This feature would help him spend more time baking
    and less time answering the phone to reassure customers that their order will
    be on time. Louis is passionate about cheesecakes, not phone calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明测试如何使开发更具可预测性，让我们想象Louis要求你添加一个新功能。他希望客户能够跟踪他们订单的状态。这个功能将帮助他花更多的时间烘焙，而不是花时间接电话来向客户保证他们的订单将准时到达。Louis对芝士蛋糕充满热情，而不是对电话。
- en: If you were to implement the tracking feature without automated tests, you’d
    have to run through the entire shopping process manually to see if it works, as
    shown in figure 1.6\. Every time you need to test it again, besides restarting
    the server, you also need to clear your databases to make sure they are in a consistent
    state, open your browser, add items to the cart, schedule a delivery, go through
    checkout, and only then you’d finally test tracking your order.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在没有自动化测试的情况下实现跟踪功能，你将不得不手动完成整个购物流程来查看它是否工作，如图1.6所示。每次你需要再次测试时，除了重启服务器外，你还需要清除你的数据库以确保它们处于一致状态，打开你的浏览器，将商品添加到购物车，安排配送，完成结账，然后你才能最终测试跟踪订单。
- en: '![](../Images/CH01_F06_DaCosta.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH01_F06_DaCosta.png)'
- en: Figure 1.6 The steps to test tracking an order
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 测试跟踪订单的步骤
- en: Before you can even manually test this feature, it needs to be accessible on
    the website. You need to write its interface and a good chunk of the backend the
    client talks to.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以手动测试这个功能之前，它需要在网站上可访问。你需要编写它的接口以及客户端与之交互的大块后端代码。
- en: Not having automated tests will cause you to write too much code before checking
    whether the feature works. If you have to go through a long and tedious process
    every time you make changes, you will write bigger chunks of code at a time. Because
    it takes so long to get feedback when you write bigger chunks of code, by the
    time you do receive it, it might be too late. You have written too much code before
    testing, and now there are more places for bugs to hide. Where, among the thousand
    new lines of code, is the bug you’ve just seen?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 没有自动化测试会导致你在检查功能是否工作之前编写过多的代码。如果你每次更改都必须经历一个漫长而繁琐的过程，你将一次编写更大的代码块。因为编写更大的代码块需要很长时间才能获得反馈，到你最终收到反馈时，可能已经太晚了。你在测试之前已经编写了过多的代码，现在有更多的地方可以隐藏错误。在成千上万的新代码行中，你刚刚看到的错误在哪里？
- en: '![](../Images/CH01_F07_DaCosta.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH01_F07_DaCosta.png)'
- en: Figure 1.7 The tests for the `trackOrder` function can call that function directly,
    so you don’t have to touch other parts of the application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 对于`trackOrder`函数的测试可以直接调用该函数，因此你不需要触及应用程序的其他部分。
- en: With an automated test like the ones in figure 1.7, you can write less code
    before getting feedback. When your automated tests can call the `trackOrder` function
    directly, you can avoid touching unnecessary parts of your application before
    you’re sure that `trackOrder` works.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如图1.7所示的自动化测试，你可以在获得反馈之前编写更少的代码。当你的自动化测试可以直接调用`trackOrder`函数时，你可以在确认`trackOrder`正常工作之前避免触及应用程序中不必要的部分。
- en: When a test fails after you’ve written only 10 lines of code, you have only
    10 lines of code to worry about. Even if the bug is not within those 10 lines,
    it becomes way easier to detect which one of them provoked misbehavior somewhere
    else.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编写了10行代码之后测试失败，你只需要担心这10行代码。即使错误不在这10行代码中，它也变得更容易检测出是哪一行引发了其他地方的异常行为。
- en: The situation can get even worse if you break other parts of your application.
    If you introduce bugs into the checkout procedure, you need to check how your
    changes affected it. The more changes you’ve made, the harder it becomes to find
    where the problem is.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你破坏了应用程序的其他部分，情况可能会变得更糟。如果你在结账过程中引入了错误，你需要检查你的更改对其产生了怎样的影响。你做的更改越多，找到问题所在就越困难。
- en: When you have automated tests like the ones in figure 1.8, they can alert you
    as soon as something breaks so that you can correct course more easily. If you
    run tests frequently, you will get precise feedback on what part of your application
    is broken as soon as you break it. Remember that **the less time it takes to get
    feedback once you’ve written code, the more predictable your development process
    will be**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有如图1.8所示的自动化测试时，它们可以在出现问题后立即提醒你，这样你就可以更容易地纠正方向。如果你经常运行测试，你将能够在你破坏它时立即获得关于应用程序哪个部分出错的精确反馈。记住，**一旦你编写了代码，获得反馈所需的时间越少，你的开发过程就越可预测**。
- en: '![](../Images/CH01_F08_DaCosta.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/CH01_F08_DaCosta.png)'
- en: Figure 1.8 Automated tests can check parts of your code individually and give
    you precise feedback on what’s broken as soon as you break it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 自动化测试可以单独检查你的代码部分，并在你破坏它时立即提供关于什么出错的精确反馈。
- en: Often I see developers having to throw work away because they’ve done too many
    changes at once. When those changes caused so many parts of the application to
    break, they didn’t know where to start. It was easier to start from scratch than
    to fix the mess they had already created. How many times have *you* done that?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到开发者不得不丢弃工作，因为他们一次做了太多的更改。当这些更改导致应用程序的许多部分出现问题时，他们不知道从哪里开始。从头开始比修复他们已经造成的混乱要容易得多。你**有多少次**这样做过？
- en: 1.2.2 Reproducibility
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 可重复性
- en: The more steps a particular task has, the more likely a human is to make mistakes
    following them. Automated tests make it easier and quicker to reproduce bugs and
    ensure they aren’t present anymore.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定任务包含的步骤越多，人类在遵循这些步骤时犯错误的可能性就越大。自动化测试使得重现错误和确保它们不再存在变得更加容易和快捷。
- en: For a customer to track the status of an order, they will have to go through
    multiple steps. They’d have to add items to their cart, pick a delivery date,
    and go through the checkout process. To test your application and ensure that
    it will work for customers, you must do the same. This process is reasonably long
    and error-prone, and you could approach each step in many different ways. With
    automated tests, we can ensure that these steps are followed to the letter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户跟踪订单状态，他们必须经过多个步骤。他们需要将商品添加到购物车中，选择送货日期，并通过结账流程。为了测试你的应用程序并确保它对客户有效，你必须做同样的事情。这个过程相当长且容易出错，你可以以许多不同的方式处理每个步骤。通过自动化测试，我们可以确保这些步骤被严格遵循。
- en: Let’s assume that you find bugs when you test your application, like being able
    to check out with an empty cart or with an invalid credit card. For you to find
    those bugs, you had to go through a series of steps manually.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在测试应用程序时发现了一些错误，比如能够用空购物车或无效的信用卡结账。为了找到这些错误，你必须手动完成一系列步骤。
- en: To avoid those bugs happening again, you must reproduce the exact same steps
    that cause each one of them. If the list of test cases grows too long or if there
    are too many steps, the room for human mistakes gets bigger. Unless you have a
    checklist that you follow to the letter every single time, bugs will slip in (see
    figure 1.9).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些错误再次发生，你必须重现导致每个错误的完全相同的步骤。如果测试案例列表太长或步骤太多，人为错误的空间就更大了。除非你有一个每次都必须严格遵循的清单，否则错误会悄悄溜进来（见图1.9）。
- en: Ordering a cake is something you will certainly remember to check, but what
    about ordering –1 cakes, or even `NaN` cakes? People forget and make mistakes,
    and, therefore, software breaks. Humans should do things that humans are good
    at, and performing repetitive tasks is not one of them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 订购蛋糕是你一定会记得检查的事情，但订购-1个蛋糕，或者甚至`NaN`个蛋糕呢？人们会忘记并犯错误，因此软件会出错。人类应该做人类擅长的事情，而执行重复性任务并不是其中之一。
- en: '![](../Images/CH01_F09_DaCosta.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F09_DaCosta.png)'
- en: Figure 1.9 The steps that must be followed when testing each feature
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 测试每个功能时必须遵循的步骤
- en: Even if you decide to maintain a checklist for those test cases, you will have
    the overhead of keeping that documentation always up-to-date. If you ever forget
    to update it and something not described in a test case happens, who’s wrong—the
    application or the documentation?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你决定为这些测试案例维护一个清单，你也将不得不承担保持该文档始终更新的开销。如果你忘记更新它，并且发生了测试案例中没有描述的事情，那么错的是应用程序还是文档？
- en: Automated tests do the exact same actions every time you execute them. When
    a machine is running tests, it neither forgets any steps nor makes mistakes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试每次执行时都会执行完全相同的操作。当机器运行测试时，它既不会忘记任何步骤，也不会犯错误。
- en: 1.2.3 Collaboration
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 协作
- en: Everyone who tastes Louis’s banoffee pies knows he’s one *Great British Bake
    Off* away from stardom. If you do everything right on the software side, maybe
    one day he’ll open bakeries everywhere from San Franciso to Saint Petersburg.
    In that scenario, a single developer just won’t cut it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个品尝过路易斯班夫提尼派的人都知道，他离成为明星的**Great British Bake Off**只有一步之遥。如果你在软件方面做得一切正确，也许有一天他会从旧金山到圣彼得堡的每个地方都开设面包店。在这种情况下，一个开发者显然是不够的。
- en: If you hire other developers to work with you, all of a sudden, you start having
    new and different concerns. If you’re implementing a new discount system, and
    Alice is implementing a way to generate coupons, what do you do if your changes
    to the checkout procedure make it impossible for customers also to apply coupons
    to their orders? In other words, how can you ensure that your work is not going
    to interfere with hers and vice versa?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你雇佣其他开发者与你一起工作，突然之间，你开始有新的和不同的担忧。如果你正在实施一个新的折扣系统，而爱丽丝正在实施生成优惠券的方法，如果你的结账程序更改使得客户无法将优惠券应用于他们的订单，你会怎么办？换句话说，你如何确保你的工作不会干扰她的工作，反之亦然？
- en: If Alice merges her feature into the codebase first, you have to ask her how
    you’re supposed to test her work to ensure yours didn’t break it. Merging *your*
    work will consume *your* time *and* Alice’s.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果爱丽丝首先将她的功能合并到代码库中，你必须问她你应该如何测试她的工作以确保你的工作没有破坏它。合并*你的*工作将消耗*你的*时间和爱丽丝的时间。
- en: The effort you and Alice spent manually testing your changes will have to be
    repeated when integrating your work with hers. On top of that, there will be additional
    effort to test the integration between both changes, as illustrated by figure
    1.10.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你和爱丽丝手动测试更改所花费的努力，在将你的工作与她的工作集成时也必须重复。除此之外，还需要额外的努力来测试这两个更改之间的集成，如图1.10所示。
- en: '![](../Images/CH01_F10_DaCosta.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F10_DaCosta.png)'
- en: Figure 1.10 The effort necessary to verify changes in each stage of the development
    process when doing manual testing
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 手动测试时在每个开发阶段验证更改所需的工作量
- en: Besides time-consuming, this process is also error-prone. You have to remember
    all the steps and edge cases to test in both your work and Alice’s. And, even
    if you do remember, you still need to follow them exactly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了耗时之外，这个过程还容易出错。你必须记住在您的工作和爱丽丝的工作中测试的所有步骤和边缘情况。即使你记得，你仍然需要严格按照这些步骤进行。
- en: When a programmer adds automated tests for their features, everyone else benefits.
    If Alice’s work has tests, you don’t need to ask her how to test her changes.
    When the time comes for you to merge both pieces of work, you can simply run the
    existing automated tests instead of going through the whole manual testing process
    again.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员为他们的功能添加自动化测试时，每个人都会受益。如果爱丽丝的工作有测试，你就不需要问她如何测试她的更改。当你合并这两部分工作的时候，你可以简单地运行现有的自动化测试，而不是再次经历整个手动测试过程。
- en: Even if your changes build on top of hers, tests will serve as up-to-date documentation
    to guide further work. Well-written tests are the best documentation a developer
    can have. Because they need to pass, they will always be up-to-date. If you are
    going to write technical documentation anyway, why not write a test instead?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的更改建立在她的基础上，测试也将作为最新的文档来指导进一步的工作。编写良好的测试是开发者能拥有的最佳文档。因为它们需要通过，所以它们总是最新的。如果你无论如何都要编写技术文档，为什么不写一个测试呢？
- en: If your code integrates with Alice’s, you will also add more automated tests
    that cover the integration between your work and hers. These new tests will be
    used by the next developers when implementing correlated features and, therefore,
    save them time. Writing tests whenever you make changes creates a virtuous collaboration
    cycle where one developer helps those who will touch that part of the codebase
    next (see figure 1.11).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码与爱丽丝的代码集成，你也将添加更多自动化测试，这些测试将覆盖你和她工作之间的集成。这些新测试将在后续开发者实现相关功能时使用，因此可以节省他们的时间。每次你进行更改时都编写测试，可以创造一个良性的协作循环，其中一个开发者帮助那些将要接触代码库该部分的人（见图1.11）。
- en: This approach reduces communication *overhead* but does not eliminate the need
    for communication, which is the foundation stone for every project to succeed.
    Automated tests remarkably improve the collaboration process, but they become
    even more effective when paired with other practices, such as code reviews.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法减少了沟通的*开销*，但并没有消除沟通的需求，这是每个项目成功的基础。自动化测试显著提高了协作过程，但与代码审查等其他实践相结合时，它们会变得更加有效。
- en: '![](../Images/CH01_F11_DaCosta.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F11_DaCosta.png)'
- en: Figure 1.11 The effort necessary to verify changes in each stage of the development
    process when automated tests exist
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 存在自动化测试时在每个开发阶段验证更改所需的工作量
- en: One of the most challenging tasks in software engineering is to make multiple
    developers collaborate efficiently, and tests are one of the most useful tools
    for that.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程中最具挑战性的任务之一是让多个开发者高效协作，而测试是实现这一目标最有用的工具之一。
- en: 1.2.4 Speed
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 速度
- en: 'Louis doesn’t care about which language you use and much less about how many
    tests you have written. Louis wants to sell pastries, cakes, and whatever other
    sugary marvels he can produce. Louis cares about revenue. If more features make
    customers happier and generate more revenue, then he wants you to deliver those
    features as fast as possible. There’s only one caveat: they must work.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 路易不在乎你使用哪种语言，更不用说你对多少测试感兴趣了。路易只想卖糕点、蛋糕以及他能制作出的任何其他甜点。路易关心的是收入。如果更多的功能能让客户更满意并带来更多收入，那么他希望你尽可能快地提供这些功能。只有一个前提：它们必须能正常工作。
- en: For the business, it’s speed and correctness that matters, not tests. In all
    the previous sections, we talked about how tests improved the development process
    by making it more predictable, reproducible, and collaborative, but, ultimately,
    those are benefits only because they help us produce better software in less time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业来说，重要的是速度和正确性，而不是测试。在前面的所有章节中，我们讨论了测试如何通过使其更具可预测性、可重复性和协作性来改进开发过程，但最终，这些好处仅因为它们帮助我们以更短的时间生产更好的软件。
- en: When it takes less time for you to produce code, prove that it doesn’t have
    specific bugs, and integrate it with everyone else’s work, the business succeeds.
    When you prevent regressions, the business succeeds. When you make deployments
    safer, the business succeeds.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你产生代码的时间更短，证明它没有特定的错误，并将其与其他人的工作集成时，业务就会成功。当你防止回归时，业务就会成功。当你使部署更安全时，业务就会成功。
- en: Because it takes time to write tests, they *do* have a cost. But we insist on
    writing tests because the benefits vastly outweigh the drawbacks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编写测试需要时间，所以它们确实有成本。但我们坚持编写测试，因为其带来的好处远远超过了缺点。
- en: Initially, writing a test can be time-consuming, too, even more than doing a
    manual test, but the more you run it, the more value you extract from it. If it
    takes you one minute to do a manual test and you spend five minutes writing one
    that’s automated, as soon as it runs for the fifth time it will have paid for
    itself—and trust me, that test is going to run way more than five times.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，编写测试也可能很耗时，甚至比手动测试还多，但随着你运行它的次数越多，你从中提取的价值就越大。如果你手动测试需要一分钟，而你编写一个自动化测试需要五分钟，一旦它运行第五次，它就会收回成本——相信我，这个测试将会运行超过五次。
- en: In contrast to manual testing, which will always take the same amount of time
    or more, automating a test causes the time and effort it takes to run it to drop
    to almost zero. As time passes, the total effort involved in manual tests grows
    much quicker. This difference in effort between writing automated tests and performing
    manual testing is illustrated in figure 1.12.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动测试相比，手动测试始终需要相同的时间或更多，而自动化测试会导致运行测试所需的时间和精力几乎降至零。随着时间的推移，手动测试的总投入增长得更快。编写自动化测试和执行手动测试之间的这种努力差异在图1.12中得到了说明。
- en: '![](../Images/CH01_F12_DaCosta.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图1.12](../Images/CH01_F12_DaCosta.png)'
- en: Figure 1.12 The effort applied over time when doing manual testing versus automated
    testing
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 手动测试与自动化测试随时间投入的努力对比
- en: Writing tests is like buying stocks. You may pay a big price up-front, but you
    will continue to reap the dividends for a long time. As in finance, the kind of
    investment you will make—and whether you will make it—depends on when you need
    the money back. Long-term projects are the ones that benefit the most from tests.
    The longer the project runs, the more effort is saved, and the more you can invest
    in new features or other meaningful activities. Short-term projects, like the
    ones you make in pizza-fueled hackathons, for example, don’t benefit much. They
    don’t live long enough to justify the effort you will save with testing over time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试就像购买股票。你可能需要 upfront 支付一大笔钱，但你会长期持续获得回报。就像在金融领域一样，你将进行的投资类型——以及你是否会进行投资——取决于你需要回款的时间。长期项目是最能从测试中受益的。项目运行时间越长，节省的精力越多，你可以在新功能或其他有意义的活动上投入得更多。例如，像在披萨驱动的黑客马拉松中制作的短期项目，受益不大。它们存活的时间不够长，无法证明通过测试节省的努力是合理的。
- en: The last time Louis asked you if you could deliver features faster if you were
    not writing so many tests, you didn’t use the financial analogy, though. You told
    him that this would be like increasing an oven’s temperature for a cake to be
    ready sooner. The edges get burned, but the middle is still raw.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上次路易斯问你，如果你不编写这么多测试，能否更快地交付功能时，你并没有使用金融类比。你告诉他，这就像提高烤箱温度以更快地让蛋糕熟透一样。边缘会被烧焦，但中间仍然生硬。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Automated tests are programs that automate the task of testing your software.
    These tests will interact with your application and compare its actual output
    to the expected output. They will pass when the output is correct and provide
    you with meaningful feedback when it isn’t.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试是自动执行测试软件任务的程序。这些测试将与你的应用程序交互，并将其实际输出与预期输出进行比较。当输出正确时，它们会通过，并在输出不正确时提供有意义的反馈。
- en: Tests that never fail are useless. The goal of having tests is for them to fail
    when the application misbehaves no longer present.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不会失败的测试是无用的。拥有测试的目标是当应用程序出现异常时，测试不再出现失败。
- en: You can’t prove your software works. You can prove only it doesn’t. Tests show
    that particular bugs are no longer present—not that there are no bugs. An almost
    infinite number of possible inputs could be given to your application, and it’s
    not feasible to test all of them. Tests tend to cover bugs you’ve seen before
    or particular kinds of situations you want to ensure will work.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你无法证明你的软件是有效的。你只能证明它不是。测试表明特定的错误不再存在——而不是没有错误。几乎无限数量的可能输入可以提供给你的应用程序，测试所有这些是不切实际的。测试倾向于覆盖你之前看到的错误或你想要确保会正常工作的特定情况。
- en: Automated tests reduce the distance between the act of writing code and getting
    feedback. Therefore, they make your development process more structured and reduce
    the number of surprises. A predictable development process makes it easier to
    estimate tasks and allows developers to revisit their work less often.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试缩短了编写代码和获取反馈之间的距离。因此，它们使你的开发过程更加结构化，并减少了意外情况的数量。可预测的开发过程使估计任务变得更容易，并允许开发者更少地回顾他们的工作。
- en: Automated tests always follow the exact same series of steps. They don’t forget
    or make mistakes. They ensure that test cases are followed thoroughly and make
    it easier to reproduce bugs.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试总是遵循一系列精确的步骤。它们不会忘记或出错。它们确保测试用例被彻底执行，并使重现错误变得更加容易。
- en: When tests are automated, rework and communication overhead decrease. On their
    own, developers can immediately verify other people’s work and ensure they haven’t
    broken other parts of the application.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试自动化时，返工和沟通开销会减少。开发者可以立即验证他人的工作，并确保他们没有破坏应用程序的其他部分。
- en: Well-written tests are the best documentation a developer can have. Because
    tests need to pass, they must always be up-to-date. They demonstrate the usage
    of an API and help others understand how the codebase works.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写良好的测试是开发者所能拥有的最佳文档。因为测试需要通过，所以它们必须始终是最新的。它们展示了 API 的使用方式，并帮助他人理解代码库的工作原理。
- en: Businesses don’t care about your tests. Businesses care about making a profit.
    Ultimately, automated tests are helpful because they drive up profits by helping
    developers deliver higher-quality software faster.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业不关心你的测试。企业关心的是盈利。最终，自动化测试是有帮助的，因为它们通过帮助开发者更快地交付高质量软件来提高利润。
- en: When writing tests, you pay a big price up-front by investing extra time in
    creating them. However, you get value back in dividends. The more often a test
    runs, the more time it has saved you. Therefore, the longer the life cycle of
    a project, the more critical tests become.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写测试时，你需要在创建它们上投入额外的时间，这会 upfront 支付一大笔代价。然而，你会在回报中获取价值。测试运行得越频繁，为你节省的时间就越多。因此，项目的生命周期越长，测试就越关键。
