- en: Chapter 4\. Cohort Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。Cohort分析
- en: 'In [Chapter 3](ch03.xhtml#time_series_analysis) we covered time series analysis.
    With those techniques in hand, we will now turn to a related type of analysis
    with many business and other applications: cohort analysis.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.xhtml#time_series_analysis)中，我们讨论了时间序列分析。现在，我们将转向另一种相关的分析类型，它在许多商业和其他应用中都有用途：cohort分析。
- en: I remember the first time I encountered a cohort analysis. I was working at
    my first data analyst job, at a small startup. I was reviewing a purchase analysis
    I’d worked on with the CEO, and he suggested that I break up the customer base
    by cohorts to see whether behavior was changing over time. I assumed it was some
    fancy business school thing and probably useless, but he was the CEO, so of course
    I humored him. Turns out it wasn’t just a lark. Breaking populations into cohorts
    and following them over time is a powerful way to analyze your data and avoid
    various biases. Cohorts can provide clues to how subpopulations differ from each
    other and how they change over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得我第一次接触cohort分析的时候。那时我在一家小型创业公司做数据分析师的工作。我正在审查一份我与CEO共同完成的购买分析，他建议我按cohort来拆分客户群，看看行为是否随时间而变化。我以为那只是一些花哨的商学院东西，可能没什么用，但他是CEO，所以我当然顺着他。结果证明这不只是一个噱头。将人群按cohort分组并随时间跟踪它们是分析数据和避免各种偏见的强大方式。cohorts可以提供关于亚群体如何不同以及随时间如何变化的线索。
- en: In this chapter, we’ll first take a look at what cohorts are and at the building
    blocks of certain types of cohort analysis. After an introduction to the legislators
    data set used for the examples, we’ll learn how to construct a retention analysis
    and deal with various challenges such as defining the cohort and handling sparse
    data. Next, we’ll cover survivorship, returnship, and cumulative calculations,
    all of which are similar to retention analysis in the way the SQL code is structured.
    Finally, we’ll look at how to combine cohort analysis with cross-sectional analysis
    to understand the makeup of populations over time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们首先来看看什么是cohorts以及某些类型的cohort分析的基本组成部分。在介绍用于示例的立法者数据集之后，我们将学习如何构建留存分析，并处理诸如定义cohort和处理稀疏数据等各种挑战。接下来，我们将涵盖生存分析、回归分析和累积计算，这些都类似于留存分析中SQL代码的结构。最后，我们将看看如何将cohort分析与横截面分析结合起来，以理解随时间变化的人群构成。
- en: 'Cohorts: A Useful Analysis Framework'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cohorts：一个有用的分析框架
- en: Before we get into the code, I will define what cohorts are, consider the types
    of questions we can answer with this type of analysis, and describe the components
    of any cohort analysis.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入代码之前，我会定义什么是cohorts，考虑我们可以用这种分析回答哪些类型的问题，并描述任何cohort分析的组成部分。
- en: 'A *cohort* is a group of individuals who share some characteristic of interest,
    described below, at the time we start observing them. Cohort members are often
    people but can be any type of entity we want to study: companies, products, or
    physical world phenomena. Individuals in a cohort may be aware of their membership,
    just as children in a first-grade class are aware they are part of a peer group
    of first graders, or participants in a drug trial are aware they are part of a
    group receiving a treatment. At other times, entities are grouped into cohorts
    virtually, as when a software company groups all customers acquired in a certain
    year to study how long they remain customers. It’s always important to consider
    the ethical implications of cohorting entities without their awareness, if any
    different treatment is to be applied to them.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*cohort*是一群在我们开始观察时具有某些特征的个体，下文将描述。Cohort成员通常是人，但也可以是我们想研究的任何类型的实体：公司、产品或物理世界现象。cohort中的个体可能意识到他们的成员身份，就像一个一年级班级的孩子意识到他们是第一年级同学群体的一部分，或者药物试验的参与者意识到他们是接受治疗的组的一部分。在其他时候，实体被虚拟地分成cohort，例如软件公司将所有在某一年获得的客户分组，以研究他们保持客户的时间长短。无论何时，都要考虑将实体分组而不通知它们的伦理影响，如果要对它们施加任何不同的对待。
- en: '*Cohort analysis* is a useful way to compare groups of entities over time.
    Many important behaviors take weeks, months, or years to occur or evolve, and
    cohort analysis is a way to understand these changes. Cohort analysis provides
    a framework for detecting correlations between cohort characteristics and these
    long-term trends, which can lead to hypotheses about the causal drivers. For example,
    customers acquired through a marketing campaign may have different long-term purchase
    patterns than those who were persuaded by a friend to try a company’s products.
    Cohort analysis can be used to monitor new cohorts of users or customers and assess
    how they compare to previous cohorts. Such monitoring can provide an early alert
    signal that something has gone wrong (or right) for new customers. Cohort analysis
    is also used to mine historical data. A/B tests, discussed in [Chapter 7](ch07.xhtml#experiment_analysis),
    are the gold standard for determining causality, but we can’t go back in time
    and run every test for every question about the past in which we are interested.
    We should of course be cautious about attaching causal meaning to cohort analysis
    and instead use cohort analysis as a way to understand customers and generate
    hypotheses that can be tested rigorously in the future.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列分析*是一种有益的比较实体群体随时间变化的方式。许多重要行为需要几周、几个月或几年的时间来发生或发展，队列分析是理解这些变化的一种方法。队列分析提供了一个框架，用于检测队列特征与这些长期趋势之间的相关性，这可以导致关于因果驱动因素的假设。例如，通过营销活动获得的客户可能具有与那些被朋友说服尝试公司产品的客户不同的长期购买模式。队列分析可用于监测新用户或客户的新队列，并评估它们与先前队列的比较情况。这种监测可以提供早期警报信号，表明新客户的情况出现了问题（或者好转）。队列分析还用于挖掘历史数据。A/B测试，在[第7章](ch07.xhtml#experiment_analysis)中讨论，是确定因果关系的黄金标准，但我们不能回到过去，并为我们感兴趣的过去每个问题运行每个测试。当然，我们应该谨慎地将因果意义附加到队列分析中，而是将队列分析用作了解客户并产生未来可以严格测试的假设的一种方式。'
- en: 'Cohort analyses have three components: the cohort grouping, a time series of
    data over which the cohort is observed, and an aggregate metric that measures
    an action done by cohort members.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 队列分析有三个组成部分：队列分组、观察队列的时间序列数据和衡量队列成员执行的聚合指标。
- en: '*Cohort grouping* is often based on a start date: the customer’s first purchase
    or subscription date, the date a student started school, and so on. However, cohorts
    can also be formed around other characteristics that are either innate or changing
    over time. Innate qualities include birth year and country of origin, or the year
    a company was founded. Characteristics that can change over time include city
    of residence and marital status. When these are used, we need to be careful to
    cohort only on the value on the starting date, or else entities can jump between
    cohort groups.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列分组*通常基于起始日期：客户的第一次购买或订阅日期，学生入学日期等。然而，队列也可以根据其他特征形成，这些特征可以是固有的或随时间变化的。固有特征包括出生年份和国家/地区，或公司成立年份。随时间变化的特征包括居住城市和婚姻状况。当使用这些特征时，我们需要确保只在起始日期上对队列进行分组，否则实体可能会在队列组之间跳跃。'
- en: Cohort or Segment?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列还是段？
- en: These two terms are often used in similar ways, or even interchangeably, but
    it’s worth drawing a distinction between them for the sake of clarity. A *cohort*
    is a group of users (or other entities) who have a common starting date and are
    followed over time. A *segment* is a grouping of users who share a common characteristic
    or set of characteristics at a point in time, regardless of their starting date.
    Similar to cohorts, segments can be based on innate factors such as age or on
    behavioral characteristics. A segment of users that signs up in the same month
    can be put into a cohort and followed over time. Or different groupings of users
    can be explored with cohort analysis so that you can see which ones have the most
    valuable characteristics. The analyses we’ll cover in this chapter, such as retention,
    can help put concrete data behind marketing segments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个术语通常以类似的方式使用，甚至可以互换，但出于清晰起见，区分它们是值得的。*队列*是一组具有共同起始日期并随时间跟踪的用户（或其他实体）。*段*是在某一时间点具有共同特征或一组特征的用户分组，而不考虑它们的起始日期。与队列类似，段可以基于固有因素（如年龄）或行为特征进行分组。在同一月份注册的用户可以被放入一个队列并随时间跟踪。或者可以使用队列分析探索不同的用户分组，以便了解哪些分组具有最有价值的特征。本章将涵盖的分析，如保留，可以帮助在市场细分背后提供具体数据。
- en: The second component of any cohort analysis is the *time series*. This is a
    series of purchases, logins, interactions, or other actions that are taken by
    the customers or entities to be cohorted. It’s important that the time series
    covers the entire life span of the entities, or there will be *survivorship bias*
    in early cohorts. Survivorship bias occurs when only customers who have stayed
    are in the data set; churned customers are excluded because they are no longer
    around, so the rest of the customers appear to be of higher quality or fit in
    comparison to newer cohorts (see [“Survivorship Bias”](#survivorship_bias)). It’s
    also important to have a time series that is long enough for the entities to complete
    the action of interest. For example, if customers tend to purchase once a month,
    a time series of several months is needed. If, on the other hand, purchases happen
    only once a year, a time series of several years would be preferable. Inevitably,
    more recently acquired customers will not have had as long to complete actions
    as those customers who were acquired further in the past. In order to normalize,
    cohort analysis usually measures the number of periods that have elapsed from
    a starting date, rather than calendar months. In this way, cohorts can be compared
    in period 1, period 2, and so on to see how they evolve over time, regardless
    of which month the action actually occurred. The intervals may be days, weeks,
    months, or years.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何队列分析的第二个组成部分是*时间序列*。这是一系列购买、登录、互动或其他由客户或被队列化的实体执行的行动。重要的是时间序列覆盖实体的整个生命周期，否则早期队列中会有*生存偏差*。生存偏差发生在只有留下的客户在数据集中；已流失的客户因不再存在而被排除，因此其余客户看起来比新队列的质量更高或更合适（见[“生存偏差”](#survivorship_bias)）。同样重要的是，时间序列足够长，以使实体完成感兴趣的行动。例如，如果客户倾向于每月购买一次，那么需要几个月的时间序列。另一方面，如果购买只发生一次一年，那么几年的时间序列将更可取。不可避免地，最近获取的客户没有足够的时间完成动作，与过去获取的客户相比。为了进行规范化，队列分析通常测量从起始日期起经过的周期数，而不是日历月份。通过这种方式，可以比较周期1、周期2等不同的队列，看看它们随时间的演变，而不考虑动作实际发生的月份。这些间隔可以是天、周、月或年。
- en: The *aggregate metric* should be related to the actions that matter to the health
    of the organization, such as customers continuing to use or purchase the product.
    Metric values are aggregated across the cohort, usually with `sum`, `count`, or
    `average`, though any relevant aggregation works. The result is a time series
    that can then be used to understand changes in behavior over time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*总量度量* 应与对组织健康至关重要的行动有关，比如继续使用或购买产品的客户。通常在队列中对度量值进行汇总，使用 `sum`、`count` 或 `average`，尽管任何相关的汇总都可以。其结果是一个时间序列，随后可用于理解随时间行为的变化。'
- en: 'In this chapter, I’ll cover four types of cohort analysis: retention, survivorship,
    returnship or repeat purchase behavior, and cumulative behavior.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将涵盖四种类型的队列分析：留存、生存、重购行为或再购买行为，以及累积行为。
- en: Retention
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 留存
- en: Retention is concerned with whether the cohort member has a record in the time
    series on a particular date, expressed as a number of periods from the starting
    date. This is useful in any kind of organization in which repeated actions are
    expected, from playing an online game to using a product or renewing a subscription,
    and it helps to answer questions about how sticky or engaging a product is and
    how many entities can be expected to appear on future dates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 留存关注的是队列成员在特定日期的时间序列中是否有记录，表示从起始日期起的周期数。这在任何预期有重复行为的组织中都很有用，无论是玩在线游戏、使用产品还是续订订阅，它有助于回答产品有多粘性或吸引力以及未来可能出现多少实体的问题。
- en: Survivorship
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 生存
- en: Survivorship is concerned with how many entities remained in the data set for
    a certain length of time or longer, regardless of the number or frequency of actions
    up to that time. Survivorship is useful for answering questions about the proportion
    of the population that can be expected to remain—either in a positive sense by
    not churning or passing away, or in a negative sense by not graduating or fulfilling
    some requirement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 生存关注的是在数据集中保留了多少实体一定长度的时间或更长时间，而不论到那时为止的行动次数或频率。生存对于回答预期有多少人口能够保持下去是很有用的——无论是因为没有流失或死亡，还是因为没有毕业或完成某些要求而保持下去。
- en: Returnship
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重购行为
- en: Returnship or repeat purchase behavior is concerned with whether an action has
    happened more than some minimum threshold of times—often simply more than once—during
    a fixed window of time. This type of analysis is useful in situations in which
    the behavior is intermittent and unpredictable, such as in retail, where it characterizes
    the share of repeat purchasers in each cohort within a fixed time window.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重购或重复购买行为关注的是在固定时间窗口内是否发生了动作超过某个最小阈值——通常仅仅是超过一次。这种分析类型在行为是间歇性和不可预测的情况下非常有用，比如在零售业中，它描述了每个队列中重复购买者的份额在固定时间窗口内。
- en: Cumulative
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 累积的
- en: Cumulative calculations are concerned with the total number or amounts measured
    at one or more fixed time windows, regardless of when they happened during that
    window. Cumulative calculations are often used in calculations of customer lifetime
    value (LTV or CLTV).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 累积计算关注的是在一个或多个固定时间窗口内测得的总数量或总金额，而不管它们在该窗口内何时发生。累积计算经常用于计算客户生命周期价值（LTV或CLTV）。
- en: The four types of cohort analysis allow us to compare subgroups and understand
    how they differ over time in order to make better product, marketing, and financial
    decisions. The calculations for the different types are similar, so we will set
    the stage with retention, and then I’ll show how to modify retention code to calculate
    the other types. Before we dive into constructing our cohort analysis, let’s take
    a look at the data set we’ll be using for the examples in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 四种类型的队列分析允许我们比较子群体，并了解它们随时间的差异，以便做出更好的产品、营销和财务决策。不同类型的计算方法相似，因此我们将从保留开始介绍，并展示如何修改保留代码以计算其他类型。在我们深入构建队列分析之前，让我们先看看我们将在本章的示例中使用的数据集。
- en: The Legislators Data Set
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[立法者数据集](https://github.com/unitedstates/congress-legislators)'
- en: The SQL examples in this chapter will use a data set of past and present members
    of the United States Congress maintained in a [GitHub repository](https://github.com/unitedstates/congress-legislators).
    In the US, Congress is responsible for writing laws or legislation, so its members
    are also known as legislators. Since the data set is a JSON file, I have applied
    some transformations to produce a more suitable data model for analysis, and I
    have posted data in a format suitable for following along with the examples in
    the book’s GitHub [legislators folder](https://oreil.ly/H2tYP).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的SQL示例将使用一个维护在[Github库](https://github.com/unitedstates/congress-legislators)中的过去和现任美国国会成员的数据集。在美国，国会负责制定法律或立法，所以其成员也被称为立法者。由于数据集是一个JSON文件，我已经应用了一些转换来为分析产生更适合的数据模型，并且我已经发布了适合在书的GitHub
    [legislators文件夹](https://oreil.ly/H2tYP)中跟随示例的数据格式。
- en: The source repository has an excellent data dictionary, so I won’t repeat all
    the details here. I will provide a few details, however, that should help those
    who aren’t familiar with the US government to follow along with the analyses in
    this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码库有一个很好的数据字典，所以我不会在这里重复所有细节。然而，我会提供一些细节，这些细节应该帮助那些不熟悉美国政府的人跟随本章的分析。
- en: Congress has two chambers, the Senate (“sen” in the data set) and the House
    of Representatives (“rep”). Each state has two senators, and they are elected
    for six-year terms. Representatives are allocated to states based on population;
    each representative has a district that they alone represent. Representatives
    are elected for two-year terms. Actual terms in either chamber can be shorter
    in the event that the legislator dies or is elected or appointed to a higher office.
    Legislators accumulate power and influence via leadership positions the longer
    they are in office, and thus standing for re-election is common. Finally, a legislator
    may belong to a political party, or they may be an “independent.” In the modern
    era, the vast majority of legislators are Democrats or Republicans, and the rivalry
    between the two parties is well known. Legislators occasionally change parties
    while in office.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 国会有两个议院，参议院（在数据集中为“sen”）和众议院（“rep”）。每个州有两名参议员，他们任期为六年。代表根据人口分配给各州；每个代表有一个他们独自代表的选区。代表任期为两年。在某位立法者死亡、当选或被任命到更高职务的情况下，任何一院的实际任期都可能较短。立法者通过担任领导职务累积权力和影响力，因此经常参加连任。最后，立法者可能属于一个政党，或者他们可能是“独立”的。在现代，绝大多数立法者是民主党人或共和党人，两党之间的竞争是众所周知的。立法者偶尔在任职期间更换政党。
- en: 'For the analyses, we’ll make use of two tables: `legislators` and `legislators_terms`.
    The `legislators` table contains a list of all the people included in the data
    set, with birthday, gender, and a set of ID fields that can be used to look up
    the person in other data sets. The `legislators_terms` table contains a record
    for each term in office for each legislator, with start and end date, and other
    attributes such as chamber and party. The `id_bioguide` field is used as the unique
    identifier of a legislator and appears in each table. [Figure 4-1](#sample_of_the_legislators_table)
    shows a sample of the `legislators` data. [Figure 4-2](#sample_of_the_legislators_terms_table)
    shows a sample of the `legislators_terms` data.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析中，我们将使用两个表：`legislators` 和 `legislators_terms`。`legislators` 表包含数据集中所有包括的人员列表，包括生日、性别和一组可以用于在其他数据集中查找该人员的ID字段。`legislators_terms`
    表包含每位立法者任期的记录，包括开始和结束日期，以及其他属性，如议会和党派。`id_bioguide` 字段用作立法者的唯一标识符，并出现在每个表中。[图 4-1](#legislators_table)
    展示了 `legislators` 数据的示例。[图 4-2](#legislators_terms_table) 展示了 `legislators_terms`
    数据的示例。
- en: '![](Images/sfda_0401.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![sfda_0401.png](Images/sfda_0401.png)'
- en: Figure 4-1\. Sample of the `legislators` table
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. `legislators` 表的示例
- en: '![](Images/sfda_0402.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![sfda_0402.png](Images/sfda_0402.png)'
- en: Figure 4-2\. Sample of the `legislators_terms` table
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. `legislators_terms` 表的示例
- en: 'Now that we have an understanding of what cohort analysis is and of the data
    set we’ll be using for examples, let’s get into how to write SQL for retention
    analysis. The key question SQL will help us answer is: once representatives take
    office, how long do they keep their jobs?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是队列分析，以及我们将用于示例的数据集，让我们来看看如何编写用于保留分析的SQL。SQL将帮助我们回答的关键问题是：一旦代表就职，他们会持续多长时间？
- en: Retention
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留
- en: One of the most common types of cohort analysis is *retention analysis*. To
    retain is to keep or continue something. Many skills need to be practiced to be
    retained. Businesses usually want their customers to keep purchasing their products
    or using their services, since retaining customers is more profitable than acquiring
    new ones. Employers want to retain their employees, because recruiting replacements
    is expensive and time consuming. Elected officials seek reelection in order to
    continue working on the priorities of their constituents.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的一种队列分析是*保留分析*。保留即是保持或继续某事物。许多技能需要练习才能保持。企业通常希望客户继续购买他们的产品或使用他们的服务，因为保留客户比获取新客户更具盈利性。雇主希望保留员工，因为招聘替代者既昂贵又耗时。当选官员寻求连任，以便继续推动选民的重要事务。
- en: The main question in retention analysis is whether the starting size of the
    cohort—number of subscribers or employees, amount spent, or another key metric—will
    remain constant, decay, or increase over time. When there is an increase or a
    decrease, the amount and speed of change are also interesting questions. In most
    retention analyses, the starting size will tend to decay over time, since a cohort
    can lose but cannot gain new members once it is formed. Revenue is an interesting
    exception, since a cohort of customers can spend more in subsequent months than
    they did in the first month collectively, even if some of them churn.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 保留分析中的主要问题是，起始队列的大小——订阅者或员工数量、支出金额或其他关键指标——是否会随时间保持恒定、衰减或增加。当存在增加或减少时，变化的数量和速度也是有趣的问题。在大多数保留分析中，起始队列大小随时间倾向于衰减，因为一旦形成队列，队列就无法获得新成员，只能失去成员。收入是一个有趣的例外，因为客户队列可以在后续几个月花费比首个月更多的金额，即使其中一些客户已经流失。
- en: Retention analysis uses the `count` of entities or `sum` of money or actions
    present in the data set for each period from the starting date, and it normalizes
    by dividing this number by the `count` or `sum` of entities, money, or actions
    in the first time period. The result is expressed as a percentage, and retention
    in the starting period is always 100%. Over time, retention based on counts generally
    declines and can never exceed 100%, whereas money- or action-based retention,
    while often declining, can increase and be greater than 100% in a time period.
    Retention analysis output is typically displayed in either table or graph form,
    which is referred to as a retention curve. We’ll see a number of examples of retention
    curves later in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 留存分析使用数据集中每个周期从起始日期起的实体的`count`或金钱或操作的`sum`，并通过将这个数值除以第一个时间段内的实体，金钱或操作的`count`或`sum`来进行标准化。结果以百分比表示，起始周期的留存率始终为100%。随着时间的推移，基于计数的留存率通常会下降，并且永远不会超过100%，而基于金钱或行动的留存率虽然通常会下降，但可以在某一时间段内增加并超过100%。留存分析的输出通常以表格或图形形式显示，称为留存曲线。在本章后面，我们将看到多个留存曲线的示例。
- en: Graphs of retention curves can be used to compare cohorts. The first characteristic
    to pay attention to is the shape of the curve in the initial few periods, where
    there is often an initial steep drop. For many consumer apps, losing half a cohort
    in the first few months is common. A cohort with a curve that is either more or
    less steep than others can indicate changes in the product or customer acquisition
    source that merit further investigation. A second characteristic to look for is
    whether the curve flattens after some number of periods or continues declining
    rapidly to zero. A flattening curve indicates that there is a point in time from
    which most of the cohort that remains stays indefinitely. A retention curve that
    inflects upward, sometimes called a smile curve, can occur if cohort members return
    or reactivate after falling out of the data set for some period. Finally, retention
    curves that measure subscription revenue are monitored for signs of increasing
    revenue per customer over time, a sign of a healthy SaaS software business.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 留存曲线图可以用来比较队列。要注意的第一个特征是曲线在最初几个周期内的形状，通常会有一个初始的陡峭下降。对于许多消费类应用程序，头几个月失去一半的队列是很常见的。具有比其他更陡或更缓的曲线的队列可能表明产品或客户获取来源发生了变化，值得进一步调查。要寻找的第二个特征是曲线在一定周期后是否变平或继续快速下降至零。平坦的曲线表明有一个时间点，此后大多数留存的队列成员将无限期留在其中。如果队列成员在一段时间后返回或重新激活，则留存曲线可能出现上升的情况，有时被称为笑脸曲线。最后，监控订阅收入的留存曲线，以了解时间内每个客户的增加收入迹象，是一个健康的SaaS软件业务的标志。
- en: This section will show how to create a retention analysis, add cohort groupings
    from the time series itself and other tables, and handle missing and sparse data
    that can occur in time series data. With this framework in hand, you’ll learn
    in the subsequent section how to make modifications to create the other related
    types of cohort analysis. As a result, this section on retention will be the longest
    one in the chapter, as you build up code and develop your intuition about the
    calculations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示如何创建留存分析，从时间序列本身和其他表中添加队列分组，并处理时间序列数据中可能出现的缺失和稀疏数据。有了这个框架，您将在随后的部分中学习如何进行修改，以创建其他相关类型的队列分析。因此，本节关于留存的内容将是本章中最长的部分，因为您将逐步构建代码并发展您对计算的直觉。
- en: SQL for a Basic Retention Curve
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL用于基本留存曲线
- en: 'For retention analysis, as with other cohort analyses, we need three components:
    the cohort definition, a time series of actions, and an aggregate metric that
    measures something relevant to the organization or process. In our case, the cohort
    members will be the legislators, the time series will be the terms in office for
    each legislator, and the metric of interest will be the `count` of those who are
    still in office each period from the starting date.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于留存分析，与其他队列分析一样，我们需要三个组成部分：队列定义，操作的时间序列，以及衡量与组织或流程相关的某种聚合指标。在我们的情况下，队列成员将是立法者，时间序列将是每位立法者任职的任期，而感兴趣的指标将是从起始日期起每个周期仍在职的人数的`count`。
- en: 'We’ll start by calculating basic retention, before moving on to examples that
    include various cohort groupings. The first step is to find the first date each
    legislator took office (`first_term`). We will use this date to calculate the
    number of periods for each subsequent date in the time series. To do this, take
    the `min` of the `term_start` and *GROUP BY* each `id_bioguide`, the unique identifier
    for a legislator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从计算基本保持率开始，然后再进入包含各种队列分组示例的部分。第一步是找到每位议员上任的第一个日期(`first_term`)。我们将使用此日期来计算时间序列中每个后续日期的期数。为此，取`term_start`的最小值，并*GROUP
    BY*每个`id_bioguide`，这是每位议员的唯一标识符：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next step is to put this code into a subquery and *JOIN* it to the time
    series. The `age` function is applied to calculate the intervals between each
    `term_start` and the `first_term` for each legislator. Applying the `date_part`
    functions to the result, with year, transforms this into the number of yearly
    periods. Since elections happen every two or six years, we’ll use years as the
    time interval to calculate the `period`s. We could use a shorter interval, but
    in this data set there is little fluctuation daily or weekly. The `count` of legislators
    with records for that period is the number retained:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这段代码放入子查询中，并将其*JOIN*到时间序列中。应用`age`函数计算每个议员的`term_start`和`first_term`之间的间隔。对结果应用`date_part`函数，以年为单位转换为年度周期数。由于选举每两年或六年举行一次，我们将使用年作为计算`period`的时间间隔。我们可以使用更短的间隔，但在这个数据集中，每日或每周的波动很小。对于该周期有记录的议员的`count`是保持数：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'In databases that support the `datediff` function, the `date_part` and `age`
    construction can be replaced by this simpler function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持`datediff`函数的数据库中，可以用这个更简单的函数代替`date_part`和`age`构造：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some databases, such as Oracle, place the `date_part` last:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有些数据库，比如Oracle，将`date_part`放在最后：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have the periods and the number of legislators retained in each,
    the final step is to calculate the total `cohort_size` and populate it in each
    row so that the `cohort_retained` can be divided by it. The `first_value` window
    function returns the first record in the *PARTITION BY* clause, according to the
    ordering set in the *ORDER BY*, a convenient way to get the cohort size in each
    row. In this case, the `cohort_size` comes from the first record in the entire
    data set, so the *PARTITION BY* is omitted:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了期数和每个期数保留的议员数量，最后一步是计算总`cohort_size`并填充到每一行，以便可以将`cohort_retained`除以它。`first_value`窗口函数根据*ORDER
    BY*中设置的顺序返回*PARTITION BY*子句中的第一个记录，这是获取每行中队列大小的便捷方式。在这种情况下，`cohort_size`来自整个数据集中的第一个记录，因此*PARTITION
    BY*被省略：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To find the percent retained, divide the `cohort_retained` value by this same
    calculation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到保持百分比，将`cohort_retained`值除以相同的计算结果：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now have a retention calculation, and we can see that there is a big drop-off
    between the 100% of legislators retained in period 0, or on their start date,
    and the share with another term record that starts a year later. Graphing the
    results, as in [Figure 4-3](#retention_from_start_of_first_term_for), demonstrates
    how the curve flattens and eventually goes to zero, as even the longest-serving
    legislators eventually retire or die.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个保持率的计算，我们可以看到在第0期保留的议员百分比与一年后开始的第二届记录之间有明显的下降。如图[图 4-3](#retention_from_start_of_first_term_for)所示，展示了曲线如何变平，并最终趋近于零，因为即使是任期最长的议员最终也会退休或去世。
- en: '![](Images/sfda_0403.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0403.png)'
- en: Figure 4-3\. Retention from start of first term for US legislators
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3\. 美国议员第一届任期开始后的保持率
- en: 'We can take the cohort retention result and reshape the data to show it in
    table format. Pivot and flatten the results using an aggregate function with a
    CASE statement; `max` is used in this example, but other aggregations such as
    `min` or `avg` would return the same result. Retention is calculated for years
    0 through 4, but additional years can be added by following the same pattern:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将队列保持结果重新整理成表格格式展示。使用带有CASE语句的聚合函数进行数据的旋转和展平；在本例中使用了`max`，但是其他聚合函数如`min`或`avg`将返回相同的结果。保持率计算为0到4年，但可以通过相同的模式添加额外的年份：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Retention appears to be quite low, and from the graph we can see that it is
    jagged in the first few years. One reason for this is that a representative’s
    term lasts two years, and senators’ terms last six years, but the data set only
    contains records for the start of new terms; thus we are missing data for years
    in which a legislator was still in office but did not start a new term. Measuring
    retention each year is misleading in this case. One option is to measure retention
    only on a two- or six-year cycle, but there is also another strategy we can employ
    to fill in the “missing” data. I will cover this next before returning to the
    topic of forming cohort groups.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 保持率似乎相当低，从图表中我们可以看到在最初几年内呈现出锯齿状。造成这种情况的一个原因是代表的任期为两年，而参议员的任期为六年，但数据集只包含新任期的开始记录；因此，我们缺少议员仍在职但未开始新任期的年份的数据。在这种情况下，每年测量保持率是误导性的。一种选择是仅在两年或六年周期内测量保持率，但我们还可以采用另一种策略来填补“缺失”的数据。我将在回到形成队列组之前介绍这一点。
- en: Adjusting Time Series to Increase Retention Accuracy
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整时间序列以提高保持准确性
- en: We discussed techniques for cleaning “missing” data in [Chapter 2](ch02.xhtml#preparing_data_for_analysis),
    and we will turn to those techniques in this section in order to arrive at a smoother
    and more truthful retention curve for the legislators. When working with time
    series data, such as in cohort analysis, it’s important to consider not only the
    data that is present but also whether that data accurately reflects the presence
    or absence of entities at each time period. This is particularly a problem in
    contexts in which an event captured in the data leads to the entity persisting
    for some period of time that is not captured in the data. For example, a customer
    buying a software subscription is represented in the data at the time of the transaction,
    but that customer is entitled to use the software for months or years and is not
    necessarily represented in the data over that span. To correct for this, we need
    a way to derive the span of time in which the entity is still present, either
    with an explicit end date or with knowledge of the length of the subscription
    or term. Then we can say that the entity was present at any date in between those
    start and end dates.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第二章](ch02.xhtml#preparing_data_for_analysis)讨论了清理“缺失”数据的技术，我们将在本节中转向这些技术，以便为议员形成更平滑且更真实的保持曲线。在处理时间序列数据，例如队列分析时，重要的是考虑不仅存在的数据，还要考虑这些数据是否准确地反映了每个时间段内实体的存在或缺失。在数据捕获到的事件导致实体在数据中存在一段未被记录的时间时，这尤其成为问题。例如，客户购买软件订阅在交易时被记录在数据中，但客户有权在几个月或几年内使用该软件，而这段时间不一定在数据中得到体现。为了纠正这一点，我们需要一种方法来推导实体仍然存在的时间跨度，无论是通过明确的结束日期还是知道订阅或任期的长度。然后我们可以说，在这些开始和结束日期之间的任何日期该实体都存在。
- en: In the legislators data set, we have a record for a term’s start date, but we
    are missing the notion that this “entitles” a legislator to serve for two or six
    years, depending on the chamber. To correct for this and smooth out the curve,
    we need to fill in the “missing” values for the years that legislators are still
    in office between new terms. Since this data set includes a `term_end` value for
    each term, I’ll show how to create a more accurate cohort retention analysis by
    filling in dates between the start and end values. Then I’ll show how you can
    impute end dates when the data set does not include an end date.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在议员数据集中，我们有一个记录任期开始日期的记录，但我们缺少这样一个概念，即这个日期“赋予”议员能够在众议院或参议院中任职两年或六年的资格。为了纠正这一点并平滑曲线，我们需要填补议员在新任期之间仍在职的年份的“缺失”数值。由于这个数据集为每个任期都包括一个`term_end`值，我将展示如何通过填补开始和结束值之间的日期来创建更准确的队列保持分析。然后，我将展示如何在数据集不包含结束日期时填补结束日期。
- en: Calculating retention using a start and end date defined in the data is the
    most accurate approach. For the following examples, we will consider legislators
    retained in a particular year if they were still in office as of the last day
    of the year, December 31\. Prior to the Twentieth Amendment to the US Constitution,
    terms began on March 4, but afterward the start date moved to January 3, or to
    a subsequent weekday if the third falls on a weekend. Legislators can be sworn
    in on other days of the year due to special off-cycle elections or appointments
    to fill vacant seats. As a result, `term_start` dates cluster in January but are
    spread across the year. While we could pick another day, December 31 is a strategy
    for normalizing around these varying start dates.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据中定义的开始日期和结束日期来计算保留是最准确的方法。对于以下示例，如果立法者在年底12月31日仍在任职，则视为保留。在美国宪法第二十修正案之前，任期始于3月4日，但之后开始日期移至1月3日，或者如果第三天是周末，则移至随后的工作日。由于特别的非周期性选举或任命以填补空缺席位，立法者可以在一年中的其他日期宣誓就职。因此，`term_start`日期在1月聚集，但在全年范围内分布。虽然我们可以选择另一个日期，但12月31日是围绕这些不同开始日期进行规范化的策略之一。
- en: 'The first step is to create a data set that contains a record for each December
    31 that each legislator was in office. This can be accomplished by *JOIN*ing the
    subquery that found the `first_term` to the `legislators_terms` table to find
    the `term_start` and `term_end` for each term. A second *JOIN* to the `date_dim`
    retrieves the dates that fall between the start and end dates, restricting the
    returned values to `c.month_name = ''December'' and c.day_of_month = 31`. The
    `period` is calculated as the years between the `date` from the `date_dim` and
    the `first_term`. Note that even though more than 11 months may have elapsed between
    being sworn in in January and December 31, the first year still appears as 0:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个数据集，其中包含每位立法者在任的每个12月31日的记录。这可以通过将找到`first_term`的子查询与`legislators_terms`表进行*JOIN*来实现，以查找每个任期的`term_start`和`term_end`。对`date_dim`的第二*JOIN*检索从开始到结束日期之间的日期，限制返回值为`c.month_name
    = 'December'和c.day_of_month = 31`。计算`period`为`date_dim`中的`date`与`first_term`之间的年数。请注意，即使在1月宣誓就职和12月31日之间可能已经过去了超过11个月，第一年仍然显示为0：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If a date dimension is not available, you can create a subquery with the necessary
    dates in a couple of ways. If your database supports the `generate_series`, you
    can create a subquery that returns the desired dates:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有日期维度可用，可以通过几种方式创建包含所需日期的子查询。如果您的数据库支持`generate_series`，可以创建一个子查询来返回所需的日期：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You may want to save this as a table or view for later use. Alternatively,
    you can query the data set or any other table in the database that has a full
    set of dates. In this case, the table has all of the necessary years, but we will
    make a December 31 date for each year using the `make_date` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想把这个保存为一个表或视图以供以后使用。或者，您可以查询数据集或数据库中具有完整日期集的任何其他表。在这种情况下，表中包含所有必要的年份，但我们将使用`make_date`函数为每年创建一个12月31日的日期：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a number of creative ways to get the series of dates needed. Use whichever
    method is available and simplest within your queries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多创造性的方法可以获取所需的日期系列。请使用在查询中可用且最简单的任何方法。
- en: 'We now have a row for each `date` (year end) for which we would like to calculate
    retention. The next step is to calculate the `cohort_retained` for each period,
    which is done with a `count` of `id_bioguide`. A `coalesce` function is used on
    `period` to set a default value of 0 when null. This handles the cases in which
    a legislator’s term starts and ends in the same year, giving credit for serving
    in that year:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们每个`date`（年末）都有一行，我们希望计算保留率。下一步是计算每个期间的`cohort_retained`，使用`id_bioguide`的`count`完成。在`period`上使用`coalesce`函数设置默认值为0时，处理议员在同一年内开始和结束任期的情况，这样便为在该年内服务提供了信用：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The final step is to calculate the `cohort_size` and `pct_retained` as we did
    previously using `first_value` window functions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是像以前一样使用`first_value`窗口函数计算`cohort_size`和`pct_retained`：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The results, graphed in [Figure 4-4](#legislator_retention_after_adjusting_fo),
    are now much more accurate. Almost all legislators are still in office in year
    1, and the first big drop-off occurs in year 2, when some representatives will
    fail to be reelected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过图表显示的[图4-4](#legislator_retention_after_adjusting_fo)的结果更加准确。几乎所有立法者在第1年仍然在任职，而在第2年发生的第一个大幅下降发生在一些代表未能连任时。
- en: '![](Images/sfda_0404.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0404.png)'
- en: Figure 4-4\. Legislator retention after adjusting for actual years in office
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-4\. 调整后的议员任职年限
- en: 'If the data set does not contain an end date, there are a couple of options
    for imputing one. One option is to add a fixed interval to the start date, when
    the length of a subscription or term is known. This can be done with date math
    by adding a constant interval to the `term_start`. Here, a CASE statement handles
    the addition for the two `term_type`s:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据集不包含结束日期，则有几种选项可以补充。一种选项是在已知订阅或任期长度时，将固定的间隔添加到开始日期。这可以通过日期数学通过将恒定间隔添加到`term_start`来完成。在这里，一个CASE语句处理了两种`term_type`的添加：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This block of code can then be plugged into the retention code to derive the
    `period` and `pct_retained`. The drawback to this method is that it fails to capture
    instances in which a legislator did not complete a full term, which can happen
    in the event of death or appointment to a higher office.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块可以随后插入保留代码中以推导出`period`和`pct_retained`。这种方法的缺点在于它未能捕捉到立法者未能完成全任期的情况，这种情况可能出现在死亡或被提升到更高职位的事件中。
- en: 'A second option is to use the subsequent starting date, minus one day, as the
    `term_end` date. This can be calculated with the `lead` window function. This
    function is similar to the `lag` function we’ve used previously, but rather than
    returning a value from a row earlier in the partition, it returns a value from
    a row later in the partition, as determined in the *ORDER BY* clause. The default
    is one row, which we will use here, but the function has an optional argument
    indicating a different number of rows. Here we find the `term_start` date of the
    subsequent term using `lead` and then subtract the interval `''1 day''` to derive
    the `term_end`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选择是使用后续开始日期减去一天作为`term_end`日期。这可以通过`lead`窗口函数计算。这个函数类似于我们之前使用的`lag`函数，但是它不是返回分区中较早的行的值，而是返回分区中较晚的行的值，如*ORDER
    BY*子句所确定。默认是一行，我们将在这里使用这个默认值，但是该函数有一个可选参数指示不同数量的行。在这里，我们使用`lead`找到后续任期的`term_start`日期，然后减去间隔`'1
    day'`来推导出`term_end`：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code block can then be plugged into the retention code. This method has
    a couple of drawbacks. First, when there is no subsequent term, the `lead` function
    returns null, leaving that term without a `term_end`. A default value, such as
    a default interval shown in the last example, could be used in such cases. The
    second drawback is that this method assumes that terms are always consecutive,
    with no time spent out of office. Although most legislators tend to serve continuously
    until their congressional careers end, there are certainly examples of gaps between
    terms spanning several years.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块随后可以插入保留代码中。这种方法有一些缺点。首先，当没有后续任期时，`lead`函数返回空值，使得该任期没有`term_end`。在这种情况下可以使用默认值，如上一个例子中所示的默认间隔。第二个缺点是该方法假设任期总是连续的，没有在职期间的空闲时间。尽管大多数立法者倾向于连续服务，直到他们的国会生涯结束，但确实存在任期之间跨越数年的间隔的例子。
- en: Any time we make adjustments to fill in missing data, we need to be careful
    about the assumptions we make. In subscription- or term-based contexts, explicit
    start and end dates tend to be most accurate. Either of the two other methods
    shown—adding a fixed interval or setting the end date relative to the next start
    date—can be used when no end date is present and we have a reasonable expectation
    that most customers or users will stay for the duration assumed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行填补缺失数据的调整时，必须谨慎对待我们所做的假设。在订阅或期限为基础的情境中，显式的开始和结束日期通常是最准确的。在没有结束日期并且我们合理预期大多数客户或用户将保持所假设的持续时间时，可以使用另外两种方法中的任意一种：添加一个固定的间隔或者相对于下一个开始日期设置结束日期。
- en: Now that we’ve seen how to calculate a basic retention curve and correct for
    missing dates, we can start adding in cohort groups. Comparing retention between
    different groups is one of the main reasons to do cohort analysis. Next, I’ll
    discuss forming groups from the time series itself, and after that, I’ll discuss
    forming cohort groups from data in other tables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何计算基本的保留曲线并纠正缺失日期，我们可以开始添加队列组。比较不同组之间的保留率是进行队列分析的主要原因之一。接下来，我将讨论如何从时间序列本身形成组，并在此之后，我将讨论如何从其他表中的数据形成队列组。
- en: Cohorts Derived from the Time Series Itself
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从时间序列本身派生队列
- en: Now that we have SQL code to calculate retention, we can start to split the
    entities into cohorts. In this section, I will show how to derive cohort groupings
    from the time series itself. First I’ll discuss time-based cohorts based on the
    first date, and I’ll explain how to make cohorts based on other attributes from
    the time series.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了计算保留的SQL代码，我们可以开始将实体分割成队列。在本节中，我将展示如何从时间序列本身推导出队列分组。首先，我将讨论基于第一日期的基于时间的队列，并解释如何基于时间序列的其他属性进行队列分组。
- en: 'The most common way to create the cohorts is based on the first or minimum
    date or time that the entity appears in the time series. This means that only
    one table is necessary for the cohort retention analysis: the time series itself.
    Cohorting by the first appearance or action is interesting because often groups
    that start at different times behave differently. For consumer services, early
    adopters are often more enthusiastic and retain differently than later adopters,
    whereas in SaaS software, later adopters may retain better because the product
    is more mature. Time-based cohorts can be grouped by any time granularity that
    is meaningful to the organization, though weekly, monthly, or yearly cohorts are
    common. If you’re not sure what grouping to use, try running the cohort analysis
    with different groupings, without making the cohort sizes too small, to see where
    meaningful patterns emerge. Fortunately, once you know how to construct the cohorts
    and retention analysis, substituting different time granularities is straightforward.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 建立队列的最常见方式是基于时间序列中实体首次出现的日期或时间。这意味着队列保持分析只需要一个表：时间序列本身。按首次出现或行动进行分组是有趣的，因为通常在不同时间开始的群体表现不同。对于消费者服务，早期采纳者通常更加热情，并且保持方式不同于后来的采纳者；而在SaaS软件中，后期采纳者可能更好地保持，因为产品更加成熟。基于时间的队列可以按照组织中有意义的任何时间粒度进行分组，尽管周、月或年队列是常见的。如果不确定使用何种分组方式，请尝试使用不同的分组运行队列分析，但不要将队列大小设定得太小，以便看到有意义的模式出现。幸运的是，一旦了解如何构建队列和保持分析，替换不同的时间粒度就变得简单了。
- en: The first example will use yearly cohorts, and then I will demonstrate swapping
    in centuries. The key question we will consider is whether the era in which a
    legislator first took office has any correlation with their retention. Political
    trends and the public mood do change over time, but by how much?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子将使用年度队列，然后我将演示如何更换为世纪。我们将考虑的关键问题是，立法者首次就职的时代是否与他们的保留有任何相关性。政治趋势和公众情绪确实会随时间而变化，但变化的幅度是多少呢？
- en: 'To calculate yearly cohorts, we first add the year of the `first_term` calculated
    previously to the query that finds the `period` and `cohort_retained`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算年度队列，我们首先将之前计算的`first_term`的年份添加到查询中，以找到`period`和`cohort_retained`：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This query is then used as the subquery, and the `cohort_size` and `pct_retained`
    are calculated in the outer query as previously.  In this case, however, we need
    a *PARTITION BY* clause that includes `first_year` so that the `first_value` is
    calculated only within the set of rows for that `first_year`, rather than across
    the whole result set from the subquery:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此查询用作子查询，并像以前一样在外部查询中计算`cohort_size`和`pct_retained`。但是，在这种情况下，我们需要一个*PARTITION
    BY*子句，其中包括`first_year`，以便`first_value`仅在该`first_year`的行集内计算，而不是在子查询的整个结果集中计算：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This data set includes over two hundred starting years, too many to easily
    graph or examine in a table. Next we’ll look at a less granular interval and cohort
    the legislators by the century of the `first_term`. This change is easily made
    by substituting `century` for `year` in the `date_part` function in subquery `aa`.
    Recall that century names are offset from the years they represent, so that the
    18th century lasted from 1700 to 1799, the 19th century lasted from 1800 to 1899,
    and so on. The partitioning in the `first_value` function changes to the `first_century`
    field:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集包含两百多个起始年份，过多无法轻松绘制或在表中检查。接下来，我们将以较少的粒度间隔查看，并将立法者按其`first_term`的世纪进行队列分组。这一变更通过在子查询`aa`中将`date_part`函数中的`year`替换为`century`轻松完成。请记住，世纪名称与它们所代表的年份有所偏移，因此18世纪从1700年到1799年，19世纪从1800年到1899年，依此类推。在`first_value`函数中的分区更改为`first_century`字段：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The results are graphed in [Figure 4-5](#legislator_retention_by_century_in_whic).
    Retention in the early years has been higher for those first elected in the 20th
    or 21st century. The 21st century is still underway, and thus many of those legislators
    have not had the opportunity to stay in office for five or more years, though
    they are still included in the denominator. We might want to consider removing
    the 21st century from the analysis, but I’ve left it here to demonstrate how the
    retention curve drops artificially due to this circumstance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在 [图 4-5](#legislator_retention_by_century_in_whic) 中进行了图表化。在早期年代，首次当选于20世纪或21世纪的人员的保留率较高。21世纪仍在进行中，因此许多这些立法者还没有机会在任职五年或更长时间，尽管他们仍然包含在分母中。我们可能需要考虑从分析中排除21世纪，但我保留它在这里以展示由于这种情况而导致的保留曲线的人为下降。
- en: '![](Images/sfda_0405.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0405.png)'
- en: Figure 4-5\. Legislator retention by century in which first term began
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. 按首次任期开始世纪保留的立法者
- en: Cohorts can be defined from other attributes in a time series besides the first
    date, with options depending on the values in the table. The `legislators_terms`
    table has a `state` field, indicating which state the person is representing for
    that term. We can use this to create cohorts, and we will base them on the first
    state in order to ensure that anyone who has represented multiple states appears
    in the data only once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个日期外，时间序列中的队列可以根据表格中的值来定义。 `legislators_terms` 表格具有 `state` 字段，指示该任期中人员所代表的州。我们可以利用这一点创建队列，并且将它们基于第一个州以确保任何代表多个州的人员仅在数据中出现一次。
- en: Warning
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When cohorting on an attribute that can change over time, it’s important to
    ensure that each entity is assigned only one value. Otherwise the entity may be
    represented in multiple cohorts, introducing bias into the analysis. Usually the
    value from the earliest record in the data set is used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个随时间变化的属性上进行队列处理时，确保每个实体只分配一个值非常重要。否则，该实体可能会出现在多个队列中，从而引入分析中的偏差。通常使用数据集中最早记录的值来确定队列。
- en: 'To find the first state for each legislator, we can use the `first_value` window
    function. In this example, we’ll also turn the `min` function into a window function
    to avoid a lengthy *GROUP BY* clause:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到每位立法者的第一个州，我们可以使用 `first_value` 窗口函数。在这个例子中，我们还将 `min` 函数转换为窗口函数，以避免冗长的 *GROUP
    BY* 子句：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can then plug this code into our retention code to find the retention by
    `first_state`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将此代码插入我们的保留代码中，以查找按`first_state`保留的情况：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The retention curves for the five states with the highest total number of legislators
    are graphed in [Figure 4-6](#legislator_retention_by_first_state_top). Those elected
    in Illinois and Massachusetts have the highest retention, while New Yorkers have
    the lowest retention. Determining the reasons why would be an interesting offshoot
    of this analysis.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对具有最高总立法者数的五个州的保留曲线进行了图表化，参见 [图 4-6](#legislator_retention_by_first_state_top)。伊利诺伊州和马萨诸塞州的当选者保留率最高，而纽约州的保留率最低。确定原因将是这项分析的一个有趣的分支。
- en: '![](Images/sfda_0406.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0406.png)'
- en: 'Figure 4-6\. Legislator retention by first state: top five states by total
    legislators'
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-6\. 按首个州保留的立法者：按总立法者数前五个州
- en: Defining cohorts from the time series is relatively straightforward using a
    `min` date for each entity and then converting that date into a month, year, or
    century as appropriate for the analysis. Switching between month and year or other
    levels of granularity also is straightforward, allowing for multiple options to
    be tested in order to find a grouping that is meaningful for the organization.
    Other attributes can be used for cohorting with the `first_value` window function.
    Next, we’ll turn to cases in which the cohorting attribute comes from a table
    other than that of the time series.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `min` 日期为每个实体定义时间序列中的队列相对简单，然后根据分析的适当性将该日期转换为月份、年份或世纪。在粒度之间进行切换也很简单，允许测试多个选项以找到对组织有意义的分组方式。其他属性可以与
    `first_value` 窗口函数一起用于队列化。接下来，我们将转向队列属性来自时间序列之外的表格的情况。
- en: Defining the Cohort from a Separate Table
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从单独的表格定义队列
- en: Often the characteristics that define a cohort exist in a table separate from
    the one that contains the time series. For example, a database might have a customer
    table with information such as acquisition source or registration date by which
    customers can be cohorted. Adding in attributes from other tables, or even subqueries,
    is relatively straightforward and can be done in retention analysis and related
    analyses discussed later in the chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 经常定义队列的特征存在于与包含时间序列不同的表中。例如，数据库可能具有客户表，其中包含客户可以按获取来源或注册日期进行分组的信息。从其他表或甚至子查询添加属性相对简单，并且可以在保留分析及本章后续讨论的相关分析中完成。
- en: 'For this example, we’ll consider whether the gender of the legislator has any
    impact on their retention. The `legislators` table has a `gender` field, where
    F means female and M means male, that we can use to cohort the legislators. To
    do this, we’ll *JOIN* the `legislators` table in as alias `d` to add `gender`
    to the calculation of `cohort_retained`, in place of year or century:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例，我们将考虑立法者的性别是否对其保留率有影响。`legislators`表具有`gender`字段，其中F表示女性，M表示男性，我们可以使用它来对立法者进行分组。为此，我们将*JOIN*
    `legislators`表作为别名`d`，以将`gender`添加到`cohort_retained`的计算中，取代年份或世纪：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It’s immediately clear that many more males than females have served legislative
    terms. We can now calculate the `percent_retained` so we can compare the retention
    for these groups:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 立法任期中服务的男性比女性明显更多。现在我们可以计算`percent_retained`，以便比较这些群体的保留率：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see from the results graphed in [Figure 4-7](#legislator_retention_by_gender)
    that retention is higher for female legislators than for their male counterparts
    for periods 2 through 29\. The first female legislator did not take office until
    1917, when Jeannette Rankin joined the House as a Republican representative from
    Montana. As we saw earlier, retention has increased in more recent centuries.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从图[4-7](#legislator_retention_by_gender)的结果中看出，与其男性对手相比，女性立法者在第2到第29期间的保留率更高。第一位女性立法者直到1917年才上任，当时Jeannette
    Rankin作为来自蒙大拿州的共和党代表加入了众议院。正如我们之前看到的，保留率在更近的世纪有所增加。
- en: '![](Images/sfda_0407.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0407.png)'
- en: Figure 4-7\. Legislator retention by gender
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-7\. 按性别分类的立法者保留率
- en: 'To make a more fair comparison, we might restrict the legislators included
    in the analysis to only those whose `first_term` started since there have been
    women in Congress. We can do this by adding a *WHERE* filter to subquery `aa`.
    Here the results are also restricted to those who started before 2000, to ensure
    the cohorts have had at least 20 possible years to stay in office:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行更公平的比较，我们可以限制分析中包含的立法者仅限于那些自国会有女性以来开始任职的人。我们可以通过向子查询`aa`添加*WHERE*过滤器来实现这一点。在这里，结果也限制为那些在2000年之前开始的人，以确保队列至少有20年的可能留任时间：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Male legislators still outnumber female legislators, but by a smaller margin.
    The retention for the cohorts is graphed in [Figure 4-8](#legislator_retention_by_gender_cohorts).
    With the revised cohorts, male legislators have higher retention through year
    7, but starting in year 12, female legislators have higher retention. The difference
    between the two gender-based cohort analyses underscores the importance of setting
    up appropriate cohorts and ensuring that they have comparable amounts of time
    to be present or complete other actions of interest. To further improve this analysis,
    we could cohort by both starting year or decade *and* gender, in order to control
    for additional changes in retention through the 20th century and into the 21st
    century.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 男性立法者仍然比女性立法者人数多，但差距较小。队列的保留率见图[4-8](#legislator_retention_by_gender_cohorts)。在修订后的队列中，男性立法者在第7年之前有更高的保留率，但从第12年开始，女性立法者的保留率更高。这两种基于性别的队列分析的差异突显了设置适当的队列和确保它们具有相同时间量来参加或完成其他感兴趣行动的重要性。为了进一步改进此分析，我们可以按照起始年或十年以及性别进行队列分析，以控制20世纪和21世纪初的保留率的额外变化。
- en: '![](Images/sfda_0408.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0408.png)'
- en: 'Figure 4-8\. Legislator retention by gender: cohorts from 1917 to 1999'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-8\. 按性别分类的立法者保留率：1917年至1999年的队列
- en: Cohorts can be defined in multiple ways, from the time series and from other
    tables. With the framework we’ve developed, subqueries, views, or other derived
    tables can be swapped in, opening up a whole range of calculations to be the basis
    of a cohort. Multiple criteria, such as starting year and gender, can be used.
    One caution when dividing populations into cohorts based on multiple criteria
    is that this can lead to sparse cohorts, where some of the defined groups are
    too small and are not represented in the data set for all time periods. The next
    section will discuss methods for overcoming this challenge.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Cohorts 可以通过时间序列和其他表格的方式定义。通过我们开发的框架，可以替换子查询、视图或其他派生表，从而打开一整套计算作为 cohort 基础的可能性。可以使用多个标准，比如起始年份和性别。将人群根据多个标准分为
    cohort 时需要注意的是，这可能导致稀疏的 cohort，即某些定义的组在所有时间段的数据集中太小，无法代表所有时间段。接下来的部分将讨论克服这一挑战的方法。
- en: Dealing with Sparse Cohorts
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理稀疏 cohort
- en: In the ideal data set, every cohort has some action or record in the time series
    for every period of interest. We’ve already seen how “missing” dates can occur
    due to subscriptions or terms lasting over multiple periods, and we looked at
    how to correct for them using a date dimension to infer intermediate dates. Another
    issue can arise when, due to grouping criteria, the cohort becomes too small and
    as a result is represented only sporadically in the data. A cohort may disappear
    from the result set, when we would prefer it to appear with a zero retention value.
    This problem is called *sparse cohorts*, and it can be worked around with the
    careful use of *LEFT JOIN*s.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的数据集中，每个 cohort 在所有感兴趣的期间都有一些操作或记录。我们已经看到由于订阅或任期跨越多个期间而可能出现“缺失”日期的情况，以及如何使用日期维度来推断中间日期进行校正。另一个问题可能是，由于分组标准，cohort
    变得太小，结果数据中只偶尔出现。当 cohort 消失在结果集中时，我们希望它以零的留任值出现而不是空值。这个问题称为 *稀疏 cohort*，可以通过谨慎使用
    *LEFT JOIN* 来解决。
- en: 'To demonstrate this, let’s attempt to cohort female legislators by the first
    state they represented to see if there are any differences in retention. We’ve
    already seen that there have been relatively few female legislators. Cohorting
    them further by state is highly likely to create some sparse cohorts in which
    there are very few members. Before making code adjustments, let’s add `first_state`
    (calculated in the section on deriving cohorts from the time series) into our
    previous gender example and look at the results:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们尝试通过首次代表的州来对女性立法者进行 cohort，看看留任情况是否有所不同。我们已经看到女性立法者相对较少。进一步按州对他们进行
    cohort 很可能会创建一些稀疏的 cohort，其中成员非常少。在进行代码调整之前，让我们将 `first_state`（在从时间序列派生 cohort
    的部分计算）添加到之前的性别示例中，并查看结果：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Graphing the results for the first 20 periods, as in [Figure 4-9](#legislator_retention_by_gender_and_firs),
    reveals the sparse cohorts. Alaska did not have any female legislators, while
    Arizona’s female retention curve disappears after year 3\. Only California, a
    large state with many legislators, has complete retention curves for both genders.
    This pattern repeats for other small and large states.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制前 20 个期间的结果，例如 [图 4-9](#legislator_retention_by_gender_and_firs)，显示了这些稀疏的
    cohort。阿拉斯加没有女性立法者，而亚利桑那州的女性留任曲线在第三年后消失。只有加利福尼亚州，一个有很多议员的大州，两性都有完整的留任曲线。其他小州和大州的情况也如此。
- en: '![](Images/sfda_0409.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0409.png)'
- en: Figure 4-9\. Legislator retention by gender and first state
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-9. 按性别和首个州的立法者留任
- en: 'Now let’s look at how to ensure a record for every period so that the query
    returns zero values for retention instead of nulls. The first step is to query
    for all combinations of `period`s and cohort attributes, in this case `first_state`
    and `gender`, with the starting `cohort_size` for each combination. This can be
    done by *JOIN*ing subquery `aa`, which calculates the cohort, with a `generate_series`
    subquery that returns all integers from 0 to 20, with the criteria `on 1 = 1`.
    This is a handy way to force a Cartesian *JOIN* when the two subqueries don’t
    have any fields in common:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何确保每个期间都有记录，以便查询在留任的情况下返回零值而不是空值。第一步是查询所有 `period` 和 cohort 属性的组合，例如
    `first_state` 和 `gender`，每个组合的起始 `cohort_size`。这可以通过将计算 cohort 的子查询 `aa` 与生成一个从
    0 到 20 的整数的子查询进行 *JOIN*，条件为 `on 1 = 1` 来完成。这是强制进行笛卡尔 *JOIN* 的便捷方式，当两个子查询没有共同字段时非常有用。
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to *JOIN* this back to the actual periods in office, with
    a *LEFT JOIN* to ensure all the time periods remain in the final result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将此与实际任期中的时间段进行*JOIN*，并使用*LEFT JOIN*确保所有时间段都保留在最终结果中：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then pivot the results and confirm that a value exists for each cohort
    for each period:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以旋转结果，并确认每个周期中每个人群都存在一个值：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that at this point, the SQL code has gotten quite long. One of the harder
    parts of writing SQL for cohort retention analysis is keeping all of the logic
    straight and the code organized, a topic I’ll discuss more in [Chapter 8](ch08.xhtml#creating_complex_data_sets_for_analysis).
    When building up retention code, I find it helpful to go step-by-step, checking
    results along the way. I also spot-check individual cohorts to validate that the
    final result is accurate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此时SQL代码已变得非常长。编写用于人群留存分析的SQL的较难部分之一是保持所有逻辑清晰和代码组织良好，这是我将在[第8章](ch08.xhtml#creating_complex_data_sets_for_analysis)中进一步讨论的主题。在构建留存代码时，逐步进行检查结果并逐步进行，对个别人群进行抽样检查，以验证最终结果的准确性，我发现这非常有帮助。
- en: Cohorts can be defined in many ways. So far, we’ve normalized all our cohorts
    to the first date they appear in the time series data. This isn’t the only option,
    however, and interesting analysis can be done starting in the middle of an entity’s
    life span. Before concluding our work on retention analysis, let’s take a look
    at this additional way to define cohorts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 人群可以用多种方式定义。到目前为止，我们已将所有人群标准化为时间序列数据中首次出现的日期。然而，这并不是唯一的选择，从实体寿命中段开始进行有趣的分析也是可以的。在结束我们对留存分析的工作之前，让我们看看这另一种定义人群的方式。
- en: Defining Cohorts from Dates Other Than the First Date
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从非首次日期定义人群
- en: Usually time-based cohorts are defined from the entity’s first appearance in
    the time series or from some other earliest date, such as a registration date.
    However, cohorting on a different date can be useful and insightful. For example,
    we might want to look at retention across all customers using a service as of
    a particular date. This type of analysis can be used to understand whether product
    or marketing changes have had a long-term impact on existing customers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于时间的人群是从实体在时间序列中首次出现或从某些其他最早日期（如注册日期）开始定义的。然而，基于不同日期的人群分析也可能非常有用和深刻。例如，我们可能想要查看在特定日期之前使用服务的所有客户的留存情况。这种类型的分析可以用来了解产品或营销变化是否对现有客户产生了长期影响。
- en: When using a date other than the first date, we need to take care to precisely
    define the criteria for inclusion in each cohort. One option is to pick entities
    present on a particular calendar date. This is relatively straightforward to put
    into SQL code, but it can be problematic if a large share of the regular user
    population doesn’t show up every day, causing retention to vary depending on the
    exact day chosen. One option to correct for this is to calculate retention for
    several starting dates and then average the results.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用非首次日期时，我们需要确切地定义每个人群包含的标准。一种选择是选择在特定日历日期出现的实体。这在SQL代码中相对直接，但如果大部分常规用户不是每天都出现，会导致留存率取决于选择的确切日期，这可能会出现问题。一个纠正这个问题的选择是计算几个起始日期的留存率，然后平均结果。
- en: Another option is to use a window of time such as a week or month. Any entity
    that appears in the data set during that window is included in the cohort. While
    this approach is often more representative of the business or process, the trade-off
    is that the SQL code will become more complex, and the query time may be slower
    due to more intense database calculations. Finding the right balance between query
    performance and accuracy of results is something of an art.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用一段时间窗口，如一周或一个月。在该窗口内出现在数据集中的任何实体都包含在人群中。虽然这种方法通常更能代表业务或过程，但折衷之处在于SQL代码将变得更加复杂，而查询时间可能会变慢，因为数据库计算更为密集。在查询性能和结果准确性之间找到合适的平衡是一门艺术。
- en: 'Let’s take a look at how to calculate such midstream analysis with the legislators
    data set by considering retention for legislators who were in office in the year
    2000\. We’ll cohort by the `term_type`, which has values of “sen” for senators
    and “rep” for representatives. The definition will include any legislator in office
    at any time during the year 2000: those who started prior to 2000 and whose terms
    ended during or after 2000 qualify, as do those who started a term in 2000\. We
    can hardcode any date in 2000 as the `first_term`, since we will later check whether
    they were in office at some point during 2000\. The `min_start` of the terms falling
    in this window is also calculated for use in a later step:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过考虑在2000年任职的立法者数据集来计算此类中期分析。我们将按`term_type`对其进行队列化，“sen”表示参议员，“rep”表示代表。定义将包括在2000年任何时间内任职的任何立法者：在2000年之前开始并在2000年期间或之后结束其任期的人符合条件，以及在2000年开始任期的人。我们可以硬编码2000年的任何日期作为`first_term`，因为稍后我们将检查他们是否在2000年任职。也计算了此窗口内任期的`min_start`，以便在后续步骤中使用：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then plug this into our retention code, with two adjustments. First,
    an additional *JOIN* criteria between subquery `a` and the `legislators_terms`
    table is added in order to return only terms that started on or after the `min_start`
    date. Second, an additional filter is added to the `date_dim` so that it only
    returns `date`s in 2000 or later:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此插入我们的保持代码中，并进行两个调整。首先，在子查询`a`和`legislators_terms`表之间添加了一个额外的*JOIN*条件，以便仅返回从`min_start`日期开始或之后开始的任期。其次，在`date_dim`中添加了一个额外的过滤器，以便仅返回2000年或之后的日期：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Figure 4-10](#retention_by_term_type_for_legislators) shows that despite longer
    terms for senators, retention among the two cohorts was similar, and was actually
    worse for senators after 10 years. A further analysis comparing the different
    years they were first elected, or other cohort attributes, might yield some interesting
    insights.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-10](#retention_by_term_type_for_legislators)显示，尽管参议员任期较长，两个队列的保持率相似，在超过10年后，参议员的保持率实际上更低。进一步分析比较它们首次当选的不同年份或其他队列属性可能会得出一些有趣的见解。'
- en: '![](Images/sfda_0410.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0410.png)'
- en: Figure 4-10\. Retention by term type for legislators in office during the year
    2000
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-10\. 2000年在任立法者的任期类型保持率
- en: A common use case for cohorting on a value other than a starting value is when
    trying to analyze retention after an entity has reached a threshold, such as a
    certain number of purchases or a certain amount spent. As with any cohort, it’s
    important to take care in defining what qualifies an entity to be in a cohort
    and which date will be used as the starting date.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了起始值之外的值上的队列常见用例是当试图分析实体达到阈值后的保持，例如一定数量的购买或一定金额的花费。与任何队列一样，定义什么条件使实体成为队列成员以及将用作起始日期的日期非常重要。
- en: 'Cohort retention is a powerful way to understand the behavior of entities in
    a time series data set. We’ve seen how to calculate retention with SQL and how
    to cohort based on the time series itself or on other tables, and from points
    in the middle of entity life span. We also looked at how to use functions and
    *JOIN*s to adjust dates within time series and compensate for sparse cohorts.
    There are several types of analyses that are related to cohort retention: analysis,
    survivorship, returnship, and cumulative calculations, all of which build off
    of the SQL code that we’ve developed for retention. Let’s turn to them next.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 队列保持是了解时间序列数据集中实体行为的强大方法。我们已经看到了如何使用SQL计算保持以及如何基于时间序列本身或其他表进行队列化，以及在实体生命周期中的中间点。我们还研究了如何使用函数和*JOIN*来调整时间序列中的日期，并补偿稀疏队列。与队列保持相关的分析有几种类型：分析、存活率、回报率和累积计算，这些都是我们为保持开发的SQL代码的基础。让我们接下来看看它们。
- en: Related Cohort Analyses
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关队列分析
- en: In the last section, we learned how to write SQL for cohort retention analysis.
    Retention captures whether an entity was in a time series data set on a specific
    date or window of time. In addition to presence on a specific date, analysis is
    often interested in questions of how long an entity lasted, whether an entity
    did multiple actions, and how many of those actions occurred. These can all be
    answered with code that is similar to retention and is well suited to just about
    any cohorting criteria you like. Let’s take a look at the first of these, survivorship.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何为队列保留分析编写SQL。保留分析捕捉了一个实体是否在特定日期或时间窗口内的时间序列数据集中。除了在特定日期的存在之外，分析通常还关心实体持续存在的时间长短，以及实体是否执行了多个动作以及这些动作的数量。可以使用类似于保留的代码来回答所有这些问题，并且非常适合于您喜欢的任何队列标准。让我们先看看这些中的第一个，生存率。
- en: Survivorship
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生存率
- en: '*Survivorship*, also called *survival analysis*, is concerned with questions
    about how long something lasts, or the duration of time until a particular event
    such as churn or death. Survivorship analysis can answer questions about the share
    of the population that is likely to remain past a certain amount of time. Cohorts
    can help identify or at least provide hypotheses about which characteristics or
    circumstances increase or decrease the survival likelihood.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*生存率*，也称为*生存分析*，涉及到持续存在多长时间的问题，或者直到特定事件（如流失或死亡）发生的时间长度。生存分析可以回答关于群体中有多少比例可能会在某个时间点之后继续存在的问题。队列可以帮助识别或至少提供关于哪些特征或情况会增加或减少生存可能性的假设。'
- en: This is similar to a retention analysis, but instead of calculating whether
    an entity was present in a certain period, we calculate whether the entity is
    present in that period or later in the time series. Then the share of the total
    cohort is calculated. Typically one or more periods are chosen depending on the
    nature of the data set analyzed. For example, if we want to know the share of
    game players who survive for a week or longer, we can check for actions that occur
    after a week from starting and consider those players still surviving. On the
    other hand, if we are concerned about the number of students who are still in
    school after a certain number of years, we could look for the absence of a graduation
    event in a data set. The number of periods can be *SELECT*ed either by calculating
    an average or typical life span or by choosing time periods that are meaningful
    to the organization or process analyzed, such as a month, year, or longer time
    period.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于保留分析，但不是计算实体是否在特定时期存在，而是计算实体是否在该时期或后来的时间序列中存在。然后计算总队列的份额。通常根据分析的数据集性质选择一个或多个期间。例如，如果我们想知道在一周或更长时间内存活的游戏玩家的份额，我们可以检查从开始后一周发生的动作，并考虑那些仍然存活的玩家。另一方面，如果我们关心在一定年限后仍在校的学生人数，我们可以在数据集中寻找毕业事件的缺失。可以通过计算平均寿命或典型寿命来*SELECT*一个或多个期间，或者选择对组织或分析过程有意义的时间期间，如一个月、一年或更长时间期间。
- en: 'In this example, we’ll look at the share of legislators who survived in office
    for a decade or more after their first term started. Since we don’t need to know
    the specific dates of each term, we can start by calculating the first and last
    `term_start` dates, using `min` and `max` aggregations:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将看看在其第一任期开始后存活了十年或更长时间的立法者的份额。由于我们不需要知道每个任期的具体日期，我们可以先计算第一个和最后一个`term_start`日期，使用`min`和`max`聚合：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we add to the query a `date_part` function to find the century of the
    `min term_start`, and we calculate the `tenure` as the number of years between
    the `min` and `max term_start`s found with the `age` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在查询中添加一个`date_part`函数来找到`min term_start`的世纪，并使用`age`函数计算`tenure`，作为`min`和`max
    term_start`之间年数的数量：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we calculate the `cohort_size` with a `count` of all the legislators,
    as well as calculating the number who survived for at least 10 years by using
    a CASE statement and `count` aggregation. The percent who survived is found by
    dividing these two values:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`count`计算所有立法者的`cohort_size`，并使用CASE语句和`count`聚合计算至少存活10年的人数。通过将这两个值相除，可以找到存活的百分比：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since terms may or may not be consecutive, we can also calculate the share
    of legislators in each century who survived for five or more total terms. In the
    subquery, add a `count` to find the total number of terms per legislator. Then
    in the outer query, divide the number of legislators with five or more terms by
    the total cohort size:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于术语可能连续也可能不连续，我们还可以计算每个世纪在议员中生存了五个或更多任期的比例。在子查询中，添加一个`count`以找到每位议员的总任期数。然后在外部查询中，将有五个或更多任期的议员数除以总队列大小：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Ten years or five terms is somewhat arbitrary. We can also calculate the survivorship
    for each number of years or periods and display the results in graph or table
    form. Here, we calculate the survivorship for each number of terms from 1 to 20\.
    This is accomplished through a Cartesian *JOIN* to a subquery that contains those
    integers derived by the `generate_series` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 十年或五个任期有些随意。我们还可以计算每个年份或期间的存活率，并以图表或表格形式显示结果。在这里，我们计算了从1到20个任期的存活率。这通过与包含由`generate_series`函数生成的整数的子查询的笛卡尔*JOIN*来实现：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The results are graphed in [Figure 4-11](#survivorship_for_legislators_share_of_c).
    Survivorship was highest in the 20th century, a result that agrees with results
    we saw previously in which retention was also highest in the 20th century.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在[图4-11](#survivorship_for_legislators_share_of_c)中绘制出来。存活率在20世纪最高，这与我们先前看到的保留率在20世纪也最高的结果一致。
- en: '![](Images/sfda_0411.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0411.png)'
- en: 'Figure 4-11\. Survivorship for legislators: share of cohort who stayed in office
    for that many terms or longer'
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-11。议员的存活率：在任职了那么多个任期或更长时间的群体的份额。
- en: Survivorship is closely related to retention. While retention counts entities
    present in a specific number of periods from the start, survivorship considers
    only whether an entity was present as of a specific period or later. As a result,
    the code is simpler since it needs only the first and last dates in the time series,
    or a count of dates. Cohorting is done similar to cohorting for retention, and
    cohort definitions can come from within the time series or be derived from another
    table or subquery.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 存活率与保留率密切相关。而保留率计算的是在从开始计算的特定期间内存在的实体数，存活率只考虑实体是否在特定期间或更晚时作为存在。因此，代码更简单，因为它只需要时间序列中的第一个和最后一个日期，或日期的计数。与保留率的分组类似于保留率的分组，群体定义可以来自时间序列内部，也可以来自另一个表或子查询中。
- en: Next we’ll consider another type of analysis that is in some ways the inverse
    of survivorship. Rather than calculating whether an entity is present in the data
    set at a certain time or later, we will calculate whether an entity returns or
    repeats an action at a certain period or earlier. This is called returnship or
    repeat purchase behavior.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将考虑另一种在某些方面与存活率相反的分析类型。与其计算实体在数据集中是否在某一特定时间或更晚存在，我们将计算实体是否在某一特定时间段或更早时返回或重复某个动作。这被称为返回率或重复购买行为。
- en: Returnship, or Repeat Purchase Behavior
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Returnship，或者重复购买行为。
- en: Survivorship is useful for understanding how long a cohort is likely to stick
    around. Another useful type of cohort analysis seeks to understand whether a cohort
    member can be expected to return within a given window of time and the intensity
    of activity during that window. This is called *returnship* or *repeat purchase
    behavior*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 存活率对于理解一个群体可能会留下多长时间很有用。另一种有用的群体分析类型旨在了解一个群体成员在给定时间窗口内是否可以预期返回以及在该窗口期间的活动强度。这被称为*返回率*或*重复购买行为*。
- en: For example, an ecommerce site might want to know not only how many new buyers
    were acquired via a marketing campaign but also whether those buyers have become
    repeat buyers. One way to figure this out is to simply calculate total purchases
    per customer. However, comparing customers acquired two years ago with those acquired
    a month ago isn’t fair, since the former have had a much longer time in which
    to return. The older cohort would almost certainly appear more valuable than the
    newer one. Although this is true in a sense, it gives an incomplete picture of
    how the cohorts are likely to behave across their entire life span.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个电子商务网站可能想要知道通过营销活动获得了多少新买家，以及这些买家是否成为了重复购买者。解决这个问题的一种方法是简单地计算每位客户的总购买次数。然而，比较两年前获得的客户和一个月前获得的客户并不公平，因为前者有更长的时间来回购。老一批人几乎肯定比新一批看起来更有价值。虽然在某种意义上这是正确的，但这并没有完全展示出各个群体在整个生命周期内的行为方式。
- en: To make fair comparisons between cohorts with different starting dates, we need
    to create an analysis based on a *time box*, or a fixed window of time from the
    first date, and consider whether cohort members returned within that window. This
    way, every cohort has an equal amount of time under consideration, so long as
    we include only those cohorts for which the full window has elapsed. Returnship
    analysis is common for retail organizations, but it can also be applied in other
    domains. For example, a university might want to see how many students enrolled
    in a second course, or a hospital might be interested in how many patients need
    follow-up medical treatments after an initial incident.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不同起始日期的队列之间进行公平比较，我们需要基于*时间窗口*或从第一个日期开始的固定时间窗口创建分析，并考虑队列成员是否在该窗口内返回。这样，只要我们仅包括那些完整窗口已过去的队列，每个队列就有相同的考虑时间。在零售组织中，回归分析很常见，但也可以应用在其他领域。例如，大学可能想要了解有多少学生在第二门课程中注册，医院可能对初次事件后需要进行后续医疗治疗的患者感兴趣。
- en: 'To demonstrate returnship analysis, we can ask a new question of the legislators
    data set: how many legislators have more than one term type, and specifically,
    what share of them start as representatives and go on to become senators (some
    senators later become representatives, but that is much less common). Since relatively
    few make this transition, we’ll cohort legislators by the century in which they
    first became a representative.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示回归分析，我们可以对立法者数据集提出一个新问题：有多少立法者拥有多个任期类型，具体而言，有多少人从代表开始，最终成为参议员（有些参议员后来成为代表，但这种情况较少见）。由于这种转变的人数相对较少，我们将立法者按其首次成为代表的世纪进行分类。
- en: 'The first step is to find the cohort size for each century, using the subquery
    and `date_part` calculations seen previously, for only those with `term_type =
    ''rep''`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是找出每个世纪的队列规模，仅使用`term_type = 'rep'`的子查询和之前看到的`date_part`计算：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next we’ll perform a similar calculation, with a *JOIN* to the `legislators_terms`
    table, to find the representatives who later became senators. This is accomplished
    with the clauses `b.term_type = ''sen''` and `b.term_start > a.first_term`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行类似的计算，通过与`legislators_terms`表的*JOIN*来查找后来成为参议员的代表。这通过`b.term_type =
    'sen'`和`b.term_start > a.first_term`子句来实现：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we *JOIN* these two subqueries together and calculate the percent
    of representatives who became senators. A *LEFT JOIN* is used; this clause is
    typically recommended to ensure that all cohorts are included whether or not the
    subsequent event happened. If there is a century in which no representatives became
    senators, we still want to include that century in the result set:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们*JOIN*这两个子查询并计算成为参议员的代表的百分比。使用*LEFT JOIN*通常建议使用这个子句，以确保所有队列都被包含，无论是否发生了随后的事件。如果某个世纪没有代表成为参议员，我们仍然希望将该世纪包含在结果集中：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Representatives from the 18th century were most likely to become senators.
    However, we have not yet applied a time box to ensure a fair comparison. While
    we can safely assume that all legislators who served in the 18th and 19th centuries
    are no longer living, many of those who were first elected in the 20th and 21st
    centuries are still in the middle of their careers. Adding the filter `WHERE age(c.term_start,
    b.first_term) <= interval ''10 years''` to subquery `bb` creates a time box of
    10 years. Note that the window can easily be made larger or smaller by changing
    the constant in the interval. An additional filter applied to subquery `a`, `WHERE
    first_term <= ''2009-12-31''`, excludes those who were less than 10 years into
    their careers when the data set was assembled:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 18世纪的代表最有可能成为参议员。然而，我们尚未应用时间窗口来确保公平比较。尽管我们可以安全地假设所有在18世纪和19世纪服务过的立法者现已不再生存，但许多首次当选于20世纪和21世纪的人仍处于事业的中期。将过滤器`WHERE
    age(c.term_start, b.first_term) <= interval '10 years'`添加到子查询`bb`中可以创建一个10年的时间窗口。请注意，通过更改间隔中的常数，可以轻松地调整窗口的大小。附加到子查询`a`的额外过滤器`WHERE
    first_term <= '2009-12-31'`排除了在数据集汇编时事业不足10年的人：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this new adjustment, the 18th century still had the highest share of representatives
    becoming senators within 10 years, but the 21st century has the second-highest
    share, and the 20th century had a higher share than the 19th.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种新调整后，18世纪仍然拥有最高比例的代表在10年内成为参议员，但21世纪的比例排名第二，20世纪的比例高于19世纪。
- en: 'Since 10 years is somewhat arbitrary, we might also want to compare several
    time windows. One option is to run the query several times with different intervals
    and note the results. Another option is to calculate multiple windows in the same
    result set by using a set of CASE statements inside of `count distinct` aggregations
    to form the intervals, rather than specifying the interval in the *WHERE* clause:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于10年有些随意，我们可能还想比较几个时间窗口。一种选择是多次运行查询，并注意结果。另一种选择是通过在`count distinct`聚合内使用一组CASE语句来形成间隔，而不是在*WHERE*子句中指定间隔：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With this output, we can see how the share of representatives who became senators
    evolved over time, both within each cohort and across cohorts. In addition to
    the table format, graphing the output often reveals interesting trends. In [Figure 4-12](#trend_of_the_share_of_representatives_f),
    the cohorts based on century are replaced with cohorts based on the first decade,
    and the trends over 10 and 20 years are shown. Conversion of representatives to
    senators during the first few decades of the new US legislature was clearly different
    from patterns in the years since.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个输出，我们可以看到代表成为参议员的份额随时间的演变，无论是在每个群体内部还是跨群体之间。除了表格格式外，将输出图形化通常会显示出有趣的趋势。在[图4-12](#trend_of_the_share_of_representatives_f)中，基于世纪的群体被替换为基于第一个十年的群体，并展示了10年和20年的趋势。在美国新立法的最初几十年内，代表转为参议员的情况显然与后来的模式有所不同。
- en: '![](Images/sfda_0412.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0412.png)'
- en: Figure 4-12\. Trend of the share of representatives for each cohort, defined
    by starting decade, who later became senators
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-12\. 每个由起始十年定义的群体代表后来成为参议员的份额趋势
- en: Finding the repeat behavior within a fixed time box is a useful tool for comparing
    cohorts. This is particularly true when the behaviors are intermittent in nature,
    such as purchase behavior or content or service consumption. In the next section,
    we’ll look at how to calculate not only whether an entity had a subsequent action
    but also how many subsequent actions they had, and we’ll aggregate them with cumulative
    calculations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个固定时间段内找到重复的行为模式对比各个群体是一个有用的工具。特别是当行为是间歇性的，比如购买行为或内容或服务消费时。在下一节中，我们将看看如何计算一个实体不仅是否有后续行动，还有多少后续行动，并通过累积计算来汇总它们。
- en: Cumulative Calculations
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 累积计算
- en: Cumulative cohort analysis can be used to establish *cumulative lifetime value*,
    also called *customer lifetime value* (the acronyms CLTV and LTV are used interchangeably),
    and to monitor newer cohorts in order to be able to predict what their full LTV
    will be. This is possible because early behavior is often highly correlated with
    long-term behavior. Users of a service who return frequently in their first days
    or weeks of using it tend to be the most likely to stay around over the long term.
    Customers who buy a second or third time early on are likely to continue purchasing
    over a longer time period. Subscribers who renew after the first month or year
    are often likely to stick around over many subsequent months or years.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 累积群体分析可用于建立*累积生命周期价值*，也称为*客户生命周期价值*（CLTV和LTV缩写可互换使用），并监测更新的群体，以便能够预测他们的完整LTV。这是可能的，因为早期行为通常与长期行为高度相关。在最初使用某项服务的几天或几周内经常返回的用户，往往最有可能长期保持在服务中。在早期购买第二或第三次的客户通常会在较长时期内继续购买。在第一个月或第一年后续费的订阅者通常也会在许多后续的月份或年份内继续停留。
- en: In this section, I’ll mainly talk about the revenue-generating activities of
    customers, but this analysis can also be applied to situations in which customers
    or entities incur costs, such as through product returns, support interactions,
    or use of health-care services.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将主要讨论客户的收入生成活动，但这种分析也可以应用于客户或实体产生成本的情况，例如产品退货、支持交互或使用医疗服务。
- en: 'With cumulative calculations, we’re less concerned about whether an entity
    did an action on a particular date and more about the total as of a particular
    date. The cumulative calculations used in this type of analysis are most often
    `count`s or `sum`s. We will again use the time box concept to ensure apples-to-apples
    comparisons between cohorts. Let’s look at the number of terms started within
    10 years of the first `term_start`, cohorting the legislators by century and type
    of first term:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在累积计算中，我们更少关心实体在特定日期是否执行了某项操作，而更关心截至特定日期的总数。在这类分析中使用的累积计算通常是`count`或`sum`。我们将再次使用时间框概念，以确保对各队伍之间进行苹果对苹果的比较。让我们来看看在首次`term_start`后10年内开始的任期数，通过世纪和首次任期类型来分组立法者：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The largest cohort is that of representatives first elected in the 19th century,
    but the cohort with the largest number of terms started within 10 years is that
    of representatives first elected in the 20th century. This type of calculation
    can be useful for understanding the overall contribution of a cohort to an organization.
    Total sales or total repeat purchases can be valuable metrics. Usually, though,
    we want to normalize to understand the contribution on a per-entity basis. Calculations
    we might want to make include average actions per person, average order value
    (AOV), items per order, and orders per customer. To normalize by the cohort size,
    simply divide by the starting cohort, which we’ve done previously with retention,
    survivorship, and returnship. Here we do that and also pivot the results into
    table form for easier comparisons:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的队伍是19世纪首次当选的代表队，但最大届数队伍是在10年内首次当选的20世纪代表队。这种计算方法有助于理解一个队伍对组织的整体贡献。总销售额或总重复购买可以是有价值的度量标准。通常，我们希望对每个实体的贡献进行归一化理解。我们可能想做的计算包括每人平均行动次数，平均订单价值（AOV），订单中的商品数以及客户的订单数。为了按队伍规模进行归一化，只需除以起始队伍，这在之前处理保留率、生存率和回访率时已经做过。在这里，我们不仅这样做，还将结果转换为表格形式以便于比较：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With the cumulative terms normalized by the cohort size, we can now confirm
    that representatives first elected in the 20th century had the highest average
    number of terms, while those who started in the 19th century had the fewest number
    of terms on average. Senators have fewer but longer terms than their representative
    peers, and again those who started in the 20th century have had the highest number
    of terms on average.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按队伍规模归一化的累积任期数，我们现在可以确认20世纪首次当选的代表平均拥有最多的任期数，而19世纪开始的人则平均拥有最少的任期数。参议员比他们的代表同行拥有更少但更长的任期，同样，那些20世纪开始的人平均拥有最多的任期数。
- en: Cumulative calculations are often used in customer lifetime value calculations.
    LTV is usually calculated using monetary measures, such as total dollars spent
    by a customer, or the gross margin (revenue minus costs) generated by a customer
    across their lifetime. To facilitate comparisons between cohorts, the “lifetime”
    is often chosen to reflect average customer lifetime, or periods that are convenient
    to analyze, such as 3, 5, or 10 years. The legislators data set doesn’t contain
    financial metrics, but swapping in dollar values in any of the preceding SQL code
    would be straightforward. Fortunately, SQL is a flexible enough language that
    we can adapt these templates to address a wide variety of analytical questions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 累积计算通常用于计算客户生命周期价值。LTV通常使用货币衡量指标进行计算，如客户终身支出的总金额，或者客户在其生命周期内产生的总毛利（收入减去成本）。为了比较各个队伍之间的差异，通常选择“终身”来反映平均客户生命周期，或者方便分析的周期，如3年、5年或10年。立法者数据集不包含财务指标，但在任何前述的SQL代码中加入金额值是直接的。幸运的是，SQL是一种足够灵活的语言，我们可以根据各种分析问题调整这些模板。
- en: Cohort analysis includes a set of techniques that can be used to answer questions
    related to behavior over time and how various attributes may contribute to differences
    between groups. Survivorship, returnship, and cumulative calculations all shed
    light on these questions. With a good understanding of how cohorts behave, we
    often have to turn our attention back to the composition or mix of cohorts over
    time, understanding how that can impact total retention, survivorship, returnship,
    or cumulative values such that these measures differ surprisingly from the individual
    cohorts.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 队列分析包括一系列技术，可用于回答与时间相关的行为问题，以及各种属性如何导致不同群体之间差异的问题。存活率、回头率和累积计算都可以阐明这些问题。了解了队列的行为方式后，我们常常需要重新关注随时间变化的队列组成或混合情况，了解这如何影响总的保留率、存活率、回头率或累积值，从而使这些度量值与个体队列之间的差异出现意外的情况。
- en: Cross-Section Analysis, Through a Cohort Lens
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过队列镜头的横断面分析
- en: So far in this chapter, we’ve been looking at cohort analysis. We’ve followed
    the behavior of cohorts across time with retention, survivorship, returnship,
    and cumulative behavior analyses. One of the challenges with these analyses, however,
    is that even as they make changes within cohorts easy to spot, it can be difficult
    to spot changes in the overall composition of a customer or user base.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们迄今为止一直在研究队列分析。我们通过保留率、存活率、回头率和累积行为分析跨时间追踪队列的行为。然而，这些分析面临的一个挑战是，即使它们使得队列内部的变化变得容易发现，但很难发现客户或用户基础整体组成的变化。
- en: '*Mix shifts*, which are changes in the composition of the customer or user
    base over time, can also occur, making later cohorts different from earlier ones.
    Mix shifts may be due to international expansion, shifting between organic and
    paid acquisition strategies, or moving from a niche enthusiast audience to a broader
    mass market one. Creating additional cohorts, or segments, along any of these
    suspected lines can help diagnose whether a mix shift is happening.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*混合转变*，即客户或用户基础随时间发生的组成变化，也可能发生，使后来的队列与之前的不同。混合转变可能是由于国际扩展、在有机和付费获取策略之间的转变，或是从小众爱好者观众转向更广泛的大众市场观众。沿着这些疑似线路创建额外的队列或段可以帮助诊断是否正在发生混合转变。'
- en: Cohort analysis can be contrasted with cross-sectional analysis, which compares
    individuals or groups at a single point in time. Cross-sectional studies can correlate
    years of education with current income, for example. On the positive side, collecting
    data sets for cross-sectional analysis is often easier since no time series is
    necessary. Cross-sectional analysis can be insightful, generating hypotheses for
    further investigation. On the negative side, a form of selection bias called survivorship
    bias usually exists, which can lead to false conclusions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 队列分析可以与横断面分析进行对比，后者比较个体或群体在单一时间点上的情况。例如，横断面研究可以将教育年限与当前收入进行相关性分析。积极的一面是，收集用于横断面分析的数据集通常更容易，因为不需要时间序列。横断面分析可以提供深刻的见解，为进一步研究生成假设。然而，消极的一面是，通常存在一种叫做存活偏差的选择偏差，可能导致错误的结论。
- en: Cohort analysis is a way to overcome survivorship bias by including all members
    of a starting cohort in the analysis. We can take a series of cross sections from
    a cohort analysis to understand how the mix of entities may have changed over
    time. On any given date, users from a variety of cohorts are present. We can use
    cross-sectional analysis to examine them, like layers of sediment, to reveal new
    insights. In the next example, we’ll create a time series of the share of legislators
    from each cohort for each year in the data set.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 队列分析是通过将起始队列的所有成员纳入分析来克服存活偏差的一种方法。我们可以从队列分析中获取一系列横断面，以了解实体的组合如何随时间变化而变化。在任何给定日期，各种队列的用户都在场。我们可以像沉积物的层层一样使用横断面分析来检查它们，以揭示新的见解。在下一个示例中，我们将为数据集中每年的每个立法者队列的份额创建一个时间序列。
- en: 'The first step is to find the number of legislators in office each year by
    *JOIN*ing the `legislators` table to the `date_dim`, *WHERE* the `date` from the
    `date_dim` is between the start and end dates of each term. Here we use December
    31 for each year to find the legislators in office at each year’s end:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过将`legislators`表连接到`date_dim`，*WHERE* `date_dim`中的日期位于每个任期的起始日期和结束日期之间，来找到每年在任的立法者数量。在这里，我们使用每年的12月31日来找出每年末在任的立法者：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we add in the century cohorting criteria by *JOIN*ing to a subquery with
    the `first_term` calculated:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据计算的`first_term`加入世纪队列准则：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we calculate the percent of total `legislators` in each year that
    the century cohort represents. This can be done in a couple of ways, depending
    on the shape of output desired. The first way is to keep a row for each `date`
    and `century` combination and use a `sum` window function in the denominator of
    the percentage calculation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算每年世纪队列代表的总立法者百分比。这可以通过几种方式完成，具体取决于所需输出的形状。第一种方式是保留每个`date`和`century`组合的行，并在百分比计算的分母中使用`sum`窗口函数：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The second approach results in one row per year, with a column for each century,
    a table format that may be easier to scan for trends:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法会导致每年一行，每个世纪一个列，这种表格形式可能更容易扫描趋势：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can graph the output, as in [Figure 4-13](#percent_of_legislators_each_yearcomma_b),
    to see how newer cohorts of legislators gradually overtake older cohorts, until
    they themselves are replaced by new cohorts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在[图表4-13](#percent_of_legislators_each_yearcomma_b)中那样绘制输出，以查看新一代立法者逐渐超过老一代，直到它们自己被新一代取代。
- en: '![](Images/sfda_0413.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0413.png)'
- en: Figure 4-13\. Percent of legislators each year, by century first elected
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图表4-13。按首次当选世纪计算的每年立法者百分比
- en: Rather than cohorting on `first_term`, we can cohort on tenure instead. Finding
    the share of customers who are relatively new, are of medium tenure, or are long-term
    customers at various points in time can be insightful. Let’s take a look at how
    the tenure of legislators in Congress has changed over time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据`first_term`而不是任期进行队列化。在不同时间点找到相对新的客户、中期任期客户和长期客户的份额可能很有见地。让我们看看国会议员的任期如何随时间变化。
- en: 'The first step is to calculate, for each year, the cumulative number of years
    in office for each legislator. Since there can be gaps between terms when legislators
    are voted out or leave office for other reasons, we’ll first find each year in
    which the legislator was in office at the end of the year, in the subquery. Then
    we’ll use a `count` window function, with the window covering the rows `unbounded
    preceding`, or all prior rows for that legislator, and `current row`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是计算每位立法者每年在职的累积任期。由于立法者可能因选举失败或其他原因离职，会有任期之间的空白期，我们首先在子查询中找到每年底时立法者在职的年份。然后我们将使用`count`窗口函数，窗口涵盖该立法者的所有先前行和当前行：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, `count` the number of legislators for each combination of `date` and
    `cume_years` to create a distribution:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于每个`date`和`cume_years`的组合，计算立法者的数量以创建分布：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Before calculating the percentage for each tenure per year and adjusting the
    presentation format, we might want to consider grouping the tenures. A quick profiling
    of our results so far reveals that in some years, almost 40 different tenures
    are represented. This will likely be difficult to visualize and interpret:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在为每年的任期计算百分比并调整展示格式之前，我们可能需要考虑对任期进行分组。我们目前的结果快速分析显示，在某些年份，几乎有40个不同的任期。这可能会导致可视化和解释变得困难：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As a result, we may want to group the values. There is no single right way
    to group tenures. If there are organizational definitions of tenure groups, go
    ahead and use them. Otherwise, I usually try to break them up into three to five
    groups of roughly equal size. Here we’ll group the tenures into four cohorts,
    where `cume_years` is less than or equal to 4 years, between 5 and 10 years, between
    11 and 20 years, and equal to or more than 21 years:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能需要对数值进行分组。对任期进行分组没有唯一正确的方法。如果有组织定义的任期组，可以直接使用。否则，我通常尝试将其分成三到五个大致相等大小的组。在这里，我们将任期分为四个队列，其中`cume_years`小于或等于4年、5到10年之间、11到20年之间，以及大于或等于21年：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The graphing of the results in [Figure 4-14](#percent_of_legislators_by_number_of_yea)
    shows that in the early years of the country, most legislators had very little
    tenure. In more recent years, the share of legislators with 21 or more years in
    office has been increasing. There are also interesting periodic increases in 1-to-4-year-tenure
    legislators that may reflect shifts in political trends.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图表4-14](#percent_of_legislators_by_number_of_yea)中展示的结果表明，在国家早期，大多数立法者任期非常短。近年来，任期超过21年的立法者比例逐渐增加。还有有趣的周期性增加的1至4年任期立法者，可能反映了政治趋势的变化。
- en: '![](Images/sfda_0414.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/sfda_0414.png)'
- en: Figure 4-14\. Percent of legislators by number of years in office
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-14\. 在职年限的立法者百分比
- en: A cross section of a population at any point in time is made up of members from
    multiple cohorts. Creating a time series of these cross sections is another interesting
    way of analyzing trends. Combining this with insights from retention can provide
    a more robust picture of trends in any organization.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 人群的任何时间点的横截面由多个队列的成员组成。创建这些横截面的时间序列是分析趋势的另一种有趣方式。将这一点与留存的见解结合起来可以提供组织中趋势的更全面图像。
- en: Conclusion
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Cohort analysis is a useful way to investigate how groups change over time,
    whether it be from the perspective of retention, repeat behavior, or cumulative
    actions. Cohort analysis is retrospective, looking back at populations using intrinsic
    attributes or attributes derived from behavior. Interesting and hopefully useful
    correlations can be found through this type of analysis. However, as the saying
    goes, correlation does not imply causation. To determine actual causality, randomized
    experiments are the gold standard. [Chapter 7](ch07.xhtml#experiment_analysis)
    will go into depth on experiment analysis.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 跨时间队列分析是一种有用的方法，用于调查群体随时间变化的方式，无论是从留存、重复行为还是累积行为的角度来看。队列分析是回顾性的，通过回顾具有固有属性或行为派生属性的人群来进行。通过这种类型的分析可以找到有趣且有希望的相关性。然而，俗话说，相关不等于因果关系。要确定实际的因果关系，随机实验是金标准。[第
    7 章](ch07.xhtml#experiment_analysis)将深入探讨实验分析。
- en: 'Before we turn to experimentation, however, we have a few other types of analysis
    to cover. Next we’ll cover text analysis: components of text analysis often show
    up in other analyses, and it’s an interesting facet of analysis in itself.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们转向实验之前，我们还有其他几种类型的分析需要涵盖。接下来我们将涵盖文本分析：文本分析的组成部分经常出现在其他分析中，它本身也是分析的一个有趣方面。
