- en: 7 Containerized deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 容器化部署
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building a standardized way of deploying applications across multiple machines
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多台机器上构建标准化的应用程序部署方式
- en: Using Buildpacks to build optimized containers for hosted infrastructure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Buildpacks构建针对托管基础设施优化的容器
- en: Customizing a deployment using a Dockerfile
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile自定义部署
- en: Deploying containers to hosted environments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器部署到托管环境中
- en: Organizing containers for local development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为本地开发组织容器
- en: “Listen, I understand that this project is now gaining some traction, but we
    need to be able to integrate with it as soon as we can. The old service is at
    the center of everything we do, so you will need to give us documentation on how
    to run what you already have,” says Carol. You are just sitting down with your
    lunch when she sits down at the same table. Carol has been the team lead over
    at the mobile application team for several years now. She runs a tight ship and
    doesn’t like surprises—like to one your PM put you in charge of developing. You
    smile and say you’ll get her team something by the end of the day. Something simple
    that they won’t have to do anything crazy to use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “听着，我明白这个项目现在正在取得一些进展，但我们需要能够尽快与之集成。旧服务是我们所做的一切的中心，所以你需要给我们提供关于如何运行你已有的内容的文档，”卡罗尔说。你刚坐下吃午饭，她就坐在了同一张桌子上。卡罗尔现在已经在移动应用团队担任团队领导多年。她管理得非常严格，不喜欢惊喜——比如你的项目经理让你负责开发。
- en: “It would be nice if it’s the exact system you are using in production and can
    be used locally.” This is important. Having a system work the same on your machine
    as it does in production is huge. Of course, you could point her team to the binary
    you publish on your repository, but your binaries are compiled for Linux, not
    for macOS or Windows, which the mobile app team uses. You need something more
    universal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “如果它是你在生产中使用的确切系统并且可以在本地使用，那就太好了。”这很重要。让系统在你的机器上与在生产中一样工作是非常大的。当然，你可以把你的团队指向你在仓库上发布的二进制文件，但你的二进制文件是为Linux编译的，而不是为macOS或Windows编译的，这是移动应用团队使用的。你需要一个更通用的东西。
- en: What can you do? How can you deliver a product in a way that runs uniformly
    in any environment? How can you ensure that it runs efficiently and is secure?
    The answer is containers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做什么？你如何以统一的方式在任何环境中交付产品？你如何确保它运行高效且安全？答案是容器。
- en: If you look at some trucks driving down the highway, you will see a large metal
    cargo container on the back. These are the same containers you see at shipping
    docks in harbors and on the backs of trains. They are all the same ISO containers
    that adhere to ISO standard 668:2020 and have the dimensions of 8 feet wide, 20
    or 40 feet long, and 8 feet 6 inches high. This standardization allows items to
    be transported easily by all of these different vehicles, as demonstrated in figure
    7.1.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看高速公路上行驶的一些卡车，你会在后面看到一个大型的金属货运集装箱。这些就是在港口的码头和火车后面的集装箱。它们都是相同的ISO标准集装箱，符合ISO标准668:2020，尺寸为8英尺宽，20或40英尺长，8英尺6英寸高。这种标准化使得物品可以通过所有这些不同的车辆轻松运输，如图7.1所示。
- en: '![](../../OEBPS/Images/CH07_F01_Holmes4.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F01_Holmes4.png)'
- en: Figure 7.1 Container vessels have a flat surface that allows for many containers
    to be moved at once.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 容器船有一个平坦的表面，可以同时移动许多集装箱。
- en: Prior to the invention of these containers, ships, trucks, and trains had *break
    bulk cargo* or essentially loosely bound, nonstandard containers such as barrels
    and boxes. Trying to find space for such items became a complicated puzzle and
    required extra manual labor to move items from one vehicle to another. The transition
    to containers made it so that shipping products were standardized in a way that
    made the transportation of goods easy and efficient.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些容器发明之前，船只、卡车和火车有散装货物或基本上是松散捆绑、非标准容器，如桶和箱子。试图为这些物品找到空间变成了一道复杂的谜题，并且需要额外的体力劳动来将物品从一个车辆移动到另一个车辆。转向容器使得运输产品在一种使货物运输变得容易和高效的方式上实现了标准化。
- en: Shipping software today can often feel like break bulk cargo if you consider
    the state of the operating systems and computer architectures. Suppose we want
    to write code that supports Linux, macOS, and Windows but also runs on 32-bit
    or 64-bit Intel or ARM architectures. How many binaries would we need to ship?
    If we take three operating systems and four architectures, we would have 12 different
    binaries that would need to be built and run for that specific machine. This becomes
    the same problem of irregular barrels and boxes that the shipping industry had
    and often falls victim to the meme “it works on my machine.” As mentioned before,
    we want uniformity in the items we build and the products we ship.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑到操作系统和计算机架构的状态，今天发布软件常常会感觉像散装货物。假设我们想要编写支持Linux、macOS和Windows，并且能在32位或64位的Intel或ARM架构上运行的代码。我们需要发布多少个二进制文件？如果我们考虑三个操作系统和四种架构，我们将需要构建和运行12个不同的二进制文件，以适应特定的机器。这变成了航运业所面临的非标准桶和箱子的相同问题，并且常常成为“在我的机器上它工作”这个梗的受害者。如前所述，我们希望我们在构建的项目和发布的产品中保持一致性。
- en: 'How can we solve this problem? The same way the shipping industry did: containers.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？与航运业一样：使用容器。
- en: 7.1 What is a container?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 容器是什么？
- en: To better understand how a container works, we need a brief overview of how
    an operating system works. An operating system’s job is to manage various resources
    within the physical machine. This includes storing information in memory or on
    a hard disk or deciding which programs to execute. A *container* is a self-contained
    operating system that is *virtualized*, meaning it runs on a machine that doesn’t
    use a physical machine directly. This *virtual machine* works with the underlying
    operating system to run various applications. Container runtimes are virtual machines
    that work with the host operating system to share the same *kernel*, or the service
    that chooses which applications run. These abstraction layers give us the ability
    to hide the underlying implementation layers, as seen in figure 7.2.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解容器的工作原理，我们需要简要概述操作系统的工作方式。操作系统的工作是管理物理机器内的各种资源。这包括在内存或硬盘上存储信息或决定要执行哪些程序。*容器*是一个封装的操作系统，它是*虚拟化*的，这意味着它运行在不需要直接使用物理机器的机器上。这个*虚拟机*与底层操作系统协同工作，以运行各种应用程序。容器运行时是与主机操作系统协同工作的虚拟机，它们共享相同的*内核*，即选择哪些应用程序运行的服务。这些抽象层使我们能够隐藏底层实现层，如图7.2所示。
- en: '![](../../OEBPS/Images/CH07_F02_Holmes4.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F02_Holmes4.png)'
- en: Figure 7.2 Applications work with an operating system within the container,
    which interacts with the container runtime. The runtime then runs as a process
    within the host operating system like any other application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 应用程序在容器内与操作系统协同工作，并与容器运行时进行交互。运行时随后作为主机操作系统中的一个进程运行，就像任何其他应用程序一样。
- en: 'NOTE In this book, we use one of the more popular container tools: Docker.
    Alternatively, you can use Podman, which is gaining popularity.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这本书中，我们使用了一些更受欢迎的容器工具之一：Docker。或者，你也可以使用Podman，它正在变得越来越受欢迎。
- en: What does this mean for you? When we create a container, we create a standardized
    format to run on a given runtime. Containers are built from *images* or snapshots
    of what our system should look like. You can think of this as being sort of like
    a template or a saved file that gets loaded and runs on the system. A single image
    can be used to create many containers. These images are defined and built for
    a given runtime, much like our application binaries, but the runtime allows our
    container to run anywhere that implements this specification. Currently, the most
    common runtime for most developers is Docker, so much so that Docker and containers
    are often used interchangeably (like calling a tissue a Kleenex), but there are
    many different implementations of the container specification.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你意味着什么？当我们创建一个容器时，我们创建了一个在给定运行时上运行的标准化格式。容器是由*镜像*或系统应呈现的快照构建的。你可以将其视为一种模板或已保存的文件，该文件在系统上加载并运行。单个镜像可以用来创建许多容器。这些镜像是为特定运行时定义和构建的，就像我们的应用程序二进制文件一样，但运行时允许我们的容器在任何实现此规范的地方运行。目前，对于大多数开发者来说，最常用的运行时是Docker，以至于Docker和容器经常被互换使用（就像称呼纸巾为Kleenex一样），但容器规范有许多不同的实现。
- en: You may be thinking, “What does this mean for you?” Well, as you can imagine,
    as your company grows, you may not all be using Go. Python or JavaScript may be
    introduced. Or you may have dependencies like databases and queuing systems. All
    of these pieces require configuration and setup. If you are working in Go, you
    may not want to have to go through the hassle of installing Python to integrate
    with another team’s product. You don’t want your developers taking precious time
    trying to install or update to the latest version of Postgres. Instead, you can
    rely on Docker to help manage, maintain, and run all of these dependencies. This
    frees you up to focus on your development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“这对你们来说意味着什么？”嗯，正如你可以想象的那样，随着你们公司的成长，你们可能不会所有人都使用Go。可能会引入Python或JavaScript。或者你们可能有数据库和队列系统这样的依赖。所有这些组件都需要配置和设置。如果你在Go中工作，你可能不想为了与另一个团队的产品集成而麻烦地安装Python。你也不想你的开发者们浪费宝贵的时间去安装或更新到Postgres的最新版本。相反，你可以依赖Docker来帮助管理、维护和运行所有这些依赖。这让你可以腾出时间专注于你的开发。
- en: Because Docker is a common runtime for containers, many developers will have
    it installed on their machines to help them run their applications and application
    dependencies uniformly. But as you move away from your host machine and want to
    ship your container to a hosted environment, you may find that there are other
    ways of optimizing and building your containers to have them run more efficiently
    in that environment. There is a joke that the “cloud” is just someone else’s machine.
    This joke, though, is true. It is all just some other machine somewhere else,
    and with many different cloud providers building and implementing their hardware
    and custom runtimes, it can sometimes be better to build images optimized for
    their runtimes. This can be done by using their base images or allowing them to
    help build the images for you, which is known as *Buildpacks*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Docker是容器的通用运行时，许多开发者会在他们的机器上安装它，以帮助他们统一运行他们的应用程序和应用程序依赖。但是当你离开你的主机机器，想要将你的容器发送到托管环境时，你可能会发现还有其他方法来优化和构建你的容器，以便它们在该环境中更有效地运行。有一个笑话，“云”只是别人的机器。这个笑话，尽管如此，是真实的。它只是某个地方的其他机器，由于许多不同的云提供商在构建和实施他们的硬件和自定义运行时，有时构建针对他们运行时的优化镜像会更好。这可以通过使用他们的基础镜像或让他们帮助你构建镜像来实现，这被称为*Buildpacks*。
- en: 7.2 What is a Buildpack?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 什么是Buildpack？
- en: In chapter 4, we deployed our application using a PaaS framework in Google Cloud.
    In both of those deployments, we did not need to focus on how those applications
    were being run or where they were running; they were abstracted. We can imagine,
    though, how all of this works. At the very base of everything are physical machines
    running the code, but there are layers of virtualization and abstraction. You,
    as the developer, do not need to worry about things like security patches and
    kernel upgrades; just focus on your code. There is some hidden magic that determines
    what code you are running and how to deploy it, and suddenly it works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们使用Google Cloud中的PaaS框架部署了我们的应用程序。在这两次部署中，我们都不需要关注这些应用程序是如何运行的或在哪里运行的；它们被抽象化了。然而，我们可以想象这一切是如何工作的。在所有事情的最底层是运行代码的物理机器，但是有虚拟化和抽象的层。作为开发者，你不需要担心像安全补丁和内核升级这样的问题；只需专注于你的代码。有一些隐藏的魔法决定了你运行什么代码以及如何部署它，然后它突然就工作了。
- en: The cloud is just someone else’s computer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 云只是别人的电脑。
- en: 'Buildpacks work in a very similar way and are inextricably linked with how
    many PaaS work under the hood. In fact, this technology was first developed by
    Heroku in 2011 and has been used by various other companies such as Pivotal and
    Google to help run their PaaS. The concepts are simple: you provide the code,
    and they’ll build the image. Under the hood, PaaS are building their custom images
    based on the libraries and dependencies that their platforms need to make the
    code run as efficiently as possible and deploy them as containers in their hosting
    environment. This gives you resilience and substantial uptime, and they can get
    the most out of their hardware by running isolated, secure, and maintainable applications.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Buildpacks以非常相似的方式工作，并且与许多PaaS在底层的工作方式密不可分。实际上，这项技术最初是在2011年由Heroku开发的，并被Pivotal和Google等公司用于帮助他们运行他们的PaaS。概念很简单：你提供代码，他们会构建镜像。在底层，PaaS根据他们的平台需要的库和依赖项构建自定义镜像，以便尽可能高效地运行代码，并在他们的托管环境中将它们作为容器部署。这为你提供了弹性和实质性的正常运行时间，并且他们可以通过运行隔离的、安全的和可维护的应用程序来最大限度地利用他们的硬件。
- en: If you are building an application, Buildpacks will give you a lot of features
    that will make your application more robust, such as advanced caching, multiprocessing,
    language detection, and much more. The recent Buildpacks game-changer is the notion
    of *Cloud Native Buildpacks* which allows you, as the developer, to take advantage
    of the PaaS-like ecosystem of building an application with the portability of
    using containers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建应用程序，构建包将为您提供许多功能，这些功能将使您的应用程序更加健壮，例如高级缓存、多进程、语言检测等等。最近的构建包变革性概念是*云原生构建包*，它允许您作为开发者利用类似于PaaS的生态系统来构建应用程序，同时使用容器的便携性。
- en: 'What goes on inside of a Buildpack? When triggering a Buildpack, it goes through
    two stages: detection and builds. When triggering a build, the Buildpack analyzes
    your source code to first determine if it can recognize the source code and build
    the container; this is known as the detection stage. In our case, it will look
    for Go files or a .mod file. If we were building a Javascript application, it
    would look for a `package .json` file, or if a Java application, it would look
    for a `pom.xml` file.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包内部发生了什么？当触发构建包时，它将经历两个阶段：检测和构建。当触发构建时，构建包会分析您的源代码，首先确定它是否可以识别源代码并构建容器；这被称为检测阶段。在我们的情况下，它将寻找Go文件或一个`.mod`文件。如果我们正在构建一个JavaScript应用程序，它将寻找一个`package.json`文件，或者如果是一个Java应用程序，它将寻找一个`pom.xml`文件。
- en: When entering the building stage, the Buildpack will determine what the runtime
    should be, how the library should be built, the installation of dependencies,
    and the compilation and running of the application itself. It does this through
    the use of a *builder*, which is an image specifically used for creating the application
    based on the detection done in the previous step. The building and running of
    an image are done through a *stack*, which combines the build and run environments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入构建阶段时，构建包将确定运行时应该是什么，库应该如何构建，依赖项的安装，以及应用程序本身的编译和运行。它是通过使用一个*构建器*来做到这一点的，这是一个专门用于基于前一步检测创建应用程序的镜像。镜像的构建和运行是通过一个*栈*来完成的，它结合了构建和运行环境。
- en: Docker is just one container runtime. There are many other container runtimes
    out there that aren’t as popular.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker只是一个容器运行时。还有许多其他不那么受欢迎的容器运行时。
- en: All of this can allow different groups to create a process for identifying and
    building applications specific to their runtimes and environments. This means
    that Google, Amazon, Heroku, and Microsoft can build their own container runtimes
    that are optimized for their hardware, and you can tap into that performance by
    using their Buildpack. Let’s try it with Google.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以让不同的团队为识别和构建特定于其运行时和环境的应用程序创建一个流程。这意味着Google、Amazon、Heroku和Microsoft可以构建自己的容器运行时，这些运行时针对其硬件进行了优化，您可以通过使用他们的构建包来利用这种性能。让我们用Google试试。
- en: 7.3 Let’s build a container
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 让我们构建一个容器
- en: To start, we will use a Buildpack to build and run our container locally. Then
    we will use the same process to deploy the container to production. Following
    that, we will work on building our own container using our own definition and
    deploy that as well. This way, you will know how to build and maintain your own
    containerized deployment and local development. First, we must install our container
    runtime, in this case, Docker.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用构建包在本地上构建和运行我们的容器。然后我们将使用相同的过程将容器部署到生产环境中。随后，我们将使用自己的定义构建自己的容器，并将其部署。这样，您将了解如何构建和维护自己的容器化部署和本地开发。首先，我们必须安装我们的容器运行时，在这种情况下，是Docker。
- en: Docker has three different installation types depending on your operating system,
    so it will be best if you follow the directions for the one that best suits you.
    Directions can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    This will give us our container runtime. Now we need to create a container. To
    do this, we will use a Buildpack and install `pack`, which is a tool built and
    maintained by Cloud Native Buildpacks. It can be installed by following the directions
    at [https://buildpacks.io/docs/tools/pack/](https://buildpacks.io/docs/tools/pack/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，Docker有三种不同的安装类型，因此最好遵循最适合您的说明。说明可以在[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)找到。这将为我们提供容器运行时。现在我们需要创建一个容器。为此，我们将使用构建包并安装`pack`，这是一个由Cloud
    Native Buildpacks构建和维护的工具。可以通过遵循[https://buildpacks.io/docs/tools/pack/](https://buildpacks.io/docs/tools/pack/)中的说明来安装。
- en: '`pack` will help us choose and build our application into a container using
    a defined Buildpack. To demonstrate this, let’s see what `pack` suggests we use
    to build our application. Type `pack builder suggest` and see what options come
    up:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack`将帮助我们使用定义的构建包选择和构建我们的应用程序到一个容器中。为了演示这一点，让我们看看`pack`建议我们使用什么来构建我们的应用程序。输入`pack
    builder suggest`并查看出现的选项：'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice that these packs are not focused on a specific language but rather provide
    a broad foundation for multiple languages. You may also notice that these languages
    are those that are supported for FaaS and PaaS offerings on Google. This is because
    underneath, our FaaS and PaaS are running within a container using a Buildpack.
    Now let’s build our application by typing the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些pack并不是针对特定语言的，而是为多种语言提供了一个广泛的基础。你也可能注意到，这些语言是Google上支持FaaS和PaaS提供的语言。这是因为在我们底层，我们的FaaS和PaaS是在使用Buildpack的容器中运行的。现在，让我们通过输入以下内容来构建我们的应用程序：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s look at what it did. The builder identifies that our application is a
    Go project from our module file and looks for a `main` package to run. Some configurations
    can be done if you have more than one main function. Each Buildpack will have
    its own configuration. To see how our container runs, type
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它做了什么。构建器识别出我们的应用程序是一个来自我们的模块文件的Go项目，并寻找一个`main`包来运行。如果你有多个`main`函数，可以进行一些配置。每个Buildpack都将有自己的配置。要查看我们的容器是如何运行的，输入
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should see your server run. Call your translation endpoint and see that
    your application is running in a nice, neat, portable package. Now that you can
    build a container, let’s publish it so that others can use it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到你的服务器正在运行。调用你的翻译端点，看看你的应用程序正在一个整洁、便携的包中运行。现在，既然你可以构建一个容器，让我们发布它，以便其他人可以使用它。
- en: 7.4 Adding a container build to your pipeline
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 将容器构建添加到您的管道中
- en: 'Now we want to make this an artifact available through our releases, just like
    we did with our binary. Why do we want a container if we already have the binary?
    Remember what containers are: a universal runtime for your application independent
    of the underlying operating system. Since our other development teams want to
    use our application, we can simply share a container with them so that they don’t
    need to worry about dependencies, libraries, or runtimes. This way, they don’t
    need to have any underlying knowledge of Go or even of how to start our application
    and instead can run the container like they would any other application. They
    don’t even need to build our container; we can provide it for them in a *registry*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望将这个容器构建作为一个工件通过我们的发布版本提供，就像我们为我们的二进制文件所做的那样。如果我们已经有了二进制文件，为什么我们还需要容器呢？记住容器是什么：一个独立于底层操作系统的应用程序通用运行时。由于我们的其他开发团队希望使用我们的应用程序，我们可以简单地与他们共享一个容器，这样他们就不需要担心依赖项、库或运行时。这样，他们不需要对Go有任何底层知识，甚至不需要知道如何启动我们的应用程序，而是可以像运行其他任何应用程序一样运行容器。他们甚至不需要构建我们的容器；我们可以在一个*注册表*中为他们提供它。
- en: A *container registry* is just a storage area for images that are created for
    a container. The default registry on Docker is `hub .docker.com`, in which you
    can find all sorts of images to use. Each item in the registry can be pulled to
    run or be used as a *base* image for other images to be built from. Like Legos,
    images can be stacked on top of each other to build products. The image from which
    a container starts is known as the *base*. Figure 7.3 shows how this could work.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器注册表*只是一个用于存储为容器创建的镜像的存储区域。Docker上的默认注册表是`hub .docker.com`，在那里你可以找到各种可用的镜像。注册表中的每个项目都可以被拉取来运行或用作其他镜像构建的*基础*镜像。就像乐高积木一样，镜像可以堆叠在一起来构建产品。从该镜像启动容器的称为*基础*。图7.3显示了这是如何工作的。'
- en: '![](../../OEBPS/Images/CH07_F03_Holmes4.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 Holmes4](../../OEBPS/Images/CH07_F03_Holmes4.png)'
- en: Figure 7.3 Layers of containers
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 容器层
- en: 'At the bottom, you have an image such as an operating system. This layer can
    then be the base for another layer, such as a language. Then you can use that
    layer for building your application. These layers can add up over time and become
    complex, but they all get stored in this registry. When you run a container, more
    often than not, you want to pull it from a registry rather than build it on your
    own. Registries can act as private places for you and others to store and run
    your containers. In this chapter, we will publish our application to two repositories:
    one for public consumption and one for us to run in Google Cloud. Since we can
    now build our container using a Buildpack, we can publish the container to a registry.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，你有一个像操作系统这样的镜像。这个层可以成为另一个层的基础，比如语言层。然后你可以使用这个层来构建你的应用程序。这些层可以随着时间的推移而累积并变得复杂，但它们都存储在这个注册库中。当你运行一个容器时，你通常更愿意从注册库中拉取它，而不是自己构建它。注册库可以作为你和其他人存储和运行容器的私人场所。在本章中，我们将把我们的应用程序发布到两个存储库：一个用于公共消费，一个用于我们在Google
    Cloud中运行。由于我们现在可以使用Buildpack构建容器，我们可以将容器发布到注册库。
- en: To publish our container, we want to add it to our pipeline so that it is continuously
    delivered. Open your `pipeline.yml`, and add a container build section using the
    code in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布我们的容器，我们希望将其添加到我们的管道中，以便它能够持续交付。打开你的`pipeline.yml`文件，并使用以下列表中的代码添加一个容器构建部分。
- en: Listing 7.1 `pipeline.yml`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 `pipeline.yml`
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Only builds our container after the source code has passed unit tests
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅在源代码通过单元测试后构建我们的容器
- en: ❷ Installs Pack through curl for our build stage
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过curl安装Pack到我们的构建阶段
- en: ❸ Uses the pack command to build our container targeted for GCP
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用pack命令构建针对GCP的容器
- en: ❹ Configures Docker to use GCP for the container registry
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 配置Docker使用GCP作为容器注册库
- en: ❺ Pushes the container to GCP registry
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将容器推送到GCP注册库
- en: ❻ Logs into GitHub Container Registry
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 登录到GitHub容器注册库
- en: ❼ Retags the image for GitHub
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 为GitHub重命名镜像
- en: ❽ Pushes the new tag to GitHub Container Registry
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将新标签推送到GitHub容器注册库
- en: 'If you commit and push your changes, you should see a container now listed
    on your artifacts page. To test this, we can simply do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提交并推送了你的更改，你应该会在你的工件页面上看到一个新的容器。为了测试这一点，我们可以简单地执行以下操作：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you’ve automatically built and pushed your containers, we need to run
    them. To do this, we will use a container runtime.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经自动构建并推送了你的容器，我们需要运行它们。为此，我们将使用容器运行时。
- en: 7.5 Deploying to a container runtime
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 部署到容器运行时
- en: We’ve created a container using a Buildpack. We’ve published the container to
    the Google Container Registry. Now let’s deploy our container. What advantage
    does using a container runtime provide? Why did we go through all of this?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Buildpack创建了一个容器。我们已经将容器发布到了Google容器注册库。现在让我们部署我们的容器。使用容器运行时有什么优势？我们为什么要经历所有这些？
- en: For the first time in this book, we have a point of inflection between how an
    application is run in the cloud and how it runs on our machine. Our container
    now runs in a universal runtime. This is the closest we can get to an abstraction
    that we can run locally the same way it’s run in the cloud. This is a powerful
    tool because it solves the problem of “it runs on my machine” and “I’m struggling
    with this framework.” This is why containers are such a popular solution in today’s
    development process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们第一次在云中运行应用程序和在我们机器上运行应用程序的方式之间有一个转折点。我们的容器现在运行在通用运行时中。这是我们能够达到的本地运行与云中运行最接近的抽象。这是一个强大的工具，因为它解决了“它在我的机器上运行”和“我在这个框架上挣扎”的问题。这就是为什么容器在今天的开发过程中如此受欢迎的解决方案。
- en: A famous (or infamous) container orchestration tool is Kubernetes, which gives
    developers tools to deploy applications built on containers within a resilient,
    clustered environment. It’s a big, complicated, and powerful tool. Kubernetes
    is beyond the scope of this book, but I mention it here because it is the foundation
    of some other container runtimes that we will use. These containers are underneath
    the hood of products such as Google Cloud Run and FaaS; you can’t see the container,
    but it’s there. Google runs your container for you using Kubernetes in an isolated
    process, but you don’t need to worry about maintaining the cluster, writing deployments,
    and setting up incoming requests. Instead, you follow a pattern and deploy the
    container, and Google takes care of the rest.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的（或臭名昭著的）容器编排工具是Kubernetes，它为开发者提供了在弹性、集群环境中部署基于容器的应用程序的工具。这是一个庞大、复杂且强大的工具。Kubernetes超出了本书的范围，但我在这里提到它，因为它是我们将使用的某些其他容器运行时的基础。这些容器位于Google
    Cloud Run和FaaS等产品的底层；你无法看到容器，但它确实存在。Google使用Kubernetes在隔离过程中为你运行容器，但你不需要担心维护集群、编写部署和设置传入请求。相反，你遵循一个模式并部署容器，Google会处理其余部分。
- en: In figure 7.4\. we can see that we continue to move toward less abstraction
    and more control over our deployment process. We can now define the container
    and have it run in a universal runtime. We will use Google Cloud Run, but we could
    just as easily ship this product onto AWS ECS or a Kubernetes cluster.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.4中，我们可以看到我们继续朝着更少的抽象和更多对我们部署过程的控制迈进。我们现在可以定义容器，并在通用运行时中运行它。我们将使用Google Cloud
    Run，但同样可以轻松地将此产品部署到AWS ECS或Kubernetes集群。
- en: '![](../../OEBPS/Images/CH07_F04_Holmes4.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F04_Holmes4.png)'
- en: Figure 7.4 We are now using our container as our shippable product.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 我们现在使用我们的容器作为我们的可交付产品。
- en: Now we can set up a container deployment just as easily as all of the other
    deployments we’ve completed thus far. We just need to open our `pipeline.yml`
    and add the code in the following listing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像完成迄今为止的所有其他部署一样轻松地设置容器部署。我们只需要打开我们的`pipeline.yml`文件，并添加以下列表中的代码。
- en: Listing 7.2 `pipeline.yml`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 `pipeline.yml`
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ This is the name of the service you are deploying.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是你要部署的服务名称。
- en: ❷ The path to the image you are deploying
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你要部署的镜像的路径
- en: ❸ Validates that the endpoint works
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 验证端点是否工作
- en: 7.6 Writing your own image
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 编写自己的镜像
- en: What if you don’t want all of the extra stuff that’s in the Buildpack container?
    Remember, the Buildpack is structured to run well in the containerized environment
    with underlying libraries, configurations, and services to all help your products
    run well in their runtime. But with these libraries comes some additional overhead,
    in this case, space. For a deployed environment, this may not be a big deal, but
    what if we wanted to make it smaller or debug information?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望Buildpack容器中有所有额外的内容怎么办？记住，Buildpack的结构是为了在容器化环境中运行良好，它包含底层库、配置和服务，所有这些都有助于你的产品在它们的运行时中良好运行。但是，随着这些库的出现，也会带来一些额外的开销，在这种情况下，是空间。对于已部署的环境，这可能不是什么大问题，但如果我们想让它更小或调试信息呢？
- en: Why smaller? For a development team, it may make sense to have smaller images
    floating around or a special development image for debugging purposes. In either
    case, we can’t rely on the Buildpack abstraction to do this for us, so we will
    need to define our Dockerfile to build them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么更小？对于一个开发团队来说，拥有较小的镜像或为调试目的的特殊开发镜像可能是有意义的。在两种情况下，我们都不能依赖Buildpack抽象来为我们完成这项工作，因此我们需要定义我们的Dockerfile来构建它们。
- en: The beautiful thing about Go is that it compiles into a binary and in most cases
    does not rely on external libraries to run. This means that you can make a binary
    and put it on the smallest base image possible. A *base image* is the starting
    place from which our container is built. If you look through different container
    definitions, you will find images for Ubuntu, Debian, Windows, and so forth. These
    images are built and maintained by teams that install security patches, upgrades,
    libraries, and in some cases applications. This way, you can run something like
    Postgres without installing it on your machine, or use a base image for Go so
    that you don’t need to install Go. Let’s see how this works by creating a Dockerfile.
    Type `touch` `Dockerfile` in the root of your directory. The following listing
    shows the result.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Go的美丽之处在于它编译成二进制文件，并且在大多数情况下不需要依赖外部库来运行。这意味着你可以创建一个二进制文件并将其放置在可能的最小基础镜像上。*基础镜像*是我们构建容器的起点。如果你查看不同的容器定义，你会找到Ubuntu、Debian、Windows等镜像。这些镜像是由安装安全补丁、升级、库以及在某些情况下应用程序的团队构建和维护的。这样，你可以运行像Postgres这样的东西，而无需在你的机器上安装它，或者使用Go的基础镜像，这样你就不需要安装Go。让我们通过创建一个Dockerfile来了解一下这是如何工作的。在你的目录根目录下输入`touch
    Dockerfile`。以下列表显示了结果。
- en: Listing 7.3 Dockerfile
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 Dockerfile
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Uses the base image of the most recent version of Go
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用Go最新版本的基镜像
- en: ❷ Creates a working directory to store source code
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个工作目录来存储源代码
- en: ❸ Only copies module files and downloads dependencies. Putting this in its own
    step allows for caching and faster future builds.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 只复制模块文件并下载依赖项。将此步骤放在其自己的步骤中允许缓存和加快未来的构建。
- en: ❹ Creates a new stage of the build to use caching ability
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个新的构建阶段以使用缓存能力
- en: ❺ Adds remaining source code
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 添加剩余的源代码
- en: ❻ Builds the binary with flags for container optimization. We do not utilize
    this build flag, but the compiler will.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用容器优化的标志构建二进制文件。我们不会使用这个构建标志，但编译器会使用。
- en: ❼ Uses base scratch image for the smallest image possible
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用最小的基础镜像
- en: ❽ Copies the binary over from the dev stage
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 从开发阶段复制二进制文件
- en: 'We can then build our image by typing `docker build` `-t` `hello-api:min` `.`
    and for our dev image `docker build -t hello-api:dev --target dev .`. Now that
    both images are built, let’s compare how large they are! We can simply type `docker`
    `images`, and you’ll see your three image definitions, their tags, their size,
    and when they were built:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过输入`docker build -t hello-api:min .`来构建我们的镜像，对于我们的开发镜像`docker build
    -t hello-api:dev --target dev .`。现在两个镜像都构建好了，让我们比较一下它们的大小！我们可以简单地输入`docker images`，你会看到你的三个镜像定义、它们的标签、它们的大小以及它们构建的时间：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Wow! Our dev image is obviously the largest, but our min image is 3% the size
    of the Buildpack image! Why is that? Earlier we talked about how containers work.
    Each image is based on another image. Each time a new container is built, a layer
    gets added to your image. You can see this when you pull images as part of this
    build. Beneath all of those layers is the very base image that all images come
    from, as you can see in figure 7.5\. It is called `scratch` and is completely
    empty, so your application needs to be self-contained—just like our Go binary!
    That means we can copy our binary over to the `scratch` image, and it will interact
    with the runtime to run, just like any other container but without the bloat.
    This way, you don’t have to worry about outdated libraries or security patches.
    However, you can’t debug because there isn’t a command line. It’s a trade-off,
    but it can be extremely useful to ship around to other users.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们的开发镜像显然是最大的，但我们的最小镜像只有Buildpack镜像的3%大！为什么是这样？我们之前讨论了容器是如何工作的。每个镜像都是基于另一个镜像的。每次构建一个新的容器时，都会在你的镜像中添加一个层。当你作为构建的一部分拉取镜像时，你可以看到这一点。在最底层是所有镜像都从中来的非常基础镜像，如图7.5所示。它被称为`scratch`，是完全空的，所以你的应用程序需要是自包含的——就像我们的Go二进制文件一样！这意味着我们可以将我们的二进制文件复制到`scratch`镜像中，并且它将与运行时交互来运行，就像任何其他容器一样，但没有冗余。这样，你不必担心过时的库或安全补丁。然而，你不能调试，因为没有命令行。这是一个权衡，但它可以非常有助于将应用程序分发到其他用户。
- en: '![](../../OEBPS/Images/CH07_F05_Holmes4.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F05_Holmes4.png)'
- en: Figure 7.5 Containers use layers to help construct the image. The more layers
    you have, the larger your image becomes, and the more security vulnerabilities
    arise.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 容器使用层来帮助构建镜像。层越多，你的镜像就越大，并且安全漏洞也越多。
- en: Now let’s add these containers to our pipeline and publish them to our registry
    using the code in the following listing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些容器添加到我们的管道中，并使用以下列表中的代码将它们发布到我们的注册表中。
- en: Listing 7.4 `pipeline.yml`
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 `pipeline.yml`
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Builds the min image and tags it
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建最小镜像并为其打标签
- en: ❷ Builds the dev image using dev as the target for the build
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用“dev”作为构建目标构建开发镜像
- en: ❸ Logs in to GitHub Container Registry
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 登录到 GitHub 容器注册表
- en: ❹ Pushes the min image to the registry
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将最小镜像推送到注册表
- en: ❺ Pushes the dev image to the registry
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将开发镜像推送到注册表
- en: When your code is pushed, you should now see that you have three different containers.
    This can become extremely helpful when we start tagging our product for stable
    releases. These can be considered our latest builds for the time being and are
    used to test new features that may not be stable. Now that we are shipping our
    containers, we can integrate them into our development process, and others can
    as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码被推送到服务器后，你现在应该能看到你有三个不同的容器。当我们开始为稳定版本打标签时，这会变得非常有帮助。目前，这些可以被视为我们的最新构建版本，并用于测试可能不稳定的新功能。现在，我们正在分发容器，我们可以将它们集成到我们的开发过程中，其他人也可以这样做。
- en: 7.7 Local environment organization
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 本地环境组织
- en: You have a containerized service. You are shipping it for other developers to
    use. But your development is becoming dependent on other services as well. Is
    there something containers can do to help you in your development and shipping?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个容器化的服务。你正在为其他开发者使用它。但是你的开发也在依赖其他服务。容器能为你开发分发提供帮助吗？
- en: As you start down the path of using containers in your development environment,
    you will find that things such as environmental variables, port numbers, and runtime
    args can get a little clunky. You will find that you are going back to restarting
    a container and forgetting how it was configured. Or you may find that running
    a full integration of your application requires more than one container. This
    is where tools like `docker-compose` can help. `docker-compose` is a tool for
    running and organizing multiple containers. By writing a simple YAML file, you
    will be able to build and run containers in a simple, universal environment. As
    has been emphasized throughout this book, it is important to have simple-to-use
    tools to help developers. The compose file will even integrate into our CI pipeline
    by organizing our build parameters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在你开发环境中使用容器的道路时，你会发现诸如环境变量、端口号和运行时参数等问题可能会变得有些繁琐。你会发现你正在回到重启容器并忘记它的配置。或者你可能发现运行你应用程序的完整集成可能需要多个容器。这就是像
    `docker-compose` 这样的工具可以提供帮助的地方。`docker-compose` 是一个用于运行和组织多个容器的工具。通过编写一个简单的 YAML
    文件，你将能够在简单、通用的环境中构建和运行容器。正如本书中一直强调的那样，拥有简单易用的工具来帮助开发者是非常重要的。这个组合文件甚至可以通过组织我们的构建参数集成到我们的
    CI 管道中。
- en: 'To begin, let’s install Docker Compose. If you are using Mac or Windows, you
    are in luck! It is already installed as part of your Docker Desktop installation.
    If you are on Linux, you will need to follow the simple install here: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装 Docker Compose。如果你使用的是 Mac 或 Windows，那么你很幸运！它已经作为 Docker Desktop 安装的一部分被安装了。如果你使用的是
    Linux，你需要按照以下简单的安装步骤进行：[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)
- en: Once you have it installed, you will find a list of commands to use by typing
    `docker-compose`. Here, you will see options to build, create, and run services
    or commands. Compose requires the presence of a `docker-compose.yml` file to work.
    It will progressively look into parent directories until a suitable file is found.
    This YAML file is specially structured to give every service a unique name to
    reference, along with the image name, parameters, and many other options to help
    developers configure their containers to start. The names used in the file can
    also act as DNS entries for an internally run network that `docker-compose` builds,
    allowing services to reference each other if need be. We will explore this in
    upcoming chapters. For now, we will make a basic file to create our containers.
    Create and open `docker-compose.yml` in the root directory of your project, and
    add the code in the following listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过输入 `docker-compose` 来找到要使用的命令列表。在这里，您将看到构建、创建和运行服务或命令的选项。Compose
    需要存在一个 `docker-compose.yml` 文件才能工作。它将逐步检查父目录，直到找到一个合适的文件。这个 YAML 文件专门结构化，为每个服务提供一个独特的名称以供引用，包括镜像名称、参数以及许多其他选项，以帮助开发者配置他们的容器以启动。文件中使用的名称还可以作为
    `docker-compose` 构建的内部运行网络的 DNS 条目，允许服务在需要时相互引用。我们将在后续章节中探讨这一点。现在，我们将创建一个基本的文件来创建我们的容器。在项目的根目录中创建并打开
    `docker-compose.yml`，然后添加以下列表中的代码。
- en: Listing 7.5 `docker-compose.yml`
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 `docker-compose.yml`
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Specifies the name of the service for internal use
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定服务的名称，供内部使用
- en: ❷ Labels the service as part of the prod group for targeted deployments and
    builds
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将服务标记为生产组的一部分，以进行定向部署和构建
- en: ❸ The image you wish to use for this service
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 你希望用于此服务的镜像
- en: ❹ Separates the dev service target for debugging purposes
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将开发服务目标分离，用于调试目的
- en: ❺ Labels the service as part of the dev group for additional testing features
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将服务标记为开发组的一部分，以提供额外的测试功能
- en: ❻ The image you wish to use for this service
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 你希望用于此服务的镜像
- en: ❼ Specifies the target if you are using this for building your Docker image
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如果您使用此服务构建 Docker 镜像，请指定目标
- en: We can see that we have defined both of our builds in `docker-compose`, which
    allows us to simply type `docker-compose` `build` `api-min` to build our min file.
    Try it out! Additionally, we have added the concept of profiles, which will help
    as our application grows. Try `docker-compose` `--profile` `prod` `up` to see
    the min file start. Try this with your `dev` profile too.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们在 `docker-compose` 中定义了我们的两个构建，这使得我们可以简单地输入 `docker-compose build api-min`
    来构建我们的最小文件。试试看！此外，我们还添加了配置文件的概念，这有助于我们的应用程序增长。尝试使用 `docker-compose --profile prod
    up` 来查看最小文件启动。也可以用你的 `dev` 配置文件试试。
- en: This will become important once we add dependencies and advanced testing, but
    for now, we will use this for shipping. We can now update our pipeline to reference
    our compose file rather than bake our configuration into the build command directly.
    This will save us time and energy as we move along in our development.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了依赖项和高级测试，这将会变得很重要，但到目前为止，我们将使用它来发布。现在我们可以更新我们的管道，使其引用我们的 compose 文件，而不是直接将配置烘焙到构建命令中。这将随着我们开发工作的进行而节省我们时间和精力。
- en: Now that we have successfully deployed a tool to help us build our application
    and run it, we are poised to expand our capabilities. We can slowly and efficiently
    start building our application with its dependencies for easy local development.
    We can ensure that our services work the same on our machine as they do in our
    deployed environment because we are using the same artifact. Our compose file
    can act as a loose definition of our infrastructure that we can eventually evolve
    to suit our needs and act just like our production environment. This loose coupling
    of services allows us to focus on our code instead of trying to focus on the infrastructure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功部署了一个帮助我们构建应用程序并运行的工具，我们准备扩展我们的能力。我们可以缓慢而高效地开始构建我们的应用程序及其依赖项，以便于本地开发。由于我们使用的是相同的工件，我们可以确保我们的服务在机器上与部署环境中的表现一致。我们的
    compose 文件可以作为我们基础设施的松散定义，我们最终可以将其调整为满足我们的需求，就像我们的生产环境一样。这种服务之间的松散耦合使我们能够专注于我们的代码，而不是试图关注基础设施。
- en: 7.8 Containers, containers everywhere
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 容器，到处都是容器
- en: Containers are popular, and I’m sure you can see why. Portability and simplicity
    were game changers in the development world. Now entire operating systems can
    be shipped with products inside of them with minimal setup on the user end. Entire
    infrastructures and systems are built using containers. They run as cloud applications,
    build systems, and even robots. This is the peak of software development, right?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 容器很受欢迎，我相信你可以看到原因。可移植性和简单性在开发世界中是颠覆性的。现在，整个操作系统可以与产品一起发货，用户端的设置最小。整个基础设施和系统都是使用容器构建的。它们作为云应用程序、构建系统和甚至机器人运行。这是软件开发的高峰，对吧？
- en: Not really. The gains we have with containers are certainly helpful for developers
    and with the developer experience but are sometimes unnecessary. As we saw in
    previous chapters, sometimes software can be written to be a simple function that
    does everything you need. Or you can have a simple application that is hosted
    on a shared platform. Containers may lie underneath the surface of many of these
    technologies, but developers may not need to use them. Building and maintaining
    containers means that you are responsible for things like upgrades, security patches,
    and how to best build your application. This can create complexity in its own
    right.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 并非如此。我们通过容器获得的收益当然对开发者和开发者体验有所帮助，但有时可能是多余的。正如我们在前面的章节中看到的，有时软件可以被编写成执行所有你需要做的简单函数。或者你可以有一个简单的应用程序，它托管在共享平台上。容器可能隐藏在这些技术的大多数表面之下，但开发者可能不需要使用它们。构建和维护容器意味着你需要负责诸如升级、安全补丁以及如何最佳构建你的应用程序等问题。这本身可能会产生复杂性。
- en: There is no silver bullet in technology, so always be wary of people who preach
    otherwise. Consider the technical cost of running and building containers before
    adopting them. The portability of the product is the most important aspect. If
    you find that you are struggling with a container, you may be using it wrong.
    Remember that there are trade-offs to everything. You need to consider them before
    adopting a technology. In this case, a container may not be the best solution
    for instances of high-performing applications because you are running a virtual
    machine. Containers can be great for running tests in a clean environment, but
    the tests shouldn’t be reliant on the container to run tests locally.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 技术中没有银弹，所以总是要警惕那些宣扬相反观点的人。在采用容器之前，考虑运行和构建容器的技术成本。产品的可移植性是最重要的方面。如果你发现自己正在与容器作斗争，你可能用错了它。记住，每件事都有权衡。在采用技术之前，你需要考虑它们。在这种情况下，由于你正在运行虚拟机，容器可能不是高性能应用程序实例的最佳解决方案。容器可以在干净的环境中运行测试，但测试不应该依赖于容器在本地运行。
- en: But, as we will see in the upcoming chapters, containers have their place in
    the development cycle and can help us be more productive. As always, work with
    your team, and find what works best for you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们将在接下来的章节中看到的，容器在开发周期中也有其位置，并且可以帮助我们提高生产力。一如既往，与你的团队一起工作，找到最适合你的方法。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Containers provide an abstraction with the local operating system to help create
    a universal runtime for applications.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器提供了一个与本地操作系统的抽象层，以帮助创建适用于应用程序的通用运行时。
- en: Buildpacks focus on creating containers that run efficiently on managed platforms.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildpacks专注于创建在托管平台上高效运行的容器。
- en: Use container runtimes to use your container locally as well as in a production
    environment.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器运行时，你可以在本地以及生产环境中使用你的容器。
