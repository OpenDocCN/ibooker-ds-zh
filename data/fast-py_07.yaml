- en: 5 Re-implementing critical code with Cython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 使用 Cython 重实现关键代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How to re-implement Python code more efficiently
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更高效地重实现 Python 代码
- en: Understanding Cython from a data processing perspective
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据处理的角度理解 Cython
- en: Profiling Cython code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 Cython 代码
- en: Using Cython to implement performant NumPy functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cython 实现高效的 NumPy 函数
- en: Releasing the GIL to implement true threaded parallelism
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放 GIL 以实现真正的线程并行
- en: Python is slow. The standard implementation is slow, and the language’s dynamic
    features pay a performance toll. Many Python libraries are performant precisely
    because they are partially implemented in lower-level languages, making available
    efficient data processing algorithms. But sometimes we will need to implement
    our own high-performance algorithms in *something* faster than Python. In this
    chapter, we will consider Cython, a superset of Python that is converted to C
    and is substantially more performant than Python.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 很慢。标准实现很慢，语言的动态特性会付出性能代价。许多 Python 库之所以性能良好，正是因为它们部分是用底层语言实现的，从而提供了高效的数据处理算法。但有时我们可能需要在比
    Python 更快的“某种东西”中实现我们自己的高性能算法。在本章中，我们将考虑 Cython，它是 Python 的超集，可以转换为 C，并且比 Python
    性能好得多。
- en: There are plenty of alternatives other than Cython that can be integrated with
    Python for performance, so we will start with a brief overview of the available
    options. After that, we will delve into Cython properly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Cython 之外，还有许多其他可以与 Python 集成以提高性能的替代方案，因此我们将从对可用选项的简要概述开始。之后，我们将深入探讨 Cython。
- en: If you never used Cython in the past, this introduction will give you enough
    background from a data analytics perspective and, hence, coupled with NumPy as
    it is the core library for data analysis. We will then discuss Cython profiling
    and optimization. We will also write Cython code in a way that allows NumPy to
    release the GIL and do parallel multithreading. We finish up with a general-purpose
    parallel threaded example where our Cython code will release the GIL itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未使用过 Cython，本介绍将为您提供足够的数据分析背景知识，因此，与 NumPy 结合，因为它是数据分析的核心库。然后我们将讨论 Cython
    分析和优化。我们还将以允许 NumPy 释放 GIL 并进行并行多线程的方式编写 Cython 代码。最后，我们将完成一个通用并行线程示例，其中我们的 Cython
    代码将自行释放 GIL。
- en: But first, let’s survey other alternatives to Cython. There might be an alternative
    that fits your profile better than Cython. This is especially true if you already
    know a low-level language like C or Rust.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们了解一下 Cython 的其他替代方案。可能存在一个比 Cython 更适合您个人情况的替代方案。这尤其适用于您已经熟悉像 C 或 Rust
    这样的底层语言的情况。
- en: 5.1 Overview of techniques for efficient code re-implementation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 高效代码重实现技术概述
- en: Cython is one of the many alternatives to re-implement code in a more performant
    way. We will use it because it doesn’t require us to learn substantially more
    than Python; Cython is a superset of Python. But you should be aware of alternatives,
    either because you might know some of them already or you have some constraint
    that requires you to use something else.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是许多替代方案之一，可以以更高效的方式重实现代码。我们将使用它，因为它不需要我们比 Python 学习更多；Cython 是 Python
    的超集。但您应该了解替代方案，要么是因为您可能已经了解其中的一些，要么是因为您有一些需要使用其他东西的限制。
- en: 'Alternatives come in four shapes (table 5.1):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方案有四种形式（表 5.1）：
- en: Existing libraries
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有库
- en: Numba
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numba
- en: Faster languages, such as Cython, C, and Rust
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的语言，如 Cython、C 和 Rust
- en: Alternative Python implementations, such as PyPy, Jython, Iron Python, and Stackless
    Python
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 PyPy、Jython、IronPython 和 Stackless Python 这样的替代 Python 实现
- en: 'Table 5.1 Different approaches to efficient code re-implementation: libraries,
    faster languages, alternative Python implementations, and Numba'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 不同高效代码重实现的方法：库、更快语言、替代 Python 实现、Numba
- en: '| Libraries | Low-level languages | Alternative Python implementations | Just-in-time
    compilers |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 底层语言 | 替代 Python 实现 | 即时编译器 |'
- en: '| NumPy, SciPy, scikit-learn, PyTorch | C, Rust, Fortran, C++, Go, Cython |
    PyPy, IronPython, Jython, Stackless Python | Numba |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| NumPy、SciPy、scikit-learn、PyTorch | C、Rust、Fortran、C++、Go、Cython | PyPy、IronPython、Jython、Stackless
    Python | Numba |'
- en: NumPy is an example of an existing library that offers an efficient implementation
    of Python. There are many libraries implementing all kinds of functionality efficiently
    (e.g., pandas, scikit-learn). Before implementing your own code, be sure it’s
    not done elsewhere in an existing library.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是一个现有库的例子，它提供了Python的高效实现。有许多库以高效的方式实现了各种功能（例如，pandas、scikit-learn）。在实现你自己的代码之前，请确保它不是在现有的库中完成的。
- en: The second option worth considering is Numba. Numba is a just-in-time compiler
    that converts a subset of Python into fast native code. Numba is normally easier
    to use than another language, even Cython. There are Numba optimizations for a
    plethora of libraries, NumPy and pandas included, and to several architectures,
    including GPUs. The reason we prioritize Cython in the book is that we have a
    *hidden agenda* of explaining how things work, and there is something *magical*
    about Numba. It tries to be intelligent with the code it generates. But in this
    book, we are trying to *understand* how more efficient code can be created; as
    such, we want to go a bit deeper than just a *magic* solution. In practical terms,
    you should not discard Numba; on the contrary, for most situations it might provide
    equal performance gains compared to Cython with less work. That being said, we
    will touch upon Numba throughout the book when it makes sense; indeed, appendix
    B is dedicated to it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值得考虑的第二个选项是Numba。Numba是一个即时编译器，它将Python的一部分转换为快速的本地代码。Numba通常比另一种语言更容易使用，甚至比Cython还容易。Numba为许多库提供了优化，包括NumPy和pandas，以及多种架构，包括GPU。我们在本书中优先考虑Cython的原因是我们有一个*隐藏议程*，那就是解释事物的工作原理，而Numba有一些*神奇之处*。它试图通过生成的代码变得智能。但在这本书中，我们试图*理解*如何创建更高效的代码；因此，我们想要比仅仅提供一个*魔法*解决方案更深入一些。从实际的角度来看，你不应该放弃Numba；相反，对于大多数情况，它可能提供与Cython相当的性能提升，但工作量更少。话虽如此，当有需要时，我们将在本书中提及Numba；确实，附录B是专门为其编写的。
- en: 'The path we follow in this chapter is re-implementing code in a lower-level
    language. It happens that the language, Cython, is very close to Python, but you
    have many alternatives. C is probably the most common, but the list is almost
    never-ending: C++, Rust, Julia, and so on. Cython makes your life easier in many
    ways because it is so tightly integrated with Python. If you decide to use another
    language, you will need to research how to link the code in the other language
    to Python. For C and C++, you might want to consider Python’s built-in `ctypes`
    module or SWIG ([https://swig.org](https://swig.org)).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要遵循的路径是在更低级语言中重新实现代码。碰巧这个语言，Cython，非常接近Python，但你有很多其他选择。C可能是最常见的，但列表几乎永远不会结束：C++、Rust、Julia等等。Cython在很多方面使你的生活变得更轻松，因为它与Python紧密集成。如果你决定使用另一种语言，你需要研究如何将其他语言的代码链接到Python上。对于C和C++，你可能想要考虑Python内置的`ctypes`模块或SWIG（[https://swig.org](https://swig.org)）。
- en: Finally, you can consider using a Python implementation different from CPython.
    If you are tied to Java, you can consider Jython. If you are tied to .Net, then
    consider IronPython. The most realistic alternative to CPython is PyPy, which
    is faster because it is a just-in-time compiler. While PyPy is somewhat viable,
    it has limitations to which libraries work on it. At this stage, for most use
    cases, CPython is still the most realistic option.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以考虑使用不同于CPython的Python实现。如果你依赖于Java，你可以考虑Jython。如果你依赖于.Net，那么考虑IronPython。CPython最现实的替代品是PyPy，它更快，因为它是一个即时编译器。虽然PyPy在某种程度上是可行的，但它有一些限制，即哪些库可以在其上运行。在这个阶段，对于大多数用例，CPython仍然是现实的最现实选择。
- en: Many of these alternatives can be used in conjunction with one another. The
    core for this chapter is tying an external library, NumPy, with a low-level language,
    Cython.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些替代方案可以相互结合使用。本章的核心是将外部库NumPy与底层语言Cython绑定。
- en: Now that you are aware of the most important alternatives, let’s work on a concrete
    example using Cython. This will demonstrate how we can easily gain substantial
    computing performance with Cython.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了最重要的替代方案，让我们通过一个具体的Cython示例来工作。这将展示我们如何轻松地通过Cython获得显著的计算性能。
- en: 5.2 A whirlwind tour of Cython
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 Cython快速浏览
- en: While this is not an introductory book, it’s fair to assume there may be plenty
    of readers who have never used Cython. In this section, we’ll use a small project
    to demonstrate the basics, with a focus on performance. We will avoid many details
    about Cython compilation that, while important, are not fundamental to understand
    performance problems. You will find plenty of tutorials on the internet covering
    topics such as Cython compilation and explicit memory management, and if you want
    to study the basics, Cython’s project documentation is a good way to start ([https://cython.readthedocs.io/en/latest/](https://cython.readthedocs.io/en/latest/)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一本入门书籍，但可以合理假设可能会有很多读者从未使用过 Cython。在本节中，我们将通过一个小项目来展示基础知识，重点关注性能。我们将避免许多关于
    Cython 编译的细节，尽管这些细节很重要，但不是理解性能问题的基本要素。你可以在互联网上找到大量关于 Cython 编译和显式内存管理的教程，如果你想学习基础知识，Cython
    的项目文档是一个很好的起点 ([https://cython.readthedocs.io/en/latest/](https://cython.readthedocs.io/en/latest/))。
- en: Here we will take the example from the previous chapter, image processing, and
    build a filter that takes an image, generates a grayscale version, and then darkens
    it according to a value on another image of the same size. Our first implementation
    might not necessarily be faster—we will get that later in the chapter—but it will
    introduce fundamental Cython concepts that are needed before we speed up the code.
    Figure 5.1 provides an example output to make this clear.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从上一章的例子，图像处理，构建一个过滤器，该过滤器接受一个图像，生成一个灰度版本，然后根据另一个相同大小的图像上的值进行变暗。我们的第一次实现可能不一定更快——我们将在本章后面得到这个结果——但它将介绍在加速代码之前需要的
    Cython 基本概念。图 5.1 提供了一个示例输出以使这一点更清晰。
- en: '![](../Images/CH05_F01_Antao.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Antao.png)'
- en: Figure 5.1 The original image (here in grayscale), the processed image, and
    the filter applied
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 原始图像（此处为灰度图）、处理后的图像以及应用的过滤器
- en: Let’s go ahead and implement the filter code in Cython. For performance comparison,
    the code in the repository allows you to run a native Python implementation. For
    reference, the native Python code takes 35 s on my computer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在 Cython 中实现过滤代码。为了进行性能比较，仓库中的代码允许你运行原生 Python 实现。为了参考，原生 Python 代码在我的电脑上需要
    35 秒。
- en: 5.2.1 A naive implementation in Cython
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 Cython 中的简单实现
- en: Our image filter will use NumPy and Pillow for image processing as in the previous
    chapter. The image will be in color; hence, there will be three RGB components.
    The filter will vary between 0 to 255, with 0 being no darkening and 255 being
    completely black. Our code first converts each pixel to grayscale and then does
    the darkening.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图像过滤器将使用 NumPy 和 Pillow 进行图像处理，就像上一章一样。图像将是彩色的；因此，将有三个 RGB 分量。过滤器的值将在 0 到
    255 之间变化，0 表示没有变暗，255 表示完全变黑。我们的代码首先将每个像素转换为灰度，然后进行变暗。
- en: 'We are now going to do the first implementation in Cython. We will divide the
    code into two parts: The Python code that *calls* the Cython code in a normal
    `.py` file and the Cython code proper, which is written in a file with a `.pyx`
    extension. `.pyx` comes from Pyrex, the project from which Cython was originally
    forked. The Python code is in `05-cython/sec1-intro/apply_filter.py`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 Cython 进行第一次实现。我们将把代码分成两部分：在正常的 `.py` 文件中调用 Cython 代码的 Python 代码，以及真正的
    Cython 代码，它是以 `.pyx` 扩展名编写的文件。`.pyx` 来自 Pyrex，这是 Cython 最初分叉的项目。Python 代码位于 `05-cython/sec1-intro/apply_filter.py`：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① pyximport will take care of compiling and loading Cython code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ① pyximport 将负责编译和加载 Cython 代码。
- en: ② We want Python 3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们需要 Python 3。
- en: ③ We need to use NumPy headers for compilation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们需要使用 NumPy 头文件进行编译。
- en: ④ We will be implementing the Cython code in a module called cyfilter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们将在一个名为 cyfilter 的模块中实现 Cython 代码。
- en: The only conceptually new piece in the previous code is related to `pyximport`.
    This will take care of compiling and linking the Cython code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中唯一概念上新的部分与 `pyximport` 相关。这将负责编译和链接 Cython 代码。
- en: Linking Cython code
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 链接 Cython 代码
- en: Remember that Cython is a superset of Python, which compiles to C, making the
    code available as a foreign extension. It’s not as easy as simply importing a
    native Python module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Cython 是 Python 的超集，编译成 C，使代码可以作为外部扩展使用。这并不像简单地导入原生 Python 模块那样简单。
- en: 'There are several ways to take care of the whole process, as referenced in
    the Cython documentation. We won’t go into all of them here, but I will point
    out three approaches of note:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以处理整个过程，如 Cython 文档中所述。我们不会在这里详细介绍所有这些方法，但我会指出三种值得注意的方法：
- en: The approach used here, `pyximport`, will take care of compiling the code and
    linking it in a way that is transparent and easy. Every time you import a Cython
    module, the code might be converted to C, compiled, and linked, and as such, you
    pay a performance price at startup, but only at startup. Just make sure that when
    you are profiling, you discount this time in some way.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里使用的方法 `pyximport` 将负责以透明和简单的方式编译代码并进行链接。每次你导入一个 Cython 模块时，代码可能会被转换为 C 语言，编译并链接，因此你将在启动时付出性能代价，但仅限于启动时。只需确保在分析性能时，以某种方式排除这部分时间。
- en: If you are using Jupyter/IPython Notebook, the `%cython` magic is available.
    See either the Cython or IPython documentation for details.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用 Jupyter/IPython Notebook，则 `%cython` 魔法是可用的。有关详细信息，请参阅 Cython 或 IPython
    文档。
- en: Directly calling `cython` over the `.pyx` file. This approach will require us
    to do our own linking. We will use it later in the chapter, but just to take a
    peek at the generated code.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在 `.pyx` 文件上调用 `cython`。这种方法将需要我们自行进行链接。我们将在本章后面使用它，但只是为了看看生成的代码。
- en: If you are in Jupyter or more generally in IPython, `%cython` takes care of
    everything for you, and it’s really easy; I recommend it if you are working with
    Jupyter or IPython. But if you plan to distribute the code to general Python users,
    you cannot use it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Jupyter 或更普遍地使用 IPython，`%cython` 会为你处理一切，而且非常简单；如果你使用 Jupyter 或 IPython
    进行工作，我推荐使用它。但如果你计划将代码分发给一般的 Python 用户，则不能使用它。
- en: Calling `cython` directly is mostly useful to inspect the C code. There is no
    real pragmatic reason to do it for any other use case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用 `cython` 主要用于检查 C 语言代码。对于任何其他用例，实际上并没有真正的实用理由去做这件事。
- en: When putting your code in production or preparing to distribute it to users,
    other alternatives should be used. Most probably you will have to precompile your
    Cython code for the target architectures, as requiring your users to have a complete
    C compiler stack is normally asking for too much. Preparing code for distribution
    is a fairly complex subject, which we will not address here, and for the purposes
    of this book, it’s not very relevant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当将代码投入生产或准备分发给用户时，应使用其他替代方案。很可能会需要为目标架构预编译您的 Cython 代码，因为要求用户拥有完整的 C 编译器栈通常要求过多。准备代码以分发是一个相当复杂的话题，我们在此不予讨论，并且对于本书的目的来说，这并不非常相关。
- en: 'The Cython code is, for now, *exactly the same* as the Python version. It is
    just in a `pyx` file (`05-cython/sec2-intro/cyfilter.pyx`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Cython 代码与 Python 版本完全相同。它只是位于一个 `pyx` 文件中（`05-cython/sec2-intro/cyfilter.pyx`）：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① The first line is not really a comment. It is instructing Cython to compile
    for Python version 3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ① 第一行实际上并不是注释。它是指导 Cython 为 Python 3 版本编译。
- en: Save for the first line and the function name, the code is the same as the Python
    version. If you call the Python top-level file, you will be sorely disappointed.
    On my computer, it took 33 s. Just 2 s less than the native Python version. In
    the next section, we will write something much faster and determine why the previous
    version is slow.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一行和函数名之外，代码与 Python 版本相同。如果你调用 Python 顶级文件，你将会非常失望。在我的电脑上，它花费了 33 秒。仅比原生
    Python 版本少 2 秒。在下一节中，我们将编写一些运行得更快的东西，并确定为什么之前的版本运行缓慢。
- en: Cython as a compiled language
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为编译型语言的 Cython
- en: Cython is a compiled language, not interpreted as Python. That has many consequences;
    one of them regards where you find certain types of errors. For example, this
    code
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是一种编译型语言，而不是像 Python 那样解释执行。这带来了许多后果；其中之一涉及到你会在哪里发现某些类型的错误。例如，这段代码
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: will fail *only* at run time in Python, so you can deploy it in production and
    be oblivious to the problem. But it will immediately fail when you try to compile
    it as a Cython program. In this regard, Cython helps a bit with catching bugs,
    but be prepared for the Cython compiler to nag you about errors that Python would
    not catch.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将仅在 Python 运行时失败，因此你可以将其部署到生产环境中而无需担心问题。但是，当你尝试将其作为 Cython 程序编译时，它将立即失败。在这方面，Cython
    有助于捕获一些错误，但请准备好 Cython 编译器会对你提出一些 Python 不会捕获的错误进行抱怨。
- en: 5.2.2 Using Cython annotations to increase performance
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 使用 Cython 注释提高性能
- en: 'Before we dig into the reasons why the previous code is slow, let’s produce
    a faster version so that we have something to compare with. The faster version
    depends on using the Cython annotation system:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨为什么之前的代码运行缓慢的原因之前，让我们先生成一个更快的版本，以便我们可以进行比较。更快的版本依赖于使用 Cython 注释系统：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① We import C-level definitions for NumPy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入 NumPy 的 C 级定义。
- en: ② We type the first parameter as a C-level NumPy array with three dimensions;
    remember that for a color image, we have three components (RGB) per pixel. The
    type is a C-level unsigned integer of 8 bits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们将第一个参数作为具有三个维度的C级NumPy数组输入；记住，对于彩色图像，每个像素有三个组件（RGB）。类型是8位无符号整数。
- en: ③ The second parameter is a two-dimensional array of 8-bit unsigned integers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 第二个参数是一个8位无符号整数的二维数组。
- en: ④ We also type all local variables. Tuple assignment is sometimes not possible
    with Cython, so we split the tuple assignment into two.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们还指定了所有局部变量。元组赋值在Cython中有时是不可能的，所以我们把元组赋值拆分成两个。
- en: ⑤ Typing of variables must be done at the beginning of the function, so we define
    the inner loop variables before we enter it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 变量的类型必须在函数的开始处指定，因此我们在进入内部循环之前定义内部循环变量。
- en: ⑥ This is a slightly more efficient way to compute a mean.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 这是一种计算平均值稍微高效一些的方法。
- en: 'The really important difference in this code is the use of Cython annotations.
    For example, `nrows` becomes `cdef int nrows`: we inform Cython that the variable
    is of the type `int`. This definition will be operative at the C level as Cython
    code is converted to C. It is possible to have C-level definitions of external
    libraries like NumPy; that is exactly what `cimport numpy as cnp` imports. Then
    we can type arrays.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中真正重要的区别是Cython注释的使用。例如，`nrows`变成了`cdef int nrows`：我们通知Cython该变量是`int`类型。这个定义将在C级别生效，因为Cython代码被转换为C。可以对外部库如NumPy进行C级别的定义；这正是`cimport
    numpy as cnp`所导入的。然后我们可以指定数组。
- en: Warning Cython-level–type annotations are completely different from modern Python-level
    annotations, and the two have no relation to each other.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Cython级别的类型注释与现代Python级别的注释完全不同，两者之间没有任何关系。
- en: Note that save for the mean calculation and the tuple assignment split, the
    code is exactly the same. Namely, the two `for` loops have the same complexity.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了平均值计算和元组赋值拆分外，代码完全相同。也就是说，两个`for`循环具有相同的复杂度。
- en: Run time falls from ~30 s in the native Python version to 1.5 s—20 times faster.
    Now we are getting somewhere.[¹](#pgfId-1013317)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间从原生Python版本的约30秒降低到1.5秒——快了20倍。现在我们正在取得进展。[¹](#pgfId-1013317)
- en: Tip Annotate *all* your Cython variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：注释你的所有Cython变量。
- en: This code can still be made several times faster. We will discuss techniques
    for that later in the chapter. But for now, we will turn our attention to *understanding*
    why the annotations are so important.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还可以进一步加快速度。我们将在本章后面讨论加快速度的技术。但到目前为止，我们将把注意力转向*理解*为什么注释如此重要。
- en: 5.2.3 Why annotations are fundamental to performance
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 为什么注释对性能至关重要
- en: 'Why are annotations so important for performance? To answer that, we need to
    look at the C-generated code for our functions. Even if you do not know C, there
    is no reason to be afraid: reading C is substantially easier than writing it,
    and you will get the gist of it easily.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么注释对性能如此重要？为了回答这个问题，我们需要查看我们函数的C生成代码。即使你不知道C，也没有理由害怕：阅读C代码比编写它容易得多，你将很容易理解其精髓。
- en: 'We will use a trivial example: add 4 to a number. Here is the code with and
    without annotations (this code is in `05-cython/sec2-intro/add4.pyx`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的例子：给一个数字加4。以下是带注释和不带注释的代码（此代码位于`05-cython/sec2-intro/add4.pyx`）：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Simple right? To be able to see the C-generated code, we will run Cython directly:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吗？为了能够看到C生成的代码，我们将直接运行Cython：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will generate a C file called `add4.c`. My version of Cython has almost
    3,000 lines. No reason to panic: most of it is boilerplate, and Cython makes it
    very easy to find our code and learn what is generated. You can find every line
    of your code inside C comments so that you know what is being generated. For example,
    this is generated by Cython:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为`add4.c`的C文件。我的Cython版本有近3000行。没有必要恐慌：其中大部分是样板代码，Cython使得找到我们的代码并了解生成的代码变得非常容易。你可以在C注释中找到你代码的每一行，这样你就可以知道正在生成什么。例如，这是由Cython生成的：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For each of our functions, Cython generates two C functions: A Python wrapper—responsible
    for interfacing between Python and C—and the function implementation proper.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们每个函数，Cython生成两个C函数：一个Python包装器——负责Python和C之间的接口——以及函数的正确实现。
- en: 'So, for `add4`, we have a C wrapper, which is:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`add4`，我们有一个C包装器，如下所示：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you think in terms of Python, not C or Cython, this makes sense: the function
    returns a Python object, `static PyObject *`. `self` is also a Python object,
    `PyObject *__pyx_self`, and the parameter is `PyObject *__pyx_v_my_number`. Python
    only knows objects.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从Python的角度思考，而不是C或Cython，这很有道理：函数返回一个Python对象，`static PyObject *`。`self`也是一个Python对象，`PyObject
    *__pyx_self`，参数是`PyObject *__pyx_v_my_number`。Python只知道对象。
- en: 'Here is the signature for the wrapper of `add4_annotated`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`add4_annotated`包装器的签名：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The types are *exactly the same*, and this makes sense: remember that Python
    only sees objects. Thus, at the Python interface level, the functions are the
    same.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类型**完全相同**，这很有道理：记住Python只看到对象。因此，在Python接口级别上，函数是相同的。
- en: 'Both wrappers do a lot of packing and unpacking and then call the implementations.
    Here is the signature for the implementation of `add4`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 两个包装器都做了大量的打包和拆包，然后调用实现。以下是`add4`实现的签名：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The types are mostly the same. This makes sense as we did not annotate the function
    and Cython to create code for the most general case.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类型**大多相同**。这很有道理，因为我们没有注释函数和Cython来为最通用的情况创建代码。
- en: 'Here is the function signature for `add4_annotated`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`add4_annotated`函数的签名：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the type `my_number` is now a native C type, not a Python object,
    `int __pyx_v_my_number`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型`my_number`现在是一个原生C类型，而不是Python对象，`int __pyx_v_my_number`。
- en: If you look at the wrapper for both functions, you will notice that the wrapper
    for the annotated function is more complicated, with a lot of packing and unpacking
    of types. The non-annotated wrapper can just pass parameters to the implementation
    as it deals with Python objects. But the annotated wrapper must manage the Python
    object to int conversions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这两个函数的包装器，你会注意到，注释函数的包装器更复杂，有很多类型的打包和拆包。非注释包装器可以直接将参数传递给实现，因为它处理的是Python对象。但注释包装器必须管理Python对象到整数的转换。
- en: 'After all these preliminaries, we arrive at the fundamental problem: the implementation
    of `i = my_number + 4`. This is what we have for the non-annotated version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些预备知识之后，我们来到了基本问题：`i = my_number + 4`的实现。这是非注释版本的内容：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code is calling the function `__Pyx_PyInt_AddObjC` to add an integer to
    an object. This function is defined in the source code `add4.c`. You are invited
    to inspect that monstrosity. You will find a lot of calls to the CPython functions,
    a lot of C `if`s, and, in some cases, even a `goto` call. Remember that all this
    is in service of adding 4 to a variable. It is extremely burdensome.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在调用函数`__Pyx_PyInt_AddObjC`将一个整数添加到一个对象上。这个函数在源代码`add4.c`中定义。欢迎你检查这个怪物。你会找到很多对CPython函数的调用，很多C
    `if`语句，在某些情况下，甚至有`goto`调用。记住，所有这些都是为了将4加到一个变量上。这非常繁琐。
- en: 'There is another serious problem with this code: because we are dealing with
    Python objects, Cython cannot release the GIL. Python code is GIL bound, but lower-level
    code can, in certain circumstances, release the GIL. As this code stands, the
    GIL cannot be released, and as such, we cannot have parallel threads.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还有一个严重的问题：因为我们正在处理Python对象，Cython无法释放GIL。Python代码是GIL绑定的，但在某些情况下，底层代码可以释放GIL。按照目前的代码，GIL无法被释放，因此，我们无法有并行线程。
- en: In reality, the biggest problem is the former—the implementation of the sum—as
    it is mostly spent on managing Python objects. Even if we could, although we can’t,
    make a parallel version of it, the loss from Python manipulation of the sum would
    be much bigger than the gain from using a handful of parallel cores.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，最大的问题是前者——求和的实现——因为它大部分时间都在管理Python对象。即使我们能够，尽管我们做不到，制作它的并行版本，Python操作求和的损失将远大于使用少量并行核心的收益。
- en: 'Without further ado, here is the annotated version from `add4_annotated`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，以下是来自`add4_annotated`的注释版本：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a simple C-level addition and, as such, should be *orders of magnitude
    faster* than the non-annotated version.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的C级别添加，因此，它应该比非注释版本**快几个数量级**。
- en: The takeaway
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的教训
- en: Annotations help Cython to remove a lot of CPython infrastructure from the C
    version of your code. As such, annotated Cython will run faster than non-annotated
    Cython, and I recommend using annotated Cython whenever possible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注释帮助Cython从你的代码的C版本中移除大量的CPython基础设施。因此，注释的Cython将比非注释的Cython运行得更快，我建议尽可能使用注释的Cython。
- en: 5.2.4 Adding typing to function returns
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 为函数返回添加类型
- en: 'You can also type function returns like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样为函数返回添加类型：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that not only the `int` return type but also that the function are now
    defined using `cdef` and not `def`. This is a function that can only be called
    from C. If you try to call this from Python, it will not work because there is
    no wrapper. What is the advantage of this? For Cython functions that are called
    *only* from other Cython functions, it is possible to declare a function to be
    usable from Python and Cython (i.e., a different interface will be used if called
    from Python or Cython):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不仅返回类型是 `int`，而且函数现在使用 `cdef` 而不是 `def` 定义。这是一个只能从 C 调用的函数。如果你尝试从 Python
    调用它，它将不会工作，因为没有包装器。这有什么优势呢？对于仅从其他 Cython 函数调用的 Cython 函数，可以声明一个函数可以从 Python 和
    Cython 使用（即，如果从 Python 或 Cython 调用，将使用不同的接口）：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, you get both the wrapper and the low-level implementation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将得到包装器和底层实现。
- en: 'So you have three ways of declaring a function: Cython only, which interfaces
    with `cdef`; both Python and Cython, which interface with `cpdef`; and Python
    only, which interfaces with `def`. Any time you need to go through a Python native
    interface, you are sure to pay a performance price. When you go through a Cython-only
    interface, your burden will be smaller. (As we have seen in the previous section,
    a `def` function generates both levels, but that is an implementation detail that
    is not assured if you use `def`.)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你有三种声明函数的方式：仅使用 Cython，它通过 `cdef` 接口；Python 和 Cython 都可以使用，通过 `cpdef` 接口；以及仅使用
    Python，通过 `def` 接口。任何需要通过 Python 原生接口的时候，你都会付出性能的代价。当你通过仅使用 Cython 的接口时，你的负担会更小。（正如我们在上一节中看到的，`def`
    函数会生成两个级别的接口，但这并不是使用 `def` 时可以保证的实现细节。）
- en: Why not always use `cpdef` instead of `def` and `cdef`? Sometimes you want to
    use `def` as `cpdef` and `cdef` to impose extra restrictions on the function implementation
    and sometimes you have an explicit need to add annotations. `cdef` is needed when
    you are using types that Python cannot understand, for example, C pointers written
    in Cython code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不总是使用 `cpdef` 而不是 `def` 和 `cdef` 呢？有时你想要使用 `def` 作为 `cpdef` 和 `cdef` 来对函数实现施加额外的限制，有时你有明确的需要添加注解。当你使用
    Python 无法理解的数据类型时，需要 `cdef`，例如，在 Cython 代码中编写的 C 指针。
- en: The takeaway
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的经验教训
- en: Always annotate types with Cython; the upside is tremendous with no downside
    other than the hassle of writing the annotations. If possible, use `cdef`. If
    it’s not possible, consider having the code refactored so that you have the Python
    linked part in a `def/cpdef` and the computationally intensive part in a `cdef`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总是用 Cython 注释类型；好处巨大，唯一的缺点是编写注释的麻烦。如果可能，使用 `cdef`。如果不可能，考虑重构代码，以便你有一个在 `def/cpdef`
    中的 Python 链接部分，以及在 `cdef` 中的计算密集部分。
- en: Now that we have a deeper understanding of *why* annotations are important for
    performance, let’s continue to fine-tune our code by profiling our Cython code.
    ,
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对为什么注释对性能很重要有了更深入的理解，让我们继续通过分析我们的 Cython 代码来微调我们的代码。
- en: 5.3 Profiling Cython code
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 分析 Cython 代码
- en: Let’s get back to our Cython-based image filtering code. While it is substantially
    faster than the pure Python implementation, it still *feels* a bit slow. After
    all, it’s more than 1 s to apply a trivial filter. While our intuition serves
    us well to suspect there is a problem, as we noted in chapter 2, gut feelings
    with performance analysis tend to deliver bad results, so we will revisit profiling
    from a Cython perspective to rigorously find remaining bottlenecks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的基于 Cython 的图像过滤代码。虽然它比纯 Python 实现快得多，但仍然感觉有点慢。毕竟，应用一个简单的过滤器需要超过 1 秒。虽然我们的直觉使我们怀疑存在问题，但正如我们在第
    2 章中提到的，性能分析中的直觉往往会导致不良结果，所以我们将从 Cython 视角重新审视分析，以严格找到剩余的瓶颈。
- en: Cython profiling is well integrated with that of native Python. The profiling
    techniques of chapter 2 can readily be used here. As such, we will line profile
    our function to find the sources of delay.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 分析与原生 Python 的分析很好地集成。第 2 章中介绍的分析技术可以在这里直接使用。因此，我们将对函数进行逐行分析，以找到延迟的来源。
- en: 5.3.1 Using Python’s built-in profiling infrastructure
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 使用 Python 的内置分析基础设施
- en: 'We will start with using the built-in profiling infrastructure. The first thing
    we need to do is to annotate our Cython code, so we generate profilable code.
    This is quite simple to do. Here are the annotations for our darkened annotated
    function (the code is in `05-cython/sec3-profiling/cython_prof.py`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始使用内置的分析基础设施。我们首先需要做的是注释我们的 Cython 代码，以便生成可分析代码。这相当简单。以下是我们的暗色注释函数的注释（代码位于
    `05-cython/sec3-profiling/cython_prof.py`）：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① We tell Cython that we want our code to be profiled.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们告诉 Cython 我们想要我们的代码被配置文件。
- en: It is as simple as adding the global directive in the code. If, for some reason,
    you don’t want to instrument a specific function in your file, just add `@cython.profile(False)`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像在代码中添加全局指令一样简单。如果你出于某种原因不想对你的文件中的特定函数进行检测，只需添加 `@cython.profile(False)`。
- en: 'As a variation from the profiling example in chapter 2, let’s use the built-in
    `pstat` module to get profiling statistics. Here is our caller function (see `code/05-cython/
    sec3-profiling/apply_filter_prof.py`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对第二章中配置文件示例的变体，让我们使用内置的 `pstat` 模块来获取配置文件统计信息。以下是我们的调用函数（见 `code/05-cython/sec3-profiling/apply_filter_prof.py`）：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① We will take care of running the profiling code from within.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将负责在内部运行配置文件代码。
- en: ② The pstats module processes the output of the profiler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ② pstats 模块处理分析器的输出。
- en: ③ We call the profiler on our function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们在我们的函数上调用分析器。
- en: ④ We use the pstats module to print the collected statistics.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们使用 pstats 模块来打印收集到的统计信息。
- en: 'With regard to profiling, there is nothing in this code that is Cython specific.
    The output is:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置文件，这段代码中没有 Cython 特有的内容。输出如下：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Details about the output are discussed in chapter 2\. As we saw in chapter 2
    as well, built-in profiling is sometimes not as informative as we would like.
    With this in mind, let’s revisit line profiling, now in the context of Cython.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关于输出的详细信息请参阅第二章。正如我们在第二章中看到的那样，内置的配置文件有时并不像我们希望的那样具有信息量。考虑到这一点，让我们重新审视行配置文件，现在是在
    Cython 的背景下。
- en: 5.3.2 Using line_profiler
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 使用 line_profiler
- en: 'We will use the `line_profiler` module, just like in chapter 2\. For that,
    we have to instruct Cython to instrument our code for line profiling (see `05-cython/sec3-profiling/
    cython_lprof.py` in the repository for details):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `line_profiler` 模块，就像在第二章中一样。为此，我们必须指示 Cython 为行配置文件检测我们的代码（有关详细信息，请参阅存储库中的
    `05-cython/sec3-profiling/cython_lprof.py`）：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① We need Python-like bindings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们需要 Python 类型的绑定。
- en: ② We tell Cython to generate line-tracing code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们告诉 Cython 生成行跟踪代码。
- en: 'The only change we need is to instruct Cython to generate the line-tracing
    instrumentation. We use the directive `# cython: linetrace=True` to accomplish
    that. You can also activate line tracing on a function-by-function basis by not
    using the directive and instead annotating each function that you want to profile:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要做的唯一改变是指导 Cython 生成行跟踪检测代码。我们使用指令 `# cython: linetrace=True` 来实现这一点。你还可以通过不使用指令，而是注释每个你想要配置文件检测的函数来逐个函数地激活行跟踪：'
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You might remember from chapter 2 that line tracing is very slow. For that
    reason, Cython requires that you not only annotate your Cython code with `linetrace`
    but also that you explicitly request tracing when you *use* the code. To see this
    in action, let’s check the code that calls this function (i.e., the Python side):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，从第二章中，行跟踪非常慢。因此，Cython 要求你不仅用 `linetrace` 注释你的 Cython 代码，而且当你 *使用* 代码时，你必须明确请求跟踪。为了看到这个动作，让我们检查调用此函数的代码（即
    Python 端）：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① We import line_profiler.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入 line_profiler。
- en: ② We need to compile the C code with the CYTHON_TRACE macro.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们需要用 CYTHON_TRACE 宏编译 C 代码。
- en: ③ We will explicitly call line_profiler here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们将在这里显式调用 line_profiler。
- en: We must not forget to activate the C code that does the instrumentation. The
    C code is wrapped in C macros and is only compiled if the directive `CYTHON_TRACE`
    is passed to the compiler. We do this by instructing pyximport via the distutils
    system. Both the C macro system and the Python building infrastructure are beyond
    the scope of this book. But you have to make sure that the `CYTHON_TRACE` macro
    is defined in whatever system you use to compile your C code—remember, pyximport
    is one of several options.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住激活执行检测的 C 代码。C 代码被 C 宏封装，并且只有当编译器传递指令 `CYTHON_TRACE` 时才会编译。我们通过 distutils
    系统指导 pyximport 来完成此操作。C 宏系统和 Python 构建基础设施超出了本书的范围。但你要确保在编译你的 C 代码的系统（记住，pyximport
    是几个选项之一）中定义了 `CYTHON_TRACE` 宏。
- en: Here we instrument the `line_profiler` machinery directly from our code; in
    chapter 2, we used a different approach by calling our code with `kernprof`. We
    create the `LineProfiler` object, call `darken_annotate` inside it, and print
    the statistics. As an exercise, before we look at the result, think about *your
    expectations* of where the bottleneck is. Then have a look at the following figure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们直接从我们的代码中配置`line_profiler`机制；在第2章中，我们通过调用`kernprof`来使用不同的方法。我们创建`LineProfiler`对象，在其中调用`darken_annotate`，并打印统计信息。作为一个练习，在我们查看结果之前，思考一下你对瓶颈位置的*预期*。然后看看下面的图。
- en: '![](../Images/CH05_UN01_Antao.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_UN01_Antao.png)'
- en: The run time for our function is 3.5 s; this is substantially more than the
    1.5 s for the whole run before. Remember that line profiling is very expensive
    and incurs overhead. We should not compare the *absolute* timings of standard
    profiling with line profiling, as they are expected to be different. We also need
    to be a bit more patient while profiling.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的运行时间为3.5秒；这比之前的整个运行时间1.5秒多得多。记住，行分析非常昂贵，并产生开销。我们不应该将标准分析与行分析的*绝对*时间进行比较，因为它们预期会有所不同。我们还需要在分析时更加耐心。
- en: The apparently innocent assignment `pixel = image[row, col]` is taking 60% of
    the time. Was this what you expected?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看似无辜的赋值`pixel = image[row, col]`占用了60%的时间。这是你预期的吗？
- en: 'The easiest way to understand what is slowing us down is again to do `cython
    cyfilter_ lprof.py` and have a look at the generated code. This C-analysis case
    is easier than the first example presented; in that case, we can use a web report
    produced by Cython with `cython -a cyfilter_lprof.py`. An HTML file is created—cyfilter_lprof.html—and
    can be opened with any web browser. Figure 5.2 shows the main view for our function.
    You can click each line and see which C code is generated for it. The grayed-out
    lines (in the browser version they would be in yellow) hint at interactions with
    the Python machinery: if the Python machinery is required you can bet that performance
    will suffer.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 理解什么在拖慢我们速度的最简单方法再次是执行`cython cyfilter_lprof.py`并查看生成的代码。这个C分析案例比第一个示例更容易；在那个例子中，我们可以使用Cython通过`cython
    -a cyfilter_lprof.py`生成的网络报告。一个HTML文件被创建——cyfilter_lprof.html——可以用任何网络浏览器打开。图5.2显示了我们的函数的主视图。你可以点击每一行，并查看为其生成的C代码。灰色（在浏览器版本中为黄色）的线条暗示了与Python机制的交互：如果需要Python机制，你可以肯定性能会受到影响。
- en: '![](../Images/CH05_F02_Antao.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F02_Antao.png)'
- en: Figure 5.2 The web output for cyfilter_lprof.html. The lines that are grayed
    out (in the browser version they would be in yellow) hint at interactions with
    Python.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 cyfilter_lprof.html的网页输出。灰色（在浏览器版本中为黄色）的线条暗示了与Python的交互。
- en: 'If you expand line 22—our “innocent” assignment of `pixel = image[row, col]`—you
    will see that there is much more there than just an assignment. There are many
    C calls that raise many performance flags: `__Pyx_PyInt_From_int`, `PyTuple_New`,
    `__Pyx_ PyObject_GetItem`, and `__Pyx_SafeReleaseBuffer` all seem to be invoking
    a lot of potentially slow stuff for something that should be a simple assignment,
    at least at the C level.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展开第22行的代码——我们的“无辜”的赋值`pixel = image[row, col]`——你会看到这里不仅仅是赋值。有许多C调用会引发许多性能标志：`__Pyx_PyInt_From_int`、`PyTuple_New`、`__Pyx_PyObject_GetItem`和`__Pyx_SafeReleaseBuffer`似乎都在为应该是一个简单赋值的操作调用很多可能很慢的东西，至少在C级别上是这样。
- en: The takeaway
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的经验教训
- en: While we informed Cython of lower-level types with our previous Cython annotations,
    the profiling process indicates that it is still manipulating NumPy arrays. If
    the code operations are interacting with Python objects like NumPy arrays, the
    whole Python machinery is still required to run the code. Involving that machinery
    is a sure way to drag down your performance rates.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通过之前的Cython注解通知了Cython低级类型，但分析过程表明它仍在操作NumPy数组。如果代码操作与Python对象（如NumPy数组）交互，整个Python机制仍然需要运行代码。涉及这个机制是降低性能的可靠方法。
- en: 'The question then becomes: can we look at these arrays more efficiently and
    make the code for an innocent assignment simpler? It turns out we can.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题变成了：我们能否更有效地查看这些数组，并使无辜赋值的代码更简单？结果是我们可以做到。
- en: 5.4 Optimizing array access with Cython memoryviews
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 使用Cython内存视图优化数组访问
- en: To accelerate our code, we need to reduce the interaction with Python objects
    to the least amount possible—ideally, zero. We need to remove Python built-ins
    *and* Python views of NumPy arrays. In our current example, we still have our
    arrays as Python objects, and we need to change that.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加速我们的代码，我们需要将与 Python 对象的交互减少到尽可能少的程度——理想情况下为零。我们需要移除 Python 内置函数和 Python
    对 NumPy 数组的视图。在我们的当前示例中，我们仍然有作为 Python 对象的数组，我们需要改变这一点。
- en: 'It turns out that Cython has a concept of memoryview for NumPy arrays, which
    is somewhat similar to the equally named concept that we explored in the previous
    chapter. It is possible for Cython to directly access the raw array representation
    without using Python’s object machinery. We will separate our Cython code into
    two functions: one to deal with Python objects, which cannot ever be that fast,
    and another to work at C-level speeds. So one receives the NumPy arrays and prepares
    the memoryviews, and the other applies the image filter (see `05-cython/sec4-memoryview`
    in the repository). Let’s start with the function that takes NumPy arrays and
    prepares memoryviews:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，Cython 对于 NumPy 数组有一个内存视图的概念，这与我们在上一章中探索的同等名称的概念有些相似。Cython 可以直接访问原始数组表示，而无需使用
    Python 的对象机制。我们将我们的 Cython 代码分为两个函数：一个用于处理 Python 对象，这些对象永远无法那么快，另一个以 C 级别速度工作。所以一个接收
    NumPy 数组并准备内存视图，另一个应用图像过滤器（见存储库中的 `05-cython/sec4-memoryview`）。让我们从接收 NumPy 数组并准备内存视图的函数开始：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① This declares a memory view that will point to dark_image raw data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这声明了一个将指向 dark_image 原始数据的内存视图。
- en: ② Here we make Cython resolve the view to the raw data of the NumPy array.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在这里，我们让 Cython 将视图解析为 NumPy 数组的原始数据。
- en: ③ Finally, we call a new function, darken_annotated_mv, that deals with views
    only.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 最后，我们调用一个新的函数，darken_annotated_mv，它只处理视图。
- en: 'Notice the syntax to declare memoryviews: it has a C type and the dimensionality
    needs to be known (e.g., `[:,:,:]` for the three dimensions of `image`). Cython
    will make sure that the memoryview variables point to the raw data of the array
    with correct strides and shapes.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意声明内存视图的语法：它有一个 C 类型，并且需要知道维度（例如，`[:,:,:]` 用于 `image` 的三个维度）。Cython 将确保内存视图变量指向具有正确步长和形状的数组原始数据。
- en: 'Lets now look at the new inner function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看新的内部函数：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① We change the type of the input parameters from Numpy arrays to views.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将输入参数的类型从 Numpy 数组更改为视图。
- en: ② The output is now a parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ② 输出现在是一个参数。
- en: The code ends up being very similar to the original version. The input types
    are changed from arrays to memoryviews, and just to have a cleaner version, we
    are passing the output view as a parameter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最终与原始版本非常相似。输入类型已从数组更改为内存视图，为了得到一个更干净的版本，我们将输出视图作为参数传递。
- en: The performance gets a bit better from line profiling, as shown in the following
    figure.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，性能通过行分析有所提升。
- en: '![](../Images/CH05_UN02_Antao.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_UN02_Antao.png)'
- en: It is now 50% faster, and the “innocent” assignment `pixel = image_mv[row, col]`
    is now more innocent in the sense that it requires no Python object management
    code. However, insight suggests that it still takes way too much time for a simple
    image manipulation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在速度提高了 50%，并且“无辜”的赋值 `pixel = image_mv[row, col]` 现在在意义上更加“无辜”，因为它不需要 Python
    对象管理代码。然而，洞察力表明，对于简单的图像处理，它仍然花费了太多的时间。
- en: It turns out that a lot of Python interactions are still happening in this code.
    If we run `cython -a`, generating a web page for the code that colors each code
    line with the amount of Python interactions, we get a lot of marked interactions
    as shown in figure 5.3.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在这个代码中仍然有很多 Python 交互。如果我们运行 `cython -a`，生成一个代码网页，为每行代码着色以显示 Python 交互的数量，我们会得到如图
    5.3 所示的大量标记交互。
- en: '![](../Images/CH05_F03_Antao.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F03_Antao.png)'
- en: Figure 5.3 The web output for our memoryview-based function. The lines that
    are grayed out (in the browser version they would be in yellow) hint at interactions
    with Python.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 基于内存视图函数的网页输出。灰色（在浏览器版本中为黄色）的线条暗示了与 Python 的交互。
- en: 5.4.1 The takeaway
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 吸取的经验
- en: It is generally worth the time to create memoryviews of NumPy arrays, which
    will allow Cython to interact with raw array representations and avoid the Python
    machinery. The performance improvements can be significant. But further profiling
    indicates we are still interacting with the machinery, thus still performing suboptimally.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，创建 NumPy 数组的内存视图是值得花费时间的，这将允许 Cython 与原始数组表示进行交互，并避免 Python 机制。性能提升可能是显著的。但进一步的性能分析表明，我们仍在与机制交互，因此仍然表现不佳。
- en: 'Our next question then is: can we get rid of the remaining (Python) interactions
    to substantially optimize our code? The answer again is, yes we can.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的问题是：我们能否消除剩余的（Python）交互以显著优化我们的代码？答案仍然是，我们可以。
- en: 5.4.2 Cleaning up all internal interactions with Python
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 清理所有与 Python 的内部交互
- en: 'There are three types of interactions that are responsible for `cython -a`,
    marking the lines in figure 5.3, still going on:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的交互负责 `cython -a`，标记图 5.3 中的行，仍在继续：
- en: We have a `cpdef` function that generates a C function *with* a Python stub.
    We can replace that with a `cdef`.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个 `cpdef` 函数，它生成一个带有 Python 桩的 C 函数。我们可以用 `cdef` 来替换它。
- en: The function is implicitly returning a `None` object as expected from all Python
    functions. This means managing a Python object, even if only a `None`.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数隐式返回一个 `None` 对象，正如所有 Python 函数所期望的那样。这意味着管理一个 Python 对象，即使只是一个 `None`。
- en: The NumPy memoryview is still trying to help you with bounds checking (i.e.,
    if you put an index that is not valid the Python exception machinery will be activated).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 内存视图仍在尝试帮助您进行边界检查（即，如果您放入一个无效的索引，Python 异常机制将被激活）。
- en: 'Let’s sort out all these problems in one fell swoop. We simply need to change
    the function definition:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一举解决所有这些问题。我们只需更改函数定义：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① We deactivate bounds checking.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们停用边界检查。
- en: ② We have a cdef (i.e., no Python stub), and we declare the return type as C
    void.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们有一个 cdef（即，没有 Python 桩），我们声明返回类型为 C void。
- en: ③ We can now tell Cython that this function can release the GIL.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们现在可以告诉 Cython 这个函数可以释放 GIL。
- en: We will revisit bounds checking later; in a general case, your code can now
    crash without the bounds-checking guard rails. It is not a problem in this case,
    but later in the chapter, we will see how this can be a problem.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后重新讨论边界检查；在一般情况下，您的代码现在可以没有边界检查保护栏而崩溃。在这种情况下这不是问题，但本章后面我们将看到这可能会成为一个问题。
- en: The `nogil` annotation is optional; there is nothing to be gained at this stage.
    This will allow us to have real parallelism, a subject we will return to later
    in the chapter. Cython would complain if you have this annotation and have not
    removed all Python connections. So it’s only possible to do it because of all
    the other changes we have done.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`nogil` 注解是可选的；在这个阶段没有获得任何好处。这将使我们能够拥有真正的并行性，这是一个我们将在本章后面再次讨论的主题。如果存在此注解但未移除所有
    Python 连接，Cython 将会抱怨。所以，我们之所以能够这样做，仅仅是因为我们已经做了所有其他改变。'
- en: On my computer, a laptop with an Intel i5 CPU at 1.6GHz, this now takes 0.04
    s. Remember that we started with 35 s for a native Python implementation and 18
    s for a naive Cython one.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上，这是一台装有 1.6GHz 英特尔 i5 CPU 的笔记本电脑，现在只需要 0.04 秒。记住，我们最初是用 35 秒进行原生 Python
    实现和 18 秒进行原始 Cython 实现开始的。
- en: The takeaway
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的经验教训
- en: To remove the last lingering interactions between Cython and Python, we can
    change the function definition to avoid making or returning calls with a Python
    function. By combining this process with annotating Cython code, adding typing
    to function returns, and using memoryviews instead of raw NumPy arrays, we have
    a strategy for eliminating the interactions between the faster Cython and the
    slower Python.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除 Cython 和 Python 之间最后残留的交互，我们可以更改函数定义以避免使用 Python 函数进行调用或返回。通过将此过程与注释 Cython
    代码、添加函数返回类型注解以及使用内存视图而不是原始 NumPy 数组相结合，我们有一个消除更快 Cython 和较慢 Python 之间交互的策略。
- en: Later, we will discuss bounds checking and other NumPy optimizations. We will
    also discuss parallelism, but for now, we will visit implementing NumPy universal
    functions in Cython. This can be quite useful as universal functions are amenable
    to NumPy broadcasting rules.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将讨论边界检查和其他 NumPy 优化。我们还将讨论并行性，但到目前为止，我们将探讨在 Cython 中实现 NumPy 通用函数。这非常有用，因为通用函数适用于
    NumPy 广播规则。
- en: 5.5 Writing NumPy generalized universal functions in Cython
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 在 Cython 中编写 NumPy 通用函数
- en: We are now going to use an alternative solution to the image filtering problem
    by writing a universal function in Cython. Remember from the previous chapter
    that the universal function machinery makes life easier by providing goodies like
    broadcasting. Universal functions come with all these extra perks and, as we will
    see later, are somewhat akin to the programming paradigm GPU. However, remember
    that they are not universal computing solutions, and we will see such an example
    in the next section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过在Cython中编写通用函数来解决图像过滤问题的一种替代方案。记得从上一章中，通用函数机制通过提供广播等好处使生活变得更简单。通用函数附带所有这些额外的好处，并且，正如我们稍后将看到的，它们在某种程度上类似于GPU编程范式。然而，请记住，它们不是通用的计算解决方案，我们将在下一节中看到一个这样的例子。
- en: 'We also learned in chapter 4 that universal functions operate on an element-by-element
    basis. In our case, that will mean pixel by pixel. Our code will be composed of
    two parts: the universal function and the code to register it. Let’s start with
    the universal function (code is available in the repository in `05-cython/sec5-ufunc`):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第四章中也了解到，通用函数是逐元素操作的。在我们的例子中，这意味着逐像素操作。我们的代码将由两部分组成：通用函数和注册它的代码。让我们从通用函数开始（代码可在`05-cython/sec5-ufunc`目录下的仓库中找到）：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① Notice the usage of pointer notation (*).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ① 注意指针符号的使用（*）。
- en: We are now operating on a pixel-by-pixel basis so the code is simpler as we
    do not have the `for` loops over the whole array/image.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在是在逐像素的基础上操作，因此代码更简单，因为我们不需要在整个数组/图像上使用`for`循环。
- en: 'The fundamental difference is that instead of passing a number, `cnp.unit8_t`,
    a *pointer* to a number is passed, `cnp.uint8_t *`. This concept may be new to
    you if you are not used to lower-level languages like C. For our practical purposes,
    this doesn’t have many consequences, but for more complex examples, you are directed
    to Cython’s documentation. The only consequence of significance is that the output
    will be written to an “input variable.” Finally, the function is marked as `nogil`,
    allowing it to run in parallel: no Python objects are being referred, so the GIL
    can be released by a parallel executor.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的区别在于，我们传递的是一个数字的指针，`cnp.unit8_t`，而不是一个数字，`cnp.uint8_t *`。如果你不习惯像C这样的底层语言，这个概念可能对你来说很新。就我们的实际用途而言，这不会带来很多后果，但对于更复杂的例子，你应参考Cython的文档。唯一有意义的后果是，输出将被写入“输入变量”。最后，该函数被标记为`nogil`，允许它并行运行：没有引用Python对象，因此并行执行器可以释放GIL。
- en: 'Our universal function, as was the case in the previous chapter, is a *general*
    universal function because the first parameter, `image_pixel`, is not a primitive
    type but an array: the pixel in color has three RGB components.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中提到的通用函数，与上一章的情况相同，是一个**通用**的通用函数，因为第一个参数`image_pixel`不是一个原始类型，而是一个数组：彩色像素有三个RGB分量。
- en: 'We now need to *wrap* our (general) universal function. Sadly, the boilerplate
    is a bit long and slightly complicated:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要**包装**我们的（通用）通用函数。遗憾的是，模板代码有点长且稍微复杂：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① We need a variable to specify the types of all inputs and outputs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们需要一个变量来指定所有输入和输出的类型。
- en: ② All functions that implement the universal function
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ② 实现通用函数的所有函数
- en: ③ We specify the types for our two input and one output parameters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们指定了两个输入参数和一个输出参数的类型。
- en: ④ The list of functions that implements the universal function
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 实现通用函数的功能列表
- en: ⑤ Creates the wrapped universal function
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建包装后的通用函数
- en: ⑥ Number of input types
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 输入类型的数量
- en: ⑦ Number of input parameters
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 输入参数的数量
- en: ⑧ Number of output parameters
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 输出参数的数量
- en: ⑨ The Numpy signature
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ Numpy签名
- en: We need to specify the data types of all parameters, which is coded `all_types`.
    Also, the general universal function signature, `(n),()→()`, means `(n)` is an
    array with the three color components of our initial pixel, `()`, a primitive
    value representing the grayscale darkening pixel, and the output, `()`, another
    primitive type with the grayscale pixel.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定所有参数的数据类型，这用`all_types`编码。此外，通用函数的签名`（n），（）→（）`意味着`（n）`是一个包含初始像素三个颜色分量的数组，`（）`是一个表示灰度变暗像素的原始值，以及输出`（）`，另一个表示灰度像素的原始类型。
- en: The most confusing part is the ability to have several functions to render the
    implementation; notice that we have a list of functions in `funcs`, not a single
    function. In our case, we only need a single function, `darken_pixel`, but we
    could have different functions for different input or output parameters—say, one
    for `NPY_UINT8` and another for `NPY_UINT16`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人困惑的部分是拥有多个函数来渲染实现的能力；注意，我们有一个名为`funcs`的函数列表，而不是一个单独的函数。在我们的情况下，我们只需要一个函数，即`darken_pixel`，但我们可以为不同的输入或输出参数使用不同的函数——比如说，一个用于`NPY_UINT8`，另一个用于`NPY_UINT16`。
- en: 'This can now be used as any other universal function. In our case:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在可以像任何其他通用函数一样使用。在我们的情况下：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 5.5.1 The takeaway
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 主要收获
- en: 'Writing NumPy universal functions in Cython is often both possible and preferable,
    especially since they come with some built-in time-saving features. However, in
    some cases, NumPy universal functions are not enough to implement an algorithm—for
    example, when you need to inspect the state of other places in the array, not
    just your current position. To deal with that and other problems with array processing
    in Cython, we will now consider a new example: the Game of Life.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中编写 NumPy 通用函数通常是可能的，也是首选的，尤其是它们自带一些节省时间的内置功能。然而，在某些情况下，NumPy 通用函数不足以实现一个算法——例如，当你需要检查数组中的其他位置的状态，而不仅仅是当前位置时。为了处理这种情况以及
    Cython 中数组处理的其他问题，我们现在将考虑一个新的示例：生命游戏。
- en: 5.6 Advanced array access in Cython
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 Cython 中的高级数组访问
- en: In this section, we will solidify our understanding of Cython and NumPy interactions
    by going deeper into optimizing array access. Specifically, we will do low-level
    multithreaded parallelism finally bypassing the GIL’s limitation on running a
    single Python thread at a time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过深入研究优化数组访问来巩固我们对 Cython 和 NumPy 交互的理解。具体来说，我们将进行低级别的多线程并行处理，最终绕过 GIL
    对一次运行单个 Python 线程的限制。
- en: 'We’ll work on a new example project to see these processes in action: we will
    create a color version of Conway’s game of life (see [https://conwaylife.com/](https://conwaylife.com/)
    for details). Conway’s Game of Life is a zero-player game that evolves automatically
    from its initial state; devising interesting initial states is part of the fun.
    The state of the game is composed of a grid of arbitrary size, and each cell can
    have two states: alive or dead. As time advances, each cell will change its state
    according to the following rules:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个新的示例项目来观察这些过程的具体实现：我们将创建康威生命游戏的彩色版本（详情请见[https://conwaylife.com/](https://conwaylife.com/)）。康威生命游戏是一个零玩家游戏，它从初始状态自动进化；设计有趣的初始状态是乐趣的一部分。游戏的状态由任意大小的网格组成，每个细胞可以有两种状态：活着或死亡。随着时间的推移，每个细胞将根据以下规则改变其状态：
- en: Any live cell with two or three neighbors survives.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有两个或三个邻居的活细胞都会存活。
- en: A dead cell with three neighbors becomes live.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有三个邻居的死亡细胞变成活细胞。
- en: All other cells die or stay dead.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他细胞都会死亡或保持死亡状态。
- en: The world wraps around in the sense that the left-most column will look at the
    right-most column to compute neighbors, and vice versa. The same applies to the
    top and bottom rows.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 世界是环绕的，这意味着最左边的列会查看最右边的列来计算邻居，反之亦然。同样的情况也适用于顶部和底部的行。
- en: Figure 5.4 shows three examples over time. The first example is a dash that
    eternally changes direction from vertical to horizontal. The second is a box that
    is stable, and the third dies off completely.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 展示了三个随时间变化的示例。第一个示例是一个永恒地改变方向从垂直到水平的破折号。第二个是一个稳定的盒子，第三个完全死亡。
- en: '![](../Images/CH05_F04_Antao.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F04_Antao.png)'
- en: Figure 5.4 Three examples using standard rules from the Game of Life
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 使用生命游戏的标准规则三个示例
- en: 'We will be using an extension called QuadLife,[²](#pgfId-1017554) where each
    live cell can have four different states: red, green, blue, and yellow. I prefer
    this extension simply because it looks cooler. It includes two new rules:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 QuadLife 的扩展，[²](#pgfId-1017554)，其中每个活细胞可以有四种不同的状态：红色、绿色、蓝色和黄色。我更喜欢这个扩展，仅仅因为它看起来更酷。它包括两个新的规则：
- en: If a color is present in the majority of neighbors, that color becomes the color
    of the new cell.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某个颜色在邻居中占多数，那么这个颜色将成为新细胞的颜色。
- en: If all three live neighbors are different, the new cell takes the remaining
    of the four possible colors.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有三个活邻居颜色都不同，新细胞将采用四种可能颜色中的剩余颜色。
- en: 'As with previous Cython examples, our implementation will include two components:
    calling Python code, with the computationally expensive part implemented in Cython.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 Cython 示例一样，我们的实现将包括两个组件：调用 Python 代码，其中计算密集的部分用 Cython 实现。
- en: 'The Python part should be familiar and simple by now. It is available in the
    repository (`05-cython/sec6-quadlife`). It is provided here with annotated explanations:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Python 部分现在应该很熟悉且简单。它在仓库（`05-cython/sec6-quadlife`）中可用。这里提供了带有注释说明的内容：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① We set up pyximport to include NumPy.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们设置 pyximport 以包含 NumPy。
- en: ② We read parameters from the command line.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们从命令行读取参数。
- en: ③ We use a function (defined later) to create a random world.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用一个（稍后定义）的函数来创建一个随机世界。
- en: ④ We apply the Quadlife algorithm for the number of generations specified by
    the user.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们根据用户指定的代数应用 Quadlife 算法。
- en: We call this script by passing the desired X and Y resolution along with the
    number of generations. The script doesn’t output anything for now, it just runs
    the game; later we will do some cool stuff with the results.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递所需的 X 和 Y 分辨率以及代数数来调用此脚本。目前脚本不输出任何内容，它只是运行游戏；稍后我们将对结果做一些有趣的事情。
- en: 'To start, we will generate a random world with `create_random_world`, which
    is good enough for testing; later we will consider better-looking alternatives.
    We will use a NumPy array of the dimension `SIZE_Y`, `SIZE_X`, as specified by
    the user. It will be filled with random values between 0 and 4\. Zero represents
    a dead cell. We then run the simulation function called `live` for `GENERATIONS`:
    the first call gets the random world, and its output is then fed to itself in
    succession. There is nothing conceptually new presented in the code and it should
    be easy to understand.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `create_random_world` 生成一个随机世界，这对于测试来说已经足够好了；稍后我们将考虑更好的替代方案。我们将使用用户指定的
    `SIZE_Y`、`SIZE_X` 维度的 NumPy 数组。它将被填充在 0 和 4 之间的随机值。0 代表一个死细胞。然后我们运行名为 `live` 的模拟函数
    `GENERATIONS` 次：第一次调用获取随机世界，然后其输出依次传递给自己。代码中没有展示任何概念上的新内容，应该很容易理解。
- en: 'We now consider our Cython code. Creating the initial random world doesn’t
    really need to be optimized as it is called only once at the beginning:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑我们的 Cython 代码。创建初始随机世界实际上并不需要优化，因为它只在开始时被调用一次：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now the fun starts. Our implementation will include conceptually new techniques,
    but we will be piling up on what we have learned in the previous sections.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有趣的部分开始了。我们的实现将包括概念上新的技术，但我们将在此基础上构建我们在前面章节中学到的内容。
- en: 5.6.1 Bypassing the GIL’s limitation on running multiple threads at a time
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.1 绕过 GIL 对同时运行多个线程的限制
- en: 'First, we want to make sure our inner loop can be GIL-free. For that, we create
    a Cython top-level `live` function that mostly converts NumPy arrays into memoryviews:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要确保我们的内部循环可以无 GIL（全局解释器锁）。为此，我们创建了一个 Cython 最高级 `live` 函数，它主要将 NumPy 数组转换为内存视图：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The conversion to memoryviews will be forced by the `live_core` function signature
    (see following discussion), but we still need a layer that can convert Python
    objects into potentially GIL-free representations. `old_world` is the input world;
    `new_world` will have the output. `extended_world` and `states` are `live_core`
    internal variables that we will pre-allocate here. Before we present the core
    algorithm in `live_core`, let’s discuss how we will algorithmically optimize part
    of it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为内存视图将由 `live_core` 函数签名强制执行（见以下讨论），但我们仍然需要一个可以将 Python 对象转换为可能无 GIL 表示的层的。`old_world`
    是输入世界；`new_world` 将有输出。`extended_world` 和 `states` 是 `live_core` 内部变量，我们将在这里预分配。在我们展示
    `live_core` 中的核心算法之前，让我们讨论我们将如何算法优化其一部分。
- en: In the Game of Life, the extremes of the board are connected; for example, the
    left-most column cells will “look” at the states of the right-most cells to compute
    their new states. To avoid a lot of corner case testing, which would add a lot
    of `if` statements and thus increase the time to compute, we will implement a
    temporary extended world in the previously mentioned variable `extended_world`
    of dimensions `(y+2, x+2)`. The extended boundaries copy what happens on the other
    side, as in figure 5.5.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在生命游戏中，棋盘的边缘是相连的；例如，最左列的细胞将“观察”最右列的细胞的状态来计算它们的新状态。为了避免大量的边缘情况测试，这将增加许多 `if`
    语句并因此增加计算时间，我们将在之前提到的变量 `extended_world` 中实现一个临时的扩展世界，其维度为 `(y+2, x+2)`。扩展边界会复制另一侧发生的情况，如图
    5.5 所示。
- en: '![](../Images/CH05_F05_Antao.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F05_Antao.png)'
- en: Figure 5.5 The extended board used to compute the new world
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 用于计算新世界的扩展棋盘
- en: 'The purpose of this algorithm is to allow a slightly more efficient approach
    when computing the new board: we do not need `if` statements for boundary conditions.
    This is done at the cost of memory: we now need to store a new and bigger version
    of the board. Making these kinds of tradeoffs (i.e., memory versus computation)
    is our bread and butter across high-performance computing problems. It’s difficult
    to come up with generalized guidelines to decide on the tradeoff. It will depend
    on the computational and memory cost of a specific algorithm and the resources
    that you have available.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '这个算法的目的是在计算新棋盘时允许一种略微更有效的方法：我们不需要`if`语句来处理边界条件。这是以内存为代价完成的：我们现在需要存储一个新的大版本的棋盘。在高性能计算问题中，我们经常需要做出这类权衡（即内存与计算之间的权衡）。很难提出通用的指导方针来决定权衡。它将取决于特定算法的计算和内存成本以及你拥有的资源。 '
- en: 'Following is the code that implements this extended world. Notice that the
    code has no boundary tests, thus reducing the computation time of using `if` statements:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现这个扩展世界的代码。请注意，代码没有边界测试，因此减少了使用`if`语句的计算时间：
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① Uses deactivate bounds, None, and wrap checks
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用关闭边界、None和环绕检查
- en: ② We use cdef to avoid the GIL.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用`cdef`来避免全局解释器锁（GIL）。
- en: ③ We type everything on the function signature.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们在函数签名上对一切进行类型化。
- en: ④ The copy of world in the middle of extended_world can be potentially expensive.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 扩展_world中间的world副本可能很昂贵。
- en: The copy of `world` in the middle of `extended_world` can potentially cost a
    steep computation and memory price, but the computational part might be compensated
    by the easier core algorithm.[³](#pgfId-1018526) But at least for pedagogical
    purposes, it makes the core algorithm substantially simpler, which is important
    for learning purposes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`extended_world`中间的`world`副本可能需要高昂的计算和内存代价，但计算部分可能通过更简单的核心算法得到补偿。[³](#pgfId-1018526)
    但至少从教学目的来看，它使核心算法大大简化，这对于学习目的来说很重要。
- en: You might notice that many lines on the previous function look like they could
    be written in a more expedient notation. For example, perhaps
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到前一个函数中的许多行看起来可以用更便捷的记法来编写。例如，也许
- en: '[PRE31]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'could maybe be written as:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可能可以写成：
- en: '[PRE32]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It turns out, however, that we cannot do these kinds of rewrites because when
    we deactivate wrap-around to avoid paying the price of the generated C code, we
    must spend time on wrap verification. In addition, deactivating wrap-around means
    we cannot use negative indexes. The tradeoff—i.e, not being able to write certain
    idioms—is worth it, though: wrap-around requires the CPython machinery, which
    slows things down, so our implementation without it is substantially faster, *and*
    we need to deactivate it to release the GIL as the wrap-around uses the Python
    machinery.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们发现我们无法进行这类重写，因为当我们关闭环绕检查以避免支付生成的C代码的代价时，我们必须花费时间在环绕验证上。此外，关闭环绕检查意味着我们无法使用负索引。这种权衡——即无法编写某些惯用语——是值得的：环绕检查需要CPython机制，这会减慢速度，因此我们的没有环绕检查的实现要快得多，*并且*我们需要关闭它以释放GIL，因为环绕检查使用了Python机制。
- en: Warning Not doing wrap-around or bounds checking may result in segmentation
    faults of your code. If you see those errors, make sure to deactivate the decorator
    during development. Your code must be robust enough to tolerate removing this
    and the other checks.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：不进行环绕或边界检查可能会导致你的代码出现段错误。如果你看到这些错误，请确保在开发期间关闭装饰器。你的代码必须足够健壮，能够容忍移除这些和其他检查。
- en: 'We also use optimizations discussed previously: a `cdef`, complete typing of
    parameters and variables, and use of memoryviews instead of NumPy arrays. If you
    use `cython -a cquadlife.pyx`, you will see no yellow lines in the browser version
    of the previous code denoting Python interaction lines.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了之前讨论过的优化：`cdef`，参数和变量的完整类型化，以及使用内存视图代替NumPy数组。如果你使用`cython -a cquadlife.pyx`，你将不会在浏览器版本的先前代码中看到表示Python交互行的黄色线条。
- en: The main implementation that changes the state makes use of the extended world.
    The code following implements the QuadLife game rules. Because it is quite long
    we will carefully annotate it, including problems that we might have addressed
    previously.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 主要改变状态的实施利用了扩展世界。接下来的代码实现了QuadLife游戏规则。因为它相当长，我们将仔细注释，包括我们可能之前已经解决的问题。
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '① We deactivate a lot of checking machinery: bounds and None, checking along
    with wrap-around.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们关闭了很多检查机制：边界和None，以及环绕检查。
- en: ② We use a cdef to avoid passing standard Python objects. We also declare the
    return type as void, which is C for nothing at all.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用cdef来避免传递标准Python对象。我们还声明返回类型为void，这在C语言中表示什么都没有。
- en: ③ We type all parameters.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们输入所有参数。
- en: ④ Some internal variables (states and extended_world) are allocated outside,
    and we use the memory made available.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 一些内部变量（states和extended_world）是在外部分配的，我们使用了可用的内存。
- en: ⑤ We type all local variables.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们输入所有局部变量。
- en: ⑥ Everything is pre-allocated when we call get_extended_world.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 当我们调用get_extended_world时，所有内容都是预先分配的。
- en: ⑦ Implements sum(states[:1])
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 实现sum(states[:1])
- en: ⑧ Implements max(states[:1])
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 实现max(states[:1])
- en: ⑨ Implements states[1:].index(max_represented)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 实现states[1:].index(max_represented)
- en: ⑩ Implements states[1:].index(0)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 实现states[1:].index(0)
- en: This function is complicated, but many of these techniques used were introduced
    before; here, they are combined in a more realistic example. So read the code
    and the annotations carefully, and you will understand it all.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很复杂，但其中许多技术是在之前引入的；在这里，它们在一个更现实的例子中被结合起来。所以仔细阅读代码和注释，您就会明白一切。
- en: You might see a few oddities in the code—namely, the replacement of `sum` and
    `index` by less declarative versions. We do this because `sum` and `index` would
    make use of the CPython machinery, and we want to avoid that. A similar argument
    is valid for the `max` function, but in that case, a replacement version can’t
    compare all values in a single call. When you are using general functions, you
    might want to profile them and maybe replace them with optimized nongeneral functions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在代码中看到一些奇怪之处——特别是用非声明性版本替换了`sum`和`index`。我们这样做是因为`sum`和`index`会使用CPython机制，而我们想避免这种情况。对于`max`函数，也有类似的论点，但在那种情况下，替换版本无法在一次调用中比较所有值。当您使用通用函数时，您可能想对它们进行性能分析，并可能用优化的非通用函数来替换它们。
- en: Note Because the Game of Life produces nice evolving visualizations, we will
    make a simple GUI. We will be using the Python built-in `tkinter` module for the
    GUI along with the external library Pillow for image manipulation. We will not
    discuss the code here because it falls outside of the scope of this book, but
    you can find it in the repository in `05-cython/sec6-quadlife/ gui.py`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于生命游戏可以产生漂亮的演变可视化效果，我们将制作一个简单的图形用户界面。我们将使用Python内置的`tkinter`模块来创建GUI，以及外部库Pillow来进行图像处理。我们不会在这里讨论代码，因为它超出了本书的范围，但您可以在`05-cython/sec6-quadlife/
    gui.py`目录下的仓库中找到它。
- en: Our implementation is complete, but now we want to gauge the performance gain
    that we got from our code.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实施是完整的，但现在我们想衡量我们从代码中获得的速度提升。
- en: 5.6.2 Basic performance analysis
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.2 基本性能分析
- en: You can find the native Python version in the repository. We will use this version
    to make some basic comparisons with the Cython one. Running the Python version
    at a resolution of 1000 × 1000 for 200 generations on my computer takes slightly
    less than 1000 s, which is below 17 min. The Cython code takes 2.5 s.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在仓库中找到原生Python版本。我们将使用这个版本来与Cython版本进行一些基本比较。在我的电脑上，以1000 × 1000的分辨率运行Python版本，200代需要略少于1000秒，这低于17分钟。Cython代码需要2.5秒。
- en: 'Warning Our implementation is memory-intensive. Be very careful if you test
    it with large resolutions. In fact, a running theme in the book is the consideration
    of amount of memory used by algorithms: if they can be in-memory, they will be
    much faster than if they require disk storage for ongoing computations. Whenever
    possible, we will try to use in-memory algorithms. If not, we normally will have
    to optimize storage for processing to happen efficiently.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：我们的实现是内存密集型的。如果您用高分辨率测试它，请务必小心。实际上，本书的一个主题是考虑算法使用的内存量：如果它们可以在内存中运行，它们将比需要磁盘存储进行持续计算的速度快得多。只要可能，我们将尝试使用内存中的算法。如果不可以，我们通常将不得不优化存储以使处理高效进行。
- en: Let’s now consider a very large map of 400 × 900,000 run for only four generations.
    On my computer, it takes 44 s. Now, if we run the transposed map of 900,000 ×
    400 for the same four generations, how much time do you think it will take? It’s
    the same number of total cells for the same number of generations. It turns out
    that it’s not the same amount of time, not even close. It’s only 20 s. What is
    apparently the same problem in theoretical terms has very different results. The
    answer to this mind-boggling difference will be explored in chapter 6\. To make
    things even weirder, the relationship that you get on *your* computer might be
    completely different from the one I got on *my* computer.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个非常大的地图，400 × 900,000，只运行四代。在我的电脑上，这需要44秒。现在，如果我们为相同的四代运行900,000 ×
    400的转置地图，你认为需要多少时间？总细胞数和代数相同，但结果却大相径庭。它只需要20秒。在理论层面上明显相同的问题，结果却截然不同。对这个令人困惑的差异的答案将在第6章中探讨。更奇怪的是，你在你的电脑上得到的关系可能与我电脑上得到的关系完全不同。
- en: Before we address the final topic of this chapter, GIL-free multithreading with
    Cython, let’s take a quick detour and generate a cool video from the Game of Life.
    This process will allow us to consider computational complexity and think about
    the role of theory in helping us to write more efficient programs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论本章的最后一个主题，即Cython的无GIL多线程之前，让我们先快速地从一个Game of Life生成一个酷炫的视频。这个过程将使我们考虑计算复杂度，并思考理论在帮助我们编写更高效程序中的作用。
- en: 5.6.3 A spacewar example using Quadlife
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.3 使用Quadlife的空间战示例
- en: In the repository, you will find code that will generate a video using a starting
    state that includes “spaceships” and “defenses.” The code itself is not very relevant
    for optimization purposes so we won’t discuss it here. If you want to replicate
    it, you will need Python’s Pillow library for image processing and ffmpeg to generate
    videos. You can find the main shell script to generate it in `05-cython/generate_video.sh`.
    Figure 5.6 shows the starting state, with color inverted.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，你可以找到使用包含“飞船”和“防御”的起始状态的代码来生成视频。代码本身对于优化目的并不太相关，所以我们在这里不讨论它。如果你想复制它，你需要Python的Pillow库进行图像处理和ffmpeg生成视频。你可以找到生成它的主要shell脚本在`05-cython/generate_video.sh`中。图5.6显示了起始状态，颜色已反转。
- en: '![](../Images/CH05_F06_Antao.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F06_Antao.png)'
- en: Figure 5.6 The video starting state for our QuadLife simulation
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 QuadLife模拟的起始状态视频
- en: A video is available at [https://www.youtube.com/watch?v=E0B1fDKU_MI](https://www.youtube.com/watch?v=E0B1fDKU_MI).
    A library ([www.conwaylife.com](https://conwaylife.com/)) also allows you to get
    patterns like the ones used in the video.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 视频可在[https://www.youtube.com/watch?v=E0B1fDKU_MI](https://www.youtube.com/watch?v=E0B1fDKU_MI)找到。图书馆([www.conwaylife.com](https://conwaylife.com/))也允许你获取视频中使用的类似图案。
- en: You can use the code in the repository (`05-cython/patterns.py`) to generate
    similar kinds of movies. This code will run the Game of Life on the spaceship
    model for 400 generations on a map of 400 × 250, which takes less than 1 s. An
    HD resolution of 1920 × 1080 with the same 400 generations takes around 11 s;
    800 frames takes 22 s; and 400 frames at the 4K resolution of 3840 × 2160 takes
    48 s. At 40 frames per second, a 4K game of 90 min would take roughly 196 min
    to generate. The silver lining is that the same video would take 54 days to generate
    in a pure Python solution.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用存储库中的代码(`05-cython/patterns.py`)来生成类似的电影。此代码将在400 × 250的地图上运行太空船模型的Game
    of Life 400代，耗时不到1秒。以1920 × 1080的HD分辨率运行相同的400代需要大约11秒；800帧需要22秒；而在3840 × 2160的4K分辨率下，400帧需要48秒。以每秒40帧的速度，90分钟的4K游戏大约需要196分钟来生成。但好处是，同样的视频在纯Python解决方案中生成需要54天。
- en: The role of computational complexity
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 计算复杂性的作用
- en: While this is not a theoretical book, it is impossible to deny the importance
    of computational complexity and its underlying theory. That is the study of resources
    consumed by an algorithm—commonly, but not only, time and memory.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一本理论书籍，但无法否认计算复杂性和其基础理论的重要性。这涉及到算法消耗的资源——通常，但不仅限于时间和内存。
- en: 'For example, the time cost of our system increases linearly with the number
    of generations that we compute. But if we are computing a world that is square
    and has a lateral size of n, the growth is quadratic: a square of 20 is not two
    times slower than a square of 10; it’s actually four times slower. Also, a square
    of size 200 is a whopping 400 times slower (not 20 times) than a 10 × 10 square.
    In this case, the algorithm is also quadratic for the memory required.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们系统的运行时间成本随着我们计算的代数数量的线性增长。但如果我们计算的是一个边长为n的正方形世界，增长是二次的：20的平方不是10的平方的两倍慢；实际上要慢四倍。同样，一个大小为200的平方比一个10×10的平方慢400倍（而不是20倍）。在这种情况下，算法对于内存需求也是二次的。
- en: In the world of ever-increasing big data, this means that some algorithms will
    scale very poorly and eventually might need to be replaced by completely different
    solutions. In this book, we will not formally discuss computational complexity
    theory, but sometimes we will have to address some intuitions behind it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在大数据不断增长的世界中，这意味着一些算法的扩展性可能非常差，最终可能需要被完全不同的解决方案所取代。在这本书中，我们不会正式讨论计算复杂度理论，但有时我们不得不解决其背后的直觉。
- en: We still have plenty of motivation to do better. Because our code does not interact
    with Python objects, we can release the GIL and do real parallelism with multiple
    threads. Let’s do that in the final section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有足够的动力做得更好。因为我们的代码不与Python对象交互，我们可以释放GIL并使用多个线程进行真正的并行。让我们在最后一节中这样做。
- en: 5.7 Parallelism with Cython
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 使用Cython进行并行处理
- en: With all the preparation we’ve done cleaning up GIL-tying code, introducing
    a multiprocessing solution is now quite straightforward. Our approach will make
    use of Cython’s internal parallel functionality, and the code (available in `05-cython/sec7-parallel`)
    is quite simple.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已经做了清理GIL绑定代码的所有准备工作之后，引入多进程解决方案现在相当直接。我们的方法将利用Cython的内部并行功能，代码（在`05-cython/sec7-parallel`中可用）相当简单。
- en: 'Cython provides declarative parallel functions based on OpenMP. OpenMP is a
    multiplatform library providing parallelism primitives. One of the functions provided
    is a parallel range function, which will multithread the content of a `for` loop;
    using it is quite easy:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Cython提供了基于OpenMP的声明式并行函数。OpenMP是一个多平台库，提供并行原语。它提供的一个函数是并行范围函数，该函数将对`for`循环的内容进行多线程处理；使用它相当简单：
- en: '[PRE34]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ① We import the prange function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入prange函数。
- en: ② nogil is now compulsory.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ② nogil现在是强制性的。
- en: ③ We simply replace range with prange.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们只需将range替换为prange。
- en: 'It’s as simple as that. Of course, remember that by cleaning all GIL-related
    code, we did most of the work well before arriving at this step. We also need
    to remember to annotate the `get_extended_world` function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。当然，记住，通过清理所有与GIL相关的代码，我们在到达这一步之前已经做了大部分工作。我们还需要记住注释`get_extended_world`函数：
- en: '[PRE35]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Cython provides a few functions over OpenMP to make parallel code easier to
    write. This can be extremely handy in most cases. The fundamental requirement
    is to clear all GIL-related calls.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Cython提供了一些函数来覆盖OpenMP，使并行代码更容易编写。这在大多数情况下都非常有用。基本要求是清除所有与GIL相关的调用。
- en: We are mostly concerned with the interactions between GIL’s Python and threaded
    parallelism. We are also concerned with Cython’s primitives, based on OpenMP,
    to write parallel code. The elephant in the room is the whole field of parallel
    processing. Here we provide the fundamental building blocks to unleash true parallel
    threaded processing in the Python space. But parallel programming techniques in
    general are a separate subject for which you should consult other resources.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注GIL的Python和线程并行之间的交互。我们也关注基于OpenMP的Cython原语来编写并行代码。房间里的大象是整个并行处理领域。在这里，我们提供了在Python空间中释放真正并行线程处理的基本构建块。但并行编程技术通常是一个独立的主题，你应该咨询其他资源。
- en: 'Note that with Cython you are, in fact, inside a C-paradigm. While there is
    no reason to ignore Cython’s OpenMP functionality, remember that you are not tied
    to it. You can use other C-based parallelisms libraries: it’s just that you have
    to go an even lower level yourself.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实际上，使用Cython你是在C范式内部。虽然没有理由忽略Cython的OpenMP功能，但请记住，你并不局限于它。你可以使用其他基于C的并行库：只是你需要自己走得更低级一些。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Native Python, CPython, is not enough to implement the fastest code for complex
    operations.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生Python，CPython，不足以实现复杂操作的最快代码。
- en: 'There are many options to accelerate your Python-based code: using optimized
    libraries, lower-level languages, Numba, or even other Python implementations
    such as PyPy.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多选项可以加速你的基于Python的代码：使用优化库、底层语言、Numba，甚至其他Python实现，如PyPy。
- en: Cython is a superset of Python that compiles to C and provides C-like speeds
    without having to learn a new language.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython是Python的超集，编译成C，提供类似C的速度，而无需学习新语言。
- en: Cython can be profiled in similar ways to Python code.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython可以以类似于Python代码的方式进行分析。
- en: Writing efficient Cython code requires annotating Cython variables to provide
    type hints, which are different from the hints of standard mypy, and sometimes
    analyzing the generated C code from Cython.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写高效的Cython代码需要注释Cython变量以提供类型提示，这些提示与标准mypy的提示不同，有时还需要分析Cython生成的C代码。
- en: The C code browser provided by Cython allows you to easily identify lines that
    interact with the Python interpreter and thus are potential candidates for being
    rewritten more efficiently.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython提供的C代码浏览器允许你轻松地识别与Python解释器交互的行，因此它们是重写以更高效方式执行的潜在候选者。
- en: You should remove as many interactions with CPython as possible, to the point
    that you should consider re-architecting your code so that the expensive inner
    loop for your implementation is free of CPython interactions. This can easily
    accelerate your Cython code by numerous orders of magnitude.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该尽可能地减少与CPython的交互，甚至应该考虑重构你的代码，使得实现中的昂贵内循环不与CPython交互。这可以轻易地以数个数量级加速你的Cython代码。
- en: Cython integrates with NumPy, allowing for the efficient manipulation of arrays.
    Resources, like memoryviews, are available that allow direct communication between
    Cython and NumPy, thus removing the inefficient Python interpreter as a middleman.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython与NumPy集成，允许高效地操作数组。资源，如memoryviews，允许Cython和NumPy之间直接通信，从而消除了低效的Python解释器作为中间人的作用。
- en: CPython-independent code is the first step for GIL-independent code. If we can
    release the GIL, we can use parallel multithreading from our Cython code.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与CPython无关的代码是迈向GIL无关代码的第一步。如果我们能够释放GIL，我们就可以从我们的Cython代码中使用并行多线程。
- en: 'Remember to consider Numba as an alternative to Cython: in many cases, it is
    easier to use, although not as customizable as Cython.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住考虑Numba作为Cython的替代方案：在许多情况下，它更容易使用，尽管不如Cython可定制。
- en: '* * *'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹  For details on how to measure time, see chapter 2\. With IPython/Jupyter,
    you can use the `%timeit` magic. With standard Python, you can use the `timeit`
    module. Or, as I did in this case, I simply timed the run time of the process.
    In some cases, a rough approximation can be a good start.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ¹  关于如何测量时间的详细信息，请参阅第2章。使用IPython/Jupyter，你可以使用`%timeit`魔法。使用标准Python，你可以使用`timeit`模块。或者，就像我在这个例子中所做的那样，我简单地测量了进程的运行时间。在某些情况下，一个粗略的近似值可能是一个好的开始。
- en: ²  You can find a lot of information about game variants and the Game of Life
    in general on the LifeWiki ([https://conwaylife.com/](https://conwaylife.com/)).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ²  你可以在LifeWiki（[https://conwaylife.com/](https://conwaylife.com/)）上找到关于游戏变体和生命游戏一般信息的大量资料。
- en: ³  To determine whether it is compensated or not would require careful profiling,
    which you now know how to do.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ³  要确定是否得到补偿，需要进行仔细的分析，你现在知道如何做了。
