- en: 9 Structuring an application with functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 使用函数构建应用程序的结构
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Partial application and currying
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用和柯里化
- en: Getting around the limitations of method type inference
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克服方法类型推断的限制
- en: Modularizing and composing an application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化和组合应用程序
- en: Reducing lists to single values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将列表简化为单个值
- en: Structuring a complex, real-world application is no easy task. There are entire
    books written on the subject, so this chapter by no means aims to provide a comprehensive
    view. We’ll focus on the techniques that you can use to modularize and compose
    an application consisting entirely of functions and how the result compares to
    how this is usually done in OOP.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 构建复杂、现实世界的应用程序并非易事。关于这个主题已经写下了整本书，所以这一章绝对不是旨在提供一个全面的视角。我们将关注你可以用来模块化和组合完全由函数组成的应用程序的技术，以及这些技术与通常在面向对象编程中如何实现的结果相比。
- en: We’ll get there gradually. First, you’ll need to learn about a classic but fairly
    low-level functional technique called *partial application*. This technique allows
    you to write highly general functions whose behavior is parameterized and then
    supply those parameters, obtaining more specialized functions that have the parameters
    given so far “baked in.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步实现。首先，你需要了解一个经典但相对低级的函数技术，称为*部分应用*。这项技术允许你编写高度通用的函数，其行为由参数化，然后提供这些参数，获得具有给定参数的更专业化的函数，这些参数已经“固化”在函数中。
- en: We’ll then look at how partial application can be used in practice to first
    specify configuration arguments that are available at startup and purely run-time
    arguments later as they’re received. Finally, we’ll look at how you can take the
    approach one step further and use partial application for dependency injection,
    to the point of composing an entire application out of functions, without losing
    any of the granularity or decoupling you’d expect when composing it with objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨如何在实际中应用部分应用来首先指定在启动时可用和纯运行时参数，稍后随着它们的接收而提供。最后，我们将探讨如何进一步采取这种方法，并使用部分应用进行依赖注入，以至于可以完全由函数组成一个应用程序，而不会失去在用对象组合时预期的任何粒度或解耦。
- en: '9.1 Partial application: Supplying arguments piecemeal'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 部分应用：分阶段提供参数
- en: Imagine that you’re having your house redecorated. Your interior designer, Ada,
    calls Fred, her trusted paint supplier, with details about the paint she intends
    to order and then sends Bruno, the decorator, to pick up the required amount of
    paint. Figure 9.1 illustrates this scenario.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在翻新你的房子。你的室内设计师艾达，打电话给弗雷德，她信任的油漆供应商，并告诉她她打算订购的油漆的详细信息，然后派布鲁诺，装饰师，去取所需的油漆量。图9.1说明了这个场景。
- en: '![](Images/CH09_F01_Buonanno2.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F01_Buonanno2.png)'
- en: Figure 9.1 Fred needs several pieces of information before he can provide the
    product. This information can be given at different points by Ada and Bruno.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 弗雷德在提供产品之前需要几条信息。这些信息可以由艾达和布鲁诺在不同时间提供。
- en: Clearly, the shop needs to know both *what* the customer wants to buy and *how
    much* in order to fulfill the request, and in this case, the information is given
    at different points in time. Why? Well, it’s Ada’s responsibility to choose the
    color and brand (she wouldn’t trust Bruno to remember her exact choice). Bruno,
    on the other hand, has the task of measuring the surface and calculating the amount
    of paint required. At this point, all required information is available, and Bruno
    can pick up the paint from the supplier.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，商店需要知道客户想要购买什么以及需要多少，以便满足请求，在这种情况下，信息是在不同时间点给出的。为什么？好吧，这是Ada的责任来选择颜色和品牌（她不会信任布鲁诺记住她确切的选择）。另一方面，布鲁诺的任务是测量表面并计算所需的油漆量。在这个时候，所有必要的信息都可用，布鲁诺可以从供应商那里取走油漆。
- en: 'What I’ve just described is a real-life analogy of partial application. In
    programming, this means giving a function its input arguments piecemeal. Just
    as in my real-life example, this has to do with *separation of concerns*: it may
    be best to provide the arguments that a function needs at different points in
    the application lifecycle and from different components.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才描述的是部分应用的现实生活类比。在编程中，这意味着分阶段向函数提供输入参数。正如我的现实生活例子一样，这与*关注点分离*有关：最好在不同的应用程序生命周期阶段和不同的组件中提供函数所需的参数。
- en: Let’s see this in code. The idea here is that you have a function that needs
    several pieces of information to do its work (analogous to Fred, the paint supplier).
    For instance, in the following listing, we have the function `greet`, which takes
    a general greeting and a name and produces a greeting personalized for the given
    name.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码示例。这里的想法是，你有一个需要几块信息来完成其工作的函数（类似于弗雷德，油漆供应商）。例如，在下面的列表中，我们有 `greet` 函数，它接受一个通用问候语和一个名字，并为给定名字生成个性化的问候语。
- en: Listing 9.1 A binary function mapped over a list
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 在列表上映射的二进制函数
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: TIP If you’ve never used partial application before, it’s important that you
    type the examples in this section into the REPL to get a hands-on feel for how
    it works.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你以前从未使用过部分应用，那么将本节中的示例输入到 REPL 中进行操作，以获得对它如何工作的实际感受是很重要的。
- en: 'The `using` statements at the top of listing 9.1 allow us to attach some semantic
    meaning to specific uses of the `string` type, thus making the function signatures
    more meaningful. You could go the extra mile and define dedicated types (as discussed
    in chapter 4), thus ensuring that, say, a `PersonalizedGreeting` can’t accidentally
    be given as input to the `greet` function. But for the present discussion, I’m
    not too worried about enforcing business rules—just about having meaningful, unequivocal
    signatures because we’ll be looking at the signatures a lot. This is the signature
    of `greet`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 顶部的 `using` 语句使我们能够给 `string` 类型的特定使用赋予一些语义意义，从而使得函数签名更有意义。你可以更进一步，定义专用类型（如第
    4 章所述），从而确保例如 `PersonalizedGreeting` 不可能意外地作为 `greet` 函数的输入。但就目前的讨论而言，我并不太担心强制执行业务规则——只是关于拥有有意义的、明确的签名，因为我们将会查看很多签名。这是
    `greet` 函数的签名：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We then have a list of names and map `greet` over the list to obtain a greeting
    for each name in the list. Notice that the `greet` function is always called with
    “Hello” as its first argument, whereas the second argument varies with each name
    in the list.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个名字列表，并将 `greet` 映射到列表上，以获得列表中每个名字的问候语。请注意，`greet` 函数始终以“Hello”作为其第一个参数，而第二个参数则随着列表中的每个名字而变化。
- en: This feels slightly odd. We have a single general greeting and *n* different
    names, and we’re repeating that one greeting *n* times. Somehow it seems we’re
    repeating ourselves. Wouldn’t it be better to fix the greeting to be “Hello” outside
    the scope of `Map`? This would express the fact that deciding on “Hello” as the
    greeting to use for all names is a more general decision and can be taken first.
    The function passed to `Map` would then only consume the name. How can we achieve
    this?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这感觉有点奇怪。我们有一个通用的问候语和 *n* 个不同的名字，我们重复了那个问候语 *n* 次。似乎我们是在重复自己。难道不是更好将问候语固定为“Hello”在
    `Map` 的作用域之外？这将表达这样一个事实，即决定使用“Hello”作为所有名字的问候语是一个更通用的决策，并且可以首先进行。传递给 `Map` 的函数将只消耗名字。我们如何实现这一点？
- en: In listing 9.1, we can’t do this because `greet` expects two arguments, and
    we’re using “normal” function application; that is, we call `greet` with the two
    arguments it expects. (It’s called *application* because we’re applying the function
    `greet` to its arguments.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9.1 中，我们无法这样做，因为 `greet` 需要两个参数，而我们使用的是“正常”的函数应用；也就是说，我们以 `greet` 所期望的两个参数来调用
    `greet`。（它被称为 *application*，因为我们正在将函数 `greet` 应用到其参数上。）
- en: We can solve this with partial application. The idea is to allow some code to
    decide on the general greeting and give it to `greet` as its first argument (the
    way Ada decides on the color). This will generate a new function with “Hello”
    already baked in as the greeting to use. Some other code can then invoke this
    function with the name of the person to greet.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过部分应用来解决此问题。想法是允许一些代码决定通用的问候语，并将其作为第一个参数（就像 Ada 决定颜色那样）传递给 `greet`。这将生成一个新的函数，其中已经内置了“Hello”作为要使用的问候语。然后，其他代码可以调用这个函数，以问候人的名字。
- en: There are a couple of ways to make this possible. You’ll first see how to write
    a specific function in a way that supports partial application and then how to
    define a general `Apply` function that enables partial application for any given
    function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使这成为可能。你将首先看到如何以一种支持部分应用的方式编写一个特定的函数，然后是如何定义一个通用的 `Apply` 函数，它可以为任何给定的函数启用部分应用。
- en: 9.1.1 Manually enabling partial application
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 手动启用部分应用
- en: 'One way to supply arguments independently would be to rewrite the `greet` function
    like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 独立提供参数的一种方法是将 `greet` 函数重写如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This new function, `greetWith`, takes a single argument, the general greeting,
    and returns a new function of type `Name` `→` `PersonalizedGreeting`. Notice that
    when the function is called with its first argument, `gr`, this is captured in
    a closure and is, therefore, “remembered” until the returned function is called
    with the second argument, `name`. You’d use it like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的函数 `greetWith` 接受一个参数，即通用问候语，并返回一个类型为 `Name` `→` `PersonalizedGreeting`
    的新函数。注意，当函数使用其第一个参数 `gr` 被调用时，它被捕获在闭包中，因此“记住”直到返回的函数使用第二个参数 `name` 被调用。你可以这样使用它：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ve achieved our goal of fixing the greeting outside of the scope of `Map`.
    Notice that `greet` and `greetWith` rely on the same implementation, but their
    signatures are different. Let’s compare them:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了在 `Map` 范围之外修复问候语的目标。注意 `greet` 和 `greetWith` 依赖于相同的实现，但它们的签名不同。让我们比较一下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`greet` takes two arguments and returns a value. In contrast, `greetWith` takes
    a single argument, a `Greeting`, and returns a function that, in turn, takes a
    `Name` to return a `PersonalizedGreeting`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`greet` 接受两个参数并返回一个值。相比之下，`greetWith` 接受一个参数，即 `Greeting`，并返回一个函数，该函数反过来接受一个
    `Name` 并返回一个 `PersonalizedGreeting`。'
- en: 'In fact, arrow notation is *right-associative*: everything to the right of
    an arrow is grouped. So the parentheses in the signature of `greetWith` are redundant,
    and the type of `greetWith` would normally be written as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，箭头符号是 *右结合的*：箭头右侧的所有内容都被分组。因此，`greetWith` 签名中的括号是多余的，`greetWith` 的类型通常可以写成以下形式：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`greetWith` is said to be in *curried* form: all arguments are supplied one
    by one via function invocation.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`greetWith` 被称为是 *柯里化* 形式：所有参数都是通过函数调用逐个提供的。'
- en: Again, `greet` and `greetWith` rely on the same implementation. What changes
    is the signature and the fact that arguments are provided independently and are
    captured in closures. This is a good indicator that we should be able to do partial
    application mechanically without the need to rewrite the function. Let’s look
    at how to do this next.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`greet` 和 `greetWith` 依赖于相同的实现。变化的是签名以及参数是独立提供的并被捕获在闭包中。这是一个很好的迹象，表明我们应该能够机械地进行部分应用，而无需重写函数。让我们看看如何实现这一点。
- en: 9.1.2 Generalizing partial application
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 部分应用的一般化
- en: 'As a more general alternative to the approach you’ve just seen with `greetWith`,
    we can define an adapter function that allows you to provide just one argument
    to a multi-argument function, producing a function that is waiting to receive
    the remaining arguments. The following snippet shows the definition of a general
    `Apply` function, providing a given value as the first argument to a given binary
    function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对 `greetWith` 方法所展示方法的更一般替代，我们可以定义一个适配函数，允许你向一个多参数函数提供一个参数，从而生成一个等待接收剩余参数的函数。以下代码片段展示了通用
    `Apply` 函数的定义，它将给定值作为第一个参数传递给指定的二元函数：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ A binary function
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个二元函数
- en: ❷ A value for the first argument
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一个参数的值
- en: ❸ Returns a unary function that takes the second argument of the original function
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个接受原始函数第二个参数的一元函数
- en: '`Apply` takes a binary function, *partially applies* it to the given argument,
    and returns a unary function accepting the second argument. The supplied input
    argument, `t1`, is captured in a closure, yielding a new function that calls the
    original function, `f`, when the second parameter is provided.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apply` 接受一个二元函数，对给定的参数进行部分应用，并返回一个接受第二个参数的一元函数。提供的输入参数 `t1` 被捕获在闭包中，产生一个新的函数，当第二个参数提供时，它会调用原始函数
    `f`。'
- en: 'We can similarly define `Apply` for functions of greater arities. For example,
    here is `Apply` defined for a ternary function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地定义 `Apply` 用于更高阶的函数。例如，下面是 `Apply` 对三元函数的定义：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This overload takes a ternary function and a value to use as the first argument.
    It yields a binary function waiting for the remaining two arguments. Similar overloads
    can be defined for functions of greater arity and are included in `LaYumba.Functional`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重载接受一个三元函数和一个用作第一个参数的值。它产生一个二元函数，等待剩余的两个参数。可以定义类似的重载用于更高阶的函数，并包含在 `LaYumba.Functional`
    中。
- en: 'Notice how expression-bodied methods and the lambda notation give us good syntactic
    support to define this sort of function transformation. This general definition
    of `Apply` means you need not manually create a function like `greetWith`. Instead,
    you can just use `Apply` to give the original `greet` function its first argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意表达式主体方法和 lambda 表示法如何为我们提供良好的语法支持来定义这种函数转换。这种 `Apply` 的一般定义意味着你不需要手动创建一个像
    `greetWith` 这样的函数。相反，你只需使用 `Apply` 给原始的 `greet` 函数提供其第一个参数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Whether you’re using the manual approach or the general `Apply` function, you
    should be starting to see a pattern: we’re starting with a general function (like
    `greet`) and using partial application to create a specialized version of this
    function (like `greetInformally`). This is now a unary function that can be passed
    around, and the code that uses it doesn’t even need to be aware that this new
    function was partially applied. Figure 9.2 graphically summarizes the steps we’ve
    covered so far.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是使用手动方法还是通用的 `Apply` 函数，你应该开始看到一种模式：我们从一个通用函数（如 `greet`）开始，使用部分应用来创建这个函数的专用版本（如
    `greetInformally`）。现在这是一个一元函数，可以传递，使用它的代码甚至不需要意识到这个新函数已经被部分应用。图 9.2 图形总结了我们迄今为止所涵盖的步骤。
- en: '![](Images/CH09_F02_Buonanno2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F02_Buonanno2.png)'
- en: Figure 9.2 Comparing normal function application with partial application. Partial
    application allows you to supply arguments piecemeal to obtain functions that
    have those arguments built-inand are awaiting the following arguments. Partial
    application can be enabled manually or by using the general `Apply` function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 比较正常函数应用与部分应用。部分应用允许你分步骤提供参数，以获得内置这些参数并等待后续参数的函数。部分应用可以通过手动操作或使用通用的 `Apply`
    函数来启用。
- en: In summary, partial application is always about going from general to specific.
    It allows you to define general functions and then fine-tune their behavior by
    giving them arguments. Ultimately, writing such general functions ups the level
    of abstraction and potentially allows greater code reuse.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，部分应用始终是从一般到具体的。它允许你定义通用函数，然后通过提供参数来微调它们的行为。最终，编写这样的通用函数提高了抽象级别，并可能允许更大的代码重用。
- en: 9.1.3 Order of arguments matters
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 参数顺序的重要性
- en: 'The `greet` function shows what is generally a good order of arguments: the
    more general parameters, which are likely to be applied early in the life of the
    application, should come first, followed by the more specific parameters. We learn
    to say “Hello” early in life, but we keep meeting and greeting new people until
    we’re old.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`greet` 函数展示了通常良好的参数顺序：更通用的参数，这些参数可能在应用程序的生命周期早期被应用，应该放在前面，然后是更具体的参数。我们在早年就学会了说“你好”，但我们会一直遇到和问候新的人直到变老。'
- en: 'As a rule of thumb, if you think of a function as an operation, its arguments
    typically include the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，如果你将函数视为一个操作，它的参数通常包括以下内容：
- en: The data that the operation will affect. This is likely to be given late and
    should be left last.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该操作将影响的数据。这通常会在后期提供，应该放在最后。
- en: Some options that determine *how* the function will operate or dependencies
    that the function requires to do its work. These are likely to be determined early
    and should come first.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些确定函数将如何操作或函数执行工作所需的依赖项的选项。这些可能需要在早期确定，并应该放在前面。
- en: 'Warning This order of parameters is sometimes in conflict with our desire to
    use extension methods: unfortunately, we can only mark the *first* of a method’s
    parameters with the `this` modifier, although it may not be the most general parameter.
    In such cases, you have to make a choice on whether extension-method syntax or
    partial application is more desirable for your intended use.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这种参数顺序有时与我们的扩展方法使用愿望相冲突：不幸的是，我们只能用 `this` 修饰符标记方法参数中的第一个，尽管它可能不是最通用的参数。在这种情况下，你必须选择扩展方法语法或部分应用对你预期的用途是否更可取。
- en: Of course, it’s not always easy to establish the best order for parameters.
    You’ll shortly see how you can use partial application even if the order of parameters
    is wrong for your intended use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，确定参数的最佳顺序并不总是容易。你很快就会看到，即使参数的顺序不符合你的预期用途，你仍然可以使用部分应用。
- en: In summary, whenever you have a multi-argument function and it’s desirable to
    separate the responsibilities of supplying the different arguments it takes, you
    have a good case for using partial application. There is, however, one catch that
    we should iron out before proceeding to more practical uses of partial application.
    The catch has to do with type inference, and we’ll tackle this next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，每当您有一个多参数函数，并且希望分离提供不同参数的责任时，您就有很好的理由使用部分应用。然而，在继续使用部分应用的实际用途之前，我们应先解决一个难题。这个问题与类型推断有关，我们将在下一节中解决它。
- en: 9.2 Overcoming the quirks of method resolution
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 克服方法解析的怪癖
- en: 'So far, we’ve freely used methods, lambdas, and delegates to represent functions.
    To the compiler, however, these are all different things, and type inference for
    methods is not as good as we’d like it to be. Let’s first see what happens when
    things go well, like when we use `Option.Map`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们自由地使用了方法、lambda 和委托来表示函数。然而，对于编译器来说，这些都是不同的事物，并且方法的类型推断并不像我们希望的那样好。让我们首先看看事情顺利时会发生什么，比如当我们使用
    `Option.Map` 时：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that `Map` has two type parameters. If the compiler were unable to infer
    their types, we would have to write the preceding snippet like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Map` 有两个类型参数。如果编译器无法推断它们的类型，我们就必须像这样编写前面的代码片段：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the name `Math.Sqrt` identifies a method, and `Map` expects a delegate
    of type `Func<T, R>`. More technically, `Math.Sqrt` identifies a method group.
    Because of method overloading, there may be several methods with the same name.
    The compiler is smart enough to not only pick the right overload (in this case,
    there’s only one), but also to infer the type arguments for `Map`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，名称 `Math.Sqrt` 识别了一个方法，而 `Map` 期望一个类型为 `Func<T, R>` 的委托。更技术地说，`Math.Sqrt`
    识别了一个方法组。由于方法重载，可能有多个具有相同名称的方法。编译器足够智能，不仅可以选择正确的重载（在这种情况下，只有一个），还可以推断 `Map` 的类型参数。
- en: This is all very well and good. It keeps us from having to convert between methods
    (or, alternatively, lambdas) and delegates, and from specifying the generic types,
    given that these can be inferred from the method signature. Unfortunately, for
    methods taking two or more arguments, all this goodness goes away.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很完美。它使我们不必在方法（或，作为替代，lambda）和委托之间进行转换，也不必指定泛型类型，因为这些可以从方法签名中推断出来。不幸的是，对于需要两个或更多参数的方法，所有这些优点都消失了。
- en: Let’s see what happens if we try to rewrite the `greet` function as a method.
    In the following listing, it’s called `GreeterMethod`. Here’s what we would like
    to write.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们尝试将 `greet` 函数重写为方法会发生什么。在下面的列表中，它被称为 `GreeterMethod`。这是我们想要编写的代码。
- en: Listing 9.2 Type inference fails with multi-argument methods
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 多参数方法类型推断失败
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ If we write our greeting function as a method...
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果我们将问候函数编写为一个方法...
- en: ❷ ...then this expression does not compile.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ ...然后这个表达式无法编译。
- en: Here we’ve written the greeter function as a method, and we now want a `GreetWith`
    method to partially apply it to a given greeting. Unfortunately, this code doesn’t
    compile because the name `GreeterMethod` identifies a `MethodGroup`, whereas `Apply`
    expects a `Func`, and the compiler doesn’t make the inference for us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将问候函数编写为一个方法，现在我们想要一个 `GreetWith` 方法来部分应用它到一个特定的问候。不幸的是，这段代码无法编译，因为名称
    `GreeterMethod` 识别了一个 `MethodGroup`，而 `Apply` 期望一个 `Func`，编译器并没有为我们进行推断。
- en: Type inference in local functions
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数中的类型推断
- en: C# 7 introduces *local functions* (functions that are declared within the scope
    of a method), but they should actually be called *local methods*. Internally,
    they’re implemented as methods even though this gives no benefit (you can’t overload
    them), so in terms of type inference, they have the same characteristics as normal
    methods.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 引入了 *局部函数*（在方法作用域内声明的函数），但实际上它们应该被称为 *局部方法*。内部实现上，它们作为方法实现，尽管这没有任何好处（您不能重载它们），所以在类型推断方面，它们与普通方法具有相同的特性。
- en: If you want to use the generic `Apply` to supply arguments to a method, you
    have to use one of the forms in the following listing. You’ll see that using multi-argument
    methods as arguments to HOFs requires messy syntax.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用泛型 `Apply` 为方法提供参数，您必须使用以下列表中的某种形式。您会看到，将多参数方法作为 HOF（高阶函数）的参数使用时，需要复杂的语法。
- en: Listing 9.3 Multi-argument methods as arguments to HOFs
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 将多参数方法作为 HOF 的参数
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Foregoes extension method syntax and provides all generic arguments explicitly
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 放弃扩展方法语法，并显式提供所有泛型参数
- en: ❷ Explicitly converts the method to a `Func` before calling `Apply`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在调用`Apply`之前，显式地将方法转换为`Func`
- en: I personally find the syntactic noise in both cases unacceptable. Note that
    these issues are specific to *method* resolution. They go away if you use delegates
    (think `Func`) instead. The following listing shows different ways to create a
    delegate, which you can then use with `Apply`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人认为这两种情况中的语法噪声都是不可接受的。请注意，这些问题是特定于*方法*解析的。如果你使用委托（例如`Func`），这些问题就会消失。以下列表展示了创建委托的不同方式，然后你可以使用`Apply`：
- en: Listing 9.4 Different ways of obtaining a delegate instance
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 获取委托实例的不同方式
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Declaration and initialization of a delegate field; note that you can’t reference
    `separator` here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 委托字段的声明和初始化；注意你在这里不能引用`separator`。
- en: ❷ A getter-only property has its body introduced by `=>`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只有getters的属性通过`=>`引入其主体。
- en: ❸ A method that acts as a factory of functions can have generic parameters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 作为函数工厂的方法可以有泛型参数。
- en: Let’s briefly discuss these options. Declaring a delegate field would seem the
    most natural option. Unfortunately, it’s not very powerful. For example, if you
    combine declaration and initialization as shown in listing 9.4, you can’t reference
    any instance variables like `separator` in the delegate body. Also, because fields
    can be reassigned (something we certainly don’t want to do in this case), you
    should mark the delegate as `readonly`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论这些选项。声明委托字段似乎是最自然的选择。不幸的是，它并不强大。例如，如果你像列表9.4中所示的那样结合声明和初始化，你无法在委托主体中引用任何实例变量，如`separator`。此外，由于字段可以被重新赋值（我们当然不希望在这种情况下这样做），你应该将委托标记为`readonly`。
- en: Alternatively, you can expose the delegate through a property instead. In the
    class exposing the delegate, this amounts to just replacing `=` with `=>` to declare
    a getter-only property. From the point of view of the calling code, this change
    is completely transparent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过属性公开委托。在公开委托的类中，这相当于只是将`=`替换为`=>`来声明一个只有getters的属性。从调用代码的角度来看，这种变化是完全透明的。
- en: 'But the most powerful way is to have a *factory method*: a method that’s there
    just to create the delegate you want. The big difference here is that you can
    also have generic parameters, which isn’t possible with fields or properties.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但最强大的方式是有一个*工厂方法*：一个仅用于创建你想要的委托的方法。这里的主要区别是，你还可以有泛型参数，这是字段或属性所不可能的。
- en: 'Whichever way you obtain a delegate instance, type resolution will work fine,
    so that in all cases, you can supply the first argument like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你以何种方式获取委托实例，类型解析都将正常工作，因此，在所有情况下，你可以像这样提供第一个参数：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The takeaway from this section is that if you want to use HOFs that take multi-argument
    functions as arguments, it’s sometimes best to move away from using methods and
    write `Func`s instead (or methods that return `Func`s). While less idiomatic than
    methods, `Func`s save you the syntactic overhead of explicitly specifying type
    arguments, making the code much more readable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的要点是，如果你想使用接受多参数函数作为参数的高阶函数（HOFs），有时最好放弃使用方法，转而使用`Func`（或者返回`Func`的方法）。虽然`Func`不如方法那样符合惯例，但它们可以节省你显式指定类型参数的语法开销，使代码更易于阅读。
- en: 'Now that you know about partial application, let’s move on to a related concept:
    currying. It’s a technique that assumes and arguably simplifies partial application.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了部分应用，让我们继续讨论一个相关概念：currying。这是一种假设并可能简化部分应用的技术。
- en: '9.3 Curried functions: Optimized for partial application'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9.3 Curried functions: Optimized for partial application'
- en: Named after mathematician Haskell Curry, *currying* is the process of transforming
    an *n*-ary function *f* that takes the arguments *t1*, *t2*,..., *tn* into a unary
    function that takes *t1* and yields a new function that takes *t2*, and so on,
    ultimately returning the same result as *f* once the arguments have all been given.
    In other words, an *n*-ary function with this signature
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以数学家Haskell Curry命名，*currying*是将一个*n*-元函数*f*，它接受参数*t1*，*t2*，...，*tn*，转换为一个一元函数，它接受*t1*并产生一个新的函数，该函数接受*t2*，依此类推，最终在所有参数都给出后返回与*f*相同的结果。换句话说，具有此签名的*n*-元函数
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'when curried, has this signature:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行curry操作时，具有以下特征：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You’ve seen an example of this in the first section of this chapter. Here’s
    a reminder:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章的第一节中已经看到了这个例子。这里是一个提醒：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I mentioned that `greetWith` is like `greet` but in curried form. Indeed, compare
    the signatures:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到`greetWith`类似于`greet`，但以curry形式。确实，比较它们的签名：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This means that you could call the curried `greetWith` function like so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以像这样调用柯里化的 `greetWith` 函数：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is two function invocations, and it’s effectively the same as calling
    `greet` with two arguments. Of course, if you’re going to pass in all the parameters
    at the same time, this is pointless. But it becomes useful when you’re interested
    in partial application. If a function is curried, partial application is achieved
    simply by invoking the function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是两次函数调用，并且它有效地等同于用两个参数调用 `greet`。当然，如果你打算同时传递所有参数，这就没有意义了。但是，当你对部分应用感兴趣时，它就变得很有用。如果一个函数是柯里化的，那么通过调用函数就可以简单地实现部分应用。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A function can be written in curried form like `greetWith` here; this is called
    *manual currying*. Alternatively, it’s possible to define generic functions that
    will take an *n*-ary function and curry it. For binary and ternary functions,
    `Curry` looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以像这里的 `greetWith` 一样写成柯里形式；这被称为*手动柯里化*。或者，也可以定义通用的函数，这些函数将接受一个*n*-元函数并将其柯里化。对于二元和三元函数，`Curry`
    看起来是这样的：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similar overloads can be defined for functions of other arities. As an exercise,
    write the signatures of the preceding functions in arrow notation. Let’s look
    at how we could use such a generic `Curry` function to curry the `greet` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为其他元数的函数定义类似的重载。作为一个练习，请用箭头符号写出前面函数的签名。让我们看看我们如何使用这样一个通用的 `Curry` 函数来柯里化 `greet`
    函数：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, if you want to use the generic `Curry` function, the same caveats
    about method resolution apply as with `Apply`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想使用通用的 `Curry` 函数，与 `Apply` 一样，方法解析的注意事项同样适用。
- en: 'Partial application and currying are closely related yet distinct concepts,
    and this is often confusing when you’re introduced to them. Let’s spell out the
    differences:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用和柯里化是密切相关的概念，但又是不同的，当你第一次接触它们时，这通常很令人困惑。让我们明确一下这些区别：
- en: '*Partial application*—You give a function fewer arguments than the function
    expects, obtaining a function that’s particularized with the values of the arguments
    given so far.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分应用*——你给函数提供的参数少于函数期望的参数，得到一个使用到目前为止提供的参数值特定化的函数。'
- en: '*Currying*—You don’t give any arguments; you just transform an *n*-ary function
    into a unary function to which arguments can be successively given to eventually
    get the same result as the original function.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*柯里化*——你没有任何参数；你只是将一个*n*-元函数转换成一个一元函数，可以依次给出参数，最终得到与原始函数相同的结果。'
- en: 'As you can see, currying doesn’t really *do* anything; rather, it optimizes
    a function for partial application. You can do partial application without currying
    as we did previously in this chapter with the use of the generic `Apply` functions.
    On the other hand, currying by itself is pointless: you curry a function (or write
    a function in curried form) so that you can more easily use partial application.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，柯里化实际上并没有*做*任何事情；相反，它优化了函数以进行部分应用。你可以像我们在本章前面使用通用 `Apply` 函数那样，不进行柯里化就进行部分应用。另一方面，仅仅柯里化本身是没有意义的：你柯里化一个函数（或以柯里形式编写一个函数）是为了更容易地使用部分应用。
- en: 'Partial application is so commonly used in FP that in many functional languages
    all functions are curried by default. For this reason, function signatures in
    arrow notation are given in curried form in the FP literature, like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用在 FP 中非常常见，以至于在许多函数式语言中，所有函数默认都是柯里化的。因此，在 FP 文献中，箭头符号中的函数签名都是以柯里形式给出的，如下所示：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: IMPORTANT In the rest of the book, I’ll always use the curried notation even
    for functions that aren’t, in fact, curried.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：在本书的其余部分，我总是使用柯里符号，即使对于实际上不是柯里化的函数也是如此。
- en: 'Even though functions aren’t curried by default in C#, you can still take advantage
    of partial application, allowing you to write highly general and, hence, widely
    reusable functions by parameterizing their behavior. You can then use partial
    application to create the more specific functions that you’ll require from time
    to time. As you’ve seen so far, you can achieve this in different ways:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 C# 中函数默认不是柯里化的，但你仍然可以利用部分应用，通过参数化其行为来编写高度通用且因此广泛可重用的函数。然后你可以使用部分应用来创建你偶尔需要的更具体的函数。如你所见，你可以用不同的方式实现这一点：
- en: By writing functions in curried form
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将函数写成柯里形式
- en: By currying functions with `Curry` and then invoking the curried function with
    subsequent arguments
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `Curry` 柯里化函数，然后使用后续参数调用柯里化函数
- en: By supplying arguments one by one with `Apply`
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过逐个提供参数使用 `Apply`
- en: Which technique you use is a matter of taste, although I personally find that
    using `Apply` is the most intuitive.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用哪种技术是个人口味的问题，尽管我个人认为使用 `Apply` 是最直观的。
- en: 9.4 Creating a partial-application-friendly API
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 创建部分应用友好的 API
- en: Now that you’ve seen the basic mechanism of partial application and how to work
    around poor type inference by using `Func`s instead of methods, we can move on
    to a more complex scenario in which we’ll use a third-party library and realistic
    real-world requirements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看到了部分应用的基本机制以及如何通过使用 `Func` 而不是方法来绕过类型推断不足，我们可以继续到一个更复杂的场景，在这个场景中我们将使用第三方库和现实世界的需求。
- en: One good scenario for partial application is when a function requires some configuration
    that’s available at startup and doesn’t change, along with transient arguments
    that vary with every invocation. In such cases, a bootstrapping component can
    supply the configuration arguments, obtaining a specialized function that only
    expects invocation-specific arguments. This can then be given to the final consumer
    of the functionality, which is thus freed from having to know anything about the
    configuration.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用的一个好场景是当一个函数需要一些在启动时可用且不改变的配置，以及每次调用时都变化的临时参数。在这种情况下，一个引导组件可以提供配置参数，从而获得一个只期望调用特定参数的专用函数。然后，这可以提供给功能最终消费者，从而使其无需了解任何关于配置的信息。
- en: 'In this section, we’ll look at such an example: that of accessing a SQL database.
    Imagine an application that, like most, needs to perform a number of queries against
    a database. Let’s think about this in terms of partial application. Imagine a
    general function for retrieving data:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨这样一个例子：访问 SQL 数据库。想象一个应用程序，像大多数应用程序一样，需要对数据库执行多个查询。让我们从部分应用的角度来考虑这个问题。想象一个用于检索数据的一般函数：
- en: It can be particularized to query a specific database.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以被具体化为查询特定的数据库。
- en: It can be further particularized to retrieve objects of a given type.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以被进一步具体化为检索特定类型的对象。
- en: It can be further particularized with a given query and parameters.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过给定的查询和参数进一步具体化。
- en: 'Let’s explore this through a simple example. Suppose we want to load an `Employee`
    by ID or to search for `Employee`s by last name. These operations can be captured
    by functions with the following signatures:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来探索这个问题。假设我们想要通过 ID 加载一个 `Employee` 或通过姓氏搜索 `Employee`。这些操作可以通过以下签名的函数来捕捉：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implementing these functions is our high-level goal. At a low level, we’re
    going to use the Dapper library to query a SQL Server database.[¹](#pgfId-1119600)
    For retrieving data, Dapper exposes the `Query` method with the following signature:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些函数是我们的高级目标。在低级上，我们将使用 Dapper 库来查询 SQL Server 数据库。[¹](#pgfId-1119600) 对于检索数据，Dapper
    提供了具有以下签名的 `Query` 方法：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Table 9.1 describes the arguments we need to provide when calling `Query`, including
    the type parameter `T`. In this example, we’ll disregard the last two parameters,
    which are optional.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 描述了在调用 `Query` 时我们需要提供的参数，包括类型参数 `T`。在这个例子中，我们将忽略最后两个参数，它们是可选的。
- en: Table 9.1 Arguments to Dapper’s `Query` method
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 Dapper 的 `Query` 方法参数
- en: '| `T` | The type that should be populated from the data returned by the query.
    In our case, this will be `Employee` (Dapper automatically maps columns to fields).
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `T` | 应从查询返回的数据中填充的类型。在我们的例子中，这将是一个 `Employee`（Dapper 自动将列映射到字段）。|'
- en: '| `conn` | The connection to the database (notice that `Query` is an extension
    method on the connection but that doesn’t matter as far as partial application
    is concerned). |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `conn` | 数据库的连接（注意 `Query` 是连接上的扩展方法，但这与部分应用无关）。|'
- en: '| `sqlQuery` | This is a template for the SQL query you want to execute, such
    as `"SELECT` `*` `FROM EMPLOYEES` `WHERE` `ID` `=` `@Id"` (notice the `@Id` placeholder).
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `sqlQuery` | 这是你要执行的 SQL 查询的模板，例如 `"SELECT` `*` `FROM EMPLOYEES` `WHERE`
    `ID` `=` `@Id"`（注意 `@Id` 占位符）。|'
- en: '| `param` | An object whose properties are used to populate the placeholders
    in the `sqlQuery`. For instance, the preceding query needs the provided object
    to include a field called `Id`, whose value will be evaluated and rendered in
    the `sqlQuery` instead of `@Id`. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `param` | 一个其属性用于填充 `sqlQuery` 中占位符的对象。例如，前面的查询需要提供的对象包含一个名为 `Id` 的字段，其值将在
    `sqlQuery` 中被评估并渲染，而不是 `@Id`。|'
- en: This is a great example of order of parameters because the connection and the
    SQL query can be applied as part of the application setup, whereas the `param`
    object will be specific to each call to `Query`. Right?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于参数顺序的绝佳例子，因为连接和 SQL 查询可以作为应用程序设置的一部分应用，而 `param` 对象将针对 `Query` 的每次调用而特定。对吗？
- en: 'Err . . . well, actually, wrong! SQL connections are lightweight objects and
    should be obtained and disposed of whenever a query is performed. In fact, as
    you may remember from chapter 2, the standard use of Dapper’s API follows this
    pattern:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 噢，实际上，错了！SQL 连接是轻量级对象，应该在查询执行时获取和释放。实际上，正如你可能从第 2 章中记得的，Dapper 的 API 的标准使用遵循此模式：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This means our first parameter, the connection, is less general than the second
    parameter, the SQL template. But all is not lost. Remember, if you don’t like
    the API you have, you can change it! That’s what adapter functions are for.[²](#pgfId-1119642)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的第一个参数（连接）不如第二个参数（SQL 模板）通用。但并非一切都已失去。记住，如果你不喜欢你拥有的 API，你可以改变它！这就是适配器函数的作用。[²](#pgfId-1119642)
- en: In the rest of this section, we’ll write an API that better supports partial
    application in order to create specialized functions that retrieve the data we’re
    interested in.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将编写一个更好的支持部分应用的 API，以便创建检索我们感兴趣的数据的专用函数。
- en: 9.4.1 Types as documentation
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 类型作为文档
- en: While the DB connection must be short lived, the connection string which is
    used to create a connection typically doesn’t change during the application’s
    lifetime. It can be read from configuration when the application starts, and it
    never changes thereafter. The connection string would therefore be the most general
    parameter taken by a function that retrieves data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 DB 连接必须是短暂的，但用于创建连接的连接字符串在应用程序的生命周期内通常不会改变。它可以在应用程序启动时从配置中读取，之后永远不会改变。因此，连接字符串将是函数检索数据时使用的最一般参数。
- en: Let’s apply an idea introduced in section 4.2 (namely, that we can use types
    to make our code more expressive) and create a dedicated type for connection strings.
    The following listing shows this approach.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用第 4.2 节中介绍的一个想法（即我们可以使用类型来使我们的代码更具表达性），并为连接字符串创建一个专用类型。以下列表展示了这种方法。
- en: Listing 9.5 A custom type for connection strings
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 用于连接字符串的自定义类型
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When a string is not just a string but a DB connection string, we’ll wrap it
    in a `ConnectionString`. This can be done trivially through implicit conversion.
    For example, on startup, we can populate it from configuration like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个字符串不仅仅是字符串，而是数据库连接字符串时，我们将它包装在 `ConnectionString` 中。这可以通过隐式转换轻易完成。例如，在启动时，我们可以从配置中填充它，如下所示：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The same thinking applies to the SQL template, so I’ve also defined a `SqlTemplate`
    type along the same lines. Most statically typed functional languages let you
    define custom types in terms of built-in types with a one-liner like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的思考方式也适用于 SQL 模板，因此我也定义了一个 `SqlTemplate` 类型，遵循同样的原则。大多数静态类型函数式语言允许你使用一行代码定义自定义类型，基于内置类型，如下所示：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In C#, it’s a bit more laborious but still worth the effort. First, it makes
    your function signatures more intention-revealing: you’re using types to document
    what your function does. For example, a function can declare that it depends on
    a connection string as in the following listing.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，这要费点劲，但仍然值得。首先，它使你的函数签名更具意图性：你正在使用类型来记录你的函数做什么。例如，一个函数可以声明它依赖于连接字符串，如下所示。
- en: Listing 9.6 Making function signatures more explicit with custom types
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 使用自定义类型使函数签名更明确
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is much more explicit than depending on a `string`. The second benefit
    is that you can now define extension methods on `ConnectionString`, which wouldn’t
    make sense on `string`. You’ll see this next.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这比依赖于 `string` 要明确得多。第二个好处是，你现在可以定义 `ConnectionString` 的扩展方法，这在 `string` 上是没有意义的。你将在下一部分看到这一点。
- en: 9.4.2 Particularizing the data access function
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 数据访问函数的特定化
- en: 'Now that we’ve looked at representing and acquiring a connection string, let’s
    look at the remaining data needed to perform the DB query, from general to specific:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了表示和获取连接字符串的方法，让我们看看执行 DB 查询所需的其他数据，从一般到具体：
- en: The type of data we want to retrieve (such as `Employee`)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要检索的数据类型（例如 `Employee`）
- en: The SQL query template (such as `"SELECT` `*` `FROM` `EMPLOYEES` `WHERE` `ID`
    `=` `@Id"`)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 查询模板（例如 `"SELECT` `*` `FROM` `EMPLOYEES` `WHERE` `ID` `=` `@Id"`)
- en: The `param` object that we’ll use to render the SQL template (such as `new`
    `{` `Id = "123" }`)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用`param`对象来渲染 SQL 模板（例如`new` `{` `Id = "123" }`）
- en: Now comes the crux of the solution. We can define an extension method on `ConnectionString`
    that takes the parameters we need as in the following listing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是解决方案的核心。我们可以在`ConnectionString`上定义一个扩展方法，它接受我们需要的参数，如下所示。
- en: Listing 9.7 An adapter function that’s better suited for partial application
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 一个更适合部分应用的适配函数
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ These values are available on application startup.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些值在应用程序启动时可用。
- en: ❷ This value changes with each query.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个值随着每个查询而变化。
- en: 'Notice that we’re relying on `ConnectionHelper.Connect`, which we implemented
    in section 2.3 and which internally takes care of opening and disposing the connection.
    It doesn’t matter if you don’t remember the implementation details; just notice
    that here the most general parameter (the connection string, which will not change
    throughout the lifetime of the application) comes as the first parameter, whereas
    the DB connection itself is short-lived, and a new instance will be created by
    `Connect` with every query. This is the signature of the preceding method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们依赖于`ConnectionHelper.Connect`，我们在第 2.3 节中实现了它，并且它内部负责打开和释放连接。如果你不记得实现细节没关系；只需注意，在这里，最通用的参数（在整个应用程序生命周期中不会改变的连接字符串）作为第一个参数，而数据库连接本身是短暂的，并且每次查询都会由`Connect`创建一个新的实例。这是先前方法的签名：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The function takes a connection string and a SQL template. These values are
    known when the application starts, so they can be given by a component that reads
    the configuration to `Retrieve` at startup. The result is a function that is still
    waiting to receive a final parameter: an object with the SQL query parameters.
    Such a function can be given to the component that handles incoming requests made
    by a client, for example. Hopefully, you now see how partial application relates
    to separation of concerns.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接收一个连接字符串和一个 SQL 模板。这些值在应用程序启动时已知，因此可以由一个在启动时读取配置以`检索`的组件提供。结果是仍然等待接收一个最终参数：一个包含
    SQL 查询参数的对象。例如，这样的函数可以被处理客户端发起的请求的组件使用。希望你现在看到了部分应用与关注点分离之间的关系。
- en: The following listing shows how `Retrieve` can be particularized to implement
    the functions we need.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何具体化`Retrieve`以实现我们需要的函数。
- en: Listing 9.8 Supplying arguments to get a function of the desired signature
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 向获取所需签名的函数提供参数
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ The connection string and SQL query are fixed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 连接字符串和 SQL 查询是固定的。
- en: ❷ The connection string and SQL query are fixed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 连接字符串和 SQL 查询是固定的。
- en: ❸ The functions we set out to implement
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们打算实现的函数
- en: Here we define `queryById` and `queryByLastName` by particularizing the previously
    defined `Retrieve` method. We now have two unary functions that expect a `param`
    object, which wraps values that are used to replace the placeholder in the `SqlTemplate`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过具体化先前定义的`Retrieve`方法来定义`queryById`和`queryByLastName`。现在我们有两个接受`param`对象的单参数函数，它封装了用于替换`SqlTemplate`中占位符的值。
- en: All that’s left to do is to define `lookupEmployee` and `findEmployeesByLastName`
    with the signatures we set out to expose at the beginning of the section. These
    act as adapter functions that translate their input argument to a suitably populated
    `param` object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是定义`lookupEmployee`和`findEmployeesByLastName`，它们具有我们在本节开头设定的签名。这些函数作为适配函数，将它们的输入参数转换为适当填充的`param`对象。
- en: NOTE It would be nice to be able to give `Retrieve` the connection string and
    obtain a function that can then be parameterized by the type of data returned.
    After all, we’re going to use the same connection string for retrieving `Employee`s
    as for any other entities. Unfortunately, C# doesn’t allow us to defer the resolution
    of generic type arguments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：能够给`Retrieve`提供连接字符串并获取一个可以由返回的数据类型参数化的函数将是非常好的。毕竟，我们将使用相同的连接字符串来检索`Employee`和其他实体。不幸的是，C#不允许我们延迟泛型类型参数的解析。
- en: In this example, you saw how we started with an extremely general function for
    running any query against any SQL database and ended up with highly specialized
    functions. Note that we didn’t explicitly use `Curry` or `Apply`; instead, `Retrieve`
    is defined in such a way that the arguments can be given piecemeal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你看到了我们从一个针对任何 SQL 数据库运行任何查询的极其通用的函数开始，最终得到了高度专业化的函数。请注意，我们没有明确使用`Curry`或`Apply`；相反，`Retrieve`被定义为可以分步骤提供参数。
- en: 9.5 Modularizing and composing an application
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 模块化和组合应用程序
- en: As applications grow, we need to modularize them and break them down into components.
    For instance, in chapter 8, you saw an end-to-end example of handling a request
    to book a transfer. We put all the code in the controller, and by the end, the
    list of members in the controller looked like that shown in the following listing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，我们需要对它们进行模块化，并将它们分解成组件。例如，在第8章中，你看到了处理预订转账请求的端到端示例。我们将所有代码放在控制器中，到结束时，控制器的成员列表看起来如下面的列表所示。
- en: Listing 9.9 A controller with too many responsibilities?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 过于负责的控制器？
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If this were a real-world banking application, you’d have not two but dozens
    of rules for checking the validity of the transfer request. You’d also have functionality
    to deal with identity and session management, instrumentation, and so on. In short,
    the controller would quickly become too big, and you’d need to break it down into
    separate components with more discrete responsibilities. This makes your code
    more modular and more manageable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个现实世界的银行应用程序，你将不仅仅有两个规则来检查转账请求的有效性，而是会有几十个规则。你还会处理身份验证和会话管理、仪表化等功能。简而言之，控制器会迅速变得太大，你需要将其分解成具有更多离散责任的不同组件。这使得你的代码更加模块化和易于管理。
- en: 'The other big drive for modularity is code reuse: logic for, say, session management
    or authorization could be required by several controllers and should, therefore,
    be placed in a separate component. Once you’ve broken up an application into components,
    you need to compose it back together so that all required components can collaborate
    at run time.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的另一个主要动力是代码重用：例如，会话管理或授权的逻辑可能需要由几个控制器使用，因此应该放置在单独的组件中。一旦将应用程序分解成组件，你需要将其重新组合，以便所有必需的组件可以在运行时协作。
- en: In this section, we’ll look at how to deal with modularity and how the OO and
    functional approaches differ in this respect. We’ll illustrate this by refactoring
    `MakeTransferController`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何处理模块化以及面向对象和函数式方法在这方面的差异。我们将通过重构 `MakeTransferController` 来说明这一点。
- en: 9.5.1 Modularity in OOP
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 面向对象编程中的模块化
- en: Modularity in OOP is usually obtained by assigning responsibilities to different
    classes and capturing these responsibilities with interfaces. For instance, you
    might define an `IValidator` interface for validation and an `IRepository` for
    persistence as the following listing displays.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，模块性通常是通过将责任分配给不同的类，并通过接口捕获这些责任来获得的。例如，你可能定义一个 `IValidator` 接口用于验证，以及一个
    `IRepository` 接口用于持久化，如下面的列表所示。
- en: Listing 9.10 Interfaces in OOP capture the components' responsibilities
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 面向对象编程中的接口捕获组件的责任
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The controller would then depend on these interfaces in order to do its work
    as figure 9.3 shows.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器将依赖于这些接口来完成其工作，如图9.3所示。
- en: '![](Images/CH09_F03_Buonanno2.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F03_Buonanno2.png)'
- en: Figure 9.3 In OO design, higher-level components, like `Controller`, consume
    lower-level components, like `Repository`, via interfaces.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 在面向对象设计中，高级组件（如 `Controller`）通过接口消费低级组件（如 `Repository`）。
- en: 'This follows a pattern called *dependency inversion*, according to which a
    higher-level component (such as the controller) doesn’t consume lower-level components
    directly but rather through abstractions, which is usually understood to mean
    interfaces that the lower-level components (such as the validators and repository)
    implement.[³](#pgfId-1119800) There are a couple of benefits to this approach:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循一种称为 *依赖反转* 的模式，根据该模式，高级组件（如控制器）不是直接消费低级组件，而是通过抽象来消费，这通常被理解为低级组件（如验证器和存储库）实现的接口。[³](#pgfId-1119800)
    这种方法有几个好处：
- en: '*Decoupling*—You can swap out the repository implementation, changing it from
    writing to a database to writing to a queue, and this wouldn’t impact the controller.
    You’d only need to change how the two are wired.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解耦*—你可以更换存储库实现，将其从写入数据库更改为写入队列，而这不会影响控制器。你只需要更改两者之间的连接方式。'
- en: '*Testability*—You can unit test the handler without hitting the database by
    injecting a fake `IRepository`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可测试性*—你可以通过注入一个假的 `IRepository` 来对处理器进行单元测试，而无需访问数据库。'
- en: 'There’s also a rather high cost associated with dependency inversion:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖反转相关的高成本也是相当高的：
- en: There’s an explosion in the number of interfaces, adding boilerplate and making
    the code difficult to navigate.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的数量激增，增加了样板代码，并使代码难以导航。
- en: The bootstrapping logic to compose the application is often far from trivial.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合应用程序的启动逻辑通常远非简单。
- en: Building fake implementations for testability can be complex.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用于可测试性的模拟实现可能很复杂。
- en: To manage this extra complexity, third-party frameworks are often used; namely,
    IoC containers and mocking frameworks. If we follow this approach, the implementation
    of the controller ends up looking like what you see in the following listing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理这种额外的复杂性，通常会使用第三方框架；即，IoC容器和模拟框架。如果我们遵循这种方法，控制器的实现最终看起来就像下面列表中所示的那样。
- en: Listing 9.11 Functional in the small and OO in the large
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11 小规模函数式和大规模面向对象
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Dependencies are objects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 依赖项是对象。
- en: ❷ Dependencies are injected in the constructor.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 依赖项在构造函数中注入。
- en: ❸ Consumes dependencies
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 消耗依赖项
- en: You could say that the preceding implementation is functional in the small and
    OO in the large. The main components (controller, validator, repository) are indeed
    objects, and the program behavior is encoded in methods on these objects. On the
    other hand, many functional concepts are then used in the implementation of the
    methods and in defining their signatures.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说，前面的实现在小规模上是功能性的，在大规模上是面向对象的。主要组件（控制器、验证器、存储库）确实是对象，程序行为编码在这些对象的方法上。另一方面，许多功能性概念随后被用于方法的实现以及它们的签名定义中。
- en: This approach of using functional techniques within an overall OO software architecture
    is a perfectly valid way to integrate FP with OOP. It’s also possible to push
    the functional approach so that all behavior is captured in functions. You’ll
    see this next.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在整体面向对象软件架构中使用功能性技术的方法是整合函数式编程（FP）与面向对象编程（OOP）的一种完全有效的方式。也有可能将函数式方法推进到所有行为都被函数捕获的程度。你将在下一部分看到这一点。
- en: 9.5.2 Modularity in FP
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 FP中的模块化
- en: If the fundamental units of OOP are objects, in FP they’re functions. Modularity
    in FP is achieved by assigning responsibilities to functions, which are then combined
    using function composition. In a functional approach, we don’t define interfaces
    because function signatures already provide all the interface we need.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果面向对象编程的基本单元是对象，那么在函数式编程中它们就是函数。函数式编程中的模块化是通过将责任分配给函数，然后通过函数组合来实现的。在函数式方法中，我们不需要定义接口，因为函数签名已经提供了我们需要的所有接口。
- en: For instance, in chapter 3, you saw that a validator class that needs to know
    the current time doesn’t need to depend on a service, but can just depend on a
    function that returns the current time. The following listing provides a reminder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第3章中，你看到需要一个知道当前时间的验证器类不需要依赖于服务，而只需依赖于一个返回当前时间的函数。下面的列表提供了一个提醒。
- en: Listing 9.12 Injecting functions as dependencies
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12 将函数作为依赖项注入
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After all, what is a clock if not a function that you can invoke to get the
    current time? But let’s take this one step further: Why would you even need the
    `IValidator` interface in the first place? After all, what is a validator if not
    a function that you can call to find out if a given object is valid? Let’s instead
    use a delegate to represent validation:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，如果时钟不是一个可以调用来获取当前时间的函数，那它是什么呢？但让我们更进一步：为什么你甚至需要`IValidator`接口呢？毕竟，验证器如果不是一个可以用来确定给定对象是否有效的函数，那又是什么呢？让我们改用一个委托来表示验证：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we follow this approach, `MakeTransferController` depends not on an `IValidator`
    object but on a `Validator` function. To implement a `Validator`, you don’t need
    to have an object storing dependencies as fields; instead, dependencies can be
    passed as function arguments, as the next listing shows.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循这种方法，`MakeTransferController`不是依赖于一个`IValidator`对象，而是依赖于一个`Validator`函数。要实现一个`Validator`，你不需要有一个存储依赖项的字段的对象；相反，依赖项可以作为函数参数传递，如下一个列表所示。
- en: Listing 9.13 Passing dependencies as function arguments
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 将依赖项作为函数参数传递
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `DateNotPast` is a HOF that takes a function `clock` (the dependency it
    needs in order to know the current date) and returns a function of type `Validator`.
    Notice how this approach spares you the whole ceremony of creating interfaces,
    injecting them in the constructor, and storing them in fields.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DateNotPast`是一个高阶函数（HOF），它接受一个函数`clock`（它需要知道当前日期的依赖项）并返回一个类型为`Validator`的函数。注意这种方法如何让你免于创建接口、在构造函数中注入它们以及将它们存储在字段中的整个仪式。
- en: 'Let’s see how you would create a `Validator`. When bootstrapping the application,
    you’d give `DateNotPast` a function that reads from the system clock:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个`Validator`。在启动应用程序时，你会给`DateNotPast`一个从系统时钟读取的函数：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For testing purposes, however, you can provide a `clock` that returns a constant
    date:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，出于测试目的，你可以提供一个返回固定日期的`clock`：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice that this is, in fact, partial application: `DateNotPast` is a binary
    function (in curried form) that needs a clock and a `MakeTransfer` to compute
    its result. You supply the first argument when composing the application (or in
    the *arrange* phase of a unit test) and the second argument when processing an
    incoming request (or in the *act* phase of a unit test).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这实际上是一种部分应用：`DateNotPast`是一个二元函数（以柯里化形式），它需要一个`clock`和一个`MakeTransfer`来计算其结果。你在组合应用（或单元测试的*arrange*阶段）时提供第一个参数，在处理传入请求（或单元测试的*act*阶段）时提供第二个参数。
- en: 'Apart from the validator, `MakeTransferController` also needs a dependency
    to persist the `MakeTransfer` request data. If we’re going to use functions, we
    can represent this with the following signature:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了验证器之外，`MakeTransferController`还需要一个依赖项来持久化`MakeTransfer`请求数据。如果我们打算使用函数，我们可以用以下签名来表示这一点：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Again, we can create such a function by starting with a general function that
    writes to the DB with this signature:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以从一个通用的函数开始，该函数使用此签名写入数据库来创建这样一个函数：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can then parameterize it with a connection string from the configuration
    and a SQL template with the command we want to execute. This is similar to the
    `Retrieve` function you saw in section 9.3, so I’ll omit the full details here.
    Our controller implementation will now look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用配置中的连接字符串和要执行的命令的SQL模板来参数化它。这与你在9.3节中看到的`Retrieve`函数类似，所以我在这里省略了全部细节。我们的控制器实现现在将看起来像这样：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we take this approach to its logical conclusion, we should question why
    we need a controller at all when all the logic we’re using could be captured in
    a function of type:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这种方法推向逻辑结论，我们应该质疑为什么我们还需要控制器，因为所有我们使用的逻辑都可以被捕获在类型为的函数中：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is a function that takes a `MakeTransfer` command, deserialized from the
    body of the HTTP request, and returns an `IResult`, which ASP.NET uses to populate
    the HTTP response appropriately. More precisely, the function also needs to take
    in the `validate` and `save` functions it depends on. The following listing shows
    this approach.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受从HTTP请求体反序列化的`MakeTransfer`命令的函数，并返回一个`IResult`，ASP.NET使用它来适当地填充HTTP响应。更确切地说，该函数还需要接受它所依赖的`validate`和`save`函数。以下列表显示了这种方法。
- en: Listing 9.14 The top-level function of our use case
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 我们用例的最高级函数
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Defines the functions `Ok`, `BadRequest`, etc., which populate an `IResult`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义了`Ok`、`BadRequest`等函数，这些函数用于填充`IResult`
- en: ❷ Dependencies required to handle the command
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 处理命令所需的依赖项
- en: ❸ The command that is received by the API
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ API接收到的命令
- en: 'This is pretty much the same as our `MakeTransferController` method with a
    couple of differences:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与我们的`MakeTransferController`方法相同，只是有几个不同之处：
- en: '*Dependencies are not stored in fields but are functions passed as parameters.*
    We expect that `validate` and `save` are given when the application starts, resulting
    in a function that takes a `MakeTransfer`, which is called with each incoming
    request.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖项不是存储在字段中，而是作为参数传递的函数。我们期望在应用程序启动时提供`validate`和`save`，从而得到一个接受`MakeTransfer`的函数，该函数与每个传入请求一起调用。'
- en: '*The code uses functions like* `OK` *and* `BadRequest` *to populate an* `IResult`*.*
    These are exposed as static methods in `Microsoft.AspNetCore.Http.Results`. In
    contrast, the previous implementation (listing 9.11) used equally named methods
    inherited from `ControllerBase`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码使用像`OK`和`BadRequest`这样的函数来填充`IResult`。这些作为静态方法在`Microsoft.AspNetCore.Http.Results`中公开。相比之下，之前的实现（列表9.11）使用了从`ControllerBase`继承的同等名称的方法。'
- en: We now need to register this function to actually be called when a client sends
    an HTTP request to the corresponding route. Let’s do that next.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要注册这个函数，以便当客户端向相应的路由发送HTTP请求时实际被调用。让我们接下来这么做。
- en: 9.5.3 Mapping functions to API endpoints
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 将函数映射到API端点
- en: You could think of a Web API as a function that takes an HTTP request as input
    and yields an HTTP response as output. How would such a function work? It would
    look at the request’s route and pass the request to a corresponding function,
    so, a collection of functions, one for each API endpoint. Conceptually, it’s easy
    to conceive of an API as a set of functions. For a long time, however, translating
    this idea into practice using ASP.NET has been impractical because ASP.NET favored
    MVC controllers as the way to create Web APIs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Web API 视为一个函数，它接受 HTTP 请求作为输入，并产生 HTTP 响应作为输出。这样的函数会如何工作？它会查看请求的路由，并将请求传递给相应的函数，因此，一组函数，每个
    API 端点一个。从概念上讲，将 API 视为一组函数很容易理解。然而，长期以来，使用 ASP.NET 将这个想法转化为实践并不实用，因为 ASP.NET
    优先考虑 MVC 控制器作为创建 Web API 的方式。
- en: This has changed completely with .NET 6, which includes *minimal APIs*, a feature
    allowing you to simply map functions to API endpoints. This represents a huge
    shift! For years, we’ve had functional features in C# but were somewhat inhibited
    in their use by OO frameworks, including ASP.NET. Minimal APIs allow you to start
    building in a functional style from the ground up.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 .NET 6 中发生了彻底的变化，它包括 *最小 API*，这是一个允许你简单地将函数映射到 API 端点的特性。这代表了一个巨大的转变！多年来，我们在
    C# 中有函数式特性，但受限于面向对象的框架，包括 ASP.NET。最小 API 允许你从头开始以函数式风格构建。
- en: TIP If you cannot use .NET 6, you can still build Web APIs in a functional style
    by using a package called Feather HTTP. Feather HTTP was the first incarnation
    of what has since become .NET 6 minimal APIs. See [https://github.com/featherhttp/framework](https://github.com/featherhttp/framework)
    for up-to-date instructions on how to reference Feather HTTP.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你不能使用 .NET 6，你仍然可以通过使用名为 Feather HTTP 的包以函数式风格构建 Web API。Feather HTTP 是后来成为
    .NET 6 最小 API 的第一个版本。有关如何引用 Feather HTTP 的最新说明，请参阅 [https://github.com/featherhttp/framework](https://github.com/featherhttp/framework)。
- en: Using minimal APIs, you can configure a Web API with just a few lines of code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最小 API，你可以用几行代码就配置一个 Web API。
- en: Listing 9.15 Configuring a minimal Web API
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 配置最小 Web API
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Creates a web application
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 Web 应用程序
- en: ❷ Configures an endpoint
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置端点
- en: ❸ Starts listening for requests
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 开始监听请求
- en: As you can see, you just create a `WebApplication` and then use `MapGet`, `MapPost`,
    and so on, providing a route and the function that should handle requests on that
    route. This is in line with the micro web frameworks that are so popular in other
    languages.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你只需创建一个 `WebApplication`，然后使用 `MapGet`、`MapPost` 等方法，提供一个路由以及处理该路由请求的函数。这与在其他语言中非常流行的微
    Web 框架相一致。
- en: Top-level statements
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级语句
- en: The previous listing uses *top-level statements*, a feature introduced in C#
    9\. You can have a single file containing loose statements, and this will serve
    as the entry point for your application (previously these statements would have
    been wrapped in `Program.Main`).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表使用了 *顶级语句*，这是 C# 9 中引入的一个特性。你可以有一个包含松散语句的单个文件，这将作为你应用程序的入口点（之前这些语句会被包裹在
    `Program.Main` 中）。
- en: If you’re writing a minimal API, it makes sense to have your API configuration
    in your entry-point file, potentially using top-level statements. In this file,
    you can map all your application’s endpoints to functions defined in other files
    in your project.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写最小 API，将你的 API 配置放在入口点文件中是有意义的，可能使用顶级语句。在这个文件中，你可以将你应用程序的所有端点映射到项目中其他文件中定义的函数。
- en: The following listing shows another, slightly more complex, endpoint. This one
    receives a `Todo` object and saves it to a database.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了另一个稍微复杂一些的端点。这个端点接收一个 `Todo` 对象并将其保存到数据库中。
- en: Listing 9.16 Configuring a POST request
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 配置 POST 请求
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ This dependency must be registered.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此依赖项必须注册。
- en: ❷ The deserialized request body
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 反序列化请求体
- en: ❸ Writes to the DB
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 写入数据库
- en: ❹ Populates the response
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 填充响应
- en: 'As you can see, minimal APIs offer all the perks available in MVC controllers
    (dependency injection, deserialization, handling asynchronous processing, etc.)
    with less ceremony. Similarly, in our BOC application, we can simply plug the
    handler defined in listing 9.14 into the `WebApplication`. The application’s entry
    point will then look like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最小 API 提供了 MVC 控制器中可用的所有优点（依赖注入、反序列化、处理异步处理等），但形式更为简洁。同样，在我们的 BOC 应用程序中，我们可以简单地将列表
    9.14 中定义的处理程序插入到 `WebApplication` 中。然后，应用程序的入口点将看起来像这样：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All that is left to do is to implement `ConfigureSaveTransferHandler`, where
    we set up the dependencies that will be used in our `MakeTransfer` handler. The
    following listing shows this setup.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是实现`ConfigureSaveTransferHandler`，在那里我们设置将在我们的`MakeTransfer`处理程序中使用的依赖项。以下列表显示了此设置。
- en: Listing 9.17 Wiring up the functions needed for a use case
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17 为用例连接所需函数
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Sets up persistence
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置持久性
- en: ❷ Sets up validation
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置验证
- en: ❸ Combines the two into the main workflow
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将两个合并到主工作流程中
- en: 'Here we wire up the various pieces: we give our general `TryExecute` all the
    parameters it needs to be able to save a `MakeTransfer` to the DB when required;
    we give `DateNotPast` a clock; and, finally, we give both resulting functions
    to the main function in our logic (listing 9.14).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们连接了各个部分：我们给我们的通用`TryExecute`提供所有它需要的参数，以便在需要时将`MakeTransfer`保存到数据库中；我们给`DateNotPast`一个时钟；最后，我们将这两个结果函数都传递给我们的逻辑中的主函数（列表9.14）。
- en: 'That’s it! You can see how we were able to build a whole use case using just
    functions: no interfaces, no repositories—just functions (a function for saving
    data, a function for validating, a function for combining both in the handling
    of a request). When you look at it, it’s actually pretty clean and simple.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！你可以看到我们如何仅使用函数构建整个用例：没有接口，没有存储库——只是函数（一个用于保存数据的函数，一个用于验证的函数，一个用于在处理请求时结合两者的函数）。当你看的时候，它实际上非常干净和简单。
- en: We still simplistically only apply one validation rule, but we’ll cater for
    several rules in section 9.6\. First, let’s discuss how the OO and the functional
    approach stack up in this example.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然只是简单地应用一条验证规则，但在第9.6节中，我们将为几个规则提供服务。首先，让我们讨论一下在这个例子中OO和功能方法是如何排列的。
- en: 9.5.4 Comparing the two approaches
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.4 比较两种方法
- en: 'In the functional approach I just demonstrated, all dependencies are injected
    as functions. Notice that with this approach, you still have the benefits associated
    with dependency inversion:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我刚刚展示的功能方法中，所有依赖都作为函数注入。请注意，使用这种方法，你仍然享有与依赖倒置相关的优势：
- en: '*Decoupling*—A function knows nothing about the implementation details of the
    functions it consumes.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解耦*—一个函数对其所消费的函数的实现细节一无所知。'
- en: '*Testability*—When testing any of these functions, you can simply pass it functions
    that return a predictable result.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可测试性*—当测试这些函数中的任何一个时，你可以简单地传递给它返回可预测结果的函数。'
- en: 'You also mitigate some of the problems associated with dependency inversion
    in its OOP version:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你也减轻了与其面向对象版本中依赖倒置相关的一些问题：
- en: You don’t need to define any interfaces.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要定义任何接口。
- en: This makes testing easier because you don’t need to set up fakes.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得测试更容易，因为你不需要设置模拟对象。
- en: For example, the following listing shows a test for the use case we developed
    in this section. Note that when dependencies are functions, unit tests can be
    written without fakes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下列表展示了本节中开发的用例的测试。注意，当依赖是函数时，可以编写不使用模拟对象的单元测试。
- en: Listing 9.18 A unit test without fakes
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18 无模拟对象的单元测试
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Injects functions that return a predictable result
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注入返回可预测结果的函数
- en: 'So far, the functional approach seems preferable. There’s also another difference
    to point out. In the OO implementation (listing 9.10), the controller depends
    on an `IRepository` interface defined as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，功能方法似乎更可取。还有另一个差异需要指出。在OO实现（列表9.10）中，控制器依赖于以下定义的`IRepository`接口：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'But notice that the controller only uses the `Save` method. This violates the
    *interface segregation principle* (ISP), which states that clients shouldn’t depend
    on methods they don’t use. The idea is that just because you’re trusting your
    15-year-old child with your house keys, that doesn’t mean they should have your
    car keys as well. The `IRepository` interface should actually be broken up into
    two single-method interfaces, and the controller should depend on a smaller interface
    like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，控制器只使用了`Save`方法。这违反了*接口隔离原则*（ISP），该原则指出，客户端不应该依赖于它们不使用的方法。想法是，仅仅因为你在信任你的15岁孩子保管你的房子钥匙，并不意味着他们应该有你的车钥匙。`IRepository`接口实际上应该被拆分为两个单方法接口，控制器应该依赖于一个更小的接口，如下所示：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This further increases the number of interfaces in the application. If you push
    the ISP hard enough, you’ll end up with a prevalence of single-method interfaces
    that convey the same information as a function signature, ultimately making it
    simpler to just inject functions as in the functional approach.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这进一步增加了应用程序中的接口数量。如果你足够坚持 ISP（接口隔离原则），最终你会得到大量只包含一个方法的接口，这些接口传达的信息与函数签名相同，最终使得仅仅注入函数的方法更简单。
- en: (Of course, if the controller did require both a function to read and to write,
    then in the functional style, we’d have to inject two functions, increasing the
    number of dependencies. As usual, the functional style is more explicit.)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，如果控制器确实需要读取和写入两个函数，那么在函数式风格中，我们就必须注入两个函数，从而增加依赖项的数量。通常，函数式风格更为明确。）
- en: To complete the implementation of this use case, we need to cater for not one,
    but many validation rules. In OOP, you could use a composite validator that implements
    `IValidator` and internally uses a list of specific `IValidator`s. But we want
    to do this in a functional style and have a `Validator` function that internally
    combines the rules of many `Validator`s. We’ll look at this next, but in order
    to do so, we must first take a step back and look at a general pattern for reducing
    a list of values to a single value.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个用例的实现，我们需要考虑的不是一条，而是多条验证规则。在面向对象编程（OOP）中，你可以使用一个实现 `IValidator` 的复合验证器，并在内部使用一系列特定的
    `IValidator`。但我们要以函数式风格来完成这个任务，并有一个 `Validator` 函数，它内部组合多个 `Validator` 的规则。我们将在下一节中探讨这个问题，但为了做到这一点，我们必须首先退一步，看看将值列表缩减为一个单一值的一般模式。
- en: 9.6 Reducing a list to a single value
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 将列表缩减为一个单一值
- en: 'Reducing a list of values into a single value is a common operation, but one
    we haven’t discussed so far. In FP-speak, this operation is called *fold* or *reduce*,
    and these are the names you’ll encounter in most languages or libraries and in
    the FP literature. Characteristically, LINQ uses a different name: `Aggregate`.
    If you’re already familiar with `Aggregate`, you can skip the next subsection.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将值列表缩减为一个单一值是一个常见的操作，但我们之前还没有讨论过。在函数式编程（FP）的术语中，这个操作被称为 *折叠* 或 *缩减*，这些是在大多数语言或库以及
    FP 文献中会遇到的名字。典型地，LINQ 使用不同的名字：`Aggregate`。如果你已经熟悉 `Aggregate`，可以跳过下一个小节。
- en: 9.6.1 LINQ’s Aggregate method
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 LINQ 的 Aggregate 方法
- en: Note that most of the functions we’ve used so far with `IEnumerable` also return
    an `IEnumerable`. For example, `Map` takes a list of *n* things and returns another
    list of *n* things, possibly of a different type. `Where` and `Bind` also stay
    within the abstraction; they take an `IEnumerable` and return an `IEnumerable`,
    although the quantity and the type of the elements may change.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们之前使用的大多数与 `IEnumerable` 相关的函数也返回一个 `IEnumerable`。例如，`Map` 接受一个包含 *n* 个项目的列表，并返回另一个包含
    *n* 个项目的列表，可能类型不同。`Where` 和 `Bind` 也保持在抽象内部；它们接受一个 `IEnumerable` 并返回一个 `IEnumerable`，尽管元素的数量和类型可能会改变。
- en: '`Aggregate` is different from these functions in that it takes a list of *n*
    things and returns exactly one thing (just like the SQL aggregate functions `COUNT`,
    `SUM`, and `AVERAGE`, which you may be familiar with).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregate` 与这些函数不同，因为它接受一个包含 *n* 个项目的列表，并返回恰好一个项目（就像你可能熟悉的 SQL 聚合函数 `COUNT`、`SUM`
    和 `AVERAGE` 一样）。'
- en: Given an `IEnumerable<T>`, `Aggregate` takes an initial value, called an *accumulator*
    (or *seed*), and a *reducer* function (a binary function accepting the accumulator
    and an element in the list and returning the new value for the accumulator). `Aggregate`
    then traverses the list, applying the function to the current value of the accumulator
    and each element in the list. The signature for `Aggregate` is
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 `IEnumerable<T>`，`Aggregate` 接受一个初始值，称为累加器（或种子），以及一个累加函数（一个接受累加器和列表中的元素并返回累加器新值的二元函数）。然后
    `Aggregate` 遍历列表，将函数应用于累加器的当前值和列表中的每个元素。`Aggregate` 的签名是
- en: '[PRE54]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For example, you could have a list of lemons and aggregate it into a glass of
    lemon juice. The accumulator would be an empty glass, and this is what you get
    back if the list of lemons is empty. The reducer function takes a glass and a
    single lemon and returns a glass with the lemon squeezed into it. Given these
    arguments, `Aggregate` traverses the list, squeezing each lemon into the glass,
    finally returning the glass with juice from all the lemons.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有一个柠檬的列表，并将其汇总成一杯柠檬汁。累加器是一个空杯子，如果柠檬列表为空，这就是你得到的结果。累加函数接受一个杯子和一个单独的柠檬，并返回一个挤过柠檬的杯子。给定这些参数，`Aggregate`
    遍历列表，将每个柠檬挤入杯子中，最后返回包含所有柠檬汁的杯子。
- en: 'Figure 9.4 shows it graphically. If the list is empty, `Aggregate` returns
    the given accumulator, *acc*. If it contains one item, *t*[0], it returns the
    result of applying *f* to *acc* and *t*[0]; let’s call this value *acc*[1]. If
    it contains more items, it will compute *acc*[1] and then apply *f* to *acc*[1]
    and *t*[1] to obtain *acc*[2], and so on, finally returning *acc[N]* as a result:
    *acc* can be seen as an initial value on top of which all values in the list are
    applied using the given function.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 以图形方式展示了它。如果列表为空，`Aggregate` 返回给定的累加器，*acc*。如果它包含一个项目，*t*[0]，它返回将 *f*
    应用到 *acc* 和 *t*[0] 的结果；让我们称这个值为 *acc*[1]。如果它包含更多项目，它将计算 *acc*[1]，然后应用 *f* 到 *acc*[1]
    和 *t*[1] 以获得 *acc*[2]，依此类推，最终返回 *acc[N]* 作为结果：*acc* 可以看作是一个初始值，在它之上应用列表中的所有值使用给定的函数。
- en: '![](Images/CH09_F04_Buonanno2.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F04_Buonanno2.png)'
- en: Figure 9.4 Reducing a list to a single value with `Aggregate`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 使用 `Aggregate` 将列表缩减为一个单一值
- en: The `Sum` function (available in its own right in LINQ) is a special case of
    `Aggregate`. What’s the sum of all the numbers in an empty list? Naturally, 0!
    That’s our accumulator value. The binary function is just addition, so we can
    express `Sum` as the next listing shows.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sum` 函数（在 LINQ 中可以独立使用）是 `Aggregate` 的一个特例。一个空列表中所有数字的总和是多少？当然是 0！这就是我们的累加器值。二进制函数仅仅是加法，所以我们可以像下面列表所示那样表达
    `Sum`。'
- en: Listing 9.19 `Sum` as a special case of `Aggregate`
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 `Sum` 作为 `Aggregate` 的特例
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice that this expands to the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这会展开成以下内容：
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: More generally, `ts.Aggregate(acc, f)` expands to
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，`ts.Aggregate(acc, f)` 展开成
- en: '[PRE57]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`Count` can also be seen as a special case of `Aggregate`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count` 也可以看作是 `Aggregate` 的一个特例：'
- en: '[PRE58]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice that the type of the accumulator isn’t necessarily the type of the list
    items. For example, let’s say that we have a list of things, and we want to add
    them to a tree. The type in our list would be, say, `T`, and the type of the accumulator
    would be `Tree<T>`. The following listing shows how we could start with an empty
    tree as an accumulator and add each item as we traverse the list.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，累加器的类型不一定是列表项的类型。例如，假设我们有一个项目列表，我们想要将它们添加到一个树中。我们列表中的类型可能是 `T`，而累加器的类型将是
    `Tree<T>`。以下列表显示了我们可以从一个空的树作为累加器开始，并在遍历列表时添加每个项目。
- en: Listing 9.20 Using `Aggregate` to create a tree of all items in a list
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.20 使用 `Aggregate` 创建列表中所有项目的树
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this example, I’m assuming that `tree.Insert(i)` returns a tree with the
    newly inserted value.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我假设 `tree.Insert(i)` 返回一个包含新插入值的树。
- en: '`Aggregate` is such a powerful method that it’s possible to implement `Map`,
    `Where`, and `Bind` in terms of `Aggregate` (something I suggest as an exercise).
    There’s also a less general overload that doesn’t take an accumulator argument
    but uses the first element of the list as accumulator. The signature for this
    overload is'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregate` 是一个如此强大的方法，以至于我们可以用 `Aggregate` 来实现 `Map`、`Where` 和 `Bind`（我建议作为练习来做）。还有一个不那么通用的重载版本，它不接收累加器参数，而是使用列表的第一个元素作为累加器。这个重载版本的签名是'
- en: '[PRE60]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When using this overload, the result type is the same as the type of the elements
    in the list, and the list can’t be empty.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这个重载版本时，结果类型与列表中元素的类型相同，并且列表不能为空。
- en: 9.6.2 Aggregating validation results
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.2 聚合验证结果
- en: Now that you know how to reduce a list of values to a single value, let’s apply
    this knowledge and see how we can reduce a list of validators to a single validator.
    To do this, we’ll need to implement a function with type
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何将值列表缩减为一个单一值，让我们应用这个知识，看看我们如何将验证器列表缩减为一个单一验证器。为了做到这一点，我们需要实现一个具有以下类型的函数
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Notice that because `Validator` is itself a function type, the preceding type
    expands to this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为 `Validator` 本身就是一个函数类型，所以前面的类型展开成这样：
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'First of all, we need to decide how we want the combined validation to work:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定我们希望组合验证如何工作：
- en: '*Fail fast*—If validation should be optimized for efficiency, the combined
    validation should fail as soon as one validator fails, thus minimizing the use
    of resources. This is a good approach if you’re validating a request made programmatically
    from an application.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速失败*——如果验证应该优化效率，则组合验证应该在任何一个验证器失败时立即失败，从而最小化资源的使用。如果你从应用程序中以编程方式验证请求，这是一个很好的方法。'
- en: '*Harvest errors*—You may want to identify all the rules that have been violated
    so that they can be fixed prior to making another request. This is a better approach
    when validating a request made by a user through a form.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*收集错误*——您可能希望识别所有被违反的规则，以便在再次请求之前进行修复。当通过表单验证用户请求时，这是一个更好的方法。'
- en: 'The fail-fast strategy is easier to implement: every validator returns a `Validation`,
    and `Validation` exposes a `Bind` function that only applies the bound function
    if the state is `Valid` (just like `Option` and `Either`), so we can use `Aggregate`
    to traverse the list of validators and `Bind` each validator to the running result.
    The following listing shows this approach.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 快速失败策略更容易实现：每个验证器都返回一个 `Validation`，`Validation` 暴露了一个 `Bind` 函数，该函数仅在状态为 `Valid`
    时应用绑定函数（就像 `Option` 和 `Either` 一样），因此我们可以使用 `Aggregate` 遍历验证器列表并将每个验证器绑定到运行结果。以下列表显示了这种方法。
- en: Listing 9.21 Using `Aggregate` to apply all validators in a list
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.21 使用 `Aggregate` 应用列表中的所有验证器
- en: '[PRE63]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Notice that the `FailFast` function takes a list of `Validator`s and returns
    a `Validator`: a function that expects an object of type `T` to validate. On receiving
    the valid `t`, it traverses the list of validators using `Valid(t)` as accumulator
    (if the list of validators is empty, then `t` is valid) and applies each validator
    in the list to the accumulator with `Bind`. Conceptually, the call to `Aggregate`
    expands as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`FailFast` 函数接受一个 `Validator` 列表并返回一个 `Validator`：一个期望类型为 `T` 的对象进行验证的函数。在接收到有效的
    `t` 后，它使用 `Valid(t)` 作为累加器遍历验证器列表（如果验证器列表为空，则 `t` 是有效的）并将列表中的每个验证器应用到累加器上。从概念上讲，对
    `Aggregate` 的调用如下所示：
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Because of how `Bind` is defined for `Validation`, when a validator fails, the
    subsequent validators will be skipped, and the whole validation fails.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Validation`中对`Bind`的定义，当验证器失败时，后续的验证器将被跳过，整个验证失败。
- en: Not all validation is equally expensive. For instance, validating that the BIC
    code is well-formed with a regular expression (as shown in listing 8.7) is cheap.
    Suppose that you also need to ensure that the given BIC code identifies an existing
    bank branch. This might involve a DB lookup or a remote call to a service with
    a list of valid codes, which is clearly more expensive.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有验证的成本都相同。例如，使用正则表达式验证BIC代码是否格式正确（如列表 8.7 所示）是便宜的。假设您还需要确保给定的BIC代码识别一个现有的银行分支。这可能涉及数据库查找或远程调用一个包含有效代码列表的服务，这显然更昂贵。
- en: To ensure that overall validation is efficient, you need to order the list of
    validators accordingly. In this case, you’d need to apply the (cheap) regular
    expression validation first and only then the (expensive) remote lookup.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保整体验证效率，您需要相应地排序验证者列表。在这种情况下，您需要首先应用（便宜）的正则表达式验证，然后才是（昂贵）的远程查找。
- en: 9.6.3 Harvesting validation errors
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.3 收集验证错误
- en: The opposite approach is to prioritize *completeness*, including the details
    of *all* failing validations. In this case, you don’t want failure to prevent
    further computation; on the contrary, you want to ensure that all the validators
    run and that all errors, if any, are harvested. This is useful if, say, you’re
    validating a form with lots of fields, and you want the user to see everything
    they need to fix in order to make a valid submission. The following listing shows
    how we could rewrite the method that combines the different validators.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的方法是优先考虑*完整性*，包括所有失败的验证的细节。在这种情况下，您不希望失败阻止进一步的计算；相反，您希望确保所有验证器都运行，并且如果有的话，所有错误都被收集。如果您正在验证一个包含许多字段的表单，并且希望用户看到他们需要修复的所有内容以便进行有效提交，这很有用。以下列表显示了我们可以如何重写结合不同验证器的函数。
- en: Collecting errors from all validators that fail
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 收集所有失败验证器的错误
- en: '[PRE65]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Runs all validators independently
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 独立运行所有验证器
- en: ❷ Collects validation errors
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 收集验证错误
- en: ❸ Disregards passed validation
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 忽略通过验证
- en: ❹ If there were no errors, the overall validation passes.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果没有错误，整体验证通过。
- en: Here, instead of using `Aggregate`, we use `Map` to map the list of validators
    to the results of running the validators on the object to be validated. This ensures
    that all validators are called independently, and we end up with an `IEnumerable`
    of `Validation`s.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是使用 `Aggregate`，而是使用 `Map` 将验证器列表映射到对要验证的对象运行验证器的结果。这确保了所有验证器都是独立调用的，我们最终得到一个
    `IEnumerable` 的 `Validation`。
- en: We’re then interested in harvesting all the errors. To do this, we use `Option`.
    We map `Invalid`s to a `Some` wrapping the errors and `Valid`s to `None`. Remember
    from chapter 6 that `Bind` can be used to filter `None`s from a list of `Option`s,
    and that’s what we’re doing here to obtain a list of all errors. Because each
    `Invalid` contains a list of errors, `errors` is actually a list of lists. In
    case of failure, we need to flatten it into a one-dimensional list and use it
    to populate an `Invalid`. If there were no errors, we return the object being
    validated, wrapped in a `Valid`.[⁴](#pgfId-1120183)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们感兴趣的是收集所有错误。为此，我们使用`Option`。将`Invalid`映射到包含错误的`Some`包装，将`Valid`映射到`None`。记住，从第6章中，`Bind`可以用来从`Option`列表中过滤`None`，这正是我们在下面所做的事情，以获得所有错误的列表。因为每个`Invalid`都包含一个错误列表，所以`errors`实际上是一个列表的列表。在失败的情况下，我们需要将其展平成一个一维列表，并使用它来填充一个`Invalid`。如果没有错误，我们返回正在验证的对象，并用`Valid`包装。[⁴](#pgfId-1120183)
- en: Exercises
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Partial application with a binary arithmetic function:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二元算术函数的偏应用：
- en: Write a function, `Remainder`, that calculates the remainder of integer division
    (and works for negative input values!). Notice how the expected order of parameters
    isn’t the one that’s most likely to be required by partial application (you’re
    more likely to partially apply the divisor).
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为`Remainder`的函数，该函数计算整数除法的余数（适用于负输入值！）。注意参数的预期顺序并不是偏应用最可能需要的顺序（你更有可能偏应用除数）。
- en: Write an `ApplyR` function that gives the rightmost parameter to a given binary
    function. (Try to do so without looking at the implementation for `Apply`.) Write
    the signature of `ApplyR` in arrow notation, both in curried and non-curried forms.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个`ApplyR`函数，该函数将给定二进制函数的最右侧参数传递给它。（尽量在不查看`Apply`实现的情况下完成。）以箭头符号表示`ApplyR`的签名，包括柯里化和非柯里化形式。
- en: Use `ApplyR` to create a function that returns the remainder of dividing any
    number by 5.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ApplyR`创建一个函数，该函数返回任何数字除以5的余数。
- en: Write an overload of `ApplyR` that gives the rightmost argument to a ternary
    function.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个`ApplyR`的重载版本，将三元函数的最右侧参数传递给它。
- en: 'Ternary functions:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三元函数：
- en: 'Define a `PhoneNumber` class with three fields: number type (home, mobile .
    . .), country code (''it'', ''uk'' . . .), and number. `CountryCode` should be
    a custom type with implicit conversion to and from `string`.'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个包含三个字段的`PhoneNumber`类：号码类型（家庭、手机等）、国家代码（'it'、'uk'等）和号码。`CountryCode`应该是一个自定义类型，具有到和从`string`的隐式转换。
- en: Define a ternary function that creates a new number, given values for these
    fields. What’s the signature of your factory function?
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个三元函数，根据这些字段的值创建一个新的数字。你的工厂函数的签名是什么？
- en: Use partial application to create a binary function that creates a UK number
    and then again to create a unary function that creates a UK mobile.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用偏应用创建一个二元函数，该函数创建一个英国号码，然后再创建一个一元函数，该函数创建一个英国手机号码。
- en: 'Functions everywhere: you may still have a feeling that objects are ultimately
    more powerful than functions. Surely a logger object should expose methods for
    related operations such as `Debug`, `Info`, and `Error`? To see that this is not
    necessarily so, challenge yourself to write a simple logging mechanism (logging
    to the console is fine) that doesn’t require any classes or structs. You should
    still be able to inject a `Log` value into a consumer class or function, exposing
    the operations `Debug`, `Info`, and `Error`, like so:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到处都是函数：你可能仍然觉得对象最终比函数更强大。当然，一个日志对象应该公开`Debug`、`Info`和`Error`等相关操作的方法？为了证明这并不一定如此，挑战自己编写一个简单的日志机制（将日志记录到控制台即可），该机制不需要任何类或结构体。你仍然应该能够将一个`Log`值注入到消费者类或函数中，公开`Debug`、`Info`和`Error`操作，如下所示：
- en: '[PRE66]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Open exercise: in your day-to-day coding, start paying more attention to the
    signatures of the functions you write and consume. Does the order of arguments
    make sense; do they go from general to specific? Is there some argument that you
    always invoke with the same value so that you could partially apply it? Do you
    sometimes write similar variations of the same code, and could these be generalized
    into a parameterized function?'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开放练习：在你的日常编码中，开始更加关注你编写和使用的函数的签名。参数的顺序是否合理；它们是否从一般到具体？是否有某个参数你总是用相同的值调用，以便可以偏应用它？你是否有时编写相同代码的相似变体，并且可以将这些代码泛化成参数化函数？
- en: Implement `Map`, `Where`, and `Bind` for `IEnumerable` in terms of `Aggregate`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`Aggregate`为依据实现`IEnumerable`的`Map`、`Where`和`Bind`。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Partial application means giving a function its arguments piecemeal, effectively
    creating a more specialized function with each argument given.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用意味着逐步提供函数的参数，实际上是在每次提供参数时创建一个更专业的函数。
- en: Currying means changing the signature of a function so that it will take its
    arguments one at a time.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化意味着改变函数的签名，使其一次接受一个参数。
- en: Partial application enables you to write highly general functions by parameterizing
    their behavior and then supplying arguments to obtain increasingly specialized
    functions.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用允许你通过参数化函数的行为，然后提供参数以获得越来越专业的函数，从而编写高度通用的函数。
- en: 'The order of arguments matters: you give the leftmost argument first so that
    a function should declare its arguments from general to specific.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的顺序很重要：你首先给出最左边的参数，这样函数应该从一般到具体声明其参数。
- en: When working with multi-argument functions in C#, method resolution can be problematic
    and lead to syntactic overhead. This can be overcome by relying on `Func`s rather
    than on methods.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在C#中处理多参数函数时，方法解析可能会出现问题，并导致语法开销。这可以通过依赖于`Func`而不是方法来克服。
- en: You can inject the dependencies required by your functions by declaring them
    as arguments. This allows you to compose your application entirely of functions
    without compromising on the separation of concerns, decoupling, and testability.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将它们声明为参数来注入函数所需的依赖项。这允许你完全由函数组成你的应用程序，而不会牺牲关注点的分离、解耦和可测试性。
- en: '* * *'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ Dapper is a lightweight ORM that has gained a lot of popularity for being
    fast and simple to use; we used it first in chapter 2\. It’s available on GitHub
    at [https://github.com/StackExchange/dapper-dot-net](https://github.com/StackExchange/dapper-dot-net),
    and you can find more documentation there.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ Dapper是一个轻量级的ORM，因其速度快、使用简单而受到很多欢迎；我们首次在第2章中使用它。你可以在GitHub上找到它，网址为[https://github.com/StackExchange/dapper-dot-net](https://github.com/StackExchange/dapper-dot-net)，你可以在那里找到更多文档。
- en: '² We discussed adapter functions in chapter 2: if you don’t like the signature
    of a function, you can change it by defining a function that calls another and
    exposes an interface better suited to your needs.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ² 我们在第2章中讨论了适配器函数：如果你不喜欢函数的签名，你可以通过定义一个调用另一个函数并公开更适合你需求的接口的函数来改变它。
- en: '³ Note that there’s a difference between dependency injection and dependency
    inversion. *Dependency injection* is far more general: it means you’re injecting
    something that a class, method, or function requires. For example, if you inject
    a concrete implementation, a primitive value, or a configuration object, you’re
    using dependency injection but not dependency inversion. *Dependency inversion*
    relies on dependency injection, but the opposite is not true.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 注意，依赖注入和依赖反转之间有一个区别。*依赖注入*要通用得多：这意味着你正在注入一个类、方法或函数所需的某物。例如，如果你注入一个具体实现、原始值或配置对象，你正在使用依赖注入，但不是依赖反转。*依赖反转*依赖于依赖注入，但反之则不然。
- en: ⁴ There’s actually a simpler way to accomplish this using applicatives and traverse,
    tools we haven’t covered yet. You’ll see this in chapter 15.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 实际上，使用我们尚未介绍的应用程序和遍历工具，有更简单的方法来完成这项任务。你将在第15章中看到这一点。
