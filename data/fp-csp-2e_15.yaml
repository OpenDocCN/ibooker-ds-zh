- en: 12 A short introduction to functional data structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 函数式数据结构简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Functional data structures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式数据结构
- en: Linked lists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: Binary trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树
- en: In chapter 11, you saw how to create immutable objects. Particularly, section
    11.1 showed the pitfalls of state mutation when concurrency is involved. These
    pitfalls become even more evident when dealing with collections. Because it takes
    longer to process a large collection than to update a single object, there are
    greater chances of a race conditions occurring (we saw an example of this in section
    1.1.3).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章中，你看到了如何创建不可变对象。特别是，第11.1节展示了在涉及并发时状态变更的陷阱。当处理集合时，这些陷阱变得更加明显。因为处理大型集合比更新单个对象需要更长的时间，所以发生竞争条件的机会更大（我们在第1.1.3节中看到了这个例子）。
- en: 'Now that you know about immutable objects, let’s look at some of the principles
    behind the design of immutable data structures. Note that the terms *functional*
    data structures and *immutable* data structures are used interchangeably in the
    literature.[¹](#pgfId-1145742) You’ll see that the principles are the same: after
    all, objects are just ad hoc data structures.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了不可变对象，让我们来看看不可变数据结构设计背后的某些原则。请注意，文献中使用的术语*函数式*数据结构和*不可变*数据结构是可以互换的。[¹](#pgfId-1145742)
    你会发现原则是相同的：毕竟，对象只是临时的数据结构。
- en: If you commit to only working with immutable data, all data structures should
    also be immutable. For example, you should never add an element to a list by changing
    its structure, but rather create a new list with the desired changes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只承诺使用不可变数据，所有数据结构也应该是不可变的。例如，你不应该通过改变其结构来向列表中添加元素，而应该创建一个新的列表，包含所需的变化。
- en: 'This may initially cause you to raise your eyebrows: “To add an item to a list,
    I need to copy all existing elements into a new list along with the extra item?
    How inefficient is that?”'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能最初会让你皱起眉头：“为了向列表中添加一个项目，我需要将所有现有元素复制到一个新的列表中，再加上额外的项目？这是多么低效啊？”
- en: To give you an idea of why this isn’t necessarily inefficient, let’s look at
    some simple functional data structures. You’ll see that adding a new element to
    a collection does yield a new collection, but this doesn’t involve copying every
    item in the original collection.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解这并不一定是不高效的，让我们看看一些简单的函数式数据结构。你会发现向集合中添加新元素确实会产生一个新的集合，但这并不涉及复制原始集合中的每个项目。
- en: NOTE The implementations shown in this chapter are naive. They’re helpful in
    understanding the basic concepts, but they’re not for use in production. For real-world
    applications, use a proven library such as `System.Collections.Immutable`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中展示的实现是原始的。它们有助于理解基本概念，但不适用于生产环境。对于实际应用，请使用经过验证的库，如`System.Collections.Immutable`。
- en: 12.1 The classic functional linked list
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 经典的函数式链表
- en: 'We’ll start with the classic functional linked list. While deceptively simple,
    this is the basic list you’ll find in the core library of most functional languages.
    Symbolically, we can describe it as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从经典的函数式链表开始。虽然表面上很简单，但这通常是大多数函数式语言核心库中的基本列表。我们可以用以下方式符号化地描述它：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In other words, a `List` of `T`''s can be one of two things:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个`T`的`List`可以是以下两种情况之一：
- en: '`Empty`—A special value representing the empty list'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Empty`——表示空列表的特殊值'
- en: '`Cons`—A non-empty list *cons*-tructed from two values:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cons`——由两个值*cons*-tructed的非空列表：'
- en: A single `T`, called the *head*, representing the first element in the list
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单独的`T`，称为*头*，表示列表中的第一个元素
- en: Another `List` of `T`'s, called the *tail*, representing all the other elements
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个名为*尾*的`T`列表，表示所有其他元素
- en: 'The tail can, in turn, be `Empty` or a `Cons` and so on. Thus, `List` is an
    example of a *recursive type*: a type that’s defined in terms of itself. This
    is how with just two cases we can cater for lists of any length. For example,
    the structure of a list containing `["a",` `"b", "c"]` is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尾可以是`Empty`或`Cons`等。因此，`List`是一个*递归类型*的例子：一个用自身定义的类型。这就是我们如何只用两种情况就能应对任何长度的列表。例如，包含`["a",`
    `"b", "c"]`的列表的结构如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](Images/CH12_F01_Buonanno2.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F01_Buonanno2.png)'
- en: Figure 12.1 A linked list containing the values `["a", "b", "c"]`
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 包含值`["a", "b", "c"]`的链表
- en: It can be represented graphically as in figure 12.1, where each `Cons` is represented
    as a box with a value (the head) and a pointer to the rest of the list (the tail).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用图12.1中的图形表示，其中每个`Cons`用一个包含值（头）和指向列表其余部分的指针（尾）的框表示。
- en: 'Let’s look at how we can implement this in C#. These implementations are included
    in the `LaYumba.Functional.Data` project in the source repository. Here are the
    types I use to model a list:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在 C# 中实现这一点。这些实现包含在源存储库中的 `LaYumba.Functional.Data` 项目中。以下是我用来模拟列表的类型：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that only the `List` type is public. To interact with a `List`, I’ve defined
    a `Match` method that provides nice syntax for pattern matching:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有 `List` 类型是公开的。为了与 `List` 交互，我定义了一个 `Match` 方法，它提供了用于模式匹配的优美语法：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is all similar to the idealized implementation for `Option` I showed in
    section 5.3: `Empty` has no members (like `None`), while `Cons` stores the list’s
    elements. The `Match` method allows you to handle both cases, taking away some
    of the syntactical noise of the `switch` expression.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我在第 5.3 节中展示的 `Option` 理想化实现非常相似：`Empty` 没有成员（就像 `None` 一样），而 `Cons` 存储列表的元素。`Match`
    方法允许你处理这两种情况，从而减少了 `switch` 表达式的语法噪音。
- en: It turns out that you can define all commonly used list operations in terms
    of `Match`. For example, if you want to know the length of the list (as the following
    listing demonstrates), you’d use `Match`—the empty list obviously has length 0,
    whereas the non-empty list has the length of its tail plus 1.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，你可以用 `Match` 来定义所有常用的列表操作。例如，如果你想知道列表的长度（如下面的列表所示），你会使用 `Match`——空列表显然长度为
    0，而非空列表的长度是其尾部长度加 1。
- en: Listing 12.1 Calculating the length of a list
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.1 计算列表的长度
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The first function given to `Match` handles the case of an empty list.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 给 `Match` 的第一个函数处理空列表的情况。
- en: ❷ The second function is given the head and tail of the list if it’s not empty.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果列表不为空，第二个函数将获得列表的头部和尾部。
- en: Notice how in the first function given to `Match`, the empty braces graphically
    suggest an empty list. In the second function, the arguments include the `Cons`'s
    head and tail. In most cases, here we’ll process the head and then rely on the
    list’s recursive definition to recursively process the tail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在第一个函数给 `Match` 的函数中，空括号图形上暗示了一个空列表。在第二个函数中，参数包括 `Cons` 的头部和尾部。在大多数情况下，我们在这里会处理头部，然后依赖于列表的递归定义来递归处理尾部。
- en: Finally, I’ve provided a few functions to create empty and populated lists.
    Creating the whole structure explicitly with `new Cons("a",` `new` `Cons("b",`
    `...` would be tedious, so I’ve defined a few functions for initializing an empty
    or populated list. These are shown in the following listing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我提供了一些函数来创建空列表和填充列表。使用 `new Cons("a", new Cons("b", ...)` 明确创建整个结构将非常繁琐，所以我定义了一些用于初始化空列表或填充列表的函数。这些函数如下所示。
- en: Listing 12.2 Functions for initializing a list
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2 初始化列表的函数
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Creates an empty list
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空列表
- en: ❷ Creates a non-empty list from a head and tail
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从头部和尾部创建非空列表
- en: ❸ Convenience method for creating a list with a few hard-coded elements
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 用于创建具有几个硬编码元素的列表的便利方法
- en: The first two functions simply call the constructors for `Empty` and `Cons`,
    respectively. The following function in the listing is a convenience list initializer.
    The `params` keyword already collects all the arguments into an array, so we just
    need to translate the array into a suitable combination of `Empty` and `Cons`.
    That’s done with `Aggregate`, using `Empty` as the accumulator, and creating a
    `Cons` in the reducer function. Because `List` prepends the item to the list,
    we must reverse the parameters list first.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数只是分别调用 `Empty` 和 `Cons` 的构造函数。列表中的下一个函数是一个便利的列表初始化器。`params` 关键字已经将所有参数收集到一个数组中，所以我们只需要将数组转换成
    `Empty` 和 `Cons` 的合适组合。这是通过 `Aggregate` 实现的，使用 `Empty` 作为累加器，并在减少函数中创建一个 `Cons`。因为
    `List` 将项目添加到列表的开头，所以我们必须首先反转参数列表。
- en: 'Now that you’ve seen all the building blocks, let’s play with `List` in the
    REPL. You’ll need to import the `LaYumba.Functional.Data` assembly:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了所有构建块，让我们在 REPL 中玩一玩 `List`。你需要导入 `LaYumba.Functional.Data` 集合：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are some examples of how you can create lists in the REPL:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例，说明你如何在 REPL 中创建列表：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code demonstrates how you can create a list, empty or prepopulated, and
    how you can create a `Cons` by adding a single item to an existing list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了如何创建一个列表，无论是空的还是预先填充的，以及如何通过向现有列表添加单个项目来创建一个 `Cons`。
- en: 12.1.1 Common list operations
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 常见列表操作
- en: 'Let’s now look at how we can perform some common operations with this list,
    like those we’ve become accustomed to with `IEnumerable`. For example, here’s
    `Map`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何使用这个列表执行一些常见的操作，就像我们习惯于使用 `IEnumerable` 一样。例如，这是 `Map`：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Map` takes a list and a function to be mapped onto the list. It then uses
    pattern matching. If the list is empty, it returns an empty list; otherwise, it
    applies the function to the head and recursively maps the function onto the tail
    and returns the `Cons` of these two.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`接受一个列表和一个要映射到列表上的函数。然后它使用模式匹配。如果列表为空，它返回一个空列表；否则，它将函数应用于头部并递归地将函数映射到尾部，然后返回这两个的`Cons`。'
- en: Here you see a common naming convention; when a `Cons` is deconstructed, its
    elements are often called `t` (singular, for the head) and `ts` (plural, for the
    tail), given that they are all of type `T`. (You’ll see `x` and `xs` in languages
    where the generic type does not need to be named.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一个常见的命名约定；当一个`Cons`被解构时，它的元素通常被称为`t`（单数，表示头部）和`ts`（复数，表示尾部），因为它们都是类型`T`。（在不需要命名泛型类型的语言中，你会看到`x`和`xs`。）
- en: 'If we had a list of integers and wanted the sum, we could implement this along
    the same lines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个整数列表并且想要求和，我们可以按照同样的方式实现：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you know from section 9.6, `Sum` is a special case of `Aggregate`. Let’s
    see how we can implement the more generic `Aggregate` for `List`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在9.6节所知，`Sum`是`Aggregate`的一个特例。让我们看看我们如何为`List`实现更通用的`Aggregate`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, we pattern match, and in the `Cons` case, we apply the reducer function
    `f` to the accumulator and the head. Then we recursively call `Aggregate` with
    the new accumulator and the tail of the list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们进行模式匹配，并在`Cons`情况下，将归约函数`f`应用于累加器和头部。然后我们使用新的累加器和列表的尾部递归调用`Aggregate`。
- en: Warning The implementations shown here aren’t stack-safe. If the list is long
    enough, they’ll cause a `StackOverflowException`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 这里展示的实现不是栈安全的。如果列表足够长，它们将导致`StackOverflowException`。
- en: Now that we’ve looked at how we can work with the linked list, let’s see about
    operations that modify the list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理链表，让我们看看如何进行修改列表的操作。
- en: 12.1.2 Modifying an immutable list
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 修改不可变列表
- en: 'Let’s say we want to add an item to an existing list (by which, naturally,
    I mean obtain a new list with an additional item). With a singly linked list,
    the natural approach is to add items at the front:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要向现有的列表中添加一个项目（通过这种方式，我自然是指获得一个包含额外项目的新的列表）。对于单链表，自然的方法是在前面添加项目：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Given an existing list and a new value, we construct a new list with a new
    head. The head of the new list is a list node holding the new value and a pointer
    to the head of the original list. That’s all! There’s no need to copy all the
    elements, so we can add an element in constant time, creating just one new object.
    Here’s an example of adding to our immutable linked list:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个现有的列表和一个新值，我们构建一个新的列表，其头部是一个包含新值和指向原始列表头部指针的列表节点。就是这样！不需要复制所有元素，因此我们可以以常数时间添加一个元素，只创建一个新对象。以下是我们不可变链表添加元素的示例：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `fruit` list is initialized with two items. We then add a third fruit to
    obtain a new list, `tropicalMix`. Because the list is immutable, our original
    `fruit` list hasn’t changed and still contains two items. This is apparent because
    we can reuse it to create a new, modified version of the list containing just
    yellow fruit.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`fruit`列表以两个项目初始化。然后我们添加第三个水果以获得一个新的列表`tropicalMix`。因为列表是不可变的，我们的原始`fruit`列表没有改变，仍然包含两个项目。这很明显，因为我们可以用它来创建一个新的、只包含黄色水果的列表的新版本。'
- en: Figure 12.2 offers a graphical representation of the objects that are created
    in the preceding code and shows that the original `fruit` list is not altered
    (nor do its elements need to be copied) when creating new lists with an added
    item.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2展示了前述代码中创建的对象的图形表示，并显示在创建带有新项目的新的列表时，原始的`fruit`列表没有被修改（也不需要复制其元素）。
- en: '![](Images/CH12_F02_Buonanno2.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F02_Buonanno2.png)'
- en: Figure 12.2 Adding an item to a list doesn’t affect the original list.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 向列表添加项目不会影响原始列表。
- en: 'Think what this means in terms of decoupling: when you have an immutable list
    (and more generally, an immutable object), you can expose it without ever having
    to worry about what some other component will do to the data. There’s nothing
    they can do to the data at all!'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这在解耦方面的意义：当你有一个不可变列表（以及更一般地，不可变对象）时，你可以暴露它而无需担心其他组件会对数据进行什么操作。他们根本无法对数据进行任何操作！
- en: 'What about removing an item? The singly linked list is biased to work well
    with the first item, so we’ll remove the first item (the head) and return the
    rest of the list (the tail):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那么移除一个项目呢？单链表倾向于很好地处理第一个项目，所以我们将移除第一个项目（头部）并返回剩余的列表（尾部）：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, we can remove the first element from the list in constant time, without
    altering the original list. (Notice that this is one of very few places where
    throwing an exception is justified because calling `Tail` on an empty list is
    a developer error. If there’s a chance of the list being empty, a correct implementation
    should use `Match` rather than calling `Tail`.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以在常数时间内从列表中移除第一个元素，而不改变原始列表。（注意，这是非常少数几个可以合理抛出异常的地方之一，因为在对空列表调用`Tail`是开发者的错误。如果有可能列表为空，正确的实现应该使用`Match`而不是调用`Tail`。）
- en: You may find these examples rather limited because we’ve only interacted with
    the first element of the list. But, in practice, this can be used to cover quite
    a number of use cases. For example, it’s a perfect starting point if you need
    a stack. Common operations like `Map` and `Where` would be *O*(*n*) for a list
    of length *n* as with any other list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现这些示例相当有限，因为我们只与列表的第一个元素进行了交互。但在实践中，这可以用来覆盖相当多的用例。例如，如果你需要一个栈，这是一个完美的起点。常见的操作如`Map`和`Where`对于长度为*n*的列表来说，时间复杂度都是*O*(n)，就像任何其他列表一样。
- en: You can define functions to insert or remove an element at index *m*, and these
    operations are *O*(*m*) because they would require traversing *m* elements and
    creating *m* new `Cons` objects. If you need to append or remove from the end
    of a long list often (for example, if you need to implement a queue), you’d use
    a different data structure—all the data structures you’re used to have immutable
    counterparts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义函数在索引*m*处插入或删除一个元素，这些操作的时间复杂度为*O*(m)，因为它们需要遍历*m*个元素并创建*m*个新的`Cons`对象。如果你经常需要从长列表的末尾添加或删除元素（例如，如果你需要实现一个队列），你会使用不同的数据结构——你习惯的所有数据结构都有不可变的对立面。
- en: 12.1.3 Destructuring any IEnumerable
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 解构任何`IEnumerable`
- en: Notice how we could define many useful operations on our simple linked list
    type in terms of pattern matching. This is because it’s common to want different
    behavior for an empty list rather than for a non-empty list. Note that the non-empty
    case destructures the list into its head and tail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何能够定义许多有用的操作在我们的简单链表类型中，这些操作都是基于模式匹配的。这是因为通常我们希望空列表的行为与非空列表不同。注意非空情况将列表解构为其头部和尾部。
- en: 'A `Match` method with the same semantics can be defined to work for any `IEnumerable`
    and can be defined as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义具有相同语义的`Match`方法，使其适用于任何`IEnumerable`，可以定义如下：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ `Head` returns `None` if the list is empty; otherwise, the head of the list
    wrapped in a `Some`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果列表为空，`Head`返回`None`；否则，列表的头部被包裹在一个`Some`中。
- en: ❷ Calls the `Empty` handler if the list is empty
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果列表为空，调用`Empty`处理程序
- en: ❸ Calls the `Otherwise` handler with the list’s head and tail if it’s not empty
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果列表不为空，调用`Otherwise`处理程序，并传递列表的头部和尾部
- en: This implementation of `Match` is included in `LaYumba.Functional`. You’ll see
    how it can be useful in practice in chapter 13\.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Match`的实现包含在`LaYumba.Functional`中。你将在第13章中看到它在实践中是如何有用的。
- en: 12.2 Binary trees
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 二叉树
- en: Trees are also common data structures. Most list implementations other than
    linked lists use trees as their underlying representation because this allows
    certain operations to be performed more efficiently. We’ll just look at a basic
    binary tree, defined as follows:[²](#pgfId-1145964)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 树也是常见的数据结构。除了链表之外，大多数列表实现都使用树作为其底层表示，因为这允许某些操作更有效地执行。我们只需看看一个基本的二叉树，如下定义：[²](#pgfId-1145964)
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'According to this definition, a tree can be a `Leaf`, which is a terminal node
    and contains a `T`, or it can be a `Branch`, which is a non-terminal node that
    contains two children or *subtrees*. These can, in turn, be leaves or branches
    and so on recursively. Like with `List`, I’ll represent each case with a different
    type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，树可以是一个`Leaf`，它是一个终端节点并包含一个`T`，或者它可以是一个`Branch`，它是一个非终端节点，包含两个子节点或*子树*。这些可以进一步是叶子或分支，等等递归。就像`List`一样，我将用不同的类型来表示每个情况：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you traverse a tree, you will want to execute different code for branches
    and for leaves and access the leaves'' inner values. I’ll define a `Match` method
    providing a pleasant API to perform pattern matching:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遍历树时，你将想要为分支和叶子执行不同的代码，并访问叶子的内部值。我将定义一个`Match`方法，提供一个愉快的API来执行模式匹配：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can now call `Match` as usual:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以像往常一样调用`Match`：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I also have the typical factory functions `Leaf` and `Branch`, allowing you
    to create a tree in the REPL like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我还有典型的工厂函数`Leaf`和`Branch`，允许你在REPL中创建一个树，如下所示：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That would create a tree like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个如下所示的树：
- en: '![](Images/CH12_UN01_Buonanno2.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_UN01_Buonanno2.png)'
- en: 12.2.1 Common tree operations
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 常见树操作
- en: 'Now let’s look at some common operations. As with lists, we can define most
    operations in terms of pattern matching. For example, counting the number of values
    in a tree can be done as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些常见的操作。与列表一样，我们可以用模式匹配来定义大多数操作。例如，计算树中值的数量可以这样做：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Trees also have *depth* (how many nodes you have to traverse to get from the
    root node to the furthest leaf) and, again, you can compute the depth using pattern
    matching:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 树也有*深度*（你需要遍历多少个节点才能从根节点到达最远的叶子节点），同样，你可以使用模式匹配来计算深度：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What about `Map`? `Map` should yield a new tree, isomorphic to the original
    one, with the mapped function applied to each value in the original tree, as figure
    12.3 shows.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`Map`呢？`Map`应该产生一个与原始树同构的新树，将映射函数应用于原始树中的每个值，如图12.3所示。
- en: '![](Images/CH12_F03_Buonanno2.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F03_Buonanno2.png)'
- en: Figure 12.3 The `Map` function for a binary tree
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 二叉树的`Map`函数
- en: 'Try to avoid looking at the following implementation and write down how you
    think `Map` might work:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要看下面的实现，写下你认为`Map`可能如何工作的方法：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To implement `Map` on a tree, you pattern match:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在树上实现 `Map`，你进行模式匹配：
- en: If you have a leaf, then you extract its value, apply the function to the leaf,
    and wrap it in a new leaf.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个叶子节点，那么你提取它的值，将函数应用于叶子节点，并将其包裹在一个新的叶子节点中。
- en: Otherwise, you create a new branch whose left and right subtrees are the result
    of mapping the function onto the original subtrees.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，你创建一个新的分支，其左右子树是将函数映射到原始子树的结果。
- en: 'It’s also reasonable to define an `Aggregate` function that reduces all the
    values in the tree to a single value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个将树中所有值减少到单个值的 `Aggregate` 函数也是合理的：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 12.2.2 Structure sharing
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 结构共享
- en: More interestingly, let’s look at an operation that changes the structure of
    a tree, such as inserting an element. This can be done simply, as the following
    listing shows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，让我们看看一个改变树结构的操作，比如插入一个元素。这可以简单地完成，如下面的列表所示。
- en: Listing 12.3 Adding a value to an immutable tree
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.3 向不可变树添加值
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As usual, the code uses pattern matching. If the tree is a leaf, it creates
    a branch whose two children are the leaf itself and a new leaf with the inserted
    value. If it’s a branch, it inserts the new value into the right subtree.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，代码使用模式匹配。如果树是叶子节点，它创建一个分支，其两个子节点是叶子节点本身和带有插入值的新的叶子节点。如果它是分支，它将新值插入到右子树中。
- en: For example, if you start with a tree containing `{1, 2, 3, 7}` and insert the
    value `9`, the result would be as figure 12.4 shows. As you can see, the new tree
    shares large portions of its structure with the original tree. This is an example
    of the more general idea of *structure sharing*; the updated collection shares
    as much of its structure as possible with the original collection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你从一个包含 `{1, 2, 3, 7}` 的树开始，并插入值 `9`，结果将如图12.4所示。正如你所看到的，新树与原始树共享其大部分结构。这是一个更普遍的*结构共享*思想的例子；更新的集合尽可能多地与原始集合共享其结构。
- en: '![](Images/CH12_F04_Buonanno2.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F04_Buonanno2.png)'
- en: Figure 12.4 The tree with the added value shares parts of the structure with
    the original tree.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 增值后的树与原始树共享部分结构。
- en: How many new items are created to insert an item into a tree? As many as it
    takes to reach a leaf. If you start with a balanced tree with *n* elements,[³](#pgfId-1146081)
    an insert involves the creation of log *n* + 2 objects, which is reasonable.[⁴](#pgfId-1146084)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一个元素到树中需要创建多少新项？与到达叶子节点所需的一样多。如果你从一个包含 *n* 个元素的平衡树开始，[³](#pgfId-1146081) 插入涉及到创建
    log *n* + 2 个对象，这是合理的。[⁴](#pgfId-1146084)
- en: Of course, the implementation in listing 12.3 would eventually lead to a very
    imbalanced tree because it always adds elements to the right. To guarantee efficient
    inserts, we’d need to refine the tree representation to include a self-balancing
    mechanism. This is certainly possible but beyond the scope of this introduction.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，列表12.3中的实现最终会导致一个非常不平衡的树，因为它总是向右添加元素。为了保证高效的插入，我们需要改进树表示以包括自我平衡机制。这当然可能，但超出了本介绍的范畴。
- en: 12.3 In conclusion
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 结论
- en: Developing efficient functional data structures is a vast and fascinating topic
    of which we’ve only scratched the surface. The reference book on the subject is
    *Purely Functional Data Structures* by Chris Okasaki (Cambridge University Press,
    1999). Unfortunately, the code samples are in Standard ML. Nonetheless, in this
    section, you’ve gained some insight into the inner workings of functional data
    structures and the idea of structure sharing, which allows immutable data structures
    to be safe and to perform well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 开发高效的函数式数据结构是一个庞大而迷人的主题，我们只是触及了皮毛。关于这个主题的参考书是Chris Okasaki（剑桥大学出版社，1999年）的《Purely
    Functional Data Structures》。不幸的是，代码示例是Standard ML。尽管如此，在本节中，你已经对函数数据结构的内部工作原理和结构共享的概念有所了解，这允许不可变数据结构既安全又高效。
- en: Functional programs may incur some performance penalty for copying data rather
    than updating it in place, but imperative programs may have to introduce locking
    and defensive copies to ensure correctness. As a result, functional programs tend
    to perform better in many scenarios. For most practical applications, however,
    performance isn’t the critical concern, but rather the greater reliability that
    you gain by embracing immutability.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序在复制数据而不是就地更新数据时可能会遭受一些性能损失，但命令式程序可能必须引入锁定和防御性复制以确保正确性。因此，函数式程序在许多场景中往往表现更好。然而，对于大多数实际应用来说，性能并不是关键问题，而是通过拥抱不可变性而获得的更高可靠性。
- en: Exercises
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Lists:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表：
- en: 'Implement the following functions to work with the singly linked `List` defined
    in this chapter:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下函数以使用本章中定义的单链表`List`：
- en: '`InsertAt` inserts an item at the given index.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertAt`在给定索引处插入一个项。'
- en: '`RemoveAt` removes the item at the given index.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveAt`移除给定索引处的项。'
- en: '`TakeWhile` takes a predicate and traverses the list, yielding all items until
    it finds one that fails the predicate.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakeWhile`接受一个谓词并遍历列表，直到找到一个不满足谓词的项，然后输出所有项。'
- en: '`DropWhile` works similarly but excludes all items at the front of the list.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DropWhile`的工作方式类似，但排除了列表前面的所有项。'
- en: What’s the complexity of these four functions? How many new objects are required
    to create the new list?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这四个函数的复杂度是多少？创建新列表需要多少新对象？
- en: '`TakeWhile` and `DropWhile` are useful when working with a list that’s sorted,
    and you’d like to get all items greater or smaller than some value. Write implementations
    that take an `IEnumerable` rather than a `List`.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TakeWhile`和`DropWhile`在处理已排序的列表并且希望获取所有大于或小于某个值的项时非常有用。编写实现时，请使用`IEnumerable`而不是`List`。'
- en: 'Trees:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 树：
- en: 'Is it possible to define `Bind` for the binary tree implementation shown in
    this chapter? If so, implement `Bind`; otherwise, explain why it’s not possible.
    (Hint: start by writing the signature and then sketch a binary tree and how you
    could apply a tree-returning function to each value in the tree.)'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中展示的二叉树实现中定义`Bind`是否可能？如果是，实现`Bind`；如果不是，解释为什么不可能。（提示：首先编写签名，然后绘制一个二叉树以及如何将返回树的函数应用于树中的每个值。）
- en: Implement a `LabelTree` type where each node has a label of type `string` and
    a list of subtrees. This could be used to model a typical navigation tree or a
    category tree in a website.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`LabelTree`类型，其中每个节点都有一个类型为`string`的标签和一个子树列表。这可以用来模拟一个典型的导航树或网站中的分类树。
- en: 'Imagine you need to add localization to your navigation tree. You’re given
    a `LabelTree` where the value of each label is a key, and a dictionary that maps
    keys to translations in one of the languages that your site must support. You
    need to compute the localized navigation/category tree. (Hint: define `Map` for
    `LabelTree`.)'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你需要给你的导航树添加本地化功能。你被提供了一个`LabelTree`，其中每个标签的值是一个键，以及一个将键映射到网站必须支持的一种语言中的翻译的字典。你需要计算本地化的导航/分类树。（提示：为`LabelTree`定义`Map`。）
- en: Unit test the preceding implementation.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对前面的实现进行单元测试。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In FP, collections should be immutable so that existing collections are never
    altered, but rather new collections are created with the desired changes.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数式编程中，集合应该是不可变的，这样现有的集合就不会被修改，而是通过创建带有所需更改的新集合。
- en: Immutable collections can be safe and efficient because an updated version shares
    much of its structure with the original collection without affecting it.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变集合可以既安全又高效，因为更新版本与原始集合共享大部分结构，而不会影响它。
- en: '* * *'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ Immutable data structures are also referred to as persistent data structures.
    The term *persistence* in this context doesn’t indicate persistence onto some
    media but simply persistence in memory: the original data structure is unaffected
    by any operation that creates a new version, such as adding or removing elements.
    Furthermore, the term *persistent* applied to a data structure implies that it
    offers certain guarantees in terms of the running time of certain operations.
    Namely, operations should be just as efficient in a persistent data structure
    as in the corresponding mutable structure or at least be within the same order
    of magnitude. This goes deeper into data structure and algorithm design, so here
    I’ll just stick with the terms *immutable/functional* data structures/collections.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 不可变数据结构也被称为持久数据结构。在这个上下文中，“持久”一词并不表示持久到某种媒体，而只是指在内存中的持久性：原始数据结构不受创建新版本（如添加或删除元素）的任何操作的影响。此外，将“持久”一词应用于数据结构意味着它对某些操作的运行时间提供某些保证。具体来说，操作在持久数据结构中的效率应该与相应的可变结构中的效率相当，或者至少在同一数量级。这涉及到数据结构和算法设计，所以在这里我将坚持使用术语“不可变/函数式”数据结构/集合。
- en: ² *Binary* here means that every branch has two subtrees.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ² 在这里，“二叉”表示每个分支都有两个子树。
- en: ³ A tree is balanced if all paths from the root to a leaf have the same length
    or differ at most by one.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 如果从根到叶子的所有路径长度相同或最多相差一个，则该树是平衡的。
- en: ⁴ The base of the log will be the arity of the tree (how many children each
    node has). A real-world implementation of a tree underlying a list representation
    may have an arity of 32 so that after inserting 1 million objects, your tree may
    still only have a depth of 4 levels.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 对数的基础将是树的基数（每个节点有多少个子节点）。一个基于列表表示的树的实际实现可能有32个基数，这样在插入一百万个对象后，你的树可能仍然只有4层的深度。
