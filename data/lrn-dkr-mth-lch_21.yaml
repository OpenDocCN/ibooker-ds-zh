- en: 18 Application configuration management in containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 容器中的应用配置管理
- en: Applications need to load their configuration from the environment they’re running
    in, which is usually a combination of environment variables and files read from
    disk. Docker creates that environment for apps running in containers, and it can
    set environment variables and construct a filesystem from many different sources.
    The pieces are all there to help you build a flexible configuration approach for
    your apps, so when you deploy to production you’re using the same image that passed
    all the test phases. You just need to do some work to bring the pieces together,
    setting up your app to merge configuration values from multiple places.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要从它们运行的环境中加载其配置，这通常是环境变量和从磁盘读取的文件的组合。Docker为在容器中运行的应用程序创建该环境，它可以设置环境变量并从许多不同的来源构建文件系统。所有这些部件都是为了帮助您为应用程序构建灵活的配置方法，因此当您部署到生产环境时，您使用的是通过了所有测试阶段的相同镜像。您只需做一些工作来将这些部件组合在一起，设置您的应用程序以从多个位置合并配置值。
- en: This chapter will take you through the recommended approach (and some alternatives)
    using examples in .NET Core, Java, Go, and Node.js. Some of the work here lives
    in the developer space, bringing in libraries to provide config management, and
    the rest lives in that gray area between dev and ops that relies on communication
    so both sides know how the configuration model works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过.NET Core、Java、Go和Node.js中的示例，向您介绍推荐的方法（以及一些替代方案）。这里的一些工作位于开发空间中，引入库以提供配置管理，其余部分位于开发和运维之间的灰色区域，该区域依赖于沟通，以便双方都了解配置模型的工作方式。
- en: 18.1 A multi-tiered approach to app configuration
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 应用配置的多层方法
- en: 'Your configuration model should reflect the structure of the data you’re storing,
    which is typically one of three types:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您的配置模型应该反映您存储的数据的结构，通常是以下三种类型之一：
- en: Release-level settings, which are the same for every environment for a given
    release
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布级别的设置，对于给定发布的每个环境都是相同的
- en: Environment-level settings, which are different for every environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境级别的设置，对于每个环境都是不同的
- en: Feature-level settings, which can be used to change behavior between releases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性级别的设置，可用于在发布之间更改行为
- en: Some of those are fairly static, some are dynamic with a known set of variables,
    and others are dynamic with an unknown set of variables. Figure 18.1 shows some
    sample config settings and where they can be read from the environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些相对静态，一些是动态的，具有一组已知的变量，而其他则是动态的，具有一组未知的变量。图18.1显示了某些示例配置设置以及它们可以从环境中读取的位置。
- en: '![](../Images/18-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/18-1.jpg)'
- en: Figure 18.1 A config hierarchy with settings from the image, filesystem, and
    environment variables
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1 从镜像、文件系统和环境变量中读取设置的配置层次结构
- en: The first example we’ll use is Node.js with a popular config management library
    called node-config. The library lets you read config from multiple file locations
    in a hierarchy and override them all with environment variables. The access-log
    sample app in the exercises for this chapter uses the node-config library and
    sets up two directories to read configuration files from
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第一个例子是Node.js，以及一个流行的配置管理库，名为node-config。这个库允许您从层次结构中的多个文件位置读取配置，并通过环境变量覆盖它们。本章练习中的access-log示例应用程序使用了node-config库，并设置了两个目录来读取配置文件
- en: '`config` --This will be packaged with default settings in the Docker image.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config` -- 这将打包到Docker镜像中的默认设置中。'
- en: '`config-override` --This doesn’t exist in the image but can be provisioned
    in the container filesystem from a volume, config object, or secret.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-override` -- 这个配置在镜像中不存在，但可以从卷、配置对象或秘密中在容器文件系统中配置。'
- en: 'try it now Run the sample app with the default configuration from the image,
    and then the same image with an override file for the development environment:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行具有默认配置的示例应用程序，然后是具有开发环境覆盖文件的相同镜像：
- en: '` cd ch18/exercises/access-log`  ` # run a container with the default config
    in the image:` ` docker container run -d -p 8080:80 diamol/ch18-access-log`  ` #
    run a container loading a local config file override:` ` docker container run
    -d -p 8081:80 -v "$(pwd)/config/dev:/app/config-override" diamol/ch18-access-log`
     ` # check the config APIs in each container:` ` curl http://localhost:8080/config`
    ` curl http://localhost:8081/config`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch18/exercises/access-log`  ` # 在镜像中运行默认配置的容器:` ` docker container run
    -d -p 8080:80 diamol/ch18-access-log`  ` # 运行加载本地配置文件覆盖的容器:` ` docker container
    run -d -p 8081:80 -v "$(pwd)/config/dev:/app/config-override" diamol/ch18-access-log`
     ` # 检查每个容器中的配置API:` ` curl http://localhost:8080/config` ` curl http://localhost:8081/config`'
- en: The first container only uses the default config file that is packaged in the
    image--that specifies the name of the release cycle (19.12) and sets the Prometheus
    metrics to be enabled. There’s an `UNKNOWN` setting for the environment name--if
    you ever see that, you know the environment-level config settings haven’t been
    correctly applied. The second container loads a local config directory as a volume
    in the expected location for the app to find overrides--it sets the environment
    name and flips the metrics feature to off. You’ll see when you call the config
    API that containers from the same image have applied different settings--mine
    is in figure 18.2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个容器仅使用镜像中打包的默认配置文件--指定了发布周期名称（19.12）并设置了要启用的Prometheus指标。环境名称有一个`UNKNOWN`设置--如果你看到这个设置，你就知道环境级别的配置设置还没有正确应用。第二个容器将本地配置目录作为卷加载到应用程序预期的覆盖位置--它设置了环境名称并将指标功能关闭。当你调用配置API时，你会看到来自同一镜像的容器应用了不同的设置--我的设置在图18.2中。
- en: '![](../Images/18-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-2.jpg)'
- en: Figure 18.2 It’s straightforward to merge config files using volumes, config
    objects, or secrets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2 使用卷、配置对象或机密项合并配置文件非常直接。
- en: Loading config overrides from a known path in your app code lets you provide
    them from any source into the container. I’m using a local bind mount, but the
    source could be a config object or a secret stored in a container cluster (as
    we saw in chapters 10 and 13), and the behavior would be the same. There’s one
    nuance to this pattern--your config target can either be a specific file path
    or a directory. A directory target is more flexible (Windows containers don’t
    support loading volumes from a single file), but the source file names need to
    match the config file names the app expects. In this example the bind source is
    the directory `config/dev` , which has a single file--the container sees `/app/config-override/local.json`
    , which is where it looks for overrides.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序代码中的已知路径加载配置覆盖项可以让你在容器中从任何来源提供它们。我正在使用本地绑定挂载，但源可以是配置对象或存储在容器集群中的机密（如我们在第10章和第13章中看到的），行为将是相同的。这个模式有一个细微差别--你的配置目标可以是特定的文件路径或目录。目录目标更灵活（Windows容器不支持从单个文件加载卷），但源文件名需要与应用程序期望的配置文件名匹配。在这个例子中，绑定源是目录`config/dev`，它只有一个文件--容器看到`/app/config-override/local.json`，这是它查找覆盖的地方。
- en: 'The node-config package can also load settings from environment variables,
    and they override any settings loaded from the file hierarchy. This is the configuration
    approach recommended in “The Twelve-Factor App” ( *[https://12factor.net](https://12factor.net)*
    )--a modern style of application architecture, where environment variables always
    take precedence over other config sources. It’s a useful approach that helps you
    get into the mindset that containers are ephemeral because changing environment
    variables to set application config means replacing containers. Node-config has
    a slightly unusual implementation: rather than specifying individual settings
    as environment variables, you need to provide the settings as a JSON-formatted
    string in the environment variable.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: node-config包还可以从环境变量加载设置，并且它们会覆盖从文件层次结构加载的任何设置。这是在《十二要素应用》中推荐的方法（*[https://12factor.net](https://12factor.net)*）--一种现代的应用架构风格，其中环境变量始终优先于其他配置源。这是一个有用的方法，有助于你养成容器是瞬时的思维模式，因为更改环境变量以设置应用程序配置意味着替换容器。Node-config有一个稍微不同寻常的实现：不是将单个设置指定为环境变量，你需要以JSON格式字符串的形式在环境变量中提供设置。
- en: 'try it now Run a third version of the access log container in development mode
    but with metrics enabled. Use the volume mount to load the dev config and an environment
    variable to override the metrics setting:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 运行第三个版本的访问日志容器，以开发模式运行但启用指标。使用卷挂载加载dev配置，并使用环境变量覆盖指标设置：
- en: '` cd ch18/exercises/access-log`  ` # run a container with an override file
    and an environment variable:` ` docker container run -d -p 8082:80 -v "$(pwd)/config/dev:/app/config-override"
    -e NODE_CONFIG=''{\"metrics\": {\"enabled\":\"true\"}}'' diamol/ch18-access-log`
     ` # check the config:` ` curl http://localhost:8082/config`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch18/exercises/access-log`  ` # 运行一个带有覆盖文件和环境变量的容器:` ` docker container
    run -d -p 8082:80 -v "$(pwd)/config/dev:/app/config-override" -e NODE_CONFIG=''{\"metrics\":
    {\"enabled\":\"true\"}}'' diamol/ch18-access-log`  ` # 检查配置:` ` curl http://localhost:8082/config`'
- en: The third container merges config from the default file in the image, the local
    config override file in the volume, and the specific environment variable setting.
    This is a good example of building config to keep the developer workflow running
    smoothly. Devs can run the default settings without metrics enabled (which will
    save CPU cycles and memory), but when they need to turn metrics on for some debugging,
    they can do it with the same image and an environment variable switch. Figure
    18.3 shows my output.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个容器合并了镜像中的默认文件、卷中的本地配置覆盖文件和特定的环境变量设置。这是一个构建配置以使开发者工作流程顺利运行的优秀示例。开发者可以运行默认设置而不启用度量（这将节省CPU周期和内存），但当他们需要为某些调试打开度量时，他们可以使用相同的镜像和环境变量开关来完成。图18.3显示了我的输出。
- en: '![](../Images/18-3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/18-3.jpg)'
- en: Figure 18.3 Merging config from environment variables makes it easy to change
    specific features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3 从环境变量合并配置使更改特定功能变得容易。
- en: This is the core pattern for configuration that you should look to apply in
    all your apps. From this example you can see that the pattern is quite clear,
    but the details are significant, and that’s the gray area where knowledge can
    break down between delivery and deployment. The access-log app lets you override
    the default config file with a new one, but that target file has to be in a specific
    location. You can also override all file settings with environment variables,
    but the environment variable needs to be in JSON format. Ultimately that will
    be documented in the YAML files you use for deployment, but you need to be aware
    that the pattern has the potential for mistakes. An alternative approach removes
    that risk, at the cost of making config management less flexible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应该在所有应用程序中应用的配置核心模式。从这个例子中，您可以清楚地看到模式，但细节很重要，这是在交付和部署之间知识可能崩溃的灰色区域。访问日志应用程序允许您使用新的配置文件覆盖默认配置文件，但该目标文件必须位于特定位置。您还可以使用环境变量覆盖所有文件设置，但环境变量需要是JSON格式。最终，这将在您用于部署的YAML文件中记录，但您需要意识到该模式可能存在错误的风险。一种替代方法可以消除这种风险，但代价是使配置管理变得不那么灵活。
- en: 18.2 Packaging config for every environment
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 为每个环境打包配置
- en: 'Many application frameworks support a config management system where you bundle
    all the config files for every environment in your deployment, and at runtime
    you set a single value to specify the name of the environment you’re running in.
    The app platform loads the config file with the matching environment name, and
    your app is fully configured. .NET Core does this with its default configuration
    provider setup, where config settings are merged from these sources:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序框架支持配置管理系统，其中您将部署中每个环境的所有配置文件捆绑在一起，并在运行时设置一个值以指定正在运行的环境名称。应用程序平台加载与环境名称匹配的配置文件，您的应用程序就完全配置好了。.NET
    Core通过其默认配置提供程序设置来实现这一点，其中配置设置从以下来源合并：
- en: '`appsettings.json` --The default values for all environments'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.json` -- 所有环境的默认值'
- en: '`appsettings.{Environment}.json` --The overrides for the named environment'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.{Environment}.json` -- 对指定环境的覆盖设置'
- en: Environment variables --Used to specify the environment name, and for setting
    overrides
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量 -- 用于指定环境名称和设置覆盖
- en: There’s a new version of the to-do list app for this chapter that uses this
    approach of packaging all the config files in the Docker image. You use a specific
    environment variable to provide the current environment name, and that gets loaded
    in before the rest of the configuration files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的新任务列表应用程序使用在Docker镜像中打包所有配置文件的方法。您使用特定的环境变量来提供当前的环境名称，该名称在配置文件之前加载。
- en: 'try it now Run the to-do list app with the default configuration, which is
    set with the environment name Development, and then with the test environment
    settings:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行默认配置的任务列表应用程序，默认配置设置为开发环境名称，然后使用测试环境设置：
- en: '` # run the to-do list app with default config:` ` docker container run -d
    -p 8083:80 diamol/ch18-todo-list`  ` # run the app with the config for the test
    environment:` ` docker container run -d -p 8084:80 -e DOTNET_ENVIRONMENT=Test
    diamol/ch18-todo-list`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 使用默认配置运行待办事项列表应用:` ` docker container run -d -p 8083:80 diamol/ch18-todo-list`
     ` # 使用测试环境的配置运行应用:` ` docker container run -d -p 8084:80 -e DOTNET_ENVIRONMENT=Test
    diamol/ch18-todo-list`'
- en: The two containers are running from the same image but loading different configuration
    files. Inside the image there are environment files for development, test, and
    production environments. The first container merges the core `appsettings.json`
    with `appsettings.Development.json` --it runs in development mode because Development
    is set as the default environment in the Dockerfile. The second merges `appsettings.json`
    with `appsettings.Test.json` . Both the environment config files are already present
    in the Docker image, so there’s no need to mount an external source for the new
    config. Browse to http:/ /localhost:8083/diagnostics to see the dev config and
    http:/ /localhost:8084/diagnostics to see the test version. My output is in figure
    18.4.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个容器是从相同的镜像运行，但加载不同的配置文件。在镜像内部，有针对开发、测试和生产环境的配置文件。第一个容器将核心的`appsettings.json`与`appsettings.Development.json`合并--因为它在开发模式下运行，因为在Dockerfile中将Development设置为默认环境。第二个容器将`appsettings.json`与`appsettings.Test.json`合并。这两个环境配置文件已经存在于Docker镜像中，因此不需要挂载外部源以获取新的配置。浏览到http:/
    /localhost:8083/diagnostics以查看开发配置，浏览到http:/ /localhost:8084/diagnostics以查看测试版本。我的输出在图18.4中。
- en: '![](../Images/18-4.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-4.jpg)'
- en: Figure 18.4 Packaging every environment’s config file in the image makes it
    easy to switch environments.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4 将每个环境的配置文件打包到镜像中，使得环境切换变得容易。
- en: This approach can work nicely if you have separate systems to manage your configuration
    files and your source code. The CI/CD pipeline can bring the config files into
    the Docker image as part of the build, so you keep config management separate
    from development. The downside is that you still can’t package every setting,
    because you need to keep confidential information out of the Docker image. You
    need to have a security-in-depth approach and assume that your registry could
    be compromised--in that case you don’t want someone to find all your passwords
    and API keys in nice plain-text files in your images.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个独立系统来管理你的配置文件和源代码，这种方法可以很好地工作。CI/CD管道可以将配置文件作为构建的一部分带入Docker镜像，这样你就可以将配置管理从开发中分离出来。缺点是，你仍然不能打包每个设置，因为你需要将机密信息从Docker镜像中排除。你需要有一个多层次的安全方法，并假设你的注册表可能会被攻破--在这种情况下，你不想让某人找到你镜像中的所有密码和API密钥，这些信息以漂亮的纯文本文件的形式存在。
- en: If you like this approach, you still need to allow for override files, and final
    overrides with environment variables. The to-do list app does that, loading files
    from a folder called `config-overrides` if it exists, and using the standard .NET
    Core approach of loading environment variables last. That lets you do useful things
    like run the production environment locally if you’re trying to replicate an issue,
    but override the environment settings to use a database file instead of a remote
    database server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这种方法，你仍然需要允许覆盖文件，以及使用环境变量的最终覆盖。待办事项列表应用就是这样做的，如果存在名为`config-overrides`的文件夹，它会从该文件夹中加载文件，并使用.NET
    Core的加载环境变量的标准方法，最后加载环境变量。这让你能够做些有用的事情，比如在尝试复现问题时在本地运行生产环境，但覆盖环境设置以使用数据库文件而不是远程数据库服务器。
- en: 'try it now The to-do list app still supports config overrides, even though
    all the environment config is bundled in the app. If you run in production mode,
    the app fails because it’s expecting to find a database server, but you can run
    in production with an override file to use a database file instead:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 待办事项列表应用仍然支持配置覆盖，尽管所有环境配置都打包在应用中。如果你以生产模式运行，应用会失败，因为它期望找到数据库服务器，但你可以通过覆盖文件以使用数据库文件而不是远程数据库服务器来以生产模式运行：
- en: '` cd ch18/exercises/todo-list` ` docker container run -d -p 8085:80 -e DOTNET_ENVIRONMENT=Production
    -v "$(pwd)/config/prod-local:/app/config-override" diamol/ch18-todo-list`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch18/exercises/todo-list` ` docker container run -d -p 8085:80 -e DOTNET_ENVIRONMENT=Production
    -v "$(pwd)/config/prod-local:/app/config-override" diamol/ch18-todo-list`'
- en: You can browse to http:/ /localhost:8085/diagnostics and see that the app is
    running in production mode, but the config file override changes the database
    setting, so the app still works without running a Postgres container. My output
    is in figure 18.5.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以浏览到http:/ /localhost:8085/diagnostics并看到应用正在以生产模式运行，但配置文件覆盖改变了数据库设置，因此应用仍然可以运行，无需运行Postgres容器。我的输出在图18.5中。
- en: '![](../Images/18-5.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-5.jpg)'
- en: Figure 18.5 Selecting an environment to run in should still support config overrides
    from additional files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5 选择运行环境时，应仍然支持来自附加文件中的配置覆盖。
- en: This container merges the default `appsettings.json` file with the environment
    file `appsettings.Production.json` and the override file `local.json` in the `prod-local`
    folder. The setup is similar to the Node.js example, so there’s some consistency
    around folder and file names, but .NET Core takes a different approach to setting
    overrides with environment variables. In node-config you pass a JSON string as
    an environment variable to override settings, but in .NET Core you specify individual
    settings as environment variables.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器将默认的 `appsettings.json` 文件与 `prod-local` 文件夹中的环境文件 `appsettings.Production.json`
    和覆盖文件 `local.json` 合并。设置与 Node.js 示例类似，因此文件夹和文件名周围有一些一致性，但 .NET Core 在使用环境变量设置覆盖方面采取了不同的方法。在
    node-config 中，你通过将 JSON 字符串作为环境变量传递来覆盖设置，但在 .NET Core 中，你指定单个设置作为环境变量。
- en: 'Try it Now Run the same local version of production but with a custom release
    name by overriding that setting with an environment variable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 运行与生产相同的本地版本，但通过覆盖该设置使用自定义发布名称：
- en: '` # run the container with a bind mount and a custom environment variable:`
    ` docker container run -d -p 8086:80 -e DOTNET_ENVIRONMENT=Production -e release=CUSTOM
    -v "$(pwd)/config/prod-local:/app/config-override" diamol/ch18-todo-list`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 使用绑定挂载和自定义环境变量运行容器：` ` docker container run -d -p 8086:80 -e DOTNET_ENVIRONMENT=Production
    -e release=CUSTOM -v "$(pwd)/config/prod-local:/app/config-override" diamol/ch18-todo-list`'
- en: Browse to http:/ /localhost:8086/diagnostics and you’ll see the custom release
    name from the environment variable. My output is in figure 18.6.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到 http:/ /localhost:8086/diagnostics，你将看到来自环境变量的自定义发布名称。我的输出在图 18.6 中。
- en: '![](../Images/18-6.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-6.jpg)'
- en: Figure 18.6 The config hierarchy overrides values from any of the config files
    with environment variables.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.6 配置层次结构覆盖了任何配置文件中的环境变量值。
- en: I have to say I don’t like this way of packaging multiple config files, although
    it’s a common approach across lots of app platforms. There’s a danger that you’ll
    include some config setting in your image that you don’t think is sensitive, but
    your security team might disagree. Server names, URLs, file paths, logging levels,
    and even cache sizes could all be useful information to anyone trying to hack
    your system. By the time you move all the confidential settings to override files
    that you apply from the runtime, there’s probably very little left in those packaged
    environment files anyway. I also don’t like the split, where some settings are
    managed in source control and others are in a config management system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须说，我不喜欢这种打包多个配置文件的方式，尽管这在许多应用程序平台上是一种常见的做法。存在一种风险，你可能会在镜像中包含一些你认为不敏感的配置设置，但你的安全团队可能不同意。服务器名称、URL、文件路径、日志级别，甚至缓存大小都可能是有意攻击你系统的人有用的信息。在你将所有机密设置移动到从运行时应用的覆盖文件中之前，这些打包的环境文件中可能已经剩下很少的内容了。我也不喜欢这种分割，其中一些设置在源代码控制中管理，而其他设置在配置管理系统中。
- en: The beauty of containers is that you can follow whichever pattern you like,
    so don’t let me decide for you. Some approaches work better, depending on your
    organization and technology stack. Things get more complicated too if you have
    multiple stacks to deal with--you’ll see that in the next example using a Go application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的美妙之处在于你可以遵循你喜欢的任何模式，所以不要让我为你做决定。根据你的组织和技术堆栈，某些方法可能更有效。如果你要处理多个堆栈，事情也会变得更加复杂——你将在下一个使用
    Go 应用程序的示例中看到这一点。
- en: 18.3 Loading configuration from the runtime
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 从运行时加载配置
- en: 'Go has a popular configuration module called Viper, which offers much of the
    same functionality as the .NET Core libraries or node-config. You add the module
    to your package list, and in your application code you specify the paths to the
    config directories and whether you want environment variables brought in to override
    the config files. I’ve added it to the image gallery app for this chapter, using
    a similar hierarchy to the other examples:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有一个流行的配置模块叫做 Viper，它提供了与 .NET Core 库或 node-config 相当多的功能。你将这个模块添加到你的包列表中，然后在你的应用程序代码中指定配置目录的路径以及你是否希望环境变量用来覆盖配置文件。我已经将它添加到本章的图像库应用程序中，使用与其他示例相似的层次结构：
- en: Files are loaded from the `config` directory first which is populated in the
    Docker image.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件首先从 `config` 目录加载，该目录在 Docker 镜像中填充。
- en: Environment-specific files are loaded from the `config-override` directory,
    which is empty in the image and can be the target for a container filesystem mount.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`config-override`目录加载特定环境的文件，该目录在镜像中为空，可以是容器文件系统挂载的目标。
- en: Environment variables override the file settings.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量覆盖文件设置。
- en: Viper supports a wider set of languages for configuration files than the other
    examples. You can use JSON or YAML, but the popular format in the Go world is
    TOML (named after its creator, Tom Preston-Werner). TOML is great for configuration
    files because it maps easily to dictionaries in code, and it’s easier to read
    than JSON or YAML. Listing 18.1 shows the TOML configuration for the image gallery
    app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Viper支持比其他示例更广泛的配置文件语言集。你可以使用JSON或YAML，但在Go世界中流行的格式是TOML（以创建者Tom Preston-Werner的名字命名）。TOML非常适合配置文件，因为它可以轻松地映射到代码中的字典，并且比JSON或YAML更容易阅读。列表18.1显示了图片库应用的TOML配置。
- en: Listing 18.1 The TOML format makes for easily managed config files
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.1 TOML格式使得配置文件易于管理
- en: '` release = "19.12"` ` environment = "UNKNOWN"`  ` [metrics]` ` enabled = true`
     ` [apis]`  `  [apis.image]` `  url = "http://iotd/image"`  `  [apis.access]`
    `  url = "http://accesslog/access-log"`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '` release = "19.12"` ` environment = "UNKNOWN"`  ` [metrics]` ` enabled = true`
     ` [apis]`  `  [apis.image]` `  url = "http://iotd/image"`  `  [apis.access]`
    `  url = "http://accesslog/access-log"`'
- en: You see TOML being used in lots of cloud-native projects because it’s so much
    easier than the alternatives. If you have a choice of formats, TOML is worth considering
    because “easy to read” also means easy to debug, and easy to see the differences
    between versions in a merge tool. Other than the file format, this example works
    in the same way as the Node.js app, with a default `config.toml` file packaged
    into the Docker image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在许多云原生项目中看到TOML的使用，因为它比其他替代方案容易得多。如果你有多种格式可供选择，TOML值得考虑，因为“易于阅读”也意味着易于调试，并且在合并工具中更容易看到版本之间的差异。除了文件格式之外，此示例与Node.js应用的工作方式相同，默认的`config.toml`文件打包到Docker镜像中。
- en: 'Try it Now Run the app without any additional config setup to check the defaults:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试：运行应用而不进行任何额外的配置设置，以检查默认设置：
- en: '` # run the container:` ` docker container run -d -p 8086:80 diamol/ch18-image-gallery`
     ` # check the config API:` ` curl http://localhost:8086/config`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 运行容器：` ` docker container run -d -p 8086:80 diamol/ch18-image-gallery`
     ` # 检查配置API：` ` curl http://localhost:8086/config`'
- en: When you run this exercise, you’ll see the current app configuration, which
    all comes from the default TOML file. My output is in figure 18.7, and it shows
    the release cycle and the default URLs for the APIs that this app consumes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个练习时，你会看到当前的应用配置，所有这些配置都来自默认的TOML文件。我的输出在图18.7中，显示了发布周期和该应用所消耗的API的默认URL。
- en: '![](../Images/18-7.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-7.jpg)'
- en: Figure 18.7 You can package your app with default settings that work but aren’t
    a complete environment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7 你可以将应用与默认设置打包，这些设置可以工作，但不是完整的环境。
- en: 'The output is from a config API that returns JSON for the current configuration
    settings. A config API is a very useful feature in your app when you have multiple
    layers of config sources; it makes debugging configuration issues much easier,
    but you need to secure that data. There’s no point using secrets for confidential
    settings if they can be publicly read by anyone who tries browsing to `/config`
    , so if you’re going to add a config API, you need to do three things:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出来自返回当前配置设置JSON的配置API。当你的应用有多个配置源层时，配置API是一个非常有用的功能；它使得调试配置问题变得容易得多，但你需要保护这些数据。如果它们可以被尝试浏览`/config`的任何人公开读取，那么使用机密设置就没有意义，所以如果你要添加配置API，你需要做三件事：
- en: Don’t just publish the whole config; be selective and never include secrets.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要只发布整个配置；要有选择性，永远不要包含机密信息。
- en: Secure the endpoint so only authorized users can access it.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护端点，以确保只有授权用户可以访问它。
- en: Make the config API a feature that can be enabled through config.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置API作为一个可以通过配置启用的功能。
- en: The image gallery app takes a slightly different approach from the hierarchical
    config model--default settings are saved in the image, but not for any specific
    environment. The expectation is that every environment will specify its own additional
    config file, which extends or overrides settings in the default file to set up
    the full environment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图片库应用采用了与分层配置模型略有不同的方法--默认设置保存在图片中，但不是针对任何特定环境。预期是每个环境都将指定自己的附加配置文件，该文件扩展或覆盖默认文件中的设置，以设置完整的环境。
- en: 'Try it Now Run the same app again with an override file to build a complete
    environment:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 再次运行相同的应用程序，使用覆盖文件来构建一个完整的环境：
- en: '` cd ch18/exercises/image-gallery`  ` # run the container with a bind mount
    to the local config directory:` ` docker container run -d -p 8087:80 -v "$(pwd)/config/dev:/app/config-override"
    diamol/ch18-image-gallery`  ` # check config again:` ` curl http://localhost:8087/config`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch18/exercises/image-gallery`  ` # 使用绑定挂载到本地配置目录运行容器:` ` docker container
    run -d -p 8087:80 -v "$(pwd)/config/dev:/app/config-override" diamol/ch18-image-gallery`
     ` # 再次检查配置:` ` curl http://localhost:8087/config`'
- en: My output in figure 18.8 shows the app is now fully configured for the dev environment,
    merging the release-level config file in the image with the environment override
    file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我在图18.8中的输出显示，应用程序现在已完全配置为开发环境，将镜像中的发布级别配置文件与环境覆盖文件合并。
- en: '![](../Images/18-8.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-8.jpg)'
- en: Figure 18.8 The Go Viper module merges config files in the same way as the node-config
    package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.8 Go Viper模块以与node-config包相同的方式合并配置文件。
- en: Showing you all these slight variations on the config theme isn’t just a cheap
    way to fill out the chapter. When organizations adopt Docker, they tend to find
    that usage accelerates quickly, and they soon have a lot of apps running in containers
    that each have their own opinions on configuration. Lots of small variations like
    this are bound to happen because the app platforms differ in the features they
    provide and the conventions they expect. You can apply standards at a high level--images
    must come packaged with default config and must support file and environment variable
    overrides--but the details of the config file and environment variable formats
    will be hard to standardize.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 展示所有这些配置主题的细微变化并不仅仅是为了填补章节内容。当组织采用Docker时，它们往往会发现使用速度加快，很快就会有很多应用程序在容器中运行，每个应用程序都有自己的配置观点。由于应用程序平台在提供的功能和期望的约定上存在差异，因此必然会发生许多这样的小变化。您可以在高层次上应用标准——镜像必须包含默认配置，并且必须支持文件和环境变量覆盖——但配置文件和环境变量格式的细节将难以标准化。
- en: We’ll see that in a last example with the Go application. The Viper module supports
    environment variables to override settings in config files, but with a convention
    that is different again from node-config and from .NET Core.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在最后一个Go应用程序的例子中看到这一点。Viper模块支持环境变量来覆盖配置文件中的设置，但与node-config和.NET Core的约定不同。
- en: 'Try it now Run the container with an environment variable override. The config
    model in this app only uses environment variables prefixed with `IG` :'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 使用环境变量覆盖运行容器。此应用程序的配置模型仅使用以`IG`为前缀的环境变量：
- en: '` cd ch18/exercises/image-gallery`  ` # run the container with config override
    and an environment variable:` ` docker container run -d -p 8088:80 -v "$(pwd)/config/dev:/app/config-override"
    -e IG_METRICS.ENABLED=TRUE diamol/ch18-image-gallery`  ` # check the config:`
    ` curl http://localhost:8088/config`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch18/exercises/image-gallery`  ` # 使用配置覆盖和环境变量运行容器:` ` docker container
    run -d -p 8088:80 -v "$(pwd)/config/dev:/app/config-override" -e IG_METRICS.ENABLED=TRUE
    diamol/ch18-image-gallery`  ` # 检查配置:` ` curl http://localhost:8088/config`'
- en: Viper has the convention that you should prefix environment variable names so
    they don’t clash with other environment variables. In this app, the prefix is
    `IG` , followed by an underscore, followed by the config setting name in dot notation
    (so `IG_METRICS .ENABLED` matches the `enabled` value in the `metrics` group in
    the TOML file). You can see from my output in figure 18.9 that this setup adds
    the development environment on top of the default settings but then overrides
    the metrics settings to enable Prometheus metrics.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Viper有一个约定，即你应该给环境变量名称添加前缀，以避免与其他环境变量冲突。在这个应用程序中，前缀是`IG`，后面跟着一个下划线，然后是配置设置名称的点表示法（因此`IG_METRICS
    .ENABLED`与TOML文件中`metrics`组中的`enabled`值匹配）。您可以从我在图18.9中的输出中看到，这种设置在默认设置之上添加了开发环境，但随后覆盖了指标设置以启用Prometheus指标。
- en: '![](../Images/18-9.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-9.jpg)'
- en: Figure 18.9 All the example apps support environment variables for config, but
    with small variations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.9 所有示例应用程序都支持配置环境变量，但存在细微差异。
- en: We’ve walked through config modeling with three different apps, and we have
    three slightly different approaches. The differences are manageable and easy to
    document in the application manifest files, and they don’t actually impact how
    you build the image or run the container. We’ll look at one last example in this
    chapter that takes the same configuration model and applies it to an application
    that doesn’t have a nice new configuration library, so it needs some extra work
    to make it behave like a modern app.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用三个不同的应用程序演示了配置建模，并且我们有三种略有不同的方法。这些差异是可管理的，并且可以在应用程序清单文件中轻松记录，并且实际上不会影响您构建镜像或运行容器的方式。在本章中，我们将查看一个最后的例子，它采用相同的配置模型并将其应用于没有优雅的新配置库的应用程序，因此需要做一些额外的工作来使其表现得像现代应用程序。
- en: 18.4 Configuring legacy apps in the same way as new apps
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4 以与新版应用程序相同的方式配置旧版应用程序
- en: Legacy apps have their own ideas about configuration, which don’t usually involve
    environment variables or file merges. .NET Framework apps on Windows are a good
    example--they expect XML configuration files in specific locations. They don’t
    like looking for files outside the application root folder, and they don’t look
    at environment variables at all. You can still take the same configuration approach
    with those apps, but you need to do some extra work in your Dockerfile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版应用程序对配置有自己的看法，通常不涉及环境变量或文件合并。例如，Windows上的.NET Framework应用程序——它们期望在特定位置有XML配置文件。它们不喜欢在应用程序根文件夹外寻找文件，并且根本不查看环境变量。您仍然可以使用相同的配置方法来处理这些应用程序，但您需要在Dockerfile中做一些额外的工作。
- en: 'The approach here is to package a utility app or set of scripts that transform
    the configuration settings in the container environment into the configuration
    model the application expects. The exact implementation will depend on your app
    framework and how it uses config files, but the logic will be something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的方法是将一个实用程序应用程序或脚本集打包到容器环境中，将这些配置设置转换为应用程序期望的配置模型。具体的实现将取决于您的应用程序框架以及它如何使用配置文件，但逻辑可能如下所示：
- en: Read in the config override settings from a specified source file in the container.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从容器中指定的源文件读取配置覆盖设置。
- en: Read in the overrides from environment variables.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从环境变量中读取覆盖设置。
- en: Merge the two sets of overrides, so environment variables take precedence.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并两组覆盖设置，使环境变量具有优先权。
- en: Write the merged overrides to the specified target file in the container.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将合并后的覆盖设置写入容器中指定的目标文件。
- en: In the exercises for this chapter, there’s an updated version of the image of
    the day Java API that uses this approach. It’s not actually a legacy app, but
    I’ve built the image with the legacy pattern, as though the app can’t use the
    normal container configuration options. There’s a utility app that runs at startup
    and sets up the configuration, so although the internal configuration mechanism
    is different, users can configure containers in the same way as the other examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习中，有一个使用此方法的每日图像Java API的更新版本。它实际上不是一个旧版应用程序，但我已经按照旧版模式构建了镜像，就像应用程序不能使用正常的容器配置选项一样。有一个实用程序应用程序在启动时运行并设置配置，因此尽管内部配置机制不同，用户仍然可以像其他示例一样配置容器。
- en: 'Try it Now Run the “legacy” app with default config settings and with a file
    override:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行“旧版”应用程序，使用默认配置设置和文件覆盖：
- en: '` cd ch18/exercises/image-of-the-day`  ` # run a container with default configuration:`
    ` docker container run -d -p 8089:80 diamol/ch18-image-of-the-day`  ` # run with
    a config override file in a bind mount:` ` docker container run -d -p 8090:80
    -v "$(pwd)/config/dev:/config-override" -e CONFIG_SOURCE_PATH="/config-override/application.properties"
    diamol/ch18-image-of-the-day`  ` # check the config settings:` ` curl http://localhost:8089/config`
    ` curl http://localhost:8090/config`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch18/exercises/image-of-the-day`  ` # 运行具有默认配置的容器：` ` docker container
    run -d -p 8089:80 diamol/ch18-image-of-the-day`  ` # 使用绑定挂载中的配置覆盖文件运行：` ` docker
    container run -d -p 8090:80 -v "$(pwd)/config/dev:/config-override" -e CONFIG_SOURCE_PATH="/config-override/application.properties"
    diamol/ch18-image-of-the-day`  ` # 检查配置设置：` ` curl http://localhost:8089/config`
    ` curl http://localhost:8090/config`'
- en: The user experience is very similar to the other apps--mounting a volume with
    the environment override file (and the source could be a config object or secret)--but
    you have to additionally specify the override file location in an environment
    variable so the startup utility knows where to look. You’ll see in the output
    that the default config in the image specifies the release cycle but not the environment--that
    gets merged in with the override file in the second container. My output is in
    figure 18.10.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验与其他应用程序非常相似--使用环境覆盖文件（源可以是配置对象或密钥）挂载卷，但您还必须在环境变量中指定覆盖文件的位置，以便启动实用程序知道在哪里查找。您将在输出中看到，镜像中的默认配置指定了发布周期但没有指定环境--这将在第二个容器中的覆盖文件中合并。我的输出在图18.10中。
- en: '![](../Images/18-10.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-10.jpg)'
- en: Figure 18.10 This app has a utility to bootstrap the config model, but the user
    experience is the same.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.10 此应用程序有一个用于引导配置模型的实用程序，但用户体验相同。
- en: The magic happens here in a simple Java utility app, which gets compiled and
    packaged in the same multi-stage build as the rest of the app. Listing 18.2 shows
    the key parts of the Dockerfile that build the utility and set it to run at startup.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里发生魔法般的事情的是一个简单的Java实用程序应用程序，它与应用程序的其他部分一起编译和打包在多阶段构建中。列表18.2显示了构建实用程序并将其设置为启动时运行的Dockerfile的关键部分。
- en: Listing 18.2 Building and using a config load utility in the Dockerfile
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.2 在Dockerfile中构建和使用配置加载实用程序
- en: '` FROM diamol/maven AS builder` ` # ...` ` RUN mvn package`  ` # config util`
    ` FROM diamol/maven as utility-builder` ` WORKDIR /usr/src/utilities` ` COPY ./src/utilities/ConfigLoader.java
    .` ` RUN javac ConfigLoader.java`  ` # app` ` FROM diamol/openjdk` ` ENV CONFIG_SOURCE_PATH=""
    \` `       CONFIG_TARGET_PATH="/app/config/application.properties"`  ` CMD java
    ConfigLoader && \` `       java -jar /app/iotd-service-0.1.0.jar`  ` WORKDIR /app`
    ` COPY --from=utility-builder /usr/src/utilities/ConfigLoader.class .` ` COPY
    --from=builder /usr/src/iotd/target/iotd-service-0.1.0.jar .`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM diamol/maven AS builder` ` # ...` ` RUN mvn package`  ` # config util`
    ` FROM diamol/maven as utility-builder` ` WORKDIR /usr/src/utilities` ` COPY ./src/utilities/ConfigLoader.java
    .` ` RUN javac ConfigLoader.java`  ` # app` ` FROM diamol/openjdk` ` ENV CONFIG_SOURCE_PATH=""
    \` `       CONFIG_TARGET_PATH="/app/config/application.properties"`  ` CMD java
    ConfigLoader && \` `       java -jar /app/iotd-service-0.1.0.jar`  ` WORKDIR /app`
    ` COPY --from=utility-builder /usr/src/utilities/ConfigLoader.class .` ` COPY
    --from=builder /usr/src/iotd/target/iotd-service-0.1.0.jar .`'
- en: The important takeaway here is that you can extend your Docker image to make
    old apps behave in the same way as new apps. You control the startup logic, so
    you can run any steps you need before starting the actual application. When you
    do this, you’re increasing the amount of time between the container starting and
    the app being ready, and you’re also increasing the risk the container might fail
    (if the startup logic has an error). You should always have health checks in your
    image or your application manifests to mitigate that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要收获是您可以扩展您的Docker镜像，使旧应用程序的行为与新应用程序相同。您控制启动逻辑，因此可以在启动实际应用程序之前运行所需的任何步骤。当您这样做时，您正在增加容器启动和应用程序准备就绪之间的时间，同时也增加了容器可能失败的风险（如果启动逻辑有错误）。您应该在镜像或应用程序清单中始终有健康检查来减轻这一点。
- en: My config loader utility app supports the 12-factor approach that has environment
    variables override other settings. It merges environment variables with the override
    config file and writes the output as a config file in a location the app expects.
    The utility takes the same approach as Viper, looking for environment variables
    with a specific prefix that helps keep app settings separate from other settings
    in the container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我配置加载实用程序支持12因子方法，该方法中环境变量会覆盖其他设置。它将环境变量与覆盖配置文件合并，并将输出作为应用程序期望的位置的配置文件写入。该实用程序采用与Viper相同的方法，寻找具有特定前缀的环境变量，这有助于将应用程序设置与其他容器中的设置分开。
- en: Try it now The legacy app doesn’t use environment variables, but the config
    utility sets them up so the user experience is the same as a modern app.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧！传统应用程序不使用环境变量，但配置实用程序会设置它们，以便用户体验与现代应用程序相同。
- en: '` # run a container with an override file and an environment variable:` ` docker
    run -d -p 8091:80 -v "$(pwd)/config/dev:/config-override" -e CONFIG_SOURCE_PATH="/config-override/application.properties"
    -e IOTD_ENVIRONMENT="custom" diamol/ch18-image-of-the-day`  ` # check the config
    settings:` ` curl http://localhost:8091/config`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 使用覆盖文件和环境变量运行容器：` ` docker run -d -p 8091:80 -v "$(pwd)/config/dev:/config-override"
    -e CONFIG_SOURCE_PATH="/config-override/application.properties" -e IOTD_ENVIRONMENT="custom"
    diamol/ch18-image-of-the-day`  ` # 检查配置设置：` ` curl http://localhost:8091/config`'
- en: The utility lets me work with my old app in the same way as my other apps. It’s
    mostly transparent to the user--they just set environment variables and load override
    files into volumes. It’s transparent to the app, which just reads the config files
    it expects to see--there are no changes to the original app code here. Figure
    18.11 shows that this “legacy” app uses the modern multi-tiered configuration
    approach.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用程序让我可以用与我其他应用程序相同的方式处理我的旧应用程序。对用户来说主要是透明的——他们只需设置环境变量并将覆盖文件加载到卷中。对应用程序来说也是透明的，它只读取它期望看到的配置文件——这里没有对原始应用程序代码的更改。图
    18.11 显示了这个“遗留”应用程序使用了现代的多层配置方法。
- en: '![](../Images/18-11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.11](../Images/18-11.jpg)'
- en: Figure 18.11 Environment variables make the config model for this old app behave
    like new apps.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.11 环境变量使这个旧应用程序的配置模型表现得像新应用程序。
- en: Now every component in the image gallery app uses the same configuration pattern.
    There’s a level of standardization across all components, but there are also small
    implementation differences. Every component can be configured with a file override
    to run in development mode, and every component can be configured with an environment
    variable to enable Prometheus metrics. How you actually do that differs for each
    app, which is that gray area I mentioned right at the beginning--it’s difficult
    to enforce a standard to say every component will run a Prometheus endpoint if
    the environment variable `ENABLE_METRICS=true` , because app platforms work in
    different ways.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图像库应用程序中的每个组件都使用相同的配置模式。所有组件之间有一个标准化的层次，但也存在一些小的实现差异。每个组件都可以通过文件覆盖来配置以在开发模式下运行，并且每个组件都可以通过环境变量来配置以启用
    Prometheus 指标。实际如何操作因应用程序而异，这就是我在一开始提到的灰色区域——如果环境变量 `ENABLE_METRICS=true`，要强制执行每个组件都将运行
    Prometheus 端点的标准是困难的，因为应用程序平台的工作方式不同。
- en: Documentation is how you remove that confusion, and in the Docker world, deployment
    documentation is best done in the application manifest files. There’s a Docker
    Compose file in the exercises for this chapter that does exactly what I’ve laid
    out in the previous paragraph--setting every component to development mode, but
    enabling Prometheus metrics. Listing 18.3 shows the configuration parts of the
    Compose file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是消除这种困惑的方法，在 Docker 世界中，部署文档最好在应用程序清单文件中完成。本章的练习中有一个 Docker Compose 文件，它正好做了我在上一段中描述的事情——将每个组件设置为开发模式，但启用
    Prometheus 指标。列表 18.3 展示了 Compose 文件的配置部分。
- en: Listing 18.3 Documenting config settings in Docker Compose
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.3 在 Docker Compose 中记录配置设置
- en: '` version: "3.7"` ` services:` `   accesslog:` `       image: diamol/ch18-access-log`
    `       environment:` `           NODE_CONFIG: ''{"metrics": {"enabled":"true"}}''`
    `       secrets:` `           - source: access-log-config` `               target:
    /app/config-override/local.json`  `   iotd:` `       image: diamol/ch18-image-of-the-day`
    `       environment:` `           CONFIG_SOURCE_PATH: "/config-override/application.properties"`
    `           IOTD_MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: "health,prometheus"`
    `       secrets:` `           - source: iotd-config` `               target: /config-override/application.properties`
    `   image-gallery:` `       image: diamol/ch18-image-gallery` `       environment:`
    `           IG_METRICS.ENABLED: "TRUE"` `       secrets:` `           - source:
    image-gallery-config` `               target: /app/config-override/config.toml` 
    ` secrets:` `   access-log-config:` `       file: access-log/config/dev/local.json`
    `   iotd-config:` `       file: image-of-the-day/config/dev/application.properties`
    `   image-gallery-config:` `         file: image-gallery/config/dev/config.toml`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '` version: "3.7"` ` services:` `   accesslog:` `       image: diamol/ch18-access-log`
    `       environment:` `           NODE_CONFIG: ''{"metrics": {"enabled":"true"}}''`
    `       secrets:` `           - source: access-log-config` `               target:
    /app/config-override/local.json`  `   iotd:` `       image: diamol/ch18-image-of-the-day`
    `       environment:` `           CONFIG_SOURCE_PATH: "/config-override/application.properties"`
    `           IOTD_MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: "health,prometheus"`
    `       secrets:` `           - source: iotd-config` `               target: /config-override/application.properties`
    `   image-gallery:` `       image: diamol/ch18-image-gallery` `       environment:`
    `           IG_METRICS.ENABLED: "TRUE"` `       secrets:` `           - source:
    image-gallery-config` `               target: /app/config-override/config.toml` 
    ` secrets:` `   access-log-config:` `       file: access-log/config/dev/local.json`
    `   iotd-config:` `       file: image-of-the-day/config/dev/application.properties`
    `   image-gallery-config:` `         file: image-gallery/config/dev/config.toml`'
- en: It’s a bit of a lengthy code listing, but I wanted to keep all that in one place
    so you can see how the patterns are the same, although the details are different.
    The Node.js app uses a JSON string in an environment variable to enable metrics,
    and it loads a JSON file as a config override.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码列表有点长，但我希望将所有内容放在一个地方，这样你可以看到模式是相同的，尽管细节不同。Node.js应用程序使用环境变量中的一个JSON字符串来启用指标，并加载一个JSON文件作为配置覆盖。
- en: The Java application uses an environment variable that lists the management
    endpoints to include; adding Prometheus in there enables metrics collection. Then
    it loads a config override from a properties file, which is a series of key/value
    pairs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序使用一个列出要包含的管理端点的环境变量；在其中添加Prometheus可以启用指标收集。然后它从属性文件加载配置覆盖，这是一个键值对的序列。
- en: The Go application uses a simple `"TRUE"` string in an environment variable
    to enable metrics and loads the config override as a TOML file. I’m using the
    secret support in Docker Compose for the file sources, but the pattern is the
    same for volume mounts or config objects in a cluster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Go应用程序使用环境变量中的一个简单字符串`"TRUE"`来启用指标，并将配置覆盖作为TOML文件加载。我在Docker Compose中使用了秘密支持来处理文件源，但对于卷挂载或集群中的配置对象，模式是相同的。
- en: The user experience here is both good and bad. It’s good because you can easily
    load different environments by changing the source paths for the config overrides,
    and you can change individual settings with environment variables. It’s bad because
    you need to know the quirks of the application. The project team will likely evolve
    various Docker Compose overrides to cover different configurations, so editing
    config settings won’t be a common activity. Running the app will be far more common,
    and that’s as easy as starting any app with Compose.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户体验既有好的一面也有不好的一面。好的一面是，你可以通过更改配置覆盖的源路径来轻松加载不同的环境，并且可以使用环境变量更改单个设置。不好的一面是，你需要了解应用程序的怪癖。项目团队可能会逐步演变各种Docker
    Compose覆盖，以覆盖不同的配置，因此编辑配置设置不会是一个常见的活动。运行应用程序将会更加常见，而且这和用Compose启动任何应用程序一样简单。
- en: 'Try it Now Let’s run the app as a whole with a fixed set of configuration for
    all the components. Start by removing all running containers, and then run the
    app with Docker Compose:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。让我们使用为所有组件固定的一组配置来整体运行应用程序。首先，删除所有正在运行的容器，然后使用Docker Compose运行应用程序：
- en: '` # clear all containers:` ` docker container rm -f $(docker container ls -aq)`
    ` cd ch18/exercises`  ` # run the app with the config settings:` ` docker-compose
    up -d`  ` # check all the config APIs:` ` curl http://localhost:8030/config` ` curl
    http://localhost:8020/config` ` curl http://localhost:8010/config`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 清除所有容器：` ` docker container rm -f $(docker container ls -aq)` ` cd ch18/exercises`
     ` # 使用配置设置运行应用程序：` ` docker-compose up -d`  ` # 检查所有配置API：` ` curl http://localhost:8030/config`
    ` curl http://localhost:8020/config` ` curl http://localhost:8010/config`'
- en: 'You can browse to http: */ /* localhost:8010 and use the app in the normal
    way, and browse to the Prometheus endpoints to see the component metrics (on http:/
    /localhost:8010/ metrics, http:/ /localhost:8030/metrics, and http:/ /localhost:8020/actuator/prometheus).
    But actually, all the confirmation that the app is configured correctly comes
    from those config APIs.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以通过访问http: */ /* localhost:8010来浏览应用程序，并像通常一样使用它，并浏览到Prometheus端点以查看组件指标（在http:/
    /localhost:8010/ metrics, http:/ /localhost:8030/metrics, 和 http:/ /localhost:8020/actuator/prometheus）。但实际上，所有确认应用程序配置正确的信息都来自那些配置API。'
- en: You can see my output in figure 18.12\. Every component loads the release cycle
    name from the default config file in the image, the environment name from the
    config override file, and the metrics setting from the environment variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图18.12中看到我的输出。每个组件都会从镜像中的默认配置文件加载发布周期名称，从配置覆盖文件加载环境名称，并从环境变量加载指标设置。
- en: '![](../Images/18-12.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-12.jpg)'
- en: Figure 18.12 Docker Compose can document app config settings and start the app
    with that configuration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.12 Docker Compose可以记录应用程序配置设置，并使用该配置启动应用程序。
- en: That’s all we really need to cover regarding the patterns for building your
    applications to fetch configuration from the container environment. We’ll wrap
    up this chapter with some thoughts on where that multi-tiered configuration model
    can take you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于构建应用程序以从容器环境获取配置的模式，我们实际上需要涵盖的内容就这些了。我们将以对多级配置模型可能带给你哪些好处的思考来结束本章。
- en: 18.5 Understanding why a flexible configuration model pays off
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5 理解为什么灵活的配置模型会带来好处
- en: I covered the CI/CD pipeline with Docker in chapters 11 and 15, and the core
    design of that pipeline is that you build one image, and your deployment process
    is about promoting that image through your environments up to production. Your
    apps will need to work slightly differently in each environment, and the way to
    support that while keeping the single-image approach is to use a multi-tiered
    configuration model.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第11章和第15章中用Docker介绍了CI/CD管道，该管道的核心设计是构建一个镜像，你的部署过程就是将这个镜像通过你的环境提升到生产环境。你的应用在每个环境中都需要稍微有所不同，而为了保持单镜像方法同时支持这一点，你可以使用多级配置模型。
- en: In practice you’ll use the release-level settings built into the container image,
    with the environment-level override file provided by the container platform in
    almost all cases, but the ability to set feature-level config with environment
    variables is a useful addition. It means you can react quickly to production issues--tuning
    down the level of logging if that’s a performance issue, or turning off a feature
    that has a security hole. It also means you can create a production-like environment
    on a dev machine to replicate a bug, using the production config override with
    secrets removed, and using environment variables instead.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你将使用内置在容器镜像中的发布级别设置，几乎在所有情况下，环境级别覆盖文件由容器平台提供，但使用环境变量设置功能级别配置的能力是一个有用的补充。这意味着你可以快速响应生产问题——如果这是一个性能问题，则降低日志级别，或者关闭存在安全漏洞的功能。这也意味着你可以在开发机器上创建类似生产环境的环境来复现错误，使用移除机密的发布配置覆盖，并使用环境变量。
- en: That ability to run the exact same image in any environment is the payback for
    investing time in your config model. Figure 18.13 shows the life cycle of an image
    from the CI/CD pipeline onwards.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在任何环境中运行完全相同的镜像，这是在配置模型上投入时间的回报。图18.13显示了从CI/CD管道开始的镜像生命周期。
- en: '![](../Images/18-13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-13.jpg)'
- en: Figure 18.13 The CI/CD pipeline produces one image, and you use the config model
    to change behavior.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.13 CI/CD管道生成一个镜像，你使用配置模型来改变行为。
- en: The work you do in producing this flexible configuration model will go a long
    way toward future-proofing your app. All container runtimes support loading files
    into the container from config objects or secrets and setting environment variables.
    The Docker images for this chapter’s image gallery app will work in the same way
    with Docker Compose, Docker Swarm, or Kubernetes. And it’s not just container
    runtimes--standard configuration files and environment variables are the models
    used in platform-as-a-service (PAAS) products and serverless functions too.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你在创建这种灵活配置模型时所做的努力将大大有助于确保你的应用在未来具有适应性。所有容器运行时都支持从配置对象或机密中加载文件到容器中，并设置环境变量。本章图片库应用的Docker镜像将以相同的方式与Docker
    Compose、Docker Swarm或Kubernetes一起工作。而且不仅限于容器运行时——标准配置文件和环境变量也是平台即服务（PAAS）产品和无服务器函数中使用的模型。
- en: 18.6 Lab
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.6 实验室
- en: It can be tricky to dig into the configuration model for a new app and work
    out how to set override files and configure feature overrides, so you’re going
    to get some practice in this lab. You’ll be using the same image gallery app--in
    the lab folder for this chapter there’s a Docker Compose file with the app components
    specified but with no configuration. Your job is to set up every component to
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究新应用的配置模型可能会有些棘手，需要弄清楚如何设置覆盖文件和配置功能覆盖，因此你将在本实验室中获得一些实践机会。你将使用相同的图片库应用——在本章的实验室文件夹中有一个包含应用组件的Docker
    Compose文件，但没有配置。你的任务是设置每个组件以
- en: Use volumes to load configuration override files.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷来加载配置覆盖文件。
- en: Load the configuration overrides for the test environment.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载测试环境的配置覆盖。
- en: Override the release cycle to be “20.01” instead of “19.12”.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将发布周期覆盖为“20.01”而不是“19.12”。
- en: 'This should be fairly straightforward, but it will be useful to spend some
    time tweaking app config without making any changes to the apps. When you run
    the app with `docker-compose` `up` , you should be able to browse to http: */
    /* localhost:8010 and the app should work. And you should be able to browse to
    all three config APIs and see that the release name is 20.01 and the environment
    is TEST.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '这应该相当直接，但花些时间调整应用配置而不更改应用本身将是有用的。当你使用`docker-compose` `up` 运行应用时，你应该能够浏览到 http:
    */ /* localhost:8010，并且应用应该能够正常工作。你应该能够浏览到所有三个配置API，并看到发布名称是20.01，环境是TEST。'
- en: 'My solution is in the same folder in the `docker-compose-solution.yml` file,
    or you can check it on GitHub here: *[https://github.com/sixeyed/diamol/blob/master/
    ch18/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch18/lab/README.md)*
    .'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案在同一个文件夹中的 `docker-compose-solution.yml` 文件里，或者您也可以在这里的 GitHub 上查看：*[https://github.com/sixeyed/diamol/blob/master/ch18/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch18/lab/README.md)*
    .
