- en: Part 1\. Basics of the IoT and the WoT
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分：物联网和万物互联的基础
- en: In [part 1](#part01) we lay the basis of the Web of Things, what it is, and
    how it compares and relates to the Internet of Things. At the end of the first
    part you’ll have a broad understanding of the problems and challenges of building
    Internet of Things systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一部分](#part01)中，我们为物联网和万物互联奠定了基础，解释了它是什么，以及它与物联网的比较和关联。在第一部分的结尾，你将广泛了解构建物联网系统的问题和挑战。
- en: '[Chapter 1](kindle_split_008.html#ch01) introduces the Web of Things approach
    and discusses the various advantages it offers in numerous use cases and contexts.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](kindle_split_008.html#ch01) 介绍了物联网的方法，并讨论了它在众多用例和环境中提供的各种优势。'
- en: '[Chapter 2](kindle_split_009.html#ch02) offers a high-level yet hands-on first
    encounter with the Web of Things. You’ll learn how to send requests to a real
    device in London and quickly write simple applications that interact with the
    device.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](kindle_split_009.html#ch02) 提供了与物联网的第一次高级但实用的接触。你将学习如何向伦敦的设备发送请求，并快速编写与设备交互的简单应用程序。'
- en: '[Chapter 3](kindle_split_010.html#ch03) describes why JavaScript is an excellent
    fit for embedded devices and the Web of Things and also provides a crash course
    on the Node.js framework and ecosystem.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三章](kindle_split_010.html#ch03) 描述了为什么JavaScript非常适合嵌入式设备和物联网，并提供了对Node.js框架和生态系统的快速入门课程。'
- en: '[Chapter 4](kindle_split_011.html#ch04) provides an introduction to the world
    of embedded systems, their various types, and their differences. Next, you’ll
    become familiar with the Raspberry Pi platform, learn how to connect sensors and
    actuators to your device, and then control it from Node.js applications.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四章](kindle_split_011.html#ch04) 介绍了嵌入式系统的世界，它们的类型及其差异。接下来，你将熟悉树莓派平台，学习如何将传感器和执行器连接到你的设备，然后从Node.js应用程序中控制它。'
- en: '[Chapter 5](kindle_split_012.html#ch05) is a broad introduction to the various
    approaches and methods for interconnecting physical objects. In particular, you’ll
    learn about the benefits of and differences between the various networking protocols
    commonly used in the Internet of Things. At the end of the chapter, we propose
    a layered architecture for the Web of Things.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](kindle_split_012.html#ch05) 对连接物理对象的多种方法和途径进行了广泛的介绍。特别是，你将了解在物联网中常用各种网络协议的优缺点。本章结尾，我们提出了物联网的分层架构。'
- en: Chapter 1\. From the Internet of Things to the Web of Things
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章：从物联网到万物互联
- en: '*This chapter covers*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: An introduction to the concept and history of the Internet of Things (IoT)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网（IoT）的概念和历史简介
- en: When and why we should digitally connect physical objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们何时以及为何应该将物理对象进行数字化连接
- en: The limitations of traditional approaches to the Internet of Things
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统物联网方法的局限性
- en: How and why the Web of Things (WoT) is different and why it’s promising
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网（WoT）为何不同以及为何有前景
- en: If you’re holding this book in your hands, it’s very likely that you’ve already
    heard the terms *Internet of Things (IoT)* and *Web of Things (WoT)*. Maybe you
    want to understand what this trend is all about. Or maybe you already understand
    why this topic has become so popular and you’d like to be part of it, but you’re
    not sure where to start. Or—even further than that—you realize what the IoT could
    mean for your industry and you’d like to gain the hard technical skills needed
    to build web-connected products and services. If any of those ring true, you’re
    in for a treat!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手里拿着这本书，你很可能已经听说过“物联网（IoT）”和“万物互联（WoT）”这两个术语。也许你想了解这个趋势是什么。或者也许你已经理解为什么这个话题变得如此受欢迎，并且你想成为其中的一员，但你不确定从哪里开始。或者——更进一步——你意识到物联网对你所在行业可能意味着什么，你希望获得构建网络连接产品和服务的所需的技术技能。如果你有任何这些共鸣，你将有一个美好的体验！
- en: What is the IoT, anyway? When and where was it invented? What new types of applications
    and scenarios does the IoT enable? How will this change the technology and business
    landscape for the coming years? The next chapters will answer all these questions
    and many more. But don’t throw away this book yet, because it won’t just discuss
    theory. It will also cover in detail all the web technologies and tools that will
    help you make the Internet of Things a reality. On the other hand, we believe
    that starting with some background will help you better understand what the IoT
    really is and how you can use it in your own projects, not just stick to the superficial
    and stereotypical descriptions of it. Diving into the history of the IoT will
    help you understand the subtle difference between the Internet of Things and the
    Web of Things and especially why this distinction matters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网到底是什么？它是什么时候在哪里被发明的？物联网使哪些新的应用和场景成为可能？它将如何改变未来几年的技术和商业格局？接下来的章节将回答所有这些问题以及更多。但不要扔掉这本书，因为它不仅会讨论理论。它还会详细涵盖所有可以帮助你将物联网变为现实的技术和工具。另一方面，我们相信，从一些背景知识开始将帮助你更好地理解物联网到底是什么，以及你如何在你的项目中使用它，而不仅仅是停留在表面和刻板化的描述。深入了解物联网的历史将帮助你理解物联网和物联网之网之间的微妙差异，特别是为什么这种区别很重要。
- en: In the last few years, the Internet of Things has become one of the most promising
    and exciting developments in technology and business. The vision of a world where
    tiny computers with sensors and communication interfaces that are embedded in
    the infrastructure of our cities or in cars, offices, or clothes is likely to
    revolutionize every area of our lives—how we play, how we work and do business,
    and how we live. Until recently, IoT projects mostly focused on building small-scale,
    closed, and isolated deployments where devices were not designed to be easily
    accessible or reprogrammable. The bespoke coupling between devices and applications
    in a given use case means that any change to an existing deployment is complex
    and expensive. This limits both the maintenance and evolution of the Internet
    of Things because considerable resources (time, money, and technical skills) are
    required each time a new function is added.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，物联网已经成为技术和商业中最有希望和最激动人心的进展之一。一个世界的愿景，在这个世界里，微型计算机、传感器和通信接口嵌入到我们城市的基础设施中，或者嵌入到汽车、办公室或衣服中，可能会彻底改变我们生活的每一个领域——我们如何玩耍，我们如何工作和做生意，以及我们如何生活。直到最近，物联网项目主要关注构建小规模、封闭和孤立的部署，其中设备不是设计成易于访问或可重编程的。在特定用例中，设备和应用程序之间的定制耦合意味着对现有部署的任何更改都是复杂且昂贵的。这限制了物联网的维护和演变，因为每次添加新功能都需要大量的资源（时间、金钱和技术技能）。
- en: In contrast, the web has become widely successful in the last two decades because
    it’s simple to learn and use and it also emphasizes loose coupling between servers,
    browsers, and applications. The simple and clearly defined programming model of
    HTTP makes it possible for anyone to change pieces of the system without breaking
    the whole system. Therefore, building new web applications has been relatively
    inexpensive and accessible to a much larger group of technology enthusiasts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，在过去的二十年里，互联网之所以取得了广泛的成功，是因为它易于学习和使用，并且它还强调了服务器、浏览器和应用程序之间松散耦合的重要性。HTTP简单且明确定义的编程模型使得任何人都可以在不破坏整个系统的情况下更改系统的某些部分。因此，构建新的网络应用相对便宜且易于接触，对更大一群技术爱好者来说更加可行。
- en: The Web of Things is a specialization of the Internet of Things that uses what
    made the web so successful and applies it to embedded devices in order to make
    the latest developments in the Internet of Things accessible to as many developers
    as possible. On the Web of Things—just like on the web—anyone with a text editor
    and the basic understanding of web standards (HTML and HTTP) can quickly start
    connecting devices and objects to the web. But it also enables going to the next
    level and helps you to effectively build interactive and innovative real-world
    applications that blend the physical and digital worlds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网之网（Web of Things）是物联网的一个专门领域，它利用了使互联网取得成功的因素，并将其应用于嵌入式设备，以便让尽可能多的开发者能够访问物联网的最新进展。在物联网之网——就像在互联网上一样——任何拥有文本编辑器和基本网络标准（HTML和HTTP）理解的人都可以快速开始将设备和物体连接到互联网。但它还使你能够达到下一个层次，并帮助你有效地构建交互性和创新性的现实世界应用，这些应用融合了物理世界和数字世界。
- en: 1.1\. Defining the Internet of Things
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 定义物联网
- en: 'Capturing the essence of the Internet of Things in one sentence is nearly impossible.
    The concepts have been around for decades and there are no clear boundaries to
    what the IoT is or isn’t. Nevertheless, the broad definition of the Internet of
    Things vision is a world where the internet is much more than the collection of
    multimedia content it is today: it extends into the physical, real-time world
    using a myriad of small or even tiny computers. In short, the simplest definition
    we can offer for the Internet of Things is the following.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 用一句话概括物联网的本质几乎是不可能的。这些概念已经存在了几十年，物联网是什么或不是什么并没有明确的界限。尽管如此，物联网愿景的广泛定义是一个互联网远远超出今天的多媒体内容集合的世界：它通过无数小型甚至微型的计算机扩展到物理、实时世界。简而言之，我们可以为物联网提供的最简单定义如下。
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: The Internet of Things is a system of physical objects that can be discovered,
    monitored, controlled, or interacted with by electronic devices that communicate
    over various networking interfaces and eventually can be connected to the wider
    internet.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网是一个物理对象系统，可以通过在多种网络接口上通信的电子设备发现、监控、控制或与之交互，最终可以连接到更广泛的互联网。
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Two decades ago, a world where everyday objects could feel the world through
    sensors and then analyze, store, or exchange information existed only in science-fiction
    novels or in the Jetsons. Today, such scenarios are increasingly becoming reality,
    thanks to the colossal progress in embedded devices that brought into the world
    a new class of objects: smart things. A *smart thing* (which we’ll refer to as
    a *Thing*—with a capital *T*—in the rest of this book) is a physical object that’s
    digitally augmented with one or more of the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 二十年前，一个可以通过传感器感知世界、然后分析、存储或交换信息的日常物体世界，仅存在于科幻小说或《杰森一家》中。如今，由于嵌入式设备的巨大进步，带来了一个新类别的物体：智能物体。一个*智能物体*（在本书的其余部分我们将称之为*物体*——首字母大写*T*）是一个通过以下一个或多个方式数字化增强的物理对象：
- en: Sensors (temperature, light, motion, and so on)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器（温度、光线、运动等）
- en: Actuators (displays, sound, motors, and so on)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行器（显示器、声音、电机等）
- en: Computation (can run programs and logic)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算（可以运行程序和逻辑）
- en: Communication interfaces (wired or wireless)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信接口（有线或无线）
- en: Things extend the world we live in by enabling a whole new range of applications;
    see [figure 1.1](#ch01fig01). By deploying a bunch of tiny and cheap—yet increasingly
    powerful—computers everywhere around us, it becomes possible to monitor and interact
    with the physical world with a much finer spatial and temporal resolution than
    ever before.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 物体通过启用一系列全新的应用扩展了我们生活的世界；参见[图1.1](#ch01fig01)。通过在我们周围部署大量微型且价格低廉——但越来越强大——的计算机，我们现在能够以前所未有的精细空间和时间分辨率监控和交互物理世界。
- en: Figure 1.1\. The Internet of Things landscape. The IoT is a network of Things,
    which are anything that can be connected in some form to the internet. From a
    box of oranges with an RFID tag, to a smart city, to every Thing in between, all
    digitally augmented objects make up the Internet of Things.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. 物联网的景观。物联网是一个物体的网络，任何可以通过某种形式连接到互联网的东西都可以成为物体。从带有RFID标签的橙子箱，到智能城市，再到中间的每一个物体，所有数字化增强的对象共同构成了物联网。
- en: '![](01fig01_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](01fig01_alt.jpg)'
- en: Concretely, the Things in the Internet of Things can range from simple tagged
    products such as your FedEx package with an Auto-ID tag (Automatic Identification
    methods such as bar codes, QR codes, and NFC and RFID tags) attached to it so
    it can be tracked from the shipping center to your door; to more elaborate, complex,
    and wirelessly connected products, devices, or machines such as security systems,
    your car, or a factory assembly line; and all the way up to a building or even
    a city. The *internet* part of the term means that the Thing (or at least its
    services or data about/from it) can be accessed and processed by other applications
    through the existing internet infrastructure. Note that this does not imply that
    the Thing itself must be directly connected to the internet. The communication
    network used can be an Auto-ID method, short-range radio (Bluetooth, ZigBee, and
    the like), or the Wi-Fi network in a building.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，物联网中的“物”可以是从简单的带有自动识别标签的产品，比如你带有自动识别标签（如条形码、二维码、NFC和RFID标签）的联邦快递包裹，这样它可以从发货中心追踪到你的门口；到更复杂、无线连接的产品、设备或机器，如安全系统、你的汽车或工厂装配线；甚至是一个建筑或整个城市。术语中的“互联网”部分意味着“物”（或至少其服务或关于/来自它的数据）可以通过现有的互联网基础设施被其他应用程序访问和处理。请注意，这并不意味着“物”本身必须直接连接到互联网。所使用的通信网络可以是自动识别方法、短距离无线电（蓝牙、ZigBee等）、建筑中的Wi-Fi网络。
- en: Unfortunately, building a single and global ecosystem of Things that communicate
    with each other seamlessly is virtually impossible today. There’s no unique and
    universal application protocol for the Internet of Things that can work across
    the many networking interfaces available today. To put it bluntly, the Internet
    of Things of today is essentially a growing collection of isolated Intranets of
    Things that can’t be connected to each other.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，今天几乎不可能建立一个单一且全球的物联网生态系统，使得各种设备能够无缝通信。没有一种独特且通用的物联网应用协议可以在今天可用的许多网络接口上工作。直言不讳地说，今天的物联网本质上是一个不断增长的孤立物联网内联网集合，它们无法相互连接。
- en: 'For the Internet of Things to become real, we need a single universal application
    layer protocol (think *language*) for devices and applications to talk to each
    other, regardless of how they’re physically connected. Rather than inventing yet
    another protocol from scratch (as many IoT projects have been—and keep—doing),
    why not reuse something that’s already widely used to build scalable and interactive
    applications, such as the web itself? This is what the Web of Things (and this
    book) is all about: using and reusing readily available and widely popular web
    protocols, standards, and blueprints to make data and services offered by Things
    more accessible to a larger pool of (web) developers.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使物联网成为现实，我们需要一个单一的全局应用层协议（想想*语言*），使得设备和应用程序能够相互交流，无论它们如何物理连接。与其从头开始发明另一个协议（正如许多物联网项目所做的那样，并且仍在继续这样做），为什么不重用已经广泛用于构建可扩展和交互式应用程序的东西，比如互联网本身呢？这正是物联网（以及这本书）的主题：使用和重用现成的、广泛流行的互联网协议、标准和蓝图，使物联网提供的数据和服务更容易被更多的（网络）开发者访问。
- en: 1.2\. Enter the Web of Things
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 物联网的诞生
- en: As we’ll describe in detail in [section 1.4](#ch01lev1sec4), the limitations
    of the Internet of Things become visible as soon as one wants to integrate devices
    from various manufacturers into a single application or system. To illustrate
    how the Web of Things can deal with these limitations, let’s consider the life
    of Johnny B., the owner of a famous hotel chain in several cities around the world.
    Johnny would like to digitally connect all the appliances in all the rooms of
    all his hotels, so that he can monitor, control, and improve the management of
    his hotels from the deck of his yacht in the Bahamas via a single control center
    application. Meanwhile, this system could also offer a more pleasant and personalized
    experience to each guest in his hotels, as shown in [figure 1.2](#ch01fig02).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第1.4节](#ch01lev1sec4)中详细描述的那样，当人们想要将来自不同制造商的设备集成到单个应用程序或系统中时，物联网的局限性就会显现出来。为了说明物联网如何处理这些局限性，让我们考虑一下约翰尼·B.的生活，他是全球多个城市的著名酒店连锁店的老板。约翰尼希望将所有酒店的每个房间中的所有电器都进行数字化连接，这样他就可以通过巴哈马的游艇甲板上的单个控制中心应用程序来监控、控制和改善他酒店的管理。同时，这个系统还可以为他的酒店中的每位客人提供更愉快和个性化的体验，如图[图1.2](#ch01fig02)所示。
- en: Figure 1.2\. Johnny would like to digitally connect the appliances in all rooms
    of his hotel. First, guests could have access to a variety of services from controlling
    their room (lights, air-conditioning, entertainment, and so on), to booking hotel
    facilities, to ordering food and drinks—all of this on their mobile phones. Second,
    this system would allow Johnny to coordinate and optimize all aspects of his hotel
    in a centralized and efficient manner, without having to use a variety of siloed
    applications and tools.
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. 约翰尼希望将酒店所有房间的电器进行数字化连接。首先，客人可以通过他们的手机访问各种服务，从控制他们的房间（灯光、空调、娱乐等），到预订酒店设施，到订购食物和饮料——所有这些都可以在他们的手机上完成。其次，这个系统将允许约翰尼以集中和高效的方式协调和优化他酒店的各个方面，而无需使用各种孤岛化的应用程序和工具。
- en: '![](01fig02_alt.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](01fig02_alt.jpg)'
- en: '1.2.1\. Web of Things scenario: connected hotel'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. 物联网场景：联网酒店
- en: 'Building this smart hotel system will likely require electronic door locks
    made by company *Alpha*, security cameras from company *Beta*, and a control application
    to manage all of this made by company *Gamma*. Making these devices and systems
    talk and work with each other will require lots of custom system integration.
    Johnny could contract with a specialized company and spend his well-earned resources
    on a substantial project that will take months to complete. Such a complex and
    bespoke project will have the robustness of a Jenga tower (touch the wrong piece
    and all hell breaks loose): it will be swamped with bugs and hacks and therefore
    will be a nightmare to maintain and to extend. In this scenario, there’s little
    doubt that Johnny will run out of money before he gets the system he wants.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这个智能酒店系统可能需要由公司*Alpha*制造的电子门锁，由公司*Beta*提供的安全摄像头，以及由公司*Gamma*提供的用于管理所有这些的控制应用程序。使这些设备和系统能够相互通信和协同工作需要大量的定制系统集成。约翰尼可以与一家专业公司签订合同，并花费他辛苦赚来的资源在一个需要数月才能完成的大项目上。这样一个复杂和定制的项目将具有Jenga塔的坚固性（触摸错误的部件，所有事情都会失控）：它将充斥着错误和黑客攻击，因此维护和扩展将是一场噩梦。在这种情况下，毫无疑问，约翰尼在得到他想要的系统之前就会耗尽资金。
- en: 'If Johnny is into DIY (do it yourself), he can certainly decide to build the
    whole system himself. He’ll need to buy all the equipment from the same company
    so he won’t run into any incompatibilities. Unfortunately, it’s unlikely that
    he’ll find a single manufacturer that has all the sensors and equipment he needs.
    Even if he finds this perfect system, chances are high that the control application
    that comes with it won’t be what he wants: easy to use and to configure. He’ll
    likely have to write a whole new control center application himself, from scratch.
    Oh, and if he also wants the system to be scalable, reliable, and secure, he can
    easily double—if not triple—the time he’ll need to build it. Should we also talk
    about the mobile apps that will need to be built for the hotel guests? You get
    the idea.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '如果约翰尼喜欢DIY（自己动手做），他当然可以决定自己构建整个系统。他需要从同一家公司购买所有设备，这样他就不会遇到任何不兼容的问题。不幸的是，他不太可能找到一家拥有他所需所有传感器和设备的单一制造商。即使他找到了这个完美的系统，
    chances are high that the control application that comes with it won’t be what
    he wants: easy to use and to configure. 他很可能会不得不从头开始自己编写一个全新的控制中心应用程序。哦，如果他还想让系统具有可扩展性、可靠性和安全性，他可以轻易地将所需时间翻倍——如果不是三倍。我们是否也应该谈谈需要为酒店客人构建的移动应用程序？你明白我的意思了。'
- en: Johnny’s life may seem surreal. Sadly, it’s pretty much what the IoT looks like
    today. We know this because we’ve had the chance to work with many Johnnies over
    the last decade, ranging from shop managers wanting to combine their existing
    security cameras with RFID gates to create smarter security systems, to LED manufacturers
    wanting their lights to be controlled from the web. We’ve experienced this scenario
    over and over.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰尼的生活可能看起来很超现实。遗憾的是，这正是今天物联网的样子。我们知道这一点，因为我们过去十年中与许多约翰尼有过合作，从想要将现有的安全摄像头与RFID门结合以创建更智能的安全系统的小店经理，到想要通过互联网控制其灯光的LED制造商。我们反复经历了这种场景。
- en: Wouldn’t it be wonderful if any device could be easily integrated and consumed
    by any application, regardless of the networking protocols or standards they use?
    This is exactly what the Web of Things enables, as illustrated in [figure 1.3](#ch01fig03).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何设备都能轻松集成并被任何应用程序消费，无论它们使用的是哪种网络协议或标准，那岂不是太棒了？这正是物联网所实现的，如图1.3所示[链接](https://wiki.example.org/feynmans_learning_method)。
- en: Figure 1.3\. In the Internet of Things, hundreds of incompatible protocols coexist
    today. This makes the integration of data and services from various devices extremely
    complex and costly. In the Web of Things, any device can be accessed using standard
    web protocols. Connecting heterogeneous devices to the web makes the integration
    across systems and applications much simpler.
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3。在物联网中，今天存在数百种不兼容的协议。这使得从各种设备中集成数据和服务的复杂性和成本极高。在物联网络中，任何设备都可以使用标准网络协议进行访问。将异构设备连接到网络使得跨系统和应用程序的集成变得更加简单。
- en: '![](01fig03_alt.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig03_alt.jpg)'
- en: 1.2.2\. Comparing IoT and WoT
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2. 物联网与物联网络的比较
- en: Because more everyday objects will be digitally augmented, the next logical
    step is to use the World Wide Web ecosystem and infrastructure to build applications
    for the Internet of Things, effectively breaking this ongoing “one device, one
    protocol, one app” pattern. It would be particularly interesting to push down
    to each of those tiny devices the exact same technology that helped modern websites
    such as Facebook or Google scale to millions of concurrent users, without compromising
    on security or performance. The idea of maximizing existing and emerging tools
    and techniques used on the web and applying them to the development of Internet
    of Things scenarios is the ultimate goal of the Web of Things.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更多日常物品将被数字化增强，下一步合乎逻辑的步骤是利用万维网生态系统和基础设施来构建物联网应用程序，有效地打破这种持续的“一个设备，一个协议，一个应用”模式。将帮助现代网站如Facebook或Google扩展到数百万并发用户的技术推向每个这些微小的设备，同时不牺牲安全或性能，将特别有趣。将现有和新兴的工具和技术最大化，并将它们应用于物联网场景的开发，这是物联网络的最终目标。
- en: While the Internet of Things has been busy resolving networking problems, the
    Web of Things relies exclusively on Application-level protocols and tools (layer
    7 of the Open Systems Interconnection (OSI) model described in [chapter 5](kindle_split_012.html#ch05));
    see [figure 1.4](#ch01fig04). Mapping any device into a web mindset makes the
    Web of Things agnostic to the Physical and Transport layer protocols used by devices.
    As you’ll learn to do in the next chapters, the good news is that pretty much
    any custom IoT protocol or standard can be linked to the web thanks to software
    or hardware bridges called *gateways*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当物联网正忙于解决网络问题时，物联网络完全依赖于应用层协议和工具（如[第5章](kindle_split_012.html#ch05)中描述的开放系统互连（OSI）模型的第7层）；参见[图1.4](#ch01fig04)。将任何设备映射到网络思维中，使得物联网络对设备使用的物理和传输层协议变得无关紧要。正如你将在下一章中学到的，好消息是，几乎任何定制的物联网协议或标准都可以通过称为*网关*的软件或硬件桥接器与网络连接起来。
- en: Figure 1.4\. The Web of Things is concerned with only the highest OSI layer
    (7), which handles applications, services, and data. Working with such a high
    level of abstraction makes it possible to connect data and services from many
    devices regardless of the actual transport protocols they use. In contrast, the
    Internet of Things doesn’t advocate a single Application-level protocol and usually
    focuses on the lower layers of the OSI stack.
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4。物联网络只关注最高的OSI层（7），该层处理应用程序、服务和数据。与这样高层次的抽象工作使得连接来自许多设备的数据和服务成为可能，无论它们实际使用的传输协议是什么。相比之下，物联网并不提倡单一的应用层协议，通常关注OSI堆栈的底层。
- en: '![](01fig04_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig04_alt.jpg)'
- en: Abstracting the complexity and variety of the lower-level protocols behind the
    simple model of the web offers many advantages. Just like the web has become the
    global integration platform for distributed applications over the internet, the
    Web of Things facilitates the integration of all sorts of devices and the applications
    that interact with them. In other words, by hiding the complexity and differences
    between various transport protocols used in the IoT, the Web of Things allows
    developers to focus on the logic of their applications without having to bother
    about how this or that protocol or device actually works.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将底层协议的复杂性和多样性抽象到简单的网络模型背后提供了许多优势。就像网络已经成为互联网上分布式应用程序的全球集成平台一样，物联网络促进了各种设备和与之交互的应用程序的集成。换句话说，通过隐藏物联网中使用的各种传输协议的复杂性和差异，物联网络允许开发者专注于其应用程序的逻辑，而无需担心这个或那个协议或设备实际上是如何工作的。
- en: Coming back to our smart hotel scenario, if all devices (regardless of their
    manufacturer) could offer a standard web API, integration of data across devices
    and applications will pretty much come out of the box because all devices would
    speak the same language. In this case, the hotel owner (or system integrator)
    will only need to worry about building the control center application that’s likely
    going to be a web mashup—a single web application that combines data and services
    from various sources. He won’t have to bother learning the specifics of each protocol
    used by the various devices he wants to use.^([[1](#ch01fn01)]) This will not
    only take significantly less time to build but will also minimize the effort required
    to maintain the system each time a device or service is added, removed, or updated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的智能酒店场景，如果所有设备（无论制造商如何）都能提供标准的Web API，那么跨设备和应用程序的数据集成将几乎“开箱即用”，因为所有设备都会说同一种语言。在这种情况下，酒店业主（或系统集成商）只需担心构建控制中心应用程序，这很可能是Web混合应用——一个结合来自各种来源的数据和服务的单一Web应用程序。他不必费心学习他想要使用的各种设备所使用的每个协议的具体细节.^([[1](#ch01fn01)])
    这不仅将显著减少构建所需的时间，而且还将最大限度地减少每次添加、删除或更新设备或服务时维护系统所需的努力。
- en: ¹
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A not so short list of automation protocols: [https://en.wikipedia.org/wiki/List_of_automation_protocols](https://en.wikipedia.org/wiki/List_of_automation_protocols)'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一份不太短的自动化协议列表：[https://en.wikipedia.org/wiki/List_of_automation_protocols](https://en.wikipedia.org/wiki/List_of_automation_protocols)
- en: 'Making this vision a reality has been the objective of the Web of Things community
    we started in 2007.^([[2](#ch01fn02)]) Using HTTP and other web standards or tools
    to interact with embedded devices made perfect sense to us. At the time, this
    idea seemed unrealistic and even pointless to some, and we got our fair share
    of criticism, mainly because embedded web servers in an Internet of Things generally
    have more limited resources than the clients who access them (such as browsers
    or mobile phones). But things have changed: recent embedded web servers with advanced
    features can be implemented with only 8 KB of memory. Thanks to efficient cross-layer
    TCP/HTTP optimizations, they can run on tiny embedded systems or even smart cards.
    Also, thanks to the massive developments in the JavaScript community, it has become
    increasingly easy to shift a lot of the workload from devices to client applications
    and even to the cloud.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一愿景变为现实一直是我们在2007年启动的物联网社区的目标.^([[2](#ch01fn02)]) 使用HTTP和其他网络标准或工具与嵌入式设备交互对我们来说非常合理。当时，这个想法似乎是不切实际的，甚至毫无意义，我们受到了不少批评，主要是因为物联网中的嵌入式网络服务器通常比访问它们的客户端（如浏览器或手机）拥有更有限的资源。但情况已经改变：最近具有高级功能的嵌入式网络服务器只需8
    KB的内存即可实现。多亏了高效的跨层TCP/HTTP优化，它们可以在微小的嵌入式系统或智能卡上运行。此外，多亏了JavaScript社区的巨大发展，将大量工作负载从设备转移到客户端应用程序甚至云端的操作变得越来越容易。
- en: ²
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://webofthings.org](http://webofthings.org)'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://webofthings.org](http://webofthings.org)'
- en: In the Web of Things, devices and their services are fully integrated in the
    web because they use the same standards and techniques as traditional websites.
    This means that you can write applications that interact with embedded devices
    in exactly the same way as you would interact with any other web service that
    uses web APIs—in particular, RESTful architectures.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中，设备和它们的服务完全集成在网络上，因为它们使用与传统网站相同的标准和技巧。这意味着你可以编写与嵌入式设备交互的应用程序，就像你与任何其他使用网络API的Web服务交互一样——特别是RESTful架构。
- en: As we’ll describe in [chapter 6](kindle_split_014.html#ch06), REST is an architectural
    style for developing distributed applications and is the basis upon which the
    modern web is built. The essence of REST is to focus on creating loosely coupled
    services that can be easily reused, which are implemented using URIs, HTTP, and
    standardized media types. Abstracting the services from their application-specific
    semantics thanks to a uniform interface (HTTP verbs and response codes) makes
    it easy to build loosely coupled services because it provides a simple mechanism
    for clients to select the best possible representations for interactions. This
    makes the web the ideal substrate to build a universal architecture and application
    programming interface (API) to interact with Things, as shown in [figure 1.5](#ch01fig05).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](kindle_split_014.html#ch06)中将要描述的，REST是一种用于开发分布式应用程序的架构风格，是现代网络的基础。REST的本质是专注于创建松散耦合的服务，这些服务可以轻松重用，并使用URI、HTTP和标准化的媒体类型实现。由于统一的接口（HTTP动词和响应代码）抽象了服务的应用特定语义，因此它使得构建松散耦合的服务变得容易，因为它为客户端提供了一个简单的机制来选择最佳可能的交互表示。这使得网络成为构建通用架构和应用程序编程接口（API）的理想基础，如图1.5所示。
- en: Figure 1.5\. The Web of Things is the ability to use modern web standards on
    embedded devices. By using all these standards for Internet of Things scenarios,
    we both enable new types of interactive applications to be built and make sure
    that devices can be integrated with modern web applications and services with
    minimal effort.
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.5\. 物联网是能够在嵌入式设备上使用现代网络标准的能力。通过使用所有这些标准来处理物联网场景，我们既能够构建新的交互式应用程序类型，又确保设备可以以最小的努力集成到现代网络应用程序和服务中。
- en: '![](01fig05_alt.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig05_alt.jpg)'
- en: In practice, this means you can start interacting with Things via web browsers
    and explore the Web of Things as you would surf the web (via links to other related
    Things). Real-time data collected from distributed sensors can then be easily
    retrieved, processed, and displayed on web pages using HTML, CSS, and JavaScript.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着您可以通过网络浏览器开始与事物互动，就像您在网上冲浪（通过链接到其他相关事物）一样探索物联网。然后可以轻松检索、处理和显示在网页上，使用HTML、CSS和JavaScript。
- en: In contrast to many protocols and standards existing in the Internet of Things,
    the programming model behind the Web of Things is significantly easier to learn
    and to use. This is particularly interesting because it enables anyone with basic
    web programming skills to build websites and applications, not only around multimedia
    content but also with real-time data from the physical world, as [figure 1.6](#ch01fig06)
    illustrates.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与物联网中存在的许多协议和标准相比，物联网背后的编程模型更容易学习和使用。这一点特别有趣，因为它使任何具有基本网络编程技能的人都能构建网站和应用，不仅围绕多媒体内容，还可以使用来自物理世界的实时数据，如图1.6所示。
- en: Figure 1.6\. The Web of Things allows developers and applications to exchange
    data with any physical object or device using standard HTTP requests, regardless
    of how the device is connected.
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6\. 物联网允许开发者和应用程序使用标准的HTTP请求与任何物理对象或设备交换数据，无论设备如何连接。
- en: '![](01fig06_alt.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig06_alt.jpg)'
- en: Although the Web of Things emphasizes the use of web standards to exchange data
    between devices, it doesn’t imply anything about how the devices should be physically
    connected to each other. In other words, devices can (but don’t have to) be openly
    connected to the web and publicly accessible by anyone just like websites. The
    Web of Things works equally well in a local network (for example, the intranet
    of your company or your Wi-Fi network at home).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管物联网强调使用网络标准在设备之间交换数据，但它并没有涉及设备之间应该如何物理连接。换句话说，设备可以（但不必）公开连接到网络，任何人都可以像访问网站一样公开访问它们。物联网在本地网络（例如，您公司的内部网络或您家的Wi-Fi网络）中同样工作得很好。
- en: In some cases, it makes sense for Things to have a public URL and be openly
    accessible over the web—for example, traffic or pollution sensors in a city operated
    by the public authorities. In this case, devices could also be crawled and indexed
    by search engines like any other web page and allow users to literally Google
    the physical world or bookmark the URL of a smart object and share it with friends.
    Web-connected objects can also become active and participate in the web just like
    other users by publishing their own blogs or talking to each other using the APIs
    of services such as Twitter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，让事物拥有公共URL并在网络上公开访问是有意义的——例如，由公共当局运营的城市交通或污染传感器。在这种情况下，设备也可以像任何其他网页一样被搜索引擎抓取和索引，并允许用户在物理世界中“谷歌”或为智能对象的URL设置书签并与朋友分享。网络连接的对象也可以像其他用户一样变得活跃并参与网络，通过发布自己的博客或使用如Twitter等服务的API相互交谈。
- en: Using services such as IFTTT,^([[3](#ch01fn03)]) users can create small, logical
    rules that mix real-world devices such as sensors in their home with virtual services
    in the cloud; for example, an SMS gateway or a weather forecast service. Such
    applications are called *physical mashups* and are the topic of [chapter 10](kindle_split_018.html#ch10),
    where you’ll learn the principles and tools that will allow you to create physical
    mashups on top of your Things.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如IFTTT等服务，用户可以创建小型的、逻辑上的规则，将现实世界中的设备，如家中的传感器，与云中的虚拟服务混合；例如，一个短信网关或天气预报服务。这样的应用被称为*物理混搭*，这是第10章的主题，你将学习到创建物理混搭所需的原则和工具。
- en: ³
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://ifttt.com/](https://ifttt.com/)'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://ifttt.com/](https://ifttt.com/)'
- en: To really understand why the Web of Things represents an interesting next stage
    in the evolution of the IoT, we first need to look at the history of this field
    up to today. Why did the idea of connected devices emerge in the first place?
    And if the vision of a global network of connected devices is so promising, why
    doesn’t it exist yet? We attempt to answer these questions in the next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解为什么物联网络代表了物联网演变中的一个有趣的新阶段，我们首先需要回顾这一领域至今的历史。为什么连接设备的想法最初会出现？如果全球连接设备的愿景如此有希望，为什么它还没有实现？我们将在下一节尝试回答这些问题。
- en: 1.2.3\. The Internet of Things—a brief history
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 物联网——简史
- en: 'To understand where the notion of the Internet of Things comes from, we have
    to look into a field of computer science research that goes by many names, most
    commonly *ubiquitous computing* or *pervasive computing*. One of the founding
    fathers of this discipline was Mark Weiser. While leading the Xerox PARC research
    lab in the early ‘90s, Weiser started to think about the next wave of computers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解物联网这一概念从何而来，我们必须探究一个名为计算机科学研究的领域，它有许多名称，最常见的是*普适计算*或*泛在计算*。这一学科的创始人之一是马克·魏斯。在20世纪90年代初领导施乐帕克研究中心时，魏斯开始思考计算机的下一波浪潮：
- en: '*The most profound technologies are those that disappear. They weave themselves
    into the fabric of everyday life until they are indistinguishable from it....
    Silicon-based information technology, in contrast, is far from having become part
    of the environment. More than 50 million personal computers have been sold, and
    nonetheless the computer remains largely in a world of its own. It is approachable
    only through complex jargon that has nothing to do with the tasks for which people
    actually use computers.*'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*最深刻的技术是那些消失的技术。它们融入日常生活的织物中，直到它们与日常生活无法区分……基于硅的信息技术，相比之下，远未成为环境的一部分。已经售出了超过5000万台个人电脑，但电脑仍然主要存在于自己的世界中。人们只能通过与人们实际使用电脑的任务无关的复杂术语来接近它。*'
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Mark Weiser, “The Computer for the Twenty-First Century,” 1991*'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*马克·魏斯，《21世纪的计算机》，1991*'
- en: What Weiser understood before anyone else was that computers were clearly evolving
    from the big, bulky boxes on desktops and in offices toward smaller and smarter
    devices that would soon be seamlessly embedded everywhere in the world around
    us and become invisible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 魏斯比其他人更早地理解到，计算机显然正在从桌面和办公室中的大型、笨重的盒子向更小、更智能的设备发展，这些设备很快将无缝地嵌入我们周围的世界中，变得无影无踪。
- en: The years that followed 1991 were the early years of the internet we know today,
    which has grown into a massive public global network of computers, thanks to the
    invention, by Sir Tim Berners-Lee, and development of the web (HTTP and HTML)—the
    Application layer on top of the internet.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 1991年之后的几年是我们今天所知道的互联网的早期年份，它已经成长为一个庞大的公共全球计算机网络，这得益于蒂姆·伯纳斯-李爵士的发明和网络的开发（HTTP和HTML）——互联网的顶层应用层。
- en: No wonder the stunning success of the internet had a strong impact on the ubiquitous
    computing research community. A number of researchers started to think about connecting
    physical objects to the internet. In particular, these included researchers from
    the Auto-ID Labs (an international cluster of research laboratories originally
    founded at MIT), such as Sanjay Sarma, Kevin Ashton, David Brock, and Daniel Engels
    at MIT and Friedemann Mattern and Elgar Fleisch at ETH Zurich. Their primary focus
    was on automatically identifying goods using radio frequency identification (RFID)
    tags in order to create a global network of electronically tagged products and
    to be able to optimize logistics and supply chains. Looking for a term to describe
    this global network, Kevin Ashton came up with the term *Internet of Things*.^([[4](#ch01fn04)])
    The rest is history.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网惊人的成功对无处不在的计算研究社区产生了深远的影响。许多研究人员开始思考将物理对象连接到互联网。特别是，这些人包括来自MIT的Auto-ID实验室（一个最初在MIT成立的国际研究实验室集群）的研究人员，如Sanjay
    Sarma、Kevin Ashton、David Brock和Daniel Engels，以及ETH Zurich的Friedemann Mattern和Elgar
    Fleisch。他们的主要焦点是利用射频识别（RFID）标签自动识别商品，以创建一个全球电子标签产品网络，并能够优化物流和供应链。为了找到一个描述这个全球网络的术语，Kevin
    Ashton提出了“物联网”这个术语。其余的都是历史。
- en: ⁴
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.rfidjournal.com/articles/view?4986](http://www.rfidjournal.com/articles/view?4986)'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.rfidjournal.com/articles/view?4986](http://www.rfidjournal.com/articles/view?4986)'
- en: Although the term *Internet of Things* was coined in 1999, this concept has
    remained under the radar of the general public until the last few years, when
    people realized it was more than just a trendy term. According to Google Trends,
    since December 2013 the term *Internet of Things* clearly took over *Web 2.0*
    in news headlines ([figure 1.7](#ch01fig07)). Although Web 2.0 has been one of
    the most popular emerging web trends of the 2000s, in the last few years it has
    faded away from the spotlight as the popularity of the Internet of Things has
    grown exponentially.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在1999年就提出了“物联网”这个术语，但这个概念直到最近几年才被公众所关注，当时人们意识到它不仅仅是一个时髦的术语。根据Google Trends的数据，自2013年12月以来，“物联网”这个术语在新闻标题中明显超过了“Web
    2.0”。[图1.7](#ch01fig07)。尽管Web 2.0是2000年代最受欢迎的互联网新兴趋势之一，但在过去几年中，随着物联网的指数级增长，它已经从聚光灯下淡出。
- en: 'Figure 1.7\. Since December 2013, the term *Internet of Things* has become
    more popular in news headlines than *Web 2.0.* [Source: Google Trends, September
    25, 2015]'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7。自2013年12月以来，“物联网”这个术语在新闻标题中的流行度已经超过了“Web 2.0”。[来源：Google Trends，2015年9月25日]
- en: '![](01fig07_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig07_alt.jpg)'
- en: 'When Google acquired NEST for a “modest” $3.3 billion USD in December 2013,
    a collective “Aha!” moment took place: *Hold on! There is actually money to be
    made with the Internet of Things*. And lots of it! In 2014, Gartner predicted
    a population of over 25 billion connected devices by 2020.^([[5](#ch01fn05)])
    Cisco was a bit more optimistic and predicted that by 2020 there would be more
    than 50 billion Things connected to the internet.^([[6](#ch01fn06)])'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当谷歌在2013年12月以“适度”的33亿美元收购NEST时，发生了一个集体“啊哈！”的时刻：“等等！实际上可以从物联网中赚到钱。而且还有很多！2014年，Gartner预测到2020年将有超过250亿个连接设备。[参考文献5](#ch01fn05)]思科则更为乐观，预测到2020年将有超过500亿个设备连接到互联网。[参考文献6](#ch01fn06)]
- en: ⁵
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.gartner.com/newsroom/id/2905717](http://www.gartner.com/newsroom/id/2905717)'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.gartner.com/newsroom/id/2905717](http://www.gartner.com/newsroom/id/2905717)'
- en: ⁶
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.cisco.com/web/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf](https://www.cisco.com/web/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf)'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.cisco.com/web/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf](https://www.cisco.com/web/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf)'
- en: 'It doesn’t really matter who is right or wrong because one thing is certain:
    in the next decade, there will be a lot more internet-connected devices around
    us. A significant milestone was reached in 2008 when the number of Things connected
    to the Internet exceeded the number of people. In consequence, many of the largest
    companies in the world, from Cisco to Samsung to IBM, mentioned the IoT as a key
    strategic investment in 2014.^([[7](#ch01fn07)])'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 究竟谁对谁错并不重要，因为有一点是确定的：在下一个十年里，我们周围将会有更多互联网连接的设备。2008年是一个重要的里程碑，当时连接到互联网的“事物”数量超过了人类数量。因此，从思科到三星再到IBM，世界上许多最大的公司都在2014年将物联网视为一项关键的战略投资。（[[7](#ch01fn07)]）
- en: ⁷
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://postscapes.com/internet-of-things-investment](http://postscapes.com/internet-of-things-investment)'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[物联网投资](http://postscapes.com/internet-of-things-investment)'
- en: We can learn two things from this sudden interest in the Internet of Things.
    First, regardless of whether you are a back-end guru, a front-end developer, or
    a hobbyist hacker, now is the ideal time to brush up on your Internet of Things
    skills. Second, the years of the Intranet of Things, where Things only ever communicate
    in their own little world, are numbered. But for the IoT to become a reality and
    unleash its potential, all those objects need to speak the same language. For
    devices and applications to interact with each other easily, securely, and in
    an ad hoc manner, we need a universal and open standard that promotes loose coupling,
    scalability, and flexibility.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从对物联网的突然兴趣中学习到两点。首先，无论你是后端大牛、前端开发者还是业余黑客，现在正是提升你的物联网技能的理想时机。其次，那些事物只在自己的小世界里相互通信的内联网时代已经为数不多。但是，为了让物联网成为现实并释放其潜力，所有这些物体都需要说同一种语言。为了设备和应用程序能够轻松、安全、灵活地相互交互，我们需要一个通用和开放的标准，它能够促进松散耦合、可扩展性和灵活性。
- en: 1.3\. Use cases—why connected objects?
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 用例——为什么是连接的对象？
- en: It would be incorrect to ask when the IoT will be here because it already is.
    Countless examples can be found everywhere today. Your smart TV connects to the
    internet and records the shows you prefer to watch. The Nike+ sensor in your shoes
    uploads all your runs to the internet so you can compete with your friends. And
    your mobile phone streams your location so you can track it or disable it remotely
    if it gets stolen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 询问物联网何时到来是不正确的，因为它已经在这里了。今天到处都可以找到无数的例子。你的智能电视连接到互联网并记录你喜欢的节目。你的鞋中的Nike+传感器将你所有的跑步记录上传到互联网，这样你可以与朋友竞争。你的手机流式传输你的位置，这样你可以跟踪它，或者如果它被偷了，你可以远程禁用它。
- en: Nonetheless, the IoT is still in its early teenage years and will certainly
    influence our world in a much more profound way than these early use cases did.
    Let’s look at the areas where the IoT will most likely have a big impact. This
    is an opportunity to see what benefits the Web of Things can bring to multiple
    areas. Hopefully, this will inspire you for your future weekend hacks or more
    serious product developments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，物联网仍然处于其青少年早期阶段，并且肯定会以比这些早期用例更深远的方式影响我们的世界。让我们看看物联网最有可能产生重大影响的领域。这是一个看到物联网如何为多个领域带来好处的机会。希望这能激发你未来周末的破解或更严肃的产品开发。
- en: 1.3.1\. Wireless sensor networks and distributed sensing
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1. 无线传感器网络和分布式传感
- en: The incredible progress in computing in the ‘80s and ‘90s, especially the miniaturization
    of embedded computers and radio networking chips, led to the emergence in the
    early 2000s of wireless sensor networks (WSNs). Those networks are composed of
    tiny, single-board computers such as the ones shown in [figure 1.8](#ch01fig08).^([[8](#ch01fn08)])
    Those devices, being cheap and battery-powered, could be deployed in large areas
    to continuously monitor various physical environments or structures using a multitude
    of sensors. For example, WSNs have been used to monitor the structure of historical
    buildings such as the Torre Aquila in Italy,^([[9](#ch01fn09)]) to understand
    the impact of humans on bird habitats,^([[10](#ch01fn10)]) and to monitor agricultural
    crops for food production.^([[11](#ch01fn11)])
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代和90年代计算领域的惊人进步，尤其是嵌入式计算机和无线网络芯片的微型化，导致了无线传感器网络（WSNs）在21世纪初的出现。这些网络由如[图1.8](#ch01fig08)中所示的小型单板计算机组成。这些设备由于价格低廉、电池供电，可以在大范围内部署，使用多种传感器连续监测各种物理环境或结构。例如，WSNs已被用于监测意大利的托雷阿基拉等历史建筑的结构，[[9](#ch01fn09)]以了解人类对鸟类栖息地的影响，[[10](#ch01fn10)]以及监测农作物以促进食品生产。[11](#ch01fn11)）
- en: ⁸
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/List_of_wireless_sensor_nodes](http://en.wikipedia.org/wiki/List_of_wireless_sensor_nodes)'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/List_of_wireless_sensor_nodes](http://en.wikipedia.org/wiki/List_of_wireless_sensor_nodes)'
- en: ⁹
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://d3s.disi.unitn.it/projects/torreaquila](http://d3s.disi.unitn.it/projects/torreaquila)'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://d3s.disi.unitn.it/projects/torreaquila](http://d3s.disi.unitn.it/projects/torreaquila)'
- en: ^(10)
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.cs.berkeley.edu/~culler/papers/wsna02.pdf](http://www.cs.berkeley.edu/~culler/papers/wsna02.pdf)'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.cs.berkeley.edu/~culler/papers/wsna02.pdf](http://www.cs.berkeley.edu/~culler/papers/wsna02.pdf)'
- en: ^(11)
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.mdpi.com/1424-8220/9/6/4728/htm](http://www.mdpi.com/1424-8220/9/6/4728/htm)'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.mdpi.com/1424-8220/9/6/4728/htm](http://www.mdpi.com/1424-8220/9/6/4728/htm)'
- en: Figure 1.8\. Three generations of wireless sensor nodes
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8\. 三代无线传感器节点
- en: '![](01fig08_alt.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig08_alt.jpg)'
- en: Although early WSN deployments weren’t connected to the internet, these systems
    influenced the IoT in many ways because this prolific research community gave
    birth to innovative ideas that shaped IoT technologies. The techniques, tools,
    and protocols developed for WSNs made it possible to use low-power platforms for
    large-scale distributed sensing applications in the real world.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管早期的无线传感器网络（WSN）部署并未连接到互联网，但这些系统以多种方式影响了物联网（IoT），因为这一富有成果的研究社区孕育了塑造物联网技术的创新思想。为WSN开发的技巧、工具和协议使得在现实世界中能够使用低功耗平台进行大规模分布式传感应用成为可能。
- en: The requirements and operating context of those devices also gave birth to a
    number of operating systems optimized for low-power sensing, such as TinyOS^([[12](#ch01fn12)])
    or Contiki.^([[13](#ch01fn13)]) Indeed, when battery-powered devices are deployed
    in natural and unpredictable environments, it’s essential to ensure robustness
    and minimal energy consumption because human intervention to debug or fix software
    and hardware problems—or even to change the batteries—is clearly impractical.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备的需要和操作环境也催生了许多针对低功耗传感优化的操作系统，例如TinyOS^([[12](#ch01fn12)])或Contiki.^([[13](#ch01fn13)])。实际上，当电池供电的设备部署在自然和不可预测的环境中时，确保其鲁棒性和最小能耗是至关重要的，因为人工干预来调试或修复软件和硬件问题——甚至更换电池——显然是不切实际的。
- en: ^(12)
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.tinyos.net](http://www.tinyos.net)'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.tinyos.net](http://www.tinyos.net)'
- en: ^(13)
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.contiki-os.org](http://www.contiki-os.org)'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.contiki-os.org](http://www.contiki-os.org)'
- en: WSNs and the Web of Things
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无线传感器网络（WSN）和物联网（IoT）
- en: It’s clear that the majority of WSN devices weren’t designed for the public.
    Those platforms were intended to be mainly programmed by experts. Although web
    protocols are heavier (more verbose) than the optimized protocols used on embedded
    devices, there has been a lot of progress in optimized HTTP libraries that run
    on constrained devices.^([[14](#ch01fn14)]) Additionally, devices are becoming
    increasingly powerful and many come with Wi-Fi connectivity on board. The ability
    to interact with embedded sensors using standard web protocols makes the collection,
    storage, and analysis of data from heterogeneous sensors much simpler. Indeed,
    integrating data across several cloud services is much faster thanks to the simplicity
    and ubiquity of REST APIs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，大多数WSN设备并非为公众设计。这些平台主要是由专家编程的。尽管Web协议比嵌入式设备上使用的优化协议更复杂（更冗长），但针对受限设备的优化HTTP库已经取得了很大进展.^([[14](#ch01fn14)])
    此外，设备变得越来越强大，许多设备都内置了Wi-Fi连接。使用标准Web协议与嵌入式传感器交互的能力使得从异构传感器收集、存储和分析数据变得更加简单。实际上，由于REST
    API的简单性和普遍性，跨多个云服务集成数据要快得多。
- en: ^(14)
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://research.microsoft.com/pubs/73067/tws.pdf](http://research.microsoft.com/pubs/73067/tws.pdf)'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://research.microsoft.com/pubs/73067/tws.pdf](http://research.microsoft.com/pubs/73067/tws.pdf)'
- en: 1.3.2\. Wearables and quantified self
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. 可穿戴设备和量化自我
- en: Another interesting use case for the IoT is building tiny sensors that people
    can carry or wear to passively monitor their daily activities or even body factors
    such as heartbeats or chemicals in their blood or sweat. Heartbeat monitors have
    long been commercialized for long-distance runners to keep track of and regulate
    their heart activity. A major breakthrough in this domain was the Nike+, which
    was easy to use and could connect out of the box to an iPhone (see [figure 1.9](#ch01fig09)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（IoT）的另一个有趣用例是制造人们可以携带或佩戴的小型传感器，以被动地监控他们的日常活动，甚至监测身体因素，如心跳或血液或汗液中的化学物质。心跳监测器长期以来一直被商业化，用于长跑运动员跟踪和调节他们的心脏活动。这一领域的重大突破是Nike+，它易于使用，并且可以开箱即用地连接到iPhone（见图1.9）。
- en: Figure 1.9\. The Nike+ ecosystem was one of the pioneers in the quantified self
    or wearables trend. [Photo by ivyfield on Flickr licensed under CC BY 2.0]
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9.耐克+生态系统是量化自我或可穿戴趋势的先驱之一。[照片由Flickr上的ivyfield提供，授权使用CC BY 2.0]
- en: '![](01fig09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig09.jpg)'
- en: This trend has experiences a boom in the last few years with many more products
    ranging from activity trackers,^([[15](#ch01fn15)]) to smart scales connected
    to your phone helping you to control your weight and body fat,^([[16](#ch01fn16)])
    to smart pedals tracking your rides and working as antitheft devices,^([[17](#ch01fn17)])
    to smart pillows, smart pill boxes, alarm clocks, and smart watches giving you
    access to a whole new world of information about yourself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种趋势在过去的几年中经历了繁荣，产品种类繁多，从活动追踪器，^([[15](#ch01fn15)]) 到连接到您的手机的智能秤，帮助您控制体重和体脂，^([[16](#ch01fn16)))
    到智能踏板跟踪您的骑行并作为防盗设备，^([[17](#ch01fn17))) 到智能枕头、智能药盒、闹钟和智能手表，让您能够访问关于自己的全新信息世界。
- en: ^(15)
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example: [http://misfit.com](http://misfit.com) or [https://jawbone.com/up](https://jawbone.com/up)'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如：[http://misfit.com](http://misfit.com) 或 [https://jawbone.com/up](https://jawbone.com/up)
- en: ^(16)
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(16)
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.withings.com/us/en/products/smart-body-analyzer](http://www.withings.com/us/en/products/smart-body-analyzer)'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.withings.com/us/en/products/smart-body-analyzer](http://www.withings.com/us/en/products/smart-body-analyzer)'
- en: ^(17)
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(17)
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://connectedcycle.com](http://connectedcycle.com)'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://connectedcycle.com](http://connectedcycle.com)'
- en: Wearables and the Web of Things
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可穿戴设备和物联网
- en: Integrating wearable and quantified self devices on the web, so that the data
    is directly accessible by other devices and applications, will make it much easier
    to develop new classes of extensible applications for elder care, health and fitness,
    or fun and sports. It will also ensure you don’t need a separate app for each
    of them (with interesting security and privacy challenges that we’ll discuss in
    [chapter 9](kindle_split_017.html#ch09)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将可穿戴设备和量化自我设备集成到网络中，以便数据可以直接由其他设备和应用程序访问，将使开发新的可扩展应用程序类别（如养老服务、健康和健身、娱乐和体育）变得容易得多。它还将确保您不需要为每个它们都安装一个单独的应用程序（我们将在第9章中讨论的有趣的隐私和安全挑战）。
- en: As illustrated by Nike’s success story, early wearable devices focused on the
    social aspects of sports by sharing and comparing personal data such as race times,
    distances, and so on. Here again, the Web of Things helps because it allows a
    seamless connection between wearable devices and social networks on the web.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如耐克的成功故事所示，早期的可穿戴设备专注于体育的社会方面，通过分享和比较个人数据，如比赛时间、距离等。在这里，物联网再次发挥了作用，因为它允许可穿戴设备与网络上的社交网络无缝连接。
- en: 1.3.3\. Smart homes and buildings
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3.智能家居和建筑
- en: In the ‘60s and ‘70s, the house of the future was envisioned as an entirely
    automated and responsive system, like the ones you could see in *The Jetsons*
    or *Star Trek*. Doors would open automatically; food and coffee would be made
    by robots and readily served as soon as you pop out of your bed. Your environment
    would make your life easier and take care of everything you needed when you needed
    it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代和70年代，未来的房子被设想为一个完全自动化和响应的系统，就像你在《杰森一家》或《星际迷航》中看到的那样。门会自动打开；食物和咖啡将由机器人制作并随时准备好，一旦你从床上跳起来。你的环境会使你的生活变得更轻松，并在你需要的时候照顾好你需要的一切。
- en: '*Domotics*—the technical term for smart and connected homes—became all the
    rage in the 2000s, and these systems included entertainment systems, lighting
    systems, heating, ventilation, air-conditioning systems (HVAC), and so on. But
    smart homes existed way before the Internet of Things was invented. The most important
    difference between the legacy systems and the second wave of smart homes is the
    use of internet or internet-friendly protocols, pushing home automation away from
    the world of proprietary systems by connecting devices directly to the internet
    or through residential gateways.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能家居*——智能和连接式家庭的术语——在21世纪初变得非常流行，这些系统包括娱乐系统、照明系统、供暖、通风、空调系统（HVAC）等等。但是，在物联网发明之前，智能家居就已经存在了。传统系统与智能家居第二波之间的最重要的区别是使用互联网或互联网友好型协议，通过将设备直接连接到互联网或通过家庭网关连接，将家庭自动化从专有系统世界推向了互联网。'
- en: Interestingly enough, this trend toward digitalizing our homes went even further
    with the development of open-source hardware and software platforms such as Arduino.^([[18](#ch01fn18)])
    Indeed, many amateurs started hacking around and connecting various bits in their
    houses. From energy and gas meters to lighting and presence detectors, amateur
    developers were suddenly interested and empowered to connect their houses to the
    internet.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，随着开源硬件和软件平台（如Arduino）的发展，这种将我们的家庭数字化的趋势甚至进一步发展了.^([[18](#ch01fn18)])
    确实，许多业余爱好者开始在家中破解并连接各种部件。从能源和煤气表到照明和存在探测器，业余开发者突然对将他们的房屋连接到互联网产生了兴趣并获得了能力。
- en: ^(18)
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.arduino.cc](http://www.arduino.cc)'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.arduino.cc](http://www.arduino.cc)'
- en: Smart homes and the Web of Things
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 智能家居和物联网
- en: The smart home environment is probably symptomatic of the (too) vast number
    of standards and protocols that exist for connecting things to networks. Although
    all devices in your home should talk to each other, they can’t because those protocols
    are incompatible and you end up with more apps and remote controls than ever before.
    The Web of Things offers an alternative approach where web languages are the baseline,
    the minimal API that devices should offer either directly or indirectly through
    gateways. In our own company—EVRYTHNG^([[19](#ch01fn19)])—we used the Web of Things
    approach to connect, at scale, a number of home automation devices from different
    manufacturers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 智能家居环境可能是连接事物到网络存在的（过于）众多标准和协议的一个典型例子。尽管你家里的所有设备都应该相互通信，但由于这些协议不兼容，你最终会拥有比以往更多的应用程序和遥控器。物联网提供了一种替代方法，其中网络语言是基础，设备应直接或通过网关间接提供的最小API。在我们自己的公司——EVRYTHNG^([[19](#ch01fn19)])——我们使用了物联网方法，以规模连接了来自不同制造商的许多智能家居设备。
- en: ^(19)
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(19)
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://evrythng.com](http://evrythng.com)'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://evrythng.com](http://evrythng.com)'
- en: The Web of Things allows interoperability between devices from different manufacturers
    and fosters cross-device applications. It also makes it possible for a larger
    group of amateurs to buy all sorts of devices, build rapidly their smart home
    systems, and especially reuse and customize these systems easily for their unique
    needs and desires.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网允许不同制造商的设备之间实现互操作性，并促进跨设备应用的发展。它还使得更大范围的业余爱好者能够购买各种设备，快速构建他们的智能家居系统，并且特别容易根据他们的独特需求和愿望对这些系统进行重用和定制。
- en: 1.3.4\. Smart cities and energy grids
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4. 智能城市和能源网格
- en: One of the most promising use cases for the Internet of Things might well be
    the emergence of smart cities. As more humans move from rural areas to cities
    each year, it becomes clear that changes are necessary to the way large cities
    are designed and operate to ensure the safety and well-being of their inhabitants.
    The ability to monitor urban environments in real time thanks to a plethora of
    sensors and computers is an incredibly promising substrate to make our cities
    smarter and more efficient.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网最有希望的应用案例之一可能是智能城市的出现。随着每年越来越多的人从农村地区迁移到城市，很明显，为了确保其居民的安全和福祉，需要对大型城市的设计和运营方式做出改变。由于有大量传感器和计算机，能够实时监控城市环境是一个非常有前景的基础，可以使我们的城市更智能、更高效。
- en: 'Smart cities have always been at the heart of what WSN researchers do: getting
    more insights about our environment based on data gathered by tiny computers.
    But most of this work was based on an asynchronous and linear workflow:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 智能城市一直是WSN研究人员工作的核心：基于由微型计算机收集的数据，更多地了解我们的环境。但大部分这项工作都是基于异步和线性工作流程：
- en: '**1**.  Deploy wireless sensor nodes.'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 部署无线传感器节点。'
- en: '**2**.  Collect data.'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 收集数据。'
- en: '**3**.  Analyze data in the lab.'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 在实验室分析数据。'
- en: '**4**.  Write reports.'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 编写报告。'
- en: '**5**.  Take actions based on these reports.'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 基于这些报告采取行动。'
- en: The Internet of Things gives new dimension to this domain by drastically short-circuiting
    the required steps. The data is now available on the internet as real-time streams
    upon which direct actions can be taken. These can be used to monitor safety, traffic,
    or utilities (water, waste disposal, and more) in real time and react rapidly
    when any anomaly is detected—ideally before a serious problem occurs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网通过大幅缩短所需步骤，为这个领域带来了新的维度。数据现在作为实时流在互联网上可用，可以直接采取行动。这些可以用于实时监控安全、交通或公用事业（水、废物处理等），并在检测到任何异常时迅速反应——理想情况下在严重问题发生之前。
- en: The interest in smart cities has significantly increased in the past few years
    with a number of cities betting a lot on the potential of the Internet of Things,
    such as Milton Keynes in the UK,^([[20](#ch01fn20)]) Santander in Spain,^([[21](#ch01fn21)])
    New York in the United States,^([[22](#ch01fn22)]) and Songdo in South Korea.^([[23](#ch01fn23)])
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，对智慧城市的兴趣显著增加，许多城市都押注于物联网的潜力，例如英国的米尔顿凯恩斯市^([20](#ch01fn20))、西班牙的桑坦德市^([21](#ch01fn21))、美国的纽约市^([22](#ch01fn22))和韩国的松岛市^([23](#ch01fn23))。
- en: ^(20)
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([20](#ch01fn20))
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.mksmart.org](http://www.mksmart.org)'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.mksmart.org](http://www.mksmart.org)'
- en: ^(21)
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([21](#ch01fn21))
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.smartsantander.eu](http://www.smartsantander.eu)'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.smartsantander.eu](http://www.smartsantander.eu)'
- en: ^(22)
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([22](#ch01fn22))
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://nycopendata.socrata.com](https://nycopendata.socrata.com)'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://nycopendata.socrata.com](https://nycopendata.socrata.com)'
- en: ^(23)
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([23](#ch01fn23))
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.bbc.co.uk/news/technology-23757738](http://www.bbc.co.uk/news/technology-23757738)'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.bbc.co.uk/news/technology-23757738](http://www.bbc.co.uk/news/technology-23757738)'
- en: As a stepping-stone to this vision of future cities, smart grids are using the
    Internet of Things to optimize the way we consume and distribute energy. Thanks
    to real-world services, home and industrial appliances can increasingly communicate
    their energy consumption in real time and raise consumers’ energy awareness. Furthermore,
    appliances can communicate with each other to make whole buildings smarter by
    optimizing HVAC among other things. Even more important, through composite applications
    using real-world services, industrial machinery and citywide infrastructures will
    be able to negotiate energy consumption and limit consumption peaks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实现未来城市愿景的垫脚石，智能电网正在利用物联网优化我们的能源消费和分配方式。得益于现实世界服务，家庭和工业设备可以越来越实时地交流其能源消耗，并提高消费者的能源意识。此外，设备之间可以相互通信，通过优化HVAC等方式使整个建筑更加智能。更重要的是，通过使用现实世界服务的复合应用，工业机械和城市基础设施将能够协商能源消耗并限制消费高峰。
- en: Smart cities and the Web of Things
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 智慧城市和物联网
- en: Using web standards in the context of smart cities is particularly interesting
    because they make it much easier to share sensor data with the public and make
    it easy for developers to consume real-time data about traffic, pollution, or
    public transportation in their own urban applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在智慧城市的背景下使用网络标准尤其有趣，因为它们使得与公众共享传感器数据变得更加容易，同时也让开发者能够轻松消费他们自己城市应用中的实时交通、污染或公共交通数据。
- en: 1.3.5\. Smart manufacturing and Industry 4.0
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.5. 智能制造和工业4.0
- en: Manufacturing went through three main cycles of evolution. First came the mechanization
    of production processes using water and steam power in the Industrial Era during
    the 19th century. Afterwards, mass production of goods was enabled thanks to electric
    power. The third revolution was the digital age, where electronics and computers
    made it possible to further automate production, distribution, and communication
    processes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 制造业经历了三个主要的演变周期。首先是在19世纪工业时代，利用水和蒸汽动力实现生产过程的机械化。之后，由于电力的发展，商品的大规模生产成为可能。第三次革命是数字时代，电子计算机使得进一步自动化生产、分销和通信过程成为可能。
- en: 'The IoT is enabling a fourth revolution in manufacturing and industrial systems
    commonly referred to as *Industry 4.0*. Germany has been at the forefront of this
    change driven by companies such as Bosch, Siemens, and SAP. The IoT can bring
    two main benefits to traditional industries. First is access to unparalleled amounts
    of data. Connecting machines to the internet and feeding them real-time data is
    one step toward more transparent and efficient industrial systems. Second, the
    IoT brings services to machines. Rather than being bound to a single set of operations,
    industrial machines can now offer services, making it possible to use and reuse
    these machines in combination with other machines by connecting their respective
    services. This ability will transform manufacturing machines and plants into flexible
    ecosystems of reconfigurable production lines that can rearrange themselves to
    perform any given tasks as efficiently as possible. Industry 4.0 is an ongoing
    revolution and most of the activities in this field are still taking place in
    research labs all over the world. But in the last two years, most large companies
    have actively engaged in IoT projects and products, showing that this isn’t just
    a trend: it’s a massive opportunity to reinvent any business. And it’s here to
    stay.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网正在推动制造业和工业系统第四次革命，通常被称为*工业4.0*。德国在这一变革中处于领先地位，由博世、西门子和SAP等公司推动。物联网可以为传统行业带来两大主要好处。首先是无与伦比的数据访问量。将机器连接到互联网并为其提供实时数据是朝着更透明、更高效的工业系统迈出的一步。其次，物联网为机器带来了服务。工业机器不再局限于单一的操作集，现在可以提供服务，通过连接它们各自的服务，使这些机器能够与其他机器结合使用和重复使用。这种能力将使制造机器和工厂转变为可重新配置的生产线的灵活生态系统，可以重新排列自身以尽可能高效地执行任何给定任务。工业4.0是一场持续的革命，该领域的多数活动仍在世界各地的研究实验室中进行。但在过去两年中，大多数大型公司都积极参与了物联网项目和产品，这表明这不仅仅是一个趋势：这是一个彻底重塑任何业务的巨大机会。而且它将长期存在。
- en: Industry and the Web of Things
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 行业与物联网
- en: Using web standards to interconnect all the elements in a business process,
    such as the shop-floor machinery, enterprise software, employees in various departments,
    products, customer, and suppliers, will represent a significant change in how
    companies do business. Turning all the elements in a factory into easy-to-combine
    LEGO-like bricks will make it much easier and faster for companies to adapt to
    changing environments, get their products to market more quickly, optimize their
    business and manufacturing processes, and so on. When all the actors in those
    processes are able to automatically decide how best to perform their duty based
    on real-time data, there’s no doubt that the way we design, manufacture, and distribute
    physical products will be profoundly changed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络标准将业务流程中的所有元素，如车间机械、企业软件、各部门的员工、产品、客户和供应商，相互连接，这将代表公司经营方式的重大变化。将工厂中的所有元素转变为易于组合的乐高积木，将使公司更容易、更快地适应不断变化的环境，更快地将产品推向市场，优化其业务和制造流程等。当那些流程中的所有参与者都能根据实时数据自动决定如何最好地履行其职责时，毫无疑问，我们将设计、制造和分销物理产品的方式将发生深刻的变化。
- en: 1.3.6\. Smart logistics and supply chains
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.6 智能物流与供应链
- en: As explained before, the first mention of the Internet of Things comes from
    the world of Auto-ID of the everyday consumer packaged goods (CPGs) or even the
    cheaper and short-lived fast-moving consumer goods (FMCGs). It’s no wonder that
    the world of logistics and supply chains was the first to explore the connectivity
    between all kinds of real-world objects and the internet. Indeed, the Internet
    of Things isn’t limited to devices but can include any physical object. Even if
    the object itself doesn’t have any communication capabilities, one can use a mobile
    phone or an RFID reader to recognize the product and interact with it. In consequence,
    CPGs such as food products and also more expensive and long-lived items such as
    a luxury watch or a handbag only need a machine-readable tag to be part of the
    Internet of Things.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，物联网的首次提及源于日常消费品（CPGs）或更便宜、使用寿命更短的快速消费品（FMCGs）的Auto-ID世界。物流和供应链领域成为第一个探索各种现实世界物体与互联网之间连接性的领域，这并不奇怪。实际上，物联网并不仅限于设备，它可以包括任何物理对象。即使物体本身没有任何通信能力，人们也可以使用手机或RFID阅读器来识别产品并与它互动。因此，食品产品等CPGs以及更昂贵、使用寿命更长的物品，如奢侈品手表或手袋，只需要一个可机器读取的标签就可以成为物联网的一部分。
- en: The EPCglobal network^([[24](#ch01fn24)]) was probably the first standardized
    system for applying the Internet of Things to logistics. The EPCglobal network
    is a set of standards that describe how to connect RFID-tagged objects to standard
    readers, which in turn are connected via the internet to RFID information systems
    and databases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: EPCglobal网络^([[24](#ch01fn24)])可能是第一个将物联网应用于物流的标准化系统。EPCglobal网络是一套标准，描述了如何将RFID标签对象连接到标准读取器，这些读取器再通过互联网连接到RFID信息系统和数据库。
- en: ^(24)
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((24))
- en: ''
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.gs1.org/epcglobal](http://www.gs1.org/epcglobal)'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.gs1.org/epcglobal](http://www.gs1.org/epcglobal)'
- en: 'Passive RFID tags are tiny computers that harvest energy from the electromagnetic
    field generated by nearby RFID readers. RFID tags are certainly not the only way
    to identify FMCGs, but they present a key advantage over other technologies such
    as barcodes, image recognition, or QR codes: they can be read automatically, without
    human intervention or line of sight, and they’re already widely deployed in live
    systems throughout the whole supply chain.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 被动RFID标签是小型计算机，它们从附近RFID读取器产生的电磁场中获取能量。RFID标签当然不是识别快速消费品（FMCGs）的唯一方式，但它们相对于条形码、图像识别或二维码等其他技术具有关键优势：它们可以自动读取，无需人工干预或视线，并且已经在整个供应链的实时系统中广泛部署。
- en: 'The biggest barrier of adoption for RFID in logistics and supply-chain operations
    has always been the relatively high cost of RFID, making it expensive to tag every
    object. But recent developments are producing radical changes in this space: a
    number of companies in the world have managed to print RFID tags, sensors, and
    batteries (see [figure 1.10](#ch01fig10)). In a few years, it will be easy and
    cheap to print embedded computers and sensors on products and/or their packaging.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 物流和供应链操作中RFID采用的最大障碍一直是RFID相对较高的成本，这使得为每个对象贴标签变得昂贵。但最近的发展正在这个领域产生根本性的变化：世界上的一些公司已经能够打印RFID标签、传感器和电池（见[图1.10](#ch01fig10)）。在几年内，将嵌入式计算机和传感器打印在产品及其包装上将会变得既容易又便宜。
- en: 'Figure 1.10\. A Thinfilm^([[25](#ch01fn25)]) printed NFC tag and temperature
    sensor. RFID tags, sensors, and batteries can now be printed, reducing the costs
    and allowing packages to become smart. [Source: Thinfilm, used with permission]'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.10\. Thinfilm^([[25](#ch01fn25)])打印的NFC标签和温度传感器。现在可以打印RFID标签、传感器和电池，这降低了成本，并使包装变得智能。[来源：Thinfilm，经许可使用]
- en: ^(25)
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((25))
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://thinfilm.no/products-nfc-solutions/](http://thinfilm.no/products-nfc-solutions/)'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://thinfilm.no/products-nfc-solutions/](http://thinfilm.no/products-nfc-solutions/)'
- en: '![](01fig10.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig10.jpg)'
- en: Large-scale adoption of automated identification and tracking methods on products
    will have a massive impact on supply chains, allowing them to be much more efficient
    and also to offer better services to consumers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品上大规模采用自动识别和跟踪方法将对供应链产生巨大影响，使它们变得更加高效，并且能够为消费者提供更好的服务。
- en: Smart logistics and the Web of Things
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 智能物流和物联网
- en: Imagine a web-enabled supply chain that knows in real time the temperature of
    your strawberries and can send alerts as soon as the conditions change or even
    regulate automatically the temperature of trucks, ships, and warehouses according
    to the type of the products being stored and transported—all of that information
    accessible over web APIs. Sharing historical data about devices using web standards
    will make it much easier for multiple applications to work together across the
    whole lifecycle of products. This means much lower integration costs and high
    data integrity across the different systems that will process and handle those
    products.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个能够实时了解您草莓温度的、通过互联网连接的供应链，一旦条件发生变化，它就可以发送警报，甚至可以根据存储和运输产品的类型自动调节卡车、船只和仓库的温度——所有这些信息都可以通过Web
    API访问。使用Web标准共享设备的历史数据将使多个应用程序在整个产品生命周期中协同工作变得更加容易。这意味着集成成本大大降低，并且在不同系统之间处理和操作这些产品的数据完整性很高。
- en: 1.3.7\. Marketing 2.0
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.7\. 营销2.0
- en: The ability to connect CPGs and FMCGs to the internet enables many interesting
    applications for product manufacturers and retailers, but beyond the supply chain,
    on the consumer side, it also allows new services, commonly referred to as Marketing
    2.0\. The ability to identify products with mobile phones using bar codes, QR
    codes, or image recognition makes it possible to launch personalized marketing
    campaigns by turning a product into a direct communication and service delivery
    channel between consumers and retailers. Typical applications in this field range
    from product personalization and gifting to customer loyalty, digital user guides
    and after-sales services, and personalized warranties and product recalls.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将CPG和FMCG连接到互联网的能力为产品制造商和零售商带来了许多有趣的应用，但不仅限于供应链，在消费者方面，它还允许新的服务，通常被称为营销2.0。使用手机通过条形码、二维码或图像识别来识别产品，使得将产品变成消费者和零售商之间直接沟通和服务交付渠道成为可能，从而可以启动个性化的营销活动。该领域的典型应用范围从产品个性化、送礼到客户忠诚度、数字用户指南和售后服务，以及个性化的保修和产品召回。
- en: The use of IoT technologies for marketing purposes isn’t limited to tagged products.
    Smart devices can be used to fuel the craziest and most creative (we’ll let you
    be the judge of that.) marketing campaigns as well. Examples of those are the
    Evian Drop, a small device that lets you order water directly from your fridge
    for delivery to your doorstep,^([[26](#ch01fn26)]) the Dom Pérignon button ([figure
    1.11](#ch01fig11)) that lets you order champagne at the push of a button in your
    hotel room at the prestigious Savoy Hotel in London,^([[27](#ch01fn27)]) and the
    Budweiser Red Light that glows bright red when your favorite team scores a goal.^([[28](#ch01fn28)])
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 用于营销目的的物联网技术并不仅限于贴有标签的产品。智能设备也可以用来推动最疯狂和最具创意（我们让您来评判这一点）的营销活动。这些例子包括依云水滴，一个让您可以直接从冰箱订购水并送货上门的小设备^([[26](#ch01fn26)]),
    在伦敦著名的萨沃伊酒店房间内按一下按钮就能订购香槟的Dom Pérignon按钮([图1.11](#ch01fig11)), 以及当您的最爱球队进球时亮起明亮的红灯的百威红光^([[28](#ch01fn28)])。
- en: ^(26)
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(26)
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://theinspirationroom.com/daily/2012/evian-smart-drop/](http://theinspirationroom.com/daily/2012/evian-smart-drop/)'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://theinspirationroom.com/daily/2012/evian-smart-drop/](http://theinspirationroom.com/daily/2012/evian-smart-drop/)'
- en: ^(27)
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(27)
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.altomagazine.com/newsdetails/travel/hotels/dom-prignon-at-the-press-of-a-button-4310934/](http://www.altomagazine.com/newsdetails/travel/hotels/dom-prignon-at-the-press-of-a-button-4310934/)'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.altomagazine.com/newsdetails/travel/hotels/dom-prignon-at-the-press-of-a-button-4310934/](http://www.altomagazine.com/newsdetails/travel/hotels/dom-prignon-at-the-press-of-a-button-4310934/)'
- en: ^(28)
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(28)
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.wired.com/2013/02/budweiser-red-light/](http://www.wired.com/2013/02/budweiser-red-light/)'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.wired.com/2013/02/budweiser-red-light/](http://www.wired.com/2013/02/budweiser-red-light/)'
- en: 'Figure 1.11\. The Press for DP button manages the delivery of Dom Pérignon
    champagne in Savoy Hotel rooms within a few minutes. [Source: LVMH, used with
    permission]'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.11\. 萨沃伊酒店房间内DP按钮的按压管理着Dom Pérignon香槟的配送，几分钟内完成。[来源：LVMH，经许可使用]
- en: '![](01fig11.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig11.jpg)'
- en: Marketing and the Web of Things
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 营销与万物互联
- en: Mobile applications can retrieve data about CPG and FMCG products, interact
    with them to attach digital content, and share information about them on social
    networks much quicker and more easily over the web. If every product in the world
    had its own URL and web API, it would be easy for any application to recognize
    a product and access its data without much integration effort. At EVRYTHNG we
    used our Web of Things platform to connect products to the web and deliver such
    Marketing 2.0 applications. As an example, Diageo in Brazil printed unique QR
    codes on its whiskey bottles so that their customers could attach a personalized
    message to each bottle; in that case, it was a video created on the customer’s
    smartphone for Father’s Day.^([[29](#ch01fn29)])
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序可以快速、轻松地从网络上检索CPG和FMCG产品的数据，与之互动以附加数字内容，并在社交网络上分享有关它们的信息。如果世界上每个产品都有自己的URL和Web
    API，那么任何应用程序都可以轻松识别产品并访问其数据，而无需太多的集成工作。在EVRYTHNG，我们使用我们的万物互联平台将产品连接到网络并交付此类营销2.0应用程序。例如，巴西的帝亚吉欧在其威士忌瓶上打印了独特的二维码，以便客户可以为每个瓶子附加个性化的信息；在这种情况下，这是一段在客户智能手机上为父亲节制作的视频^([[29](#ch01fn29)])。
- en: ^(29)
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(29)
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://adage.com/article/global-news/diageo-personalizes-whiskeys-videos-gift-givers/238015/](http://adage.com/article/global-news/diageo-personalizes-whiskeys-videos-gift-givers/238015/)'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://adage.com/article/global-news/diageo-personalizes-whiskeys-videos-gift-givers/238015/](http://adage.com/article/global-news/diageo-personalizes-whiskeys-videos-gift-givers/238015/)'
- en: 1.4\. The Web of Things—a supercharged Internet of Things
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 物联网之网——超级增强的物联网
- en: As described previously, the majority of IoT systems paid little attention to
    the issues of an open and large-scale system of heterogeneous devices talking
    to each other. This is partially because the IoT focused strongly on the lower
    layers of the networking stack (how data can be transmitted between actors) and
    much less on how to facilitate the development of new applications (how data can
    be collected, visualized, or processed). In particular, limited effort has been
    devoted to enable ad hoc interoperability, and consequently it’s still difficult
    to build scalable applications on top of heterogeneous devices.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数物联网系统对开放和大规模异构设备之间的通信问题关注不多。这部分的理由是因为物联网强烈关注网络堆栈的底层（数据如何在参与者之间传输），而对如何促进新应用的发展（如何收集、可视化或处理数据）关注较少。特别是，在实现即席互操作性方面投入的努力有限，因此，在异构设备之上构建可扩展的应用仍然很困难。
- en: The reason for that isn’t as much technical as it is commercial. A plethora
    of protocols for the IoT have been proposed in the last decade by standardization
    bodies, industrial alliances, and vendors. In essence this is a good thing. But
    the crude reality is that none of those standards has reached sufficient traction
    to be “the one” universal protocol for the IoT (see [figure 1.12](#ch01fig12)).
    Today, if you want a smart house, at best you’ll have to buy all components from
    the same manufacturer. Because of this, your only option to control that system
    will be through the application that comes with it. If that application has been
    designed mainly for iPhone and isn’t available on Android, well, that’s too bad.
    If that application is badly designed, is painfully slow, or doesn’t have half
    the features you need, you’re stuck with it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是技术原因，更多的是商业原因。在过去十年中，标准化机构、工业联盟和供应商提出了大量针对物联网的协议。本质上这是一个好事。但残酷的现实是，这些标准中的任何一个都没有达到足够的吸引力成为物联网的“唯一”通用协议（参见[图
    1.12](#ch01fig12)）。今天，如果你想拥有一个智能家居，最好的办法是购买来自同一制造商的所有组件。正因为如此，你控制该系统的唯一选择将是使用随附的应用程序。如果该应用程序主要针对
    iPhone 设计且在 Android 上不可用，那真是太糟糕了。如果该应用程序设计得糟糕、运行缓慢或没有你需要的半数功能，你就只能忍受它。
- en: 'Figure 1.12\. The problem with Internet of Things. The Web of Things builds
    upon and extends existing and widely used web standards so that it can use the
    whole web ecosystem in place. [Source: [http://xkcd.com/927/](http://xkcd.com/927/)
    used under Creative Commons 2.5 license]'
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.12. 物联网的问题。物联网建立在现有和广泛使用的网络标准之上，以便它可以利用整个网络生态系统。 [来源：[http://xkcd.com/927/](http://xkcd.com/927/)，根据
    Creative Commons 2.5 许可使用]
- en: '![](01fig12.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig12.jpg)'
- en: Put simply, most IoT solutions on the market today have little in common with
    the Internet—a unique, open, global network where everything is interconnected.
    The Internet of Things of today should rather be called the *Intranets* of Things,
    because it’s a set of isolated islands of functionality that weren’t designed
    to talk to each other. Even though an increasing number of networked devices offer
    APIs to control and access data about them, a custom application still needs to
    be developed specifically for each of those APIs. This is the case not only because
    different devices have different functionalities, but also because each API is
    implemented using different application protocols and has a different data model
    without a shared and standardized language.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，目前市场上的大多数物联网解决方案与互联网——一个独特、开放、全球的网络，其中一切事物都相互连接——几乎没有共同之处。今天的物联网更应该被称为“物联网内网”，因为它是一组功能孤岛，这些孤岛没有设计成可以相互通信。尽管越来越多的网络设备提供了控制它们和访问它们数据的
    API，但仍然需要为每个 API 开发特定的自定义应用程序。这种情况不仅是因为不同的设备具有不同的功能，而且是因为每个 API 都使用不同的应用程序协议，并具有不同的数据模型，而没有共享和标准化的语言。
- en: The simplicity and openness of the web and its standards (URL, HTTP, HTML, JavaScript,
    and so on) is likely what enabled the web we know today. This lingua franca enabled
    any user in the world to read any other web page without installing anything and
    has been a major factor in the success of the web. By enabling web pages, browsers,
    servers, and services to all speak the same application language, the integration
    of a large variety of content was incredibly simplified. The equivalent enabler
    has unfortunately not yet been found for devices and applications in the Internet
    of Things.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网及其标准（URL、HTTP、HTML、JavaScript等）的简单性和开放性可能是我们今天所知道的互联网得以实现的原因。这种通用语言使得世界上任何用户都能阅读任何其他网页，而无需安装任何东西，并且一直是互联网成功的主要因素之一。通过使网页、浏览器、服务器和服务都能使用相同的应用语言，大量内容的集成被极大地简化了。不幸的是，对于物联网中的设备和应用程序，尚未找到类似的推动者。
- en: In this section, we describe the limitations and problems with the existing
    approaches to IoT that don’t prioritize an open, universal, and simple Application
    layer protocol for devices. For each of those limitations, we show the benefits
    of using a Web of Things approach instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了现有物联网方法中存在的局限性以及问题，这些方法没有优先考虑为设备提供一个开放、通用和简单的应用层协议。对于这些局限性中的每一个，我们都展示了使用物联网方法带来的好处。
- en: 1.4.1\. Easier to program
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1\. 更容易编程
- en: First, let’s look at the way Things are programmed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看事物编程的方式。
- en: Internet of Things
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: The first problem with existing solutions and products today is that many of
    those protocols are complex and difficult to use. Such a high barrier for adoption,
    like the internet had in the 70s, puts the IoT out of reach for most people. Learning
    to connect to various devices that use a variety of interfaces and protocols is
    an especially arduous task that will deter the most tenacious amateur who wants
    to get started with programming their smart house. If you have any doubt about
    this, we invite you to consult the specifications of the ZigBee^([[30](#ch01fn30)])
    protocol or of the Devices Profile for Web Services (DPWS).^([[31](#ch01fn31)])
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当前现有解决方案和产品面临的首要问题是许多这些协议复杂且难以使用。这种高门槛的采用，就像70年代的互联网一样，使得物联网对大多数人来说遥不可及。学习连接使用各种接口和协议的多种设备是一项特别艰巨的任务，这将阻止最坚韧的业余爱好者开始编程他们的智能家居。如果您对此有任何疑问，我们邀请您查阅ZigBee^([[30](#ch01fn30)])协议或Web服务设备配置文件（DPWS).^([[31](#ch01fn31)])
- en: ^(30)
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(30)
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://zigbee.org/zigbee-for-developers/zigbee3-0/](http://zigbee.org/zigbee-for-developers/zigbee3-0/)'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://zigbee.org/zigbee-for-developers/zigbee3-0/](http://zigbee.org/zigbee-for-developers/zigbee3-0/)'
- en: ^(31)
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(31)
- en: ''
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://docs.oasis-open.org/ws-dd/dpws/wsdd-dpws-1.1-spec.html](http://docs.oasis-open.org/ws-dd/dpws/wsdd-dpws-1.1-spec.html)'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://docs.oasis-open.org/ws-dd/dpws/wsdd-dpws-1.1-spec.html](http://docs.oasis-open.org/ws-dd/dpws/wsdd-dpws-1.1-spec.html)'
- en: Web of Things
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: Web protocols can easily be used to read and write data from/to devices, and
    are especially much simpler to use and faster to learn than the complex IoT protocols.
    In addition, if all devices could offer a Web API, developers could use the same
    programming model to interact with any of them. Once you get the basic skills
    needed to build simple web applications, you can rapidly talk to new devices with
    minimal effort.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议可以轻松地用于从/到设备读取和写入数据，并且与复杂的物联网协议相比，使用起来更加简单，学习起来也更快。此外，如果所有设备都能提供Web API，开发者就可以使用相同的编程模型与任何设备进行交互。一旦你掌握了构建简单Web应用程序所需的基本技能，你就可以以最小的努力快速与新的设备进行通信。
- en: 1.4.2\. Open and extensible standards
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. 开放和可扩展的标准
- en: Next, we look at how open the standards are in both worlds.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看这两个世界的标准开放程度。
- en: Internet of Things
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: Another issue is that many of those protocols have been continually evolving
    as new use cases are made possible by new technological developments. Because
    some of those standards are funded and governed by one or a limited number of
    large corporations, they aren’t as neutral as a community-led open-source project.
    Besides, these companies could decide to introduce breaking changes as they wish,
    thereby rendering existing devices and applications unable to talk to each other.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是一些协议随着新技术的发展而不断演变，因为新技术使得新的用例成为可能。由于一些这些标准由一个或少数几家大型公司资助和监管，它们不如由社区领导的开源项目那样中立。此外，这些公司可以决定按照他们的意愿引入破坏性变化，从而使现有的设备和应用程序无法相互通信。
- en: Moreover, some of those standards aren’t publicly documented and can’t be simply
    used and implemented without paying a significant annual fee. This automatically
    limits, which automatically limits their adoption to only large industrial organizations.
    Closed and proprietary protocols also lead to vendor lock-in. Ensuring that switching
    to a different vendor is time- and cost-intensive is a well-known business strategy
    for big software players—nothing new here. But in an IoT context the barriers
    are much higher because switching protocols sometimes also implies changing the
    hardware (e.g. using a different radio chip). Similarly, switching application
    protocols requires firmware updates, which are hard to apply in the real world.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，其中一些标准并未公开文档，并且不能简单地使用和实施，除非支付一笔相当大的年度费用。这自动限制了它们的采用，只限于大型工业组织。封闭和专有协议也导致供应商锁定。确保切换到不同供应商需要时间和成本密集型，这是大型软件玩家众所周知的企业策略——这里没有新内容。但在物联网环境中，障碍要高得多，因为切换协议有时也意味着改变硬件（例如使用不同的射频芯片）。同样，切换应用程序协议需要固件更新，这在现实世界中很难应用。
- en: Web of Things
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: The reason web standards have reached such popularity is that they’re entirely
    open and free, so there’s virtually zero risk that they would change overnight.
    They ensure that data can be rapidly and easily moved across systems, hence HTTP
    and REST are an obvious choice when one wants to offer public access to some data.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 网络标准之所以达到如此高的普及率，是因为它们完全开放且免费，因此几乎不存在它们会一夜之间改变的零风险。它们确保数据可以快速轻松地在系统之间移动，因此当有人想要提供对某些数据的公开访问时，HTTP和REST是显而易见的选择。
- en: 1.4.3\. Fast and easy to deploy, maintain, and integrate
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.3\. 快速部署、维护和集成
- en: Let’s look at the impact on deployment, maintenance, and integration for each
    approach.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每种方法对部署、维护和集成的具体影响。
- en: Internet of Things
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: Because entire systems would need to use a single protocol, significant effort
    is required to write custom convertors for each new device or application that
    needs to be integrated. Maintenance of such a delicate assemblage of custom code
    is a risky task and in business applications would mean significant investments.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因为整个系统需要使用单个协议，因此需要大量努力为每个需要集成的新的设备或应用程序编写自定义转换器。维护这样一套精细的自定义代码集是一个风险任务，在商业应用中意味着重大的投资。
- en: Web of Things
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: There’s no risk that the web will suddenly stop working and require an upgrade.
    Yet, the limits of what can be done on the web have not ceased to be redefined
    in a decade, such as the ability to capture images from a camera or share one’s
    location. In contrast, there are always new devices and protocols in the IoT world,
    and each time one of the many protocols changes, all the other pieces of the puzzle
    that use the device need to be updated.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 网络突然停止工作并需要升级的风险并不存在。然而，过去十年中，网络上可以做的事情的界限并没有停止重新定义，例如从相机捕获图像或分享位置的能力。相比之下，物联网世界中总是有新的设备和协议，每次许多协议中的任何一个发生变化时，所有使用该设备的其他拼图部件都需要更新。
- en: 1.4.4\. Loose coupling between elements
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.4\. 元素之间的松散耦合
- en: Next, we look at the dependencies of each approach, focusing on reusability.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看每种方法的依赖关系，重点关注可重用性。
- en: Internet of Things
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: The implication of the previous sections is most importantly a tight coupling
    between the devices and applications in the network. The system works well as
    long as all pieces behave as expected and are used as intended. Sadly, this doesn’t
    leave much space for ad hoc, unplanned interactions and repurposing of services
    into new use cases, which are essential requirements in large-scale open networks
    of devices.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节的意义最重要的在于网络中设备和应用之间的紧密耦合。只要所有部件都按预期行为并按预期使用，系统就能良好运行。遗憾的是，这几乎不留空间进行即兴、未计划的交互以及将服务重新用于新的用例，而这些在大规模开放设备网络中是基本需求。
- en: Web of Things
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: HTTP is loosely coupled by design because the contract (API specification) between
    actors on the web is both simple and well defined, which leaves little room for
    ambiguity. This allows any actor to change and evolve independently from each
    other (as long as the contract doesn’t change). That’s why you can still visit
    a web page that hasn’t been updated since the early ‘90s (we’ll skip any comments
    about its visual design). The ability for devices on the Internet of Things to
    talk to new devices as they get added without requiring any firmware updates is
    essential for a global Web of Things.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP由于设计上松散耦合，因为网络中行为者之间的合同（API规范）既简单又定义良好，这留下了很少的模糊空间。这允许任何行为者独立于彼此进行更改和演变（只要合同不改变）。这就是为什么你仍然可以访问自20世纪90年代初以来未更新的网页（我们将跳过对其视觉设计的任何评论）。物联网设备在添加新设备时能够与之通信，而无需进行任何固件更新，这对于全球物联网网至关重要。
- en: 1.4.5\. Widely used security and privacy mechanisms
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.5. 广泛使用的安全和隐私机制
- en: 'The issue of personal data, privacy, and security of IoT/WoT systems has always
    been a major concern when building and deploying real-world applications. The
    two angles to consider are these:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网/物联网网系统中的个人数据、隐私和安全问题始终是构建和部署现实世界应用时的一个主要关注点。需要考虑的两个角度是这些：
- en: '***Security—*** How to ensure a system can’t be easily accessed or used in
    a harmful way by unauthorized users or systems. In other words, this is about
    ensuring that no one can access data or a device they aren’t supposed to have
    access to.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***安全——*** 如何确保系统不会被未经授权的用户或系统轻易访问或以有害方式使用。换句话说，这是关于确保没有人可以访问他们不应该访问的数据或设备。'
- en: '***User privacy—*** Assuming security is in place and only authorized and authenticated
    parties or applications can access some data, how do we ensure that no private
    information about users (for example, personal information or behavioral data—where
    the user is, what the user is doing, and the like) could be accessed or derived
    from it? This is particularly difficult because even if a piece of data available
    about a user is harmless on its own, when combined with another piece of data
    available from another sensor or system, it can be used to unambiguously identify
    a user and their behaviors.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***用户隐私——*** 假设安全措施已经到位，并且只有授权和经过身份验证的各方或应用程序可以访问某些数据，我们如何确保不会有人访问或从其中推导出有关用户的任何私人信息（例如，个人信息或行为数据——用户在哪里，用户在做什么等）？这尤其困难，因为即使关于用户的某些数据本身无害，当与来自另一个传感器或系统的另一份数据结合时，它可以被用来明确识别用户及其行为。'
- en: The truth is that even though there have been many projects and efforts to improve
    the security of those systems, as of today, the Holy Grail of security and privacy
    in the IoT world remains to be found. The real challenge is that capabilities
    of the IoT are relatively new at this scale, and the risks associated with those
    technologies are both largely unknown and hard to identify or measure in real-world
    applications.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，尽管已经有许多项目和努力来提高这些系统的安全性，但截至今天，物联网世界中的安全和隐私的圣杯仍然有待发现。真正的挑战是，物联网在这个规模上的能力相对较新，与这些技术相关的风险在很大程度上是未知的，并且在现实世界应用中难以识别或衡量。
- en: Internet of Things
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网
- en: As explained earlier, because applications in the IoT are often developed individually,
    the security mechanisms for these deployments are too often written from scratch,
    not tested sufficiently in the real world, or simply non-existing. Even today,
    a number of IoT devices are being deployed without using a sufficient level of
    security, dangerously exposing their authentication keys to the world.^([[32](#ch01fn32)])
    This is mainly because IoT-specific security systems have quite often been designed
    to work well in closed ecosystems, where every element is controlled.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，由于物联网中的应用程序通常是单独开发的，因此这些部署的安全机制往往是从头开始编写的，在现实世界中测试不足，或者根本不存在。即使今天，许多物联网设备仍在部署时没有使用足够的安全级别，危险地将它们的认证密钥暴露于世界之中。[32](#ch01fn32)
    这主要是因为物联网特定的安全系统往往被设计成在封闭生态系统中运行良好，其中每个元素都受到控制。
- en: ^(32)
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[32]'
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.ioactive.com/news-events/IOActive_advisory_belkinwemo_2014.html](http://www.ioactive.com/news-events/IOActive_advisory_belkinwemo_2014.html)'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.ioactive.com/news-events/IOActive_advisory_belkinwemo_2014.html](http://www.ioactive.com/news-events/IOActive_advisory_belkinwemo_2014.html)'
- en: Web of Things
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网网
- en: The web can help here, too, and we’ll look into this in [chapter 9](kindle_split_017.html#ch09).
    Looking back at the history of the web, we can see that we’ve made tremendous
    progress in building usable and reliable security mechanisms and protocols. These
    methods are not bulletproof—no security system is—but are a practical compromise
    of dependability, ease of use, performance, and availability.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 网络也能在这方面提供帮助，我们将在第9章（kindle_split_017.html#ch09）中探讨这一点。回顾网络的历程，我们可以看到我们在构建可用且可靠的安全机制和协议方面取得了巨大的进步。这些方法并非坚不可摧——没有任何安全系统是完美的——但它们是在可靠性、易用性、性能和可用性之间的一种实际折衷。
- en: The fact is that even today it isn’t uncommon to hear that a large and famous
    online company has been hacked and the data about millions of its users has been
    leaked publicly. Even worse, protocols that have been viewed as secure and trusted
    might still suffer from tiny unknown problems, making them vulnerable when found
    (SSL Heartbleed^([[33](#ch01fn33)]) anyone?). With a few exceptions, as long as
    those systems are implemented correctly, the possibility of them being hacked
    remains minor, especially given that those systems are used daily by billions
    of users. The advantage of using web-based common standards, as opposed to custom
    and novel ones developed for the IoT, is that they have been and still are extensively
    used and tested. Many implementations of such systems are open source (for example,
    OpenSSL), which means the code is constantly used, tested, updated, and fixed
    by thousands of developers. Using such established methods reduced the risk of
    failures as opposed to the bleeding-edge (pun intended) techniques being developed
    from scratch for the IoT that have been tested and used in the wild only marginally.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使在今天，听到一家大型知名在线公司遭到黑客攻击，数百万用户的资料被公开泄露的情况也并不少见。更糟糕的是，那些被视为安全和可信的协议可能仍然存在微小的未知问题，一旦被发现就会变得脆弱（比如SSL
    Heartbleed^([[33](#ch01fn33)])？）。除非有少数例外，只要那些系统被正确实施，它们被黑客攻击的可能性仍然很小，尤其是考虑到这些系统每天被数十亿用户使用。与为物联网开发的定制和新型标准相比，使用基于网络的通用标准的优势在于它们已经被广泛使用和测试。许多此类系统的实现都是开源的（例如，OpenSSL），这意味着代码被数千名开发者不断使用、测试、更新和修复。使用这些既定方法降低了失败的风险，相比之下，为物联网从头开发并仅在野外进行有限测试的尖端（有意为之）技术风险更大。
- en: ^(33)
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (33)
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Heartbleed Bug is a serious vulnerability that was found in the popular
    OpenSSL cryptographic software library (see more at [http://heartbleed.com/](http://heartbleed.com/))
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Heartbleed漏洞是在流行的OpenSSL加密软件库中发现的一个严重漏洞（更多信息请参阅[http://heartbleed.com/](http://heartbleed.com/)）
- en: 1.4.6\. WoT—the shortcomings
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.6. WoT的不足之处
- en: We realize that at this stage you might be thinking, “These guys got a little
    carried away with their WoT!” Maybe. But after using traditional IoT tools for
    over a decade, it’s hard to describe the pleasure we feel after creating the same
    type of applications directly in our browser with a few lines of JavaScript and
    with much less effort, time, and suffering.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到，在这个阶段，你可能正在想，“这些家伙对他们的WoT有点过于热情了！”也许吧。但使用传统的物联网工具超过十年后，很难描述我们直接在浏览器中使用几行JavaScript创建相同类型的应用程序时的愉悦感，而且所需付出的努力、时间和痛苦都要少得多。
- en: 'Nevertheless, the Web of Things isn’t the “Answer to the Ultimate Question
    of Life, the Universe, and Everything” (aka 42).^([[34](#ch01fn34)]) As with every
    disruptive technology or approach, it comes with its own share of challenges.
    Security and general data privacy are some of these. Connecting all Things in
    our physical world to the internet and making them accessible on the web also
    means we potentially expose them to intrusive governments, viruses, or disreputable
    companies that could use this to run denial of service attacks or mine information
    about the real world. We should assume they will. Thinking about security is already
    a must for the IoT; the WoT adds a few more concerns, especially on the data privacy
    side of things. We’ll cover these advanced topics in [chapter 9](kindle_split_017.html#ch09),
    but the short answer is that a largely connected system will always be more vulnerable
    than an isolated one. But a system connected using open standards is usually better
    off than one based on custom security mechanisms. Moreover, this isn’t the first
    time we’ve had to face such a dilemma: our computers could be isolated, but this
    would reduce their range of applications. The IoT and the WoT are no exceptions:
    we, as citizens, have a choice and should weigh each of these new technologies
    on the balance between risks and benefits. The WoT should be about making our
    lives easier and more enjoyable, not harder.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，物联网并不是“生命、宇宙和万物的终极问题的答案”（也就是42）。就像每一种颠覆性技术或方法一样，它也伴随着自己的挑战。安全和一般数据隐私就是其中的一些。将我们物理世界中的所有事物连接到互联网并在网络上使其可访问，这也意味着我们可能将它们暴露于侵入性的政府、病毒或可能利用这一点进行拒绝服务攻击或挖掘关于现实世界信息的不名誉公司。我们应该假设他们会这么做。对于物联网来说，考虑安全性已经是必须的；物联网网增加了更多关注点，尤其是在数据隐私方面。我们将在第9章中讨论这些高级主题，但简短的答案是，一个高度连接的系统总是比一个孤立的系统更脆弱。但是，使用开放标准的连接系统通常比基于定制安全机制的系统更好。此外，这并不是我们第一次面临这样的困境：我们的计算机可以是孤立的，但这会减少它们的应用范围。物联网和物联网网也不例外：作为公民，我们有选择权，应该在风险和收益之间权衡每一种新技术。物联网网应该关于使我们的生活更轻松、更愉快，而不是更艰难。
- en: ^(34)
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(34)
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://goo.gl/l4rG1b](http://goo.gl/l4rG1b)'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://goo.gl/l4rG1b](http://goo.gl/l4rG1b)'
- en: 'It’s important to realize that pushing web standards on every single device
    isn’t always the right thing to do, and in some cases it isn’t practical or feasible.
    Under certain constraints (such as when a battery-powered device needs to operate
    for a very long time), you might be better off using an optimized IoT protocol.
    In [chapter 5](kindle_split_012.html#ch05), we’ll help you understand what these
    tradeoffs are and give you a framework to decide the best options for various
    situations. The good news is that the Web of Things is all about integration patterns:
    we’ll show you how to integrate non-web or even non-IP devices to the web via
    proxies, gateways, or clouds. This type of hybrid solution sometimes makes deployments
    more complex but is more practical because it allows for optimizations where needed.
    We’ll discuss these integration patterns in [chapter 7](kindle_split_015.html#ch07).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，将网络标准强加给每一个设备并不总是正确的事情，在某些情况下，这并不实际或可行。在一定的约束条件下（例如，当电池供电的设备需要长时间运行时），你可能更愿意使用优化的物联网协议。在第5章中，我们将帮助你理解这些权衡，并为你提供一个框架来决定各种情况下的最佳选项。好消息是，物联网网完全是关于集成模式：我们将向你展示如何通过代理、网关或云将非网络或甚至非IP设备集成到网络中。这种混合解决方案有时会使部署更复杂，但更实用，因为它允许在需要的地方进行优化。我们将在第7章中讨论这些集成模式。
- en: 1.5\. Summary
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5\. 摘要
- en: The Internet of Things has been around for much longer than you think and certainly
    before it was called this.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网的存在时间比你想象的要长，当然在它被称为这个名字之前就已经存在了。
- en: Early IoT systems were designed to operate in isolation; therefore, the IoT
    today is a fragmented world—the Intranets of Things.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期的物联网系统被设计为在孤立状态下运行；因此，今天的物联网是一个碎片化的世界——事物内网。
- en: The Web of Things is different because it doesn’t care about underlying networking
    protocols or standards, only about how to weave various isolated systems and devices
    into a single, web-based ecosystem.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网网不同之处在于，它不关心底层网络协议或标准，只关心如何将各种孤立系统和设备编织成一个单一的、基于网络的生态系统。
- en: Using simple and ubiquitous web standards such as HTTP, Web Socket, and JSON
    to integrate all sorts of devices and applications makes it much easier to rapidly
    prototype all sorts of applications and then scale them for enterprise-grade solutions.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单且普遍的网络标准，如HTTP、WebSocket和JSON，将各种设备和应用程序集成在一起，这使得快速原型设计和扩展企业级解决方案变得更加容易。
- en: The IoT is still in its infancy, and there are many opportunities ahead for
    those who want to master the complexity of a world where the physical world becomes
    connected.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网仍处于起步阶段，对于那些想要掌握物理世界连接的复杂性的世界的人来说，前方有许多机会。
- en: This book will teach you how to use the Web of Things to build a new generation
    of IoT solutions that are more flexible, scalable, and interoperable by building
    upon and using the infrastructure, tools, and experience accumulated since the
    web was invented in the early 90s.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书将教你如何使用物联网构建新一代的物联网解决方案，这些解决方案通过利用自20世纪90年代初互联网发明以来积累的基础设施、工具和经验，更加灵活、可扩展和互操作。
- en: In the next chapter, we’ll give you a first taste of what the Web of Things
    feels like. By working on a few hands-on exercises, you’ll experience first-hand
    how easy it is to build Web of Things applications that read sensor data, send
    commands to devices, and merge information from various sources to create hybrid
    applications where the real world becomes accessible on the Web. We kept the next
    chapter simple by hiding the complexity of the devices behind web standards so
    that you are able to rapidly build and customize your first Web of Things application
    without having to deal with how to implement it directly on devices (yet!). In
    the chapters after that, you’ll learn the details of how you can apply those principles
    to create elaborate applications and connectors for any device and scenario you
    might have in mind.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将给你一个物联网的感觉初体验。通过进行一些动手练习，你将亲身体验构建读取传感器数据、向设备发送命令以及从各种来源合并信息以创建混合应用程序的Web物联网应用程序是多么容易。我们通过隐藏设备背后的复杂性，使用网络标准来简化下一章的内容，这样你就可以快速构建和定制你的第一个Web物联网应用程序，而无需直接在设备上实现它（目前还不必）。在随后的章节中，你将了解如何将这些原则应用于创建任何设备和场景的复杂应用程序和连接器。
- en: Chapter 2\. Hello, World Wide Web of Things
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章. 嗨，全球物联网
- en: '*This chapter covers*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: A sneak peek at the different levels of the Web of Things architecture
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悄悄一瞥物联网架构的不同层级
- en: Accessing devices with HTTP, URLs, WebSockets, and browsers
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP、URL、WebSocket和浏览器访问设备
- en: Working with REST APIs to consume JSON data
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST API消费JSON数据
- en: Learning about the notion of web semantics
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解网络语义的概念
- en: Creating your first physical mashup
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个物理混合应用
- en: Before we dive head first into the Web of Things architecture and show how to
    implement it from scratch, we want to give you a taste of what the Web of Things
    looks like. This chapter is structured as a set of exercises where you’ll build
    tiny web applications that use data generated by a real device. Each exercise
    will be a smooth introduction to the many problems and technical issues that you’ll
    face when building web-connected devices and applications that interact with them.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们一头扎进物联网架构并展示如何从头开始实现它之前，我们想先让你了解一下物联网是什么样子。本章结构为一套练习，你将构建使用真实设备生成数据的微型网络应用程序。每个练习都将平滑地引入你在构建连接到网络的设备和与之交互的应用程序时可能会遇到的各种问题和技术难题。
- en: In this chapter, you’ll have the opportunity to get your hands dirty and code
    some simple (and less simple) Web of Things applications. Oh, you don’t have a
    device yet? No problem; just use ours! To make it possible for you to do those
    exercises without having to buy a real device, we connected our own device to
    the web so you can access it from your computer over the Web. Of course, if you
    already have a device, you can also download the source code used in this chapter
    and run it on your own device. How to run the code on the device will be detailed
    later, in [chapter 7](kindle_split_015.html#ch07).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将有机会亲自动手编写一些简单（以及不那么简单）的物联网应用程序。哦，你还没有设备？没问题；只需使用我们的设备！为了让你能够在不购买真实设备的情况下进行这些练习，我们将我们的设备连接到网络上，这样你就可以通过Web从你的电脑访问它。当然，如果你已经有了设备，你也可以下载本章中使用的源代码并在自己的设备上运行它。如何在设备上运行代码将在第7章中详细说明。
- en: 2.1\. Meet a Web of Things device
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 认识物联网设备
- en: This chapter is organized as a series of short and sweet exercises. Each exercise
    allows you to interact with an actual Web of Things device in our office that’s
    live 24/7\. This will allow you to do the exercises without having a real device
    next to you.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本章组织了一系列简短而精炼的练习。每个练习都允许你与我们在办公室实际运行的物联网设备进行交互，这些设备全天候24/7在线。这样你就可以在没有实际设备的情况下完成练习。
- en: The device in our office is the Raspberry Pi 2 (or just Pi for friends and family)
    shown in [figure 2.1](#ch02fig01), which we’ll describe in detail in [chapter
    4](kindle_split_011.html#ch04). If you’ve never seen one, you can think of a credit
    card–sized computer board with a few sensors attached to it and connected to our
    local network and the web via an Ethernet cable. In our setup, the Pi acts as
    a gateway to various sensors or devices attached to it, so you can interact with
    those resources through the Web. Gateways are described in detail in [chapter
    7](kindle_split_015.html#ch07), but for now just remember that the Pi runs a web
    server that allows you to access those resources over the Web, as shown in [figure
    2.2](#ch02fig02)..
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们办公室的设备是图2.1（[figure 2.1](#ch02fig01)）中所示的树莓派2（或简称为Pi，对朋友和家人来说），我们将在第4章（[chapter
    4](kindle_split_011.html#ch04)）中详细描述。如果你从未见过，你可以想象一个信用卡大小的计算机板，上面连接了一些传感器，并通过以太网线连接到我们的本地网络和互联网。在我们的设置中，Pi充当连接到其上的各种传感器或设备的网关，因此你可以通过Web与这些资源进行交互。网关在第7章（[chapter
    7](kindle_split_015.html#ch07)）中有详细描述，但你现在只需记住，Pi运行一个Web服务器，允许你通过Web访问这些资源，如图2.2（[figure
    2.2](#ch02fig02)）所示。
- en: Figure 2.1\. The Raspberry Pi and webcam you are accessing as they are set up
    in our London office
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. 你正在访问的树莓派和摄像头，它们在我们伦敦办公室的设置情况
- en: '![](02fig01_alt.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig01_alt.jpg)'
- en: Figure 2.2\. The setup of devices and sensors used in the examples of this chapter
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 本章示例中使用的设备和传感器的设置
- en: '![](02fig02_alt.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig02_alt.jpg)'
- en: At the time of writing, we have a liquid crystal display (LCD), a camera, a
    temperature sensor, and a PIR sensor connected to our Raspberry Pi. We’ll keep
    adding various sensors and actuators to it over time, so you’re welcome to experiment
    and go well beyond the examples we provide here. You’ll soon realize that the
    various techniques and patterns described in this book will allow you to quickly
    extend and customize the examples we provide to any device, sensor, or object
    you can think of.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我们已经将液晶显示器（LCD）、摄像头、温度传感器和PIR传感器连接到我们的树莓派上。我们将随着时间的推移继续添加各种传感器和执行器，因此欢迎你进行实验，并超越我们在此提供的示例。你很快就会意识到，本书中描述的各种技术和模式将允许你快速扩展和定制我们提供的示例，以适应任何你能想到的设备、传感器或物体。
- en: '2.1.1\. The suspect: Raspberry Pi'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 嫌疑人：树莓派
- en: 'We’ll introduce the Raspberry Pi in greater detail in [chapter 4](kindle_split_011.html#ch04),
    so all you need to understand for now is that a Pi is a small computer to which
    you can connect multiple sensors and accessories. It offers all the features you
    would expect from a desktop computer but with a lower power consumption and smaller
    form factor. Moreover, you can attach all sorts of digital sensors or actuators
    to it using the input/output (I/O) pins. *Actuator* is an umbrella term for any
    element attached to a device that has an effect on the real world, for example,
    turning on/off some LEDs, displaying a text on an LCD panel, rotating an electric
    motor, unlocking a door, playing some music, and so on. In the Web of Things,
    just as you send write requests to a web API using HTTP, you do the same to activate
    an actuator. Now back to our exercises. The first thing you need to do is to download
    the examples used in these pages from our repository here: [http://book.webofthings.io](http://book.webofthings.io).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第4章（[chapter 4](kindle_split_011.html#ch04)）中更详细地介绍树莓派，因此你现在需要了解的是，Pi是一个小型计算机，你可以连接多个传感器和附件。它提供了你从台式计算机上期望的所有功能，但功耗更低，体积更小。此外，你可以使用输入/输出（I/O）引脚将其连接到各种数字传感器或执行器。“执行器”是一个总称，指任何连接到设备并对现实世界产生影响的元素，例如，打开/关闭一些LED灯，在液晶面板上显示文本，旋转电动机，解锁门，播放音乐等等。在物联网中，正如你使用HTTP向Web
    API发送写请求一样，你也会这样做来激活执行器。现在回到我们的练习。你需要做的第一件事是从我们这里的存储库下载这些页面中使用的示例：[http://book.webofthings.io](http://book.webofthings.io)。
- en: You can check out the repository on your own computer, and in it you’ll find
    a few folders—one for each chapter. The exercises in this chapter are located
    in the folder chapter2-hello-wot/client. If you’re wondering about the code for
    the server, worry not! You’ll learn how to build this in the rest of the book.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在自己的电脑上查看仓库，在其中您会发现几个文件夹——每个章节一个。本章的练习位于文件夹 chapter2-hello-wot/client 中。如果您想知道服务器的代码，不用担心！您将在本书的其余部分学习如何构建它。
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How to get the code examples in this chapter**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何获取本章的代码示例**'
- en: 'We use the GitHub^([[a](#ch02fn01a)]) service to synchronize code between our
    computer and our Pi. As an alternative, the Bitbucket^([[b](#ch02fn02a)]) service
    works and is configured in a similar manner. Both services are based on the Git
    source version control system, and the source code for all the chapters is available
    from GitHub (here’s the link: [http://book.webofthings.io](http://book.webofthings.io)).
    The examples for this chapter are located in the chapter2-hello-wot folder.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 GitHub^([[a](#ch02fn01a)]) 服务在电脑和我们的 Pi 之间同步代码。作为替代，Bitbucket^([[b](#ch02fn02a)])
    服务也可以使用，并且配置方式类似。这两个服务都基于 Git 源代码控制系统，所有章节的源代码都可在 GitHub 上找到（这里是链接：[http://book.webofthings.io](http://book.webofthings.io))。本章的示例位于
    chapter2-hello-wot 文件夹中。
- en: ^a
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'GitHub is a widely popular, web-based, source code management system. Many
    open source projects are hosted on GitHub, because, well, it’s pretty awesome.
    Here’s an excellent intro to GitHub: [http://bit.ly/intro-git](http://bit.ly/intro-git).'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GitHub 是一个广泛流行的基于网络的源代码管理系统。许多开源项目都托管在 GitHub 上，因为，嗯，它相当酷。这里有 GitHub 的一个优秀介绍：[http://bit.ly/intro-git](http://bit.ly/intro-git)。
- en: ^b
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^b
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://bitbucket.com](https://bitbucket.com)'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://bitbucket.com](https://bitbucket.com)'
- en: 'If you’re unfamiliar with Git and its commands, don’t worry—there’s plenty
    of information about this on the web, but here are the most vital commands to
    work with it:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对 Git 及其命令不熟悉，不用担心——网上有大量关于这方面的信息，但这里有一些与 Git 一起工作的最关键的命令：
- en: '`git clone`—Fetches a version of a repository locally. For the book code you
    need to use the `recursive` option that will clone all the sub-projects as well:
    `git clone` [https://github.com/webofthings/wot-book](https://github.com/webofthings/wot-book)
    `--recursive`.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git clone`——在本地获取仓库的一个版本。对于本书的代码，您需要使用 `recursive` 选项，这将克隆所有子项目：`git clone`
    [https://github.com/webofthings/wot-book](https://github.com/webofthings/wot-book)
    `--recursive`。'
- en: '`git commit –a –m "your message"`—Commits code changes locally.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git commit –a –m "your message"`——在本地提交代码更改。'
- en: '`git push origin master`—Pushes the last commits to the remote repository (origin)
    on the master branch.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git push origin master`——将最后的提交推送到远程仓库（origin）的 master 分支。'
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.2\. Exercise 1—Browse a device on the Web of Things
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 练习 1——浏览物联网网络中的设备
- en: We’ll start our exploration of the Web of Things with a simple exercise where
    you have almost nothing to do but click on a few links in your browser. The first
    point we want to illustrate is that on the Web of Things, devices can offer simultaneously
    a visual user interface (web pages) to allow humans to control and interact with
    them and an application programming interface (API) to allow machines or applications
    to do the same.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一项简单的练习开始对物联网网络的探索，您几乎没有什么事情要做，只需在浏览器中点击几个链接即可。我们想要说明的第一个要点是，在物联网网络中，设备可以同时提供视觉用户界面（网页）以允许人类控制和与之交互，以及应用程序编程接口（API）以允许机器或应用程序执行相同的操作。
- en: 2.2.1\. Part 1—The web as user interface
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 第一部分——网络作为用户界面
- en: 'In this first exercise, you’ll use your browser to interact with some of the
    real Web of Things devices connected in our office. First, have a glimpse of what
    the setup in our office looks like through a webcam; see [figure 2.3](#ch02fig03).
    Open the following link in your favorite browser to access the latest image taken
    by the web cam: [http://devices.webofthings.io/camera/sensors/picture](http://devices.webofthings.io/camera/sensors/picture).
    This link will always return the latest screenshot taken by our camera so you
    can see the devices you will play with (try it at night—at night it’s even more
    fun!). You won’t see the camera itself, though.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个练习中，您将使用浏览器与我们在办公室连接的一些真实物联网设备进行交互。首先，通过网络摄像头看看我们办公室的设置；见 [图 2.3](#ch02fig03)。在您最喜欢的浏览器中打开以下链接以访问网络摄像头拍摄的最新图像：[http://devices.webofthings.io/camera/sensors/picture](http://devices.webofthings.io/camera/sensors/picture)。此链接将始终返回我们的摄像头拍摄的最新截图，因此您可以查看您将要与之交互的设备（晚上试试——晚上更有趣！）。不过，您不会看到摄像头本身。
- en: Figure 2.3\. The web page of the camera used in our setup. The image is a live
    screenshot taken by the camera.
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3。我们设置中使用的摄像头的网页。图像是摄像头实时捕获的截图。
- en: '![](02fig03_alt.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![02fig03_alt.jpg](02fig03_alt.jpg)'
- en: 'You probably noticed that the URL you typed had a certain path structure. Let’s
    play a bit with this structure and go back to the root of this URL, where you’ll
    see the homepage of the gateway that allows you to browse through the devices
    in our office ([figure 2.4](#ch02fig04)). Enter the following URL in your browser:
    [http://devices.webofthings.io](http://devices.webofthings.io).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到你输入的URL有一个特定的路径结构。让我们对这个结构玩一点，回到这个URL的根目录，在那里你会看到允许你浏览我们办公室设备的网关主页（[图2.4](#ch02fig04)）。在你的浏览器中输入以下URL：[http://devices.webofthings.io](http://devices.webofthings.io)。
- en: Figure 2.4\. The HTML homepage of the gateway of our WoT device. The two hyperlinks
    at the bottom of the page allow you to access the pages of the devices connected
    to the gateway.
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4。我们WoT设备网关的HTML主页。页面底部的两个超链接允许你访问连接到网关的设备的页面。
- en: '![](02fig04_alt.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![02fig04_alt.jpg](02fig04_alt.jpg)'
- en: 'This URL will always redirect you to the *root page* of the gateway running
    in our office, which shows the list of devices attached to it. Here, you can see
    that two devices are attached to the gateway:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL将始终重定向到你办公室运行的网关的**根页面**，它显示了附加到网关的设备列表。在这里，你可以看到两个设备连接到了网关：
- en: A Raspberry Pi with various sensors and actuators
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有各种传感器和执行器的Raspberry Pi
- en: A webcam (the one you accessed earlier)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络摄像头（你之前访问的那个）
- en: Note that this page is automatically generated based on which physical devices
    we have attached to it, so you might see a few more devices or sensors as we attach
    them. Yes, although it looks like any other web page, it’s actually *real* data
    served in *real time* from *real* devices that are in a *real* office!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个页面是根据我们附加到它的物理设备自动生成的，所以当你我们附加更多设备或传感器时，你可能会看到更多设备。是的，尽管它看起来像任何其他网页，但实际上它是在**实时**从**真实**办公室的**真实**设备上提供的**真实**数据！
- en: Now, click the My WoT Raspberry Pi link to access the root page of the device
    itself. Because you followed a link in your browser, you’ll see that the URL has
    changed to [http://devices.webofthings.io/pi](http://devices.webofthings.io/pi),
    as shown in [figure 2.5](#ch02fig05).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击“我的WoT Raspberry Pi”链接以访问设备的根页面。因为你通过浏览器跟随了一个链接，所以你会看到URL已经更改到了[http://devices.webofthings.io/pi](http://devices.webofthings.io/pi)，如图2.5所示。
- en: Figure 2.5\. The homepage of the Raspberry Pi. Here, you can use the links at
    the bottom to browse and explore the various resources offered by this device;
    for example, its sensors and actuators.
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5。Raspberry Pi的主页。在这里，你可以使用底部的链接浏览和探索该设备提供的各种资源；例如，它的传感器和执行器。
- en: '![](02fig05_alt.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![02fig05_alt.jpg](02fig05_alt.jpg)'
- en: This is another root page—the one of the device this time. In this case, we
    just appended `/pi` to the root URL of the gateway.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个根页面——这次是设备的根页面。在这种情况下，我们只是将`/pi`附加到了网关的根URL。
- en: 'Coming back to our device root page, hover with your mouse above the various
    links to see their structure, and then click The list of sensors link. You’ll
    see the URL change again to this ([figure 2.6](#ch02fig06)): [http://devices.webofthings.io/pi/sensors](http://devices.webofthings.io/pi/sensors).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的设备根页面，将鼠标悬停在各个链接上方以查看它们的结构，然后点击“传感器列表”链接。你会看到URL再次更改到这个（[图2.6](#ch02fig06)）：[http://devices.webofthings.io/pi/sensors](http://devices.webofthings.io/pi/sensors)。
- en: Figure 2.6\. The list of sensors on the Pi. You can click each of them and see
    the latest known value for each.
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6。Pi上的传感器列表。你可以点击每个传感器并查看每个传感器的最新已知值。
- en: '![](02fig06_alt.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![02fig06_alt.jpg](02fig06_alt.jpg)'
- en: 'So far, it’s pretty straightforward: your browser is asking for an HTML page
    that shows the list of `/sensors` of the device `/pi` connected to the `devices.webofthings.io`
    gateway. Remember that there’s also a camera connected to this, so in your browser
    address bar replace `/pi/` with `/camera/` in the URL and you’ll be taken directly
    to the Sensors page of the camera: [http://devices.webofthings.io/camera/sensors](http://devices.webofthings.io/camera/sensors);
    see [figure 2.7](#ch02fig07).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这相当直接：你的浏览器正在请求一个HTML页面，显示连接到`devices.webofthings.io`网关的`/pi`设备的`/sensors`列表。记住，这里也连接了一个摄像头，所以在你浏览器的地址栏中，将URL中的`/pi/`替换为`/camera/`，你将直接进入相机的传感器页面：[http://devices.webofthings.io/camera/sensors](http://devices.webofthings.io/camera/sensors)；见图2.7。
- en: Figure 2.7\. The sensors on the camera. There’s only one sensor here, which
    is the current image.
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7。相机上的传感器。这里只有一个传感器，即当前图像。
- en: '![](02fig07_alt.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig07_alt.jpg)'
- en: 'Now, go back to the list of sensors on your Pi and see the various sensors
    attached to the device. Currently, you can access three sensors: temperature,
    humidity, and passive infrared. Open the Temperature Sensor link and you’ll see
    the temperature sensor page with the current value of the sensor. Finally, just
    like you did for the sensors, go to the actuators list of the Pi and open the
    Actuator Details page (see [figure 2.13](#ch02fig13)) at the following URL: [http://devices.webofthings.io/pi/actuators/display](http://devices.webofthings.io/pi/actuators/display).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到您Pi上的传感器列表，查看连接到设备的各种传感器。目前，您可以访问三个传感器：温度、湿度和被动红外。打开温度传感器链接，您将看到温度传感器的页面，其中包含传感器的当前值。最后，就像您对传感器所做的那样，转到Pi的执行器列表，打开执行器详细信息页面（见[图2.13](#ch02fig13)），以下URL：[http://devices.webofthings.io/pi/actuators/display](http://devices.webofthings.io/pi/actuators/display)。
- en: The display is a simple LCD screen attached to the Pi that can display some
    text, which you’ll use in exercise 2.4\. You can see the information about this
    actuator—in particular the current value being displayed, the API description
    to send data to it, and a form to display new data. You won’t use this form for
    now, but this is coming in [section 2.4](#ch02lev1sec4).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 显示屏是连接到Pi的一个简单LCD屏幕，可以显示一些文本，您将在练习2.4中使用它。您可以看到关于这个执行器的信息——特别是当前显示的值、发送数据到它的API描述以及显示新数据的表单。现在您不会使用这个表单，但这个功能将在[第2.4节](#ch02lev1sec4)中介绍。
- en: 2.2.2\. Part 2—The web as an API
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2. 第二部分——Web作为API
- en: In [part 1](kindle_split_007.html#part01), you started to interact with the
    Web of Things from your browser. You’ve seen how a human user can explore the
    resources of a device (sensors, actuators, and so on) and how to interact with
    that device from a web page. All of that is done by browsing the resources of
    a physical device, just as you’d browse the various pages of a website. But what
    if instead of a human user, you want a software application or another device
    to do the same thing, without having a human in the loop? How can you make it
    easy for any web client to find a device, understand what it does, see what its
    API looks like, determine what commands it can send, and so on?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一部分](kindle_split_007.html#part01)中，您开始从浏览器中与物联网进行交互。您已经看到了人类用户如何探索设备的资源（传感器、执行器等）以及如何从网页中与该设备进行交互。所有这些操作都是通过浏览物理设备的资源来完成的，就像您浏览网站的各种页面一样。但如果不是人类用户，而是希望一个软件应用或另一个设备执行相同操作，而不需要人类介入，怎么办？您如何让任何Web客户端都能轻松找到设备，了解其功能，查看其API的样子，确定它可以发送哪些命令等等？
- en: Later in the book, we’ll show you in detail how to do this. For now, we’ll illustrate
    how the web makes it easy to support both humans and applications by showing you
    what another device or application sees when it browses your device.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将详细向您展示如何做到这一点。现在，我们将通过向您展示当另一个设备或应用浏览您的设备时看到的内容，来展示Web如何使支持人类和应用变得容易。
- en: For this exercise, you’ll need to have Chrome installed and install one of our
    favorite browser extensions called Postman.^([[1](#ch02fn01)]) Or you could use
    cURL^([[2](#ch02fn02)]) if you’d rather use the command line. Postman is a handy
    little app that will help you a lot when working with a web API because it allows
    you to easily send HTTP requests and customize the various options of these requests,
    such as the headers, the payload, and much more. Postman will make your life easier
    throughout this book, so go ahead and install it.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，您需要安装Chrome并安装我们最喜欢的一个浏览器扩展程序，名为Postman.^([[1](#ch02fn01)]) 或者如果您更愿意使用命令行，可以使用cURL^([[2](#ch02fn02))).
    Postman是一个小巧的应用程序，当您与Web API一起工作时，它将极大地帮助您，因为它允许您轻松发送HTTP请求并自定义这些请求的各种选项，如头部、负载等。Postman将使您在本书中更容易地完成任务，所以请继续安装它。
- en: ¹
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Get it here: [http://www.getpostman.com/](http://www.getpostman.com/)'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里获取：[http://www.getpostman.com/](http://www.getpostman.com/)
- en: ²
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'cURL is a command-line tool that allows you to transfer data using various
    protocols, among which is HTTP. If it’s not preinstalled on your machine, you
    can easily install it on Mac, Linux, or Windows. Website: [http://curl.haxx.se/](http://curl.haxx.se/)'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cURL是一个命令行工具，允许您使用各种协议传输数据，其中包括HTTP。如果您的机器上没有预先安装，您可以在Mac、Linux或Windows上轻松安装它。网站：[http://curl.haxx.se/](http://curl.haxx.se/)
- en: In [part 1](kindle_split_007.html#part01), your browser is simply a web client
    requesting content from the server. The browser automatically asks for the content
    to be in HTML format, which is returned by the server and then displayed by the
    browser.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 部分](kindle_split_007.html#part01) 中，你的浏览器只是一个请求服务器内容的网络客户端。浏览器会自动请求以
    HTML 格式的内容，然后由服务器返回并由浏览器显示。
- en: In [part 2](kindle_split_013.html#part02), you’ll do almost the same exercise
    as in [part 1](kindle_split_007.html#part01) but this time by requesting the server
    to return JSON documents instead of an HTML page. JSON is pretty much the most
    successful data interchange format used on the internet. It has an easy-to-understand
    syntax and is lightweight, which makes it much more efficient to transmit when
    compared to its old parent, XML. In addition, JSON is easy for humans to read
    and write and also for machines to parse and generate, which makes it particularly
    suited to be *the* data exchange format of the Web of Things. The process of asking
    for a specific encoding is called *content negotiation* in the HTTP 1.1 specification
    and will be covered in detail in [chapter 6](kindle_split_014.html#ch06).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 部分](kindle_split_013.html#part02) 中，你将几乎与 [第 1 部分](kindle_split_007.html#part01)
    中相同的练习，但这次是通过请求服务器返回 JSON 文档而不是 HTML 页面。JSON 几乎是互联网上使用最成功的数据交换格式。它具有易于理解的语法，且轻量级，与它的老式父格式
    XML 相比，这使得它在传输时更加高效。此外，JSON 便于人类阅读和编写，也便于机器解析和生成，这使得它特别适合成为物联网的数据交换格式。请求特定编码的过程在
    HTTP 1.1 规范中称为 *内容协商*，将在 [第 6 章](kindle_split_014.html#ch06) 中详细介绍。
- en: Step 1—Getting the list of devices from the gateway
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 1 步——从网关获取设备列表
- en: Just as you did before, you’ll send a GET request to the root page of the gateway
    to get the list of devices. For this you’ll enter the URL of the gateway in Postman
    and click Send, as shown in [figure 2.8](#ch02fig08).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你之前做的那样，你将向网关的根页面发送 GET 请求以获取设备列表。为此，你需要在 Postman 中输入网关的 URL 并点击“发送”，如图 2.8
    所示。
- en: Figure 2.8\. Getting the root page of the gateway using the Postman web client.
    The request is an HTTP GET (1) on the URL of the gateway (2). The response body
    will contain an HTML document (4).
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.8\. 使用 Postman 网络客户端获取网关的根页面。请求是针对网关 URL 的 HTTP GET (1)。响应体将包含一个 HTML 文档
    (4)。
- en: '![](02fig08_alt.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.8](02fig08_alt.jpg)'
- en: Because most web servers return HTML by default, you’ll see in the body area
    the HTML page content returned by the server (4). This is basically what happens
    behind the scenes each time you access a website from your browser. Now to get
    JSON instead of HTML, click the Headers button and add a header named `Accept`
    with `application/json` in the value, and click Send again, as shown in [figure
    2.9](#ch02fig09). Adding this header to your request is telling the HTTP server,
    “Hey, if you can, please return me the results encoded in JSON.” Because this
    is supported by the gateway, you’ll now see the same content in JSON, which is
    the machine equivalent of the web page you’ve retrieved before, but this time
    with only the content and no visual elements (that is, the HTML code).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数网络服务器默认返回 HTML，你会在主体区域看到服务器返回的 HTML 页面内容 (4)。这基本上就是每次你从浏览器访问网站时幕后发生的事情。现在要获取
    JSON 而不是 HTML，请点击“头部”按钮，添加一个名为“Accept”的头部，其值为 `application/json`，然后再次点击“发送”，如图
    2.9 所示。向请求添加此头部是在告诉 HTTP 服务器，“嘿，如果你能的话，请返回给我编码为 JSON 的结果。”因为网关支持这一点，你现在将看到与之前检索到的网页相同的
    JSON 内容，但这次只有内容，没有视觉元素（即 HTML 代码）。
- en: Figure 2.9\. Getting the list of devices connected to the gateway via Postman.
    The `Accept` header is now set to `application/json` to ask for the results to
    be returned in JSON.
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.9\. 使用 Postman 获取连接到网关的设备列表。现在“Accept”头部设置为 `application/json` 以请求返回 JSON
    格式的结果。
- en: '![](02fig09_alt.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.9](02fig09_alt.jpg)'
- en: 'The JSON body returned contains a machine-readable description of the devices
    attached to the gateway and looks like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 JSON 主体包含连接到网关的设备的机器可读描述，其外观如下：
- en: '[PRE0]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this JSON document, you can see two first-level elements (`pi` and `camera`)
    that represent the two devices attached to the gateway, as well as a few details
    about them, such as their URL, name, ID, and description. Don’t worry for now
    if you don’t understand everything here; all of this will become crystal clear
    to you in a few chapters.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 JSON 文档中，你可以看到两个一级元素 (`pi` 和 `camera`)，它们代表连接到网关的两个设备，以及一些关于它们的细节，例如它们的
    URL、名称、ID 和描述。现在如果你不理解这里的一切，请不要担心；所有这些内容将在接下来的几章中变得清晰易懂。
- en: Step 2—Getting a single device
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 2 步——获取单个设备
- en: Now change the URL of the request in Postman so it points back to the Pi device
    (which is exactly the same as the one you typed in your browser in [part 1](kindle_split_007.html#part01)),
    and click Send again, as shown in [figure 2.10](#ch02fig10).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更改 Postman 中的请求 URL，使其指向 Pi 设备（这与你在[第 1 部分](kindle_split_007.html#part01)中输入浏览器中的
    URL 完全相同），然后再次点击发送，如图 2.10 所示。
- en: Figure 2.10\. Getting the JSON representation of the Raspberry Pi. The JSON
    payload contains metadata about the device as well as links to its sub-resources.
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.10. 获取 Raspberry Pi 的 JSON 表示形式。JSON 有效负载包含有关设备的元数据以及其子资源的链接。
- en: '![](02fig10_alt.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![02fig10_alt.jpg](02fig10_alt.jpg)'
- en: 'The body now contains the JSON object of the Pi except with the same information
    as shown previously, and you can see that the `resources` object has `sensors`,
    `actuators`, and so on:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设备中包含的 Pi JSON 对象与之前显示的信息相同，但你可以看到 `resources` 对象包含 `sensors`、`actuators`
    等内容：
- en: '[PRE1]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Step 3—Getting the list of sensors on the device
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3 步——获取设备上的传感器列表
- en: 'To get to the list of sensors available on the device, just as you did before,
    append `/sensors` to the URL of the Pi in Postman and send the request again.
    An HTTP GET there will return this JSON document in the response:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取设备上可用的传感器列表，就像你之前做的那样，只需在 Postman 中将 `/sensors` 添加到 Pi 的 URL，然后再次发送请求。HTTP
    GET 请求将返回此 JSON 文档作为响应：
- en: '[PRE2]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that the Pi has three sensors attached to it (respectively, `temperature`,
    `humidity`, and `pir`), along with details about each sensor and its latest value.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 Pi 上连接了三个传感器（分别是 `temperature`、`humidity` 和 `pir`），以及每个传感器的详细信息及其最新值。
- en: Step 4—Get details of a single sensor
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 4 步——获取单个传感器的详细信息
- en: Finally, you’ll get the details of a specific sensor, so append `/temperature`
    to the URL in Postman and click Send again. The URL should now be [http://devices.webofthings.io/pi/sensors/temperature](http://devices.webofthings.io/pi/sensors/temperature),
    as shown in [figure 2.11](#ch02fig11).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会得到一个特定传感器的详细信息，因此将 `/temperature` 添加到 Postman 中的 URL 并再次点击发送。现在 URL 应该是
    [http://devices.webofthings.io/pi/sensors/temperature](http://devices.webofthings.io/pi/sensors/temperature)，如图
    2.11 所示。
- en: Figure 2.11\. Retrieve the temperature sensor object from the Raspberry Pi.
    You can see the latest reading (23.4 degrees Celsius) and when it took place (at
    14:43 on October 4, 2015).
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.11. 从 Raspberry Pi 获取温度传感器对象。你可以看到最新的读数（23.4 摄氏度）以及它发生的时间（2015 年 10 月 4
    日 14:43）。
- en: '![](02fig11_alt.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![02fig11_alt.jpg](02fig11_alt.jpg)'
- en: 'You will get detailed information about the temperature sensor, in particular
    the latest value that was read (the value field). If you only want to retrieve
    the sensor value, you can append /value to the URL of the sensor to retrieve it,
    which also work for other sensors:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得有关温度传感器的详细信息，特别是读取的最新值（值字段）。如果你只想检索传感器值，你可以将 `/value` 添加到传感器的 URL 来检索它，这也适用于其他传感器：
- en: '[PRE3]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 2.2.3\. So what?
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3. 那么，这又意味着什么呢？
- en: 'Now it’s time for you to play around with the different URLs you’ve seen so
    far in this exercise. Look at how they differ and are structured, browse around
    the device, and try to understand what data each sensor has, its format, and so
    on. As an extension look at the electronic devices around you—the appliances in
    your kitchen or the TV or sound system in your living room, the ordering system
    in the café, or the train notification system, depending on where you’re reading
    this book from. Now imagine how the services and data offered by all these devices
    could all have a similar structure: URLs, content, paths, and so on. Try to map
    this system using the same JSON structure you’ve just seen, and write the URLs
    and JSON object that would be returned.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让你在这个练习中看到的不同 URL 进行一番探索了。看看它们如何不同以及它们的结构，浏览设备，并尝试理解每个传感器有什么数据，其格式等。作为一个扩展，看看你周围的电子设备——厨房里的电器或你客厅里的电视或音响系统，咖啡馆的订餐系统，或者你所在地区的火车通知系统。现在想象一下，所有这些设备提供的服务和数据可能都具有相似的结构：URL、内容、路径等。尝试使用你刚刚看到的相同
    JSON 结构来映射这个系统，并写出返回的 URL 和 JSON 对象。
- en: What you have seen is that both humans and applications get data using exactly
    the same URL but using different encoding formats (HTML for humans, JSON for applications).
    Obviously, the data in both cases is identical, which makes it easy for application
    developers to go back and forth from one format to the other. This is one example
    of how simple—yet powerful—web technologies can be. Thanks to immensely popular
    web standards such as HTTP and URLs, it becomes straightforward to interact with
    the real world from any web browser. You’ll learn much more about these concepts
    in [chapter 6](kindle_split_014.html#ch06) onward.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您所看到的是，人类和应用程序使用完全相同的 URL 获取数据，但使用不同的编码格式（人类使用 HTML，应用程序使用 JSON）。显然，两种情况下的数据都是相同的，这使得应用程序开发者可以轻松地在两种格式之间来回转换。这是简单但强大的
    Web 技术的一个例子。多亏了像 HTTP 和 URL 这样极其流行的 Web 标准，从任何 Web 浏览器与真实世界交互变得非常简单。您将在第 6 章及以后学到更多关于这些概念的内容。
- en: 2.3\. Exercise 2—Polling data from a WoT sensor
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 练习 2—从 WoT 传感器轮询数据
- en: In the first exercise you learned about the structure of a WoT device and how
    it works. In particular, you saw that every element of the device is simply a
    resource with a unique URL that can be used by both people and applications to
    read and write data. Now you’re going to put a developer hat on and start coding
    your first web application that interacts with this Web of Things device.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，您学习了 WoT 设备的结构以及它是如何工作的。特别是，您看到设备的每个元素都是一个资源，具有唯一的 URL，人们和应用程序都可以使用它来读取和写入数据。现在，您将戴上开发者的帽子，开始编写您的第一个与这个物联网设备交互的
    Web 应用程序。
- en: 2.3.1\. Part 1—Polling the current sensor value
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1. 第一部分—轮询当前传感器值
- en: For this exercise, go to the folder you checked out from GitHub into the chapter2-hello-wot/client
    folder. Double-click the ex-2.1-polling-temp.html file to open it in a modern
    browser.^([[3](#ch02fn03)]) This page displays the value of the temperature sensor
    on the Pi in our office and updates this value every five seconds by retrieving
    it in JSON, exactly as you saw in [figure 2.11](#ch02fig11).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，请转到您从 GitHub 检出的文件夹，进入 chapter2-hello-wot/client 文件夹。双击 ex-2.1-polling-temp.html
    文件，在现代浏览器中打开它.^([[3](#ch02fn03)]) 此页面显示我们办公室 Pi 上的温度传感器值，并每隔五秒通过检索 JSON 格式来更新此值，正如您在
    [图 2.11](#ch02fig11) 中所看到的那样。
- en: ³
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We fully tested our examples on Firefox (>41) and Chrome (>46) and suggest you
    install the latest version of these. Safari (>9) should also work. If you really
    want to use Internet Explorer, please be aware that you’ll need version 10 onward;
    older versions won’t work.
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在 Firefox (>41) 和 Chrome (>46) 上完全测试了我们的示例，并建议您安装这些浏览器的最新版本。Safari (>9) 也应该可以工作。如果您真的想使用
    Internet Explorer，请注意您将需要版本 10 及以上；较旧版本将无法工作。
- en: 'This file uses jQuery^([[4](#ch02fn04)]) to poll data from the temperature
    sensor on our Pi. Now open this file in your favorite code editor and look at
    the source code. You’ll see two things there:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件使用 jQuery^([[4](#ch02fn04)]) 从我们 Pi 上的温度传感器轮询数据。现在请打开此文件到您最喜欢的代码编辑器中，查看源代码。您将看到以下两点：
- en: ⁴
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'jQuery is a handy JavaScript library that makes it easier to do lots of things,
    such as talk to REST APIs, manipulate HTML elements, handle events, and so on.
    Learn more here: [http://jquery.com/](http://jquery.com/).'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: jQuery 是一个方便的 JavaScript 库，它使得做很多事情变得更容易，例如与 REST API 通信、操作 HTML 元素、处理事件等等。更多信息请访问：[http://jquery.com/](http://jquery.com/)。
- en: An `<h2>` tag showing where the current sensor value will be written.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `<h2>` 标签显示当前传感器值将被写入的位置。
- en: A JavaScript function called `doPoll()` that reads the value from the Pi, displays
    it, and calls itself again five seconds later. This function is shown in the following
    listing.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `doPoll()` 的 JavaScript 函数，它从 Pi 读取值，显示它，并在五秒后再次调用自己。此函数在下面的列表中显示。
- en: Listing 2.1\. Polling for the temperature sensor
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1. 轮询温度传感器
- en: '![](042fig01_alt.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](042fig01_alt.jpg)'
- en: When developing (and especially debugging!) web applications, it might be useful
    to display content from JavaScript outside the page; for this you have a JavaScript
    console. To access it in Chrome, right-click somewhere on the page and select
    Inspect Element; then look for the console that appears below where you can see
    the HTML code of the current page. The `console.log(data)` statement displays
    the `data` JSON object received from the server in this console.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发（尤其是调试！）Web 应用程序时，显示页面外的 JavaScript 内容可能很有用；为此，您有一个 JavaScript 控制台。要在 Chrome
    中访问它，请右键单击页面上的某个位置，然后选择“检查元素”；然后查找出现在当前页面 HTML 代码下方出现的控制台。`console.log(data)`
    语句在此控制台中显示从服务器接收到的 `data` JSON 对象。
- en: 2.3.2\. Part 2—Polling and graphing sensor values
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 第二部分—轮询和图表化传感器值
- en: This is great, but in some cases you’d like to display more than the current
    value of the sensor—for example, a graph of all readings in the last hour or week.
    Open the second HTML file in the exercises (ex-2.2-polling-temp-chart.html). This
    is a slightly more complex example that keeps track of the last 10 values of the
    temperature sensor and displays them in a graph. When you open this second file
    in your browser, you’ll see the graph being updated every two seconds, as shown
    in [figure 2.12](#ch02fig12).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但在某些情况下，你可能希望显示比传感器当前值更多的信息——例如，过去一小时或一周的所有读数的图表。打开练习中的第二个 HTML 文件（ex-2.2-polling-temp-chart.html）。这是一个稍微复杂一些的例子，它跟踪温度传感器的最后
    10 个值并在图表中显示它们。当你用浏览器打开这个第二个文件时，你会看到图表每两秒更新一次，如图 2.12 所示。
- en: Figure 2.12\. This graph gets a new value every few seconds from the device
    and is updated automatically.
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.12\. 这个图表每隔几秒从设备获取一个新值，并自动更新。
- en: '![](02fig12_alt.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig12_alt.jpg)'
- en: We built this graph using Google Charts,^([[5](#ch02fn05)]) a nice and lightweight
    JavaScript library for displaying all sorts of charts and graphs. See our annotated
    code sample in the next listing.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Google Charts 构建了这个图表，^([[5](#ch02fn05)]) 这是一个用于显示各种图表和图形的不错且轻量级的 JavaScript
    库。请参阅我们下一列表中的注释代码示例。
- en: ⁵
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://developers.google.com/chart/](https://developers.google.com/chart/)'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/chart/](https://developers.google.com/chart/)'
- en: Listing 2.2\. Polling and displaying a sensor reading
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 轮询并显示传感器读数
- en: '![](ch02ex02-0.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch02ex02-0.jpg)'
- en: '![](ch02ex02-1.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch02ex02-1.jpg)'
- en: 2.3.3\. Part 3—Real-time data updates
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 第三部分—实时数据更新
- en: In the previous exercises, polling the temperature sensor of the Pi worked just
    fine. But this seems somewhat inefficient, doesn’t it? Instead of having to fetch
    the temperature from the device every two seconds or so, wouldn’t it be better
    if our script was *informed* of any change of temperature when it happens, and
    only if the value changes?
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，轮询 Pi 的温度传感器工作得很好。但这似乎有些低效，不是吗？我们不需要每隔两秒或更长时间从设备获取温度，如果我们的脚本在温度变化时被*通知*，并且只有当值发生变化时，这不是更好吗？
- en: 'As we’ll explore to a greater extent in [chapter 6](kindle_split_014.html#ch06),
    this has been one of the major impedance mismatches between the model of the web
    and the event-driven model of wireless sensor applications. For now, we’ll look
    at one way of resolving the problem using a relatively recent add-on to the web:
    *WebSockets*. In a nutshell, WebSockets are simple yet powerful mechanisms for
    web servers to push notifications to web clients introduced as part of the efforts
    around the HTML5 standards.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 6 章中将要更深入地探讨的那样，这一直是网络模型和无线传感器应用的事件驱动模型之间主要的阻抗不匹配之一。现在，我们将探讨使用相对较新的网络附加组件来解决这个问题的方法：*WebSocket*。简而言之，WebSocket
    是一种简单而强大的机制，允许网络服务器将通知推送到作为 HTML5 标准努力的一部分引入的网络客户端。
- en: 'The WebSockets standard comprises two distinct parts: one for the server and
    one for the client. Since the server is already implemented for us, the only specification
    we’ll use here is the client part. The client WebSockets API is based on JavaScript
    and is relatively simple and straightforward. The two lines of code in the following
    listing are all you need to connect to a WebSocket server and display in the console
    all messages received.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 标准由两个不同的部分组成：一个用于服务器，一个用于客户端。由于服务器已经为我们实现，我们在这里将只使用客户端部分的规范。客户端 WebSocket
    API 基于 JavaScript，相对简单直接。以下列表中的两行代码就是连接到 WebSocket 服务器并在控制台显示所有接收到的消息所需的所有内容。
- en: Listing 2.3\. Connecting to a WebSocket and listening for messages
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 连接到 WebSocket 并监听消息
- en: '[PRE4]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s get back to our examples. Go to the folder. Double-click the ex-2.3-websockets-temp-graph.html
    file to open it in your favorite browser. What you see on the page is exactly
    the same as in the previous exercise, but under the hood things are quite different.
    Have a look at the new code shown in the next listing.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。转到文件夹。双击 ex-2.3-websockets-temp-graph.html 文件，在您喜欢的浏览器中打开它。您在页面上看到的内容与之前的练习完全相同，但在底层，事情相当不同。请查看下一列表中显示的新代码。
- en: Listing 2.4\. Register to a WebSocket and get real-time temperature updates
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 注册 WebSocket 并获取实时温度更新
- en: '![](045fig01_alt.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![图片](045fig01_alt.jpg)'
- en: In this exercise, you don’t poll periodically for new data but only register
    your interest in these updates by subscribing to the `/sensors/temperature` endpoint
    via WebSockets. When the server has new temperature data available, it will send
    it to your client (your web browser). This event will be picked up by the anonymous
    function you registered and will be given as a parameter the event object that
    contains the latest temperature value.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你不需要定期轮询新数据，而是通过订阅 `/sensors/temperature` 端点来通过 WebSockets 注册你对这些更新的兴趣。当服务器有新的温度数据可用时，它将将其发送到你的客户端（你的网页浏览器）。这个事件将由你注册的匿名函数捕获，并将包含最新温度值的事件对象作为参数传递。
- en: 2.3.4\. So what?
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4. 那么，这又意味着什么呢？
- en: 'Let’s take a step back and reflect on what you did in this exercise: you managed
    to communicate with an embedded device (the Raspberry Pi) that might be on the
    other side of the world (if you don’t happen to be living in rainy and beautiful
    England). From a web page you were able to fetch, on a regular basis, data from
    a sensor connected to the device and display it on a graph. Not bad for a simple
    web page of 60 lines of HTML, JavaScript, and CSS code. You didn’t stop there:
    with fewer than 10 lines of JavaScript you also subscribed to notifications from
    our Pi using WebSockets and then displayed the temperature in our office in real
    time. As an extension of this exercise, you could write a simple page that automatically
    fetches the image from the camera (ideally, you’d avoid doing this 25 times per
    second!).'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你在这次练习中所做的事情：你成功与一个嵌入式设备（树莓派）进行了通信，这个设备可能位于世界另一端（如果你不是住在多雨美丽的英格兰的话）。从网页上，你能够定期获取连接到设备的传感器数据，并在图表上显示。对于一个只有
    60 行 HTML、JavaScript 和 CSS 代码的简单网页来说，这已经很不错了。你没有就此止步：通过少于 10 行的 JavaScript，你还订阅了来自我们的
    Pi 的通知，并在实时显示我们办公室的温度。作为这个练习的扩展，你可以编写一个简单的页面，自动从摄像头获取图像（理想情况下，你应该避免每秒做 25 次这种操作！）。
- en: 'If this was your first encounter with the Web of Things, what should strike
    you at this stage is the simplicity of these examples. Let’s imagine for a second
    that our Pi wasn’t actually providing its data through HTTP, JSON, or WebSockets
    but via a “vintage” XML-based machine-to-machine application stack such as DPWS
    (if you’ve never heard about it, don’t worry; that’s exactly our point!). Basically,
    you wouldn’t be able to talk directly to the device from your browser without
    a lot more effort. You would have be forced to write your application using a
    lower-level and more complex language such as C or Java. You wouldn’t have been
    able to use widespread concepts and languages such as URLs, HTML, CSS, and JavaScript.
    This is also what the Web of Things is about: making things from the real world
    programmable and universally accessible by bringing them closer to the masses
    of web developers, where a lot of today’s innovations are happening.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次接触物联网，那么在这个阶段应该让你印象深刻的是这些示例的简单性。让我们想象一下，如果我们的 Pi 并不是通过 HTTP、JSON 或 WebSockets
    提供数据，而是通过一个“复古”的基于 XML 的机器到机器应用程序堆栈，比如 DPWS（如果你从未听说过它，不要担心；这正是我们的观点！）。基本上，你将无法直接从你的浏览器与设备通信，除非你付出更多的努力。你将被迫使用更低级和更复杂的语言，如
    C 或 Java 来编写你的应用程序。你将无法使用像 URL、HTML、CSS 和 JavaScript 这样广泛的概念和语言。这也是物联网的宗旨：通过将事物带入大众，使现实世界中的事物可编程且普遍可访问，从而推动许多今天的创新。
- en: As mentioned before, in this book you’ll learn a lot more about the art of API
    crafting for physical things. In [chapter 6](kindle_split_014.html#ch06) we’ll
    look at HTTP, REST, and JSON as well as at the real-time web, and in [chapter
    7](kindle_split_015.html#ch07) we’ll discover how to use gateways to bring other
    protocols and systems closer to the goodness of the web.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在这本书中，你将学习更多关于为物理事物制作 API 的艺术。在第 6 章 [kindle_split_014.html#ch06] 中，我们将探讨
    HTTP、REST 和 JSON 以及实时网络，而在第 7 章 [kindle_split_015.html#ch07] 中，我们将发现如何使用网关将其他协议和系统带入网络的美好之中。
- en: 2.4\. Exercise 3—Act on the real world
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 练习 3—对现实世界采取行动
- en: So far, you’ve seen various ways to read all sorts of sensor data from web devices.
    What about “writing” to a device? For example, you’d like to send a command to
    your device to change a configuration parameter. In other cases, you might want
    to control an actuator (for example, open the garage door or turn off all lights).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了从网络设备读取各种传感器数据的不同方法。那么，“写入”设备呢？例如，你可能想向设备发送一个命令来更改配置参数。在其他情况下，你可能想控制一个执行器（例如，打开车库门或关闭所有灯光）。
- en: 2.4.1\. Part 1—Use a form to update text to display
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 第一部分——使用表单更新要显示的文本
- en: 'To illustrate how you can send commands to an actuator, this exercise will
    show you how to build a simple page that allows you to send some text to the LCD
    connected to the Pi in our office. To test this functionality first, open the
    actuator page of the LCD: [http://devices.webofthings.io/pi/actuators/display](http://devices.webofthings.io/pi/actuators/display).'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明你如何向执行器发送命令，这个练习将向你展示如何构建一个简单的页面，允许你向连接到我们办公室Pi的LCD发送一些文本。为了测试这个功能，首先打开LCD的执行器页面：[http://devices.webofthings.io/pi/actuators/display](http://devices.webofthings.io/pi/actuators/display)。
- en: 'On this page (shown in [figure 2.13](#ch02fig13)), you now see the various
    *properties* of the LED actuator. First, you see `brightness`, which you could
    change (but can’t, because we made it read-only). Then, you have `content`, which
    is the value you want to send, and finally there is the `duration`, which specifies
    how long the text will be displayed on our LCD. Use Postman to get the JSON object
    that describes the display actuator by entering the URL shown in the last paragraph,
    as you learned in the first exercise of this chapter:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在本页（如图2.13所示）中，你现在可以看到LED执行器的各种**属性**。首先，你看到的是`亮度`，你可以更改它（但无法更改，因为我们将其设置为只读）。然后，你有`内容`，这是你想要发送的值，最后是`持续时间`，它指定文本将在我们的LCD上显示多长时间。使用Postman通过输入上一段中显示的URL来获取描述显示执行器的JSON对象，正如你在本章第一项练习中学到的那样：
- en: '[PRE5]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Figure 2.13\. The details of the LCD actuator, with the various properties that
    you can set, for example, the text that should be displayed next on the device
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.13\. LCD执行器的详细信息，以及你可以设置的各个属性，例如，设备上接下来要显示的文本
- en: '![](02fig13_alt.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig13_alt.jpg)'
- en: 'Obviously, it wouldn’t be much fun to display something in our office if you
    couldn’t see what was being displayed. For this reason, we’ve set up a webcam
    where you can see the LCD on our Pi, so you can always see what is displayed on
    it. Here’s the URL: [http://devices.webofthings.io/camera/sensors/picture](http://devices.webofthings.io/camera/sensors/picture).
    Go ahead; open this page, and you’ll see the latest picture of the camera you
    saw in [figure 2.3](#ch02fig03) (to see the latest image, refresh the page).'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你无法看到显示的内容，那么在我们的办公室显示东西就不会很有趣。因此，我们设置了一个可以查看我们Pi上LCD的摄像头，这样你就可以始终看到它上显示的内容。以下是URL：[http://devices.webofthings.io/camera/sensors/picture](http://devices.webofthings.io/camera/sensors/picture)。继续打开这个页面，你将看到你在图2.3中看到的最新相机图像（要查看最新图像，请刷新页面）。
- en: 'Now you’ll send a new message to the Pi for it to be displayed by the LCD.
    The `content` property is always the current message displayed on the LCD, so
    to update it you POST a new value for that property with the message to be displayed
    (for example, `{"value": "Hello World!"}`) as a body. You can go ahead and try
    this in Postman, but the simplest way to do it is through the page of the display
    actuator in your browser: [http://devices.webofthings.io/pi/actuators/display](http://devices.webofthings.io/pi/actuators/display).
    See [figure 2.13](#ch02fig13) for the details of the LCD actuator.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，你将向Pi发送一条新消息，以便通过LCD显示。`内容`属性始终是LCD上当前显示的消息，因此要更新它，你需要通过POST一个新值作为消息体来更新该属性（例如，`{"value":
    "Hello World!"}`）。你可以继续在Postman中尝试这样做，但最简单的方法是通过浏览器中的显示执行器页面：[http://devices.webofthings.io/pi/actuators/display](http://devices.webofthings.io/pi/actuators/display)。见图2.13以了解LCD执行器的详细信息。'
- en: 'On this page you can see the various properties of the LCD actuator. Some are
    editable, and some aren’t. The `content` property is the one you want to edit,
    so enter the text you’d like to display and click Update. If all works fine, you’ll
    see a JSON payload like this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，你可以看到LCD执行器的各种属性。其中一些是可编辑的，而另一些则不是。`内容`属性是你想要编辑的属性，因此输入你想要显示的文本并点击更新。如果一切正常，你将看到如下JSON有效负载：
- en: '[PRE6]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The returned payload contains the message that will be displayed, a unique ID
    for your message, and an estimated delay for when your text will appear on the
    LCD screen (in seconds), so you know when to look at the camera image to see your
    text.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的有效负载包含将要显示的消息、你消息的唯一ID以及文本将在LCD屏幕上显示的估计延迟（以秒为单位），这样你就知道何时查看相机图像以查看你的文本。
- en: 2.4.2\. Part 2—Create your own form to control devices
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 第二部分——创建自己的表单来控制设备
- en: Now let’s build a simple HTML page that allows you to send all sorts of commands
    to a web device using a simple form. From your browser, open the file ex-3.1-actuator-form.html
    in the exercises folder and you’ll see the screen shown in [figure 2.14](#ch02fig14).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的 HTML 页面，允许你使用简单的表单向网络设备发送各种命令。从你的浏览器中，打开练习文件夹中的文件 ex-3.1-actuator-form.html，你将看到
    [图 2.14](#ch02fig14) 中所示的屏幕。
- en: Figure 2.14\. This simple client-side form allows you to send new text to be
    displayed by the Pi.
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.14\. 这个简单的客户端表单允许你向 Pi 发送要显示的新文本。
- en: '![](02fig14.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.14](02fig14.jpg)'
- en: This page has an input text field and a Send to Pi button, as shown in the following
    listing. Whatever text you enter will be displayed on the LCD screen of the Pi
    in our office. Please keep it courteous, and because the API of our Pi is open
    to the public, we decline all responsibility for what people write there.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面有一个输入文本字段和一个发送到 Pi 的按钮，如下所示。你输入的任何文本都将显示在我们办公室的 Pi 的液晶屏幕上。请保持礼貌，并且由于我们的 Pi
    API 对公众开放，我们对此处人们所写的内容不承担任何责任。
- en: Listing 2.5\. Simple HTML form to send a command to an actuator
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5\. 简单的 HTML 表单，用于向执行器发送命令
- en: '[PRE7]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a simple HTML form that sends an HTTP POST (value of `method`) to the
    URL of the display (the value of `action`). The input text bar is called *value*
    (`name="value"`) so that the Pi knows what text to display. This method works
    well for a basic website. Unfortunately, what you don’t see behind the scenes
    is that web browsers do not submit (nor do they make it possible to submit) data
    to the server using a JSON payload body (as you could easily do with Postman previously)
    but instead use a format called `application/x-www-form-urlencoded`. The Pi needs
    to be able to understand this format in addition to `application/json` in order
    to handle data input from HTML forms.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 HTML 表单，它将 HTTP POST（`method` 的值）发送到显示的 URL（`action` 的值）。输入文本栏被称为 *value*（`name="value"`），这样
    Pi 就知道要显示什么文本。这种方法对于基本网站来说效果很好。不幸的是，你无法看到幕后的是，网络浏览器不会使用 JSON 负载体（正如你以前可以用 Postman
    容易做到的那样）提交数据到服务器，而是使用一种称为 `application/x-www-form-urlencoded` 的格式。Pi 需要能够理解这种格式，以及
    `application/json`，以便处理来自 HTML 表单的数据输入。
- en: HTML forms can use only the verbs POST or GET, not DELETE or PUT. It’s rather
    unfortunate that even modern browsers don’t send the content of HTML forms as
    JSON objects because of some obscure legacy reasons, but hey, *c’est la vie!*
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 表单只能使用动词 POST 或 GET，不能使用 DELETE 或 PUT。遗憾的是，即使是现代浏览器也因为一些神秘的历史原因而没有将 HTML
    表单的内容作为 JSON 对象发送，但嘿，*这就是生活！*
- en: As you’ll see later in this book, the ability for all entities on the Web of
    Things to receive and transmit JSON content is essential to guarantee a truly
    open ecosystem. For this reason, we’ll show you how to send actual JSON from an
    HTML form page (by using AJAX and JavaScript), because doing so is an essential
    part of communicating with web devices.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本书后面看到的那样，Web 物联网上所有实体接收和传输 JSON 内容的能力对于确保一个真正开放的生态系统至关重要。因此，我们将向你展示如何从
    HTML 表单页面发送实际的 JSON 数据（通过使用 AJAX 和 JavaScript），因为这样做是与网络设备通信的一个基本部分。
- en: Open the ex-3.2-actuator-ajax-json.html file to see a similar form but this
    time with a large piece of JavaScript, shown in the following listing.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 ex-3.2-actuator-ajax-json.html 文件，可以看到一个类似表单，但这次包含一大段 JavaScript，如下所示。
- en: Listing 2.6\. Send an HTTP POST with JSON payload from a form
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. 从表单发送带有 JSON 负载的 HTTP POST 请求
- en: '![](049fig01_alt.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.9fig01_alt](049fig01_alt.jpg)'
- en: In this code, a function called `processForm()` is defined, which takes the
    data from the form, packs it into a JSON object, POSTs it to the Pi, and displays
    the result if successful (or displays an error in the console otherwise). The
    `url` parameter specifies the end-point URL (the Pi display), the `method` is
    the HTTP method to use, and the `contentType` is the format of the content sent
    to the server (in this case `application /json`). The last line attaches the event
    generated by a click of the Submit button of the form `#message-form` to call
    the `processForm()` function.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，定义了一个名为 `processForm()` 的函数，它从表单中获取数据，将其打包成一个 JSON 对象，并将其 POST 到 Pi，如果成功则显示结果（否则在控制台显示错误）。`url`
    参数指定了端点 URL（Pi 显示），`method` 是要使用的 HTTP 方法，而 `contentType` 是发送到服务器的内容的格式（在这种情况下为
    `application/json`）。最后一行将表单 `#message-form` 的提交按钮点击事件附加到调用 `processForm()` 函数。
- en: There is a variation of this code, ex-3.2b-actuator-ajax-form.html, which encodes
    the data in the `application/x-www-form-urlencoded` format in place of JSON, as
    it’s done with the simple form we showed in [part 1](kindle_split_007.html#part01)
    of exercise 3.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个变体，即ex-3.2b-actuator-ajax-form.html，它将数据编码为`application/x-www-form-urlencoded`格式，而不是JSON，就像我们在练习3的第[1部分](kindle_split_007.html#part01)中展示的简单表单那样。
- en: 2.4.3\. So what?
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3. 那么，这又意味着什么呢？
- en: In this section you learned the basics of how to send data and commands to a
    device, both using a form on a web page and from an API. You had a crash course
    in the limitations, challenges, and problems of the modern web (don’t worry; there
    are many more ahead!), in particular how different web browsers can interpret
    and implement the same web standards differently. Finally, you learned how to
    use AJAX to bypass these limitations and send JSON commands to a Raspberry Pi
    and control it remotely.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用网页表单和API向设备发送数据和命令的基础知识。你接受了现代网络限制、挑战和问题的快速课程（别担心，还有更多！），特别是不同的网络浏览器如何以不同的方式解释和实现相同的网络标准。最后，你学习了如何使用AJAX绕过这些限制，并向树莓派发送JSON命令以远程控制它。
- en: We hope that after doing this exercise you realize that it’s straightforward
    to send actuator commands over the web to all sorts of devices—as long as these
    are connected to the web and offer a simple HTTP/JSON interface. But the last
    problem is how to find a device nearby, understand its API, determine what functions
    are offered by the device, and know what parameters you need to include in your
    command, along with their type, unit, limitations, and the like. The next section
    will show you how to solve this problem, so keep reading.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你在完成这个练习后意识到，只要这些设备连接到互联网并提供了简单的HTTP/JSON接口，发送执行器命令到各种设备是非常直接的。但最后一个问题是如何找到附近的设备，理解其API，确定设备提供的功能，以及知道在你的命令中需要包含哪些参数，包括它们的类型、单位、限制等。下一节将向你展示如何解决这个问题，所以请继续阅读。
- en: 2.5\. Exercise 4—Tell the world about your device
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5. 练习4——向世界介绍你的设备
- en: In the previous exercises you learned how devices can be easily exposed over
    the web and then explored and used by other client applications. But those examples
    assumed that you (as a human developer or as the application you wrote) *know*
    what the fields of the JSON objects (for example, sensor or actuator) mean and
    how to use them. But how is this possible? What if the only thing you know about
    a device is its URL and nothing else?
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，你学习了如何轻松地将设备暴露在网络上，然后由其他客户端应用程序探索和使用。但那些例子假设你（作为一个人类开发者或你编写的应用程序）*知道*
    JSON对象的字段（例如，传感器或执行器）的含义以及如何使用它们。但这怎么可能呢？如果你对设备的唯一了解就是它的URL，而其他一无所知呢？
- en: Imagine you’d like to build a web application that can control home automation
    devices present in your local network. How can you ensure this application will
    always work, even if you’re in someone else’s network and you don’t know anything
    about the devices there?
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想构建一个可以控制本地网络中智能家居设备的Web应用程序。你如何确保这个应用程序始终可以工作，即使你身处他人的网络，你对那里的设备一无所知？
- en: First, you need to find the devices at a network level (the *device discovery*
    problem). In other words, how can your web application discover the root URL of
    all the devices around you?
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在网络层面上找到设备（即*设备发现*问题）。换句话说，你的Web应用程序如何发现你周围所有设备的根URL？
- en: Second, even if you happen to know (by some magic trick) the root URL of all
    Web of Things–compatible devices around you, how can your application “understand”
    what sensors or actuators these devices offer, what formats they use, and the
    meaning of those devices, properties, fields, and so on?
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，即使你偶然知道（通过某种魔法技巧）你周围所有Web of Things兼容设备的根URL，你的应用程序“理解”这些设备提供的传感器或执行器，它们使用的格式，以及这些设备、属性、字段等含义又该如何呢？
- en: As you saw in exercise 2 ([section 2.3.2](#ch02lev2sec6)), if you know the root
    URL of a device, you can easily browse the device and find data about it and its
    sensors, services, and more. This is easy because you’re a human, but imagine
    if you had a JSON document with unintelligible words or characters and no documentation
    that explain what those words mean—how would you know what the device does? And
    how would you know it’s a device, for that matter?
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在练习2（[第2.3.2节](#ch02lev2sec6)）中看到的，如果你知道设备的根URL，你可以轻松地浏览设备并找到关于它及其传感器、服务等方面的数据。这很简单，因为你是一个人类，但想象一下，如果你有一个包含无法理解的单词或字符的JSON文档，并且没有任何解释这些单词含义的文档——你将如何知道设备的功能？你又将如何知道它是一个设备呢？
- en: Open ex-4-parse-device.html in your browser and you’ll see a form prepopulated
    with the URL of the Pi ([figure 2.15](#ch02fig15)). Click Browse This Device.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开ex-4-parse-device.html，你会看到一个预先填充了Pi的URL（[图2.15](#ch02fig15)）的表单。点击浏览此设备。
- en: Figure 2.15\. A mini-browser that parses your device metadata and displays the
    results
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.15\. 一个解析你的设备元数据并显示结果的迷你浏览器
- en: '![](02fig15_alt.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![图片2.15](02fig15_alt.jpg)'
- en: This JavaScript code of ex-4-parse-device.html will read the root document of
    the Raspberry Pi (as JSON) and generate a simple report about the device and its
    sensors, along with link to the documentation for this device. First, let’s look
    at the HTML code to display the report, as shown in the next listing.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ex-4-parse-device.html的这段JavaScript代码将读取树莓派的根文档（作为JSON）并生成一个关于设备及其传感器的简单报告，以及指向此设备文档的链接。首先，让我们看看显示报告的HTML代码，如下一列表所示。
- en: Listing 2.7\. A basic device browser
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 一个基本的设备浏览器
- en: '[PRE8]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing you can see is a form where you can enter the root URL of a
    device with a Browse button. Then, there are some HTML text elements that will
    act as placeholders (`meta`, `doc`, and so on). Now let’s look at the AJAX calls
    in the following listing.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先可以看到一个表单，你可以在这里输入设备的根URL并带有浏览按钮。然后，有一些HTML文本元素将充当占位符（`meta`、`doc`等）。现在让我们看看以下列表中的AJAX调用。
- en: Listing 2.8\. Retrieve and parse device metadata using AJAX JSON calls
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8\. 使用AJAX JSON调用检索和解析设备元数据
- en: '![](ch02ex08-0.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图片2.2.8](ch02ex08-0.jpg)'
- en: '![](ch02ex08-1.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![图片2.2.8-1](ch02ex08-1.jpg)'
- en: 'Looking at this code, you can see that you first set the root JSON document
    of the device using the URL entered in the form (`$(''#host'').val()`). If the
    JSON file has been successfully retrieved, the `success` callback function will
    be triggered with the `data` variable containing the root JSON document of the
    device (which was shown in step 2 of [section 2.2.2](#ch02lev2sec3)). Then you
    parse this JSON to extract the elements you’re looking for; in this case the code
    is looking for a `links` element in the returned JSON object (hence the `data.links`),
    which contains various links to get more information about this device, which
    looks like the following code:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 看着这段代码，你可以看到你首先使用表单中输入的URL（`$('#host').val()`）设置了设备的根JSON文档。如果JSON文件已成功检索，则`success`回调函数将被触发，其中`data`变量包含设备的根JSON文档（如[第2.2.2节](#ch02lev2sec3)的第2步所示）。然后你解析这个JSON以提取你正在寻找的元素；在这种情况下，代码正在寻找返回的JSON对象中的`links`元素（因此是`data.links`），它包含各种链接，可以获取更多关于此设备的信息，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In particular, the `meta` element contains a link (value of `rel`) to the general
    model used by this device (which describes the grammar used to describe the elements
    of this device) and then a `doc` that links to a human-readable documentation
    that describes the meaning (the semantics) and specific details of this particular
    device (that is, which sensors are present and what they measure).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`meta`元素包含一个链接（`rel`的值）指向此设备使用的通用模型（它描述了描述此设备元素所使用的语法），然后是一个`doc`，它链接到一个人类可读的文档，该文档描述了此特定设备的含义（即，哪些传感器存在以及它们测量什么）。
- en: The metadata document linked in the previous code is nothing more than a machine-readable
    JSON document model that allows users to describe WoT devices in a structured
    manner, along with a definition of the logic elements all WoT devices must have.
    If hundreds of device manufacturers would use this same data model to expose the
    services of their devices, it would mean that any application that can read and
    parse this file would be able to read the JSON file returned by the device and
    understand the components of the devices (how many sensors it has, their names
    or limitations, their type, and so on).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一段代码中链接的元数据文档不过是一个可机器读取的JSON文档模型，它允许用户以结构化的方式描述WoT设备，并定义了所有WoT设备必须具备的逻辑元素。如果成百上千的设备制造商都使用这个相同的数据模型来公开他们的设备服务，这意味着任何能够读取和解析这个文件的应用程序都能够读取设备返回的JSON文件并理解设备的组件（例如它有多少个传感器，它们的名称或限制，它们的类型等等）。
- en: 'Now, what about the sensors or actuators themselves? The `links` element only
    defined metadata (such as documentation) about the device, not the device contents
    itself. To find the sensors contained in the device, you’ll have to parse the
    `sensors` field of the `resources` element, which is what happens in the second
    AJAX call where you do a GET on the sensors resource of the device. Once you get
    the sensors JSON document, you iterate over each sensor and create a link to it
    using this pattern:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于传感器或执行器本身呢？`links`元素只定义了关于设备的元数据（例如文档），而不是设备本身的内容。要找到设备中包含的传感器，你需要解析`resources`元素的`sensors`字段，这就是在第二个AJAX调用中发生的事情，你在设备的传感器资源上执行GET操作。一旦你得到了传感器的JSON文档，你将遍历每个传感器，并使用以下模式创建一个链接：
- en: '[PRE10]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here `sensorsPath` is the URL of the sensors resource (in this case [http://devices.webofthings.io/pi/sensors](http://devices.webofthings.io/pi/sensors))
    to which you add the sensor ID of each sensor (`key`), along with the name of
    the respective sensor (`data[key].name`).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sensorsPath`是传感器资源的URL（在这种情况下为[http://devices.webofthings.io/pi/sensors](http://devices.webofthings.io/pi/sensors)），你将添加每个传感器的传感器ID（`key`），以及相应传感器的名称（`data[key].name`）。
- en: 2.5.1\. So what?
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1. 那又如何？
- en: 'If you didn’t understand all the details of the previous exercises, it’s perfectly
    fine—there’s nothing wrong with you! What happened is that you got your first
    hands-on crash course on the Semantic Web, or rather, on the hard problems it
    tries to solve. The reason you’ve heard a lot about it yet never seen or used
    it (or understood it, for that matter) is that it’s a complex problem for computers
    and people who program them: how the hell do you explain the real world—and its
    existential questions—to a computer? Well, it turns out you can’t really teach
    philosophy to your machine yet. But as we’ve shown here and will detail in [chapter
    8](kindle_split_016.html#ch08), there are quite a few small tricks that you can
    apply successfully that make the web—and computers—just a little smarter.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完全理解前一个练习的所有细节，那完全没问题——这并不代表你有问题！发生的事情是你第一次亲身体验了语义网，或者更确切地说，是它试图解决的难题。你之所以听到很多关于它，却从未见过或使用过（或者理解过），是因为它对计算机和编写它们的程序员来说是一个复杂的问题：你怎么向计算机解释现实世界及其存在性疑问呢？好吧，结果是你实际上还不能给你的机器教授哲学。但正如我们在这里所展示的，并在第8章中详细说明的那样，有一些小技巧可以成功地应用，使网络和计算机变得更聪明一点。
- en: You’ve seen how web devices can advertise their basic capabilities, data, and
    services in a machine-readable manner. The fact that we used well-known web patterns
    made it easy to build a web app interacting with our Things. Unfortunately, there’s
    no single standard to define this information universally, and the JSON model
    we use is something born out of trial and error over the years. In order to unlock
    the full potential of the Web of Things, we must be able to define all the details
    about an object using a single data model with clear semantics that all machines
    and applications can understand without any room for ambiguity. We’ll explore
    how to get there using web and lightweight Semantic Web technologies in much more
    detail in [chapter 8](kindle_split_016.html#ch08).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了网络设备如何以机器可读的方式宣传它们的基本能力、数据和服务。我们使用的是众所周知的网络模式，这使得构建与我们的设备交互的Web应用程序变得容易。不幸的是，没有单一的标准来定义这种信息，我们使用的JSON模型是多年来通过试错产生的。为了释放物联网的潜力，我们必须能够使用具有清晰语义的单个数据模型来定义关于一个对象的全部细节，这样所有机器和应用都能理解，没有任何歧义的空间。我们将在第8章中更详细地探讨如何使用Web和轻量级语义网技术实现这一点。
- en: 2.6\. Exercise 5—Create your first physical mashup
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6\. 练习 5—创建您的第一个物理混合应用
- en: In the previous exercises, you learned how to access a web device, understand
    the service and data it offers, and read and write data from devices. In this
    exercise, we’ll show you how to build your first mashup. The concept of mashups
    originates from the hip-hop scene to describe a song composed by taking samples
    of other songs. Similarly, a web mashup is a web application that gets data from
    various sources, processes it, and combines it to create a new application.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，您学习了如何访问网络设备，理解它提供的服务和数据，以及从设备中读取和写入数据。在这个练习中，我们将向您展示如何构建您的第一个混合应用。混合应用的概念起源于嘻哈场景，用来描述由其他歌曲采样组成的歌曲。同样，网络混合应用是一个从各种来源获取数据、处理数据并将其组合成新应用的网页应用。
- en: Here, you’ll create not only a web mashup but a *physical mashup*—a web application
    that uses data from a real sensor connected to the web. In this exercise you’re
    going to take local temperature data from the Yahoo! Weather service, compare
    it with the temperature sensor attached to the Pi in our office, and publish your
    results to the LCD screen attached to the Pi in London. Finally, to see what your
    message looks like, you’ll use the web API of the webcam to take a picture and
    display it on our web page! See [figure 2.16](#ch02fig16) for an illlustration
    of this process.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将创建不仅是一个网络混合应用，还是一个 *物理混合应用*——一个使用连接到网络的实时传感器数据的网页应用。在这个练习中，您将从雅虎天气服务获取本地温度数据，将其与办公室中连接到
    Pi 的温度传感器进行比较，并将结果发布到连接到伦敦 Pi 的 LCD 屏幕。最后，为了查看您的消息看起来像什么，您将使用摄像头的网络 API 拍摄一张照片并在我们的网页上显示！请参阅[图
    2.16](#ch02fig16)了解此过程的说明。
- en: Figure 2.16\. A physical mashup application. First (1), you retrieve the local
    temperature from Yahoo Weather and then the remote temperature from the sensor
    attached to our Pi (2). You compare it with the temperature in London and send
    the results to an LCD screen (3). When the screen displays the text you’ve sent,
    you retrieve a picture of the screen form the webcam (4) and display it on the
    mashup.
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.16\. 物理混合应用。首先（1），您从雅虎天气获取本地温度，然后从连接到我们的 Pi 的传感器获取远程温度（2）。您将其与伦敦的温度进行比较，并将结果发送到
    LCD 屏幕（3）。当屏幕显示您发送的文本时，您从摄像头获取屏幕的图片（4）并在混合应用中显示它。
- en: '![](02fig16.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig16.jpg)'
- en: Go ahead and open the file ex-5-mashup.html in both your editor and your browser.
    This code is a little longer than what you’ve seen so far but not much more complicated,
    as shown in the following listing.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，请同时在您的编辑器和浏览器中打开文件 ex-5-mashup.html。这段代码比您之前看到的要长一些，但并不复杂，如下所示。
- en: Listing 2.9\. Mashup function
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.9\. 混合函数
- en: '![](ch02ex09-0.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch02ex09-0.jpg)'
- en: '![](ch02ex09-1.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch02ex09-1.jpg)'
- en: 'The `mashup()` function is responsible for running the different bits of the
    mashup. It takes two parameters: the first parameter is your name; the second
    one is the name of the city where you live formatted as `city, country code` (for
    example, Zurich, CH; London, UK; or New York, US). It’s then essentially composed
    of two HTTP GET calls over AJAX requesting a response as `application/json` representations.
    The first call is to the Yahoo! Weather Service API, which given a location returns
    its current weather and temperature.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`mashup()` 函数负责运行混合应用的不同部分。它接受两个参数：第一个参数是您的名字；第二个参数是您居住的城市名称，格式为 `城市, 国家代码`（例如，苏黎世，CH；伦敦，UK；或纽约，US）。它本质上由两个
    AJAX 的 HTTP GET 调用组成，请求以 `application/json` 表示形式的响应。第一个调用是到雅虎天气服务 API，给定一个位置返回其当前天气和温度。'
- en: Once this call has returned (that is, the anonymous callback function has been
    invoked), the second function is called to fetch the latest value from the Pi
    temperature sensor, just as you did in [section 2.3.1](#ch02lev2sec5).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个调用返回（即，匿名回调函数已被调用），第二个函数将被调用以从 Pi 温度传感器获取最新值，就像您在[第 2.3.1 节](#ch02lev2sec5)中所做的那样。
- en: Next, you call `prepareMessage()`, which formats your message and passes the
    result to `publishMessage()`. This last function runs an HTTP POST call over AJAX
    with a JSON payload containing the message to push to the LCD screen, as done
    in Exercise 3—Act on the real world.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您调用 `prepareMessage()`，该函数格式化您的消息并将结果传递给 `publishMessage()`。这个最后的函数通过 AJAX
    运行一个 HTTP POST 调用，带有包含要推送到 LCD 屏幕的消息的 JSON 有效负载，就像在练习 3—对现实世界采取行动中所做的那样。
- en: Because you need to wait in the queue for your message to be displayed, you
    set a timer that will trigger the `takePicture()` function. This last function
    runs a final HTTP GET request to fetch a picture of what the LCD screen shows,
    via the web-enabled camera. You then dynamically add the returned picture to the
    image container of your HTML page.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你需要等待你的信息显示在队列中，你设置了一个定时器来触发`takePicture()`函数。这个最后的函数运行一个最终的HTTP GET请求，通过网络摄像头获取液晶显示屏显示的图片。然后你将返回的图片动态添加到你的HTML页面中的图像容器中。
- en: 'To start this chain of real-world and virtual-world events, all you need to
    do is edit the source code so it invokes the `mashup(x,y)` function using your
    own name and city. For example, Rachel from Zurich in Switzerland needs to call
    this function as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这一系列现实世界和虚拟世界的事件，你只需要编辑源代码，使其调用`mashup(x,y)`函数，使用你自己的名字和城市。例如，来自瑞士苏黎世的Rachel需要如下调用此函数：
- en: '[PRE11]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then open the file in your browser, and voilà! Within a few seconds, you’ll
    see a live image from the webcam with your message appearing on the screen of
    the Pi in our office.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在浏览器中打开文件，哇！几秒钟内，你将看到来自网络摄像头的实时图像，你的信息出现在我们办公室的树莓派屏幕上。
- en: 2.6.1\. So what?
  id: totrans-512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.1. 那又如何？
- en: You’ve built your first web-based physical mashup using data from various sources,
    both physical and real-time, and run a simple algorithm to decide whether your
    weather is better than ours (although competing against London on the weather
    is somewhat unfair). Think about it for a second. This mashup involves a temperature
    sensor connected to an embedded device, a video camera, an LCD screen, and a virtual
    weather service, yet you were able to create a whole new application that fits
    into 80 lines of HTML and JavaScript, UI included! Isn’t that nice? All this thanks
    to the fact that all the actors (devices and other services) expose their APIs
    on the web and therefore are directly accessible using JavaScript! You’ll learn
    much more about physical mashups throughout the book and especially in [chapter
    10](kindle_split_018.html#ch10), where we’ll survey the various tools and techniques
    available.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用来自各种来源的数据，包括物理和实时数据，构建了第一个基于网络的物理混合应用，并运行了一个简单的算法来判断你的天气是否比我们的更好（尽管与伦敦的天气竞争在某种程度上有些不公平）。想想看。这个混合应用涉及一个连接到嵌入式设备的温度传感器、一个视频摄像头、一个液晶显示屏和一个虚拟天气服务，而你却能够创建一个全新的应用，它只包含80行HTML和JavaScript代码，包括UI！这不是很棒吗？这一切都归功于所有参与者（设备和其他服务）都在网络上公开了它们的API，因此可以直接使用JavaScript进行访问！在整个书中，你将学到更多关于物理混合应用的知识，尤其是在第10章中，我们将调查可用的各种工具和技术。
- en: 2.7\. Summary
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7. 摘要
- en: You experienced your first hands-on encounter with web-connected devices across
    the world and could browse their metadata, content, sensors, actuators, and so
    on.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你第一次亲手接触到了全球范围内的网络连接设备，并可以浏览它们的元数据、内容、传感器、执行器等等。
- en: Web-connected devices can be surfed just like any other website. Real-time data
    from sensors can be consumed via an HTTP or WebSocket API just like other content
    on the web.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络连接设备可以像任何其他网站一样进行浏览。通过HTTP或WebSocket API，可以实时获取传感器的数据，就像在网络上获取其他内容一样。
- en: It’s much easier and faster to understand the basics of HTTP APIs than the various
    and complex protocols commonly used in the IoT.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与物联网中常用的各种复杂协议相比，理解HTTP API的基础要容易得多和快得多。
- en: In only a few minutes you were able to read and write data to a device across
    the world by sending HTTP requests with Postman.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在短短几分钟内，你通过发送HTTP请求使用Postman，就能读取和写入世界各地的设备数据。
- en: Connecting the physical world to the web enables rapid prototyping of interactive
    applications that require only a few lines of HTML/JavaScript code.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将物理世界连接到网络，可以快速原型化需要少量HTML/JavaScript代码的交互式应用。
- en: As data and services from various devices are made available as web resources,
    it becomes easy to build physical mashups that integrate content from all sorts
    of sources with minimal integration effort.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着各种设备的数据和服务作为网络资源提供，构建将各种来源的内容集成在一起且集成工作最少的物理混合应用变得容易。
- en: We hope you enjoyed this first encounter with the Web of Things enough to read
    the ensuing chapters and learn how to implement these concepts on your own device.
    In the next chapters, we’ll look at how to implement JavaScript on devices and
    we’ll provide a short and sweet introduction to Node.js. Then, we’ll look into
    configuring your own device and making it fit for the Web of Things. We’ll show
    you how to create and deploy a Node.js application on a Raspberry Pi device, and
    you’ll be able to create your first web-connected device and adapt these examples
    for your own use case.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您对物联网的第一次接触感到满意，以至于愿意阅读接下来的章节，并学习如何在您的设备上实现这些概念。在接下来的章节中，我们将探讨如何在设备上实现JavaScript，并提供Node.js的简短而全面的介绍。然后，我们将探讨如何配置您的设备，使其适合物联网。我们将向您展示如何在Raspberry
    Pi设备上创建和部署Node.js应用程序，您将能够创建您的第一个网络连接设备，并将这些示例适应您自己的用例。
- en: Chapter 3\. Node.js for the Web of Things
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 物联网中的Node.js
- en: '*This chapter covers*'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: An overview of how JavaScript can be used for the IoT and the WoT
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述JavaScript如何用于物联网和物联网
- en: A thorough yet accessible introduction to Node.js
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Node.js的全面而易于理解的介绍
- en: The implementation of a simple HTTP server with Node.js
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js实现简单HTTP服务器的示例
- en: An introduction to Node.js modularity and NPM
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js模块化和NPM的介绍
- en: The basics of asynchronous programming and control-flow libraries
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程和控制流库的基础
- en: The previous chapter provided a first encounter with web-connected devices.
    We hope it made you realize how easy it is to build applications that interact
    with various web-connected devices. But this was only the tip of the iceberg because
    we did all the hard work for you. In the rest of the book, we’ll teach you all
    you need to know in order to implement your own web-connected devices and applications.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章为您提供了对网络连接设备的第一次接触。我们希望这使您意识到构建与各种网络连接设备交互的应用程序是多么容易。但这只是冰山一角，因为我们为您做了所有艰苦的工作。在本书的其余部分，我们将向您传授您需要知道的一切，以便实现您自己的网络连接设备和应用程序。
- en: Before we jump straight to the code and other juicy bits, you have two important
    decisions to make. First, you have to pick an embedded platform on which your
    applications will run. This will be the subject of [chapter 4](kindle_split_011.html#ch04).
    Second, you need to choose the programming language in which you’ll write your
    code, and this is the topic of this chapter.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们直接跳到代码和其他有趣的部分之前，您有两个重要的决定要做。首先，您必须选择一个嵌入式平台，您的应用程序将在该平台上运行。这将是第4章的主题。其次，您需要选择您将用其编写代码的编程语言，这正是本章的主题。
- en: 'To choose a programming language for building your Web of Things prototypes
    you have two basic requirements: first, the language you pick should fully support
    web protocols and standards. Well, this doesn’t help much because just about any
    serious language today (who said “whitespace”?^([[1](#ch03fn01)])) provides tools
    and libraries to support HTTP. The second requirement is that you should be able
    to use a single language to build the client application, the cloud engine or
    gateways (which we’ll present in [chapter 6](kindle_split_014.html#ch06)), and
    even the code running on the embedded device. It turns out that JavaScript can
    be The One.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择一种编程语言来构建您的物联网原型，您有两个基本要求：首先，您选择的编程语言应完全支持Web协议和标准。嗯，这并没有太大的帮助，因为今天几乎任何严肃的语言（谁说“空白字符”？^([[1](#ch03fn01)]))都提供了工具和库来支持HTTP。第二个要求是您应该能够使用一种语言来构建客户端应用程序、云引擎或网关（我们将在第6章中介绍），甚至是在嵌入式设备上运行的代码。结果证明，JavaScript可以是“唯一的选择”。
- en: ¹
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Whitespace_(programming_language)](https://en.wikipedia.org/wiki/Whitespace_(programming_language))'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Whitespace_(programming_language)](https://en.wikipedia.org/wiki/Whitespace_(programming_language))'
- en: In consequence, this chapter first looks into the recent developments around
    the JavaScript community and its massively growing importance for the internet
    and the Web of Things. Afterward, we’ll introduce you to Node.js, an environment
    for writing server- side applications with JavaScript. This introduction won’t
    make you a Node.js expert, but it will certainly give you all the elements you
    need to understand how Node.js works and to be able to build and deploy the examples
    of this book.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章首先探讨了JavaScript社区的最新发展及其在互联网和物联网中的日益增长的重要性。之后，我们将向您介绍Node.js，这是一个用JavaScript编写服务器端应用程序的环境。这个介绍不会让您成为Node.js专家，但它肯定会为您提供理解Node.js工作原理以及构建和部署本书示例所需的所有要素。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How to get the code**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何获取代码**'
- en: 'If you don’t want to write the code samples we show from scratch, you can clone
    our GitHub repository (find the link here: [http://book.webofthings.io](http://book.webofthings.io)).
    All code examples in this chapter are located in the chapter3-node-js folder.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想从头开始编写我们展示的代码示例，您可以克隆我们的GitHub存储库（链接见此处：[http://book.webofthings.io](http://book.webofthings.io)）。本章中所有的代码示例都位于chapter3-node-js文件夹中。
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '3.1\. The rise of JavaScript: from clients to servers to things!'
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. JavaScript的崛起：从客户端到服务器再到物联网！
- en: JavaScript is a dynamic programming language where client-side scripts executed
    by web browsers can process data asynchronously and alter the page being displayed.
    Long gone are the days when JavaScript was solely used to animate banners on a
    web page! Thanks to its widespread support by virtually all web browsers, relative
    ease of use, and flexibility, JavaScript has become the de facto solution for
    writing dynamic, client-side applications. According to the number of public repositories
    on GitHub, it has also become one of the most popular programming languages ever,^([[2](#ch03fn02)])
    with a community of developers growing faster than any other; see [figure 3.1](#ch03fig01).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种动态编程语言，由网络浏览器执行的客户端脚本可以异步处理数据并改变显示的页面。JavaScript仅用于在网页上动画化横幅的日子已经一去不复返了！多亏了几乎所有网络浏览器对其广泛的支持、相对易用性和灵活性，JavaScript已经成为编写动态客户端应用程序的事实上的解决方案。根据GitHub上公共存储库的数量，它也已经成为历史上最受欢迎的编程语言之一，拥有一个增长速度超过其他任何语言的开发者社区；参见[图3.1](#ch03fig01)。
- en: ²
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.tiobe.com/tiobe_index](http://www.tiobe.com/tiobe_index)'
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.tiobe.com/tiobe_index](http://www.tiobe.com/tiobe_index)'
- en: 'Figure 3.1\. The ranking of the most popular languages on GitHub. Since 2008
    JavaScript has experienced a steady growth that led it to outnumber all other
    languages in terms of available projects on GitHub. [Source: GitHub.com]'
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1. GitHub上最受欢迎的语言排名。自2008年以来，JavaScript经历了稳步增长，使其在GitHub上可用的项目数量上超过了所有其他语言。[来源：GitHub.com]
- en: '![](03fig01_alt.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig01_alt.jpg)'
- en: 'This ongoing JavaScript revolution aligns well with the core idea of the Web
    of Things, which is to integrate devices to the web so they become more accessible
    and easier to program. In other words, make it possible to interact with devices
    just like any other resource on the web by using well-known web standards. When
    the services exposed by physical objects can be accessed via simple HTTP requests,
    writing interactive applications for the physical world becomes as easy as creating
    any basic web application: by writing with HTML, CSS, and JavaScript!'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这场正在进行的JavaScript革命与物联网的核心思想非常契合，即整合设备到网络中，使它们更易于访问和编程。换句话说，通过使用众所周知的网络标准，使与设备交互变得与在网络上交互任何其他资源一样简单。当物理对象暴露的服务可以通过简单的HTTP请求访问时，为物理世界编写交互式应用程序变得与创建任何基本网络应用程序一样简单：通过使用HTML、CSS和JavaScript编写！
- en: On the server side, applications are often implemented using various languages
    such as PHP, Ruby, Python, or Java. But here JavaScript has recently become quite
    a popular option. Indeed, JavaScript is increasingly adopted for writing highly
    scalable server-side applications, particularly in runtime environments such as
    Node.js,^([[3](#ch03fn03)]) which we introduce shortly.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，应用程序通常使用各种语言实现，如PHP、Ruby、Python或Java。但在这里，JavaScript最近已经成为一个非常受欢迎的选择。确实，JavaScript越来越多地被用于编写高度可扩展的服务器端应用程序，尤其是在Node.js等运行时环境中，我们将在稍后介绍它，^([[3](#ch03fn03)])。
- en: ³
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Node.js isn’t the only framework for server-side JavaScript. Another example
    is Vert.x: [http://vertx.io](http://vertx.io).'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Node.js并不是唯一的服务器端JavaScript框架。另一个例子是Vert.x：[http://vertx.io](http://vertx.io)。
- en: 'The convergence of all these platforms has a fortunate implication for this
    book: it means we can mainly focus on using JavaScript to write all the examples
    in this book. We’ll use JavaScript and jQuery to build the client-side examples
    (as we did already in [chapter 2](kindle_split_009.html#ch02)), JavaScript with
    Node.js to build the servers offering the Things’ services on the web, and even
    JavaScript and Node.js code to manage hardware resources of the Things themselves,
    as we explain next.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些平台的融合对本书有幸运的启示：这意味着我们可以主要专注于使用JavaScript编写本书的所有示例。我们将使用JavaScript和jQuery构建客户端示例（正如我们在[第2章](kindle_split_009.html#ch02)中已经做的那样），使用JavaScript和Node.js构建提供物联网服务的服务器，甚至使用JavaScript和Node.js代码来管理物联网本身的硬件资源，正如我们接下来要解释的。
- en: 3.1.1\. Pushing JavaScript to things
  id: totrans-553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1. 将JavaScript推向物联网
- en: Interestingly enough, the JavaScript revolution fueled by Node.js didn’t stop
    at the browser. Nor did it stop at the servers. In the last few years, it also
    infiltrated the world of devices themselves! In a world massively dominated by
    devices running low-level C programs, JavaScript and Node.js have managed to stand
    out as a viable and easy-to-use alternative for powering all kinds of things from
    robots (for example, with the Cylon.js^([[4](#ch03fn04)]) library) to wireless
    sensor nodes. A number of embedded device platforms today directly support JavaScript
    and Node.js to write embedded code. This is the case for most Linux-based platforms
    that we’ll introduce in the next chapter, such as the Raspberry Pi, the Intel
    Edison, and Beagle Board,^([[5](#ch03fn05)]) as well as some low-power platforms
    such as the Tessel^([[6](#ch03fn06)]) and Espruino.^([[7](#ch03fn07)])
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，由Node.js引发的JavaScript革命并没有止步于浏览器。也没有止步于服务器。在过去的几年里，它还渗透到了设备本身的世界！在一个被运行底层C程序的低级设备大规模主导的世界中，JavaScript和Node.js已经设法脱颖而出，成为为各种事物供电的可行且易于使用的替代方案，从机器人（例如，使用Cylon.js库）到无线传感器节点。今天，许多嵌入式设备平台直接支持JavaScript和Node.js来编写嵌入式代码。这包括我们在下一章中将要介绍的基于Linux的大多数平台，如Raspberry
    Pi、Intel Edison和Beagle Board，[5](#ch03fn05)以及一些低功耗平台，如Tessel[6](#ch03fn06)和Espruino[7](#ch03fn07)]。
- en: ⁴
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://cylonjs.com/](http://cylonjs.com/)'
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://cylonjs.com/](http://cylonjs.com/)'
- en: ⁵
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://beagleboard.org/](http://beagleboard.org/)'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://beagleboard.org/](http://beagleboard.org/)'
- en: ⁶
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://tessel.io/](http://tessel.io/)'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://tessel.io/](http://tessel.io/)'
- en: ⁷
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.espruino.com](http://www.espruino.com)'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.espruino.com](http://www.espruino.com)'
- en: “When you have a hammer, everything looks like a nail!” we hear you say. Not
    exactly; we don’t advocate using JavaScript and Node.js for every IoT implementation.
    We’d rather compare JavaScript and Node.js to the Swiss army knife of modern IoT
    and WoT development than to a hammer. It certainly isn’t the optimal solution
    for every IoT project we can think of, but it’s a great option for many of them.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: “当你手里有一把锤子，看什么都是钉子！”我们听到你这么说。但并不完全是这样；我们并不提倡在每一个物联网实现中都用JavaScript和Node.js。我们更愿意将JavaScript和Node.js比作现代物联网和WoT开发的瑞士军刀，而不是锤子。当然，它并不是我们所能想到的每一个物联网项目的最佳解决方案，但它是许多项目的绝佳选择。
- en: An embedded application that requires absolutely predictable and real-time performance
    (for example, the code running in a high-speed train) is better off being written
    in a low-level language such as C. Moreover, JavaScript as a language is often
    criticized by its detractors for its lack of static typing and a plethora of different
    programming patterns and styles leading to code that’s sometimes harder to maintain,
    typically in large projects involving a large number of people. Nevertheless,
    its ubiquity, portability, and asynchronous event-driven model, along with a large
    and vibrant online community, make it a solid candidate to consider seriously.
    This is certainly true when using Node.js to build scalable and real-time web
    systems, but is also increasingly true for the blazing-fast prototyping of hardware
    projects.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要绝对可预测和实时性能的嵌入式应用（例如，在高速列车上运行代码），最好用C这样的底层语言编写。此外，JavaScript作为一种语言，经常受到批评者对其缺乏静态类型和众多不同的编程模式和风格的批评，这导致代码有时难以维护，尤其是在涉及大量人员的庞大项目中。尽管如此，其普遍性、可移植性和异步事件驱动模型，以及庞大的活跃在线社区，使其成为值得认真考虑的可靠选择。当使用Node.js构建可扩展和实时网络系统时，这一点尤为正确，而对于硬件项目的快速原型设计也是如此。
- en: 3.2\. Introduction to Node.js
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2. Node.js 简介
- en: Node.js—or Node, as its aficionados call it—first emerged in 2009 when a brilliant
    developer named Ryan Dahl started to build it in “starving artist” mode in Germany.
    Later on, Ryan was hired by Joyent, a cloud provider company that was an early
    supporter of Node. In 2015, the Node.js foundation was formed, with key companies
    such as Joyent, IBM, Microsoft, and Intel getting on board, giving Node.js a great
    hope for a bright professional future.^([[8](#ch03fn08)])
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js——或者如其爱好者所称呼的Node，首次在2009年出现，当时一位名叫Ryan Dahl的杰出开发者开始在德国以“饥饿艺术家”模式构建它。后来，Ryan被云服务提供商公司Joyent雇佣，该公司是Node的早期支持者。2015年，Node.js基金会成立，Joyent、IBM、Microsoft和Intel等关键公司加入，为Node.js带来了光明的职业前景的希望。[8](#ch03fn08)
- en: ⁸
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://nodejs.org/en/foundation/](https://nodejs.org/en/foundation/)'
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://nodejs.org/en/foundation/](https://nodejs.org/en/foundation/)'
- en: Node.js provides an event-driven architecture and a non-blocking I/O API (more
    details about that to follow) that optimizes an application’s throughput and scalability.
    This model is commonly used to design high-performance real-time web applications.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js提供了一个事件驱动的架构和非阻塞I/O API（关于这个的更多细节将在后面介绍），这优化了应用程序的吞吐量和可伸缩性。这种模型通常用于设计高性能的实时网络应用程序。
- en: The idea behind Node is to provide a framework in which high-performance server-side
    web applications can be written. Unlike other servers where you deploy your application
    in a running server instance, with Node your application *is* the server. Node
    builds on the highly efficient Google V8 JavaScript engine, which is at the heart
    of the Chrome browser. Node isn’t JavaScript, but JavaScript is the language you
    use to build Node applications, although other languages such as CoffeeScript
    can be used as well.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: Node背后的理念是提供一个框架，在其中可以编写高性能的服务器端网络应用程序。与其他服务器不同，您在运行的服务器实例中部署应用程序，而在Node中，您的应用程序*就是*服务器。Node建立在高效的Google
    V8 JavaScript引擎之上，这是Chrome浏览器核心。Node不是JavaScript，但您使用JavaScript语言来构建Node应用程序，尽管也可以使用像CoffeeScript这样的其他语言。
- en: Although this book assumes you have some basic knowledge of client-side JavaScript,
    it will introduce you to server-side and device-side JavaScript. Node.js is the
    framework we’ll use to build the servers running in the cloud or on the devices
    themselves. We’ll also use Node.js to access the physical peripherals of the devices
    such as sensors or actuators.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书假设您对客户端JavaScript有一些基本了解，但它将向您介绍服务器端和设备端JavaScript。Node.js是我们将用于构建在云中或设备本身上运行的服务的框架。我们还将使用Node.js访问设备的物理外围设备，如传感器或执行器。
- en: 'This book is by no means a comprehensive Node.js manual: there are a number
    of great books dedicated to Node. See, for example, Mike Cantelo’s *Node.js in
    Action, Second Edition* (Manning, 2015);^([[9](#ch03fn09)]) Alex Young and Marc
    Harter’s *Node.js in Practice* (Manning, 2014);^([[10](#ch03fn10)]) or some good
    tutorials such as Manuel Kiessling’s *The Node Beginner Book.*^([[11](#ch03fn11)])
    But although we can assume that the basics of client-side JavaScript are known
    to most developers, Node is still fairly new and has some rather uncommon aspects
    that make it both powerful and, at times, tricky to grasp.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书绝对不是Node.js的全面手册：有许多优秀的书籍专门介绍Node。例如，参见Mike Cantelo的《Node.js in Action，第二版》（Manning，2015）；^([[9](#ch03fn09)])
    Alex Young和Marc Harter的《Node.js in Practice》（Manning，2014）；^([[10](#ch03fn10)])
    或者像Manuel Kiessling的《The Node Beginner Book》这样的优秀教程。^([[11](#ch03fn11)]) 尽管我们可以假设大多数开发者都知道客户端JavaScript的基础知识，但Node仍然相对较新，并且有一些相当不寻常的方面，这使得它既强大又有时难以掌握。
- en: ⁹
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://manning.com/cantelon2/?a_aid=wot&a_bid=9b654188](http://manning.com/cantelon2/?a_aid=wot&a_bid=9b654188)'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://manning.com/cantelon2/?a_aid=wot&a_bid=9b654188](http://manning.com/cantelon2/?a_aid=wot&a_bid=9b654188)'
- en: ^(10)
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（10）
- en: ''
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.manning.com/young/?a_aid=wot&a_bid=f45747b3](http://www.manning.com/young/?a_aid=wot&a_bid=f45747b3)'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.manning.com/young/?a_aid=wot&a_bid=f45747b3](http://www.manning.com/young/?a_aid=wot&a_bid=f45747b3)'
- en: ^(11)
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（11）
- en: ''
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.nodebeginner.org/](http://www.nodebeginner.org/)'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.nodebeginner.org/](http://www.nodebeginner.org/)'
- en: In the next sections we’ll cover the basics of Node to make sure you’re not
    too puzzled by the examples in the following chapters. First, we’ll show you how
    to write your first Node web application (and, yes, Node HTTP server, too). Then,
    because we reuse many great libraries to build our examples, we’ll look at the
    aspects of modularity and package management in Node. Then we’ll dig a bit more
    into the way Node and other single-threaded web and networking frameworks work.
    Finally, we’ll look at the core concepts of asynchronous programming in Node,
    providing you with the tools to build increasingly complex Node code.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将介绍Node的基础知识，以确保您不会对后续章节中的示例感到过于困惑。首先，我们将向您展示如何编写您的第一个Node网络应用程序（是的，也包括Node
    HTTP服务器）。然后，因为我们重用许多优秀的库来构建我们的示例，我们将探讨Node中模块化和包管理的方面。接着，我们将更深入地探讨Node和其他单线程网络框架的工作方式。最后，我们将探讨Node中异步编程的核心概念，为您提供构建越来越复杂的Node代码的工具。
- en: 3.2.1\. Installing Node.js on your machine
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 在您的机器上安装Node.js
- en: If you don’t have a Raspberry Pi, don’t worry! Thanks to the awesomeness of
    Node.js, you can run all the examples in this chapter (and even in this book)
    without actually owning a device! It’s just way nicer on a device.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有树莓派，请不要担心！多亏了Node.js的神奇之处，您可以在没有实际拥有设备的情况下运行本章（甚至本书）中的所有示例！在设备上运行会更好一些。
- en: 'You’ll start by installing Node.js on your local machine.^([[12](#ch03fn12)])
    Fortunately, this is as simple as installing any application on your favorite
    platform. Once it’s installed, open a terminal window and type the following:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先在本地机器上安装Node.js。^([[12](#ch03fn12)]) 幸运的是，这和在任何您喜欢的平台上安装任何应用程序一样简单。安装完成后，打开一个终端窗口并输入以下内容：
- en: ^(12)
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can find the different installers on the official Node.js page at [http://nodejs.org/en/download/](http://nodejs.org/en/download/).
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以在官方Node.js页面上找到不同的安装程序：[http://nodejs.org/en/download/](http://nodejs.org/en/download/)。
- en: '[PRE12]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*This should return the version of Node.js you installed (which should be at
    least 4.2.2 to ensure the code in this book runs). You’re now ready to run your
    first example!*'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '*这应该会返回您安装的Node.js版本（应该至少是4.2.2，以确保本书中的代码可以运行）。现在您已经准备好运行第一个示例了！*'
- en: 3.2.2\. Your first web server in Node.js
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. Node.js中的第一个Web服务器
- en: 'Now that Node is installed on your computer, you can start using it. One thing
    Node is especially good at is building servers with only a few lines of code.
    You can use it to build all kinds of servers accepting all kinds of protocols:
    from sockets, to TCP/IP, to HTTP, to WebSockets.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Node已经安装到您的计算机上，您就可以开始使用了。Node特别擅长的是仅用几行代码就构建服务器。您可以使用它构建接受各种协议的各种服务器：从套接字到TCP/IP，再到HTTP，到WebSocket。
- en: You’ll use Node to build all kinds of servers in this book, but you’ll get started
    with a web server based on HTTP because this is built into Node and doesn’t require
    you to import any dependencies; see [figure 3.2](#ch03fig02).
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本书中使用Node构建各种服务器，但您将从基于HTTP的Web服务器开始，因为这是Node内置的，不需要您导入任何依赖项；请参阅[图3.2](#ch03fig02)。
- en: Figure 3.2\. Starting your first web server with Node (bottom) and returning
    the traditional “Hello World” to your web browser (top)
  id: totrans-599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 使用Node启动第一个Web服务器（底部）并将传统的“Hello World”返回到您的网页浏览器（顶部）
- en: '![](03fig02_alt.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig02_alt.jpg)'
- en: If you’re used to PHP and Apache or Java and web servers like Tomcat, you’re
    familiar with creating a web application and then deploying it to an existing
    server. In Node, things are different because your application is the server*.*
    Let’s get started with building a simple web server that always returns “Hello
    World” to all incoming requests; see the following listing.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯了PHP和Apache或Java和Tomcat这样的Web服务器，您熟悉创建一个Web应用程序然后将其部署到现有服务器上。在Node中，事情有所不同，因为您的应用程序就是服务器*。*
    让我们开始构建一个简单的Web服务器，该服务器对所有的传入请求总是返回“Hello World”；请参阅下面的列表。
- en: Listing 3.1\. A Hello World HTTP server in Node.js
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. Node.js中的Hello World HTTP服务器
- en: '![](064fig01_alt.jpg)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![](064fig01_alt.jpg)'
- en: 'This is as small as it gets! First, you `require` the `http` module. This basically
    loads the HTTP module and makes it available to your application (we’ll detail
    the way Node dependencies work in the next section). Afterward, you use the HTTP
    object to create a new server. You pass to this server a function that will be
    called whenever a client connects to your server. When a client actually connects,
    the function is called with two parameters:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最小的了！首先，您`require` `http`模块。这基本上是加载HTTP模块并将其提供给您的应用程序（我们将在下一节中详细介绍Node依赖项的工作方式）。之后，您使用HTTP对象创建一个新的服务器。您将一个函数传递给这个服务器，这个函数将在客户端连接到您的服务器时被调用。当客户端实际连接时，该函数会带两个参数被调用：
- en: '`req` represents the client request and offers a number of functions to retrieve
    information about it, such as the requested URL or the payload that was sent.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req`代表客户端请求，并提供了一些函数来检索有关它的信息，例如请求的URL或发送的数据负载。'
- en: '`res` represents the response you’d like to send back to the client.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res`代表您希望发送回客户端的响应。'
- en: With `res.writeHeader()` you can write the HTTP headers. In this example you
    write the `Status` header with a value of `200` (meaning everything went well)
    and the `Content-Type` header to `text-plain,` meaning that you’ll return plain
    text to the client. For now, don’t panic if you don’t understand exactly what
    this means because we’ll cover this at length in [chapter 6](kindle_split_014.html#ch06).
    You then start the server by invoking `listen(PORT)`, which will start the server
    on port 8585.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`res.writeHeader()`您可以写入HTTP头。在这个例子中，您使用值为`200`的`Status`头（表示一切顺利）和`Content-Type`头为`text-plain`，这意味着您将向客户端返回纯文本。现在，如果您不完全理解这到底意味着什么，请不要担心，因为我们在[第6章](kindle_split_014.html#ch06)中会详细讲解这一点。然后，您通过调用`listen(PORT)`来启动服务器，这将使服务器在端口8585上启动。
- en: 'To run your first server, copy and paste [listing 3.1](#ch03ex01) into a file^([[13](#ch03fn13)])
    with a .js extension (for example, helloworld.js). Copy this file into a folder
    called hello-node, open a terminal window, go to this folder, and start your application
    with the command “node” followed by the name of your file, like this:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你的第一个服务器，将 [列表 3.1](#ch03ex01) 复制并粘贴到一个以 .js 扩展名（例如，helloworld.js）的文件中^([[13](#ch03fn13)])。将此文件复制到名为
    hello-node 的文件夹中，打开一个终端窗口，进入此文件夹，然后使用命令“node”后跟文件名来启动你的应用程序，如下所示：
- en: ^(13)
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[(13)]
- en: ''
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can create simple JavaScript files with any text editor, but for more serious
    projects you might need an advanced text editor such as Sublime Text ([http://www.sublimetext.com](http://www.sublimetext.com)),
    Atom ([https://atom.io/](https://atom.io/)), or Brackets ([http://brackets.io/](http://brackets.io/)).
    You can also use a feature-rich IDE (Integrated Development Environment) such
    as WebStorm ([https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/))
    or NetBeans ([https://netbeans.org/](https://netbeans.org/)).
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以用任何文本编辑器创建简单的 JavaScript 文件，但对于更严肃的项目，你可能需要一个高级文本编辑器，如 Sublime Text ([http://www.sublimetext.com](http://www.sublimetext.com))、Atom
    ([https://atom.io/](https://atom.io/)) 或 Brackets ([http://brackets.io/](http://brackets.io/))。你也可以使用功能丰富的
    IDE（集成开发环境），如 WebStorm ([https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/))
    或 NetBeans ([https://netbeans.org/](https://netbeans.org/))。
- en: '[PRE13]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see the text Server Started! appearing in your terminal telling
    you that your Node application is running. Now go to http://localhost:8585 in
    your browser. You should see the “Hello World” message, as shown in [figure 3.2](#ch03fig02).
    Not utterly impressive, but think about it: with only five lines of code you created
    a web application that talks to your browser. You didn’t even need to install
    and configure an Apache server for your specific OS! You can now stop the server
    by pressing Ctrl-C in the terminal window.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端中看到文本 Server Started! 出现，告诉你 Node 应用程序正在运行。现在在你的浏览器中访问 http://localhost:8585。你应该看到“Hello
    World”消息，如图 3.2 所示。虽然并不十分令人印象深刻，但想想看：仅用五行代码你就创建了一个与浏览器通信的 Web 应用程序。你甚至不需要为你的特定操作系统安装和配置
    Apache 服务器！你现在可以通过在终端窗口中按 Ctrl-C 来停止服务器。
- en: 3.2.3\. Returning sensor data as JSON
  id: totrans-614
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3\. 以 JSON 格式返回传感器数据
- en: Let’s shift gears and build a server that actually delivers some values! You’ll
    build a server that returns a temperature sensor value when browsing to `/temperature`,
    as shown in [figure 3.3](#ch03fig03), and a light sensor value when browsing to
    `/light`. You’ll connect real sensors to your Node code in the next chapter, but
    for now you’ll return random data. You’ll also change the data format that the
    browser returns to JSON, which you encountered in [chapter 2](kindle_split_009.html#ch02).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换一下方向，构建一个真正能提供一些价值的服务器！你将构建一个服务器，当浏览到 `/temperature` 时返回温度传感器的值，如图 3.3
    所示，当浏览到 `/light` 时返回光传感器的值。你将在下一章将真实传感器连接到你的 Node 代码中，但到目前为止，你将返回随机数据。你还将更改浏览器返回的数据格式为
    JSON，这在第 2 章中你已经遇到过了。
- en: Figure 3.3\. A simple Node web server returning temperature data with a JSON
    representation in Firefox
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3\. 一个简单的 Node Web 服务器，在 Firefox 中以 JSON 表示形式返回温度数据
- en: '![](03fig03_alt.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig03_alt.jpg)'
- en: 'Just as you did before, you first create an HTTP server, as shown in [listing
    3.2](#ch03ex02). But this time you inform the client that the response is in JSON
    using the `{''Content-Type'': ''application/json''}` header. You then look into
    the request using `req.url`, which will contain the path, after the domain, that
    the client requested (for example, `/temperature`). You then create a `switch`
    that handles the requests to your different paths. For each path you generate
    the corresponding random value and return it as JSON.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '就像你之前做的那样，你首先创建一个 HTTP 服务器，如图 3.2 所示。但这次你通过使用 `{''Content-Type'': ''application/json''}`
    标头通知客户端响应是 JSON 格式。然后你通过 `req.url` 查看请求，它将包含客户端请求的路径（例如，`/temperature`）。然后你创建一个
    `switch` 语句来处理对您不同路径的请求。对于每个路径，你生成相应的随机值并将其作为 JSON 返回。'
- en: Listing 3.2\. A simple HTTP server returning JSON data
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 一个简单的返回 JSON 数据的 HTTP 服务器
- en: '![](066fig01_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](066fig01_alt.jpg)'
- en: 'Now save this file and run your application like you did before:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存这个文件，并像之前一样运行你的应用程序：
- en: '[PRE14]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Use your browser to navigate to http://localhost:8686/temperature and http://localhost:8686/light
    to see a random sensor value in JSON.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的浏览器导航到 http://localhost:8686/temperature 和 http://localhost:8686/light，以查看一个随机的传感器值，以
    JSON 格式显示。
- en: 3.3\. Modularity in Node.js
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. Node.js 中的模块化
- en: 'You’ve created your first server based on built-in Node modules. That worked
    well, but what if you’d like to benefit from the work of the growing and active
    community of Node developers by using third-party modules for specific tasks?
    This is what this section is about: first understanding the Node modules management
    system and then understanding the structure of the modules themselves.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经基于内置的Node模块创建了自己的第一个服务器。这做得很好，但您如果想通过使用第三方模块来利用不断增长和活跃的Node开发者社区的工作，该怎么办呢？本节就是关于这个的：首先了解Node模块管理系统，然后了解模块本身的架构。
- en: 3.3.1\. npm—the Node package manager
  id: totrans-626
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. npm——Node包管理器
- en: Just as Java has Maven repositories, Ubuntu has apt-get, and Ruby has Gem, Node
    has its own package or module manager (and a great one!) called npm. As the npm
    team members put it,
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Java有Maven仓库，Ubuntu有apt-get，Ruby有Gem一样，Node也有自己的包或模块管理器（而且是一个非常好的！），称为npm。正如npm团队成员所说，
- en: '*“npm” doesn’t stand for “Node Package Manager.” It stands for “npm Is Not
    An Acronym.” Why not “NINAA”? Because then it would be an acronym.*'
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“npm并不代表‘Node包管理器’。它代表‘npm Is Not An Acronym’。为什么不叫‘NINAA’？因为那样它就会成为一个缩写词。*'
- en: Joke aside, the reason for not calling npm the Node Package Manager is that
    it is not only a package manager for Node, but also a package manager for client-side
    JavaScript.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑，不叫npm为Node包管理器的原因是，它不仅是一个Node的包管理器，也是一个客户端JavaScript的包管理器。
- en: If you installed Node the way we suggested in section Installing Node.js on
    your machine, you should be all set to use npm through the `npm` command-line
    utility. The first step is obviously choosing a module to install. This can be
    done in several ways, but a popular one is by searching for modules by keywords
    using the search engine of the main npm repository at [https://www.npmjs.com/](https://www.npmjs.com/).
    As an exercise, look for the `request` module that you’ll use later. All npm modules
    are identified by a unique name, so once you’ve found the one you want, write
    its name down.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照我们在“在您的机器上安装Node.js”一节中建议的方式安装了Node，那么您应该已经准备好通过`npm`命令行工具使用npm了。第一步显然是选择一个模块进行安装。这可以通过多种方式完成，但一种流行的方式是使用npm主仓库的搜索引擎通过关键词搜索模块，网址为[https://www.npmjs.com/](https://www.npmjs.com/)。作为一个练习，寻找您稍后将要使用的`request`模块。所有npm模块都有一个独特的名称，所以一旦您找到了想要的模块，就把它写下来。
- en: Because of the popularity of Node.js, each search query will return a large
    number of options, and choosing the module you should use is sometimes overwhelming.
    Choosing the right module is especially relevant in a booming ecosystem such as
    Node where a lot of code is committed at a fast pace, sometimes at the cost of
    stability and quality. A good way to quickly evaluate the relevance and maturity
    of a project is to look at its GitHub page, which is accessible on the detail
    page of each module, as shown in [figure 3.4](#ch03fig04). On this page you can
    find the number of people following the module (Watch), how many developers liked
    the module (Star), and how many created a new version of this module (Fork); these
    are good indicators of the popularity and stability of the module.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js的流行，每个搜索查询都会返回大量选项，有时选择要使用的模块可能会让人感到不知所措。在Node这样的快速发展的生态系统中，代码提交速度很快，有时会以稳定性和质量为代价，选择正确的模块尤为重要。快速评估项目相关性和成熟度的好方法之一是查看其GitHub页面，这可以在每个模块的详细页面中访问，如图3.4所示。在这个页面上，您可以找到关注该模块的人数（Watch）、喜欢该模块的开发者数量（Star）以及创建该模块新版本的人数（Fork）；这些都是模块流行度和稳定性的良好指标。
- en: Figure 3.4\. The GitHub page of a Node module. Look for the popularity metrics
    of the module when choosing it.
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. Node模块的GitHub页面。在选择模块时寻找模块的流行度指标。
- en: '![](03fig04_alt.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig04_alt.jpg)'
- en: 'Now that you’ve picked a module, you can install it using the `npm` command-line
    tool with the unique name of the module. Let’s install `request`, an intuitive
    module designed to make HTTP calls as simple and straightforward as possible.
    Create a new folder (here we name it `hello-npm`) and change the directory to
    this folder; then run the following command:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经选择了一个模块，您可以使用具有模块唯一名称的`npm`命令行工具来安装它。让我们安装`request`，这是一个旨在使HTTP调用尽可能简单直接的直观模块。创建一个新的文件夹（这里我们命名为`hello-npm`）并将目录更改为这个文件夹；然后运行以下命令：
- en: '[PRE15]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will communicate with the npm server and install the new module into a
    directory called node_modules/. Then you can use the module from any Node source
    file inside the hello-npm folder by using the `require` instruction, which loads
    the module into memory and makes it accessible to your source code. This is done
    with the following statement:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与 npm 服务器通信，并将新模块安装到名为 node_modules/ 的目录中。然后您可以通过使用 `require` 指令从 hello-npm
    文件夹内的任何 Node 源文件中使用该模块，该指令将模块加载到内存中并使其对源代码可用。这是通过以下语句完成的：
- en: '[PRE16]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 3.3.2\. Clean dependencies with package.json and npm
  id: totrans-638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 使用 package.json 和 npm 清理依赖项
- en: The system we just illustrated works well, but adding more modules to your project
    and shifting it from one place to another requires a lot of manual runs of the
    `npm` command. Fortunately, npm solved this issue by allowing you to specify the
    modules your code depends on in a single JSON file called package.json. You can
    see the structure of a typical package.json file in the following listing.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才展示的系统运行良好，但向项目中添加更多模块并将其从一个地方移动到另一个地方需要多次手动运行 `npm` 命令。幸运的是，npm 通过允许您在单个名为
    package.json 的 JSON 文件中指定代码所依赖的模块来解决此问题。您可以在以下列表中查看典型 package.json 文件的结构。
- en: Listing 3.3\. A simple package.json file
  id: totrans-640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 一个简单的 package.json 文件
- en: '![](068fig01_alt.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![](068fig01_alt.jpg)'
- en: 'First, you give your project a name and a version. Note that if you ever decide
    to also publish your project as a module on npm, this name will be used. Then,
    you add a short description and an author, as well as a link to a source control
    system where the code of your project can be found (it can be private as well).
    Next comes the core of the file: the modules your project depends on. Here you
    have a single module: `request`. Node modules usually follow the semantic versioning
    pattern,^([[14](#ch03fn14)]) `MAJOR.MINOR.PATCH`:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您为项目命名并指定版本。请注意，如果您决定将项目作为模块发布到 npm，则将使用此名称。然后，您添加简短描述、作者以及可以找到项目代码的源代码控制系统链接（可以是私有的）。接下来是文件的核心：项目所依赖的模块。在这里，您有一个单独的模块：`request`。Node
    模块通常遵循语义版本控制模式，^([[14](#ch03fn14)]) `MAJOR.MINOR.PATCH`：
- en: ^(14)
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((14))
- en: ''
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://semver.org/](http://semver.org/)'
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://semver.org/](http://semver.org/)'
- en: '`MAJOR` version when you make incompatible API changes'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您进行不兼容的 API 变更时使用 `MAJOR` 版本
- en: '`MINOR` version when you add functionality in a backward-compatible manner'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您以向后兼容的方式添加功能时使用 `MINOR` 版本
- en: '`PATCH` version when you make backward-compatible bug fixes'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您进行向后兼容的错误修复时使用 `PATCH` 版本
- en: Wildcards are supported, so `2.x.x` means that npm will fetch the latest `MINOR`
    and `PATCH` versions of `request MAJOR` version 2\. `devDependencies` is required
    for dependencies only when you build your project in a developer environment.
    A good example of such a dependency is a testing library that wouldn’t need to
    be imported when deploying the final version of your code. Finally, with `engine`
    you can also specify the version of Node your project should run with. This is
    a minimal example of a package.json file because much more can be specified there.
    A great interactive guide to building your package.json files is provided online.^([[15](#ch03fn15)])
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 支持通配符，因此 `2.x.x` 表示 npm 将获取 `request` MAJOR 版本 2 的最新 `MINOR` 和 `PATCH` 版本。`devDependencies`
    仅在您在开发环境中构建项目时才需要依赖项。此类依赖项的一个好例子是测试库，在部署代码的最终版本时不需要导入。最后，使用 `engine` 您还可以指定项目应运行的
    Node 版本。这是一个 package.json 文件的简化示例，因为那里可以指定更多内容。网上提供了一份构建 package.json 文件的优秀交互式指南。^([[15](#ch03fn15)])
- en: ^(15)
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((15))
- en: ''
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://browsenpm.org/package.json](http://browsenpm.org/package.json)'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://browsenpm.org/package.json](http://browsenpm.org/package.json)'
- en: Of course, you don’t have to write your package.json file manually. Instead,
    you can use the `npm init` command, which will ask you for basic information about
    your application and generate a package.json file for you automatically.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不必手动编写 package.json 文件。相反，您可以使用 `npm init` 命令，该命令将询问您有关应用程序的基本信息，并为您自动生成
    package.json 文件。
- en: 'Another useful feature of npm is that you don’t have to manually add each new
    module to your package.json. Instead, you can install them with the `–-save` flag
    as follows:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: npm 的另一个有用功能是您不必手动将每个新模块添加到 package.json 文件中。相反，您可以使用以下命令中的 `–-save` 标志来安装它们：
- en: '[PRE17]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command will automatically add this dependency to your package.json file.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将自动将此依赖项添加到您的 package.json 文件中。
- en: 3.3.3\. Your first Node module
  id: totrans-657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 您的第一个 Node 模块
- en: 'Now that you’ve seen how to manage packaged modules in Node, we’ll show how
    to organize your code by creating your own simple modules. Imagine you want to
    create a module that offers arithmetic operations to an application. The structure
    of the folders for your first module is shown in the following code. The module
    file (operations.js) is located in the /lib folder and accessed from the modules-client.js
    file:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何在Node中管理打包的模块，我们将展示如何通过创建自己的简单模块来组织你的代码。想象一下，你想创建一个为应用程序提供算术运算的模块。你的第一个模块的文件夹结构如下所示。模块文件（operations.js）位于/lib文件夹中，并通过modules-client.js文件访问：
- en: '![](069fig01.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![](069fig01.jpg)'
- en: Begin by creating a folder for your project called hello-modules. To keep your
    code tidy and respect the Node conventions, create a lib folder inside hello-modules.
    You then write the module itself in a file called operations.js that you put into
    the lib folder; the code for operations.js is shown in the following listing.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为你的项目创建一个名为hello-modules的文件夹。为了保持你的代码整洁并尊重Node约定，在hello-modules内部创建一个lib文件夹。然后，你将模块本身写入一个名为operations.js的文件，并将其放入lib文件夹中；operations.js的代码如下所示。
- en: 'Listing 3.4\. operations.js: a mathematics module in Node.js'
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. operations.js：Node.js中的数学模块
- en: '![](070fig01_alt.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![](070fig01_alt.jpg)'
- en: 'This module contains three functions that you want to make available to module
    users: `add`, `sub`, and `mul`. You make them available by defining properties
    on the `exports` object. Note that you can also make any other object, string,
    or variable available through this mechanism. Other functions used only in your
    module file (for example, `logOp`) won’t be available to files outside your module
    because you don’t attach them to the `exports` object.'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块包含三个你希望提供给模块用户的函数：`add`、`sub`和`mul`。你通过在`exports`对象上定义属性来提供它们。请注意，你也可以通过此机制提供任何其他对象、字符串或变量。仅在你模块文件中使用的其他函数（例如，`logOp`）将不会对模块外的文件可用，因为你没有将它们附加到`exports`对象上。
- en: The last step is to create a client for your library. In the root folder of
    the project (that is, the hello-modules folder), create a new file called module-client.js
    (note that unlike the module name, the name of the client file doesn’t matter).
    The code of this file is fairly straightforward, as shown in the next listing.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是为你的库创建一个客户端。在项目的根目录下（即hello-modules文件夹），创建一个名为module-client.js的新文件（注意，与模块名称不同，客户端文件的名称并不重要）。这个文件的代码相当简单，如下所示。
- en: Listing 3.5\. A simple Node application using the operations module
  id: totrans-665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. 使用operations模块的简单Node应用程序
- en: '![](070fig02_alt.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
  zh: '![](070fig02_alt.jpg)'
- en: The key lies in `require`, where you import your new module. Essentially, you’re
    telling Node to go fetch the module `operations` in the lib subdirectory and save
    it in the `ops` variable. Note that you don’t need to specify the .js extension
    when using `require`.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于`require`，其中你导入你的新模块。本质上，你是在告诉Node去获取位于lib子目录中的模块`operations`并将其保存在`ops`变量中。请注意，在使用`require`时，你不需要指定.js扩展名。
- en: 'That’s it! Your first module is ready to be used. Run `node module-client.js`
    to test it. If everything works fine, you should see the following output in your
    console:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你的第一个模块已经准备好使用了。运行`node module-client.js`来测试它。如果一切正常，你应该在你的控制台中看到以下输出：
- en: '[PRE18]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There’s much more to modules than what we covered here, but this will help you
    to get started and understand how we use modules in the rest of this book.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的内容远不止我们在这里所涵盖的，但这将帮助你开始并理解我们在这本书的其余部分如何使用模块。
- en: 3.4\. Understanding the Node.js event loop
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 理解Node.js事件循环
- en: Building server-side web applications such as the one you used in [chapter 2](kindle_split_009.html#ch02)—or
    generally any web server that needs to deal with more than a single client at
    a time—requires the ability to handle a large number of connections in a concurrent
    manner. If the connections couldn’t be accepted concurrently, each new web client
    would have to wait until the clients that arrived earlier were served. This would
    be almost as slow as taking London’s underground from Waterloo to Bank during
    rush hour! To use a more appropriate analogy, imagine a single gas station on
    a busy intersection, with a single pump used by a single attendant.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器端Web应用程序，例如你在第2章中使用的[该应用程序](kindle_split_009.html#ch02)——或者通常任何需要同时处理多个客户端的Web服务器——需要能够以并发方式处理大量连接。如果连接不能被并发接受，每个新的Web客户端都必须等待先到达的客户端被服务。这几乎和伦敦的Waterloo到Bank的地下铁高峰时段一样慢！为了使用一个更恰当的类比，想象一个繁忙交叉路口上的一个单独的加油站，只有一个加油员和一个加油机。
- en: 3.4.1\. Multithreaded web servers
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 多线程Web服务器
- en: Two common patterns can be used to resolve this issue. As shown in [figure 3.5](#ch03fig05),
    the first pattern is to create one process—or better, one thread—per request.
    A thread is essentially a lightweight process because it’s able to share some
    of the process’s resources (for example, some of the allocated memory) while executing
    largely independently.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种常见的模式来解决这个问题。如图3.5所示，第一种模式是为每个请求创建一个进程——或者更好的是，一个线程。线程本质上是一个轻量级进程，因为它能够在执行时共享一些进程的资源（例如，一些分配的内存），同时大部分独立执行。
- en: 'Figure 3.5\. Dealing with a number of concurrent requests with a threading
    or process-forking approach: for each new client a new thread or process is created.'
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. 使用线程或进程分叉方法处理多个并发请求：为每个新客户端创建一个新的线程或进程。
- en: '![](03fig05.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig05.jpg)'
- en: 'Consider this code snippet, which fetches data from a database and then displays
    it:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个代码片段，它从数据库中获取数据然后显示：
- en: '[PRE19]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you ever worked with a server-side web language such as PHP running on Apache
    or Java on Tomcat, you most likely used code like this, working in a sequential
    manner white waiting for I/O operations to finish. This works fine in the PHP
    and Java worlds because while one client waits to be served, the underlying server
    (for example, Apache) serves the next clients. It does this by creating one thread
    for each incoming client.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过在Apache上运行的PHP或Tomcat上的Java这样的服务器端Web语言，你很可能使用过这样的代码，以顺序方式工作，等待I/O操作完成。在PHP和Java的世界里，这没问题，因为当一个客户端等待服务时，底层服务器（例如，Apache）会为下一个客户端提供服务。它是通过为每个传入的客户端创建一个线程来做到这一点的。
- en: 3.4.2\. Single-threaded, non-blocking web servers
  id: totrans-680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 单线程、非阻塞Web服务器
- en: 'Let’s think about this example by applying it to our gas station: imagine each
    thread is a pump with an attendant, each web client is a customer, and the database
    is the central tank. We’re better off than with a single pump and attendant, but
    each attendant is still idle some of the time, waiting for our tank to get filled.
    What if we had only one attendant managing several pumps in an efficient manner?
    Wouldn’t this be more economical in terms of costs?'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将其应用于我们的加油站来思考这个例子：想象每个线程是一个带有服务员的水泵，每个Web客户端是一个客户，数据库是中央油罐。我们比只有一个泵和服务员的情况要好，但每个服务员仍然会在某些时候空闲，等待我们的油罐被填满。如果我们只有一个服务员以高效的方式管理几个泵会怎样？这从成本角度来看不是更经济吗？
- en: 'In a nutshell, this is what modern non-blocking web servers are all about:
    being able to handle more requests by minimizing the memory overhead required
    for each new client. This second pattern is an event-driven system often based
    on the idea of a single thread (or a limited number of threads) with an event
    loop and non-blocking or *asynchronous* I/O.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这就是现代非阻塞Web服务器的主要内容：通过最小化每个新客户端所需的内存开销来处理更多请求。第二种模式是一个基于单线程（或有限数量的线程）和事件循环的事件驱动系统，并且是非阻塞的或*异步*
    I/O。
- en: The Node.js runtime is built on these principles. It runs a single thread with
    an event loop, as shown on [figure 3.6](#ch03fig06), and strongly favors asynchronous
    I/O operations. When the Node server accepts a client, it puts it on hold until
    the I/O operations it requested (for example, reading from the database, reading
    a value from a sensor, or uploading a file on a remote server) have returned and
    goes on serving other clients in the meanwhile.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js运行时建立在这些原则之上。它运行一个线程和一个事件循环，如图3.6所示，并且强烈倾向于异步I/O操作。当Node服务器接受一个客户端时，它会将其挂起，直到它请求的I/O操作（例如，从数据库读取，从传感器读取值，或在远程服务器上上传文件）返回，同时继续为其他客户端提供服务。
- en: Figure 3.6\. Dealing with a number of concurrent requests with a single-threaded
    event-driven approach. The event loop puts the clients on hold until the I/O operations
    have returned.
  id: totrans-684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6\. 使用单线程事件驱动方法处理多个并发请求。事件循环将客户端挂起，直到I/O操作返回。
- en: '![](03fig06.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig06.jpg)'
- en: A direct consequence of the event-loop pattern with a single thread is that
    Node really doesn’t like waiting actively because it completely blocks the Node
    server and prevents it from serving any subsequent request!
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程事件循环模式的一个直接后果是，Node实际上不喜欢主动等待，因为它会完全阻塞Node服务器，并阻止它处理任何后续请求！
- en: To better understand the difference between blocking and non-blocking calls,
    imagine that we run the synchronous code shown previously in a Node server. The
    Node runtime will fetch data from the database, wait until it gets it, and then
    execute the `console.log()` instruction. If there’s a lot of data to fetch, you
    might have to wait for quite some time, during which the Node server wouldn’t
    be able to serve or accept any other incoming request—not a good idea to scale
    your system! Let’s rewrite the database function in a non-blocking way that fits
    the Node model, as shown in the next listing.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解阻塞和非阻塞调用的区别，想象一下我们在Node服务器上运行之前显示的同步代码。Node运行时会从数据库获取数据，等待直到获取到数据，然后执行`console.log()`指令。如果有大量数据要获取，你可能需要等待相当长的时间，在这段时间内，Node服务器将无法服务或接受任何其他传入请求——这不是扩展系统的好方法！让我们以适合Node模型的方式重写数据库函数，如下所示。
- en: Listing 3.6\. An asynchronous call to the database
  id: totrans-688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.6\. 对数据库的异步调用
- en: '![](072fig01_alt.jpg)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![072fig01_alt.jpg]'
- en: The major difference with this version is that you pass a function as a parameter
    when calling the `database.query` function (we’ll talk more about these functions,
    called *callbacks*, in the next section). The Node event loop will then put this
    call on hold until a response arrives from the database. This time, while waiting
    for the response, other instructions will be executed until the results have been
    fetched from the database and are ready to be consumed. When the results are retrieved,
    the event loop will call the callback `function(results)` with the results.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个版本的主要区别在于，在调用`database.query`函数时，你传递一个函数作为参数（我们将在下一节中更多地讨论这些函数，称为*回调*）。然后，Node事件循环将挂起此调用，直到从数据库收到响应。这次，在等待响应的同时，其他指令将被执行，直到从数据库获取结果并准备好消费。当结果检索到时，事件循环将使用结果调用回调函数`function(results)`。
- en: Interestingly enough, this means that the `database.query` instruction will
    return directly after it’s called. As a consequence, the `console.log(results)`
    will execute right away, before the results are actually ready! Moreover, the
    results themselves will be available only to the anonymous function (injected
    in the callback by the event loop), and the variable will be undefined for the
    `console.log` instruction.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这意味着在调用`database.query`指令后，它将直接返回。因此，`console.log(results)`将立即执行，在结果实际上准备好之前！此外，结果本身仅对匿名函数（由事件循环注入回调中）可用，对于`console.log`指令，变量将是未定义的。
- en: This way of serving requests on a single thread while not blocking all clients
    works only if all calls in the chain are asynchronous, so all the libraries you
    use and the code you write should be asynchronous unless there’s a really good
    reason for them not to be. An example of a justified synchronous call occurs when
    loading configurations or dependencies at the startup of a Node program. As a
    convention, to make sure you keep track of your synchronous calls, Node functions
    that are synchronous end with the `Sync` suffix and do not usually take a function
    as a parameter. For example, `fs.readFileSync(filename)` reads a file synchronously
    (that is, blocking the single thread until the file is fully read) as opposed
    to `fs.readFile(filename,callback)`, which reads a file asynchronously (that is,
    releasing the thread to do other work while waiting for the file to be read).
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在单个线程上提供服务而不阻塞所有客户端的方式仅当链中的所有调用都是异步时才有效，因此你使用的所有库和编写的所有代码都应该异步，除非有非常好的理由不这样做。一个合理的同步调用例子发生在Node程序启动时加载配置或依赖项。作为一种惯例，为了确保你跟踪你的同步调用，Node中同步函数通常以`Sync`后缀结尾，并且通常不接收一个函数作为参数。例如，`fs.readFileSync(filename)`以同步方式读取文件（即，阻塞单个线程直到文件完全读取），而`fs.readFile(filename,callback)`则以异步方式读取文件（即，在等待文件读取的同时释放线程执行其他工作）。
- en: 'Don’t get us wrong: single-threaded servers with asynchronous I/O are not trivial
    to work with and aren’t a silver bullet, either. But they’ve been shown to yield
    better performance and scaling in a number of situations, particularly for data-intensive
    real-time (DIRT) applications. Interestingly, the nature of real-world Things
    like sensors does perfectly fit into the DIRT type of applications, which partially
    explains the growing interest is these types of servers in the context of the
    Internet of Things. Reading data from the real world requires gathering a lot
    of sensor data (through I/O operations on physical sensors), and clients expect
    to be informed about changes of these sensors’ state in a timely, event-driven,
    and almost real-time manner! This fits nicely the definition of DIRT applications
    and will be covered in [chapter 6](kindle_split_014.html#ch06).'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 不要误解我们：单线程服务器使用异步 I/O 并不简单，也不是万能的。但它们已经在许多情况下证明了更好的性能和扩展性，尤其是在数据密集型实时（DIRT）应用中。有趣的是，现实世界中的事物，如传感器，其本质非常适合
    DIRT 类型的应用，这在一定程度上解释了为什么在物联网背景下，对这些类型服务器的兴趣日益增长。从现实世界读取数据需要收集大量的传感器数据（通过物理传感器的
    I/O 操作），并且客户端期望能够及时、基于事件和几乎实时地了解这些传感器状态的变化！这非常适合 DIRT 应用的定义，将在第 6 章中介绍。
- en: 'We hope we didn’t lose you! If we did, don’t worry, because you’ll see many
    more examples of this throughout the book. For now, remember one thing: Node.js
    only has one thread, so you need to make sure your code isn’t blocking waiting
    for I/O while reading files, fetching resources from the web, or reading data
    from onboard sensors. The simple way to ensure this doesn’t happen is to pass
    callback functions that will be called by the event loop when the data becomes
    available.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们没有让你感到困惑！如果我们让你感到困惑了，别担心，因为你在本书中还会看到更多这方面的例子。现在，记住一件事：Node.js 只有一个线程，所以你需要确保你的代码在读取文件、从网络获取资源或从船上传感器读取数据时不会阻塞等待
    I/O。确保这一点不发生的一个简单方法是传递回调函数，当数据可用时，事件循环会调用这些函数。
- en: 3.5\. Getting started with asynchronous programming
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 开始异步编程
- en: 'As demonstrated in the previous section, Node is largely based on the principle
    of asynchronous programming. Let’s be honest: asynchronous programming is a good
    step toward scaling your server, but it isn’t easy to master. The sequential model
    of PHP, where you can rely on the fact that instructions are executed one after
    the other, makes for clear and easily understandable code. But things that scale
    well rarely come without a cost. Having to deal with asynchronous programming
    is one of the prices we pay for using event-driven runtimes such as Node.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，Node 主要基于异步编程的原则。让我们说实话：异步编程是扩展服务器的好步骤，但掌握它并不容易。PHP 的顺序模型，你可以依赖的事实是指令一个接一个地执行，使得代码清晰易懂。但好的扩展性很少没有代价。必须处理异步编程是我们使用像
    Node 这样的基于事件的运行时所要付出的代价之一。
- en: 'Node offers two main patterns for dealing with asynchronous calls: callbacks
    and event listeners. We’ll use event listeners later in the book and will briefly
    talk about the concept when the time comes. Callbacks, on the other hand, are
    so important and ubiquitous in Node that we’ll dig into them here.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: Node 提供了两种处理异步调用的主要模式：回调和事件监听器。我们将在本书的后面部分使用事件监听器，并在适当的时候简要介绍这个概念。另一方面，回调在 Node
    中非常重要且无处不在，所以我们将在这里深入探讨它。
- en: 3.5.1\. Anonymous callbacks
  id: totrans-698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1. 匿名回调
- en: Consider a function `F` that performs some asynchronous operation such as fetching
    some data from the network, as shown on [figure 3.7](#ch03fig07). We need a way
    to express what to do next when `F` returns so we give `F` another function to
    call whenever `F` finishes with the message-sending operation. This is an example
    of a callback—that is, a function passed as a parameter to an asynchronous function
    describing what to do after the async function has completed.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个函数 `F`，它执行一些异步操作，例如从网络获取一些数据，如图 3.7 所示。[图 3.7](#ch03fig07)。我们需要一种方式来表达当
    `F` 返回时下一步要做什么，所以我们给 `F` 另一个函数来调用，当 `F` 完成消息发送操作时。这是一个回调的例子——也就是说，一个作为异步函数参数传递的函数，描述了异步函数完成后要做什么。
- en: Figure 3.7\. Callbacks and the event loop (simplification). `F` asynchronously
    fetches data from the network. Meanwhile, other functions are being served. When
    the data `F` requested is ready, the event loop calls the function specified by
    `F` for when the data is ready. This type of function is called a callback.
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.7\. 回调和事件循环（简化）。`F`异步从网络获取数据。同时，其他函数正在被服务。当`F`请求的数据准备好时，事件循环调用在数据准备好时指定的函数。这种函数被称为回调。
- en: '![](03fig07.jpg)'
  id: totrans-701
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig07.jpg)'
- en: As an example, the anonymous function passed as an argument of `database.query()`
    in [listing 3.6](#ch03ex06) is a callback. Note that we call these *anonymous
    functions* because they don’t have a name, and hence, unlike named callbacks that
    we’ll address shortly, they can’t be called by any piece of code except for the
    function they’re passed to in the first place. Another good example of using callbacks
    is the mashup of [listing 2.9](kindle_split_009.html#ch02ex09) in [chapter 2](kindle_split_009.html#ch02);
    the `mashup()` function it contained had a number of client-side JavaScript callbacks,
    calling one physical thing after the other had responded.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[列表 3.6](#ch03ex06)中，作为`database.query()`参数传递的匿名函数是一个回调。请注意，我们称这些为*匿名函数*，因为它们没有名字，因此，与我们将很快讨论的命名回调不同，除了最初传递给它们的函数之外，任何代码都无法调用它们。使用回调的另一个好例子是[第
    2 章](kindle_split_009.html#ch02)中[列表 2.9](kindle_split_009.html#ch02ex09)的混合；它包含的`mashup()`函数有几个客户端
    JavaScript 回调，在每一项响应之后调用一个物理事物。
- en: Although you can use any function for your callbacks, it’s a good practice to
    create your callback functions with two parameters; the first parameter, usually
    named `err` or `error`, will contain an error in case anything went wrong with
    the asynchronous function you called. The second parameter, usually named `resp`,
    `response`, or anything that reflects what you expect back, will contain the expected
    result if everything worked fine.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以为你的回调使用任何函数，但创建具有两个参数的回调函数是一个好习惯；第一个参数，通常命名为`err`或`error`，将包含在调用异步函数时发生错误的情况。第二个参数，通常命名为`resp`、`response`或任何反映你期望返回的内容的名称，将在一切顺利时包含预期的结果。
- en: 'To better grasp how asynchronous calls and callbacks are used, let’s create
    a mashup similar to the one in [listing 2.9](kindle_split_009.html#ch02ex09) but
    on the server side, as shown in [figure 3.8](#ch03fig08). Our application will
    run the following operations when a request comes in for the `/log` resource:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解异步调用和回调的使用，让我们创建一个类似于[列表 2.9](kindle_split_009.html#ch02ex09)的混合，但是在服务器端，如图
    3.8 所示。当对`/log`资源发出请求时，我们的应用程序将执行以下操作：
- en: '**1**.  Fetch a temperature value from the server.'
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 从服务器获取一个温度值。'
- en: '**2**.  Fetch a light value from the server.'
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 从服务器获取一个亮度值。'
- en: '**3**.  Create a log entry for these two values and append it to a log.txt
    file.'
  id: totrans-707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 为这两个值创建一个日志条目并将其追加到log.txt文件中。'
- en: Figure 3.8\. Running the server of [listing 3.2](#ch03ex02) (terminal window,
    top) and consuming its data through a server-side mashup with callbacks called
    from a browser (bottom)
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.8\. 运行[列表 3.2](#ch03ex02)的服务器（终端窗口，顶部）并通过从浏览器调用的回调在服务器端混合其数据（底部）
- en: '![](03fig08_alt.jpg)'
  id: totrans-709
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig08_alt.jpg)'
- en: 'The crucial point here is that all three operations require I/O operations:
    1 and 2 require fetching data from your HTTP server; 3 requires writing to the
    disk. Hence, if you were to run them in a blocking, synchronous manner, the whole
    Node event loop would be blocked for several CPU cycles, being unable to accept
    any connection from additional clients until these I/O operations return. You
    certainly wouldn’t want that! The following code illustrates how to build this
    mashup in a non-blocking way using callbacks.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的一点是，所有三个操作都需要 I/O 操作：1 和 2 需要从你的 HTTP 服务器获取数据；3 需要写入磁盘。因此，如果你以阻塞、同步的方式运行它们，整个
    Node 事件循环将被阻塞几个 CPU 周期，无法接受来自其他客户端的任何连接，直到这些 I/O 操作返回。你肯定不希望这样！以下代码演示了如何使用回调以非阻塞方式构建此混合。
- en: 'For this code you’ll use the external module called `request` that you installed
    previously. Create a package.json file in a new directory and install the module
    using `npm` as shown earlier:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这段代码，你将使用之前安装的外部模块`request`。在新的目录中创建一个package.json文件，并使用`npm`安装该模块，如前面所示：
- en: '[PRE20]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Calling an HTTP resource with `request` is easy! The following listing will
    get the Web of Things homepage and return its HTML content.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`request`调用 HTTP 资源很容易！以下列表将获取 Web of Things 主页并返回其 HTML 内容。
- en: Listing 3.7\. Using the request library
  id: totrans-714
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7\. 使用 request 库
- en: '![](075fig01_alt.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
  zh: '![](075fig01_alt.jpg)'
- en: You probably noticed that the call to `request` takes a callback as a parameter.
    This is expected because the call will be executed asynchronously. With the `request`
    library, your mashup becomes pretty straightforward, as you can see in [listing
    3.8](#ch03ex08). You begin by fetching the temperature from your server using
    `request`. Then, inside the callback of the temperature request, you fetch the
    light, and inside the callback of the light, you write to a file using the asynchronous
    built-in Node `fs.appendFile()` function and eventually reply to the client with
    the values you fetched.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到对 `request` 的调用带有一个回调参数。这是预期的，因为该调用将以异步方式执行。使用 `request` 库，你的混合应用变得相当直接，如
    [列表 3.8](#ch03ex08) 所示。你首先使用 `request` 从你的服务器获取温度。然后，在温度请求的回调中，你获取光线，在光线回调中，你使用异步内置的
    Node `fs.appendFile()` 函数写入文件，并最终使用你获取的值回复客户端。
- en: Listing 3.8\. A mashup with asynchronous calls leading to a “callback hell”
  id: totrans-717
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.8\. 使用异步调用导致的“回调地狱”
- en: '![](ch03ex08-0.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03ex08-0.jpg)'
- en: '![](ch03ex08-1.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03ex08-1.jpg)'
- en: 'Save this code and test it by first starting the server of [listing 3.2](#ch03ex02):'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此代码，并通过首先启动 [列表 3.2](#ch03ex02) 的服务器来测试它：
- en: '[PRE21]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, in a new terminal window run the mashup:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在新的终端窗口中运行混合应用：
- en: '[PRE22]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now point your browser to http://localhost:8787/log; if everything works as
    expected, you should see output similar to that of [figure 3.8](#ch03fig08). This
    way of calling a callback inside another and so forth is known as *nesting callbacks*.
    Unfortunately, as you can see in the code of [listing 3.8](#ch03ex08), nesting
    callbacks quickly pushes your code to the right, making it harder to read and
    manage with every additional callback. This unfortunate consequence of asynchronous
    programming with callbacks is known as *callback hell*. As you can see, this problem
    appears with a relatively low number of callbacks. A rule of thumb to keep your
    sanity is to not attempt to nest more than three callbacks like these.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将你的浏览器指向 http://localhost:8787/log；如果一切按预期工作，你应该会看到类似于 [图 3.8](#ch03fig08)
    的输出。这种方式在另一个回调内部调用回调，等等，被称为 *嵌套回调*。不幸的是，如 [列表 3.8](#ch03ex08) 的代码所示，嵌套回调很快就会将你的代码推到右边，使得随着每个额外回调的增加，代码的阅读和管理变得更加困难。这种异步编程使用回调的不幸后果被称为
    *回调地狱*。正如你所见，这个问题在相对较少的回调数量下就会出现。一个保持理智的经验法则是不要尝试嵌套超过三个这样的回调。
- en: 3.5.2\. Named callbacks
  id: totrans-725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 命名回调
- en: Don’t lose hope just yet! There are number of ways to resolve your callback
    hell. The first one is to use actual named functions instead of anonymous functions.
    Using named functions leads to more readable code because it encapsulates the
    asynchronous calls. It reduces the callback hell to a chain of function calls,
    each first calling one asynchronous function and then calling the next function
    in the chain. If you were to rewrite your mashup with this strategy, it would
    look like the code listing that follows.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 不要就此放弃希望！有几种方法可以解决你的回调地狱。第一种是使用实际的命名函数而不是匿名函数。使用命名函数可以使代码更易于阅读，因为它封装了异步调用。它将回调地狱减少为一系列函数调用，每个函数首先调用一个异步函数，然后调用链中的下一个函数。如果你使用这种策略重写你的混合应用，它看起来就像下面的代码列表。
- en: Listing 3.9\. A mashup with asynchronous calls and named callbacks
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9\. 使用异步调用和命名回调的混合
- en: '![](ch03ex09-0.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03ex09-0.jpg)'
- en: '![](ch03ex09-1.jpg)'
  id: totrans-729
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03ex09-1.jpg)'
- en: This code is essentially the same as [listing 3.8](#ch03ex08), but this time
    the workflow is split across several functions. In the callback of the server
    you invoke `getTemperature()`; this function asynchronously gets the temperature
    and calls the `getLight()` function as soon as the temperature arrives. `getLight()`
    fetches the light from the server and invokes `logValuesReply()` as soon as the
    light value is ready. Finally, `logValuesReply()` asynchronously logs the value
    to a file and replies to the client.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上与 [列表 3.8](#ch03ex08) 相同，但这次工作流程被拆分到几个函数中。在服务器的回调中，你调用 `getTemperature()`；这个函数异步获取温度，并在温度到达后立即调用
    `getLight()` 函数。`getLight()` 从服务器获取光线，并在光线值准备好后立即调用 `logValuesReply()`。最后，`logValuesReply()`
    异步将值记录到文件并回复客户端。
- en: The result is much more readable code with a manageable level of indentation.
    But on the flipside, you now have to pass the values manually across the chain
    of invocation as function parameters; these include the `res` argument, which
    contains a handle to the response object you need at the end of the chain. Furthermore,
    each function needs to know which function to call next. This means your functions
    are tightly coupled with each other and the code can’t easily be reused for other
    workflows.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是代码可读性更高，缩进级别可管理。但另一方面，你现在必须手动将值作为函数参数传递给调用链；这些包括 `res` 参数，它包含在链的末尾所需的响应对象的句柄。此外，每个函数都需要知道下一个要调用的函数。这意味着你的函数与其他函数紧密耦合，代码难以在其他工作流程中重用。
- en: 3.5.3\. Control flow libraries
  id: totrans-732
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.3\. 控制流库
- en: We clearly aren’t the first developers to face the challenges of nested callbacks;
    as a consequence, a number of developers have contributed their methods of dealing
    with the problem to the community. This has led to a number of *control flow*
    modules. Essentially, these modules provide elegant solutions to the callback
    hell problem; they also address the shortcomings of using named callbacks in a
    clean, flexible, and reusable manner. We can’t list all control flow libraries
    here, but we recommend using `Async`.^([[16](#ch03fn16)]) This library is probably
    the most comprehensive set of tools for dealing with asynchronous JavaScript in
    the browser and for Node.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然不是第一个面临嵌套回调挑战的开发者；因此，许多开发者已经将他们处理该问题的方法贡献给了社区。这导致了大量 *控制流* 模块的产生。本质上，这些模块提供了优雅的解决方案来处理回调地狱问题；它们还以干净、灵活和可重用的方式解决了使用命名回调的不足。我们无法在此列出所有控制流库，但我们推荐使用
    `Async`。^([[16](#ch03fn16)]) 这个库可能是处理浏览器和 Node 中异步 JavaScript 的最全面的工具集。
- en: ^(16)
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(16)
- en: ''
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/caolan/async](https://github.com/caolan/async)'
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/caolan/async](https://github.com/caolan/async)'
- en: 'Let’s rewrite our mashup using the `async` control flow library that you install
    with the following command:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令安装的 `async` 控制流库重写我们的混合代码：
- en: '[PRE23]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You’ll use the `async.series([])` construct, taking an array of functions as
    a parameter, as well as an optional final callback function to be invoked when
    all others have returned. The general structure of this construct is shown in
    the next listing.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `async.series([])` 构造，该构造函数接受一个函数数组作为参数，以及一个可选的最终回调函数，当所有其他函数返回后将被调用。此构造函数的一般结构在下一列表中展示。
- en: Listing 3.10\. Using `async.series` for serial control flow
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. 使用 `async.series` 进行串行控制流
- en: '![](079fig01_alt.jpg)'
  id: totrans-741
  prefs: []
  type: TYPE_IMG
  zh: '![](079fig01_alt.jpg)'
- en: Applying this construct to your mashup, you obtain the code in [listing 3.11](#ch03ex11),
    which resembles your first attempt to solve the problem (using nested callbacks)
    except that the whole structure is much flatter and a lot more readable. To foster
    reusability, we also make use of the named functions we created before. The key
    in the control flow pattern is in calling in each function in the chain the `callback(err,
    result)` method, which calls the next function in the array (through the control
    flow library) and adds the result to an array of results made available to the
    last callback function. In this case the result array contains the temperature
    and light values in an ordered manner as expected in an array (note that an alternative
    with objects is also provided by `Async`).
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 将此结构应用于你的混合代码，你将获得 [列表 3.11](#ch03ex11) 中的代码，它类似于你第一次尝试解决问题（使用嵌套回调）的方式，但整个结构更加扁平，可读性也更高。为了促进重用，我们还使用了之前创建的命名函数。在控制流模式中的关键是，在链中的每个函数中调用
    `callback(err, result)` 方法，该方法通过控制流库调用数组中的下一个函数，并将结果添加到提供给最后一个回调函数的结果数组中。在这种情况下，结果数组以有序的方式包含温度和光照值，正如在数组中预期的那样（注意，`Async`
    也提供了一个使用对象的替代方案）。
- en: Listing 3.11\. Using a control flow library
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. 使用控制流库
- en: '![](ch03ex11-0.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03ex11-0.jpg)'
- en: '![](ch03ex11-1.jpg)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03ex11-1.jpg)'
- en: Not only is this model much more readable, it’s also much more flexible. As
    an example, although you executed the calls for temperature and light in series,
    there’s nothing that forces you to do so; you just need the responses in any order.
    Now, using another construct of the `Async` library called `async.parallel`, you
    can speed up your mashup by running the calls in parallel. All you need for that
    is to change the initial call from `async.series([...])` to `async.parallel([...])`.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这种模型更易于阅读，而且它还更加灵活。例如，尽管你按顺序执行了温度和光度的调用，但没有任何东西强迫你这样做；你只需要以任何顺序得到响应。现在，使用`Async`库的另一个结构`async.parallel`，你可以通过并行运行调用来加快你的混合操作。为此，你只需要将初始调用从`async.series([...])`更改为`async.parallel([...])`。
- en: As you’ve seen in this section, asynchronous programming isn’t always straightforward
    and there’s a learning curve to master it. Luckily enough, there are a number
    of techniques and tools that can help you keep your code clean and structured
    despite this complexity. Moving forward in the book, we’ll use simple anonymous
    and named callbacks for examples not requiring more than three levels of callbacks
    nesting. For all other examples we’ll use the great `Async` library we just introduced.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，异步编程并不总是直截了当的，掌握它需要一定的学习曲线。幸运的是，有一些技术和工具可以帮助你在这种复杂性中保持代码的整洁和结构。在本书的后续内容中，我们将使用简单的匿名和命名回调作为例子，这些例子不需要超过三层回调嵌套。对于所有其他例子，我们将使用我们刚刚介绍过的伟大的`Async`库。
- en: '|  |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The nerd corner—You promised me more!**'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——你答应我更多！**'
- en: The previous section is an introduction to patterns that help you work efficiently
    with asynchronous programming. There are a number of other popular patterns such
    as promises and events. Promises mainly come from the client-side JavaScript world,
    but you can also use this with Node with libraries such as Bluebird ([https://www.npmjs.com/package/bluebird](https://www.npmjs.com/package/bluebird)).
    The events pattern is used by many Node core modules and is a good way of implementing
    asynchronous libraries ([https://nodejs.org/api/events.html](https://nodejs.org/api/events.html)).
    Don’t hesitate to go ahead and experiment with these patterns to find the one
    that best suits your needs!
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节是关于帮助你高效使用异步编程的模式的介绍。还有许多其他流行的模式，如承诺和事件。承诺主要来自客户端JavaScript世界，但你也可以使用Node.js和像Bluebird([https://www.npmjs.com/package/bluebird](https://www.npmjs.com/package/bluebird))这样的库来实现。事件模式被许多Node核心模块使用，是实现异步库的好方法([https://nodejs.org/api/events.html](https://nodejs.org/api/events.html))。不要犹豫，去尝试这些模式，找到最适合你需求的那一个！
- en: '|  |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.6\. Summary and beyond the book
  id: totrans-752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6. 摘要和本书之外的内容
- en: Embedded devices have become increasingly powerful over the last few years,
    which makes it possible and appealing to use JavaScript and Node.js directly on
    devices.
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过去的几年里，嵌入式设备变得越来越强大，这使得在设备上直接使用JavaScript和Node.js变得可行且具有吸引力。
- en: Using only JavaScript end to end to build IoT prototypes offers considerable
    flexibility and makes it much easier to maintain your code.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用JavaScript从头到尾构建物联网原型提供了相当大的灵活性，并且使代码维护变得更加容易。
- en: You can run Node.js applications on multiple platforms and environments without
    adapting your code, which makes it easy to develop and scale applications in heterogeneous
    deployments.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在多个平台和环境上运行Node.js应用程序，而无需修改代码，这使得在异构部署中开发和扩展应用程序变得容易。
- en: The modularity of Node.js allows you to tap into thousands of community libraries
    to rapidly build complex applications.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的模块化允许你利用数千个社区库快速构建复杂的应用程序。
- en: Single-threaded systems such as the Node runtime and the event loop call for
    a new way of designing applications. Code and libraries must be kept asynchronous.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如同你在本节中看到的，单线程系统，例如Node运行时和事件循环，需要一种新的应用程序设计方式。代码和库必须保持异步。
- en: The basic idea of asynchronous programming is to pass callback functions that
    will be called later on when the results are available.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程的基本思想是在结果可用时传递将被调用的回调函数。
- en: Working with anonymous and named callbacks can lead you to experience callback
    hell! Control flow libraries such as the `async` module help you resolve it and
    better structure your code.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匿名和命名回调可能会导致你经历回调地狱！像`async`模块这样的控制流库可以帮助你解决它，并更好地组织你的代码。
- en: If we piqued your curiosity about Node, it’s probably a good time for you to
    buy a Node.js book^([[17](#ch03fn17)]) and follow the official Node.js^([[18](#ch03fn18)])
    blog.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Node.js引起了你的好奇心，那么现在可能是你购买Node.js书籍^([[17](#ch03fn17)])并关注官方Node.js^([[18](#ch03fn18)])博客的好时机。
- en: ^(17)
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(17)
- en: ''
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.manning.com/catalog/by/subject/](http://www.manning.com/catalog/by/subject/)'
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.manning.com/catalog/by/subject/](http://www.manning.com/catalog/by/subject/)'
- en: ^(18)
  id: totrans-764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://blog.nodejs.org/](http://blog.nodejs.org/)'
  id: totrans-766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://blog.nodejs.org/](http://blog.nodejs.org/)'
- en: Now that you have all the software foundations of your WoT toolbox in place,
    you’re ready to learn about the hardware bits, in particular which devices to
    choose and how to configure them. In the next chapter, we’ll first provide a high-level
    overview of the world of embedded devices and the existing types of platforms
    to consider. Afterward, we’ll dig into setting up a Raspberry Pi device, connecting
    to it a number of sensors and actuators, and managing them with Node, and then
    you’ll have everything ready to make your Pi part of the Web of Things.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将WoT工具箱的所有软件基础都准备好了，你就可以学习关于硬件部分的知识了，特别是选择哪些设备以及如何配置它们。在下一章中，我们将首先提供一个关于嵌入式设备世界和现有平台类型的高层次概述。之后，我们将深入探讨设置树莓派设备，连接多个传感器和执行器，并使用Node.js管理它们，然后你将一切准备就绪，让你的树莓派成为物联网的一部分。
- en: Chapter 4\. Getting started with embedded systems
  id: totrans-768
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 开始使用嵌入式系统
- en: '*This chapter covers*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding the various categories of embedded systems
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解各种嵌入式系统类别
- en: An introduction to working with the Raspberry Pi
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派的简介
- en: An introduction to setting up and using Node.js for IoT prototyping
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍如何设置和使用Node.js进行物联网原型设计
- en: Learning to connect sensors and actuators using GPIOs
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用GPIO连接传感器和执行器
- en: 'As we discussed before, there are two broad categories of physical objects
    on the Web of Things: *tagged* objects and *connected* objects. The first category
    comprises various *tagging* technologies that are attached to a product, such
    as barcodes, QR codes, NFC or RFID tags, and so on. In this case, objects aren’t
    connected directly to the web, only passively, because there’s a need for another
    device or application to interact with the product. Connected objects are directly
    connected to the Web of Things and are the world of embedded systems and embedded
    devices, which are essentially small, relatively inexpensive, low-power computers
    with limited resources and capabilities. You can apply the techniques and architecture
    you’ll learn about in this book to both tagged and connected objects, but the
    focus of this book is mainly on connected objects.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，物联网中的物理对象大致分为两大类：*标记*对象和*连接*对象。第一类包括各种*标记*技术，这些技术附着在产品上，例如条形码、二维码、NFC或RFID标签等。在这种情况下，对象并不是直接连接到网络，而是被动地连接，因为需要另一个设备或应用程序与产品交互。连接对象直接连接到物联网，是嵌入式系统和嵌入式设备的领域，它们本质上是非常小、相对便宜、低功耗的计算机，具有有限的资源和能力。你可以将本书中将要学习的技巧和架构应用于标记对象和连接对象，但本书的重点主要在于连接对象。
- en: In [chapter 2](kindle_split_009.html#ch02), you learned how to consume services
    from a real embedded device—a Raspberry Pi located in our office—to get a first
    glimpse of the Web of Things. But this wasn’t very physical because the device
    you interacted with was neither yours nor next to you.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_009.html#ch02)中，你学习了如何从位于我们办公室的真实嵌入式设备——树莓派——获取服务，以获得对物联网的第一印象。但这是因为你交互的设备既不属于你，也不在你身边，所以这并不是一个非常物理的过程。
- en: In this chapter, we’ll show you how to set up and configure your very own IoT
    device. By the end of this chapter, you’ll have a real device connected to the
    Web of Things, and you’ll have all the tools at hand to be able to program it
    and implement all the concepts presented in the next chapters of this book. You’ll
    start by choosing a hardware platform. There are many options out there, so we’ll
    make sure to help you. You’ll then make your device fit for the Web of Things
    by installing various software packages and libraries. You’ll also learn the basics
    of IoT prototyping with a hint of electronics by connecting real sensors and actuators
    directly to your Raspberry Pi.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何设置和配置您自己的物联网设备。到本章结束时，您将拥有一个连接到万物的真实设备，您将拥有所有工具来编程它并实现本书下一章中介绍的所有概念。您将从选择硬件平台开始。市面上有很多选择，所以我们会确保帮助您。然后，您将通过安装各种软件包和库来使您的设备适合物联网。您还将通过将真实传感器和执行器直接连接到您的树莓派来学习物联网原型设计的基础知识，并了解一些电子学知识。
- en: If this is your first encounter with embedded devices and electronics, this
    chapter will be a gentle (yet challenging) and fun crash course!
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次接触嵌入式设备和电子设备，本章将是一个温和（但具有挑战性）且有趣的快速入门课程！
- en: 4.1\. The world of embedded devices
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 嵌入式设备的世界
- en: 'Literally thousands of embedded platforms types are available, ranging from
    small production runs of general-purpose sensor nodes built for researchers or
    hackers to cheap and mass-produced circuits built specifically for smoke alarms,
    microwave ovens, and alarm clocks. Obviously, we won’t have time to get into a
    deep review of these platforms in this book. What you should remember is that
    there are two big leagues of embedded devices: those targeted at hobbyists (less
    specific and optimized but more reusable and flexible) and those meant to be built
    into real-world industrial products (more optimized for specific use cases, so
    harder to extend and use in other contexts).'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可用的嵌入式平台类型数以千计，从为研究人员或黑客构建的小规模通用传感器节点生产，到专门为烟雾报警器、微波炉和闹钟等设备设计的廉价和大规模生产的电路。显然，在这本书中我们没有时间对这些平台进行深入审查。你应该记住的是，嵌入式设备分为两大类：一类是针对爱好者的（不那么具体和优化，但更可重用和灵活），另一类是旨在集成到实际工业产品中的（针对特定用例进行了更多优化，因此扩展和在其他环境中使用更困难）。
- en: 4.1.1\. Devices for hobbyists vs. industrial devices
  id: totrans-780
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 爱好者设备与工业设备
- en: 'The idea of embedding computers into everyday objects isn’t so novel: our washing
    machines have contained integrated circuits for decades. But they didn’t connect
    to the internet, nor were they designed to be easily accessible or reprogrammable
    by application developers or customers. The emergence of the Internet of Things
    changes the game quite a bit. First, IoT devices are connected to the internet,
    which can be challenging for low-power devices. This constraint gave birth to
    a number of industrial-grade embedded platforms that support various networking
    protocols out of the box, ready to be used for commercial applications. Second,
    the research community and hobbyists started to get increasingly interested in
    tiny computers that not only were easy to program but also could support all sorts
    of sensors or actuators.'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算机嵌入到日常物品中的想法并不新颖：我们的洗衣机已经包含集成电路几十年了。但它们并没有连接到互联网，也不是为了便于应用开发者或客户访问或重编程而设计的。物联网的出现极大地改变了游戏规则。首先，物联网设备连接到互联网，这对低功耗设备来说可能是一个挑战。这种限制催生了一系列工业级嵌入式平台，它们支持各种网络协议，开箱即用，适用于商业应用。其次，研究社区和爱好者开始越来越对小型计算机感兴趣，这些计算机不仅易于编程，而且可以支持各种传感器或执行器。
- en: These two trends gave birth to a myriad of platforms for both real-world and
    industrial use cases as well as for hobbyists and DIY projects. The main difference
    between these two categories is the focus of their users. For industrial platforms,
    the objective has been to reduce the costs so they could be embedded in all kinds
    of consumer products while maintaining a high level of stability (you wouldn’t
    want to have to reboot your washing machine every now and then). Hobbyists, however,
    were less sensitive to industrial-grade performance and robustness and preferred
    platforms that were open and easier to use and extend and that also came with
    an elaborate and easy-to-use tool suite.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个趋势催生了大量针对现实世界和工业用例以及爱好者DIY项目的平台。这两个类别之间的主要区别是用户关注的焦点。对于工业平台，目标一直是降低成本，以便它们可以嵌入各种消费产品，同时保持高水平稳定性（你不会希望每隔一段时间就要重启你的洗衣机）。然而，爱好者对工业级性能和坚固性不太敏感，他们更喜欢开放、易于使用和扩展的平台，并且还配备了详尽且易于使用的工具套件。
- en: Having said that, the traction around the Internet of Things in the recent years
    blurred the line between the two worlds, and you can observe industrial platforms
    manufacturers working hard to make their devices more accessible with better tools.
    Likewise, hobbyist platforms are getting more robust and cheaper and hence are
    now also embedded in real-world products.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，近年来物联网的吸引力模糊了两个世界的界限，你可以看到工业平台制造商正努力通过更好的工具使他们的设备更易于访问。同样，爱好者平台也在变得更加坚固和便宜，因此现在也被嵌入到现实世界的产品中。
- en: Providing a detailed overview of those platforms could easily consume the rest
    of this book, so we describe only some of the most popular ones in [table 4.1](#ch04table01).
    Note that this table is an oversimplification of the brands and their offerings
    and is provided as a high-level overview of some of the big players. Please refer
    to the respective sites of the platforms for more details.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 提供这些平台的详细概述可能会消耗掉这本书的剩余部分，所以我们只描述了一些最受欢迎的[表4.1](#ch04table01)。请注意，这个表格是对品牌及其产品的一个过度简化，提供了一个对一些大玩家的概述。请参考平台的相关网站以获取更多详细信息。
- en: Table 4.1\. An overview of some IoT embedded platforms. Platforms targeting
    hobbyists usually cost more but also have more resources (RAM, CPU, and so on).
    Industrial platforms tend to offer lower specifications but the costs are usually
    lower.
  id: totrans-785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.1. 一些物联网嵌入式平台的概述。针对爱好者的平台通常成本更高，但资源（RAM，CPU等）也更丰富。工业平台倾向于提供较低的规格，但成本通常较低。
- en: '| Brand | Models | CPU | RAM | + | Price | Type | Connectivity |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '| 品牌 | 型号 | CPU | RAM | + | 价格 | 类型 | 连接性 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| Arduino | 20+ and many clones (Spark, Intel, and so on) | ATmega, 8–64 MHz,
    Intel Curie, Linino | 16 KB–64 MB | Largest community | ~30 USD | RTOS, Linux,
    hobbyists | Pluggable extension boards (Wi-Fi, GPRS, BLE, ZigBee, and so on) |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '| Arduino | 20+及众多克隆（Spark，Intel等） | ATmega，8-64 MHz，Intel Curie，Linino | 16
    KB-64 MB | 最大的社区 | ~30 美元 | 实时操作系统，Linux，爱好者 | 可插拔扩展板（Wi-Fi，GPRS，BLE，ZigBee等）
    |'
- en: '| Raspberry Pi | A, A+, B, B+, 2, 3, Zero | ARMv6 or v7, 700 MHz -1.2 GHz |
    256–1 GB | Full Linux, GPU, large community | ~5-35 USD | Linux, hobbyists | Ethernet,
    extension through USB, BLE (Pi3) |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
  zh: '| Raspberry Pi | A，A+，B，B+，2，3，Zero | ARMv6或v7，700 MHz-1.2 GHz | 256-1 GB |
    全Linux，GPU，大型社区 | ~5-35 美元 | Linux，爱好者 | 以太网，通过USB扩展，BLE（Pi3） |'
- en: '| Intel | Edison | Intel Atom 500 MHz | 1 GB | X86, full Linux | ~50 USD |
    Linux, hobbyist to industrial | Wi-Fi, BLE |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| 英特尔 | Edison | Intel Atom 500 MHz | 1 GB | X86，全Linux | ~50 美元 | Linux，爱好者到工业级
    | Wi-Fi，BLE |'
- en: '| BeagleBoard | BeagleBone Black, X15, and so on | AM335x 1 GHz ARMv7 | 512
    MB–2 GB | Stability, full Linux, SDK | ~50 USD | Linux, hobbyist to industrial
    | Ethernet, extension through USB and shields |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| BeagleBoard | BeagleBone Black，X15等 | AM335x 1 GHz ARMv7 | 512 MB-2 GB |
    稳定性，全Linux，SDK | ~50 美元 | Linux，爱好者到工业级 | 以太网，通过USB和屏蔽扩展 |'
- en: '| Texas Instruments | CC3200, SoC IoT, and so on | ARM 80 MHz, etc. | from
    256 KB | Cost, Wi-Fi | <10 USD | RTOS, industrial | Wi-Fi, BLE, ZigBee |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| 德州仪器 | CC3200，SoC IoT等 | ARM 80 MHz等 | 256 KB起 | 成本，Wi-Fi | <10 美元 | 实时操作系统，工业级
    | Wi-Fi，BLE，ZigBee |'
- en: '| Marvell | 88MC200, SoC IoT, and so on | ARM 200 MHz, etc. | from 256 KB |
    Cost, Wi-Fi, SDK | <10 USD | RTOS, industrial | Wi-Fi, BLE, ZigBee |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '| Marvell | 88MC200, SoC IoT等 | ARM 200 MHz等 | 256 KB起 | 成本，Wi-Fi，SDK | <10
    美元 | 实时操作系统，工业级 | Wi-Fi，BLE，ZigBee |'
- en: '| Broadcom | WICED, and so on (also at the heart of the Raspberry PIs) | ARM
    120 MHz, and so on | from 256 KB | Cost, Wi-Fi, SDK | <10 USD | RTOS, industrial
    | Wi-Fi, BLE, ZigBee, Thread |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
  zh: '| Broadcom | WICED等（也是树莓派的核心） | ARM 120 MHz等 | 从256 KB起 | 成本、Wi-Fi、SDK | 低于10美元
    | RTOS、工业 | Wi-Fi、BLE、ZigBee、Thread |'
- en: 4.1.2\. Real-time operating systems vs. Linux
  id: totrans-795
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 实时操作系统与Linux
- en: 'In [table 4.1](#ch04table01), you probably noticed the Type column showing
    RTOS and Linux devices. There are basically two categories of *operating system
    (OS)* used for embedded devices: *real-time OS (RTOS)* and, well, not so real-time
    OS!'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表4.1](#ch04table01)中，你可能注意到了显示RTOS和Linux设备的类型列。用于嵌入式设备的操作系统主要有两大类：*实时操作系统（RTOS）*和，嗯，不那么实时的操作系统！
- en: In essence, what makes an OS real-time is its ability to respond quickly and
    predictably to data that comes in. Real-time OSs are necessary for applications
    that control “big and hairy things” such as nuclear power plants, manufacturing
    chains, and airplanes, where determinism and response time are more critical selection
    factors than anything else. They also usually lead to lower power consumption
    or at least quite predictable power consumption.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，使操作系统成为实时的是它对传入数据的快速和可预测的响应能力。对于控制“大而复杂的事物”的应用程序，如核电站、制造链和飞机，确定性响应时间比其他任何因素都更重要，实时操作系统是必要的。它们通常还会导致功耗降低或至少功耗相当可预测。
- en: When it comes to embedded devices, the world of RTOS is dominated by Free-RTOS,^([[1](#ch04fn01)])
    an open source real-time operating system, although some viable alternatives exist,
    such as Contiki,^([[2](#ch04fn02)]) TinyOS,^([[3](#ch04fn03)]) mbed OS,^([[4](#ch04fn04)])
    and the commercial VxWorks.^([[5](#ch04fn05)])
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到嵌入式设备时，RTOS的世界主要由开源实时操作系统Free-RTOS统治，^([[1](#ch04fn01)])尽管存在一些可行的替代方案，如Contiki，^([[2](#ch04fn02)])TinyOS，^([[3](#ch04fn03)])mbed
    OS，^([[4](#ch04fn04)])以及商业的VxWorks.^([[5](#ch04fn05)])
- en: ¹
  id: totrans-799
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-800
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.freertos.org/](http://www.freertos.org/)'
  id: totrans-801
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.freertos.org/](http://www.freertos.org/)'
- en: ²
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.contiki-os.org/](http://www.contiki-os.org/)'
  id: totrans-804
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.contiki-os.org/](http://www.contiki-os.org/)'
- en: ³
  id: totrans-805
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-806
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.tinyos.net/](http://www.tinyos.net/)'
  id: totrans-807
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.tinyos.net/](http://www.tinyos.net/)'
- en: ⁴
  id: totrans-808
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.mbed.com/en/development/software/mbed-os/](https://www.mbed.com/en/development/software/mbed-os/)'
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.mbed.com/en/development/software/mbed-os/](https://www.mbed.com/en/development/software/mbed-os/)'
- en: ⁵
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-812
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.windriver.com/products/vxworks/](http://www.windriver.com/products/vxworks/)'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.windriver.com/products/vxworks/](http://www.windriver.com/products/vxworks/)'
- en: 'One of the drawbacks of a real-time OS is that it isn’t very good at operating
    many tasks in parallel, which makes it hard to build complex layers offering simple
    abstractions. This is where a non-real-time OS can help. It becomes particularly
    helpful for things that are not so mission-critical where user experience and
    features are more important than a constant, very fast response time. In this
    world—even more than in the RTOS world—one operating system rules them all: Linux.^([[6](#ch04fn06)])'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 实时操作系统的缺点之一是它不太擅长并行处理多个任务，这使得构建提供简单抽象的复杂层变得困难。这就是非实时操作系统可以发挥作用的地方。对于不那么关键的使命，用户体验和功能比恒定的非常快速响应时间更重要，这种情况下它尤其有用。在这个世界里——甚至比RTOS世界——一个操作系统统治着一切：Linux.^([[6](#ch04fn06)])
- en: ⁶
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that a number of projects offer modified versions of the Linux kernel to
    transform it into a real-time OS; see, for instance, [http://www.osadl.org/Realtime-Linux.projects-realtime-linux.0.html](http://www.osadl.org/Realtime-Linux.projects-realtime-linux.0.html).
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，许多项目提供了Linux内核的修改版本，将其转变为实时操作系统；例如，参见[http://www.osadl.org/Realtime-Linux.projects-realtime-linux.0.html](http://www.osadl.org/Realtime-Linux.projects-realtime-linux.0.html)。
- en: Because of its large community, plethora of tools, abstractions, and supported
    architectures, Linux is the ideal environment in which to start tinkering and
    innovating with IoT devices. But don’t get it wrong; it’s also increasingly a
    solid candidate for real-world and robust IoT applications such as for home automation
    or for building application gateways as described in [chapter 5](kindle_split_012.html#ch05).
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其庞大的社区、丰富的工具、抽象和支持的架构，Linux是开始尝试和革新物联网设备的理想环境。但不要误解；它也越来越成为现实世界和稳健物联网应用的合适候选者，例如家庭自动化或构建应用网关，如第5章所述（kindle_split_012.html#ch05）。
- en: '|  |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—I want more operating systems!**'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '**“极客角落——我想有更多的操作系统！”**'
- en: Over the past few years, Linux has become such a popular operating system used
    on embedded devices that a project from the Linux Foundation called Yocto^([[a](#ch04fn1a)])
    is now dedicated to creating custom Linux distributions for embedded devices.
    Similarly, Google is working on Brillo,^([[b](#ch04fn2a)]) an extension of Android
    (which is built on Linux as well) for the IoT, and Ubuntu launched Ubuntu Core
    for the IoT.^([[c](#ch04fn3a)]) Although Linux is massively dominating, there
    are a few alternatives to Linux in this space, such as Windows 10 for IoT.^([[d](#ch04fn4a)])
    We’ll be using Linux Raspbian on the Pi, but you can also try Yocto, Ubuntu Core,
    or Windows 10, all of which run on the Pi (from the Pi 2 onward).
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，Linux已经成为了在嵌入式设备上使用的一种非常流行的操作系统，以至于Linux基金会的一个名为Yocto的项目现在致力于为嵌入式设备创建定制的Linux发行版。同样，谷歌正在开发Brillo，它是Android（同样基于Linux）的一个扩展，用于物联网，而Ubuntu推出了Ubuntu
    Core用于物联网。[^[[a](#ch04fn1a)]][^[[b](#ch04fn2a)]][^[[c](#ch04fn3a)]] 尽管Linux占据了主导地位，但在这个领域还有一些Linux的替代品，例如Windows
    10 for IoT。[^[[d](#ch04fn4a)]] 我们将在Pi上使用Linux Raspbian，但您也可以尝试Yocto、Ubuntu Core或Windows
    10，所有这些都可以在Pi上运行（从Pi 2开始）。
- en: ^a
  id: totrans-822
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.yoctoproject.org/](https://www.yoctoproject.org/)'
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.yoctoproject.org/](https://www.yoctoproject.org/)'
- en: ^b
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^b
- en: ''
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://developers.google.com/brillo/?hl=en](https://developers.google.com/brillo/?hl=en)'
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/brillo/?hl=en](https://developers.google.com/brillo/?hl=en)'
- en: ^c
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^c
- en: ''
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.ubuntu.com/internet-of-things](http://www.ubuntu.com/internet-of-things)'
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.ubuntu.com/internet-of-things](http://www.ubuntu.com/internet-of-things)'
- en: ^d
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^d
- en: ''
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://dev.windows.com/en-us/iot](https://dev.windows.com/en-us/iot)'
  id: totrans-833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://dev.windows.com/en-us/iot](https://dev.windows.com/en-us/iot)'
- en: '|  |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.1.3\. Summary and beyond the Pi
  id: totrans-835
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 摘要和Pi之外
- en: In this section, we offer a condensed introduction to the world of embedded
    devices. Obviously, entire books have been written on this topic, so we didn’t
    try to be exhaustive in our search, but rather tried to give you a general understanding
    of the options and elements to consider when choosing a hardware platform for
    your project.^([[7](#ch04fn07)])
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为您提供了嵌入式设备世界的简要介绍。显然，关于这个主题已经写了很多整本书，所以我们并没有试图全面搜索，而是试图让您对选择项目硬件平台时需要考虑的选项和元素有一个一般性的了解。[^[[7](#ch04fn07)]]
- en: ⁷
  id: totrans-837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A good roundup of popular hardware platforms can be found here: [http://postscapes.com/internet-of-things-hardware](http://postscapes.com/internet-of-things-hardware).'
  id: totrans-839
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以在这里找到对流行硬件平台的良好总结：[http://postscapes.com/internet-of-things-hardware](http://postscapes.com/internet-of-things-hardware)。
- en: We decided to use the Raspberry Pi as the reference platform for the remainder
    of this book. Why the Raspberry Pi? First, because it’s arguably the most popular
    embedded platform along with the Arduino. But unlike the Arduino,^([[8](#ch04fn08)])
    it was built for Linux and was designed from the beginning to be a powerful and
    accessible platform for automation and the Internet of Things. Basically it will
    let you dig into the web and the Internet of Things without having to deal with
    all the challenges (for example, C programming, limited RAM, and rough tools)
    that come with RTOS platforms.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定将Raspberry Pi作为本书剩余部分的参考平台。为什么选择Raspberry Pi？首先，因为它可能是最流行的嵌入式平台之一，与Arduino一样。但与Arduino不同，[^[[8](#ch04fn08)]]
    它是为Linux构建的，从一开始就被设计成一个强大且易于访问的平台，用于自动化和物联网。基本上，它将让您深入挖掘网络和物联网，而无需处理RTOS平台带来的所有挑战（例如，C编程、有限的RAM和粗糙的工具）。
- en: ⁸
  id: totrans-841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s worth noting that there are also a number of new Linux-based Arduinos;
    for example, the Arduino Yun.
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 值得注意的是，还有一些基于Linux的新Arduino；例如，Arduino Yun。
- en: Moreover, as you’ll see in the next section, it’s inexpensive and is available
    in many countries, and it comes with several USB ports for accessories and an
    HDMI output to connect it to your TV or screen. Because it’s based on Linux and
    offers direct access to the OS and therefore Node.js, all the required dependencies
    can be easily installed on it as you would install things on your PC.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如您将在下一节中看到的，它价格低廉，在许多国家都有销售，并且带有多个USB端口用于连接附件，以及一个HDMI输出，可以连接到您的电视或屏幕。因为它基于Linux，并提供对操作系统和Node.js的直接访问，所以您可以在上面轻松安装所有必需的依赖项，就像在您的PC上安装东西一样。
- en: This does not mean the Pi is the only option to run the code provided in this
    book or to learn the Web of Things. As long as you pick a device that can run
    Node.js, you’re pretty much good to go.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着Pi是运行本书中提供的代码或学习物联网的唯一选择。只要您选择一个可以运行Node.js的设备，您基本上就可以开始了。
- en: From proof of concept to industrial prototype
  id: totrans-846
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从概念验证到工业原型
- en: The Pi is definitely one of the easiest ways to get started with the WoT and
    to build all sorts of prototypes. But for anything more serious, such as industrial
    and commercial-grade prototypes or actual products, the classic version of the
    Pi isn’t the best choice. There are a number of reasons for this, but the two
    main ones are the use of an SD card as storage and the form factor of the Pi.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派无疑是开始使用物联网和构建各种原型最容易的方式之一。但对于任何更严肃的应用，如工业和商业级原型或实际产品，经典版本的树莓派并不是最佳选择。这有几个原因，但最主要的是使用SD卡作为存储和树莓派的尺寸。
- en: Relying on an SD card doesn’t work well in the real world. SD cards have a limited
    lifespan. They also occasionally break, get corrupted, or could be easily dislodged.
    A more practical way to store the operating system and the data you need is to
    rely on on-board flash memory. Like SD cards, flash memories are persistent, meaning
    that the data will be kept even if the device isn’t powered. They’re soldered
    to the boards and are also faster and more stable than SD cards.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于SD卡在现实世界中并不适用。SD卡的使用寿命有限。它们有时会损坏、被破坏或容易脱落。一个更实用的方法是将操作系统和所需的数据存储在板载闪存中。与SD卡一样，闪存是持久的，这意味着即使设备未供电，数据也会被保留。它们焊接在板上，并且比SD卡更快、更稳定。
- en: Furthermore, the Pi wasn’t primarily designed to be used in commercial applications
    and therefore has more components and connectors that might not be required for
    most use cases.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，树莓派并非主要用于商业应用，因此它拥有更多可能对于大多数使用场景并非必需的组件和连接器。
- en: Does that mean you won’t be able to apply what you learn here to building a
    commercial-strength prototype? Not at all! Real-world-ready platforms are available
    that are compatible with what you’ll learn in this book and with the code you’ll
    write.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你将无法将在这里学到的知识应用于构建商业级原型？绝对不是！有现成的平台与你在本书中学到的知识和你将编写的代码兼容。
- en: 'First, there’s a version of the Pi that’s much more realistic for the real
    world: the Pi Compute Module.^([[9](#ch04fn09)]) The Compute Module is an embedded
    platform similar to the classic Pi, but with a much smaller form factor and an
    on-board flash memory. Also, the Pi Zero is the latest addition to the Pi family
    and the smallest (65mm x 30mm). Add to that a shocking $5 price tag and it also
    becomes a viable candidate to be embedded within a commercial solution, although
    it lacks network connectivity or on-board flash memory. Similarly to the Pi Zero,
    the C.H.I.P^([[10](#ch04fn10)]) has a small form factor and for $9 also offers
    Wi-Fi and Bluetooth connectivity.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一种树莓派版本更适合现实世界：树莓派计算模块.^([[9](#ch04fn09))) 计算模块是一个类似于经典树莓派的嵌入式平台，但具有更小的尺寸和板载闪存。同样，树莓派Zero是Pi家族的最新成员，也是最小的（65mm
    x 30mm）。再加上令人震惊的5美元价格标签，它也成为商业解决方案中嵌入的可行候选者，尽管它缺少网络连接或板载闪存。与树莓派Zero类似，C.H.I.P^([[10](#ch04fn10)))具有小型化设计，以9美元的价格还提供了Wi-Fi和蓝牙连接。
- en: ⁹
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.raspberrypi.org/products/compute-module/](https://www.raspberrypi.org/products/compute-module/)'
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.raspberrypi.org/products/compute-module/](https://www.raspberrypi.org/products/compute-module/)'
- en: ^(10)
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://getchip.com](http://getchip.com)'
  id: totrans-857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://getchip.com](http://getchip.com)'
- en: Other very good (but slightly more expensive) alternatives exist, such as the
    Intel Edison,^([[11](#ch04fn11)]) which, like the Pi 3, also supports Bluetooth
    Low Energy (see [chapter 5](kindle_split_012.html#ch05)) and Wi-Fi out of the
    box but is much smaller and has an onboard flash.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着其他非常好的（但稍微贵一点的）替代品，例如英特尔爱迪生，^([[11](#ch04fn11))) 它与树莓派3一样，也支持蓝牙低功耗（见[第5章](kindle_split_012.html#ch05)）和Wi-Fi，但体积更小，并具有板载闪存。
- en: ^(11)
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.intel.com/content/www/us/en/do-it-yourself/edison.html](http://www.intel.com/content/www/us/en/do-it-yourself/edison.html)'
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.intel.com/content/www/us/en/do-it-yourself/edison.html](http://www.intel.com/content/www/us/en/do-it-yourself/edison.html)'
- en: If you’re looking for a device to build more mechanically stable prototypes
    without having to solder too much, you should consider the BeagleBoard^([[12](#ch04fn12)])
    platform from BeagleBone, a platform similar to the Pi but known for its robustness
    and stability. Moreover, the BeagleBone offers both SD card and flash-based storage,
    making it easy to move your prototype from a concept to a real-world trial.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一种设备来构建更加机械稳定的原型，而且不需要焊接太多，你应该考虑来自BeagleBone的BeagleBoard^([[12](#ch04fn12)))平台，这是一个与树莓派类似但以坚固和稳定著称的平台。此外，BeagleBone提供SD卡和基于闪存的存储，这使得将你的原型从概念转移到实际世界的试验变得容易。
- en: ^(12)
  id: totrans-863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://beagleboard.org/BLACK](http://beagleboard.org/BLACK)'
  id: totrans-865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://beagleboard.org/BLACK](http://beagleboard.org/BLACK)'
- en: Plenty of other platforms are available, but what’s interesting with the Pi,
    BeagleBone, and Edison is that they all run on Linux and support Node.js. This
    means that most of the examples will run out of the box on these three platforms
    (and many others), but some more advanced examples, such as those using GPIOs,
    might need a slightly different setup or alternative libraries. The appendix gives
    you a number of pointers on using the architecture, concepts, and code examples
    of this book with other devices such as the BeagleBone Black, the Intel Edison,
    and the Arduino boards.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的平台很多，但有趣的是，Pi、BeagleBone 和 Edison 都运行在 Linux 上并支持 Node.js。这意味着大多数示例将直接在这三个平台（以及许多其他平台）上运行，但一些更高级的示例，例如使用GPIO的示例，可能需要稍微不同的设置或替代库。附录为您提供了使用本书的架构、概念和代码示例与其他设备（如BeagleBone
    Black、Intel Edison 和Arduino板）的一些指南。
- en: 4.2\. Set up your first WoT device—Raspberry Pi
  id: totrans-867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 设置您的第一个WoT设备——Raspberry Pi
- en: So far, this chapter has described the world of embedded systems and the various
    aspects to consider when choosing the most appropriate hardware platform for your
    own project. Next, we briefly cover the software layer running on top of your
    hardware platform by discussing the operating system on the device and describing
    how JavaScript and particularly Node.js are a very interesting application-development
    ecosystem for building Web of Things devices.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经描述了嵌入式系统的世界，以及在选择最适合您自己项目的硬件平台时需要考虑的各个方面。接下来，我们将简要介绍运行在您的硬件平台之上的软件层，通过讨论设备上的操作系统，并描述JavaScript和Node.js如何成为构建物联网设备的一个非常有趣的应用开发生态系统。
- en: 4.2.1\. Meet the Raspberry Pi
  id: totrans-869
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 认识 Raspberry Pi
- en: 'The Raspberry Pi is a popular series of single-board computers: think of an
    entire computer not much larger than the credit card you used to buy it (see [figure
    4.1](#ch04fig01)). These devices were developed by the Raspberry Pi foundation
    primarily as educational tools for more people to learn about basic computer science
    and physical computing.'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 是一系列流行的单板计算机：想象一下，一台电脑的大小几乎不比您用来购买它的信用卡大（见图4.1）。这些设备主要由 Raspberry
    Pi 基金会开发，主要是作为教育工具，让更多的人了解基本的计算机科学和物理计算。
- en: Figure 4.1\. The Raspberry Pi 3 and the Pi Zero and their different ports and
    interfaces
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\. Raspberry Pi 3 和 Pi Zero 及其不同的端口和接口
- en: '![](04fig01_alt.jpg)'
  id: totrans-872
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig01_alt.jpg)'
- en: 'The most disruptive model to date is the Raspberry Pi Zero. This device kicked
    off a little revolution: a full Linux computer for $5, a price tag usually reserved
    to the resource limited, low-cost RTOS devices out there. The Pi Foundation went
    so far as to give it away for free, attached to the December 2015 issue of *The
    MagPi* magazine,^([[13](#ch04fn13)]) showing that the days when computers will
    be attached to any object for a ridiculously low cost aren’t that far away!'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止最具颠覆性的型号是 Raspberry Pi Zero。这款设备开启了一场小小的革命：售价仅为5美元的全功能Linux电脑，这个价格通常只属于资源有限、低成本RTOS设备。Pi基金会甚至将其免费赠送，附在2015年12月号的
    *The MagPi* 杂志上，^([[13](#ch04fn13)]) 显示出计算机以极低的价格附加到任何物体上的日子已经不远了！
- en: ^(13)
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.raspberrypi.org/magpi/raspberry-pi-zero-out-today-get-it-free-with-the-magpi-40/](https://www.raspberrypi.org/magpi/raspberry-pi-zero-out-today-get-it-free-with-the-magpi-40/)'
  id: totrans-876
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.raspberrypi.org/magpi/raspberry-pi-zero-out-today-get-it-free-with-the-magpi-40/](https://www.raspberrypi.org/magpi/raspberry-pi-zero-out-today-get-it-free-with-the-magpi-40/)'
- en: In terms of performance, the Pi Zero is pretty similar to the Pi A, but its
    ARMv6 CPU is overclocked at 1 GHz and it boasts twice as much RAM. For only 9
    grams, it also features a micro-SD card slot, a mini-HDMI socket, and two micro
    USB ports (one for power, the other for data).
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，Pi Zero 与 Pi A 非常相似，但其 ARMv6 CPU 被超频至1 GHz，并且拥有两倍多的RAM。仅9克重，它还配备了micro-SD卡槽、mini-HDMI接口和两个micro
    USB端口（一个用于供电，另一个用于数据传输）。
- en: The latest Pi model at the time of writing is the Pi 3\. It’s more expensive
    than the Pi Zero, but it also has significantly more to offer. The Pi 3 boasts
    a quad-core 1.2 GHz CPU, 1 GB RAM, a micro-SD slot, and a Broadcom VideoCore IV
    graphic unit. In terms of connectivity, the Pi 3 has four USB ports (and a Micro
    USB, which is used to power it), an HDMI port, a 3.5mm jack, an Ethernet connector,
    and 40 general-purpose input/output ports (GPIO). Finally, unlike its predecessors,
    the Pi 3 also offers out-of-the-box Wi-Fi and Bluetooth connectivity, making a
    fully WoT-ready device. All of that for a mere 45 grams in total weight!
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 写作时的最新树莓派型号是树莓派3。它比树莓派零贵，但提供的功能也更多。树莓派3拥有四核1.2 GHz CPU、1 GB RAM、一个micro-SD插槽，以及Broadcom
    VideoCore IV图形单元。在连接性方面，树莓派3有四个USB端口（以及一个用于供电的Micro USB端口）、一个HDMI端口、一个3.5mm耳机插孔、一个以太网连接器和40个通用输入/输出端口（GPIO）。最后，与前辈不同，树莓派3还提供了即插即用的Wi-Fi和蓝牙连接性，使其成为一个完全符合物联网（WoT）的设备。所有这些加起来总重量仅为45克！
- en: 4.2.2\. Choosing your Pi
  id: totrans-879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 选择你的树莓派
- en: All the examples in this book were tested on the Pi B+, Pi 2, Pi 3 and Pi Zero.
    Which one should you grab?
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都在Pi B+、Pi 2、Pi 3和Pi Zero上进行了测试。你应该选择哪一个？
- en: 'If you’re just beginning with the IoT and embedded devices, the Pi 3 (or any
    successor) is a safe choice: it offers all the required connectivity out of the
    box and doesn’t require any soldering to connect sensors and actuators to the
    GPIOs. But the Pi 3 is significantly larger and also more power hungry (4 watts
    for the Pi 2 or 3 versus 0.8 watts for the Pi Zero).'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触物联网和嵌入式设备，Pi 3（或任何后续型号）是一个安全的选择：它提供了所有必要的即插即用连接性，并且不需要焊接将传感器和执行器连接到GPIO。但Pi
    3的体积明显更大，而且也更耗电（Pi 2或3为4瓦，而Pi Zero为0.8瓦）。
- en: If size matters to you or if you plan on battery-powering your WoT device, then
    the Pi Zero is an interesting option. But it will require a bit more soldering
    and tinkering.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重视尺寸或计划使用电池为你的物联网（WoT）设备供电，那么树莓派零是一个有趣的选择。但它将需要更多的焊接和调试。
- en: Ideally, by now we’ve convinced you to go ahead and buy a Pi. If we didn’t,
    all hope is not lost! Most of the examples can run on any platform supporting
    client-side JavaScript and Node.js (like, hmm, your laptop!). For those who require
    a Pi—essentially the examples interfacing directly with sensors and actuators
    connected to the embedded device—we’ve created a small library that simulates
    them. Finally, the beauty of using JavaScript and Node for the Physical Web is
    that these examples will work on pretty much any device out of the box. The only
    significant exception is the last mile of code that actually talks to your sensors,
    which you’ll likely have to customize for each device.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，到现在我们已经说服你继续购买一个树莓派。如果我们没有，希望并未完全丧失！大多数示例可以在支持客户端JavaScript和Node.js的任何平台上运行（比如，嗯，你的笔记本电脑！）。对于那些需要树莓派的人——本质上是与连接到嵌入式设备的传感器和执行器直接交互的示例——我们创建了一个小型库来模拟它们。最后，使用JavaScript和Node.js进行物理网络的美丽之处在于，这些示例几乎可以在任何设备上直接运行。唯一的重大例外是实际与你的传感器通信的最后一英里代码，你可能需要为每个设备进行定制。
- en: 'It goes without saying that you’ll have much more fun with this book if you
    actually do have a real device next to you to implement the examples. After all,
    discovering the Web of Things without a Thing to work with sounds like skiing
    in the summer without any snow: a tad frustrating.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，如果你身边真的有一个设备来实施示例，你会从这本书中获得更多的乐趣。毕竟，在没有实物的情况下发现物联网就像在夏天没有雪的滑雪一样：有点令人沮丧。
- en: 4.2.3\. Shopping list
  id: totrans-885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 购物清单
- en: If you do decide to acquire a Raspberry Pi, you might as well get the other
    items on our shopping list. Again, they’re not mandatory to follow the book, but
    they will add a physical touch to the virtual examples of the book. [Table 4.2](#ch04table02)
    lists all the things you should buy or gather to be able to create all the prototypes
    of the book.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定购买树莓派，不妨也把购物清单上的其他物品一起拿下。再次强调，这些物品并非必须跟随本书，但它们将为本书的虚拟示例增添实物触感。[表4.2](#ch04table02)列出了你需要购买或收集的所有物品，以便能够创建本书的所有原型。
- en: Table 4.2\. The components needed to create the physical prototypes described
    later in this section and the rest of this book
  id: totrans-887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.2\. 创建本节和本书其余部分所述物理原型所需的组件
- en: '| Description | Price |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | 价格 |'
- en: '| --- | --- |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Raspberry Pi (any model from the B+ onward, Pi 3 recommended) | ~35 USD |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派（任何从B+开始的型号，推荐Pi 3） | 约35美元 |'
- en: '| A 4–16 GB SD card (e.g., SanDisk Ultra Class 10 MicroSDHC, 16 GB) | ~10 USD
    |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
  zh: '| 4-16 GB SD卡（例如，SanDisk Ultra Class 10 MicroSDHC，16 GB） | 约10美元 |'
- en: '| HCSR501 PIR sensor for Raspberry Pi | ~5 USD |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '| HCSR501树莓派PIR传感器 | ~5 美元 |'
- en: '| DHT22 humidity and temperature sensor | ~5 USD |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
  zh: '| DHT22湿度温度传感器 | ~5 美元 |'
- en: '| Small breadboard or protoboard | ~2 USD |'
  id: totrans-894
  prefs: []
  type: TYPE_TB
  zh: '| 小型面包板或原型板 | ~2 美元 |'
- en: '| Jumper wires for Raspberry Pi (4 M/M and 4 M/F) | ~2 USD |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派跳线（4 M/M和4 M/F） | ~2 美元 |'
- en: '| 330 Ohm resistor | <1 USD |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
  zh: '| 330 欧姆电阻 | <1 美元 |'
- en: '| LEDs | <1 USD |'
  id: totrans-897
  prefs: []
  type: TYPE_TB
  zh: '| LED灯 | <1 美元 |'
- en: '| Wi-Fi USB dongle (optional, for Pi Zero) | ~ 10 USD |'
  id: totrans-898
  prefs: []
  type: TYPE_TB
  zh: '| Wi-Fi USB网卡（可选，用于Pi Zero） | ~10 美元 |'
- en: '| Pi Zero cables bundle (optional, for Pi Zero) | ~ 5 USD |'
  id: totrans-899
  prefs: []
  type: TYPE_TB
  zh: '| Pi Zero线缆套装（可选，用于Pi Zero） | ~5 美元 |'
- en: To know where to buy those items and your Pi, have a look on the book’s official
    website, [http://book.webofthings.io](http://book.webofthings.io), where you’ll
    find a list of our partner retailers, along with special offers or bundles they
    provide to readers of this book.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道在哪里购买这些物品和你的Pi，请查看本书的官方网站[http://book.webofthings.io](http://book.webofthings.io)，在那里你可以找到我们合作伙伴零售商的列表，以及他们为本书读者提供的特别优惠或捆绑包。
- en: 4.2.4\. Setting up your Raspberry Pi
  id: totrans-901
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4. 设置你的树莓派
- en: A detailed tutorial on how to use a Raspberry Pi is beyond the scope of this
    book, and its usage has been widely documented on the web.^([[14](#ch04fn14)])
    Nevertheless, we’ll help you set up your Pi to make it fit for the WoT.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不涉及如何使用树莓派的详细教程，其使用方法已在网络上广泛记录。[^([14](#ch04fn14))] 尽管如此，我们将帮助你设置Pi，使其适合物联网。
- en: ^(14)
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A good place to start is the Pi portal at [http://www.raspberrypi.org/](http://www.raspberrypi.org/).
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个好的起点是树莓派门户[http://www.raspberrypi.org/](http://www.raspberrypi.org/)。
- en: Start by installing the right operating system. A number of operating systems
    can run on a Raspberry Pi. For practical reasons, in this book we’ll focus on
    Raspbian, which is essentially a port of the Debian Linux system tailored to fit
    the needs of the Pi and its users. The advantage of Raspbian is that it has been
    widely used and tested on the Pi and is easy to install and customize; therefore,
    it provides a stable and popular operating system to build on.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装正确的操作系统。许多操作系统可以在树莓派上运行。出于实用性的考虑，在这本书中，我们将专注于Raspbian，它本质上是一个针对Pi及其用户定制的Debian
    Linux系统的移植版本。Raspbian的优势在于它已经在Pi上广泛使用并经过测试，易于安装和定制；因此，它提供了一个稳定且流行的操作系统，可以在此基础上构建。
- en: The easiest way to get Raspbian installed on your Pi is to use a tool called
    NOOBS (New Out Of the Box Software). NOOBS is an OS manager that will assist you
    with the installation, and we’ll show you how to use it in this section.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Pi上安装Raspbian的最简单方法就是使用一个名为NOOBS（New Out Of the Box Software）的工具。NOOBS是一个操作系统管理器，它将帮助你进行安装，我们将在本节中向你展示如何使用它。
- en: Should you want to take the fastest possible route, we also created a WoT version
    of Raspbian that contains everything you need to get started already set up. You
    can find it on [http://book.webofthings.io](http://book.webofthings.io) and jump
    directly to [section 4.3](#ch04lev1sec3). Taking the manual route will let you
    learn more and will ensure you have a custom and up-to-date system at hand, so
    it’s your call.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要走最快的路线，我们还创建了一个包含所有启动所需内容的WoT版本Raspbian。你可以在[http://book.webofthings.io](http://book.webofthings.io)找到它，并直接跳转到[第4.3节](#ch04lev1sec3)。走手动路线会让你学到更多，并确保你手头有一个定制且最新的系统，所以这取决于你。
- en: '|  |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—Let’s have a word about current**'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '**极客角落——让我们谈谈电流**'
- en: The Pi gets all the power it needs from the Micro USB connector (shown in [figure
    4.1](#ch04fig01)); this means that the current provided on this cable should be
    high enough. Under stress, a Pi B+ or Zero will draw about 500 mA. A Pi 2 will
    need about 1000 mA and a Pi 3 about 1.5 mA. Exactly how much current you’ll need
    depends on what you connect to the Pi, especially to the male USB ports of the
    Pi. We won’t connect power-hungry accessories in this book, so you can consider
    the power requirements for a bare-bones Pi but a good compromise is a USB power
    source that provides 2000 mA (check the back of the USB adapter or the specs of
    your computer’s USB ports to find this out).
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: Pi从Micro USB连接器（如图4.1所示）获取所有所需的电源；这意味着这条电缆提供的电流应该足够高。在压力下，Pi B+或Zero将消耗大约500
    mA。Pi 2需要大约1000 mA，而Pi 3需要大约1.5 mA。你需要多少电流取决于你连接到Pi的东西，特别是Pi的USB端口。在这本书中，我们不会连接耗电的附件，所以你可以考虑裸机Pi的电源需求，但一个好的折衷方案是提供2000
    mA的USB电源（检查USB适配器的背面或你电脑USB端口的规格以了解这一点）。
- en: '|  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Installing Raspbian with NOOBS
  id: totrans-913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用NOOBS安装Raspbian
- en: First, you’ll need to format your micro SD card as FAT32\. Make sure your card
    is large enough because it’s the primary storage space of the Pi. It should be
    at least 4 GB, but we recommend using a larger one to ensure you have plenty of
    space for the software you’ll install.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将micro SD卡格式化为FAT32。确保您的卡足够大，因为它是Pi的主要存储空间。它应该至少有4GB，但我们建议使用更大的卡以确保您有足够的空间安装软件。
- en: '|  |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Attention!
  id: totrans-916
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意！
- en: According to the SD specification, a card with more than 32 GB will be formatted
    using exFAT instead of FAT. This means it might not work on the Raspberry Pi using
    NOOBS. You can use a formatting tool such as GParted on Linux or Disk Utility
    on a Mac OS to transform it to FAT32, but some users reported problems with this
    as well. To avoid any hassle, choose an SD card between 4 GB and 32 GB, ideally
    a fast one from a trusted brand. We had good success with SanDisk Ultra Class
    10 16 GB cards.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SD规范，大于32GB的卡将使用exFAT而不是FAT进行格式化。这意味着它可能无法在NOOBS使用的Raspberry Pi上工作。您可以使用Linux上的GParted或Mac
    OS上的磁盘工具等格式化工具将其转换为FAT32，但一些用户也报告了这方面的问题。为了避免任何麻烦，选择一个4GB到32GB之间的SD卡，理想情况下是一个来自可信品牌的快速卡。我们使用SanDisk
    Ultra Class 10 16GB卡取得了良好的效果。
- en: '|  |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To install Linux on your SD card so that you can plug it in your Pi and use
    it, follow these instructions:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 要在SD卡上安装Linux以便您可以将它插入Pi并使用它，请按照以下说明操作：
- en: '**1**.  Format the micro SD card where Raspbian will be installed.'
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 格式化将要安装Raspbian的micro SD卡。'
- en: ''
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On Linux, open GParted^([[15](#ch04fn15)]) and use the Devices menu to select
    the device corresponding to your SD card (make sure you’re formatting the SD card
    and not your computer). Then, right-click the biggest partition to format it to
    FAT32.
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Linux上，打开GParted^([[15](#ch04fn15)])并使用设备菜单选择与您的SD卡对应的设备（确保您正在格式化SD卡而不是您的计算机）。然后，右键单击最大的分区将其格式化为FAT32。
- en: ''
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On Mac OSX, use Disk Utility. Select the SD card reader and click Erase. Select
    MS-DOS (FAT) as the format, give it a name (for example, WOT_PI), and select Erase
    to proceed with formatting the card; see [figure 4.2](#ch04fig02). Alternatively,
    you can install the free ApplePi-Baker^([[16](#ch04fn16)]) utility—a nice little
    tool that also lets you backup and restore your Pi images.
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Mac OSX上，使用磁盘工具。选择SD卡读取器并点击擦除。选择MS-DOS（FAT）作为格式，给它起个名字（例如，WOT_PI），然后选择擦除以继续格式化卡；参见[图4.2](#ch04fig02)。或者，您可以安装免费的ApplePi-Baker^([[16](#ch04fn16)))实用程序——这是一个很好的小工具，它还允许您备份和恢复您的Pi镜像。
- en: ''
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 4.2\. Formatting an SD card for the NOOBS installer using Disk Utility
    on Mac OS. Make sure you format the card using the MS-DOS (FAT) format.
  id: totrans-926
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. 使用Mac OS上的磁盘工具格式化SD卡以供NOOBS安装程序使用。确保您使用MS-DOS（FAT）格式进行格式化。
- en: ''
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](04fig02_alt.jpg)'
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](04fig02_alt.jpg)'
- en: ''
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On Windows, download and use the SD Card Formatter tool.^([[17](#ch04fn17)])
    Select the Overwrite Format option; note, however, that this tool won’t work on
    cards bigger than 32 GB because it will format them in exFAT.
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Windows上，下载并使用SD卡格式化工具^([[17](#ch04fn17)])。选择覆盖格式选项；然而，请注意，此工具在大于32GB的卡上无法工作，因为它将以exFAT格式化它们。
- en: ''
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(15)
  id: totrans-932
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-933
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://gparted.org/](http://gparted.org/)'
  id: totrans-934
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://gparted.org/](http://gparted.org/)'
- en: ''
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(16)
  id: totrans-936
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(16)
- en: ''
  id: totrans-937
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.tweaking4all.com/hardware/raspberry-pi/macosx-apple-pi-baker/](http://www.tweaking4all.com/hardware/raspberry-pi/macosx-apple-pi-baker/)'
  id: totrans-938
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.tweaking4all.com/hardware/raspberry-pi/macosx-apple-pi-baker/](http://www.tweaking4all.com/hardware/raspberry-pi/macosx-apple-pi-baker/)'
- en: ''
  id: totrans-939
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(17)
  id: totrans-940
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(17)
- en: ''
  id: totrans-941
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.sdcard.org/downloads/formatter_4/](https://www.sdcard.org/downloads/formatter_4/)'
  id: totrans-942
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.sdcard.org/downloads/formatter_4/](https://www.sdcard.org/downloads/formatter_4/)'
- en: '**2**.  Download the latest NOOBS software from the download page of the Raspberry
    Pi community^([[18](#ch04fn18)]) (select NOOBS). The fastest way to download the
    distribution is usually using a Torrent file (before you ask: yes, it’s absolutely
    legal in this case).'
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 从Raspberry Pi社区下载最新的NOOBS软件（选择NOOBS）。通常，使用种子文件（在你问之前：是的，在这种情况下这是绝对合法的）下载发行版是最快的方式。'
- en: ''
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(18)
  id: totrans-945
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-946
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.raspberrypi.org/downloads/](http://www.raspberrypi.org/downloads/)'
  id: totrans-947
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.raspberrypi.org/downloads/](http://www.raspberrypi.org/downloads/)'
- en: '**3**.  Unzip the content of the NOOBS archive and transfer it to the freshly
    formatted SD card. Don’t put the content in a subfolder; copy all the content
    to the root folder of the SD card. Eject (or unmount) the card once you’ve copied
    the files.'
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 解压NOOBS存档的内容并将其传输到新格式化的SD卡。不要将内容放在子文件夹中；将所有内容复制到SD卡的根目录。文件复制完成后，弹出（或卸载）该卡。'
- en: '**4**.  Plug the SD card into the slot on the side of your Pi and plug the
    HDMI cable into a screen, a USB mouse and keyboard into the USB slots, and finally
    the micro USB cable to power (see [figure 4.1](#ch04fig01) to find the right ports).'
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 将SD卡插入Pi侧面的插槽，将HDMI线缆插入屏幕，将USB鼠标和键盘插入USB插槽，最后将micro USB线缆插入电源（参见[图4.1](#ch04fig01)以找到正确的端口）。'
- en: '**5**.  NOOBS should now boot. After about a minute you’ll see a splash screen
    allowing you to install the different OSs supported by the Pi. Select Raspbian
    (a special version of the Linux Debian operating system tailored for the Pi) and
    click Install. This will start installing the OS, which may take up to 30 minutes.'
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. NOOBS现在应该启动。大约一分钟后，您将看到一个启动屏幕，允许您安装Pi支持的不同操作系统。选择Raspbian（为Pi量身定制的Linux
    Debian操作系统的一个特殊版本）并点击安装。这将开始安装操作系统，这可能需要长达30分钟。'
- en: The OS should now be ready. When you start it for the first time, the Pi boots
    up with the X Window graphical environment. If you want to disable this graphical
    user interface, select Menu > Preferences > Raspberry Configuration, and in the
    System tab select To CLI as Boot option. Now restart your Pi; choose Menu > Shutdown
    > Reboot. The Pi should restart, and you’ll soon see a terminal. Should any of
    these steps turn sour, please read the complete install manual online^([[19](#ch04fn19)])
    or post a message on the book forum.^([[20](#ch04fn20)])
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统现在应该准备好了。当您第一次启动时，Pi将带有X Window图形环境启动。如果您想禁用此图形用户界面，请选择菜单 > 首选项 > Raspberry配置，然后在系统选项卡中选择CLI作为启动选项。现在重新启动Pi；选择菜单
    > 关机 > 重新启动。Pi应该重新启动，您很快就会看到一个终端。如果这些步骤中的任何一步出现问题，请在线阅读完整的安装手册^([[19](#ch04fn19)])或在本书论坛上发帖.^([[20](#ch04fn20)])
- en: ^(19)
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（19）
- en: ''
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.raspberrypi.org/help/noobs-setup/](https://www.raspberrypi.org/help/noobs-setup/)'
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.raspberrypi.org/help/noobs-setup/](https://www.raspberrypi.org/help/noobs-setup/)'
- en: ^(20)
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（20）
- en: ''
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://book.webofthings.io](http://book.webofthings.io)'
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://book.webofthings.io](http://book.webofthings.io)'
- en: Connecting the Pi to a network
  id: totrans-958
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将Pi连接到网络
- en: 'Next, you need to connect the Pi to a network. We’ll discuss a range of networking
    protocols in [chapter 5](kindle_split_012.html#ch05), but for now we’ll use Ethernet
    or Wi-Fi. If you opted for a Pi B, B+, or 2, this step is straightforward: plug
    an Ethernet cable from your router into the Pi (see [figure 4.1](#ch04fig01)).'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要将Pi连接到网络。我们将在[第5章](kindle_split_012.html#ch05)中讨论一系列网络协议，但到目前为止，我们将使用以太网或Wi-Fi。如果您选择了Pi
    B、B+或2，这一步很简单：将路由器中的以太网线缆插入Pi（参见[图4.1](#ch04fig01)）。
- en: 'If you chose a Pi Zero or Pi 3 and don’t have the option of connecting a cable
    to your router, you’ll need a little more work to add Wi-Fi connectivity to your
    Pi. This extra work also brings the advantage of portability: your Pi becomes
    wireless and can be placed wherever you want as long as it’s within range of your
    wireless router.'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择了Pi Zero或Pi 3并且没有将线缆连接到路由器的选项，您需要做更多的工作来将Wi-Fi连接添加到您的Pi上。这项额外的工作也带来了便携性的优势：您的Pi变得无线，只要在无线路由器的范围内，您就可以将其放置在您想要的位置。
- en: The software to support Wi-Fi connectivity is already present in Raspbian, but
    you need to enable this feature by modifying the Wi-Fi network configuration file,
    as shown in the next listing.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Wi-Fi连接的软件已经存在于Raspbian中，但您需要通过修改Wi-Fi网络配置文件来启用此功能，如下所示。
- en: Listing 4.1\. Modifying the Wi-Fi configuration file
  id: totrans-962
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1. 修改Wi-Fi配置文件
- en: '![](094fig01_alt.jpg)'
  id: totrans-963
  prefs: []
  type: TYPE_IMG
  zh: '![图片](094fig01_alt.jpg)'
- en: You can now save and close this file by pressing `CTRL+X`, then `Y`, and then
    `ENTER`. Once this is done, perform a clean shutdown with `sudo shutdown –h now`.
    Then, if you use a Pi Zero, insert a compatible Wi-Fi USB dongle into any free
    USB port (no need to do this on a Pi 3 because the Wi-Fi is onboard). Note that
    when using the Pi Zero you’ll need to unplug any other device (for example, your
    keyboard) and use a USB-to–Micro USB converter. Check the shopping list in [table
    4.2](#ch04table02) for more details about these components.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过按`CTRL+X`，然后`Y`，然后`ENTER`来保存并关闭此文件。完成此操作后，使用`sudo shutdown –h now`进行干净关机。然后，如果您使用Pi
    Zero，将兼容的Wi-Fi USB扩展卡插入任何空闲的USB端口（在Pi 3上不需要这样做，因为Wi-Fi是内置的）。请注意，当使用Pi Zero时，您需要拔掉任何其他设备（例如，您的键盘）并使用USB到Micro
    USB转换器。在[表4.2](#ch04table02)的购物清单中查看有关这些组件的更多详细信息。
- en: Once your Pi restarts, it should connect to your Wi-Fi network. This process
    can take up to a minute on some networks. In the next section we’ll verify that
    this all worked by remotely accessing the Pi.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的Pi重新启动，它应该会连接到您的Wi-Fi网络。这个过程在某些网络上可能需要长达一分钟。在下一节中，我们将通过远程访问Pi来验证这一切是否成功。
- en: '|  |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The nerd corner—I want more Wi-Fi**'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '**极客角落——我想要更多的Wi-Fi**'
- en: The method described here works to connect your Pi to a WPA (Wireless Protected
    Access) or the more secure WPA2\. It may not work if your Wi-Fi is set up using
    a different security protocol such as (the not-so-secure) WEP or WPA2 Enterprise.
    All hope is not lost, however, and you’ll find a number of good tutorials on the
    web on how to connect a Pi to different Wi-Fi networks. A good place to start
    is [https://www.raspberrypi.org/documentation/configuration/wireless](https://www.raspberrypi.org/documentation/configuration/wireless).
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的方法可以用来将你的Pi连接到WPA（无线保护访问）或更安全的WPA2。如果你的Wi-Fi使用的是不同的安全协议，如（不那么安全的）WEP或WPA2企业版，则可能不起作用。然而，并非所有的希望都破灭了，你可以在网上找到许多关于如何将Pi连接到不同Wi-Fi网络的优秀教程。一个不错的起点是[https://www.raspberrypi.org/documentation/configuration/wireless](https://www.raspberrypi.org/documentation/configuration/wireless)。
- en: '|  |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Remotely accessing your Pi
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 远程访问你的Pi
- en: 'Your Pi should now be up, running, and connected. Although you can write and
    run all exercises directly on the Pi using a keyboard, mouse, and screen, a more
    practical option is to run it “headless” (that is, without a display/keyboard
    attached to it) and remotely connect to it via SSH. The only problem in this mode
    is finding your Pi in the first place. This is actually a well-known problem in
    the Internet of Things known as the bootstrap or discovery problem: *given a device
    connecting the very first time to a network, how do you find its address?*'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Pi现在应该已经启动，运行，并且连接上了。虽然你可以使用键盘、鼠标和屏幕直接在Pi上编写和运行所有练习，但更实用的选项是将其“无头”（即，不连接显示器/键盘）运行，并通过SSH远程连接到它。在这种模式下唯一的问题是首先找到你的Pi。这实际上是物联网中一个众所周知的问题，称为引导或发现问题：*给定一个设备第一次连接到网络，你如何找到它的地址？*
- en: To resolve this problem, use the Avahi mDNS server of your Pi. mDNS is a discovery
    protocol that we’ll cover in [chapter 8](kindle_split_016.html#ch08), but for
    now it’s enough to understand that it gives your Pi an address that nearby computers
    can use to find it. Avahi is installed by default on the latest versions of Raspbian,
    so you can go ahead and use it.^([[21](#ch04fn21)]) By default, Avahi will set
    up the Pi to respond to the `raspberrypi.local` domain. You can check this by
    running the command shown in [listing 4.2](#ch04ex02) from a terminal on Linux/Mac
    OS. Windows users should try the ping command shown in the following listing with
    the command prompt (`cmd.exe`). Unfortunately, you might not find your Pi, because
    mDNS isn’t supported out of the box on Windows machines. It will work if you installed
    an application bundling an mDNS service such as iTunes. But if you didn’t, you’ll
    need to install an mDNS service such as Bonjour Print Services for Windows.^([[22](#ch04fn22)])
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，使用你的Pi的Avahi mDNS服务器。mDNS是一种发现协议，我们将在[第8章](kindle_split_016.html#ch08)中介绍，但就现在而言，了解它为你的Pi提供了一个地址，附近的计算机可以使用该地址找到它就足够了。Avahi默认安装在最新的Raspbian版本中，所以你可以继续使用它.^([[21](#ch04fn21)])
    默认情况下，Avahi将设置Pi以响应`raspberrypi.local`域名。你可以通过在Linux/Mac OS的终端上运行[列表4.2](#ch04ex02)中显示的命令来检查这一点。Windows用户应尝试以下列表中的ping命令，使用命令提示符（`cmd.exe`）。不幸的是，你可能找不到你的Pi，因为Windows机器上默认不支持mDNS。如果你安装了捆绑mDNS服务的应用程序，如iTunes，则它将工作。但如果你没有，你需要安装一个mDNS服务，如Bonjour
    Print Services for Windows.^([[22](#ch04fn22)])
- en: ^(21)
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(21)
- en: ''
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it isn’t installed on your Pi, run `sudo apt-get install avahi-daemon` to
    install it.
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它没有安装在你的Pi上，运行`sudo apt-get install avahi-daemon`来安装它。
- en: ^(22)
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(22)
- en: ''
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can download it for free from [http://www.apple.com/support/bonjour](http://www.apple.com/support/bonjour).
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以免费从[http://www.apple.com/support/bonjour](http://www.apple.com/support/bonjour)下载它。
- en: Listing 4.2\. Pinging your Pi
  id: totrans-979
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2\. Ping你的Pi
- en: '![](095fig01_alt.jpg)'
  id: totrans-980
  prefs: []
  type: TYPE_IMG
  zh: '![](095fig01_alt.jpg)'
- en: 'If everything worked well, you should now be able to access your Pi via its
    local DNS address: `raspberrypi.local`. Note that you can change this address
    should you need to; for example, if you have more than one Pi at home.^([[23](#ch04fn23)])'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你现在应该能够通过其本地DNS地址访问你的Pi：`raspberrypi.local`。请注意，如果你需要，你可以更改此地址；例如，如果你家里有多个Pi。^([[23](#ch04fn23)])
- en: ^(23)
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(23)
- en: ''
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [http://www.howtogeek.com/167195/how-to-change-your-raspberry-pi-or-other-linux-devices-hostname/](http://www.howtogeek.com/167195/how-to-change-your-raspberry-pi-or-other-linux-devices-hostname/).
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看[http://www.howtogeek.com/167195/how-to-change-your-raspberry-pi-or-other-linux-devices-hostname/](http://www.howtogeek.com/167195/how-to-change-your-raspberry-pi-or-other-linux-devices-hostname/)。
- en: Creating a network for your Pi
  id: totrans-985
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为你的Pi创建网络
- en: 'The method just described works well if you have access to a nearby router
    with an Ethernet port available or have added a Wi-Fi dongle to your Pi. If that’s
    not the case—for example, if you’re in a hotel room—there’s another nice and easy
    way of working with your Pi: creating a wired network between your Pi and your
    desktop/laptop computer.'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以访问附近带有以太网端口的路由器或已将 Wi-Fi 拨号器添加到您的 Pi 上，那么上述方法将很好地工作。如果情况不是这样——例如，如果您在酒店房间——还有另一种与
    Pi 一起工作的简单且不错的方法：在您的 Pi 和台式机/笔记本电脑计算机之间创建有线网络。
- en: This process is supported on Windows, Mac OS, and Linux and is well-documented
    on the internet.^([[24](#ch04fn24)]) As an example, we’ll describe how to do this
    on a Mac OS machine.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程在 Windows、Mac OS 和 Linux 上都受支持，并在互联网上有很好的文档记录。[^24](#ch04fn24) 例如，我们将描述如何在
    Mac OS 机器上执行此操作。
- en: ^(24)
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([24](#ch04fn24))
- en: ''
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://pihw.wordpress.com/guides/direct-network-connection/](https://pihw.wordpress.com/guides/direct-network-connection/)'
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://pihw.wordpress.com/guides/direct-network-connection/](https://pihw.wordpress.com/guides/direct-network-connection/)'
- en: If your machine doesn’t have an Ethernet port, you’ll need an Ethernet-to-USB
    or Thunderbolt adapter. To get started, plug your Pi into the Ethernet port on
    your machine. Then, open your System Preferences and select Sharing. Enable Internet
    Sharing from Wi-Fi to Thunderbolt Ethernet, as shown on [figure 4.3](#ch04fig03).
    This will effectively share the internet connection that your machine gets through
    Wi-Fi with the Pi.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的机器没有以太网端口，您需要一个以太网到 USB 或 Thunderbolt 适配器。要开始，将您的 Pi 插入机器上的以太网端口。然后，打开系统偏好设置并选择共享。如图
    [图 4.3](#ch04fig03) 所示，启用从 Wi-Fi 到 Thunderbolt 以太网的互联网共享。这将有效地将您的机器通过 Wi-Fi 获得的互联网连接与
    Pi 共享。
- en: Figure 4.3\. Sharing internet with your Pi over Thunderbolt Ethernet on Mac
    OS
  id: totrans-992
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 在 Mac OS 上通过 Thunderbolt 以太网与您的 Pi 共享互联网
- en: '![](04fig03_alt.jpg)'
  id: totrans-993
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig03_alt.jpg)'
- en: If you didn’t change the configuration of the Ethernet port, this should work
    out of the box. If it doesn’t, go to System Preferences again and check that the
    Ethernet connection (for example, USB Ethernet or Thunderbolt Ethernet) is set
    to Using DHCP.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有更改以太网端口的配置，这应该会直接工作。如果不工作，请再次转到系统偏好设置并检查以太网连接（例如，USB 以太网或 Thunderbolt 以太网）是否设置为使用
    DHCP。
- en: 4.2.5\. Connecting to your device
  id: totrans-995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.5\. 连接到您的设备
- en: Once the Pi has started successfully, you’ll be able connect to it using SSH
    (Secure Shell).
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Pi 成功启动，您就可以使用 SSH（安全外壳）连接到它。
- en: SSH to your Pi on Linux or Mac OS
  id: totrans-997
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Linux 或 Mac OS 上 SSH 到您的 Pi
- en: On a Linux or Mac OS machine, an SSH client is already installed, so all you
    need to do is open your terminal with the command (the default password is “raspberry”)
    in the following listing.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或 Mac OS 机器上，SSH 客户端已经安装，所以您需要做的就是使用以下命令打开终端（默认密码是“raspberry”）。
- en: Listing 4.3\. Connecting to the Pi using `ssh`
  id: totrans-999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 使用 `ssh` 连接到 Pi
- en: '![](097fig01_alt.jpg)'
  id: totrans-1000
  prefs: []
  type: TYPE_IMG
  zh: '![图片](097fig01_alt.jpg)'
- en: SSH your Pi on Windows
  id: totrans-1001
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Windows 上 SSH 到您的 Pi
- en: 'To use SSH on Windows you can download the PuTTy SSH client.^([[25](#ch04fn25)])
    This client is lightweight and doesn’t even require an installation: download
    it and double-click to start it. Write the address of your Pi (`raspberrypi.local`
    or the IP address) in the Host Name field and click Open. Your Pi should then
    prompt you for a username (the default is “pi”) and a password (the default is
    “raspberry”).'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上使用 SSH，您可以下载 PuTTy SSH 客户端。[^25](#ch04fn25) 此客户端轻量级，甚至不需要安装：下载它并双击以启动它。在主机名字段中输入您的
    Pi 地址（`raspberrypi.local` 或 IP 地址），然后单击打开。然后，您的 Pi 应该会提示您输入用户名（默认为“pi”）和密码（默认为“raspberry”）。
- en: ^(25)
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([25](#ch04fn25))
- en: ''
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.chiark.greenend.org.uk/~sgtatham/putty/](http://www.chiark.greenend.org.uk/~sgtatham/putty/)'
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.chiark.greenend.org.uk/~sgtatham/putty/](http://www.chiark.greenend.org.uk/~sgtatham/putty/)'
- en: '|  |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Attention!
  id: totrans-1007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意！
- en: Once you’re logged in, use the `passwd` command to change your password. Provided
    you’ll connect your device to the world *wild* web, this is probably a good idea
    unless you’re ready to literally open source your home!
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，使用 `passwd` 命令更改您的密码。如果您要将设备连接到互联网的“野生”世界，这可能是个好主意，除非您准备好将您的家开源！
- en: '|  |'
  id: totrans-1009
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.3\. Installing Node.js on the Raspberry Pi
  id: totrans-1010
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 在 Raspberry Pi 上安装 Node.js
- en: As explained in the previous chapter, Node is slowly but steadily making its
    way in the world of embedded systems, providing a nice alternative to the traditional
    C environments of the embedded world, so let’s see how to use Node on a Raspberry
    Pi.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，Node 正在缓慢但稳步地进入嵌入式系统领域，为嵌入式世界的传统 C 环境提供了一个很好的替代方案，因此让我们看看如何在 Raspberry
    Pi 上使用 Node。
- en: The Node.js framework is installed by default on the most recent versions of
    Raspbian, but you need to install the latest version on your Pi. The installation
    is pretty straightforward, but you need a special version of Node. “Why can’t
    I just use the standard Node.js version?” we hear you say. Well, as mentioned
    before, the Pi—and most of the embedded devices out there—run on CPU architectures
    that aren’t compatible with the ones your PCs run on (x86 or x64). More precisely,
    a lot of embedded devices run on ARM^([[26](#ch04fn26)]) processors, which is
    what’s on your Pi. As a consequence, the node binaries that you need on your Pi
    are not the same as the ones you need on your PC. Fortunately, since Node version
    4.0.0, ARM binaries are also available from the official Node website.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 框架默认安装在最新的 Raspbian 版本上，但您需要在您的 Pi 上安装最新版本。安装过程相当简单，但您需要特殊版本的 Node。我们经常听到您说：“为什么我不能直接使用标准的
    Node.js 版本？”好吧，正如之前提到的，Pi 以及大多数嵌入式设备都运行在 CPU 架构上，这些架构与您的 PC 上运行的架构（x86 或 x64）不兼容。更确切地说，许多嵌入式设备运行在
    ARM^([[26](#ch04fn26)]) 处理器上，这正是您的 Pi 上的处理器。因此，您在 Pi 上需要的 node 二进制文件与您在 PC 上需要的不同。幸运的是，自从
    Node 版本 4.0.0 以来，ARM 二进制文件也已在官方 Node 网站上提供。
- en: ^(26)
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(26)
- en: ''
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you decide to use a non-ARM-based platform, you’ll need to find a compiled
    version of Node.js for the system you have or compile it from the source on your
    target platform.
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您决定使用非 ARM 架构的平台，您需要找到适用于您系统的编译好的 Node.js 版本，或者从目标平台上的源代码编译它。
- en: To install the ARM version of Node.js, go to the Node download page at [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    and select the right version for your Pi or other embedded device. As shown in
    [figure 4.4](#ch04fig04), the archive to download depends on the version of the
    ARM architecture your device uses. As an example, the Pi 3 runs on an ARMv7 architecture.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Node.js 的 ARM 版本，请访问 Node 下载页面 [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    并选择适合您的 Pi 或其他嵌入式设备的正确版本。如图 4.4 所示，要下载的存档取决于您的设备使用的 ARM 架构版本。例如，Pi 3 运行在 ARMv7
    架构上。
- en: 'Figure 4.4\. Node.js download page: ARM CPUs are supported, but you need to
    select the right architecture for your embedded device model. As an example, the
    Pi 2 and 3 are built on an ARMv7 CPU architecture whereas the Pi Zero uses an
    ARMv6 architecture.'
  id: totrans-1017
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4. Node.js 下载页面：支持 ARM CPU，但您需要为您的嵌入式设备型号选择正确的架构。例如，Pi 2 和 3 是基于 ARMv7 CPU
    架构构建的，而 Pi Zero 使用 ARMv6 架构。
- en: '![](04fig04_alt.jpg)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig04_alt.jpg)'
- en: Once you locate the right link, copy it (right-click Copy Link Location) and
    run the commands shown in the following listing. This will install Node on your
    Pi.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到正确的链接，复制它（右键单击复制链接位置）并运行以下列表中显示的命令。这将安装 Node 到您的 Pi 上。
- en: Listing 4.4\. Installing Node.js on your Pi
  id: totrans-1020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4. 在您的 Pi 上安装 Node.js
- en: '![](098fig01_alt.jpg)'
  id: totrans-1021
  prefs: []
  type: TYPE_IMG
  zh: '![](098fig01_alt.jpg)'
- en: If the installation was successful (of course it was!), this command should
    give you the version of Node.js installed on the Pi. At the time of writing, 4.x
    is the latest long-term support (LTS) version of Node.js and the code has been
    tested with this version.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功（当然成功了！），此命令应给出 Pi 上安装的 Node.js 版本。在撰写本文时，4.x 是 Node.js 的最新长期支持（LTS）版本，代码已与该版本进行了测试。
- en: 4.3.1\. Using Git and GitHub on the Pi
  id: totrans-1023
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1. 在 Pi 上使用 Git 和 GitHub
- en: Now that Node.js is installed on the Pi, you need a way to write code to work
    with it. Although you could use an editor like Nano/Pico or Vi, you should find
    it much more efficient and comfortable to write code on your desktop or laptop
    machine using your favorite text editor or integrated development environment
    (IDE) and sync it with the Pi whenever you want to test the code.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Node.js 已安装在 Pi 上，您需要一种方法来编写与它一起工作的代码。尽管您可以使用 Nano/Pico 或 Vi 等编辑器，但您会发现使用您喜欢的文本编辑器或集成开发环境（IDE）在您的桌面或笔记本电脑上编写代码要高效得多，并且更舒适，您可以在想测试代码时随时将其与
    Pi 同步。
- en: Start by forking our project on GitHub. In case you’re not familiar with Git,
    *forking* means creating your own copy of the WoT-Book code repository, which
    will allow you to modify the code as you fancy. This is especially useful because
    it lets you write code on your desktop machine or Pi, `commit` it locally, `push`
    it to your fork on GitHub, and then `pull` it back on your Pi. To fork the project,
    go to our GitHub repository at [https://github.com/webofthings/wot-book](https://github.com/webofthings/wot-book)
    and click the Fork button. This creates a copy of the WoT-Book repository in your
    own GitHub space. Then you can install Git on your Pi and clone the project, as
    shown in the next listing.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从GitHub上fork我们的项目。如果您不熟悉Git，*forking*意味着创建WoT-Book代码仓库的自己的副本，这将允许您按需修改代码。这特别有用，因为它让您可以在桌面机器或Pi上编写代码，本地`commit`，然后将它`push`到GitHub上的fork，最后在Pi上`pull`回来。要fork项目，请访问我们的GitHub仓库[https://github.com/webofthings/wot-book](https://github.com/webofthings/wot-book)，并点击Fork按钮。这将在您的GitHub空间中创建WoT-Book仓库的副本。然后您可以在Pi上安装Git并克隆项目，如下一列表所示。
- en: Listing 4.5\. Configuring GitHub on the Pi and forking the project
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5\. 在Pi上配置GitHub并fork项目
- en: '![](099fig01_alt.jpg)'
  id: totrans-1027
  prefs: []
  type: TYPE_IMG
  zh: '![](099fig01_alt.jpg)'
- en: 4.3.2\. So what?
  id: totrans-1028
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 那么，这又意味着什么呢？
- en: Hopefully, you’ve made it this far without too many scars and you’ve been able
    to do everything as described. If that’s the case, you’re doing absolutely great
    and can pat yourself on the back. You now have a fully functional and WoT-ready
    Raspberry Pi on which you’ll be able to connect not only your first sensors and
    actuators, as shown in the next section, but also run all the code examples waiting
    for you in the upcoming chapters.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您在旅途中没有受到太多伤害，并且能够按照描述完成所有操作。如果是这样，您做得非常好，可以给自己鼓掌。现在您有一个功能齐全且已准备好WoT的Raspberry
    Pi，您不仅可以将第一台传感器和执行器连接到它，如下一节所示，还可以运行即将到来的章节中等待您的所有代码示例。
- en: 4.4\. Connecting sensors and actuators to your Pi
  id: totrans-1030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 将传感器和执行器连接到您的Pi
- en: Your Pi is now ready to conquer the World Wide Web of Things, but it doesn’t
    have much to work with in the real world yet. To make it more real-world-connected
    you’ll need to connect some sensors (for example, a humidity sensor) and actuators
    (an LED) to the Pi.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Pi现在已准备好征服万维物联网，但在现实世界中它还没有太多可以工作的东西。为了使其与现实世界更加紧密相连，您需要将一些传感器（例如，湿度传感器）和执行器（例如，LED）连接到Pi上。
- en: 4.4.1\. Understanding GPIO ports
  id: totrans-1032
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 理解GPIO端口
- en: 'The way to do this on most platforms, Pi included, is to connect the sensors
    and actuators using the general-purpose input/output (GPIO) ports. Essentially,
    a GPIO is a pin on which current can be read or output. GPIOs have two modes:
    an input mode and an output mode. When the output mode is selected, the pin can
    be set to HIGH, which means it outputs 3.3 volts; when the pin is set to LOW,
    it is off and doesn’t output any voltage. With the input mode, you essentially
    can read a value on the pin. Unlike other embedded platforms (such as Arduino),
    the Pi supports only digital input. This means that you can work only with components
    that supply series of 0s (LOW, ~0 volts) or 1s (HIGH, 3.3 volts) to the input
    pins—that is, with digital components. As an example, an LED is a digital actuator
    and a button is a digital sensor.'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数平台（包括Pi）上执行此操作的方法是使用通用输入/输出（GPIO）端口连接传感器和执行器。本质上，GPIO是一个可以读取或输出电流的引脚。GPIO有两种模式：输入模式和输出模式。当选择输出模式时，引脚可以设置为HIGH，这意味着它输出3.3伏特；当引脚设置为LOW时，它是关闭的，不输出任何电压。在输入模式下，您实际上可以读取引脚上的值。与Arduino等其他嵌入式平台不同，Pi仅支持数字输入。这意味着您只能与向输入引脚提供一系列0s（LOW，约0伏特）或1s（HIGH，3.3伏特）的组件一起工作——即数字组件。例如，LED是一个数字执行器，按钮是一个数字传感器。
- en: Analog components, on the other hand, are those that do not provide or consume
    only LOWs and HIGHs but also supply or consume variable voltages on the pins.
    As an example, a cheap, light-dependent resistor is an analog light sensor and
    a potentiometer button is an analog actuator. If you’d like to experiment with
    analog sensors and actuators, there are a number of extensions boards you can
    connect to your Pi to make it analog-friendly.^([[27](#ch04fn27)])
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，模拟组件是指那些不仅提供或消耗LOW和HIGH，而且在引脚上还提供或消耗可变电压的组件。例如，一个便宜的光敏电阻是一个模拟光传感器，一个电位器按钮是一个模拟执行器。如果您想尝试模拟传感器和执行器，有一些扩展板可以连接到您的Pi上，使其更适合模拟设备。[27](#ch04fn27)
- en: ^(27)
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(27)
- en: ''
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here’s a simple tutorial for how to read analog sensors from your Pi: [https://learn.adafruit.com/reading-a-analog-in-and-controlling-audio-volume-with-the-raspberry-pi/overview](https://learn.adafruit.com/reading-a-analog-in-and-controlling-audio-volume-with-the-raspberry-pi/overview).'
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里有一个简单的教程，教你如何从你的 Pi 读取模拟传感器：[https://learn.adafruit.com/reading-a-analog-in-and-controlling-audio-volume-with-the-raspberry-pi/overview](https://learn.adafruit.com/reading-a-analog-in-and-controlling-audio-volume-with-the-raspberry-pi/overview)。
- en: 'Back to our GPIOs: their numbering differs depending on the model of the Pi.
    Unfortunately, the numbering is anything but intuitive! [Figure 4.5](#ch04fig05)
    helps you to understand what each GPIO pin corresponds to for the Raspberry Pi
    3, 2, and B+. The GPIO pins have had exactly the same layout since the Pi A+.'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 GPIO：它们的编号取决于 Pi 的型号。不幸的是，编号一点也不直观！[图 4.5](#ch04fig05) 帮助你理解每个 GPIO 引脚对应于
    Raspberry Pi 3、2 和 B+ 的内容。GPIO 引脚自 Pi A+ 以来布局完全相同。
- en: Figure 4.5\. Layout of the GPIO, power, and ground pins on the Raspberry Pi
    Zero and Pi 3
  id: totrans-1039
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5\. Raspberry Pi Zero 和 Pi 3 上的 GPIO、电源和地线布局。
- en: '![](04fig05_alt.jpg)'
  id: totrans-1040
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig05_alt.jpg)'
- en: In this book when we refer to, for example, pin 12, we mean pin 12 in [figure
    4.5](#ch04fig05), not GPIO12, which would be pin 32.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，当我们提到，例如，引脚 12 时，我们指的是图 4.5 中的引脚 12，而不是 GPIO12，后者将是引脚 32。
- en: In the following section, you’ll get your hands dirty and connect a passive
    infrared sensor, temperature sensor, and humidity sensor to the Pi through the
    GPIOs.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将动手连接一个被动红外传感器、温度传感器和湿度传感器到 Pi 的 GPIO。
- en: 4.4.2\. Working with breadboards and electronic components
  id: totrans-1043
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 使用面包板和电子组件工作
- en: Let’s begin with the hardware part. For this you’ll need a breadboard, but not
    the kind you’re likely to find in your kitchen. As shown on [figure 4.6](#ch04fig06),
    a breadboard is a board made of plastic and metal that prevents you from having
    to solder components when creating a prototype. Basically, the exterior blue row
    is the one that gets connected to the ground (GND, -). All holes in this row are
    connected through a metal plate. The exterior red row is the one that will receive
    the power (VCC, +). All rows are connected. The inner columns are meant to hold
    components like LEDs and sensors or resistors.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从硬件部分开始。为此，你需要一个面包板，但不是你可能在厨房里找到的那种。如图 4.6 所示，面包板是由塑料和金属制成的板，可以防止你在创建原型时焊接组件。基本上，外部的蓝色行是连接到地线（GND，-）的那一行。这一行中的所有孔都通过一个金属板连接。外部的红色行是接收电源（VCC，+）的那一行。所有行都是连接的。内部的列是用来放置像
    LED 和传感器或电阻这样的组件的。
- en: Figure 4.6\. A typical breadboard where the outer rows as well as the inner
    columns are connected. The line marked with a thin blue line is usually used for
    connecting to the ground, and the line marked with a thin red line is for connecting
    to the power source.
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6\. 一个典型的面包板，其中外部的行以及内部的列都是连接的。用细蓝色线标记的线通常用于连接到地线，而用细红色线标记的线用于连接到电源。
- en: '![](04fig06_alt.jpg)'
  id: totrans-1046
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig06_alt.jpg)'
- en: For our “Hello World” blinking LED example, we’ll start by placing the elements
    on the breadboard, as shown in [figure 4.7](#ch04fig07).^([[28](#ch04fn28)]) If
    it’s the first time you’ve worked with electronics, we recommend you use an antistatic
    mat or a grounding strap to avoid damaging your Pi.^([[29](#ch04fn29)])
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的“Hello World”闪烁 LED 示例，我们首先将元件放置在面包板上，如图 4.7 所示。[28](#ch04fn28) 如果这是你第一次与电子设备打交道，我们建议你使用防静电垫或接地带，以避免损坏你的
    Pi。[29](#ch04fn29)
- en: ^(28)
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(28)
- en: ''
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This was created with Fritzing, a very cool tool for creating electronic schematics:
    [http://fritzing.org/](http://fritzing.org/).'
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是由 Fritzing 创建的，一个用于创建电子原理图的非常酷的工具：[http://fritzing.org/](http://fritzing.org/).
- en: ^(29)
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(29)
- en: ''
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Learn more about antistatic products here: [http://www.explainthatstuff.com/howantistaticcoatingswork.html](http://www.explainthatstuff.com/howantistaticcoatingswork.html).'
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里了解更多关于防静电产品的信息：[http://www.explainthatstuff.com/howantistaticcoatingswork.html](http://www.explainthatstuff.com/howantistaticcoatingswork.html)。
- en: Figure 4.7\. Wiring an LED to the GPIO ports of the Pi through a resistor. The
    resistor and the LED are plugged into the holes of the breadboard. No need to
    solder anything!
  id: totrans-1054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7\. 通过电阻将 LED 连接到 Pi 的 GPIO 端口。电阻和 LED 插入到面包板的孔中。不需要焊接任何东西！
- en: '![](04fig07.jpg)'
  id: totrans-1055
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig07.jpg)'
- en: 'Place the LED and the 330 Ohm resistor (color code: orange, orange, brown,
    gold/silver) on the breadboard according to the schematics shown in the figure.
    Note that resistors don’t have a direction; they must simply be plugged in, so
    you can connect them in any manner. In case you’re wondering what’s the purpose
    of the resistor, it prevents the LED from melting by limiting the current going
    through it. It also makes sure that the LED doesn’t blow if you invert the connection
    of the VCC and GND pins. Note that you can also use resistors with a greater resistance;
    for example, 1K Ohm—brown, black, red, gold/silver. This will reduce the brightness
    of the LED. Then connect the column with the short leg of the LED to the GND (-,
    blue) line using the resistor and the one with the long leg to the VCC (+, red)
    line using a cable. Finally, connect a cable (ideally a black one to signify ground)
    to pin 6 (GND) and one (ideally a red one to signify power) to pin 7 (GPIO4).'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图中的原理图，将LED和330欧姆电阻（颜色代码：橙色、橙色、棕色、金色/银色）放置在面包板上。请注意，电阻没有方向；它们只需插入即可，因此您可以以任何方式连接它们。如果您想知道电阻的用途，它通过限制通过LED的电流来防止LED熔化。它还确保在您反转VCC和GND引脚的连接时LED不会烧毁。请注意，您也可以使用更大电阻的电阻；例如，1K欧姆——棕色、黑色、红色、金色/银色。这将降低LED的亮度。然后使用电阻将LED短腿所在的列连接到GND（-，蓝色）线，使用电缆将长腿所在的列连接到VCC（+，红色）线。最后，将一根电缆（理想情况下是黑色电缆以表示地线）连接到引脚6（GND），另一根（理想情况下是红色电缆以表示电源）连接到引脚7（GPIO4）。
- en: 4.4.3\. Accessing GPIOs from Node.js
  id: totrans-1057
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3. 从Node.js访问GPIOs
- en: The hardware is now ready, so you can start working with GPIOs. On Linux, GPIOs
    aren’t that mysterious. The values that are being read or written to the pins
    are available through files, so you could theoretically read these virtual files
    directly from your Node code. Doing this correctly is not the easiest thing for
    a beginner, so we won’t cover this method in this book but we’ll use a library
    that others have made. You can find a dozen Node GPIO libraries for the Pi, offering
    different abstraction layers and functionality. We decided to use one we like
    called `onoff`.^([[30](#ch04fn30)]) For more advanced users, `pi-gpio`^([[31](#ch04fn31)])
    would be an excellent alternative.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件现在已准备就绪，您可以开始使用GPIOs。在Linux中，GPIOs并不那么神秘。正在读取或写入引脚的值可以通过文件访问，因此理论上您可以直接从Node代码中读取这些虚拟文件。正确地这样做对于初学者来说不是最容易的事情，所以我们不会在本书中介绍这种方法，但我们将使用其他人制作的库。您可以在Pi上找到数十个Node
    GPIO库，提供不同的抽象层和功能。我们决定使用一个我们喜欢的名为`onoff`的库。^([[30](#ch04fn30)]) 对于更高级的用户，`pi-gpio`^([[31](#ch04fn31)])
    将是一个极好的替代方案。
- en: ^(30)
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(30)
- en: ''
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/fivdi/onoff](https://github.com/fivdi/onoff)'
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/fivdi/onoff](https://github.com/fivdi/onoff)'
- en: ^(31)
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(31)
- en: ''
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/rakeshpai/pi-gpio](https://github.com/rakeshpai/pi-gpio)'
  id: totrans-1064
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/rakeshpai/pi-gpio](https://github.com/rakeshpai/pi-gpio)'
- en: To do the next exercises in this chapter, you can either fork them from our
    GitHub repository and go to the folder chapter4-gpios or create a new folder from
    scratch. Go to that folder and install `onoff` with NPM (`npm install onoff --save`).
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的下一组练习，您可以从我们的GitHub仓库中fork它们并进入chapter4-gpios文件夹，或者从头创建一个新的文件夹。进入该文件夹并使用NPM安装`onoff`（`npm
    install onoff --save`）。
- en: Note that the following examples that use the `onoff` library won’t work on
    your PC because it doesn’t have accessible GPIOs; they will only run on your Pi.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下使用`onoff`库的示例在您的PC上无法工作，因为PC没有可访问的GPIO；它们只能在您的Pi上运行。
- en: blink.js—the Hello World for the IoT
  id: totrans-1067
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: blink.js——物联网的Hello World
- en: You’re now ready to interface the Pi with sensors and actuators. In software
    engineering, the simplest piece of code one can write—the famous Hello World—displays
    “Hello World” in the console. The Hello World equivalent of the IoT is to make
    a real LED blink, so let’s build exactly that, as shown in [listing 4.6](#ch04ex06).
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以准备将Pi与传感器和执行器进行接口。在软件工程中，一个人可以编写的最简单的代码——著名的Hello World——在控制台显示“Hello World”。物联网的Hello
    World等价物是使一个真正的LED闪烁，所以让我们构建一个，如[列表4.6](#ch04ex06)所示。
- en: As mentioned before, you’ll use pin 7, corresponding to GPIO4 (see [figure 4.5](#ch04fig05)).
    You’ll then create a function that opens the pin in output mode, which means you’ll
    “push” current on it. It then either activates or deactivates the pin, depending
    on the result of the modulo function, and launches itself again at a specified
    interval.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您将使用引脚7，对应GPIO4（见[图4.5](#ch04fig05)）。然后您将创建一个函数，将引脚设置为输出模式，这意味着您将在其上“推送”电流。然后根据模运算的结果激活或去激活引脚，并在指定的时间间隔后再次启动。
- en: Finally, you listen for `SIGINT`, which corresponds to pressing Ctrl-C, and
    ensure that you release the pin and turn the LED off before exiting.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应监听`SIGINT`，这对应于按下Ctrl-C，并在退出前确保释放引脚并关闭LED。
- en: 'Listing 4.6\. blink.js: the Hello World of the IoT'
  id: totrans-1071
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. blink.js：物联网的Hello World
- en: '![](103fig01_alt.jpg)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
  zh: '![图片](103fig01_alt.jpg)'
- en: Save this file and run it by typing `node blink.js`. If everything works as
    expected, you should now see your LED blinking. Well done if this is your first
    physical prototype!
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件，通过输入`node blink.js`来运行它。如果一切按预期工作，你现在应该看到LED在闪烁。如果是你的第一个物理原型，做得好！
- en: pir.js—connecting a proximity sensor
  id: totrans-1074
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: pir.js—连接一个接近传感器
- en: Let’s now move to a slightly more interesting use case by adding a sensor to
    your Pi. The sensor you’ll add is known as a passive infrared (PIR) sensor. A
    PIR is sensitive to infrared light and captures the beams emitted by warm bodies
    like humans—or your cat, for that matter, but not zombies. This makes it a cheap
    and ideal sensor to detect movements and intrusions somewhere, so these sensors
    are commonly used in simple burglar alarms or automatic light switches to turn
    on/off lights when needed.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过向Pi添加一个传感器来转向一个稍微更有趣的使用案例。你将添加的传感器被称为被动红外（PIR）传感器。PIR对红外光敏感，并捕捉由人体或其他温暖物体（例如你的猫）发出的光束——但不是僵尸。这使得它成为检测运动和入侵的便宜且理想的传感器，因此这些传感器通常用于简单的防盗报警器或自动开关灯，以便在需要时打开/关闭灯光。
- en: Again, let’s begin with the hardware part of the project. You’ll need a digital
    PIR sensor such as the ones we mentioned on the shopping list of section Meet
    the Raspberry Pi, as well as five cables and a breadboard.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们从项目的硬件部分开始。你需要一个数字PIR传感器，如我们在“认识Raspberry Pi”部分的购物清单中提到的，以及五根电缆和一个面包板。
- en: 'As you can see in [figure 4.8](#ch04fig08), the PIR sensor has three pins:
    one marked VCC (which is its 5-volt power source), one marked OUT (which will
    contain a digital value of sensor status at any point in time: 1 if a warm body
    is detected, 0 otherwise), and the last marked GND (for ground). The pin marked
    OUT needs to be connected to a data pin (GPIO 17 in our example).'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图4.8](#ch04fig08)所示，PIR传感器有三个引脚：一个标记为VCC（这是它的5伏电源），一个标记为OUT（在任何时刻将包含传感器状态的数字值：如果检测到热体，则为1，否则为0），最后一个标记为GND（接地）。标记为OUT的引脚需要连接到一个数据引脚（在我们的例子中是GPIO
    17）。
- en: Figure 4.8\. Connecting a passive infrared sensor to the Pi. The big sensor
    on the breadboard is the PIR, which is connected to a 5-volt power source, a GPIO
    pin, and the ground.
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.8\. 将被动红外传感器连接到Pi。面包板上的大传感器是PIR，它连接到5伏电源、一个GPIO引脚和地。
- en: '![](04fig08.jpg)'
  id: totrans-1079
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig08.jpg)'
- en: Connect the components as shown in [figure 4.8](#ch04fig08). First, connect
    the GND pin to a ground GPIO on the Pi (for example, pin 39) either directly if
    you have a female-female cable (a cable that can plug into a pin on each side)
    or through the breadboard.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 按照如图4.8所示连接组件。[图4.8](#ch04fig08)。首先，将GND引脚连接到Pi上的地GPIO（例如，引脚39），如果你有公对公电缆（一种可以插入每一边引脚的电缆），可以直接连接，或者通过面包板连接。
- en: Then, connect the OUT pin of the PIR to the GPIO 17 (pin 11) on the Pi; this
    is the pin you’ll read the results from. Finally, connect the VCC pin to a GPIO
    (for example, pin 4), providing 5 volts on the Pi, again either directly or through
    the breadboard.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将PIR的OUT引脚连接到Pi上的GPIO 17（引脚11）；这是你将读取结果的引脚。最后，将VCC引脚连接到一个GPIO（例如，引脚4），在Pi上提供5伏电压，同样可以直接连接或通过面包板连接。
- en: You’re now ready to move to the coding part. To make this work, you could regularly
    poll the PIR sensor with the `onoff readSync()` function. But instead of constantly
    polling the sensor for its state and reading the same state several times, it
    would be much better to have your code called whenever the state of the physical
    world changes. This is precisely the level of abstraction that the `onoff` library
    offers; see [listing 4.7](#ch04ex07). The `watch(callback)` function lets you
    enable your code to listen for state changes on a GPIO port. The library then
    automatically calls the `callback` function you pass it whenever the state changes.
    This is a good example of *event-driven programming*, where your code reacts only
    to events that you’re interested in, in which case your code doesn’t need to continuously
    check a certain value but only do something when it changes. It allows your code
    to be simpler, which also reduces the chance of obscure bugs occurring. The event-driven
    approach fits a number of real-world things quite well, and this is somewhat of
    a challenge for the web, as you’ll see in [chapter 6](kindle_split_014.html#ch06).
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以进入编码部分。为了使这可行，您可以使用`onoff readSync()`函数定期轮询PIR传感器。但与其不断轮询传感器的状态并多次读取相同的状态，不如在物理世界状态改变时调用您的代码要好得多。这正是`onoff`库提供的抽象级别；参见[列表4.7](#ch04ex07)。`watch(callback)`函数允许您使您的代码能够监听GPIO端口的更改状态。然后库会自动在状态改变时调用您传递给它的`callback`函数。这是一个*事件驱动编程*的好例子，其中您的代码仅对您感兴趣的事件做出反应；在这种情况下，您的代码不需要持续检查某个值，而只需在它改变时执行某些操作。这使您的代码更简单，同时也减少了出现难以理解的错误的机会。事件驱动方法非常适合许多现实世界的事物，这在第6章中您将看到，对网络来说这是一个挑战。
- en: 'Listing 4.7\. pir.js: reading a PIR sensor using the `onoff` library'
  id: totrans-1083
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. pir.js：使用`onoff`库读取PIR传感器
- en: '![](105fig01_alt.jpg)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
  zh: '![105fig01_alt.jpg](105fig01_alt.jpg)'
- en: As you can see in this listing, the `onoff` library will listen to both rising
    and falling hardware interrupts, and each time the state of the GPIO pin changes,
    it will call the callback function that was registered with the `watch()` function.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以从列表中看到的那样，`onoff`库将监听上升和下降的硬件中断，并且每当GPIO引脚的状态改变时，它将调用通过`watch()`函数注册的回调函数。
- en: dht.js—Connecting a temperature and humidity sensor
  id: totrans-1086
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: dht.js—连接温度和湿度传感器
- en: 'Finally, you’ll make your Pi sense the environment by connecting it to a sensor
    combining temperature and humidity readings. The sensor we’ll use is a DHT22 (aka
    AM2302).^([[32](#ch04fn32)]) Begin by connecting it to your Pi, as shown in [figure
    4.9](#ch04fig09). The DHT22 has four pins. Working from right to left, follow
    these steps:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将通过将其连接到结合温度和湿度读数的传感器来使您的Pi感知环境。我们将使用的传感器是DHT22（也称为AM2302）。首先，按照[图4.9](#ch04fig09)所示将其连接到您的Pi。DHT22有四个引脚。从右到左，按照以下步骤操作：
- en: ^(32)
  id: totrans-1088
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([32])
- en: ''
  id: totrans-1089
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This can also work with a DHT11 sensor.
  id: totrans-1090
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这也可以与DHT11传感器一起工作。
- en: Figure 4.9\. Connecting a DHT22 temperature and humidity sensor to the Pi
  id: totrans-1091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.9\. 将DHT22温度和湿度传感器连接到Pi
- en: '![](04fig09.jpg)'
  id: totrans-1092
  prefs: []
  type: TYPE_IMG
  zh: '![04fig09.jpg](04fig09.jpg)'
- en: '**1**.  Connect the first DH22 pin to a ground (GND) pin; for example, pin
    39\. You don’t connect anything to the second pin.'
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 将第一个DH22引脚连接到地（GND）引脚；例如，引脚39。您不需要连接到第二个引脚。'
- en: '**2**.  Connect the third DH22 pin to the GPIO12 of your Pi (pin 32) and place
    a 4.7K Ohm resistor (yellow, violet, red, gold/silver)^([[33](#ch04fn33)]) between
    the DH22 pin and the connection to the pin of the Pi.'
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将第三个DH22引脚连接到您的Pi的GPIO12（引脚32），并在DH22引脚和Pi引脚之间放置一个4.7K欧姆电阻（黄色、紫色、红色、金色/银色）^([33](#ch04fn33))。'
- en: ''
  id: totrans-1095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(33)
  id: totrans-1096
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([33])
- en: ''
  id: totrans-1097
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use resistances from 4.7K to 10K Ohms.
  id: totrans-1098
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用4.7K到10K欧姆的电阻。
- en: '**3**.  Connect this resistor to the VCC line on the breadboard, the red line.'
  id: totrans-1099
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 将此电阻连接到面包板上的VCC线，红色线。'
- en: '**4**.  Connect the fourth DH22 pin to the VCC line on the breadboard.'
  id: totrans-1100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 将第四个DH22引脚连接到面包板上的VCC线。'
- en: '**5**.  Connect the 3.3-volt power source to the VCC line on the breadboard.'
  id: totrans-1101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 将3.3伏电源连接到面包板上的VCC线。'
- en: Because the DHT22 uses a special protocol, you’ll first need to install an additional
    driver on the Pi called the BCM 2835 C Library.^([[34](#ch04fn34)]) The next listing
    shows how to install it.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DHT22使用特殊的协议，您首先需要在Pi上安装一个额外的驱动程序，称为BCM 2835 C库。^([34](#ch04fn34)) 下一个列表显示了如何安装它。
- en: ^(34)
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([32](#ch04fn32))
- en: ''
  id: totrans-1104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [http://www.airspayce.com/mikem/bcm2835/index.html](http://www.airspayce.com/mikem/bcm2835/index.html).
  id: totrans-1105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 见[http://www.airspayce.com/mikem/bcm2835/index.html](http://www.airspayce.com/mikem/bcm2835/index.html)。
- en: Listing 4.8\. Installing the BCM2835 driver
  id: totrans-1106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8\. 安装BCM2835驱动程序
- en: '![](106fig01_alt.jpg)'
  id: totrans-1107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](106fig01_alt.jpg)'
- en: You’re now ready to interact with the sensor using Node code. To do this, you’ll
    use a Node library called `node-dht-sensor` that you first need to install with
    `npm install --save node-dht-sensor`. The code to run on the Pi is shown in the
    following listing.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用Node代码与传感器进行交互。为此，你需要使用一个名为`node-dht-sensor`的Node库，你首先需要使用`npm install
    --save node-dht-sensor`命令进行安装。要在Pi上运行的代码如下所示。
- en: 'Listing 4.9\. dht.js: communicating with the DHT22 sensor'
  id: totrans-1109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9. dht.js：与DHT22传感器通信
- en: '![](106fig02_alt.jpg)'
  id: totrans-1110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](106fig02_alt.jpg)'
- en: 'Save this file and run it as superuser with the `sudo` command because accessing
    the BCM 2835 driver requires it: `sudo node dht.js`. If everything works fine,
    you should see temperature and humidity values appearing every two seconds.'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存，并使用`sudo`命令以超级用户权限运行，因为访问BCM 2835驱动程序需要这样做：`sudo node dht.js`。如果一切正常，你应该每两秒看到温度和湿度值。
- en: This concludes your first encounter with GPIOs, which are a great way to add
    functionality to your Pi—or any other embedded device, really!—so that it can
    sense or actuate the real world. Now that you have the basics, nothing prevents
    you from adding other sensors and actuators to your Pi; you’ll find plenty of
    tutorials on the web.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着你对GPIO的第一次接触，GPIO是向你的Pi——或者任何其他嵌入式设备——添加功能的一种极好方式，以便它可以感知或控制现实世界。现在你已经掌握了基础知识，没有什么可以阻止你向Pi添加其他传感器和执行器；你将在网上找到大量的教程。
- en: '|  |'
  id: totrans-1113
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The nerd corner—I want to see bits!**'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '**极客角落——我想看到比特！**'
- en: 'Libraries like `onoff` or `node-dht-sensor` prevent you from having to deal
    with the nitty-gritty details of interacting with low-level hardware sensors and
    actuators. This is also what the Web of Things is about: abstracting these (complex)
    details so that you can focus on your creative applications and build them using
    web tools. You might still want to know roughly how these libraries work. Basically,
    `onoff` puts watches on virtual files that Linux uses to update the values of
    GPIOs (1 or 0) using a library called `epoll`. `node-dht-sensor` needs to retrieve
    more complex binary data and uses a C library that communicates over the GPIOs
    using two popular protocols in the low-level embedded world of bits: I2C (Inter-Integrated
    Circuit) and SPI (Serial Peripheral Interface). If you want to dig deeper, reading
    about these protocols is a good start.'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`onoff`或`node-dht-sensor`的库可以防止你处理与底层硬件传感器和执行器交互的繁琐细节。这也是物联网的核心：抽象这些（复杂的）细节，以便你可以专注于你的创意应用，并使用网络工具构建它们。你可能仍然想知道这些库大致是如何工作的。基本上，`onoff`通过名为`epoll`的库监视Linux使用的虚拟文件，以更新GPIO（1或0）的值。`node-dht-sensor`需要检索更复杂的二进制数据，并使用一个C库，通过在底层嵌入式世界的比特中使用两种流行的协议进行通信：I2C（集成电路间）和SPI（串行外围接口）。如果你想深入了解，阅读有关这些协议的内容是一个很好的开始。
- en: '|  |'
  id: totrans-1116
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.4.4\. Beyond the book
  id: totrans-1117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4. 超出书本范围
- en: If you want to learn more about embedded platforms, sensors, and hardware prototyping,
    there are many excellent resources and books that can help. A good source of information
    for emerging embedded platforms is Postscapes^([[35](#ch04fn35)]) and their IoT
    Toolkit.^([[36](#ch04fn36)]) For the more industrial side of things, you can use
    the Embedded portal.^([[37](#ch04fn37)]) For resources about hardware prototyping
    and electronics, make sure you check the Make^([[38](#ch04fn38)]) blog posts,
    books, and magazines. You might also look into the Instructables,^([[39](#ch04fn39)])
    Element 14,^([[40](#ch04fn40)]) and Sparkfun communities,^([[41](#ch04fn41)])
    where you’ll find many step-by-step tutorials and lots of good advice.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于嵌入式平台、传感器和硬件原型设计的信息，有许多优秀的资源和书籍可以帮助你。关于新兴嵌入式平台的信息来源是Postscapes^([[35](#ch04fn35)])以及他们的物联网工具包.^([[36](#ch04fn36)])对于更工业化的方面，你可以使用嵌入式门户.^([[37](#ch04fn37)])关于硬件原型设计和电子资源，确保你查看Make^([[38](#ch04fn38)])博客文章、书籍和杂志。你也可以考虑Instructables^([[39](#ch04fn39)]),
    Element 14^([[40](#ch04fn40)]), 和Sparkfun社区^([[41](#ch04fn41)]), 在那里你可以找到许多逐步教程和大量有用的建议。
- en: ^(35)
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((35))
- en: ''
  id: totrans-1120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://postscapes.com](http://postscapes.com)'
  id: totrans-1121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://postscapes.com](http://postscapes.com)'
- en: ^(36)
  id: totrans-1122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((36))
- en: ''
  id: totrans-1123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://postscapes.com/internet-of-things-resources/](http://postscapes.com/internet-of-things-resources/)'
  id: totrans-1124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://postscapes.com/internet-of-things-resources/](http://postscapes.com/internet-of-things-resources/)'
- en: ^(37)
  id: totrans-1125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((37))
- en: ''
  id: totrans-1126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.embedded.com/](http://www.embedded.com/)'
  id: totrans-1127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.embedded.com/](http://www.embedded.com/)'
- en: ^(38)
  id: totrans-1128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((38))
- en: ''
  id: totrans-1129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://makezine.com/](http://makezine.com/)'
  id: totrans-1130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://makezine.com/](http://makezine.com/)'
- en: ^(39)
  id: totrans-1131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((39))
- en: ''
  id: totrans-1132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.instructables.com/](http://www.instructables.com/)'
  id: totrans-1133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.instructables.com/](http://www.instructables.com/)'
- en: ^(40)
  id: totrans-1134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((40))
- en: ''
  id: totrans-1135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.element14.com/community/welcome](http://www.element14.com/community/welcome)'
  id: totrans-1136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.element14.com/community/welcome](http://www.element14.com/community/welcome)'
- en: ^(41)
  id: totrans-1137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(41)
- en: ''
  id: totrans-1138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://learn.sparkfun.com/](https://learn.sparkfun.com/)'
  id: totrans-1139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://learn.sparkfun.com/](https://learn.sparkfun.com/)'
- en: No doubt this chapter was a challenging one! Covering so many different technologies
    and concrete skills in a single chapter isn’t easy, so you’ve done a great job
    making it so far. But getting your Pi ready for the Web of Things is only the
    beginning.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这一章是一个挑战！在一个章节中涵盖如此多的不同技术和具体技能并不容易，所以你到目前为止做得非常出色。但让你的树莓派为物联网做好准备只是开始。
- en: 4.5\. Summary
  id: totrans-1141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5. 概述
- en: Many types of embedded platforms are commonly used in the Internet of Things,
    and you learned how to pick the right one for your use case.
  id: totrans-1142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多类型的嵌入式平台在物联网中普遍使用，您学习了如何为您的用例选择正确的平台。
- en: 'There are two main categories of operating systems for devices: RTOS and Linux.'
  id: totrans-1143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备操作系统的两大主要类别：实时操作系统（RTOS）和Linux。
- en: By installing Linux on a Raspberry Pi, you can easily access it remotely over
    SSH and configure it to be ready for the Web of Things.
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在树莓派上安装Linux，您可以轻松地通过SSH远程访问它，并配置它以准备好物联网。
- en: Embedded devices allow you to use breadboard, wires, and resistors to wire various
    sensors and actuators to the GPIO pins.
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式设备允许您使用面包板、电线和电阻将各种传感器和执行器连接到GPIO引脚。
- en: Using Node.js on your Pi makes it easy to write simple applications that read
    data from your sensors and control the LED using the `onoff` library asynchronously
    over the GPIO ports.
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的树莓派上使用Node.js可以轻松编写简单的应用程序，这些应用程序可以从您的传感器读取数据，并使用`onoff`库异步地通过GPIO端口控制LED。
- en: 'Now that you have a real embedded device at home, it’s time to connect it to
    the Web of Things. The next chapters will be about making sure it seamlessly integrates
    with the World Wide Web of Things. The first step comes with the next chapter:
    architecting an API for your Pi, its sensors, and actuators and using REST, HTTP,
    WebSockets, and JSON. In the following chapters you’ll see how to make these sensors
    and actuators accessible through web APIs.'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您家里有了真实的嵌入式设备，是时候将其连接到物联网了。接下来的章节将确保它无缝地集成到万维物联网中。第一步将在下一章中介绍：为您的树莓派、传感器和执行器设计API，并使用REST、HTTP、WebSockets和JSON。在接下来的章节中，您将看到如何通过Web
    API使这些传感器和执行器可访问。
- en: Chapter 5\. Building networks of Things
  id: totrans-1148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章. 构建物联网网络
- en: '*This chapter covers*'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: An introduction to network classification models and layered architectures
  id: totrans-1150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络分类模型和分层架构简介
- en: An overview of the various protocols for networking Things
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络化事物各种协议概述
- en: A review of the difference between the Transport and Application layers
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层和应用层之间差异的回顾
- en: A systematic approach to pick the right communication method for your use case
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种系统化的方法来选择适合您用例的通信方式
- en: An overview of the Web of Things layered architecture
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网分层架构概述
- en: 'In the previous chapter you learned how to configure a single device—your Pi—and
    how it can interact with the real world using various sensors and actuators. But
    your Pi is still very lonely: it’s not part of any large network and it can’t
    talk (yet!) with other Things. Nor is it able to communicate with other applications
    and services over the internet. Obviously, the real value of the IoT is realized
    when devices become social and are able to talk to other devices or applications.
    Today, hundreds of different and incompatible networking protocols are being used
    in IoT systems, and sadly, we’re still far from the Internet of Things, where
    all apps and devices can easily talk to each other. How did we end up here and
    why isn’t there a single official protocol for the IoT? Which one is “The” best
    networking protocol I should use for my device? Should I use Bluetooth or Wi-Fi
    for my smart bird feeder? Those are all valid questions, and the goal of this
    chapter is to give you a broad overview of the most common protocols and which
    one is best for a given scenario. Although the beauty of the Web of Things is
    that it doesn’t really matter which one you choose because the WoT is a level
    of abstraction above, you’ll benefit greatly from understanding the nuts and bolts
    of how devices can be connected to form large networks of things.'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何配置单个设备——你的树莓派——以及它是如何通过各种传感器和执行器与真实世界互动的。但你的树莓派仍然非常孤独：它不是任何大型网络的一部分，而且（目前）还不能与其他事物进行交流。它也无法通过互联网与其他应用程序和服务进行通信。显然，物联网的真实价值在于设备变得社会化，能够与其他设备或应用程序进行交流。今天，物联网系统中正在使用数百种不同且不兼容的网络协议，遗憾的是，我们离所有应用程序和设备都能轻松交流的物联网还有很长的路要走。我们是如何走到这一步的，为什么没有统一的官方物联网协议？我应该为我的设备使用哪种网络协议？我应该为我的智能鸟食器使用蓝牙还是Wi-Fi？这些都是有效的问题，本章的目标是为你提供一个关于最常见协议的广泛概述，以及针对特定场景的最佳选择。尽管物联网的魅力在于你选择哪个并不重要，因为物联网是一个高于此的抽象层，但你将极大地受益于理解设备如何连接形成大型事物网络的基础知识。
- en: The truth is that if you only want to write client applications and services
    for the Web of Things, you don’t need to worry about the underlying protocols
    and you could jump directly to [section 5.4](#ch05lev1sec4). But to really understand
    how the Internet of Things works, or if you’re building a connected product, the
    next sections will provide a crash course in the underlying protocols and technologies
    that are used for building networked devices.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，如果你只想为物联网编写客户端应用程序和服务，你不需要担心底层协议，可以直接跳转到[第5.4节](#ch05lev1sec4)。但为了真正理解物联网是如何工作的，或者如果你正在构建一个联网产品，接下来的几节将提供关于用于构建网络设备的底层协议和技术的快速课程。
- en: '[Figure 5.1](#ch05fig01) shows the three types of connectivity (stages) we
    consider in this book. First, we have a lonely device that can sense and interact
    with its surroundings but doesn’t have any connectivity. Second, the device supports
    at least one communication protocol and can talk to other devices to form a small
    network of devices. Third, these devices can be connected to the wider web ecosystem
    so that any application or service can talk to these devices over the internet.
    You had a glimpse of this last stage in [chapter 2](kindle_split_009.html#ch02),
    where you interacted with some real web devices across the globe.'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#ch05fig01)展示了本书中考虑的三种连接类型（阶段）。首先，我们有一个孤独的设备，它可以感知和与其周围环境互动，但没有任何连接性。其次，该设备支持至少一种通信协议，可以与其他设备通信，形成一个小的设备网络。第三，这些设备可以连接到更广泛的网络生态系统，这样任何应用程序或服务都可以通过互联网与这些设备进行通信。你在[第2章](kindle_split_009.html#ch02)中已经看到了这种最后阶段的缩影，当时你与全球的一些真实网络设备进行了交互。'
- en: Figure 5.1\. From one Pi to a network of embedded devices to a network of embedded
    devices interacting with the web and its ecosystem
  id: totrans-1158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 从单个树莓派到网络化的嵌入式设备，再到与网络及其生态系统交互的网络化嵌入式设备
- en: '![](05fig01_alt.jpg)'
  id: totrans-1159
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1](05fig01_alt.jpg)'
- en: In this chapter, we explore how an isolated device can move to stages 2 and
    3\. First, we look at various networking protocols for devices, such as ZigBee
    and Bluetooth, and explain their respective benefits and drawbacks. We don’t expect
    you to become an IoT networking protocol specialist overnight, but you’ll have
    enough understanding of these protocols to know the differences between them and
    which one is better suited for which usage scenario. Next, we’ll introduce you
    to the application layers for Things and describe the most common protocols by
    looking at their strengths and weaknesses. Finally, we’ll show how to go beyond
    that and integrate Things to the web in a systematic manner thanks to the Web
    of Things architecture that the following chapters are based on.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨一个孤立设备如何进入2和3阶段。首先，我们查看各种设备网络协议，例如ZigBee和蓝牙，并解释它们各自的优缺点。我们并不期望你一夜之间成为物联网网络协议专家，但你将足够了解这些协议，以了解它们之间的区别以及哪个更适合哪种使用场景。接下来，我们将向您介绍事物的应用层，并通过观察它们的优缺点来描述最常见的协议。最后，我们将展示如何利用后续章节所基于的物联网架构，以系统化的方式将事物集成到网络中。
- en: 5.1\. Connecting Things
  id: totrans-1161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 连接事物
- en: 'You probably already know that computers talk to each other by using a networking
    protocol. Let’s set the stage for a deeper dive into some of the most common networking
    protocols for the IoT so that you know which one is best for your next IoT project.
    Before diving into the protocols, we have to present two important networking
    concepts: topologies and classification models.'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道，计算机通过使用网络协议相互通信。让我们为深入了解物联网中最常见的网络协议做好准备，以便你知道哪个最适合你的下一个物联网项目。在深入探讨协议之前，我们必须介绍两个重要的网络概念：拓扑和分类模型。
- en: 5.1.1\. Network topologies
  id: totrans-1163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1. 网络拓扑
- en: One way to understand how a network of devices differs from another is to look
    at its *topology*, which is a fancy word for the structure of the connections
    between the devices. Members of a network are often called *nodes*, and the topology
    is the spatial organization of the nodes to form a network. Let’s look at the
    different topologies of a network and which topology to use in which situation.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个设备网络与另一个设备网络的不同的一种方法是通过观察其**拓扑**，这是一个指代设备之间连接结构的术语。网络成员通常被称为**节点**，拓扑是节点在空间上的组织形式，以形成一个网络。让我们看看网络的不同的拓扑结构以及在不同情况下使用哪种拓扑。
- en: Point-to-point
  id: totrans-1165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 点对点
- en: 'The simplest network topology occurs when any two devices establish a direct
    connection and start talking to each other. This model is called *point-to-point*
    and is particularly used in the context of wearable devices: you synchronize your
    fitness tracker with your mobile phone over Bluetooth by pairing the two devices.
    This model can also be used for the initial configuration of a Wi-Fi device. For
    example, a thermostat can create a point-to-point network called *Wi-Fi ad hoc
    mode*, where you can connect with your mobile phone and send to your thermostat
    the credentials and configuration of your home network.'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的网络拓扑结构发生在任何两个设备建立直接连接并开始相互交谈时。这种模型被称为**点对点**，特别用于可穿戴设备的环境：你通过配对两个设备，使用蓝牙将你的健身追踪器与你的手机同步。这种模型也可以用于Wi-Fi设备的初始配置。例如，恒温器可以创建一个名为**Wi-Fi
    ad hoc模式**的点对点网络，你可以在其中通过手机连接并发送你的家庭网络凭据和配置到恒温器。
- en: Star networks
  id: totrans-1167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 星型网络
- en: In a *star network* topology, shown in [figure 5.2](#ch05fig02), several nodes
    communicate with a single *central node* and might not be aware of other nodes
    in the network. This model is also often used as a *star of stars,* where each
    central node is in turn connected to another nearby central node.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 在星型网络拓扑结构中，如图5.2所示，多个节点与单个**中心节点**进行通信，可能不知道网络中的其他节点。这种模型也常被用作**星形星形**，其中每个中心节点又连接到另一个附近的中心节点。
- en: 'Figure 5.2\. Star topology: all nodes communicate with a single central node.
    Star of stars topology: nodes connect to intermediate nodes (gateways), which
    are in turn connected to a central node using a star topology.'
  id: totrans-1169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2. 星型拓扑：所有节点都与单个中心节点通信。星形星形拓扑：节点连接到中间节点（网关），这些中间节点又使用星型拓扑连接到中心节点。
- en: '![](05fig02_alt.jpg)'
  id: totrans-1170
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2](05fig02_alt.jpg)'
- en: In the IoT, cellular phone networks commonly use the star topology, where your
    phone (a node) connects to the nearest cell phone antenna (the central node).
    The star of stars topology can also be used for home automation systems, such
    as smart lighting systems. For example, light bulbs (nodes) can talk to several
    gateways using a wireless radio protocol such as ZigBee. Those gateways are in
    turn connected to your internet router (the central node) using Ethernet.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中，蜂窝电话网络通常采用星形拓扑结构，其中您的手机（一个节点）连接到最近的手机天线（中心节点）。星形星形拓扑也可以用于家庭自动化系统，例如智能照明系统。例如，灯泡（节点）可以使用无线无线电协议，如ZigBee，与多个网关进行通信。这些网关随后通过以太网连接到您的互联网路由器（中心节点）。
- en: Mesh networks
  id: totrans-1172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网状网络
- en: 'The last network topology that you might encounter in the IoT is also the most
    complex: *mesh networks*. In a mesh network, there are no central nodes because
    any node in the network is able to forward messages from one node to another.
    As an example, consider the devices shown in [figure 5.3](#ch05fig03). The Pi
    on the left is too far from the Intel Edison on the right to communicate with
    it directly. In a mesh network, the Pi can use the nearby devices as intermediate
    hops, called *relays,* to forward the message to its destination. In this particular
    case, the Pi can use the Arduino, which is connected to the Edison, to relay the
    message. In short, a mesh network means that you can extend the range of each
    device by adding more nodes. You can also make the network more robust against
    individual node failures. For instance, if the Arduino fails, the Pi could still
    communicate with the Edison by going through all the other devices.'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中您可能遇到的最后一个网络拓扑也是最复杂的：*网状网络*。在网状网络中，没有中心节点，因为网络中的任何节点都能够将消息从一个节点转发到另一个节点。例如，考虑[图5.3](#ch05fig03)中显示的设备。左侧的Pi与右侧的Intel
    Edison距离太远，无法直接通信。在网状网络中，Pi可以使用附近的设备作为中间跳转，称为*中继*，将消息转发到目的地。在这种情况下，Pi可以使用连接到Edison的Arduino来中继消息。简而言之，网状网络意味着您可以通过添加更多节点来扩展每个设备的范围。您还可以使网络对单个节点的故障更具鲁棒性。例如，如果Arduino失败，Pi仍然可以通过所有其他设备与Edison通信。
- en: 'Figure 5.3\. Mesh topology: messages are forwarded across several devices to
    reach their destination.'
  id: totrans-1174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 网状拓扑：消息通过多个设备转发以到达目的地。
- en: '![](05fig03_alt.jpg)'
  id: totrans-1175
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig03_alt.jpg)'
- en: 'The internet is the best and largest example of a mesh network: you don’t have
    a direct communication (point-to-point) with the server you want to talk to. Instead,
    messages travel across the internet by hopping from one router to another until
    they reach their final destination.'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网是网状网络的最佳和最大例子：您与想要与之通信的服务器之间没有直接的通信（点对点）。相反，消息通过互联网跳跃从一个路由器到另一个路由器，直到到达最终目的地。
- en: You’ll see that mesh networking plays an important role in the IoT. This is
    particularly useful where no fixed network infrastructure—for example, Ethernet
    or Wi-Fi—is available. Take the example of monitoring the pollution level in a
    remote forest. There’s no Wi-Fi infrastructure in place, so the best way to form
    a network is to drop nodes in the forest and have them communicate with each other
    by forming a mesh network. Only a few nodes need to be connected to the internet,
    using 3/4/5G or even a satellite link. The mesh topology is supported by a number
    of specialized IoT protocols that we’ll cover shortly, such as ZigBee and 6LoWPAN.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到网状网络在物联网中扮演着重要的角色。这在没有固定网络基础设施（例如，以太网或Wi-Fi）可用的情况下尤其有用。以监测偏远森林中的污染水平为例。那里没有Wi-Fi基础设施，因此形成网络的最佳方式是在森林中放置节点，并通过形成网状网络相互通信。只需要连接到互联网的节点数量很少，可以使用3/4/5G甚至卫星链路。网状拓扑由许多专门的物联网协议支持，我们将在稍后介绍，例如ZigBee和6LoWPAN。
- en: 5.1.2\. Network classification models
  id: totrans-1178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 网络分类模型
- en: 'Computer networking is a vast and complex topic where one can easily get lost.
    To make it easier to navigate the complexity of communication system, network
    classification models have been proposed to organize the variety of existing protocols
    in different layers, each having a specific purpose and knowing about only the
    one directly below it. After reading the brief introduction to networking models
    we provide in this section, you’ll have a decent understanding of where each protocol
    fits on the map and especially how all these protocols relate to each other. Once
    you understand the difference between Application-level protocols and those at
    lower levels (Network/Transport-level protocols), you’ll quickly realize why the
    Web of Things proposes an approach to the IoT that’s fundamentally different,
    yet not necessarily incompatible, and is complementary in many other cases. Let’s
    now look at the two most common models in use today: OSI (Open Systems Interconnection)
    and TCP/IP.'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机网络是一个庞大而复杂的话题，人们很容易在其中迷失方向。为了使导航通信系统的复杂性变得更容易，已经提出了网络分类模型来组织不同层中存在的各种协议，每一层都有其特定的目的，并且只知道其直接下一层的细节。在本节提供的网络模型简介阅读后，您将对该协议在地图上的位置有一个合理的理解，特别是所有这些协议之间是如何相互关联的。一旦您理解了应用层协议与较低层（网络/传输层协议）之间的区别，您将很快意识到为什么物联网（IoT）提出了一种与物联网根本不同，但并非必然不兼容的方法，并且在许多其他情况下是互补的。现在让我们来看看今天使用最广泛的两种模型：OSI（开放式系统互联）和
    TCP/IP。
- en: OSI and TCP/IP models
  id: totrans-1180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: OSI 和 TCP/IP 模型
- en: If you’re an IT professional, you’ve surely heard about the OSI model or the
    widespread alternative model known as the internet protocol suite (IPS) or TCP/IP
    model. The basic concept of these models is to define *layers*, which are essentially
    abstractions. Each layer builds on the next; a layer serves the layer above and
    is served by the layer below. This means that a protocol in a particular layer
    can only make assumptions as to what the layer directly below will offer. As a
    consequence, each layer focuses on a particular set of problems and abstracts
    this problem for the layers above.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 IT 专业人士，您肯定听说过 OSI 模型或广泛使用的替代模型，即互联网协议套件（IPS）或 TCP/IP 模型。这些模型的基本概念是定义 *层*，这本质上是一种抽象。每一层建立在下一层之上；一层服务于其上的一层，并由其下一层服务。这意味着特定层的协议只能对直接下一层将提供什么做出假设。因此，每一层都专注于特定的问题集，并为上层抽象这个问题。
- en: The OSI defines seven layers, and the IPS lists only four layers, as shown in
    [figure 5.4](#ch05fig04). We’ll focus on the IPS model here because it’s the model
    of the internet. Teaching in detail each layer of the IPS model is beyond the
    scope of this book,^([[1](#ch05fn01)]) so here we’ll only summarize what they
    are and what they do.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: OSI 定义了七层，而 IPS 只列出了四层，如图 5.4 所示。[figure 5.4](#ch05fig04)。在这里，我们将重点介绍 IPS 模型，因为它是互联网的模型。详细讲解
    IPS 模型的每一层超出了本书的范围^([[1](#ch05fn01)]），因此在这里我们只总结它们是什么以及它们的作用。
- en: ¹
  id: totrans-1183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Computer Networks* (5th Edition) by Andrew S. Tanenbaum (Pearson, 2010) is
    a fantastic book to help you better grasp the details of the core concepts of
    computer networking, including the layered models.'
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 《计算机网络》（第 5 版）由安德鲁·S·坦南鲍姆（Pearson，2010）著，是一本帮助您更好地掌握计算机网络核心概念细节的杰出书籍，包括分层模型。
- en: Figure 5.4\. The OSI model (left) compared with the Internet Protocol Suite
    (aka TCP/IP, right), along with examples of some of the most relevant protocols
    and protocol stacks for the IoT (center)
  id: totrans-1186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. OSI 模型（左侧）与互联网协议套件（又称 TCP/IP，右侧）的比较，以及一些与物联网（中心）最相关的协议和协议栈的示例
- en: '![](05fig04_alt.jpg)'
  id: totrans-1187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig04_alt.jpg)'
- en: The *Physical layer* (also called the Link layer) cares about the communication
    technologies for a single segment of the network as well as the interfaces required
    to transmit the information. The key actors here are the bits transformed to packets.
    This is where the Ethernet or Wi-Fi (IEEE 802.11) protocols live.
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*物理层*（也称为链路层）关注网络的单个段之间的通信技术以及传输信息所需的接口。这里的要角是比特转换为数据包。这就是以太网或 Wi-Fi（IEEE 802.11）协议所在的地方。'
- en: The *Network layer* (also called the Internet layer) looks into connecting hosts
    across independent networks. Common actors here are IP addresses; hence, this
    is where the Internet Protocol (IP) lives.
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络层*（也称为互联网层）关注连接独立网络中的主机。这里的常见角色是 IP 地址；因此，这就是互联网协议（IP）所在的地方。'
- en: The *Transport layer* handles the communication of information between two hosts.
    This is where the two well-known internet protocols TCP and UDP live.
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传输层* 处理两个主机之间的信息通信。这是两个著名的互联网协议TCP和UDP所在的地方。'
- en: The *Application layer* looks at data exchange between two applications. This
    is the layer most software developers are usually exposed to. Because this is
    where HTTP lives, web browsers or mobile applications use it to let us do all
    kinds of things, from managing our online calendars to reading emails to retrieving
    Wikipedia content.
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用层* 关注两个应用程序之间的数据交换。这是软件开发人员通常接触到的层。因为HTTP就生活在这里，所以网络浏览器或移动应用程序使用它来让我们做各种事情，从管理我们的在线日历到阅读电子邮件到检索维基百科内容。'
- en: As you’ll see later in the chapter, the Application layer is where the Web of
    Things architecture lives. Obviously, this means that the Web of Things can’t
    exist without the networking layers below the Application layer. In order to consume
    real-world data from applications on mobile phones and in browsers, we first need
    to somehow get this data from the lower layers of model. The good news here is
    that if you abstract the layers below the Application layer, it doesn’t matter
    which protocols or interfaces are used underneath.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章后面将看到的，应用层是物联网架构所在的地方。显然，这意味着没有应用层以下的网络层，物联网就无法存在。为了从手机和浏览器上的应用程序中消费真实世界的数据，我们首先需要从模型较低层以某种方式获取这些数据。这里的好消息是，如果你抽象出应用层以下的层，那么使用哪些协议或接口并不重要。
- en: When you combine the protocols of these different layers with each other, layer-by-layer
    you form a *protocol stack*. As you’ll see later on, many different protocol stacks
    exist; for example, Bluetooth or ZigBee, some of which are shown in [figure 5.4](#ch05fig04).
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这些不同层的协议组合在一起时，层与层相结合，形成了一个*协议栈*。正如你稍后将会看到的，存在许多不同的协议栈；例如，蓝牙或ZigBee，其中一些在[图
    5.4](#ch05fig04)中显示。
- en: 5.2\. Networking protocols for Things
  id: totrans-1194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 物联网的联网协议
- en: In [chapter 1](kindle_split_008.html#ch01), we defined the Internet of Things
    as “a system of physical objects that can be discovered, monitored, controlled,
    or interacted with by electronic devices that communicate over various networking
    interfaces and eventually can be connected to the wider internet.” But what does
    it mean for a Thing to be “connected to the internet?” It means that you can interact
    with it using the communication protocols of the Internet Protocol Stack shown
    in [figure 5.4](#ch05fig04).
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](kindle_split_008.html#ch01)中，我们将物联网定义为“一个由物理对象组成的系统，这些对象可以通过电子设备发现、监控、控制或与之交互，这些电子设备通过各种网络接口进行通信，最终可以连接到更广泛的互联网。”但事物“连接到互联网”意味着什么呢？这意味着你可以使用[图
    5.4](#ch05fig04)中显示的互联网协议栈的通信协议与之交互。
- en: More concretely, this means that the Thing should use the IP on layer 2 and
    TCP or UDP on layer 3\. If that’s the case, then the Thing “speaks” internet-ese!
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，这意味着事物应该使用第2层的IP和第3层的TCP或UDP。如果是这样，那么事物“说”的就是互联网语言！
- en: 5.2.1\. Spatial considerations
  id: totrans-1197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 空间考虑因素
- en: The last factor we consider when classifying networks is the distance between
    two nodes (range). Protocols can be classified according to how far or near nodes
    need to be from each other and also if they can be wired or if they must use radio
    signals. The various spatial scopes for IoT applications are shown in [table 5.1](#ch05table01).
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 在对网络进行分类时，我们考虑的最后因素是两个节点之间的距离（范围）。根据节点需要彼此多远或多近，以及它们是否可以有线连接或必须使用无线电信号，可以将协议进行分类。物联网应用的各个空间范围在[表
    5.1](#ch05table01)中显示。
- en: Table 5.1\. Spatial scope and range of various IoT networking protocols
  id: totrans-1199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1\. 各种物联网联网协议的空间范围和范围
- en: '| Spatial Scope | Typical Range | Examples |'
  id: totrans-1200
  prefs: []
  type: TYPE_TB
  zh: '| 空间范围 | 典型范围 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-1201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Near field (NFC) | < 10 cm | NFC Forum |'
  id: totrans-1202
  prefs: []
  type: TYPE_TB
  zh: '| 近场 (NFC) | < 10 cm | NFC 论坛 |'
- en: '| Personal area network (PAN) | 1 m–50 m | Bluetooth, ZigBee, Thread, IEEE
    802.4.15 |'
  id: totrans-1203
  prefs: []
  type: TYPE_TB
  zh: '| 个人区域网络 (PAN) | 1 m–50 m | 蓝牙，ZigBee，Thread，IEEE 802.4.15 |'
- en: '| Local area network (LAN) | 50 m–1 km | Wi-Fi, Ethernet |'
  id: totrans-1204
  prefs: []
  type: TYPE_TB
  zh: '| 局域网 (LAN) | 50 m–1 km | Wi-Fi, 以太网 |'
- en: '| Wide area network (WAN) | 1 km–50 km | SigFox, LoRa, 5G, 4G, GSM |'
  id: totrans-1205
  prefs: []
  type: TYPE_TB
  zh: '| 广域网 (WAN) | 1 km–50 km | SigFox，LoRa，5G，4G，GSM |'
- en: 'This well illustrates a harsh reality: the IoT isn’t running off one single
    network protocol and probably never will because of different needs in terms of
    ranges of different devices. Why don’t they all run on WAN protocols? Because
    the larger the distance, the more power you need, which is a no-go for battery-operated
    devices. As you’ll see later in this chapter, some protocols allow low-power devices
    to transmit data over long distances, but the tradeoff is that you can transmit
    only very small amounts of data, also referred to as a low bandwidth.'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地说明了残酷的现实：物联网不是运行在单一的网络协议上，可能永远不会因为不同设备在范围方面的不同需求。为什么它们不都运行在广域网协议上呢？因为距离越远，你需要更多的电力，这对电池供电的设备来说是不可能的。正如你将在本章后面看到的那样，一些协议允许低功耗设备在长距离传输数据，但代价是你只能传输非常少量的数据，也称为低带宽。
- en: 5.2.2\. Internet protocols and the IoT
  id: totrans-1207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 互联网协议与物联网
- en: To help you understand the difference between IoT protocols, let’s review the
    basics of the IP, TCP, and UDP protocols. If you’re familiar with those, you’re
    welcome to skip this section.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您了解物联网协议之间的差异，让我们回顾一下 IP、TCP 和 UDP 协议的基本知识。如果您熟悉这些，欢迎您跳过这一节。
- en: 'Internet Protocol: IPv4 and IPv6'
  id: totrans-1209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 互联网协议：IPv4 和 IPv6
- en: 'It’s not accidental that the Internet Protocol shares the same name as what
    we commonly call the internet: this protocol is used for any byte of data that’s
    sent over the internet. IP provides any node of a network with a unique IP address
    and is responsible for routing packets of information between any nodes using
    their IP addresses. When you type a URL in your browser, IP will find the address
    of the site you want to visit and retrieve the page across many subnetworks—for
    example, your local network, the network of your country, and so on.'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议与我们通常所说的互联网名称相同并非偶然：这个协议用于发送到互联网上的任何字节数据。IP 为网络中的任何节点提供唯一的 IP 地址，并负责使用它们的
    IP 地址在任意节点之间路由信息包。当你在浏览器中输入 URL 时，IP 会找到你想要访问的网站的地址，并在许多子网络中检索页面——例如，你的本地网络、你国家的网络等等。
- en: Currently, IP version 4 (IPv4) is the most widely used version of the protocol.
    IPv4 addresses have a size of 32 bits (see [figure 5.5](#ch05fig05)), which means
    there are 2^(32) unique IP addresses, or approximately 4.3 billion. When IPv4
    was invented back in 1974, this seemed more than enough to cater to all the machines
    that would be connected to the internet. Back then no one imagined how popular
    the internet would be 40 years later. Today, Cisco estimates that there are more
    than 15 billion things connected to the internet.^([[2](#ch05fn02)]) In other
    words, we’ve been running short of IPv4 address for quite some time.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，IP 版本 4 (IPv4) 是最广泛使用的协议版本。IPv4 地址的大小为 32 位（见[图 5.5](#ch05fig05)），这意味着有 2^(32)
    个唯一的 IP 地址，或大约 43 亿。当 IPv4 在 1974 年被发明时，这似乎已经足够满足所有将要连接到互联网的机器。当时没有人想象到 40 年后互联网会如此流行。今天，思科估计有超过
    150 亿个物品连接到互联网。[2](#ch05fn02)换句话说，我们已经很长时间以来一直在缺少 IPv4 地址。
- en: ²
  id: totrans-1212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [http://blogs.cisco.com/news/cisco-connections-counter](http://blogs.cisco.com/news/cisco-connections-counter).
  id: totrans-1214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 见[http://blogs.cisco.com/news/cisco-connections-counter](http://blogs.cisco.com/news/cisco-connections-counter)。
- en: Figure 5.5\. Comparing the size and addressing space in IPv4 and IPv6
  id: totrans-1215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 比较 IPv4 和 IPv6 的大小和寻址空间
- en: '![](05fig05.jpg)'
  id: totrans-1216
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5](05fig05.jpg)'
- en: 'With the Internet of Things, this shortage has become a major hurdle. The first
    countermeasure was the idea of *Network Address Translation (NAT)*. NAT enables
    several hosts in a local network to share a single public IP address. Most routers
    and firewalls can perform NAT, and it has become a cornerstone of today’s Internet
    of Things. But NAT is merely a patch because it adds lots of complexity to the
    network. This led to the design of a longer-term solution: IPv6.'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 随着物联网的发展，这种短缺已成为一个主要障碍。第一个对策是*网络地址转换 (NAT)* 的想法。NAT 允许本地网络中的多个主机共享一个公共 IP 地址。大多数路由器和防火墙都可以执行
    NAT，并且它已成为今天物联网的基石。但 NAT 只是一个补丁，因为它给网络增加了许多复杂性。这导致了设计一个更长期的解决方案：IPv6。
- en: IPv6 is based on 128-bit addresses represented as a series of eight groups of
    four hexadecimal (base 16) characters separated by colons (see [figure 5.5](#ch05fig05)),
    which allows 2^(128) unique addresses—that is, 340,282,366,920,938,463,463,374,607,431,768,211,456
    different IPv6 addresses, in case you didn’t do the mental math. Will that cover
    IoT’s hunger for IP addresses? To put things in perspective, this number means
    that we could assign an IPv6 to every single atom on earth, and we’d still have
    enough IP addresses for every atom on another 100 earths!
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 基于表示为一系列由冒号分隔的四组十六进制（基数为 16）字符的 128 位地址（参见[图 5.5](#ch05fig05)），这允许 2^(128)
    个唯一的地址——即 340,282,366,920,938,463,463,374,607,431,768,211,456 个不同的 IPv6 地址，以防你没有做心理计算。这能满足物联网对
    IP 地址的需求吗？为了更清楚地说明这一点，这个数字意味着我们可以为地球上的每一个原子分配一个 IPv6 地址，并且我们仍然有足够的 IP 地址为另一个 100
    个地球上的每一个原子分配！
- en: IPv6 will be instrumental to IoT’s success at scale. But upgrading the whole
    internet to IPv6 is no mean feat because this requires upgrading pretty much anything
    that’s connected to the internet. From the operating system of your laptop or
    mobile phone to the firmware of any router or firewall connected to the internet,
    all will have to support IPv6.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 将对物联网的规模化成功起到关键作用。但将整个互联网升级到 IPv6 并非易事，因为这几乎需要升级所有连接到互联网的设备。从你的笔记本电脑或手机的操作系统到任何连接到互联网的路由器或防火墙的固件，所有这些都将必须支持
    IPv6。
- en: Your Raspberry Pi isn’t IPv6-enabled out of the box, but adding IPv6 support
    is quite straightforward, as shown in the following listing. Simply connect to
    your Pi via SSH and run this code.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 你的树莓派出厂时并没有启用 IPv6，但添加 IPv6 支持相当简单，如下面的列表所示。只需通过 SSH 连接到你的 Pi 并运行此代码。
- en: Listing 5.1\. Enabling IPv6 support on your Raspberry Pi
  id: totrans-1221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 在你的树莓派上启用 IPv6 支持
- en: '![](117fig01_alt.jpg)'
  id: totrans-1222
  prefs: []
  type: TYPE_IMG
  zh: '![117fig01_alt.jpg](117fig01_alt.jpg)'
- en: If this is your first encounter with IPv6, then welcome to the future!
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次接触 IPv6，那么欢迎来到未来！
- en: Transport protocols of the internet
  id: totrans-1224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 互联网的传输协议
- en: As you’ve just seen, the Network layer is only responsible for how packets are
    routed between two hosts on the Internet, not how to deliver data to applications,
    which is the responsibility of the layer above—the Transport layer. This layer
    introduces the notion of source and destination ports that identify applications.
    For instance, it gives one port to a web server and a different one to a mail
    server. You can think of a port as a mailbox that an application such as a web
    server can rent to receive packets. The combination of source and destination
    IP addresses along with a port number forms what’s commonly called a network socket
    or just a socket.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，网络层只负责在互联网上的两个主机之间路由数据包，而不是如何将数据交付给应用程序，这是上层传输层的责任。这一层引入了源端口和目的端口的观念，用于标识应用程序。例如，它给一个网页服务器分配一个端口，给一个邮件服务器分配另一个端口。你可以将端口想象成一个应用程序（如网页服务器）可以租用的邮箱，以接收数据包。源和目的
    IP 地址以及端口号的组合形成了通常所说的网络套接字或简称套接字。
- en: 'On the internet, there are two protocols at this layer: the Transmission Control
    Protocol and the User Datagram Protocol. The best way to learn about TCP and UDP
    and their differences is by starting with a joke; see [figure 5.6](#ch05fig06).'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，这一层有两个协议：传输控制协议（TCP）和用户数据报协议（UDP）。了解 TCP 和 UDP 以及它们之间的区别的最佳方式是从一个笑话开始；参见[图
    5.6](#ch05fig06)。
- en: 'Figure 5.6\. A good UDP/TCP joke! [Source: [http://pcp-comics.com/](http://pcp-comics.com/),
    used with permission]'
  id: totrans-1227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6\. 一个好的 UDP/TCP 笑话！[来源：[http://pcp-comics.com/](http://pcp-comics.com/)，经许可使用]
- en: '![](05fig06_alt.jpg)'
  id: totrans-1228
  prefs: []
  type: TYPE_IMG
  zh: '![05fig06_alt.jpg](05fig06_alt.jpg)'
- en: 'Joking aside, this emphasizes the fundamental difference between UDP and TCP:
    UDP does not offer reliability and sequenced delivery, which is why you might
    never get the joke, whereas TCP does. On the downside, TCP is more complex and
    hence heavier, and it requires synchronization and acknowledgment messages to
    guarantee data delivery, as we’ll detail in a moment.'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑，这强调了 UDP 和 TCP 之间的基本区别：UDP 不提供可靠性和顺序交付，这就是为什么你可能永远听不到笑话，而 TCP 则提供。缺点是，TCP
    更复杂，因此更重，它需要同步和确认消息来保证数据交付，我们将在下面详细说明。
- en: Ideally, we should stop here and ignore the details. But some IoT protocols
    are based on TCP and others on UDP, so to understand the difference between IoT
    protocols—and the joke—we’ll now dive into a brief introduction to these two protocols.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该在这里停下来，忽略细节。但一些物联网协议基于 TCP，而另一些基于 UDP，因此为了了解物联网协议之间的区别——以及笑话——我们现在将简要介绍这两种协议。
- en: User Datagram Protocol
  id: totrans-1231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用户数据报协议
- en: We’ll start with UDP, which is simpler to understand. UDP is a *connectionless
    protocol*, which means that you don’t need to establish a connection (a handshake)
    between the sender and recipient of a message. You send the message and cross
    your fingers hoping it will arrive, because delivery is not guaranteed. It usually
    will be delivered, but sometimes it won’t, hence the joke!
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从UDP开始，它更容易理解。UDP是一种**无连接协议**，这意味着你不需要在消息的发送者和接收者之间建立连接（握手）。你发送消息，然后祈祷它能够到达，因为交付是不保证的。它通常会被送达，但有时不会，这就是那个笑话的由来！
- en: Let’s see a concrete example. A Thing wants to send a temperature update to
    a server using UDP. It needs to send a UDP message with the temperature value
    as content, along with the IP address and port of the receiver. The Thing also
    provides its own IP address and port in case the receiver wants to reply. This
    is just like when you send a letter with economy postage and hope it arrives.
    It’s good enough to send items of little value. This model is called *unicast*,
    because the message is sent to a unique receiver by providing the address. Because
    UDP is connectionless, it can also be used to *multicast* messages. This means
    it can also be used to send a message to several receivers within a range of IP
    addresses—that is, a subnet.^([[3](#ch05fn03)]) Multicast relies on routers to
    send the messages to multiple receivers, so it works well in local networks but
    not so much across the global internet because multicast messages are generally
    blocked by routers and gateways.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具体的例子。一个“事物”想使用UDP向服务器发送温度更新。它需要发送一个包含温度值的UDP消息，以及接收者的IP地址和端口号。如果接收者想要回复，“事物”也会提供自己的IP地址和端口号。这就像你用经济邮资寄一封信，希望它能够到达。对于价值不大的物品来说，这已经足够好了。这种模型被称为**单播**，因为消息是通过提供地址发送给唯一接收者的。由于UDP是无连接的，它也可以用来**多播**消息。这意味着它也可以用来向IP地址范围内的多个接收者发送消息——即子网。[3](#ch05fn03)
    多播依赖于路由器将消息发送给多个接收者，因此在本地网络中效果很好，但在全球互联网上效果不佳，因为多播消息通常会被路由器和网关阻塞。
- en: ³
  id: totrans-1234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Subnetwork](https://en.wikipedia.org/wiki/Subnetwork)'
  id: totrans-1236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Subnetwork](https://zh.wikipedia.org/wiki/Subnetwork)'
- en: Transmission Control Protocol
  id: totrans-1237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传输控制协议
- en: The simplicity of UDP comes at the cost of some features that are important
    for some applications, such as guaranteed delivery of messages. To send a valuable
    item to someone across the globe, economy postage won’t work—you’ll want to use
    a trusted service, which will not only require a lot of paperwork but also flatten
    your wallet. This is the price you pay for guaranteed delivery.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: UDP的简单性是以牺牲一些对某些应用程序很重要的功能为代价的，例如消息的保证交付。要将贵重物品发送到全球的某个人，经济邮资是不够的——你需要使用一个可信赖的服务，这不仅需要大量的文件工作，还会让你的钱包变薄。这就是保证交付所付出的代价。
- en: TCP is the FedEx of the internet. It also deals with sockets but ensures the
    communication is reliable and ordered by adding acknowledgement messages, sequence
    numbers, retransmission of missed packets, and also congestion and flow control,
    which we’ll explain shortly.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是互联网上的联邦快递。它也处理套接字，但通过添加确认消息、序列号、丢失数据包的重传以及拥塞和流量控制来确保通信的可靠性和顺序，我们将在稍后解释这些。
- en: '[Figure 5.7](#ch05fig07) gives you a simplified overview of a TCP connection.
    Imagine a Thing wants to send a super-important message to an application server
    on the internet; for example, your smoke detector wants to tell you that your
    house is on fire. Unlike UDP, TCP is a *connection-oriented protocol*, and the
    first thing it does is establish a connection to the server. Also note the numerous
    ACK messages used, which are confirmations that a message was received. Once the
    connection is established, the client can send messages cut into chunks (called
    *TCP packets*). The size of these packets will vary depending on how congested
    the network is, which is known as the *control flow* mechanism of TCP. Sequence
    numbers are also added to packets so that when the sender doesn’t receive an ACK
    for a given packet, it will send it again, ensuring that the entire message has
    been received. Finally, the Thing terminates the connection.'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.7](#ch05fig07) 给出了TCP连接的简化概述。想象一个“物”想要向互联网上的一个应用服务器发送一条超级重要的消息；例如，你的烟雾探测器想要告诉你你的房子着火了。与UDP不同，TCP是一种**面向连接的协议**，它首先做的事情是建立与服务器的连接。还要注意使用的众多ACK消息，这些消息是确认消息已被接收的确认。一旦建立连接，客户端可以发送分割成块的消息（称为**TCP数据包**）。这些数据包的大小将根据网络的拥塞程度而变化，这被称为TCP的**控制流**机制。数据包还会添加序列号，以便当发送者没有收到特定数据包的ACK时，它会再次发送该数据包，确保整个消息已被接收。最后，“物”终止连接。'
- en: 'Figure 5.7\. TCP communication: a client establishes a connection (SYN) to
    a server and starts pushing data to it. Once the data has been reliably transmitted,
    the client closes the connection to the server (FIN).'
  id: totrans-1241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7\. TCP通信：客户端与服务器建立连接（SYN）并开始向其推送数据。一旦数据可靠地传输完毕，客户端将关闭与服务器的连接（FIN）。
- en: '![](05fig07.jpg)'
  id: totrans-1242
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7](05fig07.jpg)'
- en: TCP vs. UDP for the IoT
  id: totrans-1243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网中的TCP与UDP对比
- en: 'As you’ve seen, TCP is a necessity when delivery must be guaranteed. Thus,
    the majority of the traffic on the internet relies on TCP. But this reliability
    comes at a price: the protocol is heavier because it requires many more messages
    to be sent, and the packets are also significantly larger because they contain
    more information to guarantee reliability and ordering. This means additional
    overhead on both the client and the server sides and delays due to messages being
    retransmitted, which makes TCP generally slower than UDP. For this reason, UDP
    fits better with time-sensitive applications where dropped packets are preferable
    to delayed packets. For example, UDP is commonly used for Voice over IP applications
    or to stream music or video over the internet.'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当必须保证交付时，TCP是必不可少的。因此，互联网上的大部分流量都依赖于TCP。但这种可靠性是有代价的：由于需要发送更多的消息，并且数据包也显著更大，因为它们包含更多保证可靠性和顺序的信息，所以协议更重。这意味着客户端和服务器两端的额外开销以及由于消息重传而产生的延迟，这使得TCP通常比UDP慢。因此，UDP更适合对时间敏感的应用，在这些应用中，丢失的数据包比延迟的数据包更可取。例如，UDP常用于VoIP应用或通过互联网流音乐或视频。
- en: In the IoT, both protocols are interesting and there’s no clear winner. Some
    widespread application protocols such as HTTP or MQTT (Message Queue Telemetry
    Transport; see [section 5.3.2](#ch05lev2sec9)) use TCP, whereas others such as
    CoAP (Constrained Application Protocol; see [section 5.3.3](#ch05lev2sec10)) are
    based on UDP.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中，这两种协议都很吸引人，没有明显的赢家。一些广泛使用的应用协议，如HTTP或MQTT（消息队列遥测传输；见[5.3.2节](#ch05lev2sec9)），使用TCP，而其他如CoAP（约束应用协议；见[5.3.3节](#ch05lev2sec10)）则基于UDP。
- en: Being lighter and faster, UDP seems more appropriate for embedded devices with
    limited resources. But some IoT applications might need guaranteed delivery; therefore,
    some application protocols on top of UDP are trying to reproduce some of the guarantees
    TCP provides. More important, unlike with TCP, routers often reject UDP traffic
    coming from the internet to the local network, unless the message was requested
    within the last few seconds. This means that if you try to control your connected
    thermostat with your mobile phone across the internet, your thermostat might never
    get the joke. Ahem, we mean the message.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UDP更轻量级且速度更快，它似乎更适合资源有限的嵌入式设备。但某些物联网应用可能需要保证交付；因此，一些基于UDP的应用协议正在尝试重现TCP提供的一些保证。更重要的是，与TCP不同，路由器通常拒绝来自互联网到本地网络的UDP流量，除非在过去的几秒钟内请求了消息。这意味着如果你尝试通过互联网用你的手机控制你的智能恒温器，你的恒温器可能永远收不到这个笑话。嗯，我们是说这个消息。
- en: This will significantly change when IPv6 dominates the internet because all
    Things will be able to have an IP address and NAT won’t be needed anymore. But
    until then, TCP remains significantly easier to deploy in large heterogeneous
    networks, hence the battle for the transport protocol of the IoT goes on.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 当IPv6主导互联网时，这将发生显著变化，因为所有事物都将能够拥有一个IP地址，NAT将不再需要。但在此之前，TCP在大型异构网络中部署仍然更加容易，因此物联网传输协议的竞争仍在继续。
- en: 5.2.3\. IoT personal area networks
  id: totrans-1248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3. 物联网个人区域网络
- en: Personal area network (PAN) protocols are used to communicate with Things located
    nearby, from wearable fitness trackers to a smart thermostat in your home to the
    connected garage door in your building. PAN protocols are hugely popular in the
    IoT because they offer an attractive tradeoff between communication range and
    power consumption. Let’s start by describing and comparing the most common PAN
    protocols.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 个人区域网络（PAN）协议用于与附近的事物进行通信，从可穿戴健身追踪器到你家的智能恒温器，再到你建筑中的联网车库门。PAN协议在物联网中非常受欢迎，因为它们在通信范围和功耗之间提供了一个有吸引力的权衡。让我们首先描述并比较最常用的PAN协议。
- en: IEEE 802.15.4 and 6LoWPAN
  id: totrans-1250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: IEEE 802.15.4和6LoWPAN
- en: As you make new friends in the IoT community, you’ll certainly hear them talk
    about “15.4.” What they really mean is IEEE 802.15.4, which is a low-power, low-cost,
    and low-rate wireless protocol for communication between devices close to each
    other. These characteristics made it an excellent candidate for the IoT, especially
    when considering home automation devices with limited resources that are used
    indoors. As a consequence, 15.4 is the basis of many IoT PAN protocols.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在物联网社区结识新朋友时，你肯定会听到他们谈论“15.4”。他们真正指的是IEEE 802.15.4，这是一种低功耗、低成本、低速率的无线通信协议，用于相邻设备之间的通信。这些特性使其成为物联网的绝佳候选者，尤其是在考虑室内使用的资源有限的智能家居设备时。因此，15.4成为了许多物联网个人区域网络协议的基础。
- en: One drawback of the IEEE 802.15.4 protocol is that it can’t communicate directly
    with other devices via the internet—that is, via TCP/IP or UDP. This limitation
    has been addressed by the creation of 6LoWPAN, which allows bridging the two worlds.
    6LoWPAN stands for “IPv6 over low-power wireless personal area networks.” It gives
    you the ability to send and receive IPv6 packets over IEEE 802.15.4-based networks.
    It not only uses IPv6 addresses but also optimizes the size of IPv6 headers to
    be used on devices with constrained resources.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 802.15.4协议的一个缺点是它不能通过互联网直接与其他设备通信——也就是说，通过TCP/IP或UDP。这一限制通过创建6LoWPAN得到了解决，它允许连接两个世界。6LoWPAN代表“IPv6
    over low-power wireless personal area networks”。它使你能够在基于IEEE 802.15.4的网络中发送和接收IPv6数据包。它不仅使用IPv6地址，还优化了用于资源受限设备的IPv6头部大小。
- en: ZigBee
  id: totrans-1253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ZigBee
- en: 'ZigBee has become one of the most popular protocols based on IEEE 802.15.4\.
    ZigBee has two interesting characteristics: first, it supports mesh networking.
    Second, ZigBee is much more than a Physical layer protocol. As shown in [figure
    5.4](#ch05fig04), it spans from the Physical layer to the Application layer. Unfortunately,
    ZigBee is a proprietary standard controlled by a group of companies and requires
    a paid membership in order to build and ship products that use this protocol.
    Although some industrial and hobbyists platforms (for example, Arduino) do support
    ZigBee, your Pi does not directly support it. Adding ZigBee support to your Pi
    is possible using a special shield^([[4](#ch05fn04)]) or by adding a ZigBee dongle,
    such as Telegesis USB, to your Pi.'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: ZigBee已成为基于IEEE 802.15.4的最受欢迎的协议之一。ZigBee有两个有趣的特点：首先，它支持网状网络。其次，ZigBee不仅仅是一个物理层协议。如图5.4所示，它从物理层到应用层。不幸的是，ZigBee是一个由一组公司控制的专有标准，需要付费会员资格才能构建和运输使用此协议的产品。尽管一些工业和爱好者平台（例如Arduino）支持ZigBee，但你的Pi并不直接支持它。通过使用特殊的屏蔽板^([[4](#ch05fn04)])或将Telegesis
    USB等ZigBee适配器添加到你的Pi上，可以为你的Pi添加ZigBee支持。
- en: ⁴
  id: totrans-1255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, [http://www.cooking-hacks.com/documentation/tutorials/raspberry-pi-xbee](http://www.cooking-hacks.com/documentation/tutorials/raspberry-pi-xbee).
  id: totrans-1257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，[http://www.cooking-hacks.com/documentation/tutorials/raspberry-pi-xbee](http://www.cooking-hacks.com/documentation/tutorials/raspberry-pi-xbee)。
- en: Thread
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Thread
- en: Thread^([[5](#ch05fn05)]) is one of the most recent IoT networking protocols.
    Like ZigBee, Thread is based on IEEE 802.15.4 and supports mesh networks. The
    difference is that Thread reuses open protocols where possible and implements
    IP via 6LoWPAN so it can directly communicate with devices on the internet. Furthermore,
    at the Transport layer it uses UDP. Unlike ZigBee or Bluetooth, Thread doesn’t
    provide an explicit Application layer and supports the various internet Application
    layer protocols (web standards, anyone?).
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: Thread^([[5](#ch05fn05)])是最近出现的物联网网络协议之一。像ZigBee一样，Thread基于IEEE 802.15.4并支持网状网络。不同之处在于Thread尽可能重用开放协议，并通过6LoWPAN实现IP，以便可以直接与互联网上的设备通信。此外，在传输层它使用UDP。与ZigBee或蓝牙不同，Thread不提供显式的应用层，并支持各种互联网应用层协议（比如网络标准？）。
- en: ⁵
  id: totrans-1260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-1261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Official site: [http://threadgroup.org](http://threadgroup.org)'
  id: totrans-1262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 官方网站：[http://threadgroup.org](http://threadgroup.org)
- en: Thread allows creating large mesh networks with 250–300 devices that can be
    deployed in a house or building. The latency, while not real-time, is fairly low,
    with less than 100 milliseconds for typical interactions. It’s also power-efficient
    and allows battery-operated devices running Thread to last for several years.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: Thread允许创建由250-300个设备组成的大型网状网络，这些设备可以部署在房屋或建筑物中。延迟虽然不是实时的，但相当低，典型交互的延迟小于100毫秒。它还节能，并允许运行Thread的电池供电设备使用数年。
- en: Although a paid membership is needed to create and sell products that use Thread,
    the protocol is built on open standards, which makes it easier to integrate than
    other protocols. Adding Thread support to your Pi is not trivial, mainly because
    the Thread protocol specification is fairly new. Once the protocol is adopted,
    you’ll simply need to add an IEEE 802.15.4 or ZigBee dongle to your device because
    the Thread protocol requires only a software (firmware) update of ZigBee controllers
    to work.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然需要付费会员资格才能创建和销售使用Thread的产品，但该协议建立在开放标准之上，这使得它比其他协议更容易集成。将Thread支持添加到您的Pi上并不简单，主要是因为Thread协议规范相对较新。一旦采用该协议，您只需将IEEE
    802.15.4或ZigBee适配器添加到您的设备即可，因为Thread协议只需要对ZigBee控制器进行软件（固件）更新即可工作。
- en: Bluetooth
  id: totrans-1265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 蓝牙
- en: 'Bluetooth is another interesting IoT protocol and, unlike the other PAN protocols
    we’ve examined so far, it isn’t based on the 802.15.4\. What makes Bluetooth so
    appealing is its popularity: pretty much any mobile phone (and many other devices)
    supports Bluetooth out of the box. This makes Bluetooth the ideal candidate for
    wearables because most of these IoT devices use mobile phones as a gateway to
    other devices and to the web.'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙是另一个有趣的物联网协议，并且与迄今为止我们检查的其他个人区域网络（PAN）协议不同，它不是基于802.15.4的。使蓝牙如此吸引人的是它的普及性：几乎任何手机（以及许多其他设备）都支持蓝牙。这使得蓝牙成为可穿戴设备的理想选择，因为大多数这些物联网设备使用手机作为通向其他设备和网络的网关。
- en: Bluetooth is managed by a nonprofit consortium of several technology partners
    and therefore requires a membership to build certified Bluetooth hardware and
    software stacks. But many of the standards and documentation are freely accessible.^([[6](#ch05fn06)])
    Similarly to ZigBee, the Bluetooth protocol stack also spans several layers from
    the Physical to the Application layer (see [figure 5.4](#ch05fig04)), which we’ll
    discuss in more detail in [section 5.3](#ch05lev1sec3).
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙由一个由多个技术合作伙伴组成的非营利联盟管理，因此需要会员资格才能构建经过认证的蓝牙硬件和软件堆栈。但许多标准和文档是免费可获取的.^([[6](#ch05fn06)])
    类似于ZigBee，蓝牙协议栈也跨越从物理层到应用层的多个层次（参见[图5.4](#ch05fig04)），我们将在[5.3节](#ch05lev1sec3)中更详细地讨论。
- en: ⁶
  id: totrans-1268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-1269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://bluetooth.com](http://bluetooth.com)'
  id: totrans-1270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://bluetooth.com](http://bluetooth.com)'
- en: Since it was first introduced as a protocol for connecting wireless headsets
    to your mobile phone, it has evolved significantly to support many other devices.
    Bluetooth 4.0, also known as Bluetooth Smart or Bluetooth Low Energy (BLE), has
    positioned Bluetooth as an excellent candidate for many IoT applications. BLE
    focuses on lowering energy consumption, which makes it ideal for battery-powered
    devices.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它首次作为连接无线耳机到手机的协议被引入以来，蓝牙已经显著发展，以支持许多其他设备。蓝牙4.0，也称为蓝牙智能或蓝牙低功耗（BLE），将蓝牙定位为许多物联网应用的优秀候选者。BLE专注于降低能耗，这使得它非常适合电池供电的设备。
- en: At the time of writing, the Bluetooth standard doesn’t include support for mesh
    networking, although many researchers have shown how it could be done. Nevertheless,
    the Bluetooth consortium announced that it’s working on adding mesh support to
    the standard,^([[7](#ch05fn07)]) making it likely that Bluetooth-based mesh networks
    will appear in the near future.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，蓝牙标准尚未包括对网状网络的支持，尽管许多研究人员已经展示了如何实现。尽管如此，蓝牙联盟宣布正在努力将网状网络支持添加到标准中，[7](#ch05fn07)]，这使得基于蓝牙的网状网络可能在不久的将来出现。
- en: ⁷
  id: totrans-1273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-1274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Read more: [http://blog.bluetooth.com/range-limitation-what-range-limitation-introducing-mesh-networks/](http://blog.bluetooth.com/range-limitation-what-range-limitation-introducing-mesh-networks/).'
  id: totrans-1275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 阅读更多：[http://blog.bluetooth.com/range-limitation-what-range-limitation-introducing-mesh-networks/](http://blog.bluetooth.com/range-limitation-what-range-limitation-introducing-mesh-networks/)。
- en: A number of devices come with out-of-the-box Bluetooth connectivity. For example,
    the Intel Edison we talked about in [chapter 4](kindle_split_011.html#ch04) offers
    both Wi-Fi and Bluetooth 4.0 connectivity. The Pi 3 also comes with Bluetooth
    4.0 BLE support; for other versions of the Pi you can add BLE support via USB
    dongles.^([[8](#ch05fn08)]) The following listing shows how to scan for Bluetooth
    devices from your Pi.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设备都自带即插即用的蓝牙连接功能。例如，我们在[第 4 章](kindle_split_011.html#ch04)中提到的英特尔 Edison 提供了
    Wi-Fi 和蓝牙 4.0 连接功能。Pi 3 也支持蓝牙 4.0 BLE；对于 Pi 的其他版本，您可以通过 USB 外置网卡添加 BLE 支持。[8](#ch05fn08)
    下面的列表显示了如何从您的 Pi 上扫描蓝牙设备。
- en: ⁸
  id: totrans-1277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-1278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.raspberrypi.org/learning/robo-butler/bluetooth-setup/](http://www.raspberrypi.org/learning/robo-butler/bluetooth-setup/)'
  id: totrans-1279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.raspberrypi.org/learning/robo-butler/bluetooth-setup/](http://www.raspberrypi.org/learning/robo-butler/bluetooth-setup/)'
- en: 'Listing 5.2\. Testing Bluetooth 4.0: BLE on a Raspberry Pi'
  id: totrans-1280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 在 Raspberry Pi 上测试蓝牙 4.0：BLE
- en: '![](122fig01_alt.jpg)'
  id: totrans-1281
  prefs: []
  type: TYPE_IMG
  zh: '![122fig01_alt.jpg](122fig01_alt.jpg)'
- en: Wi-Fi and low-power Wi-Fi
  id: totrans-1282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Wi-Fi 和低功耗 Wi-Fi
- en: Wi-Fi, technically called IEEE 802.11, is the first protocol that comes to mind
    when talking about wireless connectivity. Because of its ubiquity, Wi-Fi seems
    like the perfect match for the Physical layer of the IoT, and that’s why an increasing
    number of consumer electronics such as TV, microwaves, music players, and many
    more, support Wi-Fi.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi，技术上称为 IEEE 802.11，是谈论无线连接时首先想到的协议。由于其普遍性，Wi-Fi 似乎与物联网的物理层完美匹配，这就是为什么越来越多的消费电子产品，如电视、微波炉、音乐播放器等，都支持
    Wi-Fi。
- en: 'But the Wi-Fi protocols (802.11a–n) are limited for some IoT applications.
    The biggest problem is energy usage. The second problem of Wi-Fi is its range.
    In a Wi-Fi network, all nodes must be within range of the access point: there’s
    no mesh networking with Wi-Fi. Yes, the internet is the greatest example of a
    mesh network, but at the level of routers, not at the level of single Wi-Fi nodes
    acting as clients. These problems are being worked on, and a new Wi-Fi standard
    optimized for the IoT (IEEE 802.11ah^([[9](#ch05fn09)])) is in the works and will
    have a better range and much lower power consumption.'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Wi-Fi 协议（802.11a–n）对于某些物联网应用来说有限制。最大的问题是能耗。Wi-Fi 的第二个问题是其范围。在 Wi-Fi 网络中，所有节点都必须在接入点的范围内：Wi-Fi
    没有网状网络。是的，互联网是网状网络的最佳例子，但这是在路由器层面，而不是单个 Wi-Fi 节点作为客户端的层面。这些问题正在得到解决，一个新的针对物联网优化的
    Wi-Fi 标准（IEEE 802.11ah^([[9](#ch05fn09)]))正在开发中，它将具有更好的范围和更低的功耗。
- en: ⁹
  id: totrans-1285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-1286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/IEEE_802.11ah](http://en.wikipedia.org/wiki/IEEE_802.11ah)'
  id: totrans-1287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/IEEE_802.11ah](http://en.wikipedia.org/wiki/IEEE_802.11ah)'
- en: Since the Pi 3, Wi-Fi is supported onboard. For other Pis, adding Wi-Fi is easy
    because the Raspbian Linux OS supports most Wi-Fi USB dongles out of the box.^([[10](#ch05fn10)])
    We explained how to set up Wi-Fi on your Pi in [chapter 4](kindle_split_011.html#ch04),
    [section 4.2.3](kindle_split_011.html#ch04lev2sec6).
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Pi 3 以来，Wi-Fi 已集成到板上。对于其他 Pi 版本，添加 Wi-Fi 很容易，因为 Raspbian Linux 操作系统默认支持大多数
    Wi-Fi USB 外置网卡。[10](#ch05fn10) 我们在[第 4 章](kindle_split_011.html#ch04)、[4.2.3 节](kindle_split_011.html#ch04lev2sec6)中解释了如何在
    Pi 上设置 Wi-Fi。
- en: ^(10)
  id: totrans-1289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([10](#ch05fn10))
- en: ''
  id: totrans-1290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'More details: [http://elinux.org/RPi_USB_Wi-Fi_Adapters](http://elinux.org/RPi_USB_Wi-Fi_Adapters).'
  id: totrans-1291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更多详情：[http://elinux.org/RPi_USB_Wi-Fi_Adapters](http://elinux.org/RPi_USB_Wi-Fi_Adapters)。
- en: EnOcean
  id: totrans-1292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: EnOcean
- en: Another lesser-known protocol worth mentioning here is EnOcean,^([[11](#ch05fn11)])
    which is an energy-harvesting wireless technology mainly used in buildings and
    other industrial solutions. Although you may have never heard about it, EnOcean
    is particularly relevant for the IoT because it solves the energy problem elegantly.
    The technology allows devices to gather the energy they need from their environments.
    As an example, the kinetic energy produced when you flick a light switch is captured
    by the switch and used to transmit a message. Other products also use electromagnetic,
    solar, or thermoelectric energy converters.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得在此提及的较少为人所知的协议是EnOcean，^([[11](#ch05fn11)])它是一种能量收集无线技术，主要用于建筑和其他工业解决方案。尽管你可能从未听说过它，但EnOcean对于物联网特别相关，因为它优雅地解决了能源问题。这项技术允许设备从其环境中收集所需的能量。例如，当您轻触开关时产生的动能被开关捕获并用于传输信息。其他产品也使用电磁、太阳能或热电能量转换器。
- en: ^(11)
  id: totrans-1294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-1295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Online: [https://www.enocean.com/](https://www.enocean.com/).'
  id: totrans-1296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在线：[https://www.enocean.com/](https://www.enocean.com/).
- en: The EnOcean specification spans the Physical and Networking layers, but additional
    specifications are also provided for the Application layer. The protocol is proprietary
    and requires a dedicated wireless transceiver module on a gateway to receive messages
    from various EnOcean devices. This technology saves time and materials because
    it allows battery-less devices to be installed rapidly in a building without having
    any wires in place. Interestingly, element14 offers an EnOcean extension board
    for the Raspberry Pi so you can turn it into an EnOcean gateway.^([[12](#ch05fn12)])
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: EnOcean规范涵盖了物理和网络层，但还提供了应用层的附加规范。该协议是专有的，需要在网关上使用专用无线收发器模块来接收来自各种EnOcean设备的信息。这项技术节省了时间和材料，因为它允许在没有电线的情况下快速安装无需电池的设备。有趣的是，element14为Raspberry
    Pi提供了一种EnOcean扩展板，这样你就可以将其变成一个EnOcean网关.^([[12](#ch05fn12)])
- en: ^(12)
  id: totrans-1298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-1299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Online: [http://www.element14.com/community/community/raspberry-pi/raspberry-pi-accessories/enocean_pi/](http://www.element14.com/community/community/raspberry-pi/raspberry-pi-accessories/enocean_pi/).'
  id: totrans-1300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在线：[http://www.element14.com/community/community/raspberry-pi/raspberry-pi-accessories/enocean_pi/](http://www.element14.com/community/community/raspberry-pi/raspberry-pi-accessories/enocean_pi/).
- en: Summing up PAN
  id: totrans-1301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结PAN
- en: The various PAN protocols we’ve discussed are summarized in [table 5.2](#ch05table02),
    which compares their characteristics based on IoT-relevant criteria. In the Observed
    Range column we consider the range between two nodes when operating indoors. Note
    that the range of these protocols strongly depends on environmental variables
    such as the presence of thick walls or interferences. Furthermore, if the protocol
    supports mesh networking—for example, ZigBee—the maximal range can be much larger
    because messages can be relayed across multiple nodes.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的各种PAN协议总结在[表5.2](#ch05table02)中，该表根据与物联网相关的标准比较了它们的特性。在观察范围列中，我们考虑室内操作时两个节点之间的距离。请注意，这些协议的范围强烈依赖于环境变量，如厚墙或干扰的存在。此外，如果协议支持网状网络——例如，ZigBee——最大范围可以更大，因为消息可以在多个节点之间中继。
- en: Table 5.2\. Comparison of the most common PAN protocols
  id: totrans-1303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.2\. 最常见PAN协议的比较
- en: '| Name | Battery Usage | Observed Max Range (Indoors) | Mesh Networking | Openness
    | Ease of Use | Internet Integration |'
  id: totrans-1304
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 电池使用 | 观察到的最大范围（室内） | 网状网络 | 开放性 | 易用性 | 互联网集成 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1305
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| EnOcean | Very low | <30 m | No | Low | Medium | No |'
  id: totrans-1306
  prefs: []
  type: TYPE_TB
  zh: '| EnOcean | 非常低 | <30 m | 否 | 低 | 中等 | 否 |'
- en: '| ZigBee | Low | <50 m | Yes | Low | Hard | No |'
  id: totrans-1307
  prefs: []
  type: TYPE_TB
  zh: '| ZigBee | 低 | <50 m | 是 | 低 | 困难 | 否 |'
- en: '| Thread | Low | <50 m | Yes | Medium | Medium | Yes |'
  id: totrans-1308
  prefs: []
  type: TYPE_TB
  zh: '| Thread | 低 | <50 m | 是 | 中等 | 中等 | 是 |'
- en: '| Bluetooth | Low^([[a](#ch05tn01a)]) | <50 m | Coming in 2016 | Medium | Medium
    | No (upcoming) |'
  id: totrans-1309
  prefs: []
  type: TYPE_TB
  zh: '| 蓝牙 | 低^([[a](#ch05tn01a)]) | <50 m | 2016年推出 | 中等 | 中等 | 否（即将推出） |'
- en: '| Wi-Fi | High (low upcoming) | <30 m | No (internet) | High | Easy | Yes |'
  id: totrans-1310
  prefs: []
  type: TYPE_TB
  zh: '| Wi-Fi | 高（即将降低） | <30 m | 否（互联网） | 高 | 容易 | 是 |'
- en: ^a
  id: totrans-1311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-1312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With Bluetooth version 4 (Bluetooth Low Energy).
  id: totrans-1313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用蓝牙版本4（蓝牙低功耗）。
- en: The *ease of use* is a subjective evaluation based on our real-world experience
    with these different protocols. It merely expresses the pain we went through when
    using these different protocols both in lab and real-world settings.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '*易用性*是一个基于我们对这些不同协议的实际使用经验的主体评价。它仅仅表达了我们在实验室和实际环境中使用这些不同协议时所经历的痛苦。'
- en: Finally, if your device will be plugged into the power grid, then you should
    use Wi-Fi (great), Ethernet (even better), or both (ideally). If devices will
    be deployed in a fixed location rather than mobile and you can install a wired
    infrastructure, then you should use Ethernet, ideally with Power over Ethernet,
    so you only need the network cable.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你的设备将接入电网，那么你应该使用Wi-Fi（很好）、以太网（更好），或者两者都使用（理想情况下）。如果设备将在固定位置部署而不是移动，并且可以安装有线基础设施，那么你应该使用以太网，理想情况下使用以太网供电，这样你只需要网络电缆。
- en: There are clearly many more PAN protocols than those, ranging from the wireless
    Z-Wave^([[13](#ch05fn13)]) to the wired KNX.^([[14](#ch05fn14)]) A good place
    to hunt them all down is Wikipedia^([[15](#ch05fn15)]) or Postscapes.^([[16](#ch05fn16)])
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有许多其他的PAN协议，从无线Z-Wave^([[13](#ch05fn13)))到有线KNX.^([[14](#ch05fn14)))。寻找所有这些协议的好地方是维基百科^([[15](#ch05fn15)))或Postscapes.^([[16](#ch05fn16)))。
- en: ^(13)
  id: totrans-1317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-1318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://z-wavealliance.org](http://z-wavealliance.org)'
  id: totrans-1319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[Z-Wave联盟](http://z-wavealliance.org)'
- en: ^(14)
  id: totrans-1320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-1321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.knx.org/](http://www.knx.org/)'
  id: totrans-1322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[KNX官方网站](http://www.knx.org/)'
- en: ^(15)
  id: totrans-1323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-1324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Personal_area_network](http://en.wikipedia.org/wiki/Personal_area_network)'
  id: totrans-1325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[个人区域网络](http://en.wikipedia.org/wiki/Personal_area_network)'
- en: ^(16)
  id: totrans-1326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(16)
- en: ''
  id: totrans-1327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://postscapes.com/internet-of-things-protocols](http://postscapes.com/internet-of-things-protocols)'
  id: totrans-1328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[物联网协议](http://postscapes.com/internet-of-things-protocols)'
- en: 5.2.4\. IoT wide area networks
  id: totrans-1329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4\. 物联网广域网
- en: For some IoT applications, the PAN protocols presented in the previous section
    are not appropriate. If you want to deploy thousands of nodes to monitor large
    areas, such as a field, a forest, or a city, in theory you could use ZigBee. In
    practice, however, deploying and maintaining long-lived (months or years) and
    large-scale PAN mesh networks turn out to be extremely complex and costly. You’d
    have to deploy gateways, replicators, and amplifiers. Batteries would need to
    be changed. PANs are mainly suited for small distances between nodes, hence for
    smaller-scale deployments.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些物联网应用，上一节中提到的PAN协议可能并不适用。如果你想要部署数千个节点来监控大面积区域，例如田野、森林或城市，从理论上讲，你可以使用ZigBee。然而，在实践中，部署和维护长期（数月或数年）和大规模的PAN网状网络证明是极其复杂且昂贵的。你需要部署网关、复制器和放大器。电池需要更换。PAN主要适用于节点之间的小距离，因此适用于较小规模的部署。
- en: 'This limitation has led to the emergence of a different type of IoT network:
    wide area networks. The typical common denominator of IoT WANs is that they involve
    low-power nodes communicating directly with very high-power gateways called base
    stations or antennas. A good example of a WAN is the mobile phone network. Let’s
    take a closer look at the most relevant WAN networks that are relevant for the
    IoT.'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制导致了另一种类型物联网网络的出现：广域网。物联网WAN的典型共同特点是涉及低功耗节点直接与非常高功率的称为基站或天线的网关通信。一个WAN的好例子是移动电话网络。让我们更详细地看看与物联网最相关的WAN网络。
- en: 'Mobile networks: from GPRS to 5G'
  id: totrans-1332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 移动网络：从GPRS到5G
- en: The most common way to connect Things to the IP network without wires is to
    use the mobile phone network if available. You can use the data channel of mobile
    networks—for example, GPRS, 3G, or 4G—or use SMS. All you need is a cellular modem
    on your device and you’re good to go—at least, as long as you don’t forget to
    pay your phone bill!
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有线的情况下将事物连接到IP网络的最常见方式是，如果可用，使用移动电话网络。你可以使用移动网络的数据通道——例如，GPRS、3G或4G——或者使用短信。你只需要在设备上安装一个蜂窝调制解调器，然后就可以出发了——至少，只要你别忘了支付电话费！
- en: The drawback of cellular connectivity is that it wasn’t designed for the IoT.
    Nodes need a lot of energy—how often do you charge your cell phone, again?—so
    using the data channel to send data regularly isn’t viable for battery-powered
    devices. For less data-intensive scenarios, you could also send SMS periodically
    and put the device into sleep mode most of the time. This will work for sensing
    use cases where devices only send data, but it won’t work when you need to send
    commands to your device because you’ll have to wait until the device wakes up
    to process your request. Another limitation is that mobile phone networks weren’t
    meant for billions of things. Only a limited number of devices can connect at
    any given time to a gateway, so you’ll need to deploy a lot more antennas. Finally,
    the cost of using mobile networks is relatively high because pricing was set with
    a one-person, one-device business model that doesn’t fit the requirements of the
    IoT. These limitations imply that current mobile phone networks are merely a provisory
    solution for the IoT.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 细胞连接的缺点是它并不是为物联网设计的。节点需要大量的能量——你多久充一次手机电，再次？——因此使用数据通道定期发送数据对于电池供电的设备来说并不可行。对于数据密集度较低的场景，你也可以定期发送短信并将设备大部分时间置于睡眠模式。这对于仅发送数据的传感用例是可行的，但当你需要向设备发送命令时则不可行，因为你必须等待设备醒来处理你的请求。另一个限制是，手机网络并不是为数十亿个设备设计的。在任何给定时间，只有有限数量的设备可以连接到网关，因此你需要部署更多的天线。最后，使用移动网络的成本相对较高，因为定价是基于一人一设备的商业模式，这与物联网的需求不符。这些限制意味着当前的移动网络仅仅是物联网的一个临时解决方案。
- en: A viable long-term solution will be needed for the many billions of Things that
    will want to connect to the internet in the coming years. With this in mind, the
    NGMN (Next Generation Mobile Networks) Alliance,^([[17](#ch05fn17)]) a mobile
    telecommunications association of powerful mobile operators, vendors, manufacturers,
    and research institutions, is working on a mobile network specifically geared
    for the IoT, code-named 5G. This network should be rolled out by 2020 and will
    have several improvements. First, it will be much more energy-efficient. Second,
    it will allow a significantly higher number of simultaneously connected clients
    per gateway. Third, it will support mesh networking, which will improve coverage
    and energy usage. Finally, the cost of 5G subscriptions will be better suited
    to the IoT model.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来几年，将有数以亿计的设备需要连接到互联网，因此需要一个可行的长期解决方案。考虑到这一点，NGMN（下一代移动网络）联盟，^([[17](#ch05fn17)])，一个由强大的移动运营商、供应商、制造商和研究机构组成的移动电信协会，正在开发一个专门针对物联网的移动网络，代号为5G。这个网络预计将在2020年推出，并将有多个改进。首先，它将更加节能。其次，它将允许每个网关同时连接更多的客户端。第三，它将支持网状网络，这将提高覆盖范围和能源使用效率。最后，5G订阅的成本将更适合物联网模式。
- en: ^(17)
  id: totrans-1336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(17)
- en: ''
  id: totrans-1337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.ngmn.org](https://www.ngmn.org)'
  id: totrans-1338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.ngmn.org](https://www.ngmn.org)'
- en: The use of mobile networks for the IoT is definitely not uncommon, so there
    are a number of embedded device platforms that support this mode of communication
    either natively or through simple extension shields. Your Pi is no exception;
    several shields or Wi-Fi dongles can connect it to mobile networks whether via
    SMS or data networks.^([[18](#ch05fn18)])
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动网络进行物联网通信绝对不是不常见的事情，因此有许多嵌入式设备平台支持这种通信模式，无论是原生支持还是通过简单的扩展板。你的Pi也不例外；几个扩展板或Wi-Fi外置设备可以将它连接到移动网络，无论是通过短信还是数据网络.^([[18](#ch05fn18)])
- en: ^(18)
  id: totrans-1340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-1341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://postscapes.com/raspberry-pi-wireless-options](http://postscapes.com/raspberry-pi-wireless-options)'
  id: totrans-1342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[Raspberry Pi 无线选项](http://postscapes.com/raspberry-pi-wireless-options)'
- en: 'IoT wide area networks: low-power WANs'
  id: totrans-1343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网广域网：低功耗广域网
- en: 'Because current cellular mobile networks are ill-suited for most IoT applications,
    the number of IoT-dedicated WANs mushroomed over the past few years under the
    umbrella term *low-power wide area networks (LPWANs)*. The result is a number
    of technically compelling solutions, competing with similar offers. Most of these
    networks are organized with a star model: a number of low-power nodes communicate
    directly with powerful base stations directly attached to the power grid and to
    IP networks. Because of this architecture, LPWAN operators also face a major challenge:
    deploying their infrastructure. These dedicated networks require deploying additional
    communication antennas in the wild, just as mobile operators had to dot the landscape
    with antennas.'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前蜂窝移动网络不适合大多数物联网应用，在过去几年中，在“低功耗广域网络（LPWAN）”这个总称下，物联网专用WAN的数量激增。结果是出现了一些技术上令人信服的解决方案，与类似的提供方案竞争。大多数这些网络采用星型模型：许多低功耗节点直接与连接到电网和IP网络的强大基站通信。由于这种架构，LPWAN运营商也面临着一项重大挑战：部署他们的基础设施。这些专用网络需要在野外部署额外的通信天线，就像移动运营商不得不在景观上布置天线一样。
- en: The leading network in this field is SigFox.^([[19](#ch05fn19)]) Being the first
    large-scale LPWAN operator dedicated to the IoT, SigFox has broad coverage in
    several European countries. But competition there is fierce and other networks
    (for example, LoRa^([[20](#ch05fn20)]) or nwave and the Weightless Alliance^([[21](#ch05fn21)]))
    are catching up quickly.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 该领域的领先网络是SigFox.^([[19](#ch05fn19)]) 作为第一个专注于物联网的大规模LPWAN运营商，SigFox在几个欧洲国家拥有广泛的覆盖范围。但那里的竞争非常激烈，其他网络（例如，LoRa^([[20](#ch05fn20)])
    或nwave和Weightless联盟^([[21](#ch05fn21)]))正在迅速追赶。
- en: ^(19)
  id: totrans-1346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（19）
- en: ''
  id: totrans-1347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.sigfox.com/en/](http://www.sigfox.com/en/)'
  id: totrans-1348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.sigfox.com/en/](http://www.sigfox.com/en/)'
- en: ^(20)
  id: totrans-1349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（20）
- en: ''
  id: totrans-1350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.lora-alliance.org/](https://www.lora-alliance.org/)'
  id: totrans-1351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.lora-alliance.org/](https://www.lora-alliance.org/)'
- en: ^(21)
  id: totrans-1352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（21）
- en: ''
  id: totrans-1353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.nwave.io](http://www.nwave.io) and [http://www.weightless.org](http://www.weightless.org)'
  id: totrans-1354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.nwave.io](http://www.nwave.io) 和 [http://www.weightless.org](http://www.weightless.org)'
- en: These networks have a number of advantages. First, deploying the infrastructure
    is the operator’s business, not yours. Then, the range of the base station is
    quite high, in the order of several kilometers. In addition, each base station
    can handle a significant amount of parallel traffic coming from potentially millions
    of devices connected to a single base station. Finally, their power consumption
    is much lower than that of networks using WAN or PAN protocols. Let’s consider
    a smart meter^([[22](#ch05fn22)]) powered by a standard battery (2.5 Ah) and sending
    a few messages per day. With most WAN or PAN protocols, the battery would barely
    last several months. With LPWAN, that same battery could last up to 20 years!
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 这些网络有许多优点。首先，部署基础设施是运营商的业务，而不是你的。其次，基站的范围相当高，可达数公里。此外，每个基站可以处理来自可能连接到单个基站的数百万个设备的显著数量的并行流量。最后，它们的功耗远低于使用WAN或PAN协议的网络。让我们考虑一个由标准电池（2.5
    Ah）供电的智能电表^([[22](#ch05fn22)]），每天发送几条信息。使用大多数WAN或PAN协议，电池的寿命可能只有几个月。而使用LPWAN，同样的电池可以持续长达20年！
- en: ^(22)
  id: totrans-1356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（22）
- en: ''
  id: totrans-1357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A smart meter is a connected device that measures electricity consumption.
  id: totrans-1358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 智能电表是一种连接设备，用于测量电力消耗。
- en: These advantages make the deployment of LPWAN-based devices straightforward—in
    theory, at least, because LPWAN coverage remains sparse in comparison with mobile
    phone networks. Besides, these networks are often proprietary and closed ecosystems
    where your Things will be locked forever and beyond.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势使得基于LPWAN的设备部署变得简单——至少在理论上是这样，因为与移动电话网络相比，LPWAN的覆盖范围仍然很稀疏。此外，这些网络通常是专有和封闭的生态系统，你的设备将永远被锁定。
- en: Where’s the catch? Well, LPWAN is perfect for low-bandwidth sensing scenarios
    such as sending data from a smart meter, but it won’t work for actuation, like
    opening your garage door, because sending commands to devices is challenging and
    extremely slow.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 那有什么问题吗？嗯，LPWAN非常适合低带宽传感场景，例如从智能电表中发送数据，但它不适用于执行操作，如打开你的车库门，因为向设备发送命令具有挑战性且非常缓慢。
- en: Because of their industrial focus, connecting off-the-shelf embedded devices
    to LPWAN IoT is still more complex than with PANs. Fortunately, as LPWAN gains
    traction, various modules for embedded devices have appeared.^([[23](#ch05fn23)])
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们专注于工业领域，将现成的嵌入式设备连接到LPWAN物联网比连接到PANs更复杂。幸运的是，随着LPWAN的普及，各种嵌入式设备模块已经出现.^([[23](#ch05fn23)])
- en: ^(23)
  id: totrans-1362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（23）
- en: ''
  id: totrans-1363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.cooking-hacks.com/sx1272-lora-module-for-arduino-raspberry-pi-intel-galileo-900-mhz](http://www.cooking-hacks.com/sx1272-lora-module-for-arduino-raspberry-pi-intel-galileo-900-mhz)'
  id: totrans-1364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.cooking-hacks.com/sx1272-lora-module-for-arduino-raspberry-pi-intel-galileo-900-mhz](http://www.cooking-hacks.com/sx1272-lora-module-for-arduino-raspberry-pi-intel-galileo-900-mhz)'
- en: Summing up WAN
  id: totrans-1365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结广域网
- en: Most of the WAN protocols we described in this section share more or less the
    same capabilities. The only exception is mobile phone networks, which requires
    much more power than other IoT WAN protocols. This will likely change with the
    arrival of 5G networks, but we still have a few years to wait for that. For the
    other protocols, the main differentiator is their coverage. Because they’re still
    far from having the coverage of mobile phone networks, deploying IoT use cases
    with these protocols requires careful planning with the network providers to ensure
    the target zones are sufficiently covered. Coverage of LPWANs will likely improve
    significantly in the near future, but it’s still hard to predict which protocol
    will prevail and dominate the world of IoT WANs. See [table 5.3](#ch05table03)
    for a comparison of WAN protocols.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的大多数广域网协议具有或多或少相同的特性。唯一的例外是移动电话网络，它比其他物联网广域网协议需要更多的电力。随着5G网络的到来，这种情况可能会改变，但我们仍需等待几年。对于其他协议，主要的不同之处在于它们的覆盖范围。因为它们还远未达到移动电话网络的覆盖范围，使用这些协议部署物联网用例需要与网络提供商进行仔细规划，以确保目标区域得到充分覆盖。LPWAN的覆盖范围预计在不久的将来将显著提高，但仍然难以预测哪个协议将占主导地位并统治物联网广域网的世界。参见[表
    5.3](#ch05table03)以比较广域网协议。
- en: Table 5.3\. A comparison between most common WAN protocols.
  id: totrans-1367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.3\. 最常见广域网协议的比较。
- en: '| Name | Battery Usage | Max Range | Downlink | Openness | Coverage |'
  id: totrans-1368
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 电池使用 | 最大范围 | 下行链路 | 开放性 | 覆盖范围 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-1369
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Weightless | Very low | 20+ km | Limited | Medium | Medium |'
  id: totrans-1370
  prefs: []
  type: TYPE_TB
  zh: '| Weightless | 非常低 | 20+ 公里 | 有限 | 中等 | 中等 |'
- en: '| SigFox | Very low | 30+ km | Limited | Low | Medium-high |'
  id: totrans-1371
  prefs: []
  type: TYPE_TB
  zh: '| SigFox | 非常低 | 30+ 公里 | 有限 | 低 | 中高 |'
- en: '| LoRa | Very low | 30+ km | Limited | Medium | Medium |'
  id: totrans-1372
  prefs: []
  type: TYPE_TB
  zh: '| LoRa | 非常低 | 30+ 公里 | 有限 | 中等 | 中等 |'
- en: '| GPRS/3G/4G | High | 50+ km | Yes | High | High |'
  id: totrans-1373
  prefs: []
  type: TYPE_TB
  zh: '| GPRS/3G/4G | 高 | 50+ 公里 | 是 | 高 | 高 |'
- en: '| 5G | Very low | ? | ? (probable) | High | Not deployed yet |'
  id: totrans-1374
  prefs: []
  type: TYPE_TB
  zh: '| 5G | 非常低 | ? | ? (可能) | 高 | 尚未部署 |'
- en: 5.2.5\. So, which one should I choose?
  id: totrans-1375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5\. 那么，我应该选择哪一个呢？
- en: 'Selecting the right network protocol stack for your next IoT project can be
    a daunting task. There are literally hundreds of possibilities for every layer
    of the stack, and these choices will be harder to revert. Unlike computers, Things
    will likely have a longer lifetime because consumers won’t change the hardware
    of their fridge just to support a new Physical layer protocol. The CEO of a major
    home appliance manufacturer once told us that his top concern with the IoT was
    the ongoing war of standards and the implications of choosing the wrong one: “People
    don’t want to upgrade the protocol stacks of their ovens, do they?”'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的下一个物联网项目选择合适的网络协议栈可能是一项艰巨的任务。实际上，每一层都有数百种可能性，这些选择将更难逆转。与计算机不同，事物可能具有更长的生命周期，因为消费者不会仅仅为了支持新的物理层协议而更换冰箱的硬件。一位主要家用电器制造商的CEO曾告诉我们，他对物联网的主要担忧是持续的标准战以及选择错误标准的影响：“人们不想升级烤箱的协议栈，对吧？”
- en: There’s no secret recipe for picking the right networking protocol stack because
    all protocols we’ve presented have their respective strengths and weaknesses.
    In this section, we’ll provide some considerations and tradeoffs that will help
    you choose the right protocols for your application or device.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的网络协议栈没有秘密配方，因为我们所介绍的每个协议都有其各自的优势和劣势。在本节中，我们将提供一些考虑和权衡，以帮助您为您的应用或设备选择合适的协议。
- en: Power source
  id: totrans-1378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 电源
- en: The first thing you need to consider is how your device will be powered. Your
    options are battery, wired power source, and energy harvesting. This decision
    will depend on the context where the device will be used; for example, a power
    cord is ideal for fixed devices such as a lamp or a fridge. If wired power isn’t
    an option in a remote environment such as a forest, a battery or solar panel will
    be a better choice, unless you’re in Scotland. Likewise, a mobile device (for
    example, a portable Geiger counter) will have to use a battery or energy-harvesting
    technique.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要考虑的是你的设备将如何供电。你的选择包括电池、有线电源和能量采集。这个决定将取决于设备将使用的环境；例如，电源线对于固定设备（如灯具或冰箱）来说是非常理想的。如果在森林等偏远环境中没有有线电源，电池或太阳能板将是一个更好的选择，除非你身处苏格兰。同样，移动设备（例如，便携式盖革计数器）将不得不使用电池或能量采集技术。
- en: If your device doesn’t have the luxury of wired power, you’ll need to use low-power
    protocols such as those based on IEEE 802.15.4 or LPWAN. Bluetooth LE, Thread,
    or SigFox would be a good choice in this case. At the Transport layer, if some
    data loss is acceptable, you could use UDP instead of TCP to further reduce power
    consumption.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备没有有线电源的便利，你需要使用低功耗协议，例如基于IEEE 802.15.4或LPWAN的协议。在这种情况下，蓝牙LE、Thread或SigFox将是不错的选择。在传输层，如果可以接受一些数据丢失，你可以使用UDP而不是TCP来进一步降低功耗。
- en: If your device can connect to a power socket, Wi-Fi is the obvious choice, especially
    within a building where Wi-Fi can be easily installed. You might also consider
    Ethernet or Power Line Communication (PLC). If you have only an Ethernet socket,
    you might want to use Power over Ethernet (PoE) because this protocol tends to
    be more stable. At the Transport layer, you should use the reliability and good
    overall support of TCP.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备可以连接到电源插座，Wi-Fi是显然的选择，尤其是在建筑物内，Wi-Fi可以很容易地安装。你也可能考虑以太网或电力线通信（PLC）。如果你只有以太网插座，你可能想使用以太网供电（PoE），因为这种协议通常更稳定。在传输层，你应该使用TCP的可靠性和良好的整体支持。
- en: Cost
  id: totrans-1382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 成本
- en: Cost is an important factor because together with power consumption, it determines
    which type of embedded device you can build into your Thing. If your budget per
    embedded device is less than 10 USD, you’ll have to look into resource-constrained
    SoC (system on chip) platforms such as the ones we looked at in [chapter 2](kindle_split_009.html#ch02)—for
    example, Marvell, Broadcom, TI, and NXP. These platforms usually have limited
    RAM, storage, and processing power, which directly impacts the networking protocol
    stack you can use. If every single byte counts, you might be better off with protocols
    that were designed for resource-constrained devices at their core, such as IEEE
    802.15.4, ZigBee, and Bluetooth LE. In terms of a Transport protocol, UDP is known
    to use fewer resources (RAM, CPU, and bandwidth) than TCP. If your target cost
    is above $10–$20 per device, you can start thinking about Linux-based platforms,
    giving you total freedom in terms of the IoT networking protocols you can use.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 成本是重要的因素，因为它与功耗一起决定了你可以将哪种嵌入式设备集成到你的设备中。如果你的每个嵌入式设备的预算低于10美元，你将不得不考虑资源受限的SoC（系统芯片）平台，例如我们在[第2章](kindle_split_009.html#ch02)中提到的那些——例如，Marvell、Broadcom、TI和NXP。这些平台通常具有有限的RAM、存储和处理能力，这直接影响了你可以使用的网络协议栈。如果你的每个字节都很重要，你可能更适合使用专为资源受限设备设计的协议，如IEEE
    802.15.4、ZigBee和蓝牙LE。在传输协议方面，UDP比TCP使用更少的资源（RAM、CPU和带宽）。如果你的目标成本高于每台设备10-20美元，你可以开始考虑基于Linux的平台，这将在物联网网络协议的使用上给你带来完全的自由。
- en: Range and network topology
  id: totrans-1384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 范围和网络拓扑
- en: Another aspect to consider is how far a Thing will be from a gateway or from
    other Things. This is tightly coupled with how much power your device can use.
    Roughly speaking, the more power your device has, the farther away it will be
    reachable—with the exception of LPWAN. We described the ranges of the different
    protocols before, so you should be able to make a decision. Don’t forget that
    mesh networking can help. It lets you use low-power PAN networks like Thread or
    ZigBee while extending their range using multi-hop communication.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的方面是设备与网关或其他设备之间的距离。这与你的设备能使用的电量紧密相关。粗略地说，你的设备电量越大，其可达到的距离就越远——LPWAN除外。我们之前描述了不同协议的覆盖范围，所以你应该能够做出决定。别忘了网状网络可以帮助。它允许你使用低功耗的PAN网络，如Thread或ZigBee，同时通过多跳通信来扩展它们的范围。
- en: The infrastructure already in place is also an important consideration. For
    instance, if a star topology is available, you might as well use it. This is the
    case in a home environment where a Wi-Fi router is likely to be present, or outdoors
    in an area covered by LPWAN, making deployments a lot easier.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 已经存在的设施也是重要的考虑因素。例如，如果存在星形拓扑，您不妨使用它。在家庭环境中，这通常是存在Wi-Fi路由器的情况，或者在LPWAN覆盖的区域外，这使得部署变得容易得多。
- en: Bandwidth, latency, actuation, and sensing
  id: totrans-1387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 带宽、延迟、执行和传感
- en: You need to clearly know the interaction types and the bandwidth your Things
    will require. First, is this a sensing application where devices only need to
    send data to other devices or to the cloud? How often will you send messages;
    that is, will the device send data a few times per minute? Or will it sleep most
    of the time and send messages only a few times per day? Also, will you require
    sending commands to the device (actuation), and if so, how much latency can your
    application tolerate? Finally, how large will those messages be? A few bytes?
    Much more?
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要清楚地了解交互类型和您的设备将需要的带宽。首先，这是一个传感应用，设备只需要将数据发送到其他设备或云吗？您会多久发送一次消息；也就是说，设备每分钟会发送几次数据？还是它大部分时间都在休眠，只在每天发送几次消息？此外，您是否需要向设备发送命令（执行），如果是的话，您的应用程序可以容忍多少延迟？最后，这些消息有多大？几字节？还是更多？
- en: Some protocols like LPWAN—with the exception of mobile phone networks—don’t
    work well with actuation or with use cases requiring large bandwidth. For these,
    Wi-Fi and Ethernet are probably the most suitable physical protocols. Other PAN
    protocol stacks, like ZigBee, Bluetooth, and Thread, are somewhere in between
    in terms of available bandwidth and offer decent communication, so they’re suitable
    for sending and actuation, although end-to-end latency may increase with the number
    of hops messages have to travel through.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 一些协议（如LPWAN，除了移动电话网络外）与执行或需要大量带宽的使用案例不太兼容。对于这些，Wi-Fi和以太网可能是最合适的物理协议。其他个人区域网络（PAN）协议栈，如ZigBee、蓝牙和Thread，在可用带宽方面介于两者之间，提供良好的通信，因此适合发送和执行，尽管随着消息必须穿越的跳数增加，端到端延迟可能会增加。
- en: Internet integration and openness
  id: totrans-1390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 互联网集成和开放性
- en: Finally, the openness of the protocol stack you choose can be an important factor.
    Is it an open or proprietary standard? How open and accessible are the specifications?
    How well supported is the protocol in the real world? How integrated with the
    internet protocols stack is that protocol? If a protocol stack doesn’t provide
    ways of translating to internet protocols (IP, TCP, or UDP) easily, it might be
    fine in closed networks (industrial machines in a factory, for example), but not
    if those devices need to be accessible through the internet.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您选择的协议栈的开放性可以是一个重要因素。这是一个开放标准还是专有标准？规范有多开放和可访问？该协议在现实世界中的支持情况如何？该协议与互联网协议栈的集成程度如何？如果一个协议栈不提供将数据转换为互联网协议（IP、TCP或UDP）的简单方法，那么在封闭网络（例如工厂中的工业机器）中可能还可以，但如果这些设备需要通过互联网访问，则可能不行。
- en: 'Because of the pressure the IoT exerts on protocol stacks to be internet-compatible,
    all the protocol stacks we described previously can be integrated to the internet
    in one way or another. But the question really is this: at what layer and what
    deployment effort? The higher in the layers the integration takes place, the harder
    it is to reuse the internet infrastructure already in place. For instance, an
    implementation at only the Transport layer (such as by implementing TCP) means
    that you won’t be able to use the infrastructure already in place for the layers
    below, such as internet access points, bridges, hubs, routers, and switches, and
    these will need to be replaced by other actors playing similar roles.'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 由于物联网对协议栈施加的压力，使其必须与互联网兼容，因此我们之前描述的所有协议栈都可以以某种方式集成到互联网中。但真正的问题其实是：在哪个层次以及需要多少部署工作量？集成层次越高，就越难以重用已经存在的互联网基础设施。例如，仅在传输层（如通过实现TCP）进行实现意味着您将无法使用已经存在的下层基础设施，例如互联网接入点、网桥、集线器、路由器和交换机，这些将需要由扮演类似角色的其他参与者来替换。
- en: 'Basically, if the internet integration takes place at layer 3, someone will
    need to deploy hardware and software that covers the services offered by the layers
    below, leading to more complex deployments. The key underlying question here is
    this: who will deploy these additional components? In the case of a system based
    on an existing infrastructure like, say, SigFox, they do this for you so the burden
    is minimal but you have a dependency on a single company (SigFox, in this case).
    In the case of a home environment, for example, things are quite different, because
    you’ll need to put in place the infrastructure if you don’t plan to rely on the
    existing internet infrastructure.'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果互联网集成发生在第3层，就需要有人部署硬件和软件来覆盖下面各层提供的服务，从而导致更复杂的部署。这里的关键问题是：谁将部署这些额外的组件？在基于现有基础设施的系统（比如，SigFox）的情况下，他们会为你这样做，所以负担最小，但你依赖于单一的公司（在这种情况下是SigFox）。在家庭环境的情况下，情况则完全不同，因为你需要建立基础设施，如果你不打算依赖现有的互联网基础设施。
- en: 'Let’s look at a concrete example, as shown in [figure 5.8](#ch05fig08). Imagine
    you’d like to build a smart lamp that users can control from their mobile phone.
    You decide to choose a ZigBee protocol stack for your lamps. Because mobile phones
    can’t speak ZigBee directly, you could decide to use HTTP as an application protocol.
    Communication goes down the layer from HTTP to Wi-Fi. Your lamps, on the other
    hand, use IEEE 802.15.4, which is the physical protocol of the ZigBee stack. Because
    it’s unlikely that your customers have access points that support 802.15.4 and
    this protocol is physically incompatible with Wi-Fi, you need new hardware to
    support the 802.15.4, so you need to package your lamps with a ZigBee access point,
    too. Then, you need to bridge Wi-Fi to ZigBee and translate IP to ZigBee addressing,
    TCP to the transport protocol of ZigBee, and finally, HTTP to the application
    protocol of ZigBee. Then you need to translate this back to HTTP, TCP, IP, and
    Wi-Fi to respond to the mobile phone application. Of course, a number of these
    translations are standardized; nevertheless, it adds complexity to the deployment
    of your system and this complexity even reaches your customer, who needs to install
    additional hardware in their house for your system to work. Now imagine deploying
    this system in several buildings or in an entire city: you thought you were deploying
    smart lamps, but suddenly you’re deploying an entirely new network! ZigBee isn’t
    a bad choice per se, but if your main goal is to build a large-scale network where
    interoperability is prime, other options will make your life easier.'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个具体的例子，如图 [图5.8](#ch05fig08) 所示。想象一下，你想要制作一个用户可以通过手机控制的智能灯。你决定为你的灯选择ZigBee协议栈。因为手机不能直接使用ZigBee，你可以决定使用HTTP作为应用协议。通信从HTTP层向下到Wi-Fi层。另一方面，你的灯使用IEEE
    802.15.4，这是ZigBee协议栈的物理协议。由于你的客户不太可能有支持802.15.4的接入点，并且这个协议在物理上与Wi-Fi不兼容，你需要新的硬件来支持802.15.4，因此你还需要将ZigBee接入点包装在你的灯中。然后，你需要将Wi-Fi桥接到ZigBee，并将IP地址转换为ZigBee地址，将TCP转换为ZigBee的传输协议，最后将HTTP转换为ZigBee的应用协议。然后你需要将这些转换回HTTP、TCP、IP和Wi-Fi，以响应用户的手机应用程序。当然，其中许多转换是标准化的；然而，这增加了你系统部署的复杂性，这种复杂性甚至影响到你的客户，他们需要在自己的家中安装额外的硬件才能使你的系统工作。现在想象一下在几栋楼或整个城市部署这个系统：你以为你只是在部署智能灯，但突然你发现你正在部署一个全新的网络！ZigBee本身并不是一个坏选择，但如果你的主要目标是建立一个大规模网络，其中互操作性是首要的，其他选项会使你的生活更轻松。
- en: 'Figure 5.8\. Two smart lamps communicating with web applications. Left: a smart
    lamp with Wi-Fi on board and implementing the IP stack. Right: a smart lamp implemented
    with ZigBee on board and implementing a ZigBee stack. In this second case, translators
    are required between the application and the lamp.'
  id: totrans-1395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8。两个智能灯与网络应用程序通信。左：一个内置Wi-Fi并实现IP栈的智能灯。右：一个内置ZigBee并实现ZigBee栈的智能灯。在第二种情况下，需要在应用程序和灯之间使用翻译器。
- en: '![](05fig08_alt.jpg)'
  id: totrans-1396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig08_alt.jpg)'
- en: Choosing a protocol stack based on open standards or large alliances will help
    here. Popular and/or open protocol stacks—think Wi-Fi, Thread, Bluetooth, and
    the like—are far more likely to be supported by future generations of access points,
    routers, and mobile phones. In contrast, proprietary technologies like EnOcean
    and ZigBee will likely continue to require additional hardware and gateways to
    connect to the internet.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 基于开放标准或大型联盟选择协议栈将有助于此。流行的和/或开放协议栈——如Wi-Fi、Thread、蓝牙等——更有可能被未来一代的接入点、路由器和手机所支持。相比之下，像EnOcean和ZigBee这样的专有技术可能仍然需要额外的硬件和网关才能连接到互联网。
- en: 5.3\. Application protocols for Things
  id: totrans-1398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 物联网应用协议
- en: 'So far, we’ve only looked at the lower layers of the networking stacks: the
    Physical, Network, and Transport layers. These protocols give a voice to Things
    that can be heard on the internet. Although those Things can now speak internet,
    no one else can understand what these Things are saying—unless they can speak
    a common language. What’s the *universal language* of the internet? Well, just
    like there isn’t only a single language on earth, there are many languages for
    different purposes. The *languages of the internet* are the protocols of the Application
    layer (layer 4 of [figure 5.8](#ch05fig08)). As you’ll see in this section, many
    Application layer protocols have been designed for the IoT; unfortunately, few
    of them integrate seamlessly with the web.'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了网络堆栈的底层：物理层、网络层和传输层。这些协议为物联网中的事物提供了可以在互联网上听到的声音。尽管这些事物现在可以讲互联网语言，但其他人无法理解这些事物在说什么——除非他们能说一种共同的语言。互联网的*通用语言*是什么？嗯，就像地球上不止一种语言一样，也有许多语言用于不同的目的。*互联网的语言*是应用层的协议（[图5.8](#ch05fig08)的第4层）。正如您在本节中将会看到的，许多应用层协议是为物联网设计的；不幸的是，其中很少能够与互联网无缝集成。
- en: 'Let’s begin by looking at Application layers that aren’t based on internet
    protocols. This space is filled with standards that have been used in fields such
    as home automation, building management, and manufacturing, so we could easily
    write another book just on these. Instead, let’s focus on two built on top of
    two PAN protocol stacks we’ve looked at before: ZigBee and Bluetooth.'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看不基于互联网协议的应用层开始。这个领域充满了在家用自动化、楼宇管理和制造等领域使用过的标准，所以我们完全可以就这些内容再写一本书。相反，让我们专注于建立在之前查看过的两个PAN协议栈之上的两个应用：ZigBee和蓝牙。
- en: 5.3.1\. ZigBee and Bluetooth application stacks
  id: totrans-1401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. ZigBee和蓝牙应用堆栈
- en: Both ZigBee and Bluetooth offer a conceptually similar stack for the Application
    layer. The key idea is to provide a set of specifications for domain-specific
    applications; these are very specific use cases, such as managing security systems
    or controlling industrial machines. These specifications are called *application
    profiles* in the case of ZigBee or just *profiles* in the Bluetooth case. For
    example, Bluetooth defines a custom profile for health monitoring devices called
    the Health Device Profile (HDP). For building accessories (such as your car) that
    can read messages on a mobile phone, it defines a profile called the Message Access
    Profile (MAP). For ZigBee there are profiles for building lighting systems, fans,
    HVAC systems, or shades. Profiles define the protocol, operations, and payloads
    that can be used to interact with a device that uses a certain profile.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: ZigBee和蓝牙在应用层提供了概念上相似的堆栈。关键思想是提供一套针对特定领域应用的规范；这些是非常具体的用例，例如管理安全系统或控制工业机器。在ZigBee的情况下，这些规范被称为*应用配置文件*，而在蓝牙的情况下则简单地称为*配置文件*。例如，蓝牙定义了一个用于健康监测设备的自定义配置文件，称为健康设备配置文件（HDP）。对于可以读取手机上消息的楼宇配件（如您的汽车），它定义了一个名为消息访问配置文件（MAP）的配置文件。对于ZigBee，有针对楼宇照明系统、风扇、HVAC系统或百叶窗的配置文件。配置文件定义了可以用来与使用特定配置文件的设备交互的协议、操作和有效载荷。
- en: You don’t have to use these profiles to build applications using Things built
    on top of ZigBee or Bluetooth; you can also build your own application protocol.
    But these profiles ensure that a client application understands what a ZigBee
    or Bluetooth device has to offer, so they’re important for facilitating interoperability
    between services running on Things and applications*.*
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必使用这些配置文件来构建基于ZigBee或蓝牙构建的应用程序；您也可以构建自己的应用协议。但这些配置文件确保客户端应用程序理解ZigBee或蓝牙设备能提供什么，因此对于促进在物联网上运行的服务和应用程序之间的互操作性非常重要。
- en: Bluetooth and ZigBee Application layers also address other Application layer
    issues. For instance, both standards provide a way to uniquely identify devices
    as well as ways to perform network discovery. That is, they provide a way for
    several devices or several applications and devices to discover each other without
    knowing of their existence in the first place. In Bluetooth, for example, this
    is achieved by broadcasting a Bluetooth identifier and a reference to a profile
    to all listening devices. A similar system is in place for ZigBee.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙和ZigBee的应用层也解决了其他应用层问题。例如，这两个标准都提供了一种唯一标识设备以及执行网络发现的方法。也就是说，它们提供了一种方式，让多个设备或多个应用程序和设备在最初不知道它们存在的情况下相互发现。例如，在蓝牙中，这是通过向所有监听设备广播一个蓝牙标识符和一个配置文件引用来实现的。ZigBee也有类似的系统。
- en: 'All in all, Bluetooth and ZigBee have a lot to teach us in terms of what’s
    needed at the Application layer. But as you’ve seen before, Bluetooth and ZigBee
    don’t natively speak internet or web protocols. Moreover, there’s a lack of SDK
    support for common languages: while you have web client libraries available for
    virtually any programming language, this isn’t the case of Zigbee or Bluetooth.^([[24](#ch05fn24)])
    In consequence, the application protocols of ZigBee and Bluetooth make them largely
    incompatible with devices that use other protocol stacks.'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，蓝牙和ZigBee在应用层需要什么方面有很多可以教给我们。但正如你之前看到的，蓝牙和ZigBee并不原生支持互联网或Web协议。此外，对于常见语言缺乏SDK支持：虽然几乎任何编程语言都有Web客户端库可用，但这并不适用于Zigbee或蓝牙.^([[24](#ch05fn24)])
    因此，ZigBee和蓝牙的应用协议使它们在很大程度上与其他使用其他协议栈的设备不兼容。
- en: ^(24)
  id: totrans-1406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(24)
- en: ''
  id: totrans-1407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although Bluetooth is in a slightly better place in terms of SDKs with standard
    SDKs for Android and iOS or Linux (see [http://www.bluez.org/](http://www.bluez.org/))
  id: totrans-1408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管在SDK方面，蓝牙略好一些，因为Android、iOS或Linux都有标准的SDK（参见[http://www.bluez.org/](http://www.bluez.org/)）
- en: To deal with this, a number of bridges (gateways) have been built. As an example,
    a number of Bluetooth vendors have proposed integrations of Bluetooth devices
    to 6LoWPAN,^([[25](#ch05fn25)]) where every Bluetooth device gets an IPv6 address
    via special Bluetooth smart gateways. Similar initiatives exist for ZigBee, and
    the respective working groups are busy standardizing these bridges.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，已经建立了许多网桥（网关）。例如，许多蓝牙供应商提出了将蓝牙设备集成到6LoWPAN^([[25](#ch05fn25)])中的方案，其中每个蓝牙设备都通过特殊的蓝牙智能网关获得一个IPv6地址。对于ZigBee也存在类似的倡议，并且相应的工作组正在忙于标准化这些网桥。
- en: ^(25)
  id: totrans-1410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(25)
- en: ''
  id: totrans-1411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A good example is the Bluetooth IoT SDK for NordicSemic: [https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF51-IoT-SDK](https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF51-IoT-SDK).'
  id: totrans-1412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个很好的例子是NordicSemic的蓝牙物联网SDK：[https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF51-IoT-SDK](https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF51-IoT-SDK).
- en: 'There’s a good likelihood that ZigBee and Bluetooth will systematically implement
    the Internet Protocol Stack in the near future. This puts them on the internet
    resolving the networking of these Things but not their Application layer. Although
    the Application layer of Bluetooth or ZigBee is not built on top of IP-based protocols,
    a number of IP-based application protocols are available. Some of them, such as
    XMPP^([[26](#ch05fn26)]) (Extensible Messaging and Presence Protocol) and AMQP^([[27](#ch05fn27)])
    (Advanced Message Queuing Protocol), were not meant for IoT use cases in the first
    place, yet people started adapting them over the years. Others, such as CoAP (Constrained
    Application Protocol) and MQTT (Message Queuing Telemetry Transport), were specifically
    created for the Internet of Things and are built on top of internet protocols,
    so we need to take a more detailed look at these two. But first, let’s look at
    two other protocols pushed by today’s most notorious tech giants: Apple and Google.'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 有很大的可能性，ZigBee和蓝牙将在不久的将来系统地实现互联网协议栈。这使得它们可以连接到互联网，解决这些事物的网络问题，但不是它们的应用层。尽管蓝牙或ZigBee的应用层不是建立在基于IP的协议之上，但有许多基于IP的应用协议可用。其中一些，如XMPP^([[26](#ch05fn26)])（可扩展消息和存在协议）和AMQP^([[27](#ch05fn27)])（高级消息队列协议），最初并不是为物联网用例设计的，但多年来人们开始适应它们。其他一些，如CoAP（约束应用协议）和MQTT（消息队列遥测传输），是专门为物联网创建的，并且建立在互联网协议之上，因此我们需要更详细地研究这两个。但首先，让我们看看今天最臭名昭著的技术巨头苹果和谷歌推动的两个其他协议。
- en: ^(26)
  id: totrans-1414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(26)
- en: ''
  id: totrans-1415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://xmpp.org](http://xmpp.org)'
  id: totrans-1416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://xmpp.org](http://xmpp.org)'
- en: ^(27)
  id: totrans-1417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(27)
- en: ''
  id: totrans-1418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.amqp.org](https://www.amqp.org)'
  id: totrans-1419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.amqp.org](https://www.amqp.org)'
- en: 5.3.2\. Apple HomeKit and Google Weave
  id: totrans-1420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 苹果 HomeKit 和谷歌 Weave
- en: In June 2014, Apple announced it was entering the IoT and in particular the
    home automation market with a protocol called HomeKit,^([[28](#ch05fn28)]) to
    be supported on all iOS-based devices. The HomeKit protocol stack covers several
    options, as shown in [figure 5.9](#ch05fig09). There’s an option for Bluetooth
    devices that uses the Bluetooth protocols stack and an option for internet-ready
    devices that uses IP, TCP, HTTP, and JSON. Finally, a bridge specification allows
    other devices to be integrated to the HomeKit Accessory Protocol. Regardless of
    the stack you choose to use, the Things you connect are eventually available for
    applications through iOS SDK interfaces.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年6月，苹果宣布它将进入物联网市场，特别是智能家居市场，推出名为HomeKit的协议，^([[28](#ch05fn28)]) 将支持所有基于iOS的设备。HomeKit
    协议栈涵盖了几个选项，如图 5.9 所示。有一个选项是使用蓝牙协议栈的蓝牙设备选项，还有一个选项是使用 IP、TCP、HTTP 和 JSON 的互联网设备选项。最后，桥接规范允许其他设备集成到
    HomeKit 配件协议中。无论你选择使用哪个栈，你连接的设备最终都可以通过 iOS SDK 接口供应用程序使用。
- en: ^(28)
  id: totrans-1422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(28)
- en: ''
  id: totrans-1423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/homekit/](https://developer.apple.com/homekit/)'
  id: totrans-1424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/homekit/](https://developer.apple.com/homekit/)'
- en: 'Figure 5.9\. The HomeKit stack: both IP Things and Bluetooth Things are supported.
    Things based on other stacks are integrated via a HomeKit bridge. At the Application
    layer, HomeKit enables direct access to Things through iOS.'
  id: totrans-1425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.9\. HomeKit 栈：支持 IP 设备和蓝牙设备。基于其他栈的设备通过 HomeKit 桥接器集成。在应用层，HomeKit 通过 iOS
    直接访问设备。
- en: '![](05fig09.jpg)'
  id: totrans-1426
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig09.jpg)'
- en: Although HomeKit is still in its early days, the presence of Apple devices in
    many homes means that it’s likely to play an important role. Because it’s based
    on a number of open standards, integration between HomeKit and other devices won’t
    be a major technical challenge. But the HomeKit Protocol itself isn’t open, so
    implementing a HomeKit Thing or an application requires being part of Apple’s
    MFi (Made for iPhone) program.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HomeKit仍处于早期阶段，但许多家庭中苹果设备的存在意味着它可能扮演一个重要的角色。因为它基于多个开放标准，HomeKit与其他设备的集成不会是一个重大的技术挑战。但是，HomeKit
    协议本身并不是开放的，因此实现 HomeKit 设备或应用程序需要成为苹果的 MFi（为iPhone制造）计划的一部分。
- en: Not surprisingly, Google decided to strike back and announced Google Weave in
    2015\. Conceptually, Weave is similar to HomeKit because it provides a protocol
    for an application (for example, a mobile app) to talk to an IoT device built
    on web technologies. But unlike HomeKit, it also specifies a set of cloud APIs
    and supports both Android and iOS devices. At the time of writing, Google Weave
    hasn’t been publicly released but is likely to also play an important role, especially
    in home automation.^([[29](#ch05fn29)])
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，谷歌决定反击，并在2015年宣布了Google Weave。从概念上讲，Weave 与 HomeKit 类似，因为它为应用程序（例如，移动应用程序）提供了一个与基于网络技术的物联网设备通信的协议。但与
    HomeKit 不同，它还指定了一套云 API，并支持 Android 和 iOS 设备。在撰写本文时，Google Weave 尚未公开发布，但可能也会扮演一个重要的角色，尤其是在智能家居领域.^([[29](#ch05fn29)])
- en: ^(29)
  id: totrans-1429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(29)
- en: ''
  id: totrans-1430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://developers.google.com/weave/](https://developers.google.com/weave/)'
  id: totrans-1431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/weave/](https://developers.google.com/weave/)'
- en: 5.3.3\. Message Queuing Telemetry Transport
  id: totrans-1432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3\. 消息队列遥测传输
- en: The Message Queuing Telemetry Transport (MQTT) Application layer protocol was
    invented in 1999 by Andy Stanford-Clark and Arlen Nipper. It was meant as a lightweight
    messaging protocol built on top of TCP/IP that allowed constrained devices with
    limited bandwidth to talk to each other. MQTT did this very well, with implementations
    fitting the constraints of most embedded devices. Over the years, MQTT has become
    an important Application layer protocol for machine-to-machine (M2M) communication.
    See [figure 5.10](#ch05fig10).
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列遥测传输（MQTT）应用层协议是在1999年由 Andy Stanford-Clark 和 Arlen Nipper 发明的。它旨在作为一种轻量级消息协议，建立在
    TCP/IP 之上，允许带宽有限的受限设备相互通信。MQTT 在此方面做得非常好，其实施符合大多数嵌入式设备的限制。多年来，MQTT 已成为机器对机器（M2M）通信的重要应用层协议。参见
    [图 5.10](#ch05fig10)。
- en: Figure 5.10\. Typical protocol stacks for MQTT, MQTT-SN, and CoAP. MQTT is built
    on top of TCP. CoAP is built on top of UDP and usually IPv6 (6LoWPAN). MQTT-SN
    is usually built on top of UDP.
  id: totrans-1434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.10\. MQTT、MQTT-SN 和 CoAP 的典型协议栈。MQTT 建立在 TCP 之上。CoAP 建立在 UDP 之上，通常使用 IPv6（6LoWPAN）。MQTT-SN
    通常建立在 UDP 之上。
- en: '![](05fig10_alt.jpg)'
  id: totrans-1435
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig10_alt.jpg)'
- en: As you’ll learn in the next chapter, MQTT is a publish-subscribe protocol. For
    now, all you need to know is that with MQTT clients *subscribe* to a topic of
    interest and receive notifications whenever a new message for this topic is *published*.
    The publisher and subscribers of messages don’t speak to each other directly but
    through an intermediate called a *broker*. The broker can be deployed locally
    if you only require local communication, or on the internet if the publishers
    and subscribers are not in the same local network.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解到MQTT是一个发布-订阅协议。现在，您需要知道的是，MQTT客户端会*订阅*一个感兴趣的主题，并在为该主题发布新消息时接收通知。消息的发布者和订阅者不会直接交流，而是通过一个称为*代理*的中间件进行交流。如果只需要本地通信，代理可以部署在本地；如果发布者和订阅者不在同一本地网络中，则可以部署在互联网上。
- en: Quality of service
  id: totrans-1437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务质量
- en: 'An interesting feature of MQTT is that it offers three levels of quality of
    service (QoS) to guarantee what a client application can expect when it comes
    to the delivery of messages. Note that this is complementary to the Transport
    layer delivery guarantee of TCP you saw before because it relates to delivery
    between subscribers and publishers at the Application layer. Clients can request
    the following QoS levels from brokers that support them:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT的一个有趣特性是它提供了三个服务质量（QoS）级别，以确保客户端在消息投递方面可以期待什么。请注意，这与您之前看到的TCP传输层投递保证是互补的，因为它与订阅者和发布者之间的应用层投递相关。客户端可以从支持它们的代理请求以下QoS级别：
- en: '***QoS 0: fire and forget—*** A published message might be delivered to the
    subscribers, but this is not guaranteed. Receivers won’t acknowledge a message
    and brokers won’t store or redeliver them.'
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***QoS 0：发射后即忘—*** 已发布的消息可能会被投递给订阅者，但这并不保证。接收者不会确认消息，而代理也不会存储或重新投递它们。'
- en: '***QoS 1: deliver at least once—*** A published message will be delivered at
    least once to the subscribers. This means that if a subscriber temporarily disconnects,
    it will receive the message as soon as it reconnects. An example of the messages
    required for such a connection is shown in [figure 5.11](#ch05fig11).'
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***QoS 1：至少一次投递—*** 已发布的消息至少会投递一次给订阅者。这意味着如果订阅者暂时断开连接，它将在重新连接时立即收到消息。这种连接所需的示例消息如图5.11所示。'
- en: Figure 5.11\. A connection between a client and a broker with QoS 1\. The connection
    is kept open by sending regular `PINGREQ` requests. The frequency of these requests
    depends on a keepalive parameter set by the client. Because MQTT is a protocol
    working on connections that should be kept open, this parameter ensures that both
    the broker and client are connected. If the broker doesn’t receive a `PINGREQ`
    or any other message in 1.5x the keepalive interval, it will close the connection.
  id: totrans-1441
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.11。具有QoS 1的客户端和代理之间的连接。通过发送定期的`PINGREQ`请求来保持连接打开。这些请求的频率取决于客户端设置的keepalive参数。由于MQTT是一个应在连接上保持打开的协议，这个参数确保了代理和客户端都处于连接状态。如果代理在1.5倍的keepalive间隔内没有收到`PINGREQ`或任何其他消息，它将关闭连接。
- en: '![](05fig11.jpg)'
  id: totrans-1442
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](05fig11.jpg)'
- en: '***QoS 2: deliver exactly once—*** A published message will be delivered once—and
    only once—to each subscriber.'
  id: totrans-1443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***QoS 2：精确一次投递—*** 已发布的消息将只投递一次，并且仅投递一次给每个订阅者。'
- en: Persistent connections
  id: totrans-1444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 持久连接
- en: As shown in [figure 5.10](#ch05fig10), MQTT is built on top of TCP and IP. This
    means that all the publication and subscription happens via TPC/IP. But one interesting
    aspect of MQTT is that it keeps the connection between a client and a broker open
    for as long as it can. To maintain this open connection, the client sends regular
    ping requests (`PINGREQ`) to the server, as shown in [figure 5.11](#ch05fig11),
    where a client is connected to a broker with QoS 1.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 如图5.10所示，MQTT建立在TCP和IP之上。这意味着所有发布和订阅都通过TCP/IP进行。但MQTT的一个有趣方面是它尽可能长时间地保持客户端和代理之间的连接打开。为了保持这个打开的连接，客户端会定期向服务器发送ping请求（`PINGREQ`），如图5.11所示，其中客户端通过QoS
    1连接到代理。这些请求的频率取决于客户端设置的keepalive参数。由于MQTT是一个应在连接上保持打开的协议，这个参数确保了代理和客户端都处于连接状态。如果代理在1.5倍的keepalive间隔内没有收到`PINGREQ`或任何其他消息，它将关闭连接。
- en: Security and encryption
  id: totrans-1446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安全性和加密
- en: Security in MQTT works via Transport Layer Security (TLS), the successor of
    SSL that’s used to encrypt traffic on the web. On top of encryption, the broker
    can request a username and password to identify the clients.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT中的安全是通过传输层安全性（TLS）实现的，TLS是用于加密网络流量的SSL的后继者。在加密之上，代理可以请求用户名和密码来识别客户端。
- en: MQTT for tiny devices—MQTT-SN
  id: totrans-1448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用于小型设备的MQTT—MQTT-SN
- en: Even if it was designed to be lightweight, the fact that MQTT maintains permanent
    connections over TCP can be problematic for some devices. This isn’t an issue
    for your Pi, but it could be problematic for resource-constrained devices such
    as the RTOS platforms we talked about in [chapter 4](kindle_split_011.html#ch04).
    In particular, this is clearly a problem for battery-powered devices, because
    keeping a TCP connection open permanently will rapidly drain the battery.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 MQTT 被设计成轻量级，它通过 TCP 维护永久连接的事实对于某些设备来说可能是个问题。这对你的 Pi 来说不是问题，但对于我们在第 4 章中提到的资源受限设备（如
    RTOS 平台）来说可能是个问题。特别是，这对电池供电的设备来说显然是个问题，因为永久保持 TCP 连接开放会迅速耗尽电池。
- en: 'The MQTT world has a protocol with a similar objective: MQTT for Sensor Networks
    (MQTT-SN). MQTT-SN is conceptually similar to MQTT but with two major differences,
    as shown previously in [figure 5.10](#ch05fig10). First, it doesn’t require a
    permanent connection and is built on top of UDP and not TCP, which saves some
    bandwidth—and introduces some limitations, as you’ve seen before. Then, an MQTT-SN
    broker indexes topic names, which are sometimes too long for very-low-bandwidth
    networks. Even though it’s an interesting protocol, MQTT-SN isn’t as popular as
    MQTT or CoAP, and the only full-featured broker freely available to date is the
    Really Small Message Broker provided via the Eclipse foundation.^([[30](#ch05fn30)])'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT 世界有一个具有类似目标的协议：用于传感器网络的 MQTT（MQTT-SN）。MQTT-SN 在概念上与 MQTT 类似，但有两个主要区别，如图
    5.10 所示。首先，它不需要永久连接，并且建立在 UDP 而不是 TCP 之上，这节省了一些带宽——但引入了一些限制，正如你之前看到的。然后，MQTT-SN
    代理索引主题名称，这些名称对于非常低带宽的网络来说有时太长。尽管这是一个有趣的协议，但 MQTT-SN 的普及度不如 MQTT 或 CoAP，迄今为止，唯一免费提供的功能齐全的代理是
    Eclipse 基金会提供的 Really Small Message Broker.^([[30](#ch05fn30)])
- en: ^(30)
  id: totrans-1451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(30)
- en: ''
  id: totrans-1452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://git.eclipse.org/c/mosquitto/org.eclipse.mosquitto.rsmb.git/](http://git.eclipse.org/c/mosquitto/org.eclipse.mosquitto.rsmb.git/)'
  id: totrans-1453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://git.eclipse.org/c/mosquitto/org.eclipse.mosquitto.rsmb.git/](http://git.eclipse.org/c/mosquitto/org.eclipse.mosquitto.rsmb.git/)'
- en: 5.3.4\. Constrained Application Protocol
  id: totrans-1454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4. 限制应用协议
- en: 'Focusing on a footprint acceptable for very limited embedded devices as well
    as saving battery power are among the raisons d’être of the next Application level
    protocol we look at: the Constrained Application Protocol (CoAP).^([[31](#ch05fn31)])
    CoAP is a set of protocol specifications designed to work on embedded devices
    with as little as 10 KB of RAM, and it yields a code footprint of about 100 KB.
    CoAP is also the youngest application protocol we looked at here; it was officially
    released in June 2014.'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于适用于非常有限的嵌入式设备的占地面积以及节省电池电量是下一个我们关注的网络层协议（限制应用协议 CoAP）的几个原因之一。CoAP 是一组旨在在具有至少
    10 KB RAM 的嵌入式设备上运行的协议规范，并产生大约 100 KB 的代码占用空间。CoAP 也是我们在这里看到的最新应用协议；它于 2014 年
    6 月正式发布.^([[31](#ch05fn31)])
- en: ^(31)
  id: totrans-1456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(31)
- en: ''
  id: totrans-1457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://coap.technology/](http://coap.technology/)'
  id: totrans-1458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://coap.technology/](http://coap.technology/)'
- en: UDP for non-persistent connections
  id: totrans-1459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非持久连接的 UDP
- en: The typical stack CoAP, often referred to as “IP for Smart Objects,” differs
    from MQTT in three ways. first, as shown in [figure 5.10](#ch05fig10), CoAP is
    usually used alongside 6LoWPAN at the Network layer. Then, at the Transport layer,
    it uses UDP (just like MQTT-SN), not TCP. This means that CoAP doesn’t maintain
    an open TCP connection and thus requires less power. In practice, though, this
    also means that CoAP is harder to deploy in certain environments. As you’ve seen
    before, UDP poses a number of challenges when combined with Network Address Translation,
    and this won’t likely change until IPv6 is fully deployed; see [section 5.2.1](#ch05lev2sec3).
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 CoAP 栈，通常被称为“智能对象的 IP”，在三个方面与 MQTT 不同。首先，如图 5.10 所示，CoAP 通常在网络层与 6LoWPAN
    一起使用。然后，在传输层，它使用 UDP（就像 MQTT-SN 一样），而不是 TCP。这意味着 CoAP 不维护一个开放的 TCP 连接，因此需要更少的电力。然而，在实践中，这也意味着
    CoAP 在某些环境中部署起来更困难。正如你之前看到的，UDP 在与网络地址转换结合使用时带来了一系列挑战，并且这种情况在 IPv6 完全部署之前不太可能改变；参见[第
    5.2.1 节](#ch05lev2sec3)。
- en: Request/response and Observe
  id: totrans-1461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 请求/响应和观察
- en: CoAP is a request/response protocol implemented on the principles of REST. These
    principles are at the core of the web and the Web of Things and will be discussed
    in great detail in the next chapter. In that respect, CoAP is a very interesting
    protocol, and the concepts you’ll learn in the following chapters will be really
    useful for you to understand both HTTP for Things and CoAP.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: CoAP 是基于 REST 原则实现的请求/响应协议。这些原则是 Web 和物联网的核心，将在下一章中详细讨论。在这方面，CoAP 是一个非常有趣的协议，你将在接下来的章节中学到的概念将对你理解
    HTTP for Things 和 CoAP 非常有用。
- en: In a separate specification called CoAP Observe,^([[32](#ch05fn32)]) the request/response
    paradigm is extended with support for “observing” resources. In short, this means
    you can subscribe to a resource in a similar way to what the pub/sub of MQTT offers.
    But unlike in MQTT, there’s no broker and the Things themselves push the updates
    to the clients. Not relying on an external broker means that every Thing becomes
    both a client and a server, which allows devices to easily and directly communicate
    with each other.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为 CoAP Observe 的单独规范中，^([[32](#ch05fn32)]) 请求/响应范式通过支持“观察”资源得到了扩展。简而言之，这意味着你可以以类似
    MQTT pub/sub 的方式订阅资源。但与 MQTT 不同，没有代理，事物本身将更新推送到客户端。不依赖于外部代理意味着每个事物都既是客户端也是服务器，这使得设备能够轻松直接地相互通信。
- en: ^(32)
  id: totrans-1464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(32)
- en: ''
  id: totrans-1465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/draft-ietf-core-observe/](https://datatracker.ietf.org/doc/draft-ietf-core-observe/)'
  id: totrans-1466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://datatracker.ietf.org/doc/draft-ietf-core-observe/](https://datatracker.ietf.org/doc/draft-ietf-core-observe/)'
- en: 5.3.5\. So, which one should I use?
  id: totrans-1467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.5\. 那么，我应该使用哪一个呢？
- en: HomeKit is a promising protocol that will likely evolve a lot over the next
    few years. But it has the clear limitation of working only within the boundaries
    of the Apple ecosystem. Google Weave has yet to prove what it can do for the IoT.
    MQTT and CoAP are interesting alternatives, but they have two main challenges
    in the context of the Web of Things.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: HomeKit 是一个有潜力的协议，预计在未来几年内会有很大的发展。但它有一个明显的局限性，即只能在苹果生态系统的范围内工作。Google Weave
    还未证明它能为物联网做些什么。MQTT 和 CoAP 是有趣的替代方案，但在物联网架构的背景下，它们面临两个主要挑战。
- en: First, they don’t integrate directly with the web (of browsers). You can’t build
    client-side JavaScript that directly interacts out of the box with CoAP or MQTT.
    That doesn’t mean it’s the end of the story just yet. There are ways to integrate
    both these protocols to the web of browsers directly in the browser by channeling
    MQTT requests over WebSockets or via an HTTP proxy for CoAP. This topic will be
    covered in more detail in [chapter 7](kindle_split_015.html#ch07).
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们不能直接与 Web（浏览器）集成。你不能直接与 CoAP 或 MQTT 交互构建客户端 JavaScript。这并不意味着故事就此结束。有方法可以将这两个协议直接集成到浏览器网络中，通过在
    WebSocket 上中继 MQTT 请求或通过 HTTP 代理为 CoAP。这个主题将在第 7 章中更详细地介绍。
- en: Second, MQTT and CoAP both propose a way to implement an Application level protocol
    for the Internet of Things, but they don’t address the idea of a data model with
    fixed semantics and syntax and the possible interactions. In other words, even
    if you use MQTT, you’ll still need to create your own model for your Things or
    applications. Because this isn’t based on a clearly defined standard, MQTT clients
    need to know in advance the custom model of a given device, which limits ad hoc
    interaction.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，MQTT 和 CoAP 都提出了一种实现物联网应用层协议的方法，但它们没有涉及具有固定语义和语法的数据模型以及可能的交互。换句话说，即使你使用 MQTT，你仍然需要为你的设备或应用程序创建自己的模型。因为这不是基于一个明确定义的标准，MQTT
    客户端需要事先了解特定设备的自定义模型，这限制了即兴交互。
- en: 'Bridging this gap is precisely the objective of the Web of Things: creating
    an application protocol for Things using and reusing Web standards and tools.
    This is what the Web of Things architecture is all about, and the good news is
    that what you’ll learn in the next chapters will also be applicable to other popular
    Application layer protocols such as MQTT and CoAP.'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接这个差距正是物联网架构的目标：使用和重用 Web 标准和工具为事物创建一个应用协议。这正是物联网架构的全部内容，好消息是你在下一章中学到的知识也将适用于其他流行的应用层协议，如
    MQTT 和 CoAP。
- en: 5.4\. The Web of Things architecture
  id: totrans-1472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 物联网架构
- en: As you’ve seen, existing IoT Application layer protocols offer a variety of
    features that are useful for embedded device deployment, from device and service
    discovery to reliable messaging, to ad hoc secure pairing, and so on. Unlike those
    protocols, HTTP and WebSockets alone don’t support these features because they
    weren’t designed for embedded devices. To be truly useful, the Web of Things will
    require those capabilities and also the ability to be easily extended to support
    additional features when needed. In this section, we propose a structured architecture
    for the Web of Things that will form the basis for the rest of the book. This
    architecture will show in practice how web protocols can be extended to support
    all the features we need for building any type of WoT application, while remaining
    truly integrated into the web.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，现有的物联网应用层协议提供了各种对嵌入式设备部署有用的功能，从设备和服务发现到可靠的消息传递，再到即兴安全配对等等。与这些协议不同，HTTP和WebSockets本身并不支持这些功能，因为它们并不是为嵌入式设备设计的。为了真正有用，物联网需要这些功能，并且还需要能够轻松扩展以支持在需要时添加额外功能。在本节中，我们提出了物联网的结构化架构，这将成为本书其余部分的基础。这个架构将实际展示如何扩展Web协议以支持我们构建任何类型WoT应用所需的所有功能，同时真正集成到网络中。
- en: 'Unlike the OSI or the Internet Protocol Stack, the WoT architecture stack is
    not composed of layers in the strict sense but rather of levels that add functionality,
    as shown in [figure 5.12](#ch05fig12). Each layer helps to integrate Things to
    the web even more and hence makes them more accessible for applications and humans.
    The WoT architecture stack starts where the OSI and Internet Protocol Stack ends:
    it looks into all protocols and tools that live at the Application layer and above
    (layer 7 and upward). The powerful implication of this is that you don’t have
    to worry about the underlying layers (1–6), because the Web of Things is concerned
    only with Application layer protocols and what you do with them—not which underlying
    protocols are used.'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 与OSI或互联网协议栈不同，WoT架构栈并不是由严格意义上的层组成，而是由添加功能的水准组成，如图5.12所示。每一层都有助于将事物集成到网络中，从而使它们对应用程序和人类更加易于访问。WoT架构栈从OSI和互联网协议栈结束的地方开始：它探讨所有位于应用层及其以上（第7层及以上）的协议和工具。这一强大的含义是，你不必担心底层（1-6层），因为物联网只关注应用层协议以及你如何使用它们——而不是使用哪些底层协议。
- en: Figure 5.12\. The Web of Things architecture stack^([[33](#ch05fn33)]) with
    its various layers
  id: totrans-1475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.12\. 物联网架构堆栈及其各种层^([[33](#ch05fn33)])
- en: ^(33)
  id: totrans-1476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(33)
- en: ''
  id: totrans-1477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This Web of Things architecture was proposed in Dominique Guinard’s PhD thesis:
    [http://webofthings.org/2011/12/01/phd-web-of-things-app-archi/](http://webofthings.org/2011/12/01/phd-web-of-things-app-archi/).'
  id: totrans-1478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个物联网架构是在Dominique Guinard的博士论文中提出的：[http://webofthings.org/2011/12/01/phd-web-of-things-app-archi/](http://webofthings.org/2011/12/01/phd-web-of-things-app-archi/)。
- en: '![](05fig12_alt.jpg)'
  id: totrans-1479
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig12_alt.jpg)'
- en: The following chapters of this book will describe each layer in detail so you’ll
    have all the tools you need to use those device-specific features for your WoT
    products and applications in a way that maximizes reuse and interoperability.
    Let’s now review the various layers of the WoT architecture and describe their
    purpose; see [figure 5.12](#ch05fig12).
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 本书接下来的章节将详细描述每一层，这样你将拥有所有使用这些特定于设备的特性为你的WoT产品和应用程序提供最大重用和互操作性的工具。现在，让我们回顾WoT架构的各个层，并描述它们的目的；参见[图5.12](#ch05fig12)。
- en: '5.4.1\. Layer 1: Access'
  id: totrans-1481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 层 1：访问
- en: The Access layer is also the most fundamental because it looks into the way
    Things can be connected to the web by offering a web API. This layer is responsible
    for turning any Thing into a programmable web Thing that other devices and applications
    can easily talk to.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 访问层也是最基础的，因为它通过提供Web API来探讨事物如何连接到网络。这一层负责将任何事物转变为可编程的Web事物，其他设备和应用程序可以轻松与之通信。
- en: 'The core idea of this level is simple: Things can be smoothly integrated to
    the web by exposing their services through a RESTful API using HTTP, built on
    top of TCP/IP as well as the JSON data format. The Access level also describes
    how to use WebSockets to accommodate the fact that a number of IoT use cases are
    real-time or event-driven. We’ll look into these aspects in [chapter 6](kindle_split_014.html#ch06).'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层的核心思想很简单：通过使用基于TCP/IP和JSON数据格式的HTTP RESTful API公开其服务，事物可以无缝集成到网络中。访问层还描述了如何使用WebSockets来适应许多物联网用例是实时或事件驱动的这一事实。我们将在第6章中探讨这些方面。[第6章](kindle_split_014.html#ch06)。
- en: Not all Things will be able to speak web protocols or even be connected to the
    internet, but that doesn’t mean those things won’t be part of the Web of Things.
    Thus, we’ll look into the web integration of non-web and non-internet Things using
    several integration patterns such as gateways. These aspects of the Access layer
    are covered in [chapter 7](kindle_split_015.html#ch07).
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有事物都能说网络协议，甚至可能无法连接到互联网，但这并不意味着这些事物不会成为物联网的一部分。因此，我们将探讨使用网关等集成模式将非网络和非互联网事物集成到网络中。这些访问层的方面将在第
    7 章（[chapter 7](kindle_split_015.html#ch07)）中介绍。
- en: '5.4.2\. Layer 2: Find'
  id: totrans-1485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 层次 2：查找
- en: 'Marking things accessible via a web API doesn’t mean a client can “understand”
    what the Thing is, what data or services it offers, and so on. This is the goal
    of the second layer: Find. In this layer we propose an HTTP-based protocol with
    a set of resources, data models, payload syntax, and semantic extensions that
    web Things and applications should follow. This layer ensures that your device
    can not only be easily used by other HTTP clients butcan also be findable and
    automatically usable by other WoT applications. The approach here is to reuse
    web semantic standards to describe things and their services. This enables searching
    for things through search engines and other web indexes as well as the automatic
    generation of user interfaces or tools to interact with Things. At this level,
    we also describe Semantic Web technologies such as JSON-LD and HTML5 microdata
    and their integration into the API of Things. These topics will be covered in
    [chapter 8](kindle_split_016.html#ch08).'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络 API 访问事物并不意味着客户端可以“理解”事物是什么，它提供哪些数据或服务，等等。这是第二层的目标：查找。在这个层次上，我们提出一个基于 HTTP
    的协议，包括一系列资源、数据模型、有效载荷语法和语义扩展，网络事物和应用程序应该遵循。这一层确保您的设备不仅可以被其他 HTTP 客户端轻松使用，还可以被其他
    WoT 应用程序找到并自动使用。这里的方法是重用网络语义标准来描述事物及其服务。这使您可以通过搜索引擎和其他网络索引来搜索事物，以及自动生成用户界面或工具来与事物交互。在这个层面，我们还描述了语义网络技术，如
    JSON-LD 和 HTML5 微数据，以及它们如何集成到事物 API 中。这些主题将在第 8 章（[chapter 8](kindle_split_016.html#ch08)）中介绍。
- en: '5.4.3\. Layer 3: Share'
  id: totrans-1487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3\. 层次 3：共享
- en: The Web of Things is largely based on the idea of Things pushing data to the
    web, where more intelligence and big-data techniques can be applied—for example,
    to help us manage our health or optimize our energy consumption. But this can
    only happen in a large-scale way if some of the data can be efficiently—and securely—shared
    across services. This is the responsibility of the Share layer, which specifies
    how the data generated by Things can be shared in an efficient and secure manner
    over the web.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网在很大程度上基于事物将数据推送到网络的理念，在那里可以应用更多的智能和大数据技术——例如，帮助我们管理健康或优化能源消耗。但只有当一些数据可以高效且安全地在服务之间共享时，这才能以大规模的方式发生。这是
    Share 层的责任，它规定了事物生成数据如何在网络上以高效和安全的方式共享。
- en: At this level, we look into applying fine-grained sharing mechanisms on top
    of RESTful APIs. We also look at delegated web authentication mechanisms and integrate
    OAuth to our Things’ APIs. Finally, we discuss implementing the Social Web of
    Things by using social networks to share Things and their resources. We cover
    these topics in [chapter 9](kindle_split_017.html#ch09).
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层面，我们探讨在 RESTful API 之上应用细粒度共享机制。我们还研究了委托网络身份验证机制，并将 OAuth 集成到我们的事物 API 中。最后，我们讨论通过使用社交网络来共享事物及其资源来实现社交物联网。这些主题将在第
    9 章（[chapter 9](kindle_split_017.html#ch09)）中介绍。
- en: '5.4.4\. Layer 4: Compose'
  id: totrans-1490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.4\. 层次 4：组合
- en: Finally, once Things are on the web (layer 1) where they can be found by humans
    and machines (layer 2) and their resources can be shared securely with others
    (layer 3), it’s time to look at how to build large-scale, meaningful applications
    for the Web of Things. In other words, we need to understand the integration of
    data and services from heterogeneous Things into an immense ecosystem of web tools
    such as analytics software and mashup platforms. The goal of the Compose layer
    is to make it even simpler to create applications involving Things and virtual
    web services.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦事物被放置在网络上（层次 1），人类和机器都可以找到它们（层次 2），并且它们的资源可以安全地与其他人共享（层次 3），那么就是时候考虑如何构建大规模、有意义的物联网应用了。换句话说，我们需要理解来自异构事物的数据和服务如何整合到一个庞大的网络工具生态系统，例如分析软件和混合平台。Compose
    层的目标是使创建涉及事物和虚拟网络服务的应用变得更加简单。
- en: Tools at the Compose layer range from web toolkits—for example, JavaScript SDKs
    offering higher-level abstractions—to dashboards with programmable widgets, and
    finally to physical mashup tools such as Node-RED. Inspired by Web 2.0 participatory
    services and in particular web mashups, the physical mashups offer a unified view
    of the classical web and Web of Things and empower people to build applications
    using Web of Things services without requiring programming skills. We’ll look
    at this level in [chapter 10](kindle_split_018.html#ch10).
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 组合层上的工具从网络工具包——例如提供高级抽象的JavaScript SDKs——到可编程小部件的仪表板，最后到物理混合工具，如Node-RED。受到Web
    2.0参与式服务和特别是Web混合的启发，物理混合工具提供了一个对经典互联网和物联网的统一视图，并赋予人们使用物联网服务构建应用程序的能力，而无需编程技能。我们将在[第10章](kindle_split_018.html#ch10)中探讨这一层。
- en: 5.4.5\. Why does the WoT matter?
  id: totrans-1493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.5\. 物联网为什么重要？
- en: The good news is that on the Web of Things you needn’t care about how various
    devices talk to each other physically, or at the Network layer. Just like on the
    web, you don’t need to worry about whether your phone uses 4G or Wi-Fi to fetch
    a web page. All you need to care about in the Web of Things is that those devices
    share a common set of languages that allows them to communicate at the Application
    level regardless of the way they’re networked. By layering the well-known web
    standards on top of the myriad of networking protocols in use, you’re enabling
    any device and application across any network to talk to each other and exchange
    data in a standard and meaningful way. In short, the Web of Things is agnostic
    to anything below the Application layer, so that any device can be part of the
    universal Web of Things regardless of what protocol(s) it uses connects to the
    internet.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，在物联网的网络上，你不需要关心各种设备如何物理上相互通信，或者在网络层。就像在互联网上一样，你不需要担心你的手机是用4G还是Wi-Fi来获取网页。在物联网中，你只需要关心这些设备共享一套通用的语言，使得它们能够在应用层进行通信，无论它们的网络连接方式如何。通过在众多网络协议之上叠加已知的网络标准，你使得任何网络上的设备和应用都能以标准且有意义的方式相互通信和交换数据。简而言之，物联网对应用层以下的所有内容都是中立的，因此任何设备都可以成为通用物联网的一部分，无论它使用什么协议连接到互联网。
- en: 'As you’ve also learned, a number of Application layer protocols have been proposed
    for the IoT, but none can be considered “The One.” The premise of the WoT is different:
    instead of creating yet another protocol from scratch, why not reuse and adapt
    something widely popular and universally supported, like the web? The architecture
    we proposed for the Web of Things in [section 5.4](#ch05lev1sec4) puts this exact
    idea in practice: have a single uniform architecture for the Web of Things that
    any WoT device, service, or application can use to talk to each other. How this
    can be done is what the remainder of this book will teach you.'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所学到的，已经提出了许多应用层协议用于物联网，但没有一个可以被看作是“唯一”的。物联网的前提不同：与其从头开始创建另一个协议，为什么不重用和适应那些广泛流行且普遍支持的，比如互联网？我们在[第5.4节](#ch05lev1sec4)中提出的物联网架构正是将这个想法付诸实践：为物联网提供一个单一的统一架构，任何物联网设备、服务或应用都可以使用它来相互通信。这本书的剩余部分将教你如何实现这一点。
- en: 5.4.6\. Beyond the book
  id: totrans-1496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.6\. 超越书籍
- en: What you’ve certainly realized is that a single universal protocol stack to
    rule them all is both unrealistic and impractical. Certain protocol stacks are
    much better suited for some scenarios than others, and compromising on those doesn’t
    make sense, especially for commercial use cases. If you were to remember one thing
    about this chapter, it would be to ensure that you choose protocols that play
    well with the internet. It seems like a pretty obvious statement when working
    on building the Internet of Things, but the more straightforward the integration,
    the easier it will be to develop and deploy your product.
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定已经意识到，一个单一的通用协议栈来统治一切既不现实也不实用。某些协议栈在某些场景下比其他场景更适合，对这些妥协没有意义，尤其是在商业用例中。如果你要记住本章的一个要点，那就是确保你选择与互联网兼容的协议。当你在构建物联网时，这似乎是一个相当明显的声明，但集成越直接，开发和应用你的产品就会越容易。
- en: The arena of IoT protocols is likely to remain a hodgepodge of old, new, and
    incompatible protocols for many years to come—the battle is far from being over!
    You should follow the upcoming developments in this field. A good place to start
    is the IPSO (Internet Protocol for Smart Objects) Alliance,^([[34](#ch05fn34)])
    a consortium of powerful players promoting the use of internet protocols on embedded
    devices. Also make sure you follow the Thread Group,^([[35](#ch05fn35)]) which
    is actively looking at creating a clean and operational IoT protocol stack up
    to the Network layer. You should also take a closer look at the AllSeen Alliance^([[36](#ch05fn36)])
    and the OIC (Open Interconnect Consortium),^([[37](#ch05fn37)]) which are becoming
    increasingly popular.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网协议领域很可能会在许多年内继续是旧、新和不兼容协议的混合体——战斗远未结束！你应该关注这个领域的未来发展。一个好的起点是IPSO（智能对象互联网协议）联盟^([[34](#ch05fn34)]),一个强大的参与者联盟，推广在嵌入式设备上使用互联网协议。还请确保关注Thread
    Group^([[35](#ch05fn35)]),它正在积极研究创建一个干净且可操作的物联网协议栈，直至网络层。你还应该更仔细地研究AllSeen Alliance^([[36](#ch05fn36)])和OIC（开放互连联盟）^([[37](#ch05fn37)]),它们正变得越来越受欢迎。
- en: ^(34)
  id: totrans-1499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(34)
- en: ''
  id: totrans-1500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.ipso-alliance.org/](http://www.ipso-alliance.org/)'
  id: totrans-1501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.ipso-alliance.org/](http://www.ipso-alliance.org/)'
- en: ^(35)
  id: totrans-1502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(35)
- en: ''
  id: totrans-1503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://threadgroup.org/](http://threadgroup.org/)'
  id: totrans-1504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://threadgroup.org/](http://threadgroup.org/)'
- en: ^(36)
  id: totrans-1505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(36)
- en: ''
  id: totrans-1506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://allseenalliance.org/](https://allseenalliance.org/)'
  id: totrans-1507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://allseenalliance.org/](https://allseenalliance.org/)'
- en: ^(37)
  id: totrans-1508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(37)
- en: ''
  id: totrans-1509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://openinterconnect.org/](http://openinterconnect.org/)'
  id: totrans-1510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://openinterconnect.org/](http://openinterconnect.org/)'
- en: 5.5\. Summary
  id: totrans-1511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5. 摘要
- en: There are various models for classifying network topologies and protocols, and
    they help us compare and contrast various tools and use cases commonly used in
    the IoT.
  id: totrans-1512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在着各种用于分类网络拓扑和协议的模型，它们帮助我们比较和对比物联网中常用的一系列工具和用例。
- en: The IoT today is a hodgepodge of protocols, and few of them are based on the
    Internet Protocol suite.
  id: totrans-1513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天的物联网是一个由各种协议组成的混合体，其中很少是基于互联网协议套件的。
- en: Some popular IoT protocols have been designed specifically for the constraints
    of embedded devices—low power or bandwidth, for example—and therefore require
    specifically designed gateways to be connected to the internet.
  id: totrans-1514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些流行的物联网协议是专门为嵌入式设备的限制条件设计的——例如低功耗或带宽——因此需要特别设计的网关才能连接到互联网。
- en: There are also various Applications layer protocols for the IoT that can’t be
    easily integrated with one another. These protocols offer additional capabilities
    that are desirable for IoT applications, such as real-time push, device discovery,
    and so on.
  id: totrans-1515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于物联网，也存在各种应用层协议，它们之间难以轻松集成。这些协议提供了物联网应用所期望的额外功能，例如实时推送、设备发现等。
- en: The Web of Things helps maximize interoperability across various physical networks.
  id: totrans-1516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网帮助最大程度地提高各种物理网络之间的互操作性。
- en: Web technologies are widely popular and offer all the flexibility and features
    needed for the majority of IoT applications, including discovery, security, and
    real-time push.
  id: totrans-1517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络技术非常流行，并为大多数物联网应用提供了所需的灵活性和功能，包括发现、安全和实时推送。
- en: The WoT architecture stack organizes the variety of tools, techniques, and standards
    commonly used on the web so they form a complete framework on which to build IoT
    systems that are natively part of the web.
  id: totrans-1518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网架构堆栈组织了在网络上常用的一系列工具、技术和标准，以便它们形成一个完整的框架，用于构建物联网系统，这些系统是网络的原生部分。
- en: If you’re new to IoT and networking, no doubt this chapter was a tough one.
    It certainly didn’t turn you into an IoT networking protocol expert, but at least
    it equipped you with a solid overview of the variety of technologies that can
    be used to build networked devices. If you have to deal with hardware and/or infrastructure,
    knowing which protocol is good for which use case will definitely help you choose
    the right tools for your next project.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触物联网和网络，毫无疑问，这一章对你来说是一个挑战。它当然没有让你变成物联网网络协议专家，但至少它为你提供了构建网络设备所需的各种技术的坚实基础概述。如果你必须处理硬件和/或基础设施，了解哪种协议适用于哪种用例将肯定有助于你为下一个项目选择合适的工具。
