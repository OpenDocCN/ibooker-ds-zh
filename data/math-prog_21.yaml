- en: appendix B. Python tips and tricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. Python 技巧与窍门
- en: After following the set-up instructions in appendix A, you should be able to
    run Python code on your computer. If you’re new to Python, the next step is to
    learn some of the language features. If you haven’t seen *any* Python before,
    don’t sweat! It’s one of the simplest and easiest-to-learn programming languages
    out there. Plus, there are many excellent online resources and books to help you
    learn the basics of Python programming, and the website [python.org](https://www.python.org/)
    is a great starting point.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循附录 A 中的设置说明后，你应该能够在你的计算机上运行 Python 代码。如果你是 Python 新手，下一步是学习一些语言特性。如果你以前从未见过
    *任何* Python，不要担心！它是目前最简单、最容易学习的编程语言之一。此外，还有许多优秀的在线资源和书籍可以帮助你学习 Python 编程的基础知识，而
    [python.org](https://www.python.org/) 是一个很好的起点。
- en: 'This appendix assumes you’ve tinkered around with Python a bit and are comfortable
    with the basics: numbers, strings, True and False, if/else statements, and so
    on. To make this book as accessible as possible, I’ve avoided using advanced Python
    language features. This appendix covers some Python features used in this book
    that are either beyond the “basics” or warrant special attention because of their
    importance in this book. Don’t worry if this is a lot to digest; when these features
    appear in the book, I often include a quick review of how they work. All of the
    code in this appendix is covered in a “walkthrough” notebook in the source code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录假设你已经对 Python 进行了一些实验，并且对基础知识（如数字、字符串、True 和 False、if/else 语句等）感到舒适。为了使这本书尽可能易于理解，我避免了使用高级
    Python 语言特性。本附录涵盖了本书中使用的某些 Python 特性，这些特性要么超出了“基础知识”，要么因为它们在本书中的重要性而需要特别关注。如果你觉得这些内容太多，不要担心；当这些特性在书中出现时，我通常会包括一个快速回顾它们是如何工作的。本附录中的所有代码都在源代码中的“walkthrough”笔记本中进行了覆盖。
- en: B.1 Python numbers and math
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 Python 数字和数学
- en: 'Like most languages, Python has built-in support for basic math. I’ll assume
    you’re already familiar with the basic Python arithmetic operators: `+`, − , `*`,
    and `/`. Note that when you divide integers in Python 3, you can get a fractional
    value, for instance,'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，Python 内置了对基本数学的支持。我假设你已经熟悉了基本的 Python 算术运算符：`+`、`-`、`*` 和 `/`。请注意，在
    Python 3 中，当你除以整数时，你可以得到一个分数值，例如，
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By contrast, in Python 2, this would have returned `2`, which is the result
    of whole number division with the remainder of 1 discarded. But sometimes we want
    to get a remainder, in which case, we can use the `%` operator, called the *modulus*
    operator. Running `13 % 5` returns 3, which tells us that 13 divided by 5 has
    remainder 3 (as in 13 = 2 × 5 + 3). Note also that the modulus operator works
    for floating-point numbers. In particular, you can use it to get the fractional
    part of a number as the remainder when dividing by 1\. Running `3.75 % 1` returns
    `0.75`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，在 Python 2 中，这将返回 `2`，这是整数除法的结果，余数 1 被丢弃。但有时我们想要得到余数，在这种情况下，我们可以使用 `%`
    运算符，称为 *模数* 运算符。运行 `13 % 5` 返回 3，这告诉我们 13 除以 5 的余数是 3（即 13 = 2 × 5 + 3）。请注意，模数运算符也适用于浮点数。特别是，你可以用它来获取一个数的分数部分作为除以
    1 时的余数。运行 `3.75 % 1` 返回 `0.75`。
- en: Another useful operator beyond the basic four is the `**` operator, which raises
    numbers to a given power. For instance, `2 ** 3` represents two to the third power,
    or two cubed, which is 8\. Similarly, `4 ** 2` is four squared, which is 16.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的前四个运算符之外，还有一个有用的运算符是 `**` 运算符，它可以将数字提升到指定的幂。例如，`2 ** 3` 表示 2 的三次幂，即 2 的立方，等于
    8。同样，`4 ** 2` 是 4 的平方，等于 16。
- en: 'A final thing to keep in mind when doing math in Python is that floating-point
    arithmetic is not exact. I won’t go into why this is, but will show you what it
    looks like so you aren’t caught by surprise. For instance, 1000.1 − 1000.0 is
    obviously 0.1, but Python doesn’t compute this value exactly:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中进行数学运算时，还需要注意的一点是浮点数运算不是精确的。我不会深入解释为什么是这样，但我会向你展示它看起来是什么样子，这样你就不会感到意外。例如，1000.1
    - 1000.0 显然是 0.1，但 Python 并没有精确地计算这个值：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, this result is within one-trillionth of the correct answer so it
    won’t cause us problems, but it can lead to results that look wrong at first glance.
    For instance, we expect (1000.1 − 1000.0) − 0.1 to be zero, but Python gives us
    a big, hairy-looking result instead:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个结果与正确答案相差一万亿分之一，所以它不会给我们带来问题，但它可能导致看起来不正确的结果。例如，我们期望 (1000.1 - 1000.0)
    - 0.1 等于零，但 Python 给我们一个庞大、复杂的看起来不正确的结果：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This long number is written in scientific notation and is roughly 2.27 times
    10^(−14) power. The number 10^(−14) is the same as 1/100,000,000,000,000 (1 over
    1 followed by 14 zeros or 1 over 100 trillion), so this number is very close to
    zero after all.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长数字用科学记数法表示，大约是 2.27 乘以 10 的负 14 次方。10 的负 14 次方等同于 1/100,000,000,000,000（1
    除以后面跟着 14 个零，或者 1 除以 100 万亿），所以这个数字实际上非常接近于零。
- en: B.1.1 The math module
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.1 数学模块
- en: Python has a math module with more helpful mathematical values and functions.
    Like any Python module, you need to import the objects you want to use from it.
    For instance,
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个包含更多有用数学值和函数的数学模块。像任何 Python 模块一样，你需要从其中导入你想要使用的对象。例如，
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'imports the variable `pi` from the `math` module, which represents the number
    *π*. You may remember *π* from geometry class; it’s the ratio of the circumference
    of a circle to its diameter. With the value `pi` imported, we can use it in subsequent
    code like any other variable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `math` 模块导入变量 `pi`，它代表数字 *π*。你可能还记得从几何课上学到的 *π*；它是圆周长与其直径的比值。导入 `pi` 值后，我们可以在后续代码中像使用任何其他变量一样使用它：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another way to access values from modules in Python is to import the module
    itself and then access the values as needed. Here I import the math module and
    then use it to access the number *π* and another special number *e* that we’ll
    run into a few times.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中访问模块中的值的另一种方法是导入模块本身，然后根据需要访问值。在这里，我导入了 math 模块，然后使用它来访问数字 *π* 和我们将在几处遇到的另一个特殊数字
    *e*。
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The math module also contains a number of important functions we’ll use in
    the book. Among these are the square root function `sqrt`, the trigonometric functions
    `cos` and `sin`, the exponential function `exp`, and the natural logarithm function
    `log`. We’ll go over each of these functions as needed, but the important thing
    to know for now is that you call them like ordinary Python functions, providing
    their input values in parentheses:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数学模块还包含了一些我们在书中会用到的非常重要的函数。其中就包括平方根函数 `sqrt`，三角函数 `cos` 和 `sin`，指数函数 `exp` 和自然对数函数
    `log`。我们将在需要时逐一介绍这些函数，但你现在需要知道的重要一点是，你可以像调用普通的 Python 函数一样调用它们，在括号中提供它们的输入值：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As a quick reminder about exponential functions, `math.exp(x)` is the same as
    `math.e` `**` `x`, for any value of `x`, and the `math.log` function undoes the
    effect of `math.exp`. The trigonometric functions are introduced in chapter 2.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对指数函数的快速提醒，`math.exp(x)` 对于任何 `x` 的值都等同于 `math.e` 的 `**` `x`，`math.log` 函数可以取消
    `math.exp` 的效果。三角函数在第 2 章中介绍。
- en: B.1.2 Random numbers
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.2 随机数
- en: 'Sometimes we want to choose some arbitrary numbers to test our computations,
    and we can use Python’s random number generators to do this. These are stored
    in the `random` module, so we need to import that first:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们想要选择一些任意的数字来测试我们的计算，我们可以使用 Python 的随机数生成器来做这件事。这些生成器存储在 `random` 模块中，因此我们首先需要导入它：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first important function in this module is `randint`, which returns a randomly
    selected floating-point value from a given range. If you run `random.randint(0,10)`,
    you get a randomly selected integer from 0 to 10, and both 0 and 10 are possible
    outputs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块中第一个重要的函数是 `randint`，它从一个给定的范围内返回一个随机选择的浮点数。如果你运行 `random.randint(0,10)`，你将得到一个从
    0 到 10 的随机选择的整数，0 和 10 都是可能的输出：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The other function we use for generating random numbers is `random.uniform`,
    which generates a random floating-point number on a specified interval. The following
    code returns a randomly selected number between 7.5 and 9.5:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于生成随机数的另一个函数是 `random.uniform`，它在指定的区间内生成一个随机浮点数。以下代码返回一个在 7.5 和 9.5 之间的随机选择的数字：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The word *uniform* indicates that no subrange is more likely than any other.
    By contrast, if you picked people at random and returned their ages, you would
    get a *non-uniform* distribution of random numbers, meaning you’d find more far
    people between ages 10-20 than between ages 100-110.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 词语 *uniform* 表示没有任何子范围比其他子范围更有可能。相比之下，如果你随机挑选人群并返回他们的年龄，你会得到一个 *非均匀* 的随机数分布，这意味着你会在
    10-20 岁之间找到比在 100-110 岁之间更多的人。
- en: B.2 Collections of data in Python
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 Python 中的数据集合
- en: Throughout this book, we do math involving *collections* of data. These can
    be ordered pairs of numbers representing points in the plane, lists of numbers
    representing measured data from the real world, or sets of symbols in an algebraic
    expression. Python has a number of ways to model collections, and in this section,
    I’ll introduce them and compare them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们处理涉及 *集合* 的数学。这些可以是表示平面中点的有序数对、表示来自现实世界的测量数据的数字列表，或者代数表达式中的符号集合。Python
    有多种方式来模拟集合，在本节中，我将介绍它们并进行比较。
- en: B.2.1 Lists
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.1 列表
- en: 'The most basic collection in Python is the list. To create a list, simply enclose
    some values between square brackets and separate them by commas. Here’s a list
    of three strings, saved as a variable called `months` :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中最基本的集合类型是列表。要创建一个列表，只需在方括号内包围一些值并用逗号分隔它们即可。以下是一个包含三个字符串的列表，保存为名为 `months`
    的变量：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can retrieve an entry from a list by its index (plural, *indices*) or its
    numerical position in the list. In Python, lists are *zero-indexed* , meaning
    the entries are numbered, counting from zero instead of from one. In the `months`
    list, the three indices are 0, 1, and 2\. Therefore, we can get
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引（复数，*indices*）或列表中的数值位置来检索列表中的条目。在 Python 中，列表是 *零索引* 的，这意味着条目是编号的，从零开始计数而不是从一。在
    `months` 列表中，三个索引是 0、1 和 2。因此，我们可以得到
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Attempting to access an entry of a list outside the range of valid indices returns
    an error. For example, there’s no `months[3]` or `months[17]`. A trick I use in
    a few places in the book is to use the modulus operator on indices to guarantee
    a valid entry. For any Python integer `n`, the expression `months[n % 3]` is guaranteed
    to be valid because `n % 3` always returns `0`, `1`, or `2`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问超出有效索引范围的列表条目会返回一个错误。例如，没有 `months[3]` 或 `months[17]`。我在书中的一些地方使用了一个技巧，即对索引使用取模运算符以确保有效的条目。对于任何
    Python 整数 `n`，表达式 `months[n % 3]` 总是有效的，因为 `n % 3` 总是返回 `0`、`1` 或 `2`。
- en: Another way to access list entries is to *unpack* them. If we are sure there
    are three entries in the list of months, we can write
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种访问列表条目的方式是 *解包* 它们。如果我们确信月份列表中有三个条目，我们可以写
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which sets the variables `j`, `f`, and `m` equal to the three values from `months`
    in order. After running this, we have
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变量 `j`、`f` 和 `m` 分别设置为 `months` 中的三个值。运行此代码后，我们有
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another basic thing we can do with lists is *concatenate* them or combine them
    in order to make a bigger list. In Python, this is done with the + operator. Concatenating
    `[1,` `2,` `3]` and `[4,` `5,` `6]` gives us a new list consisting of the entries
    of the first followed by the entries of the second:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用列表的 *连接* 或按顺序组合它们来做的另一件基本事情。在 Python 中，这是通过 + 运算符完成的。将 `[1,` `2,` `3]`
    和 `[4,` `5,` `6]` 连接起来，我们得到一个新列表，其条目顺序是第一个列表的条目后跟第二个列表的条目：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More list indexing and slicing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更多列表索引和切片
- en: Python also lets you extract a *slice* of a list, which is the list of all values
    between two indices. For instance,
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还允许你从列表中提取一个 *切片*，即两个索引之间的所有值的列表。例如，
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'gives the slice starting at index 1 and going up to (but not including) index
    3\. For an even clearer example, we can look at a list whose entries are equal
    to their corresponding indices:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给出从索引 1 开始到（但不包括）索引 3 的切片。为了更清楚地说明，我们可以看看一个条目等于其对应索引的列表：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The length of a list can be computed with the `len` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的长度可以用 `len` 函数来计算：
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because the entries of a list are indexed starting from zero, the last entry
    in a list has index one less than the length of the list. To get the last entry
    of a list (like `nums`), we can write
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表的条目是从零开始索引的，所以列表中的最后一个条目的索引比列表长度少一。要获取列表（如 `nums`）的最后一个条目，我们可以写
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To get the last entry of a list, you can also use
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取列表的最后一个条目，你也可以使用
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Likewise, `nums[-2]` returns the second-to-last entry of the `nums` list, which
    is `9`. There are many ways to combine positive and negative indices and slices.
    For instance, `nums[1:]` returns all entries of the list except the first (at
    index zero), and `nums[3:-1]` returns the entries of `nums` from index 3 up until
    the second to last entry:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`nums[-2]` 返回 `nums` 列表的倒数第二个条目，即 `9`。组合正负索引和切片的方式有很多种。例如，`nums[1:]` 返回列表中除了第一个条目（索引为零）之外的所有条目，而
    `nums[3:-1]` 返回从索引 3 开始直到倒数第二个条目的 `nums` 中的条目：
- en: '[PRE20]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Make sure not to confuse the slice syntax, which involves two indices, with
    retrieving an entry from a list of lists, which also involves two indices. With
    a list like
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要混淆涉及两个索引的切片语法，与从列表中检索条目，这也涉及两个索引。对于一个像这样的列表
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: the number 8 is in the third list (index 2) and it’s the second entry (index
    1) in that list, so if we run `list_of_lists[2][1]` we get `8`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数字8位于第三个列表（索引2）中，并且是该列表中的第二个条目（索引1），因此如果我们运行`list_of_lists[2][1]`，我们得到`8`。
- en: Iterating over a list
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代列表
- en: 'Often when we’re computing something about a list, we want to use every value
    in it. That means *iterating* over the list, visiting all of its values. The easiest
    way to do this in Python is with a *for loop*. The following `for` loop prints
    a statement for each value in the `months` list:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 经常当我们对列表进行计算时，我们希望使用列表中的每个值。这意味着*迭代*列表，访问其所有值。在Python中，最简单的方法是使用*for循环*。以下`for`循环为`months`列表中的每个值打印一条语句：
- en: '[PRE22]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It’s also possible to build a new list by starting with an empty list and successively
    adding entries to it using the `append` method. This next code creates an empty
    list called `squares` and then loops over the `nums` list, adding the square of
    each number in `nums` to the `squares` list by calling `squares.append` :'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过从空列表开始，并使用`append`方法逐个添加条目来构建一个新的列表。以下代码创建了一个名为`squares`的空列表，然后遍历`nums`列表，通过调用`squares.append`将`nums`列表中每个数的平方添加到`squares`列表中：
- en: '[PRE23]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By the end of the `for` loop, `squares` contain the square of every number
    in `nums` :'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到`for`循环结束时，`squares`包含`nums`中每个数的平方：
- en: '[PRE24]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: List comprehensions
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式
- en: 'Python has a special syntax for iteratively building lists: the *list comprehension*.
    A list comprehension is essentially a special kind of `for` loop that lives between
    square brackets, indicating that list entries are being added at each step of
    the iteration. List comprehensions read like plain English, making it easy to
    understand what they are doing. For instance, the following list comprehension
    builds a list consisting of squares of the form `x` `*` `x` for every value `x`
    in the `nums` list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一种特殊的语法来迭代构建列表：*列表推导式*。列表推导式本质上是一种特殊的`for`循环，它位于方括号之间，表示在迭代的每一步中添加列表条目。列表推导式读起来像普通的英语，这使得理解它们的作用变得容易。例如，以下列表推导式构建了一个由`nums`列表中每个值`x`的平方`x
    * x`组成的列表：
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It’s possible to iterate over multiple source lists in a list comprehension.
    For instance, the following code loops over all possible values from both a `years`
    list and a `months` list, making every combination of a year and a month into
    a string:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表推导式中，可以迭代多个源列表。例如，以下代码遍历`years`列表和`months`列表的所有可能值，将每个年份和月份的组合转换为字符串：
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, we can build a list of lists by putting one comprehension inside
    of another. Adding one more pair of square brackets, we change the comprehension
    to return a list for each value in the `months` list:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过将一个推导式放入另一个推导式中来构建一个列表的列表。通过添加另一对方括号，我们将推导式更改为对`months`列表中的每个值返回一个列表：
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: B.2.2 Other iterables
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.2 其他可迭代对象
- en: 'In Python, and especially in Python 3.*x*, there are a few other types of collections.
    In particular, some of these are referred to as *iterables* because we can iterate
    over them as if they were lists. Probably the most frequently used in this book
    are *ranges* , which are used to construct sequences of numbers in order. For
    instance, `range(5,10)` represents the sequence of integers starting from 5 and
    going up to (but not including) 10\. If you evaluate `range(5,10)` on its own
    in Python, the result is unexciting:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，尤其是在Python 3.*x*中，还有一些其他类型的集合。特别是，其中一些被称为*可迭代*，因为我们可以像列表一样迭代它们。在这本书中，最常用的是*范围*，它用于按顺序构建数字序列。例如，`range(5,10)`表示从5开始到（但不包括）10的整数序列。如果你在Python中单独评估`range(5,10)`，结果可能并不令人兴奋：
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Even though a range doesn’t display the numbers that make it up, we can iterate
    over it just like a list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管范围没有显示组成它的数字，但我们仍然可以像列表一样迭代它：
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The fact that ranges are not lists allows us to use very big ranges and not
    iterate over them all at once. For instance, `range(0,1000000000)` defines a range
    of a billion numbers that we could iterate over, but it doesn’t actually store
    a billion numbers. It only stores the instructions to produce the numbers during
    an iteration. If you want to turn an iterable like a `range` into a list, all
    you have to do is convert it with the `list` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于范围不是列表，这允许我们使用非常大的范围，而无需一次性迭代它们。例如，`range(0,1000000000)`定义了一个包含十亿个数字的范围，我们可以迭代这些数字，但实际上它并没有存储十亿个数字。它只存储了在迭代过程中产生数字的指令。如果你想将一个可迭代的范围转换为列表，你只需要使用`list`函数将其转换：
- en: '[PRE30]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It’s useful to get lists of consecutive integers, so we use the `range` function
    a lot. One more note about the `range` function is that some of its arguments
    are optional. If you call it with only one input, it automatically starts from
    zero and goes up to the input number, and if you provide a third argument it counts
    by that number. For instance, `range(10)` counts from 0 to 9 and `range(0,10,3)`
    counts from 0 to 9 in increments of 3:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 获取连续整数的列表很有用，所以我们经常使用 `range` 函数。关于 `range` 函数的另一个注意事项是，它的某些参数是可选的。如果你只提供一个输入调用它，它将自动从零开始，并增加到输入的数字，如果你提供一个第三个参数，它将按该数字计数。例如，`range(10)`
    从 0 计数到 9，而 `range(0,10,3)` 以 3 的增量从 0 计数到 9：
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another example of a function that returns its own special type of iterable
    is the `zip` function. The `zip` function takes two iterables of the same length
    and returns an iterable consisting of pairs of corresponding entries from the
    first and second iterable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个返回其自身特殊类型可迭代对象的函数示例是 `zip` 函数。`zip` 函数接受两个长度相同的可迭代对象，并返回一个由第一和第二个可迭代对象中对应条目组成的可迭代对象：
- en: '[PRE32]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that not all iterables support indexing; `z[2]` is invalid, so you’ll need
    to convert it to a list first (like `list(z)[2]` instead) to get the third entry
    of a `zip z`. (Ranges do support indexing, and `range(5,10)[3]` returns 8.) Be
    careful−once you’ve iterated through a `zip` it is no longer there! It’s a good
    idea to convert a `zip` to a list immediately if you plan to reuse it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有可迭代对象都支持索引；`z[2]` 是无效的，因此你需要先将其转换为列表（例如 `list(z)[2]`），才能获取 `zip z` 的第三个条目。（范围支持索引，`range(5,10)[3]`
    返回 8。）小心 - 一旦迭代过 `zip`，它就不再存在了！如果你打算重复使用它，立即将其转换为列表是个好主意。
- en: B.2.3 Generators
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.3 生成器
- en: Python’s *generators* give you a way to create iterables that don’t store all
    of their values at once, but rather store instructions to produce values. This
    allows us to define large or even infinite sequences of values without storing
    them in memory. Generators can be created in a few ways, the most basic of which
    looks like a function with the keyword `yield` instead of `return`. The difference
    is that a generator can yield many values, where as a function returns at most
    once and then is done.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 *生成器* 给你一种创建不一次性存储所有值，而是存储生成值的可迭代对象的方法。这允许我们定义大型甚至无限序列的值，而无需在内存中存储它们。生成器可以通过几种方式创建，其中最基本的方式看起来像是一个带有
    `yield` 关键字而不是 `return` 的函数。区别在于生成器可以产生多个值，而函数最多返回一次然后结束。
- en: Here’s a generator representing the infinite sequence of integers beginning
    0, 1, 2, 3, and so on. The `while` loop goes forever, and in each loop the variable
    *x* is yielded and then incremented by 1.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示从 0 开始的无限整数序列的生成器，1, 2, 3, 4，等等。`while` 循环会无限进行，在每次循环中，变量 *x* 被产生，然后增加
    1。
- en: '[PRE33]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Even though this represents an infinite sequence, you can run `count()` without
    blowing up your computer. It just returns a generator object, not a complete list
    of values:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这代表了一个无限序列，但你可以在不损坏你的电脑的情况下运行 `count()`。它只返回一个生成器对象，而不是一个完整的值列表：
- en: '[PRE34]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A `for` loop beginning with `for x` in `count()` is valid, but runs forever.
    Here’s an example of using this infinite generator in a `for` loop with a `break`
    to escape instead of iterating forever:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `for x` in `count()` 开头的 `for` 循环是有效的，但它会无限运行。以下是一个使用这种无限生成器在 `for` 循环中通过
    `break` 跳出而不是无限迭代示例：
- en: '[PRE35]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s a more practical version of the count generator that only yields finitely
    many values. It works like the `range` function, starting from the first input
    value and going up to the second:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更实用的 `count` 生成器版本，它只产生有限数量的值。它的工作方式与 `range` 函数类似，从第一个输入值开始，并增加到第二个：
- en: '[PRE36]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result of `count(10,20)` is a generator that is like `range(10,20)` ; we
    can’t see its values directly, but we can iterate over it, for instance, in a
    list comprehension:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`count(10,20)` 的结果是类似于 `range(10,20)` 的生成器；我们无法直接看到它的值，但我们可以迭代它，例如，在列表理解中：'
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can create generator comprehensions much like list comprehensions by wrapping
    the comprehension code in parentheses instead of brackets. For example,
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将理解代码包裹在括号中而不是方括号中来创建类似于列表理解的生成器理解。例如，
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'is a generator yielding the squares of numbers from 0 to 9\. It’s behavior
    is the same as the generator:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个生成器，它产生从 0 到 9 的数字的平方。它的行为与生成器相同：
- en: '[PRE39]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When a generator is finite, you can safely convert it to a list with the `list`
    function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成器有限时，你可以安全地使用 `list` 函数将其转换为列表：
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: B.2.4 Tuples
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.4 元组
- en: '*Tuples* are iterables that are a lot like lists except that they are *immutable*
    ; you can’t change them once they are created. That means there is no `append`
    method on a tuple. In particular, once you’ve created a tuple, it always has the
    same fixed length. That makes them useful for storing data that comes in pairs
    or triples. Tuples are created like lists with the only difference being that
    we use parentheses (or no brackets at all) instead of square brackets:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组* 是可迭代的，与列表非常相似，但它们是不可变的；一旦创建，就无法更改。这意味着元组上没有 `append` 方法。特别是，一旦创建了元组，它总是具有相同的固定长度。这使得它们非常适合存储成对或成三的数据。元组的创建方式与列表类似，唯一的区别是我们使用圆括号（或根本不使用括号）而不是方括号：'
- en: '[PRE41]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you look at the `zip` in section B.2.2 again, you’ll see its entries are
    actually tuples. Tuples are in a sense the default collection in Python. If you
    write `a` `=` `1,2,3,4,5` (without the parentheses), then `a` is automatically
    interpreted as a tuple of those numbers. Likewise, if you conclude a function
    with `return` `a,b`, the output will actually be the tuple `(a,b)`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次查看 B.2.2 节中的 `zip`，您会看到其条目实际上是元组。在某种意义上，元组是 Python 中的默认集合。如果您写 `a` `=`
    `1,2,3,4,5`（不带括号），那么 `a` 将自动解释为包含这些数字的元组。同样，如果您以 `return` `a,b` 结束函数，输出实际上将是元组
    `(a,b)`。
- en: 'Tuples are often short, so we often don’t need to iterate over them. There’s
    no such thing as a tuple comprehension, but you can iterate over a tuple in another
    comprehension and convert the result back to a tuple with the built-in `tuple`
    function. Here’s something that looks like a tuple comprehension, but it’s actually
    a generator comprehension whose result is passed to the `tuple` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 元组通常很短，所以我们通常不需要迭代它们。没有元组推导式这样的东西，但您可以在另一个推导式中迭代元组，并使用内置的 `tuple` 函数将结果转换回元组。这里有一些看起来像元组推导式的东西，但实际上是一个生成器推导式，其结果被传递给
    `tuple` 函数：
- en: '[PRE42]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: B.2.5 Sets
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.5 集合
- en: 'Python *sets* are collections where every entry must be distinct, and they
    do not keep track of order. We won’t use sets much in this book, except that turning
    a list into a set is a quick way to guarantee it has no duplicate values. The
    `set` function turns an iterable into a set as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 *集合* 是每个条目都必须是唯一的集合，并且它们不跟踪顺序。在这本书中，我们不会过多地使用集合，除了将列表转换为集合是一种快速保证其没有重复值的方法。`set`
    函数将可迭代对象转换为集合，如下所示：
- en: '[PRE43]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Python sets are written as a list of entries between curly braces, which incidentally
    is the same way mathematical sets are written. You can define a set from scratch
    by listing some entries, separated by commas and enclosing them in curly braces.
    Because sets don’t respect order, sets are equal if they have exactly the same
    entries:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Python 集合的写法是使用花括号括起来的条目列表，顺便说一下，这与数学集合的写法相同。您可以通过列出一些条目，用逗号分隔并在花括号中包围它们来从头定义一个集合。由于集合不尊重顺序，如果它们具有完全相同的条目，则集合相等：
- en: '[PRE44]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: B.2.6 NumPy arrays
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.6 NumPy 数组
- en: The final collection we make extensive use of in this book is not a built-in
    Python collection; it comes from the NumPy package, which is the de-facto standard
    Python library for numerics (efficient number crunching). This collection is the
    NumPy *array*, and it’s mostly important because of how ubiquitous NumPy is. Many
    other Python libraries have functions that expect NumPy arrays as inputs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们广泛使用的一种最终集合不是内置的 Python 集合；它来自 NumPy 包，这是数值计算的默认 Python 库（高效的数值计算）。这个集合是
    NumPy 的 *数组*，它之所以很重要，主要是因为 NumPy 的普遍性。许多其他 Python 库都有期望输入 NumPy 数组的函数。
- en: 'To use NumPy arrays, make sure you have access to the NumPy library. First,
    you need to make sure NumPy is installed. If you’re using Anaconda as described
    in appendix A, you should already have it. Otherwise, you’ll want to install NumPy
    with the pip package manager via `pip install numpy` in your terminal. Once NumPy
    is installed, you need to import it to your Python program. The traditional way
    to import NumPy is with the name `np` :'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 NumPy 数组，请确保您有权访问 NumPy 库。首先，您需要确保 NumPy 已安装。如果您正在使用附录 A 中描述的 Anaconda，那么您应该已经安装了它。否则，您将通过在终端中运行
    `pip install numpy` 来使用 pip 软件包管理器安装 NumPy。一旦安装了 NumPy，您需要将其导入到您的 Python 程序中。导入
    NumPy 的传统方法是用名称 `np`：
- en: '[PRE45]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To create a NumPy array, simply pass an iterable to the `np.array` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 NumPy 数组，只需将可迭代对象传递给 `np.array` 函数：
- en: '[PRE46]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'One NumPy function we use is `np.arange`, which is like a floating-point version
    of the built-in Python `range` function. With two arguments, `np.arange` works
    the same way as `range`, producing a NumPy array instead of a `range` object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的一个 NumPy 函数是 `np.arange`，它类似于内置 Python `range` 函数的浮点版本。使用两个参数，`np.arange`
    的工作方式与 `range` 相同，生成一个 NumPy 数组而不是 `range` 对象：
- en: '[PRE47]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With a third argument, you can specify a value to count by, which can be a
    float. The following code gives us a NumPy array with values from 0 up to 10 in
    increments of 0.1, which is 100 numbers in total:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三个参数，你可以指定一个要计数的值，这可以是一个浮点数。以下代码给出了一个包含从 0 到 10 的增量 0.1 的 NumPy 数组，总共有 100
    个数字：
- en: '[PRE48]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: B.2.7 Dictionaries
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.7 字典
- en: '*Dictionaries* are collections that work quite differently than lists, tuples,
    or generators. Instead of accessing entries of a dictionary by a numeric index,
    you can label them with another piece of data called a *key*. At least in this
    book, keys are most frequently strings. The following code defines a dictionary
    called `dog` with two keys and corresponding values; the key `"name"` is associated
    with the string `"Melba"` and the key `"age"` is associated with the number `2`
    :'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 是与列表、元组或生成器工作方式相当不同的集合。你无法通过数字索引访问字典条目，而是可以用另一份数据来标记它们，称为 *键*。至少在这本书中，键最常见的是字符串。以下代码定义了一个名为
    `dog` 的字典，包含两个键和相应的值；键 `"name"` 与字符串 `"Melba"` 相关联，键 `"age"` 与数字 `2` 相关联：'
- en: '[PRE49]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To make dictionaries more readable, we often use some extra whitespace and
    write each key-value pair on its own line. The following is the same `dog` dictionary
    with extra whitespace:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使字典更易于阅读，我们经常使用一些额外的空白，并将每个键值对单独一行写出。以下是在额外空白下的相同 `dog` 字典：
- en: '[PRE50]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To access the values of a dictionary, you use a similar syntax as when getting
    the entries of a list, but instead of passing an index, you pass a key:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问字典的值，你使用与获取列表条目时类似的语法，但不是传递索引，而是传递键：
- en: '[PRE51]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you want to get all the values from a dictionary, you can get an iterable
    of key-value pair tuples using the `items` method on a dictionary. Dictionaries
    don’t order their values, so don’t expect the result of items to have any particular
    order:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从字典中获取所有值，你可以使用字典上的 `items` 方法获取键值对元组的可迭代对象。字典不排序它们的值，因此不要期望 `items` 的结果有任何特定的顺序：
- en: '[PRE52]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: B.2.8 Useful collection functions
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.8 有用的集合函数
- en: 'Python comes with a number of useful built-in functions that work with iterables,
    particularly for iterables of numbers. We already saw the length function `len`,
    which we will use most frequently, as well as the `zip` function, but there are
    a few others worth a quick mention. The `sum` function adds up an iterable of
    numbers, and the `max` and `min` functions return the largest and smallest values,
    respectively:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python 随带了一些有用的内置函数，用于处理可迭代对象，尤其是用于数字的可迭代对象。我们已经看到了 `len` 函数，我们将最频繁地使用它，以及 `zip`
    函数，但还有一些其他值得简要提及的函数。`sum` 函数将可迭代的数字相加，而 `max` 和 `min` 函数分别返回最大和最小值：
- en: '[PRE53]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `sorted` function returns a list that is a sorted copy of an iterable.
    It’s important to note that `sorted` returns a new list; the order of the original
    list is unaffected:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted` 函数返回一个列表，它是可迭代对象的排序副本。需要注意的是，`sorted` 返回一个新的列表；原始列表的顺序不受影响：'
- en: '[PRE54]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Similarly, the `reversed` function returns a reversed version of a given iterable,
    while leaving the original iterable’s order unchanged. The result is an iterable
    but not a list, so you need to convert it to see the result:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`reversed` 函数返回给定可迭代对象的反转版本，同时保持原始可迭代对象的顺序不变。结果是可迭代的，但不是列表，因此你需要将其转换为查看结果：
- en: '[PRE55]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By contrast, if you do want to sort or reverse a list in place, you can use
    the sort and reverse methods like `q.sort` `()` or `q.reverse` `()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你确实想要原地排序或反转列表，可以使用 `sort` 和 `reverse` 方法，例如 `q.sort()` 或 `q.reverse()`。
- en: B.3 Working with functions
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 与函数一起工作
- en: Python functions are like mini-programs that take some input values (or possibly
    none), do some computations, and possibly produce an output value. We already
    used some Python functions, like `math.sqrt` and `zip`, and saw the outputs they
    produce for different input values.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数就像小程序，它们接受一些输入值（或可能没有），执行一些计算，并可能产生一个输出值。我们已经使用了一些 Python 函数，如 `math.sqrt`
    和 `zip`，并看到了它们对不同的输入值产生的输出。
- en: 'We can define our own Python functions using the `def` keyword. The following
    code defines a function called `square` that takes an input value called `x`,
    stores the value `x` `*` `x` in a variable called `y`, and returns the value of
    `y`. Like a `for` loop or `if` statement, we need to use indentation to show which
    lines belong to the function definition:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `def` 关键字定义自己的 Python 函数。以下代码定义了一个名为 `square` 的函数，它接受一个名为 `x` 的输入值，将值
    `x` `*` `x` 存储在一个名为 `y` 的变量中，并返回 `y` 的值。就像 `for` 循环或 `if` 语句一样，我们需要使用缩进来表示哪些行属于函数定义：
- en: '[PRE56]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The net result of this function is returning the square of the input value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的净结果是返回输入值的平方：
- en: '[PRE57]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This section covers a few of the more advanced ways we use functions in the
    book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了我们在书中使用函数的一些更高级的方法。
- en: B.3.1 Giving functions more inputs
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.1 为函数提供更多输入
- en: 'We can define our function to take as many inputs, or *arguments* , as we want.
    The following function takes three arguments and adds them together:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义我们的函数，让它接受我们想要的任意数量的输入，或 *参数*。以下函数接受三个参数并将它们相加：
- en: '[PRE58]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Sometimes it’s useful to have a single function accept a variable number of
    arguments. For instance, we might want to write a single `add` function where
    `add(2,2)` returns `4`, `add(1,2,3)` returns `6`, and so on. We can do this by
    adding a star to a single input value, commonly called `args`. The star indicates
    that we are taking all of the input values and storing them in a tuple called
    `args.` Then we are free to write logic within our function that iterates over
    all of the arguments. This `add` function iterates over all arguments it is passed
    and adds them up, returning the total:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，让一个函数接受可变数量的参数是有用的。例如，我们可能想要编写一个单一的 `add` 函数，其中 `add(2,2)` 返回 `4`，`add(1,2,3)`
    返回 `6`，依此类推。我们可以通过在单个输入值上添加一个星号来实现这一点，这通常称为 `args`。星号表示我们将接受所有输入值并将它们存储在一个名为 `args`
    的元组中。然后我们可以在函数内部编写逻辑，遍历所有参数。这个 `add` 函数遍历它接收到的所有参数并将它们相加，返回总和：
- en: '[PRE59]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then `add(1,2,3,4,5)` returns 1 + 2 + 3 + 4 + 5 = 15 as desired and `add()`
    returns 0\. Our `add` function works differently than the `sum` function from
    before; `sum` takes an iterable, while `add` takes the underlying values directly
    as arguments. Here’s a comparison:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `add(1,2,3,4,5)` 返回 1 + 2 + 3 + 4 + 5 = 15，正如预期的那样，而 `add()` 返回 0。我们的 `add`
    函数与之前的 `sum` 函数工作方式不同；`sum` 函数接受一个可迭代对象，而 `add` 函数直接接受作为参数的底层值。以下是一个比较：
- en: '[PRE60]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `*` operator has a second application: you can use it to take a list and
    convert it into arguments of a function. For instance,'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 运算符有第二个应用：你可以用它将列表转换为函数的参数。例如，'
- en: '[PRE61]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is equivalent to evaluating `add(1,2,3,4,5)`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这与评估 `add(1,2,3,4,5)` 等效。
- en: B.3.2 Keyword arguments
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.2 关键字参数
- en: 'Using a starred argument to a function is one way to optional parameters. Another
    way is to pass in named arguments, called *keyword arguments*. Here’s an example
    function with two optional keyword arguments called `name` and `age`, which returns
    a string containing a birthday greeting:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的星号参数是一种可选参数的方式。另一种方式是通过传递命名参数，称为 *关键字参数*。以下是一个示例函数，它有两个可选关键字参数，分别称为 `name`
    和 `age`，该函数返回一个包含生日祝福的字符串：
- en: '[PRE62]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '(This function uses the string formatting operator `%`, which substitutes occurrences
    of `%s` with a given string and occurrences of `%d` with a given number.) Because
    they are keyword arguments, both `name` and `age` are optional. The name defaults
    to `"friend"`, so if we call `birthday` with no arguments, we get a generic greeting:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: （此函数使用字符串格式化运算符 `%`，它将 `%s` 出现的位置替换为给定的字符串，将 `%d` 出现的位置替换为给定的数字。）因为它们是关键字参数，所以
    `name` 和 `age` 都是可选的。名称默认为 `"friend"`，因此如果我们不带参数调用 `birthday`，我们将得到一个通用的问候：
- en: '[PRE63]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can optionally specify a different name instead. The first argument is understood
    to be the name, but we can also make it explicit by setting the `name` argument
    directly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以可选地指定一个不同的名称。第一个参数被认为是名称，但我们可以通过直接设置 `name` 参数来使其明确：
- en: '[PRE64]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `age` argument is also optional and defaults to `None`. We can specify
    a name and an age, or just an age. Because `age` is the second keyword argument,
    we need to identify it if we don’t provide a name. When all arguments are identified,
    we can pass them in any order. Here are a few examples:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`age` 参数也是可选的，默认值为 `None`。我们可以指定一个姓名和一个年龄，或者只指定一个年龄。因为 `age` 是第二个关键字参数，如果我们不提供名称，我们需要识别它。当所有参数都被识别后，我们可以以任何顺序传递它们。以下是一些示例：'
- en: '[PRE65]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you have a lot of arguments, you can package them as a dictionary and pass
    them to the function using the ** operator. This is like the * operator, except
    instead of passing a list of arguments, you pass a dictionary of keyword arguments:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多参数，你可以将它们打包成一个字典，并使用 ** 操作符将它们传递给函数。这类似于 * 操作符，但不同的是，你传递的是一个关键字参数的字典，而不是参数列表：
- en: '[PRE66]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When defining your function, you can similarly use the `**` operator to process
    all of the keywords supplied to the function as a single dictionary. We can rewrite
    the birthday function as follows, but then we need to specify the names of all
    of the arguments when calling it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义你的函数时，你可以同样使用 `**` 操作符来处理传递给函数的所有关键字参数作为一个单一的字典。我们可以将生日函数重写如下，但这样调用时我们需要指定所有参数的名称：
- en: '[PRE67]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Specifically, the `name` and `age` variables are replaced with `kwargs[''name'']`
    and `kwargs[''age'']`, and we can run it either of the following ways:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，`name` 和 `age` 变量被替换为 `kwargs['name']` 和 `kwargs['age']`，我们可以以以下两种方式之一运行它：
- en: '[PRE68]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: B.3.3 Functions as data
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.3 函数作为数据
- en: In Python, functions are *first-class* values, meaning you can assign them to
    variables, pass them to functions, and return functions as the output values of
    other functions. In other words, Python functions look like any other piece of
    data in Python. In the *functional programming* paradigm, which we introduce in
    chapter 4, it’s common to have functions that operate on other functions. The
    following function takes two inputs, a function `f` and a value `x`, and returns
    the value `f(x):`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，函数是 *一等* 值，这意味着你可以将它们赋值给变量，将它们传递给其他函数，以及将函数作为其他函数的输出值。换句话说，Python
    中的函数看起来就像 Python 中的其他任何数据。在 *函数式编程* 模式（我们在第 4 章中介绍）中，通常会有操作其他函数的函数。以下这个函数接受两个输入，一个函数
    `f` 和一个值 `x`，并返回值 `f(x)`：
- en: '[PRE69]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Using the `square` function from section B.3, `evaluate(square,10)` should
    return `square(10)` or `100` :'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 B.3 节中的 `square` 函数，`evaluate(square,10)` 应该返回 `square(10)` 或 `100`：
- en: '[PRE70]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A more useful function that takes a function as input is Python’s `map` function.
    The `map` function takes a function and an iterable, and returns a new iterable
    obtained by applying the function to every entry of the original. For instance,
    the following `map` applies `square` to every number in `range(10)`. Converting
    it to a list, we can see the first 10 square numbers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更实用的函数，它接受一个函数作为输入，是 Python 的 `map` 函数。`map` 函数接受一个函数和一个可迭代对象，并返回一个新的可迭代对象，该对象通过将函数应用于原始对象的每个条目而获得。例如，以下
    `map` 将 `square` 函数应用于 `range(10)` 中的每个数字。将其转换为列表，我们可以看到前 10 个平方数：
- en: '[PRE71]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `evaluate` and `map` functions are examples of functions that take other
    functions as inputs. It’s also possible for a function to return another function
    as output. The following function, for instance, returns a function that raises
    a number to some power. Notice, in particular, that a full function definition
    can live inside another function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluate` 和 `map` 函数是接受其他函数作为输入的函数的例子。一个函数也可以返回另一个函数作为输出。以下这个函数，例如，返回一个将数字提升到某个幂的函数。特别注意的是，一个完整的函数定义可以存在于另一个函数内部：'
- en: '[PRE72]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With this defined, `make_power_function(2)` returns a function that behaves
    just like the previous `square` function. Similarly, `make_power_function(3)`
    returns a function that cubes its input:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 定义之后，`make_power_function(2)` 返回一个函数，其行为与之前的 `square` 函数完全相同。同样，`make_power_function(3)`
    返回一个函数，它对输入进行立方：
- en: '[PRE73]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When the `make_power_function` finishes evaluating, the `power_function` returned
    still remembers the `power` variable it was passed, even though variables within
    a function are usually gone when the function finishes running. Such a function
    that remembers outside variables used in its definition is called a *closure*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `make_power_function` 完成评估后，返回的 `power_function` 仍然记得传递给它的 `power` 变量，尽管通常情况下函数运行完成后函数内部的变量就会消失。这种记住其定义中使用的外部变量的函数被称为
    *闭包*。
- en: 'B.3.4 Lambdas: Anonymous functions'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.4 Lambda：匿名函数
- en: 'There’s another simpler syntax we can use when creating functions on the fly.
    The `lambda` keyword allows us to create a function without a name, referred to
    as an *anonymous function* or a *lambda*. This name comes from the Greek letter
    λ, written lambda and pronounced LAM-duh, which is the symbol computer scientists
    use for function definitions in the theory of functional programming. To define
    a function as a lambda, you specify the input variable or variables, separated
    by commas, then a colon, then the return expression for the function. This lambda
    defines a function that takes a single input `x` and adds 2 to it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数时，我们可以使用另一种更简单的语法。`lambda` 关键字允许我们创建一个没有名称的函数，称为 *匿名函数* 或 *lambda*。这个名字来自希腊字母
    λ，写作 lambda，发音为 LAM-duh，这是计算机科学家在函数式编程理论中用于函数定义的符号。要定义一个 Lambda 函数，你指定输入变量或变量，用逗号分隔，然后是一个冒号，然后是函数的返回表达式。这个
    Lambda 定义了一个函数，它接受单个输入 `x` 并将其加 2：
- en: '[PRE74]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can use a lambda anywhere you use a function, so you can apply it directly
    to a value as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在使用函数的任何地方使用 Lambda，因此可以直接将其应用于一个值，如下所示：
- en: '[PRE75]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here’s another lambda function taking two input variables and returning the
    value of the first plus twice the value of the second. In this case, the first
    input is 2 and the second is 3, so the output is 2 + 2 · 3 = 8:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个 Lambda 函数，它接受两个输入变量并返回第一个加上第二个的两倍。在这种情况下，第一个输入是 2，第二个是 3，所以输出是 2 + 2
    · 3 = 8：
- en: '[PRE76]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can also bind a lambda to a name like any function value in Python, although
    that somewhat defeats the purpose of using the anonymous function syntax:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像在 Python 中使用任何函数值一样将 Lambda 绑定到一个名称上，尽管这多少有些违背了使用匿名函数语法的初衷：
- en: '[PRE77]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Lambdas should be used sparingly because if a function does anything interesting,
    it probably deserves a name. One place you might use a lambda is if you’re writing
    a function that returns another function. For instance, the `make_power_function`
    can be equivalently implemented with a lambda as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 应该谨慎使用 Lambda，因为如果一个函数做了任何有趣的事情，它可能值得有一个名字。你可能使用 Lambda 的情况之一是当你编写一个返回另一个函数的函数时。例如，`make_power_function`
    可以用 Lambda 等价地实现，如下所示：
- en: '[PRE78]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can see that this function behaves the same way as the original implementation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个函数的行为与原始实现相同：
- en: '[PRE79]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The name of the outside function makes this clear, and not much is gained by
    naming the return function. It’s also possible to use lambdas as inputs to functions.
    For instance, if you want to add 2 to every number from 0 to 9, you could concisely
    write
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数的名称使这一点很清楚，给返回函数命名也收获不大。还可以将 Lambda 作为函数的输入使用。例如，如果你想将 2 加到从 0 到 9 的每个数字上，你可以简洁地写出
- en: '[PRE80]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: To see the data, we again need to convert this result to a list. In most places,
    however, it’s just as concise and more readable to use comprehensions. The equivalent
    list comprehension is
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看数据，我们再次需要将此结果转换为列表。然而，在大多数地方，使用推导式既简洁又易于阅读。等价的列表推导式是
- en: '[PRE81]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: B.3.5 Applying functions to NumPy arrays
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.5 将函数应用于 NumPy 数组
- en: 'NumPy has its own versions of some of the built-in Python math functions, which
    are useful because they can be applied to every entry of a NumPy array at once.
    For instance, `np.sqrt` is a square root function that can either take the square
    root of a number or a whole NumPy array. For instance, `np.sqrt(np.arange(0,10))`
    produces a NumPy array with the square roots of integers from 0 to 9:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 有一些内置的 Python 数学函数的版本，这些函数很有用，因为它们可以一次应用于 NumPy 数组的每个条目。例如，`np.sqrt` 是一个平方根函数，它可以取一个数字或整个
    NumPy 数组的平方根。例如，`np.sqrt(np.arange(0,10))` 产生一个包含从 0 到 9 的整数的平方根的 NumPy 数组：
- en: '[PRE82]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is not just a shortcut. NumPy actually has an implementation that is faster
    than iterating over the array in Python. If you want to apply a custom function
    to every entry of a NumPy array, you can use the `np.vectorize` function. Here’s
    an example that takes a number and returns another number:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一个捷径。NumPy 实际上有一个实现，其速度比在 Python 中遍历数组要快。如果你想将自定义函数应用于 NumPy 数组的每个条目，你可以使用
    `np.vectorize` 函数。以下是一个示例，它接受一个数字并返回另一个数字：
- en: '[PRE83]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following code vectorizes the function and applies it to every entry in
    the NumPy array: `np.arange(0,10)`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将函数向量化并应用于 NumPy 数组的每个条目：`np.arange(0,10)`。
- en: '[PRE84]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: B.4 Plotting data with Matplotlib
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.4 使用 Matplotlib 绘制数据
- en: Matplotlib is the most popular plotting library in Python. Throughout the book,
    we use it to create plots of data sets, graphs of functions, and drawings of other
    geometric figures. To avoid library-specific discussions, I’ve hidden most of
    Matplotlib’s usage in wrapper functions, so you can mainly use those to do all
    of the exercises and mini-projects. In case you want to dig deeper into the implementations,
    here’s a quick overview of making plots in Matplotlib. You should have Matplotlib
    already installed with Anaconda, or you can manually install it with `pip install
    matplotlib`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是 Python 中最受欢迎的绘图库。在整个书中，我们使用它来创建数据集的图表、函数的图表以及其他几何图形的绘制。为了避免特定于库的讨论，我已经将
    Matplotlib 的大多数用法隐藏在包装函数中，因此你可以主要使用这些函数来完成所有练习和迷你项目。如果你想要深入了解实现，这里有一个快速概述，如何在
    Matplotlib 中制作图表。你应该已经通过 Anaconda 安装了 Matplotlib，或者你可以使用 `pip install matplotlib`
    手动安装。
- en: B.4.1 Making a scatter plot
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.1 制作散点图
- en: 'Scatter plots are useful for visualizing a collection of ordered pairs of numbers
    of the form (*x*, *y*) as points in the plane (covered in more detail in chapter
    2). To create a scatter plot (or any plot) with Matplotlib, the first step is
    to install the library and import it into your Python script. It’s traditional
    to import Matplotlib’s plotting module, pyplot, with the name `plt` :'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图用于可视化形式为 (*x*, *y*) 的有序数对集合作为平面上的点（在第二章中更详细地介绍）。要使用 Matplotlib 创建散点图（或任何图表），第一步是安装库并将其导入到你的
    Python 脚本中。传统上，使用名称 `plt` 导入 Matplotlib 的绘图模块，pyplot：
- en: '[PRE85]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Say we wanted to make a scatter plot of the points (1, 1), (2, 4), (3, 9),
    (4, 16), and (5, 25), which are pairs of some numbers and their squares. Thinking
    of these as points of the form (*x*, *y*), the *x* values are 1, 2, 3, 4, and
    5, and the *y* values are 1, 4, 9, 16, and 25\. To make a scatter plot, we use
    the `plt.scatter` function, passing first a list of the *x* values and then a
    list of the *y* values:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要绘制一个散点图，包含点 (1, 1), (2, 4), (3, 9), (4, 16), 和 (5, 25)，这些是一些数字及其平方的配对。将这些视为形式为
    (*x*, *y*) 的点，*x* 的值是 1, 2, 3, 4 和 5，而 *y* 的值是 1, 4, 9, 16 和 25。要制作散点图，我们使用 `plt.scatter`
    函数，首先传递一个 *x* 值的列表，然后是一个 *y* 值的列表：
- en: '[PRE86]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '![](../Images/APPB_F01_Orland.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPB_F01_Orland.png)'
- en: Figure B.1 A scatter plot created with the Matplotlib `plt.scatter` function
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.1 使用 Matplotlib 的 `plt.scatter` 函数创建的散点图
- en: The horizontal position tells us an *x* value of a given point and the vertical
    position tells us a *y* value. Notice that Matplotlib automatically scales the
    graph area to fit all of the points, so in this case, the *y* scale is bigger
    than the *x* scale.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 水平位置告诉我们给定点的 *x* 值，而垂直位置告诉我们 *y* 值。请注意，Matplotlib 自动调整图形区域以适应所有点，因此在这种情况下，*y*
    轴的比例大于 *x* 轴的比例。
- en: 'There are also a few keyword arguments you can use to customize the appearance
    of your scatter plot. For instance, the `marker` keyword argument sets the shape
    of the dots on the plot and the `c` keyword argument sets the color of the dots.
    The following line plots the same data with a red “x” for each point instead of
    the default blue circle:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一些关键字参数来自定义散点图的外观。例如，`marker` 关键字参数设置图表上点的形状，而 `c` 关键字参数设置点的颜色。以下行使用红色“x”代替默认的蓝色圆圈绘制相同的数据：
- en: '[PRE87]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '![](../Images/APPB_F02_Orland.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPB_F02_Orland.png)'
- en: Figure B.2\. Customizing the appearance of a Matplotlib scatter plot
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.2\. 自定义 Matplotlib 散点图的外观
- en: The documentation at [https://matplotlib.org/](https://matplotlib.org/) covers
    all of the possible keyword arguments and customizations that are possible with
    Matplotlib plots.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://matplotlib.org/](https://matplotlib.org/) 上的文档涵盖了所有可能的关键字参数和 Matplotlib
    图表的可定制的自定义选项。'
- en: B.4.2 Making a line chart
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.2 制作折线图
- en: If we use the Matplotlib `plt.plot` function instead of the `plt.scatter` function,
    our points are connected with lines rather than being marked as dots. This is
    sometimes called a *line chart*. For example,
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Matplotlib 的 `plt.plot` 函数而不是 `plt.scatter` 函数，我们的点将通过线条连接而不是作为点标记。这有时被称为
    *折线图*。例如，
- en: '[PRE88]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '![](../Images/APPB_F03_Orland.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPB_F03_Orland.png)'
- en: Figure B.3 Creating a line chart with the Matplotlib `plt.plot` function
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.3 使用 Matplotlib 的 `plt.plot` 函数创建折线图
- en: 'One useful application of this is specifying only two points to draw a line
    segment. For instance, we could write a function that takes two input (*x*, *y*)
    points as tuples and draws the line segment connecting them by extracting their
    *x* and *y* values and then using `plt.plot` :'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法的一个有用之处是只需指定两个点来绘制线段。例如，我们可以编写一个函数，该函数接受两个输入 (*x*, *y*) 点作为元组，并通过提取它们的 *x*
    和 *y* 值然后使用 `plt.plot` 来绘制连接它们的线段：
- en: '[PRE89]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This example also shows that you can set a `marker` keyword argument for `plt.plot`
    to mark the individual points in addition to drawing the line:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还表明，你可以为 `plt.plot` 设置一个 `marker` 关键字参数来标记单独的点，而不仅仅是绘制线：
- en: '[PRE90]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '![](../Images/APPB_F04_Orland.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPB_F04_Orland.png)'
- en: Figure B.4 A function that draws a line segment between two points
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.4 在两个点之间绘制线段的函数
- en: This `draw_segment` function is an example of a wrapper function; we can now
    use `draw_segment` any time we want to make a line segment between two (*x*, *y*)
    points, rather than using Matplotlib functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `draw_segment` 函数是一个包装函数的例子；我们现在可以在需要绘制两个 (*x*, *y*) 点之间的线段时，随时使用 `draw_segment`，而不是使用
    Matplotlib 函数。
- en: 'Another important use of a line chart is plotting the *graph* of a function.
    That is, plotting all of the pairs (*x*, *f*(*x*)) for some fixed function *f*
    over a range of *x* values. Theoretically, a smooth, continuous graph consists
    of infinitely many points. We can’t use infinitely many points, but the more we
    use, the more accurate the graph will look. Here’s a plot of *f*(*x*) = sin(*x*)
    from *x* = 0 to *x* = 10 with 1,000 points:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 线图的另一个重要用途是绘制函数的 *图像*。也就是说，在 *x* 的某个固定函数 *f* 的值域内绘制所有 (*x*, *f*(*x*)) 对。从理论上讲，一个平滑、连续的图像由无限多个点组成。我们无法使用无限多个点，但使用的点越多，图像看起来就越准确。以下是从
    *x* = 0 到 *x* = 10 的 *f*(*x*) = sin(*x*) 的图像，使用 1,000 个点：
- en: '[PRE91]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '![](../Images/APPB_F05_Orland.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPB_F05_Orland.png)'
- en: Figure B.5 Using a lot of points, we can approximate a smooth function graph.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.5 使用很多点，我们可以近似一个平滑的函数图像。
- en: B.4.3\. More plot customizations
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.3\. 更多的绘图定制
- en: As I mentioned, the best way to learn more about customizing your Matplotlib
    plots is to search the documentation at [matplotlib.org](https://matplotlib.org/)
    when you want to accomplish something specific. There are a few more important
    ways to control the appearance of your Matplotlib plots, which I’ll mention because
    they appear frequently in the examples in this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，了解如何定制你的 Matplotlib 图表的最佳方式是在你想要完成特定任务时，搜索 [matplotlib.org](https://matplotlib.org/)
    上的文档。还有一些其他重要的方式可以控制你的 Matplotlib 图表的外观，我将提到它们，因为它们在这本书的例子中经常出现。
- en: '![](../Images/APPB_F06_Orland.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPB_F06_Orland.png)'
- en: Figure B.6 Updating the x and y scales on a plot with x and y bounds
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.6 更新带有 x 和 y 范围的图表上的 x 和 y 刻度
- en: 'The first is setting the scale and size of your plot. You may have noticed
    that the result of `plot _segment(point1,point2)` was not drawn proportionally.
    If we want to see our line segment plotted to scale, we could explicitly set the
    *x* and *y* bounds for the graph to be the same. For instance, this code sets
    both the *x* and *y* bounds to the range from 0 to 5:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是设置你的图表的刻度和大小。你可能已经注意到，`plot _segment(point1,point2)` 的结果并没有按比例绘制。如果我们想按比例看到我们的线段绘制，我们可以显式设置图形的
    *x* 和 *y* 范围相同。例如，这段代码将 *x* 和 *y* 范围都设置为从 0 到 5：
- en: '[PRE92]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is still not quite to scale. One unit on the x-axis is not the same as
    one unit on the y-axis. To make them the same size visually, we need to make our
    graph a square. This can be done with the `set_size_inches` method. That method
    actually belongs to the current “figure” object that Matplotlib is working with,
    which we can retrieve with the `gcf` (get current figure) method on `plt`. The
    following code draws the line seg-
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不完全按比例。x 轴上的一个单位与 y 轴上的一个单位不同。为了使它们在视觉上大小相同，我们需要将我们的图形设置为正方形。这可以通过 `set_size_inches`
    方法完成。该方法实际上属于 Matplotlib 当前正在处理的“图形”对象，我们可以通过在 `plt` 上使用 `gcf`（获取当前图形）方法来检索它。以下代码绘制了线段：
- en: 'ment in correct proportion in a 5 in.-by-5 in. plot area. Depending on your
    display, it could appear another size, but the proportions should be correct:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 5 英寸乘 5 英寸的图表区域内按正确比例绘制。根据你的显示，它可能看起来是另一个大小，但比例应该是正确的：
- en: '[PRE93]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '![](../Images/APPB_F07_Orland.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPB_F07_Orland.png)'
- en: Figure B.7 Drawing with correct proportions by setting the figure size in inches
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.7 通过设置图尺寸为英寸来正确绘制比例
- en: 'The other important customization you can add to your graph is setting labels
    for the axes and for the whole graph. You can add a title to the current graph
    with the `plt.title` function, and you can add labels to the x- and y-axes with
    the `plt.xlabel` and `plt.ylabel` functions, respectively. Here’s an example of
    adding labels to the graph of the sine function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向你的图表添加的其他重要自定义之一是为坐标轴和整个图表设置标签。你可以使用 `plt.title` 函数给当前图表添加标题，并且可以使用 `plt.xlabel`
    和 `plt.ylabel` 函数分别添加 x 轴和 y 轴的标签。以下是一个向正弦函数图表添加标签的示例：
- en: '[PRE94]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '![](../Images/APPB_F08_Orland.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPB_F08_Orland.png)'
- en: Figure B.8 A Matplotlib plot with a title and axis labels
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.8 带标题和坐标轴标签的 Matplotlib 图
- en: B.5 Object-oriented programming in Python
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.5 Python 中的面向对象编程
- en: Object-oriented programming (OOP) is, roughly speaking, the programming paradigm
    that emphasizes organizing your program data with *classes*. Classes can store
    values called *properties* as well as functions called *methods*, which relate
    data and functionality in a program. You don’t need to know much about OOP to
    appreciate this book, but some mathematical ideas do have an object-oriented flavor.
    In chapters 6 and 10 especially, we use classes and some object-oriented design
    principles to help understand math. This section gives a quick introduction to
    classes and OOP in Python.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）大致上是一种编程范式，它强调使用 *类* 组织程序数据。类可以存储称为 *属性* 的值以及称为 *方法* 的函数，这些函数在程序中将数据和功能联系起来。你不需要了解很多关于
    OOP 的知识就能欣赏这本书，但一些数学思想确实带有面向对象的色彩。特别是在第 6 章和第 10 章中，我们使用类和一些面向对象设计原则来帮助理解数学。本节简要介绍了
    Python 中的类和面向对象编程。
- en: B.5.1 Defining classes
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.1 定义类
- en: Let’s work with a concrete example. Suppose you are writing a Python program
    that deals with geometric shapes like a drawing app, for example. One kind of
    shape you might want to describe would be a rectangle. To do this, we define a
    `Rectangle` class in Python that describes properties of rectangles and then we
    create *instances* of this class that represent specific rectangles.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个具体的例子来操作。假设你正在编写一个处理几何形状的 Python 程序，例如一个绘图应用程序。你可能想要描述的一种形状是矩形。为此，我们在
    Python 中定义一个 `Rectangle` 类来描述矩形的属性，然后我们创建这个类的 *实例* 来代表特定的矩形。
- en: 'In Python, a class is defined with the `class` keyword, and the name of the
    class is typically capitalized, like `Rectangle`. The indented lines below the
    name of the class describe the properties (values) and methods (functions) associated
    with the class. The most basic method of a class is its *constructor* , which
    is a function that allows us to make instances of the class. In Python, constructors
    are given the special name `__init__`. For a rectangle, we might want to describe
    it by two numbers, representing its height and width. In that case, the `__init__`
    function takes three values: the first represents the new instance of the class
    we’re building, and the next two represent the height and width values. The constructor
    does the work of setting height and width properties of the new instance to the
    input values:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，一个类是通过 `class` 关键字定义的，类的名称通常是大写的，如 `Rectangle`。位于类名称下方缩进的行描述了与类相关的属性（值）和方法（函数）。类最基本的方法是其
    *构造函数*，这是一个允许我们创建类实例的函数。在 Python 中，构造函数被赋予特殊的名称 `__init__`。对于一个矩形，我们可能想要通过两个数字来描述它，代表其高度和宽度。在这种情况下，`__init__`
    函数接受三个值：第一个代表我们正在构建的新类实例，接下来的两个代表高度和宽度值。构造函数负责将新实例的高度和宽度属性设置为输入值：
- en: '[PRE95]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Having created a constructor, we can use the name of the class like a function
    that takes two numbers and returns a `Rectangle` object. For instance `Rectangle(3,4)`
    creates an instance with the `width` property set to 3 and the `height` property
    set to 4\. Even though the constructor is defined with a `self` argument, you
    don’t need to include it when you call the constructor. With that `Rectangle`
    object created, we can access its height and width properties:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 创建构造函数后，我们可以像使用一个接受两个数字并返回一个 `Rectangle` 对象的函数一样使用类的名称。例如 `Rectangle(3,4)` 创建了一个宽度属性设置为
    3，高度属性设置为 4 的实例。尽管构造函数是用 `self` 参数定义的，但在调用构造函数时你不需要包含它。有了这个 `Rectangle` 对象，我们可以访问其高度和宽度属性：
- en: '[PRE96]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: B.5.2 Defining methods
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.2 定义方法
- en: 'A *method* is a function associated with a class that lets you compute something
    about instances or gives the instances some kind of functionality. For a rectangle,
    it would make sense to have an `area()` method that computes the area, which is
    the height times the width. Like the constructor, any method must take a `self`
    parameter, which represents the current instance. Once again, you don’t need to
    pass a `self` parameter to the method; `self` is automatically taken to be the
    object the method is being called on:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是与类相关联的函数，它允许你计算有关实例的信息或给实例提供某种功能。对于一个矩形来说，有一个`area()`方法来计算面积是有意义的，面积是高度乘以宽度。像构造函数一样，任何方法都必须接受一个`self`参数，它代表当前实例。同样，你不需要向方法传递`self`参数；`self`会自动被视为被调用的对象：'
- en: '[PRE97]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To find the area of a rectangle, we can call the `area` method as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算矩形的面积，我们可以按以下方式调用`area`方法：
- en: '[PRE98]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that a `self` parameter is not passed to the function; the instance `Rectangle(3,4)`
    is automatically taken to be the `self` value. As another example, we could have
    a `scale` method that takes a number and returns a new `Rectangle` object whose
    dimensions of height and width are scaled by that factor from the original. (I’ll
    start using “...” as a placeholder on the printed page to stand-in for code in
    the `Rectangle` class that we’ve already written.)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数中不会传递`self`参数；实例`Rectangle(3,4)`会自动被视为`self`值。作为另一个例子，我们可以有一个`scale`方法，它接受一个数字并返回一个新的`Rectangle`对象，其高度和宽度都按该因子从原始值缩放。（我将开始在打印页上使用“...”作为占位符，以代替`Rectangle`类中我们已编写的代码。）
- en: '[PRE99]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Calling `Rectangle(2,1)` constructs a rectangle with a width of 2 and a height
    of 1\. If we scale it by a factor of 3, we get a new rectangle with a width of
    6 and a height of 3:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Rectangle(2,1)`会构建一个宽度为2、高度为1的矩形。如果我们将其按3的因子缩放，我们得到一个新矩形，其宽度为6、高度为3：
- en: '[PRE100]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: B.5.3 Special methods
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.3 特殊方法
- en: 'Some methods are either automatically available or have special effects once
    implemented. For instance, the `__dict__` method is available by default on every
    instance of a new class and returns a dictionary of all the properties of the
    instance. With no additional modifications to the `Rectangle` class, we can write:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法在实现后要么自动可用，要么具有特殊效果。例如，`__dict__`方法默认在每个新类的实例上可用，并返回实例所有属性的字典。在不修改`Rectangle`类的情况下，我们可以编写：
- en: '[PRE101]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Another special method name is `__eq__` . This method when implemented describes
    the behavior of the `==` operator on instances of a class, and therefore, decides
    when two instances are equal. Without a custom equality method implemented, different
    instances of a class are always unequal, even if they contain the same data:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊方法名是`__eq__`。当实现此方法时，它描述了类实例上`==`运算符的行为，因此决定了何时两个实例相等。如果没有实现自定义相等方法，类实例总是不相等，即使它们包含相同的数据：
- en: '[PRE102]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'For rectangles, we might like to say they are the same if they are geometrically
    indistinguishable, having the same width and the same height. We can implement
    the `__eq__` method accordingly. The method takes two arguments, the `self` argument,
    as usual, and a second argument representing another instance we compare `self`
    to:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩形，我们可能希望说如果它们在几何上无法区分，具有相同的宽度和高度，则它们是相同的。我们可以相应地实现`__eq__`方法。该方法接受两个参数，通常是`self`参数，以及一个表示另一个实例的第二个参数，我们将`self`与该实例进行比较：
- en: '[PRE103]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'With this done, `Rectangle` instances are equal if their heights and widths
    agree:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，如果矩形的宽度和高度相同，则`Rectangle`实例相等：
- en: '[PRE104]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Another useful special method is `__repr__` , which produces a default string
    representation of an object. The following __`repr__` method makes it easier to
    see the width and height of a rectangle at first glance:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的特殊方法是`__repr__`，它生成对象的默认字符串表示。以下`__repr__`方法使得一眼就能看到矩形的宽度和高度：
- en: '[PRE105]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can see it work:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它是如何工作的：
- en: '[PRE106]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: B.5.4 Operator overloading
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.4 运算符重载
- en: 'There are more special methods that we can implement to describe how Python
    operators should behave with instances of a class. Repurposing operators that
    have an existing meaning to work on objects of a new class is called *operator
    overloading*. For instance, the `__mul__` and `__rmul__` methods describe how
    a class behaves with respect to the multiplication operator *, acting on the right
    and left, respectively. For a `Rectangle` instance `r`, we might want to write
    `r * 3` or `3 * r` to represent scaling the rectangle by a factor of 3\. The following
    implementations of __`mul` __ and __`rmul` __ call the `scale` method we already
    implemented, producing a new rectangle scaled by the given factor:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施更多特殊方法来描述 Python 操作符如何与类的实例一起使用。将具有现有意义的操作符重新用于处理新类的对象称为 *操作符重载*。例如，`__mul__`
    和 `__rmul__` 方法描述了类在乘法操作符 *（分别作用于右侧和左侧）方面的行为。对于一个 `Rectangle` 实例 `r`，我们可能想写 `r
    * 3` 或 `3 * r` 来表示将矩形按 3 倍缩放。以下对 __`mul` __ 和 __`rmul` __ 的实现调用了我们已实现的 `scale`
    方法，生成一个按给定因子缩放的新矩形：
- en: '[PRE107]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We can see that either `10 * Rectangle(1,2)` or `Rectangle(1,2) * 10` returns
    a new `Rectangle` instance with width 10 and height 20:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，无论是 `10 * Rectangle(1,2)` 还是 `Rectangle(1,2) * 10`，都会返回一个新的 `Rectangle`
    实例，其宽度为 10，高度为 20：
- en: '[PRE108]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: B.5.5 Class methods
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.5 类方法
- en: '*Methods* are functions that can only be run with an existing instance of a
    class. Another option is to create a *class method*, which is a function attached
    to the class itself rather than individual instances. For a `Rectangle` class,
    a class method would contain some functionality that has to do with rectangles
    in general, rather than with a specific rectangle.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法* 是只能通过类的现有实例来运行的函数。另一个选择是创建一个 *类方法*，这是一个附加到类本身而不是单个实例的函数。对于一个 `Rectangle`
    类，类方法将包含一些与一般矩形相关的功能，而不是与特定矩形相关。'
- en: 'One typical use of a class method is to create an alternative constructor.
    For instance, we could create a class method on the `Rectangle` class taking a
    single number as an argument, returning a rectangle with height and width both
    equal to that number. In other words, this class method constructs a rectangle
    that is a square of a given side length. The first argument of a class method
    represents the class itself and is often abbreviated to `cls` :'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法的一个典型用途是创建一个替代构造函数。例如，我们可以在 `Rectangle` 类上创建一个接受单个数字作为参数的类方法，返回一个高度和宽度都等于该数字的矩形。换句话说，这个类方法构建了一个给定边长的正方形矩形。类方法的第一参数代表类本身，通常缩写为
    `cls`：
- en: '[PRE109]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: With this class method implemented, we could write `Rectangle.square(5)` to
    get the same result as `Rectangle(5,5)`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这个类方法，我们可以使用 `Rectangle.square(5)` 来得到与 `Rectangle(5,5)` 相同的结果。
- en: B.5.6 Inheritance and abstract classes
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.6 继承和抽象类
- en: 'The last topic in OOP that we use is *inheritance*. If we say class `A` inherits
    from class `B`, it is like saying instances of class `A` are special cases of
    class `B` ; they work like instances of class `B` but with some additional or
    modified functionality. In this case, we also say that `A` is a *subclass* of
    `B`, and that `B` is a *superclass* of `A`. As a simple example, we could create
    a subclass `Square` from `Rectangle` that represents squares, while keeping most
    of the same underlying logic from `Rectangle` . Writing `class Square(Rectangle)`
    means that `Square` is a subclass of `Rectangle`, and the call to `super().__init__`
    runs the superclass (`Rectangle`) constructor from the `Square` constructor:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们使用的最后一个主题是 *继承*。如果我们说类 `A` 继承自类 `B`，就像说类 `A` 的实例是类 `B` 的特殊情况；它们像类
    `B` 的实例一样工作，但有一些额外的或修改后的功能。在这种情况下，我们也说 `A` 是 `B` 的 *子类*，而 `B` 是 `A` 的 *超类*。作为一个简单的例子，我们可以从
    `Rectangle` 创建一个表示正方形的子类 `Square`，同时保留 `Rectangle` 的大部分底层逻辑。编写 `class Square(Rectangle)`
    意味着 `Square` 是 `Rectangle` 的子类，并且调用 `super().__init__` 会从 `Square` 构造函数中运行超类（`Rectangle`）的构造函数：
- en: '[PRE110]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This is all we need to do to define the `Square` class, and we can use any
    `Rectangle` method out of the box:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们定义 `Square` 类所需做的所有事情，我们可以直接使用任何 `Rectangle` 方法：
- en: '[PRE111]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In practice, you might want to re-implement or *override* some more methods,
    like `scale`, which by default returns the scaled square as a rectangle.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能需要重新实现或 *重写* 一些更多方法，如 `scale`，它默认返回缩放后的正方形作为矩形。
- en: 'One common pattern in OOP is to have two classes inherit from the same *abstract
    base class* , a class defining some common methods or code but that you could
    never have an instance of. As an example, suppose we had a similar class `Circle`,
    representing a circle of a given radius. Most of the `Circle` class implementation
    is analogous to the `Rectangle` class:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的一种常见模式是让两个类从同一个 *抽象基类* 继承，这是一个定义了一些公共方法或代码的类，但你永远不能创建其实例。例如，假设我们有一个类似的类
    `Circle`，表示给定半径的圆。`Circle` 类的大部分实现与 `Rectangle` 类类似：
- en: '[PRE112]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: (Remember from geometry class that the area of a circle of radius *r* is *π**r*
    ².) If we’re dealing with a number of different shapes in our program, we could
    have both `Circle` and `Rectangle` inherit from a common `Shape` class. The concept
    of a shape is not specific enough that we could create an instance of it, so only
    some of the methods can be implemented. The others are marked as *abstract* *methods*
    , meaning they can’t be implemented for a `Shape` on its own but could be implemented
    for any concrete subclass.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: （记得几何课上学到的，半径为 *r* 的圆的面积是 *πr²*。）如果我们程序中处理多种不同的形状，我们可以让 `Circle` 和 `Rectangle`
    都继承自一个共同的 `Shape` 类。形状的概念不够具体，以至于我们无法创建其实例，因此只能实现其中的一些方法。其他方法被标记为 *抽象方法*，这意味着它们不能单独为
    `Shape` 实现，但可以为任何具体的子类实现。
- en: 'We can use the following code to create an abstract class in Python. *ABC*
    stands for “abstract base class,” and `ABC` is a special base class that any abstract
    class must inherit from in Python:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码在 Python 中创建一个抽象类。*ABC* 代表“抽象基类”，`ABC` 是一个特殊的基类，任何抽象类都必须在 Python 中从它继承：
- en: '[PRE113]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Equality and the multiplication overloads are fully implemented, with `__eq__`
    checking that all the properties of two shapes agree. Area and scale are left
    to be implemented, and their implementations depend on the particular shape we’re
    working with.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 等式和乘法重载已完全实现，`__eq__` 方法检查两个形状的所有属性是否一致。面积和缩放功能留待实现，它们的实现取决于我们正在处理的特定形状。
- en: 'If we were to reimplement the `Rectangle` class based on the `Shape` abstract
    base class, we could start by having it inherit from `Shape`, while giving it
    its own constructor:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要根据 `Shape` 抽象基类重新实现 `Rectangle` 类，我们可以先让它继承自 `Shape`，同时为其提供一个自己的构造函数：
- en: '[PRE114]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If we try to instantiate a `Rectangle` with just this code, we run into an
    error because the `area` and `scale` methods are not implemented:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试仅用这段代码实例化一个 `Rectangle`，我们会遇到错误，因为 `area` 和 `scale` 方法尚未实现：
- en: '[PRE115]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We can include the earlier implementations:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以包含之前实现的代码：
- en: '[PRE116]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Once we have these methods whose behavior is rectangle-specific, we have access
    to all the functionality from the `Shape` base class. For instance, equality and
    the multiplication operator overload behave as expected:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些特定于矩形的特定方法，我们就能够访问 `Shape` 基类中的所有功能。例如，等式和乘法运算符重载的行为符合预期：
- en: '[PRE117]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We can now quickly implement a `Circle` class, a `Triangle` class, or a class
    for any other 2D shape, all of which would be unified by their area and shape
    methods and operator overloads.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以快速实现一个 `Circle` 类、一个 `Triangle` 类，或者任何其他二维形状的类，所有这些类都会通过它们的面积和形状方法以及运算符重载实现统一。
