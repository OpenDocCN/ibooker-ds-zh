- en: 2 Managing component state with the useState hook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 使用useState钩子管理组件状态
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Asking React to manage component state values by calling `useState`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`useState`请求React管理组件状态值
- en: Changing state values and triggering re-renders with an updater function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更新函数更改状态值并触发重新渲染
- en: Using the previous state to help generate new state values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前一个状态来帮助生成新的状态值
- en: Managing multiple pieces of state
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个状态值
- en: Considering how React and components interact to persist and update state and
    synchronize state and UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑React和组件如何交互以持久化和更新状态以及同步状态和UI
- en: If you’re building React apps, you’re expecting the data your app uses to change
    over time. Whether it’s fully server-rendered, a mobile app, or all in a browser,
    your application’s user interface should represent the current data, or *state*,
    at the time of rendering. Sometimes multiple components throughout the app will
    use the data, and sometimes a component doesn’t need to share its secrets and
    can manage its own state without the help of mammoth, application-wide, state-store
    behemoths. In this chapter, we keep it personal and concentrate on components
    taking care of themselves, without regard for other components around them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建React应用程序，你期望应用程序使用的数据会随时间变化。无论是完全服务器渲染、移动应用，还是全部在浏览器中，应用程序的用户界面应该表示渲染时的当前数据，或*状态*。有时应用程序中的多个组件会使用这些数据，有时一个组件不需要分享其秘密，可以独立管理其状态，而不需要巨无霸级的应用级状态存储器的帮助。在本章中，我们将关注个人化，专注于自我管理的组件，而不考虑周围的其他组件。
- en: 'Figure 2.1 is a very basic illustration of React’s job: it should use the current
    state to render the UI. If the state changes, React should re-render the UI. The
    illustration shows a name in a friendly message. When the name value changes,
    React updates the UI to show the new name in its message. We usually want the
    state and UI to be in sync (although we might choose to delay synchronization
    during state transitions—when fetching the latest data, for example).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1是一个非常基本的React工作原理的说明：它应该使用当前状态来渲染UI。如果状态发生变化，React应该重新渲染UI。插图显示了一个友好的消息中的名称。当名称值发生变化时，React更新UI以显示消息中的新名称。我们通常希望状态和UI保持同步（尽管我们可能选择在状态转换期间延迟同步——例如在获取最新数据时）。
- en: '![](../Images/2-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图2-1](../Images/2-1.png)'
- en: Figure 2.1 When you change a value in a component, React should update the UI.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 当你在组件中更改一个值时，React应该更新UI。
- en: React provides a small number of functions, or *hooks*, to enable it to track
    values in your components and keep the state and UI in sync. For single values,
    React gives us the `useState` hook, and that’s the hook we explore in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一些函数，或*钩子*，以使其能够跟踪组件中的值并保持状态和UI同步。对于单个值，React提供了`useState`钩子，这也是我们在本章中要探索的钩子。
- en: We’ll look at how to call the hook, what it returns, and how to use it to update
    the state, triggering React to update the UI. Components often need more than
    one piece of state to do their jobs, so we’ll see how to call `useState` multiple
    times to handle multiple values. It’s not just a matter of documenting the `useState`
    API (you can go to the official React docs for that). We’ll use the discussion
    of the `useState` hook to help you better understand what function components
    are and how they work. To that end, we’ll finish the chapter with a review of
    the key concepts met as our code listings have evolved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何调用钩子，它返回什么，以及如何使用它来更新状态，触发React更新UI。组件通常需要多个状态值来完成其工作，因此我们将看到如何多次调用`useState`来处理多个值。这不仅仅是记录`useState`API（你可以去官方React文档中查看）。我们将通过讨论`useState`钩子来帮助你更好地理解函数组件是什么以及它们是如何工作的。为此，我们将以回顾我们在代码列表中遇到的关键概念来结束本章。
- en: Talking of code listings, in this chapter, we’ll start work on the app that
    will form the main example throughout this book. The example acts as a consistent
    context in which we use React Hooks to solve common coding problems. A little
    bit of housekeeping is required to set up the app, but once that’s done, we’ll
    be able to concentrate on a single component for the rest of the chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 说到代码列表，在本章中，我们将开始构建将在整本书中作为主要示例的应用程序。这个例子作为一个一致的上下文，我们使用React Hooks来解决常见的编码问题。设置应用程序需要一点家务管理，但一旦完成，我们就能专注于本章剩余部分的单个组件。
- en: 2.1 Setting up the bookings manager app
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 设置预订管理器应用程序
- en: 'Your fun but professional company has numerous resources that can be booked
    by staff: meeting rooms, AV equipment, technician time, table football, and even
    party supplies. One day, the boss asks you to set up the skeleton of an app for
    the company network that lets staff book the resources. The app should have three
    pages, for Bookings, Bookables, and Users, as shown in figure 2.2\. (Technically,
    it’s a single-page application, and the pages are really components, but we’ll
    keep calling them *pages* because from the user’s perspective, they’re switching
    from page to page.)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您的有趣而专业的公司拥有众多资源，员工可以预订：会议室、视听设备、技术人员时间、桌球，甚至派对用品。有一天，老板要求您为公司网络搭建一个应用程序的框架，让员工可以预订这些资源。该应用程序应包含三个页面，用于预订、可预订资源和用户，如图2.2所示。（技术上，它是一个单页应用程序，页面实际上是组件，但我们仍将它们称为“页面”，因为从用户的角度来看，他们是在页面之间切换。）
- en: '![](../Images/2-2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-2.png)'
- en: 'Figure 2.2 The Bookings app has three pages: Bookings, Bookables, and Users.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 预订应用程序有三个页面：预订、可预订资源和用户。
- en: By the end of this section, you’ll be able to display each page and use the
    links to navigate between them. The project folder at the end of the section will
    include public and src folders that look like those in figure 2.3.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，您将能够显示每个页面，并使用链接在它们之间导航。本节末尾的项目文件夹将包括类似于图2.3所示的public和src文件夹。
- en: '![](../Images/2-3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-3.png)'
- en: Figure 2.3 The public and src folders after our initial setup
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 初始设置后的public和src文件夹
- en: 'You can see how the subfolders inside the components folder correspond to the
    three pages. We have six jobs to do to get the app into the shape shown in the
    figure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到组件文件夹内的子文件夹如何对应于三个页面。为了使应用程序达到图中的形状，我们共有六个任务要做：
- en: Use `create-react-app` to generate the skeleton for our bookings app.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`create-react-app`为我们的预订应用程序生成框架。
- en: Remove the `create-react-app` generated files we won’t be using.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除我们将不会使用的`create-react-app`生成的文件。
- en: Edit four of the files that are left in the public and src folders.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑public和src文件夹中剩余的四个文件。
- en: Install a few packages from npm.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一些来自npm的包。
- en: Add a database file to give the app some data to display.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个数据库文件，为应用程序提供一些要显示的数据。
- en: Create subfolders for each page and put the page components in them.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个页面创建子文件夹，并将页面组件放入其中。
- en: 'Alternatively, you can find the code examples for the ongoing bookings example
    app on GitHub at [https://github.com/jrlarsen/react-hooks-in-action](https://github.com/jrlarsen/react-hooks-in-action),
    with branches set up for each evolution of the code. Each listing for the example
    app includes the name of the branch to check out, linked (in the ebook) to the
    GitHub repo. For example, after you’ve cloned the repo, to get the code for the
    first branch, enter this command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在GitHub上找到正在进行的预订示例应用程序的代码示例，网址为[https://github.com/jrlarsen/react-hooks-in-action](https://github.com/jrlarsen/react-hooks-in-action)，为代码的每次演变设置了分支。每个示例应用程序的列表都包括要检出分支的名称，并在电子书中链接到GitHub存储库。例如，在您克隆存储库后，要获取第一个分支的代码，请输入以下命令：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install the project dependencies with this command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装项目依赖项：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the project with this command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行项目：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can then skip to section 2.2.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以跳转到第2.2节。
- en: For those who want to get their hands dirty building most of the app from scratch,
    the first thing we need is a React app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想从零开始构建大部分应用程序的人来说，我们首先需要的是一个React应用程序。
- en: 2.1.1 Generating the app skeleton with create-react-app
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 使用create-react-app生成应用程序框架
- en: 'React’s `create-react-app` utility generates projects with preset linting and
    compilation workflows set up. It also comes with a development server that’s perfect
    for us as we work through the ever-evolving stages of our app. Let’s use `create-react-app`
    to generate a new React project called `react-hooks-in-action`. We don’t need
    to install `create-react-app` with npm before running it; we can run it from its
    repository by using the `npx` command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React的`create-react-app`实用工具会生成具有预设的linting和编译工作流程的项目。它还附带了一个开发服务器，这对于我们在应用程序不断演变的各个阶段工作来说非常完美。让我们使用`create-react-app`来生成一个名为`react-hooks-in-action`的新React项目。在运行之前，我们不需要使用npm安装`create-react-app`；我们可以通过使用`npx`命令从其存储库运行它：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The command will take a little while to do its thing, and you should end up
    with a whole bunch of generated files in a react-hooks-in-action folder. When
    I ran the `create-react-app` command, my computer used npm to install the files.
    If you have Yarn installed, `create-react-app` will use that instead, and you’ll
    get a yarn.lock file instead of package-lock.json. (`npx` is a handy command that’s
    included when you install npm. Its author, Kat Marchán, explains the thinking
    behind it in the Medium article “Introducing npx” at [http://mng.bz/RX2j.](https://shortener.manning.com/RX2j))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行需要一些时间，您最终会在 react-hooks-in-action 文件夹中获得大量生成的文件。当我运行 `create-react-app`
    命令时，我的电脑使用 npm 安装文件。如果您已安装 Yarn，`create-react-app` 将使用 Yarn，您将获得 yarn.lock 文件而不是
    package-lock.json。（`npx` 是当您安装 npm 时包含的一个方便的命令。它的作者 Kat Marchán 在 Medium 文章“Introducing
    npx”中解释了其背后的思考，见 [http://mng.bz/RX2j.](https://shortener.manning.com/RX2j)）
- en: We don’t need all of the installed files for our app, so let’s quickly delete
    a few. From the public folder inside the react-hooks-in-action folder, remove
    all but index.html. From the src folder, remove all but App.css, App.js, and index.js.
    Figure 2.4 highlights the files to remove.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为我们的应用程序安装的所有文件，所以让我们快速删除几个。从 react-hooks-in-action 文件夹内的公共文件夹中，删除除 index.html
    之外的所有文件。从 src 文件夹中，删除除 App.css、App.js 和 index.js 之外的所有文件。图 2.4 突出了需要删除的文件。
- en: '![](../Images/2-4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-4.png)'
- en: Figure 2.4 Our project doesn’t need many of the default files generated by `create-react-app`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 我们的项目不需要 `create-react-app` 生成的许多默认文件。
- en: Figure 2.5 shows the four main files left in the public and src folders. We
    use them to run our app, importing the components we build throughout the book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 显示了在公共和 src 文件夹中留下的四个主要文件。我们使用它们来运行我们的应用程序，导入我们在本书中构建的组件。
- en: '![](../Images/2-5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-5.png)'
- en: Figure 2.5 The four files we need to set up in the public and src folders
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 我们需要在公共和 src 文件夹中设置的四个文件
- en: The four files are set up for React’s demo page, not our bookings app. It’s
    time for a few tweaks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个文件是为 React 的演示页面设置的，而不是我们的预订应用程序。是时候进行一些调整了。
- en: 2.1.2 Editing the four key files
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 编辑四个关键文件
- en: 'Our little workhorse files will get the app up and running. Let me introduce
    you to:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小工作马文件将使应用程序启动并运行。让我向您介绍一下：
- en: /public/index.html—The web page that contains the app
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /public/index.html——包含应用程序的网页
- en: /src/App.css—Some styles to organize elements on the page
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /src/App.css——用于在页面上组织元素的样式
- en: /src/components/App.js—The root component that contains all the others
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /src/components/App.js——包含所有其他组件的根组件
- en: /src/index.js—The file that imports the `App` component and renders it to the
    index.html page
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /src/index.js——导入 `App` 组件并将其渲染到 index.html 页面的文件
- en: index.html
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: index.html
- en: Inside the public folder, edit the index.html file. A lot of the boilerplate
    generated by `create-react-app` can come out. The `div` element with an `id` of
    `root` must stay; it’s the container element for the app. React will render the
    `App` component into that `div`. You can also set the title for the page, as shown
    in the following listing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共文件夹内，编辑 index.html 文件。`create-react-app` 生成的许多样板代码可以删除。具有 `id` 为 `root` 的
    `div` 元素必须保留；它是应用程序的容器元素。React 将将 `App` 组件渲染到该 `div` 中。您还可以设置页面的标题，如下所示。
- en: 'Branch: 0201-pages, File: /public/index.html'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0201-pages，文件：/public/index.html
- en: Listing 2.1 The HTML skeleton for the bookings app
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 预订应用程序的 HTML 骨架
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Set the title for the page.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置页面的标题。
- en: ❷ Make sure there is a div with an id of root.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确保有一个具有 id 为 root 的 div。
- en: That’s all we need for the web page. The `App` component will appear in the
    `div`, and all our other components—for bookable items, bookings, users, and their
    separate pages—will be managed by the `App` component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们网页所需的所有内容。`App` 组件将出现在 `div` 中，而我们所有的其他组件——包括可预订项目、预订、用户及其单独的页面——将由 `App`
    组件管理。
- en: App.css
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: App.css
- en: 'This book isn’t here to teach you Cascading Style Sheets (CSS), so it doesn’t
    focus on listings of styles. At times, CSS will be used in combination with events
    in components (when loading data, for example), and the relevant styles will be
    highlighted at those times. The stylesheet will develop over time, so, if you’re
    interested, take a look in the repo. The initial styles can be found at *Branch*:
    0201-pages, *File*: /src/App.css. (If you’re not particularly interested in the
    evolution of the CSS throughout the project but want to code along with the JavaScript,
    just grab the App.css file from the finished project.)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并非旨在教你层叠样式表（CSS），因此它不会专注于样式列表。有时，CSS 将与组件中的事件（例如加载数据时）结合使用，相关样式将在这些时刻突出显示。样式表将随着时间的推移而发展，因此，如果你感兴趣，请查看仓库。初始样式可以在
    *分支*：0201-pages，*文件*：/src/App.css 中找到。（如果你对整个项目中 CSS 的发展不感兴趣，但想与 JavaScript 一起编码，只需从完成的项目中获取
    App.css 文件即可。）
- en: The styles use CSS grid properties to position the main components on each page,
    and some CSS variables to define common colors for text and backgrounds.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 样式使用 CSS 网格属性定位每个页面上的主要组件，并使用一些 CSS 变量定义文本和背景的常用颜色。
- en: App.js
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: App.js
- en: The `App` component is the root component for our application. It displays the
    header with its links and user-picker drop-down, as shown in figure 2.6.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件是我们应用程序的根组件。它显示带有其链接和用户选择器下拉菜单的页眉，如图 2.6 所示。'
- en: '![](../Images/2-6.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6](../Images/2-6.png)'
- en: Figure 2.6 The header with three links and a drop-down list
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 带有三个链接和一个下拉列表的页眉
- en: The `App` component also sets up routes to the three main pages, as shown in
    listing 2.2\. The router shows the appropriate page to the user by matching the
    URL with a page component. The App.js file has been moved to a new components
    folder. It imports a number of components that we create later in the chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件还设置了通往三个主要页面的路由，如列表 2.2 所示。通过将 URL 与页面组件匹配，路由器向用户显示适当的页面。App.js 文件已移动到新的组件文件夹中。它导入了一些我们在本章后面创建的组件。'
- en: 'Branch: 0201-pages, File: /src/components/App.js'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0201-pages，文件：/src/components/App.js
- en: Listing 2.2 The `App` component
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 `App` 组件
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Import the routing elements from react-router-dom.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 react-router-dom 导入路由元素。
- en: ❷ Import the icons for the navigation links.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入导航链接的图标。
- en: ❸ Import the separate page components and the UserPicker.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 导入单独的页面组件和 UserPicker 组件。
- en: ❹ Wrap the app in a Router component to enable routing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将应用包裹在 Router 组件中以启用路由。
- en: ❺ Use Link components along with the Router.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 与 Router 一起使用 Link 组件。
- en: ❻ Use the “to” attribute to specify where the link goes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用“to”属性指定链接的地址。
- en: ❼ Use imported icons to decorate the links.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用导入的图标装饰链接。
- en: ❽ Place the UserPicker in the header.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将 UserPicker 放在页眉中。
- en: ❾ Wrap the collection of Route components in a Routes component.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将 Route 组件的集合包裹在 Routes 组件中。
- en: ❿ Use a Route for each path you want to match.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 为每个要匹配的路径使用一个 Route。
- en: ⓫ Match a path to display a particular page component.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 将路径匹配到特定的页面组件。
- en: ⓬ Specify the component to display for the matched path.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 指定要显示的匹配路径的组件。
- en: Notice that there is no `import` `React` `from` `"react"` at the top of the
    listing. React components used to need that line so they would work when the JSX
    in them was converted into regular JavaScript. But the tools that compile React,
    like `create-react-app`, can transform JSX in the latest versions of React without
    needing the import statement. Read about this change on the React blog ([http://mng.bz/2ew8](https://shortener.manning.com/2ew8)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，列表顶部没有 `import` `React` `from` `"react"`。React 组件过去需要这一行才能在 JSX 转换为常规 JavaScript
    时正常工作。但是，像 `create-react-app` 这样的编译 React 的工具可以在 React 最新版本中转换 JSX，而无需导入语句。关于这一变化，请参阅
    React 博客（[http://mng.bz/2ew8](https://shortener.manning.com/2ew8)）。
- en: 'The app uses React Router version 6 to manage the display of its three pages.
    At the time of writing, React Router 6 is a beta release available via React Router’s
    Next channel. Install it like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用使用 React Router 版本 6 来管理其三个页面的显示。在撰写本文时，React Router 6 是通过 React Router 的
    Next 频道提供的测试版。安装方法如下：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Find out more about React Router on its GitHub page ([https://github.com/ReactTraining/react-router](https://github.com/ReactTraining/react-router)).
    We use the `Link` component to display our page links in the header, and `Route`
    elements to conditionally display page components depending on the matched URL.
    For example, if the user visits /bookings, the `BookingsPage` component will be
    displayed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在其 GitHub 页面 ([https://github.com/ReactTraining/react-router](https://github.com/ReactTraining/react-router))
    上了解更多关于 React Router 的信息。我们使用 `Link` 组件在标题中显示页面链接，并使用 `Route` 元素根据匹配的 URL 有条件地显示页面组件。例如，如果用户访问
    /bookings，则显示 `BookingsPage` 组件：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For now, you don’t need to worry about React Router; it’s just managing the
    links and the display of our page components. We’ll make much more use of it in
    chapter 10, when we start to use some of the custom hooks it provides to access
    matched URLs and query string parameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你不需要担心 React Router；它只是管理链接和页面组件的显示。我们将在第 10 章中使用它提供的自定义钩子来访问匹配的 URL 和查询字符串参数，那时我们会更多地使用它。
- en: As you can see in figure 2.7, we’ve decorated the header links with icons from
    Font Awesome ([https://fontawesome.com](https://fontawesome.com/)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 2.7 所示，我们已经用 Font Awesome ([https://fontawesome.com](https://fontawesome.com/))
    的图标装饰了标题链接。
- en: '![](../Images/2-7.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-7.png)'
- en: Figure 2.7 The header includes Font Awesome icons beside each link.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 标题栏中每个链接旁边都有 Font Awesome 图标。
- en: 'The icons are available as part of the react-icons package, so we need to install
    the package:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图标作为 react-icons 包的一部分提供，因此我们需要安装该包：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The react-icons GitHub page ([https://github.com/react-icons/react-icons](https://github.com/react-icons/react-icons))
    includes details of the icon sets available in the package, along with links to
    relevant licensing information.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: react-icons 的 GitHub 页面 ([https://github.com/react-icons/react-icons](https://github.com/react-icons/react-icons))
    包含了包中可用的图标集的详细信息，以及相关许可信息的链接。
- en: The `App` component also imports the three page components—`BookablesPage`,
    `BookingsPage`, and `UsersPage`—and the `UserPicker` component. We create those
    in section 2.1.4.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件还导入了三个页面组件—`BookablesPage`、`BookingsPage` 和 `UsersPage`—以及 `UserPicker`
    组件。我们在 2.1.4 节中创建了这些组件。'
- en: index.js
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: index.js
- en: React needs a JavaScript file to act as a starting point for the application.
    In the src folder, edit the index.js file to look like the following listing.
    It imports the `App` component and renders it into the root `div` seen in the
    index.html file back in listing 2.1.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: React 需要一个 JavaScript 文件作为应用程序的起点。在 src 文件夹中，编辑 index.js 文件，使其看起来如下所示。它导入了 `App`
    组件并将其渲染到 listing 2.1 中 index.html 文件中看到的根 `div` 中。
- en: 'Branch: 0201-pages, File: /src/index.js'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0201-pages，文件：/src/index.js
- en: Listing 2.3 The top-level JavaScript file
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 顶级 JavaScript 文件
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Import the App component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 App 组件。
- en: ❷ Specify App as the component to render.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定 App 作为要渲染的组件。
- en: ❸ Specify where to render the App component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指定渲染 App 组件的位置。
- en: And that’s the four existing files tweaked! We still need to create the page
    components for the `App` component to import and the `UserPicker` drop-down for
    the header. First, the app will need some bookables and users to show. Let’s give
    it some data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，四个现有的文件就调整好了！我们仍然需要为 `App` 组件创建页面组件以及用于标题的 `UserPicker` 下拉菜单。首先，应用需要一些可预订项和用户来显示。让我们给它一些数据。
- en: 2.1.3 Adding a database file for the application
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 为应用程序添加数据库文件
- en: Our application needs a few types of data, including users, bookables, and bookings.
    We start off by importing all of the data from a single JavaScript Object Notation
    (JSON) file, static.json. We just need some bookables and users to show in lists,
    so the initial data file isn’t too complicated, as you can see in the following
    listing. (You can copy the data from the listing’s branch on GitHub by visiting
    the specified file.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要几种类型的数据，包括用户、可预订项和预订。我们首先从单个 JavaScript 对象表示法 (JSON) 文件 static.json
    中导入所有数据。我们只需要在列表中显示一些可预订项和用户，所以初始数据文件并不复杂，如下所示。（您可以通过访问指定的文件来复制 GitHub 上列表分支的数据。）
- en: 'Branch: 0201-pages, File: /src/static.json'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0201-pages，文件：/src/static.json
- en: Listing 2.4 The bookings app data structure
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 预订应用的数据结构
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Assign an array of bookables data to the bookables property.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将可预订项数据数组分配给 bookables 属性。
- en: ❷ Specify the users who can use the app.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定可以使用该应用的用户。
- en: ❸ Leave the bookings empty for now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 目前暂时不设置预订。
- en: ❹ Configure the available sessions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 配置可用的会话。
- en: ❺ Configure the days of the week.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 配置星期几。
- en: 'Each element in the array of bookables is an object that looks something like
    this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可预订数组中的每个元素都是一个类似以下的对象：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The bookables are stored in an array of bookable objects, assigned to the `bookables`
    property. Each bookable has `id`, `group`, `title`, and `notes` properties. The
    data in the book’s code repo has slightly longer notes, but the structure is the
    same. Each bookable also specifies the days and sessions for which it can be booked.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可预订项目存储在一个包含可预订对象的数组中，分配给`bookables`属性。每个可预订项目都有`id`、`group`、`title`和`notes`属性。书籍代码仓库中的数据注释略长，但结构相同。每个可预订项目还指定了可以预订的天数和时段。
- en: 'Users are also stored as objects, with this structure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 用户也以对象的形式存储，结构如下：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The bookables will be listed by the `BookablesPage` component and the users
    by the `UsersPage` component. We’d better get those pages built!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可预订项目将由`BookablesPage`组件列出，用户将由`UsersPage`组件列出。我们最好把这些页面建好！
- en: 2.1.4 Creating page components and a UserPicker.js file
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 创建页面组件和UserPicker.js文件
- en: As we add functionality to the app, we use components to encapsulate that functionality
    and to demonstrate techniques that working with hooks offers. We put our components
    in folders related to the page they’re on. Create three new folders within the
    components folder and name them Bookables, Bookings, and Users. For the skeleton
    app, create three structurally identical placeholder pages like the one in the
    following listing. Call them `BookablesPage`, `BookingsPage`, and `UsersPage`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对应用添加功能，我们使用组件来封装这些功能并展示使用hooks的技术。我们将我们的组件放在与它们所在的页面相关的文件夹中。在组件文件夹内创建三个新的文件夹，分别命名为Bookables、Bookings和Users。对于骨架应用，创建三个与以下列表中类似的结构相同的占位符页面。将它们命名为`BookablesPage`、`BookingsPage`和`UsersPage`。
- en: 'Branch: 0201-pages, File: /src/components/Bookables/BookablesPage.js'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0201-pages，文件：/src/components/Bookables/BookablesPage.js
- en: Listing 2.5 The `BookablesPage` component
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 `BookablesPage`组件
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Assign each page a class so the CSS file can set out the page as appropriate.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为每个页面分配一个类，以便CSS文件可以适当地设置页面样式。
- en: We finish off the app setup with a `UserPicker` component in the following listing.
    For now, it just shows the word Users in a drop-down list. We populate it with
    data later in the chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下列表中的`UserPicker`组件来完成应用设置的收尾工作。目前，它只是在下拉列表中显示单词“用户”。我们将在本章的后面用数据填充它。
- en: 'Branch: 0201-pages, File: /src/components/Users/UserPicker.js'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0201-pages，文件：/src/components/Users/UserPicker.js
- en: Listing 2.6 The `UserPicker` component
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 `UserPicker`组件
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All the pieces are in place for our ongoing exploration of hooks in the context
    of the bookings app. Test that it’s working by starting the `create-react-app`
    development server:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对预订应用上下文中的hooks进行持续探索的所有部件都已就绪。通过启动`create-react-app`开发服务器来测试它是否正常工作：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If all’s well, you can navigate between the three pages, with each shouting
    its identity at you: Bookables! Bookings! Users! Let’s calm down the Bookables
    page by displaying the bookables from the database.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你可以在三个页面之间导航，每个页面都会向你喊出它的身份：可预订的！预订！用户！让我们通过显示数据库中的可预订项目来平息“可预订”页面。
- en: 2.2 Storing, using, and setting values with useState
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用useState存储、使用和设置值
- en: 'Your React applications look after a certain state: values that are shown in
    the user interface or that help manage what’s shown. The state may include posts
    on a forum, comments for those posts, and whether the comments are shown, for
    example. When users interact with the app, they change its state. They may load
    more posts, toggle whether comments are visible, or add their own comments. React
    is there to make sure state and UI are in sync. When the state changes, React
    needs to run the components that use that state. The components return their UI
    by using the latest state values. React compares the returned UI with the existing
    UI and efficiently updates the DOM as necessary.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你的React应用负责维护一定的状态：在用户界面中显示的值或帮助管理显示的内容。状态可能包括论坛上的帖子、那些帖子的评论以及是否显示评论等。当用户与应用交互时，他们会改变应用的状态。他们可能会加载更多帖子、切换评论的可见性，或者添加自己的评论。React确保状态和UI保持同步。当状态改变时，React需要运行使用该状态的组件。组件通过使用最新的状态值返回它们的UI。React将返回的UI与现有的UI进行比较，并高效地更新必要的DOM。
- en: Some state is shared across the application, some is shared by a few components,
    and some is managed locally by a component itself. If components are just functions,
    how can they persist their state across renders? Are their variables not lost
    when they finish executing? And how does React know when the variables change?
    If React is faithfully trying to match the state and the UI, it definitely needs
    to know about changes to the state, right?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些状态在应用程序中共享，一些状态由几个组件共享，还有一些状态由组件本身本地管理。如果组件只是函数，它们如何跨渲染持久化其状态？它们的变量在执行完毕后不是丢失了吗？React又是如何知道变量发生变化的？如果React忠实地试图匹配状态和UI，它肯定需要知道状态的变化，对吧？
- en: The simplest way to persist state across calls to your components and keep React
    in the loop when you change a component’s state is the `useState` hook. The `useState`
    hook is a function that enlists React’s help to manage state values. When you
    call the `useState` hook, it returns both the latest state value *and* a function
    for updating the value. Using the updater function keeps React in the loop and
    lets it do its syncy business.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用组件时持久化状态并保持React在状态改变时处于循环中的最简单方法是使用`useState`钩子。`useState`钩子是一个函数，它请求React的帮助来管理状态值。当你调用`useState`钩子时，它返回最新的状态值以及一个用于更新值的函数。使用更新函数使React保持循环并让它完成其同步任务。
- en: 'This section introduces the `useState` hook, covering why we need it and how
    it’s used. In particular, we look at the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了`useState`钩子，涵盖了为什么我们需要它以及如何使用它。特别是，我们查看以下内容：
- en: Why just assigning values to variables doesn’t let React do its job
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么仅仅将值赋给变量不能让React完成其工作
- en: How `useState` returns both a value and a function for updating that value
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`如何返回一个值和一个用于更新该值的函数'
- en: Setting an initial value for the state, both directly as a value and lazily
    as a function
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为状态设置一个初始值，无论是直接作为值还是作为函数的懒加载
- en: Using the updater function to let React know you want to change the state
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更新函数让React知道你想要更改状态
- en: Making sure you have the latest state when you call the updater function and
    need to use an existing value to generate a new value
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在调用更新函数时你有最新的状态，并且需要使用现有值来生成新值
- en: That list might seem a little scary, but the `useState` hook is very easy to
    use (and you’ll be using it a lot!), so don’t worry; we’re just covering all the
    bases. Before we call `useState` for the first time, let’s see what happens if
    we just try to manage the state ourselves.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可能看起来有点吓人，但`useState`钩子非常容易使用（你将大量使用它！），所以不要担心；我们只是在覆盖所有基础。在我们第一次调用`useState`之前，让我们看看如果我们只是尝试自己管理状态会发生什么。
- en: 2.2.1 Assigning new values to variables doesn’t update the UI
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 将新值赋给变量不会更新UI
- en: 'Figure 2.8 shows what we want from our first attempt at the `BookablesList`
    component: a list of four bookable rooms with the Lecture Hall selected.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8显示了我们对`BookablesList`组件第一次尝试想要的结果：一个包含四个可预订房间的列表，并且选定了讲堂。
- en: '![](../Images/2-8.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-8.png)'
- en: Figure 2.8 The `BookablesList` component showing a list of rooms with the selected
    room highlighted
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 显示了`BookablesList`组件，其中突出显示了选中的房间列表
- en: To display the list of rooms, the `BookablesList` component needs to get its
    hands on the data for the list. It imports the data from our static.json database
    file. The component also needs to track which bookable is currently selected.
    Listing 2.7 shows the code for the component, with a room selection hardcoded
    by setting `bookableIndex` to `1`. (*Notice we’re on a new Git branch; switch
    to it with the command* `git` `checkout` `0202-hard-coded`.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示房间列表，`BookablesList`组件需要获取列表的数据。它从我们的静态.json数据库文件中导入数据。组件还需要跟踪当前选中的可预订项。列表2.7显示了组件的代码，通过将`bookableIndex`设置为`1`来硬编码房间选择。（*注意我们正在一个新的Git分支上；使用命令*
    `git checkout 0202-hard-coded` 切换到该分支。）
- en: 'Branch: 0202-hard-coded, File: /src/components/Bookables/BookablesList.js'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0202-hard-coded，文件：/src/components/Bookables/BookablesList.js
- en: Listing 2.7 The `BookablesList` component with hardcoded selection
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 带有硬编码选择的`BookablesList`组件
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Use object destructuring to assign the bookables data to a local variable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用对象解构将可预订数据分配给一个局部变量。
- en: ❷ Set the group of bookables to be shown.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置要显示的可预订项组。
- en: ❸ Filter the bookables to just those in the group.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 过滤可预订项以仅显示该组中的项。
- en: ❹ Hardcode the index of the selected bookable.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 硬编码选中可预订项的索引。
- en: ❺ Map over the bookables to create a list item for each one.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对可预订项进行映射以创建每个项的列表项。
- en: ❻ Set the class by comparing the current index to the selected index.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通过比较当前索引和所选索引来设置类。
- en: 'The code assigns the array of bookables from the static.json file to a local
    variable called `bookables`. We could’ve taken an extra step:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将来自静态.json 文件的图书可预约项数组分配给一个名为 `bookables` 的局部变量。我们本可以采取额外的步骤：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But we don’t need the data for anything else, so we did our assignment to `bookables`
    directly inside the import:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不需要其他任何数据，所以我们直接在导入中为 `bookables` 进行了赋值：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This *destructuring* approach is one we use often throughout the book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 *解构* 方法是我们在这本书中经常使用的方法。
- en: 'With the array of bookables in hand, we filter it to get just those bookables
    in the specified group:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有图书可预约项数组后，我们过滤它以获取指定组中的那些图书可预约项：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `filter` method returns a new array, and we assign that to the `bookablesInGroup`
    variable. We then map over the `bookablesInGroup` array to generate the list of
    bookables for display. Within the map function, I use short variable names, `b`
    for bookable and `i` for index, because they’re used right away, close to their
    assignment. I think their meaning is clear, but you may prefer more descriptive
    variable names.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 方法返回一个新数组，我们将它分配给 `bookablesInGroup` 变量。然后我们对 `bookablesInGroup` 数组进行映射以生成显示的图书可预约项列表。在映射函数中，我使用了简短的变量名，`b`
    代表图书可预约项，`i` 代表索引，因为它们在分配后立即使用，并且靠近它们的分配位置。我认为它们的含义是清晰的，但你可能更喜欢更具描述性的变量名。'
- en: To display our new component, we need to wire it into the `BookablesPage` component.
    The following listing shows the two changes needed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示我们的新组件，我们需要将其连接到 `BookablesPage` 组件。以下列表显示了所需的两个更改。
- en: 'Branch: 0202-hard-coded, File: /src/components/Bookables/BookablesPage.js'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0202-hard-coded，文件：/src/components/Bookables/BookablesPage.js
- en: Listing 2.8 The `BookablesPage` component showing the `BookablesList`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 显示 `BookablesList` 的 `BookablesPage` 组件
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Import the new component.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入新的组件。
- en: ❷ Replace the placeholder text with the component.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将占位文本替换为组件。
- en: Have a go at changing the hardcoded index value in `BookablesList`. The component
    will always highlight the bookable with the specified index—so far, so good. But,
    it’s all very well changing the code to change the highlighted room. What we really
    want is for the user to change it by clicking a bookable, so let’s add an event
    handler to each list item button. Clicking a bookable should select it, and the
    UI should update to highlight the selected item. The following listing includes
    a `changeBookable` function and an `onClick` event handler that calls it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改 `BookablesList` 中的硬编码索引值。组件将始终突出显示具有指定索引的图书可预约项——到目前为止，一切顺利。但是，更改代码以更改突出显示的房间是很好的，但我们真正想要的是让用户通过点击图书可预约项来更改它，所以让我们为每个列表项按钮添加一个事件处理器。点击图书可预约项应该选择它，并且
    UI 应该更新以突出显示所选项。以下列表包括一个 `changeBookable` 函数和一个调用它的 `onClick` 事件处理器。
- en: 'Branch: 0203-direct-change, File: /src/components/Bookables/BookablesList.js'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0203-direct-change，文件：/src/components/Bookables/BookablesList.js
- en: Listing 2.9 Adding an event handler to the `BookablesList` component
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 向 `BookablesList` 组件添加事件处理器
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Declare the variable with let because it will be assigned new values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `let` 声明变量，因为它将被分配新的值。
- en: ❷ Declare a function that assigns the index of the clicked bookable to the bookableIndex
    variable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 声明一个函数，将点击的图书可预约项的索引分配给 `bookableIndex` 变量。
- en: ❸ Include an onClick handler that passes the index of the clicked bookable to
    the changeBookable function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 包含一个 `onClick` 处理器，将点击的图书可预约项的索引传递给 `changeBookable` 函数。
- en: Clicking one of the rooms now assigns that room’s index to the `bookableIndex`
    variable. *Et voilà*! Oh. Hang on . . . If you run the code in listing 2.9 and
    try clicking different rooms, you’ll see that the highlighting doesn’t change.
    But, the code *does* update the `bookableIndex` value! You can check the console
    to see the index being logged. Why is the new selection not shown on the screen?
    Why has React not updated the UI? Why do people always ignore me?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击其中一个房间会将该房间的索引分配给 `bookableIndex` 变量。*瞧！* 哦。等等……如果你运行列表 2.9 中的代码并尝试点击不同的房间，你会看到突出显示没有改变。但是，代码
    *确实* 更新了 `bookableIndex` 的值！你可以检查控制台以查看正在记录的索引。为什么新的选择没有显示在屏幕上？为什么 React 没有更新
    UI？为什么人们总是忽略我？
- en: 'It’s okay, deep breaths. Remember, components are functions that return UI.
    React calls the functions to get a description of the UI. How does React know
    when to call the function and update the UI? Just because you change the value
    of a variable within your component function doesn’t mean React will notice. If
    you want to get noticed, you can’t just say “Hello, World!” to people in your
    head; you have to say it out loud. Figure 2.9 shows what happens when you directly
    change a value in a component: React doesn’t notice. It’s happy, whistling away,
    polishing its widgets—and the UI stays rock-solid, unchanged.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题，深呼吸。记住，组件是返回UI的函数。React调用这些函数以获取UI的描述。React是如何知道何时调用函数并更新UI的呢？仅仅因为你在组件函数中更改了变量的值，并不意味着React会注意到。如果你想引起注意，你不能只是在心里对人说“你好，世界！”；你必须大声说出来。图2.9显示了在组件中直接更改值时会发生什么：React没有注意到。它很快乐，吹着口哨，打磨着它的小玩意儿——UI保持坚如磐石，没有变化。
- en: '![](../Images/2-9.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-9.png)'
- en: Figure 2.9 Directly changing a variable in our component code doesn’t update
    the UI.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 直接在我们的组件代码中更改变量不会更新UI。
- en: So how do we get React’s attention and let it know it has work to do? We call
    the `useState` hook.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何吸引React的注意并让它知道它有工作要做？我们调用 `useState` 钩子。
- en: 2.2.2 Calling useState returns a value and an updater function
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 调用 `useState` 返回一个值和一个更新函数
- en: We want to alert React that a value used within a component has changed so it
    can rerun the component and update the UI. Just updating the variable directly
    won’t do. We need a way of changing that value, some kind of updater function,
    that triggers React to call the component with the new value and get the updated
    UI, as shown in figure 2.10.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想通知React，组件内使用的值已更改，以便它可以重新运行组件并更新UI。仅仅直接更新变量是不够的。我们需要一种更改该值的方法，某种类型的更新函数，它可以触发React调用组件并使用新值获取更新的UI，如图2.10所示。
- en: '![](../Images/2-10.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-10.png)'
- en: Figure 2.10 Rather than changing a value directly, we call an updater function.
    The updater function changes the value, and React updates the display with the
    recalculated UI from the component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 而不是直接更改一个值，我们调用一个更新函数。更新函数更改值，React使用从组件重新计算的用户界面来更新显示。
- en: To avoid our component state value disappearing when the component code finishes
    running, we get React to manage the value for us. That’s what the `useState` hook
    is for. Every time React calls our component to get ahold of its UI, the component
    can ask React for the latest state value and for a function to update the value.
    The component can use the value when generating its UI and use the updater function
    when changing the value, for example, in response to a user clicking an item in
    a list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免组件代码运行完成后组件状态值消失，我们让React为我们管理这个值。这就是 `useState` 钩子的作用。每次React调用我们的组件以获取其UI时，组件都可以请求React提供最新的状态值和更新值的函数。组件可以在生成其UI时使用该值，并在更改值时使用更新函数，例如，在用户点击列表中的项目时。
- en: Calling `useState` returns a value and its updater function in an array with
    two elements, as shown in figure 2.11.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如图2.11所示，调用 `useState` 返回一个值和其更新函数，包含两个元素的数组。
- en: '![](../Images/2-11.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-11.png)'
- en: 'Figure 2.11 The `useState` function returns an array with two elements: a value
    and an updater function.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 `useState` 函数返回一个包含两个元素的数组：一个值和一个更新函数。
- en: 'You could assign the returned array to a variable, and then access the two
    elements individually, by index, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将返回的数组分配给一个变量，然后通过索引单独访问两个元素，如下所示：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ The useState function returns an array.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `useState` 函数返回一个数组。
- en: ❷ The first element is the value.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一个元素是值。
- en: ❸ The second element is the function for updating the value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 第二个元素是用于更新值的函数。
- en: 'But it’s more common to use array destructuring and assign the returned elements
    to variables in one step:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但更常见的是使用数组解构，并在一步中将返回的元素分配给变量：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Array destructuring lets us assign elements in an array to variables of our
    choosing. The names `selectedRoom` and `setSelectedRoom` are arbitrary and our
    choice, although it’s common to start the variable name for the second element,
    the updater function, with `set`. The following would work just as well:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构允许我们将数组中的元素分配给我们的变量。`selectedRoom` 和 `setSelectedRoom` 这些名称是任意选择的，虽然通常会将第二个元素（更新函数）的变量名以
    `set` 开头。以下也是可行的：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you want to set an initial value for the variable, pass the initial value
    as an argument to the `useState` function. When React first runs your component,
    `useState` will return the two-element array as usual but will assign the initial
    value to the first element of the array, as shown in figure 2.12.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为变量设置一个初始值，请将初始值作为参数传递给`useState`函数。当React首次运行你的组件时，`useState`将像往常一样返回一个两元素数组，但会将初始值分配给数组的第一个元素，如图2.12所示。
- en: '![](../Images/2-12.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-12.png)'
- en: Figure 2.12  When the component first runs, React assigns the initial value
    you pass to `useState` to the `selected` variable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 当组件首次运行时，React将传递给`useState`的初始值分配给`selected`变量。
- en: 'The first time the following line of code is executed within a component, React
    returns the value `Lecture` `Hall` as the first element in the array. The code
    assigns that value to the `selected` variable:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下代码行在组件中首次执行时，React将返回数组中的第一个元素`Lecture Hall`作为值`Lecture Hall`。代码将该值分配给`selected`变量：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s update the `BookablesList` component to use the `useState` hook to ask
    React to manage the value of the selected item’s index. We pass it `1` as the
    initial index. You should see the Lecture Hall highlighted when the `BookablesList`
    component first appears on the screen, as shown again in figure 2.13.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`BookablesList`组件，使用`useState`钩子请求React管理选定项索引的值。我们将其`1`作为初始索引传递。你应该看到当`BookablesList`组件首次出现在屏幕上时，演讲厅被突出显示，如图2.13再次所示。
- en: '![](../Images/2-13.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-13.png)'
- en: Figure 2.13 The `BookablesList` component with Lecture Hall selected
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 选择演讲厅的`BookablesList`组件
- en: The following listing shows the updated code for the component. It includes
    an `onClick` event handler that uses the updater function assigned to `setBookableIndex`
    to change the selected index when a user clicks a bookable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了组件的更新代码。它包括一个`onClick`事件处理程序，该处理程序使用分配给`setBookableIndex`的更新器函数在用户点击可预订项时更改选定的索引。
- en: 'Branch: 0204-set-index, File: /src/components/Bookables/BookablesList.js'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0204-set-index，文件：/src/components/Bookables/BookablesList.js
- en: Listing 2.10 Triggering a UI update when changing the selected room
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 在更改选定房间时触发UI更新
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Import the useState hook.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入`useState`钩子。
- en: ❷ Call useState and assign the returned state value and updater function to
    variables.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用`useState`并将返回的状态值和更新器函数分配给变量。
- en: ❸ Use the state value when generating the UI.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在生成UI时使用状态值。
- en: ❹ Use the updater function to change the state value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用更新器函数更改状态值。
- en: React runs the `BookablesList` component code, returning the value for `bookableIndex`
    from the call to `useState`. The component uses that value when generating the
    UI to set the correct `className` attribute for each `li` element. When a user
    clicks a bookable, the `onClick` event handler uses the updater function, `setBookableIndex`,
    to tell React to update the value it’s managing. If the value has changed, React
    knows it’ll need a new version of the UI. React runs the `BookablesList` code
    again, assigning the updated state value to `bookableIndex`, letting the component
    generate the updated UI. React can then compare the newly generated UI to the
    old version and decide how to update the display efficiently.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: React运行`BookablesList`组件代码，从`useState`调用返回`bookableIndex`的值。组件使用该值在生成UI时为每个`li`元素设置正确的`className`属性。当用户点击可预订项时，`onClick`事件处理程序使用更新器函数`setBookableIndex`告诉React更新它所管理的值。如果值已更改，React知道它将需要一个新版本的UI。React再次运行`BookablesList`代码，将更新的状态值分配给`bookableIndex`，让组件生成更新的UI。React可以比较新生成的UI与旧版本，并决定如何高效地更新显示。
- en: With `useState`, React is now listening. I don’t feel so lonely anymore. It’s
    living up to its promise of keeping the state in sync with the UI. The `BookablesList`
    component describes the UI for a particular state and provides a way for users
    to change the state. React then does its magic, checking whether the new UI is
    different from the old (*diffing*), batching and scheduling updates, deciding
    on an efficient way to update DOM elements, and then doing the deed and reaching
    out to the DOM on our behalf. We fixate on the state; React does its diffing and
    updates the DOM.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useState`，React现在正在监听。我不再感到那么孤独了。它正在实现其保持状态与UI同步的承诺。`BookablesList`组件描述了特定状态下的UI，并为用户提供了一种更改状态的方法。React随后施展其魔法，检查新的UI是否与旧的不同（*diffing*），批量处理和安排更新，决定以高效的方式更新DOM元素，然后为我们代表执行操作并接触DOM。我们专注于状态；React执行diffing并更新DOM。
- en: Challenge 2.1
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战2.1
- en: Create a `UsersList` component that shows the list of users from the database.
    Enable the selection of a user and wire the component into the `UsersPage`. (Remember,
    if you haven’t already, you can copy the full database file from the app’s GitHub
    repo.)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`UsersList`组件，显示从数据库中获取的用户列表。启用用户选择，并将组件连接到`UsersPage`。（记住，如果你还没有这样做，你可以从应用的GitHub仓库中复制完整的数据库文件。）
- en: Challenge 2.2
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战2.2
- en: Update the `UserPicker` drop-down list component so that it shows the users
    as options in the list. Don’t worry about wiring up any event handlers for now.
    The challenge tasks are implemented in the 0205-user-lists branch.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`UserPicker`下拉列表组件，使其显示列表中的用户选项。现在不必担心连接任何事件处理程序。挑战任务在0205-user-lists分支中实现。
- en: In listing 2.10, we passed an initial value of `1` to `useState`. A user clicking
    a different bookable *replaces* that value with another number. What if we want
    to store something more complicated, like an object, as state? In that case, we
    need to be a bit more careful when updating the state. Let’s see why.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表2.10中，我们向`useState`传递了一个初始值`1`。当用户点击不同的可预订项时，该值会被另一个数字替换。如果我们想存储更复杂的东西，比如对象，作为状态，我们更新状态时就需要更加小心。让我们看看原因。
- en: 2.2.3 Calling the updater function replaces the previous state value
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 调用更新函数替换之前的状态值
- en: If you’re coming from the class-based approach to component building in React,
    you’re used to state being an object with different properties for different state
    values. Moving to function components, you may try to replicate that state-as-an-object
    approach. It may feel more natural to have a single state object and have new
    state updates merge with the existing state.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从React中基于类的组件构建方法转换过来，你习惯于状态是一个对象，具有不同属性的不同状态值。转换到函数组件时，你可能试图复制这种状态作为对象的方法。拥有一个单一的状态对象并且新的状态更新与现有状态合并可能感觉更自然。
- en: But the `useState` hook is easy to use and easy to call multiple times, once
    for each state value you want React to monitor. It’s worth getting used to separate
    calls to `useState` for each state property, as discussed further in section 2.4,
    rather than clinging to what’s familiar. If you need to work with objects as state
    values or want to group some related values together (maybe a length and width,
    for example), you should be aware of how `setState` as a function component updater
    function is different from `this.setState` you use with a class component. In
    this section, we take a brief look at updating the state of an object in the two
    types of components.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但`useState`钩子易于使用且易于多次调用，一次用于每个你希望React监控的状态值。值得养成为每个状态属性单独调用`useState`的习惯，如第2.4节中进一步讨论的，而不是坚持熟悉的做法。如果你需要以对象作为状态值或想要将一些相关值组合在一起（比如长度和宽度），你应该意识到函数组件的更新函数`setState`与类组件中使用的`this.setState`的不同。在本节中，我们将简要探讨在两种组件类型中更新对象状态。
- en: The class component approach
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件方法
- en: 'With classes, you set up the state as an object in the constructor (or as a
    static property on the class):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类时，你在构造函数（或类上的静态属性）中设置状态为一个对象：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To update the state (in an event handler, for example), you call `this.setState`,
    passing an object with any changes you want to make:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新状态（例如在事件处理程序中），你调用`this.setState`，传递一个包含任何你想做的更改的对象：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: React merges the object you passed to `setState` with the existing state. In
    the preceding example, it updates the `bookableIndex` property but leaves the
    `group` property alone, as shown in figure 2.14.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: React将你传递给`setState`的对象与现有状态合并。在上面的例子中，它更新了`bookableIndex`属性，但`group`属性保持不变，如图2.14所示。
- en: '![](../Images/2-14.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-14.png)'
- en: Figure 2.14 In a class component, calling the updater function (`this.setState`)
    merges the new properties with the existing state object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 在类组件中，调用更新函数（`this.setState`）会将新属性与现有状态对象合并。
- en: The function component approach
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件方法
- en: 'In contrast, for the new hooks approach, the updater function *replaces* the
    previous state value with the value you pass to the function. Now, that’s straightforward
    if you have simple state values, like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，对于新的hooks方法，更新函数会将之前的状态值替换为你传递给函数的值。如果你有简单的状态值，这很简单，就像这样：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But if you decide to store JavaScript objects in state, you need to tread carefully.
    The updater function will replace the old object entirely. Say you initialize
    the state like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你决定在状态中存储JavaScript对象，你需要小心行事。更新函数将完全替换旧对象。比如说，你这样初始化状态：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you call the updater function, `setState`, with just the changed `bookableIndex`
    property, then you lose the `group` property:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用改变的 `bookableIndex` 属性调用更新器函数 `setState`，那么你将丢失 `group` 属性：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The old state object is replaced by the new one, as shown in figure 2.15.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 旧状态对象被新对象替换，如图 2.15 所示。
- en: '![](../Images/2-15.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-15.png)'
- en: Figure 2.15 In a function component, calling an updater function (returned by
    `useState`) replaces the old state value with whatever you pass to the updater
    function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 在函数组件中，调用更新器函数（由 `useState` 返回）用你传递给更新器函数的内容替换旧状态值。
- en: 'So, if you really need to use an object with the `useState` hook, copy across
    all the properties from the old object when you set a new property value:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你确实需要使用带有 `useState` 钩子的对象，在设置新属性值时，请复制旧对象的所有属性：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice how the spread operator, `...state`, is used in the preceding snippet
    to copy all of the properties from the old state to the new. In fact, to ensure
    that you have the latest state when setting new values based on old, you can pass
    a function as the argument to the updater function, like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前面的代码片段中如何使用展开运算符 `...state` 来复制旧状态的所有属性到新状态。实际上，为了确保在基于旧状态设置新值时你有最新的状态，你可以将一个函数作为参数传递给更新器函数，如下所示：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Pass a function to setState.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将函数传递给 `setState`。
- en: ❷ Use the old state value when setting the new one.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在设置新值时使用旧状态值。
- en: React will pass in the latest state as the first argument. This function version
    of the updater function is discussed in more detail in section 2.2.5.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: React 将传递最新的状态作为第一个参数。这个更新器函数的函数版本将在 2.2.5 节中更详细地讨论。
- en: With that brief caveat about working with objects out of the way, there’s one
    more feature of the `useState` hook API we need to mention before calling `useState`
    multiple times with abandon. Occasionally, you might need to hold off on calculating
    expensive initial values. There’s a function for that.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理对象的问题得到简要说明后，我们还需要在多次调用 `useState` 之前提到 `useState` 钩子 API 的另一个特性。偶尔，你可能需要推迟计算昂贵的初始值。为此有一个函数。
- en: 2.2.4 Passing a function to useState as the initial value
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 将函数传递给 `useState` 作为初始值
- en: 'Sometimes a component may need to do some work to calculate an initial value
    for a piece of state. Maybe the component is passed a tangled string of data from
    a legacy storage system and needs to extract a nugget of useful info from among
    the frayed knots. Unravelling the string may take a while, and you want to do
    the work only once. This approach is wasteful:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个组件可能需要做一些工作来计算某个状态片段的初始值。也许组件从遗留存储系统中接收了一串复杂的数据，并需要从错综复杂的结中提取有用的信息。解开这根线可能需要一段时间，而你只想做一次。这种方法是浪费的：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Whenever `ShinyComponent` runs, maybe in response to setting another piece of
    state, the expensive `untangle` function runs as well. But `useState` uses its
    initial value argument on only the first call. After the first call, it won’t
    use the value that `untangle` returns. Running the expensive `untangle` function
    again and again is a waste of time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 `ShinyComponent` 运行时，可能是在设置另一状态片段的响应中，昂贵的 `untangle` 函数也会运行。但是 `useState`
    只在第一次调用时使用其初始值参数。在第一次调用之后，它不会使用 `untangle` 返回的值。反复运行昂贵的 `untangle` 函数是浪费时间。
- en: Luckily, the `useState` hook accepts a function as its argument, a *lazy initial
    state*, as shown in figure 2.16.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`useState` 钩子接受一个函数作为其参数，一个*懒初始化状态*，如图 2.16 所示。
- en: '![](../Images/2-16.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-16.png)'
- en: Figure 2.16 You can pass a function to `useState` as the initial value. React
    will use the function’s return value as the initial value.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 你可以将函数传递给 `useState` 作为初始值。React 将使用函数的返回值作为初始值。
- en: 'React executes the function only the first time the component is rendered.
    It uses the function’s return value as the initial state:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: React 只在组件首次渲染时执行该函数。它使用函数的返回值作为初始状态：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Use the lazy initial state if you need to undertake expensive work to generate
    an initial value for a piece of state.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要执行昂贵的操作来生成某个状态片段的初始值，请使用懒初始化状态。
- en: 2.2.5 Using the previous state when setting the new state
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.5 使用旧状态设置新状态
- en: It would be great if users could more easily cycle through the bookables in
    the `BookablesList` component. Let’s add a Next button that does the cycling,
    as shown in figure 2.17\. If we move the focus to the Next button, users can activate
    it by using the keyboard.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户能够更轻松地在`BookablesList`组件中的可读内容之间循环，那就太好了。让我们添加一个“下一步”按钮来实现循环，如图2.17所示。如果我们把焦点移到“下一步”按钮上，用户可以通过键盘激活它。
- en: '![](../Images/2-17.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-17.png)'
- en: Figure 2.17 Clicking the Next button selects the next bookable in the list.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 点击“下一步”按钮选择列表中的下一个可读内容。
- en: The Next button needs to increment the `bookableIndex` state value, wrapping
    back around to 0 when it goes past the last bookable. The following listing shows
    the implementation of the Next button.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: “下一步”按钮需要增加`bookableIndex`状态值，当它超过最后一个可读内容时，会回绕到0。下面的列表显示了“下一步”按钮的实现。
- en: 'Branch: 0206-next-button, File: /src/components/Bookables/BookablesList.js'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0206-next-button，文件：/src/components/Bookables/BookablesList.js
- en: Listing 2.11 Passing a function to `setBookableIndex`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 向`setBookableIndex`传递一个函数。
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Import a Font Awesome icon.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入一个Font Awesome图标。
- en: ❷ Create an event handler for the Next button.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为“下一步”按钮创建一个事件处理程序。
- en: ❸ Pass the updater function a function to increment the index.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将更新函数传递给一个用于增加索引的函数。
- en: ❹ Include a button to call the nextBookable function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 包含一个按钮来调用`nextBookable`函数。
- en: 'In the event handler for the Next button, `nextBookable`, we call the updater
    function, `setBookableIndex`, passing it a function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在“下一步”按钮的事件处理程序`nextBookable`中，我们调用更新函数`setBookableIndex`，并传递给它一个函数：
- en: '[PRE37]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function uses the `%` operator that gives the remainder when dividing. When
    `i` `+` `1` is the same as the number of bookables, `bookablesInGroup.length`,
    the remainder is `0`, and the index cycles back to the start. But why not just
    use the state value for the index that we already have?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用`%`运算符，它给出除法时的余数。当`i + 1`与可读内容的数量`bookablesInGroup.length`相同时，余数为`0`，索引回绕到开始。但为什么不用我们已有的状态值作为索引呢？
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By using hooks to hand over management of our state values to React, we don’t
    just ask it to update values and trigger re-renders; we also give it permission
    to efficiently schedule when any updates take place. React can intelligently batch
    updates together and ignore redundant updates.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用钩子将我们状态值的管理权交给React，我们不仅请求它更新值并触发重新渲染；我们还赋予它高效安排任何更新何时发生的权限。React可以智能地将更新批量处理在一起，并忽略冗余的更新。
- en: When we want to update a state value based on its previous value, as in our
    Next button example, instead of passing the updater function a value to set, we
    can pass it a function. React will pass that function the current state value
    and will use the return value of that function as the new state value. All the
    pieces are shown in figure 2.18.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要基于其前一个值更新一个状态值时，就像我们的“下一步”按钮示例中那样，我们不是传递一个要设置的值给更新函数，而是传递一个函数。React将传递当前状态值给这个函数，并将该函数的返回值用作新的状态值。所有这些都在图2.18中展示。
- en: '![](../Images/2-18.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-18.png)'
- en: Figure 2.18 Pass the updater function a function that uses the old state value
    and returns a new state value.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 将一个函数传递给更新函数，该函数使用旧的状态值并返回一个新的状态值。
- en: By passing a function, we ensure that any new values that are based on old values
    have the latest information with which to work.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递一个函数，我们确保任何基于旧值的新的值都有最新的信息来工作。
- en: Listing 2.11 uses a separate function, `nextBookable`, for responding to clicks
    on the Next button but puts the handler for responding to clicks on bookables
    inline in the `onClick` attribute. This is just a personal choice; when a handler
    does more than call a simple updater function, I tend to put it in its own function
    rather than inline. In the case of listing 2.11, we could just as easily have
    the Next button handler inline or the bookable click handler in its own named
    function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11使用一个单独的函数`nextBookable`来响应“下一步”按钮的点击，但在`onClick`属性中将响应点击可读内容的处理程序内联。这只是一个个人选择；当处理程序执行的操作不仅仅是调用一个简单的更新函数时，我倾向于将其放在自己的函数中而不是内联。在列表2.11的情况下，我们同样可以将“下一步”按钮的处理程序内联或可读内容点击处理程序放在自己的命名函数中。
- en: So, we can call `useState` to ask React to manage a value for us. But, surely,
    we’ll need more than a single state value in our component. Let’s see how to handle
    multiple state values as we give users the ability to choose groups in the `BookablesList`
    component.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以调用`useState`来请求React为我们管理一个值。但，当然，在我们的组件中我们可能需要不止一个状态值。让我们看看如何处理多个状态值，当我们给用户在`BookablesList`组件中选择组的能力时。
- en: 2.3 Calling useState multiple times to work with multiple values
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 多次调用useState以处理多个值
- en: 'Having seen how `useState` works in some detail, it’s time to get our money’s
    worth. We’re not limited to a solitary piece of information, or even a solitary
    object with many properties. If we’re interested in multiple values to drive a
    component’s UI, we can just keep calling that hook: `useState` for this, `useState`
    for that, `useState` for the other. We can `useState` all the things!'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细了解了`useState`的工作原理后，现在是时候物尽其用了。我们不仅限于单一的信息，甚至不是一个具有许多属性的单一对象。如果我们对多个值感兴趣，以驱动组件的UI，我们只需继续调用该钩子：`useState`用于这个，`useState`用于那个，`useState`用于其他。我们可以使用`useState`来处理所有事情！
- en: 'In this section, we add to the `BookablesList` component, first letting users
    switch between groups of bookables, and then displaying the details about the
    selected bookable. Remember, it’s our job to fixate on the state, so we need to
    work with a few values:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向`BookablesList`组件添加功能，首先让用户在可预订项的组之间切换，然后显示所选可预订项的详细信息。记住，我们的任务是专注于状态，因此我们需要与几个值一起工作：
- en: The selected group
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选定的组
- en: The selected bookable
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选定的可预订项
- en: Whether the component has the bookable availability (days and sessions) showing
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是否显示可预订项的可用性（天数和时段）
- en: By the end of this section, we call `useState` for all three state values. We
    embed the values returned into our UI and use the updater functions to change
    the state when the user chooses a group or a bookable or toggles the display of
    details.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们为所有三个状态值调用`useState`。我们将返回的值嵌入到我们的UI中，并使用更新函数在用户选择组或可预订项或切换详细信息显示时更改状态。
- en: 2.3.1 Using a drop-down list to set state
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 使用下拉列表设置状态
- en: 'Let’s start by updating the `BookablesList` component so that users can select
    a type of resource to book: Rooms or Kit. Two instances of the component are shown
    in figure 2.19, the first showing bookables in the Rooms group, and the second
    showing bookables in the Kit group.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新`BookablesList`组件开始，使用户能够选择要预订的资源类型：房间或工具包。图2.19显示了该组件的两个实例，第一个显示了房间组中的可预订项，第二个显示了工具包组中的可预订项。
- en: '![](../Images/2-19.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-19.png)'
- en: 'Figure 2.19 Two views of the `BookablesList` component with a drop-down list
    for selecting the type of bookable: the first with Rooms selected and the second
    with Kit selected'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 `BookablesList`组件的两个视图：带有下拉列表选择可预订项类型的视图：第一个选择了房间，第二个选择了工具包
- en: 'We want the user to make two selections: the group to display, Rooms or Kit,
    and the bookable within the group. Changing either variable should update the
    display, so we want React to track them both. Should we create some kind of state
    object to pass to React via the `useState` hook? Well, no. The easiest approach
    is just to call `useState` twice:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户进行两次选择：要显示的组，房间或工具包，以及组内的可预订项。更改任何变量都应更新显示，因此我们希望React跟踪它们两个。我们应该创建某种状态对象通过`useState`钩子传递给React吗？嗯，不。最简单的方法是调用`useState`两次：
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: React uses the order of the calls to determine which tracked variable is which.
    In the previous code snippet, every time React invokes the component code, the
    first call to `useState` assigns the first tracked value to the `group` variable,
    and the second call to `useState` assigns the second tracked value to the `bookableIndex`
    variable. `setBookableIndex` updates the second tracked value, and `setGroup`
    updates the first.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: React使用调用顺序来确定哪个跟踪变量是哪个。在前面的代码片段中，每次React调用组件代码时，`useState`的第一次调用将第一个跟踪值分配给`group`变量，而`useState`的第二次调用将第二个跟踪值分配给`bookableIndex`变量。`setBookableIndex`更新第二个跟踪值，而`setGroup`更新第一个。
- en: Your boss keeps glancing your way, so let’s get the group-picking functionality
    implemented for the `BookablesList` component. The following listing shows the
    latest code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您的老板一直在看着您，所以让我们为`BookablesList`组件实现组选择功能。以下列表显示了最新的代码。
- en: 'Branch: 0207-groups, File: /src/components/Bookables/BookablesList.js'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0207-groups，文件：/src/components/Bookables/BookablesList.js
- en: Listing 2.12 The `BookablesList` component with two `useState` calls
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12 `BookablesList`组件使用两次`useState`调用
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Use the first tracked state value to hold the selected group.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用第一个跟踪状态值来保存所选组。
- en: ❷ Use the second tracked state value to hold the selected bookable index.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用第二个跟踪状态值来保存所选可预订项索引。
- en: ❸ Assign an array of unique group names to the groups variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将一组唯一的组名分配给`groups`变量。
- en: ❹ Include an event handler to update the selected group.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 包含一个事件处理程序来更新所选组。
- en: ❺ Create a drop-down list to show each group in the bookables data.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建一个下拉列表以显示可预订数据中的每个组。
- en: 'The code assigns the `group` variable the initial value of `Kit`, so the component
    starts off showing the list of bookables in the Kit group. When a user selects
    a new group from the drop-down list, the `setGroup` updater function lets React
    know the value has changed. To get the group names for the drop-down list, we
    put the bookables data through a few transformations. First, we create an array
    of just the group names:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将`group`变量分配给初始值`Kit`，因此组件一开始就显示Kit组中的可预订项列表。当用户从下拉列表中选择新组时，`setGroup`更新器函数让React知道值已更改。要获取下拉列表中的组名，我们将可预订数据通过几个转换。首先，我们创建一个仅包含组名的数组：
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we create a `Set` from the array of group names. Sets contain only unique
    values, so any duplicates will be discarded:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从组名数组创建一个`Set`。集合只包含唯一值，因此任何重复项都将被丢弃：
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finally, we create a new array and spread the `Set` elements into it. The new
    array contains only unique group names. Exactly what we’re after!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的数组并将`Set`元素展开到其中。新数组只包含唯一的组名。这正是我们想要的！
- en: '[PRE43]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the JS-Fu is a bit dense, you could always create a `getUniqueValues` utility
    function to make things more readable:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JS-Fu有点密集，你可以始终创建一个`getUniqueValues`实用函数来使事物更易于阅读：
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ll stick with the terse version because it never changes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持使用简洁版本，因为它永远不会改变。
- en: I hope you agree, working with two pieces of state is pretty easy. We just call
    `useState` twice. To update the state, we call the appropriate updater function.
    The user makes a selection, an event handler updates the state, and React does
    the diffing and tickles the DOM. Let’s do it again!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们同意，使用两件状态项工作相当简单。我们只需调用两次`useState`。要更新状态，我们调用适当的更新器函数。用户进行选择，事件处理程序更新状态，React执行差异比较并触发DOM。让我们再来一次！
- en: 2.3.2 Using a check box to set state
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 使用复选框设置状态
- en: Our next job is to add a details section to the component to give our office
    colleagues a bit more info about each bookable. We make the display of each bookable’s
    availability optional. Figure 2.20 shows the `BookablesList` component with the
    Show Details check box checked; the days and sessions for which the bookable is
    available are visible.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是向组件添加一个详细信息部分，以便我们的办公室同事对每个可预订项有更多了解。我们使每个可预订项的可用性显示为可选。图2.20显示了带有已勾选的“显示详细信息”复选框的`BookablesList`组件；可预订项可用的日期和时段是可见的。
- en: '![](../Images/2-20.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-20.png)'
- en: Figure 2.20 The `BookablesList` component with the availability showing. The
    Show Details check box to the right of the title is checked.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 `BookablesList`组件的可用性显示。标题右侧的“显示详细信息”复选框已勾选。
- en: Figure 2.21 shows the component with the check box unchecked; the days and sessions
    are hidden.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21显示了未勾选复选框的组件；日期和时段被隐藏。
- en: '![](../Images/2-21.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-21.png)'
- en: Figure 2.21 The `BookablesList` component with the availability hidden. The
    Show Details check box to the right of the title is not checked.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 `BookablesList`组件的可用性被隐藏。标题右侧的“显示详细信息”复选框未勾选。
- en: 'In addition to the selected group and the selected bookable index, we now have
    a third piece of state: we need to track whether the details for the selected
    bookable are displayed. The following listing shows the `BookablesList` component
    tracking our three variables via `useState` hook calls.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选定的组和选定的可预订项索引外，我们现在还有第三件状态项：我们需要跟踪是否显示所选可预订项的详细信息。以下列表显示了通过`useState`钩子调用跟踪我们的三个变量的`BookablesList`组件。
- en: 'Branch: 0208-bookable-details, File: /src/components/Bookables/BookablesList.js'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0208-bookable-details，文件：/src/components/Bookables/BookablesList.js
- en: Listing 2.13 The `Bookables` component tracking three variables
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 `Bookables`组件跟踪三个变量
- en: '[PRE45]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Import React.Fragment to wrap multiple elements.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入`React.Fragment`以包裹多个元素。
- en: ❷ Assign the currently selected bookable to its own variable.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将当前选定的可预订项分配给其自己的变量。
- en: ❸ Use a third tracked state value to hold if the details are shown.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用第三个跟踪状态值来保存是否显示详细信息。
- en: ❹ Show the details only if a bookable is selected.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仅当选择可预订项时显示详细信息。
- en: ❺ Include a new UI section for the selected bookable’s details.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 包含一个新UI部分以显示所选可预订项的详细信息。
- en: ❻ Let users toggle the details with a check box.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 允许用户通过复选框切换详细信息。
- en: ❼ Include an event handler to update if the details are shown.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 包含一个事件处理程序以更新是否显示详细信息。
- en: ❽ Show the details only if hasDetails is true.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 仅当`hasDetails`为真时显示详细信息。
- en: ❾ Display a list of available days.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 显示可用日期列表。
- en: ❿ Display a list of available sessions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 显示可用会话的列表。
- en: 'The component uses the current `bookableIndex` to access the selected bookable
    from the `bookablesInGroup` array:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用当前的 `bookableIndex` 从 `bookablesInGroup` 数组中访问所选可预订项：
- en: '[PRE46]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There’s no need to call `useState` to store the bookable object itself because
    it can be derived from the index value already in state. The UI includes a new
    section to show the details of the selected bookable. But the component shows
    the section only if there’s a bookable to display:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要调用 `useState` 来存储可预订对象本身，因为它可以从状态中已有的索引值推导出来。UI 包括一个新部分来显示所选可预订项的详细信息。但是，组件仅在存在可显示的可预订项时显示该部分：
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Similarly, the extra info about the selected bookable is visible only if the
    `hasDetails` state value is `true`; in other words, the check box is checked:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，只有当 `hasDetails` 状态值为 `true` 时，所选可预订项的额外信息才可见；换句话说，复选框被勾选：
- en: '[PRE48]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It seems like our work on the `BookablesList` component is done. We have our
    list of bookables from the currently selected group and the ability to toggle
    the display of details for the selected bookable. But before you pat yourself
    on the back and book out the games room and party supplies, follow these three
    steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们在 `BookablesList` 组件上的工作已经完成。我们有了当前所选组中的可预订项列表，并且能够切换所选可预订项的详细信息显示。但在你自我表扬并预订游戏室和派对用品之前，请遵循以下三个步骤：
- en: Select the Games Room; its details are then displayed.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择游戏室；然后显示其详细信息。
- en: Switch the group to Kit. The list of kit bookables is displayed with no bookable
    selected, and the details disappear. (Which bookable is selected?)
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组切换到 Kit。显示可预订的设备列表，但没有选择任何可预订项，并且详细信息消失。（选择了哪个可预订项？）
- en: Click the Next button. The second item of Kit, Wireless Mics, is selected and
    its details appear.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮。Kit 的第二个项目，无线麦克风，被选中，并显示其详细信息。
- en: There’s a whiff of stale data in the air. Can you work out what’s happening?
    We want user interactions to lead to predictable changes in state. Sometimes that
    means a single interaction should lead to multiple pieces of state changing. The
    next chapter investigates the problem and introduces *reducers*, a mechanism for
    orchestrating more complicated state changes and eliminating stale odors. But
    before we switch hooks, we’ll review what building the `BookablesList` component
    has taught us about function components in general. And before that, here’s a
    challenge!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 空气中有一丝陈旧的数据味道。你能找出发生了什么吗？我们希望用户交互导致状态的可预测变化。有时这意味着单个交互应该导致多个状态的变化。下一章将探讨这个问题，并介绍
    *reducers*，这是一种协调更复杂状态变化并消除陈旧味道的机制。但在我们切换钩子之前，我们将回顾构建 `BookablesList` 组件所教给我们的关于函数组件的一般知识。在此之前，这里有一个挑战！
- en: Challenge 2.3
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 2.3
- en: Update the `UsersList` component to show details for the selected user. Display
    the user’s name, title, and notes. A possible approach is shown in figure 2.22,
    with code in the 0209-user-details branch of the book’s GitHub repo.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `UsersList` 组件以显示所选用户的详细信息。显示用户姓名、职称和备注。一种可能的方法如图 2.22 所示，代码位于书籍 GitHub 仓库的
    0209-user-details 分支中。
- en: '![](../Images/2-22.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-22.png)'
- en: Figure 2.22 The `UsersList` component showing details for the selected user
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 显示所选用户详细信息的 `UsersList` 组件
- en: 2.4 Reviewing some function component concepts
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 回顾一些函数组件概念
- en: 'At this point, our `BookablesList` component is very simple. But some fundamental
    concepts are already at work, concepts that underpin our understanding of function
    components and React Hooks. Having a strong grasp of these concepts will make
    our future discussions throughout the book and your expert use of hooks much easier.
    In particular, here are five key concepts:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 `BookablesList` 组件非常简单。但一些基本概念已经在发挥作用，这些概念是我们对函数组件和 React 钩子理解的基础。对这些概念有牢固的掌握将使我们在本书中的未来讨论以及你对钩子的专家级使用变得更加容易。特别是，这里有五个关键概念：
- en: Components are functions that accept props and return a description of their
    UI.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是接受 props 并返回其 UI 描述的函数。
- en: React invokes the components. As functions, the components run their code and
    then end.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 调用组件。作为函数，组件运行其代码然后结束。
- en: Some variables may persist within closures created by event handlers. Others
    are destroyed when the function ends.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些变量可能存在于事件处理器创建的闭包中。其他变量在函数结束时被销毁。
- en: We can use hooks to ask React to manage values for us. React can pass components
    the latest values and updater functions for those values.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用钩子让 React 帮我们管理值。React 可以将最新的值和更新器函数传递给组件。
- en: By using the updater functions, we let React know of changing values. It can
    rerun the components to get the latest description of the UI.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用更新函数，我们让React知道值的变化。它可以重新运行组件以获取最新的UI描述。
- en: The component cycle diagram in figure 2.23 shows some of the steps involved
    when our `BookablesList` component runs and a user clicks a bookable. Table 2.1
    discusses each step.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23中的组件周期图显示了当我们的`BookablesList`组件运行并且用户点击可预订项时涉及的一些步骤。表2.1讨论了每个步骤。
- en: Table 2.1 Some key steps when using `useState`
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 使用`useState`时的关键步骤
- en: '| Step | What happens? | Discussion |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 发生了什么？ | 讨论 |'
- en: '| 1 | React calls the component. | To generate the UI for the page, React traverses
    the tree of components, calling each one. React will pass each component any props
    set as attributes in the JSX. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 1 | React调用组件。 | 为了生成页面的UI，React遍历组件树，调用每个组件。React将传递给每个组件任何在JSX中设置的属性作为props。|'
- en: '| 2 | The component calls `useState` for the first time. | The component passes
    the initial value to the `useState` function. React sets the current value for
    that `useState` call from that component. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 组件第一次调用`useState`。 | 组件将初始值传递给`useState`函数。React从该组件设置该`useState`调用的当前值。|'
- en: '| 3 | React returns the current value and an updater function as an array.
    | The component code assigns the value and updater function to variables for later
    use. The second variable name often starts with `set` (for example, `value` and
    `setValue`). |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 3 | React将当前值和更新函数作为一个数组返回。 | 组件代码将值和更新函数分配给变量以供以后使用。第二个变量名通常以`set`开头（例如，`value`和`setValue`）。|'
- en: '| 4 | The component sets up an event handler. | The event handler may listen
    for user clicks, for example. The handler will change the state when it runs later.
    React will hook up the handler to the DOM when it updates the DOM in step 6. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 组件设置事件处理器。 | 事件处理器可能监听用户点击，例如。处理器将在稍后运行时更改状态。React将在第6步更新DOM时将处理器连接到DOM。|'
- en: '| 5 | The component returns its UI. | The component uses the current state
    value to generate its user interface and returns it, finishing its work. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 组件返回其UI。 | 组件使用当前状态值来生成其用户界面并返回它，完成其工作。|'
- en: '| 6 | React updates the DOM. | React updates the DOM with any changes needed.
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 6 | React更新DOM。 | React使用所需的任何更改更新DOM。|'
- en: '| 7 | The event handler calls the updater function. | An event fires, and the
    handler runs. The handler uses the updater function to change the state value.
    |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 事件处理器调用更新函数。 | 一个事件被触发，处理器运行。处理器使用更新函数来更改状态值。|'
- en: '| 8 | React updates the state value. | React replaces the state value with
    the value passed by the updater function. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 8 | React更新状态值。 | React用更新函数传递的值替换状态值。|'
- en: '| 9 | React calls the component. | React knows that the state value has changed
    and so must recalculate the UI. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 9 | React调用组件。 | React知道状态值已更改，因此必须重新计算UI。|'
- en: '| 10 | The component calls `useState` for the second time. | This time, React
    will ignore the initial value argument. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 组件第二次调用`useState`。 | 这次，React将忽略初始值参数。|'
- en: '| 11 | React returns the current state value and the updater function. | React
    has updated the state value. The component needs the latest value. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 11 | React返回当前状态值和更新函数。 | React已更新状态值。组件需要最新的值。|'
- en: '| 12 | The component sets up an event handler. | This is a new version of the
    handler and may use the newly updated state value. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 组件设置事件处理器。 | 这是处理器的新版本，可能使用新更新的状态值。|'
- en: '| 13 | The component returns its UI. | The component uses the current state
    value to generate its user interface and returns it, finishing its work. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 组件返回其UI。 | 组件使用当前状态值来生成其用户界面并返回它，完成其工作。|'
- en: '| 14 | React updates the DOM. | React compares the newly returned UI with the
    old and efficiently updates the DOM with any changes needed. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 14 | React更新DOM。 | React将新返回的UI与旧的UI进行比较，并高效地使用所需的任何更改更新DOM。|'
- en: '![](../Images/2-23.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-23.png)'
- en: Figure 2.23 Stepping through the key moments when using `useState`
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 使用`useState`时的关键时刻步骤
- en: In order to discuss concepts with clarity and precision, from time to time we
    take stock of the keywords and objects we’ve encountered so far. Table 2.2 describes
    some of the terms we’ve come across.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰和精确地讨论概念，我们不时地回顾迄今为止遇到的词汇和对象。表2.2描述了我们遇到的一些术语。
- en: Table 2.2 Some of the key terms we’ve met
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 我们遇到的一些关键术语
- en: '| Icon | Term | Description |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 图标 | 术语 | 描述 |'
- en: '| ![](../Images/2-unnumb-1.png)  | Component | A function that accepts props
    and returns a description of its UI. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-1.png)  | 组件 | 接受 props 并返回其 UI 描述的函数。|'
- en: '| ![](../Images/2-unnumb-2.png) | Initial value | The component passes this
    value to `useState`. React sets the state value to this initial value when the
    component first runs. |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-2.png) | 初始值 | 组件将此值传递给 `useState`。React 在组件首次运行时将状态值设置为这个初始值。|'
- en: '| ![](../Images/2-unnumb-3.png) | Updater function | The component calls this
    function to update the state value. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-3.png) | 更新函数 | 组件调用此函数来更新状态值。|'
- en: '| ![](../Images/2-unnumb-4.png) | Event handler | A function that runs in response
    to an event of some kind—for example, a user clicking a bookable. Event handlers
    often call updater functions to change the state. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-4.png) | 事件处理器 | 在响应某种事件时运行的函数——例如，用户点击一个可预订项。事件处理器通常会调用更新函数来改变状态。|'
- en: '| ![](../Images/2-unnumb-5.png) | `UI` | A description of the elements that
    make up a user interface. The state values are often included somewhere in the
    UI. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-5.png) | `UI` | 用户界面组成的元素描述。状态值通常包含在 UI 的某个地方。|'
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Call the `useState` hook when you want React to manage a value for a component.
    It returns an array with two elements: the state value and an updater function.
    You can pass in an initial value if required:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想让 React 管理组件的值时，调用 `useState` 钩子。它返回一个包含两个元素的数组：状态值和更新函数。如果需要，你可以传递一个初始值：
- en: '[PRE49]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you need to perform an expensive calculation to generate the initial state,
    pass it to `useState` in a function. React will run the function to get this lazy
    initial state only when it first calls the component:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要执行一个昂贵的计算来生成初始状态，可以在函数中将它传递给 `useState`。React 会在第一次调用组件时运行这个函数来获取这个懒加载的初始状态：
- en: '[PRE50]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the updater function that `useState` returns to set a new value. The new
    value *replaces* the old value. React will schedule a re-render if the value has
    changed:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useState` 返回的更新函数来设置新值。新值将*替换*旧值。如果值已更改，React 将安排重新渲染：
- en: '[PRE51]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If your state value is an object, make sure to copy over unchanged properties
    from the previous state when your updater function is updating only a subset of
    the properties:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的状态值是一个对象，确保在更新函数仅更新属性子集时，从上一个状态复制未更改的属性：
- en: '[PRE52]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To be sure you’re working with the latest state value when calling the updater
    function and setting a new value based on the old one, pass the updater function
    a function as its argument. React will assign the latest state value to the function
    argument:'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保在调用更新函数并基于旧值设置新值时使用最新的状态值，将一个函数作为参数传递给更新函数。React 将最新的状态值分配给函数参数：
- en: '[PRE53]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you have multiple pieces of state, you can call `useState` multiple times.
    React uses the order of the calls to consistently assign values and updater functions
    to the correct variables:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有多件状态，你可以多次调用 `useState`。React 使用调用顺序来一致地分配值和更新函数到正确的变量：
- en: '[PRE54]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Focus on the state and how events will update the state. React will do its
    job of synchronizing the state and the UI:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于状态以及事件如何更新状态。React 将同步状态和 UI 的任务完成：
- en: '[PRE55]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Consider what state the component needs.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 考虑组件需要什么状态。
- en: ❷ Display the state.
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ 显示状态。
- en: ❸ Update the state in response to events.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❸ 根据事件更新状态。
