- en: Part 4\. Using JavaScript with hardware in other environments
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4部分\. 在其他环境中使用JavaScript与硬件
- en: This part of the book explores some other environments in which you can use
    JavaScript to control hardware, and it looks toward the future.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分探讨了你可以使用JavaScript控制硬件的其他环境，并展望了未来。
- en: You’ll start in [chapter 10](kindle_split_020.html#ch10) by looking at JavaScript
    and JavaScript-like environments on highly constrained devices, prototyping some
    experiments with the Espruino Pico and Kinoma Element devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从[第10章](kindle_split_020.html#ch10)开始，研究高度受限设备上的JavaScript和类似JavaScript的环境，使用Espruino
    Pico和Kinoma Element设备进行一些实验原型设计。
- en: 'Both [chapters 10](kindle_split_020.html#ch10) and [11](kindle_split_021.html#ch11)
    walk through a set of reusable steps for getting to know new platforms, quickly.
    In [chapter 11](kindle_split_021.html#ch11), we’ll turn our attention to beefier
    hardware: general-purpose single-board computers (SBCs) that have onboard I/O
    capabilities. You’ll get up and running with the Raspberry Pi 3 and BeagleBone
    Black and adapt some Johnny-Five experiments to run on both platforms.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章[10](kindle_split_020.html#ch10)和第11章[11](kindle_split_021.html#ch11)都介绍了一套可重复使用的步骤，用于快速了解新平台。在第11章[11](kindle_split_021.html#ch11)中，我们将把注意力转向更强大的硬件：具有板载I/O功能的一般用途单板计算机（SBC）。你将使用Raspberry
    Pi 3和BeagleBone Black开始，并将一些Johnny-Five实验适配到这两个平台上。
- en: '[Chapter 12](kindle_split_022.html#ch12) provides a taste of some other pieces
    of the IoT ecosystem and examines what’s possible from within a web browser. You’ll
    use a cloud service to package and deploy a Johnny-Five application to a BeagleBone
    Black, and you’ll explore the leading edge of Web Bluetooth and the Physical Web
    with the Espruino Puck.js device.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](kindle_split_022.html#ch12)提供了物联网生态系统其他部分的品尝，并检查了在网页浏览器内可能实现的内容。你将使用云服务打包和部署Johnny-Five应用程序到BeagleBone
    Black，并使用Espruino Puck.js设备探索Web蓝牙和物理网络的尖端。'
- en: When you’re finished with this part of the book, your JavaScript on Things toolkit
    will be well-stocked, and you’ll be ready to strike out on your own into the brave,
    inspiring world of JavaScript and embedded systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成本书的这一部分时，你的JavaScript on Things工具箱将装备齐全，你将准备好进入充满勇气和灵感的JavaScript和嵌入式系统世界。
- en: Chapter 10\. JavaScript and constrained hardware
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. JavaScript和受限硬件
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: How JavaScript-capable embedded hardware platforms compare with host-client
    and single-board-computer (SBC) platforms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript能力的嵌入式硬件平台与主机-客户端和单板计算机（SBC）平台相比
- en: Steps for familiarizing yourself with a new development platform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉新开发平台的步骤
- en: 'Examining two representative embedded JavaScript platforms: Espruino Pico and
    Kinoma Element'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查两个代表性的嵌入式JavaScript平台：Espruino Pico和Kinoma Element
- en: Developing projects with the Espruino Pico
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Espruino Pico开发项目
- en: Crafting text and shapes with Nokia 5110 LCD displays and the Espruino `Graphics`
    library
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nokia 5110 LCD显示屏和Espruino `Graphics`库制作文本和形状
- en: 'Reusing trusty components: using the BMP180 multisensor and HMC5883L compass
    in new ways on different platforms'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用可靠的组件：以新的方式在不同的平台上使用BMP180多传感器和HMC5883L指南针
- en: A case-study view of the Kinoma Element
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Kinoma Element的案例研究视角
- en: In the first half of this book, electronics fundamentals were demonstrated by
    using a tethered Arduino Uno—a *host-client* setup. In the past few chapters,
    though, you’ve met the Tessel 2, which has the oomph to run Node.js natively within
    its OpenWrt operating system—that’s a *single-board-computer* (SBC) setup.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前半部分，通过使用连接的Arduino Uno——一个**主机-客户端**设置——展示了电子基础知识。然而，在过去的几章中，你已经遇到了Tessel
    2，它具有在OpenWrt操作系统内原生运行Node.js的能力——这是一个**单板计算机**（SBC）设置。
- en: 'Now we’re going to take a look at a third class of JavaScript-controlled platforms:
    constrained embedded hardware with native support for JavaScript (or, often, something
    that’s JavaScript-*like*). To accomplish this feat with such limited hardware
    resources, these platforms tend to rely on highly optimized custom JavaScript
    engines.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨第三类JavaScript控制的平台：具有对JavaScript（或通常是类似JavaScript的东西）的原生支持的受限嵌入式硬件。为了在如此有限的硬件资源上完成这一壮举，这些平台往往依赖于高度优化的自定义JavaScript引擎。
- en: These devices are evolving quickly, entering (and exiting) the market more rapidly
    than can be captured well in print. At this very moment, the Espruino platform—we’ll
    be looking at the Espruino Pico shortly—seems to be maintaining robust momentum
    ([figure 10.1](#ch10fig01)). The Kinoma Element—also on-deck for our investigations—has
    been in prerelease for quite some time. Although Kinoma’s embedded runtime has
    been held up as an early pioneer in supporting most ECMAScript 6 features, the
    Element product may not end up taking off. It’s hard to say with things moving
    so quickly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备正在快速发展，进入（和退出）市场的速度比印刷品能捕捉到的要快。就在此刻，Espruino 平台——我们很快就会看到 Espruino Pico——似乎保持着强劲的动力
    ([图 10.1](#ch10fig01))。Kinoma Element——也将在我们的调查中——已经处于预发布状态有一段时间了。尽管 Kinoma 的嵌入式运行时被吹捧为支持大多数
    ECMAScript 6 功能的早期先驱，但 Element 产品可能最终不会起飞。由于变化如此之快，很难说。
- en: 'Figure 10.1\. Two embedded JavaScript platforms: Espruino Pico and Kinoma Element'
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. 两个嵌入式 JavaScript 平台：Espruino Pico 和 Kinoma Element
- en: '![](10fig01_alt.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig01_alt.jpg)'
- en: Obsolescence is pretty much guaranteed for IoT hardware and software information
    committed to print, which is why this chapter focuses more on tasks and puzzles
    common across embedded JavaScript platforms. Specific products and platforms come
    and go, but there are a bunch of common research steps that can help you get up
    to speed, quickly, on whichever product you choose.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将物联网硬件和软件信息印刷在纸上的情况，其过时几乎是肯定的，这就是为什么本章更多地关注嵌入式 JavaScript 平台上的常见任务和谜题。具体产品和平台来来去去，但有一些常见的研发步骤可以帮助你快速熟悉你选择的产品。
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](tool.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于本章，你需要以下物品：**'
- en: 1 Espruino Pico
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Espruino Pico
- en: 1 Kinoma Element
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Kinoma Element
- en: 1 USB micro cable
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 USB 微型线缆
- en: 18 (two strips of 9 each) 0.1″ male breakaway header pins
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 18 个（每条 9 个）0.1″ 阳性断开式引脚
- en: 1 USB 2.0 A to USB A female (a.k.a. a USB extension cord) cable
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 USB 2.0 A 到 USB A 雌性（也称为 USB 延长线）线缆
- en: 1 Adafruit BMP180 I²C multisensor breakout board
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Adafruit BMP180 I²C 多传感器扩展板
- en: 1 Nokia 5110 84x48 LCD display module
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个诺基亚 5110 84x48 LCD 显示模块
- en: 1 100 V resistor
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 100 V 电阻
- en: 1 Adafruit HMC5883L magnetometer (compass) breakout board
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Adafruit HMC5883L 磁力计（指南针）扩展板
- en: 1 full-sized breadboard
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个全尺寸面包板
- en: Jumper wires
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '![](0299fig01_alt.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](0299fig01_alt.jpg)'
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.1\. The Espruino Pico platform
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. Espruino Pico 平台
- en: 'The Espruino Pico has less memory and less computational power than the Tessel
    2\. There’s no WiFi and no USB peripheral support, so why use it? Because it shines
    at other things: it’s cheaper, it’s tiny, it’s reliable, and it’s power-efficient—hallmarks
    of low-power embedded platforms.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Espruino Pico 的内存和计算能力比 Tessel 2 要少。没有 WiFi 和 USB 外设支持，那么为什么还要使用它呢？因为它在其它方面表现出色：它更便宜，它更小巧，它更可靠，它节能——这些都是低功耗嵌入式平台的标志。
- en: '*Espruino* describes both the hardware family itself and the firmware runtime
    interpreter that comes preflashed on Espruino devices. Espruino-the-interpreter
    supports most JavaScript features, but not all of them. You can’t get away with
    omitting semicolons, for example, and regular expressions aren’t supported.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Espruino* 既可以描述硬件家族本身，也可以描述预装在 Espruino 设备上的固件运行时解释器。Espruino-解释器支持大多数 JavaScript
    功能，但并非全部。例如，你不能省略分号，正则表达式也不受支持。'
- en: 'It’s important to differentiate JavaScript and JavaScript-esque from Node.js:
    this isn’t Node.js, so you can’t use Johnny-Five or any npm modules.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要要区分 JavaScript 和 JavaScript 式的 Node.js：这不是 Node.js，所以你不能使用 Johnny-Five 或任何
    npm 模块。
- en: Instead, Espruino provides its own JavaScript API for interacting with the hardware
    I/O ([www.espruino.com/Reference#software](http://www.espruino.com/Reference#software)).
    You’ve got enough experience under your belt now that aspects of the API likely
    ring familiar—there’s an `analogRead` function, for example, that takes a pin
    number as an argument. There are also Espruino-specific modules that encapsulate
    the behavior of specific electronic components, as you’ll see.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Espruino 提供了自己的 JavaScript API 用于与硬件 I/O 交互 ([www.espruino.com/Reference#software](http://www.espruino.com/Reference#software)).
    你现在已经有足够的经验，API 的某些方面可能听起来很熟悉——例如，有一个 `analogRead` 函数，它接受一个引脚号作为参数。还有 Espruino
    特有的模块，它们封装了特定电子组件的行为，正如你将看到的。
- en: Before examining the Pico in more depth, you’ll get it set up and take a Hello
    World LED-blinking script for a spin.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深入地检查 Pico 之前，你需要将其设置好，并运行一个 Hello World LED 闪烁脚本。
- en: 10.1.1\. Setting up the Pico
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 设置 Pico
- en: The Pico needs to be soldered onto header strips ([figure 10.2](#ch10fig02)).
    Your Pico may have come with header strips, but if not you’ll need two strips
    of nine pins each.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Pico需要焊接在排针上（[图10.2](#ch10fig02)）。您的Pico可能附带排针，如果没有，您将需要两根九针的排针。
- en: Figure 10.2\. The Pico has 18 pins (two rows of 9 each) at a 0.1-inch pitch—breadboard-compatible.
    They’ll need to be soldered onto header pins. One end of the Pico board is shaped
    so that it can be plugged directly into a USB port.
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2。Pico有18个引脚（每行9个），间距为0.1英寸——与面包板兼容。它们需要焊接在排针上。Pico板的一端设计成可以直接插入USB端口。
- en: '![](10fig02_alt.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig02_alt.jpg)'
- en: The Pico plugs right into a USB port. Some versions of the Pico have an additional
    USB micro connection, but you may well be stuck with just the USB A connection.
    This can be convenient, because you can plug your Pico right into your computer,
    but if you want to use the Pico on a breadboard—which is necessary when you want
    to try out any of the I/O pins—it gets a little tricky. The Pico is designed to
    connect to a USB A female connector. You can use the kind of cable marketed as
    a USB extension cable to get the USB A to USB A female connections the Pico needs
    ([figure 10.3](#ch10fig03)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Pico可以直接插入USB端口。一些版本的Pico有一个额外的USB微型连接，但您可能只能使用USB A连接。这可能很方便，因为您可以直接将Pico插入电脑，但如果您想在面包板上使用Pico（当您想要尝试任何I/O引脚时这是必要的）就会有点棘手。Pico设计成连接到USB
    A母接头。您可以使用市场上销售的USB延长线来获得Pico需要的USB A到USB A母接头连接（[图10.3](#ch10fig03)）。
- en: Figure 10.3\. You can use a USB extension cable to connect your Pico to your
    computer, allowing the Pico to be placed on a breadboard. The Pico’s USB end slots
    into a USB A female connection.
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3。您可以使用USB延长线将Pico连接到您的电脑，使Pico可以放置在面包板上。Pico的USB端插入USB A母接头。
- en: '![](10fig03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig03.jpg)'
- en: Things are evolving quickly enough in the Espruino family that including exhaustive
    setup instructions here would be foolish. Instead, head to [https://espruino.com](https://espruino.com)
    to get started.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Espruino家族的发展变化非常快，在这里包括详尽的设置说明似乎是愚蠢的。相反，请访问[https://espruino.com](https://espruino.com)开始使用。
- en: 'These are the basic steps, after plugging your Pico into USB:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基本步骤，在将Pico插入USB后：
- en: 'Get the Pico ready for your platform:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的平台准备Pico：
- en: Mac users likely don’t need to do anything else.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mac用户可能不需要做任何事情。
- en: Windows users will probably need a driver.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows用户可能需要驱动程序。
- en: Linux users may need to adjust permissions.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux用户可能需要调整权限。
- en: Install the Espruino IDE Chrome app (and the Chrome browser if you don’t have
    it installed).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Espruino IDE Chrome应用（如果您还没有安装Chrome浏览器，还需要安装Chrome浏览器）。
- en: Launch the Chrome app, and connect to and update the Pico’s firmware.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Chrome应用，连接并更新Pico的固件。
- en: For the purposes of experimenting with the Pico, you’ll be using Espruino’s
    web-based IDE (Chrome app)—that means you’ll connect to, communicate with, and
    deploy code to the Pico from within the Chrome app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验Pico，您将使用Espruino的基于Web的IDE（Chrome应用）——这意味着您将在Chrome应用内连接到、与Pico通信并部署代码到Pico。
- en: Figure 10.4\. The Espruino Chrome app IDE
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4。Espruino Chrome应用IDE
- en: '![](10fig04_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig04_alt.jpg)'
- en: On the left side of the app’s interface, you’ll see a terminal-like console
    area. Once you’re connected to a Pico, you can type expressions here directly,
    sort of like a Node.js interpreter or the Johnny-Five REPL. On the right side
    is an area where you can compose scripts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用界面的左侧，您会看到一个类似终端的控制台区域。一旦连接到Pico，您可以直接在这里输入表达式，有点像Node.js解释器或Johnny-Five
    REPL。右侧是一个可以编写脚本的区域。
- en: 10.1.2\. Hello World LED blink
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2. Hello World LED闪烁
- en: 'Let’s try it out with the requisite blinking of an LED. For this experiment,
    you’ll be using one of the Pico’s onboard LEDs, so you can plug the Pico into
    your USB port directly or stick it on a breadboard with a USB extension cable:
    the choice is yours.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过LED闪烁来试一试。在这个实验中，您将使用Pico的板载LED之一，因此您可以直接将Pico插入USB端口，或者使用USB延长线将其放在面包板上：选择由您决定。
- en: An assortment of variables are available at a global level in Espruino scripts,
    pertaining to platform features and pins. This includes the variables `LED1` and
    `LED2` for the Pico’s built-in red and green LEDs, respectively ([figure 10.5](#ch10fig05)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Espruino脚本在全局级别提供了一系列变量，这些变量与平台功能和引脚相关。这包括用于Pico内置红色和绿色LED的变量`LED1`和`LED2`（[图10.5](#ch10fig05)）。
- en: Figure 10.5\. This experiment will cause the Pico’s onboard LEDs—one red, one
    green—to blink alternately. Access to the LEDs is provided via the global variables
    `LED1` and `LED2`.
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.5\. 此实验将使 Pico 的板载 LED（一个红色，一个绿色）交替闪烁。LED 的访问通过全局变量 `LED1` 和 `LED2` 提供。
- en: '![](10fig05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![10fig05.jpg](10fig05.jpg)'
- en: Fire up the Espruino IDE Chrome app and connect to the Pico. Enter the code
    shown in the following listing into the code-composition area of the screen (the
    right side) and click the Send to Espruino icon in the center ([figure 10.6](#ch10fig06)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Espruino IDE Chrome 应用程序并连接到 Pico。将以下列表中的代码输入屏幕的代码组合区域（右侧）并点击中间的发送到 Espruino
    图标（[图 10.6](#ch10fig06)）。
- en: Listing 10.1\. Blinking the Pico’s LEDs
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 点亮 Pico 的 LED
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* LED1 (the red onboard LED) and LED2 (green) are available in Pico scripts.**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* LED1（板载红色 LED）和 LED2（绿色）在 Pico 脚本中可用。**'
- en: '***2* Uses setTimeout to make the function call itself every 500 ms**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 setTimeout 每隔 500 毫秒调用自身函数**'
- en: '***3* Kicks off the toggling**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 开始切换**'
- en: Figure 10.6\. Entering the LED-blink code into the Espruino IDE (font size increased
    for visibility)
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6\. 将 LED-闪烁代码输入到 Espruino IDE 中（字体大小增加以提高可见性）
- en: '![](10fig06_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![10fig06_alt.jpg](10fig06_alt.jpg)'
- en: This example uses Espruino’s `digitalWrite` function to alternately set LEDs
    HIGH and LOW. Once you deploy the code to the Pico, you should see the Pico’s
    red and green LEDs blinking, one at a time. You’ll also see some output on the
    left side of the IDE window.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 Espruino 的 `digitalWrite` 函数交替设置 LED 为高电平和低电平。一旦将代码部署到 Pico 上，你应该看到 Pico
    的红色和绿色 LED 依次闪烁。你还会在 IDE 窗口的左侧看到一些输出。
- en: 10.2\. Learning about new platforms
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 了解新平台
- en: Now that you’ve gotten hands-on, let’s back up a bit. How do you know that the
    Pico has two built-in LEDs (red and green), and how do you know that there are
    variables `LED1` and `LED2`? By now, conventions like `digitalWrite` being a name
    for a function that writes logic levels to digital outputs probably seems sensible.
    But it may still seem somewhat magical or random. Where does one start?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经动手实践了，让我们回顾一下。你是如何知道 Pico 有两个内置 LED（红色和绿色），以及你是如何知道存在变量 `LED1` 和 `LED2`
    的？到现在为止，像 `digitalWrite` 这样的函数名称表示向数字输出写入逻辑电平这样的约定可能看起来很合理。但它可能仍然显得有些神奇或随机。从哪里开始呢？
- en: 'There are a series of sleuthing steps you can apply when facing a new platform
    to get you scooting along in short order. You’ll tackle these to learn about the
    Pico specifically now, but you can reuse them to evaluate different embedded platforms
    in the future:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对一个新的平台时，你可以应用一系列侦探步骤来让你迅速上手。你现在将解决这些问题来了解 Pico，但你也可以在未来重新使用它们来评估不同的嵌入式平台：
- en: Discover the platform’s core features
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现平台的核心特性
- en: Find a pinout or hardware diagram
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找引脚图或硬件图
- en: Learn about the configuration and development workflow
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解配置和开发工作流程
- en: Find examples and simple tutorials and get hands-on
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找示例和简单教程，并动手实践
- en: Use the reference API documentation
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参考 API 文档
- en: Let’s look at each of these.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些中的每一个。
- en: 10.2.1\. Discovering a platform’s core features
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 发现平台的核心特性
- en: Before you even get your hands on a new dev board or platform, you’ll probably
    want an overall sense of what it can do.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在你甚至接触到新的开发板或平台之前，你可能想要对其整体功能有一个大致的了解。
- en: 'Often the key details are summarized on the manufacturer’s or supplier’s web
    site. In the Pico’s case, a list of features the Pico’s web page gives us the
    scoop: it’s a 3.3 V device, petite in form factor (33 mm x 15 mm), it’s powered
    by a STM32F401CDU6 microcontroller (no, my cat didn’t just walk on my keyboard;
    ST—the manufacturer—has naming conventions that are unromantic, but quite precise),
    and it uses an ARM Cortex M4 processor ([www.espruino.com/Pico](http://www.espruino.com/Pico)).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关键细节会在制造商或供应商的网站上总结。在 Pico 的情况下，Pico 的网页上列出的特性列表为我们提供了信息：它是一个 3.3 V 设备，外形小巧（33
    毫米 x 15 毫米），由 STM32F401CDU6 微控制器供电（不，我的猫并没有只是走过我的键盘；ST——制造商——有非浪漫但非常精确的命名规范），并且使用
    ARM Cortex M4 处理器（[www.espruino.com/Pico](http://www.espruino.com/Pico)）。
- en: Also in the key features list are bullet points about power consumption ([figure
    10.7](#ch10fig07)). Even if the specific numbers cited here don’t hit home, you
    can see that they’re making noise about being power efficient.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键特性列表中还有关于功耗的要点（[图 10.7](#ch10fig07)）。即使这里引用的具体数字没有给你留下深刻印象，你也能看出他们正在强调其节能特性。
- en: Figure 10.7\. The Espruino Pico’s key features, listed on Espruino’s website
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.7\. Espruino Pico 的关键特性，列在 Espruino 的网站上
- en: '![](10fig07_alt.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![10fig07_alt.jpg](10fig07_alt.jpg)'
- en: There are 22 GPIO pins on the device, including 3 I²C interfaces and 3 (hardware)
    SPI interfaces—not shabby for something so small. If you click through to the
    microcontroller’s datasheet ([http://mng.bz/i7r8](http://mng.bz/i7r8)), you can
    see that you have the STM32F401D/E family to thank for that (there’s a section
    about communication interfaces on the front page).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备上有 22 个 GPIO 引脚，包括 3 个 I²C 接口和 3 个（硬件）SPI 接口——对于这么小的设备来说，这已经很不错了。如果你点击进入微控制器的数据手册（[http://mng.bz/i7r8](http://mng.bz/i7r8)），你可以看到这要归功于
    STM32F401D/E 系列微控制器（首页有关于通信接口的部分）。
- en: A couple of other features jump out. One is a nice nod to the ubiquity of 5
    V logic—”All GPIO is 5 volt tolerant (Arduino compatible)”—a kindness to those
    of us who have to swap between the two a lot. Output will always be 3.3 V, but
    5 V input won’t give the Pico heartburn.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个其他特性也值得注意。一个是向 5 V 逻辑的普遍性致敬——“所有 GPIO 都能承受 5 伏（Arduino 兼容）”——这对于我们这些经常在这两者之间切换的人来说是一种善意。输出始终是
    3.3 V，但 5 V 输入不会让 Pico 心烦。
- en: 'Another detail worth noting: although 18 pins (two rows of 9) are at a breadboard-standard
    0.1″ pin pitch, 8 pins on one short end are only 0.05″ apart ([figure 10.8](#ch10fig08)).
    You won’t be using those pins in your explorations, as they don’t slot easily
    into a breadboard, but there are physical shims you can get to make it possible.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的细节是：尽管 18 个引脚（两排各 9 个）的间距为面包板标准的 0.1 英寸，但一个短端上的 8 个引脚间距仅为 0.05 英寸（[图
    10.8](#ch10fig08)）。在探索中你不会使用这些引脚，因为它们不容易插入面包板，但你可以获得物理垫片来使其成为可能。
- en: 'Figure 10.8\. Eight of the Pico’s I/O pins are at a 0.05 inch pitch: too narrow
    to slot into breadboards.'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.8. Pico 的 8 个 I/O 引脚间距为 0.05 英寸：太窄，无法插入面包板。
- en: '![](10fig08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig08.jpg)'
- en: Granted, this particular list of features doesn’t mention that this a JavaScript-powered
    device, which is kind of key, but you can certainly glean that from Espruino’s
    home page ([www.espruino.com](http://www.espruino.com)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个特定功能列表没有提到这是一个由 JavaScript 驱动的设备，这确实很重要，但你可以从 Espruino 的主页（[www.espruino.com](http://www.espruino.com)）中清楚地看出这一点。
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**ARM Cortex M MCUs and embedded JavaScript**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARM Cortex M 微控制器和嵌入式 JavaScript**'
- en: Both the Espruino Pico and the Kinoma Element are based on microcontrollers
    from the ARM Cortex M family. Just as ATmega MCUs are found on all sorts of Arduino-compatible,
    host-client-class boards (like the Arduino Uno and its brethren), ARM Cortex M
    MCUs are very popular for the class of embedded platforms that include the Element
    and the Pico. ARM’s site claims that 10s of *billions* of devices have been produced
    using products from the Cortex M family.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Espruino Pico 和 Kinoma Element 都基于 ARM Cortex M 系列的微控制器。正如 ATmega 微控制器被用于各种
    Arduino 兼容的主机-客户端类板（如 Arduino Uno 及其同类），ARM Cortex M 微控制器在包括 Element 和 Pico 在内的嵌入式平台类别中非常受欢迎。ARM
    的网站声称，已有数十亿个设备使用了 Cortex M 系列的产品。
- en: The 32-bit microcontrollers in the Cortex M family outclass 8-bit ATmegas while
    still operating at low power (most are predictably not quite as cheap). Embedded
    JavaScript (or JavaScript-like) runtimes need more processing power than an 8-bit
    ATmega can provide.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex M 系列的 32 位微控制器在低功耗下（大多数预测性并不便宜）优于 8 位 ATmegas。嵌入式 JavaScript（或类似 JavaScript）的运行时需要比
    8 位 ATmega 提供的更多处理能力。
- en: As you continue to experiment with new platforms, chances are you’ll continue
    to encounter Cortex M variants.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续尝试新的平台，你可能会继续遇到 Cortex M 变体。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Another thing that’s handy to understand is the platform’s financial and licensing
    model. Is the hardware or software (or both) open source, or are they proprietary?
    This can be relevant if you’re considering using a platform commercially, extending
    hardware or software, or otherwise making contributions to a platform. (Espruino
    platforms are fully open source.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得了解的是平台的经济和许可模式。硬件或软件（或两者）是开源的还是专有的？如果你考虑在商业上使用平台、扩展硬件或软件，或以其他方式为平台做出贡献，这可能很重要。（Espruino
    平台是完全开源的。）
- en: 10.2.2\. Finding a pinout diagram
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2. 寻找引脚图
- en: 'Maybe it’s because I have a love for maps, but finding and analyzing a board’s
    pinout diagram is usually when things really click home. These diagrams show you
    which pins can do what: communication interfaces, PWM, power pins, and so on.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是因为我对地图的喜爱，但找到和分析板上的引脚图通常是事情真正变得清晰的时候。这些图显示了哪些引脚可以做什么：通信接口、PWM、电源引脚等等。
- en: 'From the Pico’s diagram ([figure 10.9](#ch10fig09)), we can note a few things
    (see it in a larger size with more detail on Espruino’s Pico documentation page:
    [www.espruino.com/Pico](http://www.espruino.com/Pico)). For one, pin numbers aren’t
    sequential; they jump around a bit, and you’ll find both A and B pins on both
    of the two sides you’ll be using. You can also see that there’s PWM support on
    nearly every GPIO pin. Finally, you can see which pins have hardware support for
    I²C and SPI, and which can support ADC (analog-to-digital conversion).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Pico 的图示 ([图 10.9](#ch10fig09)) 中，我们可以注意几个要点（在 Espruino 的 Pico 文档页面查看更大尺寸的详细内容：[www.espruino.com/Pico](http://www.espruino.com/Pico)）。首先，引脚编号不是连续的；它们跳来跳去，你会在你将使用的两个侧面都找到
    A 和 B 引脚。你还可以看到几乎每个 GPIO 引脚都支持 PWM。最后，你可以看到哪些引脚具有硬件支持的 I²C 和 SPI，以及哪些可以支持 ADC（模拟到数字转换）。
- en: Figure 10.9\. Detail of pinout diagram for the Espruino Pico
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.9\. Espruino Pico 引脚图细节
- en: '![](10fig09_alt.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![10fig09_alt.jpg](10fig09_alt.jpg)'
- en: A combination of sensible overall pin layout (hardware design) and high-quality
    pinout diagrams can make for a better development experience.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的整体引脚布局（硬件设计）和高质量的引脚图可以带来更好的开发体验。
- en: 10.2.3\. Learning about configuration and workflow
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 了解配置和工作流程
- en: How is code written? Deployed? How is the device managed, configured, and updated?
    Is it supported for your operating system? Is the configuration process overwhelming
    and tedious? That could be a sign of an ongoing headache.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是如何编写的？如何部署的？设备是如何管理、配置和更新的？它是否支持你的操作系统？配置过程是否令人沮丧且繁琐？这可能是一个持续头痛的迹象。
- en: In the Pico’s case, we’ve taken the recommended route of using the Chrome app
    IDE. This can be convenient—code authoring, device management, and deployment
    are in one place—but if you’re the kind of person who has an attachment to your
    own editor or IDE for writing JavaScript, it might drive you nuts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pico 的情况下，我们采取了推荐的路线，使用 Chrome 应用 IDE。这可能很方便——代码编写、设备管理和部署都在一个地方，但如果你是那种对自家的编辑器或
    IDE 写 JavaScript 有偏爱的人，这可能会让你抓狂。
- en: 'Get a sense of the high-level software constructs: are there plugins or other
    modularized components? Is there a general hardware-oriented API? Espruino has
    both of these.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 获取高级软件结构的感觉：是否有插件或其他模块化组件？是否有面向硬件的通用 API？Espruino 两者都有。
- en: 10.2.4\. Finding examples and tutorials
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.4\. 寻找示例和教程
- en: Stepping through some Hello World examples is next, and you’ve already done
    that with the Pico. When experimenting with a new platform, figure out how to
    accomplish some common tasks, such as blinking LEDs, reading data from an analog
    sensor, working with displays, and controlling I²C devices. Ideally, you’ll get
    hands-on at this step, getting a sense for how it really feels to interact with
    the platform during development.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是逐步通过一些 Hello World 示例，你已经用 Pico 做过这个了。当实验一个新的平台时，找出完成一些常见任务的方法，比如闪烁 LED、从模拟传感器读取数据、与显示屏一起工作以及控制
    I²C 设备。理想情况下，你将在这一步亲自动手，感受在开发过程中与平台交互的真实感觉。
- en: Once you’ve got your head around the big picture, and seen (and tried) a few
    applied examples, hitting up reference documentation can help fill in the details.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了整体的大致情况，并看过（尝试过）一些应用示例，查阅参考文档可以帮助你填补细节。
- en: 10.2.5\. Using reference API documentation
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.5\. 使用参考 API 文档
- en: 'If you glance at Espruino’s API documentation (10.10), you’ll see familiar
    JavaScript classes—`String`, `Math`, `Boolean`, `JSON`—along with Espruino-specific
    classes relevant to hardware stuff: `I2C`, `SPI`, `WLAN`. The `Globals` section
    lists hardware functions like `digitalWrite()` available to Espruino scripts,
    and also some standard JavaScript global goodies like `setTimeout()` and `eval()`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览 Espruino 的 API 文档（10.10），你会看到熟悉的 JavaScript 类——`String`、`Math`、`Boolean`、`JSON`——以及与硬件相关的
    Espruino 特定类：`I2C`、`SPI`、`WLAN`。《全局》部分列出了 Espruino 脚本可用的硬件函数，如 `digitalWrite()`，以及一些标准的
    JavaScript 全局功能，如 `setTimeout()` 和 `eval()`。
- en: There’s also a page that lists available modules for Espruino and how to use
    them ([www.espruino.com/Modules](http://www.espruino.com/Modules)). More on that
    as we explore the Pico more fully.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个页面列出了 Espruino 可用的模块以及如何使用它们 ([www.espruino.com/Modules](http://www.espruino.com/Modules))。随着我们对
    Pico 的深入了解，我们将进一步探讨这一点。
- en: As you learn more about a platform and gain experience with it, you’ll find
    yourself moving from a learning phase, where you’re seeking out prebaked examples,
    concepts, and tutorials, to a reference phase, where you’re searching for details
    on how to accomplish specific tasks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更多地了解一个平台并积累经验时，你会发现自己在从寻找现成示例、概念和教程的学习阶段，过渡到参考阶段，在这个阶段你正在寻找如何完成特定任务的详细信息。
- en: Figure 10.10\. Espruino’s API documentation at [www.espruino.com/Reference](http://www.espruino.com/Reference)
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.10\. Espruino的API文档在[www.espruino.com/Reference](http://www.espruino.com/Reference)
- en: '![](10fig10_alt.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig10_alt.jpg)'
- en: 10.3\. Experimenting with the Pico
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 在Pico上进行实验
- en: Next, you’ll take the Pico for a spin and try out a few experiments. First,
    you’ll revisit the BMP180 weather multisensor, but you’ll be combining it with
    a Nokia 5110 LCD display component to build a nice-looking, self-contained mini
    weather station.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将尝试使用Pico进行一些实验。首先，你将重新访问BMP180天气多传感器，但你会将其与Nokia 5110 LCD显示组件结合使用，构建一个外观漂亮的、自包含的迷你气象站。
- en: 10.3.1\. The Pico and the BMP180 multisensor
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. Pico和 BMP180多传感器
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要什么
- en: '![](note.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Espruino Pico
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Espruino Pico
- en: 1 full-size breadboard
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 全尺寸面包板
- en: 1 USB extension cable
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 USB延长线
- en: 1 BMP180 breakout board
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 BMP180扩展板
- en: Jumper wires
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Because you’re using the Web IDE, working with Espruino modules is as easy as
    using a `require()` statement in the Espruino code with the name of the module
    you’re after. These modules provide encapsulated support for different types of
    components. And, huzzah, there’s an existing module for your trusty BMP180 temperature
    and pressure multisensor. The module’s called `BMP085` because it’s also compatible
    with the similar BMP085 sensor. Once the module is imported, you can use the API
    it provides to interact with the BMP180 sensor. Let’s see what that looks like.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在使用Web IDE，使用Espruino模块与使用Espruino代码中的`require()`语句一样简单，只需指定你想要的模块名称。这些模块为不同类型的组件提供了封装支持。而且，太好了，有一个现有的模块用于你信任的BMP180温度和压力多传感器。该模块被称为`BMP085`，因为它也与类似的BMP085传感器兼容。一旦导入模块，你就可以使用它提供的API与BMP180传感器进行交互。让我们看看这会是什么样子。
- en: The BMP085 Espruino module
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: BMP085 Espruino模块
- en: This experiment will log the current temperature (in Celsius) and pressure (in
    pascals) as obtained from the I²C BMP180 sensor.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验将记录从I²C BMP180传感器获取的当前温度（摄氏度）和压力（帕斯卡）。
- en: The code required to log readings from a BMP180 isn’t too dense, as you’ll see
    in [listing 10.2](#ch10ex02). It makes use of the exposed `I2C1` global to configure
    an I²C interface that it then passes to the `connect` method of the `BMP085` module.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从[BMP180读取数据的代码](#ch10ex02)并不复杂，正如你在[列表10.2](#ch10ex02)中看到的。它使用了公开的`I2C1`全局变量来配置一个I²C接口，然后将其传递给`BMP085`模块的`connect`方法。
- en: As you’ve seen, Johnny-Five provides several constructs for performing continuous,
    periodic actions like sensor reads—`board.loop`, for example. But you’re not using
    Johnny-Five here. Instead, you’ll follow Espruino convention, which makes use
    of `setInterval` for repeated I/O.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Johnny-Five提供了几个用于执行连续、周期性操作（如传感器读取）的结构，例如`board.loop`。但在这里你并没有使用Johnny-Five。相反，你将遵循Espruino的约定，它使用`setInterval`进行重复的I/O操作。
- en: Listing 10.2\. Using the BMP085 Espruino module
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 使用BMP085 Espruino模块
- en: '[PRE1]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Sets up the Pico’s first I²C interface (I²C1), using pins B6 for SCL
    and B7 for SDA**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用B6引脚作为SCL和B7引脚作为SDA设置Pico的第一个I²C接口（I²C1）**'
- en: '***2* Requires the BMP085 module and invokes its connect function, using the
    I²C1 interface**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 需要BMP085模块并调用其connect函数，使用I²C1接口**'
- en: '***3* The getPressure method of the instantiated bmp object is async; registers
    a callback...**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实例化的bmp对象的getPressure方法是异步的；注册一个回调...**'
- en: '***4* Performs sensor reads every second (1000 ms)**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 每秒（1000毫秒）执行一次传感器读取**'
- en: How do you know that pins B6 and B7 support I²C SCL and SDA respectively? From
    the pinout ([figure 10.11](#ch10fig11)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道B6和B7引脚分别支持I²C SCL和SDA？从引脚分配([图10.11](#ch10fig11))中可以看出。
- en: Figure 10.11\. Wiring diagram for the Espruino Pico and BMP180 sensor
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.11\. Espruino Pico和BMP180传感器的接线图
- en: '![](10fig11_alt.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig11_alt.jpg)'
- en: Building the BMP180 circuit
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建 BMP180 电路
- en: To construct this, you’ll want to put the Pico on a full-size breadboard and
    use a USB extension cable. Construct the circuit shown in [figure 10.11](#ch10fig11).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个，你需要在全尺寸面包板上放置Pico并使用USB延长线。构建[图10.11](#ch10fig11)中所示的电路。
- en: 'The setup may seem a bit cockamamie at the moment. “Why stick the BMP180 sensor
    so far away from the Pico?” you may reasonably be wondering. There’s a method
    to this madness: the resulting gap will allow for the expansion of this circuit
    to accommodate the Nokia 5110 LCD component in upcoming experiments.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，设置可能看起来有点混乱。“为什么要把 BMP180 传感器放在 Pico 那么远的地方？”你可能合理地想知道。这里有一个方法：产生的间隙将允许在未来的实验中扩展此电路以容纳诺基亚
    5110 LCD 组件。
- en: '|  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Full-size breadboard connections
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 全尺寸面包板连接
- en: If this is your first time using a full-size breadboard, note that it really
    is effectively two half-size breadboards joined end-to-end, in terms of electrical
    connections. A gotcha with full-size breadboards is that the power rails have
    a break in their connections halfway down the board ([figure 10.12](#ch10fig12)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次使用全尺寸面包板，请注意，从电气连接的角度来看，它实际上是由两个半尺寸面包板首尾相连组成的。全尺寸面包板的一个问题是，电源轨在板的中部有断开连接（[图
    10.12](#ch10fig12)）。
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 10.12\. Don’t forget! The power rails on a full-size breadboard have
    a break midway down the board.
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.12\. 不要忘记！全尺寸面包板上的电源轨在板的中部有断开连接。
- en: '![](10fig12_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig12_alt.jpg)'
- en: Deploying the code
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部署代码
- en: Enter the code from [listing 10.2](#ch10ex02) into the right side of the IDE,
    and click the Send to Espruino up-arrow icon to execute the code on the Pico.
    The logged pressure and temperature will appear on the console/terminal (left)
    side of the IDE window ([figure 10.13](#ch10fig13)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [代码清单 10.2](#ch10ex02) 中的代码输入到 IDE 的右侧，然后点击发送到 Espruino 的向上箭头图标以在 Pico 上执行代码。记录的压力和温度将出现在
    IDE 窗口的控制台/终端（左侧）侧（[图 10.13](#ch10fig13)）。
- en: Figure 10.13\. Once the BMP180 script is uploaded to the Pico, you should see
    output logging to the left side of the screen once per second.
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.13\. 一旦将 BMP180 脚本上传到 Pico，你应该每秒在屏幕左侧看到一次输出日志。
- en: '![](10fig13_alt.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig13_alt.jpg)'
- en: 10.3.2\. The Pico and the Nokia 5110 LCD
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. Pico 和诺基亚 5110 LCD
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要
- en: '![](note.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Espruino Pico
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Espruino Pico
- en: 1 Nokia 5110 48x84 LCD breakout board
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个诺基亚 5110 48x84 LCD 开发板
- en: 1 full-size breadboard
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个全尺寸面包板
- en: 1 100 V resistor
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 100 V 电阻
- en: Jumper wires
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The Nokia 5110 48x84 pixel display ([figure 10.14](#ch10fig14)) was originally
    used in the popular Nokia 51xx family of phones, which date from the late 1990s
    (great phones, by the way—they were known for their durability, excellent battery
    life, and ease of use). Nokia 5110 LCD units can be found online for as little
    as $6, but they’re easier to find at around $10 each. They’re great little components:
    48x84 pixels isn’t infinite real estate, but it’s a lot more than the 16x2 we’ve
    seen so far. There’s room to draw, animate, and do fun things.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 诺基亚 5110 48x84 像素显示屏（[图 10.14](#ch10fig14)）最初用于流行的诺基亚 51xx 系列手机，这些手机始于 20 世纪
    90 年代末（顺便说一句，它们是很好的手机——它们以耐用性、出色的电池寿命和易用性而闻名）。诺基亚 5110 LCD 单元在网上可以以低至 6 美元的价格找到，但它们在每件约
    10 美元的地方更容易找到。它们是很好的小部件：48x84 像素并不是无限的面积，但它比我们迄今为止看到的 16x2 多得多。有空间绘制、动画和做有趣的事情。
- en: Figure 10.14\. The Nokia 5110 LCD has 48x84 pixel resolution and an SPI interface
    provided by its Phillips Semiconductor PCD8544 driver. The display is shown here
    the right side up.
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.14\. 诺基亚 5110 LCD 具有由其飞利浦半导体 PCD8544 驱动器提供的 48x84 像素分辨率和 SPI 接口。显示屏在此处是正立的。
- en: '![](10fig14_alt.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig14_alt.jpg)'
- en: The display is controlled by a Philips Semiconductor driver named, in that non-memorable
    way that such components often have, the PCD8544\. The PCD8544 provides an SPI
    interface to the display, and (yay!) there’s an Espruino module for this controller.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该显示屏由名为 PCD8544 的飞利浦半导体驱动器控制，这种组件通常具有那种不令人难忘的方式。PCD8544 为显示屏提供 SPI 接口，而且（太好了！）还有一个
    Espruino 模块用于此控制器。
- en: You’ll start by creating a visual countdown timer using the Nokia 5110 on its
    own, and then you’ll combine it with the BMP180 to make a little weather station.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先使用诺基亚 5110 独自创建一个视觉倒计时计时器，然后你将结合 BMP180 来制作一个小型气象站。
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Nokia 5110/PCD8544 pinouts**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**诺基亚 5110/PCD8544 引脚图**'
- en: Different PCD8544/Nokia 5110 modules have different pinouts! Check your board’s
    pin labeling before trying to follow the wiring diagram in [figure 10.15](#ch10fig15).
    The connections should be silkscreened on the board.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 PCD8544/Nokia 5110 模块有不同的引脚图！在尝试遵循图 10.15 中的布线图之前，请检查你板上的引脚标记。[图 10.15](#ch10fig15)
    的连接应该印在板上。
- en: The layout used in the wiring diagram is based on the 5110 variant available
    on SparkFun’s product page ([http://mng.bz/IId1](http://mng.bz/IId1)), with connections
    as shown in the following figure. It’s worth noting that the SparkFun module’s
    pinout is different from the one assumed in the “Pico LCD Display Hello World”
    tutorial on Espruino’s site ([http://mng.bz/604s](http://mng.bz/604s)), but the
    layout documented by SparkFun seems to be more common.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 电路图中所使用的布局基于 SparkFun 产品页面上可用的 5110 变体([http://mng.bz/IId1](http://mng.bz/IId1))，连接方式如图所示。值得注意的是，SparkFun
    模块的引脚排列与 Espruino 网站上“Pico LCD 显示 Hello World”教程中假设的引脚排列不同([http://mng.bz/604s](http://mng.bz/604s))，但
    SparkFun 记录的布局似乎更为常见。
- en: '![](0313fig01_alt.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](0313fig01_alt.jpg)'
- en: The wiring diagram in this chapter is based on the SparkFun version of the Nokia
    5110 and assumes a pinout as shown here. Check your 5110’s pinouts and adjust
    the connections in the circuit if they differ.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的接线图基于诺基亚 5110 的 SparkFun 版本，并假设引脚排列如图所示。检查您的 5110 的引脚排列，并在它们不同的情况下调整电路中的连接。
- en: See [table 10.1](#ch10table01) for the specifics of which LCD modules pins connect
    to what on the Pico.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[表 10.1](#ch10table01)了解具体哪些 LCD 模块引脚连接到 Pico 的哪些引脚。
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Connecting the LCD to the Pico
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将 LCD 连接到 Pico
- en: Leave the BMP180 connected from the previous experiment—you’ll use it again
    in a minute—and connect the Nokia 5110 to a free section of the full-sized breadboard
    as shown in [figure 10.15](#ch10fig15) (and summarized in [table 10.1](#ch10table01)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 BMP180 从上一个实验中的连接——你将在一分钟后再次使用它——并将诺基亚 5110 连接到全尺寸面包板上的空闲部分，如图[图 10.15](#ch10fig15)（并在[表
    10.1](#ch10table01)中总结）所示。
- en: Figure 10.15\. Wiring diagram for the addition of a Nokia 5110 LCD component
    to the circuit
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.15\. 将诺基亚 5110 LCD 组件添加到电路中的接线图
- en: '![](10fig15_alt.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig15_alt.jpg)'
- en: Table 10.1\. Nokia 5110 LCD connections
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.1\.诺基亚 5110 LCD 连接
- en: '| LCD module pin | LCD pin function | Connect to Pico pin | Wire color in diagram
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| LCD 模块引脚 | LCD 引脚功能 | 连接到 Pico 引脚 | 图中电线颜色 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| VCC or Vin | 3.3 V source power | 3.3 V | Red |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| VCC 或 Vin | 3.3 V 电源 | 3.3 V | 红色 |'
- en: '| GND | Ground | GND | Black |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| GND | 地 | GND | 黑色 |'
- en: '| CE or SCE | SPI chip select | B14 | Blue |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| CE 或 SCE | SPI 芯片选择 | B14 | 蓝色 |'
- en: '| RST | Reset | B15 | White |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| RST | 复位 | B15 | 白色 |'
- en: '| DC or D/C | Data/command | B13 | Orange |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| DC 或 D/C | 数据/命令 | B13 | 橙色 |'
- en: '| MOSI or DN | SPI master out, slave in | B10 | Green |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| MOSI 或 DN | SPI 主出，从入 | B10 | 绿色 |'
- en: '| SCK or SCLK | SPI clock | B1 | Yellow |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| SCK 或 SCLK | SPI 时钟 | B1 | 黄色 |'
- en: '| LED | 3.3 V source for LED backlight | 3.3 V, through 100 V resistor | Red
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| LED | LED 背光 3.3 V 电源 | 3.3 V，通过 100 Ω 电阻 | 红色 |'
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Wiring diagrams and aesthetics**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**接线图和美观**'
- en: If you study [figure 10.15](#ch10fig15), you’ll notice a few details that are
    a nod toward clarity and aesthetics, both in the diagram itself and the resulting
    circuit.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究[图 10.15](#ch10fig15)，你会注意到一些细节，这些细节既指向清晰度，也指向美观，无论是在电路图本身还是在结果电路中。
- en: For example, note the power connections (red wires). The BMP180 and Nokia 5110’s
    backlight LED are now sharing one of the positive power connections. The LCD’s
    backlight LED power is connected through a 100 V resistor—it’s an LED, so this
    resistor value of 100 V is a good one for a 3.3 V circuit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，注意电源连接（红色电线）。BMP180 和诺基亚 5110 的背光 LED 现在共享一个正电源连接。LCD 的背光 LED 电源通过一个 100
    Ω 电阻连接——它是一个 LED，所以这个 100 Ω 的电阻值对于 3.3 V 电路来说是一个很好的选择。
- en: 'Keep in mind that the full-size breadboard’s power rails have a break in their
    connections midway along the long side of the breadboard (a full-size breadboard
    really is equivalent to two half-size boards stuck together). Hence the short
    extra ground wire in this diagram: it connects the ground power to the other half
    of the board’s ground rail, bridging the connectivity gap.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，全尺寸面包板的电源轨在面包板长边的中部有断开（全尺寸面包板实际上相当于两个半尺寸板粘在一起）。因此，图中多出的短地线：它将地电源连接到板的另一半地轨，桥接了连接间隙。
- en: When you work with circuit diagrams, you’ll often see affordances made to keep
    the circuit “tidy” in appearance, like that split ground connection. Yet another
    example in [figure 10.15](#ch10fig15) is the orange wire for the Nokia 5110’s
    D/C (data/command mode); the connection is split into two segments so that it
    doesn’t have to overlap other components or wires visually. Other connections
    are bridged across the breadboard’s central notch before using separate wires
    to complete the connections.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与电路图打交道时，你经常会看到为了保持电路外观“整洁”而做出的折衷方案，比如那个分割的接地连接。另一个例子在[图10.15](#ch10fig15)中，是诺基亚5110的D/C（数据/命令模式）的橙色电线；连接被分成两段，这样它就不会在视觉上与其他组件或电线重叠。其他连接在使用单独的电线完成连接之前，被桥接在面包板的中央缺口上。
- en: There are many ways to achieve the same resulting circuit. Each of the multiwire
    connections could be made with a single wire, if you’re looking to save on time
    or wires needed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果电路的方法有很多。如果你想要节省时间或所需的电线，每个多线连接都可以用一根单独的电线来完成。
- en: '![](0315fig01_alt.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](0315fig01_alt.jpg)'
- en: The same circuit, without making affordances for tidiness
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的电路，没有为了整洁而做折衷方案
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Making a visual countdown timer with the Nokia 5110
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用诺基亚5110制作视觉倒计时器
- en: To get acquainted with the Nokia 5110 and Espruino’s `Graphics` capabilities,
    this experiment creates a 10-second timer that shows its progress using an animated
    progress bar on the LCD ([figure 10.16](#ch10fig16)). You can, of course, adjust
    the timer’s duration in the code. The timer is started by pressing the Pico’s
    itty-bitty built-in button.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉诺基亚5110和Espruino的`Graphics`功能，这个实验创建了一个10秒的定时器，它使用LCD上的动画进度条显示进度（[图10.16](#ch10fig16)）。当然，你可以在代码中调整定时器的持续时间。定时器通过按下Pico的内置小按钮启动。
- en: Figure 10.16\. The timer’s display. The filled-in rectangle is “animated” and
    grows to the right as time elapses.
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.16\. 定时器的显示。填充的矩形是“动画”的，并且随着时间的流逝向右增长。
- en: '![](10fig16.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig16.jpg)'
- en: The Espruino PCD8544 module
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Espruino PCD8544模块
- en: To write a program for the timer, you’ll use the Espruino PCD8544 module. The
    code first sets up some variables and creates an initialization function to set
    up the timer (10.3), as shown in the next listing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要为定时器编写程序，你将使用Espruino PCD8544模块。代码首先设置一些变量，创建一个初始化函数来设置定时器（10.3），如下所示。
- en: Listing 10.3\. Setting up the timer
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 设置定时器
- en: '[PRE2]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Determines how many “ticks” (frames) long the timer lasts**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确定定时器持续多长时间（“滴答”或“帧”数）**'
- en: '***2* Keeps track of whether the timer is currently running**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 跟踪定时器是否正在运行**'
- en: '***3* Configures an SPI interface for the LCD**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为LCD配置SPI接口**'
- en: '***4* Uses the PCD8544 Espruino module to instantiate an object representing
    the LCD**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用PCD8544 Espruino模块实例化表示LCD的对象**'
- en: '***5* Invokes the onInit() function to get things going**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 调用onInit()函数开始工作**'
- en: 'Next, you need to find a way for a user to activate the timer. You can use
    the Pico’s onboard push button as a trigger to start the timer by making use of
    some Espruino global goodies: the `setWatch(function, pin, options)` function
    and the virtual `BTN` pin.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要找到一种让用户激活定时器的方法。你可以使用Pico的板载按钮作为触发器，通过使用一些Espruino全局优点：`setWatch(function,
    pin, options)`函数和虚拟`BTN`引脚来启动定时器。
- en: The `setWatch()` function provides interrupt-like behavior, allowing you to
    register a callback that’s invoked when the watched pin’s value changes. In [listing
    10.4](#ch10ex04), `setWatch()` is used to watch `BTN` continuously. Before starting
    the timer, the code makes sure there isn’t another timer already running, and
    then it resets the timer’s `progress` and kicks things off.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`setWatch()`函数提供了中断类似的行为，允许你注册一个回调，当监视引脚的值发生变化时被调用。在[列表10.4](#ch10ex04)中，`setWatch()`用于持续监视`BTN`。在启动定时器之前，代码确保没有其他定时器正在运行，然后重置定时器的`progress`并开始操作。'
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Interrupt-like behavior?
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 中断类似的行为？
- en: 'The `setWatch` function provides interrupt-*like* behavior. The technicality
    is explained in Espruino’s API documentation on setWatch ([http://mng.bz/EE71](http://mng.bz/EE71)):
    “Internally, an interrupt writes the time of the pin’s state change into a queue,
    and the function supplied to `setWatch` is executed only from the main message
    loop.”'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`setWatch`函数提供了中断类似的行为。技术细节在Espruino的API文档中解释了setWatch（[http://mng.bz/EE71](http://mng.bz/EE71)）：“内部，中断将引脚状态变化的时间写入队列，而提供给`setWatch`的函数只从主消息循环中执行。”'
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 10.4\. Starting the timer
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. 启动定时器
- en: '[PRE3]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Invokes the draw function every frameDuration (200 ms)**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每个frameDuration（200 ms）调用一次draw函数**'
- en: '***2* The second argument to setWatch specifies the pin to watch—the Pico’s
    onboard button.**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* setWatch的第二个参数指定要监视的引脚——Pico的板载按钮。**'
- en: '***3* The third argument is options, here specifying that the watching should
    continue indefinitely (repeat: true).**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 第三个参数是选项，这里指定监视应无限期进行（重复：true）。**'
- en: The timer runs by repeatedly invoking a function named `draw` at a calculated
    interval. But what is the `draw` function? You’ll need to write it! Your `draw`
    function’s tasks will include incrementing the timer’s progress and rendering
    its proportional progress onto the LCD screen.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器通过重复调用名为`draw`的函数在计算间隔内运行。但`draw`函数是什么？你需要编写它！你的`draw`函数的任务将包括增加计时器的进度并在LCD屏幕上渲染其比例进度。
- en: The object returned by the PCD8544 module’s `connect` method—assigned in your
    code to the variable `lcd`—provides a few LCD-specific methods like `flip()`,
    which takes the current contents of a buffer and displays them on the screen,
    and `setContrast()`—that method does what it sounds like it would do. In addition,
    the object inherits from Espruino’s `Graphics` library ([www.espruino.com/Graphics](http://www.espruino.com/Graphics)),
    giving you tools to render text strings as well as draw lines and shapes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: PCD8544模块的`connect`方法返回的对象——在您的代码中分配给变量`lcd`——提供了一些LCD特定的方法，如`flip()`，它将缓冲区当前内容显示在屏幕上，以及`setContrast()`——该方法做的是它听起来会做的事情。此外，该对象继承自Espruino的`Graphics`库（[www.espruino.com/Graphics](http://www.espruino.com/Graphics)），为你提供了将文本字符串渲染到屏幕上以及绘制线条和形状的工具。
- en: 'The `draw` function in [listing 10.5](#ch10ex05) uses the `drawRect(x1, y1,
    x2, y2)` method to draw the outline of a box representing the total timer duration.
    Then `fillRect(x1, y1, x2, y2`) is used to draw a filled-in progress bar at a
    width representative of the time elapsed so far. The only real math the `draw`
    function needs to do is determine how wide that filled rectangle should be—how
    many of the LCD’s available 84 horizontal pixels represent the proportion of time
    that has elapsed. That’s calculated and assigned to the `rightEdge` variable.
    To summarize: an empty rectangle—the progress bar’s outline—is drawn, vertically
    centered on the screen, and then a filled rectangle of the calculated width is
    drawn inside of it.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单10.5](#ch10ex05)中的`draw`函数使用`drawRect(x1, y1, x2, y2)`方法绘制表示总计时时间的框的轮廓。然后使用`fillRect(x1,
    y1, x2, y2)`绘制一个代表到目前为止经过时间的填充进度条。`draw`函数真正需要做的数学计算就是确定填充矩形应该有多宽——LCD可用的84个水平像素中有多少代表已经过去的时间比例。这是计算并分配给`rightEdge`变量的。总结一下：绘制一个空矩形——进度条的轮廓，垂直居中于屏幕上，然后在其中绘制一个计算宽度的填充矩形。'
- en: Listing 10.5\. Drawing the timer
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单10.5\. 绘制计时器
- en: '[PRE4]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* If the timer is done, turns it off and stops**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果计时器完成，关闭它并停止**'
- en: '***2* Calculates the x-axis position of the right side of the filled progress
    rectangle**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 计算填充进度条的右侧x轴位置**'
- en: '***3* Uses drawRect(x1, y1, x2, y2) to draw an empty box vertically centered,
    eight px high**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用drawRect(x1, y1, x2, y2)绘制一个垂直居中、高度为8 px的空框**'
- en: '***4* Uses fillRect(x1, y1, x2, y2) to draw a filled box representing progress
    so far**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用fillRect(x1, y1, x2, y2)来绘制表示到目前为止进度的填充框**'
- en: '***5* Draws everything to the LCD screen**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将所有内容绘制到LCD屏幕上**'
- en: Paste the timer code into the right side of the Espruino IDE, connect to the
    Pico, and upload the code. Press the Pico’s button to start the timer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将计时器代码粘贴到Espruino IDE的右侧，连接到Pico，并上传代码。按下Pico的按钮以开始计时。
- en: You can make adjustments to the code if you’d like. You could change the timer’s
    duration, or you could make the LCD display a message when the timer is complete,
    for example.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调整代码，你可以改变计时器的持续时间，或者当计时器完成时，让LCD显示一条消息，例如。
- en: 10.3.3\. Building a power-efficient weather gadget with the Pico
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3\. 使用Pico构建高效能的气象设备
- en: You’re getting to be rather an expert at building mini weather gadgets, and
    here’s another one to add to the arsenal. By combining your old friend the BMP180
    sensor with the Nokia 5110 display, you can cobble together an independent, nicely
    formatted, low-power weather device ([figure 10.17](#ch10fig17)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你在构建迷你气象设备方面变得越来越专业，现在又有一个新设备可以加入你的装备库。通过将你的老朋友BMP180传感器与诺基亚5110显示屏结合，你可以组装成一个独立、格式良好的低功耗气象设备（[图10.17](#ch10fig17)）。
- en: Figure 10.17\. The weather gadget’s output will show temperature and air pressure,
    nicely formatted.
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.17\. 天气小工具的输出将显示温度和空气压力，格式良好。
- en: '![](10fig17.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig17.jpg)'
- en: 'If you followed along through the previous two experiments, you already have
    the circuit you need: the BMP180 and the Nokia 5110 connected to the Pico on a
    full-sized breadboard ([figure 10.18](#ch10fig18)). You’ll rely on some more features
    of the Espruino `Graphics` library to allow you to draw vector fonts and more
    shapes to format the display of the data, and you’ll deploy the resulting code
    to the Pico’s flash memory so that the Pico will independently run the program
    any time it’s provided with power.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随着前两个实验，你已经有了所需的电路：BMP180 和诺基亚 5110 连接到 Pico 上的全尺寸面包板上([图 10.18](#ch10fig18))。你将依赖
    Espruino `Graphics` 库的一些更多功能，以便你可以绘制矢量字体和更多形状来格式化数据显示，并将生成的代码部署到 Pico 的闪存中，以便
    Pico 在提供电源时可以独立运行程序。
- en: Figure 10.18\. Using Espruino’s `Graphics` support to create shapes and draw
    text strings
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.18\. 使用 Espruino 的 `Graphics` 支持创建形状和绘制文本字符串
- en: '![](10fig18_alt.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig18_alt.jpg)'
- en: As with the timer, you’ll start by setting up some variables and an initialization
    function, shown in [listing 10.6](#ch10ex06). Pressure readings on the BMP180
    are considerably more accurate if you adjust them for your local altitude (in
    meters). The `getSeaLevel` method, available on objects returned by the `BMP085`
    module’s `connect()` function, gives you a handy way to perform that altitude
    correction. Note that the `getPressure` method is used here to read both pressure
    and temperature at the same time. Make sure to adjust the value of the `altitude`
    variable in the next listing to your local altitude (in meters).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与计时器一样，你将首先设置一些变量和一个初始化函数，如[列表 10.6](#ch10ex06)所示。如果对当地海拔（以米为单位）进行调整，BMP180
    的压力读数将更加准确。`getSeaLevel` 方法，可在 `BMP085` 模块的 `connect()` 函数返回的对象上使用，为你提供了一个方便的方式来执行海拔校正。请注意，这里使用
    `getPressure` 方法同时读取压力和温度。确保将下一列表中的 `altitude` 变量的值调整为你的当地海拔（以米为单位）。
- en: Listing 10.6\. Setting up the weather gadget
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 设置天气小工具
- en: '[PRE5]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Once the LCD is set up, then kick off the setInterval.**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一旦设置好 LCD，然后启动 setInterval。**'
- en: '***2* Invokes draw with the current temperature and the pressure adjusted for
    altitude**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用当前温度和调整后的海拔压力调用 draw。**'
- en: '***3* Don’t forget to invoke the onInit function!**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 不要忘记调用 onInit 函数！**'
- en: Lines, circles, and text with Espruino Graphics
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 直线、圆和带有 Espruino 图形的文本
- en: 'As with the timer, you need to write the `draw` function. The code in [listing
    10.7](#ch10ex07) makes use of more shape-drawing methods from the `Graphics` library:
    `drawLine(x1, y1, x2, y2)` and `drawCircle(x, y, radius)` ([figure 10.18](#ch10fig18)).
    It also avails itself of some methods for deriving dimensions: `getWidth()` and
    `getHeight()`, for example, which return the display’s usable area, in pixels,
    for the x and y axes, respectively. Finally, `stringWidth(str)` calculates the
    pixel width of the given string, using the current font settings.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与计时器一样，你需要编写 `draw` 函数。[列表 10.7](#ch10ex07) 中的代码使用了来自 `Graphics` 库的更多形状绘制方法：`drawLine(x1,
    y1, x2, y2)` 和 `drawCircle(x, y, radius)` ([图 10.18](#ch10fig18))。它还利用了一些获取尺寸的方法：例如
    `getWidth()` 和 `getHeight()`，它们分别返回显示器的可用区域，以像素为单位，对于 x 和 y 轴。最后，`stringWidth(str)`
    使用当前字体设置计算给定字符串的像素宽度。
- en: Let’s talk fonts. There’s a tiny bitmap font available whose characters are
    4 x 6 pixels in size. To use the bitmap font, you use the `setFontBitmap()` method
    to make that font active. In this example, however, you’ll use a vector font.
    The vector font can be used at various sizes—it scales. The `setFontVector(size)`
    method will set the active font to a scaled vector font with a height of `size`
    pixels.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈字体。有一个可用的位图字体，其字符大小为 4 x 6 像素。要使用位图字体，你使用 `setFontBitmap()` 方法使其成为活动字体。然而，在这个例子中，你将使用矢量字体。矢量字体可以用于各种大小——它可以缩放。`setFontVector(size)`
    方法将活动字体设置为具有 `size` 像素高度的缩放矢量字体。
- en: There are a lot of numbers in the following `draw` function. It’s a bit finicky-looking,
    but everything here is unsophisticated pixel arithmetic to position elements of
    text and shapes. Note that the string “mb” in the drawing function (the abbreviation
    for *millibars*) is “hand-kerned,” because I found that drawing the string in
    one go at that font size ran the letters together illegibly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的`draw`函数中有很多数字。它看起来有点挑剔，但这里的一切都是简单的像素运算，用于定位文本和形状的元素。请注意，绘图函数中的字符串“mb”（*毫巴*的缩写）是“手工调整字距的”，因为我发现用这种字体大小一次性绘制字符串会使字母难以辨认。
- en: Listing 10.7\. Rendering the weather display
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7. 渲染天气显示
- en: '[PRE6]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Put all of the code for the weather gadget into the code side of the Espruino
    IDE, and use the Send to Espruino icon to run the code on the Pico. It’ll show
    the temperature and pressure until it’s unplugged from the USB port of your computer.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将天气小部件的所有代码放入Espruino IDE的代码部分，并使用“发送到Espruino”图标在Pico上运行代码。直到从电脑的USB端口拔掉它，它将显示温度和压力。
- en: But you can do a little better! On the left side of the IDE, type the command
    `save()` and press Enter. This will flash the code to the Pico. Now, anytime the
    Pico has power, it will resume running this code. Try it out by plugging the Pico
    into a USB power source, like a phone charger.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以做得更好！在IDE的左侧，输入命令`save()`并按Enter键。这将把代码闪存到Pico上。现在，每当Pico有电时，它将恢复运行此代码。尝试通过将Pico插入USB电源，如手机充电器，来测试它。
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Power efficiency and the LCD’s backlight
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 功耗和LCD的背光
- en: To make the weather gadget more power-efficient, you might consider disconnecting
    the LCD’s LED backlight connection from power. You won’t be able to read the LCD
    in a dark room, but it’ll draw less power.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使天气小部件更加节能，你可能考虑断开LCD的LED背光连接电源。在黑暗的房间里你将无法阅读LCD，但它将消耗更少的电力。
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 10.4\. Experimenting with the Kinoma Element platform
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 在Kinoma Element平台上进行实验
- en: 'To rinse and repeat the process of platform exploration, we’ll take a brief
    look at another embedded-JavaScript platform: the Kinoma Element.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重复平台探索的过程，我们将简要地看看另一个嵌入式JavaScript平台：Kinoma Element。
- en: The Element is a small, JavaScript-powered IoT platform with 16 programmable
    pins ([figure 10.19](#ch10fig19)). Like the Espruino Pico, it’s inexpensive—an
    Element will set you back about $20 or maybe a little more. Also like the Pico,
    it lacks the bells and whistles of its more beefy (and costly) brethren—you won’t
    find onboard USB, Ethernet, SDCard, or other peripheral goodies—but it has the
    basic bits needed for IoT products in an efficient little package. Also, it has
    built-in WiFi support.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Element是一个小型、由JavaScript驱动的物联网平台，拥有16个可编程引脚（[图10.19](#ch10fig19)）。像Espruino
    Pico一样，它价格低廉——Element的价格大约是20美元或稍多一点。同样，像Pico一样，它没有其更加强大（且昂贵）的兄弟产品的所有功能——你不会在板上找到USB、以太网、SD卡或其他外围设备，但它以一个高效的小包装提供了物联网产品所需的基本组件。此外，它还内置了WiFi支持。
- en: Figure 10.19\. The Kinoma Element
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.19. Kinoma Element
- en: '![](10fig19_alt.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig19_alt.jpg)'
- en: 10.4.1\. The Element’s core features
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1. Element的核心功能
- en: Chipmaker Marvell produces the Element ([http://mng.bz/w1lR](http://mng.bz/w1lR)),
    which features its Marvell MW302 System-on-a-Chip (SoC), which in turn uses a
    200 MHz ARM Cortex M4\. The board, enclosure, JavaScript runtime, and framework
    software are open source.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片制造商Marvell生产Element（[http://mng.bz/w1lR](http://mng.bz/w1lR)），它具有Marvell MW302系统级芯片（SoC），该芯片使用200
    MHz的ARM Cortex M4。板、外壳、JavaScript运行时和框架软件都是开源的。
- en: To run JavaScript natively with only 512 KB RAM, the Element uses a technology
    called XIP (execute in place). The Element runs FreeRTOS, a streamlined and minimal
    open source operating system. The board’s operating voltage is 3.3 V.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要在只有512 KB RAM的情况下原生运行JavaScript，Element使用一种称为XIP（原地执行）的技术。Element运行FreeRTOS，这是一个精简和最小化的开源操作系统。板的供电电压是3.3
    V。
- en: The Element comes packaged in an enclosure, which makes it look less like a
    board and more like a finished device (the enclosure design is open source too).
    Instead of having dedicated power pins, you configure any of the Element’s 16
    pins (8 on each side of the board) as 3.3 V or ground as needed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Element被封装在一个外壳中，这使得它看起来更像是一个成品设备（外壳设计也是开源的）。它没有专门的电源引脚，你可以根据需要将Element的任何16个引脚（每侧8个）配置为3.3
    V或地。
- en: Kinoma uses its own (Apache-licensed) JavaScript engine, XS6, which, with minor
    exceptions, claims ES6 compatibility. Note that the Element’s IDE software is
    available for Mac and Windows (beta), but it doesn’t have Linux support.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Kinoma使用自己的（Apache许可的）JavaScript引擎XS6，除了少数例外，声称与ES6兼容。请注意，Element的IDE软件适用于Mac和Windows（beta），但未提供Linux支持。
- en: 10.4.2\. Pinout and hardware diagram
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2. 引脚布局和硬件图
- en: The Element’s pin layout is rather straightforward ([figure 10.20](#ch10fig20)).
    It’s a simpler device than the Pico in terms of I/O feature support; for example,
    there are two I²C interfaces but no support for SPI. On the flip side, it’s less
    complex to figure out which pins do what, and the numbering is easy to follow.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Element的引脚布局相当简单（[图10.20](#ch10fig20)）。在I/O功能支持方面，它比Pico简单；例如，有两个I²C接口，但没有SPI支持。另一方面，确定哪些引脚做什么要简单得多，编号也容易跟随。
- en: Figure 10.20\. Pinout diagram for the Kinoma Element
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.20. Kinoma Element的引脚布局图
- en: '![](10fig20_alt.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig20_alt.jpg)'
- en: 10.4.3\. Configuration, management, workflow
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.3. 配置、管理、工作流程
- en: The Element is a tidy, self-contained package that won’t require any soldering
    or prep. Jumper wires can plug right into it directly.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Element是一个整洁、自包含的包，不需要任何焊接或准备。跳线可以直接插入其中。
- en: 'The configuration and workflow is similar to the Pico in that there’s an IDE
    for configuring, authoring, and deploying. If you have an Element on hand, you
    can head over to the quick-start guide for details ([http://mng.bz/84cS](http://mng.bz/84cS)),
    but these are the general steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 配置和工作流程与Pico类似，因为有一个IDE用于配置、编写和部署。如果您手头有Element，可以查看快速入门指南以获取详细信息（[http://mng.bz/84cS](http://mng.bz/84cS)），但以下是一般步骤：
- en: Download and install the Kinoma Code IDE.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装Kinoma Code IDE。
- en: Get the Element set up on your WiFi network.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的WiFi网络上设置Element。
- en: Apply the firmware update.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用固件更新。
- en: Code projects for the Element, developed in the Kinoma Code IDE ([figure 10.21](#ch10fig21)),
    can be deployed over USB or WiFi b/g/n. Setup involves getting the Element on
    your local WiFi network. It will be assigned its own IP address.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kinoma Code IDE（[图10.21](#ch10fig21)）中开发的Element代码项目可以通过USB或WiFi b/g/n部署。设置涉及将Element连接到您的本地WiFi网络。它将被分配自己的IP地址。
- en: Figure 10.21\. Kinoma Code IDE software
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.21. Kinoma Code IDE软件
- en: '![](10fig21_alt.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig21_alt.jpg)'
- en: Application projects for the Element have some structure to them. For example,
    each must contain a project.json file, which defines an entry point—the script
    that will get executed on the device. The entry point defaults to main.js.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Element的应用项目具有一定的结构。例如，每个项目都必须包含一个project.json文件，该文件定义了入口点——将在设备上执行的脚本。入口点默认为main.js。
- en: 'As with Espruino, Kinoma provides some global objects to help you interact
    with hardware, and there is the notion of modules for the encapsulation of component
    behavior. Kinoma modules for controlling hardware components are known as *Blinking-Light
    Libraries* (BLLs) and they involve interacting with the hardware through a (built-in)
    *Pins* module. You can use CommonJS style `require` statements to pull other JS
    files into your projects and any built-in or custom BLL modules (but remember,
    this isn’t Node.js: you can’t use npm modules).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与Espruino类似，Kinoma提供了一些全局对象来帮助您与硬件交互，并且有模块封装组件行为的概念。用于控制硬件组件的Kinoma模块被称为*闪烁灯库*（BLLs），它们涉及通过（内置的）*引脚*模块与硬件交互。您可以使用CommonJS风格的`require`语句将其他JS文件拉入您的项目，以及任何内置或自定义的BLL模块（但请记住，这并不是Node.js：您不能使用npm模块）。
- en: 10.4.4\. Examples and tutorials
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.4. 示例和教程
- en: 'Kinoma’s site has some code examples for the Element: [http://mng.bz/1BaB](http://mng.bz/1BaB).
    Looking at the blinking-LED example code ([http://mng.bz/5t61](http://mng.bz/5t61)),
    it’s immediately evident that the structure of Kinoma projects is more formal
    than that of some other platforms ([figure 10.22](#ch10fig22)). Blinking an LED
    involves a project.json file to define the project, a main.js (entry point) to
    initialize the board and configure the pin for the LED, and an led.js BLL module
    that provides the logical support for blinking via a `toggle` method. (The .project
    file and the XML file in the project appear to be for Kinoma-site-specific build
    and metadata support.)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Kinoma网站上有一些Element的代码示例：[http://mng.bz/1BaB](http://mng.bz/1BaB)。查看闪烁LED的示例代码([http://mng.bz/5t61](http://mng.bz/5t61))，可以立即看出Kinoma项目的结构比某些其他平台更为正式（[图10.22](#ch10fig22)）。闪烁LED需要通过一个project.json文件来定义项目，一个main.js（入口点）来初始化板子并配置LED的引脚，以及一个led.js
    BLL模块，它通过`toggle`方法提供闪烁的逻辑支持。（项目中的.project文件和XML文件似乎是用于Kinoma网站特定的构建和元数据支持。）
- en: Figure 10.22\. The source for a blinking-LED Kinoma example project. The structure
    of a Kinoma project is more involved than that of an Espruino project.
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.22. 闪烁LED的Kinoma示例项目的源代码。Kinoma项目的结构比Espruino项目更为复杂。
- en: '![](10fig22_alt.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig22_alt.jpg)'
- en: You’ll also need to bring your own LED and resistor to the party, as there’s
    no evident onboard LED you can use. The code inside of this project’s main.js
    file assumes you’re using pins 9 and 10 (ground), but there’s no wiring diagram
    provided.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在聚会上自带LED灯和电阻，因为板上没有明显的LED灯可以使用。这个项目main.js文件中的代码假设你使用的是9号和10号引脚（接地），但并未提供接线图。
- en: You’ll learn more about what the code in a Kinoma main.js script looks like
    in just a bit.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在稍后了解更多关于Kinoma main.js脚本中代码的样子。
- en: 10.4.5\. API reference
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.5. API参考
- en: 'Kinoma modules provide the API for hardware interaction. The most immediately
    relevant module is `Pins`, which provides basic I/O support for the kinds of things
    you’d expect: digital and analog input and output; pulse-width modulation (PWM);
    serial (I²C, for example). You can find a programmer’s guide on the Kinoma site
    ([http://mng.bz/w1lR](http://mng.bz/w1lR)).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Kinoma模块提供了硬件交互的API。最相关的模块是`Pins`，它提供了基本的I/O支持，包括你预期的类型：数字和模拟输入输出；脉冲宽度调制（PWM）；串行（例如I²C）。你可以在Kinoma网站上找到程序员指南([http://mng.bz/w1lR](http://mng.bz/w1lR))。
- en: '10.4.6\. Case-study project: live-updating compass readings'
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.6. 案例研究项目：实时更新的指南针读数
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备的东西
- en: '![](note.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Kinoma Element
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Kinoma Element
- en: 1 USB A to USB micro cable
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 USB A to USB micro线缆
- en: 1 breadboard
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 面包板
- en: 1 HMC5883L magnetometer breakout board
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 HMC5883L磁力计扩展板
- en: Jumper wires
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳接线
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Element, with its onboard WiFi and web utility libraries, lends itself to
    acting as a web server a little more obviously than the Pico.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Element内置WiFi和Web实用库，比Pico更明显地可以作为Web服务器使用。
- en: In this experiment, you’ll take a look at the high-level process of creating
    a project with the Element, crafting a custom BLL to support the HMC5883L I²C
    magnetometer (compass). you’ll use Kinoma’s available WebSocket module to run
    a WebSocket server on the Element that can emit changes when the compass heading
    changes. Finally, you’ll construct an HTML document that will connect to the Element’s
    WebSocket server and update as the compass heading changes ([figure 10.23](#ch10fig23)).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你将查看使用Element创建项目的高级过程，制作一个自定义BLL来支持HMC5883L I²C磁力计（指南针）。你将使用Kinoma的WebSocket模块在Element上运行WebSocket服务器，当指南针方向改变时可以发出变化。最后，你将构建一个HTML文档，该文档将连接到Element的WebSocket服务器，并在指南针方向改变时更新（[图10.23](#ch10fig23)）。
- en: Figure 10.23\. Detail of browser display, showing compass heading. The compass
    heading will update, live, without requiring a browser reload. In this case, the
    current heading was 190.62 degrees—a little bit west of south.
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.23. 浏览器显示的细节，显示指南针方向。指南针方向将实时更新，无需刷新浏览器。在这种情况下，当前方向是190.62度——稍微偏西。
- en: '![](10fig23.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig23.jpg)'
- en: The HMC5883L module will be connected to a breadboard. By rotating the breadboard,
    you can change the magnetometer’s orientation and see the updated heading within
    the browser—in real time.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: HMC5883L模块将被连接到面包板上。通过旋转面包板，你可以改变磁力计的方向，并在浏览器中实时看到更新的方向。
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**WebSocket browser support**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket浏览器支持**'
- en: You’ve met the WebSocket protocol before. In [chapter 8](kindle_split_017.html#ch08),
    you used socket.IO in the Tessel 2 weather station application to show live-updating
    temperature and pressure. Socket.IO uses WebSockets for browsers that have WebSockets
    support, and it falls back to other methods for browsers that don’t support WebSockets.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经遇到过WebSocket协议。在[第8章](kindle_split_017.html#ch08)中，你使用了Tessel 2气象站应用程序中的socket.IO来显示实时更新的温度和压力。Socket.IO为支持WebSocket的浏览器使用WebSocket，对于不支持WebSocket的浏览器，它将回退到其他方法。
- en: 'In this example, you’ll use WebSockets proper: the application won’t work in
    brows-ers that don’t support WebSockets. A lack of WebSockets support is exceedingly
    rare in browsers these days, so it’s unlikely you’ll run into problems.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将使用WebSocket的正确用法：不支持WebSocket的浏览器中应用程序将无法工作。如今，浏览器中缺少WebSocket支持的情况极为罕见，因此你不太可能遇到问题。
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Building the circuit
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建电路
- en: Place the HMC5883L on a breadboard and connect it to the Element as shown in
    [figure 10.24](#ch10fig24). The SDA and SCL pins on the breakout board connect
    to the Element’s pins 13 and 14, which, as shown in the pinout in [figure 10.20](#ch10fig20),
    have support for I²C. Any pin on the Element can be configured as power or ground;
    pins 11 and 12 are used here because of their proximity to the I²C pins.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 将HMC5883L放置在面包板上，并按[图10.24](#ch10fig24)所示连接到Element。断出板上的SDA和SCL引脚连接到Element的13号和14号引脚，如图[图10.20](#ch10fig20)中的引脚图所示，它们支持I²C。Element上的任何引脚都可以配置为电源或地；这里使用11号和12号引脚是因为它们靠近I²C引脚。
- en: Figure 10.24\. Kinoma Element and HMC5883L
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.24\. Kinoma Element和HMC5883L
- en: '![](10fig24_alt.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig24_alt.jpg)'
- en: Structuring the project
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'The Element live-compass project consists of four files ([figure 10.25](#ch10fig25)):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Element实时指南针项目由四个文件组成([图10.25](#ch10fig25))：
- en: A package.json file with Kinoma project metadata
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含Kinoma项目元数据的package.json文件
- en: A main.js file serving as the app’s main module (entry point)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个main.js文件，作为应用程序的主要模块（入口点）
- en: An HMC5883L.js file, which is the custom Kinoma BLL module for the compass
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HMC5883L.js文件，这是用于指南针的自定义Kinoma BLL模块
- en: An index.html file, which is the client-side code—you view it in a web browser
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个index.html文件，这是客户端代码——你在网页浏览器中查看它
- en: Figure 10.25\. The structure for the Element live-compass project. The main.js
    file provides application logic and a WebSocket server, relying on support from
    the BLL in HMC5883L.js to interact with the magnetometer. The project.json file
    defines the project, using Kinoma conventions. Index.html is run in a web browser
    on your computer and shows live-updating compass headings.
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.25\. Element实时指南针项目的结构。main.js文件提供应用程序逻辑和WebSocket服务器，依赖于HMC5883L.js中的BLL支持与磁力计交互。project.json文件定义了项目，使用Kinoma约定。Index.html在您的计算机上的网页浏览器中运行，并显示实时更新的指南针方向。
- en: '![](10fig25_alt.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig25_alt.jpg)'
- en: First, create the package.json file and enter some metadata, as shown in the
    next listing.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建package.json文件并输入一些元数据，如下一列表所示。
- en: Listing 10.8\. project.json
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8\. project.json
- en: '[PRE7]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* ID strings should be in “dotted domain name style” according to the documentation.**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ID字符串应根据文档中的说明采用“点域名样式”。**'
- en: '***2* The app’s entry point will be main.js.**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 应用程序的入口点将是main.js。**'
- en: Creating the application’s structure
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建应用程序的结构
- en: Kinoma project application modules—main.js in this case—have a general structure.
    They need to export a `default` function that implements some event handlers,
    such as `onLaunch()` and `onQuit()`. The launch handler configures the board’s
    pins and kicks things off.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Kinoma项目应用程序模块——在这个例子中是main.js——有一个通用结构。它们需要导出一个`default`函数，该函数实现一些事件处理器，例如`onLaunch()`和`onQuit()`。启动处理器配置板上的引脚并启动应用程序。
- en: The module’s basic structure is as follows.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的基本结构如下。
- en: Listing 10.9\. Structure of main.js
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.9\. main.js的结构
- en: '[PRE8]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* This is the built-in Pins module, upon which much in Kinoma apps depends.**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这是内置的Pins模块，Kinoma应用中的许多功能都依赖于它。**'
- en: '***2* Kinoma has a built-in websocket module; you’ll need to use the WebSocketServer
    from it.**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Kinoma有一个内置的websocket模块；你需要使用其中的WebSocketServer。**'
- en: '***3* This is a convenience function for formatting compass headers (not used
    yet).**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这是一个用于格式化指南针头部的便利函数（尚未使用）。**'
- en: '***4* onLaunch() will be invoked automatically on launch.**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* onLaunch()将在启动时自动调用。**'
- en: '***5* Pins.configure takes a callback function, invoked when it’s complete.**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* Pins.configure接受一个回调函数，当它完成时调用。**'
- en: Once the custom HMC5883L module is ready, you’ll come back and fill in the blanks
    in main.js.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦自定义HMC5883L模块准备就绪，你将返回并填写main.js中的空白。
- en: A custom BLL for the HMC5883L
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HMC5883L 的自定义 BLL
- en: A BLL, or *blinking-light library*, encapsulates Kinoma-compatible component
    behavior in a module. A BLL module needs to do certain things. According to the
    Kinoma documentation, a BLL must export at minimum a `pins` object defining the
    type of pins it uses, a `configure` function, and a `close` function.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: BLL（或闪烁灯库）封装了与 Kinoma 兼容的组件行为在一个模块中。BLL 模块需要执行某些操作。根据 Kinoma 文档，BLL 至少需要导出一个定义其使用的引脚类型的
    `pins` 对象、一个 `configure` 函数和一个 `close` 函数。
- en: The following listing shows an excerpt from the completed HMC5883L BLL module.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了完成的 HMC5883L BLL 模块的部分内容。
- en: Listing 10.10\. BLL code detail
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. BLL 代码细节
- en: '[PRE9]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* writeByteDataSMB() is provided by the Kinoma I²C API; it reads from a
    specific register address.**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* writeByteDataSMB() 由 Kinoma I²C API 提供；它从特定的寄存器地址读取。**'
- en: '***2* readBlockDataSMB(), again from the API, is used to get six bytes from
    the READ register as an array.**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* readBlockDataSMB()，同样来自 API，用于从 READ 寄存器获取六个字节的数组。**'
- en: '***3* HMC5883L data consists of two bytes for each of the three axes.**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* HMC5883L 的数据由三个轴的每个轴的两个字节组成。**'
- en: '***4* int16() is a utility function to make a 16-bit integer from two bytes
    (implementation not shown).**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* int16() 是一个实用函数，用于从两个字节中创建一个 16 位整数（实现未显示）。**'
- en: '***5* toHeading() uses math to derive a heading from the data (implementation
    not shown).**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* toHeading() 使用数学从数据中推导出航向（实现未显示）。**'
- en: '|  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Credits for the HMC5883L Kinoma BLL module**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**HMC5883L Kinoma BLL 模块的贡献者**'
- en: I cobbled together this BLL myself as an exploration into how BLL modules and
    I²C work on the Element, but the code draws heavily from pre-existing work. It’s
    effectively a port of the Johnny-Five support logic for the sensor ([http://mng.bz/TxHV](http://mng.bz/TxHV)),
    written by Johnny-Five inventor Rick Waldron. The Johnny-Five code in turn relies
    on an earlier implementation for Arduino ([http://mng.bz/nB4V](http://mng.bz/nB4V)),
    which in turn relies on the datasheet for the device ([http://mng.bz/j67k](http://mng.bz/j67k)).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己拼凑了这个 BLL，作为探索 BLL 模块和 I²C 在 Element 上如何工作的一个尝试，但代码大量借鉴了现有的工作。它实际上是 Johnny-Five
    对该传感器的支持逻辑的移植（[http://mng.bz/TxHV](http://mng.bz/TxHV)），由 Johnny-Five 的发明者 Rick
    Waldron 编写。Johnny-Five 的代码反过来依赖于 Arduino 的早期实现（[http://mng.bz/nB4V](http://mng.bz/nB4V)），而
    Arduino 的实现又依赖于该设备的数据表（[http://mng.bz/j67k](http://mng.bz/j67k)）。
- en: This kind of complex pedigree is par for the course in open source software,
    but as a reminder, always check your licenses and make sure you honor them. Also,
    give shout-outs to the inspiration for your work.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂的血统在开源软件中是常见的，但作为提醒，始终检查你的许可证并确保你遵守它们。此外，对你的工作的灵感来源表示感谢。
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Listing 10.10](#ch10ex10) only shows a portion of the completed BLL. The complete
    version of the 5883L BLL can be found in the book’s code repository. You’ll need
    it if you want to build this experiment: place it in the same directory as the
    other project files.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.10](#ch10ex10) 只显示了完成的 BLL 的一部分。完整的 5883L BLL 可以在本书的代码仓库中找到。如果你想构建这个实验，你需要它：将其放置在其他项目文件相同的目录中。'
- en: Finishing the application code
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完成应用程序代码
- en: With the BLL sewn up, the bits in main.js that rely on on the BLL can be filled
    in. As shown in the following listing, the `onLaunch` handler sets up the compass
    sensor on the Element by passing a settings object to `Pins.configure()`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 BLL 后，main.js 中依赖于 BLL 的部分可以填充。如下一个列表所示，`onLaunch` 处理程序通过传递一个设置对象到 `Pins.configure()`
    来在 Element 上设置指南针传感器。
- en: Listing 10.11\. Configuring pins
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. 配置引脚
- en: '[PRE10]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* The custom BLL module, by filename, no extension**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 自定义 BLL 模块，按文件名，无扩展名**'
- en: '***2* Callback function**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 回调函数**'
- en: You also pass a callback function as a second argument to `Pins.configure()`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将一个回调函数作为第二个参数传递给 `Pins.configure()`。
- en: Within that callback, you first need to get a WebSocket server going, as shown
    in the next listing. This code uses the API of the built-in Kinoma `WebSocketServer`
    (`WebSocketServer` was required in [listing 10.9](#ch10ex09)).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个回调函数中，你首先需要启动一个 WebSocket 服务器，如下一个列表所示。此代码使用了内置的 Kinoma `WebSocketServer`
    API（`WebSocketServer` 在 [列表 10.9](#ch10ex09) 中是必需的）。
- en: Listing 10.12\. WebSocket server setup
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12\. WebSocket 服务器设置
- en: '[PRE11]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* ES6 feature support, so Set can be used**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 支持 ES6 功能，因此可以使用 Set**'
- en: '***2* Starts a WebSocket server on the Element’s port 80**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 Element 的端口 80 上启动 WebSocket 服务器**'
- en: '***3* Holds the last compass heading reading**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 保存最后的指南针航向读取**'
- en: The code in [listing 10.12](#ch10ex12) emits an initial compass reading when
    a client connects, but how are compass readings obtained in the first place, and
    how does the client receive updates when the readings change? The last bits of
    code for main.js, shown in the following listing, take care of those things.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.12](#ch10ex12) 中的代码在客户端连接时发出初始航向读取，但航向读取最初是如何获得的，以及当读取值发生变化时客户端如何接收更新？以下列表中显示的
    main.js 的最后几行代码负责处理这些事情。'
- en: Listing 10.13\. Reading and updating compass headings
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13\. 读取和更新航向
- en: '[PRE12]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Reads every 500**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每 500 次读取**'
- en: '***2* If the new result (the heading, in degrees) differs from the last result
    by some threshold amount...**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果新的结果（航向，以度为单位）与上次结果相差某个阈值...**'
- en: '***3* ...it has meaningfully changed. Send the new value to each of the connected
    clients.**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* ...它已经发生了有意义的改变。将新值发送给每个已连接的客户端。**'
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Functions as paths in BLLs**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**BLL 中的函数作为路径**'
- en: 'Functions in BLLs are referenced externally by path:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: BLL 中的函数通过路径在外部引用：
- en: '[PRE13]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `/compass/read` is a “path” to the `read` function in the BLL module.
    The line of code here repeatedly invokes `read` every 500 ms, and a callback function
    receives the `result` of the latest read operation. See it in play in [listing
    10.13](#ch10ex13).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`/compass/read` 是 BLL 模块中 `read` 函数的“路径”。这里的代码每 500 毫秒重复调用一次 `read`，并且一个回调函数接收最新读取操作的
    `result`。请参见 [列表 10.13](#ch10ex13) 中的演示。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Client code (HTML)
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 客户端代码（HTML）
- en: Finally, you’ll need an HTML page to serve as a WebSocket client and to show
    the compass headings in real time. This page can be viewed in a browser.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要一个 HTML 页面作为 WebSocket 客户端，并实时显示航向。此页面可以在浏览器中查看。
- en: Listing 10.14\. Client code (HTML page) for showing compass heading
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 显示航向的客户端代码（HTML 页面）
- en: '[PRE14]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Styling for the heading display**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 航向显示的样式**'
- en: '***2* On load, connects to the WebSocket server**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在加载时连接到 WebSocket 服务器**'
- en: '***3* Important! You need to change this to your own Element’s IP address.**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 重要！您需要将其更改为您自己的 Element 的 IP 地址。**'
- en: '***4* When new data comes in, updates the HTML in the #direction element to
    display the new heading**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当新数据到来时，更新 #direction 元素中的 HTML 以显示新的航向**'
- en: Deploying the compass code
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部署航向代码
- en: Code is deployed to the Element via the Kinoma Code IDE. Note that the index.html
    file isn’t served from the Element in this example. Instead, you open that file
    in a browser once the Element is running the compass application. See the Element
    quick-start guide ([http://mng.bz/84cS](http://mng.bz/84cS)) for step-by-step
    instructions about how to connect to and deploy code to your Element from the
    Kinoma Code IDE, if you haven’t done so already.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Kinoma Code IDE 将代码部署到 Element。请注意，在这个例子中，index.html 文件不是从 Element 服务器上提供的。相反，您需要在
    Element 运行航向应用程序后，在浏览器中打开该文件。如果您还没有这样做，请参阅 Element 快速入门指南 ([http://mng.bz/84cS](http://mng.bz/84cS))，了解如何从
    Kinoma Code IDE 连接到并部署代码到您的 Element 的逐步说明。
- en: Once the code is deployed and running, you can open up the index.html file in
    a browser and rotate the breadboard with the attached compass to see the display
    update in real time.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码部署并运行，您就可以在浏览器中打开 index.html 文件，并旋转连接有罗盘的面包板，以实时查看显示更新。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Embedded JavaScript platforms use optimized hardware and firmware to execute
    subsets of JavaScript natively. Both Kinoma and Espruino maintain their own, open
    source JavaScript engines (KinomaJS and Espruino JavaScript, respectively) to
    make this possible.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式 JavaScript 平台使用优化的硬件和固件来执行 JavaScript 的子集。Kinoma 和 Espruino 都维护自己的开源 JavaScript
    引擎（分别称为 KinomaJS 和 Espruino JavaScript），以实现这一点。
- en: Embedded JS platforms tend to have more sophisticated processors—often 32-bit—but
    still have significant constraints on memory and program space.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式 JS 平台通常具有更复杂的处理器——通常是 32 位——但仍然对内存和程序空间有显著的限制。
- en: Espruino’s open source family of products includes the Pico, a diminutively
    sized development board. Espruino projects can make use of Espruino-specific modules
    to work with different kinds of components.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Espruino 的开源产品系列包括 Pico，这是一个尺寸较小的开发板。Espruino 项目可以利用 Espruino 特定的模块来处理不同类型的组件。
- en: The Kinoma Element is another open source JavaScript-powered device. Creating
    projects for the Element involves the use of component modules called BLLs (blinking-light
    libraries).
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kinoma Element 是另一个由 JavaScript 驱动的开源设备。为 Element 创建项目涉及使用称为 BLL（闪烁灯库）的组件模块。
- en: 'Although there are many platform options out there, you can speed your learning
    process with new platforms by following certain steps: learning about core details,
    finding hardware and pinout information, understanding the workflow, trying out
    examples, and seeking out API documentation.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然有许多平台选项，但你可以通过以下步骤加快学习新平台的速度：了解核心细节、查找硬件和引脚信息、理解工作流程、尝试示例和寻找API文档。
- en: Chapter 11\. Building with Node.js and tiny computers
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章\. 使用Node.js和微型计算机构建
- en: '*This chapter covers*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Getting started with Node.js hardware development on single-board computer (SBC)
    platforms
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单板计算机（SBC）平台上开始Node.js硬件开发
- en: Corralling components and setting up a Raspberry Pi 3 Model B system
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集组件并设置Raspberry Pi 3 Model B系统
- en: How GPIO works on the Raspberry Pi, and some different options for controlling
    it with JavaScript
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Raspberry Pi上GPIO的工作原理，以及使用JavaScript控制它的不同选项
- en: Adapting a Johnny-Five weather station app to work on several different platforms—Tessel
    2, Raspberry Pi, Arduino, and BeagleBone Black
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Johnny-Five气象站应用程序适配到多个不同的平台——Tessel 2、Raspberry Pi、Arduino和BeagleBone Black
- en: Working with the GPIO-rich BeagleBone Black open source SBC
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPIO丰富的BeagleBone Black开源SBC
- en: 'Single-board computers (SBCs) are tiny powerhouses that combine general-purpose
    computing with the characteristics of embedded systems ([figure 11.1](#ch11fig01)).
    These itty-bitty computers pack a host of peripherals and goodies into a small
    package: multiple USB ports, Bluetooth, WiFi, Ethernet—the features you’d expect
    from a desktop computer. But they have several features that lend themselves well
    to embedded applications: their cut-down size, lower price point, GPIO support,
    and relative power efficiency (while not as power-miserly as simpler embedded
    platforms, they certainly require less juice than their desktop brethren).'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 单板计算机（SBCs）是小型动力强大的设备，将通用计算与嵌入式系统的特性相结合（[图11.1](#ch11fig01)）。这些小巧的计算机将众多外围设备和好东西打包进一个小巧的封装中：多个USB端口、蓝牙、WiFi、以太网——这些都是你从台式电脑上期望的功能。但它们有几个特性非常适合嵌入式应用：它们的尺寸减小、价格较低、GPIO支持以及相对的电力效率（虽然它们不像更简单的嵌入式平台那样节能，但它们确实比台式电脑兄弟需要更少的电力）。
- en: 'Figure 11.1\. Single-board computers (SBCs), left to right: Intel Edison module
    with Arduino breakout, Raspberry Pi 2 Model B, and BeagleBone Black'
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1\. 单板计算机（SBCs），从左到右：带有Arduino扩展板的Intel Edison模块、Raspberry Pi 2 Model B和BeagleBone
    Black
- en: '![](11fig01_alt.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig01_alt.jpg)'
- en: 'This isn’t the first time you’ve seen SBCs in this book, but let’s revisit
    what an SBC is, broadly speaking. There’s no formal definition of the term, but
    SBC platforms tend to do the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你第一次在这本书中看到SBCs，但让我们广泛地回顾一下SBC是什么。这个术语没有正式的定义，但SBC平台通常具有以下特点：
- en: Run high-level operating systems; in most cases you can install a different
    OS if you choose (typically, but not always, Linux)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行高级操作系统；在大多数情况下，如果你选择的话，可以安装不同的操作系统（通常是Linux，但并非总是如此）
- en: Offer general-purpose desktop-like features, such as support for USB peripherals,
    displays, sound, and so on
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供类似桌面电脑的通用功能，例如支持USB外设、显示器、声音等
- en: Provide GPIO options, though these sometimes play second fiddle to other features
    of the platform
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供GPIO选项，尽管这些有时会排在平台其他功能的后面
- en: The juggernaut in this category is the Raspberry Pi platform, a family of SBCs
    that are enjoying epic popularity. Accordingly, we’ll spend most of this chapter
    diving into Node.js and the Raspberry Pi 3 Model B. But we’ll also take a briefer
    tour of the BeagleBone Black board as a second example of a platform in this SBC
    class.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类别中，Raspberry Pi平台是当之无愧的巨头，这是一系列广受欢迎的单板计算机。因此，我们将在本章的大部分内容中深入探讨Node.js和Raspberry
    Pi 3 Model B。但我们也将对BeagleBone Black板进行简要的浏览，作为本SBC类别中平台的第二个示例。
- en: '|  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](tool.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于本章，你需要以下内容：**'
- en: 1 Raspberry Pi 3 Model B and 5 V power supply
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Raspberry Pi 3 Model B和5 V电源
- en: 1 microSD card and adapter
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 microSD卡和适配器
- en: 1 Adafruit T-Cobbler, SparkFun Pi Wedge, or similar, or an assortment of male-to-female
    jumper wires
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Adafruit T-Cobbler、SparkFun Pi Wedge或类似产品，或一套公对母跳线
- en: 1 standard LED, any color
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 标准LED，任何颜色
- en: 1 100 V resistor
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 100 V电阻
- en: 1 Adafruit BMP180 multisensor breakout board
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Adafruit BMP180多传感器扩展板
- en: Jumper wires
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 1 BeagleBone Black
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 BeagleBone Black
- en: 1 Arduino Uno
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno
- en: 1 half-size breadboard
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 半尺寸面包板
- en: '![](0334fig01_alt.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](0334fig01_alt.jpg)'
- en: '|  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The Tessel 2 and the definition of single-board computers**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tessel 2和单板计算机的定义**'
- en: The Tessel 2 is almost a device category unto itself. Its USB peripherals, networking
    capabilities, and high-level OS (OpenWrt Linux) seem to suggest SBC territory.
    Yet its limited RAM and Flash storage, as well as its lack of desktop-like peripheral
    support (such as a display) are signs that it’s designed for embedded applications.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel 2 几乎是一个独立的设备类别。它的 USB 外设、网络功能和高级操作系统（OpenWrt Linux）似乎暗示了单板计算机（SBC）的领域。然而，它的有限
    RAM 和闪存存储，以及缺乏类似桌面的外设支持（如显示器），表明它是为嵌入式应用而设计的。
- en: So is it an SBC? I’d tend to lean toward a qualified yes, but if your own definition
    of *SBC* emphatically involves the ability to plug in a display and use it as
    a desktop computer, then nope!
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它是不是一个单板计算机？我倾向于认为是有条件的“是”，但如果你对 *SBC* 的定义明确包括能够插入显示器并用作台式计算机的能力，那么就不是！
- en: '|  |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.1\. Working with tiny computers
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. 与微型计算机一起工作
- en: 'SBCs are certainly more sophisticated than their simpler dev-board brethren.
    They can also be, correspondingly, more involved to set up and configure out of
    the box. In many cases, you’ll be dealing with copious amounts of choice in both
    software and hardware realms. Don’t panic, though: getting from zero to zoom on
    a Raspberry Pi 3 using an SD card preflashed with *NOOBS* (New Out-of-Box Software)
    for Raspberry Pis can be breathtakingly simple. But you’ll need to roll up your
    Linux sleeves and spend some time in a terminal to get a comfortable, Node.js-centric
    workflow sorted out.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 单板计算机当然比它们更简单的开发板兄弟更复杂。它们也可以相应地更复杂，需要设置和配置。在许多情况下，你将在软件和硬件领域都面临大量的选择。不过，别慌张：使用预刷了
    *NOOBS*（新开箱即用软件）的 SD 卡将 Raspberry Pi 3 从零开始到全速运行可以非常简单。但你需要卷起你的 Linux 衣袖，花些时间在终端上，以整理出一个舒适、以
    Node.js 为中心的流程。
- en: Don’t be nervous. Should anything go awry when following the setup steps for
    either of the SBCs we’ll examine—the Raspberry Pi 3 and the BeagleBone Black—you
    can always start again from scratch without doing irreparable harm.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 别紧张。如果我们检查的任何 SBC（Raspberry Pi 3 和 BeagleBone Black）的设置步骤出现问题，你总是可以从头开始，而不会造成不可修复的损害。
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**SBCs, embedded systems, and (Debian) Linux**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**单板计算机、嵌入式系统和（Debian）Linux**'
- en: 'There has been a Big Bang of Linux projects and distributions targeted at embedded
    and mobile devices over the past several years. For example, the Tessel runs a
    pared-down Linux originally developed for routers: OpenWrt.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，针对嵌入式和移动设备的 Linux 项目和发行版经历了大爆炸。例如，Tessel 运行的是最初为路由器开发的精简版 Linux：OpenWrt。
- en: As we dig into higher-performance SBCs, you’ll see that there are decisions
    to be made—most platforms will happily run a number of different Linux distributions.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究高性能 SBC 时，你会看到需要做出决定——大多数平台都愿意运行多个不同的 Linux 发行版。
- en: 'With the Raspberry Pi, we’ll stick with the default and most common choice:
    Rasp-bian, a Debian-based Linux. For consistency, the BeagleBone Black exploration
    at the end of the chapter reflashes the board with Debian Linux instead of using
    the default (Ångström) that it ships with.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Raspberry Pi，我们将坚持默认和最常见的选择：基于 Debian 的 Raspbian Linux。为了保持一致性，本章末尾的 BeagleBone
    Black 探索将使用 Debian Linux 重新刷新板子，而不是使用它随附的默认（Ångström）。
- en: Debian releases are named after *Toy Story* characters. At the time of writing,
    Debian stable is at version 9 (Stretch), but most embedded and SBC platforms are
    still using builds of version 8 (Jessie). One sometimes sees version 7 (Wheezy)
    builds, though they’re becoming less common.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 版本以《玩具总动员》的角色命名。在撰写本文时，Debian 稳定版是第 9 版（Stretch），但大多数嵌入式和单板计算机平台仍在使用第
    8 版（Jessie）的构建。有时可以看到第 7 版（Wheezy）的构建，尽管它们变得越来越不常见。
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.1.1\. The Raspberry Pi platform
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1. Raspberry Pi 平台
- en: 'The Raspberry Pi ([figure 11.2](#ch11fig02)) is everywhere you look. What the
    Arduino platform is to simpler dev boards, the Pi platform is to SBCs: ubiquitous.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi ([图 11.2](#ch11fig02)) 到处都是。Arduino 平台对于简单的开发板来说是什么，Pi 平台对于单板计算机来说就是什么：无处不在。
- en: Figure 11.2\. Raspberry Pi 2 Model B (left), Raspberry Pi Zero (center foreground),
    and Raspberry Pi 3 Model B (in a case, with attached SparkFun Pi Wedge)
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.2. Raspberry Pi 2 Model B（左侧）、Raspberry Pi Zero（中心前景）和 Raspberry Pi 3 Model
    B（在盒子里，附带 SparkFun Pi Wedge）
- en: '![](11fig02_alt.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig02_alt.jpg)'
- en: With each sequential numbered Pi generation (1, 2, and 3 so far), the platform
    has become more powerful, efficient, stable, and jam-packed with features. The
    exception is the Pi Zero family, which is even smaller and cheaper—but at the
    cost of some performance and features.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个按顺序编号的Pi代（到目前为止有1、2和3代），该平台变得更加强大、高效、稳定，并且功能丰富。例外的是Pi Zero系列，它甚至更小、更便宜——但以牺牲一些性能和功能为代价。
- en: Despite its power and flexibility, the Raspberry Pi platform isn’t always the
    ideal choice for electronics beginners. The sheer number of things you can do
    with a Pi can be distracting, as can the task of handling Linux administration
    and other configuration details. It’s easy to get off on a Google-search tangent,
    wallowing for hours amidst forums and project ideas and options.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Raspberry Pi平台在功能和灵活性方面很强大，但并不总是电子初学者的理想选择。你可以用Pi做的众多事情可能会分散注意力，处理Linux管理和其他配置细节的任务也是如此。很容易陷入谷歌搜索的歧途，在论坛、项目想法和选项中浪费数小时。
- en: In addition, Pi pinouts are fairly complex and have multiple, confusing numbering
    and naming systems. Despite the large number of pins, some GPIO support is completely
    missing. There’s no onboard analog-to-digital conversion (ADC), for instance.
    Other key GPIO features are limited. Of the 40 GPIO pins on a Raspberry Pi 3 Model
    B ([figure 11.3](#ch11fig03)) only two are PWM-capable.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Pi引脚排列相当复杂，有多个混淆的编号和命名系统。尽管引脚数量众多，但一些GPIO支持完全缺失。例如，没有板载的模数转换器（ADC）。其他关键的GPIO功能也有限。在Raspberry
    Pi 3 Model B的40个GPIO引脚中（[图11.3](#ch11fig03)），只有两个是PWM功能的。
- en: Figure 11.3\. The Raspberry Pi 3 Model B
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3\. Raspberry Pi 3 Model B
- en: '![](11fig03_alt.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig03_alt.jpg)'
- en: On the other hand, you’ve learned enough about the basics that some of these
    potential pitfalls may not seem so daunting anymore. Raspbian—the Pi’s default
    Debian-based OS—is widely used, sensible, and reliable. Because so many people
    use Pis, there are scads of resources designed to assist even rank beginners,
    and there are vast troves of forums, wikis, Stack Overflow and blog posts, and
    so on, to aid you with every last detail.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您已经对基础知识有了足够的了解，一些潜在的陷阱可能不再那么令人生畏。Raspbian——Pi的默认基于Debian的操作系统——被广泛使用，合理且可靠。由于有很多人使用Pi，因此有许多资源旨在帮助即使是初学者也能得到帮助，而且有大量的论坛、维基、Stack
    Overflow和博客文章等，以帮助您了解每一个细节。
- en: Getting your kit in order
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整理您的套件
- en: 'The following sections provide two different options for setting up a Raspberry
    Pi 3 Model B-based system:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提供了两种不同的设置基于Raspberry Pi 3 Model B的系统选项：
- en: Traditional configuration—The traditional and more beginner-friendly way to
    configure a Raspberry Pi is to treat it like a desktop computer—plug in a USB
    mouse, a USB keyboard, and an HDMI display, and work at it directly.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统配置——配置Raspberry Pi的传统且更适合初学者的方式是将它视为台式计算机——插入USB鼠标、USB键盘和HDMI显示器，然后直接工作。
- en: Headless configuration—If you don’t want to devote that many peripherals to
    your Pi, you can opt to treat it more like an embedded system. If that notion
    appeals, the headless configuration section is for you!
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头配置——如果您不想为Pi配备那么多外围设备，您可以选择将其视为嵌入式系统。如果这个想法吸引您，那么无头配置部分就是为您准备的！
- en: 'For a first-time setup, Pi starter kits, available from all of the major online
    electronics retailers—are a great, if more costly, way to go (versus buying the
    Pi board and supporting components separately). Here are some things to look for
    in a kit:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初次设置，来自所有主要在线电子零售商的Pi入门套件——虽然成本更高，但是一个不错的选择（与单独购买Pi板及其支持组件相比）。以下是在套件中寻找的一些事项：
- en: A microSD card preflashed with NOOBs or Raspbian—Preferably also with an SD
    card adapter so that you can use a standard-sized card reader/writer to update
    the card’s contents
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预装NOOBs或Raspbian的microSD卡——最好还带有SD卡适配器，这样您就可以使用标准尺寸的卡读卡器/写卡器来更新卡的内容
- en: An enclosure (case)—This gives your Pi physical stability, protection, and,
    in some cases, a suave appearance.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外壳（机箱）——这为您的Pi提供了物理稳定性、保护，在某些情况下，还提供了优雅的外观。
- en: 'Power supply—The Pi’s power connection is USB micro, so you could alternatively
    use a 5 V USB device charger. Keep in mind, however, that the Pi’s current needs
    may not be met by all phone chargers: the Pi website recommends an adapter that
    can supply 2.5 A or more.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源供应——Pi的电源连接是USB微型，因此您可以使用5 V USB设备充电器作为替代。然而，请注意，并非所有手机充电器都能满足Pi的电流需求：Pi网站推荐一个可以提供2.5
    A或更多电流的适配器。
- en: Hardware to provide easier access to the Pi’s GPIO pins—These come in the form
    of the Adafruit Cobbler, the SparkFun Wedge, and other similar options ([figure
    11.4](#ch11fig04)).
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供更方便访问Pi的GPIO引脚的硬件——这些硬件以Adafruit Cobbler、SparkFun Wedge和其他类似选项的形式出现（[图11.4](#ch11fig04)）。
- en: Figure 11.4\. Constructed Raspberry Pi 3 Model B SparkFun kit with Pi Wedge,
    here shown connected to a breadboard. Also shown is an Adafruit T-Cobbler (right),
    which provides the same kind of functionality as the Wedge.
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.4\. 构建的Raspberry Pi 3 Model B SparkFun套件，带有Pi Wedge，此处显示连接到面包板。同时显示的是Adafruit
    T-Cobbler（右侧），它提供了与Wedge相同的功能。
- en: '![](11fig04_alt.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![11fig04_alt](11fig04_alt.jpg)'
- en: 'Kits may offer other useful goodies—the SparkFun one includes a USB microSD
    card reader, for example—but they have the downside of often including things
    you probably already have: breadboards, jumper wires, LEDs, and the like.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 套件可能提供其他有用的配件——例如SparkFun套件包括USB microSD卡读卡器——但它们有一个缺点，就是经常包括你可能已经拥有的东西：面包板、跳线、LED等。
- en: A Raspberry Pi 3 Model B board on its own is about $40, whereas full kits are
    about $90\. The current Pi 3 starter kits from Adafruit and SparkFun contain all
    the parts you need for this section.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 一块单独的Raspberry Pi 3 Model B主板大约是40美元，而完整的套件大约是90美元。Adafruit和SparkFun目前提供的Pi
    3入门套件包含本节所需的所有部件。
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Making GPIO connections on the Pi**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Pi上制作GPIO连接**'
- en: The pins on Pis are male—if you connect directly to them, you’ll need male-to-female
    jumper wires, and you may end up with a rat’s nest and frustration, because there
    isn’t silkscreened info on the Pi itself.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: Pi的引脚是公的——如果你直接连接到它们，你需要公对母的跳线，你可能会得到一团糟和挫败感，因为Pi本身没有丝印信息。
- en: 'There are third-party hardware components aimed at making the Pi’s GPIO easier
    to work with. SparkFun’s Pi Wedge and Adafruit’s T-Cobbler are two examples: these
    breakouts organize pins into more intuitive groupings (with silkscreened hints)
    and provide a breadboard-compatible form factor. Your Pi kit may come with them,
    or they can be purchased separately.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 有第三方硬件组件旨在使Pi的GPIO更容易使用。SparkFun的Pi Wedge和Adafruit的T-Cobbler是两个例子：这些分线将引脚组织成更直观的分组（带有丝印提示）并提供面包板兼容的形态。你的Pi套件可能包含它们，或者可以单独购买。
- en: '![](0339fig01_alt.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![0339fig01_alt](0339fig01_alt.jpg)'
- en: Assembled Adafruit T-Cobbler and SparkFun Pi Wedge (shown with connected 40-pin
    cable)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 组装好的Adafruit T-Cobbler和SparkFun Pi Wedge（带有连接的40引脚电缆）
- en: '|  |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**FTDI (Future Technology Devices International)**'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**FTDI（未来技术设备国际）**'
- en: FTDI makes chips that allow for asynchronous serial communication between embedded
    devices and computers. FTDI chips translate the TTL or RS-232 signals (RS-232
    is another asynchronous serial protocol) coming from a device into USB signals
    that a computer can understand, and vice versa. FTDI connections can be used to
    monitor serial output from a device. In some cases, they can also be used to program
    or control the device.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: FTDI制造芯片，允许嵌入式设备和计算机之间进行异步串行通信。FTDI芯片将来自设备的TTL或RS-232信号（RS-232是另一种异步串行协议）转换为计算机可以理解的USB信号，反之亦然。FTDI连接可以用来监控设备的串行输出。在某些情况下，它们也可以用来编程或控制设备。
- en: SparkFun’s Pi Wedge includes an FTDI interface. You also need a cable or a breakout
    board to connect to the FTDI pins (a SparkFun FTDI breakout board with mini-USB
    connector is visible connected to the Pi Wedge in [figure 11.4](#ch11fig04)).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: SparkFun的Pi Wedge包括一个FTDI接口。你还需要一根线或一个分线板来连接到FTDI引脚（一个带有迷你USB连接器的SparkFun FTDI分线板连接到Pi
    Wedge，如[图11.4](#ch11fig04)所示）。
- en: '|  |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要什么
- en: '![](note.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![note](note.jpg)'
- en: 'Steps follow for both a traditional, desktop-style Pi setup and a headless
    setup. You’ll want to choose only one of these options, but no matter which path
    you follow, you’ll need the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是关于传统桌面式Pi设置和无头设置的步骤。你只需要选择其中一种选项，但无论你选择哪条路径，你都需要以下内容：
- en: 1 Raspberry Pi 3 Model B
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1块Raspberry Pi 3 Model B
- en: 1 5 V USB micro power supply
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个5V USB微型电源
- en: 1 enclosure (optional but recommended)
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个外壳（可选但推荐）
- en: 1 Adafruit T-Cobbler, SparkFun Pi Wedge, or similar; or a set of male-to-female
    jumper wires
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Adafruit T-Cobbler、SparkFun Pi Wedge或类似产品；或者一套公对母跳线
- en: '|  |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '11.1.2\. Configuration option 1: the traditional way'
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. 配置选项1：传统方式
- en: '|  |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要什么
- en: '![](note.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![note](note.jpg)'
- en: 'In addition to the parts listed in the previous section, you’ll also need the
    following:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中列出的部件外，你还需要以下内容：
- en: 1 microSD card, preflashed with NOOBS or Raspbian OS (with desktop)
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1张预装了NOOBS或Raspbian OS（带桌面）的microSD卡
- en: 1 USB keyboard
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个USB键盘
- en: 1 USB mouse
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个USB鼠标
- en: 1 monitor
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个显示器
- en: 1 HDMI cable for the monitor
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 条 HDMI 电缆用于显示器
- en: '|  |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This configuration option involves plugging in peripherals and power and following
    on-screen instructions. Pop in a microSD card preflashed with NOOBS and power
    it up. NOOBS gives you the option of installing one of several OSs. Go ahead and
    select the first choice—Raspbian. The installation process takes a few minutes.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置选项涉及连接外围设备和电源，并遵循屏幕上的说明。插入预先闪存的 NOOBS microSD 卡并通电。NOOBS 给你安装几个操作系统的选择。请选择第一个选项——Raspbian。安装过程需要几分钟。
- en: 'Once the OS is installed and configured, you’ll be able to boot into the PIXEL
    (Pi Improved Xwindows Environment, Lightweight) environment. Setting up the WiFi
    is straightforward: start by clicking on the WiFi icon in the top-right menu bar
    ([figure 11.5](#ch11fig05)).'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装并配置了操作系统，你将能够启动到 PIXEL（Pi 改进的 Xwindows 环境，轻量级）环境。设置 WiFi 很简单：首先点击右上角菜单栏中的
    WiFi 图标（[图 11.5](#ch11fig05)）。
- en: Figure 11.5\. The PIXEL desktop. Note the WiFi icon at top right.
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.5\. PIXEL 桌面。注意右上角的 WiFi 图标。
- en: '![](11fig05_alt.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig05_alt.jpg)'
- en: If you want to be able to shell in to your Pi later, without having to work
    at the Pi directly, you need to enable SSH. To do this, use the Preferences >
    Raspberry Pi Configuration menu option. Navigate to the Interfaces tab and click
    the Enabled option next to SSH. Click OK to apply the change.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在以后能够登录到你的 Pi，而无需直接在 Pi 上工作，你需要启用 SSH。为此，请使用“首选项”>“Raspberry Pi 配置”菜单选项。导航到“接口”选项卡，并点击
    SSH 旁边的“启用”选项。点击“确定”以应用更改。
- en: That’s it for the moment! If you run into any difficulty whatsoever, head on
    over to the Raspberry Pi Software Guide ([http://mng.bz/P8Hu](http://mng.bz/P8Hu)),
    which is illustrated and user-friendly.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 目前就到这里！如果你遇到任何困难，请前往 Raspberry Pi 软件指南（[http://mng.bz/P8Hu](http://mng.bz/P8Hu)），它有插图且用户友好。
- en: '11.1.3\. Configuration option 2: headless'
  id: totrans-516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.3\. 配置选项 2：无头
- en: This more pared-down, straight-to-the-essentials approach obviates the need
    for peripherals and cables. On the flip side, it’s a less common approach, and
    it requires more time in a terminal. Raspbian is ever-evolving, but the following
    steps worked reliably as of mid-2017.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更精简、直接到核心的方法消除了对外围设备和电缆的需求。另一方面，这是一种不太常见的做法，它需要在终端中花费更多时间。Raspbian 是不断发展的，但以下步骤在
    2017 年中期能够可靠地工作。
- en: If you’ve already set up your Pi using the desktop approach, you can skip this
    set of steps. You can skip forward to section 11.8.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用桌面方法设置了 Pi，你可以跳过这一组步骤。你可以跳到 11.8 节。
- en: '|  |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要什么
- en: '![](note.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 'In addition to the parts listed at the end of [section 11.1](#ch11lev1sec1),
    you’ll need the following:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 [11.1 节](#ch11lev1sec1)末尾列出的部件外，你还需要以下部件：
- en: 1 microSD card
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 microSD 卡
- en: 1 SD card adapter
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 SD 卡适配器
- en: 1 SD card reader/writer (or a computer that has a built-in reader)
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 SD 卡读写器（或具有内置读卡器的计算机）
- en: 1 Ethernet cable
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 条以太网电缆
- en: '|  |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Because you’re going headless, you’ll need to configure the Pi so that you can
    communicate with it in some way, as you’ll lack a keyboard and monitor.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将无头运行，你需要配置 Pi，以便以某种方式与之通信，因为你将缺少键盘和显示器。
- en: First you’ll need to create a bootable SD card that will enable you to `ssh`
    to the Pi over a wired Ethernet connection. Then you’ll shell in and configure
    WiFi on the command line.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个可启动的 SD 卡，这样你就可以通过有线以太网连接到 Pi 进行 `ssh`。然后你将登录并使用命令行配置 WiFi。
- en: Creating a bootable Raspbian disk image
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建可启动的 Raspbian 磁盘镜像
- en: 'You’ll need to put an operating system on a microSD card so that the Pi can
    boot:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 microSD 卡上安装操作系统，这样 Pi 才能启动：
- en: Download Raspbian (not NOOBS) from the Raspbian download page ([www.raspberrypi.org/downloads/raspbian/](http://www.raspberrypi.org/downloads/raspbian/))
    ([figure 11.6](#ch11fig06)).
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Raspbian 下载页面（[www.raspberrypi.org/downloads/raspbian/](http://www.raspberrypi.org/downloads/raspbian/)）下载
    Raspbian（不是 NOOBS）（[图 11.6](#ch11fig06)）。
- en: Figure 11.6\. Download the full version of Raspbian from Raspberry Pi’s Raspbian
    download page.
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.6\. 从 Raspberry Pi 的 Raspbian 下载页面下载 Raspbian 的完整版本。
- en: '![](11fig06_alt.jpg)'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](11fig06_alt.jpg)'
- en: Once the large download is complete, unzip the resulting zip file. If things
    go right, you should end up with an IMG file (a bootable disk image).
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大型下载完成后，解压生成的 zip 文件。如果一切顺利，你应该会得到一个 IMG 文件（一个可启动的磁盘镜像）。
- en: '|  |'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|'
- en: Big, honking Raspbian zip file
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 大型的 Raspbian zip 文件
- en: As noted on the Raspbian download page ([figure 11.6](#ch11fig06)), the resulting
    zip file is big, and your default unzip utility may not be up to the task of unzipping
    it (mine wasn’t). As suggested there, try The Unarchiver for Mac or 7Zip for Windows
    if you run into problems.
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如Raspbian下载页面所示（[图11.6](#ch11fig06)），生成的zip文件很大，您默认的解压工具可能无法完成解压任务（我的就不行）。如页面建议，如果遇到问题，请尝试Mac上的The
    Unarchiver或Windows上的7Zip。
- en: '|  |'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|'
- en: 'Create a bootable microSD card:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建可引导的microSD卡：
- en: Install the free Etcher application ([https://etcher.io/](https://etcher.io/)),
    available for Windows, Mac, or Linux. This will allow you to take the Raspbian
    IMG file and burn it onto the microSD card.
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装免费的应用程序Etcher（[https://etcher.io/](https://etcher.io/)），适用于Windows、Mac或Linux。这将允许您将Raspbian
    IMG文件烧录到microSD卡上。
- en: Insert the microSD card into the SD card adapter, and then insert the whole
    kaboodle into your computer or SD card reader/writer.
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入SD卡适配器，然后将整个装置插入您的计算机或SD卡读卡器/写入器。
- en: Launch Etcher and follow the steps to put the IMG file on the microSD card ([figure
    11.7](#ch11fig07)).
  id: totrans-543
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Etcher并按照步骤将IMG文件放置到microSD卡上（[图11.7](#ch11fig07)）。
- en: 'Figure 11.7\. Etcher is a straightforward utility: select the disk image file,
    select the drive (it often auto-selects for you), and go.'
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.7\. Etcher是一个简单的实用程序：选择磁盘镜像文件，选择驱动器（它通常自动为您选择），然后开始。
- en: '![](11fig07_alt.jpg)'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片11fig07_alt](11fig07_alt.jpg)'
- en: 'Add a file to the microSD card to enable SSH:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向microSD卡添加文件以启用SSH：
- en: When Etcher is done—it takes several minutes to create the disk image—the microSD
    card will be soft-ejected (unmounted) from your computer. Unplug it, plug it back
    in, and open up the boot partition (this may be the only partition you can see).
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Etcher完成操作——创建磁盘镜像需要几分钟时间——microSD卡将从您的计算机中软弹出（卸载）。拔掉它，重新插上，然后打开引导分区（这可能是你能看到的唯一分区）。
- en: Create an empty file named “ssh”—no extension—and place it at the top level
    of boot. This will enable SSH on the Pi, which is otherwise disabled by default
    in Raspbian.
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“ssh”的空文件——没有扩展名——并将其放置在引导分区的顶层。这将启用Pi上的SSH，否则在Raspbian中默认是禁用的。
- en: 'Install the OS:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装操作系统：
- en: Eject the SD card adapter from your computer, remove the microSD card from the
    adapter, and insert the microSD card into the Pi 3.
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的计算机中弹出SD卡适配器，从适配器中取出microSD卡，并将其插入Pi 3。
- en: Boot the Pi.
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导Pi。
- en: 'Establish communication with your Pi over Ethernet:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以太网与您的Pi建立通信：
- en: Connect the Pi 3’s Ethernet interface directly to your wireless router with
    an Ethernet cable.
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以太网线将Pi 3的以太网接口直接连接到您的无线路由器。
- en: Find your Pi’s IP address. Your Pi 3 should automatically get assigned an IP
    address (via DHCP), but you’ll need to figure out what that IP address is. There
    are many ways to skin this cat. Google “IP scanner” or “LAN scanner” and you’ll
    find a plethora of free utilities for various platforms, or you can use a command-line
    tool. I use LanScan for the Mac ([figure 11.8](#ch11fig08)). The idea is to determine
    what IP was assigned to your Pi.
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找您的Pi的IP地址。您的Pi 3应该会自动分配一个IP地址（通过DHCP），但您需要找出这个IP地址是什么。有很多种方法可以做到这一点。在Google上搜索“IP扫描器”或“LAN扫描器”，您将找到各种平台上的大量免费工具，或者您可以使用命令行工具。我使用Mac上的LanScan（[图11.8](#ch11fig08)）。目的是确定分配给您的Pi的IP地址。
- en: Figure 11.8\. Using LanScan for Mac, I can see that the Raspberry Pi’s Ethernet
    interface was assigned the IP address 192.168.1.13.
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.8\. 使用LanScan for Mac，我可以看到Raspberry Pi的以太网接口被分配了IP地址192.168.1.13。
- en: '![](11fig08_alt.jpg)'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片11fig08_alt](11fig08_alt.jpg)'
- en: 'Once you’ve obtained the Pi’s IP address, open a terminal and enter this command:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您获得了Pi的IP地址，打开终端并输入以下命令：
- en: '[PRE15]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|  |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Default Pi username and password
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认Pi用户名和密码
- en: The default username on Raspberry Pi is `pi` and the password is `raspberry`.
    It’s a good idea to change the password for the `pi` user. You can do this (when
    logged in as the `pi` user) by typing `passwd` at the command prompt and following
    the onscreen instructions. Do it. Do it now.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi的默认用户名是`pi`，密码是`raspberry`。更改`pi`用户的密码是个好主意。您可以通过在命令提示符下输入`passwd`并遵循屏幕上的说明来完成此操作。现在就做。
- en: '|  |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Configuring WiFi on the Pi
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在Pi上配置WiFi
- en: 'The last step is to get WiFi configured for your Pi so you don’t have to use
    a wired Ethernet connection. This involves messing with the Pi’s `wpa_supplicant`
    setup. Sometimes this can be finicky and frustrating if you try to edit the configuration
    file directly. I’ve found that the most failsafe way is to use the wpa_cli command-line
    utility:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是为你的树莓派配置WiFi，这样你就不必使用有线以太网连接。这涉及到对树莓派的`wpa_supplicant`设置进行操作。有时如果你直接编辑配置文件，可能会很棘手和令人沮丧。我发现最安全的方法是使用wpa_cli命令行工具：
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Raspberry Pi 3’s WiFi support
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 树莓派3的WiFi支持
- en: The Pi 3, like the Tessel 2, doesn’t support 5 GHz WiFi networks.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派3，就像Tessel 2一样，不支持5 GHz WiFi网络。
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: SSH into your Pi if you haven’t already.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有，请通过SSH连接到你的树莓派。
- en: 'Start an interactive wpa_cli session by entering this command:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令启动一个交互式的wpa_cli会话：
- en: '[PRE16]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will put you in an interactive mode. You can type subsequent commands at
    the `>` prompt.
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使你进入交互模式。你可以在`>`提示符下输入后续命令。
- en: 'Scan for available wireless networks to make sure your Pi can see the desired
    WiFi network. To do so, type this:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描可用的无线网络，以确保你的树莓派可以看到所需的WiFi网络。要这样做，输入以下内容：
- en: '[PRE17]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then this, to see the results of the scan:'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后输入以下内容，以查看扫描结果：
- en: '[PRE18]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Does your network show up? If not, check your router’s settings and make sure
    it’s a compatible WiFi network (not 5 GHz). If it does, yay! Carry on.
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的网络显示了吗？如果没有，检查你的路由器设置，确保它是一个兼容的WiFi网络（不是5 GHz）。如果是，太好了！继续。
- en: 'Execute each of the following commands to add, configure, and enable the desired
    WiFi network connection in the Pi’s `wpa_supplicant` config:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下每个命令以在树莓派的`wpa_supplicant`配置中添加、配置和启用所需的WiFi网络连接：
- en: '[PRE19]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Press Ctrl-C to exit the wpa_cli.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按Ctrl-C退出wpa_cli。
- en: 'To verify that it worked, type this:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证它是否成功，输入以下内容：
- en: '[PRE20]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If it’s all good, you should see an assigned IP address ([figure 11.9](#ch11fig09)).
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会看到一个分配的IP地址（[图11.9](#ch11fig09)）。
- en: Figure 11.9\. After configuring WiFi, the Pi now has two IP addresses—one for
    the Ethernet interface and one for its WLAN (WiFi) interface.
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.9. 配置WiFi后，树莓派现在有两个IP地址——一个用于以太网接口，一个用于其WLAN（WiFi）接口。
- en: '![](11fig09_alt.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![11fig09_alt.jpg](11fig09_alt.jpg)'
- en: You can unplug the Ethernet connection if you like. The Pi will now automatically
    connect to the WiFi network configured here every time it boots up. Handy!
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，可以拔掉以太网连接。树莓派现在将自动连接到在此配置的WiFi网络，每次启动时都会连接。方便！
- en: '|  |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you need a do-over
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如果你需要重新开始
- en: 'It’s not too hard to start over if your Pi is misbehaving or you feel confused
    or stuck. Power the Pi down, eject the microSD, and reflash it with the desired
    OS: NOOBS for a user-friendly, visual setup; Raspbian; or any other compatible
    OS of your choice. Booting from that updated SD card will give you a clean slate.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的树莓派运行不正常，或者你感到困惑或卡壳，重新开始并不太难。关闭树莓派电源，弹出microSD卡，然后用你想要的操作系统重新刷机：NOOBS提供用户友好的可视化设置；Raspbian；或者任何其他你选择的兼容操作系统。从更新后的SD卡启动将给你一个全新的开始。
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.2\. Learning about the Raspberry Pi 3
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2. 学习关于树莓派3
- en: Now that you’ve a configured Pi with WiFi connectivity, let’s apply the platform-learning
    steps first outlined in [chapter 10](kindle_split_020.html#ch10) to get a better
    understanding of the Raspberry Pi 3 platform overall.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了具有WiFi连接的树莓派，让我们首先应用第10章中概述的平台学习步骤，以更好地了解树莓派3平台的整体情况。
- en: 11.2.1\. Core features
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1. 核心功能
- en: SBCs really up the ante for processing power, commensurate with their additional
    bells and whistles. Microcontrollers from ARM’s 32-bit Cortex M family are at
    the heart of a slew of platforms that can run embedded JavaScript. With full-blown
    SBCs, you’ll be taking another step up in processor oomph. These 32- and 64-bit
    processors often sport multiple cores, 3D graphics acceleration, higher clock
    speeds, and complex subsystems.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 单板计算机（SBCs）在处理能力上大大提升，与它们额外的功能相匹配。ARM 32位Cortex M系列的微控制器是许多可以运行嵌入式JavaScript的平台的核心。使用完整的单板计算机，你将进一步提高处理器的性能。这些32位和64位处理器通常具有多个核心、3D图形加速、更高的时钟速度和复杂的子系统。
- en: The Pi 3 boasts a quad-core, 64-bit ARM (A8) CPU running at 1.2 GHz. That’s
    a far cry from the Uno’s 8-bit ATmega at 20 MHz (at the risk of comparing apples
    to oranges). Other specs noted on the product information page ([figure 11.10](#ch11fig10))
    include 1 GB of RAM, onboard WiFi and Bluetooth, 4 USB ports, video and stereo
    outputs, HDMI interface, and more ([www.raspberrypi.org/products/raspberry-pi-3-model-b/](http://www.raspberrypi.org/products/raspberry-pi-3-model-b/)).
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派3配备了四核64位ARM（A8）CPU，运行频率为1.2 GHz。这与Arduino的20 MHz 8位ATmega相比相去甚远（尽管这种比较可能不太恰当）。产品信息页上还列出了其他规格，包括1
    GB的RAM、板载WiFi和蓝牙、4个USB端口、视频和立体声音频输出、HDMI接口等（[图11.10](#ch11fig10)）。更多信息请访问[树莓派3型号B产品页面](http://www.raspberrypi.org/products/raspberry-pi-3-model-b/)。
- en: Figure 11.10\. Highlights of the Raspberry Pi 3 Model B specs on the Raspberry
    Pi website
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.10\. 树莓派网站上的树莓派3型号B规格亮点
- en: '![](11fig10_alt.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig10_alt.jpg)'
- en: GPIO-wise, it’s a mixed bag. There are multiple SPI and I²C interfaces, and
    lots of pins overall. As mentioned earlier, there’s no ADC support, and PWM is
    limited. Add-on accessories and certain peripherals may require connections to
    some of the pins, meaning you might not have I/O access to all of the 40 pins,
    depending on your configuration.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPIO方面，情况比较复杂。有多个SPI和I²C接口，引脚总数也很多。如前所述，没有ADC支持，PWM也有限制。附加配件和某些外围设备可能需要连接到一些引脚上，这意味着根据你的配置，你可能无法访问所有40个引脚的I/O。
- en: 'Because of the Pi 3’s general-purpose market, the core feature list on its
    product page doesn’t mention that its GPIO logic level voltage is 3.3 V, but you
    should know that: the Raspberry Pi 3 is a 3.3 V device.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 由于树莓派3面向通用市场，其产品页面上的核心功能列表没有提到其GPIO逻辑电平电压为3.3 V，但你应该知道：树莓派3是一个3.3 V的设备。
- en: '|  |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Seriously, the Pi is a 3.3 V device
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 严肃地说，树莓派是一个3.3 V的设备
- en: Don’t apply 5 V power to any of the Pi’s pins or you might find yourself with
    a dead Pi.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将5 V电源连接到树莓派的任何引脚上，否则你可能会发现你的树莓派已经无法使用了。
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.2.2\. GPIO features and pinouts
  id: totrans-604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2\. GPIO功能与引脚配置
- en: Pi pinouts are complicated. For starters, there are a lot of pins (40), many
    different pin numbering and naming schemes, and a given pin may already be monopolized
    by a component, process, or peripheral. Groups of related connections, such as
    SPI or I²C pins, aren’t necessarily physically adjacent to each other, either.
    The pinout.xyz website is a good resource for the nitty-gritty details on Pi pinouts.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派的引脚配置很复杂。首先，引脚数量很多（40个），有许多不同的引脚编号和命名方案，而且某个引脚可能已经被某个组件、过程或外围设备占用。例如，SPI或I²C引脚这样的相关连接组并不一定在物理上是相邻的。pinout.xyz网站是了解树莓派引脚细节的好资源。
- en: As an example of the many faces of a single Raspberry Pi GPIO pin, physical
    pin 33 ([figure 11.11](#ch11fig11)) is alternately known as BCM 13 (Broadcom pin
    number), by its primary functional name of PWM1 (it’s one of the PWM-capable pins),
    and as WiringPi pin 23\. It also has several functionally named aliases, such
    as `AVEOUT VID 9`. And will it even be available for GPIO use? It won’t be if
    you have a parallel external display connected to the Pi—it’s one of the pins
    needed for that. And it might not be if you want to use a JTAG debugging interface
    or SMI (Secondary Memory Interface) device; it’s one of the pins used in those
    kinds of connections too.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 以单个树莓派GPIO引脚的多种面貌为例，物理引脚33（[图11.11](#ch11fig11)）也被称为BCM 13（博通引脚编号），其主要功能名称为PWM1（它是具有PWM功能的引脚之一），以及WiringPi引脚23。它还有几个功能性的别名，如`AVEOUT
    VID 9`。而且，它甚至可能用于GPIO？如果你将并行外部显示器连接到树莓派上，它就是那些引脚之一。如果你想要使用JTAG调试接口或SMI（二级存储接口）设备，它也可能是那些连接中使用的引脚之一。
- en: Figure 11.11\. pinout.xyz is a website entirely devoted to Raspberry Pi pinout
    information. This detail from pinout.xyz shows the many aliases of physical pin
    33.
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.11\. pinout.xyz是一个专门提供树莓派引脚信息网站。这个来自pinout.xyz的细节显示了物理引脚33的多个别名。
- en: '![](11fig11_alt.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig11_alt.jpg)'
- en: '|  |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**SBCs and platform-specific hardware terminology**'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**SBC和平台特定硬件术语**'
- en: It seems like each SBC platform adds more jargon terms to the IoT vocabulary.
    Just as Arduino-compatible expansion boards are called *shields*, boards that
    fit on the Raspberry Pi are typically called *hats*, and those that mesh with
    the BeagleBone Black are called *capes*.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来每个SBC平台都在物联网词汇中添加了更多的术语。就像Arduino兼容的扩展板被称为*盾牌*一样，适合树莓派的板通常被称为*帽子*，而与BeagleBone
    Black兼容的板则被称为*披风*。
- en: '|  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.2.3\. Configuration and workflow
  id: totrans-613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.3\. 配置和工作流程
- en: The possibilities of what you can do and how you can do it are virtually unbounded
    on the Pi platform—it’s a full-fledged computer, after all. Let’s narrow that
    a bit by concentrating on config and workflow options for a Node.js-centric electronics-hacking
    setup.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pi 平台上，你可以做的和如何做几乎是没有边界的——毕竟，它是一个完整的计算机。让我们集中精力，关注以 Node.js 为中心的电子黑客配置的配置和工作流程选项。
- en: 'At this point you should have a working Pi—whether it’s set up as a standalone
    computer or a headless device. You have three more steps to take to get the configuration
    and workflow solid:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，你应该有一个正在工作的 Pi——无论是作为独立计算机还是无头设备。为了使配置和工作流程更加稳定，你还需要完成以下三个步骤：
- en: Make sure the Pi’s software is up to date.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Pi的软件是最新的。
- en: Get a tolerably recent version of Node.js installed on the Pi.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Pi 上安装一个可接受的 Node.js 版本。
- en: Figure out a way to author code and get it onto the Pi’s filesystem.
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出一种方法来编写代码并将其上传到 Pi 的文件系统。
- en: Updating the Pi’s software
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新Pi的软件
- en: 'Make sure the Pi has the latest software updates:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Pi拥有最新的软件更新：
- en: '`ssh` into the Pi (headless) or use a terminal (desktop). Make sure the Pi
    is connected to the internet.'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `ssh` 连接到 Pi（无头）或使用终端（桌面）。确保 Pi 已连接到互联网。
- en: 'Run the following command:'
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE21]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This may take a few minutes to complete.
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能需要几分钟才能完成。
- en: 'Run this command:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE22]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This also may take several minutes to do its job.
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能需要几分钟才能完成其任务。
- en: Upgrading Node.js on the Pi
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 升级 Pi 上的 Node.js
- en: 'Still logged in to the Pi or in a terminal window, try running this command:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然登录到 Pi 或终端窗口中，尝试运行以下命令：
- en: '[PRE23]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will output the current version of Node.js on the Pi. At time of writing,
    the preinstalled Node.js version was `v0.10.29`, which is archaic. Bring that
    up to LTS (Long-Term Support), so we don’t run into compatibility or security
    issues in your projects:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 Pi 上当前的 Node.js 版本。在撰写本文时，预安装的 Node.js 版本是 `v0.10.29`，这已经过时了。将其升级到 LTS（长期支持），这样我们就不需要在项目中遇到兼容性或安全问题：
- en: 'If you haven’t just run a full system update (as shown in the previous section),
    first run this command:'
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有运行完整的系统更新（如前文所示），首先运行以下命令：
- en: '[PRE24]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Download and run a Node.js setup script for the target version by executing
    this command:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令下载并运行目标版本的 Node.js 设置脚本：
- en: '[PRE25]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At time of writing, LTS was v6.x. This will have changed by the time you read
    this, so you’re welcome to replace the `setup_6.x` portion of the URL with the
    appropriate major version number. See the NodeSource Binary Distributions repository
    for more info ([https://github.com/nodesource/distributions](https://github.com/nodesource/distributions)).
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在撰写本文时，LTS 版本是 v6.x。在你阅读本文时，这可能已经发生了变化，因此你可以将 URL 中的 `setup_6.x` 部分替换为适当的重大版本号。更多信息请参阅
    NodeSource 二进制分发仓库 ([https://github.com/nodesource/distributions](https://github.com/nodesource/distributions))。
- en: 'Install Node.js:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Node.js：
- en: '[PRE26]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Verify that it worked by running this command:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令验证是否成功：
- en: '[PRE27]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Managing files on the Pi
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 管理 Pi 上的文件
- en: 'The JavaScript files and resources for your Pi projects will be executed on
    the Pi and need to exist on the Pi’s filesystem. There are, unsurprisingly, an
    awful lot of ways to get your files on the Pi. Here are some options:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Pi 项目中的 JavaScript 文件和资源将在 Pi 上执行，并需要在 Pi 的文件系统中存在。不出所料，有无数种方法可以将你的文件上传到
    Pi。以下是一些选项：
- en: Author the files on the Pi itself. You can use a terminal-based editor, such
    as `vi` or `nano`. Or, if you have a desktop setup for your Pi, you can use a
    GUI editor like the preinstalled Leafpad application. Or you can install any number
    of additional text-editing applications.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pi 本身上编写文件。你可以使用基于终端的编辑器，如 `vi` 或 `nano`。或者，如果你为 Pi 配置了桌面环境，你可以使用预安装的 Leafpad
    应用程序等 GUI 编辑器。或者，你可以安装任何数量的附加文本编辑应用程序。
- en: Use a utility to copy files from your computer to the Pi. You could use the
    Unix command-line tool scp (secure copy) to move files, or a GUI application that
    supports it, for example.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实用程序将文件从你的计算机复制到 Pi。你可以使用 Unix 命令行工具 scp（安全复制）来移动文件，或者使用支持它的 GUI 应用程序，例如。
- en: Set up a file server on the Pi so you can access it as a remote share from other
    computers on your network. One of the many possible methods for doing this is
    to use a Samba (SMB) server.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pi 上设置一个文件服务器，以便你可以从网络上的其他计算机作为远程共享访问它。实现这一目标的一种可能方法就是使用 Samba (SMB) 服务器。
- en: '|  |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Configuring a Samba (SMB) server on the Pi**'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 Pi 上配置 Samba (SMB) 服务器**'
- en: 'One way to make your Pi’s files easy to get at is to set up a file server on
    the Pi itself. The following steps set up a Samba (SMB) share called `projects`
    that can be read-write accessed by the `pi` user. Once configured, this share
    should show up in your system’s Finder or File Explorer as a networked drive.
    Note that these instructions assume a general familiarity with the Linux command
    line:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的Pi文件易于访问的一种方法是在Pi上设置一个文件服务器。以下步骤设置了一个名为`projects`的Samba（SMB）共享，该共享可以被`pi`用户读写访问。一旦配置完成，这个共享应该会出现在你的系统Finder或文件资源管理器中，作为一个网络驱动器。请注意，这些说明假设你对Linux命令行有一定的了解：
- en: '`ssh` into the Pi as the `pi` user (headless) or use a terminal application
    (desktop).'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`pi`用户（无头）的身份使用`ssh`连接到Pi，或使用终端应用程序（桌面）。
- en: 'Make sure you’re in the `pi` user’s home directory by typing this command:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你处于`pi`用户的家目录，通过输入以下命令：
- en: '[PRE28]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see the following output:'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE29]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a directory to keep project files in:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录来保存项目文件：
- en: '[PRE30]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Install Samba:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Samba：
- en: '[PRE31]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Set up a Samba password for the `pi` user by entering the following command
    and following the prompts:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令并按照提示操作，为`pi`用户设置Samba密码：
- en: '[PRE32]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Samba doesn’t use system passwords; it maintains its own.
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Samba不使用系统密码；它维护自己的密码。
- en: 'Edit the Samba configuration file. First make a backup to your home directory,
    just in case:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑Samba配置文件。首先备份到你的家目录，以防万一：
- en: '[PRE33]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now edit the configuration:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑配置：
- en: '[PRE34]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '(You can use a different editor, such as `nano`, if you prefer, in place of
    `vi`.) Scroll down to the very bottom of the file and add these lines, including
    the spaces around the `=` characters:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （如果你更喜欢`nano`而不是`vi`，可以使用不同的编辑器。）滚动到文件的底部并添加以下行，包括`=`字符周围的空格：
- en: '[PRE35]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save the file and exit.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并退出。
- en: 'Restart the Samba service:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Samba服务：
- en: '[PRE36]'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check your config if you like:'
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果喜欢，检查你的配置：
- en: '[PRE37]'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should now be able to connect to the SMB share from other computers on
    the same network (using Map Network Drive in Windows File Explorer or Connect
    to Server or Cmd-K on a Mac). The connection string takes this form:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够从同一网络上的其他计算机连接到SMB共享（在Windows文件资源管理器中使用映射网络驱动器或在Mac上使用连接到服务器或Cmd-K）。连接字符串采用以下形式：
- en: '[PRE38]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should end up with something like this:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终应该得到类似以下内容：
- en: '[PRE39]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Samba shares can be imperfect at times, and it’s possible you may need to adjust
    permissions or user metadata to make it work just right. There are tons of user
    forums and help articles on the web if you need support.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: Samba共享有时可能不完美，你可能需要调整权限或用户元数据才能使其正常工作。如果你需要支持，网上有大量的用户论坛和帮助文章。
- en: '|  |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Create a “projects” area
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个“项目”区域
- en: Creating a directory called “projects” inside of the pi user’s home directory
    is one of the steps in the sidebar on configuring a Samba server. Even if you
    don’t set up a share on the Pi, go ahead and create a directory to corral your
    upcoming code experiments. The rest of the chapter will assume the existence of
    a `~/projects` directory (a directory called “projects” inside your home directory).
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置Samba服务器时，在侧边栏中创建名为“projects”的目录是步骤之一。即使你不在Pi上设置共享，也请创建一个目录来整理你即将进行的代码实验。本章的其余部分将假设存在一个`~/projects`目录（家目录内的“projects”目录）。
- en: '|  |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.2.4\. Examples and tutorials
  id: totrans-682
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.4. 示例和教程
- en: There’s no one way to blink an LED on a Raspberry Pi—the options are almost
    countless. You’ll try a few ways here, emphasizing JavaScript options.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在Raspberry Pi上闪烁LED没有一种唯一的方法——选项几乎数不胜数。在这里，你将尝试几种方法，强调JavaScript选项。
- en: '|  |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要的东西
- en: '![](note.jpg)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: '![note.jpg](note.jpg)'
- en: 1 configured Raspberry Pi 3
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个配置好的Raspberry Pi 3
- en: 1 SparkFun Pi Wedge, Adafruit T-Cobbler, or similar; or male-to-female jumper
    wires
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个SparkFun Pi Wedge，Adafruit T-Cobbler或类似产品；或公对母跳线
- en: 1 standard LED, any color
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个标准LED，任何颜色
- en: 1 100 V resistor
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个100V电阻
- en: 1 breadboard
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个面包板
- en: Jumper wires
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '|  |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The right way to `sudo`**'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确使用`sudo`的方式**'
- en: Because of the conservative permissions for interacting with GPIO in Raspbian,
    you’ll likely need to execute the following code examples using `sudo`. For example,
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Raspbian中与GPIO交互的权限较为保守，你可能需要使用`sudo`执行以下代码示例。例如，
- en: '[PRE40]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: or
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE41]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Without `sudo`, you may get permissions errors like these:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`sudo`，你可能得到如下权限错误：
- en: '[PRE42]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Try to only use `sudo` with commands that require it, such as when executing
    these scripts. Don’t use `sudo` to install npm modules or create files, or the
    like. You might end up creating things with wonky permissions if you do that.
    When in doubt, try to do something first without `sudo` and see if it works.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试只使用 `sudo` 来执行需要它的命令，例如执行这些脚本时。不要使用 `sudo` 来安装 npm 模块或创建文件等。如果你这样做，可能会创建具有奇怪权限的东西。如果有疑问，先尝试在不使用
    `sudo` 的情况下执行一些操作，看看是否可行。
- en: '|  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Building an LED circuit
  id: totrans-704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建 LED 电路
- en: 'Each of the following examples uses the same physical circuit configuration:
    the LED’s anode should be connected to the Pi’s physical pin 7 (WiringPi pin 7,
    BCM pin 4). The cathode should be connected to a GND pin.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 以下每个示例都使用相同的物理电路配置：LED 的阳极应连接到 Pi 的物理引脚 7（WiringPi 引脚 7，BCM 引脚 4）。阴极应连接到 GND
    引脚。
- en: Wiring diagrams are shown for direct-to-Pi connections ([figure 11.12](#ch11fig12)),
    Adafruit’s T-Cobbler ([figure 11.13](#ch11fig13)), and SparkFun’s Pi Wedge ([figure
    11.14](#ch11fig14)).
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 接线图显示了直接连接到 Pi 的连接（[图 11.12](#ch11fig12)）、Adafruit 的 T-Cobbler（[图 11.13](#ch11fig13)）和
    SparkFun 的 Pi Wedge（[图 11.14](#ch11fig14)）。
- en: Figure 11.12\. Wiring diagram for connecting the LED directly to the Pi’s pins,
    using male-to-female jumper wires
  id: totrans-707
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.12\. 使用公对母跳线直接连接 LED 到 Pi 引脚的接线图
- en: '![](11fig12_alt.jpg)'
  id: totrans-708
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig12_alt.jpg)'
- en: Figure 11.13\. Wiring diagram, using Adafruit’s T-Cobbler
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.13\. 使用 Adafruit 的 T-Cobbler 的接线图
- en: '![](11fig13.jpg)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig13.jpg)'
- en: Figure 11.14\. Wiring diagram, using SparkFun’s Pi Wedge
  id: totrans-711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.14\. 使用 SparkFun 的 Pi Wedge 的接线图
- en: '![](11fig14_alt.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig14_alt.jpg)'
- en: Blinking an LED with sysfs
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 sysfs 闪烁 LED
- en: '*Sysfs* is a Linux pseudo-filesystem that organizes the configuration of attached
    devices and systems into a filesystem hierarchy. Each entity exported by sysfs
    into the user space is represented by a directory. Sysfs mounts at /sys, and from
    within /sys/class/gpio it’s possible to control the Pi’s GPIO pins.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sysfs* 是一个 Linux 伪文件系统，它将连接的设备和系统的配置组织成文件系统层次结构。sysfs 导出到用户空间中的每个实体都由一个目录表示。Sysfs
    挂载在 /sys 上，并且从 /sys/class/gpio 中可以控制 Pi 的 GPIO 引脚。'
- en: 'For each pin you want to use, you need to do the following:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你想要使用的每个引脚，你需要执行以下操作：
- en: Export the pin. This is done by writing the pin number to the file at /sys/class/
    gpio/export using the BCM number scheme. This will create a directory for the
    pin (`<pin_directory>`).
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出引脚。这是通过将引脚号写入 /sys/class/gpio/export 文件并使用 BCM 编号方案来完成的。这将创建一个用于引脚的目录（`<pin_directory>`）。
- en: Configure the pin, such as by writing the value `'in'` or `'out'` to /sys/class/
    gpio/<pin_directory>/direction.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置引脚，例如通过将值 `'in'` 或 `'out'` 写入 /sys/class/gpio/<pin_directory>/direction。
- en: Interact with the pin, such as by reading from the /sys/class/gpio/<pin_directory>/value
    file or writing a value to it.
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与引脚交互，例如通过从 /sys/class/gpio/<pin_directory>/value 文件中读取或向其写入值。
- en: Clean up. Unexport the pin by writing the pin number to the file at /sys/class/
    gpio/unexport.
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理。通过将引脚号写入 /sys/class/gpio/unexport 文件来取消导出引脚。
- en: This is likely easier to understand by example. Blinking an LED connected to
    physical pin 7, BCM GPIO 4, a single time—turning it on then off again—can be
    accomplished by using a shell script, as shown in the following listing.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例可能更容易理解。闪烁连接到物理引脚 7、BCM GPIO 4 的 LED 一次——打开然后再次关闭——可以通过使用 shell 脚本来实现，如下面的列表所示。
- en: To try out sysfs, create a “blink-sysfs” directory inside your ~/projects directory.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 sysfs，在你的 ~/projects 目录内创建一个“blink-sysfs”目录。
- en: Listing 11.1\. A bash script to blink an attached LED once
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.1\. 一个用于闪烁连接的 LED 一次的 bash 脚本
- en: '[PRE43]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To run the blink.sh script, you need to make the file executable. You should
    be able to do that by running this command inside the ~/projects/blink-sysfs directory:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 blink.sh 脚本，你需要使文件可执行。你可以在 ~/projects/blink-sysfs 目录内运行以下命令来完成：
- en: '[PRE44]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now try it out by typing the following:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过输入以下内容来尝试：
- en: '[PRE45]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Blinking an LED with sysfs and Node.js
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 sysfs 和 Node.js 闪烁 LED
- en: At the end of the day, these are just filesystem actions, so you can also do
    this with Node.js using the built-in `fs` module, as shown in the next listing.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这些只是文件系统操作，因此你也可以使用 Node.js 的内置 `fs` 模块来完成，如下一个列表所示。
- en: Listing 11.2\. Blinking an LED with sysfs and Node.js
  id: totrans-730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.2\. 使用 sysfs 和 Node.js 闪烁 LED
- en: '[PRE46]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Note that the pin number and all written values in this example are strings.**'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意，在这个例子中，引脚号和所有写入的值都是字符串。**'
- en: 'Try it out by using this command:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令尝试：
- en: '[PRE47]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|  |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Don’t forget to unexport**'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**别忘了取消导出**'
- en: 'You really do need to `unexport` objects in the gpio directory when you’re
    done or it’ll be problematic for you next time you want to use that pin. If you
    see an error like this when trying to run the Node.js blinking script, it’s likely
    the pin didn’t get unexported correctly:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，真的需要在 gpio 目录中 `unexport` 对象，否则下次你想使用该引脚时可能会遇到问题。当你尝试运行 Node.js 闪烁脚本时，如果看到类似这样的错误，很可能是因为引脚没有被正确地取消导出：
- en: '[PRE48]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can execute the following command in a terminal to clean up manually:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在终端中执行以下命令来手动清理：
- en: '[PRE49]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You could fill an encyclopedic tome with all of the things you can do with `sysfs`,
    but let’s move on. It’s good to know about `sysfs`, but working with it directly
    requires patience and involves a learning curve.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一本百科全书来填满所有你可以用 `sysfs` 做的事情，但让我们继续前进。了解 `sysfs` 是好的，但直接与之工作需要耐心，并且涉及一个学习曲线。
- en: WiringPi
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: WiringPi
- en: 'WiringPi is an abstracting wrapper that attempts to make pin numbering more
    sane, and it exposes an API that’s more familiarly Arduino-style. It’s written
    in C, but Ruby and Python libraries for it are popular. There’s an npm package
    that provides Node.js bindings: `wiring-pi`.'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: WiringPi 是一个抽象包装器，试图使引脚编号更合理，并且它暴露了一个更熟悉的 Arduino 风格的 API。它是用 C 编写的，但 Ruby 和
    Python 库很受欢迎。有一个 npm 包提供了 Node.js 绑定：`wiring-pi`。
- en: 'If you want to try this out, create a directory in your ~/projects area named
    blink-wiring-pi. Inside of that directory, run this command:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试一下，在你的 ~/projects 区域创建一个名为 blink-wiring-pi 的目录。在该目录内，运行以下命令：
- en: '[PRE50]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then create an index.js file with the contents shown in the following listing.
    In this script, the `status` value toggles between `0` and `1`, turning the LED
    off and on, respectively.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个名为 index.js 的文件，其内容如下所示。在这个脚本中，`status` 值在 `0` 和 `1` 之间切换，分别用于关闭和打开 LED。
- en: Listing 11.3\. index.js
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. index.js
- en: '[PRE51]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Same physical pin as before, but using WiringPi numbers, which are actually
    JavaScript Numbers (not Strings)**'
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 与之前相同的物理引脚，但使用 WiringPi 编号，实际上它们是 JavaScript 数字（不是字符串）**'
- en: '***2* Note status is a Number (0 or 1), not Boolean as before.**'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注意状态是一个数字（0 或 1），而不是之前的布尔值。**'
- en: '***3* pinMode() and the OUTPUT constant echo the Arduino Language API.**'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* pinMode() 和 OUTPUT 常量与 Arduino 语言 API 相呼应。**'
- en: '***4* status here is either 1 (HIGH) or 0 (LOW).**'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这里的状态值要么是 1（高）要么是 0（低）。**'
- en: '***5* Inverts the Boolean equivalent of status and makes it a Number again
    (+ operator)**'
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 取反状态值的布尔等效值并将其再次转换为数字（+ 操作符）**'
- en: 'To run the script, use this command:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，使用以下命令：
- en: '[PRE52]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Johnny-Five with the raspi-io I/O plugin
  id: totrans-757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Johnny-Five 与 raspi-io I/O 插件
- en: To round out the blinking extravaganza, we’ll return to our old friend Johnny-Five.
    Just as the `tessel-io` Johnny-Five I/O plugin makes it possible to use Johnny-Five
    with the Tessel, the npm package `raspi-io` allows you to use J5 on the Raspberry
    Pi.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成闪烁的盛宴，我们将回到我们的老朋友 Johnny-Five。就像 `tessel-io` Johnny-Five I/O 插件使得使用 Johnny-Five
    与 Tessel 成为可能一样，npm 包 `raspi-io` 允许你在 Raspberry Pi 上使用 J5。
- en: Go ahead and create one more directory in the ~/projects directory called blink-j5.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ~/projects 目录中创建一个名为 blink-j5 的目录。
- en: 'Inside of the blink-j5 directory, run this command to install the Johnny-Five
    and `raspi-io` packages:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在 blink-j5 目录内，运行以下命令来安装 Johnny-Five 和 `raspi-io` 包：
- en: '[PRE53]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For your next trick, you’ll take one of the very first LED scripts you ever
    tried—from way back in [chapter 2](kindle_split_009.html#ch02)—and adapt it to
    work on the Pi, as shown in the following listing. The only changes required are
    including and using the `raspi-io` plugin to provide I/O, and changing the pin
    number for the LED. That’s it!
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的下一个技巧，你将使用你尝试过的第一个 LED 脚本之一——从很久以前的 [第 2 章](kindle_split_009.html#ch02)——并将其修改为在
    Pi 上工作，如下所示。所需更改仅包括和使用 `raspi-io` 插件来提供 I/O，以及更改 LED 的引脚编号。就是这样！
- en: Listing 11.4\. Blinking the LED with Johnny-Five
  id: totrans-763
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. 使用 Johnny-Five 闪烁 LED
- en: '[PRE54]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Requires the raspi-io I/O plugin module**'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要raspi-io I/O 插件模块**'
- en: '***2* Uses a Raspi object for io**'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 Raspi 对象进行 io**'
- en: '***3* Uses the WiringPi numbering scheme**'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 WiringPi 编号方案**'
- en: '`Raspi-io` supports multiple Pi pin-numbering schemes. Pins passed as JavaScript
    `Number` values are automatically assumed to be WiringPi numbers. But you can
    also use physical pin numbers and functional names (such as `GPIO4`). See the
    plugin’s documentation for more details ([https://github.com/nebrius/raspi-io](https://github.com/nebrius/raspi-io)).'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '`Raspi-io` 支持多种 Pi 引脚编号方案。作为 JavaScript `Number` 值传递的引脚自动被认为是 WiringPi 编号。但你也可以使用物理引脚编号和功能名称（如
    `GPIO4`）。有关更多详细信息，请参阅插件的文档（[https://github.com/nebrius/raspi-io](https://github.com/nebrius/raspi-io)）。'
- en: 11.2.5\. API documentation
  id: totrans-769
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.5\. API 文档
- en: Given that there are umpteen ways to control hardware with a Pi, there’s no
    single source of API documentation. Instead, we’ll be making use of Johnny-Five,
    Node.js, and the `raspi-io` I/O plugin, so you’ll want to keep the documentation
    websites for those APIs at your fingertips as we explore.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有无数种方式可以使用 Pi 控制硬件，因此没有单一的 API 文档来源。相反，我们将使用 Johnny-Five、Node.js 和 `raspi-io`
    I/O 插件，因此在我们探索时，您需要将那些 API 的文档网站放在手边。
- en: 11.3\. Writing Johnny-Five applications for different platforms
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 为不同平台编写 Johnny-Five 应用程序
- en: As seen in [listing 11.4](#ch11ex04), adapting Johnny-Five applications to work
    on different platforms (such as migrating from Arduino Uno to Raspberry Pi) can
    be quite easy. Often it’s a matter of selecting the right I/O plugin and updating
    some pin numbers in the code.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 11.4](#ch11ex04) 所示，将 Johnny-Five 应用程序调整到不同的平台（例如从 Arduino Uno 迁移到 Raspberry
    Pi）可以非常简单。通常这只是一个选择正确的 I/O 插件和在代码中更新一些引脚编号的问题。
- en: In the next several experiments in this section, you’ll adapt the live-updating
    BMP180-based weather application originally created for the Tessel in [chapter
    8](kindle_split_017.html#ch08) ([figure 11.15](#ch11fig15)). In keeping with your
    exploration of SBCs and the Raspberry Pi 3 specifically, you’ll implement the
    weather station first on the Pi 3 and then subsequently make it work on an Arduino
    Uno.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节接下来的几个实验中，您将调整第 8 章中为 Tessel 创建的基于 BMP180 的实时更新天气应用（[图 11.15](#ch11fig15)）。遵循您对单板计算机和
    Raspberry Pi 3 的具体探索，您将首先在 Pi 3 上实现气象站，然后使其在 Arduino Uno 上工作。
- en: Figure 11.15\. The mini weather app provides live-updating temperature and pressure
    data that can be viewed in a browser on any computer on the same network.
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.15\. 小型天气应用提供实时更新的温度和压力数据，可以在同一网络上的任何计算机上的浏览器中查看。
- en: '![](11fig15_alt.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig15_alt.jpg)'
- en: You can find the source code for the Tessel version of the weather station application
    in the book’s source code repository on GitHub.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上的本书源代码库中找到天气站应用的 Tessel 版本的源代码。
- en: 11.3.1\. Adapting the mini weather station for the Pi 3
  id: totrans-777
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. 为 Pi 3 调整小型气象站
- en: '|  |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 您需要
- en: '![](note.jpg)'
  id: totrans-780
  prefs: []
  type: TYPE_IMG
  zh: '![图片](note.jpg)'
- en: 1 configured Raspberry Pi 3
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个配置好的 Raspberry Pi 3
- en: 1 SparkFun Pi Wedge, Adafruit T-Cobbler, or similar; or male-to-female jumper
    wires
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 SparkFun Pi Wedge、Adafruit T-Cobbler 或类似的；或公对母跳线
- en: 1 BMP180 multisensor breakout board
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 BMP180 多传感器开发板
- en: 1 breadboard
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个面包板
- en: Jumper wires
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '|  |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'As a refresher, the weather application has two main components:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，天气应用有两个主要组件：
- en: Server code—This includes Johnny-Five code to handle I/O and reading sensor
    data, a static web server (using `express`), and a socket.IO server that emits
    events representing weather data updates (socket.IO clients can listen for those
    events).
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器代码——这包括用于处理 I/O 和读取传感器数据的 Johnny-Five 代码，一个静态 web 服务器（使用 `express`），以及一个
    socket.IO 服务器，它发出表示天气数据更新的事件（socket.IO 客户端可以监听这些事件）。
- en: Client code—This is in the form of a single HTML page—index.html—which will
    be served by the `express` static web server. Once loaded in a browser, index.html
    connects to the socket.IO server as a client, so it can receive and display weather
    data without a user having to refresh the page.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端代码——这是以单个 HTML 页面——index.html 的形式存在的，将由 `express` 静态 web 服务器提供。一旦在浏览器中加载，index.html
    就会作为客户端连接到 socket.IO 服务器，以便接收和显示天气数据，而无需用户刷新页面。
- en: This pattern—I/O handling and web server combined with a browser-based front
    end—can be reused to build many different kinds of IoT applications. It’s a useful
    pattern to have in your back pocket.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式——I/O 处理和基于浏览器的前端结合——可以重用来构建许多不同类型的物联网应用。这是一个值得保留在您口袋里的有用模式。
- en: Building the circuit
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建电路
- en: First, you need to build the circuit by connecting the BMP180 breakout to your
    Pi. As with the blinking LED, the specifics will depend on your setup. Wiring
    diagrams are provided for direct connections to the Pi ([figure 11.16](#ch11fig16)),
    SparkFun Pi Wedge ([figure 11.17](#ch11fig17)), and Adafruit’s T-Cobbler ([figure
    11.18](#ch11fig18)).
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要通过将 BMP180 开发板连接到您的 Pi 来构建电路。与闪烁的 LED 一样，具体操作将取决于您的设置。提供了直接连接到 Pi 的布线图（[图
    11.16](#ch11fig16)）、SparkFun Pi Wedge ([图 11.17](#ch11fig17)）和 Adafruit 的 T-Cobbler
    ([图 11.18](#ch11fig18)）。
- en: Figure 11.16\. Wiring diagram for the BMP180, showing direct connections to
    the Pi
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.16\. BMP180 的布线图，显示直接连接到 Pi
- en: '![](11fig16_alt.jpg)'
  id: totrans-794
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig16_alt.jpg)'
- en: Figure 11.17\. Wiring diagram for the BMP180 and the SparkFun Pi Wedge
  id: totrans-795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.17\. BMP180 和 SparkFun Pi Wedge 的布线图
- en: '![](11fig17_alt.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig17_alt.jpg)'
- en: Figure 11.18\. Wiring diagram for the BMP180 and the Adafruit T-Cobbler
  id: totrans-797
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.18\. BMP180 和 Adafruit T-Cobbler 的接线图
- en: '![](11fig18_alt.jpg)'
  id: totrans-798
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig18_alt.jpg)'
- en: '|  |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`Raspi-io` and I²C'
  id: totrans-800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Raspi-io` 和 I²C'
- en: 'The BMP180 is I²C. `Raspi-io` supports I²C just fine, but to enable it you’ll
    need to reboot (if you haven’t yet) after installing `raspi-io`. (Hint: `sudo
    reboot` is a handy command.)'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: BMP180 是 I²C。`Raspi-io` 支持 I²C，但要启用它，您需要在安装 `raspi-io` 后重启（如果您还没有重启的话）。（提示：`sudo
    reboot` 是一个方便的命令。）
- en: '|  |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Testing the BMP180
  id: totrans-803
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试 BMP180
- en: 'Before adapting the Tessel’s weather station software, you’re going to whip
    up a basic script to log BMP180 temperature and pressure data to the console.
    This will confirm that the combination of Raspbian, `raspi-io`, I²C, and the BMP180
    are working together in harmony:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在适配 Tessel 的天气站软件之前，您将编写一个基本的脚本来将 BMP180 温度和压力数据记录到控制台。这将确认 Raspbian、`raspi-io`、I²C
    和 BMP180 正在和谐地一起工作：
- en: 'Establish a working area. Create a directory called “weather” within your Pi’s
    projects directory:'
  id: totrans-805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立工作区域。在您的 Pi 项目目录中创建一个名为“weather”的目录：
- en: '[PRE55]'
  id: totrans-806
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inside of the weather directory, run this command:'
  id: totrans-807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在天气目录中，运行以下命令：
- en: '[PRE56]'
  id: totrans-808
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Create an index.js file and populate it with the code shown in the next listing.
  id: totrans-809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 index.js 文件，并用下一列表中的代码填充。
- en: Listing 11.5\. Testing the Pi, Johnny-Five, `raspi-io`, and BMP180
  id: totrans-810
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 测试 Pi、Johnny-Five、`raspi-io` 和 BMP180
- en: '[PRE57]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Once again, uses the raspi-io plugin for I/O**'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 再次使用 raspi-io 插件进行 I/O**'
- en: In the preceding listing, note that you don’t have to designate which pins the
    BMP180 is connected to in the instantiation of the `Multi` sensor component (assigned
    to the `bmp180` variable). `Raspi-io` “knows” where the I²C-capable pins are on
    the Raspberry Pi and takes care of configuring the interface for you! That’s handy.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，请注意，在 `Multi` 传感器组件（分配给 `bmp180` 变量）的实例化中，您不必指定 BMP180 连接到的引脚。`Raspi-io`
    “知道” Raspberry Pi 上具有 I²C 功能的引脚在哪里，并为您配置接口！这很方便。
- en: 'Try it out. Still inside of the weather directory, run this command:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。仍然在天气目录中，运行以下命令：
- en: '[PRE58]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You should see temperature and pressure data logging to the console, something
    like the following.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到温度和压力数据记录到控制台，如下所示。
- en: Listing 11.6\. Sample output for the test BMP180 script
  id: totrans-817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.6\. 测试 BMP180 脚本的示例输出
- en: '[PRE59]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Making Pi-specific changes
  id: totrans-819
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 进行 Pi 特定更改
- en: Now you’ll make some Pi-specific changes. Create a new working area, a directory
    called “pi-weather”. Copy the original weather application source files from the
    book’s GitHub repository into this directory, but omit .tesselinclude. You should
    end up with a structure that looks like the following.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您将对 Pi 进行一些特定更改。创建一个新的工作区域，一个名为“pi-weather”的目录。将书中 GitHub 仓库中的原始天气应用程序源文件复制到该目录中，但省略
    .tesselinclude。您最终应该得到以下结构。
- en: Listing 11.7\. Project directory and file structure
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.7\. 项目目录和文件结构
- en: '[PRE60]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|  |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Don’t copy over the node_modules directory
  id: totrans-824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不要复制 node_modules 目录
- en: 'If you inadvertently end up with a node_modules directory inside of pi-weather
    (copied from earlier experiments with the Tessel), blow it away before proceeding:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不小心在 pi-weather 目录中（从之前与 Tessel 的实验中复制）得到了一个 node_modules 目录，请在继续之前将其删除：
- en: '[PRE61]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|  |'
  id: totrans-827
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'There are two places in the code that need changes:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有两个地方需要更改：
- en: package.json—You’ll need to update dependencies.
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: package.json—您需要更新依赖项。
- en: index.js—You’ll need to use raspi-io for I/O.
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: index.js—您需要使用 raspi-io 进行 I/O。
- en: Updating the package.json dependencies
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新 package.json 依赖项
- en: Start by editing package.json. It should contain, in part, a `dependencies`
    object, which should look similar to what’s shown in the following listing, though
    your version numbers may be different. Remove the `tessel-io` dependency, as you
    won’t need it for the Raspberry Pi version.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编辑 package.json。它应该包含部分 `dependencies` 对象，其外观应类似于以下列表，尽管您的版本号可能不同。删除 `tessel-io`
    依赖项，因为您不需要它用于 Raspberry Pi 版本。
- en: Listing 11.8\. Package.json dependencies from the Tessel project
  id: totrans-833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.8\. Tessel 项目的 package.json 依赖项
- en: '[PRE62]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Don’t forget to delete the trailing comma if the tessel-io entry is the
    last one.**'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果 tessel-io 条目是最后一个，别忘了删除尾随的逗号。**'
- en: '***2* Delete this line.**'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 删除此行。**'
- en: 'Now install the remaining dependencies:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装剩余的依赖项：
- en: '[PRE63]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then add a new dependency—`raspi-io`—using the `--save` flag to write the change
    to the `dependencies` in package.json:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `--save` 标志添加一个新的依赖项—`raspi-io`—并将更改写入 package.json 中的 `dependencies`：
- en: '[PRE64]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Updating index.js
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新 index.js
- en: The changes needed in index.js are simple.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 在 index.js 中需要做的更改很简单。
- en: Replace this line,
  id: totrans-843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换此行，
- en: '[PRE65]'
  id: totrans-844
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'with this one:'
  id: totrans-845
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个：
- en: '[PRE66]'
  id: totrans-846
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Update the `board` instantiation to use `raspi-io` instead of `tessel-io`, changing
    this line,
  id: totrans-847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `board` 实例化更新为使用 `raspi-io` 而不是 `tessel-io`，更改此行，
- en: '[PRE67]'
  id: totrans-848
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'to look like this:'
  id: totrans-849
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看起来像这样：
- en: '[PRE68]'
  id: totrans-850
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The resulting index.js contents should look like the following.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 index.js 内容应如下所示。
- en: Listing 11.9\. A Pi-compatible version of index.js
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.9\. 兼容 Pi 的 index.js 版本
- en: '[PRE69]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: No changes are needed in app/index.html because that’s client-side code—it runs
    in the user’s browser, and it isn’t affected by platform changes.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 在 app/index.html 中不需要做任何修改，因为那是客户端代码——它在用户的浏览器中运行，并且不受平台变化的影响。
- en: 'Run the application by using this command from within the weather directory:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 在天气目录中使用此命令运行应用程序：
- en: '[PRE70]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Once the server code is initialized, it will log out the URL where you can access
    the weather display from other computers on the same network as the Pi (as shown
    in the following listing). Point your computer’s browser to the logged URL to
    see the weather station in action.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器代码初始化，它将输出可以访问 Pi 同一网络上的天气显示的 URL（如下所示列表）。将您的计算机浏览器指向记录的 URL 以查看天气站的实际运行情况。
- en: Listing 11.10\. Sample output when starting the weather station application
  id: totrans-858
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10\. 启动天气站应用程序时的示例输出
- en: '[PRE71]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 11.3.2\. Adapting the mini weather station for the Arduino Uno
  id: totrans-860
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 将迷你天气站适配到 Arduino Uno
- en: Making the weather application work on other Johnny-Five-supported platforms
    is similarly straightforward. It’s quick work to make the weather application
    work on an Arduino Uno tethered to your own computer, instead of on the Pi.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 使天气应用程序在其他 Johnny-Five 支持的平台上运行同样简单直接。将天气应用程序适配到连接到您自己的计算机的 Arduino Uno 上，而不是
    Pi 上，是快速的工作。
- en: '|  |'
  id: totrans-862
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-863
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要
- en: '![](note.jpg)'
  id: totrans-864
  prefs: []
  type: TYPE_IMG
  zh: '![note](note.jpg)'
- en: 1 Arduino Uno
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno
- en: 1 breadboard
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 面板
- en: 1 BMP180 multisensor breakout board
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 BMP180 多传感器扩展板
- en: Jumper wires
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '|  |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Copy the Pi version of the application—the weather directory and its contents,
    minus the node_modules directory, to your computer.
  id: totrans-870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序的 Pi 版本——天气目录及其内容（不包括 node_modules 目录），复制到您的计算机上。
- en: Edit package.json. Remove the `raspi-io` dependency; I/O support for Arduino
    platforms is built into Johnny-Five and doesn’t require an I/O plugin.
  id: totrans-871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 package.json。移除 `raspi-io` 依赖项；Arduino 平台的 I/O 支持已内置到 Johnny-Five 中，不需要 I/O
    插件。
- en: 'Install dependencies:'
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装依赖项：
- en: '[PRE72]'
  id: totrans-873
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Edit the index.js file:'
  id: totrans-874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 index.js 文件：
- en: Remove the `require` statement for `raspi-io`.
  id: totrans-875
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `raspi-io` 的 `require` 语句。
- en: 'Change the `board` instantiation. Remove the reference to `Raspi` such that
    it reads as follows:'
  id: totrans-876
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `board` 实例化。移除对 `Raspi` 的引用，使其如下所示：
- en: '[PRE73]'
  id: totrans-877
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Connect the BMP180 to the Arduino Uno as shown in [figure 11.19](#ch11fig19).
  id: totrans-878
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 BMP180 按照图 11.19（[图 11.19](#ch11fig19)）所示连接到 Arduino Uno。
- en: Figure 11.19\. Wiring diagram for the BMP180 and the Arduino Uno
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.19\. BMP180 和 Arduino Uno 的接线图
- en: '![](11fig19_alt.jpg)'
  id: totrans-880
  prefs: []
  type: TYPE_IMG
  zh: '![11fig19_alt](11fig19_alt.jpg)'
- en: 'Connect the Uno to your computer and run the application. You won’t need `sudo`
    here:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Uno 连接到您的计算机并运行应用程序。这里不需要 `sudo`：
- en: '[PRE74]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 11.4\. Using the Raspberry Pi as a host
  id: totrans-883
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 将 Raspberry Pi 作为主机使用
- en: Remember, the Raspberry Pi 3 is a “real” computer, so there’s no reason you
    can’t use it as the host in a host-client setup, with its own tethered Arduino,
    just like you do with your own computer.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Raspberry Pi 3 是一台“真正的”计算机，所以没有理由你不能将其作为主机在主机-客户端设置中使用，就像你用自己的计算机一样，配备自己的
    Arduino。
- en: '|  |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要
- en: '![](note.jpg)'
  id: totrans-887
  prefs: []
  type: TYPE_IMG
  zh: '![note](note.jpg)'
- en: 1 configured Raspberry Pi 3
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 配置好的 Raspberry Pi 3
- en: 1 Arduino Uno
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno
- en: 1 breadboard
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 面板
- en: 1 BMP180 multisensor breakout board
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 BMP180 多传感器扩展板
- en: Jumper wires
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '|  |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Copy the Arduino Uno version of the weather application code—again, without
    the node_modules directory—to the Pi.
  id: totrans-894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Arduino Uno 版本的天气应用程序代码（同样不包括 node_modules 目录）复制到 Pi 上。
- en: 'Install dependencies:'
  id: totrans-895
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装依赖项：
- en: '[PRE75]'
  id: totrans-896
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Plug the Arduino Uno—connected to the BMP180 as in [figure 11.23](#ch11fig23)—into
    one of the Pi’s four USB ports.
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将连接到 BMP180（如图 11.23（[图 11.23](#ch11fig23)）所示）的 Arduino Uno 插入 Pi 的四个 USB 端口之一。
- en: 'Run the application:'
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序：
- en: '[PRE76]'
  id: totrans-899
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: (You don’t need to use `sudo` here as you’re not using the Pi’s GPIO.)
  id: totrans-900
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （这里不需要使用 `sudo`，因为你没有使用 Pi 的 GPIO。）
- en: '|  |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Weather station with Raspberry Pi 3 and Tessel 2
  id: totrans-902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Raspberry Pi 3 和 Tessel 2 的天气站
- en: There’s no technical reason you can’t deploy the Tessel 2 version of the weather
    app to the Tessel from the Pi (instead of from your own computer). First, however,
    you’ll need to install `t2-cli` on the Pi and provision the Tessel from it as
    detailed in Tessel’s “Install Tessel 2” page ([http://tessel.github.io/t2-start/](http://tessel.github.io/t2-start/)).
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何技术原因阻止你将 Tessel 2 版本的天气应用程序部署到 Tessel 上（而不是从你的电脑上部署）。然而，首先，你需要在 Pi 上安装 `t2-cli`
    并从它那里配置 Tessel，具体操作请参考 Tessel 的“安装 Tessel 2”页面 ([http://tessel.github.io/t2-start/](http://tessel.github.io/t2-start/))。
- en: '|  |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: At the end of the day, the Raspberry Pi platform is a vast world of options
    and choice. A true computer in its own right, the Pi 3 packs the punch to act
    as a host in a host-client setup, which is especially nice if you don’t want to
    bother with the Pi’s somewhat convoluted GPIO. But if you do want to dive into
    the Pi’s onboard GPIO, there are certainly a multitude of ways to get the job
    done.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Raspberry Pi 平台是一个充满选择和选项的广阔世界。Pi 3 本身就是一个真正的计算机，它具有作为主机在主机-客户端设置中的能力，这对于不想处理
    Pi 的复杂 GPIO 来说特别方便。但如果你确实想深入研究 Pi 的板载 GPIO，当然有无数种方法可以完成任务。
- en: '11.5\. Case study: BeagleBone Black'
  id: totrans-906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5. 案例研究：BeagleBone Black
- en: The Pi isn’t the only game in town—there are a host of other SBC platforms.
    To get a sense of the commonalities and differences between them, let’s take a
    brief tour of the BeagleBone Black ([figure 11.20](#ch11fig20)), one of the BeagleBoard
    family of SBCs.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: Pi 并非市场上唯一的游戏——还有许多其他的单板计算机（SBC）平台。为了了解它们之间的共性和差异，让我们简要地浏览一下 BeagleBone Black
    ([图 11.20](#ch11fig20))，它是 BeagleBoard 家族中的一员。
- en: Figure 11.20\. The BeagleBone Black SBC
  id: totrans-908
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.20. BeagleBone Black 单板计算机
- en: '![](11fig20_alt.jpg)'
  id: totrans-909
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig20_alt.jpg)'
- en: 11.5.1\. Learning about the BeagleBone Black
  id: totrans-910
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.1. 了解 BeagleBone Black
- en: 'Comparing any two SBCs is often an apples-to-oranges affair; different platforms
    are targeted at different applications. The Pi 3 wins the CPU and peripherals
    contest (multicore CPU, higher clock speed, more USB ports, and so on), but the
    BeagleBone Black outstrips the Pi in terms of GPIO features, and it’s more power-efficient
    at idle. Rev C of the BeagleBone Black also ups the RAM ante: it has 4 GB.'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 比较任何两个 SBC 常常是苹果和橙子的比较；不同的平台针对不同的应用。Pi 3 在 CPU 和外围设备竞赛中获胜（多核 CPU、更高的时钟速度、更多的
    USB 端口等），但 BeagleBone Black 在 GPIO 功能方面超过了 Pi，并且在空闲时更加节能。BeagleBone Black 的 Rev
    C 版本还增加了 RAM：它有 4 GB。
- en: Another important distinction is that, although the various Linux distributions
    you can run on the Raspberry Pi are open source, its hardware is not. Pis are
    exclusively manufactured by the Raspberry Pi Foundation and contain some closed-source
    components. BeagleBoards, in contrast, are open source hardware.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是，尽管你可以在 Raspberry Pi 上运行的 Linux 发行版是开源的，但其硬件并非如此。Pi 由 Raspberry Pi
    基金会独家制造，并包含一些闭源组件。相比之下，BeagleBoard 是开源硬件。
- en: A rev C BeagleBone Black will set you back about $55.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 一块 BeagleBone Black 的价格大约是 55 美元。
- en: Core features
  id: totrans-914
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 核心功能
- en: As alluded to moments ago, the BeagleBone Black’s CPU is single-core and runs
    at 1.0 GHz, which is slower than the Pi 3’s 1.2 GHz. Both are ARM v8 chips, however,
    so they’re not too dissimilar overall. If you get the rev C, you’ll score 4 GB
    of RAM (older versions have 512 MB). Like the Pi, the BeagleBone Black has a microSD
    slot, but it also has 4 GB of onboard eMMC flash storage. It has a single USB
    port, a mini-HDMI interface, and an Ethernet interface ([figure 11.21](#ch11fig21)).
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，BeagleBone Black 的 CPU 是单核，运行速度为 1.0 GHz，比 Pi 3 的 1.2 GHz 慢。然而，它们都是 ARM
    v8 芯片，所以总体上并不太相似。如果你选择 Rev C 版本，你将获得 4 GB 的 RAM（旧版本有 512 MB）。与 Pi 一样，BeagleBone
    Black 有一个 microSD 插槽，但它还内置了 4 GB 的 eMMC 闪存存储。它有一个 USB 端口，一个 mini-HDMI 接口和一个以太网接口
    ([图 11.21](#ch11fig21))。
- en: Figure 11.21\. The BeagleBone Black’s information page on BeagleBoard’s website
  id: totrans-916
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.21. BeagleBone Black 在 BeagleBoard 网站上的信息页面
- en: '![](11fig21_alt.jpg)'
  id: totrans-917
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig21_alt.jpg)'
- en: GPIO features and pinouts
  id: totrans-918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GPIO 功能和引脚配置
- en: The BeagleBone Black boasts a smorgasbord of GPIO. There are 92 (ninety-two!)
    pins. There’s hardware support for 4 UARTs, 65 interrupt-capable digital I/O pins,
    8 PWM pins, and 7 analog inputs. Whereas the Pi is a computer that also does GPIO,
    the BeagleBone is more like a GPIO champ that also does computing.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black 拥有丰富的 GPIO。有 92 个（九十二个！）引脚。它支持 4 个 UART，65 个具有中断能力的数字 I/O 引脚，8
    个 PWM 引脚和 7 个模拟输入。而 Pi 是一个同时做 GPIO 的计算机，而 BeagleBone 则更像是一个以 GPIO 为主的冠军，同时也能进行计算。
- en: '|  |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The BeagleBone Black and non-Ethernet connectivity options**'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '**BeagleBone Black 和非以太网连接选项**'
- en: The basic BeagleBone Black doesn’t have onboard WiFi, but you can add support
    using a third-party adapter. You can find a list of supported WiFi adapters on
    the BeagleBone Black page of the Embedded Linux Wiki ([http://mng.bz/Uj9d](http://mng.bz/Uj9d)).
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 基本版的 BeagleBone Black 没有内置 WiFi，但你可以使用第三方适配器添加支持。你可以在嵌入式 Linux Wiki 的 BeagleBone
    Black 页面上找到支持的 WiFi 适配器列表（[http://mng.bz/Uj9d](http://mng.bz/Uj9d)）。
- en: Another networking approach allows you to `ssh` to your BeagleBone Black over
    a USB connection. This may require you to install some drivers or tweak some other
    configuration; see the “Getting Started” page on BeagleBoard’s site for more details
    ([http://beagleboard.org/getting-started](http://beagleboard.org/getting-started)).
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种网络方法允许你通过 USB 连接 `ssh` 到你的 BeagleBone Black。这可能需要你安装一些驱动程序或调整一些其他配置；有关更多详细信息，请参阅
    BeagleBoard 网站的“入门”页面（[http://beagleboard.org/getting-started](http://beagleboard.org/getting-started)）。
- en: '|  |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The BeagleBone Black’s pins are laid out in two sets of *expansion headers*
    with 46 pins in each. With the board’s DC power connection at the top, expansion
    header P9 is on the left, P8 on the right (and as to what happened to P1–P7: no
    idea). As with the Pi, many of the BeagleBone Black’s pins can play multiple roles.'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black 的引脚分为两组 *扩展头*，每组有 46 个引脚。由于板的直流电源连接位于顶部，扩展头 P9 位于左侧，P8 位于右侧（至于
    P1–P7 发生了什么：不知道）。与 Pi 类似，BeagleBone Black 的许多引脚可以扮演多个角色。
- en: You’re going to use another Johnny-Five I/O plugin to control the BeagleBone
    Black’s GPIO. [Figure 11.22](#ch11fig22) shows the pins supported by the `beaglebone-io`
    Johnny-Five I/O plugin and their features. To reference a pin with `beaglebone-io`,
    you prefix the pin’s physical number with the header number, such as `P9_11` for
    pin 11 on P9\. You’ll only be using the I²C interface, so you won’t need to provide
    pin numbers at all—`beaglebone-io` will know automatically to use pins `P9_19`
    (SCL) and `P9_20` (SDA).
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用另一个 Johnny-Five I/O 插件来控制 BeagleBone Black 的 GPIO。[图 11.22](#ch11fig22)
    展示了 `beaglebone-io` Johnny-Five I/O 插件支持的引脚及其功能。要使用 `beaglebone-io` 引用引脚，你需要在引脚的物理编号前加上头文件编号，例如
    P9_11 表示 P9 头上的第 11 个引脚。由于你将只使用 I²C 接口，因此你不需要提供任何引脚编号——`beaglebone-io` 将自动使用引脚
    `P9_19`（SCL）和 `P9_20`（SDA）。
- en: '|  |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: BeagleBone Black Voltage
  id: totrans-928
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: BeagleBone Black 电压
- en: The analog input pins on the BeagleBone Black only accept input voltages up
    to 1.8 V.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black 的模拟输入引脚仅接受高达 1.8 V 的输入电压。
- en: '|  |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It’s important to note that the pin features shown in [figure 11.22](#ch11fig22)
    aren’t indicative of all of the hardware support that the BeagleBone Black provides
    on those pins, but the support that the `beaglebone-io` plugin provides (for Johnny-Five
    scripts).
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，图 11.22 中显示的引脚功能并不代表 BeagleBone Black 在这些引脚上提供的所有硬件支持，而是 `beaglebone-io`
    插件提供的支持（用于 Johnny-Five 脚本）。
- en: Figure 11.22\. BeagleBone Black pin features available via the `beaglebone-io`
    Johnny-Five I/O plugin
  id: totrans-932
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.22\. 通过 `beaglebone-io` Johnny-Five I/O 插件可用的 BeagleBone Black 引脚功能
- en: '![](11fig22_alt.jpg)'
  id: totrans-933
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22](11fig22_alt.jpg)'
- en: For example, there’s no UART/TTL serial support shown here, but the BeagleBone
    Black does have several UARTs. Sometimes the search for a relevant pinout diagram
    can be complicated by the reality that what the pins actually do depends on how
    you’re using them.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里没有显示 UART/TTL 串行支持，但 BeagleBone Black 确实有几个 UART。有时，寻找相关的引脚图可能会因为引脚实际功能取决于你如何使用它们而变得复杂。
- en: '|  |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: BBB GPIO beyond Johnny-Five
  id: totrans-936
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: BBB GPIO 超越 Johnny-Five
- en: 'Do you plan on using your BeagleBone Black in other, non-Johnny-Five, contexts?
    You’ll want to seek out a more complete pinout diagram. There are tons of other
    BeagleBone Black pinout diagrams available on the web. The BeagleBone Black has
    a bumper crop of 96 pins, each capable of playing upward of five or six different
    roles and referenced by different naming conventions. This can lead to some rather
    overwhelming diagrams. Take your time and be patient: it’s not you—it really *is*
    a lot of information to take in visually.'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 你计划在其他非 Johnny-Five 的环境中使用你的 BeagleBone Black 吗？你需要寻找一个更完整的引脚图。网上有大量的其他 BeagleBone
    Black 引脚图。BeagleBone Black 有 96 个引脚，每个引脚可以扮演五到六个不同的角色，并使用不同的命名约定进行引用。这可能会导致一些相当令人眼花缭乱的图表。请耐心一些：这真的是一大堆需要视觉上吸收的信息。
- en: '|  |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Configuration and workflow
  id: totrans-939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置和工作流程
- en: One way to configure the BeagleBone Black closely mirrors the Raspberry Pi 3
    setup from earlier in the chapter, minus the WiFi setup (there’s no WiFi to configure).
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 一种配置 BeagleBone Black 的方法与本章前面提到的 Raspberry Pi 3 设置非常相似，只是没有 WiFi 设置（没有 WiFi
    可配置）。
- en: 'The board ships with Ångström, an embedded Linux distribution, but this setup
    process replaces that with Debian. For more details about creating a bootable
    microSD (steps are abbreviated here), refer to the previous Raspberry Pi 3 setup
    in [section 11.4](#ch11lev1sec4):'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 该板附带Ångström，一个嵌入式Linux发行版，但此设置过程将其替换为Debian。有关创建可启动的microSD（步骤在此处简化）的更多详细信息，请参阅之前的Raspberry
    Pi 3设置[第11.4节](#ch11lev1sec4)：
- en: Download the latest Debian image for BeagleBone at [http://beagleboard.org/latest-images](http://beagleboard.org/latest-images).
  id: totrans-942
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[http://beagleboard.org/latest-images](http://beagleboard.org/latest-images)下载最新的BeagleBone
    Debian镜像。
- en: Burn the image to an SD card using the Etcher application.
  id: totrans-943
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Etcher应用程序将镜像烧录到SD卡上。
- en: 'Instead of repeatedly booting from the SD card, what you want to do is flash
    the OS image to the onboard eMMC flash storage. This requires an additional, slightly
    finicky, step here: a configuration file needs a simple edit. After you flash
    the SD card with the Debian image, it may not be readable by your computer (it
    wasn’t with mine). Instead, you can go ahead and boot the BeagleBone Black directly
    from the SD card, once, so that you can edit that config file:'
  id: totrans-944
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您不想反复从SD卡启动，所以您需要将操作系统镜像刷写到板载eMMC闪存中。这需要额外的、稍微有些麻烦的步骤：需要编辑一个配置文件。在您用Debian镜像刷写SD卡后，您的电脑可能无法读取它（我的电脑就是这种情况）。取而代之的是，您可以一次性直接从SD卡启动BeagleBone
    Black，以便编辑那个配置文件：
- en: Insert the microSD card with the Debian image on it into the BeagleBone Black.
  id: totrans-945
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将带有Debian镜像的microSD卡插入BeagleBone Black。
- en: Connect the BeagleBone Black directly to your router with an Ethernet cable,
    and then plug in power to the BeagleBone Black. It’ll take a minute or two for
    the BeagleBone Black to boot up and get an IP address on your network.
  id: totrans-946
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以太网线将BeagleBone Black直接连接到您的路由器，然后为BeagleBone Black插上电源。BeagleBone Black需要一两分钟的时间来启动并获取网络上的IP地址。
- en: Fire up your LAN- or IP-scanning utility to figure out the BeagleBone Black’s
    IP address.
  id: totrans-947
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的局域网或IP扫描工具以确定BeagleBone Black的IP地址。
- en: 'From your computer, in a terminal, `ssh` into the BBB with the `debian` user
    (`ssh` is enabled by default in the Debian image you’re using here):'
  id: totrans-948
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的电脑上，在终端中，使用`debian`用户(`ssh`在此处使用的Debian镜像中默认启用)连接到BBB：
- en: '[PRE77]'
  id: totrans-949
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There’s a default password for that user, which will be displayed to you on
    first login.
  id: totrans-950
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该用户有一个默认密码，首次登录时会显示给您。
- en: 'Edit the configuration file in question:'
  id: totrans-951
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑相关的配置文件：
- en: '[PRE78]'
  id: totrans-952
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '(or use your preferred editor if you don’t like `vi`). Toward the bottom of
    the file, find the following line and uncomment it (remove the `#`):'
  id: totrans-953
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （或者如果您不喜欢`vi`，可以使用您喜欢的编辑器）。在文件的底部附近找到以下行并取消注释它（移除`#`）：
- en: '[PRE79]'
  id: totrans-954
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Save and exit the file. Uncommenting that line will allow the BeagleBone Black
    to run a script on startup that will copy (flash) the contents of the SD card
    to the built-in eMMC.
  id: totrans-955
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存并退出文件。取消注释该行将允许BeagleBone Black在启动时运行一个脚本，该脚本将复制（刷写）SD卡的内容到内置的eMMC。
- en: Now power down the BeagleBone Black. With the SD card still inserted, hold down
    the BOOT/USER button ([figure 11.23](#ch11fig23)) and reconnect the power. Keep
    holding the button down for a few more seconds until all of the onboard LEDs light
    up solid for a moment. Then you can let the button go.
  id: totrans-956
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭BeagleBone Black的电源。在SD卡仍然插入的情况下，按住BOOT/USER按钮([图11.23](#ch11fig23))并重新连接电源。继续按住按钮几秒钟，直到所有板载LED灯瞬间亮起。然后您可以松开按钮。
- en: Figure 11.23\. The BOOT/USER button on the BeagleBone Black
  id: totrans-957
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.23. BeagleBone Black上的BOOT/USER按钮
- en: '![](11fig23_alt.jpg)'
  id: totrans-958
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](11fig23_alt.jpg)'
- en: The eMMC-flashing process takes a while—BeagleBoard’s site says 30–45 minutes.
    You can tell when it’s done because all of the BeagleBone Black’s blue LEDs will
    turn off (frankly, a welcome respite from all of its default blinking!).
  id: totrans-959
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: eMMC刷写过程需要一段时间——BeagleBoard的网站表示需要30-45分钟。您可以通过所有BeagleBone Black的蓝色LED灯都熄灭来判断何时完成（坦白说，从它默认的闪烁中解脱出来是个令人欢迎的休息！）。
- en: Power down the BeagleBone Black and eject the SD card. Power it back on again.
  id: totrans-960
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭BeagleBone Black的电源并弹出SD卡。再次打开电源。
- en: From your computer, `ssh` into the BeagleBone Black as the `debian` user.
  id: totrans-961
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的电脑上，以`debian`用户身份使用`ssh`连接到BeagleBone Black。
- en: 'Run this command:'
  id: totrans-962
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令：
- en: '[PRE80]'
  id: totrans-963
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You should see output similar to the following:'
  id: totrans-964
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到类似以下内容的输出：
- en: '[PRE81]'
  id: totrans-965
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To see what Node.js version you have, run this command:'
  id: totrans-966
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看您拥有的Node.js版本，请运行此命令：
- en: '[PRE82]'
  id: totrans-967
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: I got `v4.8.0`.
  id: totrans-968
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我得到了`v4.8.0`。
- en: You’re welcome to update the Node.js version if you’d like, but v4.8.x is good
    enough to support the rest of the code examples in this section.
  id: totrans-969
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想更新Node.js版本，欢迎您这样做，但v4.8.x已经足够支持本节中其余的代码示例。
- en: Examples and tutorials
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例和教程
- en: Next you’ll take the BeagleBone Black for a Hello World spin, LED-style, using
    Johnny-Five and the `beaglebone-io` plugin. There’s an onboard LED you can access,
    so this is a quick endeavor (no circuitry required).
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用Johnny-Five和`beaglebone-io`插件来给BeagleBone Black进行一次“Hello World”的LED式旋转，你可以访问板载LED，因此这是一个快速的任务（无需电路）。
- en: 'Connect to your BeagleBone Black over SSH and create a working area (a projects
    directory or similar). Inside of this directory, install Johnny-Five and the `beaglebone-io`
    I/O plugin:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH连接到你的BeagleBone Black，并创建一个工作区域（一个项目目录或类似）。在这个目录内，安装Johnny-Five和`beaglebone-io`
    I/O插件：
- en: '[PRE83]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Create an index.js file and add the contents from the following listing.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个index.js文件，并添加以下列表的内容。
- en: Listing 11.11\. LED blinking on the BeagleBone Black
  id: totrans-975
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.11\. 在BeagleBone Black上闪烁LED
- en: '[PRE84]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* Using the beaglebone-io plugin**'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用beaglebone-io插件**'
- en: '***2* No pin number is given here: beaglebone-io will automatically use the
    onboard LED.**'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这里没有给出引脚编号：beaglebone-io将自动使用板载LED。**'
- en: 'Now run it! As with the Pi, you’ll need `sudo` here:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它！与Pi一样，这里你需要`sudo`：
- en: '[PRE85]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You should now see one of the BeagleBone Black’s blue LEDs blinking on and off
    every 500 ms.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到BeagleBone Black的一个蓝色LED每500毫秒闪烁一次。
- en: API documentation
  id: totrans-982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API文档
- en: Once again, you’re taking the Johnny-Five route here. Documentation for the
    `beaglebone-io` plugin contains vital information about pin support and plugin
    usage details ([https://github.com/julianduque/beaglebone-io](https://github.com/julianduque/beaglebone-io)).
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你在这里选择的是Johnny-Five路线。`beaglebone-io`插件的文档包含了关于引脚支持和插件使用细节的重要信息([https://github.com/julianduque/beaglebone-io](https://github.com/julianduque/beaglebone-io))。
- en: 11.5.2\. Adapting the weather station for the BeagleBone
  id: totrans-984
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.2\. 为BeagleBone适配天气站
- en: '|  |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要的东西
- en: '![](note.jpg)'
  id: totrans-987
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 configured, networked BeagleBone Black and power supply
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 配置好网络连接的BeagleBone Black和电源
- en: 1 breadboard
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 面包板
- en: 1 BMP180 multisensor breakout board
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 BMP180多传感器扩展板
- en: Jumper wires
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '|  |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'By now, the overall adaptation pattern for the weather application is getting
    familiar:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，天气应用的总体适配模式已经变得熟悉：
- en: Connect the BMP180 to the BeagleBone Black, as shown in [figure 11.24](#ch11fig24).
  id: totrans-994
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照图11.24所示连接BMP180到BeagleBone Black。
- en: Figure 11.24\. Wiring diagram for the BMP180 and the BeagleBone Black
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.24\. BMP180和BeagleBone Black的接线图
- en: '![](11fig24_alt.jpg)'
  id: totrans-996
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](11fig24_alt.jpg)'
- en: Make a weather directory on the BeagleBone Black, and copy the original (Tessel
    variant) weather station source code into it, without node_modules.
  id: totrans-997
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在BeagleBone Black上创建一个天气目录，并将原始（Tessel变体）的天气站源代码复制进去，不包括node_modules。
- en: Edit package.json to remove the `tessel-io` dependency.
  id: totrans-998
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑package.json以移除`tessel-io`依赖项。
- en: Run `$ npm install` to install dependencies.
  id: totrans-999
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`$ npm install`来安装依赖项。
- en: Run `$npm install --save beaglebone-io` to install the `beaglebone-io` plugin
    and save it to package.json.
  id: totrans-1000
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`$npm install --save beaglebone-io`来安装`beaglebone-io`插件并将其保存到package.json。
- en: 'Edit index.js:'
  id: totrans-1001
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑index.js：
- en: 'Remove the `tessel-io` dependency and replace it with `beaglebone-io`:'
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`tessel-io`依赖项，并用`beaglebone-io`替换：
- en: '[PRE86]'
  id: totrans-1003
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Change the `board` instantiation to use the `beaglebone-io` plugin:'
  id: totrans-1004
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`board`实例化改为使用`beaglebone-io`插件：
- en: '[PRE87]'
  id: totrans-1005
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The BeagleBone Black is going to require just a couple more quick tricks from
    you.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black还需要你几个快速技巧。
- en: As it turns out, the BeagleBone Black, by default, already has a server running
    at port `3000`. And it doesn’t have WiFi, so there’s no `wlan0` network interface.
    To account for this, edit the code for `server.listen()` as follows.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，BeagleBone Black默认情况下已经在端口`3000`上运行了一个服务器。它没有WiFi，所以没有`wlan0`网络接口。为了解决这个问题，按照以下方式编辑`server.listen()`的代码。
- en: Listing 11.12\. Updated `server.listen()`
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.12\. 更新的`server.listen()`
- en: '[PRE88]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* Change the port number to something else; 4000 works fine.**'
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将端口号更改为其他值；4000也可以。**'
- en: '***2* Use `eth0` instead of `wlan0` here, and also update the port number.**'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这里使用`eth0`而不是`wlan0`，并且更新端口号。**'
- en: 'All done! Make it so:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！让它这样：
- en: '[PRE89]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now open the logged URL in a browser on your computer.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的电脑上的浏览器中打开登录的URL。
- en: Keeping the I/O details sequestered to I/O plugins makes Johnny-Five applications
    relatively portable between platforms. Details do pop up, like the unavailability
    of port `3000` on the BeagleBone Black, but overall it’s usually not too bad to
    move things between platforms. If you’d like, you can also run the Arduino-compatible
    variant of the weather application, using the BeagleBone Black as a host. SBCs
    give you a whole constellation of options.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 将I/O细节隔离到I/O插件中使得Johnny-Five应用程序在不同平台之间相对便携。确实会冒出一些细节，比如BeagleBone Black上不可用的端口`3000`，但总体来说，在平台之间移动事物通常不会太糟糕。如果你愿意，你还可以运行天气应用程序的Arduino兼容变体，使用BeagleBone
    Black作为主机。SBCs为你提供了一整个选项星座。
- en: Summary
  id: totrans-1016
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Single-board computers (SBCs) add tons of features and general-purpose goodies,
    but they use more power and are more complicated to configure and administer than
    more constrained platforms.
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单板计算机（SBCs）增加了大量功能和通用优点，但它们比更受限制的平台消耗更多电力，配置和管理也更复杂。
- en: The Raspberry Pi 3 is the third-generation Raspberry Pi platform, and it can
    be used for general-purpose computing as well as for embedded applications. Raspbian
    is a Debian-based Linux OS specifically optimized for the Pi family.
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 3是第三代Raspberry Pi平台，它可以用于通用计算以及嵌入式应用。Raspbian是基于Debian的Linux操作系统，专门针对Pi系列进行了优化。
- en: Common setup steps for SBCs and Node.js development include flashing (or otherwise
    installing or upgrading) an OS, configuring networking, updating Node.js versions,
    and establishing a filesystem workflow.
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBCs和Node.js开发的常见设置步骤包括刷写（或以其他方式安装或升级）操作系统、配置网络、更新Node.js版本以及建立文件系统工作流程。
- en: '`Sysfs` is a Linux pseudo-filesystem that allows interaction with connected
    components and hardware via virtual directories and files.'
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sysfs` 是一个Linux伪文件系统，它允许通过虚拟目录和文件与连接的组件和硬件进行交互。'
- en: There are myriad ways to hack hardware on a Raspberry Pi, with frameworks and
    libraries for nearly any programming language you can think of.
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Raspberry Pi上黑客攻击硬件有无数种方法，几乎涵盖了你能想到的任何编程语言的框架和库。
- en: WiringPi is a popular abstraction for Raspberry Pi GPIO. It’s written in C,
    but there are libraries for it in several other languages. Other frameworks not
    based on WiringPi (including the `raspi-io` plugin) support WiringPi’s pin-numbering
    scheme because its Arduino-emulating clarity can be less confusing than other
    numbering schemes.
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WiringPi是Raspberry Pi GPIO的一个流行抽象，它用C语言编写，但还有其他几种语言的库。其他不是基于WiringPi的框架（包括`raspi-io`插件）支持WiringPi的引脚编号方案，因为它的Arduino模拟清晰度可能比其他编号方案更不令人困惑。
- en: The `raspi-io` and `beaglebone-io` I/O plugins support Johnny-Five compatibility
    on the Raspberry Pi and BeagleBone Black platforms, respectively.
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raspi-io`和`beaglebone-io` I/O插件分别在Raspberry Pi和BeagleBone Black平台上支持Johnny-Five兼容性。'
- en: Adapting Johnny-Five applications to work cross-platform commonly involves swapping
    out I/O plugins and updating pin numbers. Often those are the only changes necessary.
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Johnny-Five应用程序适配为跨平台通常涉及交换I/O插件和更新引脚编号。通常这些是唯一必要的更改。
- en: The Raspberry Pi can also be used in a host-client setup, acting as the host.
    It can control a tethered Arduino Uno (client), for example.
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi也可以用于主机-客户端设置，充当主机。例如，它可以控制连接的Arduino Uno（客户端）。
- en: The BeagleBone Black is an open source SBC with features in the same ballpark,
    overall, as a Raspberry Pi 3, but it’s more targeted to embedded and GPIO applications.
  id: totrans-1026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeagleBone Black是一个开源的单板计算机，其功能与Raspberry Pi 3大致相同，但更专注于嵌入式和GPIO应用。
- en: Chapter 12\. In the cloud, in the browser, and beyond
  id: totrans-1027
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章\. 在云端、浏览器之外
- en: '*This chapter covers*'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using a cloud-based service (resin.io) to deploy and manage an application across
    a fleet of devices
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于云的服务（resin.io）在设备群中部署和管理应用程序
- en: Bleeding-edge web platform technologies for interacting with hardware, including
    Web Bluetooth and the Generic Sensor API
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与硬件交互的尖端Web平台技术，包括Web蓝牙和通用传感器API
- en: Building the Physical Web with the open Eddystone protocol and Bluetooth Low
    Energy (BLE) beacons
  id: totrans-1031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开放的Eddystone协议和蓝牙低功耗（BLE）信标构建物理Web
- en: Controlling hardware from a web page using Web Bluetooth and Puck.js
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web蓝牙和Puck.js从网页控制硬件
- en: Reading data from and writing commands to a BLE device
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从BLE设备读取数据和向其发送命令
- en: '|  |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](tool.jpg)'
  id: totrans-1035
  prefs: []
  type: TYPE_IMG
  zh: '![](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于本章，你需要以下内容：**'
- en: 1 BeagleBone Black and 5 V power supply
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 BeagleBone Black和5 V电源
- en: 1 Espruino Puck.js
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Espruino Puck.js
- en: 1 Adafruit BMP180 multisensor breakout board
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Adafruit BMP180多传感器扩展板
- en: 1 half-size breadboard
  id: totrans-1040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 半尺寸面包板
- en: Jumper wires
  id: totrans-1041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '![](0376fig01_alt.jpg)'
  id: totrans-1042
  prefs: []
  type: TYPE_IMG
  zh: '![](0376fig01_alt.jpg)'
- en: '|  |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This chapter opens up some grand vistas. Yet this grandness of scale bumps
    up against limited space. Topics merely touched upon here are entire specialties;
    there’s enough to learn about each to fill books, shelves, or even entire libraries:
    security; the web standards process; the intricacies of Bluetooth and Bluetooth
    LE (BLE) architecture; provisioning and managing fleets of IoT devices, at scale.'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开启了一些宏伟的视野。然而，这种规模的宏伟与有限的篇幅相冲突。这里仅触及的一些主题是整个专业领域；关于每个主题的学习内容足以填满书籍、书架，甚至整个图书馆：安全性；网络标准流程；蓝牙和蓝牙低功耗(BLE)架构的复杂性；大规模部署和管理物联网设备。
- en: As such, this chapter doesn’t mark the end of a learning journey but is instead
    a springboard for subsequent adventures. Its first half pulls back the curtains
    on the world of cloud-based IoT service offerings. The second half wears a futurist’s
    hat, pushing at the edges of what we can do on the web and in a browser today,
    and at what might be coming tomorrow.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章并不是学习旅程的终点，而是一个跳板，为后续的冒险做准备。它的一半揭开了基于云的物联网服务世界的面纱。另一半戴着未来主义者的帽子，探索了我们今天在网页和浏览器上能做什么，以及明天可能到来的是什么。
- en: '|  |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Code is not production-ready
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码尚未准备好用于生产
- en: The code in this chapter isn’t ready for a production environment. Security,
    performance, graceful degradation, and accessibility diligence are sacrificed
    here in pursuit of clarity and brevity.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码尚未准备好用于生产环境。为了追求清晰和简洁，这里牺牲了安全性、性能、优雅降级和可访问性。
- en: '|  |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.1\. IoT and the cloud
  id: totrans-1050
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. 物联网与云
- en: This book has been primarily concerned with illustrating core electronics principles
    and wrangling hardware with JavaScript. But the cloud is an indispensable part
    of IoT—you can’t have the internet of things without the internet. Commercial
    IoT cloud services provide inventors and entrepreneurs with ways of bringing their
    IoT visions to life, offering supporting services like data stores, deployment
    tools, RESTful APIs, analytics, security, testing, benchmarking, debugging, monitoring,
    development frameworks—wow! It turns out that IoT is complex. And, boy, is there
    a lot of jargon involved!
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 本书主要关注说明核心电子原理和用JavaScript控制硬件。但云是物联网不可或缺的一部分——没有互联网就没有物联网。商业物联网云服务为发明家和企业家提供了将他们的物联网愿景变为现实的方法，提供支持服务，如数据存储、部署工具、RESTful
    API、分析、安全性、测试、基准测试、调试、监控、开发框架——哇！结果证明物联网是复杂的。而且，涉及到的术语真是太多了！
- en: The already-vague notion of IoT cloud services is muddied further by the fact
    that some IoT companies’ products aren’t limited to software. Indeed, some companies
    combine physical hardware platforms with their cloud services, creating a top-to-bottom
    package ([figure 12.1](#ch12fig01)).
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网云服务的概念本身已经模糊不清，而一些物联网公司的产品并不局限于软件。事实上，一些公司结合了物理硬件平台和他们的云服务，创造了一个从上到下的完整方案([图12.1](#ch12fig01))。
- en: Figure 12.1\. Both Particle ([https://www.particle.io](https://www.particle.io))
    and Samsung’s ARTIK services ([https://www.artik.io](https://www.artik.io)) are
    so-called “end-to-end” offerings for IoT.
  id: totrans-1053
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1\. Particle([https://www.particle.io](https://www.particle.io))和三星的ARTIK服务([https://www.artik.io](https://www.artik.io))是所谓的“端到端”物联网解决方案。
- en: '![](12fig01_alt.jpg)'
  id: totrans-1054
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig01_alt.jpg)'
- en: Particle, for example, manufactures the Electron board, which has onboard 2G/3G
    connectivity. You deploy your code to and read data from a given Electron using
    cellular networks—depending on Particle’s proprietary cloud services for this
    deployment and I/O, naturally. In this case, the company—Particle—is providing
    the hardware (the Electron device), the software (you program your Particle boards
    using their API), and the cloud infrastructure (you deploy to your Particle device
    fleet using their centralized web-based tools).
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Particle制造了Electron板，该板具有板载2G/3G连接性。您可以通过蜂窝网络将代码部署到Electron板，并从Electron板读取数据——当然，这依赖于Particle的专有云服务进行部署和I/O。在这种情况下，公司——Particle——提供了硬件（Electron设备）、软件（您使用他们的API编程Particle板）和云基础设施（您使用他们的集中式基于网页的工具将代码部署到您的Particle设备群组）。
- en: Another example of this so-called end-to-end product offering is Samsung’s ARTIK
    platform. You could use one of the ARTIK hardware “modules” standalone—their 5-,
    7-, and 10-series boards are all capable SBCs that ship with Fedora Linux—but
    the hardware itself is just one part of their integrated ecosystem. They’re hoping
    you’ll opt to use their cloud services too.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个所谓端到端产品提供的例子是三星的ARTIK平台。你可以单独使用ARTIK硬件“模块”之一——它们的5系列、7系列和10系列板都是具备能力的SBC，随Fedora
    Linux发行版发货——但硬件本身只是它们集成生态系统的一部分。他们希望你会选择使用他们的云服务。
- en: This is a deep ocean to dive into. It can be overwhelming if you have no familiar
    landmarks against which to chart your voyage, and there’s a painful amount of
    jargon and buzzword business-speak. In an attempt to temper this novel onslaught,
    we won’t start a project from scratch but will instead adapt our old friend, the
    mini weather station with the browser interface, to work on the BeagleBone Black.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个深不可测的领域，如果你没有熟悉的标志来作为你航行的参考，可能会感到不知所措，而且有大量的术语和商业术语。为了减轻这种新颖的冲击，我们不会从头开始一个项目，而是将我们的老朋友，具有浏览器界面的迷你气象站，适配到BeagleBone
    Black上。
- en: We’ll take the same weather-station application code—with some minor tweaks—but
    instead of working directly on the device to manage the OS and run the app code,
    we’ll have resin.io do that work for us.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的气象站应用程序代码——进行一些小的调整——但不是直接在设备上操作来管理操作系统和运行应用程序代码，我们将让resin.io为我们完成这项工作。
- en: 12.2\. Containerized deployment with resin.io
  id: totrans-1059
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 使用resin.io进行容器化部署
- en: '|  |'
  id: totrans-1060
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-1061
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要的东西
- en: '![](note.jpg)'
  id: totrans-1062
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 BeagleBone Black and power supply
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1块BeagleBone Black和电源
- en: 1 Ethernet cable
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1根以太网线
- en: 1 microSD card and adapter
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1张microSD卡和适配器
- en: 1 breadboard
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1块面包板
- en: 1 BMP180 multisensor breakout board
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1块BMP180多传感器扩展板
- en: Jumper wires
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: '|  |'
  id: totrans-1069
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Resin.io ([https://resin.io/](https://resin.io/)) is a service that offers *containerized*
    deployment to and management of internet-connected, *provisioned* Linux IoT devices.
    That’s a mouthful—there’s some of that jargon I warned you about—so let’s unpack
    it by coming at it from the angle of what problems services like resin.io are
    actually trying to solve.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: Resin.io ([https://resin.io/](https://resin.io/))是一个提供将互联网连接的、已配置的Linux物联网设备进行*容器化*部署和管理的服务。这听起来有些复杂——这就是我之前警告过的一些术语——所以让我们从它试图解决的实际问题角度来解释它。
- en: Recall from [chapter 11](kindle_split_021.html#ch11) that SBCs (like the BeagleBone
    Black) are typically capable of running various flavors of Linux, but that the
    tradeoff for such flexibility is that the installation and administration of Linux
    can add some overhead (and pain) to an SBC-based workflow. Getting code files
    onto a device from your preferred development environment (such as your laptop)
    can be a chore. Managing environment settings and configuration can be a headache.
    You may have an itch to work iteratively, using familiar software development
    methodologies and tools (such as Git for version control) and collaborating with
    other devs. Getting that all set up piecemeal can take time and energy, or it
    may even stump you entirely.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第11章](kindle_split_021.html#ch11)，SBC（如BeagleBone Black）通常能够运行各种Linux版本，但为了这种灵活性所付出的代价是，Linux的安装和管理可能会给基于SBC的工作流程增加一些开销（和痛苦）。从你首选的开发环境（如你的笔记本电脑）将代码文件上传到设备上可能是一项繁琐的工作。管理环境设置和配置可能是一个头疼的问题。你可能渴望迭代性地工作，使用熟悉的软件开发方法和工具（如Git进行版本控制）并与其他开发者协作。逐一设置所有这些可能需要时间和精力，或者甚至可能让你完全不知所措。
- en: 'Now imagine that your IoT application needs to run not just on one BeagleBone
    (or Pi, or other SBC) but on an entire fleet of them, possibly scattered geographically
    across states, provinces, countries. Keeping tabs on the devices, keeping things
    in sync, sending the right version of the code to each device, monitoring devices
    for failures, pushing out OS or security updates—doing all of this manually isn’t
    going to scale well. Then there are all of those requirements for software and
    hardware products that are used by real people: analytics (how much use has a
    particular device been getting?), security (let’s make sure we’re uploading that
    user’s heart rate over a secure connection!), and so on.'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，如果你的物联网应用程序不仅需要在单个 BeagleBone（或 Pi，或其他 SBC）上运行，还需要在可能散布在州、省、国家地理分布的整个机队上运行。跟踪设备、保持同步、向每个设备发送正确的代码版本、监控设备故障、推送操作系统或安全更新——手动完成所有这些工作不会很好地扩展。然后还有所有那些由真实用户使用的软件和硬件产品的要求：分析（特定设备的使用量是多少？）、安全性（让我们确保用户的心率通过安全连接上传！），等等。
- en: 'There’s a lot going on here. To accomplish much of it, resin.io (and some other
    similar services) employ several key strategies:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中。为了完成其中许多事情，resin.io（以及一些其他类似的服务）采用了几个关键策略：
- en: '***Containerization*—** The key idea here is that you want the same application
    to run in the same way on each of your devices. Resin.io uses Docker containers
    to package applications and their dependencies cleanly and reliably. Your app’s
    container gets deployed to each of your provisioned devices.'
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***容器化*—** 这里关键的想法是，你希望同样的应用程序在每一台设备上以相同的方式运行。Resin.io 使用 Docker 容器来干净、可靠地打包应用程序及其依赖项。你的应用程序容器将被部署到每个已配置的设备上。'
- en: '***Provisioning*—** A given device needs to be able to get a hold of resin.io,
    identify itself, and receive application updates. To accomplish this, you download
    a custom disk image from resin.io and boot each device from it. Once a device
    has been successfully provisioned, it will appear on the web dashboard for the
    associated resin.io app, as you’ll see shortly.'
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***配置*—** 某个设备需要能够获取 resin.io，识别自己，并接收应用程序更新。为了实现这一点，你需要从 resin.io 下载一个自定义磁盘镜像，并从它启动每个设备。一旦设备成功配置，它将出现在关联的
    resin.io 应用程序的网页仪表板上，正如你很快就会看到的。'
- en: '***Version control integration*—** Pushing code to a particular remote of a
    specified Git repository automatically triggers redeployment of the application
    to all connected, provisioned devices. Part of setting up a resin.io project is
    defining which Git repository to use as the application source.'
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***版本控制集成*—** 将代码推送到指定的 Git 仓库的特定远程位置会自动触发应用程序在所有连接的、已配置的设备上的重新部署。设置 resin.io
    项目的部分工作是定义要使用哪个 Git 仓库作为应用程序源。'
- en: '|  |'
  id: totrans-1077
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Containers, containers, containers!**'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器，容器，容器！**'
- en: You can’t swing a cat on the internet these days without running into someone
    who’s saying something (usually vague, but almost always laudatory) about containers.
    You’ll read that containers are the greatest solution ever for app deployment,
    for security, for performance, for ensuring world peace, and so on, but what’s
    harder to track down is an explanation of what the heck a container is and what
    it, in real terms, does.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在互联网上，你几乎无法避免遇到某人在说关于容器的事情（通常含糊不清，但几乎总是赞誉有加）。你会读到容器是应用程序部署、安全性、性能、确保世界和平等问题的最佳解决方案，但更难找到的是关于容器究竟是什么以及它在实际中做什么的解释。
- en: A container serves both to encapsulate and isolate an application and the bits
    and bobs it requires to function correctly (dependencies, settings, and the like).
    A single server or computing device may run numerous separate containers at the
    same time without them interfering with each other. Likewise, the same container
    can be deployed to a whole bunch of different computers, and—because the container
    holds all of the things needed to define the app’s environment as well as all
    of its dependencies—you can feel confident that the app will behave the same way
    on each of the different devices.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 容器既用于封装和隔离应用程序及其正常运行所需的组件（依赖项、设置等）。单个服务器或计算设备可以同时运行多个独立的容器，而不会相互干扰。同样，相同的容器可以被部署到许多不同的计算机上，因为容器包含了定义应用程序环境及其所有依赖项所需的所有东西——因此，你可以确信应用程序将在不同的设备上以相同的方式运行。
- en: Resin.io uses Docker containers. Docker is both the name of a particular containerization
    technology platform and the company that created it. Docker is, by far, the most
    popular container technology in the industry.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: Resin.io使用Docker容器。Docker是特定容器化技术平台的名字，也是创建该平台的公司。Docker是目前行业中最受欢迎的容器技术。
- en: '|  |'
  id: totrans-1082
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once a resin.io project and its devices are set up, you can develop your app
    iteratively. When you push changes to your resin.io Git remote, resin.io rebuilds
    your application’s container with the updated code and deploys that container
    to all of the connected, provisioned devices for that app, wherever they may be
    ([figure 12.2](#ch12fig02)).
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了resin.io项目和其设备，您就可以迭代地开发您的应用程序。当您将更改推送到您的resin.io Git远程仓库时，resin.io会使用更新的代码重新构建应用程序的容器，并将该容器部署到所有连接的、已配置的应用程序设备上，无论它们在哪里（[图12.2](#ch12fig02)）。
- en: Figure 12.2\. Devices that will run the application are provisioned by installing
    and booting a custom-tailored resin.io OS image on each. Pushing application code
    to a project-specific resin.io Git remote triggers the rebuilding of the app’s
    container and its redeployment to connected, provisioned devices.
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.2\. 运行应用程序的设备通过在每个设备上安装和启动定制的resin.io OS镜像进行配置。将应用程序代码推送到特定项目的resin.io Git远程仓库会触发应用程序容器的重新构建和重新部署到所有连接的、已配置的设备。
- en: '![](12fig02_alt.jpg)'
  id: totrans-1085
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig02_alt.jpg)'
- en: '|  |'
  id: totrans-1086
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Git-ting up to speed
  id: totrans-1087
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速掌握Git
- en: Code for your resin.io application will be managed within a Git repository—you’ll
    need to have Git installed on your computer. The “Installing Git” section on the
    git-scm website documents how to do this on several different platforms ([https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)).
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 您的resin.io应用程序代码将在Git仓库中管理——您需要在您的计算机上安装Git。git-scm网站上的“安装Git”部分记录了如何在多个不同的平台上完成此操作([https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git))。
- en: Although the instructions for building a resin.io app include all of the Git
    commands you’ll need to get an app up and running on a BeagleBone Black, a working
    knowledge of Git should be part of every dev’s mental toolbox. It takes minutes
    to learn the Git basics (though, honestly, a lifetime to master). GitHub has an
    interactive tutorial ([https://try.github.io/levels/1/challenges/1](https://try.github.io/levels/1/challenges/1)),
    and there are copious other online Git-education resources—many of them free.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然构建resin.io应用程序的说明中包含了您在BeagleBone Black上启动应用程序所需的全部Git命令，但了解Git的基本知识应该是每个开发者心理工具箱的一部分。学习Git基础知识只需要几分钟（尽管，说实话，精通Git需要一生的时间）。GitHub有一个交互式教程([https://try.github.io/levels/1/challenges/1](https://try.github.io/levels/1/challenges/1))，还有大量的其他在线Git教育资源——其中许多是免费的。
- en: '|  |'
  id: totrans-1090
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.2.1\. Creating a resin.io application
  id: totrans-1091
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1\. 创建resin.io应用程序
- en: You’re going to create a resin.io app for your weather station software, for
    deployment to your BeagleBone Black. Resin.io offers a free tier that allows deployment
    and management for up to five devices. Head on over to [https://resin.io/](https://resin.io/)
    and create an account ([figure 12.3](#ch12fig03)).
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 您将为您的气象站软件创建一个resin.io应用程序，用于部署到您的BeagleBone Black。Resin.io提供了一个免费层，允许最多五个设备的部署和管理。前往[https://resin.io/](https://resin.io/)创建一个账户（[图12.3](#ch12fig03)）。
- en: Figure 12.3\. Sign up for an account at resin.io.
  id: totrans-1093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.3\. 在resin.io上注册账户。
- en: '![](12fig03_alt.jpg)'
  id: totrans-1094
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig03_alt.jpg)'
- en: Next, create an application. You’ll be prompted for a name and a device type
    for your application. You can name it whatever you like—I called mine `beagleweather`.
    For the Device Type field, select `BeagleBone Black` from the long list of options
    ([figure 12.4](#ch12fig04)).
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个应用程序。系统会提示您输入应用程序的名称和设备类型。您可以根据喜好命名，我将其命名为`beagleweather`。在设备类型字段中，从长长的选项列表中选择`BeagleBone
    Black`（[图12.4](#ch12fig04)）。
- en: '|  |'
  id: totrans-1096
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: No BeagleBone Black?
  id: totrans-1097
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 没有BeagleBone Black？
- en: No BeagleBone Black on hand? You can use a Raspberry Pi instead, if you like.
    You’ll need to use the Pi version of the weather application code (find it in
    the chapter-11 folder of the book’s GitHub repository)—with the `raspi-io` I/O
    plugin—but otherwise the steps should be the same. Oh, and, of course, make sure
    to select `Raspberry Pi 3` instead of `BeagleBone Black` as the Device Type for
    your resin.io application.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 没有手头的BeagleBone Black？如果您愿意，可以使用Raspberry Pi代替。您需要使用Pi版本的天气应用程序代码（在书籍GitHub仓库的第11章文件夹中找到）——带有`raspi-io`
    I/O插件——但其他步骤应该相同。哦，当然，确保在选择resin.io应用程序的设备类型时选择`Raspberry Pi 3`而不是`BeagleBone
    Black`。
- en: '|  |'
  id: totrans-1099
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 12.4\. Detail of application-creation step showing the list of supported
    device types
  id: totrans-1100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.4\. 应用程序创建步骤的详细图，显示了支持的设备类型列表
- en: '![](12fig04.jpg)'
  id: totrans-1101
  prefs: []
  type: TYPE_IMG
  zh: '![12fig04.jpg](12fig04.jpg)'
- en: 12.2.2\. Provisioning the BeagleBone Black
  id: totrans-1102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2\. 配置BeagleBone Black
- en: Resin.io generates a custom *OS image* for every project. The resin.io OS is
    a lightweight Linux. It can run your app’s Docker container, and it also takes
    care of housekeeping jobs like provisioning the device and keeping an eye out
    for deployed updates.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: Resin.io为每个项目生成一个定制的*操作系统镜像*。resin.io操作系统是一个轻量级的Linux。它可以运行你的应用程序的Docker容器，并且还负责一些日常维护工作，如配置设备和监视部署的更新。
- en: 'Once you’ve defined your resin.io application, you can go ahead and download
    the generated OS image (there’s a link provided, as shown in [figure 12.5](#ch12fig05))
    and install it on your devices (or, in our case, a single *device*). See [section
    11.2.3](kindle_split_021.html#ch11lev2sec6) in [chapter 11](kindle_split_021.html#ch11)
    for more details on the steps here:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你定义了你的resin.io应用程序，你可以继续下载生成的操作系统镜像（如图12.5所示提供了链接）并在你的设备上安装它（或者在我们的情况下，单个*设备*）。有关此处步骤的更多详细信息，请参阅[第11章11.2.3节](kindle_split_021.html#ch11lev2sec6)： '
- en: Download the OS image.
  id: totrans-1105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载操作系统镜像。
- en: Using the Etcher app, burn the IMG file to the microSD card.
  id: totrans-1106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Etcher应用程序，将IMG文件烧录到microSD卡上。
- en: Insert the microSD card into the BeagleBone Black and connect the BeagleBone
    Black’s Ethernet interface to your router.
  id: totrans-1107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入BeagleBone Black，并将BeagleBone Black的以太网接口连接到你的路由器。
- en: Hold down the USER/BOOT button ([figure 12.6](#ch12fig06)) and plug power into
    the BeagleBone Black. Keep holding down the button until the LEDs start blinking
    madly. Release the button.
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住USER/BOOT按钮（[图12.6](#ch12fig06)），并将电源插入BeagleBone Black。继续按住按钮，直到LED灯疯狂闪烁。然后释放按钮。
- en: Figure 12.5\. Detail of the resin.io project dashboard during the provisioning
    process for a BeagleBone Black device. The device, automatically named “red-night”
    by resin.io, is midway through installing the app-specific resin.io OS image.
  id: totrans-1109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.5\. resin.io项目仪表板在为BeagleBone Black设备配置过程中的详细图。该设备由resin.io自动命名为“red-night”，正在安装特定于应用程序的resin.io操作系统镜像。
- en: '![](12fig05_alt.jpg)'
  id: totrans-1110
  prefs: []
  type: TYPE_IMG
  zh: '![12fig05_alt.jpg](12fig05_alt.jpg)'
- en: Figure 12.6\. Hold down the BeagleBone Black’s BOOT/USER button to boot from
    the SD card.
  id: totrans-1111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.6\. 按住BeagleBone Black的BOOT/USER按钮从SD卡启动。
- en: '![](12fig06_alt.jpg)'
  id: totrans-1112
  prefs: []
  type: TYPE_IMG
  zh: '![12fig06_alt.jpg](12fig06_alt.jpg)'
- en: Back at your own computer, you should see the device show up on your resin.io
    application’s dashboard after a few moments. From the dashboard, you’ll be able
    to track the device’s progress through the provisioning process.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你的电脑上，几秒钟后你应该能在resin.io应用程序的仪表板上看到设备。从仪表板，你可以跟踪设备在配置过程中的进度。
- en: 12.2.3\. Adapting the weather application software
  id: totrans-1114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.3\. 适配天气应用程序软件
- en: 'To get the weather app software running on the provisioned BeagleBone Black,
    there are a few more steps:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 要在配置好的BeagleBone Black上运行天气应用程序软件，还需要进行几个额外的步骤：
- en: Set up and configure a Git repository for the app.
  id: totrans-1116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序设置和配置Git仓库。
- en: Configure the Docker container for the app.
  id: totrans-1117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置应用程序的Docker容器。
- en: Define a script to start the app (in package.json).
  id: totrans-1118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个脚本以启动应用程序（在package.json中）。
- en: Make a couple of tweaks to the software itself.
  id: totrans-1119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对软件本身进行一些调整。
- en: Commit and push to GitHub.
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交并推送到GitHub。
- en: Give the app a public URL.
  id: totrans-1121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序提供一个公开的URL。
- en: Initializing a Git repository
  id: totrans-1122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化Git仓库
- en: First you need to establish a working area. Create a directory to contain the
    project (`beagleweather`, perhaps?) on your computer.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要建立一个工作区域。在你的电脑上创建一个目录来存放项目（例如`beagleweather`？）。
- en: 'Inside of this directory, initialize a Git repository by running this command:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录内，通过运行以下命令初始化一个Git仓库：
- en: '[PRE90]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To deploy your application, you need to be able to push your repository’s master
    branch to resin.io. You’ll need to add a resin.io-specific Git remote so that
    you can push to resin.io later. Resin.io conveniently shows you the exact command
    you need to run to get this remote set up: find it at the top right of the dashboard
    for your application. Execute the displayed command in your local repository ([figure
    12.7](#ch12fig07)).'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署你的应用程序，你需要能够将你的仓库的master分支推送到resin.io。你需要添加一个resin.io特定的Git远程，以便以后可以推送到resin.io。resin.io方便地显示了你需要运行的精确命令来设置此远程：在你的应用程序仪表板的右上角找到它。在你的本地仓库中执行显示的命令（[图12.7](#ch12fig07)）。
- en: Figure 12.7\. Detail of resin.io application dashboard showing where to find
    the command for adding your application’s resin.io Git remote
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.7\. resin.io应用程序仪表板的详细图，显示了添加应用程序的resin.io Git远程的命令位置
- en: '![](12fig07_alt.jpg)'
  id: totrans-1128
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig07_alt.jpg)'
- en: 'You can see all of your repository’s remotes by running this command:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行此命令来查看你仓库的所有远程：
- en: '[PRE91]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You should see output something like this:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下输出：
- en: '[PRE92]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Next, copy the source files from the original BeagleBone weather application
    to your new working Git project directory—index.js, package.json, and the app
    directory and its contents.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将原始 BeagleBone 天气应用程序的源文件从复制到你的新工作 Git 项目目录中——index.js、package.json 以及应用目录及其内容。
- en: Defining the Docker app container
  id: totrans-1134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义 Docker 应用容器
- en: The base resin.io OS for your application that’s now running on your BeagleBone
    Black consists of a stripped-down Linux and also contains some helpful, supporting
    tools. But you still need to create the Docker container that will run on your
    app’s device(s) and tell it how to behave and what to do.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行在你 BeagleBone Black 上的应用程序的基础 resin.io OS 由一个精简的 Linux 系统组成，并包含一些有用的支持工具。但你需要创建一个将在你的应用设备上运行的
    Docker 容器，并告诉它如何表现以及做什么。
- en: Create a file called Dockerfile.template in your project directory (the “template”
    extension allows the use of certain handy variables inside the file) and add the
    contents shown in the following listing. Most of the listing is boilerplate, sourced
    directly from resin.io’s documentation.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录中创建一个名为 Dockerfile.template 的文件（“template”扩展名允许在文件中使用某些方便的变量）并添加以下列表中的内容。列表的大部分是样板代码，直接来自
    resin.io 的文档。
- en: Listing 12.1\. Dockerfile.template
  id: totrans-1137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1\. Dockerfile.template
- en: '[PRE93]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* Uses a base image with Node.js, version 6**'
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用带有 Node.js，版本 6 的基础镜像**'
- en: '***2* You’ll need to define an npm start script that starts your application.**'
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你需要定义一个 npm start 脚本来启动你的应用程序。**'
- en: '|  |'
  id: totrans-1141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: More about resin.io machine names, base images, and tags
  id: totrans-1142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更多关于 resin.io 主机名、基础镜像和标签的信息
- en: Inside of resin.io Dockerfiles, you can specify a lot of details about devices,
    features, and Linux distributions and versions. There’s too much to go into here,
    but if you’re curious about this stuff, the resin.io documentation is thorough
    ([https://docs.resin.io/raspberrypi/nodejs/getting-started/](https://docs.resin.io/raspberrypi/nodejs/getting-started/)).
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 resin.io 的 Dockerfile 中，你可以指定关于设备、功能和 Linux 发行版和版本的大量详细信息。这里的内容太多，但如果你对此类内容感兴趣，resin.io
    的文档非常详尽 ([https://docs.resin.io/raspberrypi/nodejs/getting-started/](https://docs.resin.io/raspberrypi/nodejs/getting-started/))。
- en: '|  |'
  id: totrans-1144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Adding an npm start script
  id: totrans-1145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加 npm start 脚本
- en: 'This line appears at end of the Dockerfile.template configuration:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码出现在 Dockerfile.template 配置的末尾：
- en: '[PRE94]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This tells the builder to run the command `npm start` once the container is
    started. You don’t have a `start` script yet, but you can easily add one by editing
    package.json.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉构建器在容器启动后运行命令 `npm start`。你还没有 `start` 脚本，但你可以通过编辑 package.json 来轻松添加一个。
- en: Edit the `scripts` field in package.json so that it looks like the following
    listing.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 package.json 中的 `scripts` 字段，使其看起来像以下列表。
- en: Listing 12.2\. Package.json scripts
  id: totrans-1150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. package.json 脚本
- en: '[PRE95]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Now when the build process runs the command `npm start`, it will have the same
    effect as executing `node index.js`—it will start up your weather application.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当构建过程运行 `npm start` 命令时，它将产生与执行 `node index.js` 相同的效果——它将启动你的天气应用程序。
- en: Tweaking the app code
  id: totrans-1153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调整应用代码
- en: There are two small changes to make to index.js before you’re done.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成之前，你需要对 index.js 进行两个小的修改。
- en: 'Johnny-Five’s REPL and resin.io don’t get along. You can disable the REPL easily,
    by adding a property to the board-instantiation options object (`repl: false`).'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 'Johnny-Five 的 REPL 和 resin.io 不兼容。你可以通过向板子实例化选项对象中添加一个属性 (`repl: false`) 来轻松禁用
    REPL。'
- en: Listing 12.3\. Disable Johnny-Five REPL
  id: totrans-1156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. 禁用 Johnny-Five REPL
- en: '[PRE96]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The existing port defined for the web server (`4000`) in `server.listen()` would
    work fine, but there’s a really nifty trick you’re going to pull off momentarily,
    so change the port to `80`.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server.listen()` 中为 Web 服务器定义的现有端口（`4000`）将正常工作，但你将执行一个很酷的技巧，所以将端口更改为 `80`。
- en: Listing 12.4\. Change web server port to 80
  id: totrans-1159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.4\. 将 Web 服务器端口更改为 80
- en: '[PRE97]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Committing and pushing
  id: totrans-1161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提交和推送
- en: 'Add and commit the project files to Git (make sure you’re in the project’s
    top-level directory):'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目文件添加到 Git 中（确保你处于项目的顶级目录）：
- en: '[PRE98]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now push to trigger the deployment to your BeagleBone Black:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，推送以触发到你的 BeagleBone Black 的部署：
- en: '[PRE99]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The first time you do this, it will take several minutes (it’s faster subsequently).
    You can track the progress on your resin.io dashboard ([figure 12.8](#ch12fig08)).
    You’ll be able to view the app in a browser on your computer at its local IP address.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次这样做时，可能需要几分钟（之后会更快）。您可以在resin.io仪表板上跟踪进度（[图12.8](#ch12fig08)）。您将能够在计算机上的浏览器中查看应用，并使用其本地IP地址。
- en: Figure 12.8\. Resin.io application dashboard during deployment
  id: totrans-1167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.8. 部署期间的Resin.io应用仪表板
- en: '![](12fig08_alt.jpg)'
  id: totrans-1168
  prefs: []
  type: TYPE_IMG
  zh: '![12fig08_alt.jpg](12fig08_alt.jpg)'
- en: To iterate on your app, you can make changes in your local repository, commit,
    and push as often as you need to.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代您的应用，您可以在本地仓库中做出更改，提交，并根据需要频繁地推送。
- en: Giving your app a public URL
  id: totrans-1170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为您的应用提供公共URL
- en: You’ve been building a lot of web-based interfaces for your gadgets, but so
    far you’ve only been able to visit your web applications from the same network.
    Resin.io has a nifty feature that will generate a public URL for a device, allowing
    external access to port 80 on that device (now you know why you changed the port
    number!).
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经为您的设备构建了许多基于Web的界面，但到目前为止，您只能从同一网络访问您的Web应用。Resin.io有一个很酷的功能，可以为设备生成一个公共URL，允许外部访问该设备的80端口（现在您知道为什么您更改了端口号了！）。
- en: To enable public URLs for the application as a whole, head to the Actions section
    from your application’s dashboard ([figure 12.9](#ch12fig09)).
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 要为整个应用启用公共URL，请从应用的仪表板中的操作部分进入（[图12.9](#ch12fig09)）。
- en: Figure 12.9\. Enable public URLs for your application from the application’s
    Actions tab.
  id: totrans-1173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.9. 从应用的操作选项卡中启用应用的公共URL
- en: '![](12fig09_alt.jpg)'
  id: totrans-1174
  prefs: []
  type: TYPE_IMG
  zh: '![12fig09_alt.jpg](12fig09_alt.jpg)'
- en: Next, get into a device-specific view by navigating to the Devices section and
    clicking on the name of the device you’d like to manage—*red-night* in my case
    ([figure 12.10](#ch12fig10)).
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过导航到设备部分并点击您想要管理的设备名称（在我的情况下是*red-night*）来进入设备特定的视图（[图12.10](#ch12fig10)）。
- en: Figure 12.10\. See the public URL for a device by navigating to the device-specific
    Actions tab.
  id: totrans-1176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.10. 通过导航到设备特定的操作选项卡来查看设备的公共URL。
- en: '![](12fig10_alt.jpg)'
  id: totrans-1177
  prefs: []
  type: TYPE_IMG
  zh: '![12fig10_alt.jpg](12fig10_alt.jpg)'
- en: Head to the Actions section again—these are actions for just this device instead
    of the whole application. You should be able to see—and, helpfully, click on—the
    public URL for your application running on your BeagleBone Black ([figure 12.11](#ch12fig11)).
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次前往操作部分——这些操作仅针对此设备，而不是整个应用。您应该能够看到——并且，方便的是，可以点击——在您的BeagleBone Black上运行的应用的公共URL（[图12.11](#ch12fig11)）。
- en: Figure 12.11\. The weather station app, running on a BeagleBone Black, accessed
    by a resin .io-generated public URL
  id: totrans-1179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.11. 运行在BeagleBone Black上的气象站应用，通过由resin.io生成的公共URL访问
- en: '![](12fig11_alt.jpg)'
  id: totrans-1180
  prefs: []
  type: TYPE_IMG
  zh: '![12fig11_alt.jpg](12fig11_alt.jpg)'
- en: 12.3\. Hardware and the web browser
  id: totrans-1181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 硬件和网页浏览器
- en: The weather station application takes advantage of a relatively modern web API,
    WebSockets (more accurately, it uses `socket.IO`, which uses the WebSockets API
    in browsers that support it). This API is used to maintain a connection between
    the client (browser) and server (running on the BeagleBone Black, in this case).
    The server is able to emit updated sensor data that the client can “hear” and
    process accordingly. But that’s still indirect—the browser relies on the server
    to handle the actual interaction with the BeagleBone Black’s I/O and attached
    sensor. Is it possible to interact with hardware, directly, from within the browser
    itself?
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 气象站应用利用了一个相对现代的Web API，WebSocket（更准确地说，它使用`socket.IO`，该库在支持WebSocket的浏览器中使用WebSocket
    API）。此API用于在客户端（浏览器）和服务器（在本例中运行在BeagleBone Black上）之间保持连接。服务器能够发出更新的传感器数据，客户端可以“听到”并相应地处理。但这仍然是间接的——浏览器依赖于服务器来处理与BeagleBone
    Black的I/O和附加传感器的实际交互。是否有可能在浏览器本身直接与硬件交互？
- en: The answer is complex—a combination of “it depends” and “in some browsers,”
    with a hefty dose of “wait and see just a bit longer.”
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是复杂的——是“视情况而定”和“在某些浏览器中”的结合，还包含大量的“再稍等一会儿”。
- en: The web is, without doubt, a much more physically capable platform than it was
    just a few years ago. It wasn’t that long ago that you’d have to create a native
    application to be able to access a mobile device’s location services or its camera,
    or to send push notifications. Now all of that can be done in the browser.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，与几年前相比，网络在物理能力上要强大得多。不久前，您必须创建一个本地应用才能访问移动设备的位置服务或其摄像头，或发送推送通知。现在所有这些都可以在浏览器中完成。
- en: 'The web platform is a (vast) collection of technologies and APIs. Sure, there
    are the headlining stars—HTML, ECMAScript, and CSS (though, technically, CSS isn’t
    one thing but a collection of *modules*)—but there are also dozens and dozens
    of other pieces: Web Workers, WebGL, XMLHttpRequest, Web Audio, WebSocket, WebRTC
    (I could go on all day). Different technologies and APIs are at different stages
    in the standardization process, and some aren’t technically on the standards track
    at all, yet.'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 网络平台是一个（庞大的）技术集合和 API。当然，有那些明星技术——HTML、ECMAScript 和 CSS（尽管技术上 CSS 不是一个单一的东西，而是一系列
    *模块*）——但还有成百上千的其他部分：Web Workers、WebGL、XMLHttpRequest、Web Audio、WebSocket、WebRTC（我可以一直列举下去）。不同的技术和
    API 在标准化过程中处于不同的阶段，有些甚至根本不在标准轨道上。
- en: 12.3.1\. The Web Bluetooth API
  id: totrans-1186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1\. Web Bluetooth API
- en: The Web Bluetooth API allows for interaction with Bluetooth Low Energy (BLE)
    devices via the Generic Attribute Profile (GATT). There’s an active community
    group for Web Bluetooth on the W3C (the World Wide Web Consortium, the main body
    that develops web standards), and it’s implemented in some versions of Chrome,
    Opera, and the Android browser. But it’s neither a standard nor even on the standards
    track yet (though it is headed in that general direction). It’s complicated.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: Web Bluetooth API 允许通过通用属性配置文件（GATT）与蓝牙低功耗（BLE）设备进行交互。在 W3C（万维网联盟，负责制定网络标准的主体）上有一个活跃的
    Web Bluetooth 社区小组，并且它在 Chrome、Opera 和 Android 浏览器的一些版本中得到了实现。但它既不是标准，甚至还没有进入标准轨道（尽管它正朝着这个方向前进）。这很复杂。
- en: 'Web Bluetooth has also hit a snag typical of web-hardware APIs: security concerns.
    It doesn’t take a genius to conjure up a few visions of how physical devices exposed
    to the web could pose a security nightmare. At this point, Mozilla (Firefox) isn’t
    pursuing Web Bluetooth implementation because it’s dissatisfied with the (current)
    security model.'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: Web Bluetooth 也遇到了典型的网络硬件 API 的障碍：安全问题。不需要天才就能想象出一些物理设备暴露在网络上可能带来的安全噩梦。到目前为止，Mozilla（Firefox）没有追求
    Web Bluetooth 的实现，因为它对（当前的）安全模型不满意。
- en: But lest this sound bleak, these struggles are’t atypical of proposed standards.
    It’s just hard to predict where Web Bluetooth will be in six months or two years.
    And you can—and will—use it today in Chrome.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 但别让这听起来很悲观，这些挑战对于提议的标准来说并不典型。只是很难预测 Web Bluetooth 在六个月或两年后会是什么样子。而且你今天就可以在 Chrome
    中使用它。
- en: 12.3.2\. The Generic Sensor API
  id: totrans-1190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2\. 通用传感器 API
- en: Web Bluetooth isn’t the only nascent, hardware-related web API in town (though
    it does have the most complete browser implementations at this point). The W3C’s
    Device and Sensors Working Group ([https://www.w3.org/2009/dap/](https://www.w3.org/2009/dap/))
    is tasked with creating APIs that “interact with device hardware, sensors, services
    and applications such as the camera, microphone, proximity sensors, native address
    books, calendars and native messaging applications.”
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: Web Bluetooth 不是镇上唯一的初出茅庐的、与硬件相关的网络 API（尽管它目前拥有最完整的浏览器实现）。W3C 的设备和传感器工作组（[https://www.w3.org/2009/dap/](https://www.w3.org/2009/dap/))
    负责创建与设备硬件、传感器、服务以及如相机、麦克风、接近传感器、原生地址簿、日历和原生消息应用等应用程序交互的 API。
- en: The group’s Generic Sensor API ([https://www.w3.org/TR/generic-sensor/](https://www.w3.org/TR/generic-sensor/)),
    currently in draft stage, defines an abstract `Sensor` base class, which does
    nothing on its own but is intended to be extended by component-specific APIs.
    An example of this is the Ambient Light Sensor API (also a draft, [https://www.w3.org/TR/ambient-light/](https://www.w3.org/TR/ambient-light/)),
    which defines an interface—based on `Sensor`—for interacting with ambient light
    sensors. If you review the specs’ details, it may come as no surprise that one
    of the editors of the generic and other sensor APIs is Rick Waldron—the inventor
    of Johnny-Five. There are certainly aspects of the API’s component-behavior encapsulation
    that are in harmony with how Johnny-Five abstracts behavior.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 该小组的通用传感器 API（[https://www.w3.org/TR/generic-sensor/](https://www.w3.org/TR/generic-sensor/))，目前处于草案阶段，定义了一个抽象的
    `Sensor` 基类，它本身并不做任何事情，但旨在被特定组件的 API 扩展。一个例子是环境光传感器 API（也是一个草案，[https://www.w3.org/TR/ambient-light/](https://www.w3.org/TR/ambient-light/))），它定义了一个基于
    `Sensor` 的接口，用于与环境光传感器交互。如果你审查了规范细节，可能不会感到惊讶，因为通用和其他传感器 API 的编辑之一是 Rick Waldron——Johnny-Five
    的发明者。API 的组件行为封装确实与 Johnny-Five 抽象行为的方式相协调。
- en: These APIs aren’t concerned with the nuts and bolts of how hardware is detected
    and connected to so much as defining a higher-level API for interacting with components.
    As such, early implementations of Ambient Light Sensor rely on the presence of
    built-in hardware (typically a device’s camera), and on the browser exposing that
    hardware accordingly. Ambient Light Sensor is available (behind a flag—you have
    to explicitly enable it within the browser’s settings) in Chrome and in Microsoft
    Edge.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 API 并不关心硬件检测和连接的细节，更多的是定义一个高级 API 来与组件交互。因此，早期实现的周围光传感器依赖于内置硬件的存在（通常是设备的摄像头），以及浏览器相应地公开该硬件。周围光传感器在
    Chrome 和 Microsoft Edge 中可用（在标志后面——您必须在浏览器的设置中明确启用它）。
- en: 12.3.3\. The Physical Web
  id: totrans-1194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.3\. 物理网
- en: 'The Physical Web is a discovery service that greatly simplifies interacting
    with objects via simple Bluetooth LE beacons, taking advantage of one of the greatest
    gifts the web gives us: the URL.'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 物理网是一种发现服务，极大地简化了通过简单的蓝牙低功耗信标与对象交互，利用了网络给予我们的一项伟大礼物：URL。
- en: We looked at the Physical Web briefly way back in [chapter 1](kindle_split_008.html#ch01).
    The scenario envisioned there was of a beacon-enabled bus stop. The beacon constantly
    broadcasts a URL that corresponds to a page where the next bus arrivals can be
    tracked ([figure 12.12](#ch12fig12)).
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在很久以前（[第 1 章](kindle_split_008.html#ch01)）简要地探讨了物理网。当时设想的是具有信标功能的公交车站场景。信标不断广播一个
    URL，该 URL 对应的页面可以追踪下一班公交车的到达情况（[图 12.12](#ch12fig12)）。
- en: Figure 12.12\. With the Physical Web, Bluetooth Low Energy (BLE) beacons attached
    to or embedded in a physical object broadcast a URL pertinent to interacting with
    that device. Nearby users can detect and engage with devices, opening their associated
    web pages in a browser.
  id: totrans-1197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.12\. 在物理网中，附着或嵌入在物理对象上的低功耗蓝牙（BLE）信标广播与该设备交互相关的 URL。附近的用户可以检测并与之互动，在浏览器中打开其关联的网页。
- en: '![](12fig12_alt.jpg)'
  id: totrans-1198
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12](12fig12_alt.jpg)'
- en: Or say you’re walking through a sculpture garden. Some of the works have a beacon
    near or on them, broadcasting a URL to a web page with information about that
    piece and its artist. As you wander, you can see the beacons near you and opt
    to interact with one of them, visiting the URL it’s advertising.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，假设您正在穿过一个雕塑花园。其中一些作品附近或上面有信标，广播一个指向包含该作品及其艺术家信息的网页的 URL。在您漫步时，您可以看到附近的信标，并选择与之互动，访问它所宣传的
    URL。
- en: Google is championing the Physical Web and the related open BLE protocol, Eddystone.
    Because the technical demands are so straightforward—a BLE device merely needs
    to advertise a URL using a certain protocol—the hardware needs are minimal and
    beacon batteries can last a long, long, long time. Apps, available now for Android
    and iOS, allow you to find any beacons near you.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌正在推广物理网及其相关的开放 BLE 协议 Eddystone。因为技术要求非常直接——一个 BLE 设备只需使用某种协议广播一个 URL——所以硬件需求最小，信标电池可以持续很长时间。现在可用的
    Android 和 iOS 应用程序允许您找到您附近的任何信标。
- en: 12.4\. Exploring Bluetooth LE with Puck.js
  id: totrans-1201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4\. 使用 Puck.js 探索蓝牙低功耗
- en: Espruino makes a device that allows you to experiment—today! right now!—with
    Web Bluetooth and the Physical Web. The Puck.js is a button-shaped device that
    runs the Espruino interpreter and communicates using BLE ([figure 12.13](#ch12fig13)).
    You’ll harness that to get hands-on with both Web Bluetooth and the Physical Web.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: Espruino 制造了一种设备，让您可以立即——今天！现在！——实验 Web Bluetooth 和物理网。Puck.js 是一个按钮形状的设备，运行
    Espruino 解释器和通过 BLE 通信（[图 12.13](#ch12fig13)）。您将利用它来亲身体验 Web Bluetooth 和物理网。
- en: Figure 12.13\. Puck.js is a BLE beacon device that—like the Pico—runs the Espruino
    JavaScript interpreter.
  id: totrans-1203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.13\. Puck.js 是一个 BLE 信标设备，它像 Pico 一样运行 Espruino JavaScript 解释器。
- en: '![](12fig13.jpg)'
  id: totrans-1204
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13](12fig13.jpg)'
- en: 12.4.1\. Core features
  id: totrans-1205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1\. 核心功能
- en: 'Puck.js is built around an ultra-low-power Nordic Semiconductor SoC (system
    on a chip) that includes Bluetooth LE and NFC support as well as an ARM Cortex
    M4 CPU that’s not too dissimilar from the Pico’s. Although both the Pico and Puck.js
    run the same underlying Espruino software, Puck.js differs from the Pico in the
    way that you communicate with it: over BLE versus the Pico’s direct USB connection.'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: Puck.js 是基于一款超低功耗的 Nordic Semiconductor SoC（系统级芯片）构建的，该芯片包括蓝牙低功耗和 NFC 支持，以及一个与
    Pico 不太相似的 ARM Cortex M4 CPU。尽管 Pico 和 Puck.js 都运行相同的底层 Espruino 软件，但 Puck.js
    与 Pico 的通信方式不同：通过 BLE 而不是 Pico 的直接 USB 连接。
- en: Puck.js’s onboard components include a built-in magnetometer, thermometer, and
    three LEDs (red, green, blue). The red LED can also be used as an ambient light
    sensor.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: Puck.js的板载组件包括内置磁力计、温度计和三个LED（红色、绿色、蓝色）。红色LED还可以用作环境光传感器。
- en: 'The Puck.js is a 3.3 V device powered by a coin-cell battery. It’s roughly
    comparable to a Pico, though somewhat more constrained: slower clock speed, a
    little less memory, and fewer I/O pins ([figure 12.14](#ch12fig14)).'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: Puck.js是一个由纽扣电池供电的3.3V设备。它大致相当于Pico，尽管有些限制：时钟速度较慢，内存略少，I/O引脚较少（[图12.14](#ch12fig14)）。
- en: Figure 12.14\. Some of Puck.js’s features, as listed on Espruino’s website
  id: totrans-1209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.14\. Espruino网站上列出的Puck.js的一些功能
- en: '![](12fig14_alt.jpg)'
  id: totrans-1210
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig14_alt.jpg)'
- en: Puck.js has a flexible silicone cover. The whole thing can operate as a big
    button, making a tactile click as you press down on it (and activate its built-in
    button).
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: Puck.js有一个灵活的硅胶外壳。整个设备可以作为一个大按钮操作，当您按下它时会产生触觉点击声（并激活其内置按钮）。
- en: 12.4.2\. GPIO features and pinouts
  id: totrans-1212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2\. GPIO功能和引脚排布
- en: Puck.js has various GPIO capabilities, including I²C, PWM, SPI, and ADC ([figure
    12.15](#ch12fig15)). You’ll make use of its onboard hardware (only) in these experiments.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: Puck.js具有各种GPIO功能，包括I²C、PWM、SPI和ADC（[图12.15](#ch12fig15)）。在这些实验中，您将使用其板载硬件（仅限板载硬件）。
- en: Figure 12.15\. A detail of the Puck.js pinout from Espruino.com. Pin D11 can
    sense capacitive input. I²C, SPI, and USART support is available on any pin (there’s
    support for one hardware interface each, but unlimited software support for I²C
    and SPI).
  id: totrans-1214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.15\. Espruino.com上Puck.js引脚排布的细节。引脚D11可以感应电容输入。任何引脚都提供I²C、SPI和USART支持（每个引脚支持一个硬件接口，但对于I²C和SPI，软件支持是无限的）。
- en: '![](12fig15_alt.jpg)'
  id: totrans-1215
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig15_alt.jpg)'
- en: 12.4.3\. Configuration and workflow
  id: totrans-1216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3\. 配置和工作流程
- en: 'Head on over to Espruino’s Puck.js Getting Started Guide: [http://www.espruino.com/Puck.js+Quick+Start](http://www.espruino.com/Puck.js+Quick+Start).
    You’ll need to disassemble the device to remove a protective battery tab.'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 前往Espruino的Puck.js入门指南：[http://www.espruino.com/Puck.js+Quick+Start](http://www.espruino.com/Puck.js+Quick+Start)。您需要拆卸设备以移除保护电池标签。
- en: What happens after that depends on your development platform OS and the state
    of Web Bluetooth at the moment. Chrome on Mac OS supports it—that’s easy. Linux
    users may have an extra step and may need to enable a flag or two in Chrome. Web
    Bluetooth support in Windows (in Chrome) is potentially imminent (mid-2017). Refer
    to the Getting Started Guide for up-to-date information.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 之后会发生什么取决于您的开发平台操作系统和Web蓝牙的当前状态。Mac OS上的Chrome支持它——这很简单。Linux用户可能需要额外一步，可能需要在Chrome中启用一个或两个标志。Windows（在Chrome中）的Web蓝牙支持可能即将到来（2017年中期）。请参阅入门指南以获取最新信息。
- en: If you followed along with the Pico experiments in [chapter 11](kindle_split_021.html#ch11),
    you may have already installed the Espruino Chrome app IDE. If not, don’t worry,
    because you can actually work with Puck.js using the web-based IDE at [https://www.espruino.com/ide](https://www.espruino.com/ide)
    (no installation required). The Web IDE ([figure 12.16](#ch12fig16)) is a spittin’
    image of the Chrome app IDE.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跟随了第11章中的Pico实验，您可能已经安装了Espruino Chrome应用IDE。如果没有，不要担心，因为您实际上可以使用位于[https://www.espruino.com/ide](https://www.espruino.com/ide)的基于Web的IDE来使用Puck.js（无需安装）。Web
    IDE（[图12.16](#ch12fig16)）与Chrome应用IDE几乎一模一样。
- en: Figure 12.16\. Espruino’s web-based IDE
  id: totrans-1220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.16\. Espruino的基于Web的IDE
- en: '![](12fig16_alt.jpg)'
  id: totrans-1221
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig16_alt.jpg)'
- en: '|  |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you can’t get Web Bluetooth support...
  id: totrans-1223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如果您无法获得Web蓝牙支持...
- en: A browser that supports Web Bluetooth is required for the web-controlled LED
    and remote doorbell experiments later in the chapter. You don’t need Web Bluetooth
    support for the basic Hello World LED blinking, nor for the Physical Web example—Puck.js
    can be controlled from within the IDE for those.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的部分，进行基于Web的LED和远程门铃实验需要支持Web蓝牙的浏览器。对于基本的Hello World LED闪烁，以及Physical Web示例，您不需要Web蓝牙支持——对于这些，Puck.js可以在IDE内部进行控制。
- en: 'You won’t be able to use the web-based IDE at [https://www.espruino.com/ide](https://www.espruino.com/ide)
    if you don’t have Web Bluetooth support. Instead, you’ll need to install the Web
    IDE (see Puck.js’s Getting Started Guide for details: [http://www.espruino.com/Puck.js+Quick+Start](http://www.espruino.com/Puck.js+Quick+Start)).'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有Web蓝牙支持，您将无法使用位于[https://www.espruino.com/ide](https://www.espruino.com/ide)的基于Web的IDE。相反，您需要安装Web
    IDE（有关详细信息，请参阅Puck.js的入门指南：[http://www.espruino.com/Puck.js+Quick+Start](http://www.espruino.com/Puck.js+Quick+Start)）。
- en: '|  |'
  id: totrans-1226
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Recall also from [chapter 11](kindle_split_021.html#ch11) that Espruino code
    authoring involves the use of Espruino modules—encapsulated behavior and support
    that can be imported into Espruino scripts.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得从 [第 11 章](kindle_split_021.html#ch11) 中提到的，Espruino 代码编写涉及使用 Espruino 模块——封装的行为和支持，可以导入到
    Espruino 脚本中。
- en: 'There are three main ways to get Puck.js to do something:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要方式让 Puck.js 做某事：
- en: Once it’s connected, Puck.js will execute any commands typed into the left side
    of the IDE interface, similar to a REPL or console.
  id: totrans-1229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦连接，Puck.js 将执行 IDE 界面左侧输入的任何命令，类似于 REPL 或控制台。
- en: Code written in the right side of the IDE can be uploaded using the send-to-Espruino
    icon.
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE 右侧编写的代码可以使用发送到 Espruino 的图标上传。
- en: Data and commands can be sent to and received from Puck.js over Web Bluetooth.
    This is done within the browser execution context, relying on a small client-side
    JavaScript library provided by Espruino. (This method is unique to Puck.js, unlike
    other Espruino boards.)
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据和命令可以通过 Web Bluetooth 发送到 Puck.js 并从 Puck.js 接收。这是在浏览器执行上下文中完成的，依赖于 Espruino
    提供的少量客户端 JavaScript 库。（这种方法是 Puck.js 独有的，与其他 Espruino 板不同。）
- en: 12.4.4\. Examples, tutorials, and API documentation
  id: totrans-1232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.4\. 示例、教程和 API 文档
- en: Fire up the IDE and connect to your Puck.js so you can try out a Hello World
    LED blink and poke at a few of Puck.js’s features.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 IDE 并连接到你的 Puck.js，这样你就可以尝试 Hello World LED 闪烁并探索 Puck.js 的几个功能。
- en: 'Try typing some of the following commands into the left side of the IDE. After
    you press Enter, the command will sent over BLE to Puck.js and be executed there:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 IDE 的左侧输入以下命令之一。按下 Enter 后，命令将通过 BLE 发送到 Puck.js 并在那里执行：
- en: Turn the red onboard LED on with `LED1.set()`.
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LED1.set()` 打开板载红色 LED。
- en: Turn the red onboard LED off with `LED1.reset()`.
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LED1.reset()` 关闭板载红色 LED。
- en: 'Try the preceding commands with the other two LEDs: `LED2` (green) and `LED3`
    (blue).'
  id: totrans-1237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用其他两个 LED：`LED2`（绿色）和 `LED3`（蓝色）执行前面的命令。
- en: The red LED also serves as an ambient light sensor. Make sure that all of the
    LEDs are off (`LEDx.reset()`), and then try `Puck.light()` to return an ambient
    light reading. Try covering up Puck.js with your hand and sending the `Puck.light()`
    command a second time to see the difference.
  id: totrans-1238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色 LED 还可以作为环境光传感器。确保所有 LED 都已关闭（`LEDx.reset()`），然后尝试使用 `Puck.light()` 来获取环境光读数。尝试用手遮挡
    Puck.js 并第二次发送 `Puck.light()` 命令，以查看差异。
- en: Try `E.getTemperature()` to get a temperature reading. `E` is Espruino’s utility
    class. The temperature should be accurate to about +/-1 degree (Celsius).
  id: totrans-1239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试 `E.getTemperature()` 获取温度读数。`E` 是 Espruino 的实用类。温度应准确到约 +/-1 度（摄氏度）。
- en: Espruino’s API documentation ([http://www.espruino.com/Reference](http://www.espruino.com/Reference))
    covers the API available to all Espruino devices, as well as the Puck-specific
    capabilities exposed on the `Puck` global object.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: Espruino 的 API 文档（[http://www.espruino.com/Reference](http://www.espruino.com/Reference)）涵盖了所有
    Espruino 设备可用的 API，以及 `Puck` 全局对象上公开的 Puck 特定功能。
- en: 12.4.5\. Controlling the LED from a web page
  id: totrans-1241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.5\. 从网页控制 LED
- en: '|  |'
  id: totrans-1242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-1243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要
- en: '![](note.jpg)'
  id: totrans-1244
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Puck.js
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Puck.js
- en: 1 Web Bluetooth–enabled web browser
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个支持 Web Bluetooth 的网络浏览器
- en: '|  |'
  id: totrans-1247
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As you’ve seen, you can control Puck.js by using the IDE: sending it commands
    or writing a script and deploying it to the device. This is a similar workflow
    to the Espruino Pico.'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你可以通过使用 IDE 控制 Puck.js：发送命令或编写脚本并将其部署到设备。这与 Espruino Pico 的流程类似。
- en: 'But there’s another way: you can control Puck.js from your own code within
    the browser. In this experiment, you’ll build a web page that allows a user to
    turn Puck.js’s red LED on and off by clicking buttons in the browser ([figure
    12.17](#ch12fig17)).'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另一种方法：你可以在浏览器中的自己的代码中控制 Puck.js。在这个实验中，你将构建一个网页，允许用户通过点击浏览器中的按钮来打开和关闭 Puck.js
    的红色 LED（[图 12.17](#ch12fig17)）。
- en: Figure 12.17\. Puck.js’s LED can be controlled via a web page in a Web Bluetooth–capable
    browser.
  id: totrans-1250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.17\. 在支持 Web Bluetooth 的浏览器中，可以通过网页控制 Puck.js 的 LED。
- en: '![](12fig17_alt.jpg)'
  id: totrans-1251
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig17_alt.jpg)'
- en: The page’s JavaScript will need to pair with Puck.js and communicate with it
    (send it commands) using Web Bluetooth.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的 JavaScript 需要与 Puck.js 配对并与之通信（发送命令）使用 Web Bluetooth。
- en: Espruino makes this part easy for you by providing a small client-side library
    (a JavaScript file) that you can use in our page. The library abstracts away the
    details of the Web Bluetooth API, giving you a simple interface you can use to
    pair and interact with Puck.js.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: Espruino通过提供一个小的客户端库（一个JavaScript文件）来简化这一部分，你可以在我们的页面上使用它。该库抽象了Web Bluetooth
    API的细节，提供了一个简单的接口，你可以使用它来配对并与Puck.js交互。
- en: That client-side library can be found at [https://www.puck-js.com/puck.js](https://www.puck-js.com/puck.js).
    You’ll include it in the index.html page of the project.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.puck-js.com/puck.js](https://www.puck-js.com/puck.js)找到这个客户端库。你需要在项目的index.html页面中包含它。
- en: '|  |'
  id: totrans-1255
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Web Bluetooth: still curious?'
  id: totrans-1256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Web Bluetooth：仍然好奇？
- en: 'If you’re curious about how Web Bluetooth works under the covers, you can read
    the source of the puck.js JavaScript file, which is well-commented: [https://www.puck-js.com/puck.js](https://www.puck-js.com/puck.js).'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇Web Bluetooth在底层是如何工作的，你可以阅读puck.js JavaScript文件的源代码，它有很好的注释：[https://www.puck-js.com/puck.js](https://www.puck-js.com/puck.js)。
- en: '|  |'
  id: totrans-1258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The JavaScript library from puck-js.com gives you utilities for connecting to
    and communicating with Puck.js, but you’ll still need to write your own specific
    logic for handling button clicks and sending commands to Puck.js to turn the LED
    on and off.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: puck-js.com的JavaScript库为你提供了连接和与Puck.js通信的实用工具，但你仍然需要编写自己的特定逻辑来处理按钮点击并向Puck.js发送命令来打开和关闭LED。
- en: Setting up the project structure
  id: totrans-1260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置项目结构
- en: 'First you need to establish a working area—make a directory called led-toggle.
    Then, inside of that directory, run this command:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要建立一个工作区域——创建一个名为led-toggle的目录。然后，在该目录内运行以下命令：
- en: '[PRE100]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: That’s the only project dependency.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是唯一的依赖项目。
- en: Next, create an application entry point in index.js, which spins up a super-basic
    static web server for assets in app/, as shown in the next listing.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在index.js中创建一个应用程序入口点，它为app/中的资源启动一个超级基本的静态Web服务器，如下面的列表所示。
- en: Listing 12.5\. index.js
  id: totrans-1265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.5\. index.js
- en: '[PRE101]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Now it’s time to create the application’s HTML page. To do so, create an app
    directory in the project and add index.html with the contents shown in the following
    listing.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建应用程序的HTML页面了。为此，在项目中创建一个名为app的目录，并添加index.html，其内容如下所示。
- en: Listing 12.6\. index.html
  id: totrans-1268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.6\. index.html
- en: '[PRE102]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1* Container to hold messaging if Web Bluetooth isn’t supported**'
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于在Web Bluetooth不受支持时存储消息的容器**'
- en: '***2* Provides a Puck object for communicating with Puck.js using Web Bluetooth**'
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提供一个Puck对象，用于通过Web Bluetooth与Puck.js通信**'
- en: '***3* The application’s client-side logic: you need to write it!**'
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 应用程序客户端逻辑：你需要编写它！**'
- en: 'The HTML page doesn’t do anything on its own: it has some CSS and includes
    the script from the puck-js.com site that allows you to communicate with Puck.js
    using Web Bluetooth. It also has the markup for the ON and OFF buttons, but they
    don’t do anything yet.'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面本身不做任何事情：它包含一些CSS，并包含来自puck-js.com站点的脚本，该脚本允许你使用Web Bluetooth与Puck.js通信。它还包括ON和OFF按钮的标记，但目前它们还没有做任何事情。
- en: Creating the LED-toggling logic
  id: totrans-1274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建LED切换逻辑
- en: 'Let’s talk about click handlers for the ON and OFF buttons. When a button is
    clicked, you need to send a command to the Puck to turn its red LED on or off.
    As you saw in [section 12.4.4](#ch12lev2sec10), this is the command that Puck.js
    needs to execute to turn on the red LED:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下ON和OFF按钮的点击处理器。当按钮被点击时，你需要向Puck发送一个命令来打开或关闭它的红色LED。正如你在[第12.4.4节](#ch12lev2sec10)中看到的，这是Puck.js需要执行的命令来打开红色LED：
- en: '[PRE103]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'That’s the command that you need to send to Puck.js from the browser, using
    the `puck.js` client-side library as a messenger. The command needs to be sent
    to Puck.js as a string, including the `\n` (line break) character. This is the
    resulting command string:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要通过`puck.js`客户端库作为信使发送到Puck.js的命令。该命令需要作为字符串发送到Puck.js，包括`\n`（换行符）字符。这是生成的命令字符串：
- en: '[PRE104]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: To send this to Puck.js, you’ll use the `write()` method on the `Puck` object,
    which is globally available in your page’s JavaScript because you included the
    client-side `puck.js` library ([figure 12.18](#ch12fig18)).
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此发送到Puck.js，你将使用`Puck`对象的`write()`方法，这是在页面JavaScript中全局可用的，因为你包含了客户端的`puck.js`库（[图12.18](#ch12fig18)）。
- en: '[PRE105]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Figure 12.18\. Your browser-executed JavaScript invokes the `write()` method
    on the `Puck` object provided by the `puck.js` library. That library uses Web
    Bluetooth to send the string to the physical Puck.js, which evaluates it. The
    `\n` at the end of the string command lets Puck.js know the command is complete;
    it’s almost like typing into a virtual REPL and hitting Enter.
  id: totrans-1281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.18\. 你的浏览器执行的 JavaScript 在 `puck.js` 库提供的 `Puck` 对象上调用 `write()` 方法。该库使用
    Web Bluetooth 将字符串发送到物理 Puck.js，并对其进行评估。字符串命令末尾的 `\n` 让 Puck.js 知道命令已完成；这几乎就像在虚拟
    REPL 中输入并按 Enter 键一样。
- en: '![](12fig18_alt.jpg)'
  id: totrans-1282
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig18_alt.jpg)'
- en: '|  |'
  id: totrans-1283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**What does Puck.js even mean?**'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '**Puck.js 究竟是什么意思？**'
- en: There’s a `Puck` object in the browser, a different `Puck` object you can send
    commands to in the Puck.js IDE, and Puck.js and `puck.js` are totally different
    things. Yikes!
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中有一个 `Puck` 对象，你可以在 Puck.js IDE 中向其发送命令，而 Puck.js 和 `puck.js` 完全是不同的事物。哎呀！
- en: 'The naming conventions are admittedly a tad brain-melting. Here’s a summary:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定确实有点让人头昏脑胀。以下是一个总结：
- en: Puck.js—The Puck.js physical device itself
  id: totrans-1287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puck.js——Puck.js 物理设备本身
- en: '`puck.js`—A client-side JavaScript library, provided by Espruino, used in the
    browser for communicating with a Puck.js device via Web Bluetooth (BLE)'
  id: totrans-1288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`puck.js`——Espruino 提供的客户端 JavaScript 库，用于在浏览器中通过 Web Bluetooth（BLE）与 Puck.js
    设备通信'
- en: '`Puck` object—Confusingly, this is one of two (totally different) things depending
    on where the code is executing:'
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Puck` 对象——令人困惑的是，这取决于代码执行的上下文，有两种（完全不同）的事物：'
- en: In the IDE or scripts running on Puck.js directly—It’s the Espruino `Puck` global
    class ([http://www.espruino.com/Reference#Puck](http://www.espruino.com/Reference#Puck)),
    which adds some hardware-interaction functionality specific to Puck.js—that is,
    functionality that’s not available on other Espruino boards (such as using `Puck.light()`
    to get a reading from Puck.js’s ambient light sensor)
  id: totrans-1290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IDE 或直接在 Puck.js 上运行的脚本中——它是 Espruino 的 `Puck` 全局类 ([http://www.espruino.com/Reference#Puck](http://www.espruino.com/Reference#Puck))，它为
    Puck.js 添加了一些特定的硬件交互功能——也就是说，这些功能在其他 Espruino 板上不可用（例如使用 `Puck.light()` 从 Puck.js
    的环境光传感器读取数据）
- en: In a browser, assuming the inclusion of the `puck.js` client-side library—Provides
    access to some methods for communicating with Puck.js over Web Bluetooth (such
    as `Puck.write()` and `Puck.connect()`). Keep in mind that any commands sent are
    evaluated on Puck.js itself, in the Espruino interpreter.
  id: totrans-1291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中，假设包含了 `puck.js` 客户端库——提供了一些通过 Web Bluetooth 与 Puck.js 通信的方法（例如 `Puck.write()`
    和 `Puck.connect()`）。请记住，任何发送的命令都在 Puck.js 本身上的 Espruino 解释器中评估。
- en: 'This means that in a browser script—assuming the `puck.js` client library is
    included—the following statement is valid:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在浏览器脚本中——假设包含了 `puck.js` 客户端库——以下语句是有效的：
- en: '[PRE106]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`Puck.write()` is executed in the browser’s context, which means it refers
    to the object provided by the included `puck.js` library. But the command it sends
    via `write()` is evaluated on Puck.js itself: the `Puck` object in `Puck.light()`
    is a reference to the global Espruino `Puck` object. Whew!'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: '`Puck.write()` 在浏览器上下文中执行，这意味着它指的是包含的 `puck.js` 库提供的对象。但是，它通过 `write()` 发送的命令在
    Puck.js 本身上评估：`Puck.light()` 中的 `Puck` 对象是对全局 Espruino `Puck` 对象的引用。呼！'
- en: '|  |'
  id: totrans-1295
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The following listing defines what goes between the `<script>` tags in index.html:
    the click event listeners and the commands sent to Puck.js.'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表定义了在 index.html 中的 `<script>` 标签之间放置的内容：点击事件监听器和发送到 Puck.js 的命令。
- en: Listing 12.7\. Event listeners for toggling LEDs
  id: totrans-1297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.7\. 用于切换 LED 的事件监听器
- en: '[PRE107]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The ersatz feature detection in [listing 12.7](#ch12ex07)—`if ('bluetooth' in
    window.navigator)`—is admittedly ham-fisted and naive. Just because a browser
    exposes `navigator.bluetooth` doesn’t mean it correctly implements what’s needed
    for Puck.js. There’s a more correct and thorough check for browser support in
    a function called `checkIf-Supported()`, inside of the JavaScript code that gives
    you the `Puck` object. Unfortunately, that function isn’t exposed to the `Puck`
    object—it’s not in any scope you have access to—so you can’t invoke it directly.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12.7](#ch12ex07) 中的模拟功能检测——`if (''bluetooth'' in window.navigator)`——诚然是笨拙且天真的。仅仅因为浏览器暴露了
    `navigator.bluetooth`，并不意味着它正确实现了 Puck.js 所需的功能。在 JavaScript 代码中，有一个名为 `checkIf-Supported()`
    的函数，它提供了一个更正确、更全面的浏览器支持检查。不幸的是，该函数并未暴露给 `Puck` 对象——它不在你能够访问的任何作用域中——因此你不能直接调用它。'
- en: Try it out! Start the web server using `node index.js`, and open a Web Bluetooth–capable
    browser to localhost:3000.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下！使用 `node index.js` 启动网络服务器，并打开一个支持 Web Bluetooth 的浏览器，访问 localhost:3000。
- en: When you first click on a button, you’ll see a pairing request pop up, similar
    to [figure 12.19](#ch12fig19). Once the pairing is complete, you should be able
    to click ON and OFF and see Puck.js’s red LED turn on and off.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次点击按钮时，你会看到一个配对请求弹出，类似于[图12.19](#ch12fig19)。一旦配对完成，你应该能够点击ON和OFF，并看到Puck.js的红色LED灯亮起和熄灭。
- en: Figure 12.19\. You’ll be prompted to pair with Puck.js when you first click
    a button.
  id: totrans-1302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.19. 当你第一次点击按钮时，你会被提示与Puck.js配对。
- en: '![](12fig19_alt.jpg)'
  id: totrans-1303
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig19_alt.jpg)'
- en: 12.4.6\. The Physical Web and Puck.js
  id: totrans-1304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.6. 物理网和Puck.js
- en: '|  |'
  id: totrans-1305
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-1306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要什么
- en: '![](note.jpg)'
  id: totrans-1307
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Puck.js
  id: totrans-1308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Puck.js
- en: 1 mobile device running Android or iOS
  id: totrans-1309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 运行Android或iOS的移动设备
- en: '|  |'
  id: totrans-1310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Physical Web is composed of beacons using a specific format—Eddystone—to
    broadcast an associated URL, and these broadcasts can be picked up by apps running
    on mobile devices.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 物理网由使用特定格式——Eddystone——的信标组成，用于广播相关的URL，并且这些广播可以被运行在移动设备上的应用程序接收。
- en: 'Puck.js can serve as a Physical Web–compatible beacon quite easily. To get
    this going, you’ll need to do the following:'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: Puck.js可以很容易地作为物理网兼容的信标。要启动这个过程，你需要做以下事情：
- en: Install a Physical Web discovery utility application, or enable this feature
    in Chrome, on a mobile device.
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动设备上安装物理网发现实用程序，或在Chrome中启用此功能。
- en: Determine what URL you’d like Puck.js to broadcast.
  id: totrans-1314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定你希望Puck.js广播的URL。
- en: Make Puck.js start advertising itself as a compatible beacon.
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让Puck.js开始作为兼容的信标进行广告。
- en: The Eddystone protocol
  id: totrans-1316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Eddystone协议
- en: Eddystone is an open BLE beacon protocol created by Google. Physical Web beacons
    use this format to broadcast their associated URL, and client applications detect
    these Eddystone beacons.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: Eddystone是由Google创建的一个开放的BLE信标协议。物理网信标使用此格式来广播它们相关的URL，并且客户端应用程序检测这些Eddystone信标。
- en: Eddystone is straightforward. There are only a few kinds of information—*frame
    types*—that an Eddystone-speaking beacon can send, the most pertinent one being
    `Eddystone-URL`.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: Eddystone非常简单。Eddystone设备可以发送的信息种类很少——*帧类型*——，其中最相关的是`Eddystone-URL`。
- en: '|  |'
  id: totrans-1319
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Length constraints of `Eddystone-URL`**'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Eddystone-URL`的长度限制**'
- en: The maximum length of an `Eddystone-URL` URL is 17\. That’s tight. But it’s
    not as restrictive as it sounds. A separate byte is also used to hold a representation
    of the URL’s *scheme* prefix, (https://www., http://, and so on)—those characters
    don’t count against the 17\. Also, common top-level domains (.com, .org, and the
    like) can be represented with a single character, leaving 16 characters free.
    It’s assumed that developers will use URL shorteners (such as [https://goo.gl](https://goo.gl))
    to minimize URL lengths.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '`Eddystone-URL` URL的最大长度为17。这很紧凑。但它并不像听起来那么受限。还有一个单独的字节用于存储URL的*方案*前缀的表示（例如https://www.，http://等）——这些字符不计入17个字符。此外，常见的顶级域名（.com，.org等）可以用一个字符表示，留下16个字符。假设开发者会使用URL缩短器（如[https://goo.gl](https://goo.gl)）来最小化URL长度。'
- en: The URL [https://www.lyza.com](https://www.lyza.com) is 20 characters long in
    its normal form, but it only requires 5 of the available 17 bytes.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: URL [https://www.lyza.com](https://www.lyza.com) 在其正常形式下有20个字符长，但它只需要17个可用字节中的5个。
- en: '|  |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Configuring the Puck.js as a beacon
  id: totrans-1324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将Puck.js配置为信标
- en: 'Setting up Puck.js as an Eddystone-compatible Physical Web beacon is almost
    breathtakingly easy. There’s a `ble_eddystone` Espruino module just waiting for
    you! Fire up the Web IDE, connect to your Puck.js, and enter the following command
    on the left side of the IDE:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 将Puck.js设置为Eddystone兼容的物理网信标几乎令人难以置信地简单。有一个`ble_eddystone` Espruino模块正等着你！启动Web
    IDE，连接到你的Puck.js，并在IDE的左侧输入以下命令：
- en: '[PRE108]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: (Feel free, of course, to replace my domain’s URL with any you like.)
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，你可以随意用你喜欢的任何URL替换我的域名URL。）
- en: Disconnect the IDE from your Puck.js so that it can start broadcasting in Eddystone
    format.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 断开IDE与Puck.js的连接，以便它能够以Eddystone格式开始广播。
- en: Enabling Physical Web discovery on your mobile device
  id: totrans-1329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在你的移动设备上启用物理网发现
- en: You can detect your Puck.js Physical Web beacon with devices that run Android
    or iOS ([figure 12.20](#ch12fig20)); instructions can be found on the Physical
    Web website ([https://google.github.io/physical-web/try-physical-web](https://google.github.io/physical-web/try-physical-web)).
    Once it’s configured, your mobile device should be able to see your Puck.js beacon.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用运行Android或iOS的设备检测你的Puck.js物理网信标（[图12.20](#ch12fig20)）；说明可以在物理网网站上找到（[https://google.github.io/physical-web/try-physical-web](https://google.github.io/physical-web/try-physical-web)）。一旦配置完成，你的移动设备应该能够看到你的Puck.js信标。
- en: Figure 12.20\. Physical Web support via the Chrome widget on iOS. Puck.js is
    configured to broadcast the URL [https://www.lyza.com](https://www.lyza.com) using
    the Eddystone protocol.
  id: totrans-1331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.20\. 通过 iOS 上的 Chrome 小部件支持物理网络。Puck.js 已配置为使用 Eddystone 协议广播 URL [https://www.lyza.com](https://www.lyza.com)。
- en: '![](12fig20.jpg)'
  id: totrans-1332
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig20.jpg)'
- en: It’s time to go out with a bang (well, a ding, anyway). Our last experiment
    will combine Web Bluetooth, Web Audio, and data sent from Puck.js.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候以一声巨响（好吧，至少是一声叮当声）离开了。我们的最后一个实验将结合 Web Bluetooth、Web Audio 和从 Puck.js 发送的数据。
- en: 12.4.7\. A web-based Bluetooth doorbell
  id: totrans-1334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.7\. 基于网络的蓝牙门铃
- en: '|  |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-1336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 您需要什么
- en: '![](note.jpg)'
  id: totrans-1337
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Puck.js
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Puck.js
- en: 1 Web Bluetooth–enabled web browser
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 具有Web Bluetooth功能的网络浏览器
- en: '|  |'
  id: totrans-1340
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This experiment plays a (high-quality) sound and displays a visual alert in
    a browser whenever the paired Puck.js button is pressed. Think of it as a web-based
    doorbell. It takes advantage of the Web Audio API—yet another handsome web API—to
    load and play a (public-domain) chime sound.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 此实验在按下配对的 Puck.js 按钮时，在浏览器中播放（高质量）声音并显示视觉警报。将其视为基于网络的门铃。它利用 Web Audio API——另一个出色的网络
    API——来加载和播放（公有领域）的铃声。
- en: The application logic uses the client-side `puck.js` library to connect to Puck.js
    over Web Bluetooth, configures the Puck.js to monitor its onboard button, and
    parses data—string output that will signify button presses—emitted by Puck.js.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 应用逻辑使用客户端 `puck.js` 库通过 Web Bluetooth 连接到 Puck.js，配置 Puck.js 监控其板载按钮，并解析 Puck.js
    发出的数据——字符串输出将表示按钮按下。
- en: Setting up the project structure
  id: totrans-1343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置项目结构
- en: 'Start by establishing a working area. Make a directory (“doorbell”) and install
    `express` as a dependency in that directory:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 首先建立一个工作区域。创建一个目录（“门铃”）并在该目录中安装 `express` 作为依赖项：
- en: '[PRE109]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Create index.js, the static web server. You can reuse the code in [listing 12.5](#ch12ex05),
    which will run a static web server on port 3000.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 index.js，静态网络服务器。您可以在 [列表 12.5](#ch12ex05) 中重用代码，该代码将在端口 3000 上运行静态网络服务器。
- en: Creating the HTML and event listeners
  id: totrans-1347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 HTML 和事件监听器
- en: Create an app directory inside of doorbell. Add an index.html file with the
    following content.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 在门铃内部创建一个应用目录。添加一个包含以下内容的 index.html 文件。
- en: Listing 12.8\. index.html
  id: totrans-1349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8\. index.html
- en: '[PRE110]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: If you were to view index.html in a browser now, you’d see what’s shown in [figure
    12.21](#ch12fig21), but it wouldn’t do anything yet.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在在浏览器中查看 index.html，您将看到 [图 12.21](#ch12fig21) 中所示的内容，但此时它还没有任何功能。
- en: Figure 12.21\. Right now, index.html shows a really big button, but it doesn’t
    have any functionality.
  id: totrans-1352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.21\. 目前，index.html 显示了一个非常大的按钮，但它没有任何功能。
- en: '![](12fig21_alt.jpg)'
  id: totrans-1353
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig21_alt.jpg)'
- en: The button (`#goButton`) will ultimately have a click-event handler that will
    enable the doorbell. You may be wondering why this extra click step is needed—why
    not just activate the doorbell on page load? For privacy and permissions reasons,
    there needs to be an explicit user interface action before Bluetooth pairing is
    allowed by the browser—if you tried to do this without active user input, you’d
    get an error.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 该按钮（`#goButton`）最终将有一个点击事件处理程序，将启用门铃。您可能想知道为什么需要这个额外的点击步骤——为什么不在页面加载时直接激活门铃？出于隐私和权限的原因，在浏览器允许蓝牙配对之前，需要有一个明确的用户界面操作——如果您在没有用户输入的情况下尝试这样做，您将得到一个错误。
- en: The index.html file contains a chunk of CSS. Some of the styling is to format
    the big Turn It On button, but there are also styles to make the screen flash
    when the doorbell chimes and to fade out the Turn It On button (the `.active`
    class) once the doorbell is activated.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: index.html 文件包含一段 CSS。其中一些样式是为了格式化大的“开启”按钮，但也有样式在门铃响起时使屏幕闪烁，并在门铃激活后淡出“开启”按钮（`.active`
    类）。
- en: You can now fill in the `<script>` content with the code in the following listing.
    This code assumes the existence of a `PuckChime` class, whose creation we’ll get
    to next.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在以下列表中的 `<script>` 内容中填写代码。此代码假设存在一个 `PuckChime` 类，其创建我们将在下一部分介绍。
- en: Listing 12.9\. Click handler for the Turn It On button
  id: totrans-1357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. “开启”按钮的点击处理程序
- en: '[PRE111]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '***1* Once the chime.init() Promise resolves, you’ll know the BLE Puck.js chime
    has been set up successfully.**'
  id: totrans-1359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一旦 chime.init() Promise 解决，您就会知道 BLE Puck.js 铃声已成功设置。**'
- en: '***2* You don’t need the button anymore, so you can add the active class to
    make it fade out.**'
  id: totrans-1360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 您不再需要按钮，因此可以添加活动类使其淡出。**'
- en: Coding the PuckChime class
  id: totrans-1361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写 `PuckChime` 类
- en: The logic for the BLE doorbell is more involved than dispatching one-line commands
    to Puck.js in click event handlers, as in the previous LED-controlling web page.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前在 LED 控制网页中的点击事件处理器中发送单行命令给 Puck.js 相比，BLE 门铃的逻辑更为复杂。
- en: It makes sense to encapsulate the code in a class, `PuckChime`, inside a new
    file, app/PuckChime.js. The API surface for `PuckChime` is shown in the following
    listing. You’ll fill it out in the next few steps.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码封装在新的文件 app/PuckChime.js 中的 `PuckChime` 类中是有意义的。`PuckChime` 的 API 接口在下面的列表中显示。你将在接下来的几个步骤中完成它。
- en: Listing 12.10\. The API surface for PuckChime
  id: totrans-1364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.10\. PuckChime 的 API 接口
- en: '[PRE112]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Let’s look at how the constructor and `init()` methods can be implemented in
    the next listing.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构造函数和 `init()` 方法如何在下一个列表中实现。
- en: 'Listing 12.11\. `PuckChime`: constructor and initialization methods'
  id: totrans-1367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. `PuckChime`：构造函数和初始化方法
- en: '[PRE113]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '***1* Holds the connection to Puck.js; it’s initially null until connected**'
  id: totrans-1369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 保持与 Puck.js 的连接；它最初为 null，直到连接**'
- en: '***2* A buffer for holding and parsing incoming data from Puck.js**'
  id: totrans-1370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 用于存储和解析从 Puck.js 收到的数据的缓冲区**'
- en: '***3* Sound is a convenience class for loading and playing a sound with the
    Web Audio API.**'
  id: totrans-1371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Sound 是一个方便的类，用于使用 Web Audio API 加载和播放声音。**'
- en: '***4* After init’s work is complete, invokes chime() once**'
  id: totrans-1372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在 init 的工作完成后，调用 chime() 一次**'
- en: The `constructor` readies a sound—chime.mp3—by instantiating a `Sound` object.
    If `Sound` seems like a magical class that came out of nowhere, and chime.mp3
    a file of mysterious origin, you’re right! Hang tight; more details on them in
    a little bit.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数通过实例化一个 `Sound` 对象来准备声音—chime.mp3。如果 `Sound` 看起来像是一个突然出现的神奇类，而 chime.mp3
    是一个神秘来源的文件，那么你是对的！请稍等；稍后会有更多关于它们的细节。
- en: 'The `init` method returns a `Promise` that resolves when the following steps
    are complete:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 方法返回一个 `Promise`，当以下步骤完成时解析：'
- en: A connection is established with Puck.js
  id: totrans-1375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 Puck.js 建立连接
- en: Puck.js is reset
  id: totrans-1376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Puck.js 已重置
- en: Puck.js is instructed to watch its button for presses
  id: totrans-1377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示 Puck.js 监视其按钮的按下
- en: Only when those things are all done does the `Promise` returned by `init()`
    resolve; `chime()` is also invoked as a confirmation (the doorbell will ring once
    when it’s ready to go).
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当所有这些事情都完成时，`init()` 返回的 `Promise` 才会解析；`chime()` 也作为确认被调用（门铃在准备就绪时会响一次）。
- en: 'Moving along, the methods `connect()`, `send(cmd)`, `reset()`, and `watchButton()`
    communicate with Puck.js, each returning a `Promise`. These methods rely on the
    client-side `puck.js` communication code provided by Espruino:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，`connect()`、`send(cmd)`、`reset()` 和 `watchButton()` 方法与 Puck.js 通信，每个方法都返回一个
    `Promise`。这些方法依赖于 Espruino 提供的客户端 `puck.js` 通信代码：
- en: '`connect()`—Connects to Puck.js and adds an event handler (`parseData`) for
    Puck.js `data` events'
  id: totrans-1380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect()`—连接到 Puck.js 并为 Puck.js 的 `data` 事件添加一个事件处理器 (`parseData`)'
- en: '`send(cmd)`—Formats the string `cmd` appropriately and sends it to Puck.js,
    wrapping the callback-oriented `connection.write()` method with a `Promise` for
    consistency'
  id: totrans-1381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send(cmd)`—适当地格式化字符串 `cmd` 并将其发送到 Puck.js，通过将回调导向的 `connection.write()` 方法包装在
    `Promise` 中以保持一致性'
- en: '`reset()`—Sends a reset command to Puck.js and also waits 1.5 s for Puck.js
    to be ready again before resolving the `Promise` it returns'
  id: totrans-1382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()`—向 Puck.js 发送重置命令，并在解析它返回的 `Promise` 之前等待 1.5 秒，以便 Puck.js 再次准备好'
- en: '`watchButton()`—Sends a more complex command to Puck.js to set up a watch on
    its built-in button'
  id: totrans-1383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watchButton()`—向 Puck.js 发送更复杂的命令以设置对其内置按钮的监视'
- en: These methods are fleshed out in the following listing.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在下面的列表中进行了详细说明。
- en: Listing 12.12\. Methods for communicating with Puck.js
  id: totrans-1385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.12\. 与 Puck.js 通信的方法
- en: '[PRE114]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Let’s zoom in on the command sent by `watchButton()`—it’s a bit of a doozy as
    formatted—and get a better understanding of what’s going on with sending and receiving
    Puck.js data and commands.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看 `watchButton()` 发送的命令——格式化后相当复杂——并更好地了解发送和接收 Puck.js 数据和命令的情况。
- en: As you saw in the web-controlled LED example in [section 12.4.5](#ch12lev2sec11),
    commands need to be formatted as strings before sending them to Puck.js from the
    browser. In the simpler LED experiment, this was done with individual calls to
    `Puck.write()` (see [figure 12.18](#ch12fig18)).
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [第 12.4.5 节](#ch12lev2sec11) 的网络控制 LED 示例中看到的，在从浏览器发送命令到 Puck.js 之前，需要将命令格式化为字符串。在更简单的
    LED 实验中，这是通过调用 `Puck.write()`（见 [图 12.18](#ch12fig18)）来完成的。
- en: In this more complex case, where data is going in both directions, you’re instead
    establishing a persistent connection (in the `connect()` method). Once the connection
    is established, commands are sent to Puck.js using `connection.write()`. Data
    is received from Puck.js via emitted `data` events on the `connection` ([figure
    12.22](#ch12fig22)), which are handled by the registered `data` event handler,
    `parseData()`. We’ll get to that in a moment.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更复杂的情况下，数据双向传输时，你将建立一个持久连接（在 `connect()` 方法中）。一旦建立连接，就使用 `connection.write()`
    向 Puck.js 发送命令。通过 `connection` 上的发出 `data` 事件从 Puck.js 接收数据（[图 12.22](#ch12fig22)），这些事件由注册的
    `data` 事件处理器 `parseData()` 处理。我们稍后会讨论这一点。
- en: Figure 12.22\. For the two-way communications in the doorbell example, the `puck.js`
    client library is used to establish a persistent connection between the browser
    and Puck.js. Commands can be sent to Puck.js over the connection, and any output
    to Bluetooth by Puck.js triggers a `data` event on the connection.
  id: totrans-1390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.22\. 在门铃示例中的双向通信中，使用 `puck.js` 客户端库在浏览器和 Puck.js 之间建立持久连接。可以通过连接向 Puck.js
    发送命令，并且 Puck.js 通过蓝牙输出的任何输出都会在连接上触发一个 `data` 事件。
- en: '![](12fig22_alt.jpg)'
  id: totrans-1391
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig22_alt.jpg)'
- en: '`PuckChime` objects send two commands to Puck.js: a `reset()` command during
    the init phase to clear any cobwebs or oddities out of Puck.js, and then a more
    complex command in `watchButton()`. The command constructed in that method, disabused
    of all its stringiness and ignoring line-break constraints, is shown expanded
    in the following listing. It makes use of the Espruino global `setWatch(<callback>,
    <pin>, [<options>])` function.'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '`PuckChime` 对象向 Puck.js 发送两个命令：在初始化阶段发送一个 `reset()` 命令以清除 Puck.js 中的任何蜘蛛网或异常，然后在
    `watchButton()` 中发送一个更复杂的命令。在该方法中构建的命令，去除了所有的字符串性，并忽略了换行符约束，在以下列表中展开。它使用了 Espruino
    全局 `setWatch(<callback>, <pin>, [<options>])` 函数。'
- en: Listing 12.13\. Puck.js command, expanded
  id: totrans-1393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.13\. Puck.js 命令，展开
- en: '[PRE115]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '***1* The first argument to setWatch(): a callback function**'
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* setWatch() 的第一个参数：一个回调函数**'
- en: '***2* Logs the string CHIME over Bluetooth; this will trigger a `data` event**'
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过蓝牙记录字符串 CHIME；这将触发一个 `data` 事件**'
- en: '***3* Turns the red LED on**'
  id: totrans-1397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打开红色 LED**'
- en: '***4* Turns the red LED off again after 250 ms**'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 250 毫秒后再次关闭红色 LED**'
- en: '***5* The pin to watch**'
  id: totrans-1399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 要监视的引脚**'
- en: '***6* Keeps watching this pin repeatedly**'
  id: totrans-1400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 重复监视这个引脚**'
- en: '***7* Debounces the pin (button) to 250 ms to avoid triggering multiple times
    per press or interfering with previous presses**'
  id: totrans-1401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 对引脚（按钮）进行去抖动，以 250 毫秒为间隔，避免每次按下时触发多次或干扰之前的按下**'
- en: '***8* Triggers on a rising edge—the transition from LOW to HIGH**'
  id: totrans-1402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 触发上升沿——从 LOW 到 HIGH 的转换**'
- en: The callback registered on Puck.js for button presses logs out a string via
    Bluetooth and also lights up the onboard red LED briefly as visual feedback.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puck.js 上注册的按钮按下回调通过蓝牙输出一个字符串，并且还会短暂点亮板载的红色 LED 作为视觉反馈。
- en: Data is emitted from Puck.js any time something is output on Bluetooth. This
    happens when `Bluetooth.println('CHIME')` is executed in the button-watching callback,
    but not everything that comes from the Puck.js will be a `CHIME` command. For
    instance, several lines of debugging and version output are generated (automatically)
    right after a connection is established. Those lines aren’t relevant to your logic,
    so the `parseCommand(cmd)` makes sure you have an actual match for the string
    `CHIME`.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 当在蓝牙上输出某些内容时，Puck.js 会随时发出数据。这发生在按钮监视回调中执行 `Bluetooth.println('CHIME')` 时，但并非来自
    Puck.js 的所有内容都将是一个 `CHIME` 命令。例如，在建立连接后，会自动生成几行调试和版本输出。这些行与你的逻辑无关，因此 `parseCommand(cmd)`
    确保你有一个实际的 `CHIME` 字符串匹配。
- en: Before you can feed the commands into `parseCommand()`, though, you have to
    parse out the “commands” from the other incoming data. Data comes in chunks, so
    it’s up to the `parseData()` handler to keep a simple buffer and break the incoming
    string data into lines—delimited by `\n` (line-break) characters. Those lines
    are each passed to `parseCommand()` to see if they do, in fact, represent a valid
    command—`CHIME` being your only valid command. See the following listing.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 在将命令输入到 `parseCommand()` 之前，你必须从其他传入的数据中解析出“命令”。数据以块的形式传入，因此 `parseData()` 处理器必须保持一个简单的缓冲区，并将传入的字符串数据拆分成行——由
    `\n`（换行符）字符分隔。这些行分别传递给 `parseCommand()`，以查看它们是否确实代表一个有效的命令——`CHIME` 是你唯一的有效命令。请参见以下列表。
- en: Listing 12.14\. Parsing data from Puck.js
  id: totrans-1406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.14\. 从 Puck.js 解析数据
- en: '[PRE116]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '***1* -1 is the only value that will produce 0 (false) in the face of the bitwise
    NOT (~) operator.**'
  id: totrans-1408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* -1 是唯一一个在位运算非（~）操作符面前产生 0（false）的值。**'
- en: '***2* Strips any non-alphanumeric characters in case a control character got
    crammed in**'
  id: totrans-1409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 移除任何非字母数字字符，以防控制字符被挤入**'
- en: '***3* Passes this line to parseCommand() to see if it means anything**'
  id: totrans-1410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将此行传递给 parseCommand() 以查看它是否意味着什么**'
- en: '***4* Snips the current command off the front of the data buffer and sees if
    there are more lines**'
  id: totrans-1411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从数据缓冲区的开头剪切当前命令并查看是否有更多行**'
- en: The final method in the `PuckChime` class is the `chime()` itself. The `Sound`
    that was instantiated in the constructor gets played (with `play()`) and a class—`.ding`—gets
    added to the `body` element and is then removed after 500 ms, as shown in the
    following listing. The `.ding` class creates a visual chime in the browser by
    changing the background color of the entire page temporarily.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '`PuckChime` 类中的最后一个方法是 `chime()` 本身。在构造函数中实例化的 `Sound` 对象被播放（使用 `play()`），并且添加了一个类
    — `.ding` — 到 `body` 元素上，然后在 500 毫秒后移除，如下所示。`.ding` 类通过暂时改变整个页面的背景颜色，在浏览器中创建一个视觉门铃声。 '
- en: Listing 12.15\. The chime itself
  id: totrans-1413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.15。门铃本身
- en: '[PRE117]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Web Audio and the Sound class
  id: totrans-1415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Web Audio 和 Sound 类
- en: '`Sound` is a JavaScript class that encapsulates the loading and playing of
    the sound file at the `url` passed to its constructor. It uses the Web Audio API.
    Its source is reproduced in [listing 12.16](#ch12ex16); you can put it at the
    top of the PuckChime.js file. Alternatively, you can find the entire PuckChime.js
    source, including the `Sound` class, in the book’s GitHub repository.'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sound` 是一个 JavaScript 类，它封装了在构造函数中传递给它的 `url` 处加载和播放声音文件。它使用 Web Audio API。其源代码在
    [列表 12.16](#ch12ex16) 中重现；您可以将它放在 PuckChime.js 文件的顶部。或者，您可以在本书的 GitHub 仓库中找到整个
    PuckChime.js 源代码，包括 `Sound` 类。'
- en: In the same directory as the hosted PuckChime.js source, you can also find the
    chime.mp3 sound file—or feel free to use your own sound file (don’t forget to
    update the `Sound` instantiation in `PuckChime`’s constructor if you give it a
    different filename).
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管 PuckChime.js 源代码的同一目录中，您还可以找到 chime.mp3 声音文件——或者您也可以使用自己的声音文件（如果您提供了不同的文件名，别忘了更新
    `PuckChime` 构造函数中的 `Sound` 实例化）。
- en: Listing 12.16\. The `Sound` class
  id: totrans-1418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.16。`Sound` 类
- en: '[PRE118]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The Web Audio API is powerful, and it’s correspondingly somewhat involved.
    MDN’s Web Audio API documentation is comprehensive: [https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API).'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: Web Audio API 功能强大，相应地也有些复杂。MDN 的 Web Audio API 文档非常全面：[https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)。
- en: Trying out the doorbell
  id: totrans-1421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试门铃
- en: 'To recap, the Puck.js doorbell project should contain the following files:'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 概括来说，Puck.js 门铃项目应包含以下文件：
- en: index.js—A simple web server.
  id: totrans-1423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: index.js — 一个简单的网络服务器。
- en: app/index.html—Includes styling and markup for the big Turn It On button, as
    well as a click-event handler for the button to initialize the doorbell (`PuckChime`
    object). It also includes the Puck.js client JavaScript library for communicating
    with Puck.js, as well as PuckChime.js.
  id: totrans-1424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app/index.html — 包含大“开启”按钮的样式和标记，以及按钮的点击事件处理程序以初始化门铃（`PuckChime` 对象）。它还包括与 Puck.js
    通信的 Puck.js 客户端 JavaScript 库，以及 PuckChime.js。
- en: app/PuckChime.js—Includes both the `Sound` and `PuckChime` classes.
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app/PuckChime.js — 包含 `Sound` 和 `PuckChime` 类。
- en: app/chime.mp3 (or another sound file of your choosing)—The sound played when
    the doorbell is pressed.
  id: totrans-1426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app/chime.mp3（或您选择的另一个声音文件）—按门铃时播放的声音。
- en: 'Start the web server:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 启动网络服务器：
- en: '[PRE119]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Open up your browser to localhost:3000\. It may help to also open up the Web
    Inspector’s console in your browser to see any logged messages or errors. When
    you click the Turn It On button, you should see a pairing request pop up ([figure
    12.23](#ch12fig23)).
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的浏览器到 localhost:3000。同时打开浏览器中的 Web 检查器控制台，查看任何记录的消息或错误。当您点击“开启”按钮时，应该会弹出一个配对请求（[图
    12.23](#ch12fig23)）。
- en: Figure 12.23\. Clicking the Turn It On button will prompt for pairing to Puck.js.
  id: totrans-1430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.23。点击“开启”按钮将提示与 Puck.js 配对。
- en: '![](12fig23_alt.jpg)'
  id: totrans-1431
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig23_alt.jpg)'
- en: After pairing, the initialization process takes a few seconds—you’ll see some
    logging in the console. You’ll know it’s done and successful if you hear the doorbell
    sound play and see the screen flash pink briefly ([figure 12.24](#ch12fig24)).
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 配对后，初始化过程需要几秒钟——您将在控制台中看到一些日志。如果您听到门铃声音播放并且屏幕短暂地闪烁粉红色，那么您就会知道它已经完成并且成功（[图 12.24](#ch12fig24)）。
- en: Figure 12.24\. When Puck.js’s button is pressed, the chime sound plays and the
    screen flashes hot pink—one might even call it *pank*, it’s so bright—momentarily.
  id: totrans-1433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.24。当按下 Puck.js 的按钮时，铃声响起，屏幕闪烁着亮粉色——甚至可以说它非常明亮——短暂地。
- en: '![](12fig24_alt.jpg)'
  id: totrans-1434
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig24_alt.jpg)'
- en: 12.5\. Pushing the frontiers of JavaScript and hardware
  id: totrans-1435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5。拓展 JavaScript 和硬件的边界
- en: This BLE doorbell experiment is a good illustration of where the frontiers are
    in the world of physical devices and JavaScript. Puck.js runs the Espruino interpreter,
    which is almost, but not quite, full JavaScript—optimizations are in place to
    make it possible to execute JavaScript on such constrained hardware. Web Bluetooth
    works in some browsers, but there are some shortcomings. At the time of writing,
    you have to re-pair on every page reload, which is a drag. And you may find it
    to be intermittently unreliable in tricky-to-debug ways.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 BLE 门铃实验很好地说明了在物理设备和 JavaScript 世界中的前沿在哪里。Puck.js 运行 Espruino 解释器，它几乎但并不完全是完整的
    JavaScript——有优化措施使其能够在这样的受限硬件上执行 JavaScript。Web Bluetooth 在一些浏览器中工作，但也有一些不足之处。在撰写本文时，你必须在每次页面刷新时重新配对，这真是个麻烦。你可能会发现它在调试困难的情况下间歇性地不可靠。
- en: But the very fact that Puck.js exists, and that Web Bluetooth is implemented
    in some browsers, is remarkable, and it’s a huge leap from just 12 or 18 months
    ago. The continued popularity and I/O plugin growth of Johnny-Five, which turned
    five years old in 2017, is an indication that interest in these areas from JavaScript
    developers remains strong. This growing interest in the melding of JavaScript
    and other web technologies with physical devices is also echoed in the explosion
    of Node.js-capable cloud-managed options for IoT hardware, especially within the
    SBC class of devices that are capable of running Linux.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Puck.js 的存在，以及 Web Bluetooth 在某些浏览器中的实现，都是非常引人注目的，而且这比 12 或 18 个月前有了巨大的飞跃。Johnny-Five（在
    2017 年迎来了五周年纪念日）持续的热度和 I/O 插件增长表明，JavaScript 开发者对这些领域的兴趣依然强烈。这种对将 JavaScript 和其他网络技术与其他物理设备融合的兴趣也体现在物联网硬件的
    Node.js 兼容云管理选项激增上，特别是在能够运行 Linux 的 SBC 设备类别中。
- en: Building electronic-hacking competency doesn’t mean planting a flag deeply and
    inflexibly. JavaScript doesn’t have to be your hammer, your dogmatic single approach.
    Instead, it can serve as a paradigm for exploration, a familiar lens through which
    to examine the unfamiliar. JavaScript may indeed get you all the way to where
    you need to go. But for other cases, an open and curious mind is invaluable.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 建立电子黑客能力并不意味着要深入而僵化地树立一个标志。JavaScript 不必是你的锤子，你的教条式单一方法。相反，它可以作为一个探索的范例，一个熟悉的眼镜，通过它来审视不熟悉的事物。JavaScript
    确实可以带你到达你需要去的地方。但对于其他情况，一个开放和好奇的心态是无价的。
- en: 'Thus, I encourage you not only to keep learning through JavaScript, but also,
    as you get more comfortable, to explore further. Read more about how different
    serial protocols work, dive deeper into bitwise manipulation, learn to write C-based
    firmware. And although it would be flip to say that C is easy, it’s certainly
    approachable: Many have found the Arduino programming language (which, put very
    roughly, is basically C++ with some extra hardware-controlling goodies thrown
    in) a helpful gateway to C++ proficiency.'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我鼓励你不仅通过 JavaScript 继续学习，而且在你越来越熟悉之后，也要进一步探索。了解更多关于不同串行协议的工作原理，深入了解位操作，学习编写基于
    C 的固件。尽管说 C 语言很简单可能会显得有些轻率，但它确实是可以接触的：许多人发现 Arduino 编程语言（非常粗略地说，基本上是 C++ 加上一些额外的硬件控制功能）是通往
    C++ 熟练程度的有帮助的入门途径。
- en: Tinker. Build. Ask questions. Read about technology. Break things on purpose.
    Know that, even if this is your very first time building circuits and working
    with physical I/O, you can figure out how to build the things you dream up. Happy
    hacking!
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试。构建。提问。了解技术。故意破坏。知道即使这是你第一次构建电路和与物理 I/O 一起工作，你也能想出如何构建你梦想中的事物。快乐黑客！
- en: Summary
  id: totrans-1441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: There has been an explosion of cloud-based services for managing and deploying
    IoT applications, many targeted at the enterprise. Many of these services that
    are targeted at Linux-capable SBCs offer support for Node.js.
  id: totrans-1442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近年来，针对管理部署物联网应用的云服务激增，许多服务针对企业用户。许多这些针对具备 Linux 功能的单板计算机（SBC）的服务提供对 Node.js
    的支持。
- en: Containerization is an approach that isolates applications and their dependencies
    from the vagaries of environment variations, and it’s a popular choice for IoT
    application deployment.
  id: totrans-1443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化是一种将应用程序及其依赖项从环境变化的变幻莫测中隔离出来的方法，它是物联网应用部署的流行选择。
- en: The Web Bluetooth API is not yet on the official web standards track, but implementations
    exist in several browsers. Some of its features aren’t ironed out yet, and security
    and permissions models remain contentious.
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Bluetooth API尚未正式纳入官方网络标准轨道，但已在几个浏览器中存在实现。其中一些功能尚未完善，而且安全和权限模型仍然存在争议。
- en: Espruino provides a small client-side JavaScript library that uses Web Bluetooth
    to communicate with Puck.js.
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Espruino提供了一个小的客户端JavaScript库，该库使用Web Bluetooth与Puck.js进行通信。
- en: The Generic Sensor API and further sensor APIs based on it, such as the Ambient
    Light Sensor API, are in their early days of standards definition, but they’re
    under active development.
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用传感器API及其进一步的基于此的传感器API，例如环境光传感器API，正处于标准定义的早期阶段，但它们正在积极开发中。
- en: To participate in the Physical Web, a BLE device can advertise a URL using the
    open Eddystone protocol. Nearby users with compatible discovery software can browse
    and interact with these beacons.
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要参与物理网，一个BLE设备可以使用开放的Eddystone协议来广播一个URL。附近拥有兼容发现软件的用户可以浏览并与之交互这些信标。
