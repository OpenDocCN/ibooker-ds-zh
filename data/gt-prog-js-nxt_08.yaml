- en: Unit 6\. Classes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元 6\. 类
- en: JavaScript is an object-oriented language. Except for a few primitives, most
    values in JavaScript, even functions, are objects. Most of the JavaScript code
    that gets written is for creating custom objects. Many times you’re probably building
    your own objects from scratch, but sometimes you’ll be starting from a base object
    provided from a framework or library and adding custom functionality to it. Unfortunately,
    there hasn’t been a clear way for library authors to provide a base object prototype
    that can be extended by application developers. This has left many library authors
    needing to reinvent the wheel.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种面向对象的语言。除了少数原始类型外，JavaScript 中的大多数值，甚至是函数，都是对象。大多数编写的 JavaScript
    代码都是为了创建自定义对象。很多时候你可能从头开始构建自己的对象，但有时你会从一个框架或库提供的基类开始，并为其添加自定义功能。不幸的是，还没有一个明确的方法让库作者提供可以被应用开发者扩展的基础对象原型。这导致许多库作者不得不重新发明轮子。
- en: 'But nobody reinvents the wheel the same way. Here’s how Backbone.js provides
    a way to extend base objects:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有人以相同的方式重新发明轮子。以下是 Backbone.js 提供扩展基对象的方法：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here’s how it’s done with React.js:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 React.js 实现的方法：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Backbone provides a method called `initialize` that acts as a pseudo constructor
    function. React does not. But React does autobind its methods when they’re created
    with `createClass`. And this is just the beginning of the differences: we quickly
    compared two here, but there are dozens of JavaScript frameworks that provide
    a base object, which means that you’d need to remember all the subtle differences
    of how different classes work depending on what library or framework you’re using.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 提供了一个名为 `initialize` 的方法，它充当一个伪构造函数。React 没有这个方法。但是，当使用 `createClass`
    创建方法时，React 会自动绑定这些方法。这只是差异的开始：我们在这里快速比较了两个，但实际上有数十个 JavaScript 框架提供了基础对象，这意味着你需要记住根据你使用的库或框架，不同类的工作方式的所有细微差别。
- en: With classes, however, framework authors can now provide a base class that’s
    extendable at the language level. This means that once you learn how to extend
    classes with one framework, you’ll be able to transfer that knowledge, making
    it much easier to switch and learn new frameworks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用类的情况下，框架作者现在可以在语言级别提供一个可扩展的基础类。这意味着一旦你学会了如何使用一个框架扩展类，你就能将这种知识迁移，使得切换和学习新框架变得更加容易。
- en: Lesson 27\. Classes
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课 27\. 类
- en: After reading [lesson 27](kindle_split_041_split_000.xhtml#ch27), you will
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[课 27](kindle_split_041_split_000.xhtml#ch27)后，你将
- en: Understand the syntax for defining classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解定义类的语法
- en: Know how to instantiate classes and how to use constructor functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何实例化类以及如何使用构造函数
- en: Know how to export classes from modules
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何从模块中导出类
- en: Understand that class methods are not bound
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类方法不是绑定的
- en: Know how to assign class and static properties
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何分配类和静态属性
- en: Classes are little more than syntactic sugar for declaring a constructor function
    and setting its prototype. Even with the introduction of classes, JavaScript isn’t
    statically or strongly typed. It remains a dynamically and weakly typed language.
    However, classes do create a simple self-contained syntax for defining constructors
    with prototypes. The main advantage over constructors, though, besides syntax,
    is when extending classes, which we’ll get to in the next lesson. Without having
    an easily extendable built-in construct such as classes, many libraries like Backbone.js,
    React.js, and several others had to continue to reinvent the wheel to allow extending
    their base objects. This library-specific form of extending objects will become
    a thing of the past as more and more libraries start to provide a base JavaScript
    class that can easily be extended. This means once you learn how to use and extend
    classes, you’ll have a jump start on many of today’s and tomorrow’s frameworks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类不过是声明构造函数并设置其原型的语法糖。即使引入了类，JavaScript 也不是静态或强类型。它仍然是一种动态和弱类型语言。然而，类确实为定义具有原型的构造函数提供了一个简单的自包含语法。不过，除了语法之外，主要优势在于扩展类时，我们将在下一课中讨论。如果没有一个易于扩展的内建结构，如类，许多库如
    Backbone.js、React.js 和其他几个库不得不继续重新发明轮子，以允许扩展其基对象。随着越来越多的库开始提供可以轻松扩展的基础 JavaScript
    类，这种特定于库的对象扩展形式将成为过去式。这意味着一旦你学会了如何使用和扩展类，你将在今天和明天的许多框架中领先一步。
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: 'The following two functions are current JavaScript patterns of instantiating
    objects: the factory function and the constructor function. If you were to design
    a new syntax for instantiating objects, how would you improve it?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个函数是当前JavaScript的实例化对象模式：工厂函数和构造函数。如果你要为实例化对象设计一种新的语法，你会如何改进它？
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 27.1\. Class declarations
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.1. 类声明
- en: 'Let’s say you’ll building a web application that needs to connect to several
    APIs for various resources, such as users, teams, and products. You may want to
    create several store objects that store the records for the various resources.
    You could create a store class like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个需要连接到多个API以获取各种资源（如用户、团队和产品）的Web应用程序。你可能想要创建几个存储对象来存储各种资源的记录。你可以创建一个类似以下的存储类：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here you declared a class with the keyword `class` followed by the class name,
    *DataStore*. The name doesn’t have to be capitalized, but it is a convention to
    do so. After the name of the class, you have a pair of braces `{}`: the class
    body, all the methods and properties that make up the class, go between these
    two braces.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用关键字`class`后跟类名*DataStore*声明了一个类。名称不需要大写，但按照惯例应该大写。在类名之后，你有一对大括号`{}`：类体，所有构成类的方法和属性都位于这两个大括号之间。
- en: 'Let’s say, for example, that you need a method called `fetch` on your DataStore
    class to handle fetching the records from the database. You would add a method
    like so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你需要一个名为`fetch`的方法在DataStore类中处理从数据库中获取记录。你会添加一个类似以下的方法：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Adding a method here is the exact same syntax as the shorthand method names
    on objects that you learned about in [lesson 12](kindle_split_022_split_000.xhtml#ch12).
    Don’t let this fool you, though: a class definition is not an object and other
    syntaxes won’t work. The attempt to create a method in the next listing will result
    in a syntax error.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里添加方法与你在第12课中学习的对象上的简写方法名语法完全相同。不过，不要被它迷惑：类定义不是一个对象，其他语法将不起作用。尝试在下一个列表中创建方法将导致语法错误。
- en: Listing 27.1\. Incorrect syntax for adding methods to classes
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表27.1. 向类添加方法的错误语法
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Syntax Error**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 语法错误***'
- en: 'Class methods work like any other function in JavaScipt: they accept parameters
    and can use destructuring and default values. In fact, it’s not the syntax of
    the function here that causes the error, but the use of a colon (`:)`. Colons
    are used to separate property names and property values on object literals, but
    a class declaration doesn’t use them. Also, any use of `this` inside a method
    will refer to the instance, not the class.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法在JavaScript中像任何其他函数一样工作：它们接受参数，可以使用解构和默认值。实际上，导致错误的是函数的语法，而不是冒号（`:`）的使用。冒号用于在对象字面量中分隔属性名和属性值，但类声明不使用它们。此外，任何在方法内部使用`this`的用法都将引用实例，而不是类。
- en: 'Another difference between the class syntax and object syntax is that there
    are no commas separating properties in a class like there are in an object:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类语法和对象语法之间的另一个区别是，在类中属性之间没有逗号分隔，就像在对象中那样：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* No comma separating the two methods**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 两个方法之间没有逗号分隔***'
- en: Notice how there are no commas separating the class methods. If you were creating
    an object, you would need a comma or you would get a syntax error. But in a class
    declaration, the opposite is true in that adding commas will result in a syntax
    error.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到类方法之间没有逗号分隔。如果你在创建一个对象，你需要一个逗号，否则你会得到一个语法错误。但在类声明中，情况正好相反，添加逗号会导致语法错误。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 27.1**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查27.1**'
- en: '**[Q1:](kindle_split_041_split_001.xhtml#ch27qa2q0a1)**'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_041_split_001.xhtml#ch27qa2q0a1)**'
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you spot the two problems in the following car class?
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你能发现以下汽车类中的两个问题吗？
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 27.1 answer**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.1 答案**'
- en: '**[A1:](kindle_split_041_split_001.xhtml#ch27qa1q1)**'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_041_split_001.xhtml#ch27qa1q1)**'
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Commas and colons are not allowed.
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不允许使用逗号和冒号。
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 27.2\. Instantiating classes
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.2. 实例化类
- en: 'Once you have your class definition, you can create an instance of it using
    the `new` keyword:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有你的类定义，你可以使用`new`关键字创建它的一个实例：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Create an instance of DataStore in a new constant named dataStore.**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在一个名为dataStore的新常量中创建DataStore的实例。***'
- en: 'If you try to instantiate the class without the new keyword, you receive a
    TypeError:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在没有`new`关键字的情况下实例化类，你会收到一个TypeError：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Class constructor DataStore can’t be invoked without ‘new’**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 类构造函数DataStore不能在没有‘new’的情况下调用***'
- en: 'You can also pass arguments to your new class instance when creating an instance
    like so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在创建实例时传递参数，如下所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, this raises the question: how does the class receive these parameters?
    There’s a special method name called `constructor` that gets invoked automatically
    when an instance is created. Any arguments given when creating a new instance
    will be passed to this constructor function.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这引发了一个问题：类是如何接收这些参数的？有一个特殊的方法名叫做`constructor`，当创建实例时会自动调用。创建新实例时给出的任何参数都将传递给这个构造函数。
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The constructor function gets invoked in the context of the instance that’s
    being created. That means that `this` inside of the constructor function will
    refer to the instance that’s being created, not the class itself. The constructor
    function is optional, and is provided as a hook to do any initial setup on instances
    of your classes. The placement of the constructor function doesn’t matter, but
    I like to keep mine at the top.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在创建实例的上下文中被调用。这意味着构造函数内部的`this`将指向正在创建的实例，而不是类本身。构造函数是可选的，它提供了一个钩子，可以在类的实例上进行任何初始设置。构造函数的位置并不重要，但我喜欢将其放在顶部。
- en: In the next section we’ll take a quick look at exporting classes from modules.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将快速查看如何从模块中导出类。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 27.2**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查27.2**'
- en: '**[Q1:](kindle_split_041_split_002.xhtml#ch27qa4q0a1)**'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_041_split_002.xhtml#ch27qa4q0a1)**'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be logged when creating the following class?
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建以下类时将记录什么？
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 27.2 answer**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.2答案**'
- en: '**[A1:](kindle_split_041_split_002.xhtml#ch27qa3q1)**'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_041_split_002.xhtml#ch27qa3q1)**'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “created a pet dog”
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “创建了一只宠物狗”
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 27.3\. Exporting classes
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.3\. 导出类
- en: 'When creating JavaScript classes, it’s likely that you’ll do so in modules.
    That means that you’ll need to be able to export them. For example, if you wanted
    to export the `DataStore` class you created from a module, you could do it like
    this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建JavaScript类时，你很可能会在模块中这样做。这意味着你需要能够导出它们。例如，如果你想从一个模块中导出你创建的`DataStore`类，你可以这样做：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Specify the DataStore class as the default export.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将DataStore类指定为默认导出。**'
- en: 'This exports the class as the default. Importing it is the same as importing
    any other default; you can use any name you desire:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将类作为默认导出。导入它与导入任何其他默认导出相同；你可以使用你想要的任何名称：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Additionally you can omit the default and export the class by name:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你也可以省略默认导出，并按名称导出类：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Export the DataStore class under the name DataStore.**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将DataStore类以DataStore名称导出。**'
- en: 'As you probably guessed, this exports the class as the name DataStore and it
    must be imported using its name:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这会将类导出为`DataStore`名称，并且必须使用其名称导入：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In most cases you’ll likely want to only create one class per module and export
    it as the default.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你可能只想在每个模块中创建一个类并将其作为默认导出。
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 27.3**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查27.3**'
- en: '**[Q1:](kindle_split_041_split_003.xhtml#ch27qa6q0a1)**'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_041_split_003.xhtml#ch27qa6q0a1)**'
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following two class exports are valid?
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下两种类导出哪一种是有效的？
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 27.3 answer**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.3答案**'
- en: '**[A1:](kindle_split_041_split_003.xhtml#ch27qa5q1)**'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_041_split_003.xhtml#ch27qa5q1)**'
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: They’re both valid.
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们都是有效的。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 27.4\. Class methods are not bound
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.4\. 类方法未绑定
- en: Some developers new to classes may be surprised to find out that class methods
    are not automatically bound. Let’s say, for example, that the `DataStore` class
    uses an `ajax` library internally to handle the API calls. You may have something
    set up like the next listing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对类新接触的开发者可能会惊讶地发现，类方法并不是自动绑定的。比如说，假设`DataStore`类内部使用`ajax`库来处理API调用。你可能会有如下设置。
- en: Listing 27.2\. Using unbound methods as callbacks
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表27.2\. 使用未绑定方法作为回调
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Making an ajax call and specifying this.handleNewRecords as the callback**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 发起ajax调用并指定this.handleNewRecords作为回调**'
- en: '***2* The keyword this will not point to the instance because it isn’t bound.**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 关键字this不会指向实例，因为它没有被绑定。**'
- en: 'In [listing 27.2](kindle_split_041_split_004.xhtml#ch27ex02) you’ll use an
    `ajax` library to fetch records for you. The `ajax` library takes two arguments:
    the URL to load data from, and a callback function to invoke with the data once
    loaded. This may seem like everything is fine, but since the `handleNewRecords`
    method isn’t bound, when it’s invoked from the `ajax` library, `this` will no
    longer point to the `DataStore` instance so the records won’t get properly stored.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 27.2](kindle_split_041_split_004.xhtml#ch27ex02)中，你将使用一个`ajax`库来为你获取记录。`ajax`库接受两个参数：加载数据的URL和一个回调函数，一旦数据加载完成就调用该函数。这看起来似乎一切正常，但由于`handleNewRecords`方法未绑定，当它从`ajax`库中调用时，`this`将不再指向`DataStore`实例，因此记录将无法正确存储。
- en: 'There are a few different ways to fix this. The simplest is to use an arrow
    function as the callback:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以解决这个问题。最简单的是使用箭头函数作为回调：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will work just fine. But if your callback is more complex and is used
    in multiple places, this approach may not be suitable. You can still use an arrow
    function, but as an intermediary step:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正常工作。但如果你的回调更复杂，并且被用在多个地方，这种方法可能就不合适了。你仍然可以使用箭头函数，但作为一个中间步骤：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the next lesson, you’ll learn one more way of binding methods when you learn
    about class properties.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，当你学习类属性时，你将了解绑定方法的一种新方式。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 27.4**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.4**'
- en: '**[Q1:](kindle_split_041_split_004.xhtml#ch27qa8q0a1)**'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_041_split_004.xhtml#ch27qa8q0a1)**'
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Invoking `car.delayedHonk()` will result in an error. Why?
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调用`car.delayedHonk()`将导致错误。为什么？
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 27.4 answer**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.4 答案**'
- en: '**[A1:](kindle_split_041_split_004.xhtml#ch27qa7q1)**'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_041_split_004.xhtml#ch27qa7q1)**'
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because `this.honk` is used as a callback but is not bound.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为`this.honk`被用作回调但未绑定。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 27.5\. Setting instance properties in class definitions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.5. 在类定义中设置实例属性
- en: There’s another aspect of classes that, at the time of this writing, is just
    a proposal but is gaining lots of use, and that’s setting instance properties
    in class definitions. Setting properties in classes (unlike methods) may seem
    simple at first, but actually has more to it than might initially meet the eye.
    This is because the methods are added to the prototype, but the properties are
    assigned to each instance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，类的一个方面只是一个提议，但正在得到广泛的应用，那就是在类定义中设置实例属性。在类中设置属性（与方法不同）乍一看可能很简单，但实际上比表面看起来要复杂得多。这是因为方法被添加到原型中，但属性被分配给每个实例。
- en: Let’s assume you want to set up a property on your `DataStore` to determine
    the URL of the resource. You also want an array property to store the actual records
    in. You could do so as shown in the following listing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在`DataStore`上设置一个属性来确定资源的URL。你还想有一个数组属性来存储实际的记录。你可以像以下列表所示那样做。
- en: Listing 27.3\. Setting properties on classes
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.3. 在类上设置属性
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* A property named url**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个名为url的属性**'
- en: '***2* A property named records**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个名为records的属性**'
- en: '***3* undefined**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* undefined**'
- en: '***4* “/data/resources”**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* “/data/resources”**'
- en: '***5* 0**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 0**'
- en: 'The properties, as you can see, will be available on the instance that gets
    created, not the class itself. Notice how class properties look like an assignment
    directly in the class definition. This is because they technically are an assignment.
    Unlike class methods, class properties are a syntactic sugar that gets rewritten
    directly in the constructor function. That means the `url` and `records` assignments
    you just set would actually end up being as if you had made them inside the constructor
    function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，属性将在创建的实例上可用，而不是类本身。注意类属性看起来就像直接在类定义中进行的赋值。这是因为它们在技术上就是赋值。与类方法不同，类属性是一种语法糖，它直接在构造函数中被重写。这意味着你刚刚设置的`url`和`records`赋值实际上就像你在构造函数内部做了它们一样：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is different from class methods, because those get added to the class’s
    prototype. The instances then inherit those methods via prototypical inheritance.
    But the class properties don’t get set on the prototype; they end up being set
    directly on the instance itself. Setting properties directly on the prototype
    would lead to bugs. Let’s explore why in an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这与类方法不同，因为那些方法会被添加到类的原型中。实例随后通过原型继承继承那些方法。但类属性不会设置在原型上；它们最终直接设置在实例本身上。直接在原型上设置属性会导致错误。让我们通过一个例子来探讨原因：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* 0**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 0**'
- en: '***2* 1**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 1**'
- en: '***3* ‘Example Record’**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* ‘Example Record’**'
- en: Here you set the `records` property directly on the `DataStore`’s prototype
    instead of the instance. This means all instances will use the same records array
    because it’s set on their prototype, not on the instance objects themselves. When
    object `storeB` adds a record, `storeA` receives a new record as well. They’re
    sharing the same records array!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你直接在`DataStore`的原型上设置`records`属性，而不是在实例上。这意味着所有实例都将使用相同的记录数组，因为它是设置在它们的原型上，而不是在实例对象本身上。当对象`storeB`添加记录时，`storeA`也会收到一个新的记录。它们正在共享同一个记录数组！
- en: 'One obvious benefit of class instance properties is declaring bound methods.
    In the last section, you were running into some issues because your `handleNewRecords`
    method wasn’t bound to the instance. You could make it bound by declaring it as
    a property pointing to an arrow function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类实例属性的一个明显好处是声明绑定方法。在上一个部分中，你遇到了一些问题，因为你的`handleNewRecords`方法没有绑定到实例上。你可以通过将其声明为一个指向箭头函数的属性来使其绑定：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the next section we’ll take a look at another type of class property, static
    properties.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨另一种类型的类属性，即静态属性。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.5**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.5**'
- en: '**[Q1:](kindle_split_041_split_005.xhtml#ch27qa10q0a1)**'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_041_split_005.xhtml#ch27qa10q0a1)**'
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The following class suffers from a syntax mistake common with class properties.
    Can you spot it?
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下类存在一个常见的类属性语法错误。你能找到它吗？
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.5 answer**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.5 答案**'
- en: '**[A1:](kindle_split_041_split_005.xhtml#ch27qa9q1)**'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_041_split_005.xhtml#ch27qa9q1)**'
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It should be
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它应该是
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 27.6\. Static properties
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.6\. 静态属性
- en: 'Static properties on classes are a special type of property that doesn’t set
    a property on the instance or even the prototype, but on the class object (the
    constructor) itself. Static properties make sense for properties that won’t change
    across instances. For example, your `DataStore` could potentially have a static
    property for what domain to use when connecting to APIs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类上的静态属性是一种特殊的属性，它不会在实例或原型上设置属性，而是在类对象（构造函数）本身上设置。静态属性对于不会在实例之间变化的属性是有意义的。例如，你的`DataStore`可能有一个静态属性，用于在连接到API时使用哪个域：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Assigning a static property**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 分配静态属性**'
- en: '***2* Setting a static method**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置静态方法**'
- en: '***3* Invoking the static method**'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用静态方法**'
- en: '***4* “https://example.com/user**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* “https://example.com/user**'
- en: You use a static property `domain` and a static method ``url``^([[1](kindle_split_041_split_006.xhtml#ch27fn01)])
    to generate the instance’s URL from the specified resource in the constructor
    function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用一个静态属性`domain`和一个静态方法`url`^([[1](kindle_split_041_split_006.xhtml#ch27fn01)])来从构造函数函数中指定的资源生成实例的URL。
- en: ¹
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While static properties are at the time of this writing still just a proposal,
    static methods were introduced in ES2015.
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然静态属性在撰写本文时仍然只是一个提案，但静态方法是在ES2015中引入的。
- en: Static properties are just syntactic sugar for assigning them directly on the
    classes themselves, as shown in the next listing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 静态属性只是将它们直接分配到类本身上的语法糖，如下一列表所示。
- en: Listing 27.4\. Desugaring static properties
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 27.4\. 静态属性的简化
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That sums up creating and using classes, but we aren’t done with classes yet.
    In the next lesson we’ll take a look at extending classes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了创建和使用类的方法，但我们还没有结束类。在下一节课中，我们将探讨如何扩展类。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 27.6**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 27.6**'
- en: '**[Q1:](kindle_split_041_split_006.xhtml#ch27qa12q0a1)**'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_041_split_006.xhtml#ch27qa12q0a1)**'
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following `console.log`s actually logs the number of wheels?
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个`console.log`实际上记录了轮子的数量？
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 27.6 answer**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 27.6 答案**'
- en: '**[A1:](kindle_split_041_split_006.xhtml#ch27qa11q1)**'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_041_split_006.xhtml#ch27qa11q1)**'
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson you learned how to define and use your own classes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你学习了如何定义和使用自己的类。
- en: Classes are created with the `class` keyword followed by the class name and
    class body.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是通过`class`关键字、类名和类体来创建的。
- en: Class methods use the shorthand method syntax for declaring methods.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法使用简写方法语法来声明方法。
- en: Classes don’t support colons for declaring properties or methods.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类不支持用于声明属性或方法的冒号。
- en: Classes shouldn’t have commas separating methods or properties.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类不应该用逗号分隔方法或属性。
- en: The constructor function is executed when the class is instantiated.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数在类实例化时执行。
- en: Class methods aren’t automatically bound to the instance.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法不是自动绑定到实例上的。
- en: 'Let’s see if you got this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个：
- en: '**[Q27.1](kindle_split_050_split_019.xhtml#app01qa19q0a1)**'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q27.1](kindle_split_050_split_019.xhtml#app01qa19q0a1)**'
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Take the following constructor function and prototype and convert it into a
    class:'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将以下构造函数和原型转换为类：
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Lesson 28\. Extending classes
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 28 课\. 扩展类
- en: After reading [lesson 28](kindle_split_042_split_000.xhtml#ch28), you will
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第 28 课](kindle_split_042_split_000.xhtml#ch28)后，你将
- en: Know how to extend classes to create more customized classes
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何扩展类以创建更定制化的类
- en: Learn how to use libraries that provide a base class
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用提供基类的库
- en: Understand how inheritance works with classes
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类如何进行继承
- en: Know how to use `super` to invoke functions on the superclass
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用`super`在超类上调用函数
- en: The best feature classes offer over traditional constructor function declarations
    is their ease of extension. Many consider the syntax for extending constructor
    functions clunky. This has led many library authors to create their own ways to
    extend base objects in their libraries. With built-in extendable classes, developers
    can learn one simple syntax that can be used everywhere. One crucial aspect to
    keep in mind when extending classes in JavaScript, however, is that they still
    use prototypal inheritance.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的构造函数声明相比，类提供的最佳特性是它们易于扩展。许多人认为扩展构造函数的语法很笨拙。这导致许多库的作者在自己的库中创建了扩展基对象自己的方式。有了内置的可扩展类，开发者可以学习一种简单语法，可以在任何地方使用。然而，在JavaScript中扩展类时，需要记住的一个关键方面是它们仍然使用原型继承。
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: In the following code, you have a `plane` object and a `jet` object. In a sense,
    the jet object extends the plane object because it copies all of its properties
    and overrides its `fly` method. If the jet’s `fly` method has overlapping logic
    with the plane’s `fly` method, how would you go about making them able to share
    code across the two methods?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，你有一个`plane`对象和一个`jet`对象。在某种程度上，`jet`对象扩展了`plane`对象，因为它复制了所有属性并覆盖了其`fly`方法。如果`jet`的`fly`方法与`plane`的`fly`方法有重叠的逻辑，你将如何使它们能够在两个方法之间共享代码？
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 28.1\. Extends
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.1\. 扩展
- en: 'Let’s continue to use the `DataStore` example from [lesson 27](kindle_split_041_split_000.xhtml#ch27).
    Assume you wanted to create a `TeamStore` that was a customized version of a `DataStore`.
    Your `TeamStore` needs the base functionality of a `DataStore`, but also needs
    a couple additional methods for adding or removing users from a team. You could
    create a `TeamStore` that extends the `DataStore` as shown in the following listing:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用[第 27 课](kindle_split_041_split_000.xhtml#ch27)中的`DataStore`示例。假设你想要创建一个`TeamStore`，它是`DataStore`的定制版本。你的`TeamStore`需要`DataStore`的基本功能，但还需要添加或删除用户的方法。你可以创建一个扩展`DataStore`的`TeamStore`，如下所示：
- en: Listing 28.1\. Extending a class
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.1\. 扩展类
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here in [listing 28.1](kindle_split_042_split_001.xhtml#ch28ex01) you created
    a new class called `TeamStore` that extends from `DataStore`. By making `TeamStore`
    extend from `DataStore`, the `DataStore` prototype gets appended to the `TeamStore`
    prototype chain. This means that when an instance of `TeamStore` is created, the
    prototype chain will be as follows: the `TeamStore` instance delegates to the
    `TeamStore` prototype, which in turn delegates to the `DataStore` prototype that
    it inherited from. The `DataStore` prototype delegates back to the `Object` prototype,
    which delegates to `null` (see [figure 28.1](kindle_split_042_split_001.xhtml#ch28fig01)).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 28.1](kindle_split_042_split_001.xhtml#ch28ex01)中，你创建了一个名为`TeamStore`的新类，它从`DataStore`扩展而来。通过使`TeamStore`从`DataStore`扩展，`DataStore`原型被附加到`TeamStore`原型链上。这意味着当创建`TeamStore`的实例时，原型链将是这样的：`TeamStore`实例委托给`TeamStore`原型，该原型反过来委托给从它继承而来的`DataStore`原型。`DataStore`原型将委托回`Object`原型，该原型委托给`null`（见[图
    28.1](kindle_split_042_split_001.xhtml#ch28fig01)）。
- en: Figure 28.1\. Prototypal inheritance
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 28.1\. 原型继承
- en: '![](Images/28fig01_alt.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/28fig01_alt.jpg)'
- en: 'When you create an instance of `TeamStore` and invoke methods on the instance,
    if the instance doesn’t have the method in question, the instance’s prototype
    that the `DataStore` defined is then checked. If the method is still not found,
    it continues down the prototype chain looking for the method. This isn’t new:
    this is how inheritance has always worked in JavaScript, and that hasn’t changed
    with classes.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建`TeamStore`的实例并在实例上调用方法时，如果实例没有该方法，则检查`DataStore`定义的实例原型。如果仍然找不到该方法，它将继续沿着原型链查找该方法。这并不新鲜：这是JavaScript中继承一直以来的工作方式，并且随着类的出现并没有改变。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 28.1**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.1**'
- en: '**[Q1:](kindle_split_042_split_001.xhtml#ch28qa2q0a1)**'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_042_split_001.xhtml#ch28qa2q0a1)**'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the full prototype chain of the `migaloo` object?
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`migaloo`对象的完整原型链是什么？'
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.1 answer**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.1 答案**'
- en: '**[A1:](kindle_split_042_split_001.xhtml#ch28qa1q1)**'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_042_split_001.xhtml#ch28qa1q1)**'
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: instance → Humpback → Whale → Object → null
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: instance → Humpback → Whale → Object → null
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.2\. Super
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.2\. Super
- en: 'When you defined `DataStore` in the previous example, you made the constructor
    function accept a parameter indicating the URL of the resource it was responsible
    for:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在前面的例子中定义`DataStore`时，你让构造函数接受一个参数，表示它负责的资源URL：
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This means that you would still need to specify the resource when creating an
    instance of `TeamStore`, even though `TeamStore` always uses the same URL. You
    could make this automatic in the constructor of `TeamStore` by using `super`,
    as shown in the following listing.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，即使`TeamStore`总是使用相同的URL，你仍然需要在创建`TeamStore`的实例时指定资源。你可以在`TeamStore`的构造函数中使用`super`来实现这一点，如下列表所示。
- en: Listing 28.2\. Invoking the superclass constructor with `super`
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.2\. 使用 `super` 调用超类构造函数
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Invoking super() invokes the constructor of the super class.**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用 super() 调用超类的构造函数。**'
- en: Inside `TeamStore`’s constructor, you invoked the constructor of its superclass
    (the class it extends from) using the special keyword `super`. This allows you
    to automatically set the TeamStore’s URL to `"/teams"`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TeamStore`的构造函数中，你使用特殊关键字`super`调用了其超类（它扩展的类）的构造函数。这允许你自动将`TeamStore`的URL设置为`"/teams"`。
- en: 'Inside a constructor function of any class that extends another, the invocation
    of `super` is required before any reference to `this` can be made:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何扩展另一个类的类的构造函数中，在可以引用`this`之前，必须调用`super`：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* ReferenceError: this is not defined**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ReferenceError: this is not defined**'
- en: The keyword `super` doesn’t actually reference anything. It’s a special keyword
    that allows you to invoke the constructor of the superclass or access and invoke
    other methods on the superclass. Let’s say, for example, that you have a products
    store and you want to update an analytics object about which products are accessed.
    You could override the `DataStore`’s `fetch` function to add your extra logic.
    However, you will still want the original `fetch` function (the one you overrode)
    to be invoked, and you can do so using `super.fetch` as shown in the next listing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`super`实际上不引用任何东西。它是一个特殊的关键字，允许你调用超类的构造函数或访问和调用超类上的其他方法。比如说，如果你有一个产品商店，你想要更新一个关于哪些产品被访问的分析对象。你可以覆盖`DataStore`的`fetch`函数来添加你的额外逻辑。然而，你仍然想要调用原始的`fetch`函数（你覆盖的那个），你可以使用`super.fetch`来这样做，如下一列表所示。
- en: Listing 28.3\. Invoking superclass methods with `super`
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.3\. 使用 `super` 调用超类方法
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When you reference `super[name]` you can access any property by `name` on the
    superclass’s prototype. Here you used `super.fetch` to invoke the `fetch` method
    on the superclass.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当你引用`super[name]`时，你可以通过`name`在超类的原型上访问任何属性。在这里，你使用了`super.fetch`来在超类上调用`fetch`方法。
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.2**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.2**'
- en: '**[Q1:](kindle_split_042_split_002.xhtml#ch28qa4q0a1)**'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_042_split_002.xhtml#ch28qa4q0a1)**'
- en: ''
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s wrong with the following code?
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码有什么问题？
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|  |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 28.2 answer**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.2 答案**'
- en: '**[A1:](kindle_split_042_split_002.xhtml#ch28qa3q1)**'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_042_split_002.xhtml#ch28qa3q1)**'
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`this` can’t be referenced in the constructor of an extending class until `super()`
    is invoked.'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在扩展类的构造函数中，`this`不能被引用，直到`super()`被调用。
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.3\. A common gotcha when extending classes
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.3\. 扩展类时常见的陷阱
- en: 'In the previous lesson we went over a way to bind methods by setting class
    properties that point to arrow functions:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一课中，我们介绍了一种通过设置指向箭头函数的类属性来绑定方法的方法：
- en: '[PRE41]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is a common pattern that I’ve seen all over in the wild. The problem with
    this approach is that `handleNewRecords` doesn’t get added to the `DataStore`
    prototype. It gets added directly onto the instance that gets created. This means
    that it can’t be accessed with `super`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种我在野外随处可见的常见模式。这种方法的缺点是`handleNewRecords`没有被添加到`DataStore`的原型上。它是直接添加到创建的实例上的。这意味着它不能通过`super`来访问。
- en: If you don’t plan on the method ever needing to be invoked via `super` in a
    subclass, then this approach is fine. Otherwise you’ll need a new approach. So
    how can you bind a method but still make it extendable and invokable via `super`?
    One approach is to define it as an actual method, then bind the method to the
    instance inside the constructor, as the following listing shows.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有计划在子类中通过 `super` 调用该方法，那么这种方法是可行的。否则，你需要一种新的方法。那么，如何绑定一个方法，同时仍然使其可扩展并通过
    `super` 调用？一种方法是将它定义为一个实际的方法，然后在构造函数中将方法绑定到实例上，如下所示。
- en: Listing 28.4\. Binding methods in a way that works with `super`
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表28.4\. 以一种与 `super` 一起工作的方式绑定方法
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Bind the handleNewRecords method from the prototype onto the instance.**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将原型上的 handleNewRecords 方法绑定到实例上。**'
- en: This works because it still assigns the method to the instance, but the definition
    originates from a method on the prototype. The subclass can override the instance
    method on the superclass, and even use `super`, and the subclass’s overridden
    instance method will then get bound to the instance. See [figure 28.2](kindle_split_042_split_003.xhtml#ch28fig02).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为它仍然将方法分配给实例，但定义来源于原型上的方法。子类可以覆盖超类上的实例方法，甚至使用 `super`，然后子类的覆盖实例方法将被绑定到实例上。参见[图28.2](kindle_split_042_split_003.xhtml#ch28fig02)。
- en: Figure 28.2\. How the `handleNewRecords` method gets invoked on the prototype
    chain
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图28.2\. `handleNewRecords` 方法如何在原型链上被调用
- en: '![](Images/28fig02_alt.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/28fig02_alt.jpg)'
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 28.3**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查28.3**'
- en: '**[Q1:](kindle_split_042_split_003.xhtml#ch28qa6q0a1)**'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_042_split_003.xhtml#ch28qa6q0a1)**'
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why won’t the following code work?
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么以下代码无法工作？
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 28.3 answer**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 28.3 答案**'
- en: '**[A1:](kindle_split_042_split_003.xhtml#ch28qa5q1)**'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_042_split_003.xhtml#ch28qa5q1)**'
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Both `dive` properties are set directly on the instance, so the second one completely
    overrides the first. There is no `dive` method on the prototype chain, so it can’t
    be accessed via `super`.
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两个 `dive` 属性都是直接在实例上设置的，所以第二个完全覆盖了第一个。原型链上没有 `dive` 方法，因此无法通过 `super` 访问。
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, you learned how to extend classes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你学习了如何扩展类。
- en: You extend classes using the `extends` keyword.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `extends` 关键字扩展类。
- en: Classes use prototypal inheritance.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类使用原型继承。
- en: You can access the superclass’s constructor and methods with the `super` keyword.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `super` 关键字访问超类的构造函数和方法。
- en: '`super` must be invoked in the constructor of a subclass before `this` can
    be referenced.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super` 必须在子类的构造函数中调用，然后才能引用 `this`。'
- en: Class properties are set on the instance, and thus can’t be accessed with `super`.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类属性是在实例上设置的，因此不能使用 `super` 访问。
- en: 'Let’s see if you got this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这些：
- en: '**[Q28.1](kindle_split_050_split_020.xhtml#app01qa20q0a1)**'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q28.1](kindle_split_050_split_020.xhtml#app01qa20q0a1)**'
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a class that extends the following `Car` class. Add a method called `fuel`
    that resets the gas back to 50\. Additionally, override the `drive` method to
    accept a parameter of a number called `miles`, then invoke the superclass’s `drive`
    method enough times to drive that many miles:'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个扩展以下 `Car` 类的类。添加一个名为 `fuel` 的方法，将油量重置为50。然后覆盖 `drive` 方法，接受一个名为 `miles`
    的数字参数，然后调用足够多的超类 `drive` 方法来行驶这么多英里：
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Lesson 29\. Capstone: Comets'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第29课. 顶点：彗星
- en: In this capstone you’re going to build an Asteroids-like game called Comets,
    shown in [figure 29.1](kindle_split_043_split_000.xhtml#ch29fig01).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个顶点项目中，你将构建一个类似《小行星》的游戏，名为彗星，如图29.1所示。
- en: Figure 29.1\. Comets game
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图29.1\.彗星游戏
- en: '![](Images/29fig01.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/29fig01.jpg)'
- en: 'There are many valid reasons why you would create a base class or a class that
    doesn’t extend anything. But I think the majority of most developers’ time spent
    with classes will be extending base classes provided from a framework such as
    React.js. For this capstone, you’re going to be working with a game framework
    that I have put together: the framework (like most frameworks) will handle most
    of the moving parts while giving you some base classes you can customize to create
    a unique game.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多有效的理由可以创建一个基类或者不扩展任何东西的类。但我认为，大多数开发者的大部分时间都将花费在扩展由React.js等框架提供的基类上。对于这个顶点项目，你将使用我整理的游戏框架：这个框架（就像大多数框架一样）将处理大部分的动态部分，同时给你一些可以自定义以创建独特游戏的基础类。
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'You’ll start your project using the start folder included in the code accompanying
    this book. If at any time you get stuck, you can also check out the final folder
    with the completed game. The start folder is a project already set up to use Babel
    and Browserify (see unit 0); you just need to run `npm install` to get set up.
    If you haven’t read unit 0, you should before doing this capstone. There’s also
    an included index.html file: this is where the game will run. It already includes
    all the HTML and CSS it needs; you just need to open it in a browser once you
    bundle your JavaScript files. The src folder is where you’ll put all your JavaScript
    files; there are a couple already included. The dest folder is where the bundled
    JavaScript file will go after you run `npm run build`. You’ll need to remember
    to run `npm run build` to compile your code anytime you make a change.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用这本书附带的代码中包含的start文件夹开始你的项目。如果你在任何时候遇到困难，你还可以查看包含完成游戏的final文件夹。start文件夹是一个已经设置好以使用Babel和Browserify的项目（见单元0）；你只需要运行`npm
    install`来设置。如果你还没有阅读单元0，你应该在完成这个项目之前先阅读。还有一个包含的`index.html`文件：游戏将在其中运行。它已经包含了所有需要的HTML和CSS；你只需要在捆绑你的JavaScript文件后将其在浏览器中打开。src文件夹是放置所有JavaScript文件的地方；其中已经包含了一些。dest文件夹是在你运行`npm
    run build`后捆绑的JavaScript文件将去的地方。你需要记住，每次你做出更改时都要运行`npm run build`来编译你的代码。
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 29.1\. Creating a controllable sprite
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.1\. 创建一个可控制的精灵
- en: You’ll start out by getting something on the screen as quickly as possible.
    Make sure you’re starting with the start folder included in the code accompanying
    this book. If you look in the src folder, you’ll see there’s already a framework
    folder and a shapes.js file. The framework folder contains the game framework,
    and the shapes.js file includes some arrays and functions for describing the shape
    of the game’s actors. Feel free to explore the code in any of these files.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你将尽快在屏幕上显示一些内容。确保你从这本书附带的代码中包含的start文件夹开始。如果你查看src文件夹，你会看到那里已经有一个框架文件夹和一个shapes.js文件。框架文件夹包含游戏框架，而shapes.js文件包含一些数组和函数，用于描述游戏角色的形状。你可以自由探索这些文件中的代码。
- en: Create a file in the src directory called comet.js with the following code.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在src目录下创建一个名为comet.js的文件，包含以下代码。
- en: '[PRE45]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* The base class comes from the game framework you’re using.**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 基础类来自你使用的游戏框架。**'
- en: '***2* The spaceship from your included shapes**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你包含的形状中的宇宙飞船**'
- en: '***3* Your ship class extends the controllable sprite class.**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你的飞船类扩展了可控制精灵类。**'
- en: '***4* Setting some static properties**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 设置一些静态属性**'
- en: This is a simple class, but it does a lot because you’re extending from `ControllableSprite`,
    which itself extends from `Sprite`. The `Sprite` class is the baseline for any
    object that will be painted on the screen. The `ControllableSprite` class adds
    functionality for the user to control the sprite using the keyboard’s arrow keys.
    You set the static properties `shape` and `stroke`, which determine what Ship
    sprites will look like. Go ahead and experiment with other shapes and colors once
    you get this one painted on the screen.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，但它做了很多，因为你是从`ControllableSprite`类扩展的，而`ControllableSprite`类本身又扩展自`Sprite`类。`Sprite`类是任何将在屏幕上绘制的对象的基线。`ControllableSprite`类增加了用户使用键盘箭头键控制精灵的功能。你设置了静态属性`shape`和`stroke`，这些属性决定了飞船精灵的外观。一旦你在屏幕上绘制了这个，就可以尝试其他形状和颜色。
- en: You’re almost ready to see this painted on the screen, and even control it.
    Create another file in the src folder called index.js and add the following code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎准备好在屏幕上看到并控制这个了。在src文件夹中创建另一个名为index.js的文件，并添加以下代码。
- en: '[PRE46]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* The start function from the framework starts the game.**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 框架中的start函数启动游戏。**'
- en: '***2* Import the class you previously created.**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入你之前创建的类。**'
- en: '***3* Create an instance of your ship class.**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建你的飞船类的实例。**'
- en: '***4* Start the game.**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 启动游戏。**'
- en: This code is also pretty simple. You’re just creating an instance of your `Ship`
    class and telling the game to start. The index.js file will be the root file of
    your source code that starts the game. If you compile your code now and open the
    included index.html file, you’ll see the ship you just created. Even more, by
    using the arrow keys you can move it around!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也很简单。你只是创建了一个`Ship`类的实例，并告诉游戏开始。`index.js`文件将是你的源代码的根文件，它启动游戏。如果你现在编译你的代码并打开包含的`index.html`文件，你会看到你刚刚创建的飞船。甚至更多，通过使用箭头键，你可以移动它！
- en: 29.2\. Adding comets
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.2\. 添加彗星
- en: 'Now that you can move around, your ship looks rather lonely. You’re going to
    add some additional actors to your game. In the src folder create a file called
    comet.js with the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以移动了，你的飞船看起来相当孤单。你将向你的游戏中添加一些额外的角色。在src文件夹中创建一个名为comet.js的新文件，并添加以下代码：
- en: '[PRE47]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Default options for each comet**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*每个彗星的默认选项**'
- en: '***2* The comet extends the DriftingSprite class.**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*彗星扩展了DriftingSprite类。**'
- en: '***3* The constructor accepts options.**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*构造函数接受选项。**'
- en: '***4* Invoke super with options and default options merged together.**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*将选项和默认选项合并后调用super。**'
- en: '***5* Set the comet’s shape.**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*设置彗星的形状。**'
- en: The `Comet` class is a bit more complex than the previous two examples, so let’s
    dive into what’s going on here. All sprites in the game framework can be given
    initial options (properties) as arguments to the constructor. You didn’t need
    any for your ship, but you do for each comet. The sprites are flexible in how
    to set their properties. They can be static like the `stroke` property, or set
    on the instance like the `shape` property.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comet`类比前两个例子稍微复杂一些，所以让我们深入了解一下这里的情况。游戏框架中的所有精灵都可以通过构造函数的参数传递初始选项（属性）。你的飞船不需要这些选项，但每个彗星都需要。精灵在设置属性方面很灵活。它们可以是静态的，比如`stroke`属性，或者像`shape`属性一样设置在实例上。'
- en: What’s the purpose of setting some properties as static and some on the instance?
    All of your comets will have the same green stroke, so you can set that as a static
    property on the class itself. But you want each comet to have a unique shape so
    that it looks like an individual comet, not carbon copy. Because each comet’s
    shape is unique, it needs to be set on the instance.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要把一些属性设置为静态，而把一些设置为实例属性？你的所有彗星都将有相同的绿色描边，所以你可以将其设置为类本身的静态属性。但你想让每个彗星都有独特的形状，这样它看起来就像一个单独的彗星，而不是复制品。因为每个彗星的形状都是独特的，所以它需要设置在实例上。
- en: The function `cometShape` returns a random shape with a given size and sides.
    By calling this function in the constructor, you ensure that each comet has its
    own unique shape.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`cometShape`返回一个给定大小和边的随机形状。通过在构造函数中调用此函数，你确保每个彗星都有其独特的形状。
- en: 'Now that you have your `Comet` class, you need to import it and create a few
    instances before starting your game. Update the index.js file like so:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了`Comet`类，你需要在开始游戏之前导入它并创建几个实例。像这样更新index.js文件：
- en: '[PRE48]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Import your Comet class.**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*导入你的Comet类。**'
- en: '***2* Create a few instances.**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*创建几个实例。**'
- en: Now if you bundle your code again, you should see some comets floating around
    with your ship.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你再次打包你的代码，你应该会看到一些彗星在你的飞船周围漂浮。
- en: 29.3\. Shooting rockets
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.3\. 射击火箭
- en: 'Obviously now that you have all these floating targets, you want to do some
    shooting! Next you’ll get some rockets on the screen. First create the rocket
    class. Create a new file in the src folder called rocket.js with the following
    code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，现在你有了所有这些漂浮的目标，你想要射击！接下来你将在屏幕上得到一些火箭。首先创建火箭类。在src文件夹中创建一个名为rocket.js的新文件，并添加以下代码：
- en: '[PRE49]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Nothing here is all that new yet. This is very similar to your comet, albeit
    with a different shape, of course. You also gave your rocket a fill instead of
    a stroke. One new property, though, is `removeOnExit`. Normally when sprites exit
    the screen, they reappear on the other side. This property tells your game to
    remove the sprite once it leaves the viewable area.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还没有什么特别新的内容。这与你之前的彗星非常相似，当然，形状不同。你还给你的火箭添加了填充而不是描边。不过，有一个新属性是`removeOnExit`。通常情况下，当精灵离开屏幕时，它们会在另一边重新出现。这个属性告诉你的游戏，一旦精灵离开可视区域，就将其移除。
- en: 'Now you need to get some rockets on the screen. You don’t want to just create
    instances before starting the game like you did with the ship and comets. You
    want to *fire* rockets from the ship at your command! There are a few helper functions
    provided by the game framework that you’re going to need to pull this off. Open
    the ship.js file and add the following imports to the top:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要在屏幕上得到一些火箭。你不想在开始游戏之前像飞船和彗星那样创建实例。你想要从飞船上*发射*火箭！游戏框架提供了一些辅助函数，你需要使用这些函数来实现这一点。打开ship.js文件，并在顶部添加以下导入：
- en: '[PRE50]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `isPressingSpace` function tells you if the player is pressing the spacebar.
    You’ll use this to indicate the intent to fire a rocket. When you fire a rocket,
    you want to set the rocket to start in the same location and direction as your
    ship so that it appears to be firing from your ship. Because the sprites can have
    their properties stored as static or instance properties or even methods, you
    need the special helper method `getSpriteProperty` to read the values.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`isPressingSpace` 函数告诉你玩家是否按下了空格键。你会用它来表示发射火箭的意图。当你发射火箭时，你想要将火箭设置为与你的船相同的起始位置和方向，这样它看起来就像是从你的船发射出来的。因为精灵可以将它们的属性存储为静态属性、实例属性甚至方法，你需要特殊的辅助方法
    `getSpriteProperty` 来读取值。'
- en: 'During the course of the game, the screen is being re-rendered over and over.
    Before rendering, each sprite is notified to update itself via a hook in the form
    of a method on the sprite called `next()`. The next function will always be called
    on each sprite before painting the next frame, and must always return the sprite
    itself. You can use this hook to see if the user is pressing the spacebar and,
    if so, fire a rocket. The problem is that each frame renders very fast. You don’t
    want to shoot rockets that fast; you want to slow it down. That’s where the `throttle`
    function comes in. You give it a function and it returns a throttled function.
    Let’s see how to make it happen. Add the following method to the ship:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏过程中，屏幕会不断地重新渲染。在渲染之前，每个精灵都会通过精灵上的一个名为 `next()` 的方法形式的钩子来通知自己更新。下一个函数将在绘制下一帧之前始终在每个精灵上调用，并且必须始终返回精灵本身。你可以使用这个钩子来检查用户是否按下了空格键，如果是，就发射火箭。问题是每一帧渲染得非常快。你不想那么快地发射火箭；你想要减慢速度。这就是
    `throttle` 函数的作用。你给它一个函数，它返回一个节流函数。让我们看看如何实现它。向船添加以下方法：
- en: '[PRE51]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* You’re overriding next so you need to call super.next.**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你正在覆盖 next，因此你需要调用 super.next。**'
- en: '***2* If the user is pressing the spacebar, you want to fire a rocket.**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果用户正在按空格键，你想要发射火箭。**'
- en: '***3* You still need to add this method.**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你仍然需要添加这个方法。**'
- en: '***4* The next function always needs to return this.**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 下一个函数始终需要返回 this。**'
- en: Here you overrode the `next` function, so you need to invoke `super.next`. Keep
    in mind that when I say you need to, I don’t mean it’s required at the language
    level. If you don’t want the `next` method of the superclass to also be invoked,
    you don’t need to call `super.next()`. But in this case, you do want to.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你覆盖了 `next` 函数，所以你需要调用 `super.next`。请注意，当我说你需要时，我并不是指它在语言级别上是必需的。如果你不希望调用超类的
    `next` 方法，你不需要调用 `super.next()`。但在这个情况下，你需要。
- en: 'You still need to add the `fire` method. Because you need this method to be
    throttled, you can’t set it as a regular method. Instead, you’ll set it as a class
    property that points to a throttled function:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要添加 `fire` 方法。因为你需要这个方法被节流，你不能将其设置为常规方法。相反，你将把它设置为指向节流函数的类属性：
- en: '[PRE52]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Setting the throttled function as a class property**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将节流函数设置为类属性**'
- en: Because `fire` is set as a property, not a method, it isn’t added to the prototype.
    It’s set directly on the ship instance when created. This means that any class
    that extended the `Ship` class couldn’t override the `fire` method and use `super.fire`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `fire` 被设置为属性，而不是方法，所以它没有被添加到原型中。它在创建船实例时直接设置。这意味着任何扩展了 `Ship` 类的类都不能覆盖 `fire`
    方法并使用 `super.fire`。
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Decorators**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器**'
- en: 'Alternatively there’s a solution that could throttle the `fire` method and
    keep it as a true method that works with `super`. That would be with *decorators*.
    The decorators that are in wide use today will differ from the decorators that
    will actually make their way into the language. At the time of this writing, there’s
    no transpilation available for how the future decorators will work. For this reason,
    I’ve decided to exclude decorators from this book. If you want know more about
    them, the spec can be read here: [https://tc39.github.io/proposal-decorators](https://tc39.github.io/proposal-decorators).
    Additionally, there’s a JavaScript library called *core-decorators* that even
    includes a decorator for throttling a method. See it here: [https://github.com/jayphelps/core-decorators.js/tree/c4d9a654093a6c02d436e4d236f4d21e3271867d#throttle](https://github.com/jayphelps/core-decorators.js/tree/c4d9a654093a6c02d436e4d236f4d21e3271867d#throttle).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，还有一个解决方案可以限制`fire`方法，使其作为一个与`super`一起工作的真正方法。这将是使用*装饰器*。目前广泛使用的装饰器将与真正进入语言的装饰器不同。在撰写本文时，没有可用的转译器来描述未来装饰器的工作方式。因此，我决定将装饰器从这本书中排除。如果你想了解更多关于它们的信息，规范可以在以下位置阅读：[https://tc39.github.io/proposal-decorators](https://tc39.github.io/proposal-decorators)。此外，还有一个名为*core-decorators*的JavaScript库，它甚至包括一个用于限制方法的装饰器。在这里查看：[https://github.com/jayphelps/core-decorators.js/tree/c4d9a654093a6c02d436e4d236f4d21e3271867d#throttle](https://github.com/jayphelps/core-decorators.js/tree/c4d9a654093a6c02d436e4d236f4d21e3271867d#throttle)。
- en: '|  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now if you bundle your code again and fire up the game, you’ll be able to shoot
    rockets from your spaceship by pressing the spacebar. There’s only one problem:
    when a rocket hits a comet, nothing happens!'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你再次打包你的代码并启动游戏，你将能够通过按空格键从你的宇宙飞船中发射火箭。但有一个问题：当火箭击中彗星时，什么都没有发生！
- en: 29.4\. When things collide
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.4\. 当物体发生碰撞时
- en: 'When a rocket hits a comet, you don’t just want it to blow up—you want it to
    split into smaller comets. Add the following method to the `Comet` class:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当火箭击中彗星时，你不仅希望它爆炸，还希望它分裂成更小的彗星。向`Comet`类添加以下方法：
- en: '[PRE53]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* If the comet is already smaller than 5, don’t multiply anymore.**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果彗星已经小于5，则不再进行乘法操作。**'
- en: '***2* Decrease the size and increase the speed.**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 减小大小并增加速度。**'
- en: '***3* If the shard is smaller than 5, let it drift off into space.**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果碎片小于5，让它飘向太空。**'
- en: '***4* You’re going to multiply into 4 shards.**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 你将要乘以4块碎片。**'
- en: '***5* After adding the smaller shards, remove the original.**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 添加较小的碎片后，移除原始碎片。**'
- en: 'This method will split a comet into smaller, faster moving shards. You need
    to use the `range` and `getSpriteProperty` methods here, so go ahead and import
    those at the top of your comet file:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法会将彗星分割成更小、移动速度更快的碎片。你需要在这里使用`range`和`getSpriteProperty`方法，所以请在上面的comet文件顶部导入它们：
- en: '[PRE54]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now your comet can be split into multiples, but you still need a way to kick
    this off when a rocket hits a comet. Your game framework has built-in collision
    detection: you just need to specify what types of sprites you expect to collide
    with. Open up the rocket.js file and add the following property to the `Rocket`
    class:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在彗星可以被分割成多个，但你仍然需要一个方法在火箭击中彗星时启动这个操作。你的游戏框架有内置的碰撞检测：你只需要指定你期望与之碰撞的精灵类型。打开rocket.js文件，并在`Rocket`类中添加以下属性：
- en: '[PRE55]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'By setting this property, you’re telling your game to invoke the `collision`
    method on any rocket that collides with a comet. That means you need to add the
    `collision` method on your `Rocket` class:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置这个属性，你是在告诉你的游戏在任意与彗星碰撞的火箭上调用`collision`方法。这意味着你需要在你的`Rocket`类中添加`collision`方法：
- en: '[PRE56]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* collision is called with the sprite that was collided with, in this case
    a comet.**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 与精灵发生碰撞时调用`collision`，在这个例子中是一个彗星。**'
- en: '***2* Tell the comet hit by the rocket to multiply.**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 告诉被火箭击中的彗星进行乘法操作。**'
- en: '***3* Remove the rocket.**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 移除火箭。**'
- en: 'You also need to import the `Comet` class into the rocket module. Add the following
    import to the top of the rocket.js file:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将`Comet`类导入到火箭模块中。在rocket.js文件顶部添加以下导入：
- en: '[PRE57]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can now build the code again and try playing. You should be able to destroy
    some comets. Wow, this is starting to look like a real game!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以再次构建代码并尝试玩游戏。你应该能够摧毁一些彗星。哇，这开始看起来像是一个真正的游戏了！
- en: 29.5\. Adding explosions
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.5\. 添加爆炸效果
- en: 'OK, you can destroy comets with your rockets, but what kind of rocket doesn’t
    explode? You’re going to fix that next. Create a new file called explosion.js
    and add the following code:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你可以用火箭摧毁彗星，但什么样的火箭不会爆炸？你将在下一部分修复这个问题。创建一个名为`explosion.js`的新文件，并添加以下代码：
- en: '[PRE58]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Explosions don’t drift so you need to extend the base sprite class.**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 爆炸不会漂移，所以你需要扩展基础精灵类。**'
- en: '***2* You want the explosion to grow in size on every frame.**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你希望爆炸在每一帧都增长大小。**'
- en: '***3* After you increase the size, you need to recalculate the shape.**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在增加大小后，你需要重新计算形状。**'
- en: '***4* You want the explosion to fade in as it reaches its end size.**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 你希望爆炸在达到最终大小时逐渐淡入。**'
- en: '***5* Once the explosion has reached its final size, remove it.**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 一旦爆炸达到最终大小，就移除它。**'
- en: There isn’t a lot new going on here. This is similar to the `Comet` class in
    the sense that you’re setting default options and using a dynamic shape. But you
    change the shape of the explosion at every frame. You’re also changing the size
    and opacity. Once the size of the explosion increases to its final size, you remove
    it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多新内容。从某种程度上说，这与`Comet`类相似，因为你正在设置默认选项并使用动态形状。但是，你会在每一帧改变爆炸的形状。你还在改变大小和透明度。一旦爆炸的大小增加到最终大小，你就移除它。
- en: 'Now you just need to create an explosion every time a rocket collides. Import
    the explosion class, as well as the `getSpriteProperty` helper, into the rocket
    module:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要在火箭碰撞时创建爆炸。将爆炸类以及`getSpriteProperty`辅助函数导入到火箭模块中：
- en: '[PRE59]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now inside the `Rocket` class’s `collision` method, create an explosion:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Rocket`类的`collision`方法中，创建一个爆炸：
- en: '[PRE60]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now your rockets explode when they strike a comet. (Don’t forget to bundle your
    code again before testing!) There are several things you could still add to this
    game to make it better, but you need to wrap up. But there’s still one glaring
    missing piece. When a comet hits your ship, something needs to happen.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的火箭在撞击彗星时会爆炸。（别忘了在测试之前再次打包你的代码！）你还可以添加一些东西来使这个游戏变得更好，但你需要收尾。但还有一个明显的缺失部分。当彗星撞击你的飞船时，需要发生某些事情。
- en: 'In the ship.js file, import the `Comet` and `Explosion` classes as well as
    the `stop` function from the game framework:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ship.js`文件中，导入`Comet`和`Explosion`类以及来自游戏框架的`stop`函数：
- en: '[PRE61]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Add the stop function to the existing import.**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将停止函数添加到现有的导入中。**'
- en: 'Now set the `Ship` as colliding with the `Comet` and add the following collision
    method:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`Ship`设置为与`Comet`发生碰撞，并添加以下碰撞方法：
- en: '[PRE62]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now when a comet strikes the ship, there will be an explosion and the game will
    come to an end.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当彗星撞击飞船时，将会有爆炸，游戏也将结束。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this capstone you created a game using classes. You extended base classes
    that were provided to you from a framework. When extending these base classes,
    you made use of `super` in a constructor as well as when overriding methods. You
    used static and instance properties, and we discussed why a function set as an
    instance property can’t use `super` when overrode.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你使用类创建了一个游戏。你扩展了从框架中提供的基类。在扩展这些基类时，你在一个构造函数以及覆盖方法时使用了`super`。你使用了静态和实例属性，我们讨论了为什么将函数设置为实例属性时，在覆盖时不能使用`super`。
- en: I hope you had as much fun building this game as I did. There’s much more you
    can do to take this game further. You can add multiple lives, or a button to restart
    the game, once defeated. Don’t be afraid to make changes to the framework to enhance
    this game either. You can even make UFOs appear and shoot at your ship; I included
    a `ufo` shape in the shapes.js module if you decide to give it a shot!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在构建这个游戏的过程中和我一样享受乐趣。你还可以做很多事情来进一步发展这个游戏。你可以添加多个生命值，或者添加一个重新开始游戏的按钮，一旦被击败。不要害怕对框架进行修改以增强这个游戏。你甚至可以让UFO出现并向你的飞船射击；如果你决定尝试，我在`shapes.js`模块中包含了一个`ufo`形状！
