- en: 3 Designing microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 设计微服务
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Principles of microservices design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计原则
- en: Service decomposition by business capability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按业务能力进行服务分解
- en: Service decomposition by subdomain
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按子域进行服务分解
- en: When we design a microservices platform, the first questions we face are, “How
    do you break down a system into microservices? How do you decide where a service
    ends and another one starts?” In other words, how do you define the boundaries
    between microservices? In this chapter, you’ll learn to answer these questions
    and how to evaluate the quality of a microservices architecture by applying a
    set of design principles.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个微服务平台时，我们面临的首要问题是，“如何将一个系统分解成微服务？如何决定一个服务在哪里结束，另一个服务在哪里开始？”换句话说，如何定义微服务之间的边界？在本章中，你将学会如何回答这些问题，以及如何通过应用一系列设计原则来评估微服务架构的质量。
- en: 'The process of breaking down a system into microservices is called *service
    decomposition*. Service decomposition is a fundamental step in the design of our
    microservices since it helps us define applications with clear boundaries, well-defined
    scopes, and explicit responsibilities. A well-designed microservices architecture
    is essential to reduce the risk of a distributed monolith. In this chapter, you’ll
    learn two service decomposition strategies: decomposition by business capability
    and decomposition by subdomains. We’ll see how these methods work and use a practical
    example to learn to apply them. Before we delve into service decomposition strategies,
    we introduce the project that will guide our examples throughout this chapter
    and the rest of the book: CoffeeMesh.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统分解成微服务的过程称为*服务分解*。服务分解是我们微服务设计中的一个基本步骤，因为它帮助我们定义具有明确边界、定义良好的范围和明确责任的应用程序。一个设计良好的微服务架构对于降低分布式单体风险至关重要。在本章中，你将学习两种服务分解策略：按业务能力分解和按子域分解。我们将了解这些方法是如何工作的，并使用一个实际例子来学习如何应用它们。在我们深入服务分解策略之前，我们介绍了一个项目，它将指导本章以及本书其余部分的所有示例：CoffeeMesh。
- en: 3.1 Introducing CoffeeMesh
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 介绍CoffeeMesh
- en: 'CoffeeMesh is a fictitious company that allows customers to order all sorts
    of products derived from coffee, including beverages and pastries. CoffeeMesh
    has one mission: to make and deliver the best coffee in the world on demand to
    its customers, no matter where they are or when they place their order. The production
    factories owned by CoffeeMesh form a dense network, a mesh of coffee production
    units that spans several countries. Coffee production is fully automated, and
    deliveries are carried out by an unmanned fleet of drones operating 24/7.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeMesh是一家虚构的公司，允许客户订购各种咖啡衍生产品，包括饮料和糕点。CoffeeMesh有一个使命：无论客户在哪里，无论他们何时下单，都能按需制作并交付世界上最好的咖啡。CoffeeMesh拥有的生产工厂形成了一个密集的网络，一个跨越几个国家的咖啡生产单元网。咖啡生产是完全自动化的，配送由24/7运营的无人机群执行。
- en: When a customer places an order through the CoffeeMesh website, the ordered
    items are produced on demand. An algorithm determines which factory is the most
    suitable place to produce each item based on available stock, the number of pending
    orders the factory is taking care of, and distance to the customer. Once the items
    are produced, they’re immediately dispatched to the customer. It’s part of CoffeeMesh’s
    mission statement that the customer receives each item fresh and hot.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户通过CoffeeMesh网站下单时，所订购的商品将按需生产。一个算法根据可用库存、工厂正在处理的待处理订单数量以及距离客户的距离，确定哪个工厂是最适合生产每个商品的地方。一旦商品生产出来，它们将立即派送给客户。CoffeeMesh的使命宣言之一是确保客户收到的每一件商品都是新鲜且热腾腾的。
- en: Now that we have an example to work with, let’s see how we design the microservices
    architecture for the CoffeeMesh platform. Before we learn to apply service decomposition
    strategies for microservices, the next section teaches you three principles that
    will guide our designs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个例子可以操作，让我们看看我们是如何为CoffeeMesh平台设计微服务架构的。在我们学习应用微服务的服务分解策略之前，下一节将教你三个将指导我们设计的原则。
- en: 3.2 Microservices design principles
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 微服务设计原则
- en: 'What makes a well-designed microservice? As we established in chapter 1, microservices
    are designed around well-defined business subdomains, they have clearly defined
    application boundaries, and they communicate with each other through lightweight
    protocols. What does this mean in practice? In this section, we explore three
    design principles that help us test whether our microservices are correctly designed:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使一个微服务设计得很好？正如我们在第1章中确立的，微服务是围绕定义良好的业务子域设计的，它们有明确的应用边界，并且通过轻量级协议相互通信。这在实践中意味着什么？在本节中，我们探讨三个设计原则，帮助我们测试我们的微服务是否设计正确：
- en: Database-per-service principle
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每服务数据库原则
- en: Loose coupling principle
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松耦合原则
- en: Single Responsibility Principle (SRP)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: Following these principles will help you avoid the risk of building a distributed
    monolith. In the following sections, we evaluate our architectural design against
    these principles, and they help us spot errors in the design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些原则将帮助您避免构建分布式单体架构的风险。在接下来的几节中，我们将评估我们的架构设计是否符合这些原则，并且它们帮助我们发现设计中的错误。
- en: 3.2.1 Database-per-service principle
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 每服务数据库原则
- en: The database-per-service principle states that each microservice owns a specific
    set of the data, and no other service should have access to such data except through
    an API. Despite this pattern’s name, it does not mean that each microservice should
    be connected to a completely different database. It could be different tables
    in an SQL database or different collections in a NoSQL database. The point of
    this pattern is to ensure that the data owned by a specific service is not accessed
    directly by another service.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每服务数据库原则指出，每个微服务拥有特定的一组数据，并且除了通过API之外，没有其他服务应该访问这样的数据。尽管这个模式的名称是“每服务数据库”，但这并不意味着每个微服务都应该连接到一个完全不同的数据库。它可能是SQL数据库中的不同表或NoSQL数据库中的不同集合。这个模式的目的在于确保特定服务拥有的数据不会被其他服务直接访问。
- en: Figure 3.1 shows how microservices share their data. In the illustration, the
    orders service calculates the price of a customer order. To calculate the price,
    the orders service needs the price of each item in the order, which is available
    in the Products database. It also needs to know whether the user has an applicable
    discount, which can be checked in the Users database. However, instead of accessing
    both databases directly, the orders service requests this data from the products
    and users services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1展示了微服务如何共享它们的数据。在图中，订单服务计算客户订单的价格。为了计算价格，订单服务需要订单中每个项目的价格，这些价格在产品数据库中可用。它还需要知道用户是否有适用的折扣，这可以在用户数据库中检查。然而，订单服务不是直接访问这两个数据库，而是从产品和用户服务请求这些数据。
- en: '![](../Images/03-01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-01.png)'
- en: Figure 3.1 Each microservice has its own database, and access to another service’s
    data happens through an API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 每个微服务都有自己的数据库，访问其他服务的数据库通过API进行。
- en: Why is this principle important? Encapsulating data access behind a service
    allows us to design our data models for optimal access for the service. It also
    allows us to make changes to the database without breaking another service’s code.
    If the orders service in figure 3.1 had direct access to the Products database,
    schema changes in that database would require updates to both the products and
    orders services. We’d be coupling the orders service’s code to the Products database,
    and therefore we’d be breaking the loose coupling principle, which we discuss
    in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个原则很重要？将数据访问封装在服务背后，使我们能够为服务设计最优的数据模型。这也允许我们在不破坏其他服务代码的情况下对数据库进行更改。如果图3.1中的订单服务直接访问产品数据库，该数据库的架构更改将需要更新产品和订单服务。这样，我们就会将订单服务的代码耦合到产品数据库上，因此我们就会破坏我们在下一节讨论的松耦合原则。
- en: 3.2.2 Loose coupling principle
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 松耦合原则
- en: '*Loose* *coupling* states that we must design services with clear separation
    of concerns. Loosely coupled services don’t rely on another’s implementation details.
    What does this mean in practice? This principle has two practical implications:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*松* *耦合* 指出我们必须设计具有明确关注点分离的服务。松耦合的服务不依赖于其他服务的实现细节。这在实践中意味着什么？这个原则有两个实际的影响：'
- en: Each service can work independently of others. If we have a service that can’t
    fulfill a single request without calling another service, there’s no clear separation
    of concerns between both services and they belong together.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都可以独立于其他服务工作。如果我们有一个服务不能在不调用另一个服务的情况下完成单个请求，那么这两个服务之间没有明确的职责分离，它们应该属于一起。
- en: Each service can be updated without impacting other services. If changes to
    a service require updates to other services, we have tight coupling between those
    services, and therefore they need to be redesigned.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都可以在不影响其他服务的情况下进行更新。如果对服务的更改需要更新其他服务，那么这些服务之间存在紧密耦合，因此它们需要被重新设计。
- en: Figure 3.2 shows a sales forecast service that knows how to calculate a forecast
    based on historical data. It also shows a historical data service that owns historical
    sales data. To calculate a forecast, the sales forecast service makes an API call
    to the historical data service to obtain historical data. In this case, the sales
    forecast service can’t serve any request without calling the historical data service,
    and therefore there’s tight coupling between both services. The solution is to
    redesign both services so that they don’t rely on each other, or to merge them
    into a single service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2展示了一个销售预测服务，该服务知道如何根据历史数据计算预测。它还展示了一个拥有历史销售数据的历史数据服务。为了计算预测，销售预测服务通过API调用历史数据服务以获取历史数据。在这种情况下，销售预测服务不能在不调用历史数据服务的情况下处理任何请求，因此这两个服务之间存在紧密耦合。解决方案是重新设计这两个服务，使它们不相互依赖，或者将它们合并为一个单一的服务。
- en: '![](../Images/03-02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-02.png)'
- en: Figure 3.2 When a service can’t serve a single request without calling another
    service, we say both are tightly coupled.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 当一个服务不能在不调用另一个服务的情况下处理单个请求时，我们说这两个服务是紧密耦合的。
- en: 3.2.3 Single Responsibility Principle
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 单一职责原则
- en: The SRP states that we must design components with few responsibilities, and
    ideally with only one responsibility. When applied to the microservices architecture
    design, this means we should strive for the design of services around a single
    business capability or subdomain. In the following sections, you’ll learn how
    to decompose services by business capability and by subdomain. If you follow any
    of those methods, you’ll be able to design microservices that follow the SRP.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SRP原则指出，我们必须设计具有少量职责的组件，理想情况下只有一个职责。当应用于微服务架构设计时，这意味着我们应该努力围绕单一业务能力或子域来设计服务。在接下来的章节中，你将学习如何通过业务能力和子域来分解服务。如果你遵循任何这些方法，你将能够设计遵循SRP的微服务。
- en: 3.3 Service decomposition by business capability
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 通过业务能力进行服务分解
- en: When using decomposition by business capability, we look into the activities
    a business performs and how the business organizes itself to undertake them. We
    then design microservices that mirror the organizational structure of the business.
    For example, if the business has a customer management team, we build a customer
    management service; if the business has a claims management team, we build a claims
    management service; for a kitchen team, we build the corresponding kitchen service;
    and so on. For businesses that are structured around products, we may have a microservice
    per product. For example, a company that makes pet food may have a team dedicated
    to dog food, another team dedicated to cat food, another team dedicated to turtle
    food, and so on. In this scenario, we build microservices for each of these teams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用业务能力分解时，我们研究业务执行的活动以及业务如何组织自己来完成这些活动。然后我们设计反映业务组织结构的微服务。例如，如果业务有一个客户管理团队，我们构建一个客户管理服务；如果业务有一个索赔管理团队，我们构建一个索赔管理服务；对于一个厨房团队，我们构建相应的厨房服务；等等。对于围绕产品构建的业务，我们可能对每个产品都有一个微服务。例如，一个生产宠物食品的公司可能有一个专门制作狗粮的团队，另一个专门制作猫粮的团队，另一个专门制作龟粮的团队，等等。在这种情况下，我们为这些团队中的每一个构建微服务。
- en: As you can see in figure 3.3, decomposition by business capability generally
    results in an architecture that maps every business team to a microservice. Let’s
    see how we apply this approach to the CoffeeMesh platform.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.3所示，通过业务能力分解通常会导致一个将每个业务团队映射到微服务的架构。让我们看看我们如何将这种方法应用于CoffeeMesh平台。
- en: '![](../Images/03-03.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-03.png)'
- en: Figure 3.3 Using service decomposition by business capability, we reflect the
    structure of the business in our microservices architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 通过业务能力进行服务分解，我们在微服务架构中反映了业务的结构。
- en: 3.3.1 Analyzing the business structure of CoffeeMesh
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 分析CoffeeMesh的业务结构
- en: To apply decomposition by business capability, we need to analyze the structure
    and organization of the business. Let’s do this analysis for CoffeeMesh. Through
    the CoffeeMesh website, customers can order different types of coffee-related
    products out of a catalogue managed by the products team, who is in charge of
    creating new products. The availability of products and ingredients depends on
    the CoffeeMesh stock of ingredients at the time of the order, which is looked
    after by the inventory team.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用按业务能力分解，我们需要分析业务的结构和组织。让我们为CoffeeMesh进行此分析。通过CoffeeMesh网站，客户可以订购由产品团队管理的目录中的不同类型的咖啡相关产品，该团队负责创建新产品。产品和配料的可供性取决于订单时CoffeeMesh的配料库存，这由库存团队负责。
- en: A sales team is dedicated to improving the experience of ordering products through
    the CoffeeMesh website. Their goal is to maximize sales and ensure customers are
    happy with their experience and wish to come back. A finance team makes sure that
    the company is profitable and looks after the financial infrastructure required
    to process customer payments and return their money when they cancel an order.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个销售团队致力于通过CoffeeMesh网站改善产品订购体验。他们的目标是最大化销售额，并确保客户对他们的体验感到满意，并希望再次光临。一个财务团队确保公司盈利，并负责处理客户支付和退款的财务基础设施。
- en: Once a user places an order, the kitchen picks up its details to commence production.
    Kitchen work is fully automated, and a dedicated team of engineers and chefs called
    the kitchen team monitors kitchen operations to ensure no faults happen during
    production. When the order is ready for delivery, a drone picks it up and flies
    it to the customer. A dedicated team of engineers called the delivery team monitors
    this process to ensure the operational excellence of the delivery process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户下单，厨房就会获取其详情以开始生产。厨房工作完全自动化，一个由工程师和厨师组成的专门团队称为厨房团队，负责监控厨房操作以确保生产过程中没有发生故障。当订单准备好交付时，无人机将其取走并飞往客户处。一个由工程师组成的专门团队称为配送团队，负责监控此过程以确保配送过程的运营卓越。
- en: This completes our analysis of the organizational structure of CoffeeMesh. We’re
    now ready to design a microservices architecture based on this analysis.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对CoffeeMesh组织结构的分析。我们现在可以根据这个分析设计基于微服务的架构。
- en: 3.3.2 Decomposing microservices by business capabilities
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 按业务能力分解微服务
- en: 'To decompose services by business capability, we map each business team to
    a microservice. Based on the analysis in section 3.3.1, we can map the following
    business teams to microservices:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要按业务能力分解服务，我们将每个业务团队映射到一个微服务。根据3.3.1节的分析，我们可以将以下业务团队映射到微服务：
- en: '*Products team maps to the products service*—This service owns CoffeeMesh product
    catalogue data. The products team uses this service to maintain CoffeeMesh’s catalogue
    by adding new products or updating existing products through the service’s interface.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*产品团队对应产品服务*—此服务拥有CoffeeMesh产品目录数据。产品团队使用此服务通过服务界面添加新产品或更新现有产品来维护CoffeeMesh的目录。'
- en: '*Ingredients team maps to the ingredients service*—This service owns data about
    CoffeeMesh stock of ingredients. The ingredients team uses this service to keep
    the ingredients database in sync with CoffeeMesh warehouses.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配料团队对应配料服务*—此服务拥有关于CoffeeMesh配料库存的资料。配料团队使用此服务来确保配料数据库与CoffeeMesh仓库保持同步。'
- en: '*Sales team maps to the sales service*—This service guides customers through
    their journey to place orders and keep track of them. The sales team owns data
    about customer orders, and it manages the life cycle of each order. It collects
    data from this service to analyze and improve the customer journey.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销售团队对应销售服务*—此服务引导客户完成订购旅程并跟踪订单。销售团队拥有关于客户订单的资料，并管理每个订单的生命周期。它从该服务收集数据以分析和改进客户旅程。'
- en: '*Finance team maps to the finance service*—This service implements payment
    processors, and it owns data about user payment details and payment history. The
    finance team uses this service to keep the company accounts up to date and to
    ensure payments work correctly.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*财务团队对应财务服务*—此服务实现支付处理器，并拥有关于用户支付详情和支付历史的资料。财务团队使用此服务来确保公司账户保持最新，并确保支付正确无误。'
- en: '*Kitchen team maps to the kitchen service*—This service sends orders to the
    automated kitchen system and keeps track of its progress. It owns data about the
    orders produced in the kitchen. The kitchen team collects data from this service
    to monitor the performance of the automated kitchen system.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*厨房团队对应厨房服务*—此服务将订单发送到自动化厨房系统，并跟踪其进度。它拥有厨房生产订单的数据。厨房团队从该服务收集数据以监控自动化厨房系统的性能。'
- en: '*Delivery team maps to the delivery service*—This service arranges the delivery
    of the order to the customer once it has been produced by the kitchen. This service
    knows how to translate the user location into coordinates and how to calculate
    the best route to that destination. It owns data about every delivery made by
    CoffeeMesh. The delivery team collects data from this service to monitor the performance
    of the automated delivery system.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交付团队对应交付服务*—此服务在厨房生产订单后，负责将其交付给客户。此服务知道如何将用户位置转换为坐标，以及如何计算到达该目的地的最佳路线。它拥有CoffeeMesh所有交付的数据。交付团队从该服务收集数据以监控自动化交付系统的性能。'
- en: In this microservices architecture, we named every service after the business
    structure it represents. We did this for convenience in this example, but it does
    not have to be that way. For example, the finance service could be renamed to
    payments service, since all user interactions with this service will be related
    to their payments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个微服务架构中，我们根据它所代表的业务结构命名了每个服务。我们这样做是为了方便这个例子，但并不一定必须这样。例如，财务服务可以被重命名为支付服务，因为所有与该服务的用户交互都将与其支付相关。
- en: Decomposition by business capability gives us an architecture in which every
    service maps to a business team. Is this result in agreement with the principles
    of microservices design we learned in section 3.2? Let’s look at this question.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据业务能力进行分解，给我们提供了一个每个服务都映射到业务团队的架构。这个结果是否与我们在3.2节学到的微服务设计原则一致？让我们看看这个问题。
- en: 'From the previous analysis, it’s clear that every service owns its own data:
    the products service owns product data, the ingredients service owns ingredients
    data, and so on. The SRP also applies, as every service is restricted to one business
    area: the finance service only processes payments, the delivery service only manages
    deliveries, and so on.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的分析中可以看出，每个服务都拥有自己的数据：产品服务拥有产品数据，成分服务拥有成分数据，等等。单一职责原则（SRP）也适用，因为每个服务都限制在一个业务领域：财务服务仅处理支付，交付服务仅管理交付，等等。
- en: However, as you can see in figure 3.4, this solution doesn’t satisfy the loose
    coupling principle. To serve the CoffeeMesh catalogue, the products service needs
    to determine the availability of each product, which depends on the available
    stock of ingredients. Since the stock of ingredients data is owned by the ingredients
    service, the products service needs to make an API call per product to the ingredients
    service.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如图3.4所示，这个解决方案并不满足松耦合原则。为了服务CoffeeMesh目录，产品服务需要确定每个产品的可用性，这取决于成分的可用库存。由于成分库存数据由成分服务拥有，产品服务需要为每个产品向成分服务发起一次API调用。
- en: '![](../Images/03-04.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-04.png)'
- en: Figure 3.4 To determine whether a product is available, the products service
    checks the stock of ingredients with the ingredients service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 为了确定产品是否可用，产品服务通过成分服务检查成分的库存。
- en: There’s a high degree of coupling between the products and ingredients services,
    and therefore both business capabilities should be implemented within the same
    service. Figure 3.5 shows the final layout of the CoffeeMesh microservices architecture
    using the decomposition by business capability strategy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 产品服务和成分服务之间存在高度耦合，因此这两个业务能力应该在同一服务中实现。图3.5显示了使用业务能力分解策略的CoffeeMesh微服务架构的最终布局。
- en: '![](../Images/03-05.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-05.png)'
- en: Figure 3.5 When we decompose services by business capability, we map every team
    to a service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 当我们根据业务能力分解服务时，我们将每个团队映射到一个服务。
- en: Now that we know how to decompose services by business capability, let’s see
    how decomposition by subdomain works.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何根据业务能力分解服务，让我们看看子域分解是如何工作的。
- en: 3.4 Service decomposition by subdomains
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 子域服务分解
- en: Decomposition by subdomains is an approach that draws inspiration from the field
    of *domain-driven design* (DDD)—an approach to software development that focuses
    on modeling the processes and flows of the business with software using the same
    language business users employ. When applied to the design of a microservices
    platform, DDD helps us define the core responsibilities of each service and their
    boundaries.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过子域进行分解是一种从**领域驱动设计**（DDD）领域汲取灵感的方法——一种侧重于使用与业务用户相同的语言，用软件对业务的过程和流程进行建模的软件开发方法。当应用于微服务平台的设计时，DDD帮助我们定义每个服务的核心责任及其边界。
- en: 3.4.1 What is domain-driven design?
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 什么是领域驱动设计？
- en: DDD is an approach to software that focuses on modeling the processes and flows
    of the business users. The methods of DDD were best described by Eric Evans in
    his influential book *Domain-Driven Design* (Addison-Wesley, 2003), otherwise
    called “the big blue book.” DDD offers an approach to software development that
    tries to reflect as accurately as possible the ideas and the language that businesses,
    or end users of the software, use to refer to their processes and flows. To achieve
    this alignment, DDD encourages developers to create a rigorous, model-based language
    that software developers can share with the end users. Such language must not
    have ambiguous meanings and is called *ubiquitous language*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）是一种软件方法，它侧重于通过使用与业务用户相同的语言，用软件对业务用户的过程和流程进行建模。DDD的方法在埃里克·埃文斯（Eric
    Evans）有影响力的书籍《领域驱动设计》（Domain-Driven Design，Addison-Wesley，2003年出版），也被称为“大蓝书”中得到了最好的描述。DDD提供了一种软件开发方法，试图尽可能准确地反映企业或软件的最终用户用来指代其过程和流程的思想和语言。为了实现这种一致性，DDD鼓励开发者创建一种严格、基于模型的、软件开发者可以与最终用户共享的语言。这种语言不能有歧义，被称为**通用语言**。
- en: To create an ubiquitous language, we must identify the core domain of a business,
    which corresponds with the main activity an organization performs to generate
    value. For a logistics company, it may be the shipment of products around the
    world. For an e-commerce company, it may be the sale of products. For a social
    media platform, it may be feeding a user with relevant content. For a dating app,
    it may be matching users. For CoffeeMesh, the core domain is to deliver high-quality
    coffee to customers as quickly as possible regardless of their location.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一种通用语言，我们必须确定企业的核心领域，这对应于组织为了生成价值而执行的主要活动。对于一个物流公司来说，这可能是在全球范围内运输产品。对于一个电子商务公司来说，这可能是在销售产品。对于一个社交媒体平台来说，这可能是在向用户提供相关内容。对于一个约会应用来说，这可能是在匹配用户。对于CoffeeMesh来说，核心领域是以尽可能快的速度将高品质咖啡送到客户手中，无论他们的位置在哪里。
- en: The core domain is often not sufficient to cover all areas of activity in a
    business, so DDD also distinguishes supportive subdomains and generic subdomains.
    A *supportive subdomain* represents an area of the business that is not directly
    related to value generation, but it is fundamental to support it. For a logistics
    company, it may be providing customer support to the users shipping their products,
    leasing equipment, managing partnerships with other businesses, and so on. For
    an e-commerce company, it may be marketing, customer support, warehousing, and
    so on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 核心领域通常不足以涵盖企业活动的所有领域，因此领域驱动设计（DDD）还区分了支持性子域和通用子域。一个**支持性子域**代表与企业价值生成不直接相关，但对其基本支持的业务领域。对于一个物流公司来说，这可能包括为运输产品的用户提供客户支持、租赁设备、管理与其他企业的合作关系等等。对于一个电子商务公司来说，这可能包括市场营销、客户支持、仓储等等。
- en: 'The core domain gives you a definition of the *problem space* : the problem
    you are trying to solve with software. The solution consists of a model, understood
    here as a system of abstractions that describes the domain and solves the problem.
    Ideally, there is only one generic model that provides a *solution space* for
    the problem, with a clearly defined ubiquitous language. However, in practice,
    most problems are complex enough that they require the collaboration of different
    models, with their own ubiquitous languages. We call the process of defining such
    models *strategic* *design*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 核心领域为你提供了一个**问题空间**的定义：你试图用软件解决的问题。解决方案包括一个模型，在这里被理解为描述领域并解决问题的抽象系统。理想情况下，只有一个通用模型为问题提供了一个**解决方案空间**，并具有明确定义的通用语言。然而，在实践中，大多数问题都足够复杂，需要不同模型之间的协作，每个模型都有自己的通用语言。我们将定义此类模型的过程称为**战略****设计**。
- en: 3.4.2 Applying strategic analysis to CoffeeMesh
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 将战略分析应用于CoffeeMesh
- en: 'How does DDD work in practice? How do we apply it to decompose CoffeeMesh into
    subdomains? To break down a system into subdomains, it helps to think about the
    operations the system has to perform to accomplish its goal. With CoffeeMesh,
    we want to model the process of taking an order and delivering it to the customer.
    As you can see in figure 3.6, we break down this process into eight steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: DDD在实践中是如何工作的？我们如何将其应用于将CoffeeMesh分解为子域？为了将系统分解为子域，考虑系统为了实现其目标必须执行的操作是有帮助的。在CoffeeMesh中，我们希望模拟下单并交付给顾客的过程。如图3.6所示，我们将此过程分解为八个步骤：
- en: When the customer lands on the website, we show them the product catalogue.
    Each product is marked as available or unavailable. The customer can filter the
    list by availability and sort it by price (from lowest to highest and highest
    to lowest).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当顾客登录网站时，我们向他们展示产品目录。每个产品都被标记为可用或不可用。顾客可以通过可用性过滤列表，并按价格排序（从低到高和从高到低）。
- en: The customer selects products.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顾客选择产品。
- en: The customer pays for their order.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顾客为他们的订单付款。
- en: Once the customer has paid, we pass on the details of the order to the kitchen.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦顾客付款，我们就将订单的详细信息传递给厨房。
- en: The kitchen picks up the order and produces it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 厨房接单并制作产品。
- en: The customer monitors progress on their order.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顾客监控他们订单的进度。
- en: Once the order is ready, we arrange its delivery.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦订单准备就绪，我们就安排其配送。
- en: The customer tracks the drone’s itinerary until their order is delivered.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顾客跟踪无人机的行程，直到他们的订单被送达。
- en: '![](../Images/03-06.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-06.png)'
- en: Figure 3.6 To place an order, the customer lands on the CoffeeMesh website,
    selects items from the product catalogue, and pays for the order. After payment,
    we pass the order’s details to the kitchen, which produces it while the customer
    monitors its progress. Finally, we arrange the order’s delivery.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 要下单，顾客登录CoffeeMesh网站，从产品目录中选择商品，并为订单付款。付款后，我们将订单的详细信息传递给厨房，厨房在顾客监控其进度的同时制作产品。最后，我们安排订单的配送。
- en: Let’s map each step to its corresponding subdomain (see figure 3.7 for a representation
    of this analysis). The first step represents a subdomain that serves the CoffeeMesh
    product catalogue. We can call it the *products subdomain*. This subdomain tells
    us which products are available and which are not. To do so, the products subdomain
    tracks the amount of each product and ingredient in stock.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将每个步骤映射到其相应的子域（见图3.7对此分析的分析表示）。第一步代表一个为CoffeeMesh产品目录服务的子域。我们可以称之为*产品子域*。此子域告诉我们哪些产品可用，哪些不可用。为此，产品子域跟踪每种产品和成分的库存量。
- en: '![](../Images/03-07.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-07.png)'
- en: Figure 3.7 We map to a subdomain every step in the process of placing and delivering
    an order. For example, the process of serving the product catalogue is satisfied
    by the products subdomain, while the process of taking an order is satisfied by
    the orders subdomain.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 我们将订单放置和配送过程中的每一步映射到一个子域。例如，服务产品目录的过程由产品子域满足，而接收订单的过程由订单子域满足。
- en: 'The second step represents a subdomain that allows users to select products.
    This subdomain manages the life cycle of each order, and we call it the *orders
    subdomain*. This subdomain owns data about users’ orders, and it exposes an interface
    that allows us to manage orders and check their status. It hides the complexity
    of the platform so that the user doesn’t have to know about different endpoints
    and know what to do with them. The orders subdomain also takes care of the second
    part of the fourth step: passing the details of the order to the kitchen once
    the payment has been successfully processed. It also meets the requirements for
    step 6: allow the user to check the state of their order. As an orders manager,
    the orders subdomain also works with the delivery subdomain to arrange the delivery.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步代表一个允许用户选择产品的子域。此子域管理每个订单的生命周期，我们称之为*订单子域*。此子域拥有关于用户订单的数据，并公开一个接口，允许我们管理订单并检查其状态。它隐藏了平台的复杂性，这样用户就不必了解不同的端点以及如何使用它们。订单子域还负责第四步的第二部分：在支付成功处理后，将订单的详细信息传递给厨房。它还满足第六步的要求：允许用户检查他们订单的状态。作为订单管理员，订单子域还与配送子域合作安排配送。
- en: The third step represents a subdomain that can handle user payments. We will
    call it the *payments subdomain*. This domain contains specialized logic for payment
    processing, including card validation, integration with third-party payment providers,
    handling different methods of payment, and so on. The payments subdomain owns
    data related to user payments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步代表了一个可以处理用户支付的子域。我们将称之为**支付子域**。这个域包含用于支付处理的专用逻辑，包括卡验证、与第三方支付提供商的集成、处理不同的支付方式等。支付子域拥有与用户支付相关的数据。
- en: The fifth step represents a subdomain that works with the kitchen to manage
    the production of customer orders. We call it the *kitchen subdomain*. The production
    system in the kitchen is fully automated, and the kitchen subdomain interfaces
    with the kitchen system to schedule the production of customer orders and track
    their progress. Once an order is produced, the kitchen subdomain notifies the
    orders subdomain, which then arranges its delivery. The kitchen subdomain owns
    data related to the production of customer orders, and it exposes an interface
    that allows us to send orders to the kitchen and keep track of their progress.
    The orders subdomain interfaces with the kitchen subdomain to update the order’s
    status to meet the requirements for the sixth step.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第五步代表了一个与厨房协作以管理客户订单生产的子域。我们称之为**厨房子域**。厨房中的生产系统是完全自动化的，厨房子域与厨房系统接口以安排客户订单的生产并跟踪其进度。一旦订单生产完成，厨房子域会通知订单子域，然后安排其配送。厨房子域拥有与客户订单生产相关的数据，并公开了一个接口，允许我们向厨房发送订单并跟踪其进度。订单子域与厨房子域接口以更新订单的状态，以满足第六步的要求。
- en: The seventh step represents a subdomain that interfaces with the automated delivery
    system. We call it the *delivery subdomain*. This subdomain contains specialized
    logic to resolve the geolocation of a customer and to calculate the most optimal
    route to reach them. It manages the fleet of delivery drones and optimizes the
    deliveries, and it owns data related to all the deliveries. The orders subdomain
    interfaces with the delivery subdomain to update the itinerary of the customer’s
    order to meet the requirements for the eighth step.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第七步代表了一个与自动化配送系统接口的子域。我们称之为**配送子域**。这个子域包含用于解决客户地理位置和计算到达他们最优化路线的专用逻辑。它管理配送无人机编队并优化配送，并拥有与所有配送相关的数据。订单子域与配送子域接口以更新客户订单的行程，以满足第八步的要求。
- en: 'Using strategic analysis, we obtain a decomposition for CoffeeMesh in five
    subdomains, which can be mapped to microservices, as each encapsulates a well-defined
    and clearly differentiated area of logic that owns its own data. DDD’s strategic
    analysis results in microservices that satisfy the design principles we enumerated
    in section 3.2: all these subdomains can perform their core tasks without relying
    on other microservices, and therefore we say they’re loosely coupled; each service
    owns its own data, hence complying with the database-per-service principle; finally,
    each service performs tasks within a narrowly defined subdomain, which complies
    with the SRP.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过战略分析，我们获得了CoffeeMesh在五个子域中的分解，这些子域可以映射到微服务中，因为每个都封装了一个定义明确且清晰区分的逻辑区域，拥有自己的数据。DDD的战略分析产生了满足我们在第3.2节中列举的设计原则的微服务：所有这些子域都可以在不依赖其他微服务的情况下执行其核心任务，因此我们说它们是松散耦合的；每个服务都拥有自己的数据，因此符合数据库服务原则；最后，每个服务在狭窄定义的子域内执行任务，这符合单一职责原则。
- en: 'As you can see in figure 3.8, strategic analysis gives us the following microservices
    architecture:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.8所示，战略分析为我们提供了以下微服务架构：
- en: '*Products subdomain maps to the products service*—Manages CoffeeMesh’s product
    catalogue'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品子域映射到产品服务**——管理CoffeeMesh的产品目录'
- en: '*Orders subdomain maps to the orders service*—Manages customer orders'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单子域映射到订单服务**——管理客户订单'
- en: '*Payments subdomain maps to the payments service*—Manages customer payments'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付子域映射到支付服务**——管理客户支付'
- en: '*Kitchen subdomain maps to the kitchen service*—Manages the production of orders
    in the kitchen'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**厨房子域映射到厨房服务**——管理厨房中的订单生产'
- en: '*Delivery subdomain maps to the delivery service*—Manages customer deliveries'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配送子域映射到配送服务**——管理客户配送'
- en: '![](../Images/03-08.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8](../Images/03-08.png)'
- en: Figure 3.8 Applying DDD’s strategic analysis breaks down the CoffeeMesh platform
    into five subdomains that can be mapped directly to microservices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8展示了应用DDD的战略分析将CoffeeMesh平台分解为五个可以直接映射到微服务的子域。
- en: In the next section, we compare the results of DDD’s strategic analysis with
    the outcome of service decomposition by business capability, and we evaluate the
    benefits and challenges of each approach.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将比较DDD的战略分析结果与按业务能力进行服务分解的结果，并评估每种方法的益处和挑战。
- en: 3.5 Decomposition by business capability vs. decomposition by subdomain
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 按业务能力分解与按子域分解
- en: 'Which service decomposition strategy should we use to design our microservices:
    decomposition by business capability or decomposition by subdomains? While decomposition
    by business capability focuses on business structure and organization, decomposition
    by subdomain analyzes business processes and flows. Therefore, both approaches
    give us different perspectives on the business, and if you can spare the time,
    the best strategy is to apply both approaches to service decomposition.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用哪种服务分解策略来设计我们的微服务：按业务能力分解还是按子域分解？虽然按业务能力分解侧重于业务结构和组织，但按子域分解则分析业务流程和流程。因此，这两种方法为我们提供了对业务的不同视角，如果你有时间，最佳策略是同时应用这两种服务分解方法。
- en: Sometimes we can combine the results of both approaches. For example, the CoffeeMesh
    platform could allow customers to write reviews for each product, and CoffeeMesh
    could leverage this information to recommend new products to other customers.
    The company could have an entire team dedicated to this aspect of the business.
    From a technical point of view, reviews could be just another table in the Products
    database. However, to facilitate collaboration with the business, it could make
    sense to build a reviews service. The reviews service would be able to feed new
    reviews into the recommendation system, and the orders service would use the reviews
    service’s interface to serve recommendations to new users.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可以结合两种方法的结果。例如，CoffeeMesh平台可以允许客户为每个产品撰写评论，CoffeeMesh可以利用这些信息向其他客户推荐新产品。公司可以有一个专门的团队负责这一业务方面。从技术角度来看，评论可能只是产品数据库中的另一个表。然而，为了便于与业务合作，建立一个评论服务可能是有意义的。评论服务能够将新的评论输入到推荐系统中，而订单服务将使用评论服务的接口为新用户提供推荐。
- en: The advantage of decomposition by business capability is that the architecture
    of the platform aligns with the existing organizational structure of the business.
    This alignment might facilitate the collaboration between business and technical
    teams. The downside of this approach is that the existing organizational structure
    of the business is not necessarily the most efficient one. As a matter of fact,
    it can be outdated and reflect old business processes. In that case, the inefficiencies
    of the business will be mirrored in the microservices architecture. Decomposition
    by business capability also risks falling out of alignment with the business if
    the organization is restructured.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按业务能力分解的优势在于，平台的架构与业务现有的组织结构相一致。这种一致性可能有助于业务和技术团队之间的协作。这种方法的缺点是，业务现有的组织结构并不一定是最高效的。事实上，它可能是过时的，反映了旧的业务流程。在这种情况下，业务的不效率将在微服务架构中得到反映。如果组织结构重组，按业务能力分解也可能会与业务脱节。
- en: When we applied decomposition by business capability in section 3.3.2, we obtained
    an undesirable division between the products and ingredients services. After further
    analysis of the dependencies between both services, we concluded that both capabilities
    should go into the same service. However, in real-life situations, this additional
    analysis is often missing, and the resulting architecture isn’t optimal. From
    the analysis in sections 3.3 and 3.4, we can say that decomposition by subdomain
    gives you a better architectural fit to model the business processes and flows,
    and if you must choose only one approach, decomposition by subdomain is the better
    strategy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在3.3.2节中应用按业务能力进行分解时，我们得到了产品和成分服务之间一个不理想的部分划分。在进一步分析这两个服务之间的依赖关系后，我们得出结论，这两个能力应该归入同一个服务。然而，在现实生活中的情况中，这种额外的分析往往被忽略，导致的结果架构并不最优。从3.3节和3.4节的分析中，我们可以得出结论，按子域进行分解能更好地适应业务流程和流程的建模，如果你必须选择其中一种方法，按子域进行分解是更好的策略。
- en: Now that we know how to design our microservices, it’s time to design and build
    their interfaces. In the upcoming chapters, you’ll learn to build REST and GraphQL
    interfaces for microservices.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何设计我们的微服务，是时候设计和构建它们的接口了。在接下来的章节中，你将学习如何为微服务构建REST和GraphQL接口。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We call the process of breaking down a system into microservices service decomposition.
    Service decomposition defines the boundaries between services, and we must get
    this process right to avoid the risk of building a distributed monolith.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将系统分解成微服务的过程称为服务分解。服务分解定义了服务之间的边界，我们必须正确执行这个过程以避免构建分布式单体架构的风险。
- en: Decomposition by business capability analyzes the structure of the business
    and designs microservices for each team in the organization. This approach aligns
    the business with our system architecture, but it also reproduces the inefficiencies
    of the business into the platform.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按业务能力进行分解分析业务结构，并为组织中的每个团队设计微服务。这种方法使业务与我们的系统架构保持一致，但也将业务的低效性复制到平台中。
- en: Decomposition by subdomains applies DDD to model the processes and flows of
    the business through subdomains. By using this approach, we design a microservice
    for each subdomain, which results in a more robust technical design.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按子域进行分解将领域驱动设计（DDD）应用于通过子域建模业务的过程和流程。通过使用这种方法，我们为每个子域设计一个微服务，从而得到一个更稳健的技术设计。
- en: 'To assess the quality of our microservices architecture, we apply three design
    principles:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了评估我们的微服务架构的质量，我们应用了三个设计原则：
- en: '*Database-per-service principle*—Each microservice owns its own data, and access
    to that data happens through the service’s API.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库服务原则*—每个微服务拥有自己的数据，并且对数据的访问通过服务的API进行。'
- en: '*Loose coupling principle*—You must be able to update a service without impacting
    other services, and each service should be able to work without constantly calling
    other services.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*松耦合原则*—你必须能够更新一个服务而不影响其他服务，并且每个服务应该能够在不不断调用其他服务的情况下工作。'
- en: '*Single Responsibility Principle*—We must design each service around a specific
    business capability or subdomain.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单一职责原则*—我们必须围绕特定的业务能力或子域来设计每个服务。'
