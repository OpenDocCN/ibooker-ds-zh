- en: 9 Building Docker images within a CI pipeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 在 CI 管道中构建 Docker 镜像
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building Docker images inside Jenkins pipelines and best practices of writing
    Dockerfiles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jenkins 管道中构建 Docker 镜像和编写 Dockerfile 的最佳实践
- en: Using Docker agents as an execution environment in Jenkins declarative pipelines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jenkins 声明式管道中使用 Docker 代理作为执行环境
- en: Integrating Jenkins build statuses into GitHub pull requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Jenkins 构建状态集成到 GitHub 拉取请求中
- en: Deploying and configuring hosted and managed Docker private registry solutions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和配置托管和管理的 Docker 私有仓库解决方案
- en: Docker images life cycle within the development cycle and tagging strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发周期内 Docker 镜像的生命周期和打标签策略
- en: Scanning Docker images for security vulnerabilities within Jenkins pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jenkins 管道中扫描 Docker 镜像中的安全漏洞
- en: In the previous chapter, you learned how to run automated tests inside Docker
    containers within CI pipelines. In this chapter, we will finish the CI workflow
    by building a Docker image and storing it inside a private remote repository for
    versioning; see figure 9.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何在 CI 管道中运行 Docker 容器内的自动化测试。在本章中，我们将通过构建 Docker 镜像并将其存储在私有远程仓库中以实现版本控制来完成
    CI 工作流程；见图 9.1。
- en: '![](Images/CH09_F01_Labouardy.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F01_Labouardy.png)'
- en: Figure 9.1 The Build and Push stages will be implemented in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 本章将实现构建和推送阶段。
- en: 'By the end of this chapter, you should be able to build a similar CI pipeline
    with these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够使用以下步骤构建类似的 CI 管道：
- en: Check out the source code from a remote repository. The CI server fetches the
    code from the version-control system (VCS) on a push event.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从远程仓库检出源代码。CI 服务器在推送事件发生时从版本控制系统（VCS）中获取代码。
- en: Run pre-integration tests such as unit tests, security tests, quality tests,
    and UI tests inside a Docker container. These might include generating coverage
    reports and integrating quality-inspection tools like SonarQube for static code
    analysis.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Docker 容器内运行预集成测试，如单元测试、安全测试、质量测试和 UI 测试。这些可能包括生成覆盖率报告和集成质量检查工具，如 SonarQube
    进行静态代码分析。
- en: Compile the source code and build a Docker image (automated packaging).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码并构建 Docker 镜像（自动化打包）。
- en: Tag the end image and store it in a private registry.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记最终镜像并将其存储在私有仓库中。
- en: Figure 9.2 summarizes the end result of the CI workflow.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 总结了 CI 工作流程的最终结果。
- en: '![](Images/CH09_F02_Labouardy.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F02_Labouardy.png)'
- en: Figure 9.2 The CI pipeline process
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 CI 管道过程
- en: The purpose of this CI pipeline is to automate the process of continuously building,
    testing, and uploading the Docker image to the private registry. Reporting for
    failures/ success happens at every stage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本 CI 管道的目的在于自动化持续构建、测试并将 Docker 镜像上传到私有仓库的过程。在每一个阶段都会进行失败/成功的报告。
- en: Note The CI design discussed in this chapter and previous ones can be modified
    to suit the needs of any type of project; the users just need to identify the
    right tools and configurations that can be used with Jenkins.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章和前几章中讨论的 CI 设计可以根据任何类型项目的需求进行修改；用户只需要确定可以使用 Jenkins 的正确工具和配置即可。
- en: 9.1 Building Docker images
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 构建 Docker 镜像
- en: For now, each push event to the remote repository triggers the pipeline on Jenkins.
    The pipeline will be executed based on stages defined in the Jenkinsfile. The
    first stage to be launched will be cloning the code from the remote repository,
    running automated tests, and publishing coverage reports. Figure 9.3 shows the
    current CI workflow for the movies-loader service.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，每次向远程仓库的推送事件都会触发 Jenkins 上的管道。管道将根据 Jenkinsfile 中定义的阶段执行。首先启动的阶段将是从远程仓库克隆代码、运行自动化测试和发布覆盖率报告。图
    9.3 显示了 movies-loader 服务的当前 CI 工作流程。
- en: '![](Images/CH09_F03_Labouardy.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F03_Labouardy.png)'
- en: Figure 9.3 Current CI workflow
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 当前 CI 工作流程
- en: If the tests are successful, the next stage will be building the artifact; in
    our case, it will be a Docker image.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试成功，下一个阶段将是构建工件；在我们的例子中，它将是一个 Docker 镜像。
- en: Note When you’re building a Docker image for your application, you’re building
    on top of an existing image. A broken base image can lead to production outages
    (security breaches, for instance). I recommend using an up-to-date and well-maintained
    image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你为你的应用程序构建 Docker 镜像时，你是在一个现有镜像的基础上构建的。一个损坏的基础镜像可能导致生产中断（例如安全漏洞）。我建议使用最新且维护良好的镜像。
- en: 9.1.1 Using the Docker DSL
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 使用 Docker DSL
- en: To build the main application Docker image, we need to define a Dockerfile with
    a set of instructions that specify the environment to use and the commands to
    run. Create a Dockerfile in the top-level directory of the movies-loader project,
    using the following code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建主应用程序 Docker 镜像，我们需要定义一个包含一系列指令的 Dockerfile，这些指令指定了要使用的环境和要运行的命令。在 movies-loader
    项目的顶级目录中创建一个 Dockerfile，使用以下代码。
- en: Listing 9.1 Movie loader’s Dockerfile
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 Movie loader 的 Dockerfile
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Python-based application will use Python v3.7.3 as a base image, install
    the runtime dependencies with the pip manager, and set `python main.py` as the
    main command for the Docker image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Python 的应用程序将使用 Python v3.7.3 作为基础镜像，使用 pip 管理器安装运行时依赖项，并将 `python main.py`
    设置为 Docker 镜像的主命令。
- en: Note To maintain the consistency of your image builds, create a requirements
    .txt file with transitively pinned versions of all used dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了保持镜像构建的一致性，创建一个包含所有使用依赖项的传递性固定版本的 requirements.txt 文件。
- en: 'The order of instructions in a Dockerfile is important. The Docker image is
    rebuilt whenever any change occurs in the source code. That’s why I placed the
    `pip install` command in listing 9.1, as the dependencies are not frequently changed.
    Therefore, Docker will rely on layer caching that will speed up the build time
    of the image. Refer to the official Docker documentation to learn more about the
    Docker build cache: [http://mng.bz/B10J](https://shortener.manning.com/B10J).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中指令的顺序很重要。每当源代码发生任何更改时，都会重新构建 Docker 镜像。这就是为什么我把 `pip install` 命令放在列表
    9.1 中的原因，因为依赖项不经常更改。因此，Docker 将依赖于层缓存，这将加快镜像的构建时间。有关 Docker 构建缓存的更多信息，请参阅官方 Docker
    文档：[http://mng.bz/B10J](https://shortener.manning.com/B10J)。
- en: 'Finally, we add a `Build` stage in the Jenkinsfile, which uses the Docker DSL
    to build an image based on the Dockerfile in the repository:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 Jenkinsfile 中添加了一个 `Build` 阶段，它使用 Docker DSL 基于存储库中的 Dockerfile 构建镜像：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `build()` method builds the Dockerfile in the current directory by default.
    You can override this by providing the Dockerfile path as the second argument
    of the `build()` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`build()` 方法会在当前目录中构建 Dockerfile。您可以通过提供 `build()` 方法的第二个参数作为 Dockerfile
    路径来覆盖此行为。
- en: 'The changes are pushed to the develop branch with the following commands:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将更改推送到 develop 分支：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then a new build should be triggered, and the image should be built, as shown
    in figure 9.4.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应该触发一个新的构建，并构建镜像，如图 9.4 所示。
- en: '![](Images/CH09_F04_Labouardy.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F04_Labouardy.png)'
- en: Figure 9.4 Python Docker image build logs
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 Python Docker 镜像构建日志
- en: '![](Images/CH09_F05_Labouardy.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F05_Labouardy.png)'
- en: Figure 9.5 Movie loader CI pipeline
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 Movie loader CI 管道
- en: So far, we’ve defined the CI stages in figure 9.5 for the movies-loader CI pipeline.
    The movies-parser service’s Dockerfile will be different, as it’s written in Go.
    Because Go is a compiled language, we won’t need it at the runtime of the service.
    Therefore, we will use Docker’s multistage build feature to reduce the Docker
    image size, as shown in the following listing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为 movies-loader CI 管道在图 9.5 中定义了 CI 阶段。movies-parser 服务的 Dockerfile
    将会有所不同，因为它是用 Go 编写的。由于 Go 是一种编译型语言，我们不需要在服务的运行时使用它。因此，我们将使用 Docker 的多阶段构建功能来减小
    Docker 镜像的大小，如下面的列表所示。
- en: Listing 9.2 Multistage build usage
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 多阶段构建使用
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Dockerfile is split into two stages. The first stage builds the binary with
    the `go build` command. The second stage uses Alpine as the base image, which
    is a lightweight image, and then copies the binary from the first stage.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 被分为两个阶段。第一个阶段使用 `go build` 命令构建二进制文件。第二个阶段使用 Alpine 作为基础镜像，这是一个轻量级镜像，然后从第一个阶段复制二进制文件。
- en: The intermediate layer where the Go build tools and compilation happen is about
    300 MB. The final image has a minimal footprint of 8 MB. The end result is the
    same tiny production image as before, with a significant reduction in complexity.
    The Go SDK and any intermediate artifacts are left behind and not saved in the
    final image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Go 构建工具和编译发生的中间层大约有 300 MB。最终的镜像具有最小的 8 MB 脚印。最终结果是和之前一样的微小生产镜像，但复杂性显著降低。Go
    SDK 和任何中间工件都被留下，并且没有保存在最终的镜像中。
- en: Note The multistage build feature requires Docker engine 17.05 or higher on
    the daemon and client.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：多阶段构建功能需要在守护程序和客户端上使用 Docker engine 17.05 或更高版本。
- en: In the previous Dockerfile, stages are not named and are referred to by their
    integer number (starting with 0 for the first `FROM` instruction). However, we
    can name the stages by passing `AS` `NAME` to the `FROM` instruction, as shown
    in the following listing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Dockerfile中，阶段没有被命名，而是通过它们的整数编号（从0开始，对应第一个`FROM`指令）来引用。然而，我们可以通过将`AS NAME`传递给`FROM`指令来命名阶段，如以下列表所示。
- en: Listing 9.3 Naming Docker multistages
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 命名Docker多阶段
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add the `Build` stage to the project Jenkinsfile, and push the changes to the
    develop branch. The pipeline will be triggered, and the result of the build should
    be similar to the one shown in figure 9.6.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Build`阶段添加到项目的Jenkinsfile中，并将更改推送到develop分支。管道将被触发，构建的结果应该类似于图9.6中所示。
- en: '![](Images/CH09_F06_Labouardy.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F06_Labouardy.png)'
- en: Figure 9.6 Movie parser CI pipeline
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 电影解析CI管道
- en: Note You could have just as easily based the final image on scratch or distroless
    images, but I prefer to have the convenience of Alpine. Plus, it’s a safe choice
    for reducing image size.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您同样可以基于scratch或distroless镜像构建最终镜像，但我更喜欢使用Alpine的便利性。此外，它是一个减少镜像大小的安全选择。
- en: The movies-store Docker image will use the Node.js base image from DockerHub;
    we’re using the latest LTS node release at the time of writing. I prefer to name
    a specific version, rather than one of the floating tags like `node:lts` or `node:latest`,
    so that if you or someone else builds this image on a different machine, they
    will get the same version, rather than risking an accidental upgrade and attendant
    head-scratching.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: movies-store Docker镜像将使用DockerHub中的Node.js基础镜像；我们使用的是写作时的最新LTS节点版本。我更喜欢指定一个特定版本，而不是像`node:lts`或`node:latest`这样的浮动标签，这样如果有人在其他机器上构建此镜像，他们将获得相同的版本，而不是冒着意外升级和随之而来的困惑的风险。
- en: Note In most cases, the best choice for a base image is from the official images
    available in DockerHub ([https://hub.docker.com/](https://hub.docker.com/)). They
    tend to be better controlled than those created by the community.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在大多数情况下，从DockerHub（[https://hub.docker.com/](https://hub.docker.com/)）提供的官方镜像中选择的基镜像是最好的选择。它们通常比社区创建的镜像控制得更好。
- en: Then, we install the needed dependencies for runtime by passing `--only=prod`.
    Finally, we set the `npm start` command to start the express server when the container
    is created, as shown in the following listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过传递`--only=prod`安装运行时所需的依赖项。最后，我们将`npm start`命令设置为在容器创建时启动express服务器，如以下列表所示。
- en: Listing 9.4 Movie store’s Dockerfile
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 电影存储Dockerfile
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that, rather than copying the entire working directory, we are copying
    only the package.json and package-lock.json files. This allows us to take advantage
    of cached Docker layers. The package-lock.json file records the versions of all
    dependencies to ensure that the `npm install` command in Docker builds is consistent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不是复制整个工作目录，而是只复制package.json和package-lock.json文件。这使我们能够利用缓存的Docker层。package-lock.json文件记录了所有依赖项的版本，以确保Docker构建中的`npm
    install`命令的一致性。
- en: Once the pipeline changes are versioned and the execution is completed, the
    CI pipeline so far for movies-store should look similar to the Blue Ocean view
    in figure 9.7.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦管道更改被版本化并且执行完成，到目前为止的CI管道对于movies-store应该看起来与图9.7中的Blue Ocean视图相似。
- en: '![](Images/CH09_F07_Labouardy.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F07_Labouardy.png)'
- en: Figure 9.7 Movie store CI pipeline
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 电影存储CI管道
- en: Note During image build, Docker takes all files in the context directory. To
    increase the Docker build performance, exclude files and directories by adding
    a .dockerignore file to the context directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在镜像构建过程中，Docker会取上下文目录中的所有文件。为了提高Docker构建性能，可以通过在上下文目录中添加`.dockerignore`文件来排除文件和目录。
- en: 9.1.2 Docker build arguments
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 Docker构建参数
- en: Finally, for the Angular application (aka movies-marketplace), we will once
    again use the multistage build feature to build the static folder with the `ng`
    `build` command. Then we’ll copy the folder to an NGINX image to serve the content
    with a web server; see the following listing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于Angular应用程序（即movies-marketplace），我们再次使用多阶段构建功能，通过`ng build`命令构建静态文件夹。然后我们将文件夹复制到NGINX镜像中，通过Web服务器提供服务；请参阅以下列表。
- en: Listing 9.5 Movie marketplace’s Dockerfile
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 电影市场Dockerfile
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note The `ENV` instruction is available during build and runtime. The `ARG`
    instruction (listing 9.5) is accessible only during build time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`ENV`指令在构建和运行时都可用。`ARG`指令（列表9.5）仅在构建时可用。
- en: 'Because we might have multiple Angular configurations (with different settings)
    based on the running environment, we will inject a build argument during the build
    time to specify the target environment as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能基于不同的运行环境拥有多个Angular配置（具有不同的设置），我们将在构建时注入一个构建参数来指定目标环境，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When passing arguments to the `build()` method, the last value should end with
    the folder to use as the build context.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当向`build()`方法传递参数时，最后一个值应以要使用的文件夹作为构建上下文结束。
- en: 'Finally, make sure to create a .dockerignore file in the root folder of the
    project to prevent local modules, debug logs, and temporary files from being copied
    into the Docker image. To exclude those directories, we create a .dockerignore
    file with the following content:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请确保在项目的根目录中创建一个.dockerignore文件，以防止本地模块、调试日志和临时文件被复制到Docker镜像中。为了排除这些目录，我们创建了一个包含以下内容的.dockerignore文件：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After pushing the changes, the pipeline should look like the Blue Ocean view
    in figure 9.8.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送更改后，管道应类似于图9.8中的Blue Ocean视图。
- en: '![](Images/CH09_F08_Labouardy.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F08_Labouardy.png)'
- en: Figure 9.8 Movie marketplace CI pipeline
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8电影市场CI管道
- en: Now that the project Docker images are built, we need to store them somewhere.
    Therefore, we will deploy a private registry on which we will store all the images
    built through the development cycle of the project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目Docker镜像已构建，我们需要将它们存储在某处。因此，我们将在项目开发周期中构建的所有镜像上部署一个私有注册库。
- en: 9.2 Deploying a Docker private registry
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 部署Docker私有注册库
- en: Continuous integration results in frequent builds and packages. Hence, we need
    a mechanism to store all this binary code (builds, packages, third-party plugins,
    and so on) in a system akin to a version-control system. Since VCSs such as Git
    and SVN store code and not binary files, we need a binary repository tool.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成导致频繁的构建和打包。因此，我们需要一个机制来存储所有这些二进制代码（构建、打包、第三方插件等）在一个类似于版本控制系统的系统中。由于VCSs如Git和SVN存储代码而不是二进制文件，我们需要一个二进制存储库工具。
- en: Many solutions exist, such as Nexus or Artifactory. However, they come with
    challenges including managing and hardening the instance. Fortunately, managed
    solutions also exist, depending on the cloud provider you’re using, such as Amazon
    Elastic Container Registry (ECR), Google Container Registry, and Azure Container
    Registry.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多解决方案，例如Nexus或Artifactory。然而，它们带来了挑战，包括管理和加固实例。幸运的是，也存在托管解决方案，这取决于您使用的云提供商，例如Amazon
    Elastic Container Registry (ECR)、Google Container Registry和Azure Container Registry。
- en: Note You can also host your Docker images in DockerHub. If you go with this
    approach, you can skip this part.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您也可以在DockerHub上托管您的Docker镜像。如果您选择这种方法，您可以跳过这部分。
- en: 9.2.1 Nexus Repository OSS
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 Nexus Repository OSS
- en: Nexus Repository OSS ([www.sonatype.com/products/repository-oss](http://www.sonatype.com/products/repository-oss))
    is a widely used open source, free artifact repository that can be used to store
    binaries and build artifacts. It can be used to distribute Maven/Java, npm, Helm,
    Docker, and more.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus Repository OSS ([www.sonatype.com/products/repository-oss](http://www.sonatype.com/products/repository-oss))是一个广泛使用的开源、免费工件存储库，可以用于存储二进制和构建工件。它可以用于分发Maven/Java、npm、Helm、Docker等。
- en: Note Since you’re already familiar with Docker, you can run Nexus Repository
    OSS in a Docker container by using the Docker image from Sonatype.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意由于您已经熟悉Docker，您可以使用Sonatype的Docker镜像在Docker容器中运行Nexus Repository OSS。
- en: To deploy Nexus Repository OSS, we need to bake a new machine image with Packer.
    The following listing provides the template.json content (the full template is
    available in chapter9/nexus/packer/template.json).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署Nexus Repository OSS，我们需要使用Packer制作一个新的机器镜像。以下列表提供了template.json的内容（完整的模板可在第9章/nexus/packer/template.json中找到）。
- en: Listing 9.6 Nexus Repository OSS Packer template
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 Nexus Repository OSS Packer模板
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create a temporary instance based on the Amazon Linux image and provision
    it with a shell script (listing 9.7) that installs the Nexus OSS version from
    the official repository and configures it to run a service with init.d, so it
    restarts after the instance reboots. This example uses version 3.30.1-01\. The
    full script is available in chapter9/nexus/packer/setup.sh.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基于Amazon Linux镜像创建一个临时实例，并使用一个shell脚本（列表9.7）安装从官方仓库的Nexus OSS版本，并将其配置为使用init.d运行服务，以便在实例重启后重新启动。此示例使用版本3.30.1-01。完整的脚本可在第9章/nexus/packer/setup.sh中找到。
- en: Listing 9.7 Installing the Nexus Repository OSS version (setup.sh)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7安装Nexus Repository OSS版本（setup.sh）
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Defines Nexus OSS default credentials (admin/admin123)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义 Nexus OSS 默认凭据（admin/admin123）
- en: ❷ Installs Java JDK 1.8.0, which is required to run Nexus OSS
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安装 Java JDK 1.8.0，这是运行 Nexus OSS 所必需的
- en: ❸ Downloads Nexus OSS from the official repository and extracts the archive
    to the target
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从官方仓库下载 Nexus OSS 并将存档提取到目标位置
- en: Then, the script will start Nexus server with the `service nexus restart` command
    and wait for it to be up and ready, as shown in the following listing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本将使用 `service nexus restart` 命令启动 Nexus 服务器，并等待其启动并准备好，如下一列表所示。
- en: Listing 9.8 Waiting for the Nexus server to be up (setup.sh)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 等待 Nexus 服务器启动（setup.sh）
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the server responds, a POST request will be issued to the Nexus Script
    API to create a Docker hosted repository. The scripting API can be used to automate
    the creation of complex tasks for the Nexus Repository Manager, as shown next.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器响应，将向 Nexus 脚本 API 发出 POST 请求以创建 Docker 托管仓库。脚本 API 可以用于自动化 Nexus 仓库管理器的复杂任务，如下所示。
- en: Listing 9.9 Nexus OSS script API (setup.sh)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 Nexus OSS 脚本 API（setup.sh）
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Performs a POST request on the Nexus server by including the default credentials
    in the request and the Docker repository config in the request payload
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过在请求中包含默认凭据和在请求负载中包含 Docker 仓库配置，对 Nexus 服务器执行 POST 请求
- en: Note A comprehensive listing of Nexus REST API endpoints and functionality is
    documented through the NEXUS_HOST/swagger-ui endpoint.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Nexus REST API 端点和功能的完整列表通过 NEXUS_HOST/swagger-ui 端点进行文档化。
- en: 'The request payload is a Groovy script that exposes a Docker hosted registry
    on port 5000:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请求负载是一个暴露在端口 5000 的 Docker 主机注册表的 Groovy 脚本：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Issue the `packer build` command to bake the AMI. Once the provisioning is finished,
    the Nexus AMI should be available in the Images section in the AWS Management
    Console, as shown in figure 9.9.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `packer build` 命令来烘焙 AMI。一旦配置完成，Nexus AMI 应该可以在 AWS 管理控制台的“图像”部分中找到，如图 9.9
    所示。
- en: '![](Images/CH09_F09_Labouardy.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F09_Labouardy.png)'
- en: Figure 9.9 Nexus OSS AMI
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 Nexus OSS AMI
- en: From there, use Terraform to provision an EC2 instance based on the baked Nexus
    OSS AMI. Create a nexus.tf file with the content in the following listing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，使用 Terraform 基于烘焙的 Nexus OSS AMI 配置一个 EC2 实例。创建一个包含以下列表内容的 nexus.tf 文件。
- en: Listing 9.10 Nexus EC2 instance resource
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 Nexus EC2 实例资源
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note Running Nexus OSS without a problem requires a minimum of 8 GB of memory.
    Additionally, I strongly recommend using a dedicated EBS for blob storage ([http://mng.bz/dr7Q](http://mng.bz/dr7Q)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在没有问题的前提下运行 Nexus OSS 至少需要 8 GB 的内存。此外，我强烈建议使用一个专门的 EBS 用于 blob 存储 ([http://mng.bz/dr7Q](http://mng.bz/dr7Q))。
- en: Also, provision a public load balancer to forward incoming HTTP and HTTPS traffic
    to port 8081 of the EC2 instance, which is the port where the Nexus Repository
    Manager (dashboard) is exposed. Create a new file, loadbalancers.tf, with the
    following listing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要配置一个公共负载均衡器，将传入的 HTTP 和 HTTPS 流量转发到 EC2 实例的 8081 端口，这是 Nexus 仓库管理器（仪表板）暴露的端口。创建一个名为
    loadbalancers.tf 的新文件，内容如下列表所示。
- en: Listing 9.11 Nexus Repository Manager public load balancer
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 Nexus 仓库管理器公共负载均衡器
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Within the same file, add another public load balancer, as shown in the next
    listing. This will access the Docker private registry pointing to port 5000 of
    the hosted repository on the Nexus Repository Manager.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，添加另一个公共负载均衡器，如下一列表所示。这将访问指向 Nexus 仓库管理器托管仓库端口 5000 的 Docker 私有注册表。
- en: Listing 9.12 Docker registry public load balancer
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 Docker 注册表公共负载均衡器
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Use `terraform apply` to provision the AWS resources, the Nexus dashboard, and
    Docker Registry. URLs should be displayed at the end of the provisioning process
    in the `Outputs` section, as shown in figure 9.10.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `terraform apply` 配置 AWS 资源、Nexus 仪表板和 Docker 注册表。在配置过程的“输出”部分应显示 URL，如图
    9.10 所示。
- en: '![](Images/CH09_F10_Labouardy.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F10_Labouardy.png)'
- en: Figure 9.10 Nexus Terraform resources
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 Nexus Terraform 资源
- en: Point your favorite browser to the Nexus URL, and the web dashboard in figure
    9.11 should be displayed. The default `admin` password can be found in /opt/sonatype-work/nexus3/admin.password.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将您喜欢的浏览器指向 Nexus URL，如图 9.11 所示的 Web 仪表板应该会显示出来。默认的 `admin` 密码可以在 `/opt/sonatype-work/nexus3/admin.password`
    中找到。
- en: '![](Images/CH09_F11_Labouardy.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F11_Labouardy.png)'
- en: Figure 9.11 Nexus Repository Manager
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 Nexus 仓库管理器
- en: If you jump to Settings from the cogwheel icon and then Repositories, a new
    Docker hosted repository should be created. The repository disables tag immutability
    and allows image tags to be overwritten by a subsequent image push using the same
    tag. If this option is enabled, an error will be returned if you attempt to push
    an image with a tag that already exists in the repository. The rest of the configurations
    should be similar to figure 9.12.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从齿轮图标跳转到设置，然后是仓库，应该会创建一个新的 Docker 托管仓库。该仓库禁用了标签不可变性，并允许后续使用相同标签的镜像推送覆盖图像标签。如果启用此选项，如果您尝试推送一个在仓库中已存在的标签的镜像，将返回错误。其余的配置应类似于图
    9.12。
- en: '![](Images/CH09_F12_Labouardy.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F12_Labouardy.png)'
- en: Figure 9.12 Docker-hosted registry on Nexus
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 Nexus 上的 Docker 托管注册库
- en: To be able to pull and push Docker images to the registry, we will create a
    custom Nexus role from the Security section. This role, shown in figure 9.13,
    will give full access to the Docker hosted registry.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够从注册库拉取和推送 Docker 镜像，我们将从安全部分创建一个自定义 Nexus 角色。如图 9.13 所示，此角色将授予对 Docker 托管注册库的完全访问权限。
- en: '![](Images/CH09_F13_Labouardy.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F13_Labouardy.png)'
- en: Figure 9.13 Nexus custom role for the Docker registry
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 Docker 注册库的 Nexus 自定义角色
- en: Note For push and pull operations, only `nx-*-registry-add` and `nx-* -registry-read`
    permissions are required.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于推送和拉取操作，只需要 `nx-*-registry-add` 和 `nx-* -registry-read` 权限。
- en: Next, we create a Jenkins user and assign to it the custom Nexus role we just
    created, as shown in figure 9.14.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 Jenkins 用户，并将其分配给我们刚刚创建的自定义 Nexus 角色，如图 9.14 所示。
- en: '![](Images/CH09_F14_Labouardy.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F14_Labouardy.png)'
- en: Figure 9.14 Docker registry credentials for Jenkins
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 Jenkins 的 Docker 注册库凭证
- en: 'We can test out the authentication by jumping back to the terminal session
    on the local machine and issuing the `docker login` command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过回到本地机器上的终端会话并发出 `docker login` 命令来测试身份验证：
- en: '![](Images/CH09_F14_UN01_Labouardy.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F14_UN01_Labouardy.png)'
- en: Note The hosted Docker repository is exposed on HTTPS by default. However, if
    you expose the private repository on a plain HTTP endpoint only, you need to configure
    the Docker daemon to allow insecure connections by passing the `–insecure-registry`
    flag to the Docker engine.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：默认情况下，托管 Docker 仓库通过 HTTPS 暴露。但是，如果您仅在纯 HTTP 端点暴露私有仓库，则需要配置 Docker 守护程序以允许不安全连接，通过将
    `–insecure-registry` 标志传递给 Docker 引擎。
- en: Finally, on Jenkins, create a registry credential of type Username with Password
    with the Nexus credentials we created so far for Jenkins (figure 9.15).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 Jenkins 上，使用我们迄今为止为 Jenkins 创建的 Nexus 凭证创建一个类型为用户名的注册凭证，带有密码（如图 9.15）。
- en: '![](Images/CH09_F15_Labouardy.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F15_Labouardy.png)'
- en: Figure 9.15 Docker registry credentials
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 Docker 注册库凭证
- en: Another alternative to Nexus Repository OSS is an AWS managed service.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus 仓库 OSS 的另一个替代方案是 AWS 管理服务。
- en: 9.2.2 Amazon Elastic Container Registry
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 亚马逊弹性容器注册库
- en: If you’re using AWS, as I am, you can use a managed AWS service called Elastic
    Container Registry (ECR) to host your private Docker images. From the AWS Management
    Console, navigate to Amazon ECR ([https://console.aws.amazon.com/ecr/repositories](https://console.aws.amazon.com/ecr/repositories)).
    Then, create a repository for each Docker image you want to host or store. In
    our project, we need to create four repositories, one for each microservice. The
    service-loader repository, for instance, is shown in figure 9.16.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像我一样使用 AWS，可以使用名为 Elastic Container Registry (ECR) 的托管 AWS 服务来托管您的私有 Docker
    镜像。从 AWS 管理控制台导航到 Amazon ECR ([https://console.aws.amazon.com/ecr/repositories](https://console.aws.amazon.com/ecr/repositories))。然后，为要托管或存储的每个
    Docker 镜像创建一个仓库。在我们的项目中，我们需要创建四个仓库，每个微服务一个。例如，服务加载器仓库如图 9.16 所示。
- en: '![](Images/CH09_F16_Labouardy.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F16_Labouardy.png)'
- en: Figure 9.16 ECR new repository
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 ECR 新仓库
- en: Once the repository is created, you can click the View Push Commands button,
    and a dialog should pop up with a list of instructions on how to tag, push, and
    pull images to the remote repository; see figure 9.17.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了仓库，您可以点击“查看推送命令”按钮，应该会弹出一个对话框，其中包含有关如何对远程仓库进行标记、推送和拉取镜像的说明列表；参见图 9.17。
- en: '![](Images/CH09_F17_Labouardy.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F17_Labouardy.png)'
- en: Figure 9.17 Movie loader ECR repository
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 电影加载器 ECR 仓库
- en: 'Before interacting with the repository, you need to authenticate with ECR.
    The following command for Mac and Linux users can be used to log in to the remote
    repository:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在与仓库交互之前，您需要使用 ECR 进行身份验证。以下命令适用于 Mac 和 Linux 用户，可用于登录远程仓库：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note Replace `ACCOUNT_ID` and `REGION` with your Amazon account ID and AWS region,
    respectively.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：将`ACCOUNT_ID`和`REGION`分别替换为您的Amazon账户ID和AWS区域。
- en: 'For Windows users, here is the command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，以下是命令：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Repeat the same procedure to create dedicated ECR repositories per microservice,
    as shown in figure 9.18.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重复相同的步骤，为每个微服务创建专门的ECR仓库，如图9.18所示。
- en: '![](Images/CH09_F18_Labouardy.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F18_Labouardy.png)'
- en: Figure 9.18 ECR repository for each microservice
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18每个微服务的ECR仓库
- en: 9.2.3 Azure Container Registry
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 Azure Container Registry
- en: For Azure users, the Azure Container Registry service can be used to store container
    images without managing a private registry. On the Azure portal ([https://portal.azure.com/](https://portal.azure.com/)),
    navigate to the Container Registries service and click the Add button to create
    a new registry. Specify the region where you want to deploy the registry and give
    it a name, as shown in figure 9.19.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Azure用户，可以使用Azure Container Registry服务来存储容器镜像，而无需管理私有注册表。在Azure门户([https://portal.azure.com/](https://portal.azure.com/))中，导航到容器注册表服务，点击添加按钮以创建新的注册表。指定您想要部署注册表的区域，并给它一个名称，如图9.19所示。
- en: '![](Images/CH09_F19_Labouardy.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F19_Labouardy.png)'
- en: Figure 9.19 Azure new registry configuration
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 Azure新注册表配置
- en: Leave other fields at the defaults and click Create. Once the registry is created,
    navigate to Access Keys under the Settings section, where you will find the admin
    username and password that you can use to authenticate to the registry to push
    or pull Docker images from Jenkins; see figure 9.20.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将其他字段保留为默认值，然后点击创建。一旦创建注册表，导航到设置部分下的访问密钥，在那里您将找到可用于从Jenkins推送或拉取Docker镜像的admin用户名和密码；见图9.20。
- en: '![](Images/CH09_F20_Labouardy.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F20_Labouardy.png)'
- en: Figure 9.20 Azure Docker registry admin credentials
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 Azure Docker注册表管理员凭据
- en: You can use those credentials in Jenkins to push the image within the CI pipeline.
    However, I recommend creating a token with granular access control by using role-based
    access control (RBAC), or the least privilege principle. The admin account is
    designed for only a single user to access the registry, mainly for testing purposes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些凭据在Jenkins中推送CI管道内的镜像。然而，我建议通过使用基于角色的访问控制（RBAC）或最小权限原则来创建具有细粒度访问控制的令牌。管理员账户仅设计为单个用户访问注册表，主要用于测试目的。
- en: Navigate to the Tokens section and click the Add button to create a new access
    token. Give it a name and associate the `_repositories_push` scope to allow the
    execution of the `docker push` operation only (Jenkins will need to push only
    images to the registry); see figure 9.21.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到令牌部分，点击添加按钮以创建新的访问令牌。给它一个名称，并将`_repositories_push`作用域关联起来，以允许仅执行`docker push`操作（Jenkins只需要将镜像推送到注册表）；见图9.21。
- en: '![](Images/CH09_F21_Labouardy.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F21_Labouardy.png)'
- en: Figure 9.21 Azure Docker registry new access token
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 Azure Docker注册表新访问令牌
- en: Generate a password after you have created a token, as shown in figure 9.22\.
    To authenticate with the registry, the token must be enabled and have a valid
    password.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建令牌后，如图9.22所示，生成密码。为了与注册表进行身份验证，令牌必须启用并具有有效的密码。
- en: '![](Images/CH09_F22_Labouardy.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F22_Labouardy.png)'
- en: Figure 9.22 Azure Docker registry credentials
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 Azure Docker注册表凭据
- en: After generating a password, copy and save it as Jenkins credentials of type
    Username with Password. You can’t retrieve a generated password after closing
    the dialog screen, but you can generate a new one.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成密码后，将其复制并保存为Jenkins凭据类型为用户名和密码。在关闭对话框屏幕后，您无法检索生成的密码，但可以生成一个新的。
- en: 9.2.4 Google Container Registry
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 Google Container Registry
- en: For Google Cloud Platform users, a managed service called Google Container Registry
    (GCR) can be used to host Docker images. To get started, you need to enable API
    Container Registry ([https://cloud.google.com/container-registry/docs/quickstart](https://cloud.google.com/container-registry/docs/quickstart))
    for your GCP project and then install the `gcloud` command line. For Linux users,
    run the following listing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Google Cloud Platform用户，可以使用名为Google Container Registry (GCR) 的托管服务来托管Docker镜像。要开始使用，您需要为您的GCP项目启用API
    Container Registry ([https://cloud.google.com/container-registry/docs/quickstart](https://cloud.google.com/container-registry/docs/quickstart))，然后安装`gcloud`命令行工具。对于Linux用户，运行以下列表。
- en: Listing 9.13 `gcloud` installation
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 `gcloud`安装
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note For further instructions on how to install the Google Cloud SDK, read the
    official GCP guide at [https://cloud.google.com/sdk/install](https://cloud.google.com/sdk/install).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关如何安装 Google Cloud SDK 的进一步说明，请参阅官方 GCP 指南 [https://cloud.google.com/sdk/install](https://cloud.google.com/sdk/install)。
- en: 'Next, issue the following command to authenticate with the registry. The resulting
    authentication token is persisted in ~/.docker/config.json and reused for any
    subsequent interactions against that repository:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令以对注册表进行身份验证。生成的身份验证令牌将持久化到 ~/.docker/config.json，并用于对该存储库的任何后续交互：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You need to tag the target images with the GCR URI (`gcr.io/[PROJECT-ID]`)
    and push the images with the `docker push` command. Figure 9.23 shows how to tag
    and push the movies-loader Docker image to GCR:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用 GCR URI (`gcr.io/[PROJECT-ID]`) 标记目标镜像，并使用 `docker push` 命令推送镜像。图 9.23
    展示了如何标记和推送 movies-loader Docker 镜像到 GCR：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](Images/CH09_F23_Labouardy.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F23_Labouardy.png)'
- en: Figure 9.23 Google Container Registry images
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 Google 容器注册表镜像
- en: Now that we’ve covered how to deploy a private Docker registry, we will update
    the Jenkinsfile for each service to push the image to the remote private registry
    at the end of a successful CI pipeline execution.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经介绍了如何部署私有 Docker 注册表，我们将更新每个服务的 Jenkinsfile，以便在成功的 CI 管道执行结束时将镜像推送到远程私有注册表。
- en: 9.3 Tagging Docker images the right way
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 正确标记 Docker 镜像
- en: Add a new push stage to the Jenkinsfile with the `withRegistry` block, which
    authenticates against the registry URL provided in the first parameter by using
    the credentials provided in the second parameter. Then it persists the changes
    in ~/.docker/config.json. Finally, it pushes the image with a tag value equal
    to the build number ID (using the `env.BUILD_ID` keyword). The following listing
    is the Jenkinsfile for the movies-loader service after implementing the `Push`
    stage.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkinsfile 中添加一个新的推送阶段，使用 `withRegistry` 块，通过第二个参数提供的凭据对第一个参数中提供的注册表 URL
    进行身份验证。然后，它将更改持久化到 ~/.docker/config.json。最后，它使用等于构建编号 ID 的标签值（使用 `env.BUILD_ID`
    关键字）推送镜像。以下是在实现 `Push` 阶段后 movies-loader 服务的 Jenkinsfile 列表。
- en: Listing 9.14 Publishing Docker image to a registry
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 将 Docker 镜像发布到注册表
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note The `imageName` and `registry` values must be replaced with your own Docker
    private registry URL and name of the image to store, respectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`imageName` 和 `registry` 值必须替换为您自己的 Docker 私有注册表 URL 和要存储的镜像名称。
- en: For this example, the build number is 2; therefore, the movies-loader image
    is pushed to the registry after tagging it with a tag equal to 2, as shown in
    figure 9.24.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，构建编号是 2；因此，movies-loader 镜像在标记为 2 后被推送到注册表，如图 9.24 所示。
- en: '![](Images/CH09_F24_Labouardy.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F24_Labouardy.png)'
- en: Figure 9.24 Docker push command logs
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 Docker 推送命令日志
- en: If we head back to the registry (for example, on Nexus Repository Manager),
    we can see that a movies-loader image has been successfully pushed (figure 9.25).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到注册表（例如，在 Nexus Repository Manager 上），我们可以看到 movies-loader 镜像已成功推送（图 9.25）。
- en: '![](Images/CH09_F25_Labouardy.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F25_Labouardy.png)'
- en: Figure 9.25 Docker image stored in Nexus
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 Nexus 中存储的 Docker 镜像
- en: 'While the Jenkins build ID can be used to tag the images, it might not be handy.
    A better identifier is the Git commit ID. In this example, we will use it to tag
    the built Docker image. On a declarative and scripted pipeline, this information
    is not available out of the box. Therefore, we will create a function that uses
    the Git command line to fetch the commit ID and return it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用 Jenkins 构建编号来标记镜像，但这可能不太方便。更好的标识符是 Git 提交 ID。在这个例子中，我们将使用它来标记构建的 Docker
    镜像。在声明性和脚本管道中，此信息不是默认可用的。因此，我们将创建一个函数，该函数使用 Git 命令行获取提交 ID 并返回它：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'From there, we can update the `Push` stage to tag the image with the value
    returned by the `commitID()` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以更新 `Push` 阶段，使用 `commitID()` 函数返回的值标记镜像：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note In chapter 14, we will cover how to create a Jenkins shared library with
    custom functions to avoid duplication of code in Jenkinsfiles.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第 14 章中，我们将介绍如何创建带有自定义函数的 Jenkins 共享库，以避免在 Jenkinsfile 中重复代码。
- en: 'Push the changes to the GitHub repository with the following commands:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将更改推送到 GitHub 仓库：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new CI pipeline stages should look like figure 9.26 for the movies-loader
    service.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 CI 管道阶段应该看起来像图 9.26 中的 movies-loader 服务。
- en: '![](Images/CH09_F26_Labouardy.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F26_Labouardy.png)'
- en: Figure 9.26 Movie loader CI pipeline
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 电影加载 CI 管道
- en: After a successful run on Nexus Repository Manager, a new image with a commit
    ID should be available (figure 9.27).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nexus Repository Manager上成功运行后，应该有一个带有提交ID的新镜像可用（如图9.27所示）。
- en: '![](Images/CH09_F27_Labouardy.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F27_Labouardy.png)'
- en: Figure 9.27 Commit ID image tag
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27 提交ID镜像标签
- en: 'We will take this further and push the same image with a tag based on the branch
    name. This tag will be helpful when we tackle continuous deployment and delivery.
    It will allow us to assign a particular tag per environment:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步操作，并基于分支名称推送相同的镜像。这个标签在处理持续部署和交付时将非常有用。它将允许我们为每个环境分配特定的标签：
- en: '*Latest*—Used to deploy the image to the production environment'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Latest*—用于将镜像部署到生产环境'
- en: '*Preprod*—Used to deploy the image to the staging or preproduction environment'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Preprod*—用于将镜像部署到预发布或预生产环境'
- en: '*Develop*—Used to deploy the image to the sandbox or development environment'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Develop*—用于将镜像部署到沙盒或开发环境'
- en: 'The `Push` stage code block is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Push`阶段的代码块如下：'
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `env.BRANCH_NAME` variable contains the branch name. Also, you can just
    use `BRANCH_NAME` without the `env` keyword (it hasn’t been required since Pipeline
    Groovy Plugin 2.18).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`env.BRANCH_NAME`变量包含分支名称。您也可以直接使用`BRANCH_NAME`而不需要`env`关键字（自从Pipeline Groovy
    Plugin 2.18以来就没有要求了）。'
- en: Lastly, if you’re using Amazon ECR as a private registry, you need to authenticate
    first with the AWS CLI to the remote repository before issuing the push instructions.
    For AWS CLI 2 users, use the shell instruction in the following listing to invoke
    the `aws ecr` command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您使用Amazon ECR作为私有仓库，在发出推送指令之前，您需要先使用AWS CLI对远程仓库进行认证。对于AWS CLI 2用户，请使用以下列表中的shell指令来调用`aws
    ecr`命令。
- en: Listing 9.15 Publishing the Docker image to ECR
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.15 将Docker镜像发布到ECR
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Make sure to substitute the `ACCOUNT_ID` and `REGION` variables with your own
    AWS account ID and AWS region, respectively. If you’re using a 1.x version of
    the AWS CLI, use this code block instead:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`ACCOUNT_ID`和`REGION`变量分别替换为您的AWS账户ID和AWS区域。如果您使用的是AWS CLI 1.x版本，请使用以下代码块：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before triggering the CI pipeline, you will need to give access to Jenkins workers
    to perform the push operation on the ECR registry. Therefore, you need to assign
    an IAM instance profile to Jenkins worker instances with the AmazonEC2ContainerRegistryFullAccess
    policy. Figure 9.28 illustrates the IAM instance profile assigned to Jenkins workers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在触发CI管道之前，您需要授予Jenkins工作节点对ECR注册表执行推送操作的权利。因此，您需要将AmazonEC2ContainerRegistryFullAccess策略分配给Jenkins工作节点实例的IAM实例配置文件。图9.28展示了分配给Jenkins工作节点的IAM实例配置文件。
- en: '![](Images/CH09_F28_Labouardy.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F28_Labouardy.png)'
- en: Figure 9.28 Jenkins workers’ IAM instance profile
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28 Jenkins工作节点的IAM实例配置文件
- en: Once you’ve made the required changes, a new build should be triggered. A new
    image tag should be pushed to the ECR repository, at the end of the CI pipeline,
    as shown in figure 9.29.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了必要的更改，应该触发一个新的构建。在CI管道的末尾，应该将一个新的镜像标签推送到ECR仓库，如图9.29所示。
- en: '![](Images/CH09_F29_Labouardy.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F29_Labouardy.png)'
- en: Figure 9.29 Movie loader ECR repository images
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29 电影加载器ECR仓库镜像
- en: Repeat the same procedure for the rest of the microservices, to push their Docker
    image to the end of the CI pipeline, as shown in figure 9.30.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对其他微服务重复相同的步骤，将它们的Docker镜像推送到CI管道的末尾，如图9.30所示。
- en: '![](Images/CH09_F30_Labouardy.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F30_Labouardy.png)'
- en: Figure 9.30 Movie marketplace CI pipeline
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30 电影市场CI管道
- en: In a typical workflow, the Docker images should be analyzed, inspected, and
    scanned against security rules for compliance and auditing. That’s why, in the
    upcoming section, we will integrate a container inspection and analytics platform
    within the CI pipeline to continuously inspect built Docker images for security
    vulnerabilities.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的流程中，Docker镜像应该进行分析、检查，并针对安全规则进行合规性和审计。这就是为什么在接下来的章节中，我们将集成容器检查和分析平台到CI管道中，以持续检查构建的Docker镜像中的安全漏洞。
- en: 9.4 Scanning Docker images for vulnerabilities
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 扫描Docker镜像以查找漏洞
- en: '*Anchore* *Engine* ([https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine))
    is an open source project that provides a centralized service for inspection,
    analysis, and certification of container images. You can run Anchore Engine as
    a standalone service or as a Docker container.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*Anchore* *Engine* ([https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine))是一个开源项目，它提供了一个集中的服务，用于检查、分析和认证容器镜像。您可以将Anchore
    Engine作为一个独立的服务或作为Docker容器运行。'
- en: Note A standalone installation will require at least 4 GB of RAM and enough
    disk space available to support the container images you intend to analyze.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：独立安装至少需要 4 GB 的 RAM 和足够的磁盘空间来支持您打算分析的容器镜像。
- en: You can bake your own AMI with Packer from scratch to install Anchore Engine
    and set up the PostgreSQL database. Then, use Terraform to deploy the stack, or
    you can simply deploy the configured stack out of the box with Docker Compose.
    Refer to chapters 4 and 5 for instructions on how to use Terraform and Packer.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从头使用 Packer 制作自己的 AMI 来安装 Anchore Engine 并设置 PostgreSQL 数据库。然后，使用 Terraform
    来部署堆栈，或者您可以直接使用 Docker Compose 部署配置好的堆栈。有关如何使用 Terraform 和 Packer 的说明，请参阅第 4 章和第
    5 章。
- en: Launch a private instance in the *management* VPC with Docker Community Edition
    (CE) pre-installed, and then install the Docker Compose tool from the Docker official
    guide page. Issue the following command to deploy Anchore Engine.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在预装了 Docker 社区版 (CE) 的 *管理* VPC 中启动一个私有实例，然后从 Docker 官方指南页面安装 Docker Compose
    工具。使用以下命令部署 Anchore Engine。
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After a few moments, your Anchore Engine services should be up and running,
    ready to use. You can verify that the containers are running with the `docker-compose`
    `ps` command. Figure 9.31 shows the output. Make sure to allow inbound traffic
    on port 8228 (Anchore API) from the Jenkins master security group ID only, as
    shown in figure 9.32.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，您的 Anchore Engine 服务应该已经启动并运行，准备使用。您可以使用 `docker-compose` `ps` 命令验证容器是否正在运行。图
    9.31 显示了输出。请确保仅从 Jenkins 主安全组 ID 允许端口 8228（Anchore API）的入站流量，如图 9.32 所示。
- en: '![](Images/CH09_F31_Labouardy.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F31_Labouardy.png)'
- en: Figure 9.31 Docker Compose stack services
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.31 Docker Compose 堆栈服务
- en: '![](Images/CH09_F32_Labouardy.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F32_Labouardy.png)'
- en: Figure 9.32 Anchore instance’s security group
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.32 Anchore 实例的安全组
- en: Note You can take this further and deploy a load balancer in front of the EC2
    instance and create an A record in Route 53 pointing to the load balancer FQDN.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以进一步操作，在 EC2 实例前部署一个负载均衡器，并在 Route 53 中创建一个指向负载均衡器 FQDN 的 A 记录。
- en: When it comes to Jenkins, an available plugin already makes the integration
    much easier. From the main Jenkins menu, select Manage Jenkins and jump to the
    Manage Plugins section. Click the Available tab and install the Anchore Container
    Image Scanner plugin, as shown in figure 9.33.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Jenkins 时，一个可用的插件已经使得集成变得容易得多。从主 Jenkins 菜单中选择“管理 Jenkins”，然后跳转到“管理插件”部分。点击“可用”标签，安装
    Anchore 容器镜像扫描插件，如图 9.33 所示。
- en: '![](Images/CH09_F33_Labouardy.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F33_Labouardy.png)'
- en: Figure 9.33 Anchore Container Image Scanner plugin
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.33 Anchore 容器镜像扫描插件
- en: Next, from the Manage Jenkins menu, choose Configure System and scroll down
    to the Anchore Configuration. Then, set the Anchore URL with the /v1 route included
    and credentials (the default is admin/foobar), as shown in figure 9.34.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从“管理 Jenkins”菜单中选择“配置系统”，然后滚动到“Anchore 配置”。然后，设置 Anchore URL，包括 /v1 路由和凭据（默认为
    admin/foobar），如图 9.34 所示。
- en: '![](Images/CH09_F34_Labouardy.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F34_Labouardy.png)'
- en: Figure 9.34 Anchore plugin configuration
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.34 Anchore 插件配置
- en: Finally, integrate Anchore into the Jenkins pipeline by creating a file named
    *images* in the project workspace. This file should contain the name of the Docker
    image to be scanned and optionally include the Dockerfile. Then, call the Anchore
    plugin with the file created as a parameter, as shown in the following listing.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在项目工作区中创建一个名为 *images* 的文件来将 Anchore 集成到 Jenkins 管道中。此文件应包含要扫描的 Docker
    镜像的名称，并可选地包含 Dockerfile。然后，使用创建的文件作为参数调用 Anchore 插件，如下所示。
- en: Listing 9.16 Analyzing Docker images with Anchore
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 使用 Anchore 分析 Docker 镜像
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Push the changes with the following commands to the remote repository on the
    develop branch:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将更改推送到 develop 分支上的远程仓库：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The CI pipeline will be triggered upon the push event. After the image has been
    built and pushed to the registry, the Anchore Scanner should be called. It will
    throw an error due to Anchore not being able to pull the Docker image from the
    private registry for analysis and inspection.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: CI 管道将在推送事件上触发。在镜像构建并推送到注册表后，应调用 Anchore Scanner。由于 Anchore 无法从私有注册表中拉取 Docker
    镜像进行分析和检查，它将抛出一个错误。
- en: 'Fortunately, Anchore integrates and supports analyzing images from any registry
    compatible with Docker v2\. To allow access to the remote images from Anchore,
    install the `anchor-cli` binary from the Anchore EC2 instance:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Anchore 集成并支持分析与 Docker v2 兼容的任何仓库中的镜像。为了允许 Anchore 访问远程镜像，从 Anchore EC2
    实例安装 `anchor-cli` 二进制文件：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we define credentials for the private Docker registry. Run this command;
    the `REGISTRY` parameter should include the registry’s fully qualified hostname
    and port number (if exposed).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为私有 Docker 仓库定义凭证。运行此命令；`REGISTRY` 参数应包括仓库的完全限定主机名和端口号（如果公开）。
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note The same command can be used to configure a Docker registry hosted on Nexus
    or other solutions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：相同的命令可以用来配置托管在 Nexus 或其他解决方案上的 Docker 仓库。
- en: 'Since we’re using Amazon ECR repositories and running Anchore from an EC2 instance,
    we will assign an IAM instance profile instead with the AmazonEC2ContainerRegistryReadOnly
    policy. In this case, we will pass `awsauto` for both `USERNAME` and `PASSWORD`
    and instruct the Anchore Engine to inherit the role from the underlying EC2 instance:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Amazon ECR 仓库并在 EC2 实例上运行 Anchore，我们将使用带有 AmazonEC2ContainerRegistryReadOnly
    策略的 IAM 实例配置文件。在这种情况下，我们将为 `USERNAME` 和 `PASSWORD` 都传递 `awsauto`，并指示 Anchore 引擎从底层
    EC2 实例继承角色：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To verify that credentials have been properly configured, run the following
    command to list the defined registries:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证凭证是否已正确配置，运行以下命令以列出定义的仓库：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![](Images/CH09_F34_UN02_Labouardy.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F34_UN02_Labouardy.png)'
- en: Rerun the pipeline with the Replay button. This time, Anchore will examine the
    contents of the image filesystem for vulnerabilities. If high-severity vulnerabilities
    are found, this will fail the image build, as shown in figure 9.35.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用重放按钮重新运行管道。这次，Anchore 将检查镜像文件系统中的漏洞。如果发现严重漏洞，这将导致镜像构建失败，如图 9.35 所示。
- en: '![](Images/CH09_F35_Labouardy.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F35_Labouardy.png)'
- en: Figure 9.35 Image scanning with Anchore
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.35 使用 Anchore 进行镜像扫描
- en: Once the scanning is finished, Anchore will return with a nonzero exit code
    if the image has any known high-severity issues. The result of the Anchore policy
    evaluation will be saved in JSON files. Also, the pipeline will show the status
    of the build (STOP, WARN, or FAIL), as shown in figure 9.36.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦扫描完成，如果镜像有任何已知的严重问题，Anchore 将返回非零退出代码。Anchore 策略评估的结果将保存在 JSON 文件中。此外，管道将显示构建的状态（停止、警告或失败），如图
    9.36 所示。
- en: '![](Images/CH09_F36_Labouardy.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F36_Labouardy.png)'
- en: Figure 9.36 Anchore report results
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.36 Anchore 报告结果
- en: The HTML report is automatically published, as well, on the newly created page.
    Clicking the Anchore Report link will display a graphical policy report showing
    the summary information and a detailed list of policy checks and results; see
    figure 9.37.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 报告也会自动发布在新创建的页面上。点击 Anchore 报告链接将显示一个图形化策略报告，显示摘要信息和策略检查的详细列表；见图 9.37。
- en: '![](Images/CH09_F37_Labouardy.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F37_Labouardy.png)'
- en: Figure 9.37 Anchore Common Vulnerabilities and Exposures (CVE) report
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.37 Anchore 常见漏洞和暴露（CVE）报告
- en: Note You can customize Anchore Engine to use your own security policies to allow/block
    external packages, OS scanning, and so forth.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以根据自己的安全策略自定义 Anchore 引擎，以允许/阻止外部包、操作系统扫描等。
- en: And that’s how to define a continuous integration pipeline on Jenkins from scratch
    for Dockerized microservices.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是从头开始在 Jenkins 上为 Docker 化的微服务定义持续集成管道的方法。
- en: Note An alternative solution is Aqua Trivy ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy)),
    which is a freely available community edition. Paid solutions also can be integrated
    easily with Jenkins such as Sysdig ([https://sysdig.com/](https://sysdig.com/))
    and Aqua.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：另一种解决方案是 Aqua Trivy ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy))，这是一个免费提供的社区版。付费解决方案也可以轻松集成到
    Jenkins 中，例如 Sysdig ([https://sysdig.com/](https://sysdig.com/)) 和 Aqua。
- en: 9.5 Writing a Jenkins declarative pipeline
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 编写 Jenkins 声明式管道
- en: Along with the previous chapters, we have used the scripted pipeline approach
    to define the CI pipeline for our project because of the flexibility it gives
    while using Groovy syntax. This section covers how to get the same pipeline output
    with a declarative pipeline approach. This is a simplified and friendlier syntax
    with specific statements for defining them, without a need to learn or master
    Groovy language.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的章节，我们由于Groovy语法的灵活性，使用了脚本式流水线方法来定义我们项目的CI流水线。本节将介绍如何使用声明式流水线方法获得相同的流水线输出。这是一个简化且友好的语法，具有用于定义它们的特定语句，无需学习或掌握Groovy语言。
- en: Let’s take as an example the scripted pipeline used for the movies-loader service.
    The following listing provides the service Jenkinsfile (cropped for brevity).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以movies-loader服务的脚本式流水线为例。以下列表提供了服务的Jenkinsfile（为了简洁而截断）。
- en: Listing 9.17 Jenkinsfile scripted pipeline
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17 Jenkinsfile脚本式流水线
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This scripted pipeline can be easily converted to a declarative version, by
    following these steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，可以将此脚本式流水线轻松转换为声明式版本：
- en: Replace the `node('workers')` instruction with a `pipeline` keyword. All valid
    declarative pipelines must be enclosed within a `pipeline` block.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`node('workers')`指令替换为`pipeline`关键字。所有有效的声明式流水线都必须包含在`pipeline`块内。
- en: Define an `agent` section at the top level inside the `pipeline` block, to define
    the execution environment where the pipeline will be executed. In our example,
    the execution will be on Jenkins workers.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pipeline`块内部定义一个顶级`agent`部分，以定义流水线将要执行的执行环境。在我们的例子中，执行将在Jenkins工作节点上进行。
- en: Wrap `stage` blocks with a `stages` section. The `stages` section contains a
    stage for each discrete part of the CI pipeline, such as `Checkout`, `Test`, `Build`,
    and `Push`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`stage`块用`stages`部分包裹。`stages`部分包含CI流水线每个离散部分的阶段，如`Checkout`、`Test`、`Build`和`Push`。
- en: Wrap each given `stage` command and instruction with a `steps` block.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个给定的`stage`命令和指令用`steps`块包裹。
- en: Create a Jenkinsfile.declarative file with the required changes. The end result
    should look like the following listing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含所需更改的Jenkinsfile.declarative文件。最终结果应如下列表所示。
- en: Listing 9.18 Jenkinsfile declarative pipeline
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18 Jenkinsfile声明式流水线
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Defines where the pipeline should be executed. In the example, the pipeline
    stages will be performed on the agents with the workers label.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义流水线应该在哪里执行。在示例中，流水线阶段将在带有workers标签的代理上执行。
- en: ❷ Clones the GitHub repository configured in the Jenkins’s job settings
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 克隆Jenkins作业设置中配置的GitHub仓库
- en: ❸ Builds a Docker image based on Dockerfile.test and provisions a container
    from the image to run the Python unit tests
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 基于Dockerfile.test构建Docker镜像，并从镜像中部署容器以运行Python单元测试
- en: ❹ Builds the application Docker image from the Dockerfile
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从Dockerfile构建应用程序的Docker镜像
- en: ❺ Authenticates with the Docker remote repository and pushes the application
    image to the repository
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用Docker远程仓库进行身份验证并将应用程序镜像推送到仓库
- en: Note The declarative pipeline might also contain a `post` section to perform
    post-build steps such as notification or cleaning up the environment. This section
    is covered in chapter 10.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：声明式流水线也可能包含一个`post`部分来执行如通知或清理环境的后构建步骤。这部分内容在第10章中介绍。
- en: Update the Jenkins job configuration to use the new declarative pipeline file
    instead by updating the Script Path field, as shown in figure 9.38.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新脚本路径字段，将Jenkins作业配置更新为使用新的声明式流水线文件，如图9.38所示。
- en: '![](Images/CH09_F38_Labouardy.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F38_Labouardy.png)'
- en: Figure 9.38 Jenkinsfile path configuratio.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38 Jenkinsfile路径配置。
- en: 'Push the declarative pipeline to the remote repository with these commands:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将声明式流水线推送到远程仓库：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The GitHub webhook will notify Jenkins upon the push event, and the new declarative
    pipeline should be executed, as you can see in figure 9.39.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub webhook会在推送事件发生时通知Jenkins，并执行新的声明式流水线，如图9.39所示。
- en: '![](Images/CH09_F39_Labouardy.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F39_Labouardy.png)'
- en: Figure 9.39 Jenkinsfile declarative pipeline executio.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.39 Jenkinsfile声明式流水线执行。
- en: You can now restart any completed declarative pipeline from any top-level stage
    that ran in that pipeline. You can go to the side panel for a run in the classic
    UI and click Restart from Stage, as shown in figure 9.40.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从该流水线中任何已运行的最高级阶段重新启动任何完成的声明式流水线。您可以通过经典UI中的侧面板进行运行，并如图9.40所示点击从阶段重启。
- en: '![](Images/CH09_F40_Labouardy.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F40_Labouardy.png)'
- en: Figure 9.40 Restart from Stage featur.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.40 从阶段重启功能。
- en: You will be prompted to choose from a list of top-level stages that were executed
    in the original run, in the order they were executed. This allows you to rerun
    a pipeline from a stage that failed because of transient or environmental considerations.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您将提示从原始运行中执行过的顶级阶段列表中选择，按照它们执行的顺序。这允许您从由于暂时性或环境考虑而失败的阶段重新运行管道。
- en: Note Restarting stages can also be done in the Blue Ocean UI, after your pipeline
    has completed, whether it succeeds or fails.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：重启阶段也可以在 Blue Ocean UI 中完成，无论您的管道是成功还是失败后。
- en: Docker can also be used as an execution environment for running CI/CD pipelines
    in the `agent` section, as shown in the following listing.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 也可以在 `agent` 部分用作运行 CI/CD 管道的执行环境，如下面的列表所示。
- en: Listing 9.19 Declarative pipeline with a Docker agent
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 带有 Docker 代理的声明式管道
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we try to execute this pipeline, the build will quickly fail because the
    pipeline assumes that any configured machine/instance is capable of running Docker-based
    pipelines. In this example, the build ran in the master machine. However, because
    Docker is not installed in this machine, the pipeline failed:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行此管道，构建将迅速失败，因为管道假设任何配置的机器/实例都能够运行基于 Docker 的管道。在本例中，构建是在主机器上运行的。然而，由于此机器上未安装
    Docker，管道失败了：
- en: '![](Images/CH09_F40_UN03_Labouardy.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F40_UN03_Labouardy.png)'
- en: To run the pipeline on Jenkins workers only, update the Pipeline Model Definition
    settings from the Jenkins job configuration and set the `workers` label on the
    Docker Label field, as shown in figure 9.41.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在 Jenkins 工作节点上运行管道时，请从 Jenkins 作业配置中更新 Pipeline 模型定义设置，并在 Docker 标签字段中设置 `workers`
    标签，如图 9.41 所示。
- en: '![](Images/CH09_F41_Labouardy.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F41_Labouardy.png)'
- en: Figure 9.41 Pipeline model definitio.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.41 管道模型定义。
- en: When the pipeline executes, Jenkins will automatically start the specified container
    and execute the steps defined within it. This pipeline executes the same stages
    and the same steps.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当管道执行时，Jenkins 将自动启动指定的容器并执行其中定义的步骤。此管道执行相同阶段和相同步骤。
- en: 9.6 Managing pull requests with Jenkins
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 使用 Jenkins 管理拉取请求
- en: For now, we push directly to the develop branch; however, we should create feature
    branches and then create pull requests to run tests and provide feedback to GitHub
    and block submission approval if tests fail. Let’s see how to set up a review
    process with Jenkins for pull requests.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们直接推送到 develop 分支；然而，我们应该创建功能分支，然后创建拉取请求以运行测试并提供反馈给 GitHub，如果测试失败则阻止提交批准。让我们看看如何使用
    Jenkins 为拉取请求设置审查流程。
- en: 'Create a new feature branch from the develop branch with the following command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从 develop 分支创建一个新的功能分支：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Make some changes; in this example, I have updated the README.md file. Then,
    commit the changes and push the new feature branch to the remote repository:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 进行一些更改；在本例中，我已更新了 README.md 文件。然后，提交更改并将新功能分支推送到远程仓库：
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Head over to the GitHub repository, and create a new pull request to merge the
    feature branch to the develop branch, as shown in figure 9.42.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 GitHub 仓库，并创建一个新的拉取请求以合并功能分支到 develop 分支，如图 9.42 所示。
- en: '![](Images/CH09_F42_Labouardy.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F42_Labouardy.png)'
- en: Figure 9.42 New pull request
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.42 新的拉取请求
- en: On Jenkins, a new build will be triggered on the feature branch, as you can
    see in figure 9.43.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 上，将在功能分支上触发一个新的构建，如图 9.43 所示。
- en: '![](Images/CH09_F43_Labouardy.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F43_Labouardy.png)'
- en: Figure 9.43 Build execution on the feature branc.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.43 特定分支上的构建执行
- en: Once the CI is finished, Jenkins will update the status on GitHub (figure 9.44).
    The build indicator in GitHub will turn either red or green, based on the build
    status.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 CI 完成，Jenkins 将更新 GitHub 上的状态（图 9.44）。GitHub 上的构建指示器将根据构建状态变为红色或绿色。
- en: '![](Images/CH09_F44_Labouardy.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F44_Labouardy.png)'
- en: Figure 9.44 Jenkins post-build status on GitHub PR
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.44 Jenkins 在 GitHub PR 上的构建状态
- en: Note You can also configure SonarQube to analyze pull requests so you can ensure
    that the code is clean and approved for merging.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您还可以配置 SonarQube 以分析拉取请求，以确保代码干净且已批准合并。
- en: This process allows you to run a build and subsequent automated tests at every
    check-in so only the best code gets merged. Catching bugs early and automatically
    reduces the number of problems introduced into production, so your team can build
    better, more efficient software. We can now merge the feature branch and delete
    it; see figure 9.45.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程允许你在每次提交时运行构建和后续的自动化测试，这样只有最好的代码才会被合并。早期发现并自动修复错误可以减少引入生产环境中的问题数量，因此你的团队能够构建更好、更高效的软件。现在我们可以合并功能分支并删除它；请参见图
    9.45。
- en: '![](Images/CH09_F45_Labouardy.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F45_Labouardy.png)'
- en: Figure 9.45 Merge and delete the feature branch.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.45 合并并删除功能分支。
- en: And that will trigger another build on the develop branch, which will trigger
    the CI stages and push the image with the `develop` tag to the remote Docker registry.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发 develop 分支上的另一个构建，这将触发 CI 阶段并将带有 `develop` 标签的镜像推送到远程 Docker 仓库。
- en: Once the build is completed, we can check the status of previous commits by
    clicking the Commits section from the GitHub repository. A green, yellow, or red
    check mark should be displayed, depending on the state of the build; see figure
    9.46.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，我们可以通过点击 GitHub 仓库中的 Commits 部分，来检查之前提交的状态。根据构建的状态，应该会显示绿色、黄色或红色的勾选标记；请参见图
    9.46。
- en: '![](Images/CH09_F46_Labouardy.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F46_Labouardy.png)'
- en: Figure 9.46 Jenkins build status history
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.46 Jenkins 构建状态历史
- en: Finally, to disable developers from pushing directly to the develop branch and
    also merging without a Jenkins build being passed, we will create a new rule to
    protect the develop branch. On the GitHub repository settings, jump to the Branches
    section and add a new protection rule that requires the Jenkins status check to
    be successful before merging. Figure 9.47 shows the rule configuration.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了防止开发者直接向 develop 分支推送，以及在没有 Jenkins 构建通过的情况下合并，我们将创建一个新的规则来保护 develop 分支。在
    GitHub 仓库设置中，转到 Branches 部分，并添加一个新保护规则，要求在合并之前 Jenkins 状态检查必须成功。图 9.47 显示了规则配置。
- en: '![](Images/CH09_F47_Labouardy.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F47_Labouardy.png)'
- en: Figure 9.47 GitHub branch protection
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.47 GitHub 分支保护
- en: Apply the same rule for the preprod and master branches. Then, repeat the same
    procedure for the rest of the GitHub repositories of the project.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对预生产和 master 分支应用相同的规则。然后，对项目的其余 GitHub 仓库重复相同的程序。
- en: 'With the Docker images safely stored in the private registry and the build
    status posted to GitHub, we’ve completed the implementation of the CI pipeline
    of Dockerized microservices with Jenkins multibranch pipelines. The next two chapters
    cover how to implement continuous deployment and delivery practices with Jenkins
    for two of the most used container orchestration platforms for cloud-native applications:
    Docker Swarm and Kubernetes.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Docker 镜像安全存储在私有仓库中，并将构建状态发布到 GitHub 后，我们已经完成了使用 Jenkins 多分支管道实现 Docker 化微服务的
    CI 管道的实施。接下来的两章将介绍如何使用 Jenkins 实现持续部署和交付实践，针对云原生应用中最常用的两个容器编排平台：Docker Swarm 和
    Kubernetes。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can optimize Docker images for production with Docker caching layers, multistage
    build features, and lightweight base images such as an Alpine base image.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Docker 缓存层、多阶段构建功能和轻量级基础镜像（如 Alpine 基础镜像）来优化 Docker 镜像以适应生产环境。
- en: The commit ID and Jenkins build ID can be used to tag Docker images for versioning
    and rollback to a working version in case of application deployment failure.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交 ID 和 Jenkins 构建ID可以用来对 Docker 镜像进行版本控制，并在应用程序部署失败的情况下回滚到工作版本。
- en: Binary repository tools like Nexus and Artifactory can manage and store build
    artifacts for later use.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 Nexus 和 Artifactory 这样的二进制仓库工具可以管理和存储构建工件，以供以后使用。
- en: Anchore Engine is an open source tool that lets you scan Docker images for security
    vulnerabilities during CI workflow.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anchore Engine 是一个开源工具，允许你在 CI 工作流中扫描 Docker 镜像以查找安全漏洞。
- en: In a CI environment, the frequency of a build is too high, and each build generates
    a package. Since all the built packages are in one place, developers are at liberty
    to choose what to promote and what not to promote in higher environments.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CI 环境中，构建的频率太高，每次构建都会生成一个包。由于所有构建的包都在一个地方，开发者可以自由选择在更高环境中推广什么，不推广什么。
