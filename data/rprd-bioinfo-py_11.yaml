- en: 'Chapter 10\. Finding the Longest Shared Subsequence: Finding K-mers, Writing
    Functions, and Using Binary Search'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。找到最长共享子序列：找到K-mers，编写函数和使用二分搜索
- en: As described in [the Rosalind LCSM challenge](https://oreil.ly/SONgC), the goal
    of this exercise is to find the longest substring that is shared by all sequences
    in a given FASTA file. In [Chapter 8](ch08.html#ch08), I was searching for a given
    motif in some sequences. In this challenge, I don’t know *a priori* that any shared
    motif is present—much less the size or composition of it—so I’ll just look for
    any length of sequence that is present in every sequence. This is a challenging
    exercise that brings together many ideas I’ve shown in earlier chapters. I’ll
    use the solutions to explore algorithm design, functions, tests, and code organization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如[Rosalind LCSM挑战](https://oreil.ly/SONgC)中所述，此练习的目标是在给定的FASTA文件中找到所有序列共享的最长子字符串。在[第8章](ch08.html#ch08)中，我正在搜索一些序列中的给定基序。在这个挑战中，我不知道*先验*地存在任何共享的基序——更不用说它的大小或组成——所以我将只是寻找每个序列中存在的任何长度的序列。这是一个具有挑战性的练习，汇集了我在早期章节中展示的许多想法。我将使用解决方案来探索算法设计、函数、测试和代码组织。
- en: 'You will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习：
- en: How to use k-mers to find shared subsequences
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用K-mer查找共享子序列
- en: How to use `itertools.chain()` to concatenate lists of lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`itertools.chain()`连接列表的列表
- en: How and why to use a binary search
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及为什么使用二分搜索
- en: One way to maximize a function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化函数的一种方式
- en: How to use the `key` option with `min()` and `max()`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在`min()`和`max()`中使用`key`选项
- en: Getting Started
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'All the code and tests for this challenge are in the *10_lcsm* directory. Start
    by copying the first solution to the `lcsm.py` program and asking for help:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与此挑战相关的代码和测试都在*10_lcsm*目录中。首先将第一个解决方案复制到`lcsm.py`程序，并请求帮助：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The only required argument is a single positional file of FASTA-formatted DNA
    sequences. As with other programs that accept files, the program will reject invalid
    or unreadable input. The following is the first input I’ll use. The longest common
    subsequences in these sequences are *CA*, *TA*, and *AC*, with the last shown
    in bold in the output:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一必需的参数是一个FASTA格式的DNA序列单文件。与接受文件的其他程序一样，程序将拒绝无效或不可读的输入。以下是我将要使用的第一个输入。这些序列中的最长共同子序列是*CA*，*TA*和*AC*，最后一个在输出中以粗体显示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Any of these answers are acceptable. Run the program with the first test input
    and see that it randomly selects one of the acceptable 2-mers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些答案中的任何一个都是可以接受的。使用第一个测试输入运行程序，看看它随机选择了一个可接受的2-mer：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The second test input is much larger, and you’ll notice that the program takes
    significantly longer to find the answer. On my laptop, it takes almost 40 seconds.
    In the solutions, I’ll show you a way to significantly decrease the runtime using
    a binary search:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试输入要大得多，您会注意到程序花费的时间明显更长。在我的笔记本电脑上，它几乎花了40秒。在解决方案中，我将展示一种使用二分搜索显著减少运行时间的方法：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although not a requirement of the challenge, I’ve included one input file that
    contains no shared subsequences for which the program should create a suitable
    response:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是挑战的要求，但我已经包含了一个输入文件，其中不包含任何程序应该创建合适响应的共享子序列：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start the `lcsm.py` program from scratch:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始运行`lcsm.py`程序：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define the arguments like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 定义参数如下：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-1)'
- en: The only input to this program is a FASTA-formatted file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的唯一输入是一个FASTA格式的文件。
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-2)'
- en: Define a single `file` argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个单一的`file`参数。
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-3)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-3)'
- en: Return the `Args` object containing the open filehandle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含打开文件句柄的`Args`对象。
- en: 'Then update the `main()` function to print the incoming filename:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新`main()`函数以打印传入的文件名：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Verify that you see the correct usage and that the program correctly prints
    the filename:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您看到正确的用法，并且程序正确地打印了文件名：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, your program should pass the first three tests. If you think
    you know how to complete the program, have at it. If you want a prod in the right
    direction, read on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的程序应该通过前三个测试。如果您认为自己知道如何完成程序，请继续。如果您想要一些正确方向的提示，请继续阅读。
- en: Finding the Shortest Sequence in a FASTA File
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在FASTA文件中找到最短的序列
- en: 'Reading a FASTA file should be familiar by now. I’ll use `Bio.SeqIO.parse()`
    as before. My first idea on this problem was to find shared k-mers while maximizing
    for `k`. The longest subsequence can be no longer than the shortest sequence in
    the file, so I decided to start with `k` equal to that. Finding the shortest sequence
    requires that I first scan through *all* the records. To review how to do this,
    the `Bio.SeqIO.parse()` function returns an iterator that gives me access to each
    FASTA record:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该已经熟悉了读取FASTA文件的方法。我将像之前一样使用`Bio.SeqIO.parse()`。我在解决这个问题时的第一个想法是找到共享的k-mer，同时最大化`k`。最长的子序列不能比文件中最短的序列更长，因此我决定从`k`等于最短的那个开始。找到最短的序列需要我首先扫描*所有*记录。要回顾如何做到这一点，`Bio.SeqIO.parse()`函数返回一个迭代器，让我可以访问每个FASTA记录：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I can use the `next()` function I first showed in [Chapter 4](ch04.html#ch04)
    to force the iterator to produce the next value, the type of which is `SeqRecord`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用在[第四章](ch04.html#ch04)中首次展示的`next()`函数来强制迭代器生成下一个值，其类型为`SeqRecord`：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In addition to the sequence itself, the FASTA record contains metadata such
    as the sequence ID, name, and such:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了序列本身，FASTA记录还包含元数据，如序列ID、名称等：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The read information is wrapped in a `Seq` object, which has many interesting
    and useful methods you can explore in the REPL using **`help(rec.seq)`**. I’m
    only interested in the raw sequence, so I can use the `str()` function to coerce
    it to a string:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 读取信息包装在`Seq`对象中，该对象具有许多有趣和有用的方法，您可以在REPL中使用**`help(rec.seq)`**来探索。我只对原始序列感兴趣，因此可以使用`str()`函数将其强制转换为字符串：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I need all the sequences in a list so that I can find the length of the shortest
    one. I can use a list comprehension to read the entire file into a list since
    I’ll be using these many times:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要将所有序列都存入列表中，以便可以找到最短序列的长度。由于我将多次使用它们，我可以使用列表推导式将整个文件读入列表：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-1)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-1)'
- en: Reopen the filehandle or the existing filehandle will continue from the second
    read.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开文件句柄，否则现有文件句柄将从第二次读取开始。
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-2)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-2)'
- en: Create a list, coercing each record’s sequence to a string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个列表，强制将每个记录的序列转换为字符串。
- en: Sequence files may hold millions of reads, and storing them in a list could
    easily exceed the available memory and crash your machine. (Ask me how I know.)
    The problem is that I need all the sequences in the next step to find the subsequence
    that is common to all of them. I have several *Makefile* targets that will use
    the `genseq.py` program in the *10_lcsm* directory to generate large FASTA inputs
    with a common motif for you to test. This program works adequately for the datasets
    provided by Rosalind.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 序列文件可能包含数百万个读取，并将它们存储在列表中可能会超出可用内存并导致机器崩溃。（问我为什么知道。）问题在于，我需要在下一步中找到所有这些序列中共同的子序列。我有几个*Makefile*目标，将使用*10_lcsm*目录中的`genseq.py`程序生成带有共同模体的大型FASTA输入，供您测试。该程序对Rosalind提供的数据集运行得很好。
- en: 'The same idea can be expressed using the `map()` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`map()`函数表达相同的想法：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To find the length of the shortest sequence, I need to find the lengths of
    all the sequences, which I can do using a list comprehension:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到最短序列的长度，我需要找到所有序列的长度，可以使用列表推导式来完成：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I prefer the shorter way to write this using a `map()`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用`map()`来写这个更短的方法：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Python has built-in `min()` and `max()` functions that will return the minimum
    or maximum value from a list:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置了`min()`和`max()`函数，可以从列表中返回最小值或最大值：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So the shortest sequence is equal to the minimum of the lengths:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最短序列等于长度的最小值：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Extracting K-mers from a Sequence
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从序列中提取K-mer
- en: 'The longest shared subsequence can be no longer than the shortest sequence
    and must be shared by all the reads. Therefore, my next step is to find all the
    k-mers in all the sequences, starting with `k` equal to the length of the shortest
    sequence (`5`). In [Chapter 9](ch09.html#ch09) I wrote a `find_kmers()` function
    and test, so I’ll copy that code into this program. Remember to import `typing.List`
    for this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最长的共享子序列不可能长于最短序列，并且必须被所有读取共享。 因此，我的下一步是找出所有序列中的所有`k-mer`，从最短序列的长度（`5`）开始。 在[第9章](ch09.html#ch09)中，我编写了一个`find_kmers()`函数和测试，所以我会把那段代码复制到这个程序中。
    记得为此导入`typing.List`：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One logical approach is to start with the maximum possible value of `k` and
    count down, stopping when I find a k-mer shared by all the sequences. So far I’ve
    only used the `range()` function to count up. Can I reverse the start and stop
    values to count down? Apparently not. If the start value is greater than the stop
    value, then `range()` will produce an empty list:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合乎逻辑的方法是从`k`的最大可能值开始，递减计数，直到找到所有序列共享的`k-mer`。 到目前为止，我只使用`range()`函数递增计数。 我可以反转起始和停止值来逆向计数吗？
    显然不行。 如果起始值大于停止值，则`range()`将生成一个空列表：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When reading codons in [Chapter 7](ch07.html#ch07), I mentioned that the `range()`
    function accepts up to three arguments, the last of which is the *step*, which
    I used there to jump three bases at a time. Here I need to use a step of `-1`
    to count down. Remember that the stop value is not included:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读[第7章](ch07.html#ch07)中的密码子时，我提到`range()`函数接受最多三个参数，最后一个是*步长*，我在那里用来每次跳三个碱基。
    这里我需要使用步长`-1`来倒数。 记住停止值不包括在内：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another way to count backward is to count up and reverse the results:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种逆向计数的方法是从头开始计数并反转结果：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Either way, I want to iterate over decreasing values of `k` until I find a
    k-mer that is shared by all the sequences. A sequence might contain multiple copies
    of the same k-mer, so it’s important to make the result unique by using the `set()`
    function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我都想反复迭代`k`的减少值，直到找到所有序列共享的`k-mer`。 一个序列可能包含多个相同的`k-mer`，因此使用`set()`函数将结果唯一化非常重要：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Can you see a way to use this idea to count all the k-mers for each value of
    `k`? Look for k-mers that have a frequency matching the number of sequences. If
    you find more than one, print any one of them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到如何使用这个想法来计算每个`k`值的所有`k-mer`吗？ 寻找频率与序列数匹配的`k-mer`。 如果找到多个，打印任意一个。
- en: Solutions
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: The two variations for this program use the same basic logic to find the longest
    shared subsequence. The first version proves to scale poorly as the input size
    increases because it uses a stepwise, linear approach to iterating over every
    possible `k`-length of sequence. The second version introduces a binary search
    to find a good starting value for `k` and then initiates a hill-climbing search
    to discover a maximum value for `k`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的两个变体使用相同的基本逻辑来查找最长的共享子序列。 第一个版本在输入规模增加时表现不佳，因为它使用逐步线性方法迭代每个可能的`k`长度的序列。
    第二个版本引入了二分搜索来找到一个好的`k`的起始值，然后启动一个爬坡搜索来发现`k`的最大值。
- en: 'Solution 1: Counting Frequencies of K-mers'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案1：计算K-mer的频率
- en: 'In the previous section, I got as far as finding all the k-mers in the sequences
    for values of `k`, starting with the shortest sequence and moving down to `1`.
    Here I’ll start with `k` equal to `5`, which was the length of the shortest sequence
    in the first FASTA file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我已经找到了所有序列中值为`k`的`k-mer`，从最短序列开始，然后降到`1`。 这里我将从`k`等于`5`开始，这是第一个FASTA文件中最短序列的长度：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I need a way to count how many times each k-mer appears across all the sequences.
    One approach is to use `collections.Counter()`, which I first showed in [Chapter 1](ch01.html#ch01):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要一种方法来计算每个`k-mer`在所有序列中出现的次数。 一种方法是使用`collections.Counter()`，我在[第1章](ch01.html#ch01)中首次展示了它：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I can iterate over each set of k-mers from the sequences and use the `Counter.update()`
    method to add them:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以遍历每个序列的`k-mer`集合，并使用`Counter.update()`方法将它们添加起来：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or I could concatenate the many lists of k-mers together into a single list
    using `itertools.chain()`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我可以使用`itertools.chain()`将许多`k-mer`列表连接成单个列表：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using this as the input for the `Counter()` produces the same collection, showing
    that each 5-mer is unique, occurring once each:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将此作为`Counter()`的输入会产生相同的集合，显示每个5-mer都是唯一的，每次出现一次：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Counter()` is a regular dictionary underneath, which means I have access
    to all the dictionary methods. I want to iterate through the keys and values as
    pairs using the `dict.items()` method to find where the count of the k-mers is
    equal to the number of sequences:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter()`在底层是一个常规字典，这意味着我可以访问所有字典方法。我想通过`dict.items()`方法迭代键和值作为一对，使用计数的k-mers等于序列数量：'
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When `k` is `5`, there are no candidate sequences, so I need to try with a
    smaller value. Since I know the right answer is `2`, I’ll rerun this code with
    `k=2` to produce this dictionary:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当`k`为`5`时，没有候选序列，因此我需要尝试较小的值。由于我知道正确的答案是`2`，所以我将使用`k=2`重新运行此代码以生成此字典：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'From this, I find three candidate 2-mers have a frequency of 3, which equals
    the number of sequences:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我找到了三个候选的2-mer，它们的频率为3，这等于序列的数量：
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It doesn’t matter which of the candidates I choose, so I’ll use the `random.choice()`
    function which returns one value from a list of choices:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不管我选择哪个候选者，我都会使用`random.choice()`函数，该函数从一个选择列表中返回一个值：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I like where this is going, so I’d like to put it into a function so I can
    test it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个方向，所以我想把它放到一个函数中，这样我就可以测试它：
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-1)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-1)'
- en: Find the number of sequences.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 找到序列的数量。
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-2)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-2)'
- en: Return the k-mers having a frequency equal to the number of sequences.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回频率等于序列数量的k-mers。
- en: 'This makes for a pretty readable `main()`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`main()`非常易读：
- en: '[PRE34]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-1)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-1)'
- en: Read all the sequences into a list.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有序列读入列表。
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-2)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-2)'
- en: Find the length of the shortest sequence.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最短序列的长度。
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-3)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-3)'
- en: Count down from the shortest sequence.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从最短序列倒数。
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-4)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-4)'
- en: Find all the common k-mers using this value of `k`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`k`值找到所有共同的k-mers。
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-5)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-5)'
- en: If any k-mers are found, print a random selection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到任何k-mers，则打印一个随机选择。
- en: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-6)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-6)'
- en: Exit the program using an exit value of `0` (no errors).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用退出值为`0`（无错误）退出程序。
- en: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-7)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-7)'
- en: If I make it to this point, inform the user there is no shared sequence.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我到达这一点，请通知用户没有共享的序列。
- en: 'In the preceding code, I’m again using the walrus operator (`:=`) I introduced
    in [Chapter 5](ch05.html#ch05) to first assign the result of calling `common_kmers()`
    to the variable `kmers` and then evaluate `kmers` for truthiness. Python will
    only enter the next block if `kmers` is truthy, meaning there were common k-mers
    found for this value of `k`. Before the addition of this language feature, I would
    have had to write the assignment and evaluation on two lines, like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我再次使用了我在[第五章](ch05.html#ch05)介绍的海象运算符（`:=`）来首先将调用`common_kmers()`的结果赋给变量`kmers`，然后评估`kmers`的真实性。如果`kmers`是真实的，即意味着找到了这个`k`值的共同k-mers，Python将只在下一个块中进入。在引入这种语言特性之前，我必须写两行赋值和评估，如下所示：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Solution 2: Speeding Things Up with a Binary Search'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：使用二分搜索加快速度
- en: As noted in the opening section of this chapter, this solution grows much slower
    as the size of the inputs increases. One way to track the progress of the program
    is to put a `print(k)` statement at the beginning of the `for` loop. Run this
    with the second input file, and you’ll see that it starts counting down from 1,000
    and doesn’t reach the correct value for `k` until it hits 78.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所述，随着输入大小的增加，该解决方案的增长速度会变得更慢。跟踪程序进度的一种方法是在`for`循环的开头放置一个`print(k)`语句。用第二个输入文件运行此命令，你会看到它从
    1,000 开始倒数，直到 k 达到 78 才达到正确的值。
- en: Counting backward by 1 is taking too long. If your friend asked you to guess
    a number between 1 and 1,000, you wouldn’t start at 1,000 and keep guessing 1
    less each time your friend said, “Too high.” It’s much faster (and better for
    your friendship) to guess 500. If your friend chose 453, they’d say “Too high,”
    so you’d be wise to choose 250. They’d reply, “Too low,” and you’d keep splitting
    the differences between your last high and low guesses until you found the right
    answer. This is a *binary search*, and it’s a great way to quickly find the location
    of a wanted value from a sorted list of values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向计数 1 太慢了。如果你的朋友让你猜一个介于 1 和 1,000 之间的数字，你不会从 1,000 开始，每次朋友说“太高”时就猜少 1。选择 500
    会更快（也更有利于你们的友谊）。如果你的朋友选择了 453，他们会说“太高”，所以你聪明地选择了 250。他们会回答“太低”，然后你继续在你最后一次高低猜测的中间值之间分割差值，直到找到正确答案。这就是*二分查找*，它是快速从排序值列表中查找所需值位置的绝佳方法。
- en: 'To understand this better, I’ve included a program in the *10_lcsm* directory
    called `binsearch.py`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我在 *10_lcsm* 目录中包含了一个名为`binsearch.py`的程序：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the relevant portion of the program. You can read the source
    code for the argument definitions if you like. The `binary_search()` function
    is recursive, like one solution to the Fibonacci sequence problem from [Chapter 4](ch04.html#ch04).
    Note that the search values must be sorted for binary searches to work, which
    the `range()` function provides:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序的相关部分。如果你愿意，可以阅读参数定义的源代码。`binary_search()`函数是递归的，就像[第四章](ch04.html#ch04)中对斐波那契数列问题的一种解决方案一样。请注意，为了使二分查找起作用，搜索值必须是排序的，`range()`函数提供了这个功能：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-1)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-1)'
- en: The base case to exit the recursion is when this is false.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 退出递归的基本情况是当此条件为假时。
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-2)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-2)'
- en: The midpoint is halfway between `high` and `low`, using floor division.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 中点是`high`和`low`之间的中间值，使用地板除法。
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-3)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-3)'
- en: Return the midpoint if the element is in the middle.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素在中间，则返回中点。
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-4)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-4)'
- en: See if the value at the midpoint is greater than the desired value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看看中点的值是否大于所需值。
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-5)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-5)'
- en: Search the lower values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索较低的值。
- en: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-6)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-6)'
- en: Search the higher values.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索较高的值。
- en: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-7)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-7)'
- en: The value was not found.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 未找到该值。
- en: The names `x` and `xs` in the `binary_search()` function are meant to be singular
    and plural. In my head, I pronounce them *ex* and *exes*. This kind of notation
    is common in purely functional programming because I’m not trying to describe
    what kind of value `x` is. It could be a string or a number or anything. The important
    point is that `xs` is some collection of comparable values all of the same type.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_search()`函数中的`x`和`xs`名称意为单数和复数。在我的脑海中，我将它们发音为*ex*和*exes*。这种符号在纯函数式编程中很常见，因为我不试图描述`x`是什么类型的值。它可以是字符串、数字或其他任何类型的值。重要的是`xs`是某种类型的全部可比较值的集合。'
- en: 'I included some `print()` statements so that, running with the previous numbers,
    you can see how `low` and `high` finally converge on the target number in 10 steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我加入了一些`print()`语句，这样，使用前面的数字运行，您可以看到`low`和`high`在10步中最终收敛到目标数字：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It takes just eight iterations to determine the number is not present:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 只需八次迭代即可确定数字不存在：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The binary search can tell me if a value occurs in a list of values, but this
    is not quite my problem. While I’m reasonably sure there will be at least a 2-
    or 1-mer in common in most datasets, I have included one file that has none:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索可以告诉我值是否存在于值列表中，但这并不是我的问题。虽然我相当确定大多数数据集中至少会有一个2-mer或1-mer的共同点，但我包含了一个没有这种共同点的文件：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If there is an acceptable value for `k`, then I need to find the *maximum*
    value. I decided to use the binary search to find a starting point for a hill-climbing
    search to find the maximum value. First I’ll show `main()`, and then I’ll break
    down the other functions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个可接受的`k`值，那么我需要找到*最大*值。我决定使用二分搜索来找到一个起始点，以进行寻找最大值的爬坡搜索。首先我会展示`main()`，然后我会分解其他函数：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-1)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-1)'
- en: Get a list of the sequences as strings.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列列表作为字符串获取。
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-2)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-2)'
- en: Find the length of the shortest sequence.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最短序列的长度。
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-3)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-3)'
- en: Partially apply the `common_kmers()` function with the `seqs` input.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用`common_kmers()`函数与`seqs`输入。
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-4)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-4)'
- en: Use the binary search to find a starting point for the given function, using
    `1` for the lowest value of `k` and the shortest sequence length for the maximum.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二分搜索找到给定函数的起始点，使用`1`作为`k`的最小值，使用最短序列长度为最大值。
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-5)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-5)'
- en: Check that the binary search found something useful.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 检查二分搜索是否找到了有用的东西。
- en: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-6)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-6)'
- en: Initialize a list of the candidate values.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化候选值列表。
- en: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-7)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-7)'
- en: Start the hill climbing with the binary search result.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以二分搜索结果开始爬坡搜索。
- en: '[![8](assets/8.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-8)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-8)'
- en: Check if there are common k-mers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否存在共同的k-mer。
- en: '[![9](assets/9.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-9)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-9)'
- en: If so, randomly add one to the list of candidates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，随机向候选列表添加一个。
- en: '[![10](assets/10.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-10)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-10)'
- en: If there are no common k-mers, break out of the loop.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有共同的 k-mer，则退出循环。
- en: '[![11](assets/11.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-11)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-11)'
- en: Choose the candidate sequence having the longest length.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 选择具有最长长度的候选序列。
- en: '[![12](assets/12.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-12)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-12)'
- en: Let the user know that there is no answer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉用户没有答案。
- en: 'While there are many things to explain in the preceding code, I want to highlight
    the call to `max()`. I showed earlier that this function will return the maximum
    value from a list. Normally you might think to use this on a list of numbers:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在上述代码中有许多要解释的事情，但我想强调对`max()`的调用。我之前展示了该函数将从列表中返回最大值。通常您可能会考虑在数字列表上使用它：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code, I want to find the longest string in a list. I can `map()`
    the `len()` function to find their lengths:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我想在列表中找到最长的字符串。我可以使用`map()`函数映射`len()`函数来找到它们的长度：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This shows that the third sequence, *GGGG*, is the longest. The `max()` function
    accepts an optional `key` argument, which is a function to apply to each element
    before comparing. If I use the `len()` function, then `max()` correctly identifies
    the longest sequence:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明第三个序列*GGGG*是最长的。`max()`函数接受一个可选的`key`参数，该参数是在比较之前应用于每个元素的函数。如果我使用`len()`函数，那么`max()`可以正确地识别出最长的序列：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s take a look at how I modified the `binary_search()` function to suit
    my needs:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我如何修改`binary_search()`函数以适应我的需求：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-1)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-1)'
- en: The function takes another function `f()` along with `low` and `high` values
    as arguments. In this instance, the function `f()` will return the common k-mers,
    but the function can perform any calculation you like.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受另一个函数`f()`以及`low`和`high`值作为参数。在这个例子中，函数`f()`将返回共同的 k-mer，但该函数可以执行任何您想要的计算。
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-2)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-2)'
- en: Call the function `f()` with the highest and lowest values for `k`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最高和最低的`k`值调用函数`f()`。
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-3)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-3)'
- en: Find the midpoint value of `k`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`k`的中点值。
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-4)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-4)'
- en: If the function `f()` found common k-mers for both the high and low `k` values,
    return the highest k.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数`f()`对高`k`和低`k`值都找到了共同的 k-mer，则返回最高的 k。
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-5)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-5)'
- en: If the high `k` found no k-mers but the low value did, recursively call the
    function searching in the lower values of `k`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果高`k`找不到 k-mer，但低值找到了，则递归调用函数，在更低的`k`值中搜索。
- en: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-6)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-6)'
- en: If the low `k` found no k-mers but the high value did, recursively call the
    function searching in the higher values of `k`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果低`k`找不到 k-mer，但高值找到了，则递归调用函数，在更高的`k`值中搜索。
- en: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-7)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-7)'
- en: Return `-1` to indicate no k-mers were found using the `high` and `low` arguments
    to `f()`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`-1`以指示使用`high`和`low`参数调用`f()`时未找到 k-mer。
- en: 'Here is the test I wrote for this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '这是我为此编写的测试： '
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-1)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-1)'
- en: These are the sequences I’ve been using that have three shared 2-mers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我一直在使用的具有三个共享2-mer的序列。
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-2)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-2)'
- en: Define a function to find the k-mers in the first set of sequences.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数来找到第一组序列中的k-mers。
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-3)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-3)'
- en: The search finds a `k` of `2` which is the right answer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索找到`k`为`2`是正确答案。
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-4)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-4)'
- en: The same sequences as before but now with a shared 3-mer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前相同的序列，但现在共享3-mer。
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-5)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-5)'
- en: The search finds a `k` of `3`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索找到`k`为`3`。
- en: 'Unlike the previous binary search, my version won’t (necessarily) return the
    *exact* answer, just a decent starting point. If there are no shared sequences
    for any size `k`, then I let the user know:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的二分搜索不同，我的版本不一定会返回*精确*答案，只是一个不错的起点。如果没有任何大小为`k`的共享序列，则我会告知用户：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If there is a shared subsequence, this version runs significantly faster—perhaps
    as much as 28 times faster:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有共享子序列，则此版本运行速度显著提高，可能快28倍：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When I was searching from the maximum `k` value and iterating down, I was performing
    a *linear* search through all the possible values. This means the time to search
    grows in proportion (linearly) to the number *n* of values. A binary search, by
    contrast, grows at a rate of log *n*. It’s common to talk about the runtime growth
    of algorithms using *Big O* notation, so you might see binary search described
    as O(log *n*), whereas linear searching is O(*n*)—which is much worse.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我从最大的`k`值开始搜索并向下迭代时，我正在执行对所有可能值的*线性*搜索。这意味着搜索时间与值的数量*n*成比例增长（线性增长）。相比之下，二分搜索的增长率是对数*log
    n*。通常用*大O*表示法来讨论算法的运行时增长，因此您可能会看到二分搜索描述为O(log *n*)，而线性搜索是O(*n*)，这要糟糕得多。
- en: Going Further
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更进一步
- en: As with the suggestion in [Chapter 9](ch09.html#ch09), add a Hamming distance
    option that will allow for the indicated number of differences when deciding on
    a shared k-mer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第9章](ch09.html#ch09)中的建议一样，添加一个汉明距离选项，可以在决定共享k-mer时允许指定数量的差异。
- en: Review
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键点：
- en: K-mers can be used to find conserved regions of sequences.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K-mer可以用来找到序列的保守区域。
- en: Lists of lists can be combined into a single list using `itertools.chain()`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的列表可以使用`itertools.chain()`组合成单个列表。
- en: A binary search can be used on sorted values to find a value more quickly than
    searching through the list linearly.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在排序值上使用二分搜索来比线性搜索更快地找到值。
- en: Hill climbing is one way to maximize the input to a function.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爬山法是最大化函数输入的一种方式。
- en: The `key` option for `min()` and `max()` is a function that is applied to the
    values before comparing them.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min()`和`max()`的`key`选项是在比较之前应用于值的函数。'
