- en: 4 Introducing continuous deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 引入持续部署
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Differentiating between delivery and deployment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分交付和部署
- en: Delivering an application to an artifact repository
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序交付到工件存储库
- en: Deploying an application to a hosted service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到托管服务
- en: Using health checks to verify your application is running
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用健康检查来验证应用程序正在运行
- en: You get to work early. After dropping your stuff off at your desk, you migrate
    to the coffee machine. As you arrive, you see a group of operations people talking.
    You’d like to say this is a coincidence, but it’s not. You know that the operations
    team gets in early and that this is the best time to talk to them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你很早就开始工作。在你把东西放在桌子上后，你走到咖啡机那里。当你到达那里时，你看到一群运维人员正在交谈。你可能会说这是巧合，但事实并非如此。你知道运维团队很早就到岗，而且这是和他们交谈的最佳时机。
- en: 'Greeting them, you casually mention the demo you have been working on. Someone
    groans: “I can’t see how they can expect us to keep doing this. We just don’t
    have the resources to keep funding and running these little projects. We have
    a backlog of work to be done: new projects, deployments, system upgrades, and
    performance tuning. On top of that, we are constantly being pulled off because
    of emergencies. I’m not blaming you, but it’s just a nightmare sometimes.”'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 问候他们后，你随意提到了你一直在做的演示。有人叹了口气：“我实在看不出他们怎么能期望我们一直这样做。我们根本就没有资源来持续资助和运行这些小项目。我们有一堆工作要做：新项目、部署、系统升级和性能调整。更不用说，我们经常因为紧急情况而被抽调。我并不是在责怪你，但有时候这确实是一场噩梦。”
- en: It is a nightmare sometimes. You remember completing a feature just a couple
    of months ago and waiting for it to be deployed. It took over a week for the scheduled
    release, and the deployment failed because someone else’s configuration change
    broke the system. What transpired was a whole-day event with people going through
    all of the changes trying to figure out what broke. The gap between creating the
    code and the deployment of it was too great and caused so many problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候这确实是一场噩梦。你还记得几个月前完成了一个功能，然后等待它被部署。计划发布花了超过一周的时间，部署失败是因为别人的配置更改破坏了系统。发生的事情是一整天的事件，人们都在检查所有的更改，试图找出什么出了问题。从创建代码到部署之间的差距太大，导致了太多问题。
- en: “What I’d like to do is have developers own more of the deployment piece. We
    set up the process and approved services and they own the deployments themselves.
    We would help update and maintain the machines while they focus on the deployments
    and problems surrounding them. If we could use some of these new services that
    don’t require us to maintain a server, it would be ideal. But honestly, I don’t
    know what this model would look like and if anyone would go for it. In the long
    run, it would save us money and time.”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “我希望开发者能更多地拥有部署的部分。我们设置了流程和批准了服务，他们自己负责部署。在他们专注于部署和周围的问题时，我们会帮助他们更新和维护机器。如果我们能使用一些不需要我们维护服务器的新的服务，那就太理想了。但说实话，我不知道这个模式会是什么样子，也不知道是否有人会接受它。从长远来看，这将节省我们的时间和金钱。”
- en: That’s exactly what you were hoping someone would say. Give the power to the
    developer. Run the service without the server overhead. Iterate quickly and deliver
    often. You mention that you could include it as part of your demo.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是你希望有人会说的。赋予开发者权力。在没有服务器开销的情况下运行服务。快速迭代并经常交付。你提到你可以将其作为你的演示的一部分。
- en: “Really?” the operations person says, “You’d add that scope to your project
    for us? That would be great, and I’d love to hear about what you find and what
    options we could have.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “真的吗？”运维人员说，“你会在你的项目中加入这个范围为我们做？那太好了，我很乐意听听你发现的情况以及我们可能有的选择。”
- en: Taking this as permission, you pour your coffee and head back to your desk.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将此视为许可，你倒好咖啡，回到你的桌子旁。
- en: 4.1 Delivery
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 交付
- en: The first thing you realize is that you want to get this into the hands of other
    people eventually. Yesterday it was the QA team who were interested, and tomorrow
    it may be the entire development team. You need to put the compiled product out
    there for others to easily consume. You need to deliver.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先意识到的是，你最终希望把这件事交给其他人。昨天是QA团队感兴趣，明天可能是整个开发团队。你需要把编译好的产品发布出去，让其他人容易消费。你需要交付。
- en: NOTE See chapter 2 for a list of pipeline tools to use like Jenkins, GitLab,
    and CircleCI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关使用Jenkins、GitLab和CircleCI等工具的管道工具列表，请参阅第2章。
- en: To do this, we can attach a binary to our pipeline, just like we did with the
    code coverage report in the last chapter. Let’s open up our `pipeline.yml` file
    and add the code in the following listing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以将二进制文件附加到我们的管道中，就像我们在上一章中处理代码覆盖率报告时做的那样。让我们打开我们的`pipeline.yml`文件，并添加以下列表中的代码。
- en: Listing 4.1 `pipeline.yml`
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 `pipeline.yml`
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates a new step in our pipeline called deliver
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在我们的管道中创建一个新的步骤，称为交付
- en: ❷ Downloads the binary from our build step
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从我们的构建步骤下载二进制文件
- en: ❸ GitHub Actions provides an internal token for authorization to update your
    repository.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ GitHub Actions提供了一个内部令牌用于授权更新你的仓库。
- en: ❹ Tags the release using the changed reference that triggered the build. Now
    it is just changing to the main branch that will be used later for other deployment
    triggers. This is a property that is passed to us from the GitHub Action environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用触发构建的更改引用标记发布。现在它只是切换到稍后用于其他部署触发的主分支。这是一个从GitHub Action环境传递给我们的属性。
- en: ❺ Names the release using the same mechanism as in the previous step
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用与上一步相同的机制命名发布
- en: ❻ This is not a finalized release, so we mark it as a draft so that it is not
    viewable by customers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 这不是一个最终发布版本，因此我们将其标记为草稿，以便客户无法查看。
- en: ❼ Similarly, we aren’t finalized, so we mark this as a pre-release.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 类似地，我们还没有完成，所以我们将这个标记为预发布。
- en: ❽ Uploads the binary file to the release URL created in a previous step
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将二进制文件上传到之前步骤中创建的发布URL
- en: ❾ The content type is a binary, so we need to define this as an octet stream
    so that it can be recognized by GitHub.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 内容类型是二进制，因此我们需要将其定义为八位字节流，以便GitHub能够识别。
- en: We can now push our change to our pipeline and watch it run. Once complete,
    you should see a new release on the Releases tab on your repository, as shown
    in figure 4.1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将我们的更改推送到我们的管道并观察其运行。一旦完成，你应该能在你的仓库的“发布”标签页上看到一个新的发布版本，如图4.1所示。
- en: '![](../../OEBPS/Images/CH04_F01_Holmes4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F01_Holmes4.png)'
- en: Figure 4.1 The page contains all the information we need right now, along with
    a downloadable binary.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 该页面包含我们现在需要的所有信息，以及一个可下载的二进制文件。
- en: There you have it! You are delivering a product right away, but this isn’t the
    end of our pipeline. The reason we are focused on just publishing our product
    is that it is the simplest form of *delivery*—providing a product for someone
    to use, but that doesn’t necessarily mean deployment, which is making the product
    run. *Deployment* is the final step in a process in which you run and use your
    product as a service. Not all products get deployed, but all should be delivered.
    A library is a common product that is not deployed but delivered. Deployments
    can also get complicated (as we will see) based on their run location. Building
    and running new servers or software upgrades are additional forms of deployment.
    In this chapter, we will tackle both.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是了！你正在立即交付产品，但这并不是我们管道的终点。我们之所以只关注发布我们的产品，是因为它是*交付*的最简单形式——为某人提供一个可用的产品，但这并不一定意味着部署，即让产品运行。*部署*是在一个过程中运行的最终步骤，在这个过程中，你将你的产品作为服务运行和使用。并非所有产品都需要部署，但所有产品都应该交付。库是一个常见的未部署但已交付的产品。根据其运行位置，部署也可能变得复杂（正如我们将看到的）。构建和运行新的服务器或软件升级也是部署的额外形式。在本章中，我们将探讨这两种形式。
- en: The only way to know if a product is viable in a marketplace is to get it out
    there. Once people start using your product, you receive feedback on what they
    want, what they like, and what they don’t like. This feedback drives the development
    of your product. Thus far, we’ve written what is known as a *minimal viable product*,
    or MVP. Though our example is simple, you should be able to see that what you
    first write doesn’t need to be perfect. In fact, it will never be perfect. Many
    companies wait too long to get feedback on what they are building because they
    don’t put themselves out there fast enough.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道一个产品在市场上是否可行，唯一的方法是将它推向市场。一旦人们开始使用你的产品，你将收到关于他们想要什么、喜欢什么以及不喜欢什么的反馈。这种反馈推动了你产品的开发。到目前为止，我们已经编写了所谓的*最小可行产品*，或MVP。尽管我们的例子很简单，但你应该能够看出你最初写下的东西不需要完美。事实上，它永远不会完美。许多公司因为不够快地将自己推向市场，而等待太长时间才收到关于他们正在构建的产品的反馈。
- en: Feedback can be in the form of a single person who has a vision, a group of
    pilot users, investors, or the general public. Getting your product out isn’t
    the only thing you need to worry about. You must also focus on how fast you can
    get your product released. This is what we’ve been building toward. Our pipeline
    will help transform our code into a product and release it. It is this last step
    that we still need to finish, but once we have done so, we can start iterating
    on our process to make a better product.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈可以来自有远见的人、一组试点用户、投资者或公众。推出你的产品不是你需要担心唯一的事情。你还必须关注你能够多快推出你的产品。这正是我们一直在努力的方向。我们的流程将帮助我们转换代码成为产品并发布。正是这一最后一步我们还需要完成，但一旦我们完成了，我们就可以开始迭代我们的流程，以制造更好的产品。
- en: It might seem strange that we are already releasing something this early in
    the book, but this is the essence of what we are trying to do. Like our product,
    our pipeline will never be perfect. You and your team need to revise and enhance
    your pipeline just as you do your product. Manufacturers go through a similar
    process of not only creating and enhancing the products they make but also increasing
    the efficiency with which they produce them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这个阶段就发布内容可能看起来有些奇怪，但这正是我们试图做的事情的本质。就像我们的产品一样，我们的流程永远不会完美。你和你的团队需要像对待产品一样修订和增强你的流程。制造商不仅经历了一个创建和增强他们制造的产品的过程，而且还提高了他们生产这些产品的效率。
- en: 4.2 Developers as operators
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 开发者作为操作者
- en: To some of you, this process may seem odd. Why am I doing the deployment when
    I have an entire operations team to handle it? This is a good question. Many companies
    will structure their teams to be focused on particular areas in which they are
    specialists. While this allows individuals to focus on being experts in specific
    areas, it often puts up barriers between teams. This can put teams at odds with
    one another and prevent positive collaboration. The collaboration breaks down
    because it becomes easier to play a blame game instead of taking the time to understand
    the problems and working together toward a solution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些人来说，这个过程可能看起来很奇怪。我为什么要在有整个运营团队来处理的情况下进行部署？这是一个好问题。许多公司会组织他们的团队专注于他们擅长的特定领域。虽然这允许个人专注于成为特定领域的专家，但它往往在团队之间设置障碍。这可能导致团队之间产生矛盾，阻碍积极的协作。协作破裂，因为指责游戏变得更容易，而不是花时间去理解问题和共同努力寻找解决方案。
- en: 'Take the following scenario: A tester finds a bug with an incorrect date on
    a report and files a ticket assigned to a developer. The developer looks at the
    bug and writes, “This works fine on my machine; the server must not be configured
    for the correct time zone” and attaches a screenshot. The ticket then gets punted
    to the operations team, and they just reassign the ticket with the comment “Server
    is configured properly; will not complete.” There the ticket sits for weeks while
    everyone thinks it isn’t their problem.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下场景为例：一个测试人员发现报告上日期错误的一个bug，并向分配给开发者的工单提交了问题。开发者查看bug后写道，“在我的机器上这没问题；服务器可能没有配置正确的时间区域”并附上了一张截图。然后工单被踢给了运营团队，他们只是重新分配了工单并评论道，“服务器已正确配置；不会完成。”工单就这样在那里待了数周，而每个人都认为这不是他们的问题。
- en: Who is the victim here? QA? Developers? Operations? Wrong. It’s the customer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 受害者是谁？质量保证？开发者？运营？错误。是客户。
- en: When we don’t work as a team, we don’t understand each other’s roles. When we
    don’t understand each other’s roles, we don’t think of solutions that can help
    them and ultimately the customer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不作为一个团队工作时，我们不理解彼此的角色。当我们不理解彼此的角色时，我们不会考虑可以帮助他们和最终客户的解决方案。
- en: In the early days of NASA’s space program, there was a realization that mission
    control was having problems troubleshooting and understanding the technologies
    they were developing and using. This was all new to everyone because no one had
    been in space at that time. Gene Kranz, then a procedures officer (he later became
    the flight director during Apollo 13), realized there was a disconnect and that
    engineers needed to become operators. Engineers built the systems; they understood
    them technically but never actually used them as part of a larger system. Operators,
    on the other hand, did not need to understand the inner workings of the device;
    they just needed to know how to make it run and what problems it could create.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在NASA太空计划初期，人们意识到任务控制中心在故障排除和理解他们开发和使用的科技方面遇到了问题。对每个人来说这都是全新的，因为那时没有人进入过太空。Gene
    Kranz，当时是程序官员（他后来在阿波罗13号任务中成为了飞行指挥官），意识到存在脱节，工程师需要成为操作员。工程师构建了系统；他们在技术上理解它们，但从未真正将它们作为更大系统的一部分来使用。另一方面，操作员不需要理解设备的内部工作原理；他们只需要知道如何让它运行以及它可能造成的问题。
- en: Today we can look at the same process as asking our software engineers to become
    operators. This is known as DevOps, which combines software development and IT
    operations. As Gene Kranz found during the early days of NASA, systems can become
    complicated very quickly, and there is a loss of knowledge between each line of
    communication. In space missions, if someone didn’t know what caused a blinking
    red light, the results could have been catastrophic.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们可以看看与要求我们的软件工程师成为操作员相同的过程。这被称为DevOps，它结合了软件开发和IT运维。正如Gene Kranz在NASA早期发现的那样，系统可以迅速变得复杂，并且在每条通信线路之间都会出现知识流失。在太空任务中，如果有人不知道闪烁的红色灯光是由什么引起的，结果可能是灾难性的。
- en: DevOps has taken over the industry in so many ways, but often it becomes a misnomer
    and ends up being operations. Real DevOps comes when a developer has the opportunity
    to deploy and manage products in production, while operations teams can make changes
    to code for either deployments or problems with the product. It’s a portmanteau
    for a reason. The teams become blended. In fact, if I had it my way, I would call
    it DevOpQas and include the testing as part of all of this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps以多种方式接管了行业，但往往它变成了一个误称，最终变成了运维。真正的DevOps发生在开发者有机会在生产环境中部署和管理产品，而运维团队能够对代码进行更改，无论是为了部署还是解决产品问题。这有一个原因。团队变得融合在一起。事实上，如果由我来决定，我会称之为DevOpQas，并将测试作为所有这些的一部分。
- en: We have already done some DevOps work in our project, but I find that it’s good
    to take a quick aside to tell you why it is important. As a developer, you can
    have insight into how your code works; as an operations member, you have insight
    into how it should run. There will be operations members who have a better understanding
    of how a project should be deployed, and they can guide you through the solution
    or provide examples or modules for you to use. There will be developers who will
    be able to help enhance and build deployments and pipelines to make their products
    run efficiently.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的项目中已经做了一些DevOps工作，但我发现简要地告诉你为什么这很重要是件好事。作为一名开发者，你可以了解你的代码是如何工作的；作为一名运维人员，你可以了解它应该如何运行。将会有一些运维人员对如何部署项目有更好的理解，他们可以指导你通过解决方案，或者为你提供示例或模块供你使用。将会有一些开发者能够帮助增强和构建部署和管道，使他们的产品运行更高效。
- en: To build effective products, you need to find a way to work as a team. Understanding
    is the key to success, and that success will make your customers happy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建有效的产品，你需要找到一种团队合作的方式。理解是成功的关键，而成功将使你的客户满意。
- en: 4.3 Setting up a deployment account
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 设置部署账户
- en: A notification appears in your email. It reads, “Thanks for looking into deploying
    your project on your own. I have elevated your account on our Google Cloud account
    for you to experiment with. For your demo, I would suggest looking into some of
    their ‘as a service’ products. Try a few out and let me know what you think. We
    can talk later.”
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电子邮件中出现了一条通知。内容是：“感谢你自行考虑部署你的项目。我已经提升了你在我们Google Cloud账户中的账户权限，以便你可以进行实验。为了你的演示，我建议查看他们的一些‘作为服务’产品。尝试几个，并告诉我你的想法。我们可以稍后再谈。”
- en: Great! You now have the power to deploy things in production. Use this power
    wisely!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你现在有了在生产环境中部署事物的能力。明智地使用这种力量！
- en: This is exciting because you’ve been reading up on various products and ways
    of deploying them. However, before you can get started, you need to create an
    account and set up a deployment key. To create the account, we will need to navigate
    to [https://cloud.google.com/free](https://cloud.google.com/free). Click on Get
    Started for the link. After your account is set up, we will create a deployment
    key by using a service account.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这很令人兴奋，因为您一直在研究各种产品和部署它们的方式。然而，在您开始之前，您需要创建一个帐户并设置部署密钥。要创建帐户，我们需要导航到[https://cloud.google.com/free](https://cloud.google.com/free)。点击链接的“开始使用”。在您的帐户设置完成后，我们将通过使用服务帐户创建部署密钥。
- en: NOTE We will use Google’s Cloud Platform (GCP) for all of the deployments we
    do here. GCP offers a great free tier that allots a credit for their products,
    and many of their products run for free under a specific load. We can use GCP
    to develop and deploy our product without incurring any upfront costs. The principles
    we adopt here are easily transferable to other platforms such as Amazon Web Services
    (AWS) and Microsoft Azure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在所有部署中使用谷歌的云平台（GCP）。GCP提供了一个很好的免费层，为他们的产品分配了信用额度，并且许多产品在特定负载下运行免费。我们可以使用GCP来开发和部署我们的产品，而无需承担任何前期成本。我们在这里采用的原则很容易转移到其他平台，如亚马逊网络服务（AWS）和微软Azure。
- en: To do this, go to the right-hand hamburger menu, find APIs & Services, and select
    Credentials, as shown in figure 4.2.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请转到右侧的汉堡菜单，找到API与服务，然后选择凭据，如图4.2所示。
- en: '![](../../OEBPS/Images/CH04_F02_Holmes4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F02_Holmes4.png)'
- en: Figure 4.2 Find the Credentials page.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 查找凭据页面。
- en: Once on this page, click the Create Credentials button at the top, and select
    Service Account.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入此页面，请点击顶部的创建凭据按钮，并选择服务帐户。
- en: NOTE A service account is extremely important to have whenever you are building
    a product on an external system. Your account houses things like credit cards
    and other personal identifying information and typically has full access to the
    full range of products on a given platform. It is also locked with specific permissions
    and privileges that will not compromise your account if for some reason a person
    outside of your organization gains access to it. The service account setup will
    look like figure 4.3.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在您在外部系统上构建产品时，拥有服务帐户非常重要。您的帐户包含诸如信用卡和其他个人识别信息等东西，并且通常具有对给定平台上所有产品的完全访问权限。它还锁定了特定的权限和特权，如果由于某种原因组织外的人获得了访问权限，它也不会损害您的帐户。服务帐户设置将类似于图4.3。
- en: '![](../../OEBPS/Images/CH04_F03_Holmes4.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F03_Holmes4.png)'
- en: Figure 4.3 Create a new service account.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 创建新的服务帐户。
- en: Here, you will choose a name that you feel is appropriate. You should create
    a service account for a specific product you are building or a specific service
    you are utilizing. In this case, we will focus on the product itself and call
    it hello-api.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将选择一个您认为合适的名称。您应该为正在构建的特定产品或正在使用的特定服务创建一个服务帐户。在这种情况下，我们将专注于产品本身，并将其命名为hello-api。
- en: 'Next, we will be prompted to select specific roles for a service account. We
    will add additional permissions in the future, but for now, use the search prompt
    that appears to select the following roles:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将被提示为服务帐户选择特定的角色。我们将在未来添加额外的权限，但到目前为止，请使用出现的搜索提示来选择以下角色：
- en: '*App Engine admin*—Provides administrator functions for App Engine, such as
    deleting and calling endpoints'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用引擎管理员*—为应用引擎提供管理功能，例如删除和调用端点'
- en: '*App Engine deployer*—Permits deployment of App Engine applications'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用引擎部署者*—允许部署应用引擎应用程序'
- en: '*Cloud build editor*—Allows the user to edit cloud functions'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云构建编辑器*—允许用户编辑云函数'
- en: '*Cloud functions admin*—Allows the user to create and destroy cloud functions'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云函数管理员*—允许用户创建和销毁云函数'
- en: '*Cloud functions developer*—Allows the creation and editing of cloud functions'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云函数开发者*—允许创建和编辑云函数'
- en: '*Storage admin*—Allows files to be stored'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储管理员*—允许存储文件'
- en: Select products from figure 4.4.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从图4.4中选择产品。
- en: '![](../../OEBPS/Images/CH04_F04_Holmes4.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F04_Holmes4.png)'
- en: Figure 4.4 Each product will be used for different permissions for different
    products.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 每个产品将用于不同产品的不同权限。
- en: Once all of these are selected, click Continue, and then click Done. Click on
    your newly created user, and then select Keys at the top.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了所有这些，请点击继续，然后点击完成。点击您刚创建的用户，然后在上部选择密钥。
- en: Click Add Key → Create New Key, select JSON, and download the file. This is
    a credentials file that we can then add to our GitHub account as a secret for
    deployments. Keep it safe somewhere. Figure 4.5 shows an example key setup.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加密钥”→“创建新密钥”，选择JSON，并下载文件。这是一个凭证文件，我们可以将其添加到我们的GitHub账户中作为部署的密钥。请将其保存在安全的地方。图4.5展示了示例密钥设置。
- en: '![](../../OEBPS/Images/CH04_F05_Holmes4.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F05_Holmes4.png)'
- en: Figure 4.5 Create a new key for deployment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 为部署创建新密钥。
- en: In the meantime, open a tab, navigate to your GitHub repository, and select
    Settings → Secrets. There, create a new secret called GCP_CREDENTIALS. Add the
    contents of your JSON file to this and save it. Now we can add our function to
    the pipeline as shown in figure 4.6.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，打开一个标签页，导航到您的GitHub仓库，并选择设置→密钥。在那里，创建一个名为GCP_CREDENTIALS的新密钥。将JSON文件的内容添加到其中并保存。现在我们可以将我们的函数添加到管道中，如图4.6所示。
- en: '![](../../OEBPS/Images/CH04_F06_Holmes4.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F06_Holmes4.png)'
- en: Figure 4.6 Add the contents of the key to a secret in GitHub.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 将密钥内容添加到GitHub中的密钥。
- en: Now we are ready to create a deployment for any product we want to run our application.
    But which do we choose?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好为任何我们想要运行应用程序的产品创建部署。但我们该选择哪一个呢？
- en: 4.4 As you like it
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 如你所愿
- en: Gone are the days when most of us worried about setting up a physical server.
    AWS launched its compute platform in 2006, and it revolutionized how companies
    run and maintain their servers. Servers were then virtualized and controlled by
    a set of unique API commands that allowed for the easy creation and destruction
    of server instances and provided a great abstraction, known as Infrastructure
    as a Service (IaaS), for developers to work with. The following year, in 2007,
    a company called Heroku made the job even easier for developers to get their products
    deployed. They created what is known as Platform as a Service (PaaS). This platform
    provided abstractions that allowed developers to quickly create and iterate on
    their applications. Between these two companies, we have seen a revolution in
    serverless applications and cloud computing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那些我们大多数人为设置物理服务器而担忧的日子已经过去了。AWS在2006年推出了其计算平台，并彻底改变了公司运行和维护服务器的方式。服务器随后被虚拟化，并由一组独特的API命令控制，这些命令允许轻松创建和销毁服务器实例，并为开发者提供了一个称为基础设施即服务（IaaS）的伟大抽象，使他们能够工作。第二年，即2007年，一家名为Heroku的公司使开发者部署产品的工作变得更加容易。他们创造了被称为平台即服务（PaaS）的平台。这个平台提供了允许开发者快速创建和迭代应用程序的抽象。在这两家公司之间，我们见证了无服务器应用程序和云计算的革命。
- en: Today, other products are labeled “as a service.” Each service provides a different
    layer of abstraction to a developer as it is needed. Abstractions are helpful
    because they hide certain details about the underlying system from the user. This
    abstraction comes at two costs. First is the financial cost of using the abstraction
    because often the higher the abstraction, the higher the overall cost. Over time,
    if a product takes off, it may become more affordable to start using other services
    that are cheaper but rely more on developers to maintain them. The second cost
    is the inability to access certain features hidden by the abstraction. For example,
    in a Function as a Service, the user is not able to use system libraries to do
    things such as image processing or video splitting. As with everything, this comes
    with various trade-offs and is something you and your company will need to decide
    on. As you can see in figure 4.7, all of these services run on servers, but what
    you need to worry about varies based on the abstraction. Moving from right to
    left, your cost often becomes time, while moving from left to right, the cost
    becomes money.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，其他产品被标记为“作为服务”。每个服务都为开发者提供了所需的不同的抽象层。抽象是有帮助的，因为它们隐藏了关于底层系统的某些细节。这种抽象有两个代价。首先是使用抽象的财务成本，因为通常抽象程度越高，整体成本就越高。随着时间的推移，如果产品开始流行，使用更便宜但更依赖开发者维护的其他服务可能变得更加经济。第二个代价是无法访问抽象隐藏的某些功能。例如，在函数即服务中，用户无法使用系统库进行图像处理或视频分割等操作。和所有事情一样，这也伴随着各种权衡，这是您和您的公司需要决定的事情。如图4.7所示，所有这些服务都在服务器上运行，但您需要担心的事情取决于抽象。从右向左移动，您的成本通常是时间，而从左向右移动，成本则是金钱。
- en: '![](../../OEBPS/Images/CH04_F07_Holmes4.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F07_Holmes4.png)'
- en: Figure 4.7 Each type of “as a service” product provides various levels of abstraction
    that you as the customer interact with and provide releasable items based on this
    abstraction. Below the abstraction are various elements of servers that in the
    past have been the responsibilities of entire teams to maintain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 每种“即服务”产品都提供了不同层次抽象，您作为客户与之交互，并基于这种抽象提供可发布的项目。在抽象之下是服务器的一些元素，在过去这些是整个团队负责维护的。
- en: The way you develop your code also changes when moving in different directions.
    Moving to the right provides a lot of abstraction and therefore focuses on a single
    function that can be run. Moving to the left allows you to utilize more system-level
    functions such as storage and operating system calls. Table 4.1 outlines the various
    services.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向不同方向移动时，您的代码开发方式也会改变。向右移动提供了很多抽象，因此专注于可以运行的单一函数。向左移动允许您利用更多系统级功能，如存储和操作系统调用。表
    4.1 概述了各种服务。
- en: Table 4.1 “As a service” applications
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 “即服务”应用
- en: '| Abbreviation | Service | Products |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 缩写 | 服务 | 产品 |'
- en: '| IaaS | Infrastructure as a Service | AWS EC2, Google Compute |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| IaaS | 基础设施即服务 | AWS EC2, Google Compute |'
- en: '| CaaS | Container as a Service | AWS ECS, Google Cloud Run |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| CaaS | 容器即服务 | AWS ECS, Google Cloud Run |'
- en: '| PaaS | Platform as a Service | Heroku, Google App Engine, AWS Elastic Beanstalk
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| PaaS | 平台即服务 | Heroku, Google App Engine, AWS Elastic Beanstalk |'
- en: '| FaaS | Function as a Service | AWS Lambda, Google Cloud functions |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| FaaS | 函数即服务 | AWS Lambda, Google Cloud functions |'
- en: To create an effective demonstration for your company, you must first outline
    the cost decisions for what you are doing and show how flexible your product can
    be in each of these environments as time progresses. An operations member suggested
    picking one, but you think, “Why not pick two for the demonstration?” The first
    deployment type will demonstrate rapid development at a low cost through a Function
    as a Service (FaaS), and the second will demonstrate a scalable application service
    through a Platform as a Service (PaaS). Most companies will move from right to
    left in figure 4.7 until they find the one that fits them best. We will use this
    approach throughout the book so that we can pull back various layers of abstraction.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为您的公司制作一个有效的演示，您必须首先概述您正在进行的成本决策，并展示随着时间的推移，您的产品在每种环境中如何变得灵活。一位运营团队成员建议选择一个，但您认为，“为什么不为演示选择两个？”第一种部署类型将通过函数即服务
    (FaaS) 展示低成本快速开发，第二种将通过平台即服务 (PaaS) 展示可扩展的应用服务。大多数公司将从图 4.7 的右侧向左侧移动，直到找到最适合他们的那个。我们将在这本书中一直使用这种方法，以便我们可以拉回各种抽象层。
- en: First, let’s create a serverless application due to its low-cost usage. A *serverless*
    application is another name for a FaaS application because it has a single entry
    point that is the function, and the developer doesn’t need to know or understand
    anything about the platform or runtime. This abstraction buys your team time as
    they will not need to focus on doing security updates to systems or library upgrades
    for a container. Nor do they need to pay for idle time on the system. Most cloud
    solutions will charge you by the hour to have a service run. FaaS instead focuses
    on the number of invocations your function encounters. This allows you and your
    team to experiment with your product while it is in development and incurs little
    to no costs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个无服务器应用程序，因为它具有低成本的使用。*无服务器*应用程序是函数即服务 (FaaS) 应用程序的另一个名称，因为它有一个单一的入口点，即函数，开发者不需要了解或理解任何关于平台或运行时的事情。这种抽象为您团队节省了时间，因为他们不需要专注于对系统或容器库进行安全更新或升级。他们也不需要为系统上的闲置时间付费。大多数云解决方案都会按小时收费以运行服务。相反，FaaS
    关注的是函数遇到调用的次数。这允许您和您的团队在产品开发过程中进行实验，同时产生很少或没有成本。
- en: 4.5 Function as a Service (FaaS)
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 函数即服务 (FaaS)
- en: Unfortunately, there is no universal way to create FaaS applications across
    different platforms. You define a package and function to run a command from,
    and that is what is built and deployed on GCP. Go uses a standard http.Handler,
    so there will be little to change for our product. However, GCP will look only
    in a designated root folder and will not handle functions in sub-packages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有一种通用的方法可以在不同的平台上创建 FaaS 应用程序。您定义一个包和函数来运行命令，这就是在 GCP 上构建和部署的内容。Go 使用标准的
    http.Handler，因此我们的产品几乎不需要更改。然而，GCP 只会查找指定的根文件夹，不会处理子包中的函数。
- en: Open a new `faas.go` file in the root of your project, and put in the code in
    the following listing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下打开一个新的`faas.go`文件，并放入以下列表中的代码。
- en: Listing 4.2 Adding a proxy handler to move our calls
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 添加代理处理程序以移动我们的调用
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can always use an http.Mux here to reroute multiple calls in the future
    through a single function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终可以使用http.Mux在这里重定向未来的多个调用到一个单一函数。
- en: That’s all we need to do to get our function working. Now we can create a deployment
    step to our pipeline. Open your `pipeline.yml` file, and add the deployment step
    (see the following listing).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使我们的函数工作所需做的全部。现在我们可以创建一个部署步骤到我们的管道中。打开您的`pipeline.yml`文件，并添加部署步骤（见以下列表）。
- en: Listing 4.3 `pipeline.yml`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 `pipeline.yml`
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Gives the function a name to reference
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 给函数一个可引用的名称
- en: ❷ Gives the name of the function to call
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 给出要调用的函数名称
- en: ❸ Uses the secret that is registered for the service account to conduct the
    deployment
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用为服务账户注册的密钥进行部署
- en: ❹ Tests the call to see if it works
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测试调用是否工作
- en: When tests pass, the deployment step will occur. From the output from your deployment,
    you should see an endpoint. Before you can call it, you will need to update the
    permissions to allow public access to this endpoint. Navigate to your Google Cloud
    console and search for “functions.” You should see your newly created function,
    as shown in figure 4.8.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试通过时，部署步骤将会发生。从您的部署输出中，您应该看到一个端点。在您能够调用它之前，您需要更新权限以允许公共访问此端点。导航到您的Google Cloud控制台，搜索“functions”。您应该看到您新创建的函数，如图4.8所示。
- en: '![](../../OEBPS/Images/CH04_F08_Holmes4.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F08_Holmes4.png)'
- en: Figure 4.8 Edit the permissions on the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 编辑函数的权限。
- en: 'NOTE You may need to enable the Cloud functions: [http://mng.bz/KlOZ](http://mng.bz/KlOZ).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能需要启用云功能：[http://mng.bz/KlOZ](http://mng.bz/KlOZ)。
- en: Click Add Member, type “allUsers,” and give it the Cloud function invoker role.
    It will give you a prompt telling you that this will make your function public,
    as seen in figure 4.9.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加成员，输入“allUsers”，并赋予它云函数调用者角色。它会提示您，这将使您的函数公开，如图4.9所示。
- en: '![](../../OEBPS/Images/CH04_F09_Holmes4.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F09_Holmes4.png)'
- en: Figure 4.9 Make your function open to the public.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 使您的函数公开。
- en: Press the confirmation in the prompt, open up a browser, and type in the URL
    found in the pipeline output with `/translate/hello?language=german`. You should
    see the response come back! Change the language. What do you see? Play around
    with different inputs and see what you can do to make it work (or cause it to
    break!).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示中按下确认，打开浏览器，并输入管道输出中找到的URL，使用`/translate/hello?language=german`。您应该看到响应返回！更改语言。您看到了什么？尝试不同的输入，看看您能做什么来使其工作（或使其失败！）
- en: When your trial runs out, you may incur some costs for running these various
    applications. To prevent this, remove the applications when you are done with
    this book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的试用期结束时，您可能需要为运行这些各种应用程序承担一些费用。为了避免这种情况，当您完成这本书后，请删除应用程序。
- en: To underline the power of what we just did, let’s modify our code by supporting
    a new language. Open your `translate.go` file, and add a translation for French
    using the code in the following listing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调我们刚刚所做的事情的力量，让我们通过支持新的语言来修改我们的代码。打开您的`translate.go`文件，并添加以下列表中的代码来为法语添加翻译。
- en: Listing 4.4 `translate.go`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 `translate.go`
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ New line to check to see if your CI works
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新行以检查您的CI是否工作
- en: Don’t forget to add the test! (See the following listing.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记添加测试！（见以下列表。）
- en: Listing 4.5 `translator_test.go`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 `translator_test.go`
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Commit and push your changes. Wait for the deployment to be done, and try making
    your call again, but this time with the language as French. This is a quick iteration
    with fast delivery and feedback to meet the needs of your customers. You are now
    continuously delivering a product at a minimum cost with the ability to learn
    and grow. At some point, you may find that your demand is growing, and you will
    need to scale to meet that demand. Or you may find that your product isn’t meeting
    expectations and you need to pivot. Using a serverless pattern, you only pay for
    what you use, so the risk is minimized.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 提交并推送您的更改。等待部署完成，然后再次尝试调用，但这次使用法语作为语言。这是一个快速迭代和快速交付以及快速反馈以满足客户需求的过程。现在您以最低的成本持续交付产品，并具有学习和成长的能力。在某个时候，您可能会发现需求在增长，您将需要扩展以满足该需求。或者您可能会发现您的产品没有达到预期，您需要转型。使用无服务器模式，您只需为使用付费，因此风险最小化。
- en: 4.6 Platform as a Service
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 平台即服务
- en: The benefits of FaaS are that they provide enough abstraction to make it fast
    and easy to develop and deploy an application. This abstraction comes at a cost
    of both financial expense and control. In general, you will find that the fewer
    abstractions you have, the cheaper it will be to run your applications, to a certain
    point. There is an expensive operating cost to trying to host your own servers
    and infrastructure for a product that hasn’t been tested. Alternatively, you pay
    a premium for Amazon or Google to handle this for you. Eventually, you will need
    to shift if your product becomes popular. Now we will move from FaaS to PaaS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS的好处是它们提供了足够的抽象，使得开发和应用部署变得快速且简单。这种抽象是以财务支出和控制为代价的。一般来说，你会发现，抽象越少，运行你的应用程序的成本就越低，直到一定程度。尝试为尚未经过测试的产品托管自己的服务器和基础设施会有昂贵的运营成本。或者，你可以为亚马逊或谷歌支付额外费用来处理这些事情。最终，如果你的产品变得流行，你将需要做出转变。现在我们将从FaaS迁移到PaaS。
- en: PaaS allows you to hand over your source code, and then the platform will identify,
    build, and run your application for you. In 2007, Heroku become one of the first
    PaaS available, and it revolutionized the way people develop and deploy programs.
    Their platform provided an abstraction that was built on top of AWS cloud computing,
    which provided customers the benefit of developing an application without worrying
    about provisioning or paying for servers. This paved the way for other offerings
    from Amazon and Google to provide similar abstractions as offerings to their customers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: PaaS允许你提交你的源代码，然后平台将为你识别、构建和运行应用程序。2007年，Heroku成为第一个可用的PaaS之一，它彻底改变了人们开发和部署程序的方式。他们的平台提供了一个建立在AWS云计算之上的抽象层，这为顾客提供了在无需担心配置或支付服务器费用的情况下开发应用程序的好处。这为亚马逊和谷歌提供了向客户提供类似抽象的机会铺平了道路。
- en: For many standalone services, it becomes important to check whether the application
    is running and healthy. Typically, this service can be used to great effect if
    there are dependencies involved, such as a database connection. Using a *health
    check* endpoint will tell the running platform that the service is working and
    ready. Otherwise, the platform may try restarting the application or mark the
    deployment as failed. Before we start moving our application to a PaaS, let’s
    add a health check endpoint. We don’t have any external dependencies, so we will
    use the code in the following listing to write a simple handler in the `handlers/health.go`
    file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多独立服务，检查应用程序是否正在运行且健康变得很重要。通常，如果涉及依赖项，如数据库连接，这个服务可以发挥很大的作用。使用*健康检查*端点将告诉运行平台该服务正在运行且准备就绪。否则，平台可能会尝试重新启动应用程序或标记部署为失败。在我们开始将应用程序迁移到PaaS之前，让我们添加一个健康检查端点。我们没有外部依赖项，所以我们将使用以下列表中的代码在`handlers/health.go`文件中编写一个简单的处理程序。
- en: Listing 4.6 `health.go`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 `health.go`
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ We just hardcode a response now because we don’t need to check the connection
    to any service. In the future, we could add more details here about the status
    of specific dependencies.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们现在直接硬编码响应，因为我们不需要检查任何服务的连接。将来，我们可以在这里添加更多关于特定依赖状态的信息。
- en: Now that we have this endpoint, we need to make some slight modifications to
    our `main.go` file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个端点，我们需要对我们的`main.go`文件做一些轻微的修改。
- en: Listing 4.7 `main.go`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 `main.go`
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ We add the health check to the /health endpoint to ensure we can call it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将健康检查添加到/health端点以确保我们可以调用它。
- en: Now that our application has a health check, let’s deploy it to a PaaS.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序有了健康检查，让我们将其部署到PaaS上。
- en: Why didn’t we add the health check to the FaaS? As a function, typically we
    don’t expect it to have a long-running state. Instead, it is invoked and shut
    down. In some platforms, these functions stay running for a short period to reduce
    warm-up, which is the process of starting the application. Having a health check
    is typically something that is needed for a long-running service to know if it
    should be shut down or restarted.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们没有将健康检查添加到FaaS中？作为一个函数，我们通常不期望它有一个长时间运行的状态。相反，它被调用并关闭。在一些平台上，这些函数会短暂运行以减少预热过程，预热是启动应用程序的过程。健康检查通常是长时间运行的服务需要知道是否应该关闭或重启时所需的东西。
- en: 'It wasn’t long after Heroku provided a PaaS that Google responded with Google
    App Engine. Originally focused on Java and Python applications, it now supports
    a wide variety of languages, including Go. App Engine will use your source code
    and run it in a *sandboxed* or isolated runtime to prevent your application from
    affecting other applications. This form of virtualization and abstraction ensures
    that your application will be safe and secure while providing an easy way of developing
    and deploying a scalable application. Google worries about whether the platform
    is running, as well as about upgrading servers and installing libraries, so you
    don’t have to. This is the power of using a PaaS; it gives you control of a full
    application without worrying about the underlying runtime. Deploying to App Engine
    is as easy as deploying a Cloud function, with one addition: we need to provide
    an app.yaml in the root project folder file to describe the deployment. Let’s
    create one at the root of our project using the code in the following listing.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Heroku提供PaaS之后不久，谷歌就推出了Google App Engine。最初专注于Java和Python应用程序，现在它支持包括Go在内的多种语言。App
    Engine将使用您的源代码，并在一个*沙盒*或隔离的运行时中运行它，以防止您的应用程序影响其他应用程序。这种虚拟化和抽象形式确保了您的应用程序将安全且安全，同时提供了一个简单的方式来开发和部署可扩展的应用程序。谷歌担心平台是否在运行，以及升级服务器和安装库，所以您不必担心。这就是使用PaaS的力量；它让您控制整个应用程序，而无需担心底层运行时。部署到App
    Engine与部署云函数一样简单，但有一个附加条件：我们需要在根项目文件夹文件中提供一个app.yaml来描述部署。让我们使用以下列表中的代码在我们的项目根目录中创建一个。
- en: Listing 4.8 `app.yaml`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 `app.yaml`
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is all Google needs to start our application and make sure things are running.
    To deploy this, we need to add a step to our pipeline. Instead of replacing the
    function, we deploy both. Below the function step, add the code in the following
    listing to our pipeline.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是谷歌启动我们的应用程序并确保一切正常运行所需的所有内容。为了部署这个，我们需要在我们的管道中添加一个步骤。而不是替换函数，我们部署两个。在函数步骤下方，将以下列表中的代码添加到我们的管道中。
- en: Listing 4.9 `pipeline.yml`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 `pipeline.yml`
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s it! Now we can push our changes and call the endpoint that is output
    from the deployment. From here, we can grow and get feedback from our customers.
    This feedback will feed more growth and steer our application into something useful.
    The seamlessness we have between writing code and seeing it in production helps
    bolster the productivity and engagement of developers. No longer does it take
    hours or days to see the work; instead, it is there in a matter of minutes. Moving
    forward, we will enhance our pipeline to have better development practices, reduce
    bugs, and have more advanced deployments, but for now, we can reflect on how powerful
    and easy it is to build a pipeline.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们可以推送我们的更改并调用部署输出的端点。从这里，我们可以扩展并获得客户的反馈。这些反馈将促进更多增长，并将我们的应用程序引导到有用的方向。我们在编写代码和看到它在生产中的无缝连接有助于提高开发者的生产力和参与度。不再需要花费数小时或数天才能看到工作成果；相反，它只需几分钟即可出现。向前看，我们将增强我们的管道以拥有更好的开发实践，减少错误，并实现更高级的部署，但就目前而言，我们可以反思构建管道是多么强大和简单。
- en: You commit your changes and push them to your repository. At that moment you
    look up and see the PM walking toward you quickly. “Hey,” they say, “are you ready
    for the demo?”
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您提交更改并将它们推送到您的仓库。就在那时，您抬头看到项目经理快速向您走来。“嘿，”他们说，“你准备好演示了吗？”
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Deliver the product with a description of what is changing to help customers
    adapt and use your product.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以描述更改的内容交付产品，以帮助客户适应并使用您的产品。
- en: Always deliver and deploy to receive customer feedback.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是交付和部署以获得客户反馈。
- en: A health check endpoint is an easy way of communicating the status of a deployed
    product.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查端点是传达已部署产品状态的一种简单方式。
- en: Each type of deployment has various levels of abstraction to help a developer
    quickly release products.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种部署类型都有不同级别的抽象，以帮助开发者快速发布产品。
- en: FaaS helps create simple, easy-to-manage applications at a higher cost in the
    long run.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FaaS有助于创建简单、易于管理的应用程序，但长期来看成本较高。
- en: PaaS helps give you a more complete server to run your application on, but with
    easy deployment options.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PaaS有助于为您提供更完整的服务器来运行您的应用程序，但具有易于部署的选项。
