- en: 12 Holiday detector
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 假日检测器
- en: 'No matter the time of year, it seems that a holiday looms on the horizon. It
    could be a religious holiday, a national day, or some other festive event. Many
    people may get the day off from work to celebrate. For programmers, the holiday
    is also a celebration but not from work: coders still code, but it’s a more enjoyable
    experience because everyone else is on vacation, which means fewer interruptions.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时，似乎总有一个假日即将到来。这可能是一个宗教假日、国庆日或某些其他节日活动。许多人可能会从工作中得到一天假期来庆祝。对于程序员来说，假日也是一个庆祝活动，但不是从工作中：编码者仍然在编码，但这是一个更加愉快的体验，因为其他人都在度假，这意味着更少的干扰。
- en: 'Your computer doesn’t care whether one day is a holiday. It’s not being ignorant;
    it just doesn’t know. To help the computer understand which day is a holiday,
    and to help you complete other programming projects that rely upon knowing which
    days are holidays, you must:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电脑不在乎一天是否是假日。它并不是无知的；它只是不知道。为了帮助电脑理解哪一天是假日，以及帮助你完成其他依赖于知道哪些天是假日的编程项目，你必须：
- en: Understand how the operating system uses return values
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解操作系统如何使用返回值
- en: Work with date programming in C
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C 中处理日期编程
- en: Review major holidays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾主要假日
- en: Calculate regular holidays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算常规假日
- en: Deal with irregular holidays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不规则假日
- en: Figure out when Easter occurs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定复活节何时到来
- en: Put your holiday function to the test
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的假日函数
- en: These tasks help build routines that detect and report on holidays given a specific
    day of the year. Such a utility isn’t specifically useful by itself, but it does
    come into play when programming dates or performing other tasks where knowing
    when a holiday occurs is important. For example, I wrote a stock tracker where
    it was useful to know which days not to fetch the stock data because the markets
    are closed. And my trash pickup reminder shell script uses my holiday program
    to see whether trash day has shifted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务有助于构建检测和报告特定年份某一天假日的例行程序。这种实用工具本身可能并不特别有用，但在编程日期或执行其他需要知道假日何时到来的任务时，它就派上用场了。例如，我编写了一个股票追踪器，其中知道哪些天不要获取股票数据是有用的，因为市场关闭。我的垃圾回收提醒
    shell 脚本使用我的假日程序来查看垃圾回收日是否已改变。
- en: The routines presented in this chapter also play a role in the calendar programs
    introduced in chapter 13.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的例程在第 13 章介绍的日历程序中也发挥作用。
- en: 12.1 The operating system wants its vig
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 操作系统想要它的手续费
- en: Ever wonder why *main()* is an integer function? Years ago, C programmers freely
    declared it a *void* function. Scandalous! Old programmers may still pull a void
    main() in their code. Goodness, even the first edition of the venerable K&R—*The
    C Programming Language* (Prentice-Hall)—didn’t even bother to cast the *main()*
    function. Try not to work yourself into a tizzy.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾好奇为什么 `main()` 是一个整数函数？多年前，C 程序员随意地将其声明为 `void` 函数。真是令人震惊！老程序员可能仍然会在他们的代码中使用
    `void main()`。哎呀，即使是备受尊敬的 K&R 第一版——《C 程序设计语言》（Prentice-Hall）——甚至都没有费心去强制转换 `main()`
    函数。尽量别让自己陷入混乱。
- en: The reason the *main()* function is cast as an *int* is that it must return
    a value to the operating system. Like any loan shark, when the operating system
    releases some of its resources (memory and processor time) to another program,
    it wants something in return, such as the interest—vigorish, or “vig.” That something
    is an integer value. This value is often ignored (just don’t miss a payment),
    or it’s used in some clever and innovative way. Either way, the value is required.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `main()` 函数强制转换为 `int` 的原因是它必须向操作系统返回一个值。就像任何高利贷者一样，当操作系统将其一些资源（内存和处理器时间）释放给另一个程序时，它希望得到一些回报，比如利息——手续费，或“手续费”。这个回报就是一个整数值。这个值通常被忽略（只是别错过付款），或者被用于某些巧妙和创新的方式。无论如何，这个值是必需的。
- en: 12.1.1 Understanding exit status versus the termination status
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 理解退出状态与终止状态
- en: More than one way exists to stop a program. The natural way is for the program
    to end normally, with a return statement at the end of the *main()* function passing
    its value back to the operating system. This value is officially known as the
    program’s exit status.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 停止程序的方式不止一种。最自然的方式是程序正常结束，在 `main()` 函数的末尾使用返回语句将其值传递回操作系统。这个值官方上被称为程序的退出状态。
- en: If the program stops before the *main()* function exits, it has a termination
    status. For example, an *exit()* statement nestled in a function other than *main()*
    halts a program. In this case, the value that *exit()* passes to the operating
    system is known as the termination status.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序在`main()`函数退出之前停止，它有一个终止状态。例如，在`main()`函数之外嵌套的`exit()`语句会停止程序。在这种情况下，`exit()`传递给操作系统的值被称为终止状态。
- en: Termination status. Exit status. Yes, the nerds love to pick nits. The point
    is that the way the program quits affects how the value returned is interpreted.
    Many functions that spawn other programs (processes) use a termination status
    and not an exit status. The termination status is typically 0 for success or -1
    otherwise. This value is different from whatever the exit status might be. Be
    aware of this difference as you code your programs, and especially if you choose
    to dialogue with nerds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 终止状态。退出状态。是的，那些书呆子喜欢挑刺。关键是程序退出的方式会影响返回值的解释。许多生成其他程序（进程）的函数使用终止状态而不是退出状态。终止状态通常是0表示成功，否则为-1。这个值与可能的退出状态不同。在编写程序时要注意这个差异，尤其是在你选择与书呆子对话时。
- en: 12.1.2 Setting a return value
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 设置返回值
- en: 'The *return* statement in the *main()* function is responsible for sending
    a value back to the operating system. Sending an integer value up to the mothership
    is vital for the *main()* function: miss it, and the compiler points its bony
    finger at you and shrieks like Donald Sutherland at the end of *Invasion of the
    Body Snatchers*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中的`return`语句负责将一个值发送回操作系统。将一个整数值发送到母舰对于`main()`函数至关重要：错过它，编译器就会用它的瘦手指指着你说，就像唐纳德·萨瑟兰在《人体互换》结尾时的尖叫。
- en: 'The next listing shows the source code for return01.c. This program has only
    one job: to return a value to the operating system. If the value isn’t specified
    as a command-line argument, zero is returned.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了`return01.c`的源代码。这个程序只有一个任务：向操作系统返回一个值。如果没有指定命令行参数，则返回零。
- en: Listing 12.1 Source code for return01.c
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.1 `return01.c`的源代码
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The stdio.h header isn’t required because no I/O functions are used in the
    code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不需要`stdio.h`头文件，因为代码中没有使用I/O函数。
- en: ❷ If a command-line option is present, tries to convert it into an integer
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果存在命令行选项，尝试将其转换为整数
- en: ❸ Returns the conversion of string argv[1] into an integer (*long*) value
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将字符串`argv[1]`转换为整数（*长整型*）值
- en: ❹ When no argument is present, returns zero
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当没有参数时，返回零
- en: The *strtol()* function in return01.c converts the string held in argv[1], the
    first argument at the command prompt, into an integer value, base 10\. If the
    string can’t be converted (it contains no digits), the value 0 is returned.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`return01.c`中的`strtol()`函数将命令提示符中持有的字符串`argv[1]`，第一个参数，转换为十进制整数。如果字符串无法转换（它不包含数字），则返回值0。'
- en: The program surrenders its value via the *return* statement. The *exit()* function
    could also be used, but this value is an exit status, not a termination status.
    (I wrote that for the nerds; don’t worry about the difference here.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通过`return`语句放弃其值。也可以使用`exit()`函数，但这个值是退出状态，而不是终止状态。（我写那是为了那些书呆子；别担心这里的差异。）
- en: 'Here is a sample run:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例运行：
- en: Yes, the code lacks output, even when you specify an argument. And, yes, the
    value returned is consumed by the operating system. It’s available for the shell
    to interpret. Despite being a loan shark, the operating system rarely if ever
    does anything with a program’s return value. This job can be done by other programs,
    but specifically the exit status is available for use by shell scripts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，代码没有输出，即使你指定了参数。而且，是的，返回的值被操作系统消耗。它可供shell解释。尽管操作系统像高利贷者一样，但很少或几乎不做任何关于程序返回值的事情。这项工作可以由其他程序完成，但具体来说，退出状态可供shell脚本使用。
- en: 12.1.3 Interpreting the return value
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 解释返回值
- en: The value a program poops out is left on the operating system’s doorstep. Though
    nothing needs to be done with the value, it remains available for the shell to
    use—until another program deposits another value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出的值留在了操作系统的门口。尽管不需要对这个值做任何事情，但它仍然可供shell使用——直到另一个程序存入另一个值。
- en: 'To demonstrate how the return value is accessed from the shell, rerun the program
    for return01.c:, type the program name, assumed to be *return01*, and a value
    as an argument, such as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示如何从shell访问返回值，重新运行`return01.c`程序，输入程序名称，假设为`return01`，以及一个作为参数的值，例如：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The program returns the value 27 to the operating system. This value is accessed
    via the shell scripting variable $?. To see it, type the *echo* command followed
    by $?:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '程序将值27返回给操作系统。这个值通过shell脚本变量$?访问。要查看它，请输入 *echo* 命令后跟 $?:'
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Shell scripts can use this value to determine the result of some operation.
    Alas, in Linux it’s difficult for a non-shell script program to read the return
    value of another program it spawns. Such a task is possible, and I could so easily
    get sidetracked to describe the thrilling details, but it’s beyond the scope of
    this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本可以使用这个值来确定某些操作的结果。唉，在Linux中，非shell脚本程序很难读取它所启动的另一个程序的返回值。这样的任务是有可能的，我本可以轻易地偏离主题来描述这些激动人心的细节，但这超出了本章的范围。
- en: The source code for return02.c in the following listing attempts to capture
    the value returned from the *return01* program. The *system()* function is used
    to execute *return01* with a return value of 99\. The purpose of the program is
    to show how the *system()* function doesn’t capture a program’s return value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的 return02.c 的源代码试图捕获 *return01* 程序返回的值。使用 *system()* 函数以返回值99执行 *return01*。程序的目的在于展示
    *system()* 函数不会捕获程序的返回值。
- en: Listing 12.2 Source code for return02.c
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2 return02.c 的源代码
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Runs the *return01* program and sets a return value of 99
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 运行 *return01* 程序并设置返回值为99
- en: ❷ Reports the value returned by the *system()* function
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 报告 *system()* 函数返回的值
- en: 'The *system()* function’s single argument is something you would type at the
    command prompt. The function can return a variety of values, though if the call
    is successful, the value returned is the termination status of the shell launched
    to run the program. The value is not the return value of the program run. Here’s
    a sample run:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*system()* 函数的单个参数是你会在命令提示符中输入的内容。该函数可以返回各种值，尽管如果调用成功，返回的值是启动来运行程序的shell的终止状态。这个值不是运行程序的返回值。以下是一个示例运行：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After running the *system()* function, the shell returns the value 25344 to
    the operating system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 *system()* 函数后，shell将值25344返回给操作系统。
- en: 'In Windows, the *system()* function works differently. Unlike with Linux, it
    returns the value generated by any program run. Here’s sample output of the same
    code built in Windows, with the option 99 specified:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，*system()* 函数的行为不同。与Linux不同，它返回运行任何程序生成的值。以下是同一代码在Windows中构建的示例输出，指定了选项99：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As an old MS-DOS/Windows coder, I remember using this trick with the *system()*
    function ages ago in various programs. Because system() behaves differently in
    Linux, relying upon the function to report a program’s return value isn’t anything
    you should do.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位资深的MS-DOS/Windows程序员，我记得很久以前在各种程序中使用这个技巧与 *system()* 函数。因为system()在Linux中的行为不同，依赖于该函数来报告程序的返回值并不是你应该做的事情。
- en: 'Yes, I know: the *system()* function in Linux does, in fact, return the exit
    status of the program run—the shell. The point I’m making is that the function
    can’t be used to examine another program’s return value.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道：Linux中的 *system()* 函数确实返回运行程序的退出状态——shell的。我想要表达的观点是，该函数不能用来检查另一个程序的返回值。
- en: 'Other functions that spawn a process—*fork()*, *popen()*, and so on—behave
    similarly to *system()*: the program spawned may generate an exit status, but
    this value isn’t reported by the function making the call.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其他启动进程的函数——*fork()*, *popen()*, 等等——的行为与 *system()* 类似：启动的程序可能生成退出状态，但这个值不会被调用该函数的报告。
- en: 'As I wrote earlier, it’s possible to spawn a process and capture its return
    value. If you’re curious to know the procedure, visit my blog and search for the
    wait() function: [https://c-for-dummies.com/blog](https://c-for-dummies.com/blog/).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，可以启动一个进程并捕获其返回值。如果你对过程好奇，请访问我的博客并搜索wait()函数：[https://c-for-dummies.com/blog](https://c-for-dummies.com/blog/).
- en: 12.1.4 Using the preset return values
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.4 使用预设的返回值
- en: 'The C overlords want you to know that an exit status of 0 indicates success;
    everything went as planned. An exit status of 1 means something went wrong. I
    use this consistency in my code, but don’t use the defined constants available
    in the stdlib.h header file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的大佬们想让你知道，退出状态为0表示成功；一切按计划进行。退出状态为1表示出了问题。我在我的代码中使用这种一致性，但不要使用在stdlib.h头文件中可用的定义常量：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These two values are defined as 1 and 0 for failure and success, respectively.
    The defined constants are consistent—the same for all compilers and platforms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值分别定义为1和0，代表失败和成功。定义的常量是一致的——对所有编译器和平台都相同。
- en: 'The next listing shows the source code for return03.c, which generates a random
    integer, 0 or 1\. This value is used to determine which defined constant is returned
    as an exit status: EXIT_FAILURE or EXIT_SUCCESS.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了return03.c的源代码，它生成一个随机整数，0或1。这个值用于确定返回的退出状态是EXIT_FAILURE还是EXIT_SUCCESS。
- en: Listing 12.3 Source code for return03.c
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.3 return03.c的源代码
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Seeds the randomizer
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化随机数生成器
- en: ❷ Generates a random value and stores it in r
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成一个随机值并将其存储在r中
- en: ❸ Uses r to test success (zero) or failure (one)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用r测试成功（零）或失败（一）
- en: ❹ Outputs the error to the standard error device—out of tradition
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将错误输出到标准错误设备——出于传统
- en: ❺ The non-error message is sent to standard output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将非错误消息发送到标准输出。
- en: 'The program’s output depends on the random number generated. To confirm the
    value, you can use the $? variable at the command prompt:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出取决于生成的随机数。为了确认值，你可以在命令提示符下使用$?变量：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还有：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember, return values need not be limited to 0 and 1\. Many programs and utilities
    return different values, each of which can be interpreted by a shell script to
    determine what happened. The interpretation of these values is up to whatever
    purpose the program has, to help it fulfill its function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，返回值不必局限于0和1。许多程序和实用程序返回不同的值，每个值都可以由shell脚本解释以确定发生了什么。这些值的解释取决于程序的目的，以帮助它完成其功能。
- en: 12.2 All about today
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 所有关于今天
- en: Ages ago, US national holidays fell on specific days. I remember, when I was
    young, getting to take off both Lincoln’s birthday *and* George Washington’s birthday.
    As a kid, I’d take two days off school in February over a Nintendo Switch in a
    heartbeat.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，美国的国庆节在特定的日子。我记得，当我年轻的时候，我可以在林肯的生日*和*乔治·华盛顿的生日都放假。作为一个孩子，我会在二月份为了任天堂Switch而放弃两天学校假期。
- en: Well, maybe not.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许不是。
- en: Before you can determine which day is a holiday, you need a point of reference.
    That point is today, the current date obtained from the operating system. Or you
    can backfill a tm structure with any old date and work from there. Both items
    are easy to obtain by invoking the proper C language functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在你确定哪一天是假日之前，你需要一个参考点。这个点就是今天，从操作系统获取的当前日期。或者你也可以用任何旧日期填充tm结构，并从这里开始工作。通过调用适当的C语言函数，这两项内容都很容易获得。
- en: 12.2.1 Getting today’s date
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 获取今天的日期
- en: 'One of the hallmarks of the early PC era was the prompt:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 早期个人电脑时代的标志之一是提示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: MS-DOS didn’t know whether today was a holiday because it didn’t even know which
    day it was! The user had to input the current date. Eventually, technology was
    added to the motherboard to retain the current date and time. This setup is how
    modern computers work, but with the bonus of an internet time server to keep the
    clock accurate. Your C code can use this information to obtain the current date
    and time—as it’s known to the computer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MS-DOS不知道今天是否是假日，因为它甚至不知道今天是星期几！用户必须输入当前日期。最终，技术被添加到主板上以保留当前日期和时间。这种设置就是现代计算机的工作方式，但有了互联网时间服务器来保持时钟准确。你的C代码可以使用这些信息来获取计算机所知的当前日期和时间。
- en: The following listing shows the typical time code for the C language. The current
    epoch value—the number of seconds ticked since January 1, 1970—is obtained from
    the *time()* function and stored in *time_t* variable now. This variable is used
    in the *localtime()* function to fill a tm structure, today. The tm structure’s
    members contain individual time tidbit values, which are output.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了C语言的典型时间代码。当前纪元值——自1970年1月1日以来的秒数——通过*time()*函数获取并存储在*time_t*变量中。这个变量用于*localtime()*函数填充tm结构，即今天。tm结构的成员包含个别的时间tidbits值，这些值被输出。
- en: Listing 12.4 Source code for getdate01.c
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.4 getdate01.c的源代码
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Obtains the number of seconds elapsed since January 1, 1970—the Unix epoch
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取自1970年1月1日以来的秒数——Unix纪元
- en: ❷ Fills the tm structure today with time tidbits
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将今天的tidbits填充到tm结构中
- en: ❸ The tm_mon member starts with 0 for January.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ tm_mon成员从1月为0开始。
- en: ❹ The tm_year member starts with 1901.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ tm_year成员从1901年开始。
- en: ❺ Outputs the values obtained from the tm structure
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出从tm结构获得的价值
- en: 'This code’s approach should be familiar to you if you’ve written any time-related
    programs. The output shows the current date in this format:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写过任何与时间相关的程序，这个代码的方法应该很熟悉。输出显示了当前日期的以下格式：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, the output could be made readable by a human. Unless you’re a true
    nerd you may not recognize “1” as the value for Monday.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，输出可以通过人类来使其可读。除非您是真正的极客，否则您可能不会将“1”识别为星期一的价值。
- en: Exercise 12.1
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 练习12.1
- en: Update the code for getdate01.c to output strings for the days of the week and
    months. This improvement requires adding two string arrays to the code and other
    updates, including to the *printf()* function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将getdate01.c的代码更新为输出星期几和月份的字符串。这个改进需要向代码中添加两个字符串数组，以及其他更新，包括对*printf()*函数的更新。
- en: My solution is available in the online repository as getdate02.c. Please try
    this exercise on your own before you see how I did it. Comments in my code explain
    what’s going on—including an important point you will probably forget.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案在在线仓库中作为getdate02.c提供。请在您看到我是如何做到的之前，自己尝试这个练习。我代码中的注释解释了正在发生的事情——包括您可能会忘记的一个重要观点。
- en: 12.2.2 Obtaining any old date
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 获取任何旧日期
- en: The *time()* function obtains the current time, a *time_t* value containing
    the number of seconds elapsed from January 1, 1970\. This value is useless by
    itself, which is why functions like *localtime()* help sort out the details for
    you. But what about dates other than today?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*time()*函数获取当前时间，一个包含从1970年1月1日以来经过的秒数的*time_t*值。这个值本身没有用，这就是为什么像*localtime()*这样的函数可以帮助您整理细节的原因。但除了今天之外的其他日期怎么办？'
- en: It’s possible to backfill a tm structure. You assign values to the various members,
    then use the *mktime()* function to translate these time tidbits into a *time_t*
    value. Further, the *mktime()* function fills in unknown details for you, such
    as the day of the week. This information is vital if you plan to determine upon
    which date a holiday falls.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以回填一个tm结构体。您为各种成员分配值，然后使用*mktime()*函数将这些时间片段转换为*time_t*值。此外，*mktime()*函数会为您填充未知细节，例如星期几。如果您计划确定假日是哪一天，这些信息至关重要。
- en: 'Here is the *man* page format for the *mktime()* function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*mktime()*函数的*man*页格式：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function is passed the address of a partially filled tm structure. A *time_t*
    value is returned, but more importantly, the rest of the tm structure is filled
    with key details.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数传递了一个部分填充的tm结构体的地址。返回一个*time_t*值，但更重要的是，剩余的tm结构体被填充了关键细节。
- en: The *mktime()* function is prototyped in the time.h header file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*mktime()*函数在time.h头文件中声明。'
- en: As a quick reference, table 12.1 shows the common members of a tm structure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速参考，表12.1显示了tm结构体的常见成员。
- en: Table 12.1 Members of the tm structure
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1 tm结构体的成员
- en: '| Member | References | Range/Notes |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 参考 | 范围/备注 |'
- en: '| tm_sec | Seconds | 0 to 60 (60 allows for a leap second) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| tm_sec | 秒 | 0到60（60允许闰秒） |'
- en: '| tm_min | Minutes | 0 to 59 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| tm_min | 分钟 | 0到59 |'
- en: '| tm_hour | Hours | 0 to 23 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| tm_hour | 小时 | 0到23 |'
- en: '| tm_mday | Day of the month | 1 to 31 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| tm_mday | 月份中的天数 | 1到31 |'
- en: '| tm_mon | Month | 0 to 11 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| tm_mon | 月份 | 0到11 |'
- en: '| tm_year | Year | Current year minus 1900 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| tm_year | 年 | 当前年份减去1900 |'
- en: '| tm_wday | Day of the week | 0 to 6, Sunday to Saturday |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| tm_wday | 星期 | 0到6，星期日到星期六 |'
- en: '| tm_yday | Day of the year | 0 to 365; zero is January 1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| tm_yday | 一年中的天数 | 0到365；0代表1月1日 |'
- en: '| tm_isdst | Daylight saving time | Positive values indicate daylight saving
    time; zero indicates not; negative values indicate that the data is unavailable
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| tm_isdst | 夏令时 | 正值表示夏令时；零表示不是；负值表示数据不可用 |'
- en: 'Say you want to find out the day of the week for April 12, 2022\. The code
    shown in the next listing attempts to do so by filling in three members of the
    tm structure: tm_mon, tm_day, and tm_year. Adjustments are made for the tm_mon
    member, which uses zero for January, and the tm_year member, which starts its
    count at 1900\. A *printf()* statement outputs the result in mm/dd/yyyy format,
    which also accesses the newly filled tm_wday member to output the day of the week
    string.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想找出2022年4月12日的星期几。下一列表中显示的代码尝试通过填充tm结构体的三个成员：tm_mon、tm_day和tm_year来实现这一点。对tm_mon成员进行了调整，它使用0代表1月，对tm_year成员进行了调整，它从1900年开始计数。一个*printf()*语句以mm/dd/yyyy格式输出结果，同时也访问了新填充的tm_wday成员以输出星期几字符串。
- en: Listing 12.5 Source code for getdate03.c
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 getdate03.c的源代码
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ I use this format because 0 is January, so 4 (April) minus 1 prompts me to
    double-check.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我使用这种格式是因为0代表1月，所以4（四月）减去1促使我再次检查。
- en: ❷ The 12th day of the month
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 月份的第12天
- en: ❸ This format makes the date I want, 2022, readable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这种格式使得我想要的日期2022年可读。
- en: ❹ Converts the partially filled tm structure
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 转换部分填充的tm结构体
- en: ❺ Outputs the results
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出结果
- en: 'Here is the program’s output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alas, September 11 in the year 122 wasn’t expected, whether or not it’s a Tuesday.
    That is the output from my Linux machine. On the Macintosh, I saw this output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，122年的9月11日，无论那天是星期二与否，都是意料之外的。这是我Linux机器的输出。在Macintosh上，我看到了这样的输出：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Curiously, August 22 in the year 5839 is on a Thursday. The computer is amazing,
    not only to know the exact date, but that our reptilian overlords will continue
    to use the common calendar. Obviously, something went wrong. These types of bugs
    are frustrating, especially when the code cleanly compiles.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，5839年的8月22日是在星期四。计算机很神奇，不仅知道确切的日期，而且我们的爬行动物统治者将继续使用公历。显然，出了点问题。这类错误很令人沮丧，尤其是在代码干净编译的情况下。
- en: 'The issue is that the tm structure contains garbage that’s misinterpreted or
    conflicting with the three values preset. My solution is to also set the values
    for hour, minute, and second members, adding the following three lines to the
    code just below the statements where the day, month, and year are set:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于tm结构中包含垃圾数据，这些数据被错误地解释或与预设的三个值冲突。我的解决方案是在设置日期、月份和年份的语句下方也设置小时、分钟和秒的值，添加以下三行代码：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This change is found in the source code file getdate04.c, available in the
    online repository. When built, here is the output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改可以在源代码文件getdate04.c中找到，该文件可在在线仓库中找到。构建后，这是输出：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I used a greasy old garage calendar to confirm that, indeed, April 12, 2022,
    is a Tuesday.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个油腻的老车库日历来确认，2022年4月12日确实是一个星期二。
- en: The lesson learned is that you can obtain details about a date if you know the
    month, day, and year, by filling the six tm structure members, as outlined here,
    and calling the *mktime()* function. Yet even then, you may get the wrong date.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 学到的教训是，如果你知道月份、日期和年份，就可以通过填充六个tm结构成员，如这里概述的那样，并调用*mktime()*函数来获取日期的详细信息。然而，即使如此，你也可能得到错误的日期。
- en: 12.3 Happy holidays
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 祝大家节日快乐
- en: It seems like every day is a holiday, a feast day, a saint’s day, or a day of
    proclamation for this or that cause, celebrity, hero, or historic figure. You’ve
    seen the hairspray dolls on local TV cheerfully announce, “Well, today is National
    Hoot Like an Owl Day . . .” or some such nonsense. Such filler is possible because
    every day is some sort of celebration—and it’s a slow news day.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来每一天都是假日、节日、圣人日，或者是为了某个原因、名人、英雄或历史人物而宣布的日子。你可能在当地电视上看到发胶娃娃欢快地宣布，“嗯，今天是全国模仿猫头鹰叫声日……”或者类似的胡言乱语。这种填充内容之所以可能，是因为每一天都是某种庆祝活动——而且这是新闻淡季。
- en: For purposes of this chapter, a holiday must be a big deal, such as a national
    holiday when everyone gets the day off. My personal indication of a major holiday
    is when the mail doesn’t come. Excluding every Sunday, these holidays are few,
    typically one a month. This is the type of holiday I want my holiday detector
    to report, though you’re free to modify the code to list any holiday—including
    every Sunday.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，假日必须是一件大事，比如全国假日，每个人都放假。我个人的重大假日标志是邮件不送。排除每个星期日，这些假日很少，通常每月只有一个。这就是我想要我的假日检测器报告的假日类型，尽管你可以自由地修改代码以列出任何假日——包括每个星期日。
- en: 12.3.1 Reviewing holidays in the United States
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 回顾美国的假日
- en: The United States have a smattering of holidays, though not every national holiday
    is a day off for everyone. Instead, I consider the specific holidays shown in
    table 12.2\. For these holidays, most people have the day off, government offices
    are closed, banks are closed, school is out, the mail doesn’t come, and people
    don’t bother me as much with phone calls and email.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 美国有一些假日，尽管并非每个国家假日都对每个人都是休息日。相反，我考虑表12.2中显示的具体假日。对于这些假日，大多数人都有休息日，政府办公室关闭，银行关闭，学校放假，邮件不送，人们也不会像平时那样频繁地打电话和发电子邮件。
- en: Table 12.2 US national holidays
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2 美国国家假日
- en: '| Holiday | Date | Notes |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 假日 | 日期 | 备注 |'
- en: '| New Year’s Day | January 1 | Friday/Monday holiday when this holiday occurs
    on a weekend. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 新年 | 1月1日 | 如果这个假日发生在周末，则为周五或周一的假日。 |'
- en: '| Martin Luther King Jr. Day | Third Monday of January |  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 马丁·路德·金纪念日 | 一月的第三个星期一 |  |'
- en: '| Washington’s Birthday | Third Monday of February | Unofficially called Presidents
    Day. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 华盛顿诞辰 | 二月第三个星期一 | 非正式称为总统日。 |'
- en: '| Easter | Sunday in March or April | Calculation is made on the lunar calendar,
    so it varies. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 复活节 | 三月或四月的星期日 | 由于是根据农历计算，所以日期会有所变化。 |'
- en: '| Memorial Day | Last Monday of May |  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 阵亡将士纪念日 | 五月的最后一个星期一 |  |'
- en: '| Juneteenth | June 19 | Friday/Monday holiday when this holiday occurs on
    a weekend. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 黑奴解放日 | 6月19日 | 当这个假日落在周末时，为周五/周一假日。|'
- en: '| Independence Day | July 4 | Friday/Monday holiday when this holiday occurs
    on a weekend. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 独立日 | 7月4日 | 当这个假日落在周末时，为周五/周一假日。|'
- en: '| Labor Day | First Monday of September |  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 劳动节 | 九月的第一个星期一 |  |'
- en: '| Columbus Day | Second Monday of October | Also celebrated as Indigenous Peoples’
    Day. Not every government office is closed. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 哥伦布日 | 十月的第二个星期一 | 也被称为原住民日。并非所有政府办公室都放假。|'
- en: '| Veterans Day | November 11 | Friday/Monday holiday when this holiday occurs
    on a weekend. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 退伍军人节 | 11月11日 | 当这个假日落在周末时，为周五/周一假日。|'
- en: '| Thanksgiving | Fourth Thursday of November |  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 感恩节 | 11月的第四个星期四 |  |'
- en: '| Christmas | December 25 | Friday/Monday holiday when this holiday occurs
    on a weekend. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 圣诞节 | 12月25日 | 当这个假日落在周末时，为周五/周一假日。|'
- en: Some holidays, such as Independence Day and Christmas, are specific to a day
    and date, though the holiday is often observed on the Friday or Monday after it
    falls on a weekend. Other holidays float based on the week of the month or other
    factors, as noted in table 12.2.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一些假日，如独立日和圣诞节，是特定于某一天和日期的，尽管假日通常在周末之后的周五或周一庆祝。其他假日则根据月份的周数或其他因素变动，如表12.2所示。
- en: 'When calculating a holiday, you can set two dates: the holiday’s actual date
    and the date on which the holiday is observed. Most calendars I’ve seen show both,
    such as Christmas and Christmas Observed. Adding such programming is shown later
    in this chapter, such as when a holiday falls on a Sunday and the celebration
    is on Monday.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算假日时，你可以设置两个日期：假日的实际日期和假日被观察的日期。我所见到的多数日历都显示了这两个日期，例如圣诞节和圣诞节观察日。在本章后面将展示如何添加此类编程，例如当假日落在星期日时，庆祝活动在星期一。
- en: 12.3.2 Discovering holidays in the UK
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 在英国发现假日
- en: As one of the rebels, I have no idea which days are celebrated as holidays in
    the United Kingdom—or any other country, for that matter. From Dickens, I know
    that Christmas is a thing in England, at least. I doubt the British celebrate
    George Washington’s birthday—well, perhaps not the way we do in the States. The
    rest of the UK holidays seem to be bank holidays, most likely celebrating the
    greatest banks in Britain. Even people who don’t work in a bank get the day off,
    supposedly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名叛乱者，我并不知道在英国（或者任何其他国家，实际上）哪些日子被庆祝为假日。从狄更斯的作品中，我知道在英格兰圣诞节至少是一个节日。我怀疑英国人不会像我们在美国那样庆祝乔治·华盛顿的生日——好吧，也许不是以同样的方式。其他英国的假日似乎都是银行假日，很可能是为了庆祝英国最大的银行。即使不在银行工作的人也能得到一天的休息，据说是这样。
- en: 'Table 12.3 lists UK national holidays as reported by the internet. Only three
    of them are tied to a specific date: New Year’s Day, Christmas, and Boxing Day.
    If any of these holidays falls on Saturday or Sunday, the day off is the following
    Monday. If Christmas or Boxing Day takes place on the weekend, it’s possible to
    see both Monday and Tuesday off, frequently with Tuesday as the day off for Christmas,
    for some reason.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.3列出了互联网上报道的英国国家假日。其中只有三个与特定日期相关：新年、圣诞节和节礼日。如果这些假日中的任何一个是星期六或星期日，那么放假日将是下一个星期一。如果圣诞节或节礼日发生在周末，可能会看到星期一和星期二都放假，不知何故，星期二通常是圣诞节的放假日。
- en: Table 12.3 UK national holidays
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.3 英国国家假日
- en: '| Holiday | Date |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 假日 | 日期 |'
- en: '| New Year’s Day | January 1 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 新年 | 1月1日 |'
- en: '| Good Friday | Friday before Easter |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 耶稣受难日 | 复活节前的星期五 |'
- en: '| Easter Monday | Monday after Easter |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 复活节星期一 | 复活节后的星期一 |'
- en: '| Early May Bank Holiday | First Monday of May |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 五一银行假日 | 五月的第一个星期一 |'
- en: '| Spring Bank Holiday | Last Monday of May |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 春季银行假日 | 五月的最后一个星期一 |'
- en: '| Summer Bank Holiday | Last Monday of August |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 夏季银行假日 | 八月的最后一个星期一 |'
- en: '| Christmas Day | December 25 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 圣诞节 | 12月25日 |'
- en: '| Boxing Day | December 26 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 节礼日 | 12月26日 |'
- en: 'The Easter holiday floats depending on when Easter falls. You must use an algorithm
    to calculate these holidays: Easter and Good Friday. Such code is presented later
    in this chapter.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 复活节假日会根据复活节的日期而变动。你必须使用算法来计算这些假日：复活节和耶稣受难日。此类代码将在本章后面展示。
- en: 'Don’t worry, my English, Irish, Scottish, and Welsh friends: I shan’t be writing
    any code to detect holidays in the UK. That’s your job. Given the information
    presented in this chapter, the task is quite doable.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我的英国、爱尔兰、苏格兰和威尔士的朋友们：我不会编写任何代码来检测英国的假日。那是你们的工作。根据本章提供的信息，这项任务是可以完成的。
- en: 12.4 Is today a holiday?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 今天是假日吗？
- en: Humans enjoy plenty of clues about impending holidays. For example, every August,
    shoppers at Costco are thrilled to see Christmas decorations up for sale. And
    who can forget early March with all the green shamrocks and cheery leprechauns
    reminding us of Easter? These cultural clues mean nothing to a computer—unless
    you, the programmer, are willing to help.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 人类对即将到来的假日有很多线索。例如，每年八月，Costco的购物者都会兴奋地看到圣诞节的装饰品上架。还有谁能忘记三月初，到处都是绿色的三叶草和快乐的精灵提醒我们复活节呢？这些文化线索对计算机来说毫无意义——除非你，程序员，愿意帮忙。
- en: 'For a computer holiday detector, three timely tidbits are necessary:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个计算机假日检测器来说，需要三个及时的小贴士：
- en: The month number
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份编号
- en: The day of the month
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份中的某一天
- en: The day of the week
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星期几
- en: With these three items known, it’s possible for a computer to identify a date
    as a holiday.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这三个项目后，计算机可以识别一个日期为假日。
- en: For the remainder of this chapter, I use holidays in the United States. The
    same techniques demonstrated can also be used to detect holidays in other countries,
    providing they follow a consistency on the solar calendar. I don’t cover how to
    map lunar holidays to solar holidays, except for Easter later in this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我将使用美国的假日。所展示的相同技术也可以用来检测其他国家的假日，前提是它们遵循太阳历的一致性。我不会介绍如何将农历假日映射到太阳历假日，除了在本章后面的复活节。
- en: 12.4.1 Reporting regular date holidays
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1 报告常规日期假日
- en: 'The easiest holidays to report are the predictable ones—what I call the regular
    date holidays. Each of these is fixed to a specific month and day:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易报告的假日是可预测的——我称之为常规日期假日。每个这样的假日都固定在特定的月份和日期：
- en: New Year’s Day, January 1
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元旦，1月1日
- en: Juneteenth, June 19
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立日，6月19日
- en: Independence Day, July 4
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立日，7月4日
- en: Veterans Day, November 11
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退伍军人节，11月11日
- en: Christmas Day, December 25
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣诞节，12月25日
- en: 'To report these dates, I use the *isholiday()* function. Here’s the prototype:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 报告这些日期，我使用 *isholiday()* 函数。下面是这个函数的原型：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The function’s only argument is the address of a tm structure, the same structure
    returned from the *localtime()* function and used by the *mktime()* function.
    Reusing this structure is convenient for this stage in the *isholiday()* function’s
    evolution.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的唯一参数是一个 tm 结构的地址，这个结构是由 *localtime()* 函数返回并由 *mktime()* 函数使用的。在 *isholiday()*
    函数的这个阶段重用这个结构很方便。
- en: 'The *isholiday()* function shown next returns an integer value: 0 for nonholiday
    days and 1 for a holiday. The function does a straight-up comparison of month-and-day
    values to report the regular date holidays, as shown in the listing. Please note
    that the month values used start with zero for January.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 *isholiday()* 函数返回一个整数值：非假日为0，假日为1。该函数直接比较月份和日期值来报告常规日期假日，如列表所示。请注意，所使用的月份值从1月开始为零。
- en: Listing 12.6 The *isholiday()* function
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.6 *isholiday()* 函数
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ New Year’s Day
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 元旦
- en: ❷ Juneteenth
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 独立日
- en: ❸ Independence Day
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 独立日
- en: ❹ Veterans Day
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 退伍军人节
- en: ❺ Christmas
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 圣诞节
- en: 'The *main()* function calls the *time()* and *localtime()* functions to obtain
    the current time info and pack it into the tm structure. This structure is passed
    to *isholiday()* and the results reported. You can find the full source code at
    the online repository as isholiday01.c. Here is a sample run:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*main()* 函数调用 *time()* 和 *localtime()* 函数来获取当前时间信息并将其打包到 tm 结构中。这个结构被传递给 *isholiday()*
    并报告结果。你可以在在线仓库中找到完整的源代码，即 isholiday01.c。下面是一个示例运行：'
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For my first update to the *isholiday()* function, I’d like the function to
    report the holiday’s name. To make this improvement, the tm structure must be
    ditched as the *isholiday()* function’s argument. Instead, I use a new structure
    holiday, defined with these members:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我对 *isholiday()* 函数的第一个更新，我希望该函数能够报告假日的名称。为了实现这个改进，必须放弃使用 tm 结构作为 *isholiday()*
    函数的参数。相反，我使用了一个新的结构 holiday，它具有以下成员：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The month and day members match up to the tm_mon and tm_mday members of the
    tm structure. The name member is a *char* pointer to hold the holiday’s name.
    The strings assigned to this pointer are declared in the *isholiday()* function,
    as shown in the following listing. There you also see the updates to each *if*
    decision, which now assigns the name member of the holiday structure passed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 月份和日期成员与 tm 结构的 tm_mon 和 tm_mday 成员相匹配。名称成员是一个 *char* 指针，用于存储假日的名称。分配给这个指针的字符串在
    *isholiday()* 函数中声明，如下所示。在那里，你还可以看到对每个 *if* 判断的更新，现在它将 holiday 结构的名称成员分配过去。
- en: Listing 12.7 The *isholiday()* function updated to return the holiday name
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.7 更新后的 *isholiday()* 函数以返回假日名称
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ The holiday structure must be passed as a pointer because the name member
    is modified within this function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 假期结构必须作为指针传递，因为在这个函数中修改了名称成员。
- en: ❷ Strings assigned to holidays in chronological order
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按时间顺序分配给假日的字符串
- en: ❸ Assigns the name member
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 分配名称成员
- en: ❹ Returns 1 for a true holiday
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于真正的假期返回1
- en: ❺ The pattern is repeated for each of the five holidays.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对五个假日中的每一个重复此模式。
- en: ❻ Returns 0 when the date isn’t a holiday
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当日期不是假日时返回0
- en: 'The *main()* function is also updated to assign values to the holiday structure
    declared there. The output statements are also modified to output the named holiday.
    For example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*main()* 函数也进行了更新，以分配那里声明的假期结构中的值。输出语句也进行了修改，以输出命名的假期。例如：'
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full source code for this update is found in the online repository as isholiday02.c.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新的完整源代码可在在线存储库中找到，即 isholiday02.c。
- en: The holidays detected so far are absolute. If you were creating a calendar (see
    chapter 13) and you wanted to color-code the holidays red, the *isholiday()* function
    properly reports the values. But if you wanted to note when the holiday is observed,
    more coding is necessary.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前检测到的假日是绝对的。如果你在创建日历（见第13章）并想用红色标记假日，*isholiday()* 函数会正确报告值。但如果你想记录假日是如何庆祝的，就需要更多的编码。
- en: 'Specifically, when one of these holidays falls on a weekend, it’s often the
    Friday before or the Monday after that everyone takes a day off: when Independence
    Day (July 4) is on a Sunday, the country takes off Monday, July 5\. Though when
    this type of holiday falls on a Tuesday, Wednesday, or Thursday, the day before
    or after isn’t considered a holiday, even though some people, mostly the lazy,
    take additional days.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，当这些假日中的任何一个落在周末时，通常是那个周末的前一个星期五或后一个星期一，大家都会休息一天：当独立日（7月4日）在星期日时，国家会在7月5日星期一休息。尽管当这种类型的假日落在星期二、星期三或星期四时，前一天或后一天并不被视为假日，尽管有些人，主要是懒惰的人，会额外休息几天。
- en: To update the code for isholiday02.c, and to improve the *isholiday()* function,
    some changes are in order. These changes account for those times when the holiday
    falls on a weekend.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新 isholiday02.c 的代码，并改进 *isholiday()* 函数，需要进行一些更改。这些更改考虑了假日落在周末的情况。
- en: 'First comes an update to the holiday structure, which adds a new member, wday.
    This member echoes the tm_wday member of the tm structure. It indicates a day
    of the week—0 for Sunday through 6 for Saturday. Here is the updated definition:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是对假期结构进行更新，它添加了一个新成员 wday。这个成员与 tm 结构中的 tm_wday 成员相呼应。它表示一周中的某一天——0代表星期日，6代表星期六。以下是更新的定义：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because only two days are required for testing, I also added two defined constants:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因为测试只需要两天，所以我添加了两个定义的常量：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When New Year’s Day is observed on a Friday, the date is December 31 of the
    prior year. This difference makes the New Year’s Day test a bit more complex than
    the other Friday/Monday tests. The next listing shows the code necessary to make
    the New Year’s Day test, which isn’t as elegant as the other holiday tests due
    to the year-before overlap.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当新年假日在星期五庆祝时，日期是前一年的12月31日。这种差异使得新年假日的测试比其他星期五/星期一测试要复杂一些。下面的列表显示了进行新年假日测试所需的代码，由于前一年的重叠，这个测试并不像其他假日测试那样优雅。
- en: Listing 12.8 Statements to detect New Year’s Day and any Friday/Monday celebrations
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.8 检测新年假日和任何星期五/星期一庆祝的语句
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Specifically checks for Friday, December 31
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 特别检查12月31日星期五
- en: ❷ Returns 2 for “celebration” holidays
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于“庆祝”假期返回2
- en: ❸ Checks for New Year’s Day
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查新年假日
- en: ❹ Returns 1 for the real holiday
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于实际假期返回1
- en: ❺ Specifically checks for Monday, January 2
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 特别检查1月2日星期一
- en: ❻ Returns 2 for “celebration” holidays
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于“庆祝”假期返回2
- en: 'The new return code from the *isholiday()* function is 2, as shown in listing
    12.8\. This value is handled uniquely in the *main()* function, which is found
    in the complete update source code file, isholiday03.c. Here is a sample run for
    a nonholiday:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*isholiday()* 函数的新返回代码是2，如列表12.8所示。这个值在 *main()* 函数中被独特处理，该函数位于完整的更新源代码文件 isholiday03.c
    中。以下是一个非假日的示例运行：'
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And for a holiday:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个假日：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And a Monday holiday:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 周一假期：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the code, however, I notice something that bothers me: After New Year’s
    Day is determined, the next four holidays all share similar statements. For example,
    the construction for Juneteenth is shown in the next listing. The structure of
    this code matches the structure used to test for the next three holidays. All
    that changes are the specific day values. That’s a lot of repetitious code.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在代码中，我发现了一些让我烦恼的事情：确定新年之后，接下来的四个假日都使用了类似的表达式。例如，Juneteenth的构造在下一个列表中显示。这段代码的结构与测试下一个三个假日的结构相同。唯一不同的是具体的日期值。这有很多重复的代码。
- en: Listing 12.9 Statements to detect Juneteenth and other holidays
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.9 检测Juneteenth和其他假日的语句
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Juneteenth is always in June.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Juneteenth总是在六月。
- en: ❷ Focuses on the relevant days, before (18), the day (19), and after (20)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 关注相关日期，包括之前（18），当天（19）和之后（20）
- en: ❸ Checks for the day before celebration
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查庆祝日之前的日期
- en: ❹ Returns 2 for celebration days
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于庆祝日返回2
- en: ❺ Checks for the day after celebration
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查庆祝日之后的日期
- en: ❻ Returns 2 for celebration days
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于庆祝日返回2
- en: ❼ Checks for the actual holiday
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 检查实际假日
- en: ❽ Returns 1 for the holiday
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 对于假日返回1
- en: 'Whenever I see such repetition in my code, it cries out for a function. The
    function I created is named *weekend()*. Here is its prototype:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我看到我的代码中有这样的重复时，它都会大声呼吁创建一个函数。我创建的函数名为*weekend()*。以下是它的原型：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The function has three arguments. Integer holiday is the day of the month on
    which the holiday occurs. Integers mday and wday are the day of the month and
    day of the week values, respectively. These three items represent the different
    values that change for each holiday test in the *isholiday()* function from source
    code file isholiday03.c.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有三个参数。整数holiday是假日发生的月份中的日期。整数mday和wday分别是月份中的日期和星期中的日期值。这三个项目代表了*isholiday()*函数中每个假日测试从源代码文件isholiday03.c中变化的不同值。
- en: The following listing shows the *weekend()* function. It contains most of the
    code shown in listing 12.9, the statements that repeat, but is modified to use
    variables instead of specific day-of-the-month values. This code evaluates the
    days before and after the holiday, Friday and Monday, to determine celebration
    days. The only item not addressed in the function is the string assignment for
    the holiday name.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了*weekend()*函数。它包含了列表12.9中显示的大部分代码，重复的语句，但已修改为使用变量而不是具体的月份日期值。此代码评估假日之前和之后的日期，星期五和星期一，以确定庆祝日。函数中没有处理的是假日名称的字符串赋值。
- en: Listing 12.10 The *weekend()* function from isholiday04.c
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.10 isholiday04.c中的*weekend()*函数
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Narrows down the days to search
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 窄化搜索的日期
- en: ❷ Tests for the Friday before the holiday
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试假日之前的星期五
- en: ❸ Tests for the Monday after the holiday
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试假日之后的星期一
- en: ❹ Tests for the holiday date itself
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测试假日日期本身
- en: ❺ Returns zero for no matches
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于没有匹配项返回0
- en: This function’s update is found in the online repository as isholiday04.c. The
    *isholiday()* function is also updated to account for passing most of the work
    to the *weekend()* function. The code reads more cleanly than it did before.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的更新可以在在线仓库中找到，文件名为isholiday04.c。*isholiday()*函数也进行了更新，以便将大部分工作传递给*weekend()*函数。代码比之前读起来更清晰。
- en: Further improvements could be made to the *isholiday()* function. But first,
    the irregular holidays must be dealt with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对*isholiday()*函数进行进一步的改进。但首先，必须处理不规则假日。
- en: 12.4.2 Dealing with irregular holidays
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.2 处理不规则假日
- en: 'Unlike specific date holidays, irregular holidays occur on specific weeks and
    days of the month. The day is Monday, save for Thanksgiving, which takes place
    on a Thursday. These holidays are irregular in that they fall within a range of
    dates each year, so the program must think harder about when these holidays occur.
    As a review, here are the irregular holidays in the United States:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与具体日期的假日不同，不规则假日发生在每月的特定周和日。除了感恩节在星期四之外，这些假日都是星期一。这些假日是不规则的，因为它们每年都落在日期范围内，所以程序必须更深入地思考这些假日发生的时间。作为回顾，以下是美国的非规则假日：
- en: Martin Luther King Jr. Day, third Monday of January
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·路德·金纪念日，一月的第三个星期一
- en: Presidents Day, third Monday of February
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国庆日，二月的第三个星期一
- en: Memorial Day, last Monday of May
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阵亡将士纪念日，五月的最后一个星期一
- en: Labor Day, first Monday of September
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 劳动节，九月的第一个星期一
- en: Columbus Day, second Monday of October
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哥伦布日，十月的第二个星期一
- en: Thanksgiving, fourth Thursday of November
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感恩节，十一月的第四个星期四
- en: Unlike the regular date holidays, you don’t need to worry about a shifting observance
    day; these are all specific day-of-the-week holidays. This consistency means that
    it’s possible to calculate a day-of-the-month range for each holiday. I’ve summarized
    the day ranges in table 12.4 for weeks in a month.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的日期假日不同，你不需要担心观察日的变动；这些都是特定星期的假日。这种一致性意味着可以为每个假日计算一个月中的日期范围。我已经在表12.4中总结了每周的日期范围。
- en: Table 12.4 Day ranges for Monday holidays on a given week
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.4 某周星期一假日的日期范围
- en: '| Week of month | Monday range |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 月份中的周 | 周一范围 |'
- en: '| First | 1 to 7 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 第一 | 1 至 7 |'
- en: '| Second | 8 to 14 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 第二 | 8 至 14 |'
- en: '| Third | 15 to 21 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 第三 | 15 至 21 |'
- en: '| Fourth | 22 to 28 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 第四 | 22 至 28 |'
- en: '| Last | 25 and higher |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 最后 | 25 及以上 |'
- en: 'The difference between the fourth and last week occurs in those months with
    five Mondays, such as May, shown in figure 12.1: when the 31st of May falls on
    a Monday, it’s the fifth Monday. The 24th of May is still in the fourth week (refer
    to table 12.3), but in this month configuration, where the 31st is on a Monday,
    it’s the last day. This reason is why the last week has a different range than
    the fourth week.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第四周和最后一周之间的差异出现在那些有五个周一的月份中，例如5月，如图12.1所示：当5月31日是星期一时，它是第五个周一。5月24日仍然在第四周（参见表12.3），但在这种月份配置中，由于31日是星期一，它是最后一天。这就是为什么最后一周的日期范围与第四周不同的原因。
- en: '![12-01](Images/12-01.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![12-01](Images/12-01.png)'
- en: Figure 12.1 A configuration of May, with five Mondays
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 五个周一的5月配置
- en: For Thanksgiving, the final Thursday of the month could fall on any day from
    the 22nd through the 28th. This value is shown in the fourth row in Table 12.3,
    which also applies to Thursdays.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于感恩节，该月的最后一个星期四可能从22日到28日的任何一天。这个值在表12.3的第四行中显示，也适用于星期四。
- en: 'The *isholiday()* function is nearly complete when these final, irregular holidays
    are coded. To help do so, I created a few macros and added the THURSDAY defined
    constant:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些最终的不规则假日被编码时，*isholiday()* 函数几乎完成。为了帮助这样做，我创建了一些宏并添加了定义的常量 THURSDAY：
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The weekday holidays fall on Friday, Monday, or Thursday, so the defined constants
    add readability to the code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 工作日假日落在星期五、星期一或星期四，因此定义的常量增加了代码的可读性。
- en: 'The macros shown here relate to the date values presented in table 12.3\. The
    variable h->day is used in the *isholiday()* function. These macros add readability
    to the function. For example, this code doesn’t use the macro:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的宏与表12.3中呈现的日期值相关。变量 h->day 在 *isholiday()* 函数中使用。这些宏增加了函数的可读性。例如，此代码没有使用宏：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But this code, which does the same thing as the previous snippet, is far more
    readable:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但这段代码与之前的代码片段做的是同样的事情，但可读性要好得多：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To avoid any confusion, the entire, updated code for the *isholiday()* function
    is shown in the next listing. I recognize that it’s a bit long, but it shows all
    the code to capture the 12 annual holidays in the United States, save for Easter,
    which is covered in the next section. Aside from New Year’s Day, pay attention
    to the patterns used for the regular and irregular holidays. Not shown in the
    listing are the *weekend()* and *main()* functions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免任何混淆，*isholiday()* 函数的整个更新代码在下一个列表中显示。我承认它有点长，但它显示了捕获美国12个年度假日的所有代码，除了复活节，它将在下一节中介绍。除了元旦之外，请注意常规和不规则假日使用的模式。列表中没有显示
    *weekend()* 和 *main()* 函数。
- en: Listing 12.11 The *isholiday()* function
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.11 *isholiday()* 函数
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ New Year’s Day
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 元旦
- en: ❷ Martin Luther King Jr. Day
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 马丁·路德·金纪念日
- en: ❸ Presidents Day
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 国庆日
- en: ❹ Memorial Day
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 阵亡将士纪念日
- en: ❺ Juneteenth
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 美国解放日
- en: ❻ Independence Day
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 独立日
- en: ❼ Labor Day
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 劳动节
- en: ❽ Columbus Day
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 哥伦布日
- en: ❾ Veterans Day
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 退伍军人节
- en: ❿ Thanksgiving
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 感恩节
- en: ⓫ Christmas
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 圣诞节
- en: 'Here is a sample run of the program for a nonholiday:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是程序非假日运行的一个示例：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And for a holiday:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以及假日的一个示例：
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After testing this code more thoroughly, I discovered a flaw for calculating
    Veterans Day and Thanksgiving, both of which occur in November. Here is the relevant
    code chunk:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在更彻底地测试这段代码后，我发现了一个计算退伍军人节和感恩节的缺陷，这两个节日都发生在11月。以下是相关的代码片段：
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first *if* test captures all dates for November and returns. This exit means
    that the next *if* test for November, h->month==10, never occurs. Oops.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 *if* 测试捕获了11月所有的日期并返回。这种退出意味着下一个针对11月的 *if* 测试 h->month==10 永远不会发生。哎呀。
- en: 'To remedy the situation, a single *if* test must be done for November. Then
    a test can be made for Thanksgiving and then Veterans Day. Here is the udpated
    code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，必须对11月进行单个*if*测试。然后可以对感恩节和退伍军人节进行测试。以下是更新的代码：
- en: '[PRE41]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this change made, the code now faithfully reports both Thanksgiving and
    Veterans Day. All these updates and additions are found in the full source code
    listing, isholiday05.c, available in the online repository.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 进行了此更改后，代码现在忠实地报告了感恩节和退伍军人节。所有这些更新和添加都可以在完整的源代码列表isholiday05.c中找到，该列表可在在线存储库中找到。
- en: 'The only holiday left is the most difficult to calculate: Easter.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一假日是最难计算的：复活节。
- en: Exercise 12.2
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12.2
- en: In a major update to the code, add constants for the months of the year. Use
    these constants in the *isholiday()* function so that this comparison
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的主要更新中，添加了代表一年中各月份的常量。在*isholiday()*函数中使用这些常量，以便进行此比较
- en: '[PRE42]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'now reads like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来是这样的：
- en: '[PRE43]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: My solution is available in the online repository as isholiday06.c. For bonus
    points, see if you can use enumerated constants, which is what I did.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案在在线存储库中作为isholiday06.c提供。为了加分，看看你是否可以使用枚举常量，这是我所做的事情。
- en: 12.4.3 Calculating Easter
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.3 计算复活节
- en: Easter falls on different dates each year because it’s the last holiday remaining
    in Western culture based on the lunar calendar. On the solar calendar, the date
    of Easter can be as early as March 22 or as late as April 25\. It’s always on
    a Sunday.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 复活节每年都在不同的日期，因为它是在西方文化中基于农历的最后一个剩余假日。在阳历中，复活节的日期可以是3月22日或4月25日，总是在星期日。
- en: For the lunar calendar, Easter is the first Sunday after the first new moon
    after the vernal equinox. This date is based on the Jewish holiday of Passover.
    So, first comes the spring equinox, when the sun returns to the northern hemisphere
    and Hades releases Persephone from the underworld. The next full moon—which could
    be weeks away—must pass, and then the following Friday is Passover with Easter
    falling on Sunday.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于农历，复活节是春分后的第一个新月后的第一个星期日。这个日期基于犹太人的逾越节。所以，首先是春分，当太阳返回北半球，哈迪斯从冥界释放珀耳塞福涅。下一个满月——可能要过几周——必须过去，然后下一个星期五是逾越节，复活节在星期日。
- en: In my original holiday-detector program, written years ago, I hardcoded the
    date for Easter. It was easy but not a long-lasting solution.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在我多年前编写的原始假日检测程序中，我硬编码了复活节的日期。这很容易，但不是一种持久的解决方案。
- en: As with determining the moon phase (refer to chapter 2), the date of Easter
    is best calculated by using an algorithm. As with the moon algorithm, I have no
    idea what’s going on with my Easter algorithm; I just copied it down. But unlike
    the moon phase algorithm, the Easter algorithm is extremely accurate.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与确定月亮相位（参见第2章）一样，复活节的日期最好通过算法来计算。与月亮算法一样，我对我的复活节算法正在发生什么一无所知；我只是把它记下来。但与月亮相位算法不同，复活节算法非常精确。
- en: 'Just a guess: a lot of what you see in the next listing deals with mapping
    the moon’s cycle to the solar year, as well as accounting for leap years. What
    a wonder! The value passed to the easter() function represents a year. No value
    is returned, because the function itself outputs the date of Easter. Building
    this code requires inclusion of the math.h header file, which implies that you
    link in the math library for many platforms: use the -lm (little L) switch, specified
    last when building at the command prompt.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 只是一个猜测：在接下来的列表中，你看到的大部分内容都与将月亮的周期映射到太阳年以及计算闰年有关。多么奇妙！传递给easter()函数的值代表一个年份。没有返回值，因为函数本身输出复活节的日期。构建此代码需要包含math.h头文件，这意味着你需要在许多平台上链接数学库：在命令提示符构建时使用-lm（小写的L）开关，指定在构建时最后使用。
- en: Listing 12.12 The *easter()* function from source code file easter01.c
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.12 来自源代码文件easter01.c的*easter()*函数
- en: '[PRE44]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Accepts a year value as the only argument
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅接受年份值作为唯一参数
- en: ❷ Lots of int variables
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 许多整型变量
- en: ❸ Lots of double variables
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 许多双变量
- en: ❹ Math goes on for a while.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 数学运算持续了一段时间。
- en: ❺ Obtains the month for Easter, either 3 (March) or 4 (April)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取复活节的月份，即3月（三月）或4月（四月）
- en: ❻ Obtains the day of the month
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 获取月份
- en: ❼ Outputs results
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 输出结果
- en: 'The full source code file including the *easter()* function is available in
    the online repository as easter01.c. What’s missing from listing 12.13 is the
    *main()* function. It contains a loop that calls the *easter()* function with
    year values from 2018 through 2035:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 *easter()* 函数的完整源代码文件 easter01.c 可在在线仓库中找到。列表 12.13 中缺少的是 *main()* 函数。它包含一个循环，该循环使用从
    2018 年到 2035 年的年份值调用 *easter()* 函数：
- en: '[PRE45]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Merging the *easter()* into the *isholiday()* function requires too much work.
    Instead, I sought to include *easter()* as a companion function called by *isholiday()*—like
    the *weekend()* function already in the code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *easter()* 合并到 *isholiday()* 函数中需要太多的工作。相反，我寻求将其作为由 *isholiday()* 调用的伴随函数包含进来——就像代码中已经存在的
    *weekend()* 函数一样。
- en: 'The *easter()* function must be modified to accept a date value and return
    1 or 0 depending on whether the date matches Easter for the given year. To begin
    this journey, a few changes are required to update the existing *isholiday* code.
    First, the holiday structure must be modified to also include a year member:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 必须修改 *easter()* 函数以接受一个日期值，并根据给定的年份返回 1 或 0，表示日期是否与复活节匹配。为了开始这段旅程，需要对现有的 *isholiday*
    代码进行一些更改。首先，必须修改假日结构以包括一个年份成员：
- en: '[PRE46]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Second, the year member’s value must be assigned in the *main()* function:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，必须在 *main()* 函数中分配年份成员的值：
- en: '[PRE47]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember to add 1900 to the year value!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将 1900 加到年份值上！
- en: Third, a call must be made to *easter()* in the *isholiday()* function. At the
    start of the function, a string for Easter is added to the n[] pointer array.
    I chose to add the string at the end, which doesn’t upset the existing array numbering
    elsewhere in the function. The "Easter" string is last in the array declaration,
    n[11].
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，必须在 *isholiday()* 函数中调用 *easter()*。在函数开始时，将复活节字符串添加到 n[] 指针数组中。我选择将其添加到末尾，这样不会影响函数其他部分的现有数组编号。"Easter"
    字符串是数组声明中的最后一个，即 n[11]。
- en: 'These statements in the *isholiday()* function call the *easter()* function.
    They are the last few statements in the function, right before the final return:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *isholiday()* 函数中的这些语句调用 *easter()* 函数。它们是函数中的最后几条语句，就在最终返回之前：
- en: '[PRE48]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The next listing shows the updated *easter()* function, changed to accommodate
    a holiday structure pointer as its argument and to return 1 or 0, whether the
    current date is or is not Easter, respectively.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了更新的 *easter()* 函数，该函数已修改以接受一个假日结构指针作为参数，并返回 1 或 0，分别表示当前日期是否为复活节。
- en: Listing 12.13 The updated *easter()* function as it sits in source code isholiday07.c
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.13：更新后的 *easter()* 函数，如源代码文件 isholiday07.c 中的样子
- en: '[PRE49]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ The function definition is changed, accepting structure pointer hday and returning
    an int value.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数定义已更改，接受结构指针 hday 并返回一个整型值。
- en: ❷ I couldn’t use variable h as the function’s argument because it’s already
    used in the algorithm and I don’t want to mess with it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我不能使用变量 h 作为函数的参数，因为它已经在算法中使用，并且我不想对其进行修改。
- en: ❸ Subtracts one from the final month value because January is zero in this code
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从最终月份值中减去 1，因为在这段代码中 1 月份是 0
- en: ❹ Tests to see whether today is Easter
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测试今天是否是复活节
- en: ❺ Returns 1 if it is
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果是，则返回 1
- en: ❻ Returns 0 otherwise
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 否则返回 0
- en: Finally, remember to add the math.h header file so that the compiler doesn’t
    barf over the *floor()* function used in the *easter()* function. And ensure that
    when you build the code, you link in the math library, -lm (little L). All these
    changes and updates are found in the source code file isholiday07.c, available
    from this book’s online repository.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记得添加 math.h 头文件，以免编译器因为 *easter()* 函数中使用的 *floor()* 函数而出错。并且确保在构建代码时链接 math
    库，-lm（小写的 L）。所有这些更改和更新都可以在源代码文件 isholiday07.c 中找到，该文件可在本书的在线仓库中获取。
- en: 'The code runs as it did before, but now it recognizes Easter. Here is a sample
    run for Easter 2022:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 代码运行方式与之前相同，但现在它能够识别复活节。以下是对 2022 年复活节的示例运行：
- en: '[PRE50]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 12.4.4 Running the date gauntlet
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.4 运行日期关卡
- en: To test the *isholiday()* function, you must run it through the date gauntlet.
    This test is how I refer to a program that generates dates from January 1 through
    December 31 for a given year. The goal is to ensure that the *isholiday()* function
    properly reacts, reporting the national holidays.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 *isholiday()* 函数，必须运行它通过日期关卡。这个测试是指一个程序，它为给定年份生成从 1 月 1 日到 12 月 31 日的日期。目标是确保
    *isholiday()* 函数能够正确反应，报告国家假日。
- en: 'The next listing shows the code for gauntlet01.c. It contains two arrays of
    string constants to represent months and days of the week. The mdays[] array lists
    the number of days in each month, where it’s assumed the year isn’t a leap year;
    February has only 28 days in the code. The dates are output in a nested loop:
    the outer loop processes months, and the inner loop churns days of the month.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了gauntlet01.c的代码。它包含两个字符串常量数组，用于表示月份和星期。mdays[]数组列出了每个月的天数，假设年份不是闰年；代码中二月只有28天。日期通过嵌套循环输出：外循环处理月份，内循环处理月份中的天数。
- en: Listing 12.14 Source code for gauntlet01.c
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.14 gauntlet01.c的源代码
- en: '[PRE51]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Determines days of each month, assuming it isn’t a leap year
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确定每个月的天数，假设不是闰年
- en: ❷ Shortcuts for January 1, starting day of the week
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 1月1日的快捷方式，星期几的起始日
- en: ❸ Sets the starting day for 2022, Saturday
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置2022年的起始日，星期六
- en: ❹ The first day of the year
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 年的第一天
- en: ❺ The year to be output (not a leap year)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 要输出的年份（非闰年）
- en: ❻ Loops through 12 months of the year
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 遍历一年的12个月
- en: ❼ Loops through each day of the month
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 遍历每个月的每一天
- en: ❽ Scary math to determine the proper day of the week
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 用于确定正确星期几的恐怖数学
- en: ❾ Increments the day of the year
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 增加年份的天数
- en: The math in the code determines the proper day of the week. This detail is based
    on the start_day variable set to the proper day of the week for January 1, which
    is a Saturday—enumerated constant SA in the code. The day-of-the-year variable,
    doy, is used in this calculation, incremented in the inner loop to keep track
    of each day of the year.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的数学确定正确的星期几。这个细节基于设置为1月1日正确星期几的start_day变量，即星期六——代码中的枚举常量SA。年中的日子变量doy用于这个计算，在内循环中递增以跟踪每年的每一天。
- en: 'The source code for gauntlet01.c is available in the online repository. Here
    is the abbreviated output:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: gauntlet01.c 的源代码可在在线仓库中找到。以下是简化的输出：
- en: '[PRE52]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These days all check out, matching up perfectly with the date and day of the
    week for the year 2022\. I changed some of the variables in the code to test other
    years as well, and it all works.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日期都经过验证，与2022年的日期和星期完全匹配。我还更改了一些代码中的变量来测试其他年份，并且一切正常。
- en: 'The next step is to add the functions *isholiday()*, *weekend()*, and *easter()*
    to the code—the entire *isholiday* package—to confirm that all holidays are properly
    tracked throughout the year. As the gauntlet code churns through days of the year,
    the *isholiday()* function is called. Only holidays are output. As a review, here
    are the US national holidays and their days and dates for 2022:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 *isholiday()*, *weekend()*, 和 *easter()* 函数添加到代码中——整个 *isholiday* 包——以确认全年都能正确跟踪所有假日。随着gauntlet代码遍历每年的每一天，*isholiday()*
    函数被调用。只有假日会被输出。作为复习，以下是2022年美国的全国假日及其日期：
- en: 'New Year’s Day: Saturday, January 1'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新年：星期六，1月1日
- en: 'Martin Luther King Jr. Day: Monday, January 17'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·路德·金纪念日：星期一，1月17日
- en: 'Washington’s Birthday/Presidents Day: Monday, February 21'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乔治·华盛顿诞辰/总统日：星期一，2月21日
- en: 'Easter: Sunday, April 17'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复活节：星期日，4月17日
- en: 'Memorial Day: Monday, May 30'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阵亡将士纪念日：星期一，5月30日
- en: 'Juneteenth: Sunday, June 19'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立日：星期日，6月19日
- en: 'Juneteenth observed: Monday, June 20'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立日观察日：星期一，6月20日
- en: 'Independence Day: Monday, July 4'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立日：星期一，7月4日
- en: 'Labor Day: Monday, September 5'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 劳动节：星期一，9月5日
- en: 'Columbus Day: Monday, October 10'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哥伦布日：星期一，10月10日
- en: 'Veterans Day: Friday, November 11'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退伍军人节：星期五，11月11日
- en: 'Thanksgiving: Thursday, November 24'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感恩节：星期四，11月24日
- en: 'Christmas: Sunday, December 25'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣诞节：星期日，12月25日
- en: 'Christmas Day observed: Monday, December 26'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣诞节观察日：星期一，12月26日
- en: 'The update to the code is found in the online repository as gauntlet02.c. It
    features only minor changes to the *main()* function for output formatting. Remember
    that this code requires linking of the math library, -lm (little L), so that the
    math functions in Easter all behave well. Here is the output:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的更新可以在在线仓库中找到，作为gauntlet02.c。它只对*main()*函数的输出格式进行了细微的更改。请记住，此代码需要链接数学库，-lm（小写的L），以便复活节中的数学函数表现良好。以下是输出：
- en: '[PRE53]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The *isholiday()* function can be incorporated into a variety of your source
    code files, or you can make it its own module to be linked in with special programs.
    This process is reviewed in chapter 13, which covers outputting a colorful calendar.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*isholiday()* 函数可以集成到您的各种源代码文件中，或者您可以将其作为单独的模块链接到特殊程序中。这个过程在第13章中有详细说明，该章节涵盖了输出彩色日历。'
