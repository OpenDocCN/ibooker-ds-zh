- en: Appendix B. Managing an API’s life cycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 管理API的生命周期
- en: APIs are very rarely static. As your product evolves, you need to expose new
    capabilities and features through your API, and this means that you will need
    to create new endpoints or change your schemas to introduce new entities or fields.
    Often, API changes are backward incompatible, which means clients who are unaware
    of the new changes will get failed responses to their requests. Part of managing
    an API is making sure that any changes you make don’t break the integrations that
    already exist with other applications, and API versioning serves that purpose.
    In this appendix, we study API versioning strategies to manage API changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: API很少是静态的。随着你的产品发展，你需要通过API公开新的功能和特性，这意味着你需要创建新的端点或更改你的模式以引入新的实体或字段。通常，API变更是不向后兼容的，这意味着未意识到新变更的客户端将收到失败的响应。管理API的一部分是确保你做出的任何变更都不会破坏与其他应用程序已经存在的集成，而API版本控制就是为了这个目的。在本附录中，我们研究API版本控制策略来管理API变更。
- en: In addition to evolving and changing, APIs also sometimes come to an end. Perhaps
    you’re migrating a REST API to GraphQL, or you’re ceasing a product altogether.
    If you’re planning to deprecate an API, you must let your clients know when and
    how it’ll happen, and in the second part of this appendix, you’ll learn to broadcast
    this information to your users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发展和变化之外，API有时也会结束。也许你正在将REST API迁移到GraphQL，或者你正在完全停止一个产品。如果你计划弃用API，你必须让你的客户知道何时以及如何发生，在本附录的第二部分，你将学习如何向用户广播此信息。
- en: B.1 Versioning strategies for evolving APIs
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 API版本控制策略
- en: 'Let’s see how we use versioning to manage API changes. We use two major types
    of versioning systems for APIs:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用版本控制来管理API变更。我们为API使用两种主要的版本控制系统：
- en: '*Semantic versioning* (SemVer, [https://semver.org/](https://semver.org/))—This
    is the most common type of versioning, and it is widely used to manage software
    releases. It has the following format: MAJOR.MINOR.PATCH, for example, 1.1.0\.
    The first number indicates the major version of the release, the second number
    indicates the minor version, and the third number indicates the patch version.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语义版本控制*（SemVer，[https://semver.org/](https://semver.org/)）——这是最常见的版本控制类型，它被广泛用于管理软件发布。其格式如下：MAJOR.MINOR.PATCH，例如，1.1.0。第一个数字表示发布的主版本号，第二个数字表示次版本号，第三个数字表示补丁版本号。'
- en: The major version changes whenever you make a breaking change to the API, for
    example, when a new field is required in a request payload. Minor versions represent
    nonbreaking changes to the API, such as the introduction of a new optional query
    parameter. Your API consumers expect to be able to keep calling your endpoints
    in the same way on different minor versions and continue to obtain responses.
    Patch versions indicate bug fixes.
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当你对API进行重大变更时，主版本号就会发生变化，例如，当请求负载中需要新的字段时。次版本号代表API的非破坏性变更，例如引入新的可选查询参数。API消费者期望能够在不同的次版本上以相同的方式调用你的端点，并继续获得响应。补丁版本表示错误修复。
- en: In the context of APIs, we typically only use the major version, so we may have
    v1 and v2 of an API. Minor changes and patches that improve the API can generally
    be rolled out without the risk of breaking existing integrations.
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在API的上下文中，我们通常只使用主版本号，所以我们可能有API的v1和v2版本。一般而言，改进API的次级变更和补丁可以安全地推出，而不会破坏现有的集成。
- en: Calendar versioning (CalVer, [https://calver.org/](https://calver.org/))—Calendar
    versioning uses calendar dates to version releases. This system is useful when
    your APIs change very often, or when your releases are time sensitive. An increasing
    number of software products use calendar versioning, including Ubuntu ([https://ubuntu.com/](https://ubuntu.com/)).
    AWS also uses calendar versioning in some of its products, such as CloudFormation
    ([http://mng.bz/epQZ](http://mng.bz/epQZ)) and the S3 API ([http://mng.bz/p6B0](http://mng.bz/p6B0)).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日历版本控制（CalVer，[https://calver.org/](https://calver.org/)）——日历版本控制使用日历来为发布版本。当你的API变更非常频繁，或者你的发布对时间敏感时，这个系统非常有用。越来越多的软件产品使用日历版本控制，包括Ubuntu
    ([https://ubuntu.com/](https://ubuntu.com/))。AWS也在其一些产品中使用了日历版本控制，例如CloudFormation
    ([http://mng.bz/epQZ](http://mng.bz/epQZ)) 和S3 API ([http://mng.bz/p6B0](http://mng.bz/p6B0))。
- en: CalVer does not provide a full specification about how to format your versions;
    it only emphasizes the use of dates. Some projects use the format YYYY.MM.DD,
    while others use YY.MM. If you make several releases per day, you can use an additional
    counter to keep track of each release, for example, 2022.12.01.3, which means
    this is the third release made on the 12th of December in 2022\. (For more details
    on calendar versioning, see [http://mng.bz/O6MO](http://mng.bz/O6MO).)
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CalVer没有提供关于如何格式化版本的完整规范；它只强调使用日期。一些项目使用YYYY.MM.DD的格式，而另一些则使用YY.MM。如果您每天发布多个版本，您可以使用额外的计数器来跟踪每个版本，例如，2022.12.01.3，这意味着这是在2022年12月12日发布的第三个版本。（有关日历版本化的更多详细信息，请参阅[http://mng.bz/O6MO](http://mng.bz/O6MO)。)
- en: 'Which type of versioning system is better? It depends on your specific needs
    and your overall API management strategy. SemVer is more commonly used since it’s
    more intuitive. However, if your product rollouts are time sensitive, CalVer is
    a better fit. Your choice of versioning system will also be affected by your versioning
    management strategy, so let’s take a look at the different methods we use to indicate
    the version of our APIs:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种版本控制系统更好？这取决于您的具体需求和整体API管理策略。SemVer因其直观性而被更广泛地使用。然而，如果您的产品发布对时间敏感，CalVer可能更适合。您选择的版本控制系统也将受到您的版本管理策略的影响，因此让我们看看我们用来表示API版本的不同方法：
- en: '*Versioning using the URL*—You can embed the API version in the URL, for example,
    [https://coffeemesh.com/api/v1/coffee](https://coffeemesh.com/api/v1/coffee).
    This is very convenient because consumers of your API know that they will always
    be able to call the same endpoint and get the same results. If you release a new
    version of your API, that version will go into a different URL path (/api/v2)
    and therefore will not conflict with your previous releases. It also makes your
    API easier to explore, since, to discover and test different versions of it, API
    consumers only need to change the version field in the URL. On the downside, when
    working with REST APIs, using the URL to manage versions is considered a violation
    of the principles of REST since every resource should be represented by one and
    only one URI.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用URL进行版本控制*—您可以将API版本嵌入到URL中，例如，[https://coffeemesh.com/api/v1/coffee](https://coffeemesh.com/api/v1/coffee)。这非常方便，因为您的API消费者知道他们始终能够调用相同的端点并获得相同的结果。如果您发布API的新版本，该版本将进入不同的URL路径（/api/v2），因此不会与之前的发布冲突。这也使得您的API更容易探索，因为要发现和测试其不同版本，API消费者只需更改URL中的版本字段。然而，在处理REST
    API时，使用URL来管理版本被认为违反了REST原则，因为每个资源应该只由一个且仅一个URI表示。'
- en: '*Versioning using the* `Accept` `Header` *field*—An API consumer uses the `Accept`
    HTTP request `Header` field to advertise the type of content they can parse. In
    the context of APIs, the typical value of the `Accept` `Header` is `application/json`,
    which means the client only accepts data in JSON format. Since the API version
    also influences the type of content we receive from the server, we can use the
    `Header` field to advertise which API version we want to use. An example of a
    `Header` field that specifies the content type and API version is `Accept: application/json;v1`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`Accept`头部字段进行版本控制*—API消费者使用`Accept` HTTP请求头部字段来声明他们可以解析的内容类型。在API的上下文中，`Accept`头部字段的典型值是`application/json`，这意味着客户端只接受JSON格式的数据。由于API版本也影响我们从服务器接收的内容类型，我们可以使用`Header`字段来声明我们想要使用的API版本。一个指定内容类型和API版本的`Header`字段示例是`Accept:
    application/json;v1`。'
- en: 'This approach is more harmonious with the principles of REST since it does
    not modify the resource endpoints, but it requires careful parsing. Introducing
    additional characters in the header’s value, as in the following snippet, can
    cause errors at runtime:'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法与REST原则更为和谐，因为它不修改资源端点，但需要仔细解析。在头部值中引入额外的字符，如以下片段所示，可能导致运行时错误：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since we’re using the `Accept` header, we respond with a 415 (Unsupported Media
    Type) to any errors in the API version declaration, or when the client requests
    an unavailable version of the API.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们使用`Accept`头部，对于API版本声明中的任何错误，或者当客户端请求不可用的API版本时，我们以415（不支持的媒体类型）响应。
- en: '*Versioning using custom* `Request` `Header` *fields*—In this approach, you
    use a custom `Request` `Header` field such as `Accept-version` to specify the
    version of the API you want to use. This approach is the least preferred, since
    some frameworks may not accept nonstandard `Header` fields, thus leading to integration
    issues with your clients.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用自定义* `Request` `Header` *字段*进行版本控制——在这种方法中，你使用一个自定义的`Request` `Header`字段，例如`Accept-version`，来指定你想要使用的API版本。这种方法是最不受欢迎的，因为某些框架可能不接受非标准的`Header`字段，这可能导致与客户的集成问题。'
- en: Each versioning strategy comes with its own benefits and challenges. URL versioning
    is the most adopted strategy since it’s intuitive and easy to use. However, indicating
    the API version in the URL also means that our resource URIs change depending
    on the version of the API, which may be confusing for some clients.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每种版本控制策略都有其自身的优点和挑战。URL版本控制是最广泛采用的策略，因为它直观且易于使用。然而，在URL中指示API版本也意味着我们的资源URI会根据API的版本而变化，这可能会让一些客户感到困惑。
- en: Using the `Accept` header is another popular option, but it couples the logic
    for handling our media types with the logic for handling our API versions. Also,
    using the same error status code for both media types and API versions may be
    confusing for our API clients. The best strategy is to carefully consider the
    needs of our application and to agree with your API clients on the most preferred
    solution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Accept`头信息是另一个流行的选项，但它将处理我们的媒体类型的逻辑与处理我们的API版本的逻辑耦合在一起。此外，使用相同的错误状态码来处理媒体类型和API版本可能会让我们的API客户端感到困惑。最好的策略是仔细考虑我们应用程序的需求，并与你的API客户端就最理想的解决方案达成一致。
- en: B.2 Managing the life cycle of your APIs
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 管理你的API的生命周期
- en: In this section, we study strategies to gracefully deprecate our APIs. APIs
    don’t last forever; as the products and services that you offer through APIs evolve
    and change, some of your APIs will become deprecated, and you will eventually
    retire them. However, you may have external consumers whose systems depend on
    your APIs, so you cannot just take them down without causing disruption to your
    clients. You must orchestrate your API deprecation process, and as you’ll see,
    we use specific HTTP headers to give notice of API deprecation. Let’s see how
    that works!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究如何优雅地弃用我们的API。API不会永远存在；随着你通过API提供的产品和服务的发展和变化，一些API将变得过时，你最终将淘汰它们。然而，你可能有一些外部消费者，他们的系统依赖于你的API，因此你不能随意关闭它们，以免给客户造成干扰。你必须协调你的API弃用过程，正如你所看到的，我们使用特定的HTTP头来通知API的弃用。让我们看看它是如何工作的！
- en: Before you retire an API, you should deprecate it first. A deprecated API is
    still in service, but it lacks maintenance, enhancements, and fixes. Once you
    deprecate your APIs, your users won’t expect further changes to them. Deprecation
    serves as a grace period for your users to give them time to migrate their systems
    to a new API without disrupting their operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在你退役一个API之前，你应该首先弃用它。一个已弃用的API仍然在服务中，但它缺乏维护、增强和修复。一旦你弃用了你的API，你的用户就不会期望它们有进一步的变更。弃用为用户提供了一个宽限期，以便他们有时间将系统迁移到新的API，而不会干扰他们的操作。
- en: 'As soon as you decide to deprecate your API, you should announce it to your
    API consumers through a standard communication channel, such as by email or in
    a newsletter. At the same time, you should set the `Deprecation` header in your
    responses.[¹](#pgfId-1088816) If the API is going to be deprecated in the future,
    we set the `Deprecation` header to the date when the API will be deprecated:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定弃用你的API，你应该通过标准通信渠道，例如通过电子邮件或在通讯稿中，通知你的API消费者。同时，你应该在你的响应中设置`Deprecation`头信息。[¹](#pgfId-1088816)
    如果API将在未来被弃用，我们将`Deprecation`头信息设置为API将被弃用的日期：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the API is deprecated, we set the `Deprecation` header to `true`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦API被弃用，我们将`Deprecation`头信息设置为`true`：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also use the `Link` header to provide additional information about
    your API deprecation process. For example, you can provide a link to your deprecation
    policy:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`Link`头信息来提供有关你的API弃用过程的额外信息。例如，你可以提供一个链接到你的弃用策略：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, we are telling the user that they can follow the link [https://coffeemesh.com/deprecation](https://coffeemesh.com/deprecation)
    to find additional information about the deprecation of the API.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在告诉用户，他们可以点击[https://coffeemesh.com/deprecation](https://coffeemesh.com/deprecation)链接来找到有关API弃用的更多信息。
- en: 'If you’re deprecating an old version of your API, you can use the `Link` header
    to provide the URL that replaces or supersedes the current API version:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在弃用 API 的旧版本，您可以使用 `Link` 标头提供替换或取代当前 API 版本的 URL：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In addition to broadcasting the deprecation of your APIs, you should also announce
    when the API will be retired. We use the `Sunset` header to signal when the API
    will be retired:[²](#pgfId-1088834)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了广播您的 API 弃用信息外，您还应该宣布 API 将何时被弃用。我们使用 `Sunset` 标头来表示 API 将何时被弃用：[²](#pgfId-1088834)。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The date of the `Sunset` header must be later or the same as the date given
    in the `Deprecation` header. Once you’ve retired an API, you must let your API
    clients know that the old endpoints are no longer available. You may use any combination
    of 3xx and 4xx status codes when a user calls the old API. A good option is the
    410 (Gone) status code. We use the 410 status code to signal that the requested
    resource no longer exists for a known reason. In some circumstances, 301 (Moved
    Permanently) might be useful. We use the 301 status code to signal that the requested
    resource has been assigned a new URI, and therefore it may be useful when you
    migrate your API to a new endpoint.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sunset` 标头的日期必须晚于或与 `Deprecation` 标头中给出的日期相同。一旦您弃用了一个 API，您必须让您的 API 客户知道旧端点不再可用。当用户调用旧
    API 时，您可以使用任何 3xx 和 4xx 状态码的组合。一个好的选择是 410（已消失）状态码。我们使用 410 状态码来表示请求的资源因已知原因不再存在。在某些情况下，301（永久移动）可能是有用的。我们使用
    301 状态码来表示请求的资源已被分配了新的 URI，因此当您将 API 迁移到新的端点时，这可能是有用的。'
- en: Proper management of API changes and deprecations is a crucial yet often overlooked
    ingredient necessary to deliver high-quality and reliable API integrations. By
    applying the recommendations from this appendix, you’ll be able to evolve your
    APIs with confidence and without breaking integrations with your clients.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正确管理 API 变更和弃用是确保提供高质量和可靠 API 集成的一个关键但常常被忽视的要素。通过应用本附录中的建议，您将能够有信心地演进您的 API，而不会破坏与客户的集成。
- en: '* * *'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ Sanjay Dalal and Erik Wilde, “The Deprecation HTTP Header Field,” [https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-deprecation-header-02](https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-deprecation-header-02).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ Sanjay Dalal 和 Erik Wilde，“The Deprecation HTTP Header Field，”[https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-deprecation-header-02](https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-deprecation-header-02)。
- en: ² Erik Wilde, “The Sunset HTTP Header Field,” RFC 8594, [https://tools.ietf.org/html/rfc8594](https://tools.ietf.org/html/rfc8594).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ² Erik Wilde，“The Sunset HTTP Header Field，”RFC 8594，[https://tools.ietf.org/html/rfc8594](https://tools.ietf.org/html/rfc8594)。
