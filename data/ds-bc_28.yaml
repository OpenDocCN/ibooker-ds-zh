- en: 23 Case study 5 solution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 23 案例研究 5 解决方案
- en: This section covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖
- en: Cleaning data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据清洗
- en: Exploring networks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索网络
- en: Feature engineering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征工程
- en: Optimizing machine learning models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化机器学习模型
- en: 'FriendHook is a popular social networking app designed for college campuses.
    Students can connect as friends in the FriendHook network. A recommendation engine
    emails users weekly with new friend suggestions based on their existing connections;
    students can ignore these recommendations, or they can send out friend requests.
    We have been provided with one week’s worth of data pertaining to friend recommendations
    and student responses. That data is stored in the friendhook/Observations.csv
    file. We’re provided with two additional files: friendhook/Profiles.csv and friendhook/Friendships.csv,
    containing user profile information and the friendship graph, respectively. The
    user profiles have been encrypted to protect student privacy. Our goal is to build
    a model that predicts user behavior in response to the friend recommendations.
    We will do so by following these steps:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FriendHook 是一款流行的校园社交网络应用。学生可以在 FriendHook 网络中互加好友。推荐引擎每周向用户发送基于他们现有连接的新朋友建议；学生可以选择忽略这些建议，或者发送好友请求。我们提供了一周关于朋友建议和学生响应的数据。这些数据存储在
    friendhook/Observations.csv 文件中。我们还提供了两个附加文件：friendhook/Profiles.csv 和 friendhook/Friendships.csv，分别包含用户配置文件信息和友谊图。用户配置文件已被加密以保护学生隐私。我们的目标是构建一个模型，预测用户对朋友建议的行为反应。我们将通过以下步骤来完成：
- en: Load the three datasets containing the observations, user profiles, and friendship
    connections.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载包含观察结果、用户配置文件和友谊连接的三个数据集。
- en: 'Train and evaluate a supervised model that predicts behavior based on network
    features and profile features. We can optionally split this task into two subtasks:
    training a model using network features, and then adding profile features and
    evaluating the shift in model performance.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练并评估一个基于网络特征和配置文件特征的监督模型，以预测行为。我们可以选择将此任务分为两个子任务：使用网络特征训练模型，然后添加配置文件特征并评估模型性能的变化。
- en: Check to ensure that the model generalizes well to other universities.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以确保模型能够很好地推广到其他大学。
- en: Explore the inner workings of our model to gain better insights into student
    behavior.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索我们模型的内部运作机制，以更好地了解学生行为。
- en: Warning Spoiler alert! The solution to case study 5 is about to be revealed.
    We strongly encourage you to try to solve the problem before reading the solution.
    The original problem statement is available for reference at the beginning of
    the case study.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 揭示警报！案例研究 5 的解决方案即将揭晓。我们强烈建议你在阅读解决方案之前尝试解决问题。原始问题陈述可在案例研究开头参考。
- en: 23.1 Exploring the data
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.1 探索数据
- en: Let’s separately explore the `Profiles`, `Observations`, and `Friendships` tables.
    We will clean and adjust the data in these tables if required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别探索 `配置文件`、`观察结果` 和 `友谊` 表。如果需要，我们将对这些表中的数据进行清理和调整。
- en: 23.1.1 Examining the profiles
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1.1 检查配置文件
- en: We start by loading the `Profiles` table into Pandas and summarizing the table’s
    contents.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 `配置文件` 表加载到 Pandas 中，并总结表的内容。
- en: Listing 23.1 Loading the `Profiles` table
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.1 加载 `配置文件` 表
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ We’ll reuse this summarize function on the other two tables in our dataset.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将在数据集中的其他两个表上重用此汇总函数。
- en: '|  | Profile_ID | Sex | Relationship_Status | Dorm | Major | Year |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  | 配置文件_ID | 性别 | 关系状态 | 宿舍 | 专业 | 年级 |'
- en: '| **count** | 4039 | 4039 | 3631 | 4039 | 4039 | 4039 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **计数** | 4039 | 4039 | 3631 | 4039 | 4039 | 4039 |'
- en: '| **unique** | 4039 | 2 | 3 | 15 | 30 | 4 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **唯一** | 4039 | 2 | 3 | 15 | 30 | 4 |'
- en: '| **top** | b90a1222d2b2 | e807eb960650 | ac0b88e46e20 | a8e6e404d1b3 | 141d4cdd5aaf
    | c1a648750a4b |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **顶级** | b90a1222d2b2 | e807eb960650 | ac0b88e46e20 | a8e6e404d1b3 | 141d4cdd5aaf
    | c1a648750a4b |'
- en: '| **freq** | 1 | 2020 | 1963 | 2739 | 1366 | 1796 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **频率** | 1 | 2020 | 1963 | 2739 | 1366 | 1796 |'
- en: The table contains 4,039 distinct profiles distributed across two different
    sexes. The most frequent sex is mentioned in 2,020 of 4,039 profiles, so we can
    infer that the profiles represent an equal distribution between males and females.
    Furthermore, the profiles capture a student body distribution that’s spread across
    30 majors and 15 dormitories. Suspiciously, the most frequently mentioned dorm
    contains over 2,700 students. This number seems large, but a quick Google search
    reveals that large on-campus student complexes are not uncommon. For instance,
    the 17-story Sandburg Residence Hall at the University of Wisconsin-Milwaukee
    can house 2,700 students. These numbers may also represent students in the *Off-Campus
    Housing* category. The count can be explained by a multitude of hypotheses—but
    going forward, we should consider the various driving factors behind the numbers
    we observe. Rather than blindly crunching numbers, we should keep in mind that
    our data is derived from real-world behaviors and physical constraints of university
    students.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表格包含 4,039 个不同的个人资料，分布在两个不同的性别中。最频繁提到的性别在 4,039 个个人资料中的 2,020 个中被提及，因此我们可以推断这些个人资料代表了男性和女性之间的平等分布。此外，这些个人资料捕捉到了一个分布在整个
    30 个专业和 15 个宿舍的学生群体。令人怀疑的是，最频繁提到的宿舍包含超过 2,700 名学生。这个数字看起来很大，但快速谷歌搜索显示，大型校园学生综合体并不罕见。例如，威斯康星大学密尔沃基分校的
    17 层桑德堡学生宿舍可以容纳 2,700 名学生。这些数字也可能代表了 *校外住宿* 类别的学生。这个计数可以通过多种假设来解释——但是向前看，我们应该考虑我们观察到的数字背后的各种驱动因素。而不是盲目地处理数字，我们应该记住，我们的数据来源于现实世界学生的行为和物理限制。
- en: There is one anomaly in the table summary, in the *Relationship Status* column.
    Pandas has detected three *Relationship Status* categories across 3,631 of 4,039
    table rows. The remaining 400 or so rows are null—they don’t contain any assigned
    relationship status. Let’s count the number of empty rows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格摘要中，*关系状态* 列有一个异常。Pandas 在 4,039 行中的 3,631 行检测到了三个 *关系状态* 类别。剩余的约 400 行是空的——它们不包含任何分配的关系状态。让我们计算空行的数量。
- en: Listing 23.2 Counting empty *Relationship Status* profiles
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.2 统计空 *关系状态* 个人资料
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '408 profiles are missing a value in the `Relationship_Status` field. This makes
    sense: as stated in the problem statement, the `Relationship_Status` field is
    optional. It appears that one-tenth of the students refused to specify that field.
    But we cannot continue our analysis with empty values in our data; we need to
    either delete the empty rows or replace the empty fields with some other value.
    Deleting the empty rows is not a good option—we’d be throwing out potentially
    valuable information in the other columns. Instead, we can treat the lack of status
    as a fourth *unspecified* relationship status category. To do so, we should assign
    these rows a category ID. What ID value should we choose? Before we answer the
    question, let’s examine all unique IDs in the *Relationship Status* column.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 408 个个人资料在 `Relationship_Status` 字段中缺失值。这是有道理的：正如问题陈述中所述，`Relationship_Status`
    字段是可选的。看起来有十分之一的学生拒绝指定该字段。但是我们不能在数据中带有空值继续我们的分析；我们需要删除空行或者用其他值替换空字段。删除空行不是一个好选择——我们会丢弃其他列中可能有价值的信息。相反，我们可以将缺乏状态视为第四个
    *未指定* 的关系状态类别。为此，我们应该为这些行分配一个类别 ID。我们应该选择什么 ID 值？在我们回答这个问题之前，让我们检查 *关系状态* 列中所有唯一的
    ID。
- en: Listing 23.3 Checking unique *Relationship Status* values
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.3 检查唯一的 *关系状态* 值
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As expected, the *Relationship Status* values are composed of three hash codes
    and an empty `nan`. The hash codes are encrypted versions of the three possible
    status categories: *Single*, *In a Relationship*, and *It’s Complicated*. Of course,
    we cannot know which category is which. All we can determine is whether two profiles
    fall in the same status category. Our aim is to eventually use this information
    in a trained machine learning model. However, the scikit-learn library is unable
    to process hash codes or null values: it can only process numbers, so we need
    to convert the categories to numeric values. The simplest solution would be to
    assign each category a number between 0 and 4\. Let’s execute this assignment.
    We start by generating a dictionary mapping between each category and number.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，*关系状态*值由三个哈希码和一个空的`nan`组成。这些哈希码是三种可能状态类别（*单身*、*恋爱中*和*复杂关系*）的加密版本。当然，我们无法知道哪个类别对应哪个。我们所能确定的是两个配置文件是否属于同一状态类别。我们的目标是最终使用这些信息在训练好的机器学习模型中。然而，scikit-learn库无法处理哈希码或空值：它只能处理数字，因此我们需要将这些类别转换为数值。最简单的解决方案是为每个类别分配一个介于0到4之间的数字。让我们执行这个分配。我们首先生成一个将每个类别映射到数字的字典。
- en: Listing 23.4 Mapping *Relationship Status* values to numbers
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.4 将*关系状态*值映射到数字
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '❶ Normally, we would generate this map automatically by executing category_map
    = {id_: i for i, id_ in enumerate(unique_ids)}, but the order of numeric assignments
    could vary based on Python versioning. So, we manually set the mappings to ensure
    consistent outputs for all readers of this section.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ 通常，我们会通过执行`category_map = {id_: i for i, id_ in enumerate(unique_ids)}`来自动生成这个映射，但数值分配的顺序可能会根据Python版本而变化。因此，我们手动设置映射以确保本节所有读者的输出一致。'
- en: Next, we replace the contents of the *Relationship Status* column with the appropriate
    numeric values.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将“关系状态”列的内容替换为相应的数值。
- en: Listing 23.5 Updating the *Relationship Status* column
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.5 更新*关系状态*列
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ve transformed *Relationship Status* into a numeric variable, but the remaining
    five columns in the table still contain hash codes. Should we also replace these
    hash codes with numbers? Yes! Here’s why:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将*关系状态*转换为一个数值变量，但表中的剩余五列仍然包含哈希码。我们也应该将这些哈希码替换为数字吗？是的！原因如下：
- en: As previously mentioned, scikit-learn cannot process strings or hashes. It only
    takes numeric values as input.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，scikit-learn无法处理字符串或哈希值。它只接受数值作为输入。
- en: For humans, reading hash codes is more mentally taxing than reading numbers.
    Thus, replacing the multicharacter codes with shorter numbers will make it easier
    for us to explore the data.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于人类来说，阅读哈希码比阅读数字更费脑力。因此，用较短的数字替换多字符代码将使我们更容易探索数据。
- en: With this in mind, let’s create a category mapping between hash codes and numbers
    in each column. We track the category mappings in each column with a `col_to_
    mapping` dictionary. We also use the mappings to replace all hash codes with numbers
    in `df_profile`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们在每个列中创建哈希码和数字之间的类别映射。我们使用`col_to_mapping`字典跟踪每个列中的类别映射。我们还使用这些映射将`df_profile`中的所有哈希码替换为数字。
- en: Listing 23.6 Replacing all *Profile* hash codes with numeric values
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.6 将所有*配置文件*哈希码替换为数值
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Sorting the IDs helps ensure consistent outputs for all readers, independent
    of their Python versioning. Note that we can only sort the hash code IDs if no
    nan values are present among the hash codes; otherwise, the sorting will cause
    an error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对ID进行排序有助于确保所有读者的输出一致，独立于他们的Python版本。请注意，我们只能在哈希码中没有`nan`值的情况下对哈希码ID进行排序；否则，排序将导致错误。
- en: We’ve finished tweaking `df_profile`. Now let’s turn our attention to the table
    of experimental observations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对`df_profile`的调整。现在让我们将注意力转向实验观察结果表。
- en: 23.1.2 Exploring the experimental observations
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1.2 探索实验观察结果
- en: We start by loading the `Observations` table into Pandas and summarizing the
    table’s contents.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`Observations`表加载到Pandas中，并总结表的内容。
- en: Listing 23.7 Loading the `Observations` table
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.7 加载`Observations`表
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  | Profile_ID | Selected_Friend | Selected_Friend_of_Friend | Friend_Request_Sent
    | Friend_Request_Accepted |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|  | Profile_ID | Selected_Friend | Selected_Friend_of_Friend | Friend_Request_Sent
    | Friend_Request_Accepted |'
- en: '| **count** | 4039 | 4039 | 4039 | 4039 | 4039 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **count** | 4039 | 4039 | 4039 | 4039 | 4039 |'
- en: '| **unique** | 4039 | 2219 | 2327 | 2 | 2 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **unique** | 4039 | 2219 | 2327 | 2 | 2 |'
- en: '| **top** | b90a1222d2b2 | 89581f99fa1e | 6caa597f13cc | True | True |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **top** | b90a1222d2b2 | 89581f99fa1e | 6caa597f13cc | True | True |'
- en: '| **freq** | 1 | 77 | 27 | 2519 | 2460 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **freq** | 1 | 77 | 27 | 2519 | 2460 |'
- en: 'The five table columns all consistently show 4,039 filled rows. There are no
    empty values in the table. This is good—but the column names are hard to read.
    The names are very descriptive but also very long. We should consider shortening
    some of the names to ease our cognitive load. Let’s briefly discuss the various
    columns and whether some renaming would be appropriate:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 五个表格列都一致地显示了4,039个填充的行。表中没有空值。这是好的——但是列名很难读。这些名字非常描述性，但也非常长。我们应该考虑缩短一些名字以减轻我们的认知负担。让我们简要讨论各种列，并看看是否需要重命名：
- en: '*Profile_ID*—The ID of the user who received the friend recommendation. This
    name is short and straightforward. It also corresponds to the *Profile_ID* column
    in `df_profile`. We should keep this name as is.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Profile_ID*—接收朋友推荐的用户的ID。这个名字简短且直接。它也对应于`df_profile`中的*Profile_ID*列。我们应该保持这个名字不变。'
- en: '*Selected_Friend*—An existing friend of the user in the *Profile_ID* column.
    We can simplify this column name to just *Friend*.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Selected_Friend*—在*Profile_ID*列中用户的一个现有朋友。我们可以简化这个列名为仅*Friend*。'
- en: '*Selected_Friend_of_Friend*—A randomly chosen friend of *Selected_Friend* who
    was not yet a friend of *Profile_ID*. In our analysis, this random friend-of-a-friend
    was emailed as a *friend recommendation* for the user. We can rename this column
    *Recommended_Friend* or possibly *FoF*. Let’s call the column *FoF*, because this
    acronym is memorable and short.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Selected_Friend_of_Friend*—随机选择的一个朋友，他是*Selected_Friend*，但还不是*Profile_ID*的朋友。在我们的分析中，这个随机的朋友推荐被作为用户的*朋友推荐*发送。我们可以将这个列重命名为*Recommended_Friend*或可能是*FoF*。让我们称这个列为*FoF*，因为这个缩写既容易记忆又简短。'
- en: '*Friend_Requent_Sent*—This Boolean column is `True` if a user sent a friend
    request to the suggested friend of a friend or `False` otherwise. Let’s shorten
    the column name to just *Sent*.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Friend_Requent_Sent*—这个布尔列如果是用户向建议的朋友发送了好友请求则为`True`，否则为`False`。让我们将列名缩短为仅*Sent*。'
- en: '*Friend_Request_Accepted*—This Boolean column is only `True` if a user sent
    a friend request and that request was accepted. We can shorten the column name
    to *Accepted*.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Friend_Request_Accepted*—这个布尔列仅在用户发送了好友请求并且该请求被接受时为`True`。我们可以将列名缩短为*Accepted*。'
- en: Based on our discussion, we need to rename four of the five columns. Let’s rename
    the columns and regenerate the summary.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的讨论，我们需要重命名五列中的四列。让我们重命名这些列并重新生成摘要。
- en: Listing 23.8 Renaming the observation columns
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.8 重命名观测列
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  | Profile_ID | Friend | FoF | Sent | Accepted |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  | Profile_ID | Friend | FoF | Sent | Accepted |'
- en: '| **count** | 4039 | 4039 | 4039 | 4039 | 4039 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **count** | 4039 | 4039 | 4039 | 4039 | 4039 |'
- en: '| **unique** | 4039 | 2219 | 2327 | 2 | 2 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **unique** | 4039 | 2219 | 2327 | 2 | 2 |'
- en: '| **top** | b90a1222d2b2 | 89581f99fa1e | 6caa597f13cc | True | True |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **top** | b90a1222d2b2 | 89581f99fa1e | 6caa597f13cc | True | True |'
- en: '| **freq** | 1 | 77 | 27 | 2519 | 2460 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **freq** | 1 | 77 | 27 | 2519 | 2460 |'
- en: In the updated table, the statistics are clearer. The observations contain 2,219
    unique *Friend* IDs and 2,327 unique *FoF* IDs out of 4,039 samples total. This
    means, on average, each *Friend* and *FoF* ID is utilized approximately twice.
    No single profile ID dominates our data, which is reassuring. This will allow
    us to more easily design a robust predictive model, as opposed to a model that
    is driven by a single profile signal and thus more susceptible to overtraining.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新的表中，统计数据更清晰。在总共4,039个样本中，有2,219个独特的*Friend* ID和2,327个独特的*FoF* ID。这意味着，平均每个*Friend*和*FoF*
    ID大约被使用两次。没有单个配置文件ID主导我们的数据，这是令人欣慰的。这将使我们能够更容易地设计一个健壮的预测模型，而不是一个由单个配置文件信号驱动的模型，这样的模型更容易过拟合。
- en: Further examination reveals that approximately 62% (2,519) of the friend suggestions
    led to a friend request being sent. This is very promising; the friend-of-a-friend
    suggestions are quite effective. Furthermore, approximately 60% (2,460) of sampled
    instances led to a friend request being accepted; the sent friend requests are
    ignored or rejected just 2% (2519 – 2460 = 50) of the time. Of course, our numbers
    assume that there are no observations where *Sent* is `False` and *Accepted* is
    `True`. This scenario is not possible because a friend request cannot be accepted
    if it has not yet been sent. Still, as a sanity check, let’s test the integrity
    of the data by confirming that the scenario does not take place.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步检查发现，大约 62%（2,519）的友谊建议导致了发送好友请求。这非常令人鼓舞；朋友的朋友建议非常有效。此外，大约 60%（2,460）的样本实例导致了好友请求被接受；发送的好友请求被忽略或拒绝的比例仅为
    2%（2519 – 2460 = 50）。当然，我们的数字假设没有观察到 *Sent* 为 `False` 且 *Accepted* 为 `True` 的情况。这种情况不可能发生，因为如果请求尚未发送，则无法接受请求。尽管如此，为了进行合理性检查，让我们通过确认该场景不会发生来测试数据的完整性。
- en: Listing 23.9 Ensuring that *Sent* is `True` for all accepted requests
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.9 确保所有接受请求的 *Sent* 值为 `True`
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Based on our observations, user behavior follows three possible scenarios:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的观察，用户行为遵循三种可能的场景：
- en: A user rejects or ignores the friend recommendation listed in the *FoF* column.
    This occurs in 38% of instances.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户拒绝或忽略 *FoF* 列中列出的好友推荐。这种情况发生在 38% 的实例中。
- en: A user sends a friend request based on the recommendation, and the friend request
    is accepted. This occurs in 62% of instances.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户根据推荐发送好友请求，并且该请求被接受。这种情况发生在 62% 的实例中。
- en: A user sends a friend request based on the recommendation, and the friend request
    is rejected or ignored. This scenario is rare, occurring in just 1.2% of total
    instances.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户根据推荐发送好友请求，但该请求被拒绝或忽略。这种情况很少见，仅占总实例的 1.2%。
- en: Each of these three scenarios represents three categories of user behavior.
    Hence, we can encode this categorical behavior by assigning numbers 0, 1, and
    2 to behavior patterns *a*, *b*, and *c*. Here, we carry out the categorical assignments
    and store them in a *Behavior* column.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种情况分别代表三类用户行为。因此，我们可以通过将行为模式 *a*、*b* 和 *c* 分配数字 0、1 和 2 来编码这种分类行为。在这里，我们执行分类分配并将它们存储在
    *Behavior* 列中。
- en: Listing 23.10 Assigning classes of behavior to the user observations
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.10 将行为类别分配给用户观察结果
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Python treats Boolean values True and False as simple integer values 1 and
    0, respectively. So, this arithmetic operation returns either 0, 1, or 2 based
    on our behavior definitions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Python 将布尔值 True 和 False 分别作为简单的整数值 1 和 0 处理。因此，这个算术运算根据我们的行为定义返回 0、1 或 2。
- en: Additionally, we must transform the profile IDs in the first three columns from
    hash codes to numeric IDs consistent with `df_profile.Profile_ID`. The following
    code utilizes the mapping stored in `col_to_mapping['Profile_ID']` for this purpose.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须将前三个列中的配置文件 ID 从哈希码转换为与 `df_profile.Profile_ID` 一致的数值 ID。以下代码利用存储在 `col_to_mapping['Profile_ID']`
    中的映射来完成此操作。
- en: Listing 23.11 Replacing all *Observation* hash codes with numeric values
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.11 将所有 *Observation* 哈希码替换为数值
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`df_obs` now aligns with `df_profile`. Only a single data table remains unanalyzed.
    Let’s explore the friendship linkages in the `Friendships` table.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`df_obs` 现在与 `df_profile` 对齐。只有一个数据表尚未分析。让我们探索 `Friendships` 表中的友谊链接。'
- en: 23.1.3 Exploring the Friendships linkage table
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1.3 探索友谊链接表
- en: We start by loading the `Friendships` table into Pandas and summarizing the
    table’s contents.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 `Friendships` 表加载到 Pandas 中，并总结表的内容。
- en: Listing 23.12 Loading the `Friendships` table
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.12 加载 `Friendships` 表
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|  | Friend_A | Friend_B |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  | Friend_A | Friend_B |'
- en: '| **count** | 88234 | 88234 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **count** | 88234 | 88234 |'
- en: '| **unique** | 3646 | 4037 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **unique** | 3646 | 4037 |'
- en: '| **top** | 89581f99fa1e | 97ba93d9b169 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **top** | 89581f99fa1e | 97ba93d9b169 |'
- en: '| **freq** | 1043 | 251 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **freq** | 1043 | 251 |'
- en: There are over 88,000 friendship links in this social network. The social network
    is quite dense, with an average of approximately 22 friends per FriendHook profile.
    One social butterfly in the network (*89581f99fa1e*) has more than 1,000 friends.
    However, an exact friend count cannot be gauged because the two columns in the
    network are not symmetric. In fact, we cannot even validate whether all 4,039
    profiles are appropriately represented in the table.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个社交网络中，有超过 88,000 个友谊链接。社交网络相当密集，平均每个 FriendHook 配置文件有大约 22 个朋友。网络中的社交达人（*89581f99fa1e*）有超过
    1,000 个朋友。然而，由于网络中的两列不对称，无法准确衡量朋友数量。实际上，我们甚至无法验证是否所有 4,039 个配置文件都适当地在表中表示。
- en: To carry out a more detailed analysis, we should load the friendship data into
    a NetworkX graph. Listing 23.13 computes the social graph. We represent the node
    IDs with the numeric values mapped from the hash codes in the columns. After we
    compute the graph, we count the number of nodes in `G.nodes`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行更详细的分析，我们应该将友谊数据加载到 NetworkX 图中。列表 23.13 计算了社交图。我们用列中的哈希码映射的数值表示节点 ID。计算完图后，我们在
    `G.nodes` 中计算节点数量。
- en: Listing 23.13 Loading the social graph into NetworkX
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.13 将社交图加载到 NetworkX 中
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s try to gain more insights into the graph structure by visualizing it with
    `nx.draw` (figure 23.1). Note that the graph is rather large, so visualization
    might take 10 to 30 seconds of running time to complete.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过使用 `nx.draw` 可视化来深入了解图结构（图 23.1）。请注意，图相当大，所以可视化可能需要 10 到 30 秒的运行时间来完成。
- en: '![](../Images/23-01.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23-01.png)'
- en: Figure 23.1 The university’s visualized social graph. Tight social-group clusters
    are clearly visible; these can be extracted using Markov clustering.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.1 大学的可视化社交图。紧密的社交群体聚类清晰可见；这些可以使用马尔可夫聚类提取。
- en: Listing 23.14 Visualizing the social graph
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.14 可视化社交图
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tightly clustered social groups are clearly visible in the network. Let’s extract
    these groups using Markov clustering and then count the number of clusters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密聚集的社交群体在网络中清晰可见。让我们使用马尔可夫聚类提取这些群体，然后计算聚类数量。
- en: Listing 23.15 Finding social groups using Markov clustering
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.15 使用马尔可夫聚类查找社交群体
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ten clusters were found in the social graph. Let’s visualize these clusters
    by coloring each node based on cluster ID. To start, we need to iterate over `clusters`
    and assign a `cluster_id` attribute to every node.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交图中发现了 10 个聚类。让我们通过根据聚类 ID 着色每个节点来可视化这些聚类。首先，我们需要遍历 `clusters` 并将一个 `cluster_id`
    属性分配给每个节点。
- en: Listing 23.16 Assigning cluster attributes to nodes
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.16 将聚类属性分配给节点
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we color the nodes based on their cluster attribute assignment (figure
    23.2).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据节点的聚类属性分配来着色节点（图 23.2）。
- en: '![](../Images/23-02.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23-02.png)'
- en: Figure 23.2 The university’s visualized social graph. Tight social-group clusters
    have been identified using Markov clustering. The nodes in the graph are colored
    based on their cluster ID.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.2 大学的可视化社交图。使用马尔可夫聚类确定了紧密的社交群体聚类。图中的节点根据其聚类 ID 着色。
- en: Listing 23.17 Coloring the nodes by cluster assignment
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.17 根据聚类分配给节点着色
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The cluster colors clearly correspond to tight social groups. Our clustering
    has been effective, so the assigned `cluster_id` attributes should be helpful
    during the model-building process. Similarly, it might be useful to store all
    five profile features as attributes in the student nodes. Let’s iterate over the
    rows in `df_profile` and store each column value in its corresponding node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类颜色明显对应于紧密的社交群体。我们的聚类已经有效，因此分配的 `cluster_id` 属性在建模过程中应该是有帮助的。同样，将所有五个配置文件特征作为属性存储在学生节点中可能也很有用。让我们遍历
    `df_profile` 中的行并将每个列值存储在其对应的节点中。
- en: Listing 23.18 Assigning profile attributes to nodes
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.18 将配置文件属性分配给节点
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have finished exploring our input data. Now we’ll train a model that predicts
    user behavior. We’ll start by constructing a simple model that only utilizes network
    features.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对输入数据的探索。现在我们将训练一个预测用户行为的模型。我们将从一个只利用网络特征的简单模型开始。
- en: 23.2 Training a predictive model using network features
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.2 使用网络特征训练预测模型
- en: 'Our goal is to train a supervised machine learning model on our dataset to
    predict user behavior. Currently, all possible classes of behavior are stored
    in the *Behavior* columns of `df_obs`. Our three behavior class labels are 0,
    1, and 2\. As a reminder, the Class 2 label occurs in just 50 of the 4,039 sampled
    instances: Class 2 is very imbalanced relative to the other class labels. There
    is a case to be made for removing these 50 labeled examples from our training
    data. For the time being, let’s leave in these examples to see what happens; later,
    we will remove them if necessary. For now, we assign our training class label
    array to equal the `df_obs.Behavior` column.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在我们的数据集上训练一个监督机器学习模型来预测用户行为。目前，所有可能的行为类别都存储在`df_obs`的`*Behavior*`列中。我们的三个行为类别标签是0、1和2。提醒一下，类别2的标签只出现在4,039个样本中的50个实例中：相对于其他类别标签，类别2非常不平衡。有理由从我们的训练数据中移除这50个标记的示例。目前，我们先保留这些示例，看看会发生什么；稍后，如果需要，我们将移除它们。现在，我们将我们的训练类别标签数组赋值给`df_obs.Behavior`列。
- en: Listing 23.19 Assigning the class-label array `y`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.19 赋值类别标签数组`y`
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have class labels, we need to create a feature matrix `X`. Our
    goal is to populate this matrix with features arising from the social graph structure.
    Later, we’ll add additional features from the student profiles, so we don’t need
    to assemble the feature matrix all at once. We will build up the matrix slowly,
    adding new features in batches to better understand the impact of these features
    on model performance. With this in mind, let’s create an initial version of `X`
    and populate it with some very basic features. The simplest question we can ask
    about any FriendHook user is this: how many friends does the user have? That value
    equals the edge count associated with the user’s node in the social graph. In
    other words, the friend count of user `n` is equal to `G.degree(n)`. Let’s make
    this count the very first feature in the matrix. We’ll iterate over all the rows
    in `df_obs` and assign an edge count to each profile referenced in each row. As
    a reminder, every row contains three profiles: *Profile_ID*, *Friend*, and *FoF*.
    We’ll calculate the friend count for each profile, creating features *Profile_ID_
    Edge_Count, Friend_Edge_Count*, and *FoF_Edge_Count*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了类别标签，我们需要创建一个特征矩阵`X`。我们的目标是填充这个矩阵，使其包含来自社交图结构的特征。稍后，我们将添加来自学生档案的额外特征，所以我们不需要一次性组装特征矩阵。我们将逐步构建这个矩阵，分批添加新特征，以便更好地理解这些特征对模型性能的影响。考虑到这一点，让我们创建`X`的初始版本，并用一些非常基本的特征填充它。我们可以问任何FriendHook用户的简单问题就是：用户有多少个朋友？这个值等于用户在社交图中的节点的边数。换句话说，用户`n`的朋友数等于`G.degree(n)`。让我们把这个计数作为矩阵中的第一个特征。我们将遍历`df_obs`中的所有行，并为每行中引用的每个档案分配一个边数。提醒一下，每一行包含三个档案：*Profile_ID*、*Friend*和*FoF*。我们将计算每个档案的朋友数，创建特征*Profile_ID_
    Edge_Count、Friend_Edge_Count*和*FoF_Edge_Count*。
- en: Note It’s not always easy to come up with a good, consistent feature name. Rather
    than choosing *FoF_Edge_Count*, we could have chosen *FoF_Friend_ Count* as our
    name. However, maintaining consistency would have forced us to include a *Friend_Friend_Count*
    feature as well, leading to a very awkward feature name. Alternatively, we could
    have named our three features *Profile_Degree*, *Friend_Degree*, and *FoF_Degree*.
    These names would be short and informative, but it’s worth remembering that one
    of our profile features pertains to college majors. In the context of college,
    both degrees and majors have a nearly identical definition, so a degree-based
    naming convention could cause confusion down the line. That is why we’re sticking
    with an *Edge_Count* suffix.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：并不是总是容易想出一个好的一致的特征名称。我们本可以选择*FoF_Edge_Count*作为我们的名称，而不是*FoF_Friend_Count*。然而，保持一致性将迫使我们包括一个*Friend_Friend_Count*特征，这将导致一个非常尴尬的特征名称。或者，我们可以将我们的三个特征命名为*Profile_Degree*、*Friend_Degree*和*FoF_Degree*。这些名称既简短又富有信息量，但值得记住的是，我们的一个档案特征与大学专业有关。在大学的背景下，学位和专业几乎有相同的定义，所以基于学位的命名约定可能会引起混淆。这就是为什么我们坚持使用*Edge_Count*后缀。
- en: Let’s generate a matrix of 3-by-4,039 edge count features. We need a way to
    track these features along with the associated feature names. We also need a way
    to easily update features and their names with additional inputs. One straightforward
    solution is to store the features in a `df_features` Pandas table. That table
    will allow us to access the feature matrix via `df_features.values`. Let’s compute
    `df_features` to create an initial version of our feature matrix.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成一个3-by-4,039的边数特征矩阵。我们需要一种方法来跟踪这些特征及其关联的特征名称。我们还需要一种方法来轻松地使用额外的输入更新特征及其名称。一个直接的方法是将特征存储在一个`df_features`
    Pandas表中。该表将允许我们通过`df_features.values`访问特征矩阵。让我们计算`df_features`以创建特征矩阵的初始版本。
- en: Listing 23.20 Creating a feature matrix from edge counts
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.20：从边数创建特征矩阵
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ As a reminder, the node’s degree equals the edge count of that node. Hence,
    G.degree(n) returns the friend count associated with user n.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为提醒，节点的度数等于该节点的边数。因此，G.degree(n)返回与用户n关联的朋友数。
- en: We have an initial training set in place. Let’s check the quality of the signal
    in that set by training and testing a simple model. We have multiple possible
    models to choose from. One sensible choice is a decision tree classifier; decision
    trees can handle nonlinear decision boundaries and are easily interpretable. On
    the downside, they are prone to overtraining, so cross-validation will be required
    to measure model performance appropriately. Listing 23.21 trains a decision tree
    on a subset of `(X, y)` and evaluates the results on the remaining data. During
    the evaluation, we should keep in mind that our Class 2 labels are highly imbalanced.
    Thus, the f-measure metric will provide a more reasonable assessment of performance
    than simple accuracy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个初始训练集。让我们通过训练和测试一个简单的模型来检查该集中信号的质量。我们有多个可能的选择。一个合理的选项是决策树分类器；决策树可以处理非线性决策边界，并且易于解释。然而，它们容易过拟合，因此需要交叉验证来适当地衡量模型性能。列表23.21在`(X,
    y)`的一个子集上训练决策树，并在剩余数据上评估结果。在评估过程中，我们应该记住我们的类别2标签高度不平衡。因此，f度量指标将比简单的准确率提供一个更合理的性能评估。
- en: Note Through the remainder of this section, we repeatedly train and test our
    classifier models. Listing 23.21 defines an `evaluate` function for this purpose
    that takes as input a training set `(X, y)` and a model type preset to `DecisionTreeClassifier`.
    The function then splits `X, y` into training and test sets, trains the classifier,
    and computes an f-measure using the test set. Finally, it returns both the f-measure
    and the classifier for evaluation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本节的剩余部分，我们将反复训练和测试我们的分类器模型。列表23.21定义了一个`evaluate`函数，用于此目的，它接受一个训练集`(X, y)`和一个预置为`DecisionTreeClassifier`的模型类型作为输入。该函数随后将`X,
    y`分割为训练集和测试集，训练分类器，并使用测试集计算f度量。最后，它返回f度量以及用于评估的分类器。
- en: Listing 23.21 Training and evaluating a decision tree classifier
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.21：训练和评估决策树分类器
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '❶ We’ll repeatedly utilize this function over the remainder of this section.
    It trains a classifier on a subsample of data in (X, y). The classifier type is
    specified using the model_type parameter: here, the parameter is preset to a decision
    tree classifier. Additional classifier hyperparameters can be specified using
    **kwargs. After training, the classifier’s performance is evaluated using a retained
    subset of the data.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将在本节的剩余部分反复使用此函数。它在一个`(X, y)`数据子集上训练分类器。分类器类型通过`model_type`参数指定：在这里，参数预置为决策树分类器。可以使用**kwargs指定额外的分类器超参数。训练后，使用保留的数据子集评估分类器的性能。
- en: ❷ This random seed value ensures that (X, y) is split consistently from run
    to run.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此随机种子值确保每次运行时`(X, y)`的分割是一致的。
- en: ❸ Splits (X, y) into training and test sets
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将`(X, y)`分割为训练集和测试集
- en: ❹ Trains the model
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 训练模型
- en: ❺ Computes an f-measure. The average='macro' parameter is required because three
    class labels are present in the training data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 计算f度量。由于训练数据中存在三个类别标签，因此需要`average='macro'`参数。
- en: Our f-measure is terrible! Clearly, the edge count by itself is not sufficient
    for predicting user behavior. Perhaps a more sophisticated measure of node centrality
    is required. Earlier, we learned how the PageRank centrality measure can be more
    informative than edge count. Would adding PageRank values to our training set
    improve model performance? Let’s find out.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的f度量非常糟糕！显然，仅凭边数本身不足以预测用户行为。可能需要一个更复杂的节点中心性度量。之前，我们了解到PageRank中心性度量可以比边数提供更多信息。将PageRank值添加到我们的训练集中是否会提高模型性能？让我们找出答案。
- en: Listing 23.22 Adding PageRank features
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.22 添加PageRank特征
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ This function is utilized repeatedly. It updates the df_features Pandas table
    with novel features in the new_features dictionary.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此函数被反复使用。它通过新特征字典中的新特征更新df_features Pandas表。
- en: ❷ Returns the altered feature matrix
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回修改后的特征矩阵
- en: 'The f-measure remains approximately the same. Basic centrality measures are
    insufficient. We need to expand `X` to include the social groups uncovered by
    Markov clustering. After all, two people in the same social group are more likely
    to be friends. How do we incorporate these social groups into the feature matrix?
    Well, naively, we could assign the `cluster_id` attribute of each referenced node
    as our social group feature. However, this approach has a serious downside: our
    current cluster IDs are only relevant to the specific social graph in `G`. They
    are not at all relevant to any other college network. In other words, a model
    trained on the cluster IDs in `G` is not applicable to some other college graph
    in `G_other`. This won’t do! One of our goals is to construct a model that is
    generalizable across other colleges. Thus, we need a more nuanced solution.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: f度量保持大致相同。基本中心性度量是不够的。我们需要将`X`扩展以包括由马尔可夫聚类揭示的社交群体。毕竟，属于同一个社交群体的人更有可能成为朋友。我们如何将这些社交群体纳入特征矩阵中？好吧，天真地，我们可以将每个引用节点的`cluster_id`属性作为我们的社交群体特征。然而，这种方法有一个严重的缺点：我们当前的聚类ID仅与`G`中的特定社交图相关。它们与任何其他大学网络完全不相关。换句话说，在`G`中的聚类ID上训练的模型不适用于`G_other`中的某些其他大学图。这不行！我们的目标之一是构建一个可以推广到其他学院的模型。因此，我们需要一个更细致的解决方案。
- en: 'One alternate approach is just to consider the following binary question: are
    two people in the same social group? If they are, then perhaps they are more likely
    to eventually become friends on FriendHook. We can make this binary comparison
    between each pair of profile IDs in a single row of observations. More precisely,
    we can ask the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法就是考虑以下二元问题：两个人是否属于同一个社交群体？如果是，那么他们最终在FriendHook上成为朋友的可能性可能更大。我们可以在观察数据的一行中，对每一对配置文件ID进行这种二元比较。更精确地说，我们可以提出以下问题：
- en: Does the user in the *Profile_ID* column fall in the same social group as the
    friend in the *Friend* column? We’ll name this feature *Shared_Cluster_id_f*.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*Profile_ID*列中的用户是否与*Friend*列中的朋友属于同一个社交群体？我们将这个特征命名为*Shared_Cluster_id_f*。
- en: Does the user in the *Profile_ID* column fall in the same social group as the
    friend of a friend in the *FoF* column? We’ll name this feature *Shared_Cluster_id_fof*.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*Profile_ID*列中的用户是否与*FoF*列中的朋友的朋友属于同一个社交群体？我们将这个特征命名为*Shared_Cluster_id_fof*。
- en: Does the friend in the *Friend* column fall in the same social group as the
    friend of a friend in the *FoF* column? We’ll name this feature *Shared_Cluster_f_fof*.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*Friend*列中的朋友是否与*FoF*列中的朋友的朋友属于同一个社交群体？我们将这个特征命名为*Shared_Cluster_f_fof*。
- en: Let’s answer these three questions by adding the three additional features.
    Then we test whether these features yield improved model performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加三个额外的特征来回答这三个问题。然后我们测试这些特征是否提高了模型性能。
- en: Listing 23.23 Adding social group features
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.23 添加社交群体特征
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our f-measure has improved from 0.38 to 0.43\. Performance is still poor, but
    the social group inclusion has led to a slight enhancement of our model. How important
    are the new social group features relative to the model’s current performance?
    We can check using the `feature_importance_` attribute of our trained classifier.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特征度量从0.38提高到0.43。性能仍然较差，但社交群体包含使得我们的模型略有改进。新的社交群体特征相对于模型当前性能的重要性如何？我们可以通过检查训练分类器的`feature_importance_`属性来验证。
- en: Listing 23.24 Ranking features by their importance score
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.24 根据重要性分数对特征进行排名
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Prints the top features along with their importance scores in the classifier
    based on order of importance
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印出根据重要性顺序排列的顶级特征及其重要性分数
- en: ❷ Sorts the features based on importance score
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据重要性得分对特征进行排序
- en: ❸ Features with an importance score of less than 0.01 are not displayed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 重要性得分小于 0.01 的特征不会显示。
- en: The *Shared_Cluster_id_fof* feature is the most important feature in the model.
    In other words, the social group overlap between the user and the friend of a
    friend is the most important predictor of a future online friendship. However,
    the PageRank features also rank highly on the list, which indicates that social
    graph centrality plays some role in friendship determination. Of course, our model’s
    performance is still poor, so we should be cautious with our inferences about
    how the features drive predictions. Instead, we should focus on improving model
    performance. What other graph-based features could we utilize? Perhaps the network
    cluster size can impact the predictions. We can find out, but we should be careful
    about trying to keep our model generalizable. Cluster size can inexplicably take
    the place of a cluster ID, making the model very specific to the university. Let’s
    explore how this could occur.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shared_Cluster_id_fof* 特征是模型中最重要的特征。换句话说，用户和朋友的社交群体重叠是未来在线友谊最重要的预测因素。然而，PageRank
    特征也在列表中排名很高，这表明社交图中心性在友谊决定中起着一定作用。当然，我们模型的性能仍然很差，因此我们应该谨慎地推断特征如何驱动预测。相反，我们应该专注于提高模型性能。我们还能利用哪些基于图的特征？也许网络聚类大小会影响预测。我们可以找出，但我们应该小心尝试保持模型的可泛化性。聚类大小可以无解释地取代聚类
    ID，使模型非常特定于大学。让我们探索这是如何发生的。'
- en: Suppose our dataset has two social clusters, A and B. The clusters contain 110
    and 115 students, respectively. Thus, their sizes are nearly identical and should
    not drive prediction. Now, let’s further suppose the students in Cluster A are
    more likely to become FriendHook friends than students in Cluster B. Our model
    would pick up on this during training and associate a size of 110 with a propensity
    for friendship. Essentially, it would treat the size like a cluster ID! This could
    cause trouble in the future if the model encountered a brand-new cluster with
    size 110.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的数据集有两个社交聚类，A 和 B。这些聚类分别包含 110 和 115 名学生。因此，它们的大小几乎相同，不应该驱动预测。现在，让我们进一步假设
    A 聚类的学生比 B 聚类的学生更有可能成为 FriendHook 朋友。我们的模型会在训练期间注意到这一点，并将 110 的大小与友谊倾向相关联。本质上，它将大小视为聚类
    ID！这可能会在未来造成麻烦，如果模型遇到了一个全新的大小为 110 的聚类。
- en: 'So should we ignore cluster size altogether? Not necessarily. We are scientists,
    and we wish to honestly explore how cluster size impacts model prediction. But
    we should be very cautious: if cluster size has minimal impact on model quality,
    we should delete it from our features. However, if the size drastically improves
    model prediction, we will cautiously reevaluate our options. Let’s test what happens
    when we add cluster size to our list of features.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该完全忽略聚类大小？不一定。我们是科学家，我们希望诚实地探索聚类大小对模型预测的影响。但我们应该非常谨慎：如果聚类大小对模型质量的影响很小，我们应该将其从特征中删除。然而，如果大小极大地提高了模型预测，我们将谨慎地重新评估我们的选择。让我们测试当我们将聚类大小添加到我们的特征列表中会发生什么。
- en: Listing 23.25 Adding cluster-size features
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.25 添加聚类大小特征
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The cluster size did not improve the model. As a precaution, let’s delete it
    from our feature set.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类大小并没有提高模型。作为预防措施，让我们将其从我们的特征集中删除。
- en: Listing 23.26 Deleting cluster-size features
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.26 删除聚类大小特征
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Deletes all feature names in df_features that match the regex regular expression.
    It is utilized elsewhere in this section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 删除 df_features 中所有匹配正则表达式的特征名称。它在本节的其他地方也被使用。
- en: ❷ Returns the altered feature matrix
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回修改后的特征矩阵
- en: The f-measure remains at 0.43\. What else can we do? Perhaps we should try thinking
    outside the box. In what ways can social connections drive real-world behavior?
    Are there additional, problem-specific signals we can harness? Yes! Consider the
    following scenario. Suppose we analyze a student named Alex, whose node ID in
    network `G` is `n`. Alex has 50 FriendHook friends, who are accessible through
    `G[n]`. We randomly sample two of the friends in `G[n]`. Their node IDs are `a`
    and `b`. We then check if `a` and `b` are friends. They are! It seems that `a`
    is in `list(G[n])`. We then repeat this 100 times. In 95% of sampled instances,
    `a` is a friend of `b`. Basically, there’s a 95% likelihood that any pair of Alex’s
    friends are also friends with each other. We’ll refer to this probability as the
    *friend-sharing likelihood*. Now, Mary is new to FriendHook. She just joined and
    added Alex as her friend. We can be fairly confident that Mary will also connect
    with Alex’s friends—though of course this is not guaranteed. But a friend-sharing
    likelihood of 0.95 gives us more confidence than a likelihood of 0.10.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: f-measure 仍然保持在 0.43。我们还能做什么？也许我们应该尝试跳出思维框框。社会联系以何种方式可以驱动现实世界的行为？我们能否利用额外的、特定于问题的信号？是的！考虑以下场景。假设我们分析一个名为
    Alex 的学生，他在网络 `G` 中的节点 ID 是 `n`。Alex 有 50 个 FriendHook 朋友，可以通过 `G[n]` 访问。我们从 `G[n]`
    中随机抽取两个朋友。他们的节点 ID 是 `a` 和 `b`。然后我们检查 `a` 和 `b` 是否是朋友。他们是！这似乎表明 `a` 在 `list(G[n])`
    中。然后我们重复这个过程 100 次。在 95% 的抽样实例中，`a` 是 `b` 的朋友。基本上，任何一对 Alex 的朋友之间相互成为朋友的可能性是 95%。我们将这个概率称为
    *朋友分享可能性*。现在，Mary 是 FriendHook 的新成员。她刚刚加入并添加了 Alex 作为她的朋友。我们可以相当有信心地认为 Mary 也会与
    Alex 的朋友建立联系——尽管当然这并不保证。但朋友分享可能性为 0.95 给我们比可能性为 0.10 更多的信心。
- en: Let’s try incorporating this likelihood into our features. We start by computing
    the likelihood for every node in `G`. We store the node-to-likelihood mapping
    in a `friend_sharing_likelihood` dictionary.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这种可能性整合到我们的特征中。我们首先计算 `G` 中每个节点的可能性。我们将节点到可能性的映射存储在 `friend_sharing_likelihood`
    字典中。
- en: Listing 23.27 Computing friend-sharing likelihoods
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.27 计算朋友分享可能性
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Tracks the count of shared friendships across neighbors
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪邻居之间共享友谊的数量
- en: ❷ Tracks the total possible shared friendships. Note that with a bit of graph
    theory, we could prove this value always equals len(neighbors) * (len(neighbors
    - 1)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跟踪可能共享友谊的总数。请注意，通过一点图论，我们可以证明这个值总是等于 len(neighbors) * (len(neighbors - 1))。
- en: ❸ Checks if two neighbors are friends
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查两个邻居是否是朋友
- en: Next, we generate a friend-sharing likelihood feature for each of our three
    profile IDs. After adding the features, we reevaluate the trained model’s performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的三个个人资料 ID 中的每一个生成一个朋友分享可能性特征。在添加特征后，我们重新评估训练模型的性能。
- en: Listing 23.28 Adding friend-sharing likelihood features
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.28 添加朋友分享可能性特征
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Performance has increased from 0.43 to 0.49! It’s still not great, but it’s
    progressively getting better. How does the friend-sharing likelihood compare to
    other features in the model? Let’s find out.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 性能已从 0.43 提高到 0.49！这仍然不是很好，但它是逐步变好的。朋友分享可能性与其他模型中的特征相比如何？让我们来看看。
- en: Listing 23.29 Ranking features by their importance score
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.29 按重要性分数对特征进行排序
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One of our new friend-sharing features ranks quite highly: it’s in second place,
    between `Shared_Cluster_id_fof` and `FoF_PageRank`. Our outside-the-box thinking
    has improved the model. But the model is incomplete. An f-measure of 0.49 is not
    acceptable; we need to do better. It’s time to move beyond network structure.
    We need to incorporate features from the profiles stored in `df_profiles`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新朋友分享特征中有一个排名相当高：它在第二位，介于 `Shared_Cluster_id_fof` 和 `FoF_PageRank` 之间。我们的跳出思维框框的方法提高了模型的效果。但模型还不完整。f-measure
    为 0.49 是不可接受的；我们需要做得更好。是时候超越网络结构了。我们需要将存储在 `df_profiles` 中的个人资料特征整合进来。
- en: 23.3 Adding profile features to the model
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.3 将个人资料特征添加到模型中
- en: 'Our aim is to incorporate the profile attributes `Sex`, `Relationship_Status`,
    `Major`, `Dorm`, and `Year` into our feature matrix. Based on our experience with
    the network data, there are three ways in which we can do this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将个人资料属性 `Sex`、`Relationship_Status`、`Major`、`Dorm` 和 `Year` 整合到我们的特征矩阵中。根据我们对网络数据的经验，我们可以通过以下三种方式来实现：
- en: '*Exact value extraction*—We can store the exact value of the profile feature
    associated with each of the three profile ID columns in `df_obs`. This is analogous
    to how we utilized the exact values of edge counts and PageRank outputs from the
    network.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精确值提取*—我们可以在`df_obs`中的三个配置文件ID列中存储与每个配置文件特征相关的精确值。这类似于我们如何利用网络中边数和PageRank输出的精确值。'
- en: 'Example feature: The relationship status of the friend of a friend in `df_obs`.'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例特征：`df_obs`中朋友的朋友的关系状态。
- en: '*Equivalence comparison*—Given a profile attribute, we can carry out a pairwise
    comparison of the attribute across all three profile ID columns in `df_obs`. For
    each comparison, we return a Boolean feature demarcating whether the attribute
    is equal in the two columns. This is analogous to how we checked whether a profile
    pair belonged to the same social group.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等价比较*—给定一个配置文件属性，我们可以在`df_obs`中的三个配置文件ID列之间进行成对比较。对于每次比较，我们返回一个布尔特征，表示该属性在两个列中是否相等。这类似于我们检查配置文件对是否属于同一社交群体。'
- en: 'Example feature: Do a particular user and a friend of a friend live in the
    same dorm? Yes or no?'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例特征：特定的用户和他们的朋友是否住在同一个宿舍？是或否？
- en: '*Size*—Given a profile attribute, we can return the number of profiles that
    share that attribute. This is analogous to the attempted inclusion of social group
    size in our model.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大小*—给定一个配置文件属性，我们可以返回具有该属性配置文件的数量。这类似于我们尝试将社交群体大小纳入模型中。'
- en: 'Example feature: The number of students residing in a particular dorm.'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例特征：特定宿舍居住的学生数量。
- en: Let’s utilize exact value extraction to expand our feature matrix. Which of
    our five attributes are good candidates for this technique? Well, the categorical
    values of `Sex`, `Relationship_Status`, and `Year` are not college-dependent;
    they should remain consistent across all colleges and universities. This is not
    the case for `Dorm`—dormitory names will change in other college networks. Our
    goal is to train a model that can be applied to other social graphs, so the `Dorm`
    attribute is not a valid feature for exact value extraction.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用精确值提取来扩展我们的特征矩阵。我们五个属性中哪些是这种技术的合适候选者？嗯，`Sex`、`Relationship_Status`和`Year`的类别值不依赖于大学；它们应该在整个大学和学院中保持一致。而`Dorm`的情况则不同——宿舍名称在其他大学网络中会发生变化。我们的目标是训练一个可以应用于其他社交图的模型，所以`Dorm`属性不是精确值提取的有效特征。
- en: What about the `Major` attribute? Here, the situation is trickier. Certain majors
    like biology and economics are shared by most colleges and universities. Other
    majors, like civil engineering, might appear at more technically oriented schools
    but not on a liberal arts college curriculum. And certain rare majors like bagpiping
    or astrobiology are specific to a few niche schools. Thus, we can expect some
    consistency across majors but not total consistency. A model harnessing the exact
    values of the majors will therefore be partially reusable; potentially, that partial
    signal could boost predictive power at some schools, but this would happen at
    the expense of other schools. Is the trade-off worth it? Perhaps. The answer is
    not immediately clear. For the time being, let’s see how well we can train our
    model without relying on the added crutch of `Major` values. If we find ourselves
    unable to train an adequate model, we will revisit our decision.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Major`属性呢？在这里，情况更为复杂。某些专业，如生物学和经济学，在大多数大学和学院中都是共享的。其他专业，如土木工程，可能出现在更多技术导向的学校中，但不会出现在文科院校的课程中。还有一些罕见的专业，如风笛演奏或天体生物学，只属于少数特定学校。因此，我们可以在专业之间期望一定的连贯性，但不是完全一致。因此，利用专业精确值的模型将部分可重用；潜在地，这种部分信号可能会在某些学校提高预测能力，但这是以牺牲其他学校为代价的。这种权衡是否值得？也许吧。答案并不立即明朗。目前，让我们看看在不依赖添加的`Major`值这一额外支撑的情况下，我们能够训练出多好的模型。如果我们发现自己无法训练出一个合适的模型，我们将重新审视我们的决定。
- en: Let’s now apply exact value extraction to `Sex`, `Relationship_Status`, and
    `Year` and then check for improvements in our model.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将精确值提取应用于`Sex`、`Relationship_Status`和`Year`，然后检查模型是否有所改进。
- en: Listing 23.30 Adding exact value profile features
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.30 添加精确值配置文件特征
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Wow! The f-measure dramatically increased from 0.49 to 0.74! The profile features
    have provided a very valuable signal, but we can still do better. We need to incorporate
    information from the `Major` and `Dorm` attributes. Equivalence comparison is
    an excellent way to do this. The question of whether two students share the same
    major or dorm is independent of their university. Let’s apply the equivalence
    comparison to the `Major` and `Dorm` attributes and then recompute the f-measure.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！f-measure从0.49戏剧性地增加到0.74！配置文件特征已经提供了非常有价值的信号，但我们仍然可以做得更好。我们需要将`Major`和`Dorm`属性的信息纳入其中。等价比较是做这件事的一个极好方法。两个学生是否在同一个专业或宿舍是独立于他们的大学的。让我们将等价比较应用于`Major`和`Dorm`属性，然后重新计算f-measure。
- en: Listing 23.31 Adding equivalence comparison profile features
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.31 添加等价比较配置文件特征
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The f-measure has risen to 0.82\. Incorporating the `Major` and `Dorm` attributes
    has improved model performance. Now let’s consider adding `Major` and `Dorm` size
    into the mix: we can count the number of students associated with each major and
    dorm and include this count as one of our features. But we need to be careful;
    as we previously discussed, our trained model can cheat by utilizing size as a
    substitute for a category ID. For instance, as we’ve previously seen, our largest
    dormitory holds over 2,700 students. Thus, we can easily identify that dorm based
    on its size alone. We must be cautious going forward. Let’s see what happens when
    we incorporate `Major` and `Dorm` size into our features. If there’s little impact
    on performance, we’ll delete the features from our model. Otherwise, we’ll reevaluate
    our options.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: f-measure已经上升到0.82。引入`Major`和`Dorm`属性已经提高了模型性能。现在让我们考虑将`Major`和`Dorm`的大小也加入其中：我们可以计算与每个专业和宿舍相关联的学生数量，并将这个计数作为我们的一个特征。但我们需要小心；正如我们之前讨论的，我们的训练模型可以通过利用大小作为类别ID的替代品来作弊。例如，正如我们之前看到的，我们最大的宿舍有超过2,700名学生。因此，我们可以仅根据其大小轻松地识别出这个宿舍。我们必须谨慎行事。让我们看看当我们把`Major`和`Dorm`的大小加入我们的特征时会发生什么。如果对性能影响不大，我们将从我们的模型中删除这些特征。否则，我们将重新评估我们的选择。
- en: Listing 23.32 Adding size-related profile features
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.32 添加与大小相关的配置文件特征
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Tracks the number of times each attribute appears in our dataset
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪每个属性在我们数据集中出现的次数
- en: Performance has increased from 0.82 to 0.85\. The introduction of size has impacted
    our model. Let’s dive deeper into that impact. We start by printing out the feature
    importance scores.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 性能从0.82提高到0.85。大小的引入影响了我们的模型。让我们深入探讨这种影响。我们首先打印出特征重要性得分。
- en: Listing 23.33 Ranking features by their importance score
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.33 按重要性得分对特征进行排序
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The feature importance scores are dominated by two features: *FoF_Dorm_Size*
    and *Shared_Cluster_id_fof*. These two features have importance scores of 0.25
    and 0.16, respectively. All other feature scores fall below 0.01.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 特征重要性得分主要由两个特征主导：*FoF_Dorm_Size*和*Shared_Cluster_id_fof*。这两个特征的重要性得分分别为0.25和0.16。所有其他特征得分都低于0.01。
- en: The presence of *FoF_Dorm_Size* is a bit concerning. As we’ve discussed, a single
    dorm dominates 50% of the network data. Is our model simply memorizing that dorm
    based on its size? We can find out by visualizing a trained decision tree. For
    simplicity’s sake, we limit the tree to a depth of 2, to limit our output to just
    those decisions driven by the two most dominant features.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*FoF_Dorm_Size*的存在有点令人担忧。正如我们之前讨论的，一个宿舍主导了50%的网络数据。我们的模型是否只是根据其大小来记忆这个宿舍？我们可以通过可视化训练好的决策树来找出答案。为了简单起见，我们将树限制在深度为2，以限制我们的输出仅包括由两个最主导特征驱动的决策。'
- en: Listing 23.34 Displaying the top branches of the tree
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.34 显示树的顶级分支
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ The export_text function has trouble taking NumPy arrays as input, so we convert
    feature_names to a list.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `export_text`函数在处理NumPy数组作为输入时存在问题，因此我们将feature_names转换为列表。
- en: ❷ Friend-of-a-friend dorm size is less than 279\. Under these circumstances,
    the most likely class label is 0 (friend suggestion ignored).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 朋友的朋友宿舍大小小于279。在这种情况下，最可能的类别标签是0（忽略朋友建议）。
- en: ❸ Friend-of-a-friend dorm size is >= 279.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 朋友的朋友宿舍大小大于等于279。
- en: ❹ Friend of a friend and user are not in the same social group. The most likely
    class label is 0.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 朋友的朋友和用户不在同一个社交群体中。最可能的类别标签是0。
- en: ❺ Friend of a friend and user share the same social group. The most likely class
    label is 1 (FriendHook connection established).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 朋友的朋友和用户属于同一个社交群体。最可能的类别标签是1（FriendHook连接建立）。
- en: According to the tree, the most important signal is whether *FoF_Dorm_Size*
    is less than 279\. If the friend of a friend’s dormitory holds fewer than 279
    students, then the FoF and the user are unlikely to become FriendHook friends.
    Otherwise, they are more likely to connect if they already share the same social
    group (`Shared_Cluster_id_fof > 0.50`). This begs the question, how many dorms
    contain at least 279 students? Let’s check.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据树形图，最重要的信号是*FoF_Dorm_Size*是否小于279。如果朋友宿舍的学生人数少于279，那么FoF和用户不太可能成为FriendHook朋友。否则，如果他们已经共享相同的社交群体（`Shared_Cluster_id_fof
    > 0.50`），他们更有可能建立联系。这引发了一个问题，有多少宿舍至少有279名学生？让我们检查一下。
- en: Listing 23.35 Checking dorms with at least 279 students
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.35 检查至少有279名学生的宿舍
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Just two of the 15 dorms contain more than 279 FriendHook-registered students.
    Essentially, our model relies on the two most populous dorms to make its decisions.
    This puts us in a bind: on the one hand, the observed signal is very interesting;
    FriendHook connections are more likely to occur in some dorms than others. Dorm
    size plays a factor in these connections. This insight could allow FriendHook
    developers to better understand user behavior, and perhaps this understanding
    will lead to better user engagement. We are better off having gained this knowledge.
    However, our current model has a serious downside.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在15个宿舍中，只有两个宿舍有超过279名FriendHook注册的学生。本质上，我们的模型依赖于两个最拥挤的宿舍来做出决策。这让我们陷入了困境：一方面，观察到的信号非常有趣；FriendHook连接在某些宿舍中比其他宿舍更有可能发生。宿舍大小在这些联系中起着作用。这个见解可能允许FriendHook开发者更好地理解用户行为，也许这种理解将导致更好的用户参与。我们已经获得了这种知识，但我们的当前模型有一个严重的缺点。
- en: Our model focuses mostly on the two largest dorms in the data. This focus may
    not generalize to other college campuses. For instance, consider a campus whose
    dormitories are smaller and hold 200 students at most. The model will completely
    fail to predict user behavior in this instance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式主要关注数据中的两个最大的宿舍。这种关注可能无法推广到其他大学校园。例如，考虑一个宿舍较小，最多容纳200名学生的校园。在这种情况下，模型将完全无法预测用户行为。
- en: Note Theoretically, this situation can be avoided if we divide the dorm size
    by the total student count. This will ensure that the dorm-size feature always
    lies between 0 and 1.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意理论上，如果我们把宿舍大小除以总学生数，就可以避免这种情况。这将确保宿舍大小特征始终介于0和1之间。
- en: More worryingly, we’re dealing with the very real possibility that our model
    simply picked up on behavior that’s unique to just these two specific dorms. This
    is exactly the type of scenario we were asked to avoid in the problem statement.
    What should we do?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人担忧的是，我们面临着这样一个非常现实的可能性，即我们的模型只是捕捉到了仅在这两个特定宿舍中独有的行为。这正是我们在问题陈述中要求避免的场景。我们该怎么办？
- en: Unfortunately, there is no explicit correct answer. Sometimes data scientists
    are forced to make difficult decisions, where each decision carries risks and
    trade-offs. We can keep our feature list as is to maintain high model performance,
    but we run the risk of not being able to generalize to other schools. Alternatively,
    we can remove size-related features and keep our model generalizable at the expense
    of overall performance.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有明确的正确答案。有时数据科学家被迫做出艰难的决定，每个决定都伴随着风险和权衡。我们可以保持我们的特征列表不变以维持高模型性能，但我们也面临着无法推广到其他学校的风险。或者，我们可以移除与大小相关的特征，以牺牲整体性能为代价来保持模型的可推广性。
- en: 'Perhaps there’s a third option: we can try deleting the size-related features
    while also adjusting our choice of classifier. There is a slight chance that we’ll
    achieve comparable performance without relying on dorm size. This is unlikely
    but still worth trying. Let’s assign a copy of the current feature matrix to variable
    `X_with_sizes` (in case we need it later) and then delete all size-related features
    from matrix `X`. We’ll then look for other ways to boost our f-measure beyond
    0.82\.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有第三种选择：我们可以在调整我们的分类器选择的同时尝试删除与大小相关的特征。我们有微小的机会在不依赖宿舍大小的情况下实现可比的性能。这不太可能，但仍值得一试。让我们将当前特征矩阵的一个副本分配给变量`X_with_sizes`（以防我们以后需要它），然后从矩阵`X`中删除所有与大小相关的特征。然后我们将寻找其他方法来提高我们的f度量超过0.82。
- en: Listing 23.36 Deleting all size-related features
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.36 删除所有与大小相关的特征
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 23.4 Optimizing performance across a steady set of features
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.4 在一组稳定的特征上优化性能
- en: In section 22, we learned how random forest models tend to outperform decision
    trees. Will switching the model type from a decision tree to a random forest improve
    performance? Let’s find out.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在第22节中，我们学习了随机森林模型通常如何优于决策树。将模型类型从决策树切换到随机森林会提高性能吗？让我们来看看。
- en: Listing 23.37 Training and evaluating a random forest classifier
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.37 训练和评估随机森林分类器
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Oh no! The performance has actually gotten worse! How can this be? Well, it’s
    an established fact that random forests usually outperform decision trees, but
    this does not guarantee that random forests will always perform better. In certain
    training instances, decision trees are superior to random forests. This appears
    to be one such instance. For our particular dataset, we cannot improve predictive
    performance by switching to a random forest model.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！性能实际上变差了！这是怎么回事呢？好吧，这是一个公认的事实，随机森林通常优于决策树，但这并不能保证随机森林总是表现更好。在某些训练实例中，决策树优于随机森林。这似乎就是这样一种情况。对于我们的特定数据集，我们不能通过切换到随机森林模型来提高预测性能。
- en: 'Note In supervised machine learning, there’s a well-established theorem known
    as the *No Free Lunch Theorem*. In layman’s terms, the theorem states the following:
    it is impossible for a certain training algorithm to always outperform all other
    algorithms. In other words, we cannot rely on a single algorithm for every type
    of training problem. An algorithm that works great most of the time will not work
    great all of the time. Random forests perform well on most problems but not on
    all problems. In particular, random forests perform poorly when prediction depends
    on just one or two inputted features. Random feature sampling can dilute that
    signal and worsen the quality of predictions.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在监督机器学习中，有一个被广泛认可的定理，称为**无免费午餐定理**。用通俗易懂的话来说，这个定理表明以下内容：没有任何一种训练算法能够始终优于所有其他算法。换句话说，我们不能依赖单一算法来解决所有类型的训练问题。一种在大多数情况下表现良好的算法并不意味着它在所有情况下都会表现良好。随机森林在大多数问题上表现良好，但并非在所有问题上都表现良好。特别是，当预测仅依赖于一个或两个输入特征时，随机森林的表现较差。随机特征采样可能会稀释该信号并降低预测的质量。
- en: 'Switching the type of model has not helped. Perhaps instead we can boost performance
    by optimizing on the hyperparameters. In this book, we’ve focused on a single
    decision tree hyperparameter: maximum depth. Currently, maximum depth is set to
    `None`. This means the tree’s depth is not restricted. Will limiting the depth
    improve our predictions? Let’s quickly check using a simple grid search. We scan
    across the `max_depth` parameter values that range from 1 to 100 and settle on
    the depth that optimizes performance.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 切换模型类型并没有帮助。也许我们可以通过优化超参数来提高性能。在这本书中，我们专注于单个决策树超参数：最大深度。目前，最大深度设置为`None`。这意味着树的深度不受限制。限制深度会改善我们的预测吗？让我们快速使用简单的网格搜索来检查。我们扫描从1到100的`max_depth`参数值，并确定优化性能的深度。
- en: Listing 23.38 Optimizing maximum depth using a grid search
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.38 使用网格搜索优化最大深度
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ By passing cv=2, we carry out two-fold cross-validation to be more consistent
    with our current random splitting of (X, y) into training and test datasets. Note
    that the grid search could split our data slightly differently, leading to fluctuations
    in the f-measure value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过传递cv=2，我们执行了两折交叉验证，以更一致地与当前将(X, y)分割为训练集和测试集的随机分割相匹配。请注意，网格搜索可能会以略微不同的方式分割我们的数据，导致f度量值波动。
- en: 'Setting `max_depth` to 5 improves the f-measure from 0.82 to 0.84\. This level
    of performance is comparable with our dorm-size-dependent model. Thus, we have
    achieved performance parity without relying on dorm size. Of course, the story
    is not over: we cannot make a fair comparison without first running a grid search
    on the size-inclusive `X_with_sizes` feature matrix. Will optimizing on `X_with_sizes`
    yield an even better classifier? Let’s find out.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将`max_depth`设置为5将f度量从0.82提高到0.84。这种性能水平与我们的宿舍大小依赖模型相当。因此，我们没有依赖宿舍大小就实现了性能对等。当然，故事还没有结束：我们无法在没有首先在包含大小的`X_with_sizes`特征矩阵上运行网格搜索的情况下进行公平的比较。在`X_with_sizes`上优化会产生更好的分类器吗？让我们来看看。
- en: Note A curious reader may wonder whether our random forest output could be improved
    by running a grid search on the number of trees. In this particular instance,
    the answer is no. Altering the tree count from 100 to some other number will not
    significantly improve performance.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一个好奇的读者可能会想知道，通过在树的数量上运行网格搜索，我们的随机森林输出是否可以得到改善。在这个特定的情况下，答案是肯定的。将树的数量从100更改为其他数字不会显著提高性能。
- en: Listing 23.39 Applying a grid search to size-dependent training data
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.39 将网格搜索应用于大小相关的训练数据
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The grid search did not improve performance on `X_with_sizes`. Thus, we can
    conclude that with the right choice of maximum depth, the size-dependent and size-independent
    models perform with approximately equal quality, and we can train a generalizable,
    size-independent model without sacrificing performance. That’s great news! Let’s
    train a decision tree on `X` using a `max_depth` of 5 and then explore the real-world
    implications of our model.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 网格搜索在`X_with_sizes`上没有提高性能。因此，我们可以得出结论，在正确选择最大深度的情况下，大小相关和大小无关的模型以大约相同的质量表现，我们可以训练一个可泛化的、大小无关的模型，而不会牺牲性能。这是个好消息！让我们使用`max_depth`为5在`X`上训练一个决策树，然后探讨我们模型在现实世界中的影响。
- en: Listing 23.40 Training a decision tree with `max_depth` set to 5
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.40 将`max_depth`设置为5的训练决策树
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 23.5 Interpreting the trained model
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.5 解释训练好的模型
- en: Let’s print our model’s feature importance scores.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出我们模型的特征重要性得分。
- en: Listing 23.41 Ranking features by their importance score
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.41 按重要性得分对特征进行排名
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Only nine important features remain. The top four features pertain to shared
    dorms, social groups, and majors. They are followed by features demarcating the
    category of a user’s *Sex* and *Relationship Status*. Simple network features
    like edge count and PageRank appear at the very bottom of the list. Interestingly
    enough, our friend-sharing likelihood feature doesn’t even make the list! This
    abandoned feature required effort and imagination to implement. It was satisfying
    to see the f-measure rise by 0.06 units once the friend-sharing likelihood was
    added. But in the end, that effort did not matter. With enough additional features,
    the friend-sharing likelihood was rendered irrelevant. Such experiences can sometimes
    feel frustrating. Unfortunately, feature selection is still less of a science
    and more of an art; it is difficult to know in advance which features to use and
    which features to avoid. We cannot know how a feature will integrate holistically
    into a model until we actually train the model. This does not mean we shouldn’t
    get creative—creativity usually pays off. As scientists, we should experiment!
    We should try to use every possible signal at our disposal until adequate performance
    is achieved.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 仅剩下九个重要特征。前四个特征与共享宿舍、社交圈和专业相关。它们后面是标记用户*性别*和*婚姻状况*类别的特征。像边数和PageRank这样的简单网络特征出现在列表的底部。有趣的是，我们的朋友共享可能性特征甚至没有出现在列表上！这个被遗弃的特征需要努力和想象力来实现。当朋友共享可能性被添加后，f-measure上升了0.06个单位，这令人满意。但最终，这些努力并不重要。有了足够多的附加特征，朋友共享可能性变得无关紧要。有时这样的经历可能会让人感到沮丧。不幸的是，特征选择仍然更像是一门艺术而不是科学；我们无法事先知道应该使用哪些特征以及应该避免哪些特征。我们无法知道一个特征将如何整体地整合到一个模型中，直到我们实际训练模型。这并不意味着我们不应该有创意——创意通常会有回报。作为科学家，我们应该进行实验！我们应该尝试使用我们所能利用的每一个可能的信号，直到达到足够的性能。
- en: 'Let’s return to our top features. Only three features have an importance score
    at or above 0.10: *Shared_Dorm_id_fof*, *Shared_Cluster_id_fof*, and *Shared_Major_id_fof*.
    Thus, the model is primarily driven by the following three questions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的顶级特征。只有三个特征的重要性得分在或高于0.10：*Shared_Dorm_id_fof*、*Shared_Cluster_id_fof*和*Shared_Major_id_fof*。因此，模型主要受以下三个问题的驱动：
- en: Do the user and the friend of a friend share a dormitory? Yes or no?
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和朋友的室友是否共享宿舍？是还是否？
- en: Do the user and the friend of a friend share a social group? Yes or no?
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和朋友的室友是否共享社交圈？是还是否？
- en: Do the user and the friend of a friend share a major? Yes or no?
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和朋友的室友是否共享专业？是还是否？
- en: Intuitively, if the answers to all three questions are yes, then the user and
    the friend of a friend are more likely to connect on FriendHook. Let’s test this
    intuition by displaying the tree. We’ll limit the tree’s depth to 3 to simplify
    our output while ensuring that the top three features are represented appropriately.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地看，如果对这三个问题的回答都是肯定的，那么用户和朋友的室友更有可能在FriendHook上建立联系。让我们通过显示树来测试这个直觉。我们将限制树的深度为3，以简化我们的输出，同时确保适当表示前三个特征。
- en: Listing 23.2 Displaying the top branches of the tree
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表23.2 显示树的顶级分支
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ The user and the friend of a friend do not share a dormitory.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用户和朋友的室友不共享宿舍。
- en: ❷ The user and the friend of a friend do not share a social group. Under these
    circumstances, the friend suggestion is ignored (Class 0 dominates).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用户和朋友的室友不共享社交圈。在这种情况下，朋友建议被忽略（类别0占主导地位）。
- en: ❸ The user and the friend of a friend share a dormitory.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 用户和朋友的室友住在同一个宿舍。
- en: ❹ In this branch, Class 2 dominates, and the Sex feature drives Class 2 prediction.
    We’ll soon investigate this unexpected result.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在这个分支中，第 2 类占主导地位，性别特征驱动第 2 类预测。我们将很快调查这个意外结果。
- en: ❺ The user and the friend of a friend share a social group. Under these circumstances,
    the FriendHook connection is likely (Class 1 dominates).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 用户和朋友的室友共享一个社交群体。在这种情况下，FriendHook 连接的可能性很大（第 1 类占主导地位）。
- en: As expected, dorm and social-group sharing primarily drive the model’s predictions.
    If the user and friend of a friend share both a dorm and a social group, they
    are more likely to connect. If they share neither a dorm nor a social group, they
    are less likely to connect. Additionally, individuals can connect if they fall
    in the same social group and share the same major, even if not the same dorm.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，宿舍和社交群体共享主要驱动了模型的预测。如果用户和朋友的室友既共享宿舍又共享社交群体，他们更有可能建立联系。如果他们既不共享宿舍也不共享社交群体，他们不太可能建立联系。此外，如果他们属于同一个社交群体并共享相同的学科，即使不是同一个宿舍，个人也可以建立联系。
- en: Note The text representation of the tree lacks the exact count of class labels
    at each tree branch. As we discussed in section 22, we can produce these counts
    by calling `plot_tree(clf_depth3, feature_names=list(feature_ names))`. For brevity’s
    sake, we don’t generate the tree plot, but you’re encouraged to try this visualization.
    In the visualized tree statistics, you should see that the user and the *FoF*
    share both a cluster and a dorm in 1,635 instances; 93% of these instances represent
    Class 1 labels. Also, you’ll observe that the user and the *FoF* share neither
    cluster nor dorm in 356 instances; 97% of these instances represent Class 0 labels.
    Thus, social group and dorm sharing are strong predictors of user behavior.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：树文本表示缺少每个树分支的精确类别标签计数。正如我们在第 22 节中讨论的，我们可以通过调用 `plot_tree(clf_depth3, feature_names=list(feature_names))`
    来生成这些计数。为了简洁起见，我们没有生成树图，但鼓励您尝试这种可视化。在可视化的树统计中，您应该看到用户和 *FoF* 在 1,635 个实例中共享了同一个集群和宿舍；其中
    93% 的实例代表第 1 类标签。您还会观察到，在 356 个实例中，用户和 *FoF* 既不共享集群也不共享宿舍；其中 97% 的实例代表第 0 类标签。因此，社交群体和宿舍共享是用户行为的强大预测因素。
- en: 'We are nearly ready to deliver to our employer a model based on social groups,
    dorms, and majors. The model’s logic is very straightforward: users who share
    social groups and living spaces or study schedules are more likely to connect.
    There’s nothing surprising about that. What is surprising is how the *Sex* feature
    drives Class 2 label prediction. As a reminder, the Class 2 label corresponds
    to a rejected FriendHook request. According to our tree, rejection is more likely
    when'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好向雇主交付一个基于社交群体、宿舍和专业的模型。模型的逻辑非常简单：共享社交群体和居住空间或学习计划的用户更有可能建立联系。这并不令人惊讶。令人惊讶的是，*性别*特征如何驱动第
    2 类标签预测。作为提醒，第 2 类标签对应于被拒绝的 FriendHook 请求。根据我们的树模型，当以下情况发生时，拒绝的可能性更大：
- en: The users share a dorm but are not in the same social group.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户住在同一个宿舍，但不在同一个社交群体中。
- en: The request sender is of a certain specific sex.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求发送者具有某种特定的性别。
- en: Of course, we know that Class 2 labels are fairly sparse in our data. They occur
    just 1.2% of the time. Perhaps the model’s predictions are caused by random noise
    arising from the sparse sampling. We can find out. Let’s quickly check how well
    we predict rejection. We’ll execute `evaluate` on `(X, y_reject)` where `y_reject[i]`
    equals `2` if `y[i]` equals `2`, and equals `0` otherwise. In other words, we’ll
    evaluate a model that only predicts rejection. If that model’s f-measure is low,
    then our predictions are driven primarily by random noise.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们知道在我们的数据中，第 2 类标签相对稀疏。它们只占 1.2% 的时间。也许模型的预测是由稀疏采样产生的随机噪声引起的。我们可以找出。让我们快速检查我们预测拒绝的能力。我们将对
    `(X, y_reject)` 执行 `evaluate`，其中 `y_reject[i]` 等于 `2` 当 `y[i]` 等于 `2` 时，否则等于 `0`。换句话说，我们将评估一个只预测拒绝的模型。如果该模型的
    f-measure 低，那么我们的预测主要是由随机噪声驱动的。
- en: Listing 23.43 Evaluating a rejection classifier
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.43 评估拒绝分类器
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Wow, the f-measure is actually very high! We can predict rejection very well,
    despite the sparsity of data. What features drive rejection? Let’s check by printing
    the new feature importance scores.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，f-measure 实际上非常高！尽管数据稀疏，我们仍然可以很好地预测拒绝。是什么特征驱动了拒绝？让我们通过打印新的特征重要性分数来检查一下。
- en: Listing 23.44 Ranking features by their importance score
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.44 按重要性分数对特征进行排序
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Interesting! Rejection is primarily driven by the user’s `Sex` and `Relationship_Status`
    attributes. Let’s visualize the trained tree to learn more.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 真是令人惊讶！拒绝主要是由用户的 `性别` 和 `关系状态` 属性驱动的。让我们可视化训练树以了解更多信息。
- en: Listing 23.45 Displaying the rejection-predicting tree
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23.45 显示拒绝预测树
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ The user and the friend of a friend do not share a social group.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用户和朋友的社交圈不共享。
- en: ❷ The user’s relationship status is equal to 3\. If the user’s sex is equal
    to 1, rejection (Class 2) is likely, so rejection is dependent on a user’s sex
    and relationship status.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用户的关系状态等于 3。如果用户的性别等于 1，拒绝（类别 2）的可能性较大，因此拒绝取决于用户的性别和关系状态。
- en: ❸ The user and the friend of a friend share a social group. Under such circumstances,
    rejection is unlikely.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 用户和朋友的社交圈共享。在这种情况下，拒绝的可能性不大。
- en: 'According to the tree, rejection is likely to occur under the following circumstances:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 根据树形图，以下情况下很可能会发生拒绝：
- en: The users do not belong to the same social group.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不属于同一个社交圈。
- en: The users share either a dorm or a major.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户共享宿舍或专业。
- en: The sender’s sex is Category 1.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者的性别属于类别 1。
- en: The sender’s relationship status is Category 3\. According to the tree, the
    status category must be greater than 2.5\. However, the maximum value of `df_Profile
    .Relationship_Status` is 3.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者的关系状态属于类别 3。根据树形图，状态类别必须大于 2.5。然而，`df_Profile .Relationship_Status` 的最大值是
    3。
- en: Essentially, individuals with *Sex* Category 1 and *Relationship Status* Category
    3 are sending friend requests to people outside their social group. These friend
    requests are likely to get rejected. Of course, we cannot precisely identify the
    categories that lead to rejection, but as scientists, we can still speculate.
    Given what we know about human nature, it wouldn’t be surprising if this behavior
    is driven by single men. Perhaps men are trying to connect with women outside
    their social group to get a date; if so, their requests are likely to be rejected.
    Again, all this is speculation, but this hypothesis is worth discussing with the
    product managers at FriendHook. If our hypothesis is correct, then certain changes
    should be introduced to the product. More steps could be taken to limit unwanted
    dating requests. Alternatively, new product changes could be added that make it
    easier for single people to connect.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，属于 *性别* 类别 1 和 *关系状态* 类别 3 的人向社交圈外的人发送好友请求。这些好友请求很可能会被拒绝。当然，我们无法精确地识别导致拒绝的类别，但作为科学家，我们仍然可以推测。鉴于我们对人性的了解，如果这种行为是由单身男性驱动的，这并不令人惊讶。也许男性试图与社交圈外的女性建立联系以约会；如果是这样，他们的请求很可能会被拒绝。再次强调，所有这些都是推测，但这个假设值得与
    FriendHook 的产品经理进行讨论。如果我们的假设是正确的，那么应该对产品进行某些更改。可以采取更多步骤来限制不受欢迎的约会请求。或者，可以添加新的产品更改，使单身人士更容易建立联系。
- en: 23.5.1 Why are generalizable models so important?
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.5.1 为什么可推广的模型如此重要？
- en: In this case study, we have agonized over keeping our model generalizable. A
    model that does not generalize beyond the training set is worthless, even if the
    performance score seems high. Unfortunately, it’s hard to know whether a model
    can generalize until it’s tested on external data. But we can try to remain aware
    of hidden biases that won’t generalize well to other datasets. Failure to do so
    can yield serious consequences. Consider the following true story.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我们一直在努力保持模型的可推广性。一个不能推广到训练集之外的模型即使性能评分很高也是无价值的。不幸的是，直到在外部数据上测试，我们才知道模型是否可以推广。但我们可以尝试保持对那些不会很好地推广到其他数据集的隐藏偏差的意识。未能做到这一点可能会导致严重后果。考虑以下真实故事。
- en: For many years, machine learning researchers have tried to automate the field
    of radiology. In radiology, trained doctors examine medical images (such as X-rays)
    to diagnose disease. This can be treated as a supervised learning problem in which
    the images are features and the diagnoses are class labels. By the year 2016,
    multiple radiology models were published in the scientific literature. Each published
    model was supposed to be highly accurate based on internal evaluation. That year,
    leading machine learning researchers publicly declared that “we should stop training
    radiologists” and that “radiologists should be worried about their jobs.” Four
    years later, the negative publicity had led to a worldwide radiologist shortage—medical
    students were reluctant to enter a field that seemed destined for full automation.
    But by 2020, the promise of automation had failed to materialize. Most of the
    published models performed very poorly on new data. Why? Well, it turns out that
    imaging outputs differ from hospital to hospital. Different hospitals use slightly
    different lighting and different settings on their imaging machines. Thus, a model
    trained at Hospital A could not generalize well to Hospital B. Despite their seemingly
    high performance scores, the models were not fit for generalized use. The machine
    learning researchers had been too optimistic; they failed to take into account
    the biases inherent in their data. These failures inadvertently led to a crisis
    in the medical community. A more thoughtful evaluation of generalizability could
    have prevented this from happening.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，机器学习研究人员一直在尝试自动化放射学领域。在放射学中，经过培训的医生检查医学图像（如X光片）以诊断疾病。这可以被视为一个监督学习问题，其中图像是特征，诊断是类别标签。到2016年，科学文献中发表了多个放射学模型。每个发布的模型都基于内部评估被认为是高度准确的。那年，领先的机器学习研究人员公开宣布“我们应该停止培训放射科医生”，并且“放射科医生应该担心他们的工作。”四年后，负面宣传导致了全球放射科医生短缺——医学学生不愿意进入一个似乎注定要完全自动化的领域。但到了2020年，自动化的承诺未能实现。大多数发布的模型在新数据上的表现非常差。为什么？好吧，结果是，成像输出因医院而异。不同的医院使用不同的照明和成像机器上的不同设置。因此，在A医院训练的模型无法很好地推广到B医院。尽管这些模型似乎有很高的性能评分，但它们并不适合通用。机器学习研究人员过于乐观；他们未能考虑到他们数据中固有的偏差。这些失败无意中导致了医疗界的危机。更细致的泛化性评估本可以防止这种情况发生。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Superior machine learning algorithms do not necessarily work in every situation.
    Our decision tree model outperformed our random forest model, even though random
    forests are considered superior in the literature. We should never blindly assume
    that a model will always work well in every possible scenario. Instead, we should
    intelligently calibrate our model choice based on the specifics of the problem.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀的机器学习算法并不一定在每种情况下都有效。尽管随机森林在文献中被认为更优越，但我们的决策树模型的表现超过了随机森林模型。我们永远不应该盲目地假设一个模型在所有可能的场景中都会表现良好。相反，我们应该根据问题的具体情况进行智能地调整我们的模型选择。
- en: Proper feature selection is less of a science and more of an art. We cannot
    always know in advance which features will boost a model’s performance. However,
    the commonsense integration of diverse and interesting features into our model
    should eventually improve prediction quality.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的特征选择与其说是一门科学，不如说是一门艺术。我们并不能总是事先知道哪些特征会提升模型的表现。然而，将各种多样且有趣的特征常识性地整合到我们的模型中，最终应该会提高预测质量。
- en: We should pay careful attention to the features we feed into our model. Otherwise,
    the model may not generalize to other datasets.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该仔细关注我们输入到模型中的特征。否则，模型可能无法推广到其他数据集。
- en: Proper hyperparameter optimization can sometimes significantly boost a model’s
    performance.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的超参数优化有时可以显著提高模型的表现。
- en: Occasionally, it seems like nothing is working and our data is simply insufficient.
    However, with grit and perseverance, we can eventually yield meaningful resources.
    Remember, a good data scientist should never give up until they have exhausted
    every possible avenue of analysis.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，似乎什么都没起作用，我们的数据似乎也过于不足。然而，凭借毅力和坚持不懈，我们最终可以产生有意义的资源。记住，一个好的数据科学家应该在穷尽所有可能的分析途径之前永不放弃。
