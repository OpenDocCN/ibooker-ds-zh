- en: 3 Ascending to the 3D world
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 升级到三维世界
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building a mental model for 3D vectors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为3D矢量建立心理模型
- en: Doing 3D vector arithmetic
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行3D矢量运算
- en: Using the dot product and cross product to measure lengths and directions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点积和叉积来测量长度和方向
- en: Rendering a 3D object in 2D
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在2D中渲染3D对象
- en: The 2D world is easy to visualize, but the real world has three dimensions.
    Whether we are using software to design a building, animate a movie, or run an
    action game, our programs need to be aware of the three spatial dimensions in
    which we live.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 2D世界容易可视化，但现实世界有三个维度。无论我们是用软件设计建筑、制作动画电影还是运行动作游戏，我们的程序都需要意识到我们生活的三个空间维度。
- en: In a 2D space, like a page of this book, we have a vertical and a horizontal
    direction. Adding a third dimension, we could also talk about points outside of
    the page or arrows perpendicular to the page. But even when programs simulate
    three dimensions, most computer displays are two-dimensional. Our mission in this
    chapter is to build the tools we need to take 3D objects measured by 3D vectors
    and convert them to 2D so our objects can show up on the screen.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个2D空间中，就像这本书的页面一样，我们有一个垂直和水平方向。增加一个第三维度，我们也可以谈论页面外的点或垂直于页面的箭头。但即使程序模拟三维，大多数计算机显示器仍然是二维的。本章的使命是构建我们需要的工具，将3D矢量测量的3D对象转换为2D，以便我们的对象可以在屏幕上显示。
- en: A sphere is one example of a 3D shape. A successfully drawn 3D sphere could
    look like the one shown in figure 3.1\. Without the shading, it would just look
    like a circle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 球体是3D形状的一个例子。一个成功绘制的3D球体可能看起来像图3.1中所示的那样。如果没有阴影，它看起来就像一个圆。
- en: '![](../Images/CH03_F01_Orland.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F01_Orland.png)'
- en: Figure 3.1 Shading on a 2D circle makes it look like a 3D sphere.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 在2D圆上的阴影使其看起来像一个3D球体。
- en: The shading shows that light hits our sphere at a certain angle in 3D and gives
    it an illusion of depth. Our general strategy is not to draw a perfectly round
    sphere, but an approximation made up of polygons. Each polygon can be shaded according
    to the precise angle it makes with a light source. Believe it or not, figure 3.1
    is not a picture of a round ball, but of 8,000 triangles in varying shades. Figure
    3.2 shows another example with fewer triangles.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影表明光线以一定的角度击中我们的球体，给它一种深度错觉。我们的总体策略不是绘制一个完美的球体，而是一个由多边形组成的近似。每个多边形都可以根据它与光源形成的精确角度进行着色。信不信由你，图3.1不是圆球的图片，而是8,000个不同阴影的三角形。图3.2显示了另一个具有较少三角形的例子。
- en: '![](../Images/CH03_F02a_Orland.png) ![](../Images/CH03_F02b_Orland.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02a_Orland.png) ![](../Images/CH03_F02b_Orland.png)'
- en: Figure 3.2 Drawing a shaded sphere using many small, solid-colored triangles
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 使用许多小、单色的三角形绘制阴影球体
- en: 'We have the mathematical machinery to define a triangle on a 2D screen: we
    only need the three 2D vectors defining the corners. But we can’t decide how to
    shade them unless we also think of them as having a life in three dimensions.
    For this, we need to learn to work with 3D vectors.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有数学工具在2D屏幕上定义一个三角形：我们只需要定义角落的三个2D矢量。但除非我们也认为它们在三维空间中有生命，否则我们无法决定如何给它们上色。为此，我们需要学会与3D矢量一起工作。
- en: Of course, this is already a solved problem, and we start by using a pre-built
    library to draw our 3D shapes. Once we have the feel for the world of 3D vectors,
    we can build our own renderer and show how to draw the sphere.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这已经是一个已解决的问题，我们首先使用预构建的库来绘制我们的3D形状。一旦我们对3D矢量的世界有了感觉，我们就可以构建自己的渲染器，并展示如何绘制球体。
- en: 3.1 Picturing vectors in 3D space
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 在3D空间中描绘矢量
- en: 'In the 2D plane, we worked with three interchangeable mental models of a vector:
    coordinate pairs, arrows of fixed length and direction, and points positioned
    relative to the origin. Because the pages of this book have a finite size, we
    limited our view to a small portion of the plane−a rectangle of fixed height and
    width like the one shown in figure 3.3.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D平面上，我们使用了三个可互换的矢量心理模型：坐标对、固定长度和方向的箭头，以及相对于原点的点。由于这本书的页面大小有限，我们只将视野限制在平面的一小部分——一个高度和宽度固定的矩形，如图3.3所示。
- en: '![](../Images/CH03_F03_Orland.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Orland.png)'
- en: Figure 3.3 The height and width of a small segment of the 2D plane
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 2D平面上一个小段的高度和宽度
- en: We can interpret a 3D vector in similar ways. Instead of viewing a rectangular
    portion of the plane, we start with a finite box of 3D space. Such a 3D box, pictured
    in figure 3.4, has a finite height, width, and depth. *In 3D, we* keep the notions
    of *x* and *y* directions, and we add a *z* direction with which to measure the
    depth.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式解释3D向量。我们不是查看平面的矩形部分，而是从一个有限的3D空间盒子开始。如图3.4所示，这样的3D盒子具有有限的高度、宽度和深度。在3D中，我们保持*x*和*y*方向的概念，并添加一个*z*方向来测量深度。
- en: '![](../Images/CH03_F04_Orland.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F04_Orland.png)'
- en: Fogure 3.4 A small finite box of 3D space has a width (*x*), a height (*y*),
    and a depth (*z*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 一个3D空间的小有限盒子具有宽度(*x*)、高度(*y*)和深度(*z*)。
- en: We can think of any 2D vectors as living in 3D space, having the same size and
    orientation but fixed to a plane where the depth *z* is zero. Figure 3.5 shows
    the 2D drawing of the vector (4, 3) embedded in 3D space with all the same features
    it had before. The second drawing (on the bottom) annotates all of the features
    that are still included.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何2D向量视为存在于3D空间中，具有相同的大小和方向，但固定在一个平面上，其中深度*z*为零。图3.5显示了向量(4, 3)在3D空间中的2D绘制，保留了它之前所有的特征。第二幅图（在底部）标注了所有仍然包含的特征。
- en: '![](../Images/CH03_F05_Orland.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F05_Orland.png)'
- en: Figure 3.5 The 2D world and inhabitant vector (4, 3) contained in the 3D world
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 包含在3D世界中的2D世界和居民向量(4, 3)
- en: The dashed lines form a rectangle in the 2D plane where depth is zero. It’s
    helpful to draw dashed lines meeting at right angles to help us locate points
    in 3D. Otherwise, our perspective might deceive us and a point may not be where
    we think it is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线形成了一个在深度为零的2D平面上的矩形。画虚线相交成直角有助于我们在3D中定位点。否则，我们的视角可能会欺骗我们，一个点可能不在我们认为它所在的位置。
- en: Our vector still lives in a plane, but now we can also see it lives in a bigger
    3D space. We can draw another 3D vector (a new arrow and a new point) that lives
    off of the original plane, extending to a higher depth value (figure 3.6).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的向量仍然生活在平面上，但现在我们也可以看到它生活在更大的3D空间中。我们可以在原始平面上方绘制另一个3D向量（一个新的箭头和一个新的点），它延伸到更高的深度值（图3.6）。
- en: '![](../Images/CH03_F06_Orland.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F06_Orland.png)'
- en: Figure 3.6 A vector extending into the third dimension as compared to the 2D
    world and its inhabitant vector (4, 3) of figure 3.5
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 与图3.5的2D世界及其居民向量(4, 3)相比，一个向量延伸到第三维度
- en: To make the location of this second vector clear, I drew a dashed box instead
    of a dashed rectangle as in figure 3.5\. In figure 3.6, this box shows the length,
    width, and depth the vector covers in 3D space. Arrows and points work as mental
    models for vectors in 3D just like in 2D, and we can measure them similarly with
    coordinates.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使第二个向量的位置清晰，我画了一个虚线盒子而不是图3.5中的虚线矩形。在图3.6中，这个盒子显示了向量在3D空间中覆盖的长度、宽度和深度。箭头和点在3D中作为向量的心理模型，就像在2D中一样，我们可以用坐标相似地测量它们。
- en: 3.1.1 Representing 3D vectors with coordinates
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 使用坐标表示3D向量
- en: The pair of numbers (4, 3) is enough to specify a single point or arrow in 2D,
    but in 3D, there are numerous points with an *x*-coordinate of 4 and a *y*-coordinate
    of 3\. In fact, as figure 3.7 shows, there is a whole line of points in 3D with
    these coordinates, each having different positions in the *z*(or depth) direction.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这一对数字(4, 3)足以指定2D中的一个单独的点或箭头，但在3D中，有无数个点具有*x*坐标为4和*y*坐标为3。事实上，如图3.7所示，有一个整个点线在3D空间中具有这些坐标，每个点在*z*（或深度）方向上都有不同的位置。
- en: '![](../Images/CH03_F07_Orland.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F07_Orland.png)'
- en: Figure 3.7 Several vectors with the same x- and y-coordinates but with different
    z-coordinates
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 几个具有相同的x和y坐标但具有不同z坐标的向量
- en: To specify a unique point in 3D, we need three numbers in total. A triple of
    numbers like (4, 3, 5) are called the *x* -, *y* -, and *z*-coordinates for a
    vector in 3D. As before, we can read these as instructions to find the desired
    point. As shown in figure 3.8, to get to the point (4, 3, 5), we first go +4 units
    in the *x* direction, then go +3 units in the *y* direction, and then finally,
    go +5 units in the *z* direction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定3D中的一个唯一点，我们需要总共三个数字。像(4, 3, 5)这样的数字组合被称为3D向量中的*x*、*y*和*z*坐标。和之前一样，我们可以将这些读作找到所需点的指令。如图3.8所示，要到达点(4,
    3, 5)，我们首先在*x*方向上移动+4个单位，然后在*y*方向上移动+3个单位，最后在*z*方向上移动+5个单位。
- en: '![](../Images/CH03_F08_Orland.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F08_Orland.png)'
- en: Figure 3.8 The three coordinates (4, 3, 5) give us directions to a point in
    3D.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 三个坐标(4, 3, 5)为我们提供了到达3D中一个点的方向。
- en: 3.1.2 3D drawing with Python
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 使用Python进行3D绘制
- en: As in the previous chapter, I use a wrapper around Python’s Matplotlib library
    to make vector drawings in 3D. You can find the implementation in the source code
    for this book, but I’ll stick with the wrapper to focus on the conceptual process
    of drawing rather than the details of Matplotlib.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章一样，我使用 Python 的 Matplotlib 库的包装器来绘制 3D 向量图。您可以在本书的源代码中找到实现，但我会坚持使用包装器来关注绘制的过程概念，而不是
    Matplotlib 的细节。
- en: My wrapper uses new classes like `Points3D` and `Arrow3D` to distinguish 3D
    objects from their 2D counterparts. A new function, `draw3d`, knows how to interpret
    and render these objects so as to make these look three-dimensional. By default,
    `draw3d()` shows the axes and the origin as well as a small box of 3D space (figure
    3.9), even if no objects are specified for drawing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我的包装器使用新的类如 `Points3D` 和 `Arrow3D` 来区分 3D 对象和它们的 2D 对应物。一个新的函数 `draw3d` 知道如何解释和渲染这些对象，以便使它们看起来是三维的。默认情况下，`draw3d()`
    显示坐标轴和原点，以及一个小型的 3D 空间框（图 3.9），即使没有指定要绘制的对象。
- en: '![](../Images/CH03_F09_Orland.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F09_Orland.png)'
- en: Figure 3.9 Drawing an empty 3D region with Matplotlib’s `draw3d()`
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 使用 Matplotlib 的 `draw3d()` 绘制空 3D 区域
- en: The x-, y-, and z-axes that are drawn are perpendicular in the space, despite
    being skewed by our perspective. For visual clarity, Matplotlib shows the units
    outside the box, but the origin and the axes themselves are displayed within the
    box. The origin is the coordinate (0, 0, 0), and the axes emanate from it in the
    positive and negative *x*, *y*, and *z* directions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管由于我们的视角而显得倾斜，但绘制的 x、y 和 z 轴在空间中是垂直的。为了提高视觉效果，Matplotlib 将单位显示在框外，但原点和坐标轴本身显示在框内。原点是坐标
    (0, 0, 0)，坐标轴从它向正负 *x*、*y* 和 *z* 方向延伸。
- en: 'The `Points3D` class stores a collection of vectors we want to think of as
    points and, therefore, draw as dots in 3D space. For instance, we could plot the
    vectors (2, 2, 2) and (1, −2, −2) with the following code that produces figure
    3.10:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Points3D` 类存储了我们想要将其视为点并因此绘制为 3D 空间中点的向量集合。例如，我们可以使用以下代码绘制向量 (2, 2, 2) 和 (1,
    −2, −2)，该代码生成图 3.10：'
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/CH03_F10_Orland.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F10_Orland.png)'
- en: Figure 3.10 Drawing the points (2, 2, 2) and (1, −2, −2)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 绘制点 (2, 2, 2) 和 (1, −2, −2)
- en: 'To visualize these vectors instead as arrows, we can represent the vectors
    as `Arrow3D` objects. We can also connect the tips of arrows with a `Segment3D`
    object as follows, producing figure 3.11:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些向量可视化为箭头，我们可以将向量表示为 `Arrow3D` 对象。我们还可以使用 `Segment3D` 对象连接箭头的尖端，如下所示，生成图
    3.11：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/CH03_F11_Orland.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F11_Orland.png)'
- en: Figure 3.11 Drawing 3D arrows
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 绘制 3D 箭头
- en: 'It’s a bit hard to see which direction the arrows are pointing in figure 3.11\.
    To make it clearer, we can draw dashed boxes around the arrows to make them look
    more three-dimensional. Because we’ll draw these boxes so frequently, I created
    a `Box3D` class to represent a box with one corner at the origin and the opposite
    one at a given point. Figure 3.12 illustrates the 3D box, but first, here’s the
    code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 3.11 中，箭头指向的方向有点难以看清。为了使其更清晰，我们可以围绕箭头绘制虚线框，使其看起来更有三维感。由于我们将频繁地绘制这些框，我创建了一个
    `Box3D` 类来表示一个角落位于原点，相对角落位于给定点的框。图 3.12 展示了 3D 框，但首先，这是代码：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Fogire 3.12 Drawing boxes to make our arrows look 3D
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 绘制框以使我们的箭头看起来像 3D
- en: '*In this chapter*, I use a number of (hopefully self-explanatory) keyword arguments
    without introducing them explicitly. For instance, a `color` keyword argument
    can be passed to most of these constructors, controlling the color of the object
    that shows up in the drawing.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中*，我使用了多个（希望是自解释的）关键字参数，而没有明确介绍它们。例如，可以将 `color` 关键字参数传递给这些构造函数中的大多数，以控制绘制中出现的对象的颜色。'
- en: 3.1.3 Exercises
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 练习
- en: '| **Exercise 3.1**: Draw the 3D arrow and point representing the coordinates
    (−1, −2, 2) as well as the dashed box that makes the arrow look 3D. Do this drawing
    by hand for practice, but from now on, we’ll use Python to draw for us.**Solution**:![](../Images/CH03_F12_Orland_UN01.png)The
    vector (−1, −2, 2) and the box that makes it look 3D |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.1**：绘制表示坐标 (−1, −2, 2) 的 3D 箭头和虚线框，使箭头看起来像 3D。为了练习，请手动绘制此图，但从现在起，我们将使用
    Python 来绘制。**解答**：![图片](../Images/CH03_F12_Orland_UN01.png)向量 (−1, −2, 2) 和使其看起来像
    3D 的框 |'
- en: '| **Exercise 3.2-Mini Project**: There are exactly eight 3D vectors whose coordinates
    are all either +1 or −1\. For instance, (1, −1, 1) is one of these. Plot all of
    these eight vectors as points. Then figure out how to connect them with line segments
    using `Segment3D` objects to form the outline of a cube.**Hint**: You’ll need
    12 segments in total.**Solution**: Because there are only 8 vertices and 12 edges,
    it’s not too tedious to list them all, but I decided to enumerate them with a
    list comprehension. For the vertices, I let *x*, *y*, and *z* range over the list
    of two possible values `[1,−1]` and collected the eight results. For the edges,
    I grouped them into three sets of four that point in each coordinate direction.
    For instance, there are four edges that go from *x* = −1 to *x* = 1, while their
    *y* − and *z*-coordinates are the same at both endpoints:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习3.2-迷你项目**：恰好有八个三维向量的坐标都是+1或-1。例如，(1, -1, 1)就是其中之一。将这些八个向量作为点绘制出来。然后找出如何使用`Segment3D`对象通过线段将它们连接起来，以形成立方体的轮廓。**提示**：总共需要12条线段。**解决方案**：因为只有8个顶点和12条边，所以列出它们并不太繁琐，但我决定使用列表推导来枚举它们。对于顶点，我让*x*、*y*和*z*在可能的值列表`[1,−1]`上遍历，并收集了八个结果。对于边，我将它们分为三组，每组四条，指向每个坐标方向。例如，有四条边从*x*
    = −1到*x* = 1，而它们的*y*和*z*坐标在两端点都是相同的：'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../Images/CH03_F12_Orland_UN02.png)The cube with all vertex coordinates
    equal to +1 or −1 |'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/CH03_F12_Orland_UN02.png)所有顶点坐标都等于+1或-1的立方体 |'
- en: 3.2 Vector arithmetic in 3D
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 三维空间的向量运算
- en: With these Python functions in hand, it’s easy to visualize the results of vector
    arithmetic in three dimensions. All of the arithmetic operations we saw in 2D
    have analogies in 3D, and the geometric effects of each are similar.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些Python函数，我们可以轻松地可视化三维空间中向量运算的结果。我们在二维空间中看到的所有算术运算在三维空间中都有类似之处，并且它们的几何效果也相似。
- en: 3.2.1 Adding 3D vectors
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 三维向量的加法
- en: In 3D, vector addition can still be accomplished by adding coordinates. The
    vectors (2, 1, 1) and (1, 2, 2) sum to (2 + 1, 1 + 2, 1 + 2) = (3, 3, 3). We can
    start at the origin and place the two input vectors tip-to-tail in either order
    to get to the sum point (3, 3, 3) (figure 3.13).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维空间中，向量的加法仍然可以通过加坐标来完成。向量(2, 1, 1)和(1, 2, 2)相加得到(2 + 1, 1 + 2, 1 + 2) = (3,
    3, 3)。我们可以从原点开始，以任意顺序将两个输入向量尾对尾放置，以得到和点(3, 3, 3)（图3.13）。
- en: '![](../Images/CH03_F13a_Orland.png) ![](../Images/CH03_F13b_Orland.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F13a_Orland.png) ![图片](../Images/CH03_F13b_Orland.png)'
- en: Figure 3.13 Two visual examples of vector addition in 3D
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 两个三维向量加法的视觉示例
- en: As in 2D, we can add any number of 3D vectors together by summing all of their
    *x*-coordinates, all of their *y*-coordinates, and all of their *z*-coordinates.
    These three sums give us the coordinates of the new vector. For instance, in the
    sum (1, 1, 3) + (2, 4, −4) + (4, 2, −2), the respective *x*-coordinates are 1,
    2, and 4, which sum to 7\. The *y*-coordinates sum to 7 as well, and the *z*-coordinates
    sum to −3; therefore, the vector sum is (7, 7, −3). Tip-to-tail, the three vectors
    look like those in figure 3.14.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与二维空间类似，我们可以通过将所有三维向量的*x*坐标、*y*坐标和*z*坐标相加来相加任意数量的三维向量。这三个总和给出了新向量的坐标。例如，在求和(1,
    1, 3) + (2, 4, −4) + (4, 2, −2)中，相应的*x*坐标是1、2和4，总和为7。*y*坐标的总和也是7，*z*坐标的总和为-3；因此，向量之和是(7,
    7, −3)。尾对尾地，这三个向量看起来就像图3.14中的那些。
- en: '![](../Images/CH03_F14_Orland.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F14_Orland.png)'
- en: Figure 3.14 Adding three vectors tip-to-tail in 3D
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 在三维空间中尾对尾相加三个向量
- en: 'In Python, we can write a concise function to sum any number of input vectors,
    and that works in two or three dimensions (or an even higher number of dimensions
    as we’ll see later). Here it is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以编写一个简洁的函数来求和任意数量的输入向量，这适用于二维或三维（或我们稍后将看到的更高维数）。下面是它的样子：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s break it down. Calling Python’s `zip` function on the input vectors extracts
    their x-coordinates, *y*-coordinates, and *z*-coordinates. For instance,
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。在输入向量上调用Python的`zip`函数可以提取它们的x坐标、*y*坐标和*z*坐标。例如，
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '(You need to convert the `zip` result to a list to display its values.) If
    we apply Python’s `sum` function to each of the grouped coordinates, we get the
    sums of *x*, *y*, and *z* values, respectively:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: （您需要将`zip`的结果转换为列表以显示其值。）如果我们对每个分组的坐标应用Python的`sum`函数，我们将分别得到*x*、*y*和*z*值的总和：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, for consistency, we convert this from a list to a tuple because we’ve
    represented all of our vectors as tuples to this point. The result is the tuple
    (7, 7, 3). We could also have written the `add` function as the following one-liner
    (which is perhaps less Pythonic):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了保持一致性，我们将这个列表转换为元组，因为我们已经将所有向量表示为元组。结果是元组 (7, 7, 3)。我们也可以将 `add` 函数写成以下单行代码（这可能不太符合
    Python 风格）：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 3.2.2 Scalar multiplication in 3D
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 三维中的标量乘法
- en: To multiply a 3D vector by a scalar, we multiply all of its components by the
    scalar factor. For example, the vector (1, 2, 3) multiplied by the scalar 2 gives
    us (2, 4, 6). This resulting vector is twice as long but points in the same direction
    as in the 2D case. Figure 3.15 shows ***v*** = (1, 2, 3) and its scalar multiple
    2 · ***v*** = (2, 4, 6).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个三维向量乘以一个标量，我们需要将其所有分量乘以标量因子。例如，向量 (1, 2, 3) 乘以标量 2 得到 (2, 4, 6)。这个结果向量长度是原来的两倍，但方向与二维情况相同。图
    3.15 展示了 ***v*** = (1, 2, 3) 和其标量倍数 2 · ***v*** = (2, 4, 6)。
- en: '![](../Images/CH03_F15_Orland.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F15_Orland.png)'
- en: Figure 3.15 Scalar multiplication by 2 returns a vector pointing in the same
    direction, which is twice as long as the original vector.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 将向量乘以 2 的标量乘法得到一个指向相同方向的向量，其长度是原始向量的两倍。
- en: 3.2.3 Subtracting 3D vectors
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 减去三维向量
- en: In 2D, the difference of the two vectors ***v*** − ***w*** is the vector “from
    ***w*** to ***v***,” which is called the *displacement* . In 3D, the story is
    the same; in other words, ***v*** − ***w*** is the displacement from ***w*** to
    ***v***, which is the vector you can add to ***w*** to get ***v***. Thinking of
    ***v*** and ***w*** as arrows from the origin, the difference ***v*** − ***w***
    is an arrow that can be positioned to have its tip at the tip of ***v*** and its
    tail at the tip of ***w***. Figure 3.16 shows the difference of ***v*** = (−1,
    −3, 3) and ***w*** = (3, 2, 4), both as an arrow from ***w*** to ***v*** and as
    a point in its own right.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维中，两个向量 ***v*** − ***w*** 的差是“从 ***w*** 到 ***v***”的向量，这被称为 *位移*。在三维中，故事是一样的；换句话说，***v***
    − ***w*** 是从 ***w*** 到 ***v*** 的位移，这是你可以加到 ***w*** 上以得到 ***v*** 的向量。将 ***v***
    和 ***w*** 视为从原点出发的箭头，***v*** − ***w*** 的差是一个箭头，可以定位使其尖端在 ***v*** 的尖端，其尾部在 ***w***
    的尖端。图 3.16 展示了 ***v*** = (−1, −3, 3) 和 ***w*** = (3, 2, 4) 的差，既作为从 ***w*** 到 ***v***
    的箭头，也作为一个独立的点。
- en: '![](../Images/CH03_F16a_Orland.png) ![](../Images/CH03_F16b_Orland.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F16a_Orland.png) ![图片](../Images/CH03_F16b_Orland.png)'
- en: Figure 3.16 Subtracting the vector *w* from the vector *v* gives the displacement
    from *w* to v.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 从向量 *v* 中减去向量 *w* 得到从 *w* 到 *v* 的位移。
- en: Subtracting a vector ***w*** from a vector ***v*** is accomplished in coordinates
    by taking the difference of the coordinates of ***v*** and ***w***. For instance,
    ***v*** − ***w*** gives us (−1 −3, −3 − 2, 3 − 4) = (−4, −5, −1) as a result.
    These coordinates agree with the picture of ***v*** − ***w*** in figure 3.16,
    which shows it’s a vector pointing in the negative *x*, negative *y*, and negative
    *z* directions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从向量 ***v*** 中减去向量 ***w*** 在坐标上是通过取 ***v*** 和 ***w*** 的坐标之差来完成的。例如，***v*** −
    ***w*** 得到 (−1 −3, −3 − 2, 3 − 4) = (−4, −5, −1) 作为结果。这些坐标与图 3.16 中 ***v*** −
    ***w*** 的图像一致，它显示它是一个指向负 *x*、负 *y* 和负 *z* 方向的向量。
- en: When I claim scalar multiplication by two makes a vector “twice as long,” I’m
    thinking in terms of geometric similarity. If each of the three components of
    ***v*** are doubled, corresponding to doubling the length, width, and depth of
    the box, the diagonal distance from one corner to the other should also double.
    To actually measure and confirm this, we need to know how to calculate distances
    in 3D.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我声称标量乘以二会使向量“长度加倍”时，我是从几何相似性的角度考虑的。如果 ***v*** 的三个分量都加倍，对应于长、宽和深的加倍，那么从一个角到另一个角的斜对角距离也应该加倍。为了实际测量和确认这一点，我们需要知道如何计算三维空间中的距离。
- en: 3.2.4 Computing lengths and distances
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 计算长度和距离
- en: In 2D, we calculated the length of a vector with the Pythagorean theorem, using
    the fact that an arrow vector and its components make a right triangle. Likewise,
    the distance between two points in the plane was just the length of their difference
    as a vector.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维中，我们使用勾股定理计算向量的长度，利用事实是箭头向量和其分量构成一个直角三角形。同样，平面上两点之间的距离只是它们差向量的长度。
- en: We have to look a bit closer, but we can still find a suitable right triangle
    in 3D to help us calculate the length of a vector. Let’s try to find the length
    of the vector (4, 3, 12). The *x* and *y* components still give us a right triangle
    lying in the plane where *z* = 0\. This triangle’s hypotenuse, or diagonal side,
    has length ![](../Images/CH03_F17_a_Orland.png). If this were a 2D vector, we’d
    be done, but the *z* component of 12 makes this vector quite a bit longer (figure
    3.17).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更仔细地观察，但我们仍然可以在三维中找到一个合适的直角三角形来帮助我们计算向量的长度。让我们尝试找到向量(4, 3, 12)的长度。*x*和*y*分量仍然给我们一个在*z*
    = 0的平面上的直角三角形。这个三角形的斜边，或对角边，长度为![图片](../Images/CH03_F17_a_Orland.png)。如果这是一个二维向量，我们就完成了，但12的*z*分量使这个向量变得相当长（图3.17）。
- en: '![](../Images/CH03_F17_Orland.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F17_Orland.png)'
- en: Figure 3.17 Applying the Pythagorean theorem to find the length of a hypotenuse
    in the x,y plane
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 在x,y平面上应用勾股定理找到斜边长度
- en: 'So far all of the vectors we’ve considered lie in the *x*,*y* plane where *z*
    = 0\. The *x* component is (4, 0, 0), the *y* component is (0, 3, 0), and their
    vector sum is (4, 3, 0). The *z* component of (0, 0, 12) is perpendicular to all
    three of these. That’s useful because it gives us a second right triangle in the
    diagram: the one formed by (4, 3, 0) and (0, 0, 12) and placed tip-to-tail. The
    hypotenuse of this triangle is our original vector (4, 3, 12), whose length we
    want to find. Let’s focus on this second right triangle and invoke the Pythagorean
    theorem again to find the hypotenuse length (shown in figure 3.18).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑的所有向量都位于*z* = 0的*x*,*y*平面中。*x*分量是(4, 0, 0)，*y*分量是(0, 3, 0)，它们的向量和是(4,
    3, 0)。向量(0, 0, 12)的*z*分量垂直于这三个分量。这很有用，因为它给我们图中的第二个直角三角形：由(4, 3, 0)和(0, 0, 12)组成的三角形，并放置在尖端。这个三角形的斜边是我们原始的向量(4,
    3, 12)，我们想要找到其长度。让我们专注于这个第二个直角三角形，并再次应用勾股定理来找到斜边长度（如图3.18所示）。
- en: '![](../Images/CH03_F18_Orland.png)![](../Images/w_gifs_143.gif)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F18_Orland.png)![图片](../Images/w_gifs_143.gif)'
- en: Figure 3.18 A second application of the Pythagorean theorem gives us the length
    of the 3D vector.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 第二次应用勾股定理给出了三维向量的长度。
- en: 'Squaring both known sides and taking the square root should give us the length.
    Here, the lengths are 5 and 12 so the result is  ![](../Images/CH03_F18_Orland_EQ01a.png).
    In general, the following equation shows the formula for the length of a vector
    in 3D:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对已知的两边进行平方并取平方根应该给出长度。在这里，长度是5和12，所以结果是![图片](../Images/CH03_F18_Orland_EQ01a.png)。一般来说，以下方程显示了三维向量长度的公式：
- en: '![](../Images/CH03_F18_Orland_EQ01.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F18_Orland_EQ01.png)'
- en: 'This is conveniently similar to the 2D length formula. In either 2D or 3D,
    the length of a vector is the square root of the sum of squares of its components.
    Because we don’t explicitly reference the length of the input tuple anywhere in
    the following `length` function, it will work on either 2D or 3D vectors:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这与二维长度公式非常相似。在二维或三维中，向量的长度是其各分量平方和的平方根。由于在下面的`length`函数中我们没有明确引用输入元组的长度，因此它适用于二维或三维向量：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, for instance, `length((3,4,12))` returns 13.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`length((3,4,12))`返回13。
- en: 3.2.5 Computing angles and directions
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 计算角度和方向
- en: As in 2D, you can think of a 3D vector as an arrow or a displacement of a certain
    length in a certain direction. In 2D, this means that two numbers−a length and
    an angle making a pair of polar coordinates−are sufficient to specify any 2D vector.
    In 3D, one angle is not sufficient to specify a direction but two angles are.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与二维类似，你可以将三维向量视为箭头或一定长度和方向的位移。在二维中，这意味着两个数字−一个长度和一个角度，形成一个极坐标对−足以指定任何二维向量。在三维中，一个角度不足以指定一个方向，但两个角度可以。
- en: For the first angle, we again think of the vector without its *z*-coordinate,
    as if it still lived in the *x*,*y* plane. Another way of thinking of this is
    as the shadow cast by the vector from a light at a very high *z* position. This
    shadow makes some angle with the positive x-axis, which is analogous to the angle
    we used in polar coordinates, and we label it with the Greek letter φ (phi). The
    second angle is the one that the vector makes with the z-axis, which is labeled
    with the Greek letter θ (theta). Figure 3.19 shows these angles.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个角度，我们再次考虑没有其*z*-坐标的向量，就像它仍然生活在*x*,*y*平面中一样。另一种思考方式是，这是向量从非常高的*z*位置发出的影子。这个影子与正*x*轴形成一些角度，这与极坐标中使用的角度类似，我们用希腊字母φ（phi）来标记它。第二个角度是向量与z轴形成的角度，用希腊字母θ（theta）来标记。图3.19显示了这些角度。
- en: '![](../Images/CH03_F19_Orland.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F19_Orland.png)'
- en: Figure 3.19 Two angles that together measure the direction of a 3D vector
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 两个角度共同测量3D向量的方向
- en: The length of the vector, labeled **r**, along with the angles φ and θ can describe
    any vector in three dimensions. Together, the three numbers *r* , φ, and θ are
    called *spherical coordinates* as opposed to the Cartesian coordinates *x*, *y*,
    and *z*. Calculating spherical coordinates from Cartesian coordinates is a doable
    exercise with only the trigonometry we’ve covered, but we won’t go into it here.
    *In fact, w* e won’t use spherical coordinates again in this book, but I want
    to briefly compare them with polar coordinates.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的长度，标记为**r**，以及角度φ和θ可以描述三维空间中的任何向量。这三个数字*r*、φ和θ合在一起被称为**球坐标**，而不是笛卡尔坐标*x*、*y*和*z*。从笛卡尔坐标计算球坐标是一个只需要我们已覆盖的三角学的可完成的练习，但在这里我们不会深入探讨。*实际上，我们在这本书中不会再使用球坐标，但我想要简要地比较一下它们与极坐标。*
- en: Polar coordinates were useful beca-use they allowed us to perform any rotation
    of a collection of plane vectors by simply adding or subtracting from the angle.
    We were also able to read the angle between two vectors by taking the difference
    of their angles in polar coordinates. In three dimensions, neither of the angles
    φ and θ lets us immediately decide the angle between two vectors. And while we
    could rotate vectors easily around the z-axis by adding or subtracting from the
    angle φ, it’s not convenient to rotate about any other axis in spherical coordinates.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 极坐标很有用，因为它们允许我们通过简单地加减角度来执行一组平面向量的任何旋转。我们还能通过取它们极坐标角度的差来读取两个向量之间的角度。在三维空间中，角度φ和θ中的任何一个都不能立即决定两个向量之间的角度。虽然我们可以通过加减角度φ轻松地在z轴周围旋转向量，但在球坐标中围绕任何其他轴旋转则不太方便。
- en: We need some more general tools to handle angles and trigonometry in 3D. We’ll
    cover two such tools, called *vector products* , in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些更通用的工具来处理3D中的角度和三角学。在下一节中，我们将介绍两个这样的工具，称为**向量积**。
- en: 3.2.6 Exercises
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.6 练习
- en: '| **Exercise 3.3**: Draw (4, 0, 3) and (−1, 0, 1) as `Arrow3D` objects, such
    that they are placed tip-to-tail in both orders in 3D. What is their vector sum?**Solution**:
    We can find the vector sum using the `add` function we built:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习3.3**：将(4, 0, 3)和(−1, 0, 1)作为`Arrow3D`对象绘制，使它们在3D中以尾对尾的方式排列。它们的向量和是什么？**解答**：我们可以使用我们构建的`add`函数来找到向量和：'
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then to draw these tip-to-tail, we draw arrows from the origin to each point
    and from each point to the vector sum (3, 0, 4). Like the 2D `Arrow` object, `Arrow3D`
    takes the tip vector of the arrow first and then, optionally, the tail vector
    if it is not the origin:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了绘制这些尾对尾的箭头，我们绘制从原点到每个点以及从每个点到向量和(3, 0, 4)的箭头。像2D的`Arrow`对象一样，`Arrow3D`首先取箭头的尖端向量，然后，如果它不是原点，可选地取尾向量：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/CH03_F19_Orland_UN03.png)Tip-to-tail addition shows (4, 0, 3)
    + (−1, 0, 1) = (−1, 0, 1) + (4, 0, 3) = (3, 0, 4). |'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/CH03_F19_Orland_UN03.png)尾对尾加法显示(4, 0, 3) + (−1, 0, 1) = (−1,
    0, 1) + (4, 0, 3) = (3, 0, 4)。|'
- en: '| **Exercise 3.4**: Suppose we set `vectors1=[(1,2,3,4,5),(6,7,8,9,10)]` and
    `vectors2=[(1,2),(3,4),(5,6)]`. Without evaluating in Python, what are the lengths
    of `zip(*vectors1)` and `zip(*vectors2)` ?**Solution**: The first `zip` has length
    5\. Because there are five coordinates in each of the two input vectors, `zip(*vectors1)`
    contains five tuples, having two elements each. Likewise, `zip(*vectors2)` has
    length 2; the two entries of `zip(*vectors2)` are tuples containing all of the
    *x* components and all of the *y* components, respectively. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **练习3.4**：假设我们设置了`vectors1=[(1,2,3,4,5),(6,7,8,9,10)]`和`vectors2=[(1,2),(3,4),(5,6)]`。在不使用Python评估的情况下，`zip(*vectors1)`和`zip(*vectors2)`的长度是多少？**解答**：第一个`zip`的长度是5。因为两个输入向量中每个都有五个坐标，所以`zip(*vectors1)`包含五个元组，每个元组有两个元素。同样，`zip(*vectors2)`的长度是2；`zip(*vectors2)`的两个条目是包含所有*x*分量和所有*y*分量的元组。|'
- en: '| **Exercise 3.5−Mini Project**: The following comprehension creates a list
    of 24 Python vectors:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习3.5-迷你项目**：以下理解创建了一个包含24个Python向量的列表：'
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What is the sum of the 24 vectors? Draw all 24 of them tip-to-tail as `Arrow3D`
    objects.**Solution**: Drawing these vectors tip-to-tail ends up producing a helix
    shape:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 24个向量的和是多少？将所有24个向量以尾对尾的方式作为`Arrow3D`对象绘制。**解答**：绘制这些向量尾对尾最终会产生一个螺旋形状：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Begins a running sum at (0, 0, 0), where the tip-to-tail addition starts❷
    To draw each subsequent vector tip-to-tail, we add it to the running sum. The
    latest arrow connects the previous running sum to the next.![](../Images/CH03_F19_Orland_UN04.png)Finding
    the vector sum of 24 vectors in 3DThe sum is
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 (0, 0, 0) 开始进行累加，这是尾对尾加法开始的点❷ 要绘制每个后续向量的尾对尾，我们将它加到累加和中。最新的箭头连接了前一个累加和到下一个点。![](../Images/CH03_F19_Orland_UN04.png)在三维空间中求24个向量的向量和这个和是
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: which is approximately (0, 0, 8). |
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约是 (0, 0, 8)。|
- en: '| **Exercise 3.6**: Write a function `scale(scalar,vector)` that returns the
    input scalar times the input vector. Specifically, write it so it works on 2D
    or 3D vectors, or vectors of any number of coordinates.**Solution**: With a comprehension,
    we multiply each coordinate in the vector by the scalar. This is a generator comprehension
    that is converted to a tuple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.6**: 编写一个函数 `scale(scalar,vector)`，它返回输入标量乘以输入向量。具体来说，编写它使其适用于2D或3D向量，或任何数量的坐标向量。**解答**：使用理解，我们将向量中的每个坐标乘以标量。这是一个将生成器理解转换为元组的理解：'
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 3.7**: Let ***u*** = (1, −1, −1) and ***v*** = (0, 0, 2). What
    is the result of ***u*** + ½ · (***v*** − ***u***)?**Solution**: With ***u***
    = (1, −1, −1) and ***v*** = (0, 0, 2), we can first compute (***v*** − ***u***)
    = (0 − 1, 0 − (−1), 2 − (−1)) = (−1, 1, 3). Then ½ · (***v*** − ***u***) is (−½,
    ½, 3/2). The final desired result of ***u*** + ½ · (***v*** − ***u***) is then
    (½, −½, ½). Incidentally, this is the point exactly halfway between the point
    *u* and the point *v*. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.7**: 设 ***u*** = (1, −1, −1) 和 ***v*** = (0, 0, 2)。***u*** + ½ · (***v***
    − ***u****) 的结果是什么？**解答**：给定 ***u*** = (1, −1, −1) 和 ***v*** = (0, 0, 2)，我们首先计算
    (***v*** − ***u****) = (0 − 1, 0 − (−1), 2 − (−1)) = (−1, 1, 3)。然后 ½ · (***v***
    − ***u****) 是 (−½, ½, 3/2)。最终 ***u*** + ½ · (***v*** − ***u****) 的结果是 (½, −½,
    ½)。顺便说一下，这是点 *u* 和点 *v* 之间的中点。|'
- en: '| **Exercise 3.8**: Try to find the answers for this exercise without using
    code and then check your work. What is the length of the 2D vector (1, 1)? What
    is the length of the 3D vector (1, 1, 1)? We haven’t yet talked about 4D vectors,
    but these have four coordinates instead of two or three. If you had to guess,
    what is the length of the 4D vector with coordinates (1, 1, 1, 1)?**Solution**:
    The length of (1, 1) is   ![](../Images/CH03_F19_Orland_UN04_EQa.png). The length
    of (1, 1, 1) is ![](../Images/CH03_F19_Orland_UN04_EQb.png). As you might guess,
    we use the same distance formula for higher dimensional vectors as well. The length
    of (1, 1, 1, 1) follows the same pattern: it is ![](../Images/CH03_F19_Orland_UN04_EQc.png),
    which is 2. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.8**: 尝试不使用代码来回答这个练习题，然后检查你的工作。2D向量 (1, 1) 的长度是多少？3D向量 (1, 1, 1) 的长度是多少？我们还没有讨论4D向量，但它们有四个坐标而不是两个或三个。如果你必须猜测，坐标为
    (1, 1, 1, 1) 的4D向量的长度是多少？**解答**：(1, 1) 的长度是 ![](../Images/CH03_F19_Orland_UN04_EQa.png)。
    (1, 1, 1) 的长度是 ![](../Images/CH03_F19_Orland_UN04_EQb.png)。正如你可能猜到的，我们同样使用相同的距离公式来计算高维向量。
    (1, 1, 1, 1) 的长度遵循相同的模式：它是 ![](../Images/CH03_F19_Orland_UN04_EQc.png)，即 2。|'
- en: '| **Exercise 3.9−Mini Project**: The coordinates 3, 4, 12 in any order create
    a vector of length 13, a whole number. This is unusual because most numbers are
    not perfect squares, so the square root in the length formula typically returns
    an irrational number. Find a different triple of whole numbers that define coordinates
    of a vector with a whole number length.**Solution**: The following code searches
    for triples of descending whole numbers less than 100 (an arbitrary choice):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.9-迷你项目**：坐标3, 4, 12以任何顺序创建一个长度为13的向量，这是一个整数。这是不寻常的，因为大多数数字不是完全平方数，所以长度公式中的平方根通常返回一个无理数。找到另一个定义具有整数长度的向量坐标的整数三元组。**解答**：以下代码搜索小于100（一个任意选择）的递减整数三元组：'
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It finds 869 vectors with whole number coordinates and whole number lengths.
    The shortest of these is (2, 2, 1) with length exactly 3, and the longest is (99,
    90, 70) with length exactly 150. |
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它找到了869个具有整数坐标和整数长度的向量。其中最短的是长度正好为3的 (2, 2, 1)，最长的长度正好为150的向量是 (99, 90, 70)。|
- en: '| **Exercise 3.10**: Find a vector in the same direction as (−1, −1, 2) but
    which has length 1.**Hint**: Find the appropriate scalar to multiply the original
    vector to change its length appropriately.**Solution**: The length of (−1, −1,
    2) is about 2.45, so we’ll have to take a scalar multiple of this vector by (1/2.45)
    to make its length 1:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.10**: 找到一个与 (−1, −1, 2) 方向相同但长度为1的向量。**提示**：找到适当的标量来乘以原始向量以适当改变其长度。**解答**：(−1,
    −1, 2) 的长度大约是2.45，所以我们需要将这个向量的标量乘以 (1/2.45) 来使其长度为1：'
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Rounding to the nearest hundredth in each coordinate, the vector is (−0.41,
    -0.41, 0.82). |
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个坐标四舍五入到最接近的百分位，该向量是（-0.41，-0.41，0.82）。
- en: '3.3 The dot product: Measuring vector alignment'
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 点积：测量向量对齐
- en: One kind of multiplication we’ve already seen for vectors is scalar multiplication,
    combining a scalar (a real number) and a vector to get a new vector. We haven’t
    yet talked about any ways to multiply one vector with another. It turns out there
    are two important ways to do this, and these both give important geometric insights.
    One is called the *dot product* and we write it with a dot operator (for example,
    ***u*** · ***v***), while the other is called the *cross product* (for example,
    ***u*** × ***v***). For numbers, these symbols mean the same thing, so for instance
    3 · 4 = 3 × 4\. For two vectors, the operations ***u*** · ***v*** and ***u***
    × ***v*** aren’t just different notations, these mean completely different things.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到的一种向量乘法是标量乘法，它将一个标量（一个实数）和一个向量组合起来得到一个新的向量。我们还没有讨论过任何一种将一个向量与另一个向量相乘的方法。实际上，有两种重要的方法可以做到这一点，这两种方法都提供了重要的几何洞察。一种被称为*点积*，我们用点运算符（例如，***u***
    · ***v***）来表示它，而另一种被称为*叉积*（例如，***u*** × ***v***）。对于数字，这些符号意味着相同的事情，所以例如3 · 4 =
    3 × 4。对于两个向量，***u*** · ***v***和***u*** × ***v***的操作不仅仅是不同的符号，它们意味着完全不同的事情。
- en: The dot product takes two vectors and returns a scalar (a number), while the
    cross product takes two vectors and returns another vector. Both, however, are
    operations that help us reason about lengths and directions of vectors in 3D.
    Let’s start by focusing on the dot product.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 点积接受两个向量并返回一个标量（一个数字），而叉积接受两个向量并返回另一个向量。然而，这两个操作都是帮助我们推理三维空间中向量的长度和方向的运算。让我们首先关注点积。
- en: 3.3.1 Picturing the dot product
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 点积的图像
- en: The dot product (also called the *inner product*) is an operation on two vectors
    that returns a scalar. In other words, given two vectors ***u*** and ***v***,
    the result of ***u*** · ***v*** is a real number. The dot product works on vectors
    in 2D, 3D, or any number of dimensions. You can think of it as measuring “how
    aligned” the pair of input vectors are. Let’s first look at some vectors in the
    *x*,*y* plane and show their dot products to give you some intuition for how this
    operation works.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 点积（也称为*内积*）是作用于两个向量的运算，返回一个标量。换句话说，给定两个向量***u***和***v***，***u*** · ***v***的结果是一个实数。点积可以在2D、3D或任何数量的维度上的向量上工作。你可以将其视为测量输入向量对“如何对齐”。让我们首先看看*x*，*y*平面上的某些向量，并展示它们的点积，以给你一些关于这个运算如何工作的直观感受。
- en: The vectors ***u*** and ***v*** have lengths 4 and 5, respectively, and they
    point in nearly the same direction. Their dot product is positive, meaning they
    are aligned (figure 3.20).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 向量***u***和***v***的长度分别为4和5，它们几乎指向同一方向。它们的点积是正的，这意味着它们是对齐的（图3.20）。
- en: '![](../Images/CH03_F20_Orland.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F20_Orland.png)'
- en: Figure 3.20 Two vectors that are relatively aligned give a large positive dot
    product.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 相对对齐的两个向量给出较大的正点积。
- en: Two vectors that are pointing in similar directions have a positive dot product,
    and the larger the vectors, the larger the product. Smaller vectors that are similarly
    aligned have a smaller but still positive dot product. The new vectors ***u***
    and ***v*** both have a length of 2 (figure 3.21).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 指向相似方向的两个向量具有正的点积，向量越大，乘积越大。相似对齐的较短的向量具有较小的但仍然是正的点积。新的向量***u***和***v***的长度均为2（图3.21）。
- en: '![](../Images/CH03_F21_Orland.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F21_Orland.png)'
- en: Figure 3.21 Two shorter vectors pointing in similar directions give a smaller
    but still positive dot product.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 指向相似方向的较短的向量给出较小的但仍然是正的点积。
- en: By contrast, if two vectors point in opposite or near opposite directions, their
    dot product is negative (figures 3.22 and 3.23). The bigger the magnitude of the
    vectors, the more negative their dot product.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果两个向量指向相反方向或几乎指向相反方向，它们的点积是负的（图3.22和图3.23）。向量的幅度越大，它们的点积越负。
- en: '![](../Images/CH03_F22_Orland.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F22_Orland.png)'
- en: Figure 3.22 Vectors pointing in opposing directions have a negative dot product.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 指向相反方向的向量具有负的点积。
- en: '![](../Images/CH03_F23_Orland.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F23_Orland.png)'
- en: Figure 3.23 Shorter vectors pointing in opposing directions have a smaller but
    still negative dot product.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 指向相反方向的较短的向量具有较小的但仍然是负的点积。
- en: Not all pairs of vectors clearly point in similar or opposite directions, and
    the dot product detects this. As figure 3.24 shows, if two vectors point in exactly
    perpendicular directions, their dot product is zero regardless of their lengths.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有向量的对都明显指向相似或相反的方向，而点积可以检测到这一点。如图3.24所示，如果两个向量指向完全垂直的方向，无论它们的长度如何，它们的点积都是零。
- en: '![](../Images/CH03_F24_Orland.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F24_Orland.png)'
- en: Figure 3.24 Perpendicular vectors always have a dot product of zero.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 垂直向量总是具有零点积。
- en: 'This turns out to be one of the most important applications of the dot product:
    it lets us compute whether two vectors are perpendicular without doing any trigonometry.
    This perpendicular case also serves to separate the other cases: if the angle
    between two vectors is less than 90°, the vectors then have a positive dot product.
    If the angle is greater than 90°, they have a negative dot product. While I haven’t
    yet told you how to compute a dot product, you now know how to interpret the value.
    We move on to computing it next.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是点积最重要的应用之一：它让我们能够计算两个向量是否垂直，而无需进行任何三角计算。这种垂直情况还用于区分其他情况：如果两个向量之间的角度小于90°，则它们的点积为正。如果角度大于90°，则它们的点积为负。虽然我还没有告诉你如何计算点积，但你现在知道如何解释这个值。我们继续计算它。
- en: 3.3.2 Computing the dot product
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 计算点积
- en: 'Given the coordinates for two vectors, there’s a simple formula to compute
    the dot product: multiply the corresponding coordinates and then add the products.
    For instance in the dot product (1, 2, −1) · (3, 0, 3), the product of the *x*-coordinate
    is 3, the product of the *y*-coordinate is 0, and the product of the *z*-coordinate
    is −3\. The sum is 3 + 0 + (−3) = 0, so the dot product is zero. If my claim is
    correct, these two vectors should be perpendicular. Drawing them (figure 3.25)
    demonstrates this, if you look at them from the right perspective!'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个向量的坐标，有一个简单的公式可以计算点积：将相应的坐标相乘，然后将乘积相加。例如，在点积（1, 2, −1）·（3, 0, 3）中，*x*坐标的乘积是3，*y*坐标的乘积是0，*z*坐标的乘积是−3。总和是3
    + 0 + (−3) = 0，所以点积是零。如果我的说法正确，这两个向量应该是垂直的。从正确的角度绘制它们（图3.25）可以证明这一点！
- en: '![](../Images/CH03_F25_Orland.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F25_Orland.png)'
- en: Figure 3.25 Two vectors with a dot product of zero are indeed perpendicular
    in 3D.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 两个点积为零的向量在三维空间中确实是垂直的。
- en: Our perspective can be misleading in 3D, making it all the more valuable to
    be able to *compute* relative directions rather than eyeballing them. As another
    example, figure 3.26 shows that the 2D vectors (2, 3) and (4, 5) lie in similar
    directions in the *x*,*y* plane. The product of the *x*-coordinates is 2 · 4 =
    8, while the product of the *y*-coordinates is 3 · 5 = 15\. The sum 8 + 15 = 23
    is the dot product. As a positive number, this result confirms that the vectors
    are separated by less than 90°. These vectors have the same relative geometry
    whether we consider them in 2D or in 3D as the vectors (2, 3, 0) and (4, 5, 0)
    that happen to lie in the plane where *z* = 0.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维空间中，我们的视角可能会误导，因此能够计算相对方向而不是凭直觉判断就更加有价值。作为另一个例子，图3.26显示，二维向量（2, 3）和（4, 5）在*x*，*y*平面上具有相似的方向。*x*坐标的乘积是2
    · 4 = 8，而*y*坐标的乘积是3 · 5 = 15。总和8 + 15 = 23是点积。作为一个正数，这个结果证实了这两个向量之间的角度小于90°。无论我们在二维还是三维中考虑它们，这些向量都具有相同的相对几何形状，因为它们恰好位于*z*
    = 0的平面上，即向量（2, 3, 0）和（4, 5, 0）。
- en: '![](../Images/CH03_F26_Orland.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F26_Orland.png)'
- en: Figure 3.26 Another example of computing a dot product
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26 计算点积的另一个例子
- en: In Python, we can write a dot product function that handles any pair of input
    vectors as long as they all have the same number of coordinates. For example,
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以编写一个点积函数，只要输入的向量都具有相同数量的坐标，就可以处理任何一对输入向量。例如，
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code uses Python’s `zip` function to pair the appropriate coordinates,
    then multiplies each pair in a comprehension, and adds the resulting list. Let’s
    use this to further explore how the dot product behaves.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用Python的`zip`函数来配对适当的坐标，然后在理解中乘以每一对，并将结果列表相加。让我们用这个来进一步探索点积的行为。
- en: 3.3.3 Dot products by example
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 通过示例计算点积
- en: 'It’s not surprising that two vectors lying on different axes have zero dot
    product. We know they are perpendicular:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 两个位于不同轴上的向量具有零点积并不令人惊讶。我们知道它们是垂直的：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also confirm that longer vectors give longer dot products. For instance,
    scaling either input vector by a factor of 2 doubles the output of the dot product:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以确认较长的向量会产生较长的点积。例如，将输入向量之一按 2 倍因子缩放，将点积的输出翻倍：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It turns out the dot product is proportional to each of the lengths of its
    input vectors. If you take the dot product of two vectors in the same direction,
    the dot product is precisely equal to the product of the lengths. For instance,
    (4, 3) has a length of 5 and (8, 6) has a length of 10\. The dot product is equal
    to 5 · 10:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明点积与其输入向量的长度成正比。如果你取两个同方向向量的点积，点积恰好等于长度的乘积。例如，(4, 3) 的长度为 5，(8, 6) 的长度为 10。点积等于
    5 · 10：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, the dot product is not always equal to the product of the lengths
    of its inputs. The vectors (5, 0), (−3, 4), (0, −5), and (−4, −3) all have the
    same length of 5 but different dot products with the original vector (4, 3) as
    shown in figure 3.27.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，点积并不总是等于其输入长度的乘积。向量 (5, 0)，(−3, 4)，(0, −5) 和 (−4, −3) 都有相同的长度 5，但与原始向量 (4,
    3) 的点积不同，如图 3.27 所示。
- en: '![](../Images/CH03_F27_Orland.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F27_Orland.png)'
- en: Figure 3.27 Vectors of the same length have different dot products with the
    vector (4, 3), depending on their direction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 同长度的向量与向量 (4, 3) 的点积不同，这取决于它们的方向。
- en: The dot product of two vectors of length 5 ranges from 5 · 5 = 25 when they
    are aligned to −25, when they point in opposite directions. In the next set of
    exercises, I invite you to convince yourself that the dot product of two vectors
    can range from the product of the lengths down to the opposite of that value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为 5 的两个向量的点积从它们对齐时的 5 · 5 = 25 变化到它们指向相反方向时的 −25。在下一组练习中，我邀请你证明两个向量的点积可以从长度的乘积变化到该值的相反数。
- en: 3.3.4 Measuring angles with the dot product
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 使用点积测量角度
- en: We’ve seen that the dot product varies based on the angle between two vectors.
    Specifically, the dot product ***u*** · ***v*** ranges from 1 to −1 times the
    product of the lengths of ***u*** and ***v*** as the angle ranges from 0 to 180°.
    We already saw a function that behaves that way, namely the cosine function. It
    turns out that the dot product has an alternate formula. If |***u***| and |***v***|
    denote the lengths of vectors ***u*** and ***v***, the dot product is given by
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到点积根据两个向量之间的角度而变化。具体来说，向量 ***u*** · ***v*** 的点积从 0° 到 180° 角度范围内，从 ***u***
    和 ***v*** 长度的乘积到该值的相反数变化。我们已经看到了一个具有这种行为的函数，即余弦函数。结果证明点积有一个替代公式。如果 |***u***| 和
    |***v***| 表示向量 ***u*** 和 ***v*** 的长度，点积由以下公式给出
- en: '*u* · *v* = |*u*| · |*v*| · cos(θ)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*u* · *v* = |*u*| · |*v*| · cos(θ)'
- en: where θ is the angle between the vectors ***u*** and ***v***. In principle this
    gives us a new way to compute a dot product. We could measure the lengths of two
    vectors and then measure the angle between them to get the result. Suppose, as
    in figure 3.28, we have two vectors of known lengths 3 and 2, respectively, and
    using our protractor, discovered that they are 75° apart.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 θ 是向量 ***u*** 和 ***v*** 之间的角度。原则上这为我们计算点积提供了一种新的方法。我们可以测量两个向量的长度，然后测量它们之间的角度来得到结果。假设，如图
    3.28 所示，我们有两个长度分别为 3 和 2 的已知向量，并使用我们的量角器发现它们之间相隔 75°。
- en: '![](../Images/CH03_F28_Orland.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F28_Orland.png)'
- en: Figure 3.28 Two vectors of lengths 3 and 2, respectively, at 75° apart
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28 长度分别为 3 和 2 的两个向量，相隔 75°
- en: 'The dot product for the two vectors in figure 3.28 is 3 · 2 · cos(75°). With
    the appropriate conversion to radians, we can compute this in Python to be about
    1.55:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28 中两个向量的点积是 3 · 2 · cos(75°)。通过适当的弧度转换，我们可以在 Python 中计算出大约为 1.55：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When doing computations with vectors, it’s more common to start with coordinates
    and to compute angles from them. We can combine both of our formulas to recover
    an angle: first we compute the dot product and lengths using coordinates, then
    we solve for the angle.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行向量计算时，通常从坐标开始，并从它们计算角度。我们可以将两个公式结合起来恢复一个角度：首先使用坐标计算点积和长度，然后求解角度。
- en: 'Let’s find the angle between the vectors (3, 4) and (4, 3). Their dot product
    is 24, and each of their lengths is 5\. Our new dot product formula tells us that:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出向量 (3, 4) 和 (4, 3) 之间的角度。它们的点积是 24，每个向量的长度都是 5。我们新的点积公式告诉我们：
- en: (3, 4) · (4, 3) = 24 = 5 · 5 · cos(θ) = 25 · cos(θ)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: (3, 4) · (4, 3) = 24 = 5 · 5 · cos(θ) = 25 · cos(θ)
- en: From 24 = 25 · cos(θ), we can simplify it to cos(θ) = 24/25\. Using Python’s
    `math.acos`, we find that a θ value of 0.284 radians or 16.3° gives us a cosine
    of 24/25.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从 24 = 25 · cos(θ) 中，我们可以简化为 cos(θ) = 24/25。使用 Python 的 `math.acos`，我们找到 θ 值为
    0.284 弧度或 16.3° 时，余弦值为 24/25。
- en: This exercise reminds us why we don’t need the dot product in 2D. In chapter
    2, we showed how to get the angle of a vector from the positive x-axis. Using
    that formula creatively, we could find any angle we want in the plane. The dot
    product really starts to shine in 3D, where a change of coordinates can’t help
    us as much.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习提醒我们为什么在 2D 中不需要点积。在第 2 章中，我们展示了如何从正 x 轴得到向量的角度。通过创造性地使用那个公式，我们可以在平面上找到任何我们想要的角。点积在
    3D 中真正开始发光，因为在 3D 中，坐标变换不能像在 2D 中那样帮助我们。
- en: For instance, we can use the same formula to find the angle between (1, 2, 2)
    and (2, 2, 1). The dot product is 1 · 2 + 2 · 2 + 2 · 1 = 8 and the lengths are
    both 3\. This means 8 = 3 · 3 · cos(θ), so cos(θ) = 8/9 and θ = 0.476 radians
    or 27.3°.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用相同的公式来找到 (1, 2, 2) 和 (2, 2, 1) 之间的角度。点积是 1 · 2 + 2 · 2 + 2 · 1 = 8，长度都是
    3。这意味着 8 = 3 · 3 · cos(θ)，所以 cos(θ) = 8/9，θ = 0.476 弧度或 27.3°。
- en: This process is the same in 2D or 3D, and it’s one we’ll use over and over.
    We can save some effort by implementing a Python function to find the angle between
    two vectors. Because neither our dot function nor our length function has a hard-coded
    number of dimensions, this new function won’t either. We can make use of the fact
    that ***u*** · ***v*** = |***u***| · |***v***| · cos(θ) and, therefore,
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在 2D 或 3D 中都是一样的，我们会反复使用。我们可以通过实现一个 Python 函数来找到两个向量之间的角度来节省一些力气。由于我们的点积函数和长度函数都没有硬编码的维度数，这个新函数也不会。我们可以利用
    ***u*** · ***v*** = |***u***| · |***v***| · cos(θ) 的事实，因此，
- en: '![](../Images/CH03_F28_Orland_EQ02.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F28_Orland_EQ02.png)'
- en: and
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![](../Images/CH03_F28_Orland_EQ03.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F28_Orland_EQ03.png)'
- en: 'This formula translates neatly to Python code as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式可以很好地转换为以下 Python 代码：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Nothing in this Python code depends on the number of dimensions of the vectors
    ***v***[1] and ***v***[2]. These could both be tuples of 2 coordinates or tuples
    of 3 coordinates (or, in fact, tuples of 4 or more coordinates, which we discuss
    in the coming chapters). By contrast, the next vector product we meet (the cross
    product) only works in three dimensions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 Python 代码中的任何内容都不依赖于向量 ***v***[1] 和 ***v***[2] 的维度数。这两个都可以是 2 个坐标的元组或 3 个坐标的元组（实际上，也可以是
    4 个或更多坐标的元组，我们将在接下来的章节中讨论）。相比之下，我们接下来遇到的下一个向量积（叉积）只在三维空间中有效。
- en: 3.3.5 Exercises
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 练习
- en: '| **Exercise 3.11**: Based on the following picture, rank ***u*** · ***v***,
    ***u*** · ***w***, and ***v*** · ***w*** from largest to smallest:![](../Images/CH03_F28_Orland_UN05.png)**Solution**:
    The product ***u*** · ***v*** is the only positive dot product because ***u***
    and ***v*** are the only pair with less than a right angle between them. Further,
    ***u*** · ***w*** is smaller (more negative) than ***v*** · ***w*** because ***u***
    is both bigger and further from ***w***, so ***u*** · ***v*** > x**v** · ***w***
    > x**u** · ***w***. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.11**：根据以下图片，从大到小排列 ***u*** · ***v***，***u*** · ***w***，和 ***v*** ·
    ***w***：![图片](../Images/CH03_F28_Orland_UN05.png)**解答**：***u*** · ***v*** 是唯一的正点积，因为
    ***u*** 和 ***v*** 是唯一一对之间小于直角的组合。此外，***u*** · ***w*** 小于（更负）于 ***v*** · ***w***，因为
    ***u*** 既是更大的也是离 ***w*** 更远的，所以 ***u*** · ***v*** > x**v** · ***w*** > x**u**
    · ***w***。|'
- en: '| **Exercise 3.12**: What is the dot product of (−1, −1, 1) and (1, 2, 1)?
    Are these two 3D vectors separated by more than 90°, less than 90°, or exactly
    90°?**Solution**: (−1, −1, 1) and (1, 2, 1) have the dot product −1 · 1 + −1 ·
    2 + 1 · 1 = −2\. Because this is a negative number, the two vectors are more than
    90° apart. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.12**：(-1, -1, 1) 和 (1, 2, 1) 的点积是多少？这两个 3D 向量之间的距离是大于 90°，小于 90°，还是正好
    90°？**解答**：(-1, -1, 1) 和 (1, 2, 1) 的点积是 -1 · 1 + -1 · 2 + 1 · 1 = -2。因为这个是一个负数，所以这两个向量之间的距离大于
    90°。|'
- en: '| **Exercise 3.13-Mini Project**: For two 3D vectors ***u*** and ***v***, the
    values of (2***u***) · ***v*** and ***u*** · (2***v***) are both equal to 2(***u***
    · ***v***). In this case, ***u*** · ***v*** = 18 and both (2***u***) · ***v***
    and ***u*** · (2***v***) are 36, twice the original result. Show that this works
    for any real number *s*, not just 2\. In other words, show that for any *s* the
    values of (*s* ***u***) · ***v*** and ***u*** · (*s* ***v***) are both equal to
    *s*(***u*** · ***v***). |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.13-迷你项目**: 对于两个 3D 向量 ***u*** 和 ***v***，(2***u***) · ***v*** 和 ***u***
    · (2***v***) 的值都等于 2(***u*** · ***v***)。在这种情况下，***u*** · ***v*** = 18，并且 (2***u***)
    · ***v*** 和 ***u*** · (2***v***) 都是 36，是原始结果的两倍。证明这对于任何实数 *s* 都成立，而不仅仅是 2\. 换句话说，证明对于任何
    *s*，(*s* ***u***) · ***v*** 和 ***u*** · (*s* ***v***) 的值都等于 *s*(***u*** · ***v***)。|'
- en: '| **Solution**: Let’s name the coordinates of ***u*** and ***v***, say ***u***
    = (*a*, *b*, *c*) and ***v*** = (*d*, *e*, *f* ). Then ***u*** · ***v*** = *ad*
    + *be* + *cf*. Because *s* ***u*** = (*sa*, *sb*, *sc*) and *s* ***v*** = (*sd*,
    *se*, *sf*), we can show both of the results by expanding the dot products:![](../Images/CH03_F28_Orland_UN06.png)Proving
    that scalar multiplication scales the result of the dot product accordinglyAnd
    the other product works the same way:***![](../Images/CH03_F28_Orland_UN06_EQ05.png)***
    Proving the same fact holds for the second vector input to the dot product. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **解答**: 让我们命名 ***u*** 和 ***v*** 的坐标，比如说 ***u*** = (*a*, *b*, *c*) 和 ***v***
    = (*d*, *e*, *f* )。那么 ***u*** · ***v*** = *ad* + *be* + *cf*。因为 *s* ***u*** =
    (*sa*, *sb*, *sc*) 和 *s* ***v*** = (*sd*, *se*, *sf*), 我们可以通过展开点积来展示这两个结果：![](../Images/CH03_F28_Orland_UN06.png)证明标量乘法相应地缩放点积的结果。并且另一个乘积也是同样的方式工作：***![](../Images/CH03_F28_Orland_UN06_EQ05.png)***
    证明对于点积的第二个向量输入，这个事实同样成立。|'
- en: '| **Exercise 3.14-Mini Project**: Explain algebraically why the dot product
    of a vector with itself is the square of its length.**Solution**: If a vector
    has coordinates (*a*, *b*, *c*), then the dot product with itself is *a* · *a*
    + *b* · *b* + *c* · *c*. Its length is  ![](../Images/CH03_F28_Orland_UN06_EQ05b.png),
    so this is indeed the square. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.14-迷你项目**: 用代数方法解释为什么一个向量与自身的点积等于其长度的平方。**解答**: 如果一个向量的坐标是 (*a*, *b*,
    *c*)，那么它与自身的点积是 *a* · *a* + *b* · *b* + *c* · *c*。它的长度是  ![](../Images/CH03_F28_Orland_UN06_EQ05b.png)，所以这确实是平方。|'
- en: '| **Exercise 3.15-Mini Project**: Find a vector ***u*** of length 3 and a vector
    ***v*** of length 7 such that ***u*** · ***v*** = 21\. Find another pair of vectors
    ***u*** and ***v*** such that ***u*** · ***v*** = −21\. Finally, find three more
    pairs of vectors of respective lengths 3 and 7 and show that all of their lengths
    lie between −21 and 21.**Solution**: Two vectors in the same direction (for instance,
    along the positive x-axis) will have the highest possible dot product:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.15-迷你项目**: 找到一个长度为 3 的向量 ***u*** 和一个长度为 7 的向量 ***v***，使得 ***u*** ·
    ***v*** = 21\. 找到另一对向量 ***u*** 和 ***v***，使得 ***u*** · ***v*** = −21\. 最后，找到三对长度分别为
    3 和 7 的向量，并证明它们的长度都在 −21 和 21 之间。**解答**: 方向相同的两个向量（例如，沿着正 x 轴）将具有可能的最大点积：'
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Two vectors in the opposite direction (for instance, the positive and negative
    *y* directions) will have the lowest possible dot product:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 方向相反的两个向量（例如，正负 *y* 方向）将具有可能的最小点积：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using polar coordinates, we can easily generate some more vectors of length
    3 and 7 with random angles:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用极坐标，我们可以轻松生成一些长度为 3 和 7 的随机角度的更多向量：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 3.16**: Let ***u*** and ***v*** be vectors, with &#124;***u***&#124;
    = 3.61 and &#124;***v***&#124; = 1.44\. If the angle between ***u*** and ***v***
    is 101.3°, what is ***u*** · ***v*** ?'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.16**: 设 ***u*** 和 ***v*** 是向量，其中 &#124;***u***&#124; = 3.61 和 &#124;***v***&#124;
    = 1.44\. 如果 ***u*** 和 ***v*** 之间的角度是 101.3°，那么 ***u*** · ***v*** 是多少？'
- en: '5.198'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5.198'
- en: '5.098'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5.098'
- en: −1.019
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: −1.019
- en: '1.019'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1.019'
- en: '**Solution**: Again, we can plug these values into the new dot product formula
    and, with the appropriate conversion to radians, evaluate the result in Python:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**: 再次，我们可以将这些值代入新的点积公式，并通过适当的弧度转换，在 Python 中评估结果：'
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Rounding to three decimal places, the answer agrees with *c*. |
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入到小数点后三位，答案与 *c* 相符。|
- en: '| **Exercise 3.17-Mini Project**: Find the angle between (3, 4) and (4, 3)
    by converting them to polar coordinates and taking the difference of the angles.
    The answer is'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.17-迷你项目**: 通过将它们转换为极坐标并取角度之差来找到 (3, 4) 和 (4, 3) 之间的角度。答案是'
- en: '1.569'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1.569'
- en: '0.927'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0.927'
- en: '0.643'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0.643'
- en: '0.284'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0.284'
- en: '**Hint**: The result should agree with the value from the dot product formula.**Solution**:
    The vector (3, 4) is further from the positive x-axis counterclockwise, so we
    subtract the angle of (4, 3) from the angle of (3, 4) to get our answer. It matches
    answer *d* exactly:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：结果应该与点积公式的值一致。**解答**：向量(3, 4)相对于正*x*轴逆时针更远，因此我们从(3, 4)的角度减去(4, 3)的角度来得到我们的答案。它与答案
    *d* 完全匹配：'
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 3.18**: What is the angle between (1, 1, 1) and (−1, −1, 1) in
    degrees?'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习3.18**：向量(1, 1, 1)和向量(−1, −1, 1)之间的角度是多少度？'
- en: 180°
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 180°
- en: 120°
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 120°
- en: 109.5°
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 109.5°
- en: 90°
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 90°
- en: '**Solution**: The lengths of both vectors are √3 or approximately 1.732\. Their
    dot product is 1 · (−1) + 1 · (−1) + 1 · 1 = −1, so −1 = √3 · √3 · cos(θ). Therefore,
    cos(θ) = −1/3\. This makes the angle approximately 1.911 radians or 109.5° (answer
    *c*). |'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**：这两个向量的长度都是√3或大约1.732。它们的点积是1 · (−1) + 1 · (−1) + 1 · 1 = −1，所以−1 = √3
    · √3 · cos(θ)。因此，cos(θ) = −1/3。这使得角度大约是1.911弧度或109.5°（答案 *c*）。'
- en: '3.4 The cross product: Measuring oriented area'
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 叉积：测量有向面积
- en: As previously introduced, the cross product takes two 3D vectors ***u*** and
    ***v*** as inputs, and its output ***u*** × ***v*** is another 3D vector. It is
    similar to the dot product in that the lengths and relative directions of the
    input vectors determine the output, but is different in that the output has not
    only a magnitude but also a direction. We need to think carefully about the concept
    of direction in 3D to understand the power of the cross product.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，叉积将两个3D向量***u***和***v***作为输入，其输出***u*** × ***v***是另一个3D向量。它与点积类似，输入向量的长度和相对方向决定了输出，但不同之处在于输出不仅有大小，还有方向。我们需要仔细思考3D空间中的方向概念，以理解叉积的强大功能。
- en: 3.4.1 Orienting ourselves in 3D
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 在3D空间中定位自己
- en: When I introduced the x-, y-, and z-axes at the beginning of this chapter, I
    made two clear assertions. First, I promised that the familiar *x*,*y* plane exists
    within the 3D world. Second, I set the *z* direction to be perpendicular to the
    *x*,*y* plane with the *x*,*y* plane living where *z* = 0\. What I didn’t announce
    clearly was that the positive *z* direction was up instead of down.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头介绍x-, y-, 和z-轴时，我做出了两个明确的声明。首先，我承诺熟悉的*x*,*y*平面存在于3D世界中。其次，我将*z*方向设置为垂直于*x*,*y*平面，而*x*,*y*平面位于*z*
    = 0的位置。我没有明确宣布的是，正*z*方向是向上而不是向下。
- en: In other words, if we look at the *x*,*y* plane from the usual perspective,
    we would see the positive z-axis emerging out of the plane toward us. The other
    choice we could make is sending the positive z-axis away from us (figure 3.29).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们从通常的角度看*x*,*y*平面，我们会看到正*z*轴从平面中指向我们。我们还可以选择让正*z*轴离开我们（如图3.29所示）。
- en: '![](../Images/CH03_F29_Orland.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F29_Orland.png)'
- en: Figure 3.29 Positioning ourselves in 3D to see the x,y plane as we saw it in
    chapter 2\. When looking at the x,y plane, we chose the positive z-axis to point
    toward us as opposed to away from us.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29 将自己在3D空间中定位，以便像在第2章中看到的那样看到x,y平面。当我们看*x*,*y*平面时，我们选择了正*z*轴指向我们而不是离开我们。
- en: The difference here is not a matter of perspective; the two choices represent
    different orientations of 3D space, and they are distinguishable from any perspective.
    Suppose we are floating at some positive *z*-coordinate like the stick figure
    on the left in figure 3.29\. We should see the positive y-axis positioned a quarter-turn
    counterclockwise from the positive x-axis; otherwise, the axes are arranged in
    the wrong orientation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别不是视角问题；这两个选择代表了3D空间的不同方向，并且从任何视角都可以区分它们。假设我们像图3.29左边的棍状人物一样漂浮在某个正*z*坐标上。我们应该看到正*y*轴位于正*x*轴顺时针方向四分之一转的位置；否则，轴的排列方向是错误的。
- en: Plenty of things in the real world have orientations and don’t look identical
    to their mirror images. For instance, left and right shoes have identical size
    and shape but different orientations. A plain coffee mug does not have an orientation;
    we cannot look at two pictures of an unmarked coffee mug and decide if they are
    different. But as figure 3.30 shows, two coffee mugs with graphics on opposite
    sides are distinguishable.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上许多事物都有方向性，并且与它们的镜像看起来并不相同。例如，左右脚的鞋大小和形状相同，但方向不同。一个普通的咖啡杯没有方向；我们无法通过两张未标记的咖啡杯图片来判断它们是否不同。但如图3.30所示，两个在相对侧面有图案的咖啡杯是可以区分的。
- en: '![](../Images/CH03_F30_Orland.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F30_Orland.png)'
- en: Figure 3.30 A mug with no image is the same object as its mirror image. A mug
    with an image on one side is not the same as its mirror image.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30 一个没有图像的杯子与其镜像图像是同一个物体。一个侧面有图像的杯子与其镜像图像并不相同。
- en: The readily available object most mathematicians use to detect orientation is
    a hand. Our hands are oriented objects, so we can tell right hands from left hands
    even if they were unluckily detached from our bodies. Can you tell if the hand
    in figure 3.31 is a right or left hand?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数学家用来检测取向的现成对象是手。我们的手是有取向的对象，因此即使它们不幸与我们的身体分离，我们也能区分左右手。你能判断图3.31中的手是右手还是左手吗？
- en: '![](../Images/CH03_F31_Orland.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F31_Orland.png)'
- en: Figure 3.31 Is this a right or left hand?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31 这是一只右手还是左手？
- en: 'Clearly, it’s a right hand: we don’t have fingernails on our left-hand fingertips!
    Mathematicians can use their hands to distinguish the two possible orientations
    of coordinate axes, and they call the two possibilities right-handed and left-handed
    orientations. Here’s the rule as illustrated in figure 3.32: if you point your
    right index finger along the positive x-axis and curl your remaining fingers toward
    the positive y-axis, your thumb tells you the direction of the positive z-axis.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个右手：我们的左手指尖上没有指甲！数学家可以用他们的手来区分坐标轴的两个可能取向，他们称之为右手取向和左手取向。这是如图3.32所示的规定：如果你将你的右食指指向正x轴，并将你的剩余手指向正y轴卷曲，你的大拇指就会告诉你正z轴的方向。
- en: '![](../Images/CH03_F32_Orland.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F32_Orland.png)'
- en: Figure 3.32 The right-hand rule helps us remember the orientation we’ve chosen.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32 右手定则帮助我们记住我们选择的取向。
- en: This is called the *right-hand rule* , and if it agrees with your axes, then
    you are (correctly!) using the right-handed orientation. Orientation matters!
    If you are writing a program to steer a drone or control a laparoscopic surgery
    robot, you need to keep your ups, downs, lefts, rights, forwards, and backwards
    consistent. The cross product is an oriented machine, so it can help us keep track
    of orientation throughout all of our computations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*右手定则*，如果它与你的坐标轴一致，那么你就是在（正确地！）使用右手取向。取向很重要！如果你正在编写一个控制无人机或腹腔镜手术机器人的程序，你需要保持你的上下、左右、前后的一致性。叉积是一个有取向的机器，因此它可以帮助我们在所有的计算中跟踪取向。
- en: 3.4.2 Finding the direction of the cross product
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 寻找叉积的方向
- en: Again, before I tell you how to compute the cross product, I want to show you
    what it looks like. Given two input vectors, the cross product outputs a result
    that is perpendicular to both. For instance, if ***u*** = (1,0,0) and ***v***
    = (0,1,0), then it happens that the cross product ***u*** × ***v*** is (0, 0,
    1) as shown in figure 3.33.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在我告诉你如何计算叉积之前，我想先展示一下它的样子。给定两个输入向量，叉积输出一个与两个输入都垂直的结果。例如，如果***u*** = (1,0,0)和***v***
    = (0,1,0)，那么叉积***u*** × ***v***就是(0, 0, 1)，如图3.33所示。
- en: '![](../Images/CH03_F33_Orland.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F33_Orland.png)'
- en: Figure 3.33 The cross product of *z* = (1, 0, 0) and *v* = (0, 1, 0)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.33 *z* = (1, 0, 0)和*v* = (0, 1, 0)的叉积
- en: In fact, as figure 3.34 shows, any two vectors in the *x*,*y* plane have a cross
    product that lies along the z-axis.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如图3.34所示，*x*，*y*平面上的任意两个向量都有一个位于z轴上的叉积。
- en: '![](../Images/CH03_F34a_Orland.png) ![](../Images/CH03_F34b_Orland.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F34a_Orland.png) ![图片](../Images/CH03_F34b_Orland.png)'
- en: Figure 3.34 The cross product of any two vectors in the x,y plane lies on the
    z-axis.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34 x,y平面上的任意两个向量的叉积位于z轴上。
- en: 'This makes it clear why the cross product doesn’t work in 2D: it returns a
    vector that lies outside of the plane containing the two input vectors. We can
    see the output of the cross product is perpendicular to both inputs even if they
    don’t lie in the *x*,*y* plane (figure 3.35).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地说明了为什么叉积在二维空间中不起作用：它返回一个位于包含两个输入向量的平面外的向量。即使输入不在*x*，*y*平面上，我们也能看到叉积的输出与两个输入都垂直（如图3.35所示）。
- en: '![](../Images/CH03_F35_Orland.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F35_Orland.png)'
- en: Figure 3.35 The cross product always returns a vector that is perpendicular
    to both inputs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.35 叉积总是返回一个与两个输入都垂直的向量。
- en: But there are two possible perpendicular directions, and the cross product selects
    only one. For instance, the result of (1, 0, 0) × (0, 1, 0) happens to be (0,
    0, 1), pointing in the positive *z* direction. Any vector on the z-axis, positive
    or negative, would be perpendicular to both of these inputs. Why does the result
    point in the positive direction?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有两个可能的垂直方向，而叉积只选择其中一个。例如，(1, 0, 0) × (0, 1, 0) 的结果是 (0, 0, 1)，指向正 *z* 方向。z轴上的任何向量，无论是正还是负，都会与这两个输入向量垂直。为什么结果是正方向？
- en: 'Here’s where orientation comes in: the cross product obeys the right-hand rule
    as well. Once you’ve found the direction perpendicular to two input vectors ***u***
    and ***v***, the cross product ***u*** × ***v*** lies in a direction that puts
    the three vectors ***u***, ***v***, and ***u*** × ***v*** in a right-handed configuration.
    That is, we can point our right index finger in the direction of ***u***, curl
    our other fingers toward ***v***, and our thumb points in the direction of ***u***
    × ***v***(figure 3.36).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就涉及到方向性：叉积也遵循右手法则。一旦你找到了与两个输入向量 ***u*** 和 ***v*** 垂直的方向，叉积 ***u*** × ***v***
    就位于一个使得三个向量 ***u***、***v*** 和 ***u*** × ***v*** 处于右手配置的方向。也就是说，我们可以将右手的食指指向 ***u***
    的方向，将其他手指弯曲向 ***v*** 的方向，而大拇指则指向 ***u*** × ***v*** 的方向（图3.36）。
- en: '![](../Images/CH03_F36_Orland.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F36_Orland.png)'
- en: Figure 3.36 The right-hand rule tells us which perpendicular direction the cross
    product points toward.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.36 右手法则告诉我们叉积指向哪个垂直方向。
- en: 'When input vectors lie on two coordinate axes, it’s not too hard to find the
    exact direction their cross product will point: it’s one of the two directions
    along the remaining axis. In general, it’s hard to describe a direction perpendicular
    to two vectors without computing their cross product. This is one of the features
    that make it so useful once we see how to compute it. But a vector doesn’t just
    specify a direction; it also specifies *a* length. The length of the cross product
    encodes useful information as well.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入向量位于两个坐标轴上时，找到它们的叉积的确切方向并不太难：它就是剩余轴上的两个方向之一。一般来说，不计算叉积就很难描述两个向量的垂直方向。这正是我们一旦学会了如何计算它，它就变得非常有用的一项特性。但一个向量不仅指定了一个方向；它还指定了
    *一个* 长度。叉积的长度编码了有用的信息。
- en: 3.4.3 Finding the length of the cross product
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 计算叉积的长度
- en: Like the dot product, the length of the cross product is a number that gives
    us information about the relative position of the input vectors. Instead of measuring
    how aligned two vectors are, it tells us something closer to “how perpendicular
    they are.” More precisely, it tells us how big of an area its two inputs span
    (figure 3.37).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 就像点积一样，叉积的长度是一个数字，它给我们提供了关于输入向量相对位置的信息。它不是测量两个向量有多对齐，而是告诉我们“它们有多垂直”。更精确地说，它告诉我们两个输入向量所围成的面积有多大（图3.37）。
- en: '![](../Images/CH03_F37_Orland.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F37_Orland.png)'
- en: Figure 3.37 The length of the cross product is equal to the area of a parallelogram.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.37 叉积的长度等于平行四边形的面积。
- en: The parallelogram bounded by ***u*** and ***v*** as in figure 3.37 has an area
    that is the same as the length of the cross product ***u*** × ***v***. For two
    vectors of given lengths, they span the most area if they are perpendicular. On
    the other hand, if ***u*** and ***v*** are in the same direction, they don’t span
    any area; the cross product has zero length. This is convenient; we can’t choose
    a unique perpendicular direction if the two input vectors are parallel.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图3.37所示，由 ***u*** 和 ***v*** 所围成的平行四边形面积与叉积 ***u*** × ***v*** 的长度相同。对于给定长度的两个向量，如果它们垂直，它们所围成的面积最大。另一方面，如果
    ***u*** 和 ***v*** 在同一方向上，它们不围成任何面积；叉积的长度为零。这是方便的；如果两个输入向量平行，我们无法选择一个唯一的垂直方向。
- en: Paired with the direction of the result, the length of the result gives us an
    exact vector. Two vectors in the plane are guaranteed to have a cross product
    pointing in the +*z* or − *z* direction. We can see in figure 3.38 that the bigger
    the parallelogram that the plane vectors span, the longer the cross product.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 结合结果的方向，结果的长度给我们一个确切的向量。平面上的两个向量保证它们的叉积指向 +*z* 或 − *z* 方向。我们可以从图3.38中看到，平面向量所围成的平行四边形越大，叉积就越长。
- en: '![](../Images/CH03_F38a_Orland.png) ![](../Images/CH03_F38b_Orland.png) ![](../Images/CH03_F38c_Orland.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F38a_Orland.png) ![图片](../Images/CH03_F38b_Orland.png) ![图片](../Images/CH03_F38c_Orland.png)'
- en: Figure 3.38 Pairs of vectors in the x,y plane have cross products of different
    sizes based on the area of the parallelogram these span.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.38 在x,y平面上的向量对，其叉积的大小取决于它们所围成的平行四边形的面积。
- en: 'There’s a trigonometric formula for the area of this parallelogram: if ***u***
    and ***v*** are separated by an angle θ, the area is |***u***| · |***v***| · sin(θ).
    We can put the length and direction together to see some simple cross products.
    For instance, what is the cross product of (0, 2, 0) and (0, 0, −2)? These vectors
    lie on the y- and z-axes, respectively, so to be perpendicular to both, the cross
    product must lie on the x-axis. Let’s find the direction of the result using the
    right-hand rule.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平行四边形的面积有一个三角公式：如果 **u** 和 **v** 之间的角度是 θ，则面积是 |**u**| · |**v**| · sin(θ)。我们可以将长度和方向结合起来，看看一些简单的叉积。例如，(0,
    2, 0) 和 (0, 0, −2) 的叉积是什么？这些向量分别位于y轴和z轴上，因此要垂直于两者，叉积必须位于x轴上。让我们使用右手定则来找到结果的方向。
- en: 'Pointing in the direction of the first vector with our index finger (the positive
    *y* direction) and bending our fingers in the direction of the second vector (the
    negative *z* direction), we find our thumb is in the negative *x* direction. The
    magnitude of the cross product is 2 · 2 · sin(90°) because the y- and z-axes meet
    at a 90° angle. (The parallelogram happens to be a square in this case, having
    a side length of 2). This comes out to 4, so the result is (−4, 0, 0): a vector
    of length 4 in the − *x* direction.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的食指指向第一个向量的方向（正 *y* 方向）并弯曲我们的手指指向第二个向量的方向（负 *z* 方向），我们发现我们的拇指指向负 *x* 方向。叉积的大小是
    2 · 2 · sin(90°)，因为y轴和z轴在90°角处相交。（在这个情况下，平行四边形恰好是一个正方形，边长为2）。这得出结果是4，所以结果是 (−4,
    0, 0)：一个长度为4的向量，方向在负 *x* 方向。
- en: It’s nice to convince ourselves that the cross product is a well-defined operation
    by computing it geometrically. But that’s not practical, in general, when vectors
    don’t always lie on an axis and it’s not obvious what coordinates you need to
    find a perpendicular result. Fortunately, there’s an explicit formula for the
    coordinates of the cross product in terms of the coordinates of its inputs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几何计算来证明叉积是一个定义良好的操作是件好事。但通常情况下，当向量不总是位于轴上，且不明显需要找到什么坐标以获得垂直结果时，这并不实用。幸运的是，有一个显式公式，用于根据输入向量的坐标来计算叉积的坐标。
- en: 3.4.4 Computing the cross product of 3D vectors
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4 计算三维向量的叉积
- en: 'The formula for the cross product looks hairy at first glance, but we can quickly
    wrap it in a Python function and compute it with no sweat. Let’s start with coordinates
    for two vectors ***u*** and ***v***. We could name the coordinates ***u*** = (*a*,
    *b*, *c*) and ***v*** = (*d*, *e*, *f* ), but it’s clearer if we use better symbols:
    ***u*** = (*ux*, *uy*, *uz*) and ***v*** = (*v[x]*, *v[y]*, *vz*). It’s easier
    to remember that the number called *v[x]* is the *x*-coordinate of ***v*** than
    if we called it an arbitrary letter like *d*. In terms of these coordinates, the
    formula for the cross product is'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 叉积的公式乍一看很复杂，但我们可以快速将其封装在一个Python函数中，轻松计算。让我们从两个向量 **u** 和 **v** 的坐标开始。我们可以将坐标命名为
    **u** = (*a*, *b*, *c*) 和 **v** = (*d*, *e*, *f* )，但如果我们使用更好的符号会更清晰：**u** = (*ux*,
    *uy*, *uz*) 和 **v** = (*v[x]*, *v[y]*, *vz*). 记住称为 *v[x]* 的数字是 **v** 的 *x* 坐标，比如果将其称为任意字母
    *d* 更容易。在这些坐标下，叉积的公式是
- en: '![](../Images/CH03_F39_Orland.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F39_Orland.png)'
- en: Figure 3.39 The cross product can indicate whether a polygon is visible to an
    observer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.39 叉积可以指示多边形是否对观察者可见。
- en: '***u*** × ***v*** = (*u[y]v[z]* − *u[z]v[y]*, *u[z]v[x]* − *u[x]v[z]*, *u[x]v[y]*
    − *u[y]v[x]*)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**u** × **v** = (*u[y]v[z]* − *u[z]v[y]*, *u[z]v[x]* − *u[x]v[z]*, *u[x]v[y]*
    − *u[y]v[x]*)'
- en: 'Or, in Python:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在Python中：
- en: '[PRE28]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can test-drive this formula in the exercises. Note that in contrast to most
    of the formulas we used so far, this one doesn’t appear to generalize well to
    other dimensions. It requires that the input vectors have exactly three components.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在练习中尝试这个公式。注意，与迄今为止我们使用的多数公式不同，这个公式似乎不太适用于其他维度。它要求输入向量恰好有三个分量。
- en: This algebraic procedure agrees with the geometric description we built in this
    chapter. Because it tells us area and direction, the cross product helps us decide
    whether an occupant of 3D space would see a polygon floating in space with them.
    For instance, as figure 3.39 shows, an observer standing on the x-axis would *not*
    see the parallelogram spanned by ***u*** = (1, 1, 0) and ***v*** = (−2, 1, 0).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代数过程与我们本章建立的几何描述一致。因为它告诉我们面积和方向，叉积帮助我们决定3D空间中的占用者是否会看到与他们一起漂浮在空间中的多边形。例如，如图3.39所示，站在x轴上的观察者将不会看到由***u***
    = (1, 1, 0)和***v*** = (−2, 1, 0)张成的平行四边形。
- en: In other words, the polygon in figure 3.39 is parallel to the observer’s line
    of sight. Using the cross product, we could tell this without drawing the picture.
    Because the cross product is perpendicular to the person’s line of sight, none
    of the polygon is visible.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，图3.39中的多边形与观察者的视线平行。使用叉积，我们可以不画图就能判断这一点。因为叉积垂直于人的视线，所以多边形中没有任何一个是可见的。
- en: 'Now it’s time for our culminating project: building a 3D object out of polygons
    and drawing it on a 2D canvas. You’ll use all of the vector operations you’ve
    seen so far. In particular, the cross product will help you to decide which polygons
    are visible.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们最终项目的时候了：用多边形构建一个3D对象并在2D画布上绘制它。你将使用到目前为止看到的所有矢量运算。特别是，叉积将帮助你决定哪些多边形是可见的。
- en: 3.4.5 Exercises
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.5 练习
- en: '| **Exercise 3.19**: Each of the following diagrams show three mutually perpendicular
    arrows indicating positive *x*, *y*, and *z* directions. A 3D box is shown for
    perspective with the back of the box colored gray. Which of the four diagrams
    is compatible with the one we chose? That is, which shows the x-, y-, and z-axes
    as we’ve drawn them, even if from a different perspective?![](../Images/CH03_F39_Orland_UN07.png)Which
    of these axes agrees with our orientation convention?**Solution**: Looking down
    on diagram *a* from above, we’d see the x- and y-axis as usual, with the z-axis
    pointing toward us. The diagram that agrees with our orientation is *a*.In diagram
    *b*, the z-axis is coming toward us, while the +*y* direction is 90° clockwise
    from the +*x* direction. This does not agree with our orientation. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.19**: 以下每个图都显示了三个相互垂直的箭头，指示正*x*、*y*和*z*方向。为了视角，显示了一个3D箱子，箱子的背面涂成灰色。哪个图与我们所选择的图兼容？也就是说，哪个图显示了与我们绘制的x轴、y轴和z轴，即使是从不同的视角？！![图像](../Images/CH03_F39_Orland_UN07.png)哪个轴与我们的一致？**解答**:
    从上方向下看图*a*，我们会看到x轴和y轴如常，z轴指向我们。与我们方向一致的图是*a*。在图*b*中，z轴朝向我们，而+y方向相对于+x方向顺时针90°。这与我们的方向不一致。|'
- en: '| If we looked at diagram *c* from a point in the positive *z* direction (from
    the left side of the box), we would see the +*y* direction 90° counterclockwise
    from the +*x* direction. Diagram *c* also agrees with our orientation.Looking
    at diagram *d* from the left of the box, the +*z* direction would be toward us
    and the +*y* direction would again be counterclockwise from the +*x* direction.
    This agrees with our orientation as well. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 如果我们从正z方向（箱子的左侧）的点观察图*c*，我们会看到+y方向相对于+x方向逆时针90°。图*c*也与我们的一致。从箱子的左侧观察图*d*，+z方向会朝向我们，而+y方向会再次相对于+x方向逆时针。这也与我们的一致。|'
- en: '| **Exercise 3.20**: If you held up three coordinate axes in front of a mirror,
    would the image in the mirror have the same orientation or a different one?**Solution**:
    The mirror image has reversed orientation. From this perspective, the z- and y-axes
    stay pointing in the same directions. The x-axis is clockwise from the y-axis
    in the original, but in the mirror image, it moves to counterclockwise:![](../Images/CH03_F39_Orland_UN08.png)The
    x-, y-, and z-axes and their mirror image |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.20**: 如果你面前放一面镜子，并竖立起三个坐标轴，镜中的图像会有相同的方向还是不同的方向？**解答**: 镜中的图像方向是反转的。从这个角度来看，z轴和y轴保持指向相同方向。在原始图像中，x轴是顺时针从y轴开始的，但在镜中图像中，它变为逆时针方向！![图像](../Images/CH03_F39_Orland_UN08.png)x轴、y轴、z轴及其镜像
    |'
- en: '| **Exercise 3.21**: In what direction does the result of (0, 0, 3) × (0, −2,
    0) point?**Solution**: If we point our right index finger in the direction of
    (0, 0, 3), the positive *z* direction, and curl our other fingers in the direction
    of (0, −2, 0), the negative *y* direction, our thumb points in the positive *x*
    direction. Therefore, (0, 0, 3) × (0, −2, 0) points in the positive *x* direction.
    |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.21**：叉积 (0, 0, 3) × (0, −2, 0) 的结果指向什么方向？**解答**：如果我们将右手的食指指向 (0, 0,
    3) 的方向，即正 *z* 方向，并将其他手指向 (0, −2, 0) 的方向卷曲，即负 *y* 方向，那么我们的拇指指向正 *x* 方向。因此，(0, 0,
    3) × (0, −2, 0) 指向正 *x* 方向。 |'
- en: '| **Exercise 3.22**: What are the coordinates of the cross product of (1, −2,
    1) and (−6, 12, −6)?**Solution**: As negative scalar multiples of one another,
    these vectors point in opposite directions and don’t span any area. The length
    of the cross product is, therefore, zero. The only vector of length zero is (0,
    0, 0), so that is the answer. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.22**: (1, −2, 1) 和 (−6, 12, −6) 的叉积的坐标是什么？**解答**：由于这两个向量是彼此的负标量倍数，它们指向相反的方向，并且不跨越任何区域。因此，叉积的长度为零。唯一的长度为零的向量是
    (0, 0, 0)，所以这就是答案。 |'
- en: '| **Exercise 3.23-Mini Project**: The area of a parallelogram is equal to the
    length of its base times its height as shown here:![](../Images/CH03_F39_Orland_UN09.png)Given
    that, explain why the formula'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.23-迷你项目**：平行四边形的面积等于其底边长度乘以其高度，如下所示：![](../Images/CH03_F39_Orland_UN09.png)鉴于这一点，解释为什么公式'
- en: '[PRE29]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Solution**: In the diagram, the vector ***u*** defines the base, so the base
    length is &#124;***u***&#124;. From the tip of ***v*** to the base, we can draw
    a right triangle. The length of ***v*** is the hypotenuse, and the vertical leg
    of the triangle is the height we are looking for. By the definition of the sine
    function, the height is &#124;***v***&#124; · sin(φ).![](../Images/CH03_F39_Orland_UN10.png)The
    formula for the area of a parallelogram in terms of the sine of one of its anglesBecause
    the base length is &#124;***u***&#124; and the height is &#124;***v***&#124; ·
    sin(φ), the area of the parallelogram is indeed &#124;***u***&#124; · &#124;***v***&#124;
    · sin(φ). |'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**：在图中，向量 ***u*** 定义了底边，因此底边长度是 &#124;***u***&#124;。从 ***v*** 的尖端到基边，我们可以画一个直角三角形。***v***
    的长度是斜边，三角形的垂直边是我们正在寻找的高度。根据正弦函数的定义，高度是 &#124;***v***&#124; · sin(φ)。![](../Images/CH03_F39_Orland_UN10.png)以一个角度的正弦值表示平行四边形面积的公式由于底边长度是
    &#124;***u***&#124;，高度是 &#124;***v***&#124; · sin(φ)，因此平行四边形的面积确实是 &#124;***u***&#124;
    · &#124;***v***&#124; · sin(φ)。 |'
- en: '| **Exercise 3.24**: What is the result of the cross product (1, 0, 1) × (−1,
    0, 0)?'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.24**：叉积 (1, 0, 1) × (−1, 0, 0) 的结果是什么？'
- en: (0, 1, 0)
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (0, 1, 0)
- en: (0, −1, 0)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (0, −1, 0)
- en: (0, −1, −1)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (0, −1, −1)
- en: (0, 1, −1)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (0, 1, −1)
- en: '**Solution**: These vectors lie in the *x*,*z* plane, so their cross product
    lies on the y-axis. Pointing our right index finger in the direction of (1, 0,
    1) and curling our fingers toward (−1, 0, 0) requires our thumb to point in the
    − *y* direction.![](../Images/CH03_F39_Orland_UN11.png)Computing the cross product
    of (1, 0, 1) and (−1, 0, 0) geometricallyWe could find the lengths of the vectors
    and the angle between them to get the size of the cross product, but we already
    have the base and height from the coordinates. These are both 1, so the length
    is 1\. The cross product is, therefore, (0, −1, 0), a vector of length 1 in the
    − *y* direction; the answer is *b*. |'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**：这些向量位于 *x*，*z* 平面上，因此它们的叉积位于 y 轴上。将右手的食指指向 (1, 0, 1) 的方向，并使手指向 (−1,
    0, 0) 方向卷曲，需要我们的拇指指向 − *y* 方向。![](../Images/CH03_F39_Orland_UN11.png)通过几何方法计算
    (1, 0, 1) 和 (−1, 0, 0) 的叉积我们可以找到向量的长度和它们之间的角度来得到叉积的大小，但我们已经从坐标中得到了底边和高度。这两个都是
    1，所以长度是 1。因此，叉积是 (0, −1, 0)，一个长度为 1 的在 − *y* 方向的向量；答案是 *b*。 |'
- en: '| **Exercise 3.25**: Use the Python `cross` function to compute (0, 0, 1) ×
    ***v*** for a few different values of a second vector ***v***. What is the *z*-coordinate
    of each result, and why?**Solution**: No matter what vector ***v*** is chosen,
    the *z*-coordinate is zero:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.25**：使用 Python 的 `cross` 函数计算 (0, 0, 1) × ***v*** 对于第二个向量 ***v***
    的几个不同值。每个结果的 *z* 坐标是什么，为什么？**解答**：无论选择什么向量 ***v***，*z* 坐标都是零：'
- en: '[PRE30]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because ***u*** = (0,0,1), both ***u*** *x* and ***u*** *y* are zero. This
    means the term *u* *x* *v[y]* − *uyvx* in the cross product formula is zero, regardless
    of the values *v* *x* and *v[y]*. Geometrically this makes sense: the cross product
    should be perpendicular to both inputs, and to be perpendicular to (0, 0, 1),
    the *z* component must be zero. |'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ***u*** = (0,0,1)，所以 ***u*** *x* 和 ***u*** *y* 都是零。这意味着在叉积公式中的项 *u* *x* *v[y]*
    − *uyvx* 是零，无论 *v* *x* 和 *v[y]* 的值如何。从几何学的角度来看，这是有意义的：叉积应该垂直于两个输入，并且要垂直于 (0, 0,
    1)，*z* 分量必须是零。|
- en: '| **Exercise 3.26−Mini Project**: Show algebraically that ***u*** × ***v***
    is perpendicular to both ***u*** and ***v*** regardless of the coordinates of
    ***u*** and ***v***.**Hint**: Show (***u*** × ***v***) · ***u*** and (***u***
    × ***v***) · ***v*** by expanding these into coordinates.**Solution**: Let ***u***
    = (*u*[x], *u*[y], *u*[z]) and ***v*** = (*v[x]*, *v[y]*, *v*[z]) in the following
    equations. We can write (***u*** × ***v***) · ***u*** in terms of coordinates
    as follows:*u× v = (u[y]v[z] − u[z]v[y], u[z]v[x] − u[x]v[z], u[x]v[y] − u[y]v[x])
    · (u[x], u[y], u[z])*Expanding the dot product of a cross productAfter we expand
    the dot product, we see that there are 6 terms. Each of these cancels out with
    one of the others.*= (u[y]v[z] − u[z]v[y])u[x] + (u[z]v[x] − u[x]v[z])u[y] + (u[x]v[y]
    − u[y]v[x])u[z]**= u[y]v[z]u[x] − u[z]v[y]u[x] + u[z]v[x]u[y] − u[x]v[z]u[y] +
    u[x]v[y]u[z] − u[y]v[x]u[z]*After fully expanding, all the terms cancel out.Because
    all of the terms cancel out, the result is zero. To save “ink,” I won’t show the
    result of (***u*** × ***v***) · ***v***, but the same thing happens: six terms
    appear and cancel each other out, resulting in zero. This means that (***u***
    × ***v***) is perpendicular to both ***u*** and ***v***. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **练习3.26-迷你项目**：通过代数证明 ***u*** × ***v*** 不论 ***u*** 和 ***v*** 的坐标如何，都垂直于
    ***u*** 和 ***v***。**提示**：通过将这些展开成坐标来证明 (***u*** × ***v***) · ***u*** 和 (***u***
    × ***v***) · ***v***。**解答**：在以下方程中，设 ***u*** = (*u*[x], *u*[y], *u*[z]) 和 ***v***
    = (*v[x]*, *v[y]*, *v*[z])。我们可以将 (***u*** × ***v***) · ***u*** 用坐标表示如下：*u× v =
    (u[y]v[z] − u[z]v[y], u[z]v[x] − u[x]v[z], u[x]v[y] − u[y]v[x]) · (u[x], u[y],
    u[z])*展开叉积的点积在展开点积后，我们看到有6项。这些项中的每一项都与另一项相抵消。*= (u[y]v[z] − u[z]v[y])u[x] + (u[z]v[x]
    − u[x]v[z])u[y] + (u[x]v[y] − u[y]v[x])u[z]**= u[y]v[z]u[x] − u[z]v[y]u[x] + u[z]v[x]u[y]
    − u[x]v[z]u[y] + u[x]v[y]u[z] − u[y]v[x]u[z]*在完全展开后，所有项都相互抵消。因为所有项都相互抵消，结果是零。为了节省“墨水”，我不会展示
    (***u*** × ***v***) · ***v*** 的结果，但发生的情况相同：出现6项并相互抵消，结果为零。这意味着 (***u*** × ***v***)
    垂直于 ***u*** 和 ***v***。 |'
- en: 3.5 Rendering a 3D object in 2D
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 在2D中渲染3D对象
- en: Let’s try using what we’ve learned to render a simple 3D shape called an octahedron.
    Whereas a cube has six faces, all of which are squares, an octahedron has eight
    faces, all of which are triangles. You can think of an octahedron as two, four-sided
    pyramids stacked on top of each other. Figure 3.40 shows the skeleton of an octahedron.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们所学到的知识来渲染一个简单的三维形状，称为八面体。一个立方体有六个面，都是正方形，而八面体有八个面，都是三角形。你可以把八面体想象成两个四棱锥叠加在一起。图3.40显示了八面体的骨架。
- en: '![](../Images/CH03_F40_Orland.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F40_Orland.png)'
- en: Figure 3.40 The skeleton of an octahedron, a shape with eight faces and six
    vertices. The dotted lines show the edges of the octahedron on the opposite side
    from us.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.40 八面体的骨架，一个有八个面和六个顶点的形状。虚线显示的是相对于我们的八面体的对面边。
- en: If this were a solid, we wouldn’t be able to see the opposite sides. Instead,
    we’d see four of the eight triangular faces as shown in figure 3.41.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个实心体，我们就看不到对面。相反，我们会看到如图3.41所示的八个三角形中的四个。
- en: '![](../Images/CH03_F41_Orland.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F41_Orland.png)'
- en: Figure 3.41 Four numbered faces of the octahedron that are visible to us in
    its current position
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.41 八面体的四个编号面，在我们当前的位置可见
- en: Rendering the octahedron comes down to identifying the four triangles we need
    to show and shading them appropriately. Let’s see how to do that.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染八面体归结为识别我们需要显示的四个三角形，并适当地着色它们。让我们看看如何做到这一点。
- en: 3.5.1 Defining a 3D object with vectors
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 使用向量定义3D对象
- en: 'An octahedron is an easy example because it has only six corners or vertices.
    We can give them simple coordinates: (1, 0, 0), (0, 1, 0), (0, 0, 1) and their
    three opposite vectors as shown in figure 3.42.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 八面体是一个简单的例子，因为它只有六个角或顶点。我们可以给它们简单的坐标：(1, 0, 0)，(0, 1, 0)，(0, 0, 1)以及它们在图3.42中所示的反向向量。
- en: These six vectors define the boundaries of the shape but don’t provide all the
    information we need to draw it. We also need to decide which of these verti-
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个向量定义了形状的边界，但并不提供我们绘制它所需的所有信息。我们还需要决定这些顶点中的哪些需要绘制。
- en: ces connect to form edges of the shape. For instance, the top point in figure
    3.42 is (0, 0, 1) and it connects by an edge to all four points in the *x*,*y*
    plane (figure 3.43).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些顶点连接形成形状的边。例如，图 3.42 中的顶部点是 (0, 0, 1)，并通过边与 *x*、*y* 平面（图 3.43）中的所有四个点相连。
- en: '![](../Images/CH03_F42_Orland.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F42_Orland.png)'
- en: Figure 3.42 Vertices of an octahedron
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.42 八面体的顶点
- en: '![](../Images/CH03_F43_Orland.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F43_Orland.png)'
- en: Figure 3.43 Four edges of the octahedron indicated by arrows
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.43 八面体的四个由箭头指示的边
- en: 'These edges outline the top pyramid of the octahedron. Note that there is no
    edge from (0, 0, 1) to (0, 0, −1) because that segment would lie within the octahedron,
    not on its outside. Each edge is defined by a pair of vectors: the start and end
    points of the edge as a line segment. For instance, (0, 0, 1) and (1, 0, 0) define
    one of the edges.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边勾勒出了八面体的顶部金字塔。请注意，没有从 (0, 0, 1) 到 (0, 0, −1) 的边，因为那段线会在八面体内部，而不是外部。每条边由一对向量定义：边作为线段的起点和终点。例如，(0,
    0, 1) 和 (1, 0, 0) 定义了其中一条边。
- en: 'Edges still aren’t enough data to complete the drawing. We also need to know
    which triples of vertices and edges define the triangular faces we want to fill
    with a solid, shaded color. Here’s where orientation comes in: we want to know
    not only which segments define faces of the octahedron, but also whether they
    face toward us or away from us.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 边界数据仍然不足以完成绘图。我们还需要知道哪些顶点和边的三元组定义了我们想要用实心、阴影颜色填充的三角形面。这就是方向发挥作用的地方：我们不仅想知道哪些线段定义了八面体的面，还要知道它们是朝向我们还是远离我们。
- en: 'Here’s the strategy: we’ll model a triangular face as three vectors ***v***[1],
    ***v***[2], and ***v***[3], defining its edges. (Note that here I use subscripts
    1, 2, and 3 to distinguish three different vectors, not components of the same
    vector.) Specifically, we’ll order ***v***[1], ***v***[2], and ***v***[3] such
    that (***v***[2] - ***v***[1]) × (***v***[3] − ***v***[1]) points outside the
    octahedron (figure 3.44). If an outward-pointing vector is aimed toward us, it
    means the face is visible from our perspective. Otherwise, the face is obscured
    and we won’t need to draw it.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的策略是：我们将三角形面建模为三个向量 ***v***[1]、***v***[2] 和 ***v***[3]，定义其边。请注意，在这里我使用下标 1、2
    和 3 来区分三个不同的向量，而不是同一向量的分量。具体来说，我们将 ***v***[1]、***v***[2] 和 ***v***[3] 排序，使得 (***v***[2]
    - ***v***[1]) × (***v***[3] − ***v***[1]) 指向八面体外部（图 3.44）。如果一个向外指向的向量朝向我们，这意味着从我们的视角可以看到这个面。否则，这个面被遮挡，我们不需要绘制它。
- en: '![](../Images/CH03_F44_Orland.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F44_Orland.png)'
- en: Figure 3.44 A face of the octahedron. The three points defining the face are
    ordered so that (v2 − v1) × (v3 − v1) points outside of the octahedron.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.44 八面体的一个面。定义面的三个点按顺序排列，使得 (v2 − v1) × (v3 − v1) 指向八面体外部。
- en: 'We can define the eight triangular faces as triples of three vectors ***v***[1],
    ***v***[2], and ***v***[3] as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将八个三角形面定义为三个向量的三元组 ***v***[1]、***v***[2] 和 ***v***[3]，如下所示：
- en: '[PRE31]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The faces are actually the only data we need to render the shape; these contain
    the edges and vertices implicitly. For instance, we can get the vertices from
    the faces with the following function:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们只需要面的数据来渲染形状；这些数据隐含了边和顶点。例如，我们可以使用以下函数从面中获取顶点：
- en: '[PRE32]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 3.5.2 Projecting to 2D
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 投影到二维
- en: 'To turn 3D points into 2D points, we must choose what 3D direction we are observing
    from. Once we have two 3D vectors defining “up” and “right” from our perspective,
    we can *project* any 3D vector onto them and get two components instead of three.
    The `component` function extracts the part of any 3D vector pointing in a given
    direction using the dot product:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要将三维点转换为二维点，我们必须选择我们观察的 3D 方向。一旦我们有了两个定义“向上”和“向右”的 3D 向量，我们就可以将任何 3D 向量投影到它们上，并得到两个而不是三个分量。`component`
    函数通过点积提取任何 3D 向量指向给定方向的部分：
- en: '[PRE33]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With two directions hard-coded (in this case, (1, 0, 0) and (0, 1, 0)), we
    can establish a way to project from three coordinates down to two. This function
    takes a 3D vector or a tuple of three numbers and returns a 2D vector or a tuple
    of two numbers:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 预设两个方向（在这种情况下，(1, 0, 0) 和 (0, 1, 0)）后，我们可以建立一种从三维坐标投影到二维坐标的方法。这个函数接受一个三维向量或三个数字的元组，并返回一个二维向量或两个数字的元组：
- en: '[PRE34]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can picture this as “flattening” the 3D vector into the plane. Deleting the
    *z* component takes away any depth the vector has (figure 3.45).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象这是“展平”3D向量到平面。删除*z*分量移除了向量所具有的任何深度（图3.45）。
- en: '![](../Images/CH03_F45_Orland.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F45_Orland.png)'
- en: Figure 3.45 Deleting the z component of a 3D vector flattens it into the x,y
    plane.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.45 删除3D向量的z分量将其展平到x,y平面。
- en: 'Finally, to take a triangle from 3D to 2D, we need only apply this function
    to all of the vertices defining a face:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了将三角形从3D转换为2D，我们只需将此函数应用于定义面的所有顶点：
- en: '[PRE35]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 3.5.3 Orienting faces and shading
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 面向和着色
- en: To shade our 2D drawing, we pick *a* fixed color for each triangle according
    to how much it faces a given light source. Let’s say our light source lies at
    a vector of (1, 2, 3) from the origin. Then the brightness of a triangular face
    is decided by how close to perpendicular it is to the light. Another way to measure
    this is by how aligned a perpendicular vector to the face is with the light source.
    We don’t have to worry about computing colors; Matplotlib has a built-in library
    to do that for us. For instance,
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的2D绘图着色，我们根据每个三角形面对给定光源的程度为每个三角形选择一个固定的颜色。假设我们的光源位于从原点出发的向量(1, 2, 3)。那么，三角形面的亮度取决于它对光的垂直程度。另一种衡量方法是，与面的垂直向量与光源的排列程度。我们不必担心计算颜色；Matplotlib有一个内置库为我们完成这项工作。例如，
- en: '[PRE36]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: gives us a function called `blues` that maps numbers from 0 to 1 onto a spectrum
    of darker to brighter blue values. Our task is to find a number from 0 to 1 that
    indicates how bright a face should be.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们一个名为`blues`的函数，它将0到1的数字映射到从暗到亮的蓝色值谱。我们的任务是找到一个0到1之间的数字，表示一个面应该有多亮。
- en: 'Given a vector perpendicular (or *normal*) to each face and a vector pointing
    to the light source, their dot product tells us how aligned they are. Moreover,
    because we’re only considering directions, we can choose vectors with length 1\.
    Then, if the face is pointing toward the light source at all, the dot product
    will lie between 0 and 1\. If it is further than 90° from the light source, it
    will not be illuminated at all. This helper function takes a vector and returns
    another in the same direction but with length 1:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 给定每个面的垂直（或*法线*）向量和指向光源的向量，它们的点积告诉我们它们有多对齐。此外，因为我们只考虑方向，我们可以选择长度为1的向量。然后，如果面指向光源，点积将在0和1之间。如果它比90°远离光源，它将完全不发光。这个辅助函数接受一个向量并返回另一个方向相同但长度为1的向量：
- en: '[PRE37]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This second helper function takes a face and gives us a vector perpendicular
    to it:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个辅助函数接受一个面并给我们一个垂直于它的向量：
- en: '[PRE38]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Putting it all together, we have a function that draws all the triangles we
    need to render a 3D shape using our `draw` function. (I’ve renamed `draw` to `draw2d`
    and renamed the classes accordingly to distinguish them from their 3D counterparts.)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们有一个函数，它使用我们的`draw`函数绘制所有必要的三角形，以渲染3D形状。（我已经将`draw`重命名为`draw2d`，并将相应的类相应地重命名，以区分它们与3D对应物。）
- en: '[PRE39]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ For each face, computes a vector of length 1 perpendicular to it
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于每个面，计算一个长度为1的垂直于它的向量
- en: ❷ Only proceeds if the z component of this vector is positive, or in other words,
    if it points toward the viewer
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只有当这个向量的z分量是正的，换句话说，如果它指向观察者时，才进行操作
- en: ❸ The larger the dot product between the normal vector and the light source
    vector, the less shading
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 正交向量与光源向量的点积越大，着色
- en: ❹ Specifies an optional lines argument for the edges of each triangle, revealing
    the skeleton of the shape we’re drawing
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为每个三角形的边缘指定一个可选的线条参数，揭示我们正在绘制的形状的骨架
- en: With the following `render` function, it only takes a few lines of code to produce
    an octahedron. Figure 3.46 shows the result.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下面的`render`函数，只需几行代码就可以生成一个八面体。图3.46显示了结果。
- en: '[PRE40]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![](../Images/CH03_F46_Orland.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F46_Orland.png)'
- en: Figure 3.46 Four visible faces of the octahedron in shades of blue
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.46 八面体的四个可见面，以蓝色色调着色
- en: The shaded octahedron doesn’t look that special from the side, but adding more
    faces, we can tell that the shading is working (figure 3.47). You can find pre-built
    shapes with more faces in the source code for this book.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 从侧面看，着色的八面体并不特别，但增加更多面后，我们可以看出着色效果正在起作用（图3.47）。您可以在本书的源代码中找到具有更多面的预构建形状。
- en: '![](../Images/CH03_F47_Orland.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F47_Orland.png)'
- en: Figure 3.47 A 3D shape with many triangular sides. The effect of the shading
    is more apparent.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.47 一个具有许多三角形边的3D形状。着色效果更为明显。
- en: 3.5.4 Exercises
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4 练习
- en: '| **Exercise 3.27-Mini Project**: Find pairs of vectors defining each of the
    12 edges of the octahedron and draw all of the edges in Python.**Solution**: The
    top of the octahedron is (0, 0, 1). It connects to all four points in the *x*,*y*
    plane via four edges. Likewise, the bottom of the octahedron is (0, 0, −1) and
    it also connects to all four points in the *x*,*y* plane. Finally, the four points
    in the *x*,*y* plane connect to each other in a square:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 3.27-迷你项目**：找到定义八面体12条边的向量对，并在Python中绘制所有边。**解答**：八面体的顶部是 (0, 0, 1)。它通过四条边连接到
    *x*、*y* 平面的所有四个点。同样，八面体的底部是 (0, 0, −1)，它也连接到 *x*、*y* 平面的所有四个点。最后，*x*、*y* 平面的四个点以正方形的形式相互连接：'
- en: '[PRE41]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](../Images/CH03_F47_Orland_UN14_Orland.png)The resulting edges of the octahedron
    |'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/CH03_F47_Orland_UN14_Orland.png)八面体的结果边 |'
- en: '| **Exercise 3.28**: The first face of the octahedron is [(1, 0, 0), (0, 1,
    0), (0, 0, 1)]. Is that the only valid order to write the vertices for this face?**Solution**:
    No, for instance [(0, 1, 0), (0, 0, 1), (1, 0, 0)] is the same set of three points,
    and the cross product still points in the same direction in this order. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **练习 3.28**：八面体的第一个面是 [(1, 0, 0), (0, 1, 0), (0, 0, 1)]。这是唯一有效的顶点顺序吗？**解答**：不是，例如
    [(0, 1, 0), (0, 0, 1), (1, 0, 0)] 是相同的三点集合，并且在这个顺序中叉积仍然指向相同方向。|'
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Whereas vectors in 2D have lengths and widths, vectors in 3D also have depths.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与二维向量有长度和宽度不同，三维向量还有深度。
- en: 3D vectors are defined with triples of numbers called *x* -, *y* -, and *z*-coordinates.
    They tell us how far from the origin we need to travel in each direction to get
    to a 3D point.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三维向量由称为 *x*、*y* 和 *z* 坐标的数字三元组定义。它们告诉我们到达三维点需要沿每个方向移动多远。
- en: As with 2D vectors, 3D vectors can be added, subtracted, and multiplied by scalars.
    We can find their lengths using a 3D analogy of the Pythagorean theorem.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与二维向量一样，三维向量可以进行加法、减法和与标量相乘。我们可以使用三维版本的勾股定理来找到它们的长度。
- en: The dot product is a way to multiply two vectors and get a scalar. It measures
    how aligned two vectors are, and we can use its value to find the angle between
    two vectors.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点积是乘以两个向量并得到一个标量的方法。它衡量两个向量的对齐程度，我们可以使用它的值来找到两个向量之间的角度。
- en: The cross product is a way to multiply two vectors and get a third vector that
    is perpendicular to both input vectors. The magnitude of the output of the cross
    product is the area of the parallelogram spanned by the two input vectors.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叉积是乘以两个向量并得到一个垂直于两个输入向量的第三个向量的方法。叉积输出的幅度是两个输入向量所围成的平行四边形的面积。
- en: We can represent the surface of any 3D object as a collection of triangles,
    where each triangle is respectively defined by three vectors representing its
    vertices.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将任何三维物体的表面表示为三角形的集合，其中每个三角形分别由表示其顶点的三个向量定义。
- en: Using the cross product, we can decide which direction a triangle is visible
    from in 3D. This can tell us whether a viewer can see it or how illuminated it
    is by a given light source. By drawing and shading all of the triangles defining
    an object’s surface, we can make it look three-dimensional.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用叉积，我们可以决定从3D中三角形可见的方向。这可以告诉我们观察者是否可以看到它或它被给定光源照亮的程度。通过绘制和着色定义物体表面的所有三角形，我们可以使其看起来是三维的。
