- en: '10 Clojure: A different view of programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 Clojure：对编程的不同看法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Clojure’s concept of identity and state
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure的标识和状态概念
- en: The Clojure REPL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure的REPL
- en: Clojure syntax, data structures, and sequences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure语法、数据结构和序列
- en: Clojure interoperability with Java
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure与Java的互操作性
- en: Clojure macros
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure宏
- en: Clojure is a very different style of language from Java and the other languages
    we’ve studied so far. Clojure is a JVM reboot of one of the oldest programming
    languages—Lisp. If you’re not familiar with Lisp, don’t worry. We’ll teach you
    everything you need to know about the Lisp family of languages to get you started
    with Clojure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure与Java以及我们迄今为止研究过的其他语言相比，是一种非常不同的语言风格。Clojure是Lisp这一最古老编程语言之一的JVM重启版本。如果你不熟悉Lisp，不用担心。我们将教你所有关于Lisp语言家族的知识，以便你开始学习Clojure。
- en: Note Because Clojure is such a different language, it might help to have an
    additional, Clojure-specific resource to consult while reading this chapter. A
    couple of excellent books are *Clojure in Action* (Manning, 2011; [https://livebook.manning.com/book/clojure-in-action](https://livebook.manning.com/book/clojure-in-action))
    and *The Joy of Clojure* (Manning, 2014; [https://livebook.manning.com/book/the-joy-of-clojure-second-edition](https://livebook.manning.com/book/the-joy-of-clojure-second-edition)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于Clojure是一种非常不同的语言，在阅读本章时查阅额外的、针对Clojure的资源可能会有所帮助。几本优秀的书籍是《Clojure实战》（Manning，2011；[https://livebook.manning.com/book/clojure-in-action](https://livebook.manning.com/book/clojure-in-action)）和《Clojure的乐趣》（Manning，2014；[https://livebook.manning.com/book/the-joy-of-clojure-second-edition](https://livebook.manning.com/book/the-joy-of-clojure-second-edition)）。
- en: In addition to its heritage of powerful programming techniques from classic
    Lisp, Clojure adds amazing cutting-edge technology that’s very relevant to the
    modern Java developer. This combination makes Clojure a standout language on the
    JVM and an attractive choice for application development. Particular examples
    of Clojure’s new tech are its concurrency toolkits (which we will meet in chapter
    16) and data structures (which we will introduce here and expand on in chapter
    15).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从经典Lisp继承的强大编程技术之外，Clojure还增加了与现代Java开发者非常相关的尖端技术。这种组合使Clojure成为JVM上的一门突出语言，也是应用开发的一个有吸引力的选择。Clojure新技术的特定例子包括其并发工具包（我们将在第16章中遇到）和数据结构（我们将在本章介绍，并在第15章中进一步展开）。
- en: 'For the avid reader who can’t wait until later, let us just say this: the concurrency
    abstractions enable programmers to write much safer multithreaded code than when
    working in Java. These abstractions can be combined with Clojure’s seq concept
    (a different take on collections and data structures) to provide a powerful developer
    toolbox.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于迫不及待想要了解的读者，我们只需说：并发抽象使程序员能够编写比在Java中工作时更安全的线程代码。这些抽象可以与Clojure的seq概念（对集合和数据结构的不同看法）结合使用，以提供强大的开发者工具箱。
- en: To access all of this power, some important language concepts are approached
    in a fundamentally different way from Java. This difference in approach makes
    Clojure interesting to learn, and it will probably also change the way you think
    about programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问所有这些功能，一些重要的语言概念在方法上与Java有根本的不同。这种方法的差异使Clojure的学习变得有趣，而且可能也会改变你对编程的看法。
- en: Note Learning Clojure will help make you a better programmer in any language.
    Functional programming matters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：学习Clojure将帮助你在任何语言中成为一个更好的程序员。函数式编程很重要。
- en: We’ll kick off with a discussion of Clojure’s approach to state and variables.
    After some simple examples, we’ll introduce the basic vocabulary of the language—the
    *special forms* that are equivalent to keywords in languages like Java. A small
    number of these are used to build up the rest of the language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论Clojure对状态和变量的方法开始。在几个简单示例之后，我们将介绍语言的基本词汇——与Java等语言中的关键字等效的*特殊形式*。其中一小部分用于构建语言的其他部分。
- en: We’ll also delve into Clojure’s syntax for data structures, loops, and functions.
    This will allow us to introduce sequences, which are one of Clojure’s most powerful
    abstractions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将深入研究Clojure的数据结构、循环和函数的语法。这将使我们能够介绍序列，这是Clojure最强大的抽象之一。
- en: 'We’ll conclude the chapter by looking at two very compelling features: tight
    Java integration and Clojure’s amazing macro support (which is the key to Lisp’s
    very flexible syntax). Later in the book, we’ll meet more Clojure goodness (as
    well as Kotlin and Java examples) when we talk about advanced functional programming
    (chapter 15) and advanced concurrency (chapter 16).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过探讨两个非常吸引人的特性来结束本章：紧密的 Java 集成和 Clojure 的惊人宏支持（这是 Lisp 非常灵活语法的关键）。在本书的后面部分，当我们讨论高级函数式编程（第
    15 章）和高级并发（第 16 章）时，我们将遇到更多 Clojure 的优点（以及 Kotlin 和 Java 的示例）。
- en: 10.1 Introducing Clojure
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 介绍 Clojure
- en: The basic unit of Lisp syntax consists of an expression to be evaluated. These
    expressions are typically represented as zero or more symbols surrounded by brackets.
    If the evaluation succeeds without errors, the expression is called a *form*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 语法的基本单位是一个要评估的表达式。这些表达式通常表示为零个或多个括号内的符号。如果评估成功且没有错误，则该表达式被称为 *形式*。
- en: Note Clojure is compiled, not interpreted, but the compiler is very simple.
    Also remember that Clojure is dynamically typed, so there won’t be many type-checking
    errors to help you—they will show up as runtime exceptions instead.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Clojure 是编译的，而不是解释的，但编译器非常简单。还要记住 Clojure 是动态类型的，所以不会有太多的类型检查错误来帮助你——它们将作为运行时异常出现。
- en: 'Simple examples of forms include:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的简单例子包括：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The true core of the language has very few built-in forms (the special forms).
    They are the Clojure equivalent of Java keywords, but be aware of the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的核心真正核心只有很少的内置形式（特殊形式）。它们是 Clojure 对应于 Java 关键字的，但请注意以下内容：
- en: Clojure has a different meaning for the term *keyword*, which we’ll encounter
    later.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Clojure 对 *keyword* 这个术语有不同的含义，我们稍后会遇到。
- en: Clojure (like all Lisps) allows the creation of constructs that are indistinguishable
    from built-in syntax.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Clojure（像所有的 Lisp 语言一样）允许创建与内置语法不可区分的构造。
- en: When working with Clojure code, it almost never matters whether the forms you’re
    using are special forms or library functions that are built up from them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Clojure 代码时，你使用的形式是特殊形式还是由它们构建的库函数几乎无关紧要。
- en: Let’s get started with forms by looking at one of Clojure’s most important conceptual
    differences from Java. This is the treatment of state, variables, and storage.
    As you can see in figure 10.1, Java (like Kotlin) has a model of memory and state
    that involves a variable being a “box” (really, a memory location) with contents
    that can change over time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 Clojure 与 Java 最重要概念性差异之一的形式开始。这是对状态、变量和存储的处理。如图 10.1 所示，Java（如 Kotlin）有一个涉及变量作为“盒子”（实际上是内存位置）的内存和状态模型，其内容可以随时间改变。
- en: '![](../Images/CH10_F01_Evans2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F01_Evans2.png)'
- en: Figure 10.1 Imperative language memory use
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 命令式语言内存使用
- en: Programming languages like Java are *mutable by default*, because we are trying
    to alter the program state, which in Java is made up of objects. Languages that
    follow this model are often called imperative languages, as we discussed in chapter
    8.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Java 这样的编程语言默认是 *可变的*，因为我们试图改变程序状态，在 Java 中，程序状态由对象组成。遵循此模型的语言通常被称为命令式语言，正如我们在第
    8 章中讨论的那样。
- en: 'Clojure is a little bit different. The important concept is that of a *value*.
    Values can be numbers, strings, vectors, maps, sets, or a number of other things.
    Once created, values never alter. This is really important, so we’ll say it again:
    *once created, Clojure values can’t be altered*—they’re *immutable*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 略有不同。重要的概念是 *值* 的概念。值可以是数字、字符串、向量、映射、集合或许多其他东西。一旦创建，值就不会改变。这非常重要，所以我们再重复一遍：*一旦创建，Clojure
    的值就不能改变*——它们是 *不可变的*。
- en: Note Immutability is a common property of languages that are used for functional
    programming, because it allows mathematical reasoning techniques about the properties
    of functions (such as the same input always giving the same output) to be used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不可变性是用于函数式编程的语言的常见属性，因为它允许使用关于函数属性（例如相同的输入总是产生相同的输出）的数学推理技术。
- en: The imperative language model of a box that has contents that change isn’t the
    way Clojure works. Figure 10.2 shows how Clojure deals with state and memory.
    It creates an association between a name and a value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 包含可变内容的盒子的命令式语言模型并不是 Clojure 的工作方式。图 10.2 展示了 Clojure 如何处理状态和内存。它创建了一个名称和值之间的关联。
- en: '![](../Images/CH10_F02_Evans2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F02_Evans2.png)'
- en: Figure 10.2 Clojure memory use
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 Clojure 内存使用
- en: 'This is called *binding*, and it’s done using the `def` special form. Let’s
    meet the syntax for `(def)` here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*绑定*，它使用`def`特殊形式来完成。让我们在这里看看`(def)`的语法：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Don’t worry that the syntax looks a little weird—this is entirely normal for
    Lisp syntax, and you’ll get used to it really quickly. For now you can pretend
    that the brackets are arranged slightly differently and that you’re calling a
    method like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心语法看起来有点奇怪——这对于Lisp语法来说完全是正常的，你很快就会习惯的。现在你可以假装括号排列得稍微不同一些，并且你像这样调用一个方法：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s demonstrate `(def)` with a time-honored example that uses the Clojure
    interactive environment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个时间久远的例子来演示`(def)`，这个例子使用了Clojure交互环境。
- en: 10.1.1 Hello World in Clojure
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 Clojure中的Hello World
- en: 'If you haven’t already installed Clojure, you can do so on a Mac by running
    this command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装Clojure，你可以在Mac上通过运行以下命令来安装：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will install the command-line tools with brew from the `clojure/tools`
    tap. For other operating systems, instructions can be found on the [clojure.org](https://clojure.org/)
    website.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用brew从`clojure/tools`tap安装命令行工具。对于其他操作系统，可以在[clojure.org](https://clojure.org/)网站上找到说明。
- en: Note Windows support isn’t so great for Clojure. For example, `clj` is still
    in an alpha state. Follow the instructions on the website carefully.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Clojure在Windows上的支持并不那么出色。例如，`clj`仍然处于alpha状态。请仔细遵循网站上的说明。
- en: 'Once installed, you can use the `clj` command to start the Clojure interactive
    session. Or, if you built Clojure from source, change into the directory where
    you installed Clojure and run this command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以使用`clj`命令启动Clojure交互会话。或者，如果你是从源代码构建Clojure的，请切换到安装Clojure的目录并运行以下命令：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Either way, this brings up the user prompt for the Clojure read-evaluate-print
    loop (REPL). This is the interactive session, which is where you’ll typically
    spend quite a lot of time when developing Clojure code. It looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，这都会打开Clojure读取-评估-打印循环（REPL）的用户提示。这是交互会话，你通常会在开发Clojure代码时花费相当多的时间。它看起来像这样：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `user=>` part is the Clojure prompt for the session, which can be thought
    of as a bit like an advanced debugger or a command line. To exit the session (which
    will cause all the accumulated state in the session to be lost), use the traditional
    Unix sequence `Ctrl-D`. Let’s write a “Hello World” program in Clojure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`user=>`部分是Clojure会话的提示，可以将其视为一个高级调试器或命令行。要退出会话（这将导致会话中累积的所有状态丢失），请使用传统的Unix序列`Ctrl-D`。让我们用Clojure编写一个“Hello
    World”程序：'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this code, you start off by binding the *identifier* `hello` to a value.
    `(def)` always binds identifiers (which Clojure calls *symbols*) to *values*.
    Behind the scenes, it will also create an object, called a *var*, that represents
    the binding (and the name of the symbol), as shown next:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你首先将标识符`hello`绑定到一个值。`(def)`始终将标识符（Clojure称为*symbols*）绑定到*values*。幕后，它还会创建一个称为*var*的对象，代表绑定（以及符号的名称），如下所示：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What is the value you’re binding `hello` to? It’s the value
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你绑定`hello`的值是什么？它就是
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a function, which is a genuine value (so, therefore, immutable) in Clojure.
    It’s a function that takes no arguments and returns the string “Hello world”.
    The empty argument list is represented by the `[]`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，在Clojure中是一个真正的值（因此，因此，不可变）。这是一个不接受任何参数并返回字符串“Hello world”的函数。空参数列表由`[]`表示。
- en: Note In Clojure (but not in other Lisps), square brackets indicate a linear
    data structure called a vector—in this case, a vector of function arguments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Clojure（但不在其他Lisp中），方括号表示一个称为向量的线性数据结构——在这种情况下，是函数参数的向量。
- en: After binding it, you execute it via `(hello)`. This causes the Clojure runtime
    to print the results of evaluating the function, which is “Hello world”.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定后，你通过`(hello)`来执行它。这会导致Clojure运行时打印出函数评估的结果，即“Hello world”。
- en: 'Remember that the round brackets mean “function evaluation” in Lisps, so the
    example basically consists of the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在Lisp中，圆括号表示“函数评估”，所以这个例子基本上由以下内容组成：
- en: Create a function, and bind it to the symbol `hello`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数，并将其绑定到符号`hello`。
- en: Call the function bound to the symbol `hello`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用绑定到符号`hello`的函数。
- en: At this point, you should enter the Hello World example (if you haven’t already)
    and see that it behaves as described. Once you’ve done that, we can explore a
    little further.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该输入Hello World示例（如果你还没有的话）并看到它表现得如描述的那样。一旦你做到了这一点，我们就可以进一步探索。
- en: 10.1.2 Getting started with the REPL
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 使用REPL开始
- en: The REPL allows you to enter Clojure code and execute Clojure functions. It’s
    an interactive environment, and the results of earlier evaluations are still around.
    This enables a type of programming called *exploratory programming*, which basically
    means that you can experiment with code. In many cases the right thing to do is
    to play around in the REPL, building up larger and larger functions once the building
    blocks are correct.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 允许你输入 Clojure 代码并执行 Clojure 函数。它是一个交互式环境，早期评估的结果仍然存在。这使你可以进行一种称为*探索性编程*的编程类型，这基本上意味着你可以对代码进行实验。在许多情况下，正确的方法是在
    REPL 中进行实验，一旦构建块正确，就构建更大和更大的函数。
- en: Note Subdivision is a key technique in functional programming—breaking down
    a problem into smaller parts until it becomes either soluble or amenable to a
    reusable pattern (which may already be in the standard library).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意子划分是函数式编程的关键技术——将问题分解成更小的部分，直到它变得可解或适合于可重用模式（可能已经在标准库中）。
- en: 'Let’s look at a bit more Clojure syntax. One of the first things to point out
    is that the binding of a symbol to a value can be changed by another call to `(def)`,
    so let’s see that in action in the REPL. We’ll actually use a slight variant of
    `(def)` called `(defn)`, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多的 Clojure 语法。首先要注意的是，通过另一个对 `(def)` 的调用，可以更改符号到值的绑定，所以让我们在 REPL 中看看这个动作。我们将实际使用
    `(def)` 的一个轻微变体，称为 `(defn)`，如下所示：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the original binding for hello is still in play until you change
    it—this is a key feature of the REPL. There is still state, in terms of which
    symbols are bound to which values, and that state persists between lines the user
    enters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直到你更改它，hello 的原始绑定仍然有效——这是 REPL 的一个关键特性。存在状态，即哪些符号绑定到哪些值，并且这种状态在用户输入的行之间持续存在。
- en: '![](../Images/CH10_F03_Evans2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F03_Evans2.png)'
- en: Figure 10.3 Clojure bindings changing over time
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 Clojure 绑定随时间变化
- en: The ability to change which value a symbol is bound to is Clojure’s alternative
    to mutating state. Rather than allowing the contents of a storage location (or
    “memory box”) to change over time, Clojure allows a symbol to be bound to different
    immutable values at different points in time. Another way of saying this is that
    the var can point to different values during the lifetime of a program. An example
    can be seen in figure 10.3.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 改变符号绑定到哪个值的能力是 Clojure 对状态修改的替代方案。Clojure 允许符号在不同时间绑定到不同的不可变值，而不是允许存储位置（或“内存盒子”）的内容随时间变化。另一种说法是，var
    可以在程序的生命周期内指向不同的值。一个例子可以在图 10.3 中看到。
- en: Note This distinction between mutable state and different bindings at different
    times is subtle, but it’s an important concept to grasp. Remember, *mutable state*
    means the contents of the box change, whereas *rebinding* means pointing at different
    boxes at different points in time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种可变状态和不同时间不同绑定之间的区别是微妙的，但这是一个重要的概念要掌握。记住，*可变状态*意味着盒子的内容发生变化，而*重新绑定*意味着在不同时间指向不同的盒子。
- en: This is in some ways similar to the Java concept of `final` references. In Java,
    if we say `final int`, the contents of the storage location cannot change. As
    `int`s are stored as bit patterns, which means that the value of the `int` cannot
    change.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上类似于 Java 中的 `final` 引用概念。在 Java 中，如果我们说 `final int`，存储位置的内容无法更改。因为 `int`
    以位模式存储，这意味着 `int` 的值无法更改。
- en: However, if we say `final AtomicInteger`, the contents of the storage location
    once again cannot change. This case is different, though, because a variable containing
    an atomic integer actually holds an object reference. The atomic integer object
    stored in the heap can change the value it stores (whereas an `Integer` cannot),
    and this is true whether or not the reference to the object is final.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们说 `final AtomicInteger`，存储位置的 内容再次无法更改。但这种情况是不同的，因为包含原子整数的变量实际上持有对象引用。堆中存储的原子整数对象可以更改其存储的值（而
    `Integer` 不能），无论对象引用是否为 final。
- en: We’ve also slipped in another Clojure concept in the last code snippet—the `(defn)`
    “define function” *macro*. Macros are one of the key concepts of Lisp-like languages.
    The central idea is that there should be as little distinction between built-in
    constructs and ordinary code as possible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在上一个代码片段中巧妙地引入了另一个 Clojure 概念——`(defn)` “定义函数”宏。宏是 Lisp 类语言的关键概念之一。核心思想是尽可能减少内置构造和普通代码之间的区别。
- en: Note Macros allow you to create forms that behave like built-in syntax. The
    creation of macros is an advanced topic, but mastering their creation will allow
    you to produce incredibly powerful tools.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：宏允许你创建类似内置语法的表单。宏的创建是一个高级主题，但掌握它们的创建将使你能够制作出非常强大的工具。
- en: The true language primitives of the system (the special forms) can be used to
    build up the core of the language in such a way that you don’t really notice the
    difference between the two.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的真实语言原语（特殊形式）可以用来构建语言的核心，这样你几乎不会注意到两者之间的区别。
- en: Note The `(defn)` macro is an example of this. It’s just a slightly easier way
    to bind a function value to a symbol (and create a suitable var, of course). It’s
    not a special form but instead is a macro built up from the special forms `(def)`
    and `(fn)`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`(defn)` 宏是这种类型的例子。它只是将函数值绑定到符号（当然，创建一个合适的变量）的一种稍微简单的方法。它不是一个特殊形式，而是一个由特殊形式
    `(def)` 和 `(fn)` 组成的宏。
- en: We will introduce macros properly at the end of this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章末尾正确介绍宏。
- en: 10.1.3 Making a mistake
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 犯错
- en: 'What happens if you make a mistake? Suppose you’re trying to declare a function
    but accidentally just `def` a value instead, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你犯了错误会发生什么？假设你试图声明一个函数，但意外地只 `def` 了一个值，如下所示：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There’s a couple of things to notice here. First is that the error is a runtime
    exception. This means that the form `(hello)` compiled fine; it just failed at
    runtime. In terms of the equivalent code in Java, it looks a bit like this (we’ve
    simplified things somewhat to make it easier to understand for folks who are new
    to Clojure or language implementation):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。首先，错误是一个运行时异常。这意味着表单 `(hello)` 编译良好；只是在运行时失败了。从Java中等效的代码来看，它看起来有点像这样（我们简化了一些东西，以便让Clojure或语言实现的新手更容易理解）：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'where `Symbol` and `Var` are classes in the package `clojure.lang` that provides
    the core of the Clojure runtime. They look similar to these basic implementations,
    which we have simplified here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `Symbol` 和 `Var` 是 `clojure.lang` 包中的类，它提供了Clojure运行时的核心。它们看起来与以下基本实现相似，我们在这里进行了简化：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The all-important interface `IFn` looks a bit like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的接口 `IFn` 看起来有点像这样：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`IFn` is the key to how Clojure forms work—the first element in a form is taken
    to be a function, or the name of a function, to be invoked. The remaining elements
    are the arguments to the function, and the `invoke()` method with the appropriate
    number of arguments (arity) is called.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFn` 是Clojure表单工作方式的关键——表单中的第一个元素被视为要调用的函数或函数名。其余元素是函数的参数，并且调用 `invoke()`
    方法（具有适当的参数数量，即arity）。'
- en: If a Clojure var is not bound to a value that implements `IFn`, a `ClassCastException`
    is thrown at runtime. If the value is an `IFn` but the form tries to invoke it
    with the wrong number of arguments, an `IllegalArgumentException` is thrown (it’s
    actually a subtype called an `ArityException`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Clojure变量没有绑定到实现 `IFn` 的值，则在运行时会抛出 `ClassCastException`。如果值是 `IFn` 但表单尝试用错误的参数数量调用它，则会抛出
    `IllegalArgumentException`（它实际上是一个子类型，称为 `ArityException`）。
- en: Note Remember that Clojure is dynamically typed, as you can see in several places,
    for example, all the arguments and return types of the methods in `IFn` are `Object`
    and `IFn` is *not* a Java-style `@FunctionalInterface` but instead has multiple
    methods defined on it to handle many different arities.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：记住Clojure是动态类型的，正如你在几个地方可以看到的那样，例如，`IFn` 中方法的所有参数和返回类型都是 `Object`，并且 `IFn`
    不是Java风格的 `@FunctionalInterface`，而是在其上定义了多个方法来处理许多不同的arity。
- en: This peek under the hood should help clarify both a little of Clojure’s syntax
    and how it all fits together. However, we still have some broken code to fix—but
    fortunately it’s not too hard!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对底层的窥视应该有助于澄清Clojure的语法以及它们是如何结合在一起的。然而，我们仍然有一些损坏的代码需要修复——但幸运的是，这并不太难！
- en: 'All that’s happened is that you’ve got your `hello` identifier bound to something
    that isn’t a function so it can’t be called. In the REPL, you can fix this by
    simply rebinding it like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的一切只是你的 `hello` 标识符绑定到了一个不是函数的东西上，因此不能被调用。在REPL中，你可以通过简单地重新绑定它来修复这个问题：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you might guess from the preceding snippet, the semicolon (`;`) character
    means that everything to the end of the line is a comment, and `(println)` is
    the function that prints a string. Notice that `(println)`, like all functions,
    returns a value, which is echoed back to the REPL at the end of the function’s
    execution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中猜测的那样，分号（`;`）字符表示该行末尾的所有内容都是注释，而`(println)`是打印字符串的函数。请注意，`(println)`，像所有函数一样，返回一个值，该值在函数执行结束时被回显到REPL中。
- en: Clojure does not have statements like Java, only expressions, so all functions
    must return a value. If there is no value to return, then `nil` is used, which
    is basically the Clojure equivalent of Java’s `null`. Functions that would be
    `void` in Java will return `nil` in Clojure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure没有像Java那样的语句，只有表达式，所以所有函数都必须返回一个值。如果没有值要返回，则使用`nil`，这基本上是Clojure中Java的`null`的等价物。在Java中将是`void`的函数在Clojure中会返回`nil`。
- en: 10.1.4 Learning to love the brackets
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4 学习热爱括号
- en: The culture of programmers has always had a large element of whimsy and humor.
    One of the oldest jokes is that Lisp is an acronym for *Lots of Irritating Silly
    Parentheses* (instead of the more prosaic truth—that it’s an abbreviation for
    *list processing*). This rather self-deprecating joke is popular with some Lisp
    coders, partly because it points out the unfortunate truth that Lisp syntax has
    a reputation for being difficult to learn.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员的文化一直包含着大量的异想天开和幽默。其中最古老的笑话之一是Lisp代表的是*大量令人烦恼的愚蠢括号*（而不是更平淡无奇的真相——它是*列表处理*的缩写）。这个相当自嘲的笑话在一些Lisp程序员中很受欢迎，部分原因在于它指出了不幸的真相，那就是Lisp的语法有难以学习的名声。
- en: In reality, this hurdle is rather exaggerated. Lisp syntax is different from
    what most programmers are used to, but it isn’t the obstacle that it’s sometimes
    presented as. In addition, Clojure has several innovations that reduce the barrier
    to entry even further.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个障碍被夸大了。Lisp的语法与大多数程序员习惯的不同，但它并不是有时被描述的那样一个障碍。此外，Clojure有几个创新，进一步降低了入门的门槛。
- en: 'Let’s take another look at the Hello World example. To call the function that
    returns the value “Hello World”, we wrote this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看Hello World的例子。要调用返回值“Hello World”的函数，我们写了以下代码：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we want functions with arguments, rather than having expressions such as
    `myFunction(someObj)`, in Clojure we write `(myFunction someObj)`. This syntax
    is called *Polish notation*, because it was developed by Polish mathematicians
    in the early 20th century (it is also called *prefix notation*).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要带有参数的函数，而不是有`myFunction(someObj)`这样的表达式，在Clojure中我们写成`(myFunction someObj)`。这种语法称为*波兰记号*，因为它是在20世纪初由波兰数学家开发的（它也称为*前缀记号*）。
- en: If you’ve studied compiler theory, you might wonder whether there’s a connection
    here to concepts like the abstract syntax tree (AST). The short answer is yes,
    there is. A Clojure (or other Lisp) program that is written in Polish notation
    (usually called an s-*expression* by Lisp programmers) can be shown to be a very
    simple and direct representation of the AST of that program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您研究过编译器理论，您可能会想知道这里是否与抽象语法树（AST）等概念有关。简短的答案是是的，有。用波兰记号（通常由Lisp程序员称为s-*expression*）编写的Clojure（或其他Lisp）程序可以证明是那个程序AST一个非常简单和直接的表现。
- en: Note This relates back, once again, to the simple nature of the Clojure compiler.
    Compilation of Lisp code is a very cheap operation, because the structure is so
    close to the AST.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 这一次又回到了Clojure编译器的简单本质。Lisp代码的编译是一个非常便宜的操作，因为其结构非常接近AST。
- en: 'You can think of a Lisp program as being written in terms of its AST directly.
    There’s no real distinction between a data structure representing a Lisp program
    and the code, so code and data are very interchangeable. This is the reason for
    the slightly strange notation: it’s used by Lisp-like languages to blur the distinction
    between built-in primitives and user and library code. This power is so great
    that it far outweighs the slight oddity of the syntax to the eyes of a newly arrived
    Java programmer. Let’s dive into some more of the syntax and start using Clojure
    to build real programs.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Lisp程序视为直接用其AST（抽象语法树）编写的。表示Lisp程序的数据结构与代码之间没有真正的区别，因此代码和数据非常可互换。这就是为什么记法有些奇怪的原因：它被Lisp类语言用来模糊内置原语和用户及库代码之间的区别。这种能力非常强大，以至于它远远超过了新来的Java程序员眼中语法的一点点奇怪。让我们深入更多语法，并开始使用Clojure构建真实程序。
- en: '10.2 Looking for Clojure: Syntax and semantics'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 寻找Clojure：语法和语义
- en: In the previous section, you met the `(def)` and `(fn)` special forms (we also
    met `(defn)`, but it’s a macro, not a special form). You need to know a small
    number of other special forms immediately to provide a basic vocabulary for the
    language. In addition, Clojure offers a large number of useful forms and macros,
    of which a greater awareness will develop with practice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你遇到了`(def)`和`(fn)`特殊形式（我们也遇到了`(defn)`，但它是一个宏，不是一个特殊形式）。你需要立即了解少量其他特殊形式，以提供语言的基本词汇。此外，Clojure提供了大量有用的形式和宏，随着实践的深入，对这些形式的了解将更加深入。
- en: Clojure is blessed with multiple useful functions for doing a wide range of
    conceivable tasks. Don’t be daunted by this— embrace it. Be happy that for many
    practical programming tasks you may face in Clojure, somebody else has already
    done the heavy lifting for you.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure拥有多种有用的函数，可以执行各种可想象的任务。不要被吓倒——接受它。高兴的是，对于你可能在Clojure中遇到的许多实际编程任务，其他人已经为你做了大量的工作。
- en: In this section, we’ll cover the basic working set of special forms, then progress
    to Clojure’s native data types (the equivalent of Java’s collections). After that,
    we’ll progress to a natural style for writing Clojure—one in which functions rather
    than variables have center stage. The object-oriented nature of the JVM will still
    be present beneath the surface, but Clojure’s emphasis on functions has a power
    that is not as obviously present in purely OO languages and which goes far beyond
    the basics of `map()`, `filter()`, and `reduce()`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍特殊形式的基本工作集，然后过渡到Clojure的本地数据类型（Java集合的等价物）。之后，我们将过渡到编写Clojure的自然风格——在这种风格中，函数而不是变量是舞台的中心。JVM的面向对象性质仍然在表面之下存在，但Clojure对函数的强调在纯面向对象语言中并不明显，并且远远超出了`map()`、`filter()`和`reduce()`等基本功能。
- en: 10.2.1 Special forms bootcamp
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 特殊形式训练营
- en: Table 10.1 covers the definitions of some of Clojure’s most commonly used special
    forms. To get best use of the table, skim through it now and refer back to it
    as necessary when you reach some of the examples in sections 10.3 onward. The
    table uses the traditional regular expression syntax notation where `?` represents
    a single optional value and `*` represents zero or more values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1涵盖了Clojure一些最常用特殊形式的定义。为了最好地使用表格，现在快速浏览一下，并在达到10.3节及以后的某些示例时需要时参考它。该表格使用传统的正则表达式语法表示法，其中`?`代表单个可选值，`*`代表零个或多个值。
- en: This isn’t an exhaustive list of special forms, and a high percentage of them
    have multiple ways of being used. Table 10.1 is a starter collection of basic
    use cases and not anything comprehensive.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是特殊形式的完整列表，其中大部分都有多种使用方式。表10.1是一个基本用例的起始集合，并不是全面的。
- en: Table 10.1 Some of Clojure’s basic special forms
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 Clojure的一些基本特殊形式
- en: '| Special form | Meaning |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 特殊形式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(def <symbol> <value?>)` | Binds a symbol to a value (if provided); creates
    a var corresponding to the symbol if necessary |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '`(def <symbol> <value?>)` | 将符号绑定到值（如果提供）；如果需要，为符号创建一个var |'
- en: '| `(fn <name>? [<arg>*] <expr>*)` | Returns a function value that takes the
    specified args and applies them to the exprs; often combined with `(def)` into
    forms like `(defn)` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '`(fn <name>? [<arg>*] <expr>*)` | 返回一个函数值，它接受指定的参数并将它们应用到exprs上；通常与`(def)`结合成`(defn)`等形式
    |'
- en: '| `(if <test> <then> <else>?)` | If test evaluates to logical-true, evaluate
    and yield then; otherwise, evaluate and yield else, if present |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '`(if <test> <then> <else>?)` | 如果test评估为逻辑真，则评估并产生then；否则，如果存在，评估并产生else |'
- en: '| `(do <expr>*)` | Evaluates the exprs in left-to-right order and yields the
    value of the last |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '`(do <expr>*)` | 按从左到右的顺序评估exprs并产生最后一个expr的值 |'
- en: '| `(let [<binding>*] <expr>*)` | Aliases values to a local name and implicitly
    defines a scope; makes the alias available inside all exprs within the scope of
    let |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '`(let [<binding>*] <expr>*)` | 将值别名到局部名称并隐式定义一个作用域；使别名在let的作用域内对所有exprs可用 |'
- en: '| `(quote <form>)` | Returns form as is without evaluating anything; takes
    a single form and ignores all other arguments |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '`(quote <form>)` | 返回形式而不进行任何评估；接受一个形式并忽略所有其他参数 |'
- en: '| `(var <symbol>)` | Returns the var corresponding to symbol (returns a Clojure
    JVM object, not a value) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '`(var <symbol>)` | 返回与符号对应的var（返回Clojure JVM对象，而不是值） |'
- en: A couple of points deserve further explanation, because the structure of Clojure
    code can seem very different to Java code at first glance. First, the `(do)` form
    is one of the simplest ways to construct what would be a block of statements in
    Java.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个要点需要进一步解释，因为 Clojure 代码的结构在第一眼看来可能非常不同于 Java 代码。首先，`(do)` 形式是构建在 Java 中会是一个语句块的最简单方法之一。
- en: 'Second, we need to dig a bit deeper into the distinction between a var, a value,
    and the symbol that a value is (temporarily) bound to. This simple code creates
    a Clojure var called `hi`. This is a JVM object (an instance of the type `clojure.lang.Var`)
    that lives in the heap—as all objects do—and binds it to a `java.lang.String`
    object containing “hello”:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要更深入地探讨 var、值以及值（暂时）绑定的符号之间的区别。这段简单的代码创建了一个名为 `hi` 的 Clojure var。这是一个
    JVM 对象（`clojure.lang.Var` 类型的实例），它生活在堆中——就像所有对象一样——并将其绑定到一个包含“hello”的 `java.lang.String`
    对象上：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The var has a *symbol* `hi`, and it also has a *namespace* `user` that Clojure
    uses to organize programs—a bit like a Java package. If we use the symbol unadorned
    in the REPL, it evaluates to the value it is currently bound to, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: var 有一个 *符号* `hi`，它还有一个 *命名空间* `user`，Clojure 使用它来组织程序——有点像 Java 包。如果我们不加修饰地使用符号在
    REPL 中，它将评估为它当前绑定的值，如下所示：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `(def)` form, we bind a new symbol to a value, so in this code
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `(def)` 形式中，我们将新符号绑定到一个值，因此在这段代码中
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'the symbol `bye` is bound to the *value* currently bound to `hi`, as shown
    next:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `bye` 绑定到当前绑定到 `hi` 的 *值*，如下所示：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Effectively, in this simple form, `hi` is evaluated and the symbol is replaced
    with the value that results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这个简单的形式中，`hi` 被评估，符号被替换为结果值。
- en: 'However, Clojure offers us more possibilities than just this. For example,
    the value that a symbol is bound to is just any JVM value. So, we can bind a symbol
    to the var we have created because the var is itself a JVM object. This is achieved
    using the `(var)` special form as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Clojure 给我们的可能性远不止这些。例如，符号绑定的值可以是任何 JVM 值。因此，我们可以将符号绑定到我们创建的 var 上，因为 var
    本身就是一个 JVM 对象。这可以通过使用 `(var)` 特殊形式来实现，如下所示：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This effectively uses the fact that Java/JVM objects are always handled by reference,
    as we can see in figure 10.4.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上利用了 Java/JVM 对象总是通过引用来处理的事实，正如我们在图 10.4 中所看到的。
- en: '![](../Images/CH10_F04_Evans2.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F04_Evans2.png)'
- en: Figure 10.4 Clojure var acting by reference
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 Clojure var 通过引用操作
- en: 'To get back the value contained in a var, we can use the `(deref)` form (short
    for “dereference”), like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 var 中包含的值，我们可以使用 `(deref)` 形式（简称“解引用”），如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is also a `(ref)` form that is used for safe concurrent programming in
    Clojure—we will meet it in chapter 16.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `(ref)` 形式，用于 Clojure 中的安全并发编程——我们将在第 16 章中遇到它。
- en: From this distinction between a var and the value it is currently bound to,
    the `(quote)` form should be easier to understand. Instead of evaluating the form
    it is passed, it simply returns a form comprising the unevaluated symbols.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从变量与其当前绑定值的区别来看，`(quote)` 形式应该更容易理解。它不是评估传入的表单，而是简单地返回一个包含未评估符号的表单。
- en: Now that you have an appreciation of the syntax for some basic special forms,
    let’s turn to Clojure’s data structures and start to see how the forms can operate
    on data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对一些基本特殊形式的语法有所了解，让我们转向 Clojure 的数据结构，并开始了解形式如何操作数据。
- en: 10.2.2 Lists, vectors, maps, and sets
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 列表、向量、映射和集合
- en: Clojure has several native data structures. The most familiar is the *list*,
    which in Clojure is a singly linked list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有几个原生数据结构。最熟悉的是 *列表*，在 Clojure 中它是一个单链表。
- en: Note In some respects, a Clojure list is similar to a `LinkedList` in Java,
    except that `LinkedList` is a doubly-linked list where each element has a reference
    to both the next element and the previous one.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在某些方面，Clojure 列表与 Java 中的 `LinkedList` 类似，但 `LinkedList` 是一个双链表，其中每个元素都指向下一个元素和前一个元素。
- en: 'Lists are typically surrounded with parentheses, which seemingly presents a
    slight syntactic hurdle because round brackets are also used for general forms.
    In particular, parentheses are used for evaluation of function calls. This leads
    to the following common beginner’s syntax error:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表通常被括号包围，这看似构成了一个轻微的语法障碍，因为圆括号也用于通用形式。特别是，括号用于函数调用的评估。这导致以下常见的初学者语法错误：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The problem here is that, because Clojure is very flexible about its values,
    it’s expecting a function value (or a symbol that resolves to one) as the first
    argument, so it can call that function and pass 2 and 3 as arguments; 1 isn’t
    a value that is a function, so Clojure can’t evaluate this form. We say that this
    *s* -expression is invalid, and recall that only valid *s* -expressions are Clojure
    forms.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，由于 Clojure 对其值非常灵活，它期望第一个参数是一个函数值（或解析为函数的符号），因此它可以调用该函数并将 2 和 3 作为参数传递；1
    不是一个函数值的值，所以 Clojure 不能评估这个表达式。我们说这个 *s* 表达式是无效的，并回忆一下，只有有效的 *s* 表达式才是 Clojure
    表达式。
- en: 'The solution is to use the `(quote)` form that we met in the previous section.
    This has a handy short form, which is `''`. This gives us these two equivalent
    ways of writing this list, which consists of the immutable list of three elements
    that are the numbers 1, 2 and 3, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用我们在上一节中遇到的 `(quote)` 形式。它有一个方便的简写形式，即 `'`。这给我们提供了两种等效的写法来表示这个列表，它是一个包含三个不可变元素的列表，分别是数字
    1、2 和 3，如下所示：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that `(quote)` handles its arguments in a special way. In particular, there
    is no attempt made to evaluate the argument, so there’s no error arising from
    a lack of a function value in the first slot.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`(quote)` 以特殊方式处理其参数。特别是，没有尝试评估参数，因此不存在由于第一个槽位缺少函数值而导致的错误。
- en: 'Clojure has vectors, which are like arrays (in fact, it’s not too far from
    the truth to think of lists as being basically like Java’s `LinkedList` and vectors
    as like `ArrayList`). They have a convenient literal form that makes use of square
    brackets, so all of the following are equivalent:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有向量，它们类似于数组（实际上，将列表视为类似于 Java 的 `LinkedList`，将向量视为 `ArrayList` 并不是太离谱）。它们有一个方便的文本形式，使用方括号，所以以下所有内容都是等效的：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’ve already met vectors. When we declared the Hello World function and others,
    we used a vector to indicate the parameters that the declared function takes.
    Note that the form `(vec)` accepts a list and creates a vector from it, whereas
    `(vector)` is a form that accepts multiple individual symbols and returns a vector
    of them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了向量。当我们声明 Hello World 函数和其他函数时，我们使用向量来指示声明函数所接受的参数。请注意，`(vec)` 形式接受一个列表并将其转换为向量，而
    `(vector)` 是一个接受多个单独符号的格式，并返回它们的向量。
- en: 'The function `(nth)` for collections takes two parameters: a collection and
    an index. It can be thought of as similar to the `get()` method from Java’s `List`
    interface. It can be used on vectors and lists, and also on Java collections and
    even strings, which are treated as collections of characters. Here’s an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的 `(nth)` 函数接受两个参数：一个集合和一个索引。它可以看作类似于 Java 的 `List` 接口中的 `get()` 方法。它可以用于向量、列表，以及
    Java 集合，甚至字符串，字符串被视为字符的集合。以下是一个示例：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Clojure also supports maps (which you can think of as being very similar to
    Java’s `HashMap`—and they do in fact implement the `Map` interface) with this
    simple literal syntax:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 还支持具有这种简单文本语法的映射（你可以将其视为与 Java 的 `HashMap` 非常相似——实际上它们确实实现了 `Map` 接口）：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To get a value back out of a map, the syntax, shown next, is very simple:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要从映射中获取值，下面的语法非常简单：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ This syntax is equivalent to the use of a get() method in Java.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此语法相当于在 Java 中使用 get() 方法。
- en: In addition to the `Map` interface, Clojure maps also implement the `IFn` interface,
    which is why they can be used in a form like `(foo "aaa")` without a runtime exception.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Map` 接口外，Clojure 的映射还实现了 `IFn` 接口，这就是为什么它们可以在 `(foo "aaa")` 这样的形式中使用而不抛出运行时异常。
- en: One very useful stylistic point is the use of keys that have a colon in front
    of them. Clojure refers to these as *keywords*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的风格点是使用前面带有冒号的前缀键。Clojure 将这些称为 *关键字*。
- en: Note The Clojure usage of “keyword” is, of course, very different from the meaning
    of that term in other languages (including Java) where the term means the parts
    of the language grammar that are reserved and not able to be used as identifiers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Clojure 中“关键字”的使用，当然与其他语言（包括 Java）中该术语的含义非常不同（在其他语言中，该术语意味着语言语法中保留的部分，不能用作标识符）。
- en: 'Here are some useful points about keywords and maps to keep in mind:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于关键字和映射的有用要点，请记住：
- en: A keyword in Clojure is a function that takes one argument, which must be a
    map.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 中的关键字是一个接受一个参数的函数，该参数必须是一个映射。
- en: Calling a keyword function on a map returns the value that corresponds to the
    keyword function in the map.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在映射上调用关键字函数会返回映射中对应的关键字函数的值。
- en: When using keywords, there’s a useful symmetry in the syntax, as `(my-map :key)`
    and `(:key my-map)` are both legal.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用关键字时，语法中存在一种有用的对称性，因为 `(my-map :key)` 和 `(:key my-map)` 都是合法的。
- en: As a value, a keyword returns itself.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为值，关键字返回其自身。
- en: Keywords don’t need to be declared or `def`’d before use.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字在使用前不需要声明或 `def`。
- en: Remember that Clojure functions are values and, therefore, are eligible to be
    used as keys in maps.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，Clojure 函数是值，因此可以作为映射中的键使用。
- en: Commas can be used (but aren’t necessary) to separate key-value pairs, because
    Clojure considers them whitespace.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逗号可以用（但不必要）来分隔键值对，因为 Clojure 将其视为空白字符。
- en: Symbols other than keywords can be used as keys in Clojure maps, but the keyword
    syntax is extremely useful and is worth emphasizing as a style in your own code.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了关键字之外，其他符号也可以用作 Clojure 映射的键，但关键字语法非常有用，并且值得在您的代码风格中强调。
- en: 'Let’s see some of these points in action here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里的一些实际应用：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Calls the keyword function on the map
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在映射上调用关键字函数
- en: ❷ Looks up the value associated to the keyword in the map
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在映射中查找与关键字关联的值
- en: ❸ Shows that when evaluated as a value, a keyword returns itself
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 展示了当作为值评估时，关键字返回其自身
- en: 'In addition to map literals, Clojure also has a `(map)` function. But don’t
    be caught out. Unlike `(list)`, the `(map)` function doesn’t produce a map. Instead,
    `(map)` applies a supplied function to each element in a collection in turn and
    builds a new collection (actually a Clojure sequence, which you’ll meet in detail
    in section 10.4) from the new values returned. This is, of course, the Clojure
    equivalent to the `map()` method that you have already met from Java’s Streams
    API, shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了映射字面量之外，Clojure 还有一个 `(map)` 函数。但不要被误导。与 `(list)` 不同，`(map)` 函数不会生成映射。相反，`(map)`
    依次将提供的函数应用于集合中的每个元素，并从返回的新值中构建一个新的集合（实际上是一个 Clojure 序列，您将在第 10.4 节中详细了解），如下所示：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Creates a vector of maps of author data
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含作者数据的映射的向量
- en: ❷ Maps the get-name function over the data
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在数据上映射 get-name 函数
- en: ❸ Alternates form using an inline function literal
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用内联函数字面量交替形式
- en: There are additional forms of `(map)` that are able to handle multiple collections
    at once, but the form that takes a single collection as input is the most common.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`(map)` 有其他形式可以同时处理多个集合，但接受单个集合作为输入的形式是最常见的。'
- en: 'Clojure also supports sets, which are very similar to Java’s `HashSet`. They
    have a short form for data structure literals that do not support repeated keys
    (unlike `HashSet`), shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 还支持集合，它们与 Java 的 `HashSet` 非常相似。它们有数据结构字面量的简短形式，不支持重复键（与 `HashSet` 不同），如下所示：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These data structures provide the fundamentals for building up Clojure programs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据结构为构建 Clojure 程序提供了基础。
- en: One thing that may surprise the Java native is the lack of any immediate mention
    of objects as first-class citizens. This isn’t to say that Clojure isn’t object-oriented,
    but it doesn’t see OO in quite the same way as Java. Java chooses to see the world
    in terms of statically typed bundles of data and code in explicit class definitions
    of user-defined data types. Clojure emphasizes the functions and forms instead,
    although these are implemented as objects on the JVM behind the scenes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java 原生用户来说，可能令人惊讶的是，没有立即提到对象作为一等公民。这并不是说 Clojure 不是面向对象的，但它并不像 Java 那样看待面向对象。Java
    选择以静态类型的数据和代码包的形式来看待世界，这些数据类型在用户定义的数据类型的显式类定义中。Clojure 强调函数和形式，尽管这些在 JVM 后台作为对象实现。
- en: This philosophical distinction between Clojure and Java manifests itself in
    how code is written in the two languages, and to fully understand the Clojure
    viewpoint, it’s necessary to write programs in Clojure and understand some of
    the advantages that deemphasizing Java’s OO constructs brings.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 与 Java 之间的这种哲学区别在两种语言编写代码的方式中体现出来，要完全理解 Clojure 的观点，有必要在 Clojure 中编写程序并理解淡化
    Java 的面向对象结构所带来的优势。
- en: 10.2.3 Arithmetic, equality, and other operations
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 算术、相等和其他操作
- en: 'Clojure has no operators in the sense that you might expect them in Java. So,
    how would you, for example, add two numbers? In Java it’s easy:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 没有您可能在 Java 中期望的操作符。那么，例如，您会如何添加两个数字？在 Java 中很容易：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But Clojure has no operators. We’ll have to use a function instead, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Clojure 没有操作符。我们将不得不使用一个函数，如下所示：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ This code won’t work as it stands, unless we supply an add function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果不提供添加函数，这段代码将无法正常工作。
- en: 'That’s all well and good, but we can do better. Because there aren’t any operators
    in Clojure, we don’t need to reserve any of the keyboard’s characters to represent
    them. That means our function names can be more outlandish than in Java, so we
    can write this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但我们能做得更好。因为 Clojure 中没有运算符，所以我们不需要为它们保留键盘上的任何字符。这意味着我们的函数名可以比 Java 中更奇特，因此我们可以写出这个：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ This is literally Polish notation, as discussed earlier.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这实际上是前面讨论过的波兰表示法。
- en: 'Clojure’s functions are in many cases *variadic* (they take a variable number
    of inputs), so you can, for example, write this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 的函数在许多情况下是 *可变参数*（它们接受可变数量的输入），所以例如，你可以写出这个：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will give the value 6.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回值 6。
- en: 'For the equality forms (the equivalent of `equals()` and `==` in Java), the
    situation is a little more complex. Clojure has two main forms that relate to
    equality: `(=)` and `(identical?)`. Note that these are both examples of how the
    lack of operators in Clojure means that more characters can be used in function
    names. Also, `(=)` is a single equals sign, because there’s not the same notion
    of assignment as in Java-like languages.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于等价形式（Java 中的 `equals()` 和 `==` 的等价物），情况要复杂一些。Clojure 有两个与等价相关的形式：`(=)` 和 `(identical?)`。请注意，这些都是
    Clojure 中没有运算符的例子，这意味着函数名中可以使用的字符更多。此外，`(=)` 是一个等号，因为在 Java 类语言中不存在相同的赋值概念。
- en: 'This bit of REPL code sets up a list, `list-int`, and a vector, `vect-int`,
    and applies equality logic to them like so:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 REPL 代码设置了一个列表 `list-int` 和一个向量 `vect-int`，并像这样应用了等价逻辑：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The key point is that the `(=)` form on collections checks to see whether the
    collections comprise the same objects in the same order (which is true for `list-int`
    and `vect-int`), whereas `(identical?)` checks to see whether they’re really the
    same object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是 `(=)` 形式在集合中检查集合是否包含相同顺序的相同对象（对于 `list-int` 和 `vect-int` 来说是真的），而 `(identical?)`
    检查它们是否真的是同一个对象。
- en: You might also notice that our symbol names don’t use camel case. This is usual
    for Clojure. Symbols are usually all in lowercase, with hyphens between words
    (sometimes called *kebab case*).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到我们的符号名不使用驼峰式命名法。这在 Clojure 中很常见。符号通常全部小写，单词之间用连字符分隔（有时称为 *kebab case*）。
- en: True and false in Clojure
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 中的真和假
- en: 'Clojure provides two values for logical false: `false` and `nil`. Anything
    else is logical true (including the literal `true`). This parallels the situation
    in many dynamic languages (e.g., JavaScript), but it’s a bit strange for Java
    programmers encountering it for the first time.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 为逻辑假提供了两个值：`false` 和 `nil`。任何其他内容都是逻辑真（包括字面量 `true`）。这与许多动态语言（例如 JavaScript）中的情况相似，但对于第一次遇到这种情况的
    Java 程序员来说可能有点奇怪。
- en: With basic data structures and operators under our belts, let’s put together
    some of the special forms and functions we’ve seen and write slightly longer example
    Clojure functions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了基本的数据结构和运算符之后，让我们将一些我们看到的特殊形式和函数组合起来，编写一些稍微长一点的 Clojure 函数示例。
- en: 10.2.4 Working with functions in Clojure
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 在 Clojure 中处理函数
- en: In this section, we’ll start dealing with some of the meat of Clojure programming.
    We’ll start writing functions to act on data and bring Clojure’s focus on functions
    to the fore. Next up are Clojure’s looping constructs, then reader macros and
    dispatch forms. We’ll round out the section by discussing Clojure’s approach to
    functional programming and its take on closures.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始处理 Clojure 编程的一些主要内容。我们将开始编写作用于数据的函数，并将 Clojure 对函数的关注重点突出。接下来是 Clojure
    的循环结构，然后是读取宏和调度形式。我们将通过讨论 Clojure 对函数式编程的方法及其对闭包的看法来结束本节。
- en: The best way to start doing all of this is by example, so let’s get going with
    a few simple examples and build up toward some of the powerful functional programming
    techniques that Clojure provides.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 开始做所有这些的最佳方式是通过示例，所以让我们从几个简单的示例开始，逐步构建 Clojure 提供的一些强大的函数式编程技术。
- en: Some simple Clojure functions
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的 Clojure 函数
- en: The next listing defines three functions, two of which are very simple functions
    of one argument; the third is a little more complex.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表定义了三个函数，其中两个是非常简单的单参数函数；第三个稍微复杂一些。
- en: Listing 10.1 Defining simple Clojure functions
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 定义简单的 Clojure 函数
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ The list maker takes two arguments, the second of which is a function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列表生成器接受两个参数，第二个参数是一个函数。
- en: ❷ An inline, anonymous function
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个内联的匿名函数
- en: '❸ Makes a list of two elements: the value and the result of applying f to the
    value'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个包含两个元素的列表：值和将 f 应用到值的结果
- en: In this listing, `(const-fun1)` takes in a value and returns 1, and `(ident-fun)`
    takes in a value and returns the very same value. Mathematicians would call these
    a *constant function* and the *identity function*. You can also see that the definition
    of a function uses vector literals to denote the arguments to a function and for
    the `(let)` form.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，`(const-fun1)`接受一个值并返回1，而`(ident-fun)`接受一个值并返回相同的值。数学家会称这些为*常函数*和*恒等函数*。你还可以看到，函数的定义使用向量字面量来表示函数的参数和`(let)`形式。
- en: 'The third function is more complex. The function `(list-maker-fun)` takes two
    arguments: first a vector of values to operate on, which is called `x`, and second,
    a function (called `f`). If we were to write it in Java, it might look a bit like
    this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数更复杂。函数`(list-maker-fun)`接受两个参数：首先是一个要操作的值向量，称为`x`，其次是一个函数（称为`f`）。如果我们用Java来写，它可能看起来像这样：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The role of the inline anonymous function in Clojure is played by the lambda
    expression in the Java code. However, it is important not to overstate the equivalence
    of these two code listings—Clojure and Java are *very* different languages.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中内联匿名函数的作用在Java代码中由lambda表达式扮演。然而，不要过分强调这两个代码列表（Clojure和Java）之间的等价性——Clojure和Java是*非常*不同的语言。
- en: Note Functions that take other functions as arguments are called higher-order
    functions. We’ll meet them properly in chapter 15.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：接受其他函数作为参数的函数称为高阶函数。我们将在第15章中详细介绍它们。
- en: Let’s take a look at how `(list-maker-fun)` works.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`(list-maker-fun)`是如何工作的。
- en: Listing 10.2 Working with functions
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 函数操作
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that when you’re typing these expressions into the REPL, you’re interacting
    with the Clojure compiler. The expression `(list-maker-fun [2 1 3] "a")` fails
    to run (although it does compile) because `(list-maker-fun)` expects its second
    argument to be a function, which a string isn’t. So although the Clojure compiler
    outputs bytecode for the form, it fails with a runtime exception.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你将这些表达式输入到REPL中时，你是在与Clojure编译器交互。表达式`(list-maker-fun [2 1 3] "a")`无法运行（尽管它可以编译），因为`(list-maker-fun)`期望其第二个参数是一个函数，而字符串不是。所以尽管Clojure编译器为该形式输出了字节码，但它会因运行时异常而失败。
- en: Note In Java, we can write valid code like `Integer.parseInt("foo")`, which
    will compile fine but will always fail at runtime. The Clojure situation is similar.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Java中，我们可以编写有效的代码，如`Integer.parseInt("foo")`，它将编译良好，但在运行时总是会失败。Clojure的情况类似。
- en: This example shows that when interacting with the REPL, you still have a certain
    amount of static typing in play because Clojure isn’t an interpreted language.
    Even in the REPL, every Clojure form that is typed is compiled to JVM bytecode
    and linked into the running system. The Clojure function is compiled to JVM bytecode
    when it’s defined, so the `ClassCastException` occurs because of a static typing
    violation in the JVM.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，在与REPL交互时，你仍然有一定程度的静态类型检查，因为Clojure不是一种解释型语言。即使在REPL中，每个被类型化的Clojure形式都会编译成JVM字节码，并链接到运行系统中。当定义Clojure函数时，它会编译成JVM字节码，因此`ClassCastException`是由于JVM中的静态类型违规而发生的。
- en: Listing 10.3 shows a longer piece of Clojure code, the *Schwartzian transform*.
    This is a piece of programming history, made popular by the Perl programming language
    in the 1990s. The idea is to do a sort operation on a vector, based not on the
    provided vector but on some property of the elements of the vector. The property
    values to sort on are found by calling a *keying function* on the elements.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3展示了更长的Clojure代码片段，即*Schwartzian转换*。这是编程历史的一部分，在20世纪90年代由Perl编程语言普及。其想法是在向量上执行排序操作，不是基于提供的向量，而是基于向量元素的某些属性。要排序的属性值是通过在元素上调用*键函数*来找到的。
- en: The definition of the Schwartzian transform in listing 10.3 calls the keying
    function `key-fn`. When you actually want to call the `(schwartz)` function, you
    need to supply a function to use for keying. In this code sample, we use our old
    friend, `(ident-fun)`, from listing 10.1.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3中Schwartzian转换的定义调用了键函数`key-fn`。当你实际想要调用`(schwartz)`函数时，你需要提供一个用于键的函数。在这个代码示例中，我们使用了列表10.1中的老朋友`(ident-fun)`。
- en: Listing 10.3 Schwartzian transform
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 Schwartzian转换
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Makes a list consisting of pairs using the keying function
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用键函数创建由对组成的列表
- en: ❷ Sorts the pairs based on the values of the keying function
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据键函数的值对对进行排序
- en: ❸ Constructs a new list by reducing—taking only the original value from each
    pair
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过减少操作——只从每个对中取原始值来构建新的列表
- en: This code is performing three separate steps, which may seem a little inside
    out at first glance. The steps are shown in figure 10.5.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在执行三个独立的步骤，乍一看可能显得有些反直觉。这些步骤在图 10.5 中展示。
- en: '![](../Images/CH10_F05_Evans2.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F05_Evans2.png)'
- en: Figure 10.5 The Schwartzian transform
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 Schwartzian 转换
- en: 'Note that in listing 10.3 we introduced a new form: `(sort-by)`. This is a
    function that takes two arguments: a function to do the sorting and a vector to
    be sorted. We’ve also showcased the `(apply)` form, which takes two arguments:
    a function to call and a vector of arguments to pass to it.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在列表 10.3 中，我们引入了一个新的形式：`(sort-by)`。这是一个接受两个参数的函数：一个用于排序的函数和一个要排序的向量。我们还展示了
    `(apply)` 形式，它接受两个参数：一个要调用的函数和一个传递给它的参数向量。
- en: One amusing aspect of the Schwartzian transform is that the person for whom
    it was named was deliberately aping Lisp when he came up with the Perl version.
    Representing it in the Clojure code here means we’ve come full circle—back to
    a Lisp again!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Schwartzian 转换的一个有趣方面是，为其命名的人故意模仿 Lisp，当他提出 Perl 版本时。在这里用 Clojure 代码表示它意味着我们已经回到了起点——再次回到了
    Lisp！
- en: The Schwartzian transform is a useful example that we’ll refer back to later.
    It contains just enough complexity to demonstrate quite a few useful concepts.
    Now let’s move on to discuss loops in Clojure, which work a bit differently from
    what you may be used to.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Schwartzian 转换是一个有用的例子，我们稍后会再次提到它。它包含足够的复杂性来展示许多有用的概念。现在让我们继续讨论 Clojure 中的循环，这些循环的工作方式可能与你习惯的不同。
- en: 10.2.5 Loops in Clojure
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5 Clojure 中的循环
- en: 'Loops in Java are a fairly straightforward proposition: the developer can choose
    from a `for`, a `while`, and a couple of other loop types. Usually central is
    the concept of repeating a group of statements until a condition (often expressed
    in terms of a mutable variable) is met.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的循环相当直接：开发者可以从 `for`、`while` 和几种其他循环类型中选择。通常，中心概念是重复一组语句，直到满足一个条件（通常用可变变量来表示）。
- en: 'This presents us with a slight conundrum in Clojure: how can we express a `for`
    loop when there are no mutable variables to act as the loop index? In more traditional
    Lisps, this situation is often solved by rewriting iterative loops into a form
    that uses recursion.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Clojure 中给我们带来了一点难题：当没有可变的变量可以作为循环索引时，我们如何表达 `for` 循环？在更传统的 Lisp 中，这种情况通常通过将迭代循环重写为使用递归的形式来解决。
- en: However, the JVM doesn’t guarantee optimizing tail recursion (as is required
    by Scheme and other Lisps), so naïvely using recursion can cause the stack to
    blow up. We will have more to say about this issue in chapter 15.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JVM 不保证优化尾递归（如 Scheme 和其他 Lisp 所需），因此天真地使用递归可能会导致堆栈溢出。我们将在第 15 章中更多关于这个问题进行讨论。
- en: 'Instead, Clojure provides some useful constructions to allow looping without
    increasing the size of the stack. One of the most common is `loop-recur`. The
    next snippet shows how `loop-recur` can be used to build up a simple construction
    similar to a Java for loop:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Clojure 提供了一些有用的构造，允许在不增加堆栈大小的情况下进行循环。其中最常见的是 `loop-recur`。下面的代码片段展示了如何使用
    `loop-recur` 来构建一个类似于 Java for 循环的简单结构：
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ The loop entry point
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 循环入口点
- en: ❷ The recur point where we jump backward
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 回跳的递归点
- en: 'The `(loop)` form takes a vector of arguments of local names for symbols—effectively
    aliases as `(let)` does. Then, when execution reaches the `(recur)` form (which
    it will do in this example only if the `ctr` alias is less than 10), the `(recur)`
    causes control to branch back to the `(loop)` form but with the new value specified.
    This is similar to a rather primitive form of Java loop construction, shown here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`(loop)` 形式接受一个局部符号名称的向量作为参数——实际上就像 `(let)` 一样是别名。然后，当执行达到 `(recur)` 形式时（在这个例子中，只有当
    `ctr` 别名小于 10 时才会这样做），`(recur)` 将控制权分支回 `(loop)` 形式，但带有新的指定值。这类似于一个相当原始的 Java
    循环结构，如下所示：'
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, for a functional programmer, the only common reason to return early
    is if some condition is met. However, functions return the result of the last
    form evaluated, and `(if)` basically already does this for us.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于函数式程序员来说，提前返回的唯一常见原因是满足某些条件。然而，函数返回最后一个评估的表达式的结果，而 `(if)` 已经为我们做了这件事。
- en: In our example, we put the `(recur)` in the body of the `if` and the countervalue
    in the `else` position. This allows us to build up iteration-style constructs
    (such as the equivalent of Java’s `for` and `while` loops) but still have a functional
    flavor to the implementation. We’ll now turn to our next topic, which is a look
    at useful shorthand in Clojure syntax to help make your programs even shorter
    and less verbose.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将 `(recur)` 放在 `if` 的主体中，将计数值放在 `else` 位置。这允许我们构建迭代式结构（例如 Java 的 `for`
    和 `while` 循环的等效形式），同时仍然保持实现的函数式风格。我们现在将转向下一个主题，即探讨 Clojure 语法中有用的缩写，以帮助使您的程序更短、更简洁。
- en: 10.2.6 Reader macros and dispatch
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.6 读取宏和分派
- en: Clojure has syntax features that surprise many Java programmers. One of them
    is the lack of operators. This has the side effect of relaxing Java’s restrictions
    on which characters can be used in function names. You’ve already met functions
    such as `(identical?)`, which would be illegal in Java, but we haven’t addressed
    the issue of exactly which characters are and aren’t allowed in symbols.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有一些语法特性会令许多 Java 程序员感到惊讶。其中之一是缺乏运算符。这导致放松了 Java 对函数名中可以使用哪些字符的限制。您已经遇到了像
    `(identical?)` 这样的函数，这在 Java 中是非法的，但我们还没有解决在符号中允许或不允许使用哪些字符的问题。
- en: Table 10.2 lists the characters that aren’t allowed in Clojure symbols. These
    are all characters that are reserved by the Clojure parser for its own use. They’re
    usually referred to as *reader macros*, and they are effectively a special character
    sequence, which, when seen by the reader (the first part of the Clojure compiler),
    modifies the reader’s behavior.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2 列出了不允许在 Clojure 符号中使用的字符。这些字符都是 Clojure 解析器为其自身使用保留的。它们通常被称为 *读取宏*，并且实际上是一个特殊的字符序列，当读取器（Clojure
    编译器的第一部分）看到它时，会修改读取器的行为。
- en: For example, the `;` reader macro is how Clojure implements single-line comments.
    When the reader sees `;`, it immediately ignores all remaining characters on this
    line, then resets to take the next line of input.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`;` 读取宏是 Clojure 实现单行注释的方式。当读取器看到 `;` 时，它会立即忽略该行上剩余的所有字符，然后重置以获取下一行的输入。
- en: Note Later we will meet Clojure’s general (or regular) macros. It is important
    not to confuse a reader macro with a regular macro.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：稍后我们将遇到 Clojure 的一般（或常规）宏。不要将读取宏与常规宏混淆。
- en: Reader macros exist only for syntactical concision and convenience, not to provide
    a full general-purpose metaprogramming capability.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 读取宏仅用于语法简洁和方便，而不是提供完整的通用元编程能力。
- en: Table 10.2 Reader macros
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2 读取宏
- en: '| Character | Name | Meaning |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 名称 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `''` | Quote | Expands to `(quote)`; yields the unevaluated form |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `''` | 引用 | 展开为 `(quote)`；返回未经评估的形式'
- en: '| `;` | Comment | Marks a comment to end of line; like `//` in Java |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `;` | 注释 | 标记注释直到行尾；类似于 Java 中的 `//`'
- en: '| `\` | Character | Produces a literal character, for example, `\n` for newline
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 字符 | 生成一个字面字符，例如，`\n` 表示换行符'
- en: '| `@` | Deref | Expands to `(deref)`, which takes in a var object and returns
    the value in that object (the opposite action of the `(var)` form); has additional
    meaning in a transactional memory context (see chapter 15) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `@` | 解引用 | 展开为 `(deref)`，它接受一个 var 对象并返回该对象中的值（`(var)` 表达式的相反操作）；在事务内存上下文中具有额外的意义（见第
    15 章）|'
- en: '| `^` | Metadata | Attaches a map of metadata to an object; see the Clojure
    documentation for details |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 元数据 | 将元数据映射附加到对象上；有关详细信息，请参阅 Clojure 文档'
- en: '| `` ` `` | Syntax-quote | Form of quote often used in macro definitions; see
    the macros section for details |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `` ` `` | 语法引用 | 常用于宏定义的引用形式；有关详细信息，请参阅宏部分'
- en: '| `#` | Dispatch | Has several different subforms; see table 10.3 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `#` | 分派 | 有几个不同的子形式；见表 10.3'
- en: The dispatch reader macro has several different subforms, depending on what
    follows the `#` character. Table 10.3 shows the different possible forms.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 分派读取宏有几个不同的子形式，具体取决于 `#` 字符后面的内容。表 10.3 展示了不同的可能形式。
- en: Table 10.3 The subforms of the dispatch reader macro
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3 分派读取宏的子形式
- en: '| Dispatch form | Meaning |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 分派形式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `#''` | Expands to (var) |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `#''` | 展开为 `(var)` |'
- en: '| `#{}` | Creates a set literal, as discussed in section 10.2.2 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `#{}` | 创建一个集合字面量，如第 10.2.2 节所述'
- en: '| `#()` | Creates an anonymous function literal; useful for single uses where
    `(fn)` is too wordy |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `#()` | 创建一个匿名函数字面量；在单次使用时比 `(fn)` 更简洁'
- en: '| `#_` | Skips the next form; can be used to produce a multiline comment, via
    #_( ... multiline ...) |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `#_` | 跳过下一个形式；可以通过 #_( ... 多行 ...) 产生多行注释 |'
- en: '| `#"<pattern>"` | Creates a regular expression literal (as a `java.util.regex.Pattern`
    object) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `#"<pattern>"` | 创建一个正则表达式字面量（作为 `java.util.regex.Pattern` 对象）|'
- en: 'A couple of additional points follow from the dispatch forms. The var-quote
    (`#''`) form, shown next, explains why the REPL behaves as it does after a `(def)`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 从分派形式中可以得出几个额外的观点。下面的 var-quote (`#'`) 形式解释了为什么在 `(def)` 之后 REPL 的行为是这样的：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `(def)` form returns the newly created var object named `someSymbol`, which
    lives in the current namespace (which is `user` in the REPL), so `#'user/someSymbol`
    is the full value of what’s returned from `(def)`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`(def)` 形式返回一个新创建的名为 `someSymbol` 的 var 对象，它位于当前命名空间中（在 REPL 中是 `user`），因此
    `#''user/someSymbol` 是 `(def)` 返回的完整值。'
- en: The anonymous function literal `#()` also has a major innovation to reduce verboseness—it
    omits the vector of arguments and instead uses a special syntax to allow the Clojure
    reader to infer how many arguments are required for the function literal. The
    syntax is `%N`, where N is the number of the argument to the function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数字面量 `#()` 也有一个重大的创新，可以减少冗余——它省略了参数向量，而是使用一种特殊的语法来允许 Clojure 读取器推断函数字面量所需的参数数量。该语法是
    `%N`，其中 N 是函数参数的编号。
- en: 'Let’s return to an earlier example and see how to use it with anonymous functions.
    Recall the `(list-maker-fun)` that takes two arguments (a list and a function)
    and creates a new list by applying the function to each element in turn:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到一个早期的例子，看看如何使用匿名函数。回想一下 `(list-maker-fun)` 这个函数，它接受两个参数（一个列表和一个函数），并通过依次将函数应用于列表中的每个元素来创建一个新的列表：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Rather than going to all the bother of defining a separate symbol, we can call
    this function with an inline function as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是费尽心思定义一个单独的符号，我们可以如下使用内联函数调用这个函数：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But we can go one step further and use the move compact `#()` syntax like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以更进一步，并像这样使用紧凑的 `#()` 语法：
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This example is a little unusual, because we’re using the `(do)` form we met
    back in the table of basic special forms, but it works. Now, let’s simplify `(list-maker-fun)`
    itself using the `#()` form:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有点不寻常，因为我们使用了之前在基本特殊形式表中遇到过的 `(do)` 形式，但它确实有效。现在，让我们使用 `#()` 形式简化 `(list-maker-fun)`
    本身：
- en: '[PRE46]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Schwartzian transform also makes an excellent use case to see how to use
    this syntax in a more complex example, as shown in the next code sample.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Schwartzian 转换也是一个很好的用例，可以展示如何在更复杂的示例中使用这种语法，如以下代码示例所示。
- en: Listing 10.4 Rewritten Schwartzian transform
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 重新编写的 Schwartzian 转换
- en: '[PRE47]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Anonymous function literals corresponding to the three steps
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对应于三个步骤的匿名函数字面量
- en: The use of %1 as a placeholder for a function literal’s argument (and %2, %3,
    and so on for subsequent arguments) makes the usage really stand out and makes
    the code a lot easier to read. This visual clue can be a real help for the programmer,
    similar to the arrow symbol used in lambda expressions in Java.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 %1 作为函数字面量参数的占位符（以及 %2、%3 等后续参数），使使用方式非常突出，并使代码更容易阅读。这个视觉线索对程序员来说确实很有帮助，类似于
    Java 中 lambda 表达式使用的箭头符号。
- en: As you’ve seen, Clojure relies heavily on the concept of functions as the basic
    unit of computation, rather than on objects, which are the staple of languages
    like Java. The natural setting for this approach is functional programming, which
    is our next topic.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Clojure 严重依赖于函数作为计算基本单元的概念，而不是像 Java 这样的语言中的对象。这种方法的自然环境是函数式编程，这是我们下一个主题。
- en: 10.3 Functional programming and closures
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 函数式编程和闭包
- en: We’re now going to turn to the scary world of functional programming in Clojure.
    Or rather, we’re *not*, because it’s just not that scary. In fact, we’ve been
    doing functional programming for this entire chapter; we just didn’t tell you
    to not put you off.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将转向 Clojure 中令人畏惧的函数式编程世界。或者，更确切地说，我们并没有，因为其实并没有那么可怕。事实上，我们已经在整个章节中进行了函数式编程；我们只是没有告诉你不要因此而感到沮丧。
- en: 'As we mentioned in section 8.1.3, functional programming is a somewhat nebulous
    concept—all it can be relied upon to mean is that a function is a value. A function
    can be passed around, placed in variables and manipulated, just like `2` or `"hello."`
    But so what? We did that back in our very first example: `(def hello (fn [] "Hello
    world"))`. We created a function (one that takes no arguments and returns the
    string `"Hello world"`) and bound it to the symbol `hello`. The function was just
    a value, not fundamentally different for a value like `2`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第8.1.3节中提到的，函数式编程是一个有些模糊的概念——它所能依赖的含义仅仅是一个函数是一个值。函数可以被传递、放置在变量中并像`2`或`"hello."`一样被操作。但这又如何呢？我们在我们的第一个例子中就做过：`(def
    hello (fn [] "Hello world"))`。我们创建了一个函数（一个不接受任何参数并返回字符串`"Hello world"`的函数），并将其绑定到符号`hello`。函数只是一个值，与像`2`这样的值没有本质的不同。
- en: In listing 10.3, we introduced the Schwartzian transform as an example of a
    function that takes another function as an input value. Again, this is just a
    function taking a particular type as one of its input arguments. The only thing
    that’s slightly different about it is that the type it’s taking is a function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10.3节中，我们介绍了Schwartzian转换作为接受另一个函数作为输入值的函数的例子。同样，这只是一个接受特定类型作为其输入参数之一的函数。它唯一的不同之处在于它接受的类型是一个函数。
- en: 'It’s probably also a good time to introduce the `(filter)` form, shown next,
    which should remind you of the similarly named method in Java Streams:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能也是介绍`(filter)`形式的好时机，它应该会让你想起Java Streams中类似命名的方法：
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There is also the `(reduce)` form, to complete the set of filter-map-reduce
    operations. It is most commonly seen in two variants, one that takes an initial
    starting value (sometimes called a “zero”) and one that doesn’t:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`(reduce)`形式，用于完成filter-map-reduce操作集。它最常见有两种变体，一种接受一个初始起始值（有时称为“零”），另一种则不：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'What about closures? Surely they’re really scary, right? Well, not so much.
    Let’s take a look at a simple example that should hopefully remind you of some
    of the examples we did for Kotlin in chapter 9:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 关于闭包呢？当然，它们一定很可怕，对吧？其实并没有那么可怕。让我们看看一个简单的例子，希望它能让你想起我们在第9章为Kotlin做的例子：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You first set up a function called `(adder)`. This is a function that makes
    other functions. If you’re familiar with the Factory Method pattern in Java, you
    can think of this as kind of a Clojure equivalent. There’s nothing strange about
    functions that have other functions as their return values—this is a key part
    of the concept that functions are just ordinary values.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先设置一个名为`(adder)`的函数。这是一个创建其他函数的函数。如果你熟悉Java中的工厂方法模式，你可以将其视为Clojure的类似物。函数返回其他函数作为其返回值并没有什么奇怪——这是函数只是普通值的概念的关键部分。
- en: Notice that this example uses the shorthand form `#()` for an anonymous function
    literal. The function `(adder)` takes in a number and returns a function, and
    the function returned from `(adder)` takes one argument.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子使用了匿名函数字面量的缩写形式`#()`。`(adder)`函数接受一个数字并返回一个函数，而返回的函数接受一个参数。
- en: 'You then use `(adder)` to define a new form: `(plus2)`. This is a function
    that takes one numeric argument and adds `2` to it. The value that was bound to
    `constToAdd` inside `(adder)` was `2`. Now let’s make a new function:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用`(adder)`来定义一个新的形式：`(plus2)`。这是一个接受一个数值参数并将其加2的函数。在`(adder)`内部绑定到`constToAdd`的值是`2`。现在让我们创建一个新的函数：
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This shows that you can make a different function, `(plus3)`, that has a different
    value bound to `constToAdd`. We say that the functions `(plus3)` and `(plus2)`
    have *captured*, or *closed over* a value from their environment. Note that the
    values that were captured by `(plus3)` and `(plus2)` were different and that defining
    `(plus3)` had no effect on the value captured by `(plus2)`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你可以创建一个不同的函数`(plus3)`，它将不同的值绑定到`constToAdd`。我们说函数`(plus3)`和`(plus2)`已经*捕获*或*封闭*了它们环境中的值。请注意，`(plus3)`和`(plus2)`捕获的值是不同的，并且定义`(plus3)`对`(plus2)`捕获的值没有影响。
- en: Functions that close over some values in their environment are called *closures*
    ; `(plus2)` and `(plus3)` are examples of closures. The pattern whereby a function-making
    function returns another, simpler function that has closed over something is a
    very common one in languages that have closures.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭其环境中的某些值的函数被称为*闭包*；`(plus2)`和`(plus3)`是闭包的例子。函数创建函数返回另一个更简单的函数，该函数已经封闭了某些内容，这种模式在具有闭包的语言中非常常见。
- en: Note Remember that although Clojure will compile any syntactically valid form,
    the program will throw a runtime exception if a function is called with the wrong
    number of arguments. A two-argument function could not be used in a place where
    a one-argument function was expected.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意请记住，尽管Clojure会编译任何语法上有效的形式，但如果函数以错误数量的参数被调用，程序将抛出运行时异常。一个需要两个参数的函数不能在期望一个参数的地方使用。
- en: We will have a lot more to say about functional programming in context in chapter
    15\. Now let’s turn to a powerful Clojure feature— sequences.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第15章中详细介绍关于在上下文中使用函数式编程的更多内容。现在，让我们转向Clojure的一个强大功能——序列。
- en: 10.4 Introducing Clojure sequences
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 介绍Clojure序列
- en: Clojure has a powerful core abstraction called the *sequence* or, more usually,
    *seq*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有一个强大的核心抽象，称为*序列*或更常见的是*seq*。
- en: Note Sequences are a major part of writing Clojure code that utilizes the strengths
    of the language, and they’ll provide an interesting contrast to how Java handles
    similar concepts.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意序列是利用Clojure语言优势编写代码的重要组成部分，并且它们将与Java处理类似概念的方式形成有趣的对比。
- en: 'The seq type roughly corresponds to collections and iterators in Java, but
    seqs have somewhat different properties. The fundamental idea is that seqs essentially
    merge some of the features of both Java types into one concept. This is motivated
    by wanting the three following things:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 序列类型大致对应于Java中的集合和迭代器，但序列具有不同的属性。基本思想是序列本质上合并了Java这两种类型的一些特性到一个概念中。这是由想要以下三个东西所驱动的：
- en: Immutability, allowing the seqs to be passed around between functions (and threads)
    without problems
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性，允许序列在函数（和线程）之间传递而不会出现问题
- en: A more robust iterator-like abstraction, especially for multipass algorithms
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更健壮的类似迭代器的抽象，特别是对于多遍算法
- en: The possibility of *lazy sequences* (more on these later)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*延迟序列*的可能性（稍后详细介绍）'
- en: 'Of these three things, the one that Java programmers sometimes struggle with
    the most is the immutability. The Java concept of an iterator is inherently mutable,
    partly because it does not provide a cleanly separable interface. In fact, Java’s
    `Iterator` violates the Single Responsibility Principle because `next()` does
    the following *two* things logically distinct things when called:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三者中，Java程序员有时最难以理解的是不可变性。Java的迭代器概念本质上是可变的，部分原因是因为它没有提供一个干净可分离的接口。事实上，Java的`Iterator`违反了单一责任原则，因为当调用`next()`时，它执行以下两个逻辑上不同的操作：
- en: It returns the currently pointed-at element.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回当前指向的元素。
- en: It mutates the iterator by advancing the element pointer.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过前进元素指针来突变迭代器。
- en: 'The seq is based on functional ideas and avoids the mutation by dividing up
    the capabilities of `hasNext()` and `next()` in a different way. Let’s meet a
    slightly simplified version of another of Clojure’s most important interfaces,
    `clojure.lang.ISeq`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 序列基于函数式思想，并通过以不同的方式分割`hasNext()`和`next()`的能力来避免突变。让我们来认识Clojure最重要的接口之一的一个稍微简化的版本，即`clojure.lang.ISeq`：
- en: '[PRE52]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ❶ Returns the object that is first in the seq
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回序列中的第一个对象
- en: ❷ Returns a new seq that contains all the elements of the old seq, except the
    first
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个包含旧序列所有元素的新序列，除了第一个
- en: 'Now, the seq is never mutated. Instead a new seq value is created every time
    we call `rest()`, which is when we would have stepped the iterator to the next
    value. Let’s look at some code to show how we might implement this in Java:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，序列永远不会被突变。相反，每次我们调用`rest()`时，都会创建一个新的序列值，这是我们在迭代器移动到下一个值时应该执行的操作。让我们看看一些代码，以展示我们如何在Java中实现这一点：
- en: '[PRE53]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Final fields
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 最终字段
- en: ❷ Factory method that takes a List
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个接受列表的工厂方法
- en: ❸ Needs an empty implementation as well
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 需要一个空的实现
- en: 'As you can see, we need a special-case seq for the end of the sequence. Let’s
    represent it as an inner class within `ArraySeq` like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要一个特殊的序列来表示序列的末尾。让我们将其表示为`ArraySeq`内部的内部类，如下所示：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s see this in action:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何付诸实践的：
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As expected, calls to `first()` are *idempotent*—they do not change the seq
    and will repeatedly return the same value.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，对`first()`的调用是*幂等的*——它们不会改变序列，并且会重复返回相同的值。
- en: 'Let’s look at how we’d write a loop in Java using `ISeq`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用`ISeq`在Java中编写循环：
- en: '[PRE56]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This example shows how we deal with one objection that some Java programmers
    sometimes have with the immutable seq approach: “What about all the garbage?”'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们如何处理一些Java程序员有时对不可变序列方法提出的反对意见：“那么所有垃圾怎么办？”
- en: It’s true that each call to `rest()` will create a new seq, which is an object.
    However, if you look closely at the implementing code you can see that we’re careful
    not to duplicate `values`—the array storage. Copying that would be expensive,
    so we don’t do that.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，每次调用 `rest()` 都会创建一个新的序列，这是一个对象。然而，如果你仔细查看实现代码，你可以看到我们非常小心地没有复制 `values`——数组存储。复制那将是昂贵的，所以我们不做那件事。
- en: All we’re really creating at each step is a tiny object that contains an int
    and a reference to an object. If these temporaries aren’t stored anywhere, they’ll
    fall out of scope as we walk down the seq and very quickly become eligible for
    garbage collection.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每一步实际上只是创建了一个包含整数和对象引用的小对象。如果这些临时变量没有存储在任何地方，当我们在序列中向下移动时，它们会超出作用域，并且很快就会成为垃圾回收的候选对象。
- en: Note The method bodies for `Empty` do not refer to either `index` or `values`,
    so we are free to use special values (–1 and `null`), which would not be able
    to be reached by any other instance of `ArraySeq`—this is a debugging aid.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`Empty` 的方法体不引用 `index` 或 `values`，因此我们可以自由地使用特殊值（-1 和 `null`），这些值无法通过 `ArraySeq`
    的任何其他实例访问——这是一个调试辅助工具。
- en: Let’s switch back into Clojure now that we’ve explained some of the theory of
    seqs using Java.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了使用 Java 解释序列理论的一些理论，让我们切换回 Clojure。
- en: Note The real `ISeq` interface that all Clojure sequences implement is a little
    more complex than the version we’ve met so far, but the basic intent is the same.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：所有 Clojure 序列实现的实际 `ISeq` 接口比我们之前遇到的情况要复杂一些，但基本意图是相同的。
- en: Some core functions that relate to sequences are shown in table 10.4\. Note
    that none of these functions will mutate their input arguments; if they need to
    return a different value, it will be a different seq.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.4 展示了一些与序列相关的核心函数。请注意，这些函数都不会修改它们的输入参数；如果它们需要返回不同的值，它将是一个不同的序列。
- en: Table 10.4 Basic sequence functions
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.4 基本序列函数
- en: '| Function | Effect |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 影响 |'
- en: '| --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(seq <coll>)` | Returns a seq that acts as a "view" onto the collection
    acted upon |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `(seq <coll>)` | 返回一个序列，作为对所作用集合的“视图” |'
- en: '| `(first <coll>)` | Returns the first element of the collection, calling (`seq`)
    on it first if necessary; returns nil if the collection is nil |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `(first <coll>)` | 如果需要，首先调用 (`seq`)，返回集合的第一个元素；如果集合为空，则返回 nil |'
- en: '| `(rest <coll>)` | Returns a new seq, made from the collection, minus the
    first element |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `(rest <coll>)` | 返回一个新的序列，由集合生成，但不包含第一个元素 |'
- en: '| `(seq? <o>)` | Returns true if `o` is a seq (meaning, if it implements `ISeq`)
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `(seq? <o>)` | 如果 `o` 是一个序列（意味着，如果它实现了 `ISeq`），则返回 true |'
- en: '| `(cons <elt> <coll>)` | Returns a seq made from the collection, with the
    additional element prepended |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `(cons <elt> <coll>)` | 返回一个由集合生成的序列，额外元素被添加到前面 |'
- en: '| `(conj <coll> <elt>)` | Returns a new collection with the new element added
    to the appropriate end—the end for vectors and the head for lists |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `(conj <coll> <elt>)` | 返回一个新的集合，新元素被添加到适当的位置——对于向量是末尾，对于列表是头部 |'
- en: '| `(every? <pred-fn> <coll>)` | Returns true if `(pred-fn)` returns logical-true
    for every item in the collection |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `(every? <pred-fn> <coll>)` | 如果 `(pred-fn)` 对集合中的每个元素都返回逻辑真值，则返回 true |'
- en: 'Clojure differs from other Lisps because `(cons)` requires the second argument
    to be a collection (or, really an `ISeq`). In general, a lot of Clojure programmers
    favor `(conj)` over `(cons)`. Here are a few examples:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 与其他 Lisp 语言不同，因为 `(cons)` 需要第二个参数是一个集合（或者，实际上是一个 `ISeq`）。一般来说，许多 Clojure
    程序员更喜欢使用 `(conj)` 而不是 `(cons)`。以下是一些示例：
- en: '[PRE57]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: One important point to note is that Clojure lists are their own seqs, but vectors
    aren’t. In theory, you shouldn’t be able to call `(rest)` on a vector. The reason
    you’re able to is that `(rest)` acts by calling `(seq)` on the vector before operating
    on it.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要观点是，Clojure 列表是它们自己的序列，但向量不是。理论上，你不应该能够在向量上调用 `(rest)`。你能够这样做的原因是 `(rest)`
    在操作之前会调用 `(seq)` 来处理向量。
- en: Note Many of the sequence functions take more general objects than seqs and
    will call `(seq)` on them before they begin.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：许多序列函数接受比序列更通用的对象，并在开始之前调用 `(seq)`。
- en: In the next section, we’re going to explore some of the basic properties and
    uses of the seq abstraction, paying special attention to variadic functions. Later,
    in chapter 15, we’ll meet lazy sequences—a very important functional technique.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨序列抽象的一些基本属性和用法，特别关注可变参数函数。稍后，在第 15 章中，我们将遇到惰性序列——这是一种非常重要的函数技术。
- en: 10.4.1 Sequences and variable-arity functions
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 序列和可变参数函数
- en: We’ve delayed discussing fully one powerful feature of Clojure’s approach to
    functions until now. This is the natural ability to easily have variable numbers
    of arguments to functions, sometimes called the *arity* of functions. Functions
    that accept variable numbers of parameters are called *variadic*, and they are
    frequently used when operating on seqs.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直推迟讨论Clojure对函数方法的强大功能之一，直到现在。这是函数自然具有可变数量参数的能力，有时称为函数的*arity*。接受可变数量参数的函数称为*可变参数*函数，它们在操作序列时经常被使用。
- en: Note Java supports variadic methods, with a syntax in which the final parameter
    of a method is shown with `...` on the type, to indicate that any number of parameters
    of that type are allowed at the end of the parameter list.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Java支持可变方法，其语法中方法的最后一个参数在类型上以`...`表示，以指示参数列表末尾允许任何数量的该类型参数。
- en: 'As a trivial example, consider the constant function `(const-fun1)` that we
    discussed in listing 10.1\. This function takes in a single argument and discards
    it, always returning the value 1\. But consider what happens when you pass more
    than one argument to `(const-fun1)` like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简单的例子，考虑我们在列表10.1中讨论的常量函数`(const-fun1)`。这个函数接受一个参数并丢弃它，总是返回值1。但是，考虑当你像这样传递多个参数给`(const-fun1)`时会发生什么：
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The Clojure compiler cannot enforce compile-time static checks on the number
    (and types) of arguments passed to `(const-fun1)`, and instead we have to risk
    runtime exceptions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure编译器无法在编译时对`(const-fun1)`传递的参数数量（和类型）执行静态检查，因此我们不得不冒运行时异常的风险。
- en: This seems overly restrictive, especially for a function that simply discards
    all of its arguments and returns a constant value. What would a function that
    could take any number of arguments look like in Clojure?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎过于严格，尤其是对于一个简单地丢弃所有参数并返回一个常量值的函数。在Clojure中，一个可以接受任意数量参数的函数看起来会是什么样子？
- en: The following listing shows how to do this for a version of the `(const-fun1)`
    constant function from earlier in the chapter. We’ve called it `(const-fun-arity1)`,
    for *constant function 1* with variable *arity*.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何为章节中较早提到的`(const-fun1)`常量函数的版本执行此操作。我们将其命名为`(const-fun-arity1)`，表示具有变量*arity*的*常量函数1*。
- en: Note This is, in fact, a homebrew version of the `(constantly)` function provided
    in the Clojure standard function library.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意实际上，这是一个Clojure标准函数库中提供的`(constantly)`函数的自制版本。
- en: Listing 10.5 Variable arity function
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 可变参数函数
- en: '[PRE59]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Multiple function definitions with different signatures
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 具有不同签名的多个函数定义
- en: The key is that the function definition is followed not by a vector of function
    parameters and then a form defining the behavior of the function. Instead, there
    is a list of pairs, with each pair consisting of a vector of parameters (effectively
    the signature of this version of the function) and the implementation for this
    version of the function.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，函数定义后面不是函数参数的向量以及定义函数行为的表单。相反，有一系列成对出现的内容，每个成对由参数的向量（实际上是该版本函数的签名）和该版本函数的实现组成。
- en: This can be thought of as a similar concept to method overloading in Java. Alternatively,
    it could also be seen as related to pattern matching (which we met in chapter
    3). However, because Clojure is a dynamically typed language, there is no equivalent
    of type patterns, and so the connection is not as strong as it might be.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被视为类似于Java中的方法重载的概念。或者，它也可以被视为与模式匹配（我们在第3章中遇到过的）相关。然而，由于Clojure是一种动态类型语言，没有类型模式的等价物，因此这种联系并不像可能的那样紧密。
- en: The usual convention is to define a few special-case forms (that take none,
    one, or two parameters) and an additional form that has as its last parameter
    a seq. In listing 10.5, this is the form that has the parameter vector of `[x
    & more]`. The `&` sign indicates that this is the variadic version of the function.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的约定是定义几种特殊情况的形式（这些形式接受零个、一个或两个参数）以及一个额外的形式，其最后一个参数是一个序列。在列表10.5中，这是具有参数向量`[x
    & more]`的形式。`&`符号表示这是函数的可变版本。
- en: Sequences are a powerful Clojure innovation. In fact, a large part of learning
    to think in Clojure is to start thinking about how the seq abstraction can be
    put to use to solve your specific coding problems. Another important innovation
    in Clojure is the integration between Clojure and Java, which is the subject of
    the next section.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是 Clojure 的一项强大创新。实际上，学习如何在 Clojure 中思考的大部分内容就是开始思考如何将 seq 抽象应用于解决你特定的编码问题。Clojure
    的另一个重要创新是 Clojure 与 Java 之间的集成，这是下一节的主题。
- en: 10.5 Interoperating between Clojure and Java
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 在 Clojure 和 Java 之间进行互操作
- en: Clojure was designed from the ground up to be a JVM language and to not attempt
    to completely hide the JVM character from the programmer. These specific design
    choices are apparent in a number of places. For example, at the type-system level,
    Clojure’s lists and vectors both implement `List`—the standard interface from
    the Java collections library. In addition, it’s very easy to use Java libraries
    from Clojure and vice versa. These properties are extremely useful, because Clojure
    programmers can make use of the rich variety of Java libraries and tooling, as
    well as the performance and other features of the JVM.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是从头开始设计的，旨在成为 JVM 语言，并且不试图完全隐藏 JVM 的特性给程序员。这些具体的设计选择在许多地方都很明显。例如，在类型系统级别，Clojure
    的列表和向量都实现了 `List`——Java 集合库的标准接口。此外，从 Clojure 使用 Java 库以及反之亦然都非常容易。这些特性非常有用，因为
    Clojure 程序员可以利用丰富的 Java 库和工具，以及 JVM 的性能和其他功能。
- en: 'In this section, we’ll cover a number of aspects of this interoperability decision,
    specifically:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍这个互操作性决策的多个方面，特别是：
- en: Calling Java from Clojure
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Clojure 调用 Java
- en: How Java sees the type of Clojure functions
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 如何看待 Clojure 函数的类型
- en: Clojure proxies
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 代理
- en: Exploratory programming with the REPL
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 REPL 进行探索性编程
- en: Calling Clojure from Java
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Java 调用 Clojure
- en: Let’s start exploring this integration by looking at how to access Java methods
    from Clojure.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看如何从 Clojure 访问 Java 方法来开始探索这种集成。
- en: 10.5.1 Calling Java from Clojure
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 从 Clojure 调用 Java
- en: 'Consider this piece of Clojure code being evaluated in the REPL:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在 REPL 中评估的 Clojure 代码片段：
- en: '[PRE60]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this snippet, we’ve used the Schwartzian transform to sort a vector of strings
    by their lengths. To do that, we’ve used the forms `(.toString)` and `(.length)`,
    which are Java methods. They’re being called on the Clojure objects. The period
    at the start of the symbol means that the runtime should invoke the named method
    on the next argument. This is achieved by the behind-the-scenes use of another
    macro that we haven’t met yet—`(.)`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用了 Schwartzian 转换来按字符串长度对字符串向量进行排序。为此，我们使用了 `(.toString)` 和 `(.length)`
    形式，它们是 Java 方法。它们被调用在 Clojure 对象上。符号开头的点表示运行时应该在下一个参数上调用命名方法。这是通过使用我们尚未遇到的另一个宏
    `(.)` 来实现的。
- en: Recall that all Clojure values defined by `(def)` or a variant of it are placed
    into instances of `clojure.lang.Var`, which can house any `java.lang.Object`,
    so any method that can be called on `java.lang.Object` can be called on a Clojure
    value. Some of the other forms for interacting with the Java world are
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，所有通过 `(def)` 或其变体定义的 Clojure 值都被放置在 `clojure.lang.Var` 的实例中，它可以容纳任何 `java.lang.Object`，因此可以在
    Clojure 值上调用任何可以在 `java.lang.Object` 上调用的方法。与其他与 Java 世界交互的形式一样
- en: '[PRE61]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: for calling static methods (in this case the `System.getProperty()` method)
    and
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 调用静态方法（在这种情况下是 `System.getProperty()` 方法）和
- en: '[PRE62]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: for accessing static public variables (such as constants).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问静态公共变量（例如常量）。
- en: 'The familiar “Hello World” example looks like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉的“Hello World”示例看起来像这样：
- en: '[PRE63]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that the final `nil` is because, of course, all Clojure forms must return
    a value, even if they are a call to a `void` Java method.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后的 `nil` 是因为，当然，所有 Clojure 表达式都必须返回一个值，即使它们是对 `void` Java 方法的调用。
- en: In these three examples, we’ve implicitly used Clojure’s namespaces concept,
    which is similar to Java packages and has mappings from shorthand forms to Java
    package names for common cases, such as the preceding ones.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个示例中，我们隐式地使用了 Clojure 的命名空间概念，这与 Java 包类似，并为常见情况（如前面所述）提供了从简写形式到 Java 包名的映射。
- en: 10.5.2 The nature of Clojure calls
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 Clojure 调用的本质
- en: A function call in Clojure is compiled to a JVM method call. The JVM does not
    guarantee optimizing away tail recursion, which Lisps (especially Scheme implementations)
    usually do. Some other Lisp dialects on the JVM take the viewpoint that they want
    true tail recursion, so they are prepared to have a Lisp function call not be
    exactly equivalent to a JVM method call under all circumstances. Clojure, however,
    fully embraces the JVM as a platform, even at the expense of full compliance with
    usual Lisp practice.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中的函数调用被编译成JVM方法调用。JVM不保证优化掉尾递归，而Lisp（尤其是Scheme实现）通常都会这样做。一些其他在JVM上的Lisp方言持有一个观点，即它们想要真正的尾递归，因此它们准备让Lisp函数调用在所有情况下都不完全等同于JVM方法调用。然而，Clojure却完全拥抱JVM作为平台，即使这意味着完全遵守通常的Lisp实践。
- en: 'If you want to create a new instance of a Java object and manipulate it in
    Clojure, you can easily do so by using the `(new)` form. This has an alternative
    short form, which is the class name followed by the full stop, which boils down
    to another use of the `(.)` macro, as shown next:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Clojure中创建一个新的Java对象实例并对其进行操作，你可以通过使用`(new)`形式轻松做到这一点。它有一个简短的替代形式，即类名后跟一个全点，这归结为`(.)`宏的另一种用法，如下所示：
- en: '[PRE64]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here we’re also using the `(import)` form, which allows multiple Java classes
    from a single package to be imported in just one line.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也在使用`(import)`形式，它允许在单行中导入一个包中的多个Java类。
- en: We mentioned earlier that there’s a certain amount of alignment between Clojure’s
    type system and that of Java. Let’s take a look at this concept in a bit more
    detail.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，Clojure的类型系统与Java的类型系统有一定的对应关系。让我们更详细地看看这个概念。
- en: 10.5.3 The Java type of Clojure values
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.3 Clojure值的Java类型
- en: 'From the REPL, it’s very easy to take a look at the Java types of some Clojure
    values as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 从REPL中，查看一些Clojure值的Java类型非常简单，如下所示：
- en: '[PRE65]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first thing to notice is that all Clojure values are objects; the primitive
    types of the JVM aren’t exposed by default (although there are ways of getting
    at the primitive types for the performance-conscious). As you might expect, the
    string and numeric values map directly onto the corresponding Java reference types
    (`java.lang.String`, `java.lang.Double`, and so on).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，所有Clojure值都是对象；JVM的原始类型默认不暴露（尽管有方法可以获取性能敏感的原始类型）。正如你所期望的，字符串和数值值直接映射到相应的Java引用类型（`java.lang.String`、`java.lang.Double`等）。
- en: The anonymous “Hello world!” function has a name that indicates that it’s an
    instance of a dynamically generated class. This class will implement the interface
    `IFn`, which is the very important interface that Clojure uses to indicate that
    a value is a function.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名的“Hello world!”函数有一个表明它是动态生成类实例的名称。这个类将实现`IFn`接口，这是Clojure用来指示一个值是函数的非常重要的接口。
- en: As we discussed a bit earlier, seqs implement the `ISeq` interface. They will
    typically be one of the concrete subclasses of the abstract `ASeq` or the lazy
    implementation, `LazySeq` (we’ll meet laziness in chapter 15 when we talk about
    advanced functional programming).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，seqs实现了`ISeq`接口。它们通常是抽象的`ASeq`的具体系列之一或懒实现`LazySeq`（我们将在第15章讨论高级函数式编程时遇到懒加载）。
- en: We’ve looked at the types of various values, but what about the storage for
    those values? As we mentioned at the start of this chapter, `(def)` binds a symbol
    to a value and, in doing so, creates a var. These vars are objects of type `clojure.lang.Var`
    (which implements `IFn`, among other interfaces).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了各种值的类型，但那些值的存储呢？正如我们在本章开头提到的，`(def)`将一个符号绑定到一个值，并在这样做的同时创建一个var。这些var是类型为`clojure.lang.Var`的对象（它实现了`IFn`以及其他接口）。
- en: 10.5.4 Using Clojure proxies
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.4 使用Clojure代理
- en: Clojure has a powerful macro called `(proxy)` that enables you to create a bona
    fide Clojure object that extends a Java class (or implements an interface). For
    example, the next listing revisits an earlier example (using the `ScheduledThreadPoolExecutor`
    from chapter 6), but the heart of the execution example is now done in a fraction
    of the code, due to Clojure’s more compact syntax.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有一个强大的宏叫做`(proxy)`，它允许你创建一个真正的Clojure对象，该对象扩展Java类（或实现接口）。例如，下一个列表回顾了一个早期的例子（使用第6章中的`ScheduledThreadPoolExecutor`），但由于Clojure更紧凑的语法，执行示例的核心现在只需很少的代码。
- en: Listing 10.6 Revisiting scheduled executors
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 重访计划执行器
- en: '[PRE66]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ❶ Factory method to create an executor
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建执行器的工厂方法
- en: ❷ Defines an anonymous implementation of Runnable
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个匿名的Runnable实现
- en: 'The general form of `(proxy)` follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`(proxy)` 的一般形式如下：'
- en: '[PRE67]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The first vector argument holds the interfaces that this proxy class should
    implement. If the proxy should also extend a Java class (and it can, of course,
    extend only one Java class), that class name must be the first element of the
    vector.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个向量参数包含这个代理类应该实现的接口。如果代理类还应该扩展一个 Java 类（当然，它只能扩展一个 Java 类），那么这个类的名称必须是向量中的第一个元素。
- en: The second vector argument comprises the parameters to be passed to a superclass
    constructor. This is quite often the empty vector, and it will certainly be empty
    for all cases where the `(proxy)` form is just implementing Java interfaces.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个向量参数包含要传递给超类构造函数的参数。这通常是一个空向量，并且对于 `(proxy)` 形式只是实现 Java 接口的所有情况，它肯定是一个空向量。
- en: After these two arguments come the forms that represent the implementations
    of individual methods, as required by the interfaces or superclasses specified.
    In our example, the proxy needs to implement only `Runnable`, so that is the only
    symbol in the first vector of arguments. No superclass parameters are needed,
    so the second vector is empty (as it very often is).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个参数之后，是表示接口或超类指定的单个方法实现的表单。在我们的例子中，代理只需要实现 `Runnable`，所以这是第一个向量参数中的唯一符号。不需要超类参数，所以第二个向量是空的（这通常也是这样）。
- en: 'Following the two vectors, comes a list of forms that define the methods that
    the proxy will implement. In our case, that is just `run()`, and we give it the
    definition `(run [] (.println System/out (.toString (.poll lbq))))`. This is,
    of course, just the Clojure way of writing this bit of Java:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个向量之后，是一个定义代理将实现的方法的表单列表。在我们的情况下，这只是 `run()`，我们给它定义 `(run [] (.println System/out
    (.toString (.poll lbq)))))`。这当然是 Clojure 写这个 Java 代码块的方式：
- en: '[PRE68]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `(proxy)` form allows for the simple implementation of any Java interface.
    This leads to an intriguing possibility—that of using the Clojure REPL as an extended
    playpen for experimenting with Java and JVM code.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`(proxy)` 形式允许简单地实现任何 Java 接口。这导致了一个引人入胜的可能性——使用 Clojure REPL 作为扩展的实验平台来实验
    Java 和 JVM 代码。'
- en: 10.5.5 Exploratory programming with the REPL
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.5 使用 REPL 进行探索性编程
- en: The key concept of exploratory programming is that with less code to write,
    due to Clojure’s syntax, and the live, interactive environment that the REPL provides,
    the REPL can be a great environment for not only exploring Clojure programming
    but for learning about Java libraries as well.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性编程的关键概念是，由于 Clojure 的语法，以及 REPL 提供的实时、交互式环境，REPL 可以是一个很好的环境，不仅用于探索 Clojure
    编程，还可以用于学习 Java 库。
- en: 'Let’s consider the Java list implementations. They have an `iterator()` method
    that returns an object of type Iterator. But Iterator is an interface, so you
    might be curious about what the real implementing type is. Using the REPL, it’s
    easy to find out as shown here:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 Java 列表实现。它们有一个 `iterator()` 方法，返回一个 `Iterator` 类型的对象。但 `Iterator` 是一个接口，所以你可能想知道实际的实现类型是什么。使用
    REPL，很容易找到，如下所示：
- en: '[PRE69]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `(import)` form brings in two different classes from the `java.util` package.
    Then you can use the `getClass()` Java method from within the REPL just as you
    did in section 10.5.3\. As you can see, the iterators are actually provided by
    inner classes. This perhaps shouldn’t be surprising; as we discussed in section
    10.4, iterators are tightly bound up with the collections they come from, so they
    may need to see internal implementation details of those collections.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`(import)` 形式从 `java.util` 包中引入了两个不同的类。然后你可以在 REPL 中使用 `getClass()` Java 方法，就像你在
    10.5.3 节中所做的那样。正如你所看到的，迭代器实际上是由内部类提供的。这可能并不令人惊讶；正如我们在 10.4 节中讨论的，迭代器与它们所属的集合紧密相关，因此它们可能需要看到这些集合的内部实现细节。'
- en: Notice that in the preceding example, we didn’t use a single Clojure construct—just
    a little bit of syntax. Everything we were manipulating was a true Java construct.
    Let’s suppose, though, that you wanted to use a different approach and use the
    powerful abstractions that Clojure brings within a Java program. The next subsection
    will show you just how to accomplish this.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的例子中，我们没有使用单个 Clojure 构造，只是稍微使用了一点语法。我们操作的一切都是真正的 Java 构造。但是，假设你想使用不同的方法，并在
    Java 程序中使用 Clojure 提供的强大抽象。下一小节将向你展示如何实现这一点。
- en: 10.5.6 Using Clojure from Java
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.6 从 Java 使用 Clojure
- en: Recall that Clojure’s type system is closely aligned with Java’s. The Clojure
    data structures are all true Java collections that implement the whole of the
    mandatory part of the Java interfaces. The optional parts aren’t usually implemented,
    because they’re often about mutation of the data structures, which Clojure doesn’t
    support.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Clojure的类型系统与Java的类型系统紧密对齐。Clojure的数据结构都是真正的Java集合，实现了Java接口的强制性部分。可选部分通常不实现，因为它们通常涉及数据结构的修改，而Clojure不支持这种修改。
- en: This alignment of type systems opens the possibility of using Clojure data structures
    in a Java program. This is made even more viable by the nature of Clojure itself—it’s
    a compiled language with a calling mechanism that matches that of the JVM. This
    minimizes the runtime aspects and means a class obtained from Clojure can be treated
    almost like any other Java class. Interpreted languages would find it a lot harder
    to interoperate and would typically require a minimal non-Java language runtime
    for support.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型系统的对齐为在Java程序中使用Clojure数据结构打开了可能性。由于Clojure本身的性质——它是一种编译语言，具有与JVM匹配的调用机制，这使得这一点更加可行。这最小化了运行时方面，意味着从Clojure获得的类可以几乎像任何其他Java类一样处理。解释型语言会发现这要困难得多，并且通常需要一个最小的非Java语言运行时来支持。
- en: 'The next example shows how Clojure’s seq construct can be used on an ordinary
    Java string. For this code to run, `clojure.jar` will need to be on the classpath:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何使用Clojure的seq构造在普通的Java字符串上。为了使此代码运行，`clojure.jar`需要位于类路径中：
- en: '[PRE70]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding code snippet uses the factory method `create()` from the `StringSeq`
    class. This provides a seq view on the character sequence of the string. The `first()`
    and `next()` methods return new values, as opposed to mutating the existing seq,
    just as we discussed in section 10.4.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段使用了`StringSeq`类的`create()`工厂方法。这为字符串的字符序列提供了一个seq视图。`first()`和`next()`方法返回新的值，而不是像我们在第10.4节中讨论的那样修改现有的seq。
- en: In the next section, we’ll move on to talk Clojure’s macros. This is a powerful
    technique that allows the experienced programmer to effectively modify the Clojure
    language itself. This capability is common in languages like Lisp but rather alien
    to Java programmers, so it warrants an entire section to itself.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续讨论Clojure的宏。这是一种强大的技术，允许经验丰富的程序员有效地修改Clojure语言本身。这种能力在像Lisp这样的语言中很常见，但对于Java程序员来说却相当陌生，因此它值得单独一节来介绍。
- en: 10.6 Macros
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 宏
- en: In chapter 8, we discussed the rigidity of the language grammar of Java. By
    contrast, Clojure provides and actively encourages macros as a mechanism to provide
    a much more flexible approach, allowing the programmer to write more or less ordinary
    program code that behaves in the same way as built-in language syntax.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们讨论了Java语言语法的刚性。相比之下，Clojure提供并积极鼓励使用宏作为提供更灵活方法的机制，允许程序员编写更多或更少的普通程序代码，这些代码的行为与内置语言语法相同。
- en: Note Many languages have macros (including C++), and they mostly all operate
    in a roughly similar way—by providing a special phase of source code compilation,
    often the very first phase.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：许多语言都有宏（包括C++），并且它们大多以类似的方式运作——通过提供一个特殊的源代码编译阶段，通常是第一个阶段。
- en: For example, in the C language, the first step is *preprocessing*, which removes
    comments, inlines included files, and expands macros, which are the different
    types of *preprocessor directives* such as `#include` and `#define`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在C语言中，第一步是*预处理*，它移除注释、内联包含的文件，并展开宏，这些宏是不同的*预处理器指令*，如`#include`和`#define`。
- en: However, although C macros were very powerful, they also make it possible for
    engineers to produce some very subtly confusing code that is hard to understand
    and debug. To avoid this complexity, the Java language never implemented a macro
    system or a preprocessor.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管C宏非常强大，但它们也使得工程师能够生成一些非常微妙且难以理解和调试的代码。为了避免这种复杂性，Java语言从未实现过宏系统或预处理器。
- en: C macros work by providing very simple text-replacement capabilities during
    the preprocessing phase. Clojure macros are safer, because they work within the
    syntax of Clojure itself. Effectively, they allow the programmer to create a special
    kind of function that is evaluated (in a special way) at compile time. The macro
    can transform source code during compilation during what is referred to as *macro
    expansion time*.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: C宏通过在预处理阶段提供非常简单的文本替换功能来工作。Clojure宏更安全，因为它们在Clojure本身的语法中工作。实际上，它们允许程序员创建一种特殊的函数，该函数在编译时（以特殊方式）进行评估。宏可以在所谓的*宏展开时间*期间在编译过程中转换源代码。
- en: Note The key to the power of macros is the fact that Clojure code is written
    down as a valid Clojure data structure—specifically as a list of forms.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：宏的强大之处在于Clojure代码被写成有效的Clojure数据结构——具体来说，是一个形式的列表。
- en: We say that Clojure, like other Lisps (and a few other languages), is *homoiconic*,
    which means that programs are represented in the same way as data. Other programming
    languages, like Java, write their source code as a string, and without parsing
    that string in a Java compiler, the structure of the program cannot be determined.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说Clojure，就像其他Lisp（以及一些其他语言）一样，是*homoiconic*的，这意味着程序以与数据相同的方式表示。其他编程语言，如Java，将它们的源代码写成字符串，并且如果不解析这个字符串在Java编译器中，就无法确定程序的结构。
- en: Recall that Clojure compiles source code as it is encountered. Many Lisps are
    interpreted languages, but Clojure is not. Instead, when Clojure source code is
    loaded, it is compiled on the fly into JVM bytecode. This can give the superficial
    impression that Clojure is interpreted, but the (very simple) Clojure compiler
    is hiding just below the surface.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Clojure在遇到源代码时会编译源代码。许多Lisp是解释型语言，但Clojure不是。相反，当Clojure源代码被加载时，它会即时编译成JVM字节码。这可能会给人一种Clojure是解释型的表面印象，但实际上（非常简单的）Clojure编译器隐藏在表面之下。
- en: Note A Clojure form is a list, and a macro is essentially a function that does
    not evaluate its arguments but instead manipulates them to return another list,
    which will then be compiled as a Clojure form.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Clojure形式是一个列表，宏本质上是一个不评估其参数而是操作它们以返回另一个列表的函数，然后该列表将被编译为Clojure形式。
- en: 'To demonstrate this, let’s try to write a macro form that acts like the opposite
    of `(if)`. In some languages, this would be represented with the `unless` keyword,
    so in Clojure it will be an `(unless)` form. What we want is a form that looks
    like `(if)` but behaves as the logical opposite, like this:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们尝试编写一个类似于`(if)`的反向操作的宏形式。在某些语言中，这会用`unless`关键字表示，所以在Clojure中它将是一个`(unless)`形式。我们想要的格式看起来像`(if)`，但行为是逻辑上的相反，如下所示：
- en: '[PRE71]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that we don’t provide the equivalent of an `else` condition. This somewhat
    simplifies the example and “unless ... else” sounds weird anyway. In our examples,
    if the `unless` logical test fails, the form evaluates to `nil`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有提供`else`条件的等效物。这使示例变得有些简单，而且“unless ... else”听起来也很奇怪。在我们的示例中，如果`unless`逻辑测试失败，该形式评估为`nil`。
- en: 'If we try to write this using `(defn)`, we can write a simple first attempt
    like this (spoiler: it won’t actually work properly):'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用`(defn)`来编写，我们可以写一个简单的初步尝试，如下所示（剧透：实际上它不会正确工作）：
- en: '[PRE72]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This seems fine. However, consider that we want `(unless)` to work the same
    way as `(if)`—in particular, the `then` form should evaluated only if the Boolean
    predicate condition is true. In other words, for `(if)` we see this behavior:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎没问题。然而，考虑一下我们希望`(unless)`以与`(if)`相同的方式工作——特别是，只有当布尔谓词条件为真时，`then`形式才应该被评估。换句话说，对于`(if)`，我们看到这种行为：
- en: '[PRE73]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When we try to use our `(unless)` function in the same way, the problem becomes
    clear, as illustrated here:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试以相同的方式使用我们的`(unless)`函数时，问题变得明显，如下所示：
- en: '[PRE74]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Regardless of whether the predicate is true or false, the `then` form is still
    evaluated, and as it is `(println)` in our example, it produces output, which
    provides the clue that lets us know that the evaluation is taking place. To solve
    this problem, we need to handle the forms that we are passed *without evaluating
    them*. This is essentially a (slightly different) kind of the laziness concept
    that is so important in functional programming (and which we will describe in
    detail in chapter 15). The special form `(defmacro)` is used to declare a new
    macro, like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 无论谓词是真还是假，`then` 形式仍然会被评估，并且由于在我们的例子中它是 `(println)`，它会产生输出，这为我们提供了线索，让我们知道评估正在进行。为了解决这个问题，我们需要处理我们传递的表单而无需评估它们。这本质上是一种（略有不同）的惰性概念，这在函数式编程中非常重要（我们将在第15章中详细描述）。特殊形式
    `(defmacro)` 用于声明一个新的宏，如下所示：
- en: '[PRE75]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let’s see if it does the right thing:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是否做得正确：
- en: '[PRE76]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This now behaves as we want it to: essentially, the `(unless)` form now looks
    and behaves just like the built-in `(if)` special form.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它表现得就像我们希望的那样：本质上，`(unless)` 形式现在看起来和表现得就像内置的 `(if)` 特殊形式一样。
- en: As you can see, one of the drawbacks of writing macros is that a lot of quoting
    is involved. The macro transforms its arguments to a new Clojure form at compile
    time, so it is natural that the output should be a `(list)`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，编写宏的一个缺点是涉及到大量的引用。宏在编译时将其参数转换为一个新的大Clojure形式，因此输出应该是 `(list)` 是很自然的。
- en: The list contains Clojure symbols that will be evaluated at runtime, so anything
    that we do not explicitly need to evaluate during macro expansion must be quoted.
    This relies upon the fact that macros receive their arguments at compile time,
    so they are available as unevaluated data.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中包含在运行时将被评估的Clojure符号，因此在我们进行宏展开期间不需要显式评估的任何内容都必须被引用。这依赖于宏在编译时接收它们的参数，因此它们作为未评估的数据可用。
- en: In our example, we need to quote everything that is *not* one of our arguments—these
    will be string-replaced as symbols during expansion. This gets pretty cumbersome
    fairly quickly. Can we do better?
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们需要引用所有不是我们参数的内容——这些将在展开期间被字符串替换为符号。这很快就变得相当繁琐。我们能做得更好吗？
- en: 'Let’s meet a helpful tool that might point us in the right direction. When
    writing or debugging macros, the `(macroexpand-1)` form can be very useful. If
    this form is passed a macro form, it expands the macro and returns the expansion.
    If the passed form is not a macro, it just returns the form, for example:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们认识一个可能指明正确方向的实用工具。在编写或调试宏时，`(macroexpand-1)` 形式非常有用。如果将这个形式传递给一个宏形式，它将展开宏并返回展开后的形式。如果传递的形式不是一个宏，它就只返回该形式，例如：
- en: '[PRE77]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: What we would really like is the ability to write macros that look like their
    macro-expanded form without the huge amount of quoting that we’ve seen in examples
    so far.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正希望的是能够编写出看起来像它们的宏展开形式，而不需要像迄今为止示例中所见的那样大量的引用。
- en: 'Note Full macro expansion, using the form `(macroexpand)`, is then constructed
    by just repeatedly calling the former, simpler form. When applying `(macroexpand-1)`
    is a no-op, macro expansion is over. The key to this capability is the special
    reader macro `` ` ``, which is pronounced “syntax-quote” and which we previewed
    earlier in the chapter as part of the section about reader macros. The syntax
    quoting reader macro works by basically quoting everything in the following form.
    If you want something to *not* be quoted, you have to use the syntax-unquote (`~`)
    operator to exempt a value from syntax quoting. This means our example macro `(unless)`
    can be written as follows:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用 `(macroexpand)` 形式进行完全宏展开时，只需重复调用前面的、更简单的形式即可构建。当应用 `(macroexpand-1)`
    时没有操作，宏展开就结束了。这种能力的关键是特殊的读取宏 ``` ``，它读作“语法引号”，我们在本章关于读取宏的部分中已经预览过它。语法引号读取宏通过基本上引用以下形式中的所有内容来工作。如果你想让某些内容不被引用，你必须使用语法非引号（`~`）运算符来免除一个值从语法引号中。这意味着我们的示例宏
    `(unless)` 可以写成如下形式：
- en: '[PRE78]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This form is now much clearer and closer to the form we see when macro expanding.
    The `~` character provides a nice visual clue to let us know that those symbols
    will be replaced when the macro is expanded. This fits nicely with the idea of
    a macro as a compile-time code template.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个形式现在更加清晰，更接近我们在宏展开时看到的形式。`~` 字符提供了一个很好的视觉线索，让我们知道那些符号将在宏展开时被替换。这与宏作为编译时代码模板的想法很好地吻合。
- en: 'Along with syntax-quote and -unquote, some important special variables are
    sometimes used in macro definitions. Of these, two of the most common follow:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法引用和取消引用之外，一些重要的特殊变量有时在宏定义中使用。其中，最常见的是以下两个：
- en: '`&form`—the expression that is being invoked'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&form`—正在调用的表达式'
- en: '`&env`—a map of local bindings at the point of macro expansion'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&env`—宏展开点的局部绑定映射'
- en: Full details of the information that can be obtained from each special variable
    can be found in the Clojure documentation.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从每个特殊变量中获得的信息的详细信息可以在 Clojure 文档中找到。
- en: 'We should also note that care needs to be taken when writing Clojure macros.
    For example, it is possible to create macros that create recursive expansions
    that do not terminate and instead *diverge*, such as the following example:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，在编写 Clojure 宏时需要小心。例如，可以创建递归展开而不终止而是*发散*的宏，如下面的示例所示：
- en: '[PRE79]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As a final example, let’s confirm that macros do in fact operate at compile
    time by constructing a macro that essentially acts as a closure that bridges from
    compile to runtime, shown next:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，让我们通过构建一个本质上充当从编译到运行时桥梁的闭包的宏来确认宏确实在编译时操作，如下所示：
- en: '[PRE80]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Notice how the `(let)` form is evaluated at compile time, so the value of `(System/
    currentTimeMillis)` is captured when the macro is evaluated, bound to the symbol
    `num`, and then replaced in the expanded form with the value that was bound— effectively
    a constant determined at compile time.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `(let)` 形式是在编译时评估的，因此当宏被评估时，`(System/currentTimeMillis)` 的值被捕获，绑定到符号 `num`，然后在展开形式中用绑定的值替换——实际上是一个在编译时确定的常量。
- en: Even though we have introduced macros at the very end of this chapter, macros
    are actually all around us in Clojure. In fact, much of the Clojure standard library
    is implemented as macros. The well-grounded developer can learn a lot by spending
    some time reading the source of the standard library and observing how key parts
    of it have been written.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本章的最后介绍了宏，但实际上宏在 Clojure 中无处不在。事实上，Clojure 标准库的大部分内容都是作为宏实现的。有经验的开发者可以通过花时间阅读标准库的源代码并观察其关键部分的编写方式来学到很多东西。
- en: 'At this point, a word of warning is also timely: macros are a powerful technique,
    and there is a temptation (just as there is with other techniques that “level
    up” a programmer’s thinking) that some developers can fall prey to—the tendency
    to overuse the technique by including when it is not strictly necessary.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，一个警告也是及时的：宏是一种强大的技术，有些开发者可能会陷入一种诱惑（就像其他“提升”程序员思维的技术一样），那就是在不严格必要的情况下过度使用这种技术。
- en: 'To guard against this, we highly recommend that you keep in mind the following
    simple general rules for the use of Clojure macros:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，我们强烈建议您牢记以下简单的通用规则，用于 Clojure 宏的使用：
- en: Never write a macro when the goal can be accomplished with a function.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当目标可以通过函数实现时，永远不要编写宏。
- en: Write a macro to implement a feature, capability, or pattern that is not already
    present in the language or standard library.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个宏来实现语言或标准库中尚未存在的功能、能力或模式。
- en: The first of these is, of course, merely the old adage that “just because you
    *can* do something doesn’t mean that you *should* ” in a different guise.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的第一个当然是“你*可以*做某事并不意味着你*应该*”的另一种说法。
- en: 'The second is a reminder that macros exist for a reason: there are things that
    you can do with them that cannot really be done in any other way. A proficient
    Clojure programmer will be able to use macros to great effect where appropriate.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是一个提醒，宏的存在是有原因的：你可以用它们做些其他方式真的无法做到的事情。熟练的 Clojure 程序员将能够在适当的地方有效地使用宏。
- en: Beyond macros, there is still more to learn about Clojure, such as the language’s
    approach to dynamic runtime behavior. In Java this is usually handled using class
    and interface inheritance and virtual dispatch, but these are fundamentally object-oriented
    concepts and are not a particularly good fit for Clojure.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 除了宏之外，还有更多关于 Clojure 的知识需要学习，例如语言对动态运行时行为的处理方式。在 Java 中，这通常是通过类和接口继承以及虚拟调度来处理的，但这些是基本面向对象的概念，并不特别适合
    Clojure。
- en: Instead, Clojure uses *protocols* and *datatypes*—along with the proxies that
    we have already met—to provide much of this flexibility. There are even more possibilities,
    such as custom dispatch schemes that use *multimethods*. These are also very powerful
    techniques but, unfortunately, are a little far outside of this introductory treatment
    of Clojure.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Clojure使用**协议**和**数据类型**——以及我们已经遇到的代理——来提供大部分这种灵活性。甚至还有更多可能性，例如使用**多方法**的定制分派方案。这些也是非常强大的技术，但不幸的是，它们超出了Clojure的这种入门级介绍。
- en: As a language, Clojure is arguably the most different from Java of the languages
    we’ve looked at. Its Lisp heritage, emphasis on immutability, and different approaches
    seem to make it into an entirely separate language. But its tight integration
    with the JVM, alignment of its type system (even when it provides alternatives,
    such as seqs), and the power of exploratory programming make it a very complementary
    language to Java.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种语言，Clojure可以说是我们探讨过的语言中最不同于Java的。它的Lisp血统、对不可变性的强调以及不同的方法似乎使它成为一个完全不同的语言。但与JVM的紧密集成、类型系统的对齐（即使它提供了替代方案，如seqs），以及探索性编程的力量使它成为Java的一个非常互补的语言。
- en: The differences between the languages we’ve studied in this part clearly show
    the power of the Java platform to evolve and to continue to be a viable destination
    for application development. This is also a testament to the flexibility and capability
    of the JVM.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本部分探讨的语言之间的差异清楚地显示了Java平台演变和继续成为应用开发可行目的地的力量。这也是对JVM的灵活性和能力的证明。
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Clojure is dynamically typed, and Java programmers need to be careful of runtime
    exceptions.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure是动态类型的，Java程序员需要小心运行时异常。
- en: Exploratory and REPL-based development is a different feel from a Java IDE.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索性和基于REPL的开发与Java IDE的感觉截然不同。
- en: Clojure provides and promotes a very immutable style of programming.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure提供并推广了一种非常不可变风格的编程。
- en: Functional programming pervades Clojure—far more so than Java or Kotlin.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程贯穿Clojure——比Java或Kotlin都要多。
- en: Seqs are a functional equivalent to Java’s iterators and collections.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seqs是Java的迭代器和集合的功能等价物。
- en: Macros define a compile-time transformation of Clojure source.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏定义了Clojure源代码的编译时转换。
