- en: 3 Breaking dependencies with stubs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 使用存根打破依赖
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Types of dependencies—mocks, stubs, and more
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖类型—模拟、存根等
- en: Reasons to use stubs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根的原因
- en: Functional injection techniques
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能注入技术
- en: Modular injection techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化注入技术
- en: Object-oriented injection techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象注入技术
- en: In the previous chapter, you wrote your first unit test using Jest, and we looked
    more at the maintainability of the test itself. The scenario was pretty simple,
    and more importantly, it was completely self-contained. The Password Verifier
    had no reliance on outside modules, and we could focus on its functionality without
    worrying about other things that might interfere with it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用 Jest 编写了你的第一个单元测试，我们更多地关注了测试本身的可维护性。场景相当简单，更重要的是，它是完全自包含的。密码验证器没有依赖外部模块，我们可以专注于其功能，而不用担心其他可能干扰它的事情。
- en: 'In that chapter, we used the first two types of exit points for our examples:
    return value exit points and state-based exit points. In this chapter, we’ll talk
    about the final type—*calling a third party*. This chapter will also present a
    new requirement—having your code rely on time. We’ll look at two different approaches
    to handling it—refactoring our code and monkey-patching it without refactoring.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一章中，我们使用了我们示例的前两种退出点类型：返回值退出点和基于状态的退出点。在这一章中，我们将讨论最后一种类型—*调用第三方*。本章还将提出一个新的要求—让代码依赖于时间。我们将探讨两种不同的处理方法—重构我们的代码和不重构的猴子补丁。
- en: The reliance on outside modules or functions can and will make it harder to
    write a test and to make the test repeatable, and it can also cause tests to be
    flaky. We call the external things that we rely on in our code *dependencies*.
    I’ll define them more thoroughly later in the chapter. These dependencies could
    include things like time, async execution, using the filesystem, or using the
    network, or they could simply involve using something that is very difficult to
    configure or that may be time consuming to execute.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对外部模块或函数的依赖可能会并且确实会使编写测试和使测试可重复变得更加困难，并且也可能导致测试变得不可靠。我们在代码中依赖的外部事物被称为*依赖*。我将在本章后面更详细地定义它们。这些依赖可能包括时间、异步执行、使用文件系统或使用网络，或者它们可能只是涉及使用非常难以配置或可能耗时的东西。
- en: 3.1 Types of dependencies
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 依赖类型
- en: 'In my experience, there are two main types of dependencies that our unit of
    work can use:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我们的工作单元可以使用两种主要类型的依赖：
- en: '*Outgoing dependencies*—Dependencies that represent an *exit point* of our
    unit of work, such as calling a logger, saving something to a database, sending
    an email, notifying an API or a webhook that something has happened, etc. Notice
    these are all *verbs*: “calling,” “sending,” and “notifying.” They are flowing
    *outward* from the unit of work in a sort of fire-and-forget scenario. Each represents
    an exit point, or the end of a specific logical flow in a unit of work.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传出依赖*—代表我们工作单元的*退出点*的依赖，例如调用记录器、将某些内容保存到数据库、发送电子邮件、通知API或webhook发生了某些事情等。请注意，这些都是*动词*：“调用”、“发送”和“通知”。它们以一种类似“发射并忘记”的场景从工作单元向外流动。每个都代表一个退出点，或工作单元中特定逻辑流的结束。'
- en: '*Incoming dependencies*—Dependencies that are not exit points. These do not
    represent a requirement on the eventual behavior of the unit of work. They are
    merely there to provide test-specific specialized data or behavior to the unit
    of work, such as a database query’s result, the contents of a file on the filesystem,
    a network response, etc. Notice that these are all passive pieces of data that
    flow *inward* to the unit of work as the result of a previous operation.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传入依赖*—不是退出点的依赖。这些并不代表对工作单元最终行为的要求。它们仅仅是为了向工作单元提供特定的测试专用数据或行为，例如数据库查询的结果、文件系统中的文件内容、网络响应等。请注意，这些都是所有被动数据块，作为先前操作的结果流向工作单元的。'
- en: Figure 3.1 shows these side by side.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1显示了这些内容并排展示。
- en: '![03-01](../Images/03-01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![03-01](../Images/03-01.png)'
- en: Figure 3.1 On the left, an exit point is implemented as invoking a dependency.
    On the right, the dependency provides indirect input or behavior and is not an
    exit point.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 左边，退出点是通过调用依赖来实现的。右边，依赖提供间接输入或行为，但不是退出点。
- en: Some dependencies can be both incoming and outgoing—in some tests they will
    represent exit points, and in other tests they will be used to simulate data coming
    into the application. These shouldn’t be very common, but they do exist, such
    as an external API that returns a success/fail response for an outgoing message.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些依赖项可以是输入和输出的——在某些测试中，它们将代表退出点，在其他测试中，它们将被用来模拟应用程序进入的数据。这些不应该非常常见，但它们确实存在，例如，一个外部API返回一个成功/失败响应，用于输出消息。
- en: With these types of dependencies in mind, let’s look at how the book *xUnit
    Test Patterns* defines the various patterns for things that look like other things
    in tests. Table 3.1 lists my thoughts about some patterns from the book’s website
    at [http:// mng.bz/n1WK](http://mng.bz/n1WK).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些类型的依赖，让我们看看书籍《xUnit测试模式》是如何定义测试中看似其他事物的各种模式的。表3.1列出了我从书籍网站[http:// mng.bz/n1WK](http://mng.bz/n1WK)上的一些模式的想法。
- en: Table 3.1 Clarifying terminology around stubs and mocks
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 清晰化存根和模拟的术语
- en: '| Category | Pattern | Purpose | Uses |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 模式 | 目的 | 使用 |'
- en: '|  | Test double | Generic name for stubs and mocks | I also use the term *fake*.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  | 测试替身 | 存根和模拟的通用名称 | 我也使用术语*假*。 |'
- en: '| Stub | Dummy object | Used to specify the values to be used in tests when
    the only usage is as irrelevant arguments of SUT method calls | Send as a parameter
    to the entry point or as the arrange part of the AAA pattern. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 存根 | 假对象 | 当SUT方法调用仅作为无关参数使用时，用于指定测试中要使用的值 | 作为入口点或AAA模式的安排部分发送参数。 |'
- en: '|  | Test stub | Used to verify logic independently when it depends on indirect
    inputs from other software components | Inject as a dependency, and configure
    it to return specific values or behavior into the SUT. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  | 测试存根 | 当它依赖于其他软件组件的间接输入时，用于独立验证逻辑 | 作为依赖项注入，并配置它向SUT返回特定的值或行为。 |'
- en: '| Mock | Test spy | Used to verify logic independently when it has indirect
    outputs to other software components | Override a single function on a real object,
    and verify that the fake function was called as expected. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 模拟 | 测试间谍 | 当它对其他软件组件有间接输出时，用于独立验证逻辑 | 覆盖真实对象上的单个函数，并验证假函数是否按预期被调用。 |'
- en: '|  | Mock object | Used to verify logic independently when it depends on indirect
    outputs to other software components | Inject the fake as a dependency into the
    SUT, and verify that the fake was called as expected. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  | 模拟对象 | 当它依赖于其他软件组件的间接输出时，用于独立验证逻辑 | 将假对象作为依赖项注入到SUT中，并验证假对象是否按预期被调用。 |'
- en: 'Here’s another way to think about this for the rest of this book:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的这本书中，我们还可以这样思考：
- en: '*Stubs* break incoming dependencies (indirect inputs). Stubs are fake modules,
    objects, or functions that provide fake behavior or data *into* the code under
    test. We do not assert against them. We can have many stubs in a single test.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存根*中断了输入依赖（间接输入）。存根是假的模块、对象或函数，它们向被测试的代码提供假行为或数据。我们不对它们进行断言。在单个测试中可以有多个存根。'
- en: '*Mocks* break outgoing dependencies (indirect outputs or exit points). Mocks
    are fake modules, objects, or functions that we assert were called in our tests.
    A mock represents an *exit point* in a unit test. Because of this, it is recommended
    that you have no more than a single mock per test.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟*中断了输出依赖（间接输出或退出点）。模拟是假的模块、对象或函数，我们在测试中声称它们被调用。模拟代表单元测试中的一个*退出点*。因此，建议每个测试中不要超过一个模拟。'
- en: Unfortunately, in many shops you’ll hear the word “mock” thrown around as a
    catch-all term for both stubs and mocks. Phrases like “we’ll mock this out” or
    “we have a mock database” can really create confusion. There is a huge difference
    between stubs and mocks (one should really only be used once in a test), and we
    should use the right terms to ensure it’s clear what the other person is referring
    to.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在许多商店，你会听到“模拟”这个词被用作存根和模拟的通用术语。像“我们将模拟这个”或“我们有一个模拟数据库”这样的短语可能会造成真正的混淆。存根和模拟之间有很大的区别（在测试中应该只使用一次），我们应该使用正确的术语来确保其他人清楚所指的内容。
- en: When in doubt, use the term “test double” or “fake.” Often, a single fake dependency
    can be used as a stub in one test, and it can be used as a mock in another test.
    We’ll see an example of this later on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当不确定时，使用“测试替身”或“假”这个术语。通常，单个假依赖可以在一个测试中用作存根，在另一个测试中用作模拟。我们稍后会看到这个例子。
- en: XUnit test patterns and naming things
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: XUnit测试模式和命名事物
- en: '*xUnit Test Patterns: Refactoring Test Code* by Gerard Meszaros (Addison-Wesley,
    2007) is a classic pattern reference book for unit testing. It defines patterns
    for things you fake in your tests in at least five ways. Once you’ve gotten a
    feel for the three types I mention here, I encourage you to take a look at the
    extra details that book provides.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*xUnit Test Patterns: Refactoring Test Code*（Gerard Meszaros 著，Addison-Wesley，2007）是单元测试的经典模式参考书。它定义了至少五种你在测试中模拟事物的模式。一旦你对这里提到的三种类型有了感觉，我鼓励你看看这本书提供的额外细节。'
- en: 'Note that *xUnit Test Patterns* has a definition for the word “fake”: “Replace
    a component that the system under test (SUT) depends on with a much lighter-weight
    implementation.” For example, you might use an in-memory database instead of a
    full-fledged production instance.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到*xUnit Test Patterns*对“假”这个词有一个定义：“用一个更轻量级的实现替换系统测试（SUT）所依赖的组件。”例如，你可能会使用内存数据库而不是完整的生产实例。
- en: I still consider this type of test double a “stub,” and I use the word “fake”
    to call out anything that isn’t real, much like the term “test double,” but “fake”
    is shorter and easier on the tongue.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然认为这种测试双倍是一个“存根”，我使用“假”这个词来指出任何不真实的东西，就像“测试双倍”这个术语一样，但“假”这个词更短，发音也更顺口。
- en: This might seem like a whole lot of information at once. I’ll dive deep into
    these definitions throughout this chapter. Let’s take a small bite and start with
    *stubs*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一次信息量很大的信息。我将在本章中深入探讨这些定义。让我们先小口品尝，从*存根*开始。
- en: 3.2 Reasons to use stubs
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 使用存根的原因
- en: What if we’re faced with the task of testing a piece of code like the following?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们面临测试如下代码片段的任务怎么办？
- en: Listing 3.1 `verifyPassword` using time
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 使用时间的`verifyPassword`
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our password verifier has a new dependency: it can’t work on weekends. Go figure.
    Specifically, the module has a direct dependency on moment.js, which is a very
    common date/time wrapper for JavaScript. Working with dates directly in JavaScript
    is not a pleasant experience, so we can assume many shops out there have something
    like this.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的密码验证器有一个新的依赖项：它不能在周末工作。想想看。具体来说，该模块直接依赖于moment.js，这是一个非常常见的JavaScript日期/时间包装器。在JavaScript中直接处理日期并不愉快，所以我们可以假设许多商店都有类似的东西。
- en: How does this direct use of a time-related library affect our unit tests? The
    unfortunate issue here is that this direct dependency forces our tests, given
    no direct way to affect date and time inside our application under test, to take
    into account the correct date and time. The following listing shows an unfortunate
    test that only runs on weekends.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种直接使用时间相关库的做法如何影响我们的单元测试？这里不幸的问题是，这种直接依赖迫使我们的测试，由于没有直接影响我们正在测试的应用程序中的日期和时间的方法，必须考虑正确的日期和时间。以下列表显示了一个不幸的测试，它只在周末运行。
- en: Listing 3.2 Initial unit tests for `verifyPassword`
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 `verifyPassword`的初始单元测试
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Checking the date inside the test
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在测试中检查日期
- en: ❷ Checking the date outside the test
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在测试外部检查日期
- en: The preceding listing includes two variations on the same test. One checks for
    the current date *inside* the test, and the other has the check *outside* the
    test, which means the test never even executes unless it’s the weekend. This is
    bad.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表包括了同一测试的两个变体。一个检查测试中的当前日期*内部*，另一个检查*外部*的测试，这意味着除非是周末，否则测试根本不会执行。这是不好的。
- en: 'Let’s revisit one of the good test qualities mentioned in chapter 1, consistency:
    Every time I run a test, it is the *same exact test* that I ran before. The values
    being used do not change. The asserts do not change. If no code has changed (in
    test or production code), then the test should provide the exact same result as
    previous runs.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下第1章中提到的一个好的测试质量，一致性：每次我运行一个测试，它都是我之前运行过的*完全相同的测试*。使用的值不会改变。断言不会改变。如果没有代码（测试或生产代码）发生变化，那么测试应该提供与之前运行完全相同的结果。
- en: The second test sometimes doesn’t even run. That’s a good enough reason to use
    a fake to break the dependency right there. Furthermore, we can’t simulate a weekend
    or a weekday, which gives us more than enough incentive to redesign the code under
    test so it’s a bit more injectable for dependencies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试有时甚至不会运行。这已经是一个足够好的理由来使用假来直接打破依赖。此外，我们无法模拟周末或工作日，这给了我们足够的动力来重新设计测试代码，使其对依赖项更具可注入性。
- en: But wait, there’s more. Tests that use time can often be flaky. They only fail
    sometimes, without anything but the time changing. This test is a prime candidate
    for this behavior, because we’ll only get feedback on *one* of its two states
    when we run it locally. If you want to know how it behaves on a weekend, just
    wait a couple of days. Ugh.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，还有更多。使用时间的测试往往可能不稳定。它们只在某些时候失败，除了时间变化之外没有其他原因。这个测试是这种行为的典型候选者，因为我们本地运行时只会得到其两种状态之一的反馈。如果你想了解它在周末的表现，只需等待几天。呃。
- en: Tests might become flaky due to edge cases that affect variables that are not
    under our control in the test. Common examples are network issues during end-to-end
    testing, database connectivity issues, or various server issues. When this happens,
    it’s easy to dismiss the test failure by saying “just run it again” or “It’s OK.
    It’s just [insert variability issue here].”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可能会因为影响测试中不受我们控制的变量的边缘情况而变得不稳定。常见的例子是在端到端测试期间的网络问题、数据库连接问题或各种服务器问题。当这种情况发生时，很容易通过说“再运行一次”或“没关系。只是[插入可变性问题在这里]”来忽略测试失败。
- en: 3.3 Generally accepted design approaches to stubbing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 通常接受的设计方法来模拟
- en: 'In the next few sections, we’ll discuss several common forms of injecting stubs
    into our units of work. First, we’ll discuss basic parameterization as a first
    step, then we’ll jump into the following approaches:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论几种常见的将存根注入到我们的工作单元中的形式。首先，我们将讨论基本参数化作为第一步，然后我们将跳入以下方法：
- en: '*Functional approaches*'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数式方法*'
- en: Function as parameter
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为参数
- en: Partial application (currying)
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用（柯里化）
- en: Factory functions
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂函数
- en: Constructor functions
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: '*Modular approach*'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块化方法*'
- en: Module injection
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块注入
- en: '*Object-oriented approaches*'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象方法*'
- en: Class constructor injection
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类构造函数注入
- en: Object as parameter (aka duck typing)
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象作为参数（即鸭子类型）
- en: Common interface as parameter (for this we’ll use TypeScript)
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共接口作为参数（为此我们将使用TypeScript）
- en: We’ll tackle each of these by starting with the simple case of controlling time
    in our tests.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一解决这些问题，从测试中控制时间的简单情况开始。
- en: 3.3.1 Stubbing out time with parameter injection
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 使用参数注入模拟时间
- en: 'I can think of at least two good reasons to control time based on what we’ve
    covered so far:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两个很好的理由来控制时间，基于我们到目前为止所讨论的内容：
- en: To remove the variability from our tests
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了从我们的测试中消除可变性
- en: To easily simulate any time-related scenario we’d like to test our code with
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了轻松模拟我们想要测试代码的任何时间相关场景
- en: Here’s the simplest refactoring I can think of that makes things a bit more
    repeatable. Let’s add a `currentDay` parameter to our function to specify the
    current date. This will remove the need to use the moment.js module in our function,
    and it will put that responsibility on the caller of the function. That way, in
    our tests, we can determine the time in a hardcoded manner and make the test and
    the function repeatable and consistent. The following listing shows an example
    of such a refactoring.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我能想到的最简单的重构，可以使事情更加可重复。让我们给我们的函数添加一个`currentDay`参数来指定当前日期。这将消除在函数中使用moment.js模块的需要，并将这个责任放在函数的调用者身上。这样，在我们的测试中，我们可以以硬编码的方式确定时间，并使测试和函数可重复且一致。以下列表显示了这种重构的一个示例。
- en: Listing 3.3 `verifyPassword` with a `currentDay` parameter
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 `verifyPassword`带有`currentDay`参数
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By adding the `currentDay` parameter, we’re essentially giving control over
    time to the caller of the function (our test). What we’re injecting is formally
    called a “dummy”—it’s just a piece of data with no behavior—but we can call it
    a “stub” from now on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`currentDay`参数，我们实际上是将对时间控制权交给了函数的调用者（我们的测试）。我们注入的正式称为“哑元”——它只是一块没有行为的数据——但从现在起我们可以称它为“存根”。
- en: This is approach is a form of *Dependency Inversion*. It seems the term “Inversion
    of Control” first came up in Johnson and Foote’s paper “Designing Reusable Classes,”
    published by the *Journal of Object-Oriented Programming* in 1988\. The term “Dependency
    Inversion” is also one of the SOLID patterns described by Robert C. Martin in
    2000, in his “Design Principles and Design Patterns” paper. I’ll talk more about
    higher-level design considerations in chapter 8\.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是一种*依赖倒置*的形式。似乎“控制反转”这个术语最早出现在Johnson和Foote在1988年发表的论文“Designing Reusable
    Classes”中，该论文发表在《面向对象编程杂志》上。术语“依赖倒置”也是Robert C. Martin在2000年在其“Design Principles
    and Design Patterns”论文中描述的SOLID模式之一。我将在第8章中更多地讨论高级设计考虑因素。
- en: 'Adding this parameter is a simple refactoring, but it’s quite effective. It
    provides a couple of nice benefits other than consistency in the test:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个参数是一个简单的重构，但效果相当显著。它除了在测试中提供一致性之外，还有一些其他的好处：
- en: We can now easily simulate any day we want.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以轻松地模拟任何我们想要的日期。
- en: The code under test is not responsible for managing time imports, so it has
    one less reason to change if we ever use a different time library.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被测试的代码不负责管理时间导入，因此如果我们使用不同的时间库，它就少了一个改变的理由。
- en: We’re doing “dependency injection” of time into our unit of work. We’ve changed
    the design of the entry point to use a day value as a parameter. The function
    is now “pure” by functional programming standards in that it has no side effects.
    Pure functions have built-in injections of all of their dependencies, which is
    one of the reasons you’ll find functional programming designs are typically much
    easier to test.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将“时间依赖注入”到我们的工作单元中。我们已经更改了入口点的设计，使用一个日期值作为参数。根据函数式编程的标准，这个函数现在是“纯”的，因为它没有副作用。纯函数内置了所有依赖的注入，这也是为什么你会发现函数式编程的设计通常更容易测试的原因。
- en: '![03-02](../Images/03-02.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![03-02](../Images/03-02.png)'
- en: Figure 3.2 Injecting a stub for a time dependency
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2注入时间依赖的存根
- en: It might feel weird to call the `currentDay` parameter a stub if it’s just a
    day integer value, but based on the definitions from *xUnit Test Patterns*, we
    can say that this is a “dummy” value, and as far as I’m concerned, it falls into
    the “stub” category. It does not have to be complex in order to be a stub. It
    just has to be under our control. It’s a stub because we are using it to simulate
    some input or behavior being passed *into* the unit under test. Figure 3.2 shows
    this visually.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`currentDay`参数只是一个日期整数值，那么称它为存根可能感觉有点奇怪，但根据*xUnit Test Patterns*的定义，我们可以说这是一个“虚拟”值，在我看来，它属于“存根”类别。它不需要复杂，才能成为存根。它只需要在我们控制之下。它是一个存根，因为我们正在使用它来模拟一些输入或行为被传递到被测试的单元中。图3.2展示了这一点。
- en: 3.3.2 Dependencies, injections, and control
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 依赖、注入和控制
- en: Table 3.2 recaps some important terms we’ve discussed and are about to use throughout
    the rest of the chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2总结了一些我们在本章中讨论并即将使用的术语。
- en: Table 3.2 Terminology used in this chapter
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2本章中使用的术语
- en: '| Dependencies | The things that make our testing lives and code maintainability
    difficult, since we cannot *control* them from our tests. Examples include time,
    the filesystem, the network, random values, and more. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 依赖 | 使我们的测试生活和代码可维护性变得困难的事物，因为我们无法从测试中控制它们。例如包括时间、文件系统、网络、随机值等等。|'
- en: '| Control | The ability to instruct a dependency how to behave. Whoever is
    *creating* the dependencies is said to be in control of them, since they have
    the ability to configure them before they are used in the code under test.In listing
    3.1, our test does *not* have control over *time* because the module under test
    has control over it. The module has chosen to always use the *current* date and
    time. This forces the test to do the exact same thing, and thus we lose consistency
    in our tests.In listing 3.3, we have gained access to the dependency by *inverting
    the control* over it via the `currentDay` parameter. Now the test has control
    over the time and can decide to use a hardcoded time. The module under test has
    to use the time provided, which makes things much easier for our test. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 指示依赖如何行为的能力。据说创建依赖项的人是它们的控制者，因为他们有在代码被测试之前配置它们的能力。在列表3.1中，我们的测试对时间没有控制权，因为被测试的模块控制着它。该模块选择始终使用当前的日期和时间。这迫使测试做完全相同的事情，因此我们在测试中失去了一致性。在列表3.3中，我们通过`currentDay`参数通过反转控制获得了对依赖的访问。现在测试控制着时间，可以决定使用硬编码的时间。被测试的模块必须使用提供的时间，这使得测试变得容易得多。|'
- en: '| Inversion of control | Designing the code to remove the responsibility of
    creating the dependency internally, and externalizing it instead. Listing 3.3
    shows one way of doing this with *parameter* *injection*. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 控制反转 | 设计代码以移除内部创建依赖项的责任，并将其外部化。列表3.3展示了通过参数注入实现这一点的示例。|'
- en: '| Dependency injection | The act of sending a dependency through the design
    interface to be used internally by a piece of code. The place where you inject
    the dependency is the injection point. In our case, we are using a parameter injection
    point. Another word for this place where we can inject things is *a* *seam*. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 依赖注入 | 将依赖项通过设计接口发送，以便代码内部使用。注入依赖项的地方是注入点。在我们这个例子中，我们使用参数注入点。我们可以注入东西的地方也可以称为*一个*
    *缝隙*。|'
- en: '| Seam | Pronounced “s-ee-m,” and coined by Michael Feathers in his book *Working
    Effectively with Legacy Code* (Pearson, 2004).Seams are where two pieces of software
    meet and something else can be injected. They are a place where you can alter
    behavior in your program without editing in that place. Examples include parameters,
    functions, module loaders, function rewriting, and, in the object-oriented world,
    class interfaces, public virtual methods, and more. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 缝隙 | 发音为“s-ee-m”，由迈克尔·费思在《有效地与遗留代码工作》（Pearson，2004年）一书中提出。缝隙是两个软件组件相遇并可以注入其他东西的地方。这是你可以改变程序行为而不在该处编辑的地方。例子包括参数、函数、模块加载器、函数重写，以及在面向对象的世界中，类接口、公共虚拟方法等。|'
- en: Seams in production code play an important role in the maintainability and readability
    of unit tests. The easier it is to change and inject behavior or custom data into
    the code under test, the easier it will be to write, read, and later on maintain
    the test as the production code changes. I’ll talk more about some patterns and
    antipatterns related to designing code in chapter 8.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码中的缝隙对于单元测试的可维护性和可读性起着重要作用。改变和注入行为或自定义数据到被测试代码中的难度越小，编写、阅读以及随着生产代码的变化而维护测试的难度就越小。我将在第8章中更多地讨论一些与设计代码相关的模式和反模式。
- en: 3.4 Functional injection techniques
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 函数注入技术
- en: At this point, we might not be happy with our design choice. Adding a parameter
    did solve the dependency issue at the function level, but now every caller will
    need to know how to handle dates in some way. It feels a bit too chatty.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能对我们的设计选择不满意。添加参数确实在函数级别解决了依赖问题，但现在每个调用者都需要以某种方式处理日期。这感觉有点太啰嗦了。
- en: JavaScript enables two major styles of programming—functional and object-oriented—so
    I’ll show approaches in both styles when it makes sense, and you can pick and
    choose what works best in your situation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许两种主要的编程风格——函数式和面向对象——因此，当有道理时，我会展示两种风格的方法，你可以根据你的情况选择最合适的方法。
- en: There isn’t a single way to design something. Functional programming proponents
    will argue for the simplicity, clarity, and provability of the functional style,
    but it does come with a learning curve. For that reason alone, it is wise to learn
    both approaches so that you can apply whichever works best for the team you’re
    working with. Some teams will lean more toward object-oriented designs because
    they feel more comfortable with that. Others will lean towards functional designs.
    I’d argue that the patterns remain largely the same; we just translate them to
    different styles.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 设计某物并没有唯一的方法。函数式编程的支持者会为函数式风格的简单性、清晰性和可证明性辩护，但这确实有一个学习曲线。因此，仅仅为了这个原因，学习两种方法都是明智的，这样你就可以应用最适合你所在团队的任何一种方法。有些团队可能会更倾向于面向对象的设计，因为他们觉得更舒服。其他团队可能会倾向于函数式设计。我认为模式在很大程度上是相同的；我们只是将它们翻译成不同的风格。
- en: 3.4.1 Injecting a function
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 注入函数
- en: 'The following listing shows a different refactoring for the same problem: instead
    of a data object, we’re expecting a function as the parameter. That function returns
    the date object.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了针对同一问题的不同重构方法：我们期望的是一个函数作为参数，而不是数据对象。该函数返回日期对象。
- en: Listing 3.4 Dependency injection with a function
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 使用函数进行依赖注入
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The associated test is shown in the following listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的测试在下面的列表中展示。
- en: Listing 3.5 Testing with function injection
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 使用函数注入进行测试
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There’s very little difference from the previous test, but using a function
    as a parameter is a valid way to do injection. In other scenarios, it’s also a
    great way to enable special behavior, such as simulating special cases or exceptions
    in your code under test.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的测试几乎没有区别，但使用函数作为参数是进行注入的有效方式。在其他情况下，它也是一个启用特殊行为的好方法，比如模拟代码中被测试的特殊情况或异常。
- en: 3.4.2 Dependency injection via partial application
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 通过部分应用进行依赖注入
- en: Factory functions or methods (a subcategory of “higher-order functions”) are
    functions that return other functions, preconfigured with some context. In our
    case, the context can be the list of rules and the current day function. We then
    get back a new function that we can trigger with only a string input, and it will
    use the rules and `getDay()` function configured in its creation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数或方法（“高阶函数”的一个子类别）是返回其他函数的函数，这些函数预先配置了一些上下文。在我们的情况下，上下文可以是规则列表和当前日期函数。然后我们得到一个新的函数，我们可以通过仅输入字符串来触发它，它将使用在其创建时配置的规则和`getDay()`函数。
- en: The code in the following listing essentially turns the factory function into
    the arrange part of the test, and calls the returned function into the act part.
    Quite lovely.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码列表将工厂函数转换为测试的arrange部分，并调用返回的函数到act部分。相当漂亮。
- en: Listing 3.6 Using a higher-order factory function
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 使用高阶工厂函数
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 3.5 Modular injection techniques
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 模块化注入技术
- en: JavaScript also allows for the idea of *modules*, which we `import` or `require`.
    How can we handle the idea of dependency injection when faced with a direct import
    of a dependency in our code under test, such as in the code from listing 3.1,
    shown again here?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还允许我们使用*模块*的概念，我们可以`import`或`require`。面对测试代码中的直接依赖导入时，例如在3.1列表中的代码，我们如何处理依赖注入的概念？
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How can we overcome this direct dependency that’s happening? The answer is,
    we can’t. We’ll have to write the code differently to allow for the replacement
    of that dependency later on. We’ll have to create a *seam* through which we can
    replace our dependencies. Here’s one such example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何克服这种直接依赖？答案是，我们无法克服。我们必须以不同的方式编写代码，以便稍后替换该依赖。我们必须创建一个*接口*，通过该接口我们可以替换我们的依赖。这里有一个这样的例子。
- en: Listing 3.7 Abstracting the required dependencies
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 抽象所需的依赖
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Wrapping moment.js with an intermediary object
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用中间对象包装moment.js
- en: ❷ The object containing the current dependency, either real or fake
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含当前依赖的对象，无论是真实还是假
- en: ❸ A function that replaces the real dependency with a fake one
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个用假依赖替换真实依赖的函数
- en: ❹ A function that resets the dependency back to the real one
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一个将依赖重置回真实值的函数
- en: 'What’s going on here? Three new things have been introduced:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？引入了三个新事物：
- en: 'First, we have replaced our direct dependency on moment.js with an object:
    `originalDependencies`. It contains that module import as part of its implementation.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将对moment.js的直接依赖替换为一个对象：`originalDependencies`。它包含该模块导入作为其实现的一部分。
- en: 'Next, we have added yet another object into the mix: `dependencies`. This object,
    by default, takes on all of the real dependencies that the `originalDependencies`
    object contains.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们向其中添加了另一个对象：`dependencies`。默认情况下，该对象承担了`originalDependencies`对象包含的所有真实依赖。
- en: Finally, the `inject` function, which we’re also exposing as part of our own
    module, allows whoever is importing our module (both production code and tests)
    to override our real dependencies with custom dependencies (fakes).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`inject`函数，我们也将它作为我们自己的模块的一部分暴露出来，允许导入我们的模块的人（无论是生产代码还是测试）用自定义依赖（假）覆盖我们的真实依赖。
- en: When you invoke `inject`, it returns a `reset` function that reapplies the original
    dependencies onto the current `dependencies` variable, thus resetting any fakes
    currently being used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`inject`时，它返回一个`reset`函数，该函数将原始依赖重新应用于当前的`dependencies`变量，从而重置当前正在使用的任何假依赖。
- en: Here’s how you can use the `inject` and `reset` functions in a test.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何在测试中使用`inject`和`reset`函数。
- en: Listing 3.8 Injecting a fake module with `inject()`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 使用`inject()`注入假模块
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ A helper function
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个辅助函数
- en: ❷ Injecting a fake API instead of moment.js
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用假的API代替moment.js
- en: ❸ Providing a fake day
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提供一个假的日期
- en: ❹ Resetting the dependency
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 重置依赖
- en: 'Let’s break down what’s going on here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这里正在发生的事情：
- en: The `injectDate` function is just a helper function meant to reduce the boilerplate
    code in our test. It always builds the fake structure of the moment.js API, and
    it sets its `getDay` function to return the `newDay` parameter.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`injectDate`函数只是一个辅助函数，旨在减少我们测试中的样板代码。它始终构建moment.js API的假结构，并将其`getDay`函数设置为返回`newDay`参数。'
- en: The `injectDate` function calls `inject` with the new fake moment.js API. This
    applies the fake dependency in our unit of work to the one we have sent in as
    a parameter.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`injectDate`函数调用`inject`，并使用新的假moment.js API。这将在我们的工作单元中将假依赖应用于我们作为参数传入的一个。'
- en: Our test calls the `inject` function with a custom, fake day.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的测试调用`inject`函数并传入一个自定义的、伪造的日期。
- en: At the end of the test, we call the `reset` function, which resets the unit
    of work’s module dependencies to the original ones.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试结束时，我们调用`reset`函数，该函数将工作单元的模块依赖项重置为原始状态。
- en: Once you’ve done this a couple of times, it starts making sense. But it has
    some caveats as well. On the pro side, it definitely takes care of the dependency
    issue in our tests, and it’s relatively easy to use. As for the cons, there is
    one huge downside as far as I can see. Using this method to fake our modular dependencies
    forces our tests to be closely tied to the API signature of the dependencies we
    are faking. If these are third-party dependencies, such as moment.js, loggers,
    or anything else that we do not fully control, our tests will become very brittle
    when the time comes (as it always does) to upgrade or replace the dependencies
    with something that has a different API. This doesn’t hurt much if it’s just a
    test or two, but we’ll usually have hundreds or thousands of tests that have to
    fake several common dependencies, and that sometimes means changing and fixing
    hundreds of files when replacing a logger with a breaking API change, for example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 做了几次之后，这开始变得有意义。但也有一些注意事项。在正面方面，它确实解决了我们测试中的依赖问题，并且相对容易使用。至于缺点，在我看来有一个巨大的缺点。使用这种方法伪造我们的模块依赖项迫使我们的测试紧密依赖于我们伪造的依赖项的API签名。如果这些是第三方依赖项，例如moment.js、日志记录器或其他我们无法完全控制的任何东西，当需要（总是需要）升级或替换具有不同API的依赖项时，我们的测试将变得非常脆弱。如果只是几个测试，这并不会造成太大的伤害，但通常我们会有数百或数千个测试需要伪造几个常见的依赖项，有时这意味着在用具有破坏性API更改的记录器替换时，需要更改和修复数百个文件。
- en: 'I have two possible ways to prevent such a situation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我有两种可能的方法来防止这种情况：
- en: Never import a third-party dependency that you don’t control directly in your
    code. Always use an interim abstraction that you do control. The Ports and Adapters
    architecture is a good example of such an idea (other names for this architecture
    are Hexagonal architecture and Onion architecture). With such an architecture,
    faking these internal APIs should present less risk, because we can control their
    rate of change, thus making our tests less brittle. (We can refactor them internally
    without our tests caring, even if the outside world changes.)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在你的代码中导入你无法直接控制的第三方依赖。始终使用你能够控制的中间抽象。端口和适配器架构是这种想法的一个很好的例子（这种架构的其他名称包括六边形架构和洋葱架构）。在这种架构下，伪造这些内部API应该风险更小，因为我们能够控制它们的变更速度，从而使我们的测试更加稳健。（即使外部世界发生变化，我们也可以在不影响测试的情况下对它们进行内部重构。）
- en: 'Avoid using module injection, and instead use one of the other ways mentioned
    in this book for dependency injection: function parameters, currying, and, as
    mentioned in the next section, constructors and interfaces. Between these, you
    should have plenty of choices instead of importing things directly.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用模块注入，而是使用本书中提到的其他依赖注入方法之一：函数参数、柯里化和，如下一节所述，构造函数和接口。在这些方法之间，你应该有足够的选择，而不是直接导入。
- en: 3.6 Moving toward objects with constructor functions
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 向构造函数对象迈进
- en: Constructor functions are a slightly more object-oriented JavaScript-ish way
    of achieving the same result as a factory function, but they return something
    akin to an object with methods we can trigger. We then use the keyword `new` to
    call this function and get back that special object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一种稍微更面向对象的JavaScript风格，可以达到与工厂函数相同的结果，但它们返回类似于具有我们可以触发的方法的对象。然后我们使用关键字`new`来调用这个函数，并获取那个特殊对象。
- en: Here’s what the same code and tests look like with this design choice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是采用这种设计选择后的相同代码和测试的样子。
- en: Listing 3.9 Using a constructor function
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 使用构造函数
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might look at this and ask, “Why move toward objects?” The answer really
    depends on the context of your current project, its stack, your team’s knowledge
    of functional programming and object-oriented background, and many other non-technical
    factors. It’s good to have this tool in your toolbox so you can use it when it
    makes sense to you. Keep this in the back of your mind as you read the next few
    sections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看看这个并问，“为什么要转向对象？”答案实际上取决于你当前项目的上下文、其堆栈、你团队对函数编程和面向对象背景的了解，以及许多其他非技术因素。在工具箱中拥有这个工具是好事，这样你就可以在你认为合适的时候使用它。在阅读下一节之前，把这个放在心里。
- en: 3.7 Object-oriented injection techniques
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 面向对象注入技术
- en: If a more object-oriented style is what you’re leaning toward, or if you’re
    working in an object-oriented language such as C# or Java, here are a few common
    patterns that are widely used in the object-oriented world for dependency injection.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你倾向于更面向对象的风格，或者如果你在 C# 或 Java 等面向对象语言中工作，这里有一些在面向对象世界中广泛使用的、用于依赖注入的常见模式。
- en: 3.7.1 Constructor injection
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.1 构造函数注入
- en: '*Constructor injection* is how I would describe a design in which we can inject
    dependencies through the constructor of a class. In the JavaScript world, Angular
    is the best-known web frontend framework that uses this design for injecting “services,”
    which is just a code word for “dependencies” in Angular-speak. This is a viable
    design in many other situations.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*构造函数注入*是我用来描述一种设计，我们可以通过类的构造函数注入依赖项。在 JavaScript 世界中，Angular 是最著名的使用这种设计注入“服务”的
    Web 前端框架，在 Angular 术语中，“服务”只是“依赖项”的代码词。这在许多其他情况下都是一个可行的设计。'
- en: Having a stateful class is not without benefits. It can remove repetition from
    clients that only need to configure our class once and can then reuse the configured
    class multiple times.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个有状态的类并非没有好处。它可以消除只需要配置我们的类一次并可以多次重用配置类的客户端的重复性。
- en: If we had chosen to create a stateful version of Password Verifier, and we wanted
    to inject the date function through constructor injection, it might look like
    the following design.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择创建一个有状态版本的密码验证器，并且我们想要通过构造函数注入来注入日期函数，它可能看起来像以下设计。
- en: Listing 3.10 Constructor injection design
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 构造函数注入设计
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This looks and feels a lot like the constructor function design in section 3.6\.
    This is a more class-oriented design that many people will feel more comfortable
    with, coming from an object-oriented background. It also is more verbose. You’ll
    see that we get more and more verbose the more object-oriented we make things.
    It’s part of the object-oriented game. This is partly why people are choosing
    functional styles more and more—they are much more concise.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来和感觉与第 3.6 节中的构造函数设计非常相似。这是一个更面向类的、许多人会感到更舒适的、来自面向对象背景的设计。它也更冗长。你会发现，我们使事物越加面向对象，我们就越加冗长。这是面向对象游戏的一部分。这也是为什么越来越多的人选择函数式风格的部分原因——它们更加简洁。
- en: Let’s talk a bit about the maintainability of the tests. If I wrote a second
    test with this class, I’d extract the creation of the class via the constructor
    to a nice little factory function that returns an instance of the class under
    test, so that if (i.e., “when”) the constructor signature changes and breaks many
    tests at once, I only have to fix a single place to get all the tests working
    again, as you can see in the following listing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈测试的可维护性。如果我用这个类写第二个测试，我会将类的创建通过构造函数提取到一个漂亮的小工厂函数中，该函数返回待测试类的实例，这样如果（即，“当”）构造函数签名更改并一次性破坏许多测试，我只需要修复一个地方就可以让所有测试再次工作，如下面的列表所示。
- en: Listing 3.11 Adding a helper factory function to our tests
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 向我们的测试中添加一个辅助工厂函数
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that this is not the same as the factory function design in section 3.4.2\.
    This factory function resides in our *tests*; the other was in our production
    code. This one is for test maintainability, and it can work with object-oriented
    and functional production code because it hides how the function or object is
    being created or configured. It’s an abstraction layer in our tests, so we can
    push the dependency on how a function or object is created or configured into
    a single place in our tests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与第 3.4.2 节中的工厂函数设计不同。这个工厂函数位于我们的*测试*中；另一个位于我们的生产代码中。这个是为了测试的可维护性，并且它可以与面向对象和函数式生产代码一起工作，因为它隐藏了函数或对象是如何被创建或配置的。它是我们测试中的一个抽象层，因此我们可以将如何创建或配置函数或对象的依赖项推到我们的测试中的单个地方。
- en: 3.7.2 Injecting an object instead of a function
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.2 注入对象而不是函数
- en: 'Right now, our class constructor takes in a function as the second parameter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的类构造函数接受一个函数作为第二个参数：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s go one step up in our object-oriented design and use an object instead
    of a function as our parameter. This requires us to do a bit of legwork: refactor
    the code.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在面向对象的设计上再迈出一大步，使用对象而不是函数作为我们的参数。这需要我们做一些工作：重构代码。
- en: 'First, we’ll create a new file called time-provider.js, which will contain
    our real object that has a dependency on moment.js. The object will be designed
    to have a single function called `getDay()`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为 time-provider.js 的新文件，其中将包含我们依赖于 moment.js 的真实对象。该对象将被设计为有一个名为
    `getDay()` 的单一函数：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we’ll change the parameter usage to use an object with a function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改参数使用，以使用具有函数的对象：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, let’s give whoever needs an instance of our `PasswordVerifier` the
    ability to get it preconfigured with the real time provider by default. We’ll
    do this with a new `passwordVerifierFactory` function that any production code
    that needs a verifier instance will need to use:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们给需要我们的 `PasswordVerifier` 实例的人提供通过默认情况下预配置真实时间提供者的能力。我们将使用一个新的 `passwordVerifierFactory`
    函数来完成这项工作，任何需要验证器实例的生产代码都需要使用这个函数：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: IoC containers and dependency injection
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: IoC 容器和依赖注入
- en: There are many other ways to glue `PasswordVerifier` and `TimeProvider` together.
    I’ve just chosen manual injection to keep things simple. Many frameworks today
    are able to configure the injection of dependencies into objects under test, so
    that we can define how an object is to be constructed. Angular is one such framework.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他方法可以将 `PasswordVerifier` 和 `TimeProvider` 连接起来。我只是选择了手动注入以保持事情简单。今天许多框架都能够配置将依赖注入到测试对象中，这样我们就可以定义对象的构建方式。Angular
    就是这样的框架之一。
- en: If you’re using libraries like Spring in Java or Autofac or StructureMap in
    C#, you can easily configure the construction of objects with constructor injection
    without needing to create specialized functions. Commonly, these features are
    called Inversion of Control (IoC) containers or Dependency Injection (DI) containers.
    I’m not using them in this book to avoid unneeded details. You don’t need them
    to create great tests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Java 中的 Spring 或 C# 中的 Autofac 或 StructureMap 这样的库，你可以轻松地配置使用构造函数注入的对象构建，而无需创建专门的函数。通常，这些功能被称为控制反转（IoC）容器或依赖注入（DI）容器。我在这本书中没有使用它们，以避免不必要的细节。你不需要它们来创建出色的测试。
- en: In fact, I don’t normally use IoC containers in tests. I’ll almost always use
    custom factory functions to inject dependencies. I find that makes my tests easier
    to read and reason about.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我通常不在测试中使用 IoC 容器。我几乎总是使用自定义工厂函数来注入依赖。我发现这样做可以使我的测试更容易阅读和推理。
- en: Even for tests covering Angular code, we don’t have to go through Angular’s
    DI framework to inject a dependency into an object in memory; we can call that
    object’s constructor directly and send in fake stuff. As long as we do that in
    a factory function, we’re not sacrificing maintainability, and we’re also not
    adding extra code to tests unless it’s essential to the tests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是测试 Angular 代码，我们也不必通过 Angular 的 DI 框架将依赖注入到内存中的对象中；我们可以直接调用该对象的构造函数并传入假数据。只要我们在工厂函数中这样做，我们就没有牺牲可维护性，也不会为测试添加额外的代码，除非这是测试所必需的。
- en: The following listing shows the entire piece of new code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了整个新代码块。
- en: Listing 3.12 Injecting an object
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 注入对象
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How can we handle this type of design in our tests, where we need to inject
    a fake object, instead of a fake function? We’ll do this manually at first, so
    you can see that it’s not a big deal. Later, we’ll let frameworks help us, but
    you’ll see that sometimes hand-coding fake objects can actually make your test
    more readable than using a framework, such as Jasmine, Jest, or Sinon (we’ll cover
    those in chapter 5).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在测试中处理这种类型的设计，当我们需要注入一个假对象而不是一个假函数时？我们最初会手动完成这个操作，这样你可以看到这并不是什么大问题。稍后，我们将让框架帮助我们，但你也会看到，有时手动编写假对象实际上可以使你的测试比使用框架（如
    Jasmine、Jest 或 Sinon）更易于阅读（我们将在第 5 章中介绍这些框架）。
- en: 'First, in our test file, we’ll create a new fake object that has the same function
    signature as our real time provider, but it will be controllable by our tests.
    In this case, we’ll just use a constructor pattern:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的测试文件中，我们将创建一个新的假对象，它具有与我们的真实时间提供者相同的函数签名，但它将由我们的测试控制。在这种情况下，我们将只使用构造函数模式：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note If you are working in a more object-oriented style, you might choose to
    create a simple class that inherits from a common interface. We’ll cover that
    a bit later in the chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你正在使用更面向对象的方式工作，你可能会选择创建一个继承自通用接口的简单类。我们将在本章稍后讨论这一点。
- en: 'Next, we’ll construct the `FakeTimeProvider` in our tests and inject it into
    the `verifier` under test:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的测试中构建 `FakeTimeProvider` 并将其注入到正在测试的 `verifier` 中：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here’s what the full test file looks like.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完整的测试文件看起来像什么。
- en: Listing 3.13 Creating a handwritten stub object
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.13 创建手写的存根对象
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code works because JavaScript, by default, is a very permissive language.
    Much like Ruby or Python, you can get away with duck typing things. *Duck typing*
    refers to the idea that if it walks like a duck and it talks like a duck, we’ll
    treat it like a duck. In this case, the real object and fake object both implement
    the same function, even though they are completely different objects. We can simply
    send one in place of the other, and the production code should be OK with this.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以能工作，是因为JavaScript默认是一个非常宽容的语言。就像Ruby或Python一样，你可以通过鸭子类型来避免很多问题。"鸭子类型"指的是如果一个东西看起来像鸭子，说话也像鸭子，我们就把它当作鸭子来对待。在这种情况下，真实对象和假对象都实现了相同的功能，尽管它们是完全不同的对象。我们可以简单地用一个代替另一个，并且生产代码应该能够接受这种替换。
- en: Of course, we’ll only know that this is OK and that we didn’t make any mistakes
    or miss anything regarding the function signatures at run time. If we want a bit
    more confidence, we can try it in a more type-safe manner.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们只有在运行时才知道这是可行的，并且我们没有在函数签名方面犯任何错误或遗漏任何内容。如果我们想更有信心，我们可以尝试以更安全的类型方式来做。
- en: 3.7.3 Extracting a common interface
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.3 提取公共接口
- en: We can take things one step further, and, if we’re using TypeScript or a strongly
    typed language such as Java or C#, start using interfaces to denote the roles
    that our dependencies play. We can create a contract of sorts that both real objects
    and fake objects will have to abide by at the compiler level.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，如果我们使用TypeScript或像Java或C#这样的强类型语言，我们可以开始使用接口来表示我们的依赖项所扮演的角色。我们可以创建一种合同，确保真实对象和假对象都必须在编译器级别遵守。
- en: 'First, we’ll define our new interface (notice that this is now TypeScript code):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义我们的新接口（注意，这现在是TypeScript代码）：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Second, we’ll define a real time provider that implements our interface in
    our production code like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将在生产代码中定义一个实现我们接口的真实时间提供者，如下所示：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Third, we’ll update the constructor of our `PasswordVerifier` to take a dependency
    of our new `TimeProviderInterface` type, instead of having a parameter type of
    `RealTimeProvider`. We’re abstracting away the role of a time provider and declaring
    that we don’t care what object is being passed, as long as it answers to this
    role’s interface:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们将更新`PasswordVerifier`的构造函数，使其接受我们新的`TimeProviderInterface`类型作为依赖项，而不是使用`RealTimeProvider`参数类型。我们正在抽象化时间提供者的角色，并声明我们不在乎传递什么对象，只要它符合这个角色的接口：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have an interface that defines what a “duck” looks like, we can
    implement a duck of our own in our tests. It’s going to look a lot like the previous
    test’s code, but it will have one strong difference: it will be compiler checked
    to ensure the correctness of the method signatures.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个定义了“鸭子”外观的接口，我们可以在测试中实现自己的鸭子。它看起来会非常像之前的测试代码，但有一个显著的区别：它将通过编译器检查来确保方法签名的正确性。
- en: 'Here’s what our fake time provider looks like in our test file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们测试文件中的假时间提供者：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here’s our test:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的测试：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The following listing shows all the code together.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了所有代码：
- en: Listing 3.14 Extracting a common interface in production code
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 在生产代码中提取公共接口
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’ve now made a full transition from a purely functional design into a strongly
    typed, object-oriented design. Which is best for your team and your project? There’s
    no single answer. I’ll talk more about design in chapter 8\. Here, I mainly wanted
    to show that whatever design you end up choosing, the pattern of injection remains
    largely the same. It is just enabled with different vocabulary or language features.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完全从纯函数式设计过渡到了强类型、面向对象的设计。这对你的团队和项目来说哪个更好？没有唯一的答案。我将在第8章中更多地讨论设计。在这里，我主要想展示的是，无论你最终选择哪种设计，注入模式在很大程度上都是相同的。它只是通过不同的词汇或语言特性来实现。
- en: It’s the ability to inject that enables us to simulate things that would be
    practically impossible to test in real life. That’s where the idea of stubs shines
    the most. We can tell our stubs to return fake values or even to simulate exceptions
    in our code, to see how it handles errors arising from dependencies. Injection
    makes this possible. Injection has also made our tests more repeatable, consistent,
    and trustworthy, and I’ll talk about trustworthiness in the third part of this
    book. In the next chapter, we’ll look at mock objects and see how they differ
    from stubs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 是注入的能力使我们能够模拟在现实生活中实际上无法测试的事情。这正是 stubs 理念大放异彩的地方。我们可以告诉我们的 stubs 返回假值，甚至在我们的代码中模拟异常，以查看它如何处理由依赖项引起的错误。注入使得这一切成为可能。注入也使我们的测试更加可重复、一致和可靠，我将在本书的第三部分讨论可靠性。在下一章中，我们将探讨模拟对象，并了解它们与
    stubs 的区别。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '*Test double* is an overarching term that describes all kinds of non-production-ready,
    fake dependencies in tests. There are five variations on test doubles that can
    be grouped into just two types: *mocks* and *stubs*.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试替身*是一个总称，描述了测试中所有非生产就绪的、假的依赖项。测试替身有五种变体，可以归纳为两种类型：*模拟*和*stubs*。'
- en: '*Mocks* help emulate and examine *outgoing dependencies*: dependencies that
    represent an exit point of our unit of work. The system under test (SUT) calls
    outgoing dependencies to change the state of those dependencies. *Stubs* help
    emulate *incoming dependencies*: the SUT makes calls to such dependencies to get
    input data.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟*帮助模拟和检查 *输出依赖项*：代表我们工作单元的出口点的依赖项。被测试的系统（SUT）调用输出依赖项以改变这些依赖项的状态。*Stubs*
    帮助模拟 *输入依赖项*：SUT 调用此类依赖项以获取输入数据。'
- en: Stubs help replace an unreliable dependency with a fake, reliable one and thus
    avoid *test flakiness*.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stubs 帮助用假的可信依赖项替换不可信的依赖项，从而避免 *测试的不稳定性*。
- en: 'There are multiple ways to inject a stub into a unit of work:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多种方法可以将 stub 注入到工作单元中：
- en: '*Function as parameter*—Injecting a function instead of a plain value.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数作为参数*——注入一个函数而不是一个普通值。'
- en: '*Partial application (currying) and factory functions*—Creating a function
    that returns another function with some of the context baked in. This context
    may include the dependency you replaced with a stub.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分应用（柯里化）和工厂函数*——创建一个返回另一个函数的函数，该函数包含一些预先烘焙的上下文。这个上下文可能包括你用 stub 替换的依赖项。'
- en: '*Module injection*—Replacing a module with a fake one with the same API. This
    approach is fragile. You may need a lot of refactoring if the module you are faking
    changes its API in the future.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块注入*——用一个具有相同 API 的假模块替换模块。这种方法是脆弱的。如果模拟的模块在未来更改其 API，你可能需要进行大量的重构。'
- en: '*Constructor function*—This is mostly the same as partial application.'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构造函数*——这基本上与部分应用相同。'
- en: '*Class constructor injection*—This is a common object-oriented technique where
    you inject a dependency via a constructor.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类构造函数注入*——这是一种常见的面向对象技术，通过构造函数注入依赖项。'
- en: '*Object as parameter (aka duck typing)*—In JavaScript, you can inject any dependency
    in place of the required one as long as that dependency implements the same functions.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象作为参数（即鸭子类型）*——在 JavaScript 中，只要依赖项实现了相同的函数，你就可以将其注入到所需依赖项的位置。'
- en: '*Common interface as parameter*—This is the same as object as parameter, but
    it involves a check during compile time. For this approach, you need a strongly
    typed language like TypeScript.'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公共接口作为参数*——这与对象作为参数相同，但在编译时涉及检查。对于这种方法，你需要一个强类型语言，如 TypeScript。'
