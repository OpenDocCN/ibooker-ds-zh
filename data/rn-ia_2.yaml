- en: Part 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分
- en: API reference
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: API参考
- en: React Native offers a wealth of APIs. The chapters in this part cover cross-platform
    APIs as well as APIs that are specific to the iOS and Android platforms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React Native提供了丰富的API。本部分章节涵盖了跨平台API以及特定于iOS和Android平台的API。
- en: 'In chapter 9, we explore using React Native’s cross-platform APIs: APIs that
    can be used on either iOS or Android to create alerts; detect whether the app
    is in the foreground, is in the background, or is inactive; persist, retrieve,
    and remove data; store and update text to the device clipboard; and perform a
    number of other useful tasks. In chapters 10 and 11, we’ll look at React Native’s
    APIs that are specific to either the iOS platform or the Android platform.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章中，我们探讨了使用React Native的跨平台API：可以在iOS或Android上使用的API，用于创建提醒；检测应用是否在前台、后台或非活动状态；持久化、检索和删除数据；存储和更新文本到设备剪贴板；以及执行许多其他有用任务。在第10章和第11章中，我们将探讨React
    Native针对iOS平台或Android平台的特定API。
- en: '9'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Implementing cross-platform APIs
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 实现跨平台API
- en: '**This chapter covers**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容涵盖**'
- en: Creating native application alert dialogs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建原生应用程序警告对话框
- en: Detecting whether the app is in the foreground, background, or inactive
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测应用是否处于前台、后台或非活动状态
- en: Storing and updating text to the device clipboard
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本存储和更新到设备剪贴板
- en: Using geolocation to retrieve and use latitude, longitude, speed, and altitude
    of the user’s device
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地理位置获取并使用用户设备的纬度、经度、速度和高度
- en: Detecting device attributes such as the height and width of the screen and the
    connection type
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测设备属性，如屏幕的高度和宽度以及连接类型
- en: One of the key benefits of using React Native is the ease with which native
    APIs can be accessed and used with JavaScript. In this chapter, we’ll cover most
    of the cross-platform APIs available in the framework. When accessing these APIs,
    you’ll be able to use a single codebase to implement platform-specific behavior
    on both iOS and Android.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Native的一个关键好处是，可以轻松地使用JavaScript访问和使用原生API。在本章中，我们将介绍框架中大多数可用的跨平台API。当访问这些API时，您将能够使用单个代码库在iOS和Android上实现特定于平台的行为。
- en: The main difference between the native APIs discussed in this chapter and native
    components is that native components usually have something to do with the UI,
    such as showing a specific UI element. APIs, on the other hand, are more about
    accessing native features and hardware in the phone, such as interacting with
    or accessing data held in the device (geolocation, application state, and so on).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的原生API与原生组件之间的主要区别在于，原生组件通常与UI有关，例如显示特定的UI元素。另一方面，API更多地涉及访问手机中的原生功能和硬件，例如与设备中的数据（地理位置、应用状态等）交互或访问。
- en: 'This chapter covers the following cross-platform APIs:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下跨平台API：
- en: Alert
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alert
- en: AppState
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppState
- en: AsyncStorage
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AsyncStorage
- en: Clipboard
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clipboard
- en: Dimensions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dimensions
- en: Geolocation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理位置服务
- en: Keyboard
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘
- en: NetInfo
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetInfo
- en: PanResponder
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PanResponder
- en: Although React Native offers other cross-platform APIs, you’ll find these to
    be the most useful.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然React Native提供了其他跨平台API，但你会发现这些是最有用的。
- en: In addition to its cross-platform APIs, React Native also offers platform-specific
    APIs (that is, APIs that work only on either iOS or Android). We’ll cover iOS-specific
    APIs in chapter 10 and Android-specific APIs in chapter 11.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了跨平台API之外，React Native还提供了特定于平台的API（即仅在iOS或Android上工作的API）。我们将在第10章中介绍特定于iOS的API，在第11章中介绍特定于Android的API。
- en: 9.1 Using the Alert API to create cross-platform notifications
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 使用Alert API创建跨平台通知
- en: 'Alert launches a platform-specific alert dialog with a title, a message, and
    optional methods that can be called when an alert button is pressed. Alert can
    be triggered by calling the `alert` method (`Alert.alert`), which takes four arguments
    (see [table 9.1](#table9.1)):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Alert通过调用`alert`方法（`Alert.alert`）来启动具有标题、消息和可选方法的平台特定警告对话框，这些方法可以在按下警告按钮时调用。Alert可以通过调用`alert`方法触发，该方法接受四个参数（见[表9.1](#table9.1)）：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Table 9.1 `Alert.alert` method arguments
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 `Alert.alert`方法参数
- en: '| **Argument** | **Type** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `title` | String | Main message of the alert button |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `title` | 字符串 | 提醒按钮的主要信息 |'
- en: '| `message` | String | Secondary message of the alert button |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `message` | 字符串 | 提醒按钮的次要信息 |'
- en: '| `buttons` | Array | Array of buttons, each of which is an object with two
    keys: `title` (string) and `onPress` (function) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `buttons` | 数组 | 按钮数组，每个按钮都是一个具有两个键的对象：`title`（字符串）和`onPress`（函数）|'
- en: '| `options` | Object | Object containing a cancelable Boolean (options: `{
    cancelable: true }` ) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `options` | 对象 | 包含可取消布尔值的对象（选项：`{ cancelable: true }`）|'
- en: 9.1.1 Use cases for alerts
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 警报的使用用例
- en: An alert is a common UI pattern across both the web and mobile devices, and
    it’s an easy way to let the user know about something happening in the application
    such as an error or success. Many times, an alert is used if a download has finished,
    an error has occurred, or an asynchronous process (such as logging in) has completed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 警报是在网页和移动设备上常见的 UI 模式，并且是让用户了解应用程序中发生的事情（如错误或成功）的简单方式。很多时候，如果下载完成、发生错误或异步过程（如登录）完成，就会使用警报。
- en: 9.1.2 Example of using alerts
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 使用警报的示例
- en: 'You can trigger an alert by calling the `Alert.alert()` method and passing
    in one or more arguments. In this example, you’ll create an alert with two options:
    Cancel and Show Message (see [figure 9.1](#figure9.1)). If cancel is pressed,
    you’ll dismiss the alert; if Show Message is pressed, you’ll update the state
    to show the message.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `Alert.alert()` 方法并传入一个或多个参数来触发一个警报。在这个示例中，你将创建一个带有两个选项的警报：取消和显示消息（见[图
    9.1](#figure9.1)）。如果按下取消，你将关闭警报；如果按下显示消息，你将更新状态以显示消息。
- en: Listing 9.1 Binding an alert to a touch event
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 将警报绑定到触摸事件
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![c09_01.tif](Images/c09_01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![c09_01.tif](Images/c09_01.png)'
- en: '[Figure 9.1](#figureanchor9.1) onPress alert with two options: Cancel and Show
    Message (left: iOS, right: Android)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.1](#figureanchor9.1) 按压警报带有两个选项：取消和显示消息（左：iOS，右：Android）'
- en: 9.2 Using the AppState API to detect the current application state
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 使用 AppState API 检测当前应用程序状态
- en: AppState will tell you whether the app is active, inactive, or in the background.
    It basically calls a method whenever the app state changes, allowing you to perform
    actions or call other methods based on the state of the app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: AppState 会告诉你应用是活动状态、非活动状态还是后台状态。它基本上会在应用状态改变时调用一个方法，允许你根据应用的状态执行操作或调用其他方法。
- en: AppState triggers whenever the app state changes and then returns `active`,
    `inactive`, or `background`. To respond to app state changes, add an event listener
    and call a method when the event is fired. The events that AppState uses to respond
    are `change` and `memorywarning`. This section’s example uses `change` because
    it’s what you’ll primarily use in a real-world scenario.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用状态改变时，AppState 会触发并返回 `active`、`inactive` 或 `background`。要响应应用状态改变，添加事件监听器并在事件触发时调用一个方法。AppState
    用于响应的事件是 `change` 和 `memorywarning`。本节的示例使用 `change`，因为在现实场景中你主要会用到它。
- en: 9.2.1 Use cases for AppState
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 AppState 的使用用例
- en: AppState is a useful API, and frequently comes in handy. Many times, when the
    app is pulled into the foreground, you may want to do things such as fetch fresh
    data from your API—and that’s a great use case for AppState.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: AppState 是一个有用的 API，并且经常派上用场。很多时候，当应用被拉回前台时，你可能想做一些事情，比如从你的 API 中获取新鲜数据——这就是
    AppState 的一个很好的用例。
- en: Another use case is authentication. When the app is set into the foreground,
    you may want to add another layer of security, such as a PIN or fingerprint.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是身份验证。当应用置于前台时，你可能想添加另一层安全措施，例如PIN码或指纹。
- en: If you’re doing polling, such as hitting a database every 15 seconds or so to
    check for new data, you may want to disable the polling when the user pushes the
    app into the background. AppState is a great use case for this as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在进行轮询，例如每 15 秒左右击打一次数据库以检查新数据，那么当用户将应用推入后台时，你可能想禁用轮询。AppState 也是这种情况的一个很好的用例。
- en: 9.2.2 Example of using AppState
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 使用 AppState 的示例
- en: In this example, you’ll add an event listener that listens for the `change`
    event in `componentDidMount` and then displays the current state in the console.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将在 `componentDidMount` 中添加一个事件监听器，监听 `change` 事件，然后在控制台显示当前状态。
- en: Listing 9.2 Using AppState to log out the current app state
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 使用 AppState 记录当前应用状态
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the project, and test it by either pressing CMD-Shift-H in iOS Simulator
    or pressing the home button in the Android emulator. The console should log the
    current app state (active, inactive, or background).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，并通过在 iOS 模拟器中按 CMD-Shift-H 或在 Android 模拟器中按主页按钮来测试它。控制台应记录当前应用状态（活动、非活动或后台）。
- en: 9.3 Using the AsyncStorage API to persist data
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 使用 AsyncStorage API 持久化数据
- en: 'Next up is AsyncStorage. AsyncStorage is a great way to persist and store data:
    it’s asynchronous, meaning you can retrieve data using a promise or `async await`,
    and it uses a key-value system to store and retrieve data.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是AsyncStorage。AsyncStorage是持久化和存储数据的好方法：它是异步的，这意味着你可以使用promise或`async await`检索数据，并且它使用键值系统来存储和检索数据。
- en: When you use an application and then close it, its state will be reset the next
    time you open it. One of the main benefits of AsyncStorage is that it lets you
    store the data directly to the user’s device and retrieve it whenever you need
    it!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一个应用然后关闭它时，它的状态将在你下次打开时重置。AsyncStorage的主要优点之一是它允许你直接将数据存储到用户的设备上，并在需要时检索它！
- en: AsyncStorage’s methods and arguments are listed in [table 9.2](#table9.2).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: AsyncStorage的方法和参数列于[表9.2](#table9.2)中。
- en: Table 9.2 AsyncStorage methods and arguments
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.2 AsyncStorage方法和参数
- en: '| **Method** | **Arguments** | **Description** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **参数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `setItem` | `key`, `value`, `callback` | Stores an item in AsyncStorage |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `setItem` | `key`, `value`, `callback` | 在AsyncStorage中存储一个项 |'
- en: '| `getItem` | `key`, `callback` | Retrieves an item from AsyncStorage |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `getItem` | `key`, `callback` | 从AsyncStorage中检索一个项 |'
- en: '| `removeItem` | `key`, `callback` | Removes an item from AsyncStorage |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `removeItem` | `key`, `callback` | 从AsyncStorage中删除一个项 |'
- en: '| `mergeItem` | `key`, `value`, `callback` | Merges an existing value with
    another existing value (both values must be stringified JSON) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `mergeItem` | `key`, `value`, `callback` | 将一个现有值与另一个现有值合并（两个值都必须是字符串化的JSON）
    |'
- en: '| `clear` | `callback` | Erases all values in AsyncStorage |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `clear` | `callback` | 删除AsyncStorage中的所有值 |'
- en: '| `getAllKeys` | `callback` | Gets all keys stored in your app |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `getAllKeys` | `callback` | 获取应用中存储的所有键 |'
- en: '| `flushGetRequests` | None | Flushes any pending requests |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `flushGetRequests` | 无 | 清除任何挂起的请求 |'
- en: '| `multiGet` | `[keys]`, `callback` | Allows you to get multiple values using
    an array of keys |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `multiGet` | `[keys]`, `callback` | 允许你使用键数组获取多个值 |'
- en: '| `multiSet` | `[keyValuePairs]`, `callback` | Allows you to set multiple key-value
    pairs at once |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `multiSet` | `[keyValuePairs]`, `callback` | 允许你一次性设置多个键值对 |'
- en: '| `multiRemove` | `[keys]`, `callback` | Allows you to delete multiple values
    using an array of keys |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `multiRemove` | `[keys]`, `callback` | 允许你使用键数组删除多个值 |'
- en: '| `multiMerge` | `[keyValuePairs]`, `callback` | Allows you to merge multiple
    key-value pairs into one method |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `multiMerge` | `[keyValuePairs]`, `callback` | 允许你将多个键值对合并到一个方法中 |'
- en: 9.3.1 Use cases for AsyncStorage
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 AsyncStorage的使用场景
- en: AsyncStorage is often used for authentication purposes, persisting user data
    and information that you don’t want lost when the application is closed. For example,
    when a user logs in and you get their name, user ID, avatar, and so on from the
    API, you don’t want to force that user to log in every time they open the app.
    You can save their information to AsyncStorage when they log in the first time,
    and from then on, use the original information and only update it when necessary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: AsyncStorage常用于认证目的，持久化用户数据和信息，防止在应用关闭时丢失。例如，当用户登录并从API获取他们的名字、用户ID、头像等信息时，你不想每次他们打开应用时都强制他们登录。当他们第一次登录时，你可以将他们的信息保存到AsyncStorage中，然后从那时起，使用原始信息，并在必要时更新它。
- en: Another use case is when you’re working with large data sets or slow APIs and
    don’t want to wait for them more than once. For example, if a data set takes a
    few seconds to retrieve, you may want to cache that data in AsyncStorage, show
    it to the user when they open the app, and refresh the data in a background process
    so the user doesn’t have to wait to begin interacting with the data or the UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是当你处理大量数据集或慢速API时，不想多次等待。例如，如果一个数据集需要几秒钟来检索，你可能想在AsyncStorage中缓存该数据，在用户打开应用时显示它，并在后台进程中刷新数据，这样用户就不必等待开始与数据或UI交互。
- en: 9.3.2 Example of using AsyncStorage
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 AsyncStorage使用示例
- en: In this example, you’ll take a user object and store it into the AsyncStorage
    in `componentDidMount`. You’ll then use a button to extract the data from AsyncStorage,
    populate the state with the data, and render it to the view.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将取一个用户对象并将其存储到AsyncStorage的`componentDidMount`中。然后，你将使用一个按钮从AsyncStorage中提取数据，用数据填充状态，并将其渲染到视图中。
- en: Listing 9.3 Persisting and retrieving data using AsyncStorage
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3使用AsyncStorage持久化和检索数据
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, promises are used to set and return the values from AsyncStorage.
    There’s also another way to do this: let’s look at `async await`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，promises被用来设置和从AsyncStorage返回值。还有另一种方法来做这件事：让我们看看`async await`。
- en: Listing 9.4 Using `async await` `to fetch data asynchronously`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 使用 `async await` 异步获取数据
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`async await` first requires you to mark the function as async by adding the
    `async` keyword before the function name. You’re then able to use the `await`
    keyword to wait for the returned value of a function, allowing you to write promise-based
    code as if it were synchronous. When you await a promise, the function waits until
    the promise settles, but it does so in a nonblocking way; it then assigns the
    value to the variable.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`async await` 首先需要您通过在函数名前添加 `async` 关键字来标记函数为异步。然后您可以使用 `await` 关键字等待函数返回的值，允许您像编写同步代码一样编写基于
    promise 的代码。当您等待一个 promise 时，函数会等待直到 promise 解决，但它以非阻塞的方式进行；然后它将值赋给变量。'
- en: 9.4 Using the Clipboard API to copy text into the user’s clipboard
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用剪贴板 API 将文本复制到用户的剪贴板
- en: 'Clipboard lets you save and retrieve content from the clipboard on both iOS
    and Android. Clipboard has two methods: `getString()` and `setString()` (see [table
    9.3](#table9.3)).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 剪贴板允许您在 iOS 和 Android 上保存和检索剪贴板内容。剪贴板有两个方法：`getString()` 和 `setString()`（见 [表
    9.3](#table9.3)）。
- en: Table 9.3 Clipboard methods
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.3 剪贴板方法
- en: '| **Method** | **Arguments** | **Description** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **参数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `getString` | None | Gets the contents of the clipboard |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `getString` | None | 获取剪贴板的内容 |'
- en: '| `setString` | `content` | Sets the contents of the clipboard |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `setString` | `content` | 设置剪贴板的内容 |'
- en: 9.4.1 Use cases for Clipboard
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 剪贴板的用例
- en: The most common use case for Clipboard is when a user needs to copy a string
    of text. Rather than have to remember it, the user can copy it to the clipboard
    using Clipboard and then paste it anywhere they want to use the information!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 剪贴板最常见的用例是当用户需要复制一段文本字符串时。用户不必记住它，可以使用剪贴板复制到剪贴板，然后将其粘贴到任何他们想要使用信息的地方！
- en: 9.4.2 Example of using Clipboard
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 使用剪贴板的示例
- en: In this example, you’ll set an initial clipboard value of “Hello World” in `componentDidMount`
    and then use a method attached to a `TextInput` to update the clipboard. You’ll
    add a button that pushes the current `ClipboardValue` to an array and renders
    it to the View.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您将在 `componentDidMount` 中设置一个初始剪贴板值“Hello World”，然后使用附加到 `TextInput` 的方法更新剪贴板。您将添加一个按钮，将当前的
    `ClipboardValue` 推送到一个数组并将其渲染到视图。
- en: Listing 9.5 Saving and replacing clipboard content
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 保存和替换剪贴板内容
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 9.5 Using the Dimensions API to get the user’s screen information
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 使用维度 API 获取用户的屏幕信息
- en: Dimensions gives you a way to get the device screen’s height and width. This
    is a good way to perform calculations based on the screen’s dimensions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 维度提供了一种获取设备屏幕高度和宽度的方法。这是一种根据屏幕尺寸进行计算的好方法。
- en: 9.5.1 Use cases for the Dimensions API
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 维度 API 的用例
- en: 'Many times, you want to know the exact dimensions of the user’s device, in
    order to create the perfect UI. When creating a global theme, having the width
    and the height to set global variables (such as font sizes) is a great way to
    provide consistent styling across your app, regardless of device size. Using the
    width of the device to make consistent grid elements is another easy way to create
    a consistent experience. Bottom line: whenever you need the device screen’s height
    and width, use Dimensions.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，您可能需要知道用户设备的精确尺寸，以便创建完美的 UI。在创建全局主题时，拥有宽度和高度来设置全局变量（如字体大小）是提供跨设备一致样式的好方法。使用设备宽度来创建一致的网格元素是另一种轻松创建一致体验的方法。总之：无论何时需要设备屏幕的高度和宽度，请使用维度。
- en: 9.5.2 Example of using the Dimensions API
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 使用维度 API 的示例
- en: To use Dimensions, import the API from React Native, and then call the `get()`
    method, passing in either `window` or `screen` as a parameter. Return `width`,
    `height`, or both.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用维度，从 React Native 导入 API，然后调用 `get()` 方法，传入 `window` 或 `screen` 作为参数。返回 `width`、`height`
    或两者。
- en: Listing 9.6 Using Dimensions to retrieve the width and height of the device
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 使用维度检索设备的宽度和高度
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One way to access the dimensions is to destructure what’s returned from calling
    `Dimensions.get` on the window, in this case `width` and `height`. You can also
    get the scale of the window. Another way is to call `Dimensions.get` and access
    the object property directly, calling `.width` on `Dimensions.get`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 获取维度的一种方式是解构从调用 `Dimensions.get` 在窗口返回的内容，在这种情况下是 `width` 和 `height`。您还可以获取窗口的缩放比例。另一种方式是调用
    `Dimensions.get` 并直接访问对象属性，在 `Dimensions.get` 上调用 `.width`。
- en: 9.6 Using the Geolocation API to get the user’s current location information
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 使用 Geolocation API 获取用户当前位置信息
- en: Geolocation is achieved in React Native using the same API used in the browser,
    with the `navigator.geolocation` global variable available anywhere in the app.
    You don’t need to import anything to begin using this, because it’s again available
    as a global.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 中，使用与浏览器中相同的 API 实现地理位置，`navigator.geolocation` 全局变量在应用程序的任何地方都可用。您不需要导入任何内容即可开始使用，因为它再次作为全局变量可用。
- en: 9.6.1 Use cases for the Geolocation API
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 Geolocation API 的用例
- en: If you’re building an application that requires the user’s latitude and longitude,
    then you’ll need to use geolocation. `react-native-maps`, the map component that
    was created and open sourced by Airbnb, is a great use case for geolocation. Many
    times you’ll want to have the map load to the user’s current location; to do that,
    you have to pass in the correct coordinates. Use Geolocation to get those coordinates.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建需要用户纬度和经度的应用程序，那么您将需要使用地理位置。`react-native-maps`，这是由 Airbnb 创建并开源的地图组件，是地理位置的一个很好的用例。很多时候，您希望地图加载到用户的当前位置；要做到这一点，您必须传入正确的坐标。使用地理位置来获取这些坐标。
- en: 9.6.2 Example of using Geolocation
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.2 使用 Geolocation 的示例
- en: 'To get started with Geolocation, you must enable it to be used in the app if
    you’re developing for Android (iOS is enabled by default):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用地理位置，如果您为 Android 开发（iOS 默认启用），则必须启用其在应用程序中使用：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![c09_02.tif](Images/c09_02.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![c09_02.tif](Images/c09_02.png)'
- en: '[Figure 9.2](#figureanchor9.2) Coordinates object returned from Geolocation'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.2](#figureanchor9.2) 地理位置返回的坐标对象'
- en: '[Table 9.4](#table9.4) lists the available methods.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9.4](#table9.4) 列出了可用的方法。'
- en: Table 9.4 Geolocation methods
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.4 地理位置方法
- en: '| **Method** | **Arguments** | **Description** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **参数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `getCurrentPosition` | `successcallback`, `errcallback`, `optionsobject{enableHighAccuracy:
    Boolean, timeout: number, maximumAge: number}` | Gets the current position. Success
    returns an object with a `coords` object and a timestamp. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `getCurrentPosition` | `successcallback`, `errcallback`, `optionsobject{enableHighAccuracy:
    Boolean, timeout: number, maximumAge: number}` | 获取当前位置。成功返回一个包含 `coords` 对象和时间的对象。
    |'
- en: '| `watchPosition` | `successcallback`, errcallback, `optionsobject{enableHighAccuracy:
    Boolean, timeout: number, maximumAge: number}` | Gets the current position and
    is automatically called when the device position changes. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `watchPosition` | `successcallback`, `errcallback`, `optionsobject{enableHighAccuracy:
    Boolean, timeout: number, maximumAge: number}` | 获取当前位置，并在设备位置改变时自动调用。 |'
- en: '| `clearWatch` | `watchId` | Cancels a watch. Store the `watchPosition` method
    in a variable when created to have access to the `watchId`. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `clearWatch` | `watchId` | 取消一个监视。在创建时将 `watchPosition` 方法存储在变量中以访问 `watchId`。
    |'
- en: '| `stopObserving` | None | Cancels all geolocation watches that have been set
    up. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `stopObserving` | 无 | 取消所有已设置的地定位监视。 |'
- en: '`getCurrentPosition` and `watchPosition` return coordinates as an object with
    information about the current user’s location (see [figure 9.2](#figure9.2)).
    The information returned contains not only the latitude and longitude, but also
    the speed and altitude as well as a few other data points.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCurrentPosition` 和 `watchPosition` 返回一个包含有关当前用户位置信息的对象（见 [图 9.2](#figure9.2)）。返回的信息不仅包含纬度和经度，还包括速度、海拔以及其他一些数据点。'
- en: To see this in action, you’ll set up an instance of Geolocation `getCurrentPosition`
    and `watchPosition`. You’ll also have a button to call `clearWatch`, which will
    clear the watch position functionality enabled by the call to `watchPosition`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个动作，您将设置一个 Geolocation 实例 `getCurrentPosition` 和 `watchPosition`。您还将有一个按钮来调用
    `clearWatch`，这将清除由 `watchPosition` 调用启用的监视位置功能。
- en: '`watchPosition` will only change if you physically change the coordinates.
    For example, if you run this on a device and walk around, you should see the coordinates
    update. This watch can be cancelled at any time by calling `navigator.geolocation.clearWatch(id)`,
    passing in the ID of the watch you want to cancel. You’ll then display both the
    original coordinates as well as the updated coordinates (latitude and longitude).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`watchPosition` 仅在您物理改变坐标时才会更改。例如，如果您在设备上运行此代码并四处走动，您应该会看到坐标更新。您可以通过调用 `navigator.geolocation.clearWatch(id)`
    来在任何时候取消此监视，传入您想要取消的监视的 ID。然后您将显示原始坐标以及更新后的坐标（纬度和经度）。'
- en: Listing 9.7 Retrieving user coordinates using the Geolocation API
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 使用地理位置 API 获取用户坐标
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 9.7 Using the Keyboard API to control the location and functionality of the
    native keyboard
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 使用Keyboard API控制原生键盘的位置和功能
- en: The Keyboard API gives you access to the native keyboard. You can use this to
    either listen to keyboard events (and call methods based on these events) or dismiss
    the keyboard. The Keyboard methods are listed in [table 9.5](#table9.5).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Keyboard API让您可以访问原生键盘。您可以使用它来监听键盘事件（并根据这些事件调用方法）或关闭键盘。键盘方法列在[表9.5](#table9.5)中。
- en: Table 9.5 Keyboard methods
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.5 键盘方法
- en: '| **Method** | **Arguments** | **Description** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **参数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `addListener` | `event`, `callback` | Connects a method to be called based
    on native keyboard events such as `keyboardWillShow`, `keyboardDidShow`, `keyboardWillHide`,
    `keyboardDidHide`, `keyboardWillChangeFrame`, and `keyboardDidChangeFrame` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `addListener` | `event`, `callback` | 将方法连接到基于原生键盘事件（如`keyboardWillShow`,
    `keyboardDidShow`, `keyboardWillHide`, `keyboardDidHide`, `keyboardWillChangeFrame`,
    和 `keyboardDidChangeFrame`）调用的功能 |'
- en: '| `removeAllListeners` | `eventType` | Removes all listeners of the type specified
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `removeAllListeners` | `eventType` | 移除指定类型的所有监听器 |'
- en: '| `dismiss` | None | Dismisses the keyboard |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `dismiss` | 无 | 关闭键盘 |'
- en: 9.7.1 Use cases for the Keyboard API
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.1 Keyboard API的使用场景
- en: Many times, the default behavior of text inputs and the keyboard is exactly
    what you want, but not always. If you simulate a text input using some other type
    of component, the keyboard won’t slide up. In this case, you can import Keyboard
    and get manual and granular control over when the keyboard is shown and hidden.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，文本输入和键盘的默认行为正是您想要的，但并非总是如此。如果您使用其他类型的组件模拟文本输入，键盘不会滑动。在这种情况下，您可以导入Keyboard并手动和细致地控制键盘何时显示和隐藏。
- en: In some cases, you may want to manually dismiss the keyboard even when the text
    input is in focus. For example, if a PIN number input accepts four numbers and
    automatically checks to see if the input value is correct on the last input value,
    you may want to provide a UI that fetches or checks after the last value is typed
    in. Hiding the keyboard may make sense, and you can achieve this using the Keyboard
    API.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，即使文本输入处于焦点状态，您可能也想要手动关闭键盘。例如，如果PIN号码输入接受四个数字并在最后一个输入值上自动检查输入值是否正确，您可能希望提供一个在最后一个值输入后检索或检查的UI。隐藏键盘可能是有意义的，您可以使用Keyboard
    API实现这一点。
- en: 9.7.2 Example of using the Keyboard API
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.2 使用Keyboard API的示例
- en: 'In this example, you’ll set up a text input and have listeners for all available
    events. When the event is fired, you’ll log the event to the console. You’ll also
    have two buttons: one to dismiss the keyboard and another to remove all event
    listeners set up in `componentWillMount`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您将设置一个文本输入并监听所有可用的事件。当事件被触发时，您将在控制台记录事件。您还将有两个按钮：一个用于关闭键盘，另一个用于移除在`componentWillMount`中设置的
    所有事件监听器。
- en: Listing 9.8 Controlling the device keyboard using the Keyboard API
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 使用Keyboard API控制设备键盘
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 9.8 Using NetInfo to get the user’s current online/offline status
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 使用NetInfo获取用户的当前在线/离线状态
- en: 'NetInfo is an API that allows you to access data describing whether the device
    is online or offline. In order to use the NetInfo API on Android, you need to
    add the required permission to AndroidManifest.xml:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: NetInfo是一个API，允许您访问描述设备是否在线或离线的数据。要在Android上使用NetInfo API，您需要在AndroidManifest.xml中添加所需的权限：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: iOS and Android have different connectivity types, listed in [table 9.6](#table9.6).
    Access to them depends on the actual connectivity type of the user’s connection.
    To determine the connection, you can use the methods in [table 9.7](#table9.7).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: iOS和Android有不同的连接类型，列在[表9.6](#table9.6)中。访问它们取决于用户连接的实际连接类型。为了确定连接类型，您可以使用[表9.7](#table9.7)中的方法。
- en: Table 9.6 Cross platform and Android specific connectivity types
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.6 跨平台和Android特定连接类型
- en: '| **Cross platform (iOS and Android)** | **Android** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **跨平台（iOS和Android）** | **Android** |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `none` | `bluetooth` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `none` | `bluetooth` |'
- en: '| `wifi` | `ethernet` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `wifi` | `ethernet` |'
- en: '| `cellular` | `wimax` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `cellular` | `wimax` |'
- en: '| `unknown` |  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `unknown` |  |'
- en: Table 9.7 NetInfo methods
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.7 NetInfo方法
- en: '| **Method** | **Arguments** | **Description** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **参数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `isConnectionExpensive` | None | Returns a promise that returns a Boolean
    specifying whether the connection is or isn’t expensive |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `isConnectionExpensive` | 无 | 返回一个Promise，该Promise返回一个布尔值，指定连接是否昂贵 |'
- en: '| `isConnected` | None | Returns a promise that returns a Boolean specifying
    whether the device is or isn’t connected |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `isConnected` | None | 返回一个指定设备是否连接的布尔值的Promise |'
- en: '| `addEventListener` | `eventName`, `callback` | Adds an event listener for
    the specified event |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `addEventListener` | `eventName`, `callback` | 为指定的事件添加事件监听器 |'
- en: '| `removeEventListener` | `eventName`, `callback` | Removes an event listener
    for the specified event |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `removeEventListener` | `eventName`, `callback` | 移除指定事件的监听器 |'
- en: '| `getConnectionInfo` | None | Returns a promise that returns an object with
    type and effectiveType. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `getConnectionInfo` | None | 返回一个Promise，该Promise返回一个包含类型和有效类型的对象。 |'
- en: 9.8.1 Use cases for NetInfo
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.1 NetInfo的使用场景
- en: NetInfo is often used to prevent other API calls from happening, or to provide
    an offline UI that provides some but not all features of an online application.
    For example, suppose you have a feed of items that, when pressed, shows a new
    view with fetched information about that item. You can show some indication of
    the application being offline and not navigate to the item detail when the device
    is offline. NetInfo will give you this type of device information, allowing you
    to interact with the user in a useful way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: NetInfo通常用于防止其他API调用发生，或者提供一个离线UI，该UI提供了一些但不是所有在线应用程序的功能。例如，假设你有一个项目列表，当按下时，会显示一个新视图，其中包含有关该项目的获取信息。当设备离线时，你可以显示应用程序离线的某些指示，并且不导航到项目详情。NetInfo将为你提供此类设备信息，允许你以有用的方式与用户交互。
- en: 'Another use case is to set different API configurations based on the type of
    connection. For example, on Wi-Fi you may want to be more generous about the amount
    of data you allow to be requested and sent: if the user is on a cellular network,
    you may fetch only 10 items at a time; but on Wi-Fi, you’ll bump that to 20\.
    With NetInfo, you can determine what type of connection the user has, if any.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是根据连接类型设置不同的API配置。例如，在Wi-Fi上，你可能希望允许请求和发送的数据量更慷慨：如果用户在蜂窝网络中，你可能一次只获取10个项目；但在Wi-Fi上，你将把这个数字提高到20。使用NetInfo，你可以确定用户是否有连接类型。
- en: 9.8.2 Example of using NetInfo
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.2 使用NetInfo的示例
- en: Let’s set up a `NetInfo.getConnectionInfo` method to get the initial connection
    information. Then you’ll set up a listener to log out the current NetInfo if and
    when it changes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个`NetInfo.getConnectionInfo`方法来获取初始连接信息。然后，你将设置一个监听器来记录当前的NetInfo，如果它发生变化的话。
- en: Listing 9.9 Fetching and displaying the user connection type using NetInfo
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 使用NetInfo获取和显示用户连接类型
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 9.9 Getting information about touch and gesture events with PanResponder
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9 使用PanResponder获取触摸和手势事件信息
- en: The PanResponder API offers a way to use data from touch events. With it, you
    can granularly respond to and manipulate the application state based on single
    and multiple touch events, such as swiping, tapping, pinching, scrolling, and
    more.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: PanResponder API提供了一种使用触摸事件数据的方法。通过它，你可以根据单个和多个触摸事件（如滑动、点击、捏合、滚动等）精细地响应和操作应用程序状态。
- en: 9.9.1 Use cases for the PanResponder API
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.1 PanResponder API的使用场景
- en: 'Because the fundamental functionality of PanResponder is to determine the current
    touches happening on the user’s device, the use cases are unlimited. In my experience,
    I’ve used this API often to do things like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PanResponder的基本功能是确定用户设备上当前发生的触摸，因此使用场景是无限的。在我的经验中，我经常使用此API来完成以下类似的事情：
- en: Create a swipeable stack of cards where an item is removed from the stack when
    swiped out of view (think Tinder)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可滑动的卡片堆叠，当项目从视图中滑动出去时（想想Tinder），从堆叠中移除该项目
- en: Create an animatable overlay that the user can close by clicking a button or
    move out of view by swiping down
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可动画的覆盖层，用户可以通过点击按钮关闭它，或者通过向下滑动将其移出视图
- en: Give the user the ability to rearrange items in a list by pressing part of a
    list item and moving to the desired location
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按下列表项的一部分并将其移动到所需位置，使用户能够重新排列列表中的项目
- en: The use cases for PanResponder are many, but the most apparent and frequently
    used let the user move items around in the UI based on their press/swipe position.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: PanResponder的使用场景很多，但最明显和最常使用的是根据用户的按下/滑动位置在UI中移动项目。
- en: 'Let’s look at a basic gesture event using `onPanResponderMove(event, gestureState)`,
    which gives you data about the current position of the touch event, including
    current position, accumulated difference between current position and original
    position, and more:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `onPanResponderMove(event, gestureState)` 的基本手势事件，它提供了有关触摸事件当前位置的数据，包括当前位置、当前位置与原始位置之间的累积差异等：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To use this API, you first create an instance of `PanResponder` in the `componentWillMount`
    method. In this instance, you can then set all the configuration and callback
    methods for the `PanResponder`, using the methods to manipulate the state and
    `View`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此 API，你首先在 `componentWillMount` 方法中创建 `PanResponder` 的一个实例。在这个实例中，你可以设置 `PanResponder`
    的所有配置和回调方法，使用这些方法来操作状态和 `View`。
- en: Let’s look at the `create` method, which is the only available method for PanResponder.
    It creates the configuration for the `PanResponder` instance. [Table 9.8](#table9.8)
    shows the configuration options available to the create method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `create` 方法，这是 PanResponder 唯一可用的方法。它为 `PanResponder` 实例创建配置。[表 9.8](#table9.8)
    展示了 `create` 方法可用的配置选项。
- en: Table 9.8 Configuration arguments for the PanResponder `create` method
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.8 PanResponder `create` 方法的配置参数
- en: '| **Configuration property** | **Description** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **配置属性** | **描述** |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `onStartShouldSetPanResponder` | Determines whether to enable the PanResponder.
    Gets called after the element is touched. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `onStartShouldSetPanResponder` | 确定是否启用 PanResponder。在元素被触摸后调用。|'
- en: '| `onMoveShouldSetPanResponder` | Determines whether to enable the PanResponder.
    Gets called after the initial touch has first move. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `onMoveShouldSetPanResponder` | 确定是否启用 PanResponder。在初始触摸第一次移动后调用。|'
- en: '| `onPanResponderReject` | Gets called if the PanResponder does not register.
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `onPanResponderReject` | 如果 PanResponder 没有注册，则调用。|'
- en: '| `onPanResponderGrant` | Gets called if the PanResponder does register. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `onPanResponderGrant` | 如果 PanResponder 注册，则调用。|'
- en: '| `onPanResponderStart` | Gets called after the PanResponder registers. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `onPanResponderStart` | 在 PanResponder 注册后调用。|'
- en: '| `onPanResponderEnd` | Gets called after the PanResponder has finished. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `onPanResponderEnd` | 在 PanResponder 完成后调用。|'
- en: '| `onPanResponderMove` | Gets called when the PanResponder moves. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `onPanResponderMove` | 当 PanResponder 移动时调用。|'
- en: '| `onPanResponderTerminationRequest` | Gets called when something else wants
    to become responder. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `onPanResponderTerminationRequest` | 当其他东西想要成为响应者时调用。|'
- en: '| `onPanResponderRelease` | Gets called when the touch has been released. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `onPanResponderRelease` | 当触摸被释放时调用。|'
- en: '| `onPanResponderTerminate` | This responder has been taken by another one.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `onPanResponderTerminate` | 此响应者已被另一个响应者接管。|'
- en: Each configuration option is supplied with the Native Event and Gesture State.
    [Table 9.9](#table9.9) describes all the available properties of both `evt.nativeEvent`
    and `gestureState`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置选项都提供了原生事件和手势状态。[表 9.9](#table9.9) 描述了 `evt.nativeEvent` 和 `gestureState`
    的所有可用属性。
- en: Table 9.9 `evt` and `gestureState` properties
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.9 `evt` 和 `gestureState` 属性
- en: '| **evt.nativeEvent properties** | **Description** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **evt.nativeEvent 属性** | **描述** |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `changedTouches` | Array of all touch events that have changed since the
    last event |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `changedTouches` | 自上次事件以来所有已更改的触摸事件的数组 |'
- en: '| `identifier` | ID of the touch |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `identifier` | 触摸的 ID |'
- en: '| `locationX` | X position of the touch, relative to the element |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `locationX` | 相对于元素的触摸 X 位置 |'
- en: '| `locationY` | Y position of the touch, relative to the element |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `locationY` | 相对于元素的触摸 Y 位置 |'
- en: '| `pageX` | X position of the touch, relative to the root element |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `pageX` | 相对于根元素的触摸 X 位置 |'
- en: '| `pageY` | Y position of the touch, relative to the root element |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `pageY` | 相对于根元素的触摸 Y 位置 |'
- en: '| `target` | Node ID of the element receiving the touch event |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 接收触摸事件的元素的节点 ID |'
- en: '| `timestamp` | Time identifier for the touch; useful for velocity calculations
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `timestamp` | 触摸的时间标识符；对于速度计算很有用 |'
- en: '| `touches` | Array of all current touches on the screen |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `touches` | 屏幕上所有当前触摸的数组 |'
- en: '| **gestureState properties** | **Description** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **gestureState 属性** | **描述** |'
- en: '| `stateID` | ID of the `gestureState`, persisted as long as there is at least
    one touch on the screen |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `stateID` | `gestureState` 的 ID，只要屏幕上至少有一个触摸，就会持续存在 |'
- en: '| `moveX` | Latest screen coordinates of the recently moved touch |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `moveX` | 最近移动的触摸的最新屏幕坐标 |'
- en: '| `moveY` | Latest screen coordinates of the recently moved touch |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `moveY` | 最近移动的触摸的最新屏幕坐标 |'
- en: '| `x0` | Screen coordinates of the responder |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `x0` | 响应者的屏幕坐标 |'
- en: '| `y0` | Screen coordinates of the responder |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `y0` | 响应者的屏幕坐标 |'
- en: '| `dx` | Accumulated distance of the gesture since the touch started |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `dx` | 自触摸开始以来手势的累积距离 |'
- en: '| `dy` | Accumulated distance of the gesture since the touch started |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `dy` | 自触摸开始以来手势的累积距离 |'
- en: '| `vx` | Current velocity of the gesture |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `vx` | 手势的当前速度 |'
- en: '| `vy` | Current velocity of the gesture |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `vy` | 手势的当前速度 |'
- en: '| `numberActiveTouches` | Number of touches currently on screen |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `numberActiveTouches` | 当前屏幕上的触摸次数 |'
- en: 9.9.2 Example of using PanResponder
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.2 使用PanResponder的示例
- en: For this example, you’ll create a draggable square and display its x and y coordinates
    in the view. The result is shown in [figure 9.3](#figure9.3).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您将创建一个可拖动的正方形，并在视图中显示其x和y坐标。结果如图9.3所示。
- en: '![c09_03.tif](Images/c09_03.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![c09_03.tif](Images/c09_03.png)'
- en: '[Figure 9.3](#figureanchor9.3) PanResponder used to make the square draggable'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.3](#figureanchor9.3) 用于使正方形可拖动的PanResponder'
- en: Listing 9.10 Using PanResponder to create a draggable element
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 使用PanResponder创建可拖动元素
- en: '[PRE13]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Alert gives you the ability to prompt or alert the user to important information
    or events in the app.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alert允许您在应用中提示或警告用户有关重要信息或事件。
- en: AppState provides information about whether the current app is in use. You can
    then use this information in the app in a useful way.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppState提供了有关当前应用是否正在使用的相关信息。然后您可以在应用中以有用的方式使用这些信息。
- en: AsyncStorage lets you persist data to the user’s device, so that if the user
    closes the app, you can still access the data.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AsyncStorage允许您将数据持久化到用户的设备上，这样即使用户关闭应用，您仍然可以访问这些数据。
- en: Clipboard copies information to the user’s device clipboard so they can access
    it later.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪贴板将信息复制到用户的设备剪贴板，以便他们稍后访问。
- en: Dimensions provides useful information about the user’s device, most importantly
    the screen width and height.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dimensions提供了有关用户设备的有用信息，最重要的是屏幕宽度和高度。
- en: Geolocation provides the location as well as other important information about
    the user’s device, and allows you to check the location data when the user moves.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理定位提供了用户设备的位置以及其他重要信息，并允许您在用户移动时检查位置数据。
- en: NetInfo provides the user’s current connection information, including the type
    of connection and whether they’re currently connected.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetInfo提供了用户的当前连接信息，包括连接类型以及他们是否当前连接。
- en: PanResponder provides the current touch location(s) happening on the user’s
    device. You can use this information to enhance the UX and UI.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PanResponder提供了用户设备上发生的当前触摸位置。您可以使用这些信息来增强UX和UI。
- en: '10'
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Implementing iOS-specific components and APIs
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实现iOS特定组件和API
- en: '**This chapter covers**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Strategies for effectively targeting platform-specific code
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地定位平台特定代码的策略
- en: Using the picker components, `DatePickerIOS`, and `PickerIOS`
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选择器组件，`DatePickerIOS`和`PickerIOS`
- en: Showing loading progress using `ProgressViewIOS`
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ProgressViewIOS`显示加载进度
- en: Choosing views using `SegmentedControlIOS` and `TabBarIOS`
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SegmentedControlIOS`和`TabBarIOS`选择视图
- en: Calling and choosing items in an action sheet using `ActionSheetIOS`
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ActionSheetIOS`调用和选择动作表中的项目
- en: One of the end goals of the React Native project is to have a minimal amount
    of platform-specific logic and code. Most APIs can be built so the platform-specific
    code is abstracted away by the framework, giving you a single way to interact
    with them and easily create cross-platform functionality.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: React Native项目的其中一个最终目标是拥有尽可能少的平台特定逻辑和代码。大多数API都可以构建，使得平台特定的代码通过框架抽象化，从而为您提供一种单一的方式来与之交互，并轻松创建跨平台功能。
- en: Unfortunately, there will always be platform-specific APIs that can’t be completely
    abstracted away using an approach that makes sense cross-platform. Therefore,
    you’ll need to use at least a handful of platform-specific APIs and components.
    In this chapter, we cover iOS-specific APIs and components, discuss their props
    and methods, and create examples that mimic functionality and logic that will
    get you up to speed quickly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，总会有一些平台特定的API无法通过跨平台有意义的方案完全抽象化。因此，您将需要至少使用一些平台特定的API和组件。在本章中，我们将介绍iOS特定的API和组件，讨论它们的props和方法，并创建模拟功能性和逻辑的示例，以帮助您快速上手。
- en: 10.1 Targeting platform-specific code
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 定位平台特定代码
- en: 'The main idea of platform-specific code is writing components and files in
    a way that renders iOS- or Android-specific code based on the platform you’re
    on. There are a few techniques that can be implemented to show components based
    on what platform the app is running, and we cover the two most useful of those
    techniques here: using the correct file extension, and using the Platform API.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 平台特定代码的主要思想是以一种方式编写组件和文件，根据你所在的平台渲染 iOS 或 Android 特定的代码。有一些技术可以实现根据应用程序运行的平台显示组件，我们在这里介绍其中两种最有用的技术：使用正确的文件扩展名和使用
    Platform API。
- en: 10.1.1 iOS and Android file extensions
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 iOS 和 Android 文件扩展名
- en: The first way to target platform-specific code is to name the file with the
    correct file extension, depending on the platform you wish to target. For example,
    one component that differs quite a bit between iOS and Android is `DatePicker`.
    If you want specific styling around `DatePicker`, writing all the code in the
    main component may become verbose and difficult to maintain. Instead, you create
    two files—DatePicker.ios.js and DatePicker.android.js—and import them into the
    main component. When you run the project, React Native will automatically choose
    the correct file and render it based on the platform you’re using. Let’s look
    at a basic example in listings 10.1, 10.2, and 10.3\. (Note that this example
    will throw an error as is—`DatePicker` requires both props and methods to function
    correctly.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 定位平台特定代码的第一种方法是使用正确的文件扩展名命名文件，这取决于你希望针对的平台。例如，iOS 和 Android 之间差异相当大的一个组件是 `DatePicker`。如果你想在
    `DatePicker` 周围应用特定的样式，将所有代码都写在一个主组件中可能会变得冗长且难以维护。相反，你可以创建两个文件——DatePicker.ios.js
    和 DatePicker.android.js——并将它们导入到主组件中。当你运行项目时，React Native 会自动根据你使用的平台选择正确的文件并渲染它。让我们看看列表
    10.1、10.2 和 10.3 中的基本示例。（注意，这个示例会抛出错误——`DatePicker` 需要属性和方法才能正确运行。）
- en: Listing 10.1 iOS platform-specific code
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 iOS 平台特定代码
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 10.2 Android platform-specific code
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 Android 平台特定代码
- en: '[PRE15]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 10.3 Rendering the cross-platform component
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 渲染跨平台组件
- en: '[PRE16]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You import the date picker without giving a specific file extension. React Native
    knows which component to import depending on the platform. From there, you can
    use it in the application without having to worry about which platform you’re
    on.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你导入日期选择器时没有指定特定的文件扩展名。React Native 会根据平台知道要导入哪个组件。从那里，你可以在应用程序中使用它，而无需担心你所在的平台。
- en: 10.1.2 Detecting the platform using the Platform API
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 使用 Platform API 检测平台
- en: Another way to detect and perform logic based on the platform is to use the
    Platform API. Platform has two properties. The first is an OS key that reads either
    `ios` or `android`, depending on the platform.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种检测和基于平台执行逻辑的方法是使用 Platform API。Platform 有两个属性。第一个是一个 OS 键，它读取 `ios` 或 `android`，这取决于平台。
- en: Listing 10.4 Platform module detecting using `Platform.OS` property
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 使用 `Platform.OS` 属性检测平台
- en: '[PRE17]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you check whether the value of `Platform.OS` is equal to the string `'ios'`
    and, if it is, return a color of `'blue'`. If it isn’t, you return `'green'`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你检查 `Platform.OS` 的值是否等于字符串 `'ios'`，如果是，则返回 `'blue'` 颜色。如果不是，则返回 `'green'`。
- en: The second property of Platform is a method called `select`. `select` takes
    in an object containing the `Platform.OS` strings as keys (either `ios` or `android`)
    and returns the value for the platform you’re running.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Platform 的第二个属性是一个名为 `select` 的方法。`select` 接收一个包含 `Platform.OS` 字符串（`ios` 或
    `android`）作为键的对象，并返回你正在运行的平台的值。
- en: Listing 10.5 Using `Platform.select` to render components based on Platform
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 使用 `Platform.select` 根据平台渲染组件
- en: '[PRE18]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also use the ES2015 spread syntax to return objects and use those objects
    to apply styling. You may recall seeing the `Platform.select` function used in
    a couple of examples in chapter 4.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 ES2015 扩展运算符语法来返回对象，并使用这些对象来应用样式。你可能记得在第四章的几个示例中使用了 `Platform.select`
    函数。
- en: Listing 10.6 Using `Platform.select` to apply styles based on Platform
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 使用 `Platform.select` 根据平台应用样式
- en: '[PRE19]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 10.2 DatePickerIOS
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 DatePickerIOS
- en: '`DatePickerIOS` provides an easy way to implement a native date picker component
    on iOS. `It` has three modes that come in handy when working with dates and times:
    `date`, `time`, and `dateTime`, shown in [figure 10.1](#figure10.1).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatePickerIOS` 提供了一种在 iOS 上实现原生日期选择器组件的简单方法。`它` 有三种模式，在处理日期和时间时非常有用：`date`、`time`
    和 `dateTime`，如图 10.1 所示。'
- en: '![c10_01.eps](Images/c10_01.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![c10_01.eps](Images/c10_01.png)'
- en: '[Figure 10.1](#figureanchor10.1) `DatePickerIOS` with `date` mode, `time` mode,
    and `datetime` mode'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.1](#figureanchor10.1) `DatePickerIOS` 的 `date` 模式、`time` 模式和 `datetime`
    模式'
- en: '`DatePickerIOS` has the props listed in [table 10.1](#table10.1). The minimum
    props that need to be passed are `date` (the date that’s the beginning or current
    date choice) and an `onDateChange` method. When any of the date values are changed,
    `onDateChange` is called, passing the function the new date value.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatePickerIOS` 有列在 [表 10.1](#table10.1) 中的属性。需要传递的最小属性是 `date`（作为开始或当前日期选择的日期）和一个
    `onDateChange` 方法。当任何日期值改变时，`onDateChange` 被调用，传递函数新的日期值。'
- en: Table 10.1 `DatePickerIOS` props and method
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 `DatePickerIOS` 属性与方法
- en: '| **Prop** | **Type** | **Description** |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `date` | Date | Currently selected date |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `date` | 日期 | 当前选择的日期 |'
- en: '| `maximumDate` | Date | Maximum allowed date |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `maximumDate` | 日期 | 允许的最大日期 |'
- en: '| `minimumDate` | Date | Minimum allowed date |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `minimumDate` | 日期 | 允许的最小日期 |'
- en: '| `minuteInterval` | Enum | Interval at which minutes can be selected |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `minuteInterval` | 枚举 | 可选择的分钟间隔 |'
- en: '| `mode` | String: `date`, `time`, or `datetime` | Date picker mode |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `mode` | 字符串：`date`、`time` 或 `datetime` | 日期选择器模式 |'
- en: '| `onDateChange` | Function: `onDateChange(date) { }` | Function called when
    the date changes |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `onDateChange` | 函数：`onDateChange(date) { }` | 当日期改变时调用的函数 |'
- en: '| `timeZoneOffsetInMinutes` | Number | Time zone offset in minutes; overrides
    the default (the device time zone) |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `timeZoneOffsetInMinutes` | 数字 | 时区偏移量（分钟）；覆盖默认值（设备时区） |'
- en: 10.2.1 Example of using DatePickerIOS
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 使用 `DatePickerIOS` 的示例
- en: In the following example, you’ll set up a `DatePickerIOS` component and display
    the time in the view. You won’t pass in a mode prop, because the mode defaults
    to `datetime`. [Figure 10.2](#figure10.2) shows the result.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你将设置一个 `DatePickerIOS` 组件并在视图中显示时间。你不会传递模式属性，因为模式默认为 `datetime`。[图 10.2](#figure10.2)
    显示了结果。
- en: '![c10_02.tif](Images/c10_02.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![c10_02.tif](Images/c10_02.png)'
- en: '[Figure 10.2](#figureanchor10.2) DatePickerIOS rendering chosen date and time'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.2](#figureanchor10.2) `DatePickerIOS` 渲染选择的日期和时间'
- en: Listing 10.7 Using `DatePicker` to show and update time values
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 使用 `DatePicker` 显示和更新时间值
- en: '[PRE20]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 10.3 Using PickerIOS to work with lists of values
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 使用 `PickerIOS` 处理值列表
- en: Using `PickerIOS`, you can access the native iOS `Picker` component. This component
    basically allows you to scroll through and choose from a list of values using
    the native UI (see [figure 10.3](#figure10.3)). `PickerIOS` has the methods and
    props listed in [table 10.2](#table10.2).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PickerIOS`，你可以访问原生的 iOS `Picker` 组件。此组件基本上允许你使用原生 UI 滚动并通过列表选择值（见 [图 10.3](#figure10.3)）。`PickerIOS`
    有列在 [表 10.2](#table10.2) 中的方法和属性。
- en: Table 10.2 `PickerIOS` methods and props
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2 `PickerIOS` 方法与属性
- en: '| **Prop** | **Type** | **Description** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `itemStyle` | Object (style) | The text style for items within the container
    |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `itemStyle` | 对象（样式） | 容器内项目的文本样式 |'
- en: '| `onValueChange` | Function (value) | Called when the `PickerIOS` value changes
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `onValueChange` | 函数（值） | 当 `PickerIOS` 的值改变时调用 |'
- en: '| `selectedValue` | Number or string | Currently selected `PickerIOS` value
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `selectedValue` | 数字或字符串 | 当前选择的 `PickerIOS` 值 |'
- en: '![c10_03.tif](Images/c10_03.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![c10_03.tif](Images/c10_03.png)'
- en: '[Figure 10.3](#figureanchor10.3) PickerIOS rendering a list of people'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.3](#figureanchor10.3) `PickerIOS` 渲染人员列表'
- en: '`PickerIOS` wraps a list of items to be rendered as children. Each child item
    must be a `PickerIOS.Item`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickerIOS` 包裹要作为子元素渲染的项目列表。每个子元素必须是 `PickerIOS.Item`：'
- en: '[PRE21]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It’s possible to declare each `PickerIOS.Item` individually as done here, but
    most of the time you’ll be mapping over elements in an array and returning a `PickerIOS.Item`
    for each item in the array. The following listing shows an example.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像这里一样单独声明每个 `PickerIOS.Item`，但大多数情况下，你将遍历数组中的元素，并为数组中的每个项目返回一个 `PickerIOS.Item`。以下列表显示了一个示例。
- en: Listing 10.8 Using `PickerIOS` with an array of `PickerIOS.Item`s
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 使用 `PickerIOS` 与 `PickerIOS.Item` 数组
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '`PickerIOS` and `PickerIOS.Item` receive their own props. For `PickerIOS`,
    the main props are `onValueChange` and `selectedValue`. The `onValueChange` method
    is called whenever the picker is changed. The `selectedValue` is the value the
    picker shows as selected in the UI.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`PickerIOS` 和 `PickerIOS.Item` 接收它们自己的属性。对于 `PickerIOS`，主要的属性是 `onValueChange`
    和 `selectedValue`。`onValueChange` 方法在每次选择器改变时被调用。`selectedValue` 是选择器在 UI 中显示为已选的值。'
- en: For `PickerIOS.Item`, the main props are `key`, `value`, and `label`. `key`
    is a unique identifier, `value` is what will be passed to the `onValueChange`
    method of the `PickerIOS` component, and `label` is what is displayed in the UI
    as the label for the `PickerIOS.Item`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `PickerIOS.Item`，主要的属性是 `key`、`value` 和 `label`。`key` 是一个唯一标识符，`value` 是将传递给
    `PickerIOS` 组件的 `onValueChange` 方法的值，而 `label` 是在UI中作为 `PickerIOS.Item` 标签显示的内容。
- en: 10.3.1 Example of using PickerIOS
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 使用PickerIOS的示例
- en: In this example, you’ll render an array of people in the `PickerIOS`. When the
    value changes, you’ll update the UI to show the new value.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将在 `PickerIOS` 中渲染人员数组。当值改变时，你将更新UI以显示新值。
- en: Listing 10.9 Using `PickerIOS` to render an array of people
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9 使用 `PickerIOS` 渲染人员数组
- en: '[PRE23]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 10.4 Using ProgressViewIOS to show loading indicators
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 使用ProgressViewIOS显示加载指示器
- en: '`ProgressViewIOS` lets you render the native `UIProgressView` in the UI. Basically,
    it’s a native way to show a loading-percentage indication, download-percentage
    indication, or any indication of a task that’s being completed (see [figure 10.4](#figure10.4)).
    It has the props shown in [table 10.3](#table10.3).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressViewIOS` 允许你在UI中渲染原生的 `UIProgressView`。基本上，这是一种显示加载百分比指示、下载百分比指示或任何表示正在完成的任务的指示的原生方式（参见[图10.4](#figure10.4)）。它具有[表10.3](#table10.3)中显示的属性。'
- en: '![c10_04.tif](Images/c10_04.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![c10_04.tif](Images/c10_04.png)'
- en: '[Figure 10.4](#figureanchor10.4) Rendering `ProgressViewIOS` in the UI'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.4](#figureanchor10.4) 在UI中渲染 `ProgressViewIOS`'
- en: Table 10.3 `ProgressViewIOS` methods and props
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.3 `ProgressViewIOS` 方法和属性
- en: '| **Prop** | **Type** | **Description** |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `progress` | Number | Progress value (between 0 and 1) |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `progress` | 数字 | 进度值（介于0和1之间）|'
- en: '| `progressImage` | Image source | Stretchable image to display as the progress
    bar |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `progressImage` | 图片源 | 用于显示的进度条的可拉伸图片 |'
- en: '| `progressTintColor` | String (color) | Tint color of the progress bar |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `progressTintColor` | 字符串（颜色）| 进度条着色 |'
- en: '| `progressViewStyle` | Enum (default or bar) | Progress bar style |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `progressViewStyle` | 枚举（默认或条形）| 进度条样式 |'
- en: '| `trackImage` | Image source | Stretchable image to display behind the progress
    bar |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `trackImage` | 图片源 | 可拉伸的图片，用于显示在进度条后面|'
- en: '| `trackTintColor` | String | Tint color of the progress bar track |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `trackTintColor` | 字符串 | 进度条轨道着色 |'
- en: 10.4.1 Use cases for ProgressViewIOS
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 ProgressViewIOS的使用案例
- en: The most common use case for `ProgressViewIOS` is working with an external API
    that tells you how much information has been passed across the wire when you’re
    fetching or posting data or working with a local API that does the same. For example,
    if you’re saving a video to the user’s camera roll, you can use `ProgressViewIOS`
    to show the user how much longer the download will take and how much has been
    completed.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressViewIOS` 最常见的用例是与外部API一起工作，该API告诉你当你在获取或提交数据或与本地API一起工作时，已经通过线缆传递了多少信息。例如，如果你正在将视频保存到用户的相机胶卷，你可以使用
    `ProgressViewIOS` 来显示用户下载还需要多长时间以及已经完成了多少。'
- en: 10.4.2 Example of using ProgressViewIOS
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 使用ProgressViewIOS的示例
- en: The main prop you need to know about to create this functionality is `progress`.
    `progress` takes a number between 0 and 1 and fills the `ProgressViewIOS` with
    a percentage fill between 0% and 100%.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此功能所需了解的主要属性是 `progress`。`progress` 接受介于0和1之间的数字，并将 `ProgressViewIOS` 填充到0%到100%的百分比填充。
- en: In this example, you’ll simulate some data loading by setting a `setInterval`
    method that’s called in `componentDidMount`. You’ll increment the state value
    by 0.01 every 0.01 seconds until you’re at 1, starting with the initial value
    0.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将通过在 `componentDidMount` 中调用 `setInterval` 方法来模拟一些数据加载。你将每0.01秒增加状态值0.01，直到达到1，初始值为0。
- en: Listing 10.10 Using ProgressViewIOS to increment progress bar from 0% to 100%
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 使用ProgressViewIOS从0%增加到100%的进度条
- en: '[PRE24]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 10.5 Using SegmentedControlIOS to create horizontal tab bars
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 使用SegmentedControlIOS创建水平标签栏
- en: '![c10_05.tif](Images/c10_05.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![c10_05.tif](Images/c10_05.png)'
- en: '[Figure 10.5](#figureanchor10.5) Basic `SegmentedControlIOS` implementation
    with two values (one and two)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.5](#figureanchor10.5) 基本的两个值（一个和两个）的 `SegmentedControlIOS` 实现'
- en: '`SegmentedControlIOS` allows you to access the native iOS `UISegmentedControl`
    component. It’s a horizontal tab bar made up of individual buttons, as shown in
    [figure 10.5](#figure10.5).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`SegmentedControlIOS` 允许你访问原生的iOS `UISegmentedControl` 组件。它由单个按钮组成的水平标签栏，如图[图10.5](#figure10.5)所示。'
- en: '`SegmentedControlIOS` has the methods and props in [table 10.4](#table10.4).
    At a minimum, it takes an array of values to render the control values, a `selectedIndex`
    as the index of the control selected, and an `onChange` method that will be called
    when a control is pressed.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`SegmentedControlIOS` 的方法和属性在 [表 10.4](#table10.4) 中列出。至少，它需要一个值数组来渲染控制值，一个
    `selectedIndex` 作为已选控制的索引，以及一个当控制被按下时将被调用的 `onChange` 方法。'
- en: Table 10.4 `SegmentedControlIOS` methods and props
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.4 `SegmentedControlIOS` 方法与属性
- en: '| **Prop** | **Type** | **Description** |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `enabled` | Boolean | If `false`, the user can’t interact with the control.
    Default value is `true`. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `enabled` | 布尔值 | 如果为 `false`，则用户无法与控件交互。默认值为 `true`。 |'
- en: '| `momentary` | Boolean | If `true`, selecting a segment won’t persist visually.`onValueChange`
    will still work as expected. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `momentary` | 布尔值 | 如果为 `true`，选择一个段不会在视觉上持续。`onValueChange` 仍将按预期工作。 |'
- en: '| `onChange` | Function (event) | Callback called when the user taps a segment;
    passes the event as an argument. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `onChange` | 函数（event） | 当用户点击一个段时调用的回调；将事件作为参数传递。 |'
- en: '| `onValueChange` | Function (value) | Callback called when the user taps a
    segment; passes the segment’s value as an argument. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `onValueChange` | 函数（value） | 当用户点击一个段时调用的回调；将段的值作为参数传递。 |'
- en: '| `selectedIndex` | Number | Index in `props.values` of the segment to be (pre)selected.
    |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `selectedIndex` | 数字 | 要（预）选择的段的 `props.values` 中的索引。 |'
- en: '| `tintColor` | String (color) | Accent color of the control. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `tintColor` | 字符串（颜色） | 控件的强调颜色。 |'
- en: '| `values` | Array of strings | Labels for the control’s segment buttons, in
    order. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `values` | 字符串数组 | 控制按钮的标签，按顺序排列。 |'
- en: 10.5.1 Use cases for SegmentedControlIOS
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 SegmentedControlIOS 的用例
- en: '`SegmentedControlIOS` is a good place to separate and display certain filterable/sortable
    data in the UI. For example, if an app had information listed and viewable by
    week, you could use `SegmentedControlIOS` to separate that data even further by
    day of the week, with a separate view for each day.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`SegmentedControlIOS` 是在 UI 中分离和显示某些可筛选/可排序数据的良好位置。例如，如果一个应用有按周列出和可查看的信息，你可以使用
    `SegmentedControlIOS` 通过星期几进一步分离这些数据，为每一天提供一个单独的视图。'
- en: 10.5.2 Example of using SegmentedControlIOS
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 使用 SegmentedControlIOS 的示例
- en: In this example, you’ll render an array of three items as a `SegmentedControlIOS`.
    You’ll also show a value in the UI based on which item is selected.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，你将渲染一个包含三个项目的数组作为 `SegmentedControlIOS`。你还将根据所选项目在 UI 中显示一个值。
- en: Listing 10.11 `SegmentedControlIOS` rendering three values
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 `SegmentedControlIOS` 渲染三个值
- en: '[PRE25]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 10.6 Using TabBarIOS to render tabs at the bottom of the UI
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 使用 TabBarIOS 在 UI 底部渲染标签
- en: '`TabBarIOS` allows you to access the native iOS tab bar. It renders tabs at
    the bottom of the UI, as shown in [figure 10.6](#figure10.6), giving you a nice,
    easy way to separate an application into sections. Its methods and props are listed
    in [table 10.5](#table10.5).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabBarIOS` 允许你访问原生 iOS 标签栏。它将在 UI 底部渲染标签，如图 10.6 所示，为你提供一种优雅、简单的方式将应用程序分成几个部分。其方法和属性列在
    [表 10.5](#table10.5) 中。'
- en: Table 10.5 `TabBarIOS` props
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.5 `TabBarIOS` 属性
- en: '| **Prop** | **Type** | **Description** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `barTintColor` | String (color) | Background color of the tab bar. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `barTintColor` | 字符串（颜色） | 标签栏的背景颜色。 |'
- en: '| `itemPositioning` | Enum (`"fill", "center", "auto"`) | Tab bar item positioning.
    `fill` distributes items across the entire width of the tab bar. `center` centers
    items in the available tab bar space. `auto` (default) distributes items dynamically
    according to the UI idiom; in a horizontally compact environment, defaults to
    `fill`; otherwise defaults to `center`. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `itemPositioning` | 枚举（`"fill", "center", "auto"`） | 标签栏项目定位。`fill` 将项目分布在整个标签栏宽度上。`center`
    在可用的标签栏空间中居中项目。`auto`（默认）根据 UI 习惯动态分布项目；在水平紧凑环境中默认为 `fill`；否则默认为 `center`。 |'
- en: '| `style` | Object (style) | Style of the `TabBarIOS`. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `style` | 对象（样式） | `TabBarIOS` 的样式。 |'
- en: '| `tintColor` | String (color) | Color of the currently selected tab icon.
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `tintColor` | 字符串（颜色） | 当前选中标签图标的颜色。 |'
- en: '| `translucent` | Boolean | Indicates whether the tab bar is translucent. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `translucent` | 布尔值 | 表示标签栏是否为半透明。 |'
- en: '| `unselectedItemTintColor` | String (color) | Color of unselected tab icons
    (available since iOS 10). |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `unselectedItemTintColor` | 字符串（颜色） | 未选择标签图标的颜色（自 iOS 10 以来可用）。 |'
- en: '| `unselectedTintColor` | String (color) | Color of the text on unselected
    tabs. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `unselectedTintColor` | 字符串（颜色） | 未选择标签上文本的颜色。 |'
- en: '`TabBarIOS` takes a list of `TabBarIOS.Item` components as children:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabBarIOS` 接受一个 `TabBarIOS.Item` 组件列表作为子组件：'
- en: '[PRE26]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To show the content in the `TabBarIOS.Item`, the `selected` prop of the `TabBarIOS.Item`
    must be `true`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示 `TabBarIOS.Item` 中的内容，`TabBarIOS.Item` 的 `selected` 属性必须是 `true`：
- en: '![c10_06.tif](Images/c10_06.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![c10_06.tif](Images/c10_06.png)'
- en: '[Figure 10.6](#figureanchor10.6) `TabBarIOS` with two tabs: History and Favorites'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.6](#figureanchor10.6) `TabBarIOS` 包含两个标签页：历史和收藏'
- en: '[PRE27]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 10.6.1 Use cases for TabBarIOS
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.1 TabBarIOS 的使用场景
- en: The main use case for `TabBarIOS` is for navigation. Many times, on mobile,
    the best type of navigation is a tab bar. Separating the UI and displaying content
    in sections separated by tabs is a common pattern and is encouraged because it
    delivers a good user experience.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabBarIOS` 的主要使用场景是导航。在移动设备上，很多时候，最好的导航类型是标签栏。将 UI 分离并在标签分隔的各个部分中显示内容是一种常见的模式，并且被鼓励，因为它提供了良好的用户体验。'
- en: 10.6.2 Example of using TabBarIOS
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.2 使用 TabBarIOS 的示例
- en: 'In this example, you’ll create an app with two views: History and Favorites.
    When the `TabBarIOS.Item` is pressed, you’ll switch between views by calling an
    `onPress` method to update the state.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您将创建一个包含两个视图的应用程序：历史和收藏。当按下 `TabBarIOS.Item` 时，您将通过调用 `onPress` 方法来更新状态，在视图之间切换。
- en: Listing 10.12 Rendering tabs using `TabBarIOS`
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 使用 `TabBarIOS` 渲染标签
- en: '[PRE28]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can set icons either with a system icon or by passing in an icon prop and
    requiring a local image. For a list of all system icons, see http://mng.bz/rYNJ.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用系统图标或通过传递图标属性并要求本地图像来设置图标。有关所有系统图标的列表，请参阅 http://mng.bz/rYNJ。
- en: 10.7 Using ActionSheetIOS to show action or share sheets
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 使用 ActionSheetIOS 显示操作或分享表单
- en: '`ActionSheetIOS` allows you to access the native iOS `UIAlertController` to
    show a native iOS action sheet or share sheet (see [figure 10.7](#figure10.7)).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionSheetIOS` 允许您访问原生 iOS `UIAlertController` 来显示原生 iOS 操作表或分享表单（见 [图 10.7](#figure10.7)）。'
- en: '![c10_07.tif](Images/c10_07.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![c10_07.tif](Images/c10_07.png)'
- en: '[Figure 10.7](#figureanchor10.7) `ActionSheetIOS` rendering an action sheet
    (left) and a share sheet (right)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.7](#figureanchor10.7) `ActionSheetIOS` 渲染操作表（左侧）和分享表单（右侧）'
- en: 'The two main methods that you can call on `ActionSheetIOS` are `showActionSheetWithOptions`
    and `showShareActionSheetWithOptions`; these methods have the options listed in
    tables 10.6 and 10.7, respectively. `showActionSheetWithOptions` lets you pass
    an array of buttons and attach methods to each of the buttons. It’s called with
    two arguments: an `options` object and a callback function. `showShareActionSheetWithOptions`
    displays the native iOS share sheet, passing in a URL, message, and subject to
    share. It’s called with three arguments: an `options` object, a failure callback
    function, and a success callback function.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `ActionSheetIOS` 上调用的两个主要方法是 `showActionSheetWithOptions` 和 `showShareActionSheetWithOptions`；这些方法分别列在表
    10.6 和 10.7 中。`showActionSheetWithOptions` 允许您传递一个按钮数组并将方法附加到每个按钮上。它使用两个参数调用：一个
    `options` 对象和一个回调函数。`showShareActionSheetWithOptions` 显示原生 iOS 分享表单，传递要分享的 URL、消息和主题。它使用三个参数调用：一个
    `options` 对象、一个失败回调函数和一个成功回调函数。
- en: Table 10.6 `ActionSheetIOS``showActionSheetWithOptions` options
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.6 `ActionSheetIOS` 的 `showActionSheetWithOptions` 选项
- en: '| **Option** | **Type** | **Description** |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `options` | Array of strings | List of button titles (required) |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `options` | 字符串数组 | 按钮标题列表（必需） |'
- en: '| `cancelButtonIndex` | Integer | Index of the Cancel button in `options` |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `cancelButtonIndex` | 整数 | `options` 中取消按钮的索引 |'
- en: '| `destructiveButtonIndex` | Integer | Index of the Destructive button in `options`
    |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `destructiveButtonIndex` | 整数 | `options` 中破坏性按钮的索引 |'
- en: '| `title` | String | Title to show above the action sheet |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `title` | 字符串 | 在操作表上方显示的标题 |'
- en: '| `message` | String | Message to show below the title |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `message` | 字符串 | 在标题下方显示的消息 |'
- en: Table 10.7 `ActionSheetIOS``showShareActionSheetWithOptions` options
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.7 `ActionSheetIOS` 的 `showShareActionSheetWithOptions` 选项
- en: '| **Option** | **Type** | **Description** |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `url` | String | URL to share |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `url` | 字符串 | 要分享的 URL |'
- en: '| `message` | String | Message to share |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `message` | 字符串 | 要分享的消息 |'
- en: '| `subject` | String | Subject for the message |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `subject` | 字符串 | 消息的主题 |'
- en: '| `excludedActivityTypes` | Array | Activities to exclude from the action sheet
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `excludedActivityTypes` | 数组 | 要排除在操作表中的活动 |'
- en: 10.7.1 Use cases for ActionSheetIOS
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.1 ActionSheetIOS 的使用场景
- en: The main use case for `ActionSheetIOS` is to give the user a set of options
    to choose from and then call a function based on their selection. For example,
    in the Twitter app, the action sheet is used when the Retweet button is pressed,
    giving the user a few options including retweet, quote retweet, and cancel. This
    is a common use case, displaying an action sheet after a user presses a button
    and giving the user a set of options to choose from.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionSheetIOS` 的主要用途是为用户提供一组选项进行选择，并根据他们的选择调用一个函数。例如，在 Twitter 应用中，当按下重发按钮时，操作表被用来提供用户几个选项，包括重发、引用重发和取消。这是一个常见的用例，在用户按下按钮后显示操作表，并给用户一组选项进行选择。'
- en: 10.7.2 Example of using ActionSheetIOS
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.2 使用 ActionSheetIOS 的示例
- en: In this example, you’ll create a view with two buttons. One button will call
    `showActionSheetWithOptions`, and the other will call `showShareActionSheetWithOptions`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，你将创建一个包含两个按钮的视图。一个按钮将调用 `showActionSheetWithOptions`，另一个将调用 `showShareActionSheetWithOptions`。
- en: Listing 10.13 Using `ActionSheetIOS` to create action sheets and share sheets
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.13 使用 `ActionSheetIOS` 创建操作表和分享表
- en: '[PRE29]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `showActionSheet` method, you pass in the buttons as the options. Setting
    `cancelButtonIndex` to zero positions Cancel at the bottom of the action sheet.
    The callback method takes the button index as an argument; if the button index
    is greater than 0, the `clicked` state value is set to the new button value. When
    you create the `showShareActionSheetWithOptions` method, you pass in `url` and
    a `message` to share. The first callback function checks to see if there’s an
    error, and the second checks whether success is `true`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `showActionSheet` 方法中，你将按钮作为选项传入。将 `cancelButtonIndex` 设置为零将取消按钮放置在操作表的底部。回调方法接受按钮索引作为参数；如果按钮索引大于
    0，则 `clicked` 状态值设置为新的按钮值。当你创建 `showShareActionSheetWithOptions` 方法时，你将 `url`
    和要分享的 `message` 传入。第一个回调函数检查是否有错误，第二个检查成功是否为 `true`。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: To import cross-platform files, use platform-specific android.js and ios.jsfile
    extensions.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要导入跨平台文件，请使用特定平台的 android.js 和 ios.js 文件扩展名。
- en: To render platform-specific code, use the Platform API.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要渲染特定平台的代码，请使用 Platform API。
- en: Use `DatePickerIOS` to choose and save dates in your app.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DatePickerIOS` 在你的应用中选择和保存日期。
- en: Use `PickerIOS` to render and save values from a list.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PickerIOS` 渲染和保存列表中的值。
- en: Use `ProgressViewIOS` to show loading progress.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ProgressViewIOS` 显示加载进度。
- en: Use `SegmentedControlIOS` to choose from an array of options.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SegmentedControlIOS` 从选项数组中选择。
- en: Use `TabBarIOS` to create and switch between tabs in your app.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TabBarIOS` 在你的应用中创建和切换标签页。
- en: With `ActionSheetIOS`, you can call a native iOS action sheet or share sheet
    in an app.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ActionSheetIOS`，你可以在应用中调用原生 iOS 的操作表或分享表。
- en: '11'
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Implementing Android-specific components and APIs
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 Android 特定组件和 API
- en: '**This chapter covers**'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Using `DrawerLayoutAndroid` to create a side menu
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DrawerLayoutAndroid` 创建侧边菜单
- en: Creating a native toolbar with `ToolbarAndroid`
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ToolbarAndroid` 创建原生工具栏
- en: Create paging views using `ViewPagerAndroid`
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ViewPagerAndroid` 创建分页视图。
- en: Create date/time pickers using `DatePickerAndroid and TimePickerAndroid`
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DatePickerAndroid` 和 `TimePickerAndroid` 创建日期/时间选择器。
- en: Creating toasts using `ToastAndroid`
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ToastAndroid` 创建托盘通知
- en: In this chapter, we’ll implement the most used Android-specific APIs and components,
    discuss their props and methods, and create examples that will mimic functionality
    and logic that will get you up to speed quickly. To see how these work, you’ll
    create a demo app with a menu, a toolbar, scrollable paging, a date picker, and
    a time picker. The app will also implement Android toasts. As you implement each
    of these features, you’ll learn the capabilities of the most commonly used Android-specific
    APIs and components.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现最常用的 Android 特定 API 和组件，讨论它们的属性和方法，并创建示例，这些示例将模仿功能性和逻辑，帮助你快速上手。为了了解这些功能是如何工作的，你将创建一个包含菜单、工具栏、可滚动分页、日期选择器和时间选择器的演示应用。该应用还将实现
    Android 的托盘通知。在实现每个这些功能时，你将学习最常用的 Android 特定 API 和组件的能力。
- en: 11.1 Creating a menu using DrawerLayoutAndroid
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 使用 DrawerLayoutAndroid 创建菜单
- en: To get started, you’ll first create a slide-out menu (see [figure 11.1](#figure11.1)).
    This menu will link to each of the app’s pieces of functionality. It will basically
    serve as a way to navigate between components. You’ll create this menu using the
    `DrawerLayoutAndroid` component.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你首先将创建一个滑动菜单（见[图 11.1](#figure11.1)）。此菜单将链接到应用的每个功能部分。它基本上将作为在组件之间导航的方式。你将使用
    `DrawerLayoutAndroid` 组件创建此菜单。
- en: '![c11_01.tif](Images/c11_01.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![c11_01.tif](Images/c11_01.png)'
- en: '[Figure 11.1](#figureanchor11.1) Initial layout of the application using `DrawerLayoutAndroid`.
    The button at the top in the first screen, Open Drawer, will call a method that
    opens the drawer. The second screen is the opened drawer.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.1](#figureanchor11.1) 使用 `DrawerLayoutAndroid` 的应用程序初始布局。在第一个屏幕顶部的按钮“打开抽屉”将调用一个打开抽屉的方法。第二个屏幕是打开的抽屉。'
- en: 'The first thing to do is create a new Android application. From the command
    line in the folder you’ll be working in, create a new application, replacing `YourApplication`
    in the following command with whatever application name you choose:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是创建一个新的 Android 应用程序。从你将要工作的文件夹中的命令行，创建一个新的应用程序，将以下命令中的 `YourApplication`
    替换为你选择的任何应用程序名称：
- en: '[PRE30]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, create the files you’ll use to create all this functionality. In the
    root of the application, add a folder named app and four files: App.js, Home.js,
    Menu.js, and Toolbar.js.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建你将用于创建所有这些功能的文件。在应用程序的根目录下，添加一个名为 app 的文件夹和四个文件：App.js、Home.js、Menu.js
    和 Toolbar.js。
- en: Now you need to update index.android.js to use your first Android-specific component,
    `DrawerLayoutAndroid`, which is a sliding toolbar from the left side of the screen.
    Edit index.android.js to include and implement this component.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要更新 index.android.js 以使用你的第一个特定于 Android 的组件，`DrawerLayoutAndroid`，这是一个从屏幕左侧滑动的工具栏。编辑
    index.android.js 以包含并实现此组件。
- en: Listing 11.1 Implementing the `DrawerLayoutAndroid` component
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 实现 `DrawerLayoutAndroid` 组件
- en: '[PRE31]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, create the menu you’ll use in the drawer, in app/Menu.js.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 app/Menu.js 中创建你将在抽屉中使用的菜单。
- en: Listing 11.2 Creating the `DrawerLayoutAndroid` menu component
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 创建 `DrawerLayoutAndroid` 菜单组件
- en: '[PRE32]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, in app/App.js, create the following component, which basically takes in
    a `scene` as a prop and returns a component based on the prop.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 app/App.js 中，创建以下组件，它基本上接受一个 `scene` 作为属性并根据属性返回一个组件。
- en: Listing 11.3 Creating the `DrawerLayoutAndroid` App component
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 创建 `DrawerLayoutAndroid` 应用组件
- en: '[PRE33]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now you can start creating components to interact with the menu. For the current
    setup to work, you need to create a `Home` component and a `Toolbar` component.
    Although you’ve seen the imports, you haven’t actually created those components
    yet. In app/Home.js, create the following component, which is a basic introduction
    page.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始创建与菜单交互的组件。为了使当前设置正常工作，你需要创建一个 `Home` 组件和一个 `Toolbar` 组件。尽管你已经看到了导入，但你还没有真正创建这些组件。在
    app/Home.js 中，创建以下组件，这是一个基本的介绍页面。
- en: Listing 11.4 Creating the DrawerLayoutAndroid Home component
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 创建 `DrawerLayoutAndroid` 主组件
- en: '[PRE34]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In app/Toolbar.js, create the following component, which will show that you’re
    in the toolbar by displaying a “Hello from Toolbar” message.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在 app/Toolbar.js 中，创建以下组件，这将通过显示“来自工具栏的问候”消息来表明你处于工具栏中。
- en: Listing 11.5 Creating the DrawerLayoutAndroid Toolbar component
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 创建 `DrawerLayoutAndroid` 工具栏组件
- en: '[PRE35]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Start the application, and you should see the menu shown in figure 11.1.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序，你应该看到图 11.1 所示的菜单。
- en: 11.2 Creating a toolbar with ToolbarAndroid
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用 `ToolbarAndroid` 创建工具栏
- en: With everything set up, let’s add a new component, `ToolbarAndroid`. `ToolbarAndroid`
    is a React Native component that wraps the native Android toolbar. This component
    can display a variety of things, including a title, a subtitle, a log, a navigation
    icon, and action buttons.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一切设置完毕后，让我们添加一个新的组件，`ToolbarAndroid`。`ToolbarAndroid` 是一个 React Native 组件，它包装了原生的
    Android 工具栏。此组件可以显示各种内容，包括标题、副标题、日志、导航图标和操作按钮。
- en: In this example, you’ll implement `ToolbarAndroid` with a title, a subtitle,
    and two actions (Options and Menu; see [figure 11.2](#figure11.2)). When Menu
    is clicked, you’ll trigger the `openDrawer` method, which will open the menu.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，你将使用标题、副标题和两个操作（选项和菜单；参见图 11.2）来实现 `ToolbarAndroid`。当点击菜单时，你将触发 `openDrawer`
    方法，这将打开菜单。
- en: In app/Toolbar.js, update the code as follows to implement the toolbar.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在 app/Toolbar.js 中，按照以下代码更新以实现工具栏。
- en: Listing 11.6 Implementing `ToolbarAndroid`
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 实现 `ToolbarAndroid`
- en: '[PRE36]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When you refresh your device, you should not only see the `ToolbarAndroid` but
    also be able to open the `DrawerLayoutAndroid` menu by pressing the button labeled
    Menu.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刷新你的设备时，你应该不仅看到 `ToolbarAndroid`，还应该能够通过按标有菜单的按钮来打开 `DrawerLayoutAndroid`
    菜单。
- en: '![c11_02.png](Images/c11_02.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![c11_02.png](Images/c11_02.png)'
- en: '[Figure 11.2](#figureanchor11.2) `ToolbarAndroid` with title, subtitle, and
    two actions. This menu is configurable, but you’re only working with the default
    settings in this example.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.2](#figureanchor11.2) 带有标题、副标题和两个操作的 `ToolbarAndroid`。此菜单可配置，但在此示例中你只使用默认设置。'
- en: 11.3 Implementing scrollable paging with ViewPagerAndroid
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用 ViewPagerAndroid 实现可滚动分页
- en: Next, you’ll create a new example page and component using `ViewPagerAndroid`.
    This component allows you to easily swipe left and right between views. Every
    child of `ViewPagerAndroid` is treated as its own separate, swipeable view (see
    [figure 11.3](#figure11.3)).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个新的示例页面和组件，使用 `ViewPagerAndroid`。此组件允许你轻松地在视图之间左右滑动。`ViewPagerAndroid`
    的每个子项都被视为一个独立的、可滑动的视图（见 [图 11.3](#figure11.3)）。
- en: '![c11_03.tif](Images/c11_03.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![c11_03.tif](Images/c11_03.png)'
- en: '[Figure 11.3](#figureanchor11.3) `ViewPagerAndroid` with two child views. When
    you swipe the pages, they scroll left and right to show the next page.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.3](#figureanchor11.3) 带有两个子视图的 `ViewPagerAndroid`。当你滑动页面时，它们左右滚动以显示下一页。'
- en: To get started, create an app/ViewPager.js file and add the code in [listing
    11.7](#listing11.7) to implement the `ViewPagerAndroid` component.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个 app/ViewPager.js 文件并将 [列表 11.7](#listing11.7) 中的代码添加进去以实现 `ViewPagerAndroid`
    组件。
- en: Listing 11.7 Using `ViewPagerAndroid` to enable a scrollable paging view
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 使用 `ViewPagerAndroid` 实现可滚动分页视图
- en: '[PRE37]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, update Menu.js to add the button to view the new component. In Menu.js,
    add this button below the Toolbar Android button:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 Menu.js 以添加按钮以查看新组件。在 Menu.js 中，在 Toolbar Android 按钮下方添加此按钮：
- en: '[PRE38]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, import the new component and update the `switch` statement in App.js
    to render the component.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，导入新组件并更新 App.js 中的 `switch` 语句以渲染组件。
- en: Listing 11.8 App.js with the new `ViewPager` component
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8 包含新 `ViewPager` 组件的 App.js
- en: '[PRE39]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the app. You should see the new ViewPager Android button in the side menu,
    and you can view and interact with the new component.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。你应该在侧菜单中看到新的 ViewPager Android 按钮，并且你可以查看和与之交互的新组件。
- en: 11.4 Using the DatePickerAndroid API to show a native date picker
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 使用 DatePickerAndroid API 显示原生日期选择器
- en: '`DatePickerAndroid` lets you open and interact with the native Android date-picker
    dialog as shown in [figure 11.4](#figure11.4). To open and use the `DatePickerAndroid`
    component, import `DatePickerAndroid` and call `DatePickerAndroid.open()`. To
    get started, create app/DatePicker.js and then the `DatePicker` component in it
    ([listing 11.9](#listing11.9)).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatePickerAndroid` 允许你打开并交互使用原生 Android 日期选择器对话框，如图 11.4 所示。要打开和使用 `DatePickerAndroid`
    组件，导入 `DatePickerAndroid` 并调用 `DatePickerAndroid.open()`。要开始，创建 app/DatePicker.js
    并在其中创建 `DatePicker` 组件（[列表 11.9](#listing11.9)）。'
- en: '![c11_04.tif](Images/c11_04.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![c11_04.tif](Images/c11_04.png)'
- en: '[Figure 11.4](#figureanchor11.4) `DatePickerAndroid` with a button that opens
    the date picker and then shows the selected date in the view'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.4](#figureanchor11.4) 带有打开日期选择器并显示选中日期的视图的按钮的 `DatePickerAndroid`'
- en: Listing 11.9 Implementing a `DatePicker` component
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.9 实现 `DatePicker` 组件
- en: '[PRE40]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that you have the component, update app/App.js to include it.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了这个组件，更新 app/App.js 以包含它。
- en: Listing 11.10 app/App.js with the new `DatePicker` component
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 包含新 `DatePicker` 组件的 app/App.js
- en: '[PRE41]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, update the menu to add the new button that will open the `DatePicker`
    component. In app/Menu.js, add the following button below the `ViewPager` Android
    button:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新菜单以添加将打开 `DatePicker` 组件的新按钮。在 app/Menu.js 中，在 `ViewPager` Android 按钮下方添加以下按钮：
- en: '[PRE42]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 11.5 Creating a time picker with TimePickerAndroid
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 使用 TimePickerAndroid 创建时间选择器
- en: Next up is `TimePickerAndroid`. It’s like `DatePickerAndroid` in that you import
    it and call the `open` method to interact with it. This component brings up a
    time picker dialog that allows you to choose a time and use it in your application
    ([figure 11.5](#figure11.5)).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `TimePickerAndroid`。它与 `DatePickerAndroid` 类似，即你导入它并调用 `open` 方法来与之交互。此组件弹出一个时间选择对话框，允许你选择时间并在你的应用程序中使用它（[图
    11.5](#figure11.5)）。
- en: 'To standardize the time formats, you’ll use a third party library called moment.js.
    To get started with this library, you must first install it. In the root directory
    of the project, install moment using either npm or yarn (your preference—both
    npm and yarn will work exactly the same here):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标准化时间格式，你将使用一个名为 moment.js 的第三方库。要开始使用此库，你必须首先安装它。在项目的根目录中，使用 npm 或 yarn（根据你的喜好——npm
    和 yarn 在这里都将完全相同）安装 moment：
- en: '[PRE43]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: or
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE44]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![c11_05.tif](Images/c11_05.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![c11_05.tif](Images/c11_05.png)'
- en: '[Figure 11.5](#figureanchor11.5) `TimePickerAndroid` with both hour and minute
    views'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.5](#figureanchor11.5) `TimePickerAndroid` 同时显示小时和分钟视图'
- en: Next, in app/TimePicker.js, create the following `TimePicker` component.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在 app/TimePicker.js 中，创建以下 `TimePicker` 组件。
- en: Listing 11.11 `TimePickerAndroid` using moment.js
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.11 使用 moment.js 的 `TimePickerAndroid`
- en: '[PRE45]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, update app/App.js to include the new component.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 app/App.js 以包含新组件。
- en: Listing 11.12 app/App.js with the added `TimePicker` component
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.12 添加 `TimePicker` 组件到 app/App.js
- en: '[PRE46]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, update the menu to add the button that will open the new `TimePicker`
    component. In app/Menu.js, add the following below the DatePicker Android button:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新菜单以添加将打开新 `TimePicker` 组件的按钮。在 app/Menu.js 中，在 DatePicker Android 按钮下方添加以下按钮：
- en: '[PRE47]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 11.6 Implementing Android toasts using ToastAndroid
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 使用 ToastAndroid 实现 Android toasts
- en: '`ToastAndroid` allows you to easily call native Android toasts from a React
    Native application. An Android *toast* is a popup with a message that goes away
    after a given period of time (see [figure 11.6](#figure11.6)). To get started
    building out this component, create app/Toast.js, as shown in the next listing.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToastAndroid` 允许你从 React Native 应用程序中轻松调用原生 Android toasts。Android *toast*
    是一个带有消息的弹出窗口，在给定的时间后消失（见[图 11.6](#figure11.6)）。要开始构建此组件，创建 app/Toast.js，如下所示。'
- en: Listing 11.13 Implementing `ToastAndroid`
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.13 实现 `ToastAndroid`
- en: '[PRE48]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![c11_06.tif](Images/c11_06.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![c11_06.tif](Images/c11_06.png)'
- en: '[Figure 11.6](#figureanchor11.6) `ToastAndroid` with toasts in the default
    and middle positions'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.6](#figureanchor11.6) `ToastAndroid` 在默认和中间位置显示 toasts'
- en: 'The `ToastAndroid.show()` takes two arguments: a message and a length of time
    to show the toast. The time can be either `SHORT` (about 2 seconds) or `LONG`
    (about 4 seconds); this example uses `LONG`. The `ToastAndroid.showWithGravity()`
    method is like `ToastAndroid.show()`, but you can pass it a third argument to
    position the toast at the top, bottom, or center of the view. In this case, you’re
    positioning the toast in the middle of the screen with `ToastAndroid.CENTER` as
    the third argument.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToastAndroid.show()` 方法接受两个参数：一个消息和一个显示 toast 的时间长度。时间可以是 `SHORT`（大约 2 秒）或
    `LONG`（大约 4 秒）；此示例使用 `LONG`。`ToastAndroid.showWithGravity()` 方法类似于 `ToastAndroid.show()`，但你可以传递第三个参数来将
    toast 定位到视图的顶部、底部或中心。在这种情况下，你使用 `ToastAndroid.CENTER` 作为第三个参数将 toast 定位到屏幕中间。'
- en: Now, update app/App.js to include the new component.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新 app/App.js 以包含新组件。
- en: Listing 11.14 Adding the toast component to the app
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.14 向应用程序添加 toast 组件
- en: '[PRE49]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, update the menu to add the new button that will open the toast component.
    In app/Menu.js, add the following button below the TimePicker Android button:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新菜单以添加将打开 toast 组件的新按钮。在 app/Menu.js 中，在 TimePicker Android 按钮下方添加以下按钮：
- en: '[PRE50]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Summary
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can use `DrawerLayoutAndroid` to create the main menu of an application.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `DrawerLayoutAndroid` 创建应用程序的主菜单。
- en: You can use `ToolbarAndroid` to create an interactive app toolbar.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `ToolbarAndroid` 创建一个交互式应用程序工具栏。
- en: You can use `ViewPagerAndroid` to create swipeable views.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `ViewPagerAndroid` 创建可滑动视图。
- en: With `DatePickerAndroid`, you can access the native date picker, allowing you
    to create and manipulate dates in the application.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DatePickerAndroid`，你可以访问原生日期选择器，允许你在应用程序中创建和操作日期。
- en: '`TimePickerAndroid` lets you access the native time picker, making it possible
    to create and manipulate time in the application.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimePickerAndroid` 允许你访问原生时间选择器，使得在应用程序中创建和操作时间成为可能。'
- en: You can easily create native Android toast notifications with`ToastAndroid`.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `ToastAndroid` 轻松创建原生 Android toast 通知。
