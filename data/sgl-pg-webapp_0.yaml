- en: Part 1\. Introducing SPAs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分. 介绍SPA
- en: In the time it takes to read this page, 35 million person minutes will be spent
    waiting for traditional website pages to load. That’s enough spinning icon time
    for the Curiosity Lander to fly to Mars and back 96 times. The productivity cost
    of traditional websites is astonishing, and the cost to a business can be devastating.
    A slow website can drive users away from your site—and into the welcoming wallets
    of smiling competitors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这一页的时间里，将有3500万人分钟的时间被花费在等待传统网站页面加载上。这足以让好奇号飞往火星并返回96次。传统网站的生产力成本令人震惊，对企业来说可能是毁灭性的。一个慢速的网站可能会让用户离开你的网站——并进入那些微笑着欢迎竞争对手的口袋。
- en: 'One reason traditional websites are slow is because popular MVC server frameworks
    are focused on serving page after page of static content to an essentially dumb
    client. When we click a link in a traditional website slideshow, for example,
    the screen flashes white and everything reloads over several seconds: the navigation,
    ads, headlines, text, and footer are all rendered again. Yet the only thing that
    changes is the slideshow image and perhaps the description text. Worse, there’s
    no indicator when some element of the page becomes functional. For example, sometimes
    a link can be clicked as soon as it appears on a web page; other times we have
    to wait until the redrawing is 100% complete plus five seconds. This slow, inconsistent,
    and clunky experience is becoming unacceptable for an increasingly sophisticated
    web consumer.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 传统网站速度慢的一个原因是流行的MVC服务器框架专注于向一个本质上无知的客户端连续提供一页又一页的静态内容。例如，当我们点击传统网站幻灯片中的一条链接时，屏幕会闪白，并在几秒钟内重新加载：导航、广告、标题、文本和页脚都会再次渲染。然而，唯一改变的是幻灯片图片，也许还有描述文本。更糟糕的是，没有指示器表明页面上的某些元素何时变得可用。例如，有时一个链接可以在它出现在网页上时立即点击；而其他时候，我们必须等待重绘完成100%加上五秒钟。这种缓慢、不一致且笨拙的体验对于一个日益复杂的Web消费者来说变得越来越无法接受。
- en: 'Prepare to learn about another—and dare we say better—approach to developing
    web applications, the single page web application (SPA). An SPA delivers a desktop
    application in the browser. The result is a highly responsive experience that
    surprises and delights users instead of confusing and annoying them. In [part
    1](#part01) we learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 准备学习另一种——我们甚至可以说更好的——开发Web应用的方法，即单页Web应用（SPA）。SPA在浏览器中提供桌面应用。结果是高度响应式的体验，它让用户感到惊喜和愉悦，而不是困惑和烦恼。在[第一部分](#part01)中，我们了解到：
- en: What an SPA is and the advantages it provides over traditional websites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是单页应用以及它相较于传统网站的优势
- en: How an SPA approach can make our web application a great deal more responsive
    and compelling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用SPA方法使我们的Web应用变得更加响应和吸引人
- en: How to improve our JavaScript skills for SPA development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提高我们的JavaScript技能以进行SPA开发
- en: How to build an example SPA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建一个示例SPA
- en: Product design is increasingly seen as the decisive factor in the success of
    commercial and enterprise web applications. SPAs are often the best choice to
    provide the optimal user experience. As a result, we expect the demand for user-focused
    design to drive SPA adoption and sophistication.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 产品设计越来越被视为商业和企业级Web应用成功的关键因素。SPA通常是提供最佳用户体验的最佳选择。因此，我们预计以用户为中心的设计需求将推动SPA的采用和复杂化。
- en: Chapter 1\. Our first single page application
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章. 我们的第一个单页应用
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Defining single page web applications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义单页Web应用
- en: Comparing the most popular single page application platforms—Java, Flash, and
    Javascript
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较最流行的单页应用平台——Java、Flash和JavaScript
- en: Writing our first JavaScript single page application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个JavaScript单页应用
- en: Inspecting the application using Chrome Developer Tools
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Chrome开发者工具检查应用
- en: Exploring the user benefits of single page applications
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索单页应用的用户优势
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This book is intended for web developers, architects, and product managers with
    at least a smattering of JavaScript, HTML, and CSS experience. If you’ve never
    even dabbled in web development, this book is *not* for you, although you’re welcome
    to buy it anyway (go ahead, daddy needs a new car). Many books are available that
    do a great job teaching beginner website development and design, but this isn’t
    one of them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书面向至少具备一些JavaScript、HTML和CSS经验的Web开发者、架构师和产品经理。如果你从未涉足过Web开发，这本书**并不适合**你，尽管你仍然可以购买它（快去，爸爸需要一辆新车）。市面上有许多书籍都出色地教授初学者网站开发和设计，但这本书并不属于此类。
- en: This book *does* aspire to be a great guide to designing and building large-scale
    single page web applications [SPAs] using JavaScript end to end. In fact, as [figure
    1.1](#ch01fig01) depicts, we use JavaScript as the language of the database, the
    web server, *and* the browser application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书 *确实* 致力于成为使用 JavaScript 从头到尾设计和构建大规模单页网络应用（SPA）的指南。事实上，正如 [图 1.1](#ch01fig01)
    所描绘的，我们使用 JavaScript 作为数据库、网络服务器 *以及* 浏览器应用的语言。
- en: Figure 1.1\. JavaScript end-to-end
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1\. JavaScript 从头到尾
- en: '![](01fig01_alt.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig01_alt.jpg)'
- en: We’ve spent the last six years leading the development of numerous large-scale
    commercial and enterprise SPAs. During that time we’ve constantly updated our
    practices to meet the challenges we’ve found. We share these practices in this
    book as they have helped us develop faster, provide a better user experience,
    ensure quality, and improve team communication.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在过去六年中一直领导着众多大规模商业和企业级 SPA 的发展。在这段时间里，我们不断更新我们的实践以应对遇到的挑战。我们将这些实践分享在这本书中，因为它们帮助我们更快地开发、提供更好的用户体验、确保质量和改进团队沟通。
- en: 1.1\. Definition, a little history, and some focus
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 定义、一点历史和一些重点
- en: An SPA is an application delivered to the browser that doesn’t reload the page
    during use. Like all applications, it’s intended to help the user complete a task,
    such as “write a document” or “administer a web server.” We can think of an SPA
    as a fat client that’s loaded from a web server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPA）是一种在浏览器中交付的应用，使用过程中不会重新加载页面。像所有应用一样，它的目的是帮助用户完成一项任务，例如“撰写文档”或“管理网络服务器”。我们可以将
    SPA 视为从网络服务器加载的胖客户端。
- en: 1.1.1\. A little history
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. 一点历史
- en: 'SPAs have been around for a long time. Let’s look at some early examples:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPA）已经存在很长时间了。让我们看看一些早期的例子：
- en: '*Tic-Tac-Toe*—[http://rintintin.colorado.edu/~epperson/Java/TicTacToe.html](http://rintintin.colorado.edu/~epperson/Java/TicTacToe.html).
    Hey, we didn’t say this would be pretty. This application challenges us to beat
    a formidable and ruthless computer nemesis in a game of Tic-Tac-Toe. The Java
    plugin is required—see [http://www.java.com/en/download/index.jsp](http://www.java.com/en/download/index.jsp).
    You may have to grant permission for your browser to run this applet.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*井字棋*—[http://rintintin.colorado.edu/~epperson/Java/TicTacToe.html](http://rintintin.colorado.edu/~epperson/Java/TicTacToe.html)。嘿，我们并没有说这会很好看。这个应用挑战我们与一个强大而冷酷的电脑对手在井字棋游戏中一较高下。需要
    Java 插件——请参阅 [http://www.java.com/en/download/index.jsp](http://www.java.com/en/download/index.jsp)。您可能需要授予浏览器运行此小程序的权限。'
- en: '*Flash Spacelander*—[http://games.whomwah.com/spacelander.html](http://games.whomwah.com/spacelander.html).
    This is one of the earlier Flash games, written by Duncan Robertson circa 2001\.
    The Flash plugin is required—see [http://get.adobe.com/flashplayer/](http://get.adobe.com/flashplayer/).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Flash 空间人*—[http://games.whomwah.com/spacelander.html](http://games.whomwah.com/spacelander.html)。这是
    Duncan Robertson 大约在 2001 年编写的一个早期 Flash 游戏。需要 Flash 插件——请参阅 [http://get.adobe.com/flashplayer/](http://get.adobe.com/flashplayer/)。'
- en: '*JavaScript mortgage calculator*—[http://www.mcfedries.com/creatingawebpage/mortgage.htm](http://www.mcfedries.com/creatingawebpage/mortgage.htm).
    This calculator seems almost as old as JavaScript itself, but it works nicely.
    *No plugin is required.*'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript 贷款计算器*—[http://www.mcfedries.com/creatingawebpage/mortgage.htm](http://www.mcfedries.com/creatingawebpage/mortgage.htm)。这个计算器似乎和
    JavaScript 一样古老，但它运行得很好。*不需要插件。*'
- en: 'The astute reader—and even a few slovenly ones^([[1](#ch01fn01)])—will notice
    that we’ve provided examples of three of the most popular SPA platforms: Java
    applets, Flash/Flex, and JavaScript. And those same readers may have noticed that
    *only the JavaScript SPA works without the overhead or security concerns of a
    third-party plugin.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 精明的读者——甚至是一些粗心大意的读者^([[1](#ch01fn01)])——会注意到我们提供了三个最受欢迎的单页应用（SPA）平台的例子：Java
    小程序、Flash/Flex 和 JavaScript。同样的读者可能还会注意到，*只有 JavaScript SPA 在使用过程中不需要第三方插件的额外开销或安全担忧。*
- en: ¹ If you’re reading this chapter as you eat potato chips off your chest, you’re
    slovenly.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 如果您在吃胸前的薯片时阅读这一章，您就是粗心大意的。
- en: Today, JavaScript SPAs are often the best choice of the three. But JavaScript
    took a while to become competitive, or even possible, for most SPA uses. Let’s
    take a look at why.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，JavaScript SPA 通常是最好的选择之一。但 JavaScript 在大多数 SPA 应用中需要一段时间才能变得具有竞争力，甚至变得可行。让我们看看为什么。
- en: 1.1.2\. What took JavaScript SPAs so long?
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 为什么 JavaScript SPA 用了这么久才出现？
- en: 'Flash and Java applets had evolved nicely by the year 2000\. Java was being
    used to deliver complex applications and even a complete office suite via the
    browser.^([[2](#ch01fn02)]) Flash had become the platform of choice for delivering
    rich browser games and, later, video. On the other hand, JavaScript was still
    mostly relegated to little more than mortgage calculators, form validation, roll-over
    effects, and pop-up windows. The problem was that we couldn’t rely on JavaScript
    (or the rendering methods it used) to provide critical capabilities consistently
    on popular browsers. Even so, JavaScript SPAs promised a number of enticing advantages
    over Flash and Java:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Flash和Java小程序到2000年已经发展得很好。Java被用来通过浏览器提供复杂的应用程序，甚至是一个完整的办公套件.^([[2](#ch01fn02)])
    Flash已经成为提供丰富浏览器游戏和后来视频的平台。另一方面，JavaScript仍然主要被限制在抵押贷款计算器、表单验证、悬停效果和弹出窗口等小应用中。问题是，我们无法依赖JavaScript（或它使用的渲染方法）在流行的浏览器上提供一致的关键功能。尽管如此，JavaScript
    SPA承诺在Flash和Java之上提供许多诱人的优势：
- en: ² Applix (VistaSource) Anywhere Office
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² Applix (VistaSource) Anywhere Office
- en: '*No plugin required*—Users access the application without concern for plugin
    installation, maintenance, and OS compatibility. Developers also don’t need to
    worry about a separate security model, which reduces development and maintenance
    headaches.^([[3](#ch01fn03)])'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无需插件*—用户无需担心插件的安装、维护和操作系统兼容性问题即可访问应用程序。开发者也不必担心单独的安全模型，这可以减少开发和维护的烦恼.^([[3](#ch01fn03)])'
- en: ³ Can you say “same origin policy”? If you’ve ever developed in Flash or Java,
    you almost certainly are familiar with this challenge.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 你能说出“同源策略”吗？如果你曾经用Flash或Java进行过开发，你几乎肯定熟悉这个挑战。
- en: '*Less bloat*—An SPA using JavaScript and HTML should use significantly fewer
    resources than a plugin that requires an additional run-time environment.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少冗余*—使用JavaScript和HTML的SPA应该比需要额外运行时环境的插件使用显著更少的资源。'
- en: '*One client language*—Web architects and most developers have to know many
    languages and data formats—HTML, CSS, JSON, XML, JavaScript, SQL, PHP/ Java/Ruby/Perl,
    and so on. Why write applets in Java, or Flash applications in ActionScript, when
    we’re already using JavaScript elsewhere on our pages? Using a single programming
    language for everything on the client is a great way to reduce complexity.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单一客户端语言*—网络架构师和大多数开发者必须了解许多语言和数据格式—HTML、CSS、JSON、XML、JavaScript、SQL、PHP/Java/Ruby/Perl等等。为什么要在我们的页面上用Java编写小程序，或者用ActionScript编写Flash应用程序，当我们已经在其他地方使用JavaScript呢？在客户端使用单一编程语言是一种减少复杂性的好方法。'
- en: '*A more fluid and interactive page*—We’ve all seen a Flash or Java application
    on a web page. Often the application is displayed in a box somewhere and many
    details are different than the HTML elements that surround it: the graphical widgets
    are different, the right-click is different, the sounds are different, and interaction
    with the rest of the page is limited. With a JavaScript SPA, the entire browser
    window is the application interface.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更流畅和互动的页面*—我们都见过网页上的Flash或Java应用程序。通常，应用程序显示在某个地方的框中，许多细节与围绕它的HTML元素不同：图形小部件不同，右键单击不同，声音不同，与页面的其他部分的交互有限。使用JavaScript
    SPA，整个浏览器窗口就是应用程序界面。'
- en: 'As JavaScript has matured, most of its weaknesses have been either fixed or
    mitigated and its advantages have increased in value:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript的成熟，其大多数弱点要么已被修复，要么得到了缓解，其优势的价值也增加了：
- en: '*The web browser is the world’s most widely used application*—Many people have
    a browser window always open and use it throughout the day. Access to a JavaScript
    application is one more bookmark click away.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网页浏览器是世界上最广泛使用的应用程序*—许多人始终打开浏览器窗口，并全天使用它。访问JavaScript应用程序只需多点击一个书签即可。'
- en: '*JavaScript in the browser is one of the world’s most widely distributed execution
    environments*—By December 2011, nearly one million Android and iOS mobile devices
    were being activated every day. Each of these devices has a robust JavaScript
    execution environment built into the OS. More than one billion robust JavaScript
    implementations have shipped in the last three years on phone, tablet, laptop,
    and desktop computers around the world.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浏览器中的JavaScript是全球最广泛分布的执行环境之一*—到2011年12月，每天有近一百万台Android和iOS移动设备被激活。这些设备都内置了强大的JavaScript执行环境。在过去三年中，全球已发货超过十亿的强大JavaScript实现，这些实现被用于手机、平板电脑、笔记本电脑和台式计算机。'
- en: '*Deployment of JavaScript is trivial*—A JavaScript application can be made
    available to more than a billion web users by hosting it on an HTTP server.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript 的部署非常简单*——一个 JavaScript 应用程序可以通过托管在 HTTP 服务器上，向超过十亿的网页用户提供服务。'
- en: '*JavaScript is useful for cross-platform development*—Now we can create SPAs
    using Windows, Mac OS X, or Linux, and we can deploy a single application not
    only to all desktop machines but also to tablets and smart phones. We can thank
    converging implementations of standards across browsers, and mature libraries
    such as jQuery and PhoneGap that smooth over inconsistencies.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript 对于跨平台开发非常有用*——现在我们可以使用 Windows、Mac OS X 或 Linux 创建 SPAs，并且我们可以将单个应用程序部署到所有桌面机器上，以及平板电脑和智能手机。我们可以感谢浏览器之间标准实现的趋同，以及像
    jQuery 和 PhoneGap 这样的成熟库，它们平滑了不一致性。'
- en: '*JavaScript has become surprisingly fast and can, at times, rival compiled
    languages*—Its speedup is thanks to ongoing and heated competition between Mozilla
    Firefox, Google Chrome, Opera, and Microsoft. Modern JavaScript implementations
    enjoy advanced optimizations such as JIT compilation to native machine code, branch
    prediction, type-inference, and multi-threading.^([[4](#ch01fn04)])'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript 意外地快，有时甚至可以与编译型语言相媲美*——其加速得益于 Mozilla Firefox、Google Chrome、Opera
    和 Microsoft 之间持续的激烈竞争。现代 JavaScript 实现享受着高级优化，如 JIT 编译到原生机器代码、分支预测、类型推断和多线程.^([[4](#ch01fn04)])'
- en: ⁴ See [http://iq12.com/blog/as3-benchmark/](http://iq12.com/blog/as3-benchmark/)
    and [http://jacksondunstan.com/articles/1636](http://jacksondunstan.com/articles/1636)
    for some comparisons to Flash ActionScript 3.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 请参阅 [http://iq12.com/blog/as3-benchmark/](http://iq12.com/blog/as3-benchmark/)
    和 [http://jacksondunstan.com/articles/1636](http://jacksondunstan.com/articles/1636)，了解与
    Flash ActionScript 3 的比较。
- en: '*JavaScript has evolved to include advanced features*—These features include
    the JSON native object, native jQuery-style selectors, and more consistent AJAX
    capabilities. Push messaging has become far easier with mature libraries like
    Strophie and Socket.IO.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript 已经发展出了高级功能*——这些功能包括原生 JSON 对象、原生 jQuery 风格的选择器以及更一致的 AJAX 功能。使用成熟的库如
    Strophe 和 Socket.IO，推送消息变得容易得多。'
- en: '*HTML5, SVG, and CSS3 standards and support have advanced*—These advancements
    allow for the rendering of pixel-perfect graphics that can rival the speed and
    quality produced by Java or Flash.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HTML5、SVG 和 CSS3 标准和支持已经取得了进步*——这些进步使得可以渲染出像素级的图形，其速度和质量可以与 Java 或 Flash 相媲美。'
- en: '*JavaScript can be used throughout a web project*—Now we can use the excellent
    Node.js web server and data stores such as CouchDB or MongoDB, both of which communicate
    in JSON, a JavaScript data format. We can even share libraries between the server
    and the browser.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript 可以在整个 Web 项目中使用*——现在我们可以使用出色的 Node.js Web 服务器和像 CouchDB 或 MongoDB
    这样的数据存储，它们都使用 JSON，这是一种 JavaScript 数据格式。我们甚至可以在服务器和浏览器之间共享库。'
- en: '*Desktop, laptop, and even mobile devices have become more powerful*—The ubiquity
    of multi-core processors and gigabytes of RAM means processing that used to be
    accomplished on the server can now be distributed to the client browsers.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*桌面、笔记本电脑甚至移动设备都变得更加强大*——多核处理器的普遍性和数 GB 的 RAM 意味着以前在服务器上完成的处理现在可以分配到客户端浏览器。'
- en: JavaScript SPAs are becoming increasingly popular due to these advantages, and
    the demand for experienced JavaScript developers and architects has blossomed.
    Applications that were once developed for many operating systems (or for Java
    or Flash) are now delivered as a single JavaScript SPA. Startups have embraced
    Node.js as the web server of choice, and mobile application developers are using
    JavaScript and PhoneGap to create “native” applications for multiple mobile platforms
    using a single code base.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些优势，JavaScript SPAs 正变得越来越受欢迎，对经验丰富的 JavaScript 开发人员和架构师的需求也在不断增长。曾经为许多操作系统（或
    Java 或 Flash）开发的应用程序现在正以单个 JavaScript SPA 的形式交付。初创公司已经将 Node.js 作为首选的 Web 服务器，而移动应用开发者正在使用
    JavaScript 和 PhoneGap，通过单一代码库为多个移动平台创建“原生”应用程序。
- en: JavaScript isn’t perfect, and we don’t have to look far to find omissions, inconsistencies,
    and other aspects to dislike. But this is true of all languages. Once you become
    comfortable with its core concepts, employ best practices, and learn what parts
    to avoid, JavaScript development can be pleasant and productive.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 并不完美，我们不必走得太远就能找到遗漏、不一致和其他不喜欢的方面。但这是所有语言的共性。一旦你熟悉了其核心概念，遵循最佳实践，并了解哪些部分需要避免，JavaScript
    开发可以变得愉快且富有成效。
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Generated JavaScript: One destination, two paths**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成的 JavaScript：一个目的地，两条路径**'
- en: 'We’ve found it easier to develop SPAs using JavaScript directly. We call these
    *native* JavaScript SPAs. Another surprisingly popular approach is to use *generated*
    JavaScript, where developers write code in another language which is then converted
    to JavaScript. This conversion occurs either at runtime or during a separate generation
    stage. Notable JavaScript generators include:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现直接使用JavaScript开发SPA更容易。我们称之为*原生*JavaScript SPA。另一种出人意料地受欢迎的方法是使用*生成*JavaScript，其中开发者用另一种语言编写代码，然后将其转换为JavaScript。这种转换发生在运行时或单独的生成阶段。显著的JavaScript生成器包括：
- en: '*Google Web Toolkit (GWT)*—See [http://code.google.com/webtoolkit/](http://code.google.com/webtoolkit/).
    GWT generates JavaScript from Java.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Web Toolkit (GWT)*—见[http://code.google.com/webtoolkit/](http://code.google.com/webtoolkit/)。GWT将Java代码生成JavaScript。'
- en: '*Cappuccino*—See [http://cappuccino.org/](http://cappuccino.org/). Cappuccino
    uses Objective-J, a clone of the Objective-C language from Mac OS X. Cappuccino
    itself is a port of the Cocoa application framework, again from OS X.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cappuccino*—见[http://cappuccino.org/](http://cappuccino.org/)。Cappuccino使用Objective-J，这是Mac
    OS X中Objective-C语言的克隆。Cappuccino本身是Cocoa应用程序框架的移植，同样来自OS X。'
- en: '*CoffeeScript*—See [http://coffeescript.org/](http://coffeescript.org/). CoffeeScript
    turns a custom language that provides some syntactic sugar into JavaScript.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CoffeeScript*—见[http://coffeescript.org/](http://coffeescript.org/)。CoffeeScript将一种提供一些语法糖的自定义语言转换为JavaScript。'
- en: 'Given that Google uses GWT for Blogger, Google Groups, and many other sites,
    we can safely say that generated JavaScript SPAs are widely used. This raises
    the question: *why bother writing in one high-level language and then converting
    it to another*? Here are a number of reasons generated JavaScript remains popular,
    and why these reasons aren’t as compelling as they once were:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于谷歌使用GWT（Google Web Toolkit）为Blogger、Google Groups以及许多其他网站提供服务，我们可以安全地说，生成的JavaScript
    SPA被广泛使用。这引发了一个问题：*为什么要在一种高级语言中编写代码，然后再将其转换为另一种语言*？以下是一些生成JavaScript仍然受欢迎的原因，以及为什么这些原因不像以前那样有说服力：
- en: '*Familiarity*—The developers can use a more familiar or simpler language. The
    generator and framework allows them to develop without having to learn the vagaries
    of JavaScript. The problem is that something eventually gets lost in translation.
    When this happens, the developers have to inspect the generated JavaScript and
    understand it to get things to work right. We feel we’re more effective when we
    work directly in JavaScript instead of working through a language abstraction
    layer.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*熟悉性*—开发者可以使用更熟悉或更简单的语言。生成器和框架允许他们在不学习JavaScript的复杂性情况下进行开发。问题是，翻译过程中最终会丢失一些东西。当这种情况发生时，开发者必须检查生成的JavaScript并理解它，以便正确地完成工作。我们觉得直接在JavaScript中工作比通过语言抽象层工作更有效。'
- en: '*Framework*—The developers appreciate that GWT provides the cohesive system
    of matching libraries built for server and client. This is a persuasive argument,
    particularly if the team already has a lot of expertise and products that are
    in production.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*框架*—开发者欣赏GWT提供的为服务器和客户端构建的匹配库的统一系统。这是一个有说服力的论点，尤其是如果团队已经拥有大量专业知识和正在生产中的产品。'
- en: '*Multiple targets*—The developers can have the generator write for multiple
    targets, such as one file for Internet Explorer and one for the rest of the world’s
    browsers. Although generating code for different targets sounds nice, we think
    it’s even more effective to deploy a single JavaScript source for all browsers.
    Thanks to converging browser implementations and mature cross-browser libraries
    like jQuery, it’s now much easier to write a sophisticated SPA that runs across
    all major browsers without modification.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多个目标*—开发者可以让生成器为多个目标编写代码，例如为Internet Explorer编写一个文件，为世界上其他浏览器编写另一个文件。虽然为不同的目标生成代码听起来不错，但我们认为部署单一JavaScript源代码给所有浏览器使用更为有效。多亏了浏览器实现的趋同以及成熟的跨浏览器库如jQuery，现在编写一个无需修改即可在所有主要浏览器上运行的复杂SPA（单页应用）变得容易得多。'
- en: '*Maturity*—The developers consider JavaScript insufficiently structured for
    large-scale application development. Yet JavaScript has evolved to become a much
    better language, with impressive strengths and manageable weaknesses. Developers
    from strongly typed languages like Java sometimes feel the lack of type safety
    is unforgivable. And some developers from inclusive frameworks like Ruby on Rails
    bemoan the apparent lack of structure. Thankfully, we can mitigate these issues
    through a combination of code validation tools, code standards, and the use of
    mature libraries.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*成熟度*——开发者认为JavaScript在大型应用开发中结构不足。然而，JavaScript已经发展成为一个更好的语言，具有令人印象深刻的优点和可管理的缺点。来自强类型语言（如Java）的开发者有时会感到缺乏类型安全是不可原谅的。而一些来自包容性框架（如Ruby
    on Rails）的开发者则哀叹明显的结构缺失。幸运的是，我们可以通过代码验证工具、代码标准和成熟库的使用来缓解这些问题。'
- en: We believe native JavaScript SPAs are usually the better choice today. And that’s
    what we design and build in this book.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为原生JavaScript SPA通常是今天更好的选择。这正是我们在本书中设计和构建的内容。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.1.3\. Our focus
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 我们的关注点
- en: This book shows how to develop engaging, robust, scalable, and maintainable
    SPAs using JavaScript end to end.^([[5](#ch01fn05)]) Unless otherwise noted, when
    we refer to an SPA from this point forward, we mean a *native* JavaScript SPA,
    where the business and presentation logic is written directly in JavaScript and
    executed by the browser. This JavaScript renders the interface using browser technologies
    such as HTML5, CSS3, Canvas, or SVG.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本书展示了如何使用JavaScript从头到尾开发引人入胜、健壮、可扩展和可维护的单页应用程序（SPAs）。^([[5](#ch01fn05)]) 除非另有说明，从现在起当我们提到SPA时，我们指的是原生JavaScript
    SPA，其中业务和表示逻辑直接用JavaScript编写并由浏览器执行。这种JavaScript使用HTML5、CSS3、Canvas或SVG等技术渲染界面。
- en: ⁵ Another title for this book might have been *Building Single Page Web Applications
    Using Best Practices*. But that seemed too wordy.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 这本书的另一个标题可能是 *使用最佳实践构建单页Web应用程序*。但这样似乎太冗长了。
- en: SPAs can use any number of server technologies. Because so much of the web application
    moves to the browser, the server requirements are often significantly reduced.
    [Figure 1.2](#ch01fig02) illustrates how the business logic and generation of
    HTML migrates from the server to the client.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SPAs可以使用任何数量的服务器技术。由于大量网络应用迁移到浏览器，服务器需求通常显著减少。[图1.2](#ch01fig02)说明了业务逻辑和HTML生成如何从服务器迁移到客户端。
- en: Figure 1.2\. Responsibilities of the database, server, and client
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. 数据库、服务器和客户端的责任
- en: '![](01fig02_alt.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig02_alt.jpg)'
- en: We focus on the backend in [chapters 7](kindle_split_019.html#ch07) and [8](kindle_split_020.html#ch08),
    where we use a web server and database with JavaScript as their control languages.
    You may not have this choice or may prefer a different backend. That’s okay—most
    of the SPA concepts and techniques we use in this book work well regardless of
    what backend technologies you use. But if you want to use JavaScript end-to-end,
    we’ve got you covered.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](kindle_split_019.html#ch07)和[第8章](kindle_split_020.html#ch08)中关注后端，在那里我们使用JavaScript作为控制语言的网络服务器和数据库。你可能没有这样的选择，或者可能更喜欢不同的后端。没关系——本书中使用的绝大多数SPA概念和技术无论你使用什么后端技术都能很好地工作。但如果你想要使用端到端的JavaScript，我们为你提供了解决方案。
- en: Our client libraries include jQuery for DOM manipulation with plugins for history
    management and event handling. We use TaffyDB2 to provide high-performance, data-centric
    models. Socket.IO provides seamless near-real-time messaging between the web server
    and the client. On the server, we use Node.js for our event-based web server.
    Node.js uses the Google V8 JavaScript engine and excels at handling tens of thousands
    of concurrent connections. We also use Socket.IO on the web server. Our database
    is MongoDB, a noSQL database that uses the JavaScript native data format, JSON,
    to store data and also has a JavaScript API and command-line interface. All of
    these are proven and popular solutions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端库包括用于DOM操作的jQuery，以及用于历史管理和事件处理的插件。我们使用TaffyDB2提供高性能、以数据为中心的模型。Socket.IO在Web服务器和客户端之间提供无缝的近实时消息传递。在服务器上，我们使用Node.js作为基于事件的网络服务器。Node.js使用Google
    V8 JavaScript引擎，擅长处理数万个并发连接。我们还在Web服务器上使用Socket.IO。我们的数据库是MongoDB，这是一个使用JavaScript原生数据格式JSON存储数据的NoSQL数据库，它还具有JavaScript
    API和命令行界面。所有这些都是经过验证且流行的解决方案。
- en: SPA development requires JavaScript coding at a scale at least an order of magnitude
    greater than a traditional website, as much of the application logic moves from
    the server to the browser. The development of a single SPA may require many developers
    to code concurrently and may result in well over 100,000 lines of code. Conventions
    and discipline previously reserved for server-side development become a must for
    working at this scale. On the other hand, the server software is simplified and
    relegated to authentication, validation, and data services. Keep this in mind
    as we proceed through our examples.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的网站相比，SPA开发需要更大规模的JavaScript编码，因为大部分应用程序逻辑从服务器移动到浏览器。单个SPA的开发可能需要许多开发者同时编码，并可能导致超过10万行代码。以前为服务器端开发保留的惯例和纪律现在在这个规模上变得必不可少。另一方面，服务器软件被简化，并降级为身份验证、验证和数据服务。在我们继续举例时，请记住这一点。
- en: 1.2\. Build our first SPA
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 构建我们的第一个SPA
- en: It’s now time to develop an SPA. We’ll use best practices and explain them as
    we go.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开发一个SPA了。我们将使用最佳实践，并在进行中解释它们。
- en: 1.2.1\. Define the goal
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. 定义目标
- en: Our first SPA will have the modest goal of providing a chat slider at the bottom
    right of the browser window, similar to one you might see on Gmail or Facebook.
    When we load the application, the slider will be retracted; when we click on the
    slider, it’ll extend, as shown in [figure 1.3](#ch01fig03). Clicking again will
    retract it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个SPA的目标是提供一个位于浏览器窗口右下角的聊天滑块，类似于你在Gmail或Facebook上可能看到的一个。当我们加载应用程序时，滑块将被收起；当我们点击滑块时，它将展开，如图1.3所示。再次点击将收起它。
- en: Figure 1.3\. The chat slider retracted and extended
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. 聊天滑块的收起和展开
- en: '![](01fig03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig03.jpg)'
- en: SPAs usually do many other things besides opening and closing a chat slider—like
    sending and receiving chat messages. We’ll omit such pesky details to keep this
    introduction relatively simple and brief. To pervert a famous saying, one can’t
    conquer SPAs in a day. Fear not, we’ll return to sending and retrieving messages
    in [chapters 6](kindle_split_017.html#ch06) and [8](kindle_split_020.html#ch08).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SPAs通常除了打开和关闭聊天滑块之外，还会做许多其他事情——比如发送和接收聊天消息。为了使这个介绍相对简单和简短，我们将省略这些烦人的细节。用一句名言来歪曲，一天之内是无法征服SPAs的。不必担心，我们将在第6章和第8章中回到发送和检索消息。
- en: In the next few sections, we’ll set up a file for SPA development, introduce
    some of our favorite tools, develop the code for the chat slider, and highlight
    some best practices. We’ve given you a lot to absorb here, and you’re not expected
    to understand everything right now—particularly some of the JavaScript tricks
    we’re using. We’ll have a lot more to say about each of these topics in the next
    few chapters, but for now, relax, don’t sweat the small stuff, and take in the
    lay of the land.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将为SPA开发设置一个文件，介绍一些我们最喜欢的工具，开发聊天滑块的代码，并强调一些最佳实践。我们在这里给了你很多要吸收的东西，并不期望你现在就能理解一切——尤其是我们使用的某些JavaScript技巧。在接下来的几章中，我们将对每个这些主题有更多要说的，但现在，放松，不要为小事烦恼，了解这片土地的情况。
- en: 1.2.2\. Start the file structure
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. 开始文件结构
- en: 'We’ll create our application in a single file, spa.html, using only jQuery
    as our one external library. Usually, it’s better to have separate files for CSS
    and JavaScript, but starting with a single file is handy for development and examples.
    We start by defining where we’ll place our styles and our JavaScript. We’ll also
    add a `<div>` container where our application will write HTML entities, as shown
    in [listing 1.1](#ch01list01):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个文件spa.html中创建我们的应用程序，只使用jQuery作为我们的一个外部库。通常，最好为CSS和JavaScript使用单独的文件，但从一个文件开始对于开发和示例来说很方便。我们首先定义我们将放置样式和JavaScript的位置。我们还将添加一个`<div>`容器，我们的应用程序将在这里写入HTML实体，如图1.1所示：
- en: Listing 1.1\. A toe in the pool—spa.html
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.1\. 浅尝辄止——spa.html
- en: '![](010fig01_alt.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](010fig01_alt.jpg)'
- en: Now that we have the file ready, let’s set up Chrome Developer Tools to inspect
    the application in its current state.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了准备好的文件，让我们设置Chrome开发者工具来检查应用程序的当前状态。
- en: 1.2.3\. Set up Chrome Developer Tools
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 设置Chrome开发者工具
- en: Let’s use Google Chrome to open our listing—spa.html. We should see a blank
    browser window, because we haven’t added any content. But activities *are* going
    on under the hood. Let’s use Chrome Developer Tools to inspect them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Google Chrome打开我们的列表——spa.html。我们应该看到一个空白的浏览器窗口，因为我们还没有添加任何内容。但是，在幕后正在进行活动。让我们使用Chrome开发者工具来检查它们。
- en: We can open Chrome Developer Tools by clicking on the wrench in the upper-right
    corner of Chrome, selecting Tools, and then Developer Tools (Menu > Tools > Developer
    Tools). This will display the Developer Tools, as shown in [figure 1.4](#ch01fig04).
    If we don’t see the JavaScript console, we can display it by clicking on the Activate
    console button at the bottom left. The console should be blank, which means we
    have no JavaScript warnings or errors. This is good, because currently we have
    no JavaScript. The Elements section above the console shows the HTML and structure
    of our page.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击 Chrome 右上角的扳手图标，选择工具，然后开发者工具（菜单 > 工具 > 开发者工具）来打开 Chrome 开发者工具。这将显示开发者工具，如图
    1.4 所示。如果我们看不到 JavaScript 控制台，我们可以通过点击左下角的激活控制台按钮来显示它。控制台应该是空的，这意味着我们没有 JavaScript
    警告或错误。这是好的，因为我们目前没有 JavaScript。控制台上方的元素部分显示了我们的页面 HTML 和结构。
- en: Figure 1.4\. Google Chrome Developer Tools
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. Google Chrome 开发者工具
- en: '![](01fig04_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig04_alt.jpg)'
- en: Although we use Chrome Developer Tools here and throughout the book, other browsers
    have similar capabilities. Firefox, for example, has Firebug, and both IE and
    Safari provide their own version of Developer Tools.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本书中使用了 Chrome 开发者工具，但其他浏览器也有类似的功能。例如，Firefox 有 Firebug，而 IE 和 Safari 都提供了自己的开发者工具版本。
- en: When we present listings in this book, we’ll often use the Chrome Developer
    Tools to ensure our HTML, CSS, and JavaScript all play nicely together. Now let’s
    create our HTML and CSS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本书中呈现列表时，我们通常会使用 Chrome 开发者工具来确保我们的 HTML、CSS 和 JavaScript 都能很好地协同工作。现在让我们创建我们的
    HTML 和 CSS。
- en: 1.2.4\. Develop the HTML and CSS
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.4\. 开发 HTML 和 CSS
- en: 'We’ll need to add a single chat slider container to our HTML. Let’s begin by
    styling the containers in the `<style>` section in the spa.html file. The adjustments
    to the `<style>` section are shown in the following listing:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 HTML 中添加一个单独的聊天滑块容器。让我们从在 spa.html 文件的 `<style>` 部分中设置容器样式开始。以下列表显示了 `<style>`
    部分的调整：
- en: Listing 1.2\. HTML and CSS—spa.html
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.2\. HTML 和 CSS—spa.html
- en: '![](ch01list02-0.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](ch01list02-0.jpg)'
- en: '![](ch01list02-1.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](ch01list02-1.jpg)'
- en: When we open spa.html in our browser, we should see the slider retracted, as
    shown in [figure 1.5](#ch01fig05). We’re using a liquid layout where the interface
    adapts to the display size and the slider always stays anchored at the bottom-right
    corner. We didn’t add any borders to our containers because they add to container
    width and can impede development, as we have to resize containers to accommodate
    those borders. It’s handy to add borders after the basic layout is created and
    verified, as we do in later chapters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中打开 spa.html 时，我们应该看到滑块收起，如图 1.5 所示。我们使用的是液体布局，其中界面适应显示大小，滑块始终锚定在右下角。我们没有为我们的容器添加边框，因为它们会增加容器宽度，可能会阻碍开发，因为我们必须调整容器大小以适应这些边框。在创建和验证基本布局之后添加边框很方便，就像我们在后面的章节中所做的那样。
- en: Figure 1.5\. Chat slider retracted—spa.html
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. 聊天滑块收起—spa.html
- en: '![](01fig05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig05.jpg)'
- en: Now that we have the visual elements in place, it’s time to use JavaScript to
    make the page interactive.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了视觉元素，是时候使用 JavaScript 使页面交互了。
- en: 1.2.5\. Add the JavaScript
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.5\. 添加 JavaScript
- en: We want to employ best practices with our JavaScript. One tool that will help
    is *JSLint*, written by Douglas Crockford. JSLint is a JavaScript validator that
    ensures that our code doesn’t break many sensible JavaScript best practices. And
    we also want to use *jQuery*, a Document Object Model (DOM) toolkit written by
    John Resig. jQuery provides simple cross-browser tools to easily implement the
    slider animation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在我们的 JavaScript 中采用最佳实践。一个将有所帮助的工具是 Douglas Crockford 编写的 *JSLint*。JSLint
    是一个 JavaScript 验证器，确保我们的代码不会违反许多合理的 JavaScript 最佳实践。我们还希望使用 *jQuery*，这是由 John
    Resig 编写的文档对象模型 (DOM) 工具包。jQuery 提供了简单的跨浏览器工具，可以轻松实现滑块动画。
- en: 'Before we get into writing the JavaScript, let’s outline what we want to do.
    Our first script tag will load the jQuery library. Our second script tag will
    contain *our* JavaScript which we’ll break into three parts:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写 JavaScript 之前，让我们概述一下我们想要做什么。我们的第一个脚本标签将加载 jQuery 库。我们的第二个脚本标签将包含 *我们的*
    JavaScript，我们将将其分为三个部分：
- en: A header that declares our JSLint settings.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个声明我们 JSLint 设置的标题。
- en: A function called `spa` that creates and manages the chat slider.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为 `spa` 的函数，用于创建和管理聊天滑块。
- en: A line to start the `spa` function once the browser’s Document Object Model
    (DOM) is ready.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一条在浏览器文档对象模型 (DOM) 准备就绪时启动 `spa` 函数的行。
- en: 'Let’s take a closer look at what we need the `spa` function to do. We know
    from experience that we’ll want a section where we declare our module variables
    and include configuration constants. We’ll need a function that toggles the chat
    slider. And we’ll need a function that receives the user click event and calls
    the toggle function. Finally, we’ll need a function that initializes the application
    state. Let’s sketch an outline in more detail:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `spa` 函数需要做什么。根据经验，我们知道我们想要一个声明模块变量和包含配置常数的部分。我们需要一个切换聊天滑块的功能。我们还需要一个接收用户点击事件并调用切换函数的功能。最后，我们需要一个初始化应用程序状态的功能。让我们更详细地绘制一个大纲：
- en: Listing 1.3\. JavaScript development, first pass—spa.html
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.3\. JavaScript 开发，第一次遍历——spa.html
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a good start! Let’s keep the comments just as they are and add our code.
    We have kept the comments in bold for clarity.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个良好的开始！让我们保持注释不变，并添加我们的代码。我们为了清晰起见，将注释用粗体表示。
- en: Listing 1.4\. Javascript development, second pass—spa.html
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.4\. JavaScript 开发，第二次遍历——spa.html
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let’s make a final pass at spa.html as shown in [listing 1.5](#ch01list05).
    We load the jQuery library and then we include our own JavaScript, which has our
    JSLint settings, our `spa` module, and a line to start the module once the DOM
    is ready. The `spa` module is now fully functional. Don’t worry if you don’t “get”
    everything right away—there’s lots to take in here, and we’ll be covering everything
    in more detail in upcoming chapters. This is just an example to show you what
    can be done:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次审视 spa.html，如 [列表 1.5](#ch01list05) 所示。我们加载 jQuery 库，然后包含我们自己的 JavaScript，其中包含我们的
    JSLint 设置、`spa` 模块以及一条在 DOM 准备就绪后启动模块的命令。`spa` 模块现在完全可用。如果你一开始没有完全理解，不要担心——这里有很多内容，我们将在接下来的章节中更详细地介绍。这只是一个例子，展示你可以做什么：
- en: Listing 1.5\. JavaScript development, third pass—spa.html
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.5\. JavaScript 开发，第三次遍历——spa.html
- en: '![](ch01list05-0.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](ch01list05-0.jpg)'
- en: '![](ch01list05-1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](ch01list05-1.jpg)'
- en: Don’t worry too much about JSLint validation, as we’ll detail its use in coming
    chapters. But we’ll cover a few noteworthy concepts now. First, the comments at
    the top of the script set our preferences for validation. Second, this script
    and settings pass validation without any errors or warning. Finally, JSLint requires
    that functions be declared before they’re used, and therefore the script reads
    “bottom up” with the highest level functions at the end.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心 JSLint 验证，我们将在接下来的章节中详细说明其用法。但现在，我们将介绍一些值得注意的概念。首先，脚本顶部的注释设置了我们的验证偏好。其次，这个脚本和设置没有错误或警告地通过了验证。最后，JSLint
    要求在函数使用之前声明它们，因此脚本从下到上读取，最高级别的函数在最后。
- en: 'We use jQuery because it provides optimized, cross-browser utilities for fundamental
    JavaScript features: DOM selection, traversal, and manipulation; AJAX methods;
    and events. The jQuery `$(selector).animate(...)` method, for example, provides
    a simple way to do something that’s otherwise quite complex: animate the height
    of the chat slider from retracted to extended (and vice versa) within a specified
    time period. The motion starts slowly, accelerates, and then slows to a stop.
    This type of motion—called *easing*—requires knowledge of frame-rate calculations,
    trigonometric functions, and the vagaries of implementation across popular browsers.
    If we wrote it ourselves, it would require dozens of additional lines.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 jQuery，因为它为基本的 JavaScript 功能提供了优化且跨浏览器的实用工具：DOM 选择、遍历和操作；AJAX 方法；以及事件。例如，jQuery
    的 `$(selector).animate(...)` 方法提供了一种简单的方式来执行其他情况下相当复杂的事情：在指定的时间内将聊天滑块的长度从收缩状态动画到扩展状态（反之亦然）。这种运动开始缓慢，加速，然后减速至停止。这种类型的运动——称为
    *缓动*——需要了解帧率计算、三角函数以及在不同流行浏览器中的实现细节。如果我们自己编写，将需要数十行额外的代码。
- en: The `$jQuery(document).ready(function)` also saves us a lot of work. It runs
    the function only after the DOM is ready for manipulation. The traditional way
    to do this was to use the `window.onload` event. For a variety of reasons, `window.onload`
    isn’t an efficient solution for more demanding SPAs—although it makes little difference
    here. But writing the correct code to use across all browsers is painfully tedious
    and verbose.^([[6](#ch01fn06)])
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`$jQuery(document).ready(function)` 也为我们节省了很多工作。它只在实际可以操作 DOM 之后才运行函数。传统上，我们使用
    `window.onload` 事件来做这件事。由于各种原因，`window.onload` 对于更复杂的前端应用（SPAs）来说并不是一个高效的解决方案——尽管在这里影响不大。但是，编写适用于所有浏览器的正确代码是痛苦且冗长的.^([[6](#ch01fn06)])'
- en: ⁶ See [www.javascriptkit.com/dhtmltutors/domready.shtml](http://www.javascriptkit.com/dhtmltutors/domready.shtml)
    to get a taste of the pain.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶参见[www.javascriptkit.com/dhtmltutors/domready.shtml](http://www.javascriptkit.com/dhtmltutors/domready.shtml)以体验痛苦。
- en: jQuery’s benefits, as the previous example shows, usually significantly outweigh
    its costs. In this case, it shortened our development time, reduced the length
    of our script, and provided robust cross-browser compatibility. The cost of using
    it is somewhere between low and negligible, as its library is small when minimized
    and users likely have it already cached on their devices anyway. [Figure 1.6](#ch01fig06)
    shows the completed chat slider.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，jQuery的好处通常远远超过其成本。在这种情况下，它缩短了我们的开发时间，减少了脚本长度，并提供了强大的跨浏览器兼容性。使用它的成本介于低和可忽略之间，因为它的库在最小化时很小，而且用户可能已经在他们的设备上缓存了它。[图1.6](#ch01fig06)显示了完成的聊天滑块。
- en: Figure 1.6\. The completed chat slider in action—spa.html
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6. 完成的聊天滑块在spa.html中的动作
- en: '![](01fig06.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![01fig06.jpg](01fig06.jpg)'
- en: Now that we’ve completed the first implementation of our chat slider, let’s
    look at how the application actually works using the Chrome Developer Tools.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了聊天滑块的第一种实现，让我们看看应用程序实际上是如何使用Chrome开发者工具工作的。
- en: 1.2.6\. Inspect our application using Chrome Developer Tools
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.6. 使用Chrome开发者工具检查我们的应用程序
- en: If you’re comfortable using Chrome Developer Tools, you may skip this section.
    If not, we *highly* encourage you to play along at home.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉使用Chrome开发者工具，你可以跳过这一部分。如果不熟悉，我们强烈建议你在家里尝试。
- en: Let’s open our file, spa.html, in Chrome. After it loads, let’s immediately
    open up the Developer Tools (Menu > Tools > Developer Tools).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的文件spa.html，在Chrome中。加载后，让我们立即打开开发者工具（菜单 > 工具 > 开发者工具）。
- en: The first thing you may notice is how the DOM has been changed by our module
    to include the `<div` `class="spa-slider"` `...` `>` element, as shown in [figure
    1.7](#ch01fig07). As we continue, our application will be adding a *lot* more
    dynamic elements like this one.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是，我们的模块如何将DOM改变以包含`<div class="spa-slider" ... >`元素，如图1.7所示。随着我们继续，我们的应用程序将添加更多类似这样的动态元素。
- en: Figure 1.7\. Inspecting the elements—spa.html
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7. 检查元素—spa.html
- en: '![](01fig07_alt.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![01fig07_alt.jpg](01fig07_alt.jpg)'
- en: We can explore the JavaScript execution by clicking on the Sources button in
    the top menu of the Developer Tools. Then select the file that contains the JavaScript,
    as shown in [figure 1.8](#ch01fig08).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击开发者工具顶部菜单中的“源”按钮来探索JavaScript执行。然后选择包含JavaScript的文件，如图1.8所示。
- en: Figure 1.8\. Selecting a source file—spa.html
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8. 选择源文件—spa.html
- en: '![](01fig08_alt.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![01fig08_alt.jpg](01fig08_alt.jpg)'
- en: In later chapters we’ll be placing our JavaScript into separate files. But for
    this example it’s in our HTML file as shown in [figure 1.9](#ch01fig09). We’ll
    need to scroll down to find the JavaScript we want to inspect.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将把我们的JavaScript放入单独的文件中。但在这个例子中，它就像图1.9所示的那样在我们的HTML文件中。我们需要向下滚动以找到我们想要检查的JavaScript。
- en: Figure 1.9\. Viewing the source file—spa.html
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9. 查看源文件—spa.html
- en: '![](01fig09_alt.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![01fig09_alt.jpg](01fig09_alt.jpg)'
- en: When we navigate to line 76, we should see an `if` statement, as shown in [figure
    1.10](#ch01fig10). We should like to inspect the code *before* this statement
    is executed, so we click on the left margin to add a breakpoint. Whenever the
    JavaScript interpreter reaches this line in the script, it’ll pause so we can
    inspect elements and variables to better understand what’s happening.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导航到第76行时，我们应该看到一个`if`语句，如图1.10所示。我们希望在执行此语句之前检查代码，因此我们点击左侧边缘以添加断点。每当JavaScript解释器在脚本中到达此行时，它将暂停，这样我们就可以检查元素和变量，更好地理解正在发生的事情。
- en: Figure 1.10\. Setting a breakpoint—spa.html
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.10. 设置断点—spa.html
- en: '![](01fig10_alt.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![01fig10_alt.jpg](01fig10_alt.jpg)'
- en: Now let’s go back to the browser and click on the slider. We’ll see that the
    JavaScript has paused at the red arrow at line 76, as in [figure 1.11](#ch01fig11).
    While the application is paused, we can inspect variables and elements. We can
    open the console section and type in various variables and press Return to see
    their values in this paused state. We see that the `if` statement condition is
    true (`slider_height` is 16, and `configMap.retracted_height` is 16), and we can
    even inspect complex variables like the `configMap` object, as shown at the bottom
    of the console. When we’re done inspecting, we can remove the breakpoint by clicking
    on the left margin of line 76, and then clicking the Resume button at the top
    right (above Watch Expressions).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到浏览器并点击滑块。我们会看到JavaScript在行76的红色箭头处暂停，如[图1.11](#ch01fig11)所示。当应用程序暂停时，我们可以检查变量和元素。我们可以打开控制台部分，输入各种变量并按回车键以查看它们在暂停状态下的值。我们看到`if`语句的条件为真（`slider_height`是16，`configMap.retracted_height`也是16），我们甚至可以检查像`configMap`对象这样的复杂变量，如控制台底部所示。当我们完成检查后，我们可以通过点击行76的左侧边缘来移除断点，然后点击右上角的继续按钮（在监视表达式上方）。
- en: Figure 1.11\. Inspecting values on break—spa.html
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.11\. 在断点处检查值—spa.html
- en: '![](01fig11_alt.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig11_alt.jpg)'
- en: Once we click Resume, the script will continue from line 76 and finish toggling
    the slider. Let’s return to the Elements tab and look at how the DOM has changed,
    as shown in [figure 1.12](#ch01fig12). In this figure we can see that the CSS
    `height` property, which was provided by the `spa-slider` class (see Matched CSS
    Rules on the lower right), has been overridden by an element style (element styles
    have higher priority over styles that come from classes or IDs). If we click on
    the slider again, we can watch the height change in real-time as the slider retracts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击继续，脚本将从行76继续执行并完成切换滑块。让我们回到元素标签页，查看DOM如何变化，如[图1.12](#ch01fig12)所示。在这张图中，我们可以看到由`spa-slider`类提供的CSS
    `height`属性（见右下角的匹配CSS规则）已被元素样式覆盖（元素样式比来自类或ID的样式具有更高的优先级）。如果我们再次点击滑块，我们可以实时观察高度的变化，因为滑块在收缩。
- en: Figure 1.12\. Viewing DOM changes—spa.html
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.12\. 查看DOM变化—spa.html
- en: '![](01fig12_alt.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig12_alt.jpg)'
- en: Our short introduction to Chrome Developer Tools shows only a small portion
    of their ability to help us understand and change what’s occurring “under the
    hood” of our application. We’ll continue to use these tools as we develop this
    application, and we recommend you spend some quality time with the online manual
    at [http://mng.bz/PzIJ](http://mng.bz/PzIJ). It’s time well spent.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Chrome开发者工具的简要介绍仅展示了它们帮助我们理解和改变应用程序“内部”发生的事情能力的一小部分。我们将继续使用这些工具来开发这个应用程序，并建议您花些时间阅读[http://mng.bz/PzIJ](http://mng.bz/PzIJ)上的在线手册。这是值得花时间的事情。
- en: 1.3\. The user benefits of a well-written SPA
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 一个编写良好的SPA的用户优势
- en: 'Now that we’ve built our first SPA, let’s consider the primary benefit of an
    SPA over a traditional website: it provides a substantially more engaging user
    experience. An SPA can deliver the best of both worlds: the immediacy of a desktop
    application *and* the portability and accessibility of a website.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的第一个SPA，让我们考虑SPA相对于传统网站的主要优势：它提供了一个实质上更吸引人的用户体验。SPA可以提供两个世界的最佳结合：桌面应用程序的即时性和网站的便携性和可访问性。
- en: '*An SPA can render like a desktop application*—The SPA redraws the parts of
    the interface that need to change only as needed. A traditional website, in comparison,
    redraws the entire page on many user actions, resulting in a pause and a “flash”
    while the browser retrieves from the server and then redraws everything on the
    page. If the page is large, the server is busy, or the internet connection is
    slow, this flash can take several seconds or more, and the user has to guess when
    the page is ready to use again. This is a horrible experience when compared to
    the rapid rendering and immediate feedback of an SPA.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个SPA可以像桌面应用程序一样渲染*—SPA只会在需要时重绘界面中需要改变的部分。相比之下，传统的网站在许多用户操作时都会重新绘制整个页面，导致浏览器从服务器检索并重新绘制页面上的所有内容时出现暂停和“闪烁”。如果页面很大、服务器繁忙或网络连接慢，这种闪烁可能需要几秒钟或更长时间，用户不得不猜测页面何时可以再次使用。与SPA的快速渲染和即时反馈相比，这是一种糟糕的体验。'
- en: '*An SPA can respond like a desktop application*—The SPA minimizes response
    time by moving working (transient) data and processing from the server to the
    browser as much as possible. The SPA has the data and business logic needed to
    make most decisions locally and therefore quickly. Only data validation, authentication,
    and permanent storage must remain on the server, for reasons we discuss in [chapters
    6](kindle_split_017.html#ch06)–[8](kindle_split_020.html#ch08). A traditional
    website has most of the application logic on the server and the user must wait
    for a request/response/redraw cycle in response to much of their input. This can
    take several seconds, compared to the near immediate response of the SPA.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个SPA可以像桌面应用程序一样响应*——SPA通过尽可能将工作（临时）数据和处理从服务器移动到浏览器来最小化响应时间。SPA拥有做出大多数决策所需的数据和业务逻辑，因此可以快速做出决策。只有数据验证、身份验证和永久存储必须保留在服务器上，原因我们在第6章（[kindle_split_017.html#ch06](https://wiki.example.org/kindle_split_017.html#ch06)）到第8章（[kindle_split_020.html#ch08](https://wiki.example.org/kindle_split_020.html#ch08)）中讨论。传统的网站大多数应用程序逻辑都在服务器上，用户必须等待请求/响应/重绘周期来响应他们的输入。这可能会花费几秒钟，而SPA的响应几乎是即时的。'
- en: '*An SPA can notify users of its state like a desktop application*—When an SPA
    *does* have to wait on a server, it can dynamically render a progress bar or busy
    indicator so the user isn’t befuddled by a delay. Compare this to a traditional
    website, where the user actually has to *guess* when the page is loaded and usable.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个SPA可以像桌面应用程序一样通知用户其状态*——当一个SPA确实需要等待服务器时，它可以动态渲染进度条或忙碌指示器，这样用户就不会因为延迟而感到困惑。相比之下，传统的网站，用户实际上必须*猜测*页面何时加载和可用。'
- en: '*An SPA is nearly universally accessible like a website*—Unlike most desktop
    applications, users can access an SPA from any web connection and a decent browser.
    Today, the list includes smart phones, tablets, televisions, laptops, and desktop
    computers.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个SPA几乎像网站一样普遍可访问*——与大多数桌面应用程序不同，用户可以从任何网络连接和良好的浏览器访问SPA。今天，这个列表包括智能手机、平板电脑、电视、笔记本电脑和台式电脑。'
- en: '*An SPA can be instantly updated and distributed like a website*—The user doesn’t
    have to do anything to realize the benefits—when they reload the browser it works.
    The hassle of maintaining multiple concurrent versions of software is largely
    eliminated.^([[7](#ch01fn07)]) The authors have worked on SPAs that have been
    built and updated multiple times in a single day. Desktop applications often require
    a download and administrative access to install a new version, and the interval
    between versions can be many months or years.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个SPA可以像网站一样即时更新和分发*——用户不需要做任何事情就能意识到这些好处——当他们重新加载浏览器时，它就会工作。维护多个并发软件版本的麻烦在很大程度上被消除了。[7](#ch01fn07)
    作者曾参与过一天内构建和更新多次的SPA。桌面应用程序通常需要下载和行政访问权限来安装新版本，版本之间的间隔可能是几个月或几年。'
- en: '⁷ But not completely: what happens if the server-client data exchange format
    changes, yet many users have the prior version of software loaded in their browser?
    This can be accommodated with some forethought.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 但并非完全如此：如果服务器-客户端数据交换格式发生变化，而许多用户在他们的浏览器中加载了先前的软件版本，会发生什么？这可以通过一些预先考虑得到解决。
- en: '*An SPA is cross-platform like a website*—Unlike most desktop applications,
    a well-written SPA can work on any operating system that provides a modern HTML5
    browser. Though usually this is considered a developer benefit, it’s extremely
    useful for many users who have a combination of devices—say Windows at work, a
    Mac at home, a Linux server, an Android phone, and an Amazon tablet.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个单页应用（SPA）就像网站一样跨平台*——与大多数桌面应用程序不同，一个编写良好的SPA可以在提供现代HTML5浏览器的任何操作系统上运行。虽然这通常被认为是开发者的好处，但对于拥有多种设备组合的用户来说，这极其有用——比如在工作时使用Windows，在家中使用Mac，使用Linux服务器，使用Android手机，以及使用亚马逊平板电脑。'
- en: All of these benefits mean that you may want to make your next application an
    SPA. Clunky websites that re-render an entire page after each click tend to alienate
    increasingly sophisticated users. The communicative and responsive interface of
    a well-written SPA, along with the accessibility of the internet, helps keep our
    customers where they belong—using our product.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些好处意味着你可能希望将你的下一个应用程序制作成SPA。那些每次点击后都会重新渲染整个页面的笨拙网站往往会让越来越复杂的用户感到疏远。一个编写良好的SPA的沟通和响应式界面，加上互联网的易用性，有助于让我们的客户留在他们应该的地方——使用我们的产品。
- en: 1.4\. Summary
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 摘要
- en: The single page application has been around for some time. Flash and Java have,
    until recently, been the most widely used SPA client platforms because their capability,
    speed, and consistency exceeded those of JavaScript and browser rendering. But
    recently, JavaScript and browser rendering have reached a tipping point where
    they’ve overcome their most troublesome deficiencies while providing significant
    advantages over other client platforms.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用已经存在一段时间了。直到最近，Flash 和 Java 一直是使用最广泛的 SPA 客户端平台，因为它们的性能、速度和一致性超过了 JavaScript
    和浏览器渲染。但最近，JavaScript 和浏览器渲染已经达到了一个转折点，它们克服了最大的缺陷，同时提供了相对于其他客户端平台的显著优势。
- en: We focus on creating SPAs using native JavaScript and browser rendering, and
    when we refer to an *SPA* we mean a native JavaScript SPA unless otherwise noted.
    Our SPA tool chain includes jQuery, TaffyDB2, Node.js, Socket.IO, and MongoDB.
    All of these are proven, popular solutions. You may choose to employ alternatives
    to these technologies, but the fundamental structure of an SPA would remain regardless
    of specific technology decisions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于使用原生 JavaScript 和浏览器渲染创建 SPA，当我们提到 *SPA* 时，除非另有说明，否则我们指的是原生 JavaScript
    SPA。我们的 SPA 工具链包括 jQuery、TaffyDB2、Node.js、Socket.IO 和 MongoDB。所有这些都是经过验证的、流行的解决方案。你可以选择使用这些技术的替代方案，但
    SPA 的基本结构将不会因具体技术决策而改变。
- en: The simple chat slider application we developed demonstrates many features of
    a JavaScript SPA. It responds immediately to user input, and it uses data stored
    in the client instead of the server to make decisions. We used JSLint to ensure
    that our application didn’t contain common JavaScript mistakes. And we used jQuery
    to select and animate the DOM and to handle the event when a user clicks on the
    slider. We explored using the Chrome Developer Tools to help us understand how
    our application was working.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的简单聊天滑动应用演示了 JavaScript SPA 的许多功能。它对用户输入立即做出响应，并且它使用存储在客户端的数据而不是服务器来做出决策。我们使用
    JSLint 确保我们的应用程序不包含常见的 JavaScript 错误。我们还使用 jQuery 选择和动画 DOM，并处理用户点击滑动条时的事件。我们探讨了使用
    Chrome 开发者工具来帮助我们理解应用程序的工作方式。
- en: An SPA can provide the best of both worlds—the immediacy of a desktop application
    *and* the portability and accessibility of a website. The JavaScript SPA is available
    on over a billion devices that support a modern web browser and that don’t require
    any proprietary plugins. With a little effort, it can support desktops, tablets,
    and smart phones running many different operating systems. SPAs are easily updated
    and distributed, usually without requiring any action from the user. All of these
    benefits explain why you may want to make your next application an SPA.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单页应用（SPA）可以提供两种世界的最佳结合——桌面应用的即时性和网站的便携性和可访问性。JavaScript SPA 可在支持现代网络浏览器且不要求任何专有插件的超过十亿台设备上运行。只需稍加努力，它就可以支持运行多种不同操作系统的桌面、平板电脑和智能手机。SPA
    容易更新和分发，通常无需用户采取任何行动。所有这些优势都解释了为什么你可能想要将你的下一个应用做成 SPA。
- en: In the next chapter, we’ll explore some key JavaScript concepts that are needed
    for SPA development, but are frequently ignored or misunderstood. We’ll then build
    on this foundation to improve and extend the example SPA we developed in this
    chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些对于 SPA 开发至关重要但经常被忽视或误解的 JavaScript 概念。然后，我们将在此基础上改进和扩展本章中开发的示例
    SPA。
- en: Chapter 2\. Reintroducing JavaScript
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章：重新介绍 JavaScript
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Variable scoping, function hoisting, and the execution context object
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量作用域、函数提升和执行上下文对象
- en: Explaining variable scope chains and why we use them
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释变量作用域链及其使用原因
- en: Creating JavaScript objects using prototypes
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型创建 JavaScript 对象
- en: Writing self-executing anonymous functions
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自执行的匿名函数
- en: Using the module pattern and private variables
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块模式和私有变量
- en: Exploiting closures for fun and profit
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用闭包以娱乐和盈利
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This chapter reviews unique JavaScript concepts that we need to know if we’re
    to build a native JavaScript single page application of significant scale. The
    snippet of code in [listing 2.1](#ch02list01) from [chapter 1](kindle_split_011.html#ch01)
    shows the concepts we’ll be covering. If you understand all of these *how* and
    *why* concepts then you might skim or skip this chapter and get straight to work
    on an SPA in [chapter 3](kindle_split_014.html#ch03).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了我们需要了解的独特的 JavaScript 概念，如果我们想要构建一个具有重大规模的本地 JavaScript 单页应用程序。来自[第 1 章](kindle_split_011.html#ch01)的[列表
    2.1](#ch02list01)的代码片段展示了我们将要讨论的概念。如果你理解了所有这些 *如何* 和 *为什么* 概念，那么你可以快速浏览或跳过本章，直接在[第
    3 章](kindle_split_014.html#ch03)中开始构建 SPA。
- en: To follow along at home you can cut and paste all of the listings in this chapter
    into the console log of Chrome Development Tools and press Return to see them
    execute. We highly encourage you to join in the fun.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要在家中跟随学习，你可以将本章中的所有列表复制粘贴到 Chrome 开发工具的控制台中，然后按 Return 键来查看它们的执行结果。我们强烈鼓励你加入这个乐趣。
- en: Listing 2.1\. Application JavaScript
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 应用 JavaScript
- en: '![](ch02list01-0.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](ch02list01-0.jpg)'
- en: '![](ch02list01-1.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](ch02list01-1.jpg)'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Coding standards and JavaScript syntax**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码标准和 JavaScript 语法**'
- en: JavaScript syntax can be confusing to the uninitiated. It’s important to understand
    variable declaration blocks and object literals before moving on. Feel free to
    skip this sidebar if you’re already familiar with them. For a complete rundown
    on what we consider to be important JavaScript syntax and good coding standards,
    see [appendix A](kindle_split_022.html#app01).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，JavaScript 的语法可能有些难以理解。在继续学习之前，了解变量声明块和对象字面量非常重要。如果你已经熟悉它们，可以自由地跳过这个侧边栏。关于我们认为重要的
    JavaScript 语法和良好的编码标准，请参阅[附录 A](kindle_split_022.html#app01)。
- en: '**Variable Declaration Blocks**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量声明块**'
- en: '`var spa = "Hello world!";`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`var spa = "Hello world!";`'
- en: 'JavaScript variables are declared following the `var` keyword. A variable can
    contain any type of data: arrays, integers, floats, strings, and so on. The variable
    type isn’t specified, so JavaScript is considered a *loosely typed* language.
    Even after a value is assigned to a variable, the type of value can be changed
    by assigning a value with a different type, so it’s also considered a *dynamic*
    language.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 变量的声明遵循 `var` 关键字。一个变量可以包含任何类型的数据：数组、整数、浮点数、字符串等等。变量类型没有指定，因此 JavaScript
    被认为是一种 *弱类型* 语言。即使一个值已经赋给变量，通过赋值一个不同类型的值，值的类型也可以改变，因此它也被认为是一种 *动态* 语言。
- en: 'JavaScript variable declarations and assignments can be chained together following
    the `var` keyword by separating them with commas:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `var` 关键字后用逗号分隔来链式地声明和赋值 JavaScript 变量：
- en: '[PRE2]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are many viewpoints on the best format for a variable declaration block.
    We prefer variables that are declared but not defined to be at the top, followed
    by variable declarations with definitions. We also prefer having commas at the
    end of the line, as shown here, but we aren’t religious about it and the JavaScript
    engine doesn’t care.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量声明块的最佳格式有许多观点。我们更喜欢将未定义的变量声明放在顶部，然后是带有定义的变量声明。我们也更喜欢在行尾使用逗号，如所示，但我们并不对此过于执着，JavaScript
    引擎也不关心这一点。
- en: '**Object Literals**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象字面量**'
- en: 'An *object literal* is an object defined by a comma separated list of attributes
    contained in curly braces. Attributes are set with a colon instead of an equals
    sign. Object literals can also contains arrays, which are a comma-separated list
    of members surrounded by square brackets. Methods can be defined by setting a
    function as the value of one of the attributes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *对象字面量* 是由逗号分隔的属性列表定义的对象，这些属性包含在大括号内。属性使用冒号而不是等号来设置。对象字面量还可以包含数组，数组是由方括号包围的逗号分隔的成员列表。可以通过将函数设置为某个属性的值来定义方法：
- en: '[PRE3]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Object literals and variable declaration blocks are used extensively throughout
    the book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中广泛使用了对象字面量和变量声明块。
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.1\. Variable scope
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 变量作用域
- en: A good place to start our discussion is with the behavior of variables and when
    variables are in or out of scope.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的起点是变量的行为以及变量何时在或不在作用域内。
- en: Variables are scoped by functions in JavaScript and they’re either global or
    local. *Global* variables are accessible everywhere, and *local* variables are
    only accessible where they are declared. The only block that defines scope for
    a variable in JavaScript is a function. That’s it. Global variables are defined
    outside of a function, whereas local variables are defined inside of a function.
    Simple, right?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，变量由函数作用域限定，它们要么是全局的，要么是局部的。*全局*变量在所有地方都可以访问，而*局部*变量只能在它们被声明的位置访问。在JavaScript中，定义变量作用域的唯一块是函数。仅此而已。全局变量是在函数外部定义的，而局部变量是在函数内部定义的。简单，对吧？
- en: 'Another way to look at it is that functions are like a prison, and the variables
    defined inside of the function are like prisoners. Just like a prison contains
    the prisoners and doesn’t let them escape outside of the prison walls, a function
    contains the local variables and doesn’t let them escape outside the function,
    as the following code shows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待方式是，函数就像一个监狱，函数内部定义的变量就像囚犯。就像监狱包含囚犯并且不允许他们逃出监狱围墙一样，函数包含局部变量并且不允许它们逃出函数之外，如下面的代码所示：
- en: '![](026fig01_alt.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](026fig01_alt.jpg)'
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**JavaScript 1.7, 1.8, 1.9+, and block scope**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 1.7, 1.8, 1.9+ 和块作用域**'
- en: JavaScript 1.7 introduces a new block-scope constructor, the `let` statement.
    Unfortunately, even though standards exist for JavaScript 1.7, 1.8, and 1.9, not
    even 1.7 is consistently deployed across all browsers. Until browsers are compatible
    with these JavaScript updates, we’ll pretend that JavaScript 1.7+ doesn’t exist.
    Still, let’s take a look at how it works.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 1.7引入了一个新的块作用域构造函数，即`let`语句。不幸的是，尽管存在JavaScript 1.7、1.8和1.9的标准，但甚至1.7也没有在所有浏览器中得到一致的部署。直到浏览器兼容这些JavaScript更新之前，我们将假装JavaScript
    1.7+不存在。不过，让我们看看它是如何工作的。
- en: '![](026fig02.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](026fig02.jpg)'
- en: 'To use JavaScript 1.7, put the version in the `type` attribute of the script
    tag:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JavaScript 1.7，将版本放在`<script>`标签的`type`属性中：
- en: '`<script type="application/javascript;version=1.7">`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script type="application/javascript;version=1.7">`'
- en: This is only a brief taste of JavaScript 1.7+; there are many additional changes
    and new features.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对JavaScript 1.7+的一个简要介绍；还有很多其他的变化和新特性。
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If only it were that simple. The first gotcha you’ll likely encounter with JavaScript
    scoping is that it’s possible to declare a global variable while inside of a function
    simply by omitting the `var` declaration, as [figure 2.1](#ch02fig01) shows. And
    as with all programming languages, global variables are almost always a Bad Idea.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情真的这么简单就好了。你可能会遇到的第一个JavaScript作用域问题是，在函数内部，只需省略`var`声明，就可以声明一个全局变量，如图2.1所示。并且与所有编程语言一样，全局变量几乎总是个坏主意。
- en: Figure 2.1\. If you forget the var keyword when you declare a local variable
    in a function, you create a global variable instead.
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1。如果你在函数中声明局部变量时忘记了var关键字，你将创建一个全局变量。
- en: '![](02fig01.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig01.jpg)'
- en: '![](026fig03_alt.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](026fig03_alt.jpg)'
- en: 'This isn’t good—don’t let your prisoners escape. Another place this gotcha
    shows up often is when we forget the `var` when declaring the counter in `for`
    loops. Try the following definitions for the `prison` function one at a time:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不好——不要让你的囚犯逃走。这种问题经常出现在我们忘记在`for`循环中声明计数器时使用`var`。尝试以下对`prison`函数的定义，一次一个：
- en: '[PRE4]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We like this version better because declaring the variable at the top of the
    function makes its scope perfectly clear. Declaring a variable inside the `for`
    loop initializer might fool some people into thinking the variable’s scope is
    limited to the `for` loop, as it would be in some other languages.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢这个版本，因为将变量声明在函数顶部可以使它的作用域非常清晰。在`for`循环初始化器内部声明变量可能会让一些人误以为变量的作用域仅限于`for`循环，就像在其他一些语言中那样。
- en: 'We extend this logic to solve and combine all of the JavaScript declarations
    and most assignments at the top of the function they’re declared in, so that the
    scope of the variable is clear:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个逻辑扩展到解决和组合函数顶部声明的所有JavaScript声明和大多数赋值，以便变量的作用域清晰：
- en: '[PRE5]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By consolidating the local variable definitions using commas, we make them easy
    to see and, perhaps more importantly, make it less likely that a typo could inadvertently
    sneak in and create a global variable instead of a local one. Also, did you notice
    how nicely lined up they were? See how the semicolon at the end acts to the eye
    like a closing tag for the variable declaration block? We talk about this and
    other methods of formatting JavaScript for readability and understandability in
    the JavaScript Coding Standards in [appendix A](kindle_split_022.html#app01).
    Another interesting feature of JavaScript, variable hoisting, is related to this
    method of declaring local variables. Let’s look at that next.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用逗号合并局部变量定义，我们使它们易于查看，也许更重要的是，减少了打字错误意外地创建全局变量而不是局部变量的可能性。你也注意到了它们排得有多整齐吗？看看末尾的分号是如何在视觉上起到变量声明块闭合标签的作用的？我们在[附录A](kindle_split_022.html#app01)中的JavaScript编码标准中讨论了这一点以及其他用于可读性和可理解性的JavaScript格式化方法。JavaScript的另一个有趣特性，变量提升，与这种声明局部变量的方法有关。让我们接下来看看这一点。
- en: 2.2\. Variable hoisting
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. 变量提升
- en: When a variable is declared in JavaScript, its declaration is said to be *hoisted*
    to the top of its functional scope and the variable is assigned the value of `undefined`.
    This has the effect of making it so that a variable declared anywhere in a function
    exists throughout the entire function, though its value is undefined until it’s
    assigned a value, as illustrated in [figure 2.2](#ch02fig02).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当在JavaScript中声明一个变量时，其声明被认为是提升到其函数作用域的顶部，并且变量被赋予`undefined`的值。这导致变量在函数的任何地方声明都存在于整个函数中，尽管它的值在赋予值之前是未定义的，如[图2.2](#ch02fig02)所示。
- en: 'Figure 2.2\. JavaScript variable declarations are “hoisted” to the beginning
    of the function they appear in, but initializations stay where they are. The JavaScript
    engine doesn’t actually rewrite the code: the declaration is rehoisted every time
    the function is invoked.'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2. JavaScript变量声明被“提升”到它们出现的函数的开始处，但初始化保持原位。JavaScript引擎实际上并没有重写代码：每次函数被调用时，声明都会被重新提升。
- en: '![](02fig02_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](02fig02_alt.jpg)'
- en: '![](028fig01.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](028fig01.jpg)'
- en: 'Contrast the code in the figure with an attempt to access a variable not declared
    locally or globally, which results in a runtime JavaScript error that will stop
    JavaScript from executing at that statement:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将图中的代码与尝试访问未在局部或全局作用域中声明的变量进行对比，这会导致运行时JavaScript错误，该错误将停止JavaScript在该语句处执行：
- en: '![](028fig02_alt.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](028fig02_alt.jpg)'
- en: Because variable declarations are always hoisted to the top of your functional
    scope, the best practice is to always declare your variables at the top of your
    functions, preferably with a single `var` statement. This matches what JavaScript
    does and avoids the type of confusion we illustrated in the previous figure.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量声明总是提升到你的函数作用域的顶部，所以最佳实践是在函数顶部声明你的变量，最好使用单个`var`语句。这与JavaScript的行为相匹配，并避免了我们在上一幅图中展示的那种混淆。
- en: '![](028fig03.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](028fig03.jpg)'
- en: 'This scope and hoisting behavior can sometimes combine to cause some surprising
    behavior. Take the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这种作用域和提升行为有时会结合在一起导致一些令人惊讶的行为。看看以下代码：
- en: '![](029fig01_alt.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](029fig01_alt.jpg)'
- en: When prison is executed and `regular_joe` is requested by `console.log()`, the
    JavaScript engine first checks whether `regular_joe` has been declared in the
    local scope. Because `regular_joe` isn’t declared in the local scope, the JavaScript
    engine then checks the global scope and finds that it’s defined there and returns
    that value. This is called *walking up the scope chain*. But what if the variable
    is also declared in the local scope?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行监狱代码并请求`console.log()`中的`regular_joe`时，JavaScript引擎首先检查`regular_joe`是否在局部作用域中声明。因为`regular_joe`没有在局部作用域中声明，JavaScript引擎然后检查全局作用域，发现它在那里定义，并返回该值。这被称为*沿着作用域链向上查找*。但如果变量也在局部作用域中声明呢？
- en: '![](029fig02_alt.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](029fig02_alt.jpg)'
- en: Does this seem counterintuitive or confusing? Let’s walk through the way JavaScript
    handles hoisting under the covers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来反直觉或令人困惑吗？让我们来看看JavaScript在幕后是如何处理提升的。
- en: 2.3\. Advanced variable hoisting and the execution context object
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 高级变量提升和执行上下文对象
- en: 'All the concepts we’ve covered so far are generally regarded as necessary to
    know in order to be successful as a JavaScript developer. Let’s take it a step
    beyond that and see what happens under the hood: you’ll be one of the few who
    understands how JavaScript really works. We’ll start with one of JavaScript’s
    more “magical” features: variable and function hoisting.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所讨论的所有概念通常被认为是成为成功的 JavaScript 开发者所必需了解的。让我们更进一步，看看引擎内部发生了什么：你将成为少数几个真正理解
    JavaScript 如何工作的开发者之一。我们将从 JavaScript 的一个更“神奇”的功能开始：变量和函数提升。
- en: 2.3.1\. Hoisting
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 提升
- en: Like all forms of magic, the trick becomes almost disappointing when the secret
    is revealed. The secret is that the JavaScript engine makes two passes over code
    when it comes into scope. On the first pass it initializes variables and on the
    second pass it executes code. I know, simple; I have no idea why it’s not usually
    described in these terms. Let’s go into more detail on what the JavaScript engine
    does during the first pass because it has some interesting repercussions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有形式的魔法一样，当秘密被揭露时，技巧几乎让人失望。秘密在于当 JavaScript 引擎进入作用域时，它会遍历代码两次。在第一次遍历中，它初始化变量，在第二次遍历中执行代码。我知道，很简单；我不知道为什么通常不会用这些术语来描述。让我们更详细地了解一下
    JavaScript 引擎在第一次遍历中做了什么，因为它有一些有趣的影响。
- en: 'On the first pass, the JavaScript engine walks through the code and does three
    things:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次遍历中，JavaScript 引擎遍历代码并做三件事：
- en: Declares and initializes the function arguments.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化函数参数。
- en: Declares the local variables, including anonymous functions assigned to a local
    variable, but doesn’t initialize them.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明局部变量，包括分配给局部变量的匿名函数，但不会初始化它们。
- en: Declares and initializes functions.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化函数。
- en: Listing 2.2\. The first pass
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 第一次遍历
- en: '![](030fig01_alt.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](030fig01_alt.jpg)'
- en: Values are *not* assigned to local variables during the first pass because code
    may have to be executed to determine the value and the first pass doesn’t execute
    code. Values are assigned to the arguments, because any code needed to determine
    an argument’s value was run before the argument was passed into the function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次遍历中，**不会**将值分配给局部变量，因为可能需要执行代码来确定值，而第一次遍历不会执行代码。值分配给参数，因为确定参数值所需的任何代码都是在参数传递给函数之前运行的。
- en: We can demonstrate that the values of the arguments are set in the first pass
    by comparing them to the code demonstrating function hoisting from the end of
    the last section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将它们与上一节末尾展示的函数提升代码进行比较来证明在第一次遍历中设置了参数的值。
- en: Listing 2.3\. Variables are undefined before they are declared
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 变量在声明之前是未定义的
- en: '![](030fig02_alt.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](030fig02_alt.jpg)'
- en: '`regular_joe` is undefined before it’s declared in the prison function, but
    if `regular_joe` is also passed in as an argument, it has a value before it’s
    declared.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在监狱函数中声明`regular_joe`之前，它是未定义的，但如果`regular_joe`也被作为参数传递，它在声明之前就有值。
- en: Listing 2.4\. Variables have a value before they’re declared
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 变量在声明之前有值
- en: '![](030fig03_alt.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](030fig03_alt.jpg)'
- en: If your head is spinning from this, that’s okay. Though we’ve explained that
    the JavaScript engine makes two passes over a function when it executes, and that
    on the first pass it stores the variables, we haven’t seen *how* it stores the
    variables. Seeing how the JavaScript engine stores variables will hopefully clear
    up any remaining confusion. The JavaScript engine stores variables as attributes
    on an object referred to as the *execution context object*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到头晕，那没关系。虽然我们解释了 JavaScript 引擎在执行函数时遍历两次，并且在第一次遍历中存储变量，但我们还没有看到它是如何存储变量的。了解
    JavaScript 引擎如何存储变量可能会消除任何剩余的困惑。JavaScript 引擎将变量存储在称为**执行上下文对象**的对象上的属性中。
- en: 2.3.2\. Execution context and the execution context object
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 执行上下文和执行上下文对象
- en: Every time a function is invoked, there’s a new execution context. The execution
    context is a concept, the concept of a running function—it’s not an object. It’s
    like thinking of an athlete in a running context or a jumping context. We could
    say a running athlete instead of an athlete in a running context, just like we
    could say a running function, but that’s not how the jargon works. We say the
    *execution context*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 每次函数被调用时，都会有一个新的执行上下文。执行上下文是一个概念，即运行中的函数的概念——它不是一个对象。就像在跑步或跳跃的上下文中考虑一名运动员一样。我们可以说一个跑步的运动员，而不是一个在跑步上下文中的运动员，就像我们可以说一个运行中的函数，但术语不是这样用的。我们说**执行上下文**。
- en: The execution context is made up of everything that happens while that function
    is executing. This is separate from a function declaration, because the function
    declaration describes what *will* happen when the function is executed. The execution
    context *is* the execution of the function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上下文由函数执行期间发生的一切组成。这与函数声明是不同的，因为函数声明描述了函数执行时会发生什么。执行上下文*就是*函数的执行。
- en: All of the variables and functions defined in a function are considered part
    of the execution context. The execution context is a part of what developers are
    referring to when they talk about a function’s *scope*. A variable is considered
    “in scope” if it’s accessible in the current execution context, which is another
    way of saying the variable is in scope if it’s accessible while the function is
    running.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中定义的所有变量和函数都被认为是执行上下文的一部分。执行上下文是开发人员在谈论函数的*作用域*时所指的一部分。如果变量在当前执行上下文中可访问，则认为该变量“在作用域内”，这另一种说法是，如果变量在函数运行时可以访问，则该变量在作用域内。
- en: The variables and functions that are part of the execution context are stored
    on the *execution context object*, an implementation of the ECMA standard for
    the execution context. The execution context object is an object in the JavaScript
    engine, and not a variable directly accessible in JavaScript. It’s easy enough
    to access indirectly, as every time you use a variable you’re accessing an attribute
    of an execution context object.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上下文中的变量和函数存储在*执行上下文对象*上，这是执行上下文ECMA标准的实现。执行上下文对象是JavaScript引擎中的一个对象，而不是JavaScript中可以直接访问的变量。虽然间接访问它很容易，因为每次使用变量时，你都是在访问执行上下文对象的属性。
- en: Earlier, we discussed how the JavaScript engine makes two passes over an execution
    context, declaring and initializing the variables, but where does it store these
    variables? The JavaScript engine declares and initializes the variables as attributes
    on the execution context object. For an example of how the variables are stored,
    take a look at [table 2.1](#ch02table01).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论了JavaScript引擎如何对执行上下文进行两次遍历，声明和初始化变量，但变量存储在哪里呢？JavaScript引擎将变量声明和初始化为执行上下文对象的属性。为了了解变量是如何存储的，请查看[表2.1](#ch02table01)。
- en: Table 2.1\. Execution context object
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1\. 执行上下文对象
- en: '| Code | Execution context object |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 执行上下文对象 |'
- en: '| --- | --- |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It’s possible that you’ve never heard of the execution context object. It’s
    not something commonly discussed in the web developer community, probably because
    the execution context object is buried in the implementation of JavaScript and
    not directly accessible during development.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你从未听说过执行上下文对象。这并不是在网页开发者社区中常见讨论的话题，可能是因为执行上下文对象被埋藏在JavaScript的实现中，并且在开发过程中无法直接访问。
- en: Understanding the execution context object will be key to understanding the
    rest of the chapter, so let’s walk through the lifecycle of an execution context
    object and the JavaScript code that creates it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 理解执行上下文对象对于理解本章的其余部分至关重要，因此让我们回顾一下执行上下文对象的生命周期以及创建它的JavaScript代码。
- en: Listing 2.5\. Execution context object—first pass
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5\. 执行上下文对象——第一次遍历
- en: '![](032fig01_alt.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](032fig01_alt.jpg)'
- en: Now that the arguments and functions have been declared and assigned, and the
    local variables have been declared, a second pass is made, executing the JavaScript
    and assigning the definitions of the local variables.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经声明和分配了参数和函数，并且已经声明了局部变量，接下来进行第二次遍历，执行JavaScript代码并分配局部变量的定义。
- en: Listing 2.6\. Execution context object—second pass
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6\. 执行上下文对象——第二次遍历
- en: '![](032fig02_alt.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](032fig02_alt.jpg)'
- en: This can go many layers deep, as functions can be invoked inside of an execution
    context. Invoking a function inside of an execution context creates a new execution
    context nested inside the existing execution context. Okay, head spinning again;
    it’s picture time. See [figure 2.3](#ch02fig03).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以深入很多层，因为函数可以在执行上下文中被调用。在执行上下文中调用一个函数会在现有执行上下文中创建一个新的嵌套执行上下文。好吧，又开始头晕了；现在是时候看图了。请看[图2.3](#ch02fig03)。
- en: Figure 2.3\. Calling a function creates an execution context.
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 调用一个函数创建一个执行上下文。
- en: '![](02fig03_alt.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig03_alt.jpg)'
- en: Everything inside of the `<script>` tag is in the global execution context.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<script>`标签内的所有内容都在全局执行上下文中。'
- en: Invoking `first_function` creates a new execution context inside the global
    execution context. When `first_function` runs, it has access to the variables
    of the execution context in which it was invoked. In this case, `first_function`
    has access to the variables defined in the global execution context and the local
    variables defined in `first_function`. These variables are said to be *in scope*.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`first_function`在全局执行上下文中创建一个新的执行上下文。当`first_function`运行时，它可以访问其被调用的执行上下文中的变量。在这种情况下，`first_function`可以访问全局执行上下文中定义的变量以及`first_function`中定义的局部变量。这些变量被称为*在作用域内*。
- en: Invoking `second_function` creates a new execution context inside of the `first_function`
    execution context. `second_function` has access to the variables from the `first_function`
    execution context because it was invoked inside of it. `second_function` also
    has access to variables in the global execution context and the local variables
    defined in `second_function`. These variables are said to be *in scope*.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`second_function`在`first_function`执行上下文中创建一个新的执行上下文。`second_function`可以访问`first_function`执行上下文中的变量，因为它是在其中被调用的。`second_function`还可以访问全局执行上下文中的变量以及`second_function`中定义的局部变量。这些变量被称为*在作用域内*。
- en: '`second_function` is invoked again, this time in the global execution context.
    This `second_function` doesn’t have access to the variables in the `first_function`
    execution context because this time `second_function` wasn’t invoked in the `first_function`
    execution context. Said another way, this time when `second_function` is called,
    it doesn’t have access to the variables defined in `first_function` because it
    wasn’t called inside of `first_function`. This `second_function` execution context
    doesn’t have access to the variables from the previous time `second_function`
    was invoked either, because they occur in different execution contexts. Said another
    way, when you call a function, you don’t have access to local variables created
    the last time the function was called, and the next time you call this function
    you won’t have access to the local variables from this function call. These inaccessible
    variables are said to be *out of scope*.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用`second_function`，这次是在全局执行上下文中。这个`second_function`无法访问`first_function`执行上下文中的变量，因为这次`second_function`不是在`first_function`执行上下文中被调用的。换句话说，当这次调用`second_function`时，它无法访问在`first_function`中定义的变量，因为它不是在`first_function`内部被调用的。这个`second_function`执行上下文也无法访问之前调用`second_function`时创建的变量，因为它们发生在不同的执行上下文中。换句话说，当你调用一个函数时，你无法访问上次调用该函数时创建的局部变量，下次调用该函数时你也不会访问这次函数调用中的局部变量。这些不可访问的变量被称为*超出作用域*。
- en: The order in which the JavaScript engine looks in the execution context objects
    to access variables that are “in scope” is referred to as the *scope chain*, which,
    together with the *prototype chain*, describes the order in which JavaScript accesses
    variables and their attributes. We’ll discuss these concepts in the next few sections.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎查找执行上下文对象以访问“在作用域内”的变量的顺序被称为*作用域链*，它与*原型链*一起描述了JavaScript访问变量及其属性的顺序。我们将在接下来的几节中讨论这些概念。
- en: 2.4\. The scope chain
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4。作用域链
- en: Up until now we’ve mostly limited our discussion of variable scope to *global*
    and *local*. This is a good starting point, but scoping is more nuanced, as implied
    in the discussion of nested execution contexts in the last section. Variable scope
    is more accurately thought of as a chain, as seen in [figure 2.4](#ch02fig04).
    When looking for the definition of a variable, the JavaScript engine first looks
    at the local execution context object. If the definition isn’t there, it jumps
    up the scope chain to the execution context it was created in and looks for the
    variable definition in that execution context object, and so on until it finds
    the definition or reaches the global scope.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要将变量作用域限制在*全局*和*局部*。这是一个好的起点，但作用域更为复杂，如上一节中嵌套执行上下文讨论所暗示的。变量作用域更准确地可以看作是一个链，如[图2.4](#ch02fig04)所示。当寻找变量的定义时，JavaScript引擎首先查看局部执行上下文对象。如果定义不在那里，它就会跳到作用域链上，到创建它的执行上下文中，并在该执行上下文对象中寻找变量定义，依此类推，直到找到定义或达到全局作用域。
- en: Figure 2.4\. During runtime JavaScript searches the scope hierarchy to resolve
    variable names.
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4。在运行时，JavaScript会搜索作用域层次结构以解析变量名。
- en: '![](02fig04_alt.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![02fig04_alt](02fig04_alt.jpg)'
- en: 'Let’s modify an earlier example to illustrate the scope chain. The code in
    [listing 2.7](#ch02list07) will print the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改一个早期的例子来说明作用域链。在[列表2.7](#ch02list07)中的代码将打印以下内容：
- en: '[PRE8]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 2.7\. Scope chain example—regular_joe defined at each calling scope
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 作用域链示例——在每次调用作用域中定义`regular_joe`
- en: '![](035fig01_alt.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](035fig01_alt.jpg)'
- en: 'During runtime, JavaScript searches the scope hierarchy to resolve variable
    names. It starts with the current scope, and then works its way back to the top-level
    scope, the `window` (browsers) or `global` (node.js) object. It uses the first
    match it finds and the search stops. Note that this implies that variables in
    more deeply nested scopes can hide variables in more global scopes by replacing
    them for their current scope. This can be either good or bad, depending on whether
    you’re expecting it to happen. In real code you should strive to make variable
    names unique to the extent possible: the code we just looked at, in which the
    same name is introduced into three different nested scopes, is hardly an example
    of best practice and is used only to illustrate the point.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，JavaScript会搜索作用域层次结构以解析变量名。它从当前作用域开始，然后逐级向上到顶级作用域，即`window`（浏览器）或`global`（Node.js）对象。它使用找到的第一个匹配项并停止搜索。请注意，这表明深层嵌套作用域中的变量可以通过替换它们当前作用域中的变量来隐藏更全局作用域中的变量。这可能是好是坏，这取决于你是否期望它发生。在实际代码中，你应该尽可能使变量名唯一：我们刚刚查看的代码，其中相同的名称被引入到三个不同的嵌套作用域中，几乎不是最佳实践的例子，并且仅用于说明这一点。
- en: 'In the listing, the value of a variable called `regular_joe` is requested from
    three scopes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，从三个作用域请求了一个名为`regular_joe`的变量的值：
- en: The last line of the listing, `console.log(regular_joe)`, is in the global scope.
    JavaScript starts searching for a `regular_joe` property of the global execution
    context object. It finds one with the value `I am here to save the day` and uses
    it.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表中的最后一条语句`console.log(regular_joe)`是在全局作用域中。JavaScript开始搜索全局执行上下文对象的`regular_joe`属性。它找到一个值为`I
    am here to save the day`的属性并使用它。
- en: At the last line of the `supermax` function, we see `console.log(regular_joe)`.
    This call is within the `supermax` execution context. JavaScript starts searching
    for a `regular_joe` property of the `supermax` execution context object. It finds
    one with the value of `regular_joe is assigned` and uses that.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`supermax`函数的最后一条语句中，我们看到`console.log(regular_joe)`。这个调用是在`supermax`执行上下文中进行的。JavaScript开始搜索`supermax`执行上下文对象的`regular_joe`属性。它找到一个值为`regular_joe
    is assigned`的属性并使用它。
- en: At the last line of the `prison` function, we see `console.log(regular_joe)`.
    This call is within the `prison` execution context within the `supermax` execution
    context. JavaScript starts searching for a `regular_joe` property of the `prison`
    execution context object. It finds one with a value of `undefined` and uses that.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`prison`函数的最后一条语句中，我们看到`console.log(regular_joe)`。这个调用是在`supermax`执行上下文中的`prison`执行上下文中进行的。JavaScript开始搜索`prison`执行上下文对象的`regular_joe`属性。它找到一个值为`undefined`的属性并使用它。
- en: 'In this example, the value of `regular_joe` is defined for all three scopes.
    In the next version of the code, in [listing 2.8](#ch02list08), we define it only
    in the global scope. Now the program prints “I am here to save the day!” three
    times:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`regular_joe`的值在所有三个作用域中都被定义。在代码的下一个版本中，在[列表2.8](#ch02list08)中，我们只在全局作用域中定义它。现在程序会打印三次“我来到这里是为了拯救世界！”：
- en: Listing 2.8\. Scope chain example—regular_joe defined only in one scope
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8\. 作用域链示例——只在单个作用域中定义`regular_joe`
- en: '![](036fig01_alt.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](036fig01_alt.jpg)'
- en: It’s important to remember that when we request a variable value, the result
    may come from anywhere in the scope chain. It’s up to us to control and understand
    where in the chain our values are derived from, lest we shall fall into tortured
    coding chaos. The JavaScript coding standards in [appendix A](kindle_split_022.html#app01)
    outline a number of techniques to help us in this effort, and we’ll use them as
    we go along.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，当我们请求变量值时，结果可能来自作用域链中的任何位置。这取决于我们控制并理解我们的值是从链中的哪个位置派生出来的，否则我们可能会陷入痛苦的编码混乱。[附录A](kindle_split_022.html#app01)中的JavaScript编码标准概述了帮助我们完成这项工作的多种技术，我们将随着我们的进展使用它们。
- en: '|  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Global variables and the window object**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局变量和窗口对象**'
- en: What we typically call *global* variables are properties of the top-level object
    of the execution environment. The top-level object of the browser is the `window`
    object; in node.js, the top-level object is called `global`, and variable scope
    works differently.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常所说的 *全局* 变量是执行环境顶级对象的属性。浏览器顶级对象是 `window` 对象；在 node.js 中，顶级对象称为 `global`，变量作用域的工作方式不同。
- en: The `window` object contains many properties which themselves contain objects,
    methods (`onload`, `onresize`, `alert`, `close`...), DOM elements (`document`,
    `frames`...) and other variables. All these properties are accessed by using the
    syntax `window.` *property*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`window` 对象包含许多属性，这些属性本身包含对象、方法（`onload`、`onresize`、`alert`、`close`...）、DOM
    元素（`document`、`frames`...）和其他变量。所有这些属性都是通过使用语法 `window.` *属性* 来访问的。'
- en: '[PRE9]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The top-level object for node.js is called `global`. Because node.js is a network
    server and not a browser, the functions and properties which are available are
    significantly different.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: node.js 的顶级对象称为 `global`。因为 node.js 是一个网络服务器而不是浏览器，所以可用的函数和属性与浏览器有很大的不同。
- en: When JavaScript in a browser checks for the existence of a *global* variable,
    it looks at the `window` object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器中的 JavaScript 检查全局变量的存在时，它会查看 `window` 对象。
- en: '[PRE10]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: JavaScript has a parallel concept to the scope chain, known as the *prototype
    chain*, that defines where an object looks for the definitions of its attributes.
    Let’s take a look at prototypes and the prototype chain.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有一个与作用域链平行的概念，称为 *原型链*，它定义了对象查找其属性定义的位置。让我们看看原型和原型链。
- en: 2.5\. JavaScript objects and the prototype chain
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5. JavaScript 对象和原型链
- en: JavaScript objects are prototype-based, whereas the other most widely used languages
    today all use class-based objects. In a class-based system, an object is defined
    by describing what it’ll look like with a class. In prototype-based systems, we
    create an object that looks like what we want all objects of that type to look
    like, and then tell the JavaScript engine that we want more objects that look
    like that.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象是基于原型的，而今天其他最广泛使用的语言都使用基于类的对象。在基于类的系统中，一个对象是通过描述它将如何看起来来定义一个类的。在基于原型的系统中，我们创建一个看起来像我们希望所有该类型对象都看起来像的对象，然后告诉
    JavaScript 引擎我们想要更多看起来像那样的对象。
- en: Not to stretch a metaphor too far, but if architecture were a class-based system,
    an architect would draw up the blueprints of a house and then have houses built
    based on that blueprint. If architecture were prototype-based, the architect would
    build a house and then have houses built to look like that one.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过分夸张这个比喻，但如果建筑是一个基于类的系统，建筑师会绘制房子的蓝图，然后根据那个蓝图建造房子。如果建筑是基于原型的，建筑师会建造一栋房子，然后根据那栋房子建造其他房子。
- en: Let’s build on our earlier prisoner example and compare what it takes in each
    system to create a single prisoner with properties for the name, prisoner ID,
    length of prison sentence in years, and number of years probation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于之前的囚犯例子来构建，并比较在每个系统中创建一个具有姓名、囚犯 ID、刑期年数和缓刑年数属性的单个囚犯需要什么。
- en: 'Table 2.2\. Simple object creation: class versus prototype'
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.2. 简单对象创建：类与原型
- en: '| Class-based | Prototype-based |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 基于类 | 基于原型 |'
- en: '| --- | --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| --- | ---'
- en: '|'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The prototype-based object is simpler and quicker to write when there’s only
    one instance of an object. In class-based systems you have to define a class,
    define a constructor, and then instantiate an object that is a member of that
    class. A prototype-based object is simply defined in place.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个对象实例时，基于原型的对象更简单、更快地编写。在基于类的系统中，你必须定义一个类，定义一个构造函数，然后实例化一个属于该类的对象。基于原型的对象简单地定义在原地。
- en: The prototype-based system shines for the simple one object use case, but it
    can also support the more complex use case of having multiple objects that share
    similar characteristics. Let’s take the previous example of prisoners and let
    the code change the `name` and `id` of the prisoners, but keep the same preset
    years in sentence and years until probation.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 基于原型的系统在简单的一个对象用例中表现出色，但它也可以支持具有相似特性的多个对象的更复杂用例。让我们以之前的囚犯例子为例，让代码改变囚犯的 `name`
    和 `id`，但保持相同的预设刑期和缓刑期限。
- en: As you can see in [table 2.3](#ch02table03), the two kinds of programming follow
    a similar sequence, and if you’re used to classes, adjusting to prototypes shouldn’t
    be much of a stretch. But the devil is in the details, and if you’re coming from
    a class-based system and jump into JavaScript without learning the prototype-based
    approach, it’s easy to get tripped up on something that seems like it should be
    simple. Let’s step through the sequence and see what we can learn.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [表 2.3](#ch02table03) 中可以看到，两种编程方式遵循相似的顺序，如果你习惯了类，适应原型不应该有很大困难。但问题在于细节，如果你来自基于类的系统，没有学习基于原型的方法就跳入
    JavaScript，很容易在看似简单的事情上绊倒。让我们逐步分析这个顺序，看看我们能学到什么。
- en: 'Table 2.3\. Multiple objects: class versus prototype'
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.3\. 多个对象：类与原型
- en: '| Class-based | Prototype-based |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 基于类 | 基于原型 |'
- en: '| --- | --- |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Define the class
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类
- en: Define the class constructor
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类构造函数
- en: Instantiate the objects
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化对象
- en: '|'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Define prototype object
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义原型对象
- en: Define the object constructor
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义对象构造函数
- en: Link constructor to prototype
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造函数链接到原型
- en: Instantiate the objects
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化对象
- en: '|'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In each method, we first create the template for our objects. The template
    is called the *class* in class-based programming and the *prototype object* in
    prototype-based programming, but they serve the same purpose: acting as a framework
    from which objects will be created.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个方法中，我们首先为我们的对象创建模板。在基于类的编程中，模板被称为 *类*，在基于原型的编程中，被称为 *原型对象*，但它们都服务于相同的目的：作为创建对象的框架。
- en: Second, we create a constructor. In class-based languages, the constructor is
    defined inside of the class so it’s clear when instantiating the object which
    constructor goes with which class. In JavaScript, the object constructor is set
    outside of the prototype, so an additional step is needed to link them together.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们创建一个构造函数。在基于类的语言中，构造函数定义在类内部，因此在实例化对象时可以清楚地知道哪个构造函数与哪个类相对应。在 JavaScript
    中，对象构造函数设置在原型之外，因此需要额外的步骤来将它们链接在一起。
- en: Finally, the objects are instantiated.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实例化对象。
- en: JavaScript’s use of the `new` operator is a departure from its prototype-based
    roots, perhaps as an attempt to make it more comprehensible to developers familiar
    with class-based inheritance. Unfortunately, we think it clouds the issue and
    makes something that should be unfamiliar (and therefore studied) appear to be
    familiar, causing developers to jump in until they run into issues and spend hours
    trying to figure out a bug caused by mistaking JavaScript for a class-based system.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用 `new` 操作符与其基于原型的根源不同，可能是因为试图使其对熟悉基于类继承的开发者更易于理解。不幸的是，我们认为这模糊了问题，使得本应不熟悉（因此需要研究）的东西看起来很熟悉，导致开发者盲目尝试，直到遇到问题，花费数小时试图找出由将
    JavaScript 错误地视为基于类系统而引起的错误。
- en: 'As an alternative to using the `new` operator, the method `Object.create` has
    been developed and is used to add a more prototype-based feel to JavaScript object
    creation. We use the `Object.create` method exclusively throughout the book. Creating
    prisoners from the prototype-based example from [table 2.3](#ch02table03) using
    `Object.create` would look like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 `new` 操作符的替代方案，已经开发并使用了 `Object.create` 方法，以给 JavaScript 对象创建添加更多基于原型的感觉。我们在整本书中仅使用
    `Object.create` 方法。使用 `Object.create` 从 [表 2.3](#ch02table03) 中的基于原型的示例创建囚犯看起来是这样的：
- en: Listing 2.9\. Using `Object.create` to create objects
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.9\. 使用 `Object.create` 创建对象
- en: '[PRE15]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Object.create` takes the prototype as an argument and returns an object; in
    this way you can define the common attributes and methods on a prototype object
    and use it to create many objects sharing the same properties. Having to set the
    `name` and `id` on each of them manually is a pain because having to repeat code
    isn’t very clean. As an alternative, a common pattern for using `Object.create`
    is to use a factory function that creates and returns the final object. We name
    all our factory functions `make<object_name>`.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create` 方法接受一个原型作为参数并返回一个对象；通过这种方式，你可以在原型对象上定义公共属性和方法，并使用它来创建具有相同属性的多达多个对象。必须手动在每个对象上设置
    `name` 和 `id` 是一件痛苦的事情，因为重复代码并不干净。作为替代方案，使用 `Object.create` 的一个常见模式是使用一个工厂函数来创建并返回最终对象。我们命名所有的工厂函数为
    `make<object_name>`。'
- en: Listing 2.10\. Use of `Object.create` with a factory function
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.10\. 使用工厂函数与 `Object.create` 的结合
- en: '![](039fig01_alt.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](039fig01_alt.jpg)'
- en: Though there are a number of alternative methods to create objects in JavaScript
    (it’s another oft-debated developer topic), it’s generally considered a best practice
    to use `Object.create`. We prefer this method as it clearly illustrates how the
    prototype is set. The `new` operator is, unfortunately, perhaps the most commonly
    used method to create objects. We say unfortunate because it misleads developers
    into thinking the language is class-based and obscures the nuances of the prototype-based
    system.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 JavaScript 中有几种创建对象的方法（这是另一个经常被争论的开发者话题），但通常认为使用 `Object.create` 是一种最佳实践。我们更喜欢这种方法，因为它清楚地说明了原型是如何设置的。不幸的是，`new`
    操作符可能是创建对象最常用的方法。我们说不幸，因为它误导开发者认为语言是类基础的，并掩盖了基于原型的系统的细微差别。
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Object.create for older browsers**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**针对旧浏览器的 Object.create**'
- en: '`Object.create` works in IE 9+, Firefox 4+, Safari 5+, and Chrome 5+. In order
    to be compatible across older browsers (we’re looking at you IE 6, 7, and 8!),
    we need to define `Object.create` when it doesn’t exist and leave it unchanged
    for browsers that have already implemented it.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create` 在 IE 9+、Firefox 4+、Safari 5+ 和 Chrome 5+ 中工作。为了与旧浏览器兼容（我们指的是
    IE 6、7 和 8！），我们需要在它不存在时定义 `Object.create`，并在已经实现了它的浏览器中保持不变。'
- en: '[PRE16]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that we’ve seen how JavaScript uses prototypes to create objects sharing
    the same properties, let’s dig into the prototype chain and talk about how the
    JavaScript engine implements finding the value of attributes on an object.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 JavaScript 如何使用原型来创建具有相同属性的对象，让我们深入原型链，并讨论 JavaScript 引擎是如何实现查找对象上属性值的。
- en: 2.5.1\. The prototype chain
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1\. 原型链
- en: Attributes on an object are implemented and function differently in prototype-based
    JavaScript than in a class-based system. There are enough similarities that most
    of the time we can get along without a clear understanding, but when the differences
    rear their ugly heads, we pay the price in frustration and lost productivity.
    Just like learning the basic differences between prototypes and classes is worth
    it up front, so is learning about the prototype chain.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于原型的 JavaScript 中，对象的属性实现和功能与基于类的系统不同。尽管它们有足够的相似之处，大多数时候我们可以在没有明确理解的情况下过得去，但当差异显现出来时，我们就会在挫败感和生产力损失中付出代价。就像学习原型和类之间的基本差异值得一开始就学习一样，学习原型链也同样重要。
- en: JavaScript uses the *prototype chain* to resolve property values. The prototype
    chain describes how the JavaScript engine looks from object to the object’s prototype
    to the prototype’s prototype in order to locate the value of a property of the
    object. When we request an object’s property, the JavaScript engine first looks
    for the property directly on the object. If it can’t find the property there,
    it looks at the prototype (stored in the `__proto__` property of objects) and
    sees if the prototype contains the requested property.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用 *原型链* 来解析属性值。原型链描述了 JavaScript 引擎如何从对象到对象的原型，再到原型的原型，以定位对象的属性值。当我们请求一个对象的属性时，JavaScript
    引擎首先在对象上直接查找该属性。如果在那里找不到属性，它会查看原型（存储在对象的 `__proto__` 属性中）并查看原型是否包含请求的属性。
- en: If the JavaScript engine can’t find the property in the objects prototype, it
    checks the prototype’s prototype (the prototype is just an object, so it has a
    prototype as well). And so on. This prototype chain ends when JavaScript reaches
    the generic `Object` prototype. If JavaScript can’t find the requested property
    anywhere in the chain, it returns `undefined`. The details can get intricate as
    the JavaScript engine checks up the prototype chain, but for the purposes of this
    book we just need to remember that if a property isn’t found on the object, the
    prototype is checked.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JavaScript 引擎在对象的原型中找不到属性，它会检查原型的原型（原型本身也是一个对象，因此它也有一个原型）。依此类推。当 JavaScript
    达到通用的 `Object` 原型时，原型链结束。如果 JavaScript 在链中的任何地方都找不到请求的属性，它将返回 `undefined`。随着 JavaScript
    引擎沿着原型链检查，细节可能会变得复杂，但就本书的目的而言，我们只需要记住，如果一个属性在对象上找不到，则会检查原型。
- en: This climb up the prototype chain is similar to the JavaScript engine’s climb
    up the scope chain to find a variable’s definition. As you can see in [figure
    2.5](#ch02fig05), the concept is nearly identical to the scope chain from [figure
    2.4](#ch02fig04).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着原型链的这种攀升类似于 JavaScript 引擎沿着作用域链攀升以找到变量定义的过程。正如你在 [图 2.5](#ch02fig05) 中可以看到的，这个概念几乎与
    [图 2.4](#ch02fig04) 中的作用域链相同。
- en: Figure 2.5\. During runtime JavaScript searches the prototype chain to resolve
    property values.
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.5\. 在运行时，JavaScript 会搜索原型链以解析属性值。
- en: '![](02fig05_alt.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.5 替代](02fig05_alt.jpg)'
- en: You can climb the prototype chain manually with the `__proto__` property.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `__proto__` 属性手动遍历原型链。
- en: '[PRE17]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we request `firstPrisoner.name`, JavaScript will find the name of the prisoner
    directly on the object and return `Joe`. If we request `firstPrisoner.sentence`,
    JavaScript won’t find the property on the object, but would find it in the prototype
    and return the value of `4`. And if we request `firstPrisoner.toString()`, we’ll
    get the string `[object Object]` because the base Object prototype has that method.
    Finally, if we request `firstPrisoner.hopeless`, we’ll get `undefined`, as that
    property is nowhere to be found in the prototype chain. These results are summarized
    in [table 2.4](#ch02table04).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求 `firstPrisoner.name`，JavaScript 将直接在对象上找到囚犯的名字并返回 `Joe`。如果我们请求 `firstPrisoner.sentence`，JavaScript
    不会在对象上找到属性，但会在原型中找到它并返回值 `4`。如果我们请求 `firstPrisoner.toString()`，我们将得到字符串 `[object
    Object]`，因为基本 Object 原型有那个方法。最后，如果我们请求 `firstPrisoner.hopeless`，我们将得到 `undefined`，因为该属性在原型链中无处可寻。这些结果总结在
    [表 2.4](#ch02table04) 中。
- en: Table 2.4\. Prototype chain
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.4\. 原型链
- en: '![](fig24_1.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图 24_1](fig24_1.jpg)'
- en: '![](fig24_2.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图 24_2](fig24_2.jpg)'
- en: Another way to demonstrate the prototype chain is to see what happens when we
    change a value on an object set by the prototype.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种演示原型链的方法是看看当我们改变由原型设置的对象上的值时会发生什么。
- en: Listing 2.11\. Overwriting the prototype
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.11\. 覆盖原型
- en: '![](ch02list11-0.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 列表 11-0](ch02list11-0.jpg)'
- en: '![](ch02list11-1.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 列表 11-1](ch02list11-1.jpg)'
- en: So what happens, I can hear you thinking, if we change the value of the attribute
    on the prototype object?
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果您在思考，当我们改变原型对象上的属性值时会发生什么？
- en: Prototype Mutations
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原型变异
- en: One powerful—and potentially dangerous—behavior that prototype inheritance provides
    is the ability to mutate *all* objects based on a prototype at once. For those
    familiar with static variables, attributes on the prototype act like static variables
    for objects created from the prototype. Let’s check out our code one more time.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 原型继承提供的一种强大且可能危险的行为是能够一次性突变基于原型的 *所有* 对象。对于那些熟悉静态变量的，原型上的属性就像从原型创建的对象的静态变量。让我们再次检查我们的代码。
- en: '[PRE18]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If, after the preceding example, we inspect `firstPrisoner` or `secondPrisoner`,
    we’ll find that the inherited property `sentence` is set to 4.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在先前的示例之后检查 `firstPrisoner` 或 `secondPrisoner`，我们会发现继承属性 `sentence` 被设置为 4。
- en: '[PRE19]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we change the prototype object, for example by setting `proto.sentence` `=`
    `5`, then all objects created after *and before* will reflect this value. Thus
    `firstPrisoner.sentence` and `secondPrisoner.sentence` are set to 5.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变原型对象，例如通过设置 `proto.sentence` `=` `5`，那么在 *之后* 和 *之前* 创建的所有对象都将反映这个值。因此
    `firstPrisoner.sentence` 和 `secondPrisoner.sentence` 被设置为 5。
- en: '[PRE20]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This behavior has good and bad points. The important thing is that it’s consistent
    across JavaScript environments and that we know about it so we can code accordingly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为有优点也有缺点。重要的是，它在 JavaScript 环境中是一致的，并且我们知道这一点，因此我们可以相应地编写代码。
- en: Now that we know how objects inherit properties from other objects using prototypes,
    let’s look at how functions work, because they may also behave differently than
    you’d expect. We’ll also investigate how these differences can provide some useful
    capabilities that we take advantage of throughout the book.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了对象是如何通过原型从其他对象继承属性的，那么让我们看看函数是如何工作的，因为它们可能表现得与您预期的不同。我们还将调查这些差异如何提供一些有用的功能，我们将在整本书中利用这些功能。
- en: 2.6\. Functions—a deeper look
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6\. 函数——深入了解
- en: Functions are first-class objects in JavaScript. They can be stored in variables,
    given attributes, and even be passed as arguments into function calls. They’re
    used to control variable scope and provide private variables and methods. Understanding
    functions is one of the keys to understanding JavaScript and an important foundation
    for building professional single page applications.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 JavaScript 中的第一等对象。它们可以被存储在变量中，赋予属性，甚至可以作为参数传递给函数调用。它们用于控制变量作用域并提供私有变量和方法。理解函数是理解
    JavaScript 的关键之一，也是构建专业单页应用的重要基础。
- en: 2.6.1\. Functions and anonymous functions
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.1\. 函数和匿名函数
- en: 'An important feature of a function in JavaScript is that it’s an object, just
    like any other object. We all have probably seen a JavaScript function declared
    like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中函数的一个重要特性是它是一个对象，就像任何其他对象一样。我们可能都见过像这样声明的 JavaScript 函数：
- en: '[PRE21]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But we can also store functions in variables:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以将函数存储在变量中：
- en: '[PRE22]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can decrease the redundancy (and the chance we’ll mismatch the names) by
    making it an *anonymous function*, which is just the label given to a function
    declaration without a name. Here’s an anonymous function being saved to a local
    variable:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其制作成*匿名函数*来减少冗余（以及名称不匹配的机会），匿名函数只是对没有名称的函数声明的标签。以下是将匿名函数保存到局部变量的示例：
- en: '[PRE23]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Functions saved to a local variable are called the same way we would expect
    a function to be called:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 保存到局部变量的函数是以我们预期函数调用的方式调用的：
- en: '![](046fig01.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](046fig01.jpg)'
- en: 2.6.2\. Self-executing anonymous functions
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.2\. 自执行匿名函数
- en: One problem we constantly face in JavaScript is that everything defined in the
    global scope is available everywhere. Sometimes you don’t want to share with everyone
    and you don’t want third-party libraries to share their internal variables with
    you because it’s easy to step over each other’s libraries and cause difficult-to-diagnose
    problems. Using what we know about functions, we could wrap the entire program
    in a function, call that function, and then our variables wouldn’t be accessible
    to any external code.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们经常面临的一个问题是，在全局作用域中定义的任何内容都可以在任何地方访问。有时你不想与每个人分享，也不想第三方库与你共享它们的内部变量，因为这很容易导致库之间的冲突，并造成难以诊断的问题。利用我们对函数的了解，我们可以将整个程序包裹在一个函数中，调用该函数，然后我们的变量就不会被任何外部代码访问。
- en: '[PRE24]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: But that’s a wordy and awkward way to have to do it. It’d be nice if we didn’t
    have to define a function, save it to a variable, and then execute that function.
    It sure would be nice to have a shorthand approach. Guess what... we do!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样做既啰嗦又别扭。如果我们可以不定义一个函数，将其保存到变量中，然后执行该函数，那就太好了。确实，有一个简写的方法。猜猜看……我们确实有！
- en: '[PRE25]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is referred to as a *self-executing anonymous function* because it’s defined
    without being given a name or saved to a variable, and is executed immediately.
    All we do is surround the function with parentheses, followed by a pair of parentheses
    to execute the function as shown in [table 2.5](#ch02table05). The syntax isn’t
    that surprising when seen next to an explicitly called function.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*自执行匿名函数*，因为它是在没有给出名称或保存到变量中定义的，并且立即执行。我们做的只是将函数用括号包围，然后使用一对括号来执行该函数，如[表
    2.5](#ch02table05)所示。与显式调用的函数并排看时，语法并不令人惊讶。
- en: 'Table 2.5\. Explicit invocation versus self-executing functions. These have
    the same effect: creating a function and then calling it immediately'
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.5\. 显式调用与自执行函数的比较。它们具有相同的效果：创建一个函数然后立即调用它
- en: '| Explicit invocation | Self-executing function |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 显式调用 | 自执行函数 |'
- en: '| --- | --- |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Self-executing anonymous functions are used to contain variable scope and prevent
    variables from leaking out into other places in the code. This can be used to
    create JavaScript plugins that won’t conflict with application code because they
    don’t add any variables to the global namespace. In the next section we’ll demonstrate
    an even more advanced use case that we use throughout the book. It’s called the
    *module pattern* and it gives us access to define private variables and methods.
    First, let’s see how variable scope works in a self-executing anonymous function.
    If this looks familiar it’s because it’s exactly the same as before, just using
    the new syntax:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 自执行匿名函数用于包含变量作用域并防止变量泄漏到代码的其他地方。这可以用来创建不会与应用程序代码冲突的 JavaScript 插件，因为它们不会向全局命名空间添加任何变量。在下一节中，我们将演示一个更高级的使用案例，我们在整本书中都使用了它。它被称为*模块模式*，它允许我们定义私有变量和方法。首先，让我们看看在自执行匿名函数中变量作用域是如何工作的。如果这看起来很熟悉，那是因为它与之前完全一样，只是使用了新的语法：
- en: '![](047fig01_alt.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](047fig01_alt.jpg)'
- en: Here the global namespace is polluted with the `global_var` variable and runs
    the risk of conflicting with other variables of the same name used in our code
    or in external JavaScript libraries used in our projects. *Pollution of the global
    namespace* is a term you might hear often in JavaScript circles—this is what it
    refers to.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，全局命名空间被`global_var`变量污染，并存在与我们在代码或项目中使用的同名外部 JavaScript 库中的变量冲突的风险。*全局命名空间的污染*是你在
    JavaScript 圈中可能会经常听到的术语——这就是它所指的。
- en: One problem that can be solved with a self-executing anonymous functions is
    that global variables can be overwritten by a third-party library, or even unintentionally
    by your own code. By passing a value into a self-executing anonymous function
    as a parameter, you’re guaranteeing that the value of that parameter will be what
    you expect it to be for that execution context because outside code can’t affect
    it.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 自执行的匿名函数可以解决的一个问题是，全局变量可能会被第三方库覆盖，甚至可能无意中被你自己的代码覆盖。通过将一个值作为参数传递给自执行的匿名函数，你可以保证该参数的值将是你在该执行上下文中期望的，因为外部代码无法影响它。
- en: First, let’s see how to pass a parameter into a self-executing anonymous function.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何将一个参数传递给一个自执行的匿名函数。
- en: '![](048fig01_alt.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](048fig01_alt.jpg)'
- en: 'If that syntax throws you for a loop, it’s just passing the value `sandwich`
    into the anonymous function as the first parameter. Let’s compare that syntax
    against a normal function:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个语法让你感到困惑，它只是将值 `sandwich` 作为第一个参数传递给匿名函数。让我们将这个语法与一个普通函数进行比较：
- en: '[PRE28]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only difference is that the variable `eatFunction` has been removed and
    the function definition is surrounded by parentheses.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于已经移除了变量 `eatFunction`，并且函数定义被括号包围。
- en: One famous example of preventing a variable from being overwritten uses the
    jQuery and Prototype JavaScript libraries. They both make extensive use of the
    one character variable `$`. If you include both of them in your application, then
    the library that was added last gets control over the `$`. The technique of passing
    in a variable to the self-executing anonymous function can be used to ensure that
    jQuery can use the `$` variable for a block of code.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 防止变量被覆盖的一个著名例子是使用 jQuery 和 Prototype JavaScript 库。它们都大量使用了单字符变量 `$`。如果你在应用程序中包含这两个库，那么最后添加的库将控制
    `$`。将变量传递给自执行的匿名函数的技术可以用来确保 jQuery 可以在一段代码中使用 `$` 变量。
- en: 'For this example, you should know that the jQuery and `$` variables are aliases
    of each other. By passing the jQuery variable into the self-executing anonymous
    function that uses it as the `$` parameter, you prevent the `$` from being taken
    over by the Prototype library:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，你应该知道 jQuery 和 `$` 变量是彼此的别名。通过将 jQuery 变量传递给使用它作为 `$` 参数的自执行的匿名函数，你可以防止
    `$` 被Prototype库接管：
- en: '![](048fig02_alt.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](048fig02_alt.jpg)'
- en: 2.6.3\. The module pattern—bringing private variables to JavaScript
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.3\. 模块模式——将私有变量引入JavaScript
- en: It’s great that we can wrap our application in a self-executing anonymous function
    to protect our application from third-party libraries (and protect them from us),
    but a single page application is huge and can’t be defined in one file. It sure
    would be nice if there were a way to break up that file into modules, each with
    their own private variables. Okay, you can see where I’m going with this... we
    can!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将我们的应用程序包裹在一个自执行的匿名函数中，以保护我们的应用程序免受第三方库（以及我们自身）的影响，这真是太好了，但单页应用程序非常大，无法在一个文件中定义。如果有一种方法可以将该文件拆分成模块，每个模块都有自己的私有变量，那就太好了。好吧，你可以看到我要去哪里了...我们可以做到！
- en: Let’s see how to break our code up into multiple files, but still take advantage
    of the self-executing anonymous function to control the scope of our variables.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将我们的代码拆分成多个文件，同时仍然利用自执行的匿名函数来控制变量的作用域。
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Still not used to that self-executing anonymous function syntax?**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**你还没有习惯自执行的匿名函数的语法吗？**'
- en: 'Let’s take another look at it. This funny looking syntax:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看这个看起来很奇怪的语法：
- en: '[PRE29]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Is practically the same as this syntax:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上等同于以下语法：
- en: '[PRE30]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In both cases that value of prison is “Mike is in prison”. The only practical
    difference is that instead of saving the `makePrison` function when it only needs
    to be used one time, the function is created and invoked without saving it anywhere.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`prison` 的值都是“Mike is in prison”。唯一的实际区别是，不需要保存 `makePrison` 函数，因为它只需要使用一次，函数被创建并调用，而不需要保存到任何地方。
- en: '|  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](049fig01_alt.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](049fig01_alt.jpg)'
- en: Our self-executing anonymous function is immediately executed and returns an
    object with the properties `prisoner` and `sentence`. The anonymous function isn’t
    stored in the prison variable because the anonymous function was executed—*the
    return value of the anonymous function* is stored in the `prison` variable.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自执行匿名函数立即执行，并返回一个具有 `prisoner` 和 `sentence` 属性的对象。匿名函数没有被存储在 `prison` 变量中，因为匿名函数已经执行了——*匿名函数的返回值*
    被存储在 `prison` 变量中。
- en: Instead of adding the variables `prisoner_name` and `jail_term` to the global
    scope, only the variable `prison` is added. In bigger modules, the reduction in
    global variables can be even more significant.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将变量 `prisoner_name` 和 `jail_term` 添加到全局作用域，而是只添加变量 `prison`。在更大的模块中，全局变量的减少可能更为显著。
- en: One problem with our object is that the variables defined in the self-executing
    anonymous function are gone once the function stops executing, so they can’t be
    changed. `prisoner_name` and `jail_term` aren’t properties of the object saved
    to the variable `prison`, so they can’t be accessed this way. They *are* variables
    used to define the attributes `prisoner` and `sentence` on the object returned
    from the anonymous function, and those attributes can be accessed on the `prison`
    variable.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对象的一个问题是，在自执行的匿名函数停止执行后，定义在匿名函数中的变量就消失了，因此它们不能被更改。`prisoner_name` 和 `jail_term`
    不是保存到变量 `prison` 的对象的属性，因此不能通过这种方式访问。它们是用于在匿名函数返回的对象上定义 `prisoner` 和 `sentence`
    属性的变量，并且这些属性可以通过 `prison` 变量访问。
- en: '![](050fig01_alt.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![图片](050fig01_alt.jpg)'
- en: '`prison.prisoner` doesn’t get updated for a few reasons. First, `jail_term`
    isn’t an attribute on the `prison` object or prototype; it was a variable in the
    execution context that created the object and saved to the prison variable, and
    that execution context no longer exists because the function finished executing
    already. Second, these attributes are set one time when the anonymous function
    is executed and are never updated. To make them update, we have to turn the attributes
    into methods that access the variables every time they’re invoked.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`prison.prisoner` 没有更新是因为几个原因。首先，`jail_term` 不是 `prison` 对象或原型的属性；它是在创建对象并保存到
    `prison` 变量时的执行上下文中的一个变量，并且由于函数已经执行完毕，该执行上下文不再存在。其次，这些属性在匿名函数执行时只设置一次，并且永远不会更新。为了使它们更新，我们必须将这些属性转换为每次调用时访问变量的方法。'
- en: '![](050fig02_alt.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![图片](050fig02_alt.jpg)'
- en: Even though the self-executing anonymous function is done executing, the variables
    `prisoner_name` and `jail_term` remain accessible to the `prisoner` and `setJailTerm`
    methods. `prisoner_name` and `jail_term` now act like private attributes for the
    prison object. They can only be accessed by methods on the object returned from
    the anonymous function and aren’t directly accessible on the object or the object’s
    prototype. And you’d heard closures were hard. Wait, I’m sorry... I haven’t explained
    how that’s a closure yet, have I? Okay, let’s take a few steps back and walk up
    to it.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 即使自执行的匿名函数已经执行完毕，变量 `prisoner_name` 和 `jail_term` 仍然可以通过 `prisoner` 和 `setJailTerm`
    方法访问。`prisoner_name` 和 `jail_term` 现在像私有属性一样作用于 `prison` 对象。它们只能通过匿名函数返回的对象上的方法访问，不能直接在对象或对象的原型上访问。你也许听说过闭包很难。等等，对不起...
    我还没有解释这是如何成为闭包的，对吧？好的，让我们退后几步，然后逐步接近它。
- en: What is a Closure?
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是闭包？
- en: As an abstract concept, closures can be difficult to wrap your head around,
    so before answering the question “What is a closure?” we’ll need to set some background.
    Please bear with us, as you’ll get the answer to this question by the end of this
    section.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种抽象概念，闭包可能难以理解，所以在回答“什么是闭包？”这个问题之前，我们需要先设定一些背景知识。请耐心等待，因为在本节结束时，你将得到这个问题的答案。
- en: As programs run, they take up and use the computer’s memory for all sorts of
    things, such as storing the values of variables. If programs ran and never freed
    up memory that was no longer needed, the computer would eventually crash. In some
    languages, like C, memory management has to be handled by the programmer and a
    lot of time is spent by programmers writing code to make sure that memory is freed
    up when it can.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它们会占用并使用计算机的内存来完成各种事情，例如存储变量的值。如果程序运行后不再释放不再需要的内存，计算机最终会崩溃。在一些语言中，如C语言，内存管理必须由程序员处理，程序员会花费大量时间编写代码以确保内存被释放。
- en: Other languages, like Java and JavaScript, implement a system for automatically
    freeing up memory by removing code from the computer’s memory when it’s no longer
    needed. These automated systems are called *garbage collectors*, presumably because
    unneeded variables taking up space stink. There are opinions as to which system
    is better, automated or manual, but that’s beyond the scope of this book. It’s
    enough to know that JavaScript has a garbage collector.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言，如Java和JavaScript，通过从计算机内存中移除不再需要的代码来自动释放内存。这些自动化的系统被称为*垃圾回收器*，可能是因为占位空间的无用变量很臭。关于哪种系统更好，自动或手动，各有各的看法，但这本书的范围之外。只需知道JavaScript有一个垃圾回收器。
- en: When a function is finished executing, a naive approach to memory management
    would be to remove everything that was created inside of that function from memory.
    After all, the function is finished executing, so it would seem that we don’t
    need access to anything inside of that execution context anymore.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数执行完毕时，一种简单的方法是将其内部创建的所有内容从内存中移除。毕竟，函数已经执行完毕，所以看起来我们不再需要访问执行上下文中的任何内容了。
- en: '[PRE31]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once `prison` is done executing, we no longer need access to the `prisoner`
    variable, so Josh is free to go. This pattern is verbose, so let’s turn it back
    into that self-executing anonymous function pattern.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`prison`执行完毕，我们就不再需要访问`prisoner`变量，所以乔希可以自由地走了。这种模式比较冗长，所以让我们将其转换回自执行的匿名函数模式。
- en: '[PRE32]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Same thing here: the function is executed and when it’s done the prisoner variable
    doesn’t need to be kept in memory any longer. Bye bye, Josh!'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也是同样的情况：函数执行完毕后，犯人变量不再需要保留在内存中。再见，乔希！
- en: Let’s stick this in our module pattern.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这段代码放入我们的模块模式中。
- en: '![](052fig01_alt.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](052fig01_alt.jpg)'
- en: We still don’t need access to the `prisoner` variable after the anonymous function
    has executed. Because the string `Josh Powell` is now stored in `prison.prisoner`,
    there’s no reason to keep the `prisoner` variable in the module in memory because
    it’s no longer accessible. Though it may seem otherwise, the value of `prison.prisoner`
    is the string `Josh Powell`; it doesn’t point to the `prisoner` variable.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名函数执行完毕后，我们仍然不需要访问`prisoner`变量。因为字符串`Josh Powell`现在存储在`prison.prisoner`中，所以没有必要在模块中保留`prisoner`变量，因为它不再可访问。尽管看起来可能不是这样，`prison.prisoner`的值是字符串`Josh
    Powell`；它并不指向`prisoner`变量。
- en: '[PRE33]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, the `prisoner` variable is accessed every time `prison.prisoner` is executed.
    `prison.prisoner()` returns the current value of the `prisoner` variable. If the
    garbage collector came and removed it from memory, invoking `prison.prisoner`
    would return `undefined` instead of `Josh Powell`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次执行`prison.prisoner`时都会访问`prisoner`变量。`prison.prisoner()`返回`prisoner`变量的当前值。如果垃圾回收器来移除它，调用`prison.prisoner`将返回`undefined`而不是`Josh
    Powell`。
- en: Now, finally, we can answer the question “What is a closure?” A closure is the
    process of preventing the garbage collector from removing a variable from memory
    by keeping access to the variable outside the execution context in which it was
    created. A closure is created when the `prisoner` function is saved on the `prison`
    object. The closure is created by saving a function, with dynamic access to the
    `prisoner` variable, outside of the current execution context, which prevents
    the garbage collector from removing the `prisoner` variable from memory.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，我们可以回答“什么是闭包？”的问题。闭包是通过在创建变量的执行上下文外部保持对变量的访问，防止垃圾回收器从内存中移除变量的过程。当`prisoner`函数被保存在`prison`对象上时，就创建了闭包。闭包是通过在当前执行上下文外部保存一个函数，该函数具有对`prisoner`变量的动态访问权限，从而创建的，这阻止了垃圾回收器从内存中移除`prisoner`变量。
- en: Let’s look at a few more examples of closures.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个闭包的更多例子。
- en: '[PRE34]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another common use of closures is to save variables for use when an Ajax call
    returns. When using methods in a JavaScript object, `this` refers to the object:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的另一个常见用途是在Ajax调用返回时保存变量。在使用JavaScript对象的函数时，`this`指向对象：
- en: '[PRE35]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If your method makes an Ajax call using jQuery, then `this` no longer refers
    to your object; it refers to the Ajax call:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用jQuery在方法中发起Ajax调用，那么`this`不再指向你的对象；它指向Ajax调用：
- en: '[PRE36]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So how do you refer to the object? Closures to the rescue! Remember, a closure
    is created by taking a function that has access to a variable in the current execution
    context and saving it to a variable outside of the current execution context.
    In the following example, it’s created by saving `this` to `that`, and accessing
    `that` in the function that executes when the Ajax call is returned. The Ajax
    call is asynchronous, so the response comes outside of the execution context where
    the Ajax call is made.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何引用该对象呢？闭包来帮忙！记住，闭包是通过将一个可以访问当前执行上下文中变量的函数保存到当前执行上下文之外的变量中创建的。在下面的例子中，它是通过将
    `this` 保存到 `that` 中，并在 Ajax 调用返回时执行的函数中访问 `that` 创建的。Ajax 调用是异步的，所以响应是在发出 Ajax
    调用的执行上下文之外到达的。
- en: '![](053fig01_alt.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](053fig01_alt.jpg)'
- en: Even though `who()` has finished executing by the time the Ajax call has returned,
    the `that` variable wasn’t garbage collected and is available for use by the `success`
    method.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `who()` 在 Ajax 调用返回之前已经执行完毕，但 `that` 变量没有被垃圾回收，并且可以由 `success` 方法使用。
- en: Hopefully, we’ve presented closures in a way that makes it easy to grasp what
    they are and how they work. Now that we have a grasp of what a closure is, let’s
    dig into the mechanics of closures and see how they’re implemented.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们已经以一种易于理解的方式介绍了闭包，使得我们能够轻松地掌握它们是什么以及它们是如何工作的。现在我们已经了解了闭包是什么，让我们深入探讨闭包的机制，看看它们是如何实现的。
- en: 2.6.4\. Closures
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.4\. 闭包
- en: 'How do closures work? Now we understand *what* a closure, but not *how* it
    is implemented. The answer lies with execution context objects. Let’s take a look
    at an example from the last section:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是如何工作的？现在我们理解了 *什么是* 闭包，但还不了解 *它是如何实现的*。答案在于执行上下文对象。让我们看看上一节的一个例子：
- en: '[PRE37]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When `makePrison` is invoked, an execution context object for that *specific*
    invocation is created and `prisoner` is assigned the value passed in. Remember
    that an execution context object is part of the JavaScript engine and isn’t directly
    accessible in JavaScript.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `makePrison` 时，会创建一个针对该 *特定* 调用的执行上下文对象，并将 `prisoner` 赋值为传入的值。请记住，执行上下文对象是
    JavaScript 引擎的一部分，在 JavaScript 中无法直接访问。
- en: In the preceding example, we make two calls to `makePrison`, saving the results
    to `joshPrison` and `mikePrison`. Because the return value of `makePrison` is
    a function, when we assign it to the `joshPrison` variable, the reference count
    to that *specific* execution context object is one, and because the count remains
    greater than zero, that *specific* execution context object is retained by the
    JavaScript engine. If that count were to drop to zero, then the JavaScript engine
    would know that object could be garbage collected.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们调用了两次 `makePrison`，并将结果保存到 `joshPrison` 和 `mikePrison` 中。因为 `makePrison`
    的返回值是一个函数，当我们将其赋值给 `joshPrison` 变量时，对该 *特定* 执行上下文对象的引用计数为 1，并且因为计数仍然大于零，所以该 *特定*
    执行上下文对象被 JavaScript 引擎保留。如果该计数降至零，那么 JavaScript 引擎就会知道该对象可以被垃圾回收。
- en: When `makePrison` is called again and assigned to `mikePrison`, a new execution
    context object is created and the reference count to that execution context object
    is also set to one. At that point, we have two pointers to two execution context
    objects, both with a reference count of one, even though both were created by
    executing the same function.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当再次调用 `makePrison` 并将其赋值给 `mikePrison` 时，会创建一个新的执行上下文对象，并且对该执行上下文对象的引用计数也设置为
    1。此时，我们有两个指向两个执行上下文对象的指针，它们的引用计数都是 1，尽管它们都是由执行相同函数创建的。
- en: If we were to invoke `joshPrison` again, it would use the value set on the execution
    context object created when `makePrison` was invoked and saved to `joshPrison`.
    The only way to purge the retained execution context object (besides closing the
    web page, smarty pants) is to delete the `joshPrison` variable. When we do, the
    reference count to that execution context object drops to 0, and it may be removed
    at JavaScript’s leisure.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次调用 `joshPrison`，它将使用在 `makePrison` 调用并保存到 `joshPrison` 时的执行上下文对象中的值。除了关闭网页（聪明人）之外，清除保留的执行上下文对象的唯一方法就是删除
    `joshPrison` 变量。当我们这样做时，对该执行上下文对象的引用计数降至 0，它可能被 JavaScript 随意移除。
- en: 'Let’s get a few execution context objects going at once and see what happens:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们同时启动几个执行上下文对象，看看会发生什么：
- en: Listing 2.12\. Execution context objects
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.12\. 执行上下文对象
- en: '[PRE38]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We must remember that a unique execution context object is created every time
    a function is called. After the function completes, the execution object is immediately
    discarded *unless the caller retains a reference to it*. If a function returns
    a number, you can’t typically retain a reference to a function’s execution context
    object. On the other hand, if a function returns a more complex structure like
    a function, an object, or an array, creating a reference to the execution context
    is often accomplished—sometimes mistakenly—by storing the return value to a variable.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，每次调用函数时都会创建一个唯一的执行上下文对象。函数执行完成后，执行对象会立即被丢弃*除非调用者保留对其的引用*。如果你返回一个数字，通常你不能保留对函数执行上下文对象的引用。另一方面，如果你返回一个更复杂的结构，如函数、对象或数组，创建对执行上下文的引用通常是通过将返回值存储到变量中实现的——有时是错误地实现的。
- en: It’s possible to create chains of execution context references many layers deep.
    And this is a good thing when we want it (think *object inheritance*). But there
    are times when we don’t want closures like this, as they could create runaway
    memory usage (think *memory leak*). Rules and tools are presented in [appendix
    A](kindle_split_022.html#app01) that can help you avoid unintended closures.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能创建多层深度的执行上下文引用链。当我们需要时（例如，考虑*对象继承*），这确实是一件好事。但有时我们并不希望有这种闭包，因为它们可能会造成内存使用失控（例如，考虑*内存泄漏*）。在[附录A](kindle_split_022.html#app01)中提供了规则和工具，可以帮助你避免意外的闭包。
- en: '|  |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Closures—one more time!**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包——再谈一次！**'
- en: Before moving on, because closures are such an important and confusing part
    of JavaScript, let’s take one more stab at an explanation. If you’ve got closures
    down cold, feel free to move on.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，因为闭包是JavaScript中如此重要且令人困惑的一部分，让我们再尝试一次解释。如果你已经完全掌握了闭包，请随意继续。
- en: '[PRE39]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When `outer_function` is executed, it creates an execution context. `inner_function`
    is defined inside of that execution context
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 当`outer_function`执行时，它创建了一个执行上下文。`inner_function`定义在这个执行上下文中
- en: Because `inner_function` is defined inside the `outer_function` execution context,
    it has access to all of the variables in scope in `outer_function`—in this case
    `food`, `fruit`, `outer_function`, `inner_function`, and `menu`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`inner_function`是在`outer_function`执行上下文中定义的，所以它可以访问`outer_function`中所有作用域内的变量——在这个例子中是`food`、`fruit`、`outer_function`、`inner_function`和`menu`。
- en: When `outer_function` is finished executing, you might expect everything inside
    of that execution context to be destroyed by the garbage collector. You’d be wrong.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当`outer_function`执行完毕后，你可能预期该执行上下文内部的所有内容都会被垃圾回收器销毁。你会错的。
- en: It’s not destroyed because a reference to the `inner_function` has been saved
    in the global scope in the variable `menu`. Because the `inner_function` needs
    to retain access to all of the variables that were in scope where it was declared,
    it “closes over” the `outer_function` execution context to prevent the garbage
    collector from removing it. This is a closure.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有被销毁，因为在全局作用域中的变量`menu`中保存了对`inner_function`的引用。因为`inner_function`需要保留在它声明时作用域内的所有变量的访问权限，它“覆盖”了`outer_function`执行上下文，以防止垃圾回收器将其移除。这是一个闭包。
- en: '|  |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That brings us back to our first example, so let’s examine why `scoped_var`
    is accessible after the Ajax call returns.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这又带我们回到了第一个例子，让我们来分析为什么在Ajax调用返回后`scoped_var`仍然是可访问的。
- en: '![](056fig01.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图片](056fig01.jpg)'
- en: It’s accessible because the success method is defined in the execution context
    created when `sendAjaxRequest` was called, and `scoped_var` was in scope at the
    time. If closures are still unclear to you, don’t be dismayed. Closures are one
    of the more difficult JavaScript concepts, and if after reading this section a
    few times you still don’t get it, just move on; it could be a concept that you
    need some more practical experience with in order to understand. Hopefully, by
    the end of this book you’ll have enough practical experience that it’ll become
    second nature to you.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 它是可访问的，因为成功方法是在调用`sendAjaxRequest`时创建的执行上下文中定义的，而`scoped_var`当时是有效的。如果你对闭包仍然感到困惑，不要灰心。闭包是JavaScript中较为复杂的概念之一，如果在阅读本节几次之后你仍然不理解，请继续前进；这可能是一个需要更多实践经验才能理解的概念。希望到本书结束时，你将拥有足够的实践经验，使其变得自然而然。
- en: And this concludes our head-long and sometimes deep dive into the particulars
    of JavaScript. The review wasn’t comprehensive, but instead focused on the concepts
    we’ve found necessary to develop large-scale SPAs. We hope you enjoyed the ride.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们深入探讨了JavaScript的细节，虽然这次回顾并不全面，但重点在于我们认为对于开发大规模SPA所必需的概念。我们希望您享受这次旅程。
- en: 2.7\. Summary
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7\. 摘要
- en: In this chapter we’ve covered some concepts that, though not unique to JavaScript,
    are sometimes not found in other widely used programming languages. Knowledge
    of these topics will be important to writing a single page application—without
    this knowledge you could end up feeling lost as we build out the application.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些概念，虽然这些概念并非JavaScript独有，但在其他广泛使用的编程语言中有时也找不到。对这些主题的了解对于编写单页应用至关重要——如果没有这些知识，在构建应用的过程中你可能会感到迷茫。
- en: Understanding variable scoping, and variable and function hoisting, is fundamental
    to demystifying variables in JavaScript. Understanding the execution context object
    is important for understanding how scoping and hoisting work.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 理解变量作用域、变量提升和函数提升是揭开JavaScript中变量神秘面纱的基础。理解执行上下文对象对于理解作用域和提升的工作方式至关重要。
- en: 'Knowing how to create objects in JavaScript using prototypes makes it possible
    to write reusable code in native JavaScript. Without an understanding of prototype-based
    objects, engineers often revert to using a library to write reusable code, depending
    on a class-based model provided by a library that’s actually a wrapper on top
    of the prototype-based model. If, after learning the prototype-based method, you
    still prefer to use a class-based system, you’ll still be able to take advantage
    of the prototype-based model for the simple use cases. For building our single
    page application, we’ll be using the prototype-based model for two reasons: we
    believe it’s simpler to use for our use cases, and it’s the JavaScript way and
    we’re coding in JavaScript.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何在JavaScript中使用原型创建对象，使得使用原生JavaScript编写可重用代码成为可能。如果没有理解基于原型的对象，工程师通常会回退到使用库来编写可重用代码，依赖于库提供的基于类的模型，而实际上这个库是在基于原型的模型之上构建的包装。如果你在学习了基于原型的方法之后仍然偏好使用基于类的系统，你仍然可以利用基于原型的模型来处理简单用例。对于构建我们的单页应用，我们将使用基于原型的模型，原因有两个：我们相信它对于我们的用例来说更简单易用，而且这是JavaScript的方式，我们正在用JavaScript进行编码。
- en: Writing self-executing anonymous functions will contain your variable scope,
    help prevent you from inadvertently polluting the global namespace, and help you
    write libraries and a codebase that don’t conflict with other libraries.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自执行的匿名函数将包含你的变量作用域，帮助你防止无意中污染全局命名空间，并帮助你编写不与其他库冲突的库和代码库。
- en: Understanding the module pattern and how to use private variables allows you
    to cultivate a thoughtful public API for your objects and to hide all of the messy
    internal methods and variables that other objects don’t need access to. This keeps
    your API nice and clean and makes it obvious which methods you should be consuming
    and which are meant to be private helper methods for the API.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 理解模块模式以及如何使用私有变量，可以使你为你的对象培养一个深思熟虑的公共API，并隐藏所有其他对象不需要访问的混乱的内部方法和变量。这使你的API既整洁又清晰，并使你明确知道哪些方法是应该消费的，哪些是API的私有辅助方法。
- en: 'Finally, we spent a good deal of time diving into one of the most difficult
    JavaScript concepts: closures. If you don’t fully understand closures just yet,
    hopefully there will be enough practical experience throughout the book to cement
    your understanding.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们花了很多时间深入探讨最困难的JavaScript概念之一：闭包。如果你至今还没有完全理解闭包，希望本书中的足够实践经验能帮助你巩固理解。
- en: With these concepts in mind, let’s move on to the next chapter and start building
    a production-quality SPA.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些概念，让我们继续进入下一章，开始构建一个具有生产质量的SPA。
