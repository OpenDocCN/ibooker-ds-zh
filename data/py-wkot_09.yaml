- en: 9 Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 对象
- en: 'Object-oriented programming has become a mainstream, or even **the** mainstream,
    way of approaching programming. The idea is a simple one: instead of defining
    our functions in one part of the code, and the data on which those functions operate
    in a separate part of the code, we define them together.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程已经成为主流，甚至可以说是**主流**的编程方式。这个想法很简单：我们不是在代码的一个部分定义我们的函数，在代码的另一个部分定义那些函数操作的数据，而是将它们一起定义。
- en: Or, to put it in terms of language, in traditional, *procedural* programming,
    we write a list of nouns (data) and a separate list of verbs (functions), leaving
    it up to the programmer to figure out which goes with which. In object-oriented
    programming, the verbs (functions) are defined along with the nouns (data), helping
    us to know what goes with what.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，用语言来说，在传统的、*过程式*编程中，我们编写一个名词（数据）列表和一个单独的动词（函数）列表，让程序员去判断哪个与哪个对应。在面向对象编程中，动词（函数）与名词（数据）一起定义，帮助我们了解什么与什么对应。
- en: In the world of object-oriented programming, each noun is an *object*. We say
    that each object has a *type*, or a *class*, to which it belongs. And the verbs
    (functions) we can invoke on each object are known as *methods*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程的世界里，每个名词都是一个*对象*。我们说每个对象都有一个*类型*，或一个*类*，它属于这个类别。我们可以对每个对象调用的动词（函数）被称为*方法*。
- en: 'For an example of traditional, procedural programming versus object-oriented
    programming, consider how we could calculate a student’s final grade, based on
    the average of their test scores. In procedural programming, we’d make sure the
    grades were in a list of integers and then write an `average` function that returned
    the arithmetic mean:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以传统过程式编程与面向对象编程的对比为例，考虑我们如何根据学生的测试成绩平均值来计算学生的最终成绩。在过程式编程中，我们会确保成绩在整数列表中，然后编写一个返回算术平均值的`average`函数：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code works, and works reliably. But the caller is responsible for keeping
    track of the numbers as a list ... and for knowing that we have to call the `average`
    method ... and for combining them in the right way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是有效的，并且可靠地工作。但是调用者负责跟踪数字作为列表……并知道我们必须调用`average`方法……以及以正确的方式将它们组合起来。
- en: In the object-oriented world, we would approach the problem by creating a new
    data type, which we might call a `ScoreList`. We would then create a new instance
    of `ScoreList`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的世界中，我们会通过创建一个新的数据类型来解决这个问题，我们可能称之为`ScoreList`。然后我们创建一个`ScoreList`的新实例。
- en: 'Even if it’s the same data underneath, a `ScoreList` is more explicitly and
    specifically connected to our domain than a generic Python list. We could then
    invoke the appropriate method on the `ScoreList` object:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使底层数据相同，`ScoreList`与我们的领域相比，比通用的Python列表更明确和具体地关联。然后我们可以对`ScoreList`对象调用适当的方法：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, there’s no difference from the procedural method in what’s actually
    being calculated, and even what technique we’re using to calculate it. But there’s
    an organizational and semantic difference here, one that allows us to think in
    a different way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实际计算的内容与过程式方法没有区别，甚至我们用来计算的技术也没有区别。但这里有一个组织和语义上的区别，它允许我们以不同的方式思考。
- en: We’re now thinking at a higher level of abstraction and can better reason about
    our code. Defining our own types also allows us to use shorthand when describing
    concepts. Consider the difference between telling someone that you bought a “bookshelf”
    and describing “wooden boards held together with nails and screws, stored upright
    and containing places for storing books.” The former is shorter, less ambiguous,
    and more semantically powerful than the latter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在更高层次的抽象中思考，并能更好地推理我们的代码。定义我们自己的类型还允许我们在描述概念时使用缩写。考虑一下告诉某人你买了一“书架”和描述“用钉子和螺丝固定在一起的木板，直立存放并包含存放书籍的地方”之间的区别。前者更简短，更不模糊，语义上更强大。
- en: Another advantage is that if we decide to calculate the average in a new way--for
    example, some teachers might drop the lowest score--then we can keep the existing
    interface while modifying the underlying implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，如果我们决定以新的方式计算平均值——例如，一些老师可能会去掉最低分——那么我们可以在修改底层实现的同时保持现有的接口。
- en: So, what are the main reasons for using object-oriented techniques?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用面向对象技术的最主要原因是什么？
- en: We can organize our code into distinct objects, each of which handles a different
    aspect of our code. This makes for easier planning and maintenance, as well as
    allowing us to divide a project among multiple people.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将我们的代码组织成不同的对象，每个对象处理我们代码的不同方面。这使得规划和维护更容易，同时允许我们将项目分配给多个人。
- en: We can create hierarchies of classes, with each child in the hierarchy inheriting
    functionality from its parents. This reduces the amount of code we need to write
    and simultaneously reinforces the relationships among similar data types. Given
    that many classes are slight modifications of other ones, this saves time and
    coding.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建类的层次结构，其中每个子类都从其父类继承功能。这减少了我们需要编写的代码量，同时加强了相似数据类型之间的关系。鉴于许多类只是对其他类的轻微修改，这节省了时间和编码。
- en: By creating data types that work the same way as Python’s built-in types, our
    code feels like a natural extension to the language, rather than bolted on. Moreover,
    learning how to use a new class requires learning only a tiny bit of syntax, so
    you can concentrate on the underlying ideas and functionality.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建与Python内置类型工作方式相同的数据类型，我们的代码感觉像是语言的自然扩展，而不是附加的。此外，学习如何使用新类只需要学习一点语法，因此你可以专注于底层思想和功能。
- en: While Python doesn’t hide code or make it private, you’re still likely to hear
    about the difference between an object’s implementation and its interface. If
    I’m using an object, then I care about its interface--that is, the methods that
    I can call on it and what they do. How the object is implemented internally is
    not a priority for me and doesn’t affect my day-to-day work. This way, I can concentrate
    on the coding I want to do, rather than the internals of the class I’m using,
    taking advantage of the abstraction that I’ve created via the class.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 Python 不隐藏代码或使其私有，但你仍然可能会听到关于对象的实现和接口之间的区别。如果我在使用一个对象，那么我关心的是它的接口——即我可以调用的方法和它们做什么。对象内部是如何实现的对我来说不是优先考虑的，也不影响我的日常工作。这样，我可以专注于我想要做的编码，而不是我使用的类的内部，利用我通过类创建的抽象。
- en: Object-oriented programming isn’t a panacea; over the years, we’ve found that,
    as with all other paradigms, it has both advantages and disadvantages. For example,
    it’s easy to create monstrously large objects with huge numbers of methods, effectively
    creating a procedural system disguised as an object-oriented one. It’s possible
    to abuse inheritance, creating hierarchies that make no sense. And by breaking
    the system into many small pieces, there’s the problem of testing and integrating
    those pieces, with so many possible lines of communication.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程并非万能；多年来，我们发现，与其他所有范式一样，它既有优点也有缺点。例如，很容易创建具有大量方法的巨大对象，实际上创建了一个伪装成面向对象的程序化系统。可能滥用继承，创建没有意义的层次结构。通过将系统分解成许多小块，存在测试和集成这些块的问题，因为存在许多可能的通信线路。
- en: Nevertheless, the object paradigm has helped numerous programmers to modularize
    their code, to focus on specific aspects of the program on which they’re working,
    and to exchange data with objects written by other people.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，面向对象范式已经帮助许多程序员模块化他们的代码，专注于他们正在工作的程序的具体方面，并与其他人编写的对象交换数据。
- en: In Python, we love to say that “everything is an object.” At its heart, this
    means that the language is consistent; the types (such as `str` and `dict`) that
    come with the language are defined as classes, with methods. Our objects work
    just like the built-in objects, reducing the learning curve for both those implementing
    new classes and those using them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们喜欢说“一切皆对象。”在本质上，这意味着语言是一致的；语言附带类型（如 `str` 和 `dict`）被定义为具有方法的类。我们的对象工作方式与内置对象一样，减少了实现新类和使用它们的人的学习曲线。
- en: Consider that when you learn a foreign language, you discover that nouns and
    verbs have all sorts of rules. But then there are the inevitable inconsistencies
    and exceptions to those rules. By having one consistent set of rules for all objects,
    Python removes those frustrations for non-native speakers--giving us, for lack
    of a better term, the Esperanto of programming languages. Once you’ve learned
    a rule, you can apply it throughout the language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到当你学习一门外语时，你会发现名词和动词都有各种各样的规则。但随后必然会有那些规则的不可避免的不一致和例外。通过为所有对象提供一套一致的规则，Python消除了非母语人士的这些挫折——用更好的词来说，就是编程语言的世界语。一旦你学会了规则，你就可以在整个语言中应用它。
- en: '*Note* One of the hallmarks of Python is its consistency. Once you learn a
    rule, it applies to the entire language, with no exceptions. If you understand
    variable lookup (LEGB, described in chapter 6) and attribute lookup (ICPO, described
    later in this chapter), you’ll know the rules that Python applies all of the time,
    to all objects, without exception--both those that you create and those that come
    baked into the language.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* Python 的一个显著特点是它的一致性。一旦您学会了一条规则，它就适用于整个语言，没有例外。如果您理解了变量查找（LEGB，在第 6 章中描述）和属性查找（ICPO，在本章后面描述），您就会知道
    Python 一直应用于所有对象，包括您创建的和语言内建的对象的规则。'
- en: At the same time, Python doesn’t force you to write everything in an object-oriented
    style. Indeed, it’s common to combine paradigms in Python programs, using an amalgam
    of procedural, functional, and object-oriented styles. Which style you choose,
    and where, is left up to you. But at the end of the day, even if you’re not writing
    in an object-oriented style, you’re still using Python’s objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Python 不会强迫您以面向对象的方式编写所有内容。实际上，在 Python 程序中结合范式是很常见的，使用过程式、函数式和面向对象风格的混合体。您选择哪种风格，以及在哪里使用，完全取决于您。但最终，即使您不以面向对象的方式编写，您仍然在使用
    Python 的对象。
- en: If you’re going to code in Python, you should understand Python’s object system--the
    ways objects are created, how classes are defined and interact with their parents,
    and how we can influence the ways classes interact with the rest of the world.
    Even if you write in a procedural style, you’ll still be using classes defined
    by other people, and knowing how those classes work will make your coding easier
    and more straightforward.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算用 Python 编程，您应该了解 Python 的对象系统——对象的创建方式、类的定义及其与父类的交互方式，以及我们如何影响类与外部世界的交互方式。即使您以过程式风格编写，您仍然会使用其他人定义的类，了解这些类的工作方式会使您的编码更加容易和直接。
- en: This chapter contains exercises aimed at helping you to feel more comfortable
    with Python’s objects. As you go through these exercises, you’ll create classes
    and methods, create attributes at the object and class levels, and work with such
    concepts as composition and inheritance. When you’re done, you’ll be prepared
    to create and work with Python objects, and thus both write and maintain Python
    code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含旨在帮助您更加熟悉 Python 对象的练习。随着您完成这些练习，您将创建类和方法，在对象和类级别上创建属性，并处理诸如组合和继承等概念。完成之后，您将准备好创建和使用
    Python 对象，从而编写和维护 Python 代码。
- en: '*Note* The previous chapter, about modules, was short and simple. This chapter
    is the opposite--long, with many important ideas that can take some time to absorb.
    This chapter will take time to get through, but it’s worth the effort. Understanding
    object-oriented programming won’t just help you in writing your own classes; it’ll
    also help you to understand how Python itself is built, and how the built-in types
    work.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 前一章关于模块的章节简短且简单。这一章则相反——篇幅长，包含许多需要时间吸收的重要思想。这一章需要花费时间来理解，但这是值得的。理解面向对象编程不仅可以帮助您编写自己的类，还可以帮助您理解
    Python 本身是如何构建的，以及内建类型是如何工作的。'
- en: Table 9.1 What you need to know
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 您需要了解的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| `class` | Keyword for creating Python classes | `class Foo` | [http://mng.bz/1zAV](http://mng.bz/1zAV)
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `class` | 创建 Python 类的关键字 | `class Foo` | [http://mng.bz/1zAV](http://mng.bz/1zAV)
    |'
- en: '| `__init__` | Method invoked automatically when a new instance is created
    | `def __init__(self):` | [http://mng.bz/PAa9](http://mng.bz/PAa9) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `__init__` | 在创建新实例时自动调用的方法 | `def __init__(self):` | [http://mng.bz/PAa9](http://mng.bz/PAa9)
    |'
- en: '| `__repr__` | Method that returns a string containing an object’s printed
    representation | `def __repr__(self):` | [http://mng.bz/Jyv0](http://mng.bz/Jyv0)
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `__repr__` | 返回包含对象打印表示的字符串的方法 | `def __repr__(self):` | [http://mng.bz/Jyv0](http://mng.bz/Jyv0)
    |'
- en: '| `super` built-in | Returns a proxy object on which methods can be invoked;
    typically used to invoke a method on a parent class | `super().__init__()` | [http://mng.bz/wB0q](http://mng.bz/wB0q)
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `super` 内置 | 返回一个代理对象，可以在其上调用方法；通常用于在父类上调用方法 | `super().__init__()` | [http://mng.bz/wB0q](http://mng.bz/wB0q)
    |'
- en: '| `dataclasses .dataclass` | A decorator that simplifies the definition of
    classes | `@dataclass` | [http://mng.bz/qMew](http://mng.bz/qMew) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `dataclasses .dataclass` | 简化类定义的装饰器 | `@dataclass` | [http://mng.bz/qMew](http://mng.bz/qMew)
    |'
- en: Exercise 38 ■ Ice cream scoop
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 38 ■ 冰淇淋勺
- en: If you’re going to be programming with objects, then you’ll be creating classes--lots
    of classes. Each class should represent one type of object and its behavior. You
    can think of a class as a factory for creating objects of that type--so a `Car`
    class would create cars, also known as “car objects” or “instances of `Car`.”
    Your beat-up sedan would be a car object, as would a fancy new luxury SUV.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算用面向对象的方式编程，那么你将需要创建类——很多类。每个类都应该代表一种对象及其行为。你可以把类想象成一个工厂，用于创建该类型的对象——所以一个`Car`类将创建汽车，也称为“汽车对象”或`Car`的“实例”。你的破旧的轿车就是一个汽车对象，同样，一辆豪华的新SUV也是。
- en: In this exercise, you’ll define a class, `Scoop`, that represents a single scoop
    of ice cream. Each scoop should have a single attribute, `flavor`, a string that
    you can initialize when you create the instance of `Scoop`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将定义一个名为`Scoop`的类，它代表一份冰淇淋。每份冰淇淋应该有一个属性，`flavor`，这是一个字符串，你可以在创建`Scoop`实例时初始化它。
- en: Once your class is created, write a function (`create_scoops`) that creates
    three instances of the `Scoop` class, each of which has a different `flavor` (figure
    9.1). Put these three instances into a list called `scoops` (figure 9.2). Finally,
    iterate over your `scoops` list, printing the `flavor` of each scoop of ice cream
    you’ve created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了类，就编写一个函数（`create_scoops`），该函数创建`Scoop`类的三个实例，每个实例都有不同的`flavor`（图9.1）。将这些三个实例放入一个名为`scoops`的列表中（图9.2）。最后，遍历`scoops`列表，打印你创建的每一份冰淇淋的`flavor`。
- en: '![](../Images/9-1.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-1.png)'
- en: Figure 9.1 Three instances of `Scoop`, each referring to its class
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 `Scoop`的三个实例，每个都指向其类
- en: '![](../Images/9-2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-2.png)'
- en: Figure 9.2 Our three instances of `Scoop` in a list
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 `Scoop`的三个实例在列表中
- en: Working it out
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: The key to understanding objects in Python--and much of the Python language--is
    attributes. Every object has a type and one or more attributes. Python itself
    defines some of these attributes; you can identify them by the `__` (often known
    as *dunder* in the Python world) at the beginning and end of the attribute names,
    such as `__name__` or `__init__`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Python中的对象——以及Python语言的大部分内容——的关键是属性。每个对象都有一个类型和一个或多个属性。Python本身定义了一些这些属性；你可以通过属性名开头和结尾的`__`（在Python世界中通常被称为*dunder*）来识别它们，例如`__name__`或`__init__`。
- en: When we define a new class, we do so with the `class` keyword. We then name
    the class (`Scoop`, in this case) and indicate, in parentheses, the class or classes
    from which our new class inherits.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个新的类时，我们使用`class`关键字来定义。然后我们命名这个类（在这个例子中是`Scoop`），并在括号中指明我们的新类从哪些类继承。
- en: Our `__init__` method is invoked after the new instance of `Scoop` has been
    created, but before it has been returned to whoever invoked `Scoop('flavor')`.
    The new object is passed to `__init__` in `self` (i.e., the first parameter),
    along with whatever arguments were passed to `Scoop()`. We thus assign `self.flavor`
    `=` `flavor`, creating the `flavor` attribute on the new instance, with the value
    of the `flavor` parameter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`__init__`方法在创建`Scoop`的新实例之后、在将其返回给调用`Scoop('flavor')`的人之前被调用。新对象通过`self`（即第一个参数）传递给`__init__`，包括传递给`Scoop()`的任何参数。因此，我们将`self.flavor`赋值为`flavor`，在新的实例上创建一个`flavor`属性，其值为`flavor`参数。
- en: Talking about your “self”
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论你的“self”
- en: The first parameter in every method is traditionally called `self`. However,
    `self` isn’t a reserved word in Python; the use of that word is a convention and
    comes from the Smalltalk language, whose object system influenced Python’s design.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法中的第一个参数传统上被称为`self`。然而，`self`在Python中不是一个保留字；使用该词是一种约定，它来自Smalltalk语言，该语言的对象系统影响了Python的设计。
- en: In many languages, the current object is known as `this`. Moreover, in such
    languages, `this` isn’t a parameter, but rather a special word that refers to
    the current object. Python doesn’t have any such special word; the instance on
    which the method was invoked will always be known as `self`, and `self` will always
    be the first parameter in every method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，当前对象被称为`this`。此外，在这些语言中，`this`不是一个参数，而是一个特殊词，它指向当前对象。Python没有这样的特殊词；被调用的方法所在的实例始终被称为`self`，并且`self`始终是每个方法的第一个参数。
- en: In theory, you can use any name you want for that first parameter, including
    `this`. (But, really, what self-respecting language would do so?) Although your
    program will still work, all Python developers and tools assume that the first
    parameter, representing the instance, will be called `self`, so you should do
    so too.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以为第一个参数使用任何你想要的名称，包括 `this`。（但，真的，一个有自尊的语言会这样做吗？）尽管你的程序仍然可以工作，但所有的 Python
    开发者和工具都假设代表实例的第一个参数将被命名为 `self`，所以你也应该这样做。
- en: Just as with regular Python functions, there isn’t any enforcement of types
    here. The assumption is that `flavor` will contain a `str` value because the documentation
    will indicate that this is what it expects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规的 Python 函数一样，这里没有对类型的强制执行。假设是 `flavor` 将包含一个 `str` 值，因为文档将表明这是它所期望的。
- en: '*Note* If you want to enforce things more strictly, then consider using Python’s
    type annotations and Mypy or a similar type-checking tool. You can find more information
    about Mypy at [http://mypy-lang.org/](http://mypy-lang.org/). Also, you can find
    an excellent introduction to Python’s type annotations and how to use them at
    [http://mng.bz/mByr](http://mng.bz/mByr).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 如果你想要更严格地执行，那么考虑使用 Python 的类型注解和 Mypy 或类似的类型检查工具。你可以在 [http://mypy-lang.org/](http://mypy-lang.org/)
    找到更多关于 Mypy 的信息。此外，你可以在 [http://mng.bz/mByr](http://mng.bz/mByr) 找到关于 Python 类型注解及其使用方法的优秀介绍。'
- en: 'To create three scoops, I use a list comprehension, iterating over the flavors
    and creating new instances of `Scoop`. The result is a list with three `Scoop`
    objects in it, each with a separate `flavor`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建三个冰淇淋球，我使用列表推导式，遍历口味并创建 `Scoop` 的新实例。结果是包含三个 `Scoop` 对象的列表，每个对象都有一个单独的 `flavor`：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you’re used to working with objects in another programming language, you
    might be wondering where the “getter” and “setter” methods are, to retrieve and
    set the value of the `flavor` attribute. In Python, because everything is public,
    there’s no real need for getters and setters. And indeed, unless you have a really
    good reason for it, you should probably avoid writing them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于在另一种编程语言中使用对象，你可能想知道“获取器”和“设置器”方法在哪里，以检索和设置 `flavor` 属性的值。在 Python 中，因为一切都是公开的，所以实际上并不需要获取器和设置器。实际上，除非你真的有很好的理由，否则你最好避免编写它们。
- en: '*Note* If and when you find yourself needing a getter or setter, you might
    want to consider a Python *property*, which hides a method call behind the API
    of an attribute change or retrieval. You can learn more about properties here:
    [http://mng.bz/5aWB](http://mng.bz/5aWB).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 如果你发现自己需要获取器或设置器，你可能想要考虑使用 Python 的 *property*，它将方法调用隐藏在属性更改或检索的 API 之后。你可以在这里了解更多关于
    property 的信息：[http://mng.bz/5aWB](http://mng.bz/5aWB)。'
- en: I should note that even our simple `Scoop` class exhibits several things that
    are common to nearly all Python classes. We have an `__init__` method, whose parameters
    allow us to set attributes on newly created instances. It stores state inside
    `self`, and it can store any type of Python object in this way--not just strings
    or numbers, but also lists and dicts, as well as other types of objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，即使是我们的简单 `Scoop` 类也展示了几乎所有 Python 类都有的几个共同点。我们有一个 `__init__` 方法，其参数允许我们在新创建的实例上设置属性。它在
    `self` 中存储状态，并且可以通过这种方式存储任何类型的 Python 对象——不仅仅是字符串或数字，还包括列表和字典，以及其他类型的对象。
- en: '*Note* Don’t make persimmon ice cream. Your family will never let you forget
    it.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 不要尝试制作柿子冰淇淋。你的家人永远不会让你忘记这件事。'
- en: Solution
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Every method’s first parameter is always going to be “self,” representing
    the current instance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个方法的第一参数始终将是“self”，代表当前实例。
- en: ❷ Sets the “flavor” attribute to the value in the parameter “flavor”
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将“flavor”属性设置为参数“flavor”中的值
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    8pMZ](http://mng.bz/8pMZ).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行此代码的版本，链接为 [http://mng.bz/8pMZ](http://mng.bz/8pMZ)。
- en: Screencast solution
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'If you’re coding in Python, you’ll likely end up writing classes on a regular
    basis. And if you’re doing that, you’ll be writing many `__init__` methods that
    add attributes to objects of various sorts. Here are some additional, simple classes
    that you can write to practice doing so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用 Python 编码，你很可能会定期编写类。如果你这样做，你将编写许多 `__init__` 方法，这些方法向各种类型的对象添加属性。以下是一些额外的简单类，你可以编写来练习这样做：
- en: 'Write a `Beverage` class whose instances will represent beverages. Each beverage
    should have two attributes: a name (describing the beverage) and a temperature.
    Create several beverages and check that their names and temperatures are all handled
    correctly.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `Beverage` 类，其实例将表示饮料。每个饮料应该有两个属性：一个名称（描述饮料）和一个温度。创建几个饮料并检查它们的名称和温度是否都处理得当。
- en: Modify the `Beverage` class, such that you can create a new instance specifying
    the name, and not the temperature. If you do this, then the temperature should
    have a default value of 75 degrees Celsius. Create several beverages and double-check
    that the temperature has this default when not specified.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `Beverage` 类，以便你可以创建一个指定名称的新实例，而不是温度。如果你这样做，那么温度应该有一个默认值75摄氏度。创建几个饮料并确保在未指定时温度具有此默认值。
- en: Create a new `LogFile` class that expects to be initialized with a filename.
    Inside of `__init__`, open the file for writing and assign it to an attribute,
    `file`, that sits on the instance. Check that it’s possible to write to the file
    via the `file` attribute.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 `LogFile` 类，它期望使用文件名进行初始化。在 `__init__` 中，打开文件以供写入，并将其分配给一个名为 `file` 的属性，该属性位于实例上。检查是否可以通过
    `file` 属性写入文件。
- en: What does __init__ do?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 做什么？'
- en: 'A simple class in Python looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的一个简单类看起来像这样：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And sure enough, with the `Foo` class in place, we can say
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有了 `Foo` 类，我们可以说
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This leads many people, and particularly those who come from other languages,
    to call `__init__` a *constructor*, meaning the method that actually creates a
    new instance of `Foo`. But that’s not quite the case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致许多人，尤其是那些来自其他语言的人，将 `__init__` 称为 *构造函数*，意味着实际创建 `Foo` 新实例的方法。但情况并非如此。
- en: When we call `Foo(10)`, Python first looks for the `Foo` identifier in the same
    way as it looks for every other variable in the language, following the LEGB rule.
    It finds `Foo` as a globally defined variable, referencing a class. Classes are
    *callable*, meaning that they can be invoked with parentheses. And thus, when
    we ask to invoke it and pass 10 as an argument, Python agrees.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `Foo(10)` 时，Python 首先以与它在语言中查找每个其他变量相同的方式查找 `Foo` 标识符，遵循 LEGB 规则。它找到了全局定义的
    `Foo`，引用了一个类。类是 *可调用的*，这意味着它们可以用括号调用。因此，当我们请求调用它并传递10作为参数时，Python 同意这样做。
- en: But what actually executes? The constructor method, of course, which is known
    as `__new__`. Now, you should almost never implement `__new__` on your own; there
    are some cases in which it might be useful, but in the overwhelming majority of
    cases, you don’t want to touch or redefine it. That’s because `__new__` creates
    the new object, something we don't want to have to deal with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上执行的是什么？当然是构造函数方法，也就是 `__new__`。现在，你应该几乎永远不要自己实现 `__new__`；在某些情况下它可能有用，但在绝大多数情况下，你不想接触或重新定义它。这是因为
    `__new__` 创建新对象，这是我们不想处理的。
- en: 'The `__new__` method also returns the newly created instance of `Foo` to the
    caller. But before it does that, it does one more thing: it looks for, and then
    invokes, the `__init__` method. This means that `__init__` is called after the
    object is created but before it’s returned.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__` 方法也会将新创建的 `Foo` 实例返回给调用者。但在它这样做之前，它还会做一件事：查找并调用 `__init__` 方法。这意味着
    `__init__` 在对象创建后但在返回之前被调用。'
- en: And what does `__init__` do? Put simply, it adds new attributes to the object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `__init__` 做什么呢？简单地说，它向对象添加新属性。
- en: Whereas other programming languages talk about “instance variables” and “class
    variables,” Python developers have only one tool, namely the attribute. Whenever
    you have `a.b` in code, we can say that `b` is an attribute of `a`, meaning (more
    or less) that `b` references an object associated with `a`. You can think of the
    attributes of an object as its own private dict.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言谈论“实例变量”和“类变量”不同，Python 开发者只有一个工具，即属性。每当你在代码中看到 `a.b`，我们可以说 `b` 是 `a`
    的一个属性，这意味着（或多或少）`b` 引用了与 `a` 关联的对象。你可以把对象的属性看作是其自己的私有字典。
- en: The job of `__init__` is thus to add one or more attributes to our new instance.
    Unlike languages such as C# and Java, we don’t just declare attributes in Python;
    we must actually create and assign to them, at runtime, when the new instance
    is created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 的任务因此是向我们的新实例添加一个或多个属性。与C#和Java等语言不同，在Python中，我们不仅声明属性；我们必须在创建新实例时实际创建和分配它们，即在运行时。'
- en: In all Python methods, the `self` parameter refers to the instance. Any attributes
    we add to `self` will stick around after the method returns. And so it’s natural,
    and thus preferred, to assign a bunch of attributes to `self` in `__init__`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有Python方法中，`self` 参数指向实例。我们添加到 `self` 的任何属性在方法返回后都会保留。因此，在 `__init__` 中将大量属性分配给
    `self` 是自然且首选的。
- en: 'Let’s see how this works, step by step. First, let’s define a simple `Person`
    class, which assigns a name to the object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何一步一步工作的。首先，让我们定义一个简单的 `Person` 类，它将一个名字分配给对象：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, let’s create a new instance of `Person`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个新的 `Person` 实例：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What happens inside of Python? First, the `__new__` method, which we never define,
    runs behind the scenes, creating the object, as shown in figure 9.3.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python内部发生了什么？首先，我们从未定义的 `__new__` 方法在幕后运行，创建对象，如图9.3所示。
- en: '![](../Images/9-3.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-3.png)'
- en: Figure 9.3 When we create an object, `__new__` is invoked.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 当我们创建对象时，`__new__` 被调用。
- en: It creates a new instance of `Person` and holds onto it as a local variable.
    But then `__new__` calls `__init__`. It passes the newly created object as the
    first argument to `__init__`, then it passes all additional arguments using `*args`
    and `**kwargs`, as shown in figure 9.4.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个新的 `Person` 实例，并将其作为局部变量保留。然后 `__new__` 调用 `__init__`。它将新创建的对象作为第一个参数传递给
    `__init__`，然后使用 `*args` 和 `**kwargs` 传递所有其他参数，如图9.4所示。
- en: '![](../Images/9-4.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-4.png)'
- en: '`__`Figure 9.4 `new__` then calls `__init__`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`__`图9.4 `new__` 然后调用 `__init__`。'
- en: Now `__init__` adds one or more attributes to the new object, as shown in figure
    9.5, which it knows as `self`, a local variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `__init__` 向新对象添加一个或多个属性，如图9.5所示，它知道为 `self`，一个局部变量。
- en: '![](../Images/9-5.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-5.png)'
- en: Figure 9.5 `__init__` adds attributes to the object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 `__init__` 向对象添加属性。
- en: Finally, `__new__` returns the newly created object to its caller, with the
    attribute that was added, as shown in figure 9.6.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`__new__` 将新创建的对象及其添加的属性返回给其调用者，如图9.6所示。
- en: '![](../Images/9-6.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-6.png)'
- en: Figure 9.6 Finally, `__init__` exits, and the object in `__new__` is returned
    to the caller.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 最后，`__init__` 退出，并在 `__new__` 中创建的对象返回给调用者。
- en: Now, could we add new attributes to our instance after `__init__` has run? Yes,
    absolutely--there’s no technical barrier to doing that. But as a general rule,
    you want to define all of your attributes in `__init__` to ensure that your code
    is as readable and obvious as possible. You can *modify* the values later on,
    in other methods, but the initial definition should really be in `__init__`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`__init__` 运行后，我们能否向我们的实例添加新的属性？是的，绝对可以——这样做没有技术障碍。但作为一般规则，你希望在 `__init__`
    中定义所有属性，以确保你的代码尽可能易于阅读和直观。你可以在其他方法中稍后 *修改* 值，但初始定义应该真正在 `__init__` 中。
- en: Notice, finally, that `__init__` doesn’t use the `return` keyword. That’s because
    its return value is ignored and doesn’t matter. The point of `__init__` lies in
    modifying the new instance by adding attributes, not in yielding a return value.
    Once `__init__` is done, it exits, leaving `__new__` with an updated and modified
    object. `__new__` then returns this new object to its caller.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后，`__init__` 没有使用 `return` 关键字。这是因为它的返回值被忽略，并不重要。`__init__` 的目的是通过添加属性来修改新实例，而不是产生返回值。一旦
    `__init__` 完成，它就会退出，留下更新和修改后的对象给 `__new__`。然后 `__new__` 将这个新对象返回给其调用者。
- en: Exercise 39 ■ Ice cream bowl
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习39 ■ 冰淇淋碗
- en: Whenever I teach object-oriented programming, I encounter people who’ve learned
    it before and are convinced that the most important technique is inheritance.
    Now, inheritance is certainly important, and we’ll look into it momentarily, but
    a more important technique is *composition*, when one object contains another
    object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我教授面向对象编程时，我都会遇到那些之前学过并且确信最重要的技术是继承的人。现在，继承当然很重要，我们稍后会探讨它，但一个更重要的技术是 *组合*，当一个对象包含另一个对象时。
- en: Calling it a technique in Python is a bit overblown, since everything is an
    object, and we can assign objects to attributes. So having one object owned by
    another object is just ... well, it’s just the way that we connect objects together.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中称其为一种技术有点言过其实，因为一切都是对象，我们可以将对象分配给属性。所以一个对象由另一个对象拥有只是...嗯，这只是我们连接对象的方式。
- en: That said, composition is also an important technique, because it lets us create
    larger objects out of smaller ones. I can create a car out of a motor, wheels,
    tires, gearshift, seats, and the like. I can create a house out of walls, floors,
    doors, and so forth. Dividing a project up into smaller parts, defining classes
    that describe those parts, and then joining them together to create larger objects--that’s
    how object-oriented programming works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，组合也是一种重要的技术，因为它允许我们用较小的对象创建较大的对象。我可以从发动机、车轮、轮胎、变速器、座椅等东西中创建一辆车。我可以用墙壁、地板、门等东西创建一栋房子。将项目分解成更小的部分，定义描述这些部分的类，然后将它们组合起来创建更大的对象--这就是面向对象编程的工作方式。
- en: In this exercise, we’re going to see a small-scale version of that. In the previous
    exercise, we created a `Scoop` class that represents one scoop of ice cream. If
    we’re really going to model the real world, though, we should have another object
    into which we can put the scoops. I thus want you to create a `Bowl` class, representing
    a bowl into which we can put our ice cream (figure 9.7); for example
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到这个过程的缩小版。在前一个练习中，我们创建了一个 `Scoop` 类来表示一个冰淇淋球。如果我们真的要模拟现实世界，那么我们应该有一个可以放入冰淇淋球的对象。因此，我想让你创建一个
    `Bowl` 类，表示一个可以放入我们的冰淇淋的碗（如图9.7）；例如
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/9-7.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片9-7](../Images/9-7.png)'
- en: Figure 9.7 A new instance of `Bowl`, with an empty list of scoops
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片9-7](../Images/9-7.png)'
- en: The result of running `print(b)` should be to display the three ice cream flavors
    in our bowl (figure 9.8). Note that it should be possible to add any number of
    scoops to the bowl using `Bowl.add_scoops`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `print(b)` 的结果应该是在我们的碗中显示三种冰淇淋口味（如图9.8）。注意，应该可以使用 `Bowl.add_scoops` 添加任意数量的冰淇淋球。
- en: '![](../Images/9-8.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片9-8](../Images/9-8.png)'
- en: Figure 9.8 Three `Scoop` objects in our bowl
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 我们碗中的三个 `Scoop` 对象
- en: Working it out
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: The solution doesn’t involve any changes to our `Scoop` class. Rather, we create
    our `Bowl` such that it can contain any number of instances of `Scoop`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案并不涉及对 `Scoop` 类的任何更改。相反，我们创建 `Bowl` 以使其可以包含任意数量的 `Scoop` 实例。
- en: First of all, we define the attribute `self.scoops` on our object to be a list.
    We could theoretically use a dict or a set, but given that there aren’t any obvious
    candidates for keys, and that we might want to preserve the order of the scoops,
    I’d argue that a list is a more logical choice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在我们的对象上定义属性 `self.scoops` 为一个列表。理论上我们可以使用字典或集合，但由于没有明显的键候选者，并且我们可能想要保留冰淇淋球的顺序，我认为列表是一个更合理的选择。
- en: Remember that we’re storing instances of Scoop in `self.scoops`. We aren’t just
    storing the string that describes the flavors. Each instance of `Scoop` will have
    its own `flavor` attribute, a string containing the current scoop’s flavor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在 `self.scoops` 中存储的是 `Scoop` 实例。我们不仅仅是存储描述口味的字符串。每个 `Scoop` 实例都将有自己的 `flavor`
    属性，一个包含当前冰淇淋球口味的字符串。
- en: We create the `self.scoops` attribute, as an empty list, in `__init__`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `__init__` 中创建 `self.scoops` 属性，作为一个空列表。
- en: Then we need to define `add_scoops`, which can take any number of arguments--which
    we’ll assume are instances of `Scoop`--and add them to the bowl. This means, almost
    by definition, that we’ll need to use the splat operator (`*`) when defining our
    `*new_scoops` parameter. As a result, `new_scoops` will be a tuple containing
    all of the arguments that were passed to `add_scoops`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要定义 `add_scoops`，它可以接受任意数量的参数--我们假设它们是 `Scoop` 的实例--并将它们添加到碗中。这意味着，几乎根据定义，我们定义
    `*new_scoops` 参数时将需要使用展开运算符（`*`）。因此，`new_scoops` 将是一个包含传递给 `add_scoops` 的所有参数的元组。
- en: '*Note* There’s a world of difference between the variable `new_scoops` and
    the attribute `self.scoops`. The former is a local variable in the function, referring
    to the tuple of `Scoop` objects that the user passed to `add_scoops`. The latter
    is an attribute, attached to the `self` local variable, that refers to the object
    instance on which we’re currently working.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 变量 `new_scoops` 和属性 `self.scoops` 之间有很大的区别。前者是函数中的局部变量，指的是用户传递给 `add_scoops`
    的 `Scoop` 对象的元组。后者是一个属性，附加到 `self` 局部变量上，它指的是我们目前正在工作的对象实例。'
- en: We can then iterate over each element of `scoops`, adding it to the `self.scoops`
    attribute. We do this in a `for` loop, invoking `list.append` on each scoop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以遍历 `scoops` 的每个元素，将其添加到 `self.scoops` 属性中。我们通过 `for` 循环来完成这个操作，并对每个 scoop
    调用 `list.append`。
- en: Finally, to print the scoops, we simply invoke `print(b)`. This has the effect
    of calling the `__repr__` method on our object, assuming that one is defined.
    Our `__repr__` method does little more than invoke `str.join` on the strings that
    we extract from the flavors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了打印勺子，我们只需调用 `print(b)`。这相当于在我们的对象上调用 `__repr__` 方法，假设已经定义了该方法。我们的 `__repr__`
    方法所做的只是对从口味中提取的字符串调用 `str.join`。
- en: repr vs. str
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: repr 与 str
- en: You can define `__repr__`, `__str__`, or both on your objects. In theory, `__repr__`
    produces strings that are meant for developers and are legitimate Python syntax.
    By contrast, `__str__` is how your object should appear to end users.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的对象上定义 `__repr__`、`__str__` 或两者。从理论上讲，`__repr__` 生成的是开发者使用的字符串，并且是合法的 Python
    语法。相比之下，`__str__` 是对象在最终用户面前应该呈现的样子。
- en: In practice, I tend to define `__repr__` and ignore `__str__`. That’s because
    `__repr__` covers both cases, which is just fine if I want all string representations
    to be equivalent. If and when I want to distinguish between the string output
    produced for developers and that produced for end users, I can always add a `__str__`
    later on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我倾向于定义 `__repr__` 并忽略 `__str__`。这是因为 `__repr__` 覆盖了两种情况，如果我想所有字符串表示都相同，那就很好。如果需要区分为开发者生成的字符串和为最终用户生成的字符串，我可以在稍后添加
    `__str__`。
- en: In this book, I’m going to use `__repr__` exclusively. But if you want to use
    `__str__`, that’s fine--and it’ll be more officially correct to boot.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将专门使用 `__repr__`。但如果你想使用 `__str__`，那也是可以的——而且这将更加正式正确。
- en: Notice, however, that we’re not invoking `str.join` on a list comprehension,
    because there are no square brackets. Rather, we’re invoking it on a *generator
    expression*, which you can think of as a lazy-evaluating version of a list comprehension.
    True, in a case like this, there’s really no performance benefit. My point in
    using it was to demonstrate that nearly anywhere you can use a list comprehension,
    you can use a generator expression instead.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并没有在列表推导式中调用 `str.join`，因为没有方括号。相反，我们是在调用一个 *生成器表达式*，你可以将其视为列表推导式的懒加载版本。确实，在这种情况下，实际上并没有性能上的好处。我使用它的目的是为了证明，几乎在任何可以使用列表推导的地方，你都可以使用生成器表达式。
- en: is-a vs. has-a
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: is-a 与 has-a
- en: If you have any experience with object-oriented programming, then you might
    have been tempted to say here that `Scoop` inherits from `Bowl`, or that `Bowl`
    inherits from `Scoop`. Neither is true, because inheritance (which we’ll explore
    later in this chapter) describes a relationship known in computer science as “is-a.”
    We can say that an employee is-a person, or that a car is-a vehicle, which would
    point to such a relationship.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何面向对象编程的经验，那么您可能在这里想说的是 `Scoop` 继承自 `Bowl`，或者 `Bowl` 继承自 `Scoop`。这两种说法都不正确，因为继承（我们将在本章后面探讨）描述的是计算机科学中称为“is-a”的关系。我们可以这样说，员工是个人，或者汽车是车辆，这指向了这样的关系。
- en: In real life, we can say that a bowl contains one or more scoops. In programming
    terms, we’d describe this as `Bowl` has-a `Scoop`. The “has-a” relationship doesn’t
    describe inheritance, but rather composition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们可以说碗包含一个或多个勺子。在编程术语中，我们会描述为 `Bowl` 有 `Scoop`。这种“has-a”关系并不描述继承，而是描述组合。
- en: I’ve found that relative newcomers to object-oriented programming are often
    convinced that if two classes are involved, one of them should probably inherit
    from the other. Pointing out the “is-a” rule for inheritance, versus the “has-a”
    rule for composition, helps to clarify the two different relationships and when
    it’s appropriate to use inheritance versus composition.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，相对较新的面向对象编程者常常认为如果涉及两个类，其中一个可能应该继承自另一个。指出继承的“is-a”规则与组合的“has-a”规则，有助于阐明两种不同的关系以及何时使用继承与组合是合适的。
- en: Solution
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Initializes self.scoops with an empty list
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用空列表初始化 self.scoops
- en: ❷ *new_scoops is just like *args. You can use whatever name you want.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `new_scoops` 就像 `*args`。你可以使用任何你想要的名称。
- en: ❸ Creates a string via str.join and a generator expression
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过 str.join 和生成器表达式创建字符串
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/EdWo](http://mng.bz/EdWo).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Python Tutor 中运行此代码的版本，链接为 [http://mng.bz/EdWo](http://mng.bz/EdWo)。
- en: Screencast solution
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'You’ve now seen how to create an explicit “has-a” relationship between two
    classes. Here are some more opportunities to explore this type of relationship:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何创建两个类之间的显式“具有”关系。这里有更多机会探索这种类型的关系：
- en: Create a `Book` class that lets you create books with a title, author, and price.
    Then create a `Shelf` class, onto which you can place one or more books with an
    `add_book` method. Finally, add a `total_price` method to the `Shelf` class, which
    will total the prices of the books on the shelf.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Book` 类，让你可以用标题、作者和价格创建书籍。然后创建一个 `Shelf` 类，你可以使用 `add_book` 方法将一本或多本书放在上面。最后，给
    `Shelf` 类添加一个 `total_price` 方法，它会计算架子上书籍的总价。
- en: Write a method, `Shelf.has_book`, that takes a single string argument and returns
    `True` or `False`, depending on whether a book with the named title exists on
    the shelf.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个方法 `Shelf.has_book`，它接受一个字符串参数，并根据是否有以该名称命名的书籍存在于架子上返回 `True` 或 `False`。
- en: Modify your `Book` class such that it adds another attribute, `width`. Then
    add a `width` attribute to each instance of `Shelf`. When `add_book` tries to
    add books whose combined widths will be too much for the shelf, raise an exception.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改你的 `Book` 类，使其添加另一个属性 `width`。然后给 `Shelf` 的每个实例添加一个 `width` 属性。当 `add_book`
    尝试添加宽度总和超过架子的书籍时，抛出异常。
- en: Reducing redundancy with dataclass
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据类减少冗余
- en: 'Do you feel like your class definitions repeat themselves? If so, you’re not
    alone. One of the most common complaints I hear from people regarding Python classes
    is that the `__init__` method basically does the same thing in each class: taking
    arguments and assigning them to attributes on `self`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得你的类定义重复了吗？如果你这样想，你并不孤单。我听到的关于 Python 类的最常见抱怨之一是 `__init__` 方法在每个类中基本上都做同样的事情：接受参数并将它们分配给
    `self` 的属性。
- en: 'As of Python 3.7, you can cut out some of the boilerplate class-creation code
    with the `dataclass` decorator, focusing on the code you actually want to write.
    For example, here’s how the `Scoop` class would be defined:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Python 3.7，你可以使用 `dataclass` 装饰器删除一些样板类创建代码，专注于你真正想要编写的代码。例如，以下是 `Scoop`
    类的定义方式：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Look, there’s no `__init__` method! You don’t need it here; the `@dataclass`
    decorator used writes it for you. It also takes care of other things, such as
    comparisons and a better version of `__repr__`. Basically, the whole point of
    data classes is to reduce your workload.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看看，这里没有 `__init__` 方法！你在这里不需要它；使用 `@dataclass` 装饰器会为你写入它。它还负责其他事情，例如比较和 `__repr__`
    的更好版本。基本上，数据类的整个目的就是减少你的工作量。
- en: Notice that we used a type annotation (`str`) to indicate that our `flavor`
    attribute should only take strings. Type annotations are normally optional in
    Python, but if you’re declaring attributes in a data class, then they’re mandatory.
    Python, as usual, ignores these type annotations; as mentioned earlier in this
    chapter, type checking is done by external programs such as Mypy.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用类型注解（`str`）来表示 `flavor` 属性应该只接受字符串。在 Python 中，类型注解通常是可选的，但如果你在数据类中声明属性，那么它们是强制性的。Python，像往常一样，忽略了这些类型注解；如本章前面所述，类型检查是由外部程序（如
    Mypy）完成的。
- en: Also notice that we define `flavor` at the class level, even though we want
    it to be an attribute on our instances. Given that you almost certainly don’t
    want to have the same attribute on both instances and classes, this is fine; the
    `dataclass` decorator will see the attribute, along with its type annotation,
    and will handle things appropriately.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们虽然在类级别上定义了 `flavor`，尽管我们希望它在实例上作为属性。鉴于你几乎肯定不希望在实例和类上都有相同的属性，这是可以的；`dataclass`
    装饰器会看到这个属性，以及它的类型注解，并适当地处理。
- en: 'How about our `Bowl` class? How could we define it with a data class? It turns
    out that we need to provide a bit more information:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Bowl` 类怎么样？我们如何使用数据类来定义它？事实证明，我们需要提供更多一些信息：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s ignore the methods `add_scoops` and `__repr__` and concentrate on the
    start of our class. First, we again use the `@dataclass` decorator. But then,
    when we define our `scoops` attribute, we give not just a type but a default value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们忽略 `add_scoops` 和 `__repr__` 方法，专注于我们类的开头。首先，我们再次使用 `@dataclass` 装饰器。但是，当我们定义
    `scoops` 属性时，我们不仅提供了一个类型，还提供了一个默认值。
- en: Notice that the type that we provide, `List[int]`, has a capital “L”. This means
    that it’s distinct from the built-in `list` type. It comes from the `typing` module,
    which comes with Python and provides us with objects meant for use in type annotations.
    The `List` type, when used by itself, represents a list of any type. But when
    combined with square brackets, we can indicate that all elements of the list `scoops`
    will be objects of type `Scoop`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们提供的类型`List[int]`有一个大写的“L”。这意味着它与内置的`list`类型不同。它来自`typing`模块，这是Python的一部分，为我们提供了用于类型注解的对象。`List`类型，当单独使用时，表示任何类型的列表。但是，当与方括号结合使用时，我们可以表明列表`scoops`的所有元素都将是对类型`Scoop`的对象。
- en: Normally, default values can just be assigned to their attributes. But because
    `scoops` is a list, and thus mutable, we need to get a little fancier. When we
    create a new instance of `Bowl`, we don’t want to get a reference to an existing
    object. Rather, we want to invoke `list`, returning a new instance of `list` and
    assigning it to `scoops`. To do this, we need to use `default_factory`, which
    tells `dataclass` that it shouldn’t reuse existing objects, but should rather
    create new ones.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以直接将默认值赋给它们的属性。但是因为`scoops`是一个列表，并且是可变的，所以我们需要稍微复杂一些。当我们创建一个新的`Bowl`实例时，我们不想获取现有对象的引用。相反，我们希望调用`list`，返回一个新的`list`实例并将其赋值给`scoops`。为此，我们需要使用`default_factory`，它告诉`dataclass`不应重用现有对象，而应创建新的对象。
- en: This book uses the classic, standard way of defining Python classes--partly
    to support people still using Python 3.6, and partly so that you can understand
    what’s happening under the hood. But I wouldn’t be surprised if `dataclass` eventually
    becomes the default way to create Python classes, and if you want to use them
    in your solutions, you should feel free to do so.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用经典的、标准的定义Python类的方法——部分是为了支持仍在使用Python 3.6的人，部分是为了让你了解底层发生了什么。但是，如果`dataclass`最终成为创建Python类的默认方式，并且如果你想在解决方案中使用它们，你应该感到自由地这样做。
- en: How Python searches for attributes
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Python如何搜索属性
- en: In chapter 6, I discussed how Python searches for variables using LEGB--first
    searching in the local scope, then enclosing, then global, and finally in the
    `builtins` namespace. Python adheres to this rule consistently, and knowing that
    makes it easier to reason about the language.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，我讨论了Python如何使用LEGB搜索变量——首先在局部作用域中搜索，然后是封装作用域，然后是全局作用域，最后是在`builtins`命名空间中。Python始终遵守这条规则，了解这一点使得对语言进行推理变得更加容易。
- en: Python similarly searches for attributes along a standard, well-defined path.
    But that path is quite different from the LEGB rule for variables. I call it ICPO,
    short for “instance, class, parents, and object.” I’ll explain how that works.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python同样会沿着一个标准、定义良好的路径搜索属性。但这条路径与变量的LEGB规则相当不同。我称之为ICPO，即“实例、类、父类和对象”。我将解释它是如何工作的。
- en: When you ask Python for `a.b`, it first asks the `a` object whether it has an
    attribute named `b`. If so, then the value associated with `a.b` is returned,
    and that’s the end of the process. That’s the “I” of ICPO--we first check on the
    instance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你要求Python获取`a.b`时，它首先询问`a`对象是否有一个名为`b`的属性。如果有，那么返回与`a.b`关联的值，这就是过程的结束。这就是ICPO中的“I”——我们首先检查实例。
- en: But if `a` doesn’t have a `b` attribute, then Python doesn’t give up. Rather,
    it checks on `a`’s class, whatever it is. Meaning that if `a.b` doesn’t exist,
    we look for `type(a).b`. If that exists, then we get the value back, and the search
    ends. That’s the “C” of ICPO.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`a`没有`b`属性，Python不会放弃。相反，它会检查`a`的类，无论是什么。这意味着如果`a.b`不存在，我们会查找`type(a).b`。如果它存在，那么我们就会得到值，并且搜索结束。这就是ICPO中的“C”。
- en: 'Right away, this mechanism explains why and how methods are defined on classes,
    and yet can be called via the instance. Consider the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，这种机制解释了为什么和方法定义在类上，但可以通过实例调用。考虑以下代码：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we define `s` to be a string. We then invoke `s.upper`. Python asks `s`
    if it has an attribute `upper`, and the answer is no. It then asks if `str` has
    an attribute `upper`, and the answer is **yes**. The method object is retrieved
    from `str` and is then invoked. At the same time, we can talk about the method
    as `str.upper` because it is indeed defined on `str`, and is eventually located
    there.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义`s`为一个字符串。然后我们调用`s.upper`。Python询问`s`是否有名为`upper`的属性，答案是“没有”。然后它询问`str`是否有名为`upper`的属性，答案是“是”。方法对象从`str`中检索出来，然后被调用。同时，我们可以将这个方法称为`str.upper`，因为它确实是在`str`上定义的，并且最终在那里找到。
- en: What if Python can’t find the attribute on the instance or the class? It then
    starts to check on the class’s parents. Until now, we haven’t really seen any
    use of that; all of our classes have automatically and implicitly inherited from
    `object`. But a class can inherit from any other class--and this is often a good
    idea, since the subclass can take advantage of the parent class’s functionality.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 在实例或类上找不到属性，它会开始检查类的父类。到目前为止，我们还没有真正看到它的用途；我们所有的类都自动隐式地继承自 `object`。但一个类可以继承自任何其他类——这通常是一个好主意，因为子类可以利用父类的功能。
- en: 'Here’s an example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Prints 20
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印 20
- en: ❷ Prints 30
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印 30
- en: In this code, we create an instance of `Bar`, a class that inherits from `Foo`
    (figure 9.9).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个 `Bar` 的实例，这是一个继承自 `Foo` 的类（图 9.9）。
- en: '![](../Images/9-9.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-9.png)'
- en: Figure 9.9 `Bar` inherits from `Foo`, which inherits from `object`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 `Bar` 继承自 `Foo`，而 `Foo` 继承自 `object`。
- en: '![](../Images/9-10.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-10.png)'
- en: Figure 9.10 `b` is an instance of `Bar`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 `b` 是 `Bar` 的一个实例。
- en: When we create the instance of `Bar`, Python looks for `__init__`. Where? First
    on the instance, but it isn’t there. Then on the class (`Bar`), but it isn’t there.
    Then it looks at `Bar`’s parent, `Foo`, and it finds `__init__` there. That method
    runs, setting the attribute `x`, and then returns, giving us `b`, an instance
    of `Bar` with `x` equal to 10 (figure 9.10).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `Bar` 的实例时，Python 会寻找 `__init__` 方法。在哪里？首先在实例上，但那里没有。然后在类 (`Bar`) 上，但那里也没有。然后它查看
    `Bar` 的父类 `Foo`，并在那里找到了 `__init__`。该方法运行，设置属性 `x`，然后返回，给我们 `b`，一个 `Bar` 的实例，其
    `x` 等于 10（图 9.10）。
- en: The same thing happens when we invoke `x2`. We look on `b` and can’t find that
    method. We then look on `type(b)`, or `Bar`, and can’t find the method. But when
    we check on `Bar`’s parent, `Foo`, we find it, and that method executes. If we
    had defined a method of our own named `x2` on `Bar`, then that would have executed
    instead of `Foo.x2`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `x2` 时，也会发生相同的情况。我们在 `b` 上查找，找不到该方法。然后我们查找 `type(b)`，或 `Bar`，也找不到该方法。但当我们检查
    `Bar` 的父类 `Foo` 时，我们找到了它，并且该方法被执行。如果我们已经在 `Bar` 上定义了一个名为 `x2` 的自定义方法，那么它将代替 `Foo.x2`
    执行。
- en: Finally, we invoke `x3`. We check on `b` and don’t find it. We check on `Bar`
    and do find it, and that method thus executes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `x3`。我们在 `b` 上检查，但没有找到它。我们在 `Bar` 上检查，确实找到了它，因此该方法被执行。
- en: What if, during our ICPO search, the attribute doesn’t exist on the instance,
    class, or parent? We then turn to the ultimate parent in all of Python, `object`.
    You can create an instance of `object`, but there’s no point in doing so; it exists
    solely so that other classes can inherit from it, and thus get to its methods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的 ICPO 搜索过程中，属性在实例、类或父类上不存在，我们就会转向 Python 中的终极父类 `object`。你可以创建一个 `object`
    的实例，但这样做没有意义；它仅仅存在，以便其他类可以从中继承，从而获得其方法。
- en: As a result, if you don’t define an `__init__` method, then `object.__init__`
    will run. And if you don’t define `__repr__`, then `object.__repr__` will run,
    and so forth.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你没有定义 `__init__` 方法，那么 `object.__init__` 将会运行。如果你没有定义 `__repr__`，那么 `object.__repr__`
    将会运行，依此类推。
- en: The final thing to remember with the ICPO search path is that the first match
    wins. This means that if two attributes on the search path have the same name,
    Python won’t ever find the later one. This is normally a good thing in that it
    allows us to override methods in subclasses. But if you’re not expecting that
    to happen, then you might end up being surprised.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ICPO 搜索路径中需要记住的最后一件事是第一个匹配项获胜。这意味着如果搜索路径上有两个具有相同名称的属性，Python 将永远不会找到后面的一个。通常情况下，这是一个好事，因为它允许我们覆盖子类中的方法。但如果你没有预料到这种情况发生，那么你可能会感到惊讶。
- en: Exercise 40 ■ Bowl limits
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 40 ■ 碗限制
- en: We can add an attribute to just about any object in Python. When writing classes,
    it’s typical and traditional to define data attributes on instances and method
    attributes on classes. But there’s no reason why we can’t define data attributes
    on classes too.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以在 Python 中的任何对象上添加属性。当编写类时，在实例上定义数据属性和在类上定义方法属性是典型和传统的。但也没有理由我们不能在类上定义数据属性。
- en: In this exercise, I want you to define a class attribute that will function
    like a constant, ensuring that we don’t need to hardcode any values in our class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我想让你定义一个类属性，它将像常量一样工作，确保我们不需要在我们的类中硬编码任何值。
- en: 'What’s the task here? Well, you might have noticed a flaw in our `Bowl` class,
    one that children undoubtedly love and their parents undoubtedly hate: you can
    put as many `Scoop` objects in a bowl as you like.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的任务是什么？嗯，您可能已经注意到了我们的`Bowl`类中的一个缺陷，孩子们无疑会喜欢，而父母无疑会讨厌：您可以在碗中放入尽可能多的`Scoop`对象。
- en: Let’s make the children sad, and their parents happy, by capping the number
    of scoops in a bowl at three. That is, you can add as many scoops in each call
    to `Bowl.add_scoops` as you want, and you can call that method as many times as
    you want--but only the first three scoops will actually be added. Any additional
    scoops will be ignored.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将碗中的勺数限制在三个来让孩子们感到难过，让他们的父母感到高兴。也就是说，您可以在每次调用`Bowl.add_scoops`时添加尽可能多的勺数，并且您可以多次调用该方法——但只有前三个勺数实际上会被添加。任何额外的勺数都将被忽略。
- en: Working it out
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: We only need to make two changes to our original `Bowl` class for this to work.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，我们只需要对我们的原始`Bowl`类进行两个更改。
- en: First, we need to define a class attribute on `Bowl`. We do this most easily
    by making an assignment within the class definition (figure 9.11). Setting `max_scoops`
    `=` `3` within the `class` block is the same as saying, afterwards, `Bowl.max_scoops`
    `=` `3`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`Bowl`上定义一个类属性。我们最简单的方法是在类定义内进行赋值（如图9.11所示）。在`class`块内将`max_scoops`
    `=` `3`设置为与之后说`Bowl.max_scoops` `=` `3`相同。
- en: '![](../Images/9-11.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-11.png)'
- en: Figure 9.11 `max_scoops` sits on the class, so even an empty instance has access
    to it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 `max_scoops`位于类上，因此即使是一个空的实例也能访问它。
- en: 'But wait, do we really need to define `max_scoops` on the `Bowl` class? Technically,
    we have two other options:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，我们真的需要在`Bowl`类中定义`max_scoops`吗？技术上，我们还有其他两种选择：
- en: Define the maximum on the instance, rather than the class. This will work (i.e.,
    add `self.max_scoops` `=` `3` in `__init__`), but it implies that every bowl has
    a different maximum number of scoops. By putting the attribute on the class (figure
    9.12), we indicate that every bowl will have the same maximum.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例上定义最大值，而不是在类上。这会起作用（即在`__init__`中添加`self.max_scoops` `=` `3`），但这意味着每个碗的最大勺数都不同。通过将属性放在类上（如图9.12所示），我们表明每个碗都将有相同的最大值。
- en: We could also hardcode the value `3` in our code, rather than use a symbolic
    name such as `max_scoops`. But this will reduce our flexibility, especially if
    and when we want to use inheritance (as we’ll see later). Moreover, if we decide
    to change the maximum down the line, it’s easier to do that in one place, via
    the attribute assignment, rather than in a number of places.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以在我们的代码中硬编码值`3`，而不是使用像`max_scoops`这样的符号名称。但这将减少我们的灵活性，尤其是如果我们想使用继承（我们稍后会看到）的话。此外，如果我们决定稍后更改最大值，通过属性赋值在一个地方更改比在多个地方更改要容易得多。
- en: '![](../Images/9-12.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-12.png)'
- en: Figure 9.12 A `Bowl` instance containing scoops, with `max_scoops` defined on
    the class
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 包含勺子的`Bowl`实例，其中`max_scoops`在类上定义
- en: Second, we need to change `Bowl.add_scoops`, adding an `if` statement to make
    the addition of new scoops conditional on the current length of `self.scoops`
    and the value of `Bowl.max_scoops`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要更改`Bowl.add_scoops`，添加一个`if`语句，使新勺数的添加取决于`self.scoops`的当前长度和`Bowl.max_scoops`的值。
- en: Are class attributes just static variables?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性仅仅是静态变量吗？
- en: If you’re coming from the world of Java, C#, or C++, then class attributes look
    an awful lot like static variables. But they aren’t static variables, and you
    shouldn’t call them that.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自Java、C#或C++的世界，那么类属性看起来非常像静态变量。但它们不是静态变量，您不应该这样称呼它们。
- en: 'Here are a few ways class attributes are different from static variables, even
    though their uses might be similar:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方法说明类属性与静态变量不同，尽管它们的用途可能相似：
- en: First, class attributes are just another case of attributes on a Python object.
    This means that we can and should reason about class attributes the same as all
    others, with the ICPO lookup rule. You can access them on the class (as `ClassName.attrname`)
    or on an instance (as `one_instance.attrname`). The former will work because you’re
    using the class, and the latter will work because after checking the instance,
    Python checks its class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类属性只是Python对象上的属性的另一种情况。这意味着我们可以也应该像对待所有其他属性一样推理类属性，使用ICPO查找规则。您可以在类上访问它们（作为`ClassName.attrname`）或实例上访问（作为`one_instance.attrname`）。前者将起作用，因为您正在使用类，而后者将起作用，因为Python在检查实例后还会检查其类。
- en: In the solution for this exercise, `Bowl.max_scoops` is an attribute on the
    `Bowl` class. We could, in theory, assign `max_scoops` to each individual instance
    of `Bowl`, but it makes more sense to say that all `Bowl` objects have the same
    maximum number of scoops.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习的解决方案中，`Bowl.max_scoops`是`Bowl`类的一个属性。从理论上讲，我们可以将`max_scoops`赋值给`Bowl`的每个单独实例，但说所有`Bowl`对象都有相同的最大勺数更有意义。
- en: Second, static variables are shared among the instances and class. This means
    that assigning to a class variable via an instance has the same effect as assigning
    to it via the class. In Python, there’s a world of difference between assigning
    to the class variable via the instance and doing so via the class; the former
    will add a new attribute to the instance, effectively blocking access to the class
    attribute.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，静态变量在实例和类之间是共享的。这意味着通过实例对类变量进行赋值与通过类进行赋值的效果相同。在Python中，通过实例对类变量进行赋值和通过类进行赋值之间有着天壤之别；前者会在实例上添加一个新的属性，从而阻止对类属性的访问。
- en: That is, if we assign to `Bowl.max_scoops`, then we’re changing the maximum
    number of scoops that all bowls can have. But if we assign to `one_bowl.max_scoops`,
    we’re setting a **new** attribute on the instance `one_bowl`. This will put us
    in the terrible situation of having `Bowl.max_scoops` set to one thing, and `one_bowl.max_scoops`
    set to something else. Moreover, asking for `one_bowl.max_scoops` would (by the
    ICPO rule) stop after finding the attribute on the instance and never look on
    the class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们给`Bowl.max_scoops`赋值，那么我们就是在改变所有碗可以拥有的最大勺数。但如果我们给`one_bowl.max_scoops`赋值，我们就是在实例`one_bowl`上设置一个新的属性。这将使我们陷入一个糟糕的情况，即`Bowl.max_scoops`被设置为一种东西，而`one_bowl.max_scoops`被设置为另一种东西。此外，请求`one_bowl.max_scoops`将（根据ICPO规则）在找到实例上的属性后停止，永远不会查看类。
- en: Third, methods are actually class attributes too. But we don’t think of them
    in that way because they’re defined differently. Whatever we may think, methods
    are created using `def` inside of a class definition.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，方法实际上也是类属性。但我们不这样认为，因为它们的定义方式不同。无论我们怎么想，方法都是通过在类定义内部使用`def`来创建的。
- en: When I invoke `b.add_scoops`, Python looks on `b` for the attribute `add_scoops`
    and doesn’t find it. It then looks on `Bowl` (i.e., `b`’s class) and finds it--and
    retrieves the method object. The parentheses then execute the method. This only
    works if the method is actually defined on the class, which it is. Methods are
    almost always defined on a class, and thanks to the ICPO rule, Python will look
    for them there.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我调用`b.add_scoops`时，Python会在`b`上查找属性`add_scoops`，但找不到。然后它会查找`Bowl`（即`b`的类），并找到它——并检索方法对象。然后括号执行该方法。这只有在方法实际上定义在类上时才有效，它确实是。方法几乎总是定义在类上，多亏了ICPO规则，Python会在这里查找它们。
- en: Finally, Python doesn’t have constants, but we can simulate them with class
    attributes. Much as I did with `max_scoops` earlier, I often define a class attribute
    that I can then access, by name, via both the class and the instances.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Python没有常量，但我们可以通过类属性来模拟它们。就像我之前对`max_scoops`所做的那样，我经常定义一个类属性，然后可以通过类和实例通过名称访问它。
- en: For example, the class attribute `max_scoops` is being used here as a sort of
    constant. Instead of storing the hardcoded number `3` everywhere I need to refer
    to the maximum scoops that can be put in a bowl, I can refer to `Bowl.max_scoops`.
    This both adds clarity to my code and allows me to change the value in the future
    in a single place.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里正在使用类属性`max_scoops`作为某种常量。与其在需要引用可以放入碗中的最大勺数的每个地方都存储硬编码的数字`3`，我可以通过`Bowl.max_scoops`来引用。这既使我的代码更加清晰，也允许我在未来一个地方更改该值。
- en: Solution
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ max_scoops is not a variable--it’s an attribute of the class Bowl.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ max_scoops不是一个变量——它是Bowl类的属性。
- en: ❷ Uses Bowl.max_scoops to get the maximum per bowl, set on the class
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用Bowl.max_scoops获取每个碗的最大值，这是在类上设置的
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    NK6N](http://mng.bz/NK6N).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中通过[http://mng.bz/NK6N](http://mng.bz/NK6N)查看这个代码的版本。
- en: Screencast solution
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'As I’ve indicated, you can use class attributes in a variety of ways. Here
    are a few additional challenges that can help you to appreciate and understand
    how to define and use class attributes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，你可以以多种方式使用类属性。以下是一些额外的挑战，可以帮助你欣赏和理解如何定义和使用类属性：
- en: Define a `Person` class, and a `population` class attribute that increases each
    time you create a new instance of `Person`. Double-check that after you’ve created
    five instances, named `p1` through `p5`, `Person.population` and `p1.population`
    are both equal to `5`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`Person`类，并定义一个`population`类属性，每次创建一个新的`Person`实例时，该属性会增加。确认在创建了五个实例，命名为`p1`到`p5`之后，`Person.population`和`p1.population`都等于`5`。
- en: 'Python provides a `__del__` method that’s executed when an object is garbage
    collected. (In my experience, deleting a variable or assigning it to another object
    triggers the calling of `__del__` pretty quickly.) Modify your `Person` class
    such that when a `Person` instance is deleted, the population count decrements
    by 1\. If you aren’t sure what *garbage collection* is, or how it works in Python,
    take a look at this article: [http://mng.bz/nP2a](http://mng.bz/nP2a).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python提供了一个在对象被垃圾回收时执行的`__del__`方法。（根据我的经验，删除一个变量或将它赋值给另一个对象会很快触发`__del__`的调用。）修改你的`Person`类，使得当删除一个`Person`实例时，人口计数减少1。如果你不确定什么是*垃圾回收*，或者它在Python中是如何工作的，请查看这篇文章：[http://mng.bz/nP2a](http://mng.bz/nP2a)。
- en: Define a `Transaction` class, in which each instance represents either a deposit
    or a withdrawal from a bank account. When creating a new instance of `Transaction`,
    you’ll need to specify an amount--positive for a deposit and negative for a withdrawal.
    Use a class attribute to keep track of the current balance, which should be equal
    to the sum of the amounts in all instances created to date.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`Transaction`类，其中每个实例代表从银行账户的存款或取款。在创建新的`Transaction`实例时，你需要指定一个金额——存款为正数，取款为负数。使用类属性来跟踪当前余额，该余额应等于迄今为止创建的所有实例金额的总和。
- en: Inheritance in Python
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的继承
- en: 'The time has come for us to use inheritance, an important idea in object-oriented
    programming. The basic idea reflects the fact that we often want to create classes
    that are quite similar to one another. We can thus create a *parent* class, in
    which we define the general behavior. And then we can create one or more *child*
    classes, or *subclasses*, each of which inherits from the parent class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用继承的时候到了，这是面向对象编程中的一个重要概念。基本思想反映了这样一个事实：我们经常想要创建彼此非常相似的类。因此，我们可以创建一个*父*类，在其中定义一般行为。然后我们可以创建一个或多个*子*类，或*子类*，每个子类都从父类继承：
- en: If I already have a `Person` class, then I might want to create an `Employee`
    class, which is identical to `Person` except that each employee has an ID number,
    department, and salary.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我已经有一个`Person`类，那么我可能想要创建一个`Employee`类，它与`Person`相同，除了每个员工都有一个ID号、部门和薪水。
- en: If I already have a `Vehicle` class, then I can create a `Car` class, a `Truck`
    class, and a `Bicycle` class.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我已经有一个`Vehicle`类，那么我可以创建一个`Car`类、一个`Truck`类和一个`Bicycle`类。
- en: If I already have a `Book` class, then I can create a `Textbook` class, as well
    as a `Novel` class.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我已经有一个`Book`类，那么我可以创建一个`Textbook`类，以及一个`Novel`类。
- en: As you can see, the idea of a subclass is that it does everything the parent
    class does, but then goes a bit further with more specific functionality. Inheritance
    allows us to apply the DRY principle to our classes, and to keep them organized
    in our heads.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，子类的基本思想是它做所有父类做的事情，但在此基础上增加了更多具体的功能。继承允许我们将DRY原则应用到我们的类中，并使它们在我们的脑海中保持组织。
- en: 'How does inheritance work in Python? Define a second class (i.e., a subclass),
    naming the parent class in parentheses on the first line:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的继承是如何工作的？定义第二个类（即子类），在第一行括号中命名父类：
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ This is how we tell Python that “Employee” is-a “Person,” meaning it inherits
    from “Person.”
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这就是告诉Python“Employee”是“Person”的一种方式，意味着它从“Person”继承。
- en: ❷ Does this look funny to you? It should--more soon.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这看起来很滑稽吗？应该是的——很快就会更多。
- en: 'With this code in place, we can now create an instance of `Employee`, as per
    usual:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好这段代码后，我们现在可以像往常一样创建一个`Employee`实例：
- en: '[PRE16]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But what happens if we invoke `e.greet`? By the ICPO rule, Python first looks
    for the attribute `greet` on the instance `e`, but it doesn’t find it. It then
    looks on the class `Employee` and doesn’t find it. Python then looks on the parent
    class, `Person`, finds it, retrieves the method, and invokes it. In other words,
    inheritance is a powerful idea--but in Python, it’s a natural outgrowth of the
    ICPO rule.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们调用 `e.greet` 会发生什么？根据 ICPO 规则，Python 首先在实例 `e` 上查找属性 `greet`，但没有找到。然后它在类
    `Employee` 上查找，也没有找到。Python 然后在父类 `Person` 上查找，找到了它，检索了方法，并调用了它。换句话说，继承是一个强大的概念——但在
    Python 中，它是 ICPO 规则的自然延伸。
- en: 'There’s one weird thing about my implementation of `Employee`, namely that
    I set `self.name` in `___init__`. If you’re coming from a language like Java,
    you might be wondering why I have to set it at all, since `Person.__init__` already
    sets it. But that’s just the thing: in Python, `__init__` really needs to execute
    for it to set the attribute. If we were to remove the setting of `self.name` from
    `Employee.__init__`, the attribute would **never be set**. By the ICPO rule, only
    one method would ever be called, and it would be the one that’s closest to the
    instance. Since `Employee.__init__` is closer to the instance than `Person.__init__`,
    the latter is never called.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我的 `Employee` 实现有一个奇怪的地方，即我在 `___init__` 中设置了 `self.name`。如果你来自像 Java 这样的语言，你可能会想知道为什么我必须设置它，因为
    `Person.__init__` 已经设置了它。但问题就在这里：在 Python 中，`__init__` 真的需要执行才能设置属性。如果我们从 `Employee.__init__`
    中移除设置 `self.name` 的操作，该属性将**永远不会被设置**。根据 ICPO 规则，只有一个方法会被调用，并且是离实例最近的方法。由于 `Employee.__init__`
    比较接近实例，所以 `Person.__init__` 从未被调用。
- en: The good news is that the code I provided works. But the bad news is that it
    violates the DRY rule that I’ve mentioned so often.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我提供的代码是有效的。但坏消息是，它违反了我经常提到的 DRY 规则。
- en: 'The solution is to take advantage of inheritance via `super`. The `super` built-in
    allows us to invoke a method on a parent object without explicitly naming that
    parent. In our code, we could thus rewrite `Employee.__init__` as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是利用 `super` 实现继承。`super` 内置函数允许我们在不显式命名父对象的情况下调用父对象的方法。在我们的代码中，我们可以将 `Employee.__init__`
    重写如下：
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Implicitly invoking Person.__init__ via super
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过 super 隐式调用 Person.__init__
- en: Exercise 41 ■ A bigger bowl
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 41 ■ 更大的碗
- en: While the previous exercise might have delighted parents and upset children,
    our job as ice cream vendors is to excite the children, as well as take their
    parents’ money. Our company has thus started to offer a `BigBowl` product, which
    can take up to five scoops.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上一个练习可能让父母高兴而让孩子不高兴，但作为冰淇淋摊贩，我们的工作是激发孩子们的兴趣，同时收取他们父母的钱。因此，我们的公司开始提供 `BigBowl`
    产品，它可以容纳多达五个勺子。
- en: Implement `BigBowl` for this exercise, such that the only difference between
    it and the `Bowl` class we created earlier is that it can have five scoops, rather
    than three. And yes, this means that you should use inheritance to achieve this
    goal.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `BigBowl` 以完成此练习，使其与之前创建的 `Bowl` 类的唯一区别是它可以容纳五个勺子，而不是三个。是的，这意味着你应该使用继承来实现这个目标。
- en: You can modify `Scoop` and `Bowl` if you must, but such changes should be minimal
    and justifiable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须修改 `Scoop` 和 `Bowl`，请尽量保持这些更改最小化且合理。
- en: '*Note* As a general rule, the point of inheritance is to add or modify functionality
    in an existing class without modifying the parent. Purists might thus dislike
    these instructions, which allow for changes in the parent class. However, the
    real world isn’t always squeaky clean, and if the classes are both written by
    the same team, it’s possible that the child’s author can negotiate changes in
    the parent class.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 作为一般规则，继承的目的是在不修改父类的情况下向现有类添加或修改功能。纯粹主义者可能会不喜欢这些允许在父类中更改的指令。然而，现实世界并不总是那么干净利落，如果类都是由同一团队编写的，那么子类的作者可以协商对父类的更改。'
- en: Working it out
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: This is, I must admit, a tricky one. It forces you to understand how attributes
    work, and especially how they interact between instances, classes, and parent
    classes. If you really get the ICPO rule, then the solution should make sense.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，这是一个棘手的问题。它迫使你理解属性是如何工作的，特别是它们如何在实例、类和父类之间交互。如果你真的理解了 ICPO 规则，那么解决方案应该是有意义的。
- en: In our previous version of `Bowl.add_scoops`, we said that we wanted to use
    `Bowl.max _scoops` to keep track of the maximum number of scoops allowed. That
    was fine, as long as every subclass would want to use the same value.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前版本的`Bowl.add_scoops`中，我们说我们想要使用`Bowl.max_scoops`来跟踪允许的最大勺数。只要每个子类都想要使用相同的值，这就可以了。
- en: But here, we want to use a different value. That is, when invoking `add_scoops`
    on a `Bowl` object, the maximum should be `Bowl.max_scoops`. And when invoking
    `add_scoops` on a `BigBowl` object, the maximum should be `BigBowl.max_scoops`.
    And we want to avoid writing `add_scoops` twice.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，我们想要使用不同的值。也就是说，当在`Bowl`对象上调用`add_scoops`时，最大值应该是`Bowl.max_scoops`。而当在`BigBowl`对象上调用`add_scoops`时，最大值应该是`BigBowl.max_scoops`。我们还想避免重复编写`add_scoops`。
- en: 'The simplest solution is to change our reference in `add_scoops` from `Bowl.max
    _scoops`, to `self.max_scoops`. With this change in place, things will work like
    this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是将`add_scoops`中的引用从`Bowl.max_scoops`更改为`self.max_scoops`。实施这一更改后，事情将这样进行：
- en: If we ask for `Bowl.max_scoops`, we’ll get `3`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们请求`Bowl.max_scoops`，我们将得到`3`。
- en: If we ask for `BigBowl.max_scoops`, we’ll get `5`.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们请求`BigBowl.max_scoops`，我们将得到`5`。
- en: If we invoke `add_scoops` on an instance of `Bowl`, then inside the method,
    we’ll ask for `self.max_scoops`. By the ICPO lookup rule, Python will look first
    on the instance and then on the class, which is `Bowl` in this case, and return
    `Bowl.max_scoops`, with a value of `3`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在`Bowl`的一个实例上调用`add_scoops`方法，那么在方法内部，我们将请求`self.max_scoops`。根据ICPO查找规则，Python将首先在实例上查找，然后是类，在这个例子中是`Bowl`，并返回`Bowl.max_scoops`，其值为`3`。
- en: If we invoke `add_scoops` on an instance of `BigBowl`, then inside the method
    we’ll ask for `self.max_scoops`. By the iCPO lookup rule, Python will first look
    on the instance, and then on the class, which is `BigBowl` in this case, and return
    `BigBowl.max_scoops`, with a value of `5`.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在`BigBowl`的一个实例上调用`add_scoops`方法，那么在方法内部，我们将请求`self.max_scoops`。根据iCPO查找规则，Python将首先在实例上查找，然后是类，在这个例子中是`BigBowl`，并返回`BigBowl.max_scoops`，其值为`5`。
- en: In this way, we’ve taken advantage of inheritance and the flexibility of `self`
    to use the same interface for a variety of classes. Moreover, we were able to
    implement `BigBowl` with a minimum of code, using what we’d already written for
    `Bowl`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们利用了继承和`self`的灵活性，为各种类使用相同的接口。此外，我们能够以最少的代码实现`BigBowl`，利用了我们之前为`Bowl`编写的代码。
- en: Solution
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Bowl.max_scoops remains 3.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Bowl.max_scoops保持为3。
- en: ❷ Uses self.max_scoops, rather than Bowl.max_scoops, to get the attribute from
    the correct class
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用self.max_scoops而不是Bowl.max_scoops来从正确的类获取属性
- en: ❸ BigBowl.max_scoops is set to 5.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将BigBowl.max_scoops设置为5。
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    D2gn](http://mng.bz/D2gn).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中尝试这个代码的版本：[http://mng.bz/D2gn](http://mng.bz/D2gn)。
- en: Screencast solution
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'As I’ve already indicated in this chapter, I think that many people exaggerate
    the degree to which they should use inheritance in object-oriented code. But that
    doesn’t mean I see inheritance as unnecessary or even worthless. Used correctly,
    it’s a powerful tool that can reduce code size and improve its maintenance. Here
    are some more ways you can practice using inheritance:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章中已经指出的，我认为很多人夸大了在面向对象代码中应该使用继承的程度。但这并不意味着我认为继承是不必要的，甚至是没有价值的。正确使用时，它是一个强大的工具，可以减少代码量并提高其可维护性。以下是一些你可以练习使用继承的更多方法：
- en: 'Write an `Envelope` class, with two attributes, `weight` (a float, measuring
    grams) and `was_sent` (a Boolean, defaulting to `False`). There should be three
    methods: (1) `send`, which sends the letter, and changes `was_sent` to `True`,
    but only after the envelope has enough postage; (2) `add_postage`, which adds
    postage equal to its argument; and (3) `postage_needed`, which indicates how much
    postage the envelope needs total. The postage needed will be the weight of the
    envelope times 10\. Now write a `BigEnvelope` class that works just like `Envelope`
    except that the postage is 15 times the weight, rather than 10.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个`Envelope`类，具有两个属性，`weight`（一个浮点数，表示克）和`was_sent`（一个布尔值，默认为`False`）。应该有三个方法：（1）`send`，发送信件，并将`was_sent`改为`True`，但只有在信封有足够的邮票之后；（2）`add_postage`，添加等于其参数的邮票；（3）`postage_needed`，指示信封总共需要多少邮票。所需邮票将是信封重量乘以10。现在编写一个`BigEnvelope`类，它的工作方式与`Envelope`相同，除了邮票是重量的15倍而不是10。
- en: Create a `Phone` class that represents a mobile phone. (Are there still nonmobile
    phones?) The phone should implement a `dial` method that dials a phone number
    (or simulates doing so). Implement a `SmartPhone` subclass that uses the `Phone.dial`
    method but implements its own `run_app` method. Now implement an `iPhone` subclass
    that implements not only a `run_app` method, but also its own `dial` method, which
    invokes the parent’s `dial` method but whose output is all in lowercase as a sign
    of its coolness.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Phone`类来表示一部手机。（是否还有非手机？）手机应该实现一个`dial`方法，用于拨打电话号码（或模拟拨打）。实现一个`SmartPhone`子类，它使用`Phone.dial`方法，但实现自己的`run_app`方法。现在实现一个`iPhone`子类，它不仅实现了一个`run_app`方法，还实现了自己的`dial`方法，该方法调用父类的`dial`方法，但其输出全部为小写，以示其酷炫。
- en: Define a `Bread` class representing a loaf of bread. We should be able to invoke
    a `get_nutrition` method on the object, passing an integer representing the number
    of slices we want to eat. In return, we’ll receive a dict whose key-value pairs
    will represent calories, carbohydrates, sodium, sugar, and fat, indicating the
    nutritional statistics for that number of slices. Now implement two new classes
    that inherit from `Bread`, namely `WholeWheatBread` and `RyeBread`. Each class
    should implement the same `get_nutrition` method, but with different nutritional
    information where appropriate.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`Bread`类来表示一条面包。我们应该能够在对象上调用`get_nutrition`方法，传递一个表示我们想要吃多少片的整数。作为回报，我们将收到一个字典，其键值对将表示卡路里、碳水化合物、钠、糖和脂肪，表明该数量片的营养统计信息。现在实现两个新的类，它们继承自`Bread`，即`WholeWheatBread`和`RyeBread`。每个类都应该实现相同的`get_nutrition`方法，但在适当的地方使用不同的营养信息。
- en: Exercise 42 ■ FlexibleDict
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习42 ■ FlexibleDict
- en: I’ve already said that the main point of inheritance is to take advantage of
    existing functionality. There are several ways to do this and reasons for doing
    this, and one of them is to create new behavior that’s similar to, but distinct
    from, an existing class. For example, Python comes not just with `dict`, but also
    with `Counter` and `defaultdict`. By inheriting from `dict`, those two classes
    can implement just those methods that differ from `dict`, relying on the original
    class for the majority of the functionality.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经说过，继承的主要目的是利用现有功能。有几种方法可以实现这一点，以及这样做的原因，其中之一是创建与现有类相似但不同的新行为。例如，Python不仅提供了`dict`，还提供了`Counter`和`defaultdict`。通过从`dict`继承，这两个类可以仅实现与`dict`不同的方法，依靠原始类来实现大部分功能。
- en: In this exercise, we’ll also implement a subclass of `dict`, which I call `FlexibleDict`.
    Dict keys are Python objects, and as such are identified with a type. So if you
    use key `1` (an integer) to store a value, then you can’t use key `'1'` (a string)
    to retrieve that value. But `FlexibleDict` will allow for this. If it doesn’t
    find the user’s key, it will try to convert the key to both `str` and `int` before
    giving up; for example
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们还将实现一个`dict`的子类，我称之为`FlexibleDict`。Dict键是Python对象，因此它们与类型相关联。因此，如果您使用键`1`（一个整数）来存储值，那么您就不能使用键`'1'`（一个字符串）来检索该值。但`FlexibleDict`将允许这样做。如果它找不到用户的键，它将尝试在放弃之前将键转换为`str`和`int`；例如
- en: '[PRE19]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Prints 100, just like a regular dict
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印100，就像一个普通的dict
- en: ❷ Prints 500, just like a regular dict
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印500，就像一个普通的dict
- en: ❸ int key
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 整数键
- en: ❹ Prints 100, even though we passed a str
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 打印100，尽管我们传递了一个字符串
- en: ❺ str key
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 字符串键
- en: ❻ Prints 100, even though we passed an int
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 打印100，尽管我们传递了一个整数
- en: Working it out
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: This exercise’s class, `FlexibleDict`, is an example of where you might just
    want to inherit from a built-in type. It’s somewhat rare, but as you can see here,
    it allows us to create an alternative type of dict.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的类 `FlexibleDict` 是一个你可能只想从内置类型继承的例子。这种情况比较少见，但正如你所看到的，它允许我们创建一种不同的字典类型。
- en: The specification of `FlexibleDict` indicates that everything should work just
    like a regular `dict`, except for retrievals. We thus only need to override one
    method, the `__getitem__` method that’s always associated with square brackets
    in Python. Indeed, if you’ve ever wondered why strings, lists, tuples, and dicts
    are defined in different ways but all use square brackets, this method is the
    reason.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlexibleDict` 的规范表明，除了检索之外，所有内容都应该像常规 `dict` 一样工作。因此，我们只需要重写一个方法，即 Python
    中始终与方括号关联的 `__getitem__` 方法。实际上，如果你曾经好奇为什么字符串、列表、元组和字典以不同的方式定义，但都使用方括号，这个方法就是原因。'
- en: Because everything should be the same as `dict` except for this single method,
    we can inherit from `dict`, write one method, and be done.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于除了这个单独的方法之外，所有内容都应该与 `dict` 相同，因此我们可以从 `dict` 继承，写一个方法，然后完成。
- en: This method receives a `key` argument. If the key isn’t in the dict, then we
    try to turn it into a string and an integer. Because we might encounter a `ValueError`
    trying to turn a key into an integer, we trap for `ValueError` along the way.
    At each turn, we check to see if a version of the key with a different type might
    actually work--and, if so, we reassign the value of `key`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收一个 `key` 参数。如果键不在字典中，那么我们尝试将其转换为字符串和整数。因为我们可能在尝试将键转换为整数时遇到 `ValueError`，所以我们在这个过程中捕获
    `ValueError`。在每次转换中，我们检查键的不同类型版本是否可能实际上有效--如果是这样，我们就重新分配 `key` 的值。
- en: At the end of the method, we call our parent `__getitem__` method. Why don’t
    we just use square brackets? Because that will lead to an infinite loop, seeing
    as square brackets are defined to invoke `__getitem__`. In other words, `a[b]`
    is turned into `a.__getitem__(b)`. If we then include `self[b]` inside the definition
    of `__getitem__`, we’ll end up having the method call itself. We thus need to
    explicitly call the parent’s method, which in any event will return the associated
    value.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法末尾，我们调用父类的 `__getitem__` 方法。为什么我们不直接使用方括号？因为方括号被定义为调用 `__getitem__`。换句话说，`a[b]`
    被转换为 `a.__getitem__(b)`。如果我们然后在 `__getitem__` 的定义中包含 `self[b]`，我们最终会导致方法自我调用。因此，我们需要显式地调用父类的方法，无论如何，它将返回关联的值。
- en: '*Note* While `FlexibleDict` (and some of the “Beyond the exercise” tasks) might
    be great for teaching you Python skills, building this kind of flexibility into
    Python is very un-Pythonic and not recommended. One of the key ideas in Python
    is that code should be unambiguous, and in Python it’s also better to get an error
    than for the language to guess.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 虽然 `FlexibleDict`（以及一些“除此之外”的任务）可能非常适合教你 Python 技能，但将这种灵活性构建到 Python 中是非常不
    Pythonic 的，并且不推荐这样做。Python 的一个关键思想是代码应该是无歧义的，在 Python 中，出错也比让语言猜测要好。'
- en: Solution
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE20]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ __getitem__ is what square brackets [] invoke.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `__getitem__` 是方括号 [] 调用的内容。
- en: ❷ Do we have the requested key?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们有请求的键吗？
- en: ❸ If not, then tries turning it into a string
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果不是，那么尝试将其转换为字符串
- en: ❹ If not, then tries turning it into an integer
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果不是，那么尝试将其转换为整数
- en: ❺ If we can’t turn it into an integer, then ignores it
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果我们不能将其转换为整数，那么忽略它
- en: ❻ Tries with the regular dict __getitem__, either with the original key or a
    modified one
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 尝试使用常规字典的 `__getitem__` 方法，无论是原始键还是修改后的键
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    lGx6](http://mng.bz/lGx6).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中尝试这个代码版本，链接为 [http://mng.bz/lGx6](http://mng.bz/lGx6)。
- en: Screencast solution
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'We’ve now seen how to extend a built-in class using inheritance. Here are some
    more exercises you can try, in which you’ll also experiment with extending some
    built-in classes:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用继承来扩展内置类。以下是一些你可以尝试的更多练习，你将在其中实验扩展一些内置类：
- en: With `FlexibleDict`, we allowed the user to use any key, but were then flexible
    with the retrieval. Implement `StringKeyDict`, which converts its keys into strings
    as part of the assignment. Thus, immediately after saying `skd[1]` `=` `10`, you
    would be able to then say `skd['1']` and get the value of `10` returned. This
    can come in handy if you’ll be reading keys from a file and won’t be able to distinguish
    between strings and integers.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `FlexibleDict` 中，我们允许用户使用任何键，但在检索时很灵活。实现 `StringKeyDict`，它将键转换为字符串作为赋值的一部分。因此，在说
    `skd[1] = 10` 后，你就可以说 `skd['1']` 并获取返回的值 `10`。如果你将从文件中读取键而无法区分字符串和整数，这可能会很有用。
- en: 'The `RecentDict` class works just like a `dict`, except that it contains a
    user-defined number of key-value pairs, which are determined when the instance
    is created. In a `RecentDict(5)`, only the five most recent key-value pairs are
    kept; if there are more than five pairs, then the oldest key is removed, along
    with its value. Note: your implementation could take into account the fact that
    modern dicts store their key-value pairs in chronological order.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecentDict` 类的工作方式与 `dict` 类似，只不过它包含用户定义数量的键值对，这些键值对是在实例创建时确定的。在 `RecentDict(5)`
    中，只保留五个最最近的键值对；如果键值对超过五个，则最旧的键及其值将被移除。注意：你的实现可以考虑现代字典按时间顺序存储键值对的事实。'
- en: The `FlatList` class inherits from `list` and overrides the `append` method.
    If `append` is passed an iterable, then it should add each element of the iterable
    separately. This means that `fl.append([10,` `20,` `30])` would not add the list
    `[10,` `20,` `30]` to `fl`, but would rather add the individual integers `10`,
    `20`, and `30`. You might want to use the built-in `iter` function ([http://mng.bz/Qy2G](http://mng.bz/Qy2G))
    to determine whether the passed argument is indeed iterable.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlatList` 类继承自 `list` 并重写了 `append` 方法。如果 `append` 接收到一个可迭代对象，那么它应该单独添加可迭代对象的每个元素。这意味着
    `fl.append([10, 20, 30])` 不会将列表 `[10, 20, 30]` 添加到 `fl` 中，而是单独添加整数 `10`、`20` 和
    `30`。你可能想使用内置的 `iter` 函数 ([http://mng.bz/Qy2G](http://mng.bz/Qy2G)) 来确定传递的参数是否确实是可迭代的。'
- en: Exercise 43 ■ Animals
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 43 ■ 动物
- en: 'For the final three exercises in this chapter, we’re going to create a set
    of classes that combine all of the ideas we’ve explored in this chapter: classes,
    methods, attributes, composition, and inheritance. It’s one thing to learn about
    and use them separately, but when you combine these techniques together, you see
    their power and understand the organizational and semantic advantages that they
    offer.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后三个练习中，我们将创建一组类，这些类结合了本章中探索的所有想法：类、方法、属性、组合和继承。单独学习和使用它们是一回事，但当你将这些技术结合起来时，你会看到它们的威力，并理解它们提供的组织和语义优势。
- en: For the purposes of these exercises, you are the director of IT at a zoo. The
    zoo contains several different kinds of animals, and for budget reasons, some
    of those animals have to be housed alongside other animals.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这些练习的目的，你是动物园IT部门的负责人。动物园里有几种不同的动物，由于预算原因，一些动物不得不与其他动物一起饲养。
- en: 'We will represent the animals as Python objects, with each species defined
    as a distinct class. All objects of a particular class will have the same species
    and number of legs, but the color will vary from one instance to another. We can
    thus create a white sheep:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用 Python 对象来表示动物，每种物种定义为一个独立的类。特定类中的所有对象将具有相同的物种和腿的数量，但颜色会因实例而异。因此，我们可以创建一只白色的羊：
- en: '[PRE21]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I can similarly get information about the animal back from the object by retrieving
    its attributes:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过检索对象的属性来从对象中获取有关动物的信息：
- en: '[PRE22]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Prints “sheep”
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印“sheep”
- en: ❷ Prints “white”
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印“white”
- en: ❸ Prints “4”
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打印“4”
- en: 'If I convert the animal to a string (using `str` or `print`), I’ll get back
    a string combining all of these details:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将动物转换为字符串（使用 `str` 或 `print`），我会得到一个字符串，其中包含所有这些细节：
- en: '[PRE23]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Prints “White sheep, 4 legs”
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印“White sheep, 4 legs”
- en: 'We’re going to assume that our zoo contains four different types of animals:
    sheep, wolves, snakes, and parrots. (The zoo is going through some budgetary difficulties,
    so our animal collection is both small and unusual.) Create classes for each of
    these types, such that we can print each of them and get a report on their color,
    species, and number of legs.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设我们的动物园有四种不同的动物：羊、狼、蛇和鹦鹉。（动物园正面临一些预算困难，因此我们的动物收藏既小又奇特。）为这些类型创建类，以便我们可以打印它们，并获取有关它们的颜色、物种和腿数的报告。
- en: Working it out
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The end goal here is somewhat obvious: we want to have four different classes
    (`Wolf`, `Sheep`, `Snake`, and `Parrot`), each of which takes a single argument
    representing a color. The result of invoking each of these classes is a new instance
    with three attributes: `species`, `color`, and `number_of_legs`.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最终目标在一定程度上是显而易见的：我们希望有四个不同的类（`Wolf`、`Sheep`、`Snake`和`Parrot`），每个类都接受一个表示颜色的单一参数。调用这些类中的每一个都会产生一个新的实例，具有三个属性：`species`、`color`和`number_of_legs`。
- en: A naive implementation would simply create each of these four classes. But of
    course, part of the point here is to use inheritance, and the fact that the behavior
    in each class is basically identical means that we can indeed take advantage of
    it. But what will go into the `Animal` class, from which everyone inherits, and
    what will go into each of the individual subclasses?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的实现会简单地创建这四个类中的每一个。但当然，这里的一部分目的是使用继承，并且每个类中的行为基本上是相同的，这意味着我们可以真正利用这一点。但是，将放入从所有人继承的`Animal`类中的内容，以及将放入每个单独的子类中的内容是什么？
- en: Since all of the animal classes will have the same attributes, we can define
    `__repr__` on `Animal`, the class from which they’ll all inherit. My version uses
    an f-string and grabs the attributes from `self`. Note that `self` in this case
    will be an instance not of `Animal`, but of one of the classes that inherits from
    `Animal`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有动物类别都将具有相同的属性，我们可以在它们都将继承的`Animal`类上定义`__repr__`。我的版本使用了一个f-string并从`self`中获取属性。请注意，在这个例子中，`self`将不是`Animal`的实例，而是继承自`Animal`的某个类的一个实例。
- en: So, what else should be in `Animal`, and what should be in the subclasses? There’s
    no hard-and-fast rule here, but in this particular case, I decided that `Animal.__init__`
    would be where the assignments all happen, and that the `__init__` method in each
    subclass would invoke `Animal.__init__` with a hardcoded number of legs, as well
    as the color designated by the user (figure 9.13).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`Animal`中应该包含什么，子类中又应该包含什么？这里没有硬性规则，但在这种特定情况下，我决定`Animal.__init__`将是所有赋值发生的地方，并且每个子类的`__init__`方法将使用硬编码的腿数以及用户指定的颜色调用`Animal.__init__`（图9.13）。
- en: '![](../Images/9-13.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-13.png)'
- en: Figure 9.13 `Wolf` inherits from `Animal`. Notice which methods are defined
    where.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 `Wolf`继承自`Animal`。注意哪些方法在哪里定义。
- en: In theory, `__init__` in a subclass could call `Animal.__init__` directly and
    by name. But we also have access to `super`, which returns the object on which
    our method should be called. In other words, by calling `super().__init__`, we
    know that the right method will be called on the right object, and can just pass
    along the `color` and `number_of_legs` arguments.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，子类中的`__init__`可以直接通过名称调用`Animal.__init__`。但我们也有访问`super`的权利，它返回我们的方法应该调用的对象。换句话说，通过调用`super().__init__`，我们知道正确的方程序将正确地调用正确的对象，并且可以传递`color`和`number_of_legs`参数。
- en: But wait, what about the `species` attribute? How can we set that without input
    from the user?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，关于`species`属性怎么办？我们如何在不从用户那里获取输入的情况下设置它？
- en: My solution to this problem was to take advantage of the fact that Python classes
    are very similar to modules, with similar behavior. Just as a module has a `__name__`
    attribute that reflects what module was loaded, so too classes have a `__name__`
    attribute, which is a string containing the name of the current class. And thus,
    if I invoke `self.__class__` on an object, I get its class--and if I invoke `self.__class__.__name__`,
    I get a string representation of the class.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我解决这个问题的方法是要利用Python类与模块非常相似的事实，它们具有类似的行为。就像模块有一个`__name__`属性反映了加载了哪个模块一样，类也有一个`__name__`属性，它是一个包含当前类名的字符串。因此，如果我在一个对象上调用`self.__class__`，我会得到它的类；如果调用`self.__class__.__name__`，我会得到类的字符串表示。
- en: Abstract base classes
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类
- en: The `Animal` class here is what other languages might call an *abstract base
    class*, namely one that we won’t actually instantiate, but from which other classes
    will inherit. In Python, you don’t have to declare such a class to be abstract,
    but you also won’t get the enforcement that other languages provide. If you really
    want, you can import `ABCMeta` from the `abc` (abstract base class) module. Following
    its instructions, you’ll be able to declare particular methods as *abstract*,
    meaning that they must be overridden in the child.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `Animal` 类在其他语言中可能被称为抽象基类，即我们不会实际实例化的类，但其他类将从它继承。在 Python 中，你不必声明这样的类为抽象类，但你也不会得到其他语言提供的强制执行。如果你真的想，你可以从
    `abc`（抽象基类）模块导入 `ABCMeta`。遵循其说明，你将能够声明特定方法为抽象的，这意味着它们必须在子类中重写。
- en: I’m not a big fan of abstract base classes; I think that it’s enough to document
    a class as being abstract, without the overhead or language enforcement. Whether
    that’s a smart approach depends on several factors, including the nature and size
    of the project you’re working on and whether you come from a background in dynamic
    languages. A large project, with many developers, would probably benefit from
    the additional safeguards that an abstract base class would provide.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是特别喜欢抽象基类；我认为，仅将一个类文档化为抽象类就足够了，无需额外的开销或语言强制。这种方法是否明智取决于几个因素，包括你正在工作的项目的性质和规模，以及你是否来自动态语言的背景。一个大型项目，涉及许多开发者，可能将从抽象基类提供的额外保障中受益。
- en: 'If you want to learn more about abstract base classes in Python, you can read
    about `ABCMeta` here: [http://mng.bz/yyJB](http://mng.bz/yyJB).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Python 中抽象基类的信息，你可以在这里了解 `ABCMeta`：[http://mng.bz/yyJB](http://mng.bz/yyJB)。
- en: Solution
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE24]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Our Animal base class takes a color and number of legs.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的 Animal 基类接受颜色和腿的数量。
- en: ❷ Turns the current class object into a string
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将当前类对象转换为字符串
- en: ❸ Uses an f-string to produce appropriate output
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 f-string 生成适当的输出
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    B2Z0](http://mng.bz/B2Z0).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中尝试这个代码的版本：[http://mng.bz/ B2Z0](http://mng.bz/B2Z0)。
- en: Screencast solution
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'In this exercise, we put a few classes in place as part of a hierarchy. Here
    are some additional ways you can work with inheritance and think about the implications
    of the design decisions we’re making. I should note that these questions, as well
    as those following in this chapter, are going to combine hands-on practice with
    some deeper, philosophical questions about the “right” way to work with object-oriented
    systems:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将几个类作为层次结构的一部分进行设置。以下是一些你可以用来处理继承和思考我们做出的设计决策影响的方法。我应该指出，这些问题以及本章后续的问题将结合实际操作练习和一些关于“正确”使用面向对象系统的更深层次的哲学问题：
- en: Instead of each animal class inheriting directly, from `Animal`, define several
    new classes, `ZeroLeggedAnimal`, `TwoLeggedAnimal`, and `FourLeggedAnimal`, all
    of which inherit from `Animal`, and dictate the number of legs on each instance.
    Now modify `Wolf`, `Sheep`, `Snake`, and `Parrot` such that each class inherits
    from one of these new classes, rather than directly from `Animal`. How does this
    affect your method definitions?
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是让每个动物类直接从 `Animal` 继承，定义几个新的类，`ZeroLeggedAnimal`、`TwoLeggedAnimal` 和 `FourLeggedAnimal`，所有这些类都从
    `Animal` 继承，并指定每个实例的腿数。现在修改 `Wolf`、`Sheep`、`Snake` 和 `Parrot`，使每个类从这些新类中的一个继承，而不是直接从
    `Animal` 继承。这如何影响你的方法定义？
- en: Instead of writing an `__init__` method in each subclass, we could also have
    a class attribute, `number_of_legs`, in each subclass--similar to what we did
    earlier with `Bowl` and `BigBowl`. Implement the hierarchy that way. Do you even
    need an `__init__` method in each subclass, or will `Animal.__init__` suffice?
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以在每个子类中编写一个 `__init__` 方法，而不是在每个子类中编写一个 `__init__` 方法——类似于我们之前在 `Bowl` 和
    `BigBowl` 中所做的那样。以这种方式实现层次结构。你甚至需要在每个子类中都需要一个 `__init__` 方法吗，或者 `Animal.__init__`
    就足够了吗？
- en: Let’s say that each class’s `__repr__` method should print the animal’s sound,
    as well as the standard string we implemented previously. In other words, `str(sheep)`
    would be `Baa`--`white` `sheep,` `4` `legs`. How would you use inheritance to
    maximize code reuse?
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设每个类的`__repr__`方法应该打印出动物的声音，以及我们之前实现的标准化字符串。换句话说，`str(sheep)`应该是`Baa`--`white`
    `sheep,` `4` `legs`。你将如何使用继承来最大化代码重用？
- en: Exercise 44 ■ Cages
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习44 ■ 笼子
- en: 'Now that we’ve created some animals, it’s time to put them into cages. For
    this exercise, create a `Cage` class, into which you can put one or more animals,
    as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一些动物，是时候把它们放进笼子里了。对于这个练习，创建一个`Cage`类，你可以将一个或多个动物放入其中，如下所示：
- en: '[PRE25]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When you create a new `Cage`, you’ll give it a unique ID number. (The uniqueness
    doesn’t need to be enforced, but it’ll help us to distinguish among the cages.)
    You’ll then be able to invoke `add_animals` on the new cage, passing any number
    of animals that will be put in the cage. I also want you to define a `__repr__`
    method so that printing a cage prints not just the cage ID, but also each of the
    animals it contains.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的`Cage`时，你会给它一个唯一的ID号码。（唯一性不需要强制执行，但它将帮助我们区分笼子。）然后你将能够在新笼子上调用`add_animals`，传递任何将被放入笼子中的动物。我还想让你定义一个`__repr__`方法，以便打印笼子时不仅打印笼子ID，还打印它包含的每个动物。
- en: Working it out
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution’s definition of the `Cage` class is similar in some ways to the
    `Bowl` class that we defined earlier in this chapter.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cage`类的定义在某些方面与我们在本章前面定义的`Bowl`类相似。'
- en: When we create a new cage, the `__init__` method initializes `self.animals`
    with an empty list, allowing us to add (and even remove) animals as necessary.
    We also store the ID number that was passed to us in the `id_number` parameter.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的笼子时，`__init__`方法使用空列表初始化`self.animals`，这样我们就可以根据需要添加（甚至删除）动物。我们还存储在`id_number`参数中传递给我们的ID号码。
- en: Next, we implement `Cage.add_animals`, which uses similar techniques to what
    we did in `Bowl.add_scoops`. Once again, we use the splat (`*`) operator to grab
    all arguments in a single tuple (`animals`). Although we could use `list.extend`
    to add all of the new animals to `list.animals`, I’ll still use a `for` loop here
    to add them one at a time. You can see how the Python Tutor depicts two animals
    in a cage in figure 9.14.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现`Cage.add_animals`，它使用与我们在`Bowl.add_scoops`中使用的类似技术。再次使用拆分(`*`)运算符来获取一个单独的元组(`animals`)中的所有参数。虽然我们可以使用`list.extend`将所有新动物添加到`list.animals`中，但我仍然在这里使用一个`for`循环来逐个添加它们。你可以在图9.14中看到Python
    Tutor如何描述笼子中的两只动物。
- en: The most interesting part of our `Cage` definition, in my mind, is our use of
    `__repr__` to produce a report. Given a cage `c1`, saying `print(c1)` will print
    the ID of the cage, followed by all of the animals in the cage, using their printed
    representations. We do this by first printing a basic header, which isn’t a huge
    deal. But then we take each animal in `self.animals` and use a generator expression
    (i.e., a lazy form of list comprehension) to return a sequence of strings. Each
    string in that sequence will consist of a tab followed by the printed representation
    of the animal. We then feed the result of our generator expression to `str.join`,
    which puts newline characters between each animal.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的想法中，我们`Cage`定义中最有趣的部分是我们使用`__repr__`来生成报告。给定一个笼子`c1`，说`print(c1)`将打印笼子的ID，然后是笼子中的所有动物，使用它们的打印表示。我们是首先打印一个基本标题，这不是什么大问题。但然后我们取`self.animals`中的每个动物，并使用一个生成器表达式（即列表解析的懒形式）来返回一个字符串序列。那个序列中的每个字符串将包含一个制表符后跟动物的打印表示。然后我们将我们的生成器表达式的结果传递给`str.join`，它在每个动物之间放置换行符。
- en: '![](../Images/9-14.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-14.png)'
- en: Figure 9.14 A `Cage` instance containing one wolf and one sheep
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 一个包含一只狼和一只羊的`Cage`实例
- en: Solution
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE26]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Sets an ID number for each cage, just so that we can distinguish their printouts
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为每个笼子设置一个ID号码，这样我们就可以区分它们的打印输出
- en: ❷ Sets up an empty list, into which we’ll place animals
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置一个空列表，我们将动物放入其中
- en: ❸ The string for each cage will mainly be from a string, based on a generator
    expression.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 每个笼子的字符串主要基于一个生成器表达式
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    dyeN](http://mng.bz/dyeN).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中通过[http://mng.bz/ dyeN](http://mng.bz/dyeN)查看这个代码的版本。
- en: Screencast solution
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 课外练习
- en: 'We’re once again seeing the need for composition in our classes--creating objects
    that are containers for other objects. Here are some possible extensions to this
    code, all of which draw on the ideas we’ve already seen in this chapter, and which
    you’ll see repeated in nearly every object-oriented system you build and encounter:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次在我们的课程中看到了需要组合的需求——创建其他对象的容器。以下是这个代码的一些可能的扩展，所有这些扩展都借鉴了我们在本章中已经看到的思想，并且你将在你构建和遇到的几乎每个面向对象系统中看到这些思想的重复：
- en: As you can see, there are no limits on how many animals can potentially be put
    into a cage. Just as we put a limit of three scoops in a `Bowl` and five in a
    `BigBowl`, you should similarly create `Cage` and `BigCage` classes that limit
    the number of animals that can be placed there.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如你所见，笼子中可以放置的动物数量没有限制。就像我们在 `Bowl` 中限制三个勺子，在 `BigBowl` 中限制五个勺子一样，你应该相应地创建 `Cage`
    和 `BigCage` 类来限制可以放置那里的动物数量。
- en: It’s not very realistic to say that we would limit the **number** of animals
    in a cage. Rather, it makes more sense to describe how much space each animal
    needs and to ensure that the total amount of space needed per animal isn’t greater
    than the space in each cage. You should thus modify each of the `Animal` subclasses
    to include a `space_required` attribute. Then modify the `Cage` and `BigCage`
    classes to reflect how much space each one has. Adding more animals than the cage
    can contain should raise an exception.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说我们会限制笼子中动物的数量并不太现实。相反，描述每个动物需要多少空间，并确保每个动物所需的总空间不超过每个笼子的空间，这更有意义。因此，你应该修改每个
    `Animal` 子类以包含一个 `space_required` 属性。然后修改 `Cage` 和 `BigCage` 类以反映每个类有多少空间。放置超过笼子能容纳的动物数量将引发异常。
- en: Our zookeepers have a macabre sense of humor when it comes to placing animals
    together, in that they put wolves and sheep in the first cage, and snakes and
    birds in the other cage. (The good news is that with such a configuration, the
    zoo will be able to save on food for half of the animals.) Define a dict describing
    which animals can be with others. The keys in the dict will be classes, and the
    values will be lists of classes that can compatibly be housed with the keys. Then,
    when adding new animals to the current cage, you’ll check for compatibility. Trying
    to add an animal to a cage that already contains an incompatible animal will raise
    an exception.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的饲养员在将动物放在一起时有一种令人毛骨悚然的幽默感，他们将狼和羊放在第一个笼子里，将蛇和鸟放在另一个笼子里。（好消息是，在这种配置下，动物园将能够为一半的动物节省食物。）定义一个字典，描述哪些动物可以与其他动物共处。字典的键是类，值是可以与键兼容的类的列表。然后，当向当前笼子添加新动物时，你会检查兼容性。试图向已经包含不兼容动物的笼子添加动物将引发异常。
- en: Exercise 45 ■ Zoo
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 45 ■ 动物园
- en: 'Finally, the time has come to create our `Zoo` object. It will contain cage
    objects, and they in turn will contain animals. Our `Zoo` class will need to support
    the following operations:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候创建我们的 `Zoo` 对象了。它将包含笼子对象，而这些笼子对象又包含动物。我们的 `Zoo` 类需要支持以下操作：
- en: Given a zoo `z`, we should be able to print all of the cages (with their ID
    numbers) and the animals inside simply by invoking `print(z)`.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个动物园 `z`，我们应该能够通过调用 `print(z)` 来简单地打印出所有的笼子（包括它们的ID号码）以及里面的动物。
- en: We should be able to get the animals with a particular color by invoking the
    method `z.animals_by_color`. For example, we can get all of the black animals
    by invoking `z.animals_by_color('black')`. The result should be a list of `Animal`
    objects.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够通过调用方法 `z.animals_by_color` 来获取特定颜色的动物。例如，我们可以通过调用 `z.animals_by_color('black')`
    来获取所有黑色的动物。结果应该是一个 `Animal` 对象的列表。
- en: We should be able to get the animals with a particular number of legs by invoking
    the method `z.animals_by_legs`. For example, we can get all of the four-legged
    animals by invoking `z.animals_by_legs(4)`. The result should be a list of `Animal`
    objects.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够通过调用方法 `z.animals_by_legs` 来获取特定腿数的动物。例如，我们可以通过调用 `z.animals_by_legs(4)`
    来获取所有四条腿的动物。结果应该是一个 `Animal` 对象的列表。
- en: Finally, we have a potential donor to our zoo who wants to provide socks for
    all of the animals. Thus, we need to be able to invoke `z.number_of_legs()` and
    get a count of the total number of legs for all animals in our zoo.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有一个潜在的捐赠者希望为我们动物园提供所有动物的袜子。因此，我们需要能够调用`z.number_of_legs()`并获取我们动物园中所有动物腿的总数。
- en: 'The exercise is thus to create a `Zoo` class on which we can invoke the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，练习就是创建一个`Zoo`类，我们可以调用以下操作：
- en: '[PRE27]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Working it out
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: In some ways, our `Zoo` class here is quite similar to our `Cage` class. It
    has a list attribute, `self.cages`, in which we’ll store the cages. It has an
    `add_cages` method, which takes `*args` and thus takes any number of inputs. Even
    the `__repr__` method is similar to what we did with `Cage.__repr__`. We’ll simply
    use `str.join` on the output from running `str` on each of the cages, just as
    the cages run `str` on each of the animals. We’ll similarly use a generator expression
    here, which will be slightly more efficient than a list comprehension.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，我们这里的`Zoo`类与我们的`Cage`类非常相似。它有一个列表属性`self.cages`，我们将在这里存储笼子。它有一个`add_cages`方法，该方法接受`*args`，因此可以接受任意数量的输入。甚至`__repr__`方法也与我们在`Cage.__repr__`中所做的方法相似。我们将简单地使用`str.join`对每个笼子运行`str`的结果进行输出，就像笼子对每个动物运行`str`一样。我们在这里也将使用生成器表达式，这将比列表推导式稍微高效一些。
- en: But then, when it comes to the three methods we needed to create, we’ll switch
    direction a little bit. In both `animals_by_color` and `animals_by_legs`, we want
    to get the animals with a certain color or a certain number of legs. Here, we
    take advantage of the fact that the zoo contains a list of cages, and that each
    cage contains a list of animals. We can thus use a nested list comprehension,
    getting a list of all of the animals.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们需要创建的三个方法时，我们将稍微改变方向。在`animals_by_color`和`animals_by_legs`中，我们想要获取具有特定颜色或特定数量腿的动物。在这里，我们利用动物园包含笼子列表的事实，以及每个笼子包含动物列表的事实。因此，我们可以使用嵌套列表推导式，获取所有动物列表。
- en: But of course, we don’t want **all** of the animals, so we have an `if` statement
    that filters out those that we don’t want. In the case of `animals_by_color`,
    we only include those animals that have the right color, and in `animals_by_legs`,
    we only keep those animals with the requested number of legs.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并不想要**所有**的动物，所以我们有一个`if`语句来过滤掉我们不想要的动物。在`animals_by_color`的情况下，我们只包括那些具有正确颜色的动物，而在`animals_by_legs`中，我们只保留那些具有所需数量腿的动物。
- en: But then we also have `number_of_legs`, which works a bit differently. There,
    we want to get an integer back, reflecting the number of legs that are in the
    entire zoo. Here, we can take advantage of the built-in `sum` method, handing
    it the generator expression that goes through each cage and retrieves the number
    of legs on each animal. The method will thus return an integer.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们还有`number_of_legs`，它的工作方式略有不同。在这里，我们想要返回一个整数，反映整个动物园中腿的总数。在这里，我们可以利用内置的`sum`方法，将遍历每个笼子并检索每个动物腿数的生成器表达式传递给它。因此，该方法将返回一个整数。
- en: Although the object-oriented and functional programming camps have been fighting
    for decades over which approach is superior, I think that the methods in this
    `Zoo` class show us that each has its strengths, and that our code can be short,
    elegant, and to the point if we combine the techniques. That said, I often get
    pushback from students who see this code and say that it’s a violation of the
    object-oriented principle of *encapsulation*, which ensures that we can’t (or
    shouldn’t) directly access the data in other objects.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管面向对象和函数式编程阵营已经就哪种方法更优越争论了几十年，但我认为这个`Zoo`类中的方法向我们展示了每种方法都有其优势，并且如果我们结合这些技术，我们的代码可以简短、优雅且切中要点。话虽如此，我经常遇到学生对我的代码提出反对意见，他们认为这是违反面向对象原则的*封装*，该原则确保我们无法（或不应）直接访问其他对象中的数据。
- en: Whether this is right or wrong, such violations are also fairly common in the
    Python world. Because all data is public (i.e., there’s no `private` or `protected`),
    it’s considered a good and reasonable thing to just scoop the data out of objects.
    That said, this also means that whoever writes a class has a responsibility to
    document it, and to keep the API alive--or to document elements that may be deprecated
    or removed in the future.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这是对是错，这种违规行为在Python世界中也很常见。因为所有数据都是公开的（即没有`private`或`protected`），直接从对象中提取数据被认为是一件好事和合理的事情。话虽如此，这也意味着编写类的任何人都有一份责任来记录它，并保持API活跃——或者记录可能在未来被弃用或删除的元素。
- en: Solution
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is the longest and most complex class definition in this chapter--and
    yet, each of the methods uses techniques that we’ve discussed, both in this chapter
    and in this book:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章中最长且最复杂的类定义——然而，每个方法都使用了我们在本章和本书中讨论过的技术：
- en: '[PRE28]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Sets up the self.cages attribute, a list where we’ll store cages
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置self.cages属性，一个我们将存储笼子的列表
- en: ❷ Defines the method that’ll return animal objects that match our color
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个方法，该方法将返回与我们颜色匹配的动物对象
- en: ❸ Defines the method that’ll return animal objects that match our number of
    legs
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义一个方法，该方法将返回与我们腿数匹配的动物对象
- en: ❹ Returns the number of legs
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回腿的数量
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    lGMB](http://mng.bz/lGMB).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中查看这个代码的版本：[http://mng.bz/lGMB](http://mng.bz/lGMB)。
- en: Screencast solution
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Now that you’ve seen how all of these elements fit together in our `Zoo` class,
    here are some additional exercises you might want to try out, to extend what we’ve
    done--and to better understand object-oriented programming in Python:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了所有这些元素如何在我们的`Zoo`类中结合在一起，这里有一些额外的练习你可能想要尝试，以扩展我们所做的工作——并且更好地理解Python中的面向对象编程：
- en: Modify `animals_by_color` such that it takes any number of colors. Animals having
    any of the listed colors should be returned. The method should raise an exception
    if no colors are passed.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`animals_by_color`方法，使其可以接受任意数量的颜色。应返回具有所列颜色的动物。如果没有传递颜色，该方法应抛出一个异常。
- en: As things currently stand, we’re treating our `Zoo` class almost as if it’s
    a *singleton* object--that is, a class that has only one instance. What a sad
    world that would be, with only one zoo! Let’s assume, then, that we have two instances
    of `Zoo`, representing two different zoos, and that we would like to transfer
    an animal from one to the other. Implement a `Zoo.transfer_animal` method that
    takes a `target_zoo` and a subclass of `Animal` as arguments. The first animal
    of the specified type is removed from the zoo on which we’ve called the method
    and inserted into the first cage in the target zoo.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前的情况是，我们几乎将`Zoo`类当作一个*单例*对象来处理——也就是说，只有一个实例的类。只有一个动物园的世界将会多么悲哀！那么，让我们假设我们有两个`Zoo`实例，代表两个不同的动物园，并且我们希望从一个动物园转移到另一个动物园的动物。实现一个`Zoo.transfer_animal`方法，该方法接受一个`target_zoo`和一个`Animal`子类作为参数。将指定类型的第一个动物从调用该方法所在的动物园中移除，并插入到目标动物园的第一个笼子中。
- en: Combine the `animals_by_color` and `animals_by_legs` methods into a single `get_animals`
    method, which uses `kwargs` to get names and values. The only valid names would
    be `color` and `legs`. The method would then use one or both of these keywords
    to assemble a query that returns those animals that match the passed criteria.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`animals_by_color`和`animals_by_legs`方法合并为一个单一的`get_animals`方法，该方法使用`kwargs`获取名称和值。唯一有效的名称将是`color`和`legs`。然后，该方法将使用一个或两个这些关键字来组装查询，返回符合传递标准的那些动物。
- en: Summary
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Object-oriented programming is a set of techniques, but it’s also a mindset.
    In many languages, object-oriented programming is forced on you, such that you’re
    constantly trying to fit your programming into its syntax and structure. Python
    tries to strike a balance, offering all of the object-oriented features we’re
    likely to want or use, but in a simple, nonconfrontational way. In this way, Python’s
    objects provide us with structure and organization that can make our code easier
    to write, read, and (most importantly) maintain.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一套技术，但也是一种思维方式。在许多语言中，面向对象编程是被强加给你的，以至于你不断地试图将你的编程适应其语法和结构。Python试图找到一个平衡点，提供我们可能想要或使用的所有面向对象特性，但以一种简单、非对抗的方式。以这种方式，Python的对象为我们提供了结构和组织，可以使我们的代码更容易编写、阅读（最重要的是）和维护。
