- en: Part 4\. Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分\. 数据
- en: At this point, you have an architecture with objects and functions connected
    to one another. All that’s left is to turn the hose on and let the data flow in.
    As with your system of conventional PVC pipes connected to bring water to your
    house, your application needs to be connected to transform the input into the
    desired output. The complexity of connecting everything arises when you need to
    prepare for data that can arrive at any point in time, not only when you expect
    it. In other words, you don’t know when someone will turn on the water, but you
    need to be ready for when they do.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经有一个由对象和函数相互连接的架构。剩下要做的就是打开水龙头，让数据流入。就像你的将水引入房子的传统PVC管道系统一样，你的应用程序需要连接起来，将输入转换为所需的输出。当需要准备可能在任何时间点到达的数据时，连接一切的复杂性就出现了，而不仅仅是当你期望它时。换句话说，你不知道何时有人会打开水龙头，但你需要为他们会打开水龙头做好准备。
- en: Chapter 8 teaches you how to tame asynchronous logic with promises and direct
    language syntax (`async`/`await`). Promises have the advantage of being compositional
    objects; you can chain two or three consecutive asynchronous calls without having
    to worry about falling into callback hell. As the language of the web, asynchronous
    execution is so common that we have built-in language syntax to create `async`-aware
    functions with similar semantics as promises.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章教你如何使用承诺和直接的语言语法（`async`/`await`）驯服异步逻辑。承诺的优点是它们是可组合的对象；你可以连续进行两个或三个异步调用，而无需担心陷入回调地狱。作为网络的语言，异步执行如此普遍，以至于我们内置了语言语法来创建具有与承诺类似语义的`async`感知函数。
- en: But the best way to emulate a connected application is to assemble the PVC pipes—virtually,
    that is. Chapter 9 removes the complexity of asynchronous logic to level the playing
    field. In this last chapter, we explore the streams paradigm to assemble functional,
    declarative, compositional, and fluent data flows to handle both asynchronous
    and synchronous data. This topic is not easy to grok by itself; you need to draw
    on the lessons of the previous eight chapters. For this purpose, JavaScript is
    introducing a proposal featuring the `Observable` object, which will allow you
    to treat streams of data in a consistent way. You may have had a chance to use
    libraries such as RxJS in the past, perhaps directly or through frameworks such
    as Angular. This API brings the basic component of this library directly to JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但模拟一个连接型应用程序的最好方法是组装PVC管道——即虚拟地组装。第9章移除了异步逻辑的复杂性，以使竞争场地保持平衡。在本章的最后，我们探讨了流范式，以组装功能性的、声明性的、组合性的和流畅的数据流，以处理异步和同步数据。这个主题单独理解并不容易；你需要借鉴前八章的教训。为此，JavaScript正在引入一个包含`Observable`对象的提案，这将允许你以一致的方式处理数据流。你可能过去有机会使用过像RxJS这样的库，可能是直接使用，或者通过像Angular这样的框架。这个API将这个库的基本组件直接引入JavaScript。
