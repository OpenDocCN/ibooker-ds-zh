- en: 9 Conversion and promotion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 转换和提升
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Conversion of one related type to another
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种相关类型到另一种类型的转换
- en: How promotion finds the least common denominator among related types in an expression
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式中相关类型如何找到最小公倍数
- en: Exploring the Julia standard library using the @edit macro
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 @edit 宏探索 Julia 标准库
- en: 'Julia and other mainstream programming languages handle arithmetic involving
    different number types so effortlessly that most of us likely don’t pay much attention
    to this fact:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 和其他主流编程语言处理涉及不同数字类型的算术运算如此轻松，以至于我们大多数人可能不太关注这个事实：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Numbers in the expression converted to floating-point numbers
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表达式中的数字转换为浮点数
- en: ❷ All integers converted to Int128
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 所有整数转换为 Int128
- en: In reality, doing this involves quite a lot of complexity. Under the hood, most
    programming languages have defined a set of *promotion rules*, which say what
    should be done if you combine numbers of different types. Promotion rules make
    sure all the numbers are converted to a sensible common number type that can be
    used in the final calculation. Don’t confuse number conversion with parsing text
    strings to produce numbers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '事实上，这样做涉及相当多的复杂性。在底层，大多数编程语言都定义了一套 *提升规则*，这些规则说明了如果你组合不同类型的数字应该做什么。提升规则确保所有数字都转换为可以用于最终计算的合理公共数字类型。不要将数字转换与解析文本字符串以生成数字混淆。 '
- en: 'You might wonder why you should care about these concepts. Mastering Julia’s
    promotion and conversion system opens the door to a deeper insight into how numbers
    work in Julia. That will make you capable of doing a wide variety of tasks, such
    as the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么你应该关心这些概念。掌握 Julia 的提升和转换系统将打开深入了解 Julia 中数字工作方式的门。这将使你能够执行各种任务，例如以下内容：
- en: Defining custom number types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自定义数字类型
- en: Defining a physical units system and performing conversions between different
    units
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义物理单位系统并在不同单位之间进行转换
- en: 'The main programming example in this chapter will do just that: define a unit
    system for different types of angles, such as degrees and radians. I will then
    demonstrate how the Julia promotion and conversion system can combine different
    angle types in the same expression.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要编程示例将做到这一点：为不同类型的角度定义一个单位系统，例如度数和弧度。然后我将演示 Julia 的提升和转换系统如何将不同的角度类型组合在同一表达式中。
- en: But why create numbers with units? Why not let numbers be numbers? Because a
    lot of mistakes happen in software development because feet, meters, and other
    units get mixed up. By using numbers with units you can reduce the number of bugs
    in your software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么要用带有单位的数字呢？为什么不让数字仅仅是数字呢？因为软件开发中经常出现由于英尺、米和其他单位混淆而导致的错误。通过使用带有单位的数字，你可以减少软件中的错误数量。
- en: In many cases in Julia it doesn’t matter what order the arguments are. For instance,
    if you want to check if two geometric objects overlap, then overlap(circle, triangle)
    should give the same result as overlap(triangle, circle). You could imagine a
    similar situation when simulating battle between different types of warriors in
    a video game. The Julia promotion system provides an elegant technique for handling
    such cases without implementing the same algorithms twice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 的许多情况下，参数的顺序并不重要。例如，如果你想检查两个几何对象是否重叠，那么 overlap(circle, triangle) 应该给出与
    overlap(triangle, circle) 相同的结果。你可以想象在视频游戏中模拟不同类型战士之间的战斗时会出现类似的情况。Julia 的提升系统提供了一种优雅的技术来处理这类情况，而无需两次实现相同的算法。
- en: 9.1 Exploring Julia’s number promotion system
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 探索 Julia 的数字提升系统
- en: Inside a microprocessor, mathematical operations are always performed between
    identical types of numbers. A microprocessor does not have an instruction to add
    an integer to a floating-point number. Microprocessors always perform arithmetic
    operations between identical number types.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在微处理器内部，数学运算总是在相同类型的数字之间进行。微处理器没有将整数加到浮点数上的指令。微处理器总是执行相同数字类型之间的算术运算。
- en: Thus, when dealing with expressions composed of different number types, all
    higher-level programming languages have to convert all arguments in the expression
    to the same number type. But what should this common number type be? Figuring
    out this common type is what promotion is all about.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当处理由不同数字类型组成的表达式时，所有高级编程语言都必须将表达式中的所有参数转换为相同的数字类型。但这个公共数字类型应该是什么？确定这个公共类型就是提升的全部内容。
- en: We express this as promoting arguments of mathematical operators to a common
    type. In most mainstream languages, the mechanisms and rules governing number
    promotion are hardwired into the language and detailed in the specifications of
    the language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这表达为将数学运算符的参数提升到公共类型。在大多数主流语言中，控制数字提升的机制和规则是硬编码到语言中，并在语言的规范中详细说明。
- en: Note You will see the term *type coercion* used in other programming languages.
    Coercion is implicit conversion carried out by the compiler. Julia’s compiler
    does not do that, and thus *coercion* does not occur in Julia.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你会在其他编程语言中看到术语“类型强制转换”。强制转换是由编译器执行的隐式转换。Julia的编译器不执行此操作，因此Julia中没有“强制转换”。
- en: Julia takes a radically different approach. In Julia, numbers are first-class
    objects. They are not special types with unique hardwired rules. Julia promotion
    rules are defined in the standard library, not in the internals of the Julia JIT
    compiler. That provides the benefit of you, as a developer, being able to extend
    the conversion and promotion system yourself. You can add new number types as
    well as new rules.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Julia采取了截然不同的方法。在Julia中，数字是一等对象。它们不是具有独特硬编码规则的特殊类型。Julia的提升规则定义在标准库中，而不是Julia
    JIT编译器的内部。这为你作为开发者提供了扩展转换和提升系统的能力。你可以添加新的数字类型以及新的规则。
- en: But doesn’t that increase the risk of developers messing up the number type
    system? No, because you *extend* the existing system; you don’t *modify* it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不会增加开发者搞乱数字类型系统的风险吗？不，因为你是*扩展*现有系统；你并没有*修改*它。
- en: Promotion rules are handled by plain-old Julia functions. Hooking into the existing
    system is simply a matter of adding your own methods to existing functions. You
    can explore the Julia source code for promotion using the @edit macro.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 提升规则由普通的Julia函数处理。挂钩到现有系统只是简单地添加你自己的方法到现有函数。你可以使用@edit宏探索Julia源代码中的提升。
- en: Julia environment variable setup
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Julia环境变量设置
- en: 'For the @edit macro to work, you need to have set the JULIA_EDITOR environment
    variable. This will depend on your operating system. For example, I use the fish
    shell. It requires modifying the startup configuration, $HOME/.config/fish/config.fish,
    by adding the following line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使@edit宏工作，你需要设置JULIA_EDITOR环境变量。这取决于你的操作系统。例如，我使用fish shell。它需要修改启动配置，$HOME/.config/fish/config.fish，并添加以下行：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you use the bash shell you would modify the $HOME/.profile file instead:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用bash shell，你将修改$HOME/.profile文件：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Both examples work on macOS and Linux. Windows users would use a GUI dialog
    to modify the JULIA_EDITOR environment variable. Alternatively, Windows users
    can install a Unix shell.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例在macOS和Linux上都能工作。Windows用户将使用GUI对话框来修改JULIA_EDITOR环境变量。或者，Windows用户可以安装Unix
    shell。
- en: In the following snippet you are adding an integer and floating-point number.
    By prefixing with the @edit macro, Julia jumps to the definition of the function
    being called to handle this expression, allowing you to have a look at the source
    code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，你正在添加一个整数和一个浮点数。通过使用@edit宏前缀，Julia会跳转到被调用的函数的定义，以便你查看源代码。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Everything is a function!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都是函数！
- en: 'It is worth being aware that almost everything in Julia is a function call.
    When you write 3 + 5, that is syntactic sugar for calling a function named + like
    this: +(3, 5). Every function using a symbol such as +, -, *, and so on supports
    being used in prefix form.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在Julia中几乎一切都是函数调用。当你写下3 + 5时，这实际上是调用名为+的函数的语法糖，如下所示：+(3, 5)。每个使用+、-、*等符号的函数都支持以前缀形式使用。
- en: The following code shows how every arithmetic operation on some Number in Julia
    first calls promote before performing the actual arithmetic operation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了在Julia中，对某个Number进行的每个算术操作首先调用promote，然后再执行实际的算术操作。
- en: Listing 9.1 Definition of arithmetic operations on numbers in Julia’s standard
    library
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 Julia标准库中数字算术操作的定义
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The ... is called the *splat* operator, which you can use to turn arrays or
    tuples into function arguments. This means foo([4, 5, 8]...) is the same as foo(4,
    5, 8). You can also use it to turn the tuple returned by promote into arguments
    to the various arithmetic functions, including +, -, *, and so on. You can perform
    some experiments in the Julia REPL to better understand how the promote function
    works:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '... 被称为 *splat* 操作符，你可以使用它将数组或元组转换为函数参数。这意味着 foo([4, 5, 8]...) 与 foo(4, 5,
    8) 相同。你还可以使用它将 promote 返回的元组转换为各种算术函数的参数，包括 +、-、* 等等。你可以在 Julia REPL 中进行一些实验，以更好地理解
    promote 函数的工作原理：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This shows that promote returns a tuple of numbers converted to the most appropriate
    common type. However, for everyday programming you can use typeof instead to figure
    out what an expression will get promoted to.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 promote 返回一个数字元组，这些数字被转换为最合适的公共类型。然而，对于日常编程，你可以使用 typeof 来代替，以确定表达式将被提升为哪种类型。
- en: 9.2 Understanding number conversion
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 理解数字转换
- en: Number conversion means converting from one type of number to another. This
    should not be confused with parsing. For instance, a text string can be parsed
    to produce a number, but a string and a number are not related types; hence you
    should not call it a conversion.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数字转换意味着将一种数字类型转换为另一种类型。这不应与解析混淆。例如，文本字符串可以被解析为数字，但字符串和数字不是相关类型；因此你不应该称之为转换。
- en: 'The recommended and simplest way of doing number conversion in Julia is to
    use the constructor of the type you want to convert to. So if you have a value
    x and you want to convert to some type T, then just write T(x). I’ll provide some
    examples:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中进行数字转换的推荐且最简单的方法是使用你想要转换到的类型的构造函数。所以如果你有一个值 x，并且你想将其转换为类型 T，那么只需写 T(x)。我将提供一些例子：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Keep in mind that a conversion is not always possible to perform:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，转换并不总是可以执行的：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An 8-bit number cannot hold values larger than 255 (28 - 1), and integers cannot
    represent decimals.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 8 位数字无法表示大于 255（2^8 - 1）的值，整数无法表示小数。
- en: 'In many cases, conversions are done implicitly by Julia. Julia uses the convert
    function to achieve this, not the constructor. However you are free to call convert
    explicitly yourself. Here is a demonstration:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，转换是由 Julia 隐式完成的。Julia 使用 convert 函数来实现这一点，而不是构造函数。然而，你可以自由地显式调用 convert。以下是一个演示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Convert floating-point number 5.0 to integer 5.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将浮点数 5.0 转换为整数 5。
- en: ❷ Convert integer 5 to floating-point number 5.0.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将整数 5 转换为浮点数 5.0。
- en: 'Notice the first argument in these function calls Int64, Float64, and so on.
    These are type objects. Types are first-class objects in Julia, meaning they can
    be handled like any other object. You can pass them around, store them, and define
    methods that operate on them. Type objects even have a type. The type of Int64
    is Type{Int64}, and for Float64 it is Type{Float64}:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些函数调用的第一个参数 Int64、Float64 等。这些都是类型对象。类型是 Julia 中的第一类对象，这意味着它们可以像任何其他对象一样被处理。你可以传递它们、存储它们，并为它们定义方法。类型对象甚至有自己的类型。Int64
    的类型是 Type{Int64}，对于 Float64 是 Type{Float64}：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Number 3 is of type Int64.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数字 3 是 Int64 类型。
- en: ❷ Type Int64 is of type Type{Int64}.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 类型 Int64 是 Type{Int64} 类型。
- en: ❸ Type Int64 is not of type Type{String}.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 类型 Int64 不是 Type{String} 类型。
- en: You can almost think about Type as a special kind of function. Feeding this
    “function” an argument T returns the type of T. Formally, Type is a paramatric
    type, which can be parameterized with a type argument T to produce a concrete
    type. Don’t worry if this does not make sense; it is a complex topic, and I explain
    this topic more thoroughly in the next chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以将 Type 视为一个特殊类型的函数。向这个“函数”提供一个参数 T，将返回 T 的类型。正式来说，Type 是一个参数化类型，可以用类型参数
    T 来参数化，以产生一个具体类型。如果你觉得这不太明白，不要担心；这是一个复杂的话题，我将在下一章更详细地解释这个话题。
- en: 'The convert function is called implicitly when performing various types of
    assignments, including the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行各种类型的赋值操作时，包括以下情况，会隐式调用 convert 函数：
- en: Assigning to an array element
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数组元素进行赋值
- en: Setting the value of the field of a composite type
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置复合类型字段的值
- en: Assigning to local variables with a type annotation
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型注解对局部变量进行赋值
- en: Returning from a function with a type annotation
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型注解从函数返回
- en: 'Let’s look at some examples demonstrating implicit conversion:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些演示隐式转换的例子：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Assigning an Int64 value to an array element defined to be Int8, which causes
    convert(Int8, x) to be called
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 Int64 值赋给定义为 Int8 的数组元素，这会导致调用 convert(Int8, x)
- en: In the next example, you create a composite type Point with the fields x and
    y. Next, you create an instance p of Point and assign an 8-bit integer value to
    its x field. Since the field is of type Float64, an implicit number conversion
    happens.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，你创建了一个复合类型 `Point`，具有字段 x 和 y。接下来，你创建了一个 `Point` 的实例 p，并将其 x 字段赋值为一个
    8 位整数。由于字段类型为 Float64，会发生隐式数字转换。
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Causes convert(Float64, Int8(10)) to be called
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致调用 `convert(Float64, Int8(10))`
- en: 'Here a type annotation is added to a function to make sure the return value
    is of a certain type. If it is not, a conversion is attempted with convert:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，向函数添加了一个类型注解，以确保返回值是某种类型。如果不是，将尝试使用 `convert` 进行转换：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we will get into the details of how conversion and promotion is done using
    a larger code example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个更大的代码示例来详细说明如何进行转换和提升。
- en: 9.3 Defining custom units for angles
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 定义角度的自定义单位
- en: In general, calculations within science can easily go wrong if you mix up units.
    For instance, in the petroleum industry, mixing feet and meters is easy because
    the coordinates of an oil well are usually given in meters, while the depth of
    the well is given in feet.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果混合单位，科学计算很容易出错。例如，在石油工业中，混合英尺和米很容易，因为油井的坐标通常以米给出，而井深以英尺给出。
- en: A famous example is the Mars Climate Orbiter ([http://mng.bz/m2l8](https://solarsystem.nasa.gov/missions/mars-climate-orbiter/in-depth/)),
    a robotic space probe launched by NASA, which was lost due to NASA and Lockheed
    using different units of measure. NASA was using metric units, and Lockheed used
    US customary units, such as feet and pounds. Thus, there is an advantage in designing
    code where one does not accidentally mix up units.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的例子是火星气候轨道器 ([http://mng.bz/m2l8](https://solarsystem.nasa.gov/missions/mars-climate-orbiter/in-depth/))，这是由
    NASA 发射的机器人太空探测器，由于 NASA 和洛克希德使用不同的度量单位而丢失。NASA 使用公制单位，而洛克希德使用美国习惯单位，如英尺和磅。因此，在设计代码时，避免意外混合单位是有优势的。
- en: In this example we will demonstrate working with different units for angles.
    In mathematics, angles are usually given as radians, while people navigating using
    maps will tend to use degrees. When using degrees, you split up the circle in
    360 degrees. One degree is, thus, 1/360th of the circumference of that circle.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将展示如何处理角度的不同单位。在数学中，角度通常以弧度给出，而使用地图导航的人通常会使用度。当使用度时，你将圆分成 360 度。因此，1
    度是那个圆周长度的 1/360。
- en: With radians, in contrast, we deal with how many times the radius of a circle
    is duplicated along the circumference to get that angle (figure 9.1). So 1 radian
    is the angle you get when you mark off a distance along the circumference equal
    to the radius of the circle.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与弧度相比，我们处理的是圆周上半径重复多少次以得到该角度（图 9.1）。因此，1 弧度是当你沿着圆周标记出等于圆半径的距离时得到的角。
- en: '![09-01](../Images/09-01.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![09-01](../Images/09-01.png)'
- en: Figure 9.1 Definition of a radian
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 弧度的定义
- en: Degrees, in contrast, are more strongly tied to navigation—celestial navigation
    in particular. Each day the earth moves about 1 degree around the sun, since the
    year is made up of 365 days. An angle is further divided into 60 arcminutes, and
    an arcminute is divided into 60 arcseconds.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，度与导航（特别是天体导航）的联系更为紧密。地球每天大约移动 1 度绕太阳转，因为一年由 365 天组成。角度进一步分为 60 分，而一分分为
    60 秒。
- en: Actually, you can work with both metric degrees and degrees, minutes, seconds
    (DMS), but you are working with DMS here to keep things interesting.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以同时处理公制度和度、分、秒（DMS），但在这里你使用 DMS 以保持事情有趣。
- en: '![09-02](../Images/09-02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![09-02](../Images/09-02.png)'
- en: Figure 9.2 How degrees, arcminutes, and arcseconds are subdivided
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 度、分和秒的细分
- en: 'In this code example you will implement the following functionality:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，你将实现以下功能：
- en: Radian and DMS types to represent different types of angle units
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弧度和 DMS 类型用于表示不同类型的角度单位
- en: Constructors to make it easier to construct angle objects, given degrees, arcminutes,
    and arcseconds
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数，以便在给定度、分和秒的情况下更容易构建角度对象
- en: Operations on angle types, such as addition and subtraction
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度类型上的操作，如加法和减法
- en: Accessors to extract degrees, minutes, and seconds
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问器以提取度、分和秒
- en: Extending the show function to create a pretty display of different angle units
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 `show` 函数以创建不同角度单位的漂亮显示
- en: Extending the convert function to support conversion from one angle unit to
    another
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 `convert` 函数以支持从一个角度单位转换到另一个单位
- en: Overriding the sin and cos functions to only work with angle units
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖 sin 和 cos 函数以仅与角度单位一起工作
- en: Coupling together some clever tricks to make pretty number literals for angle
    units
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合一些巧妙的技巧来制作角度单位的漂亮数字字面量
- en: Extending the promotion_rule function, so different angle units can be used
    in the same expression
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 promotion_rule 函数，以便不同的角度单位可以在同一表达式中使用
- en: Let’s start by implementing the Radian and DMS angle types.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现 Radian 和 DMS 角度类型。
- en: Listing 9.2 Defining radians and degrees as subtypes of the abstract Angle type
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 定义弧度和度作为抽象 Angle 类型的子类型
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As in the rocket example, you have defined an abstract type, Angle, which all
    the concrete angle units are subtypes of. The benefits of this will become clear
    later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如同火箭示例中一样，您定义了一个抽象类型 Angle，所有具体的角度单位都是其子类型。其好处将在以后变得明显。
- en: 9.3.1 Defining angle constructors
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 定义角度构造函数
- en: That DMSs are stored as seconds should be regarded as an implementation detail
    and not exposed to the user. Hence, users should not use that constructor directly.
    Instead, you will define more natural constructors, as follows.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 应将 DMS 存储为秒视为实现细节，不应暴露给用户。因此，用户不应直接使用该构造函数。相反，您将定义更自然的构造函数，如下所示。
- en: Listing 9.3 Angle constructors for degrees, minutes, and seconds
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 弧度构造函数：度、分和秒
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 9.3.2 Defining arithmetic operations on angles
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 定义角度上的算术运算
- en: To be able to actually run these constructors you need to be able to add together
    DMS numbers. The code snippet Degree(deg) + Minute(min) basically does a DMS(deg,
    0, 0) + DMS(0, min, 0). However, the + operator has not been defined for DMS types.
    Nor have you defined them for radians, so let’s do both in the following listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够实际运行这些构造函数，您需要能够将 DMS 数字相加。代码片段 Degree(deg) + Minute(min) 实际上执行的是 DMS(deg,
    0, 0) + DMS(0, min, 0)。然而，+ 运算符尚未为 DMS 类型定义。您也没有为弧度定义它们，所以让我们在下面的列表中同时进行这两项定义。
- en: Listing 9.4 Arithmetic for DMS and radian angles
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 DMS 和弧度角度的算术运算
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I’ll clarify how this works. As discussed in section 7.3.3, defining a method
    in Julia will automatically create a function if no corresponding function already
    exists. For example, if the + function is not imported, Julia will not know that
    it already exists when you define +*methods*. Thus, Julia will create an entirely
    new +*function* and attach your angle-specific methods to it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我将阐明这是如何工作的。如第 7.3.3 节所述，在 Julia 中定义一个方法会自动创建一个函数，如果还没有相应的函数存在。例如，如果没有导入 + 函数，当您定义
    +*methods* 时，Julia 不会知道它已经存在。因此，Julia 将创建一个全新的 +*function* 并将您的角度特定方法附加到它上。
- en: The main and base modules All Julia types and functions belong to a module.
    You can think of a module as a namespace or library. Most of the functionality
    that comes bundled with Julia is in the module called Base. Previously, you have
    used the Statistics module. Functions and types you have not explicitly made part
    of a named module become part of the Main module. Every function and type you
    create in the Julia REPL is part of the Main module.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 主要和基础模块 所有 Julia 类型和方法都属于一个模块。您可以将模块视为一个命名空间或库。Julia 随带的大部分功能都在名为 Base 的模块中。之前，您已经使用了
    Statistics 模块。您没有明确将其包含在命名模块中的函数和类型将成为 Main 模块的一部分。在 Julia REPL 中创建的每个函数和类型都是
    Main 模块的一部分。
- en: 'If you then try to evaluate 3 + 4, Julia will attempt a lookup of matching
    methods on this newly defined + function. But it has no methods dealing with regular
    numbers, only for angles. Thus, if you had forgotten to write import Base: +,
    you would have gotten this error message:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您尝试计算 3 + 4，Julia 将尝试查找这个新定义的 + 函数上的匹配方法。但它没有处理常规数字的方法，只有角度的方法。因此，如果您忘记编写
    import Base: +，您将收到以下错误信息：'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Essentially, you end up shadowing the + function defined in Base and its attached
    methods. By doing import, you are essentially telling Julia you want to add methods
    to a function defined in an existing module, such as Base. If you don’t do that,
    your newly defined + function will become part of the Main module. Everything
    defined in the REPL that has not been imported from somewhere else is made part
    of the Main module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您最终会覆盖在 Base 中定义的 + 函数及其附加的方法。通过导入，您实际上是在告诉 Julia 您想要向现有模块中定义的函数添加方法，例如
    Base。如果您不这样做，您新定义的 + 函数将成为 Main 模块的一部分。在 REPL 中定义的、未从其他地方导入的一切都将成为 Main 模块的一部分。
- en: 'Figure 9.3 is an illustration of the shadowing problem. Function list A is
    what you get when you don’t import + and - from Base before adding methods to
    these functions. The result is two separate method tables for each operator: one
    for Base and another for Main. In the B example + and - were imported; thus, the
    methods are added to the method table defined by Base, rather than a new method
    table in the Main module being created.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 是阴影问题的说明。函数列表 A 是在你向这些函数添加方法之前没有从 Base 中导入 + 和 - 时得到的。结果是每个运算符有两个单独的方法表：一个是
    Base 的，另一个是 Main 的。在 B 示例中，导入了 + 和 -；因此，方法被添加到由 Base 定义的方法表中，而不是在 Main 模块中创建一个新的方法表。
- en: '![09-03](../Images/09-03.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![09-03](../Images/09-03.png)'
- en: Figure 9.3 Shadowing of functions that occurs when you don’t import functions
    before extending them
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 在扩展函数之前未导入函数时发生的函数阴影问题
- en: 9.3.3 Defining accessors to extract degrees, minutes, and seconds
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 定义访问器以提取度、分和秒
- en: Given an angle in DMS, let’s discover the degrees, minutes, and seconds part
    in the following listing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 DMS（度、分、秒）角度，让我们在下面的列表中探讨其度、分和秒的部分。
- en: Listing 9.5 Degree and minute accessors for DMS objects
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 DMS 对象的度和分访问器
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can use these functions to provide a custom display of these angles on the
    Julia REPL. To write that the angle is 90 degrees, 30 arcminutes, and 45 arcseconds
    you would use the notation 90° 30' 45''.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些函数在 Julia REPL 中提供这些角度的定制显示。要表示角度为 90 度、30 分和 45 秒，你会使用表示法 90° 30' 45''。
- en: 9.3.4 Displaying DMS angles
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4 显示 DMS 角度
- en: 'If you use the constructors now, the display you get out of the box isn’t very
    good. It exposes the internal representation of DMS degrees as being made up of
    arcseconds:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在使用构造函数，你得到的显示效果并不是很好。它暴露了 DMS 度的内部表示是由弧秒组成的：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can define an alternative view by adding a method to the Julia show function.
    The Julia REPL environment uses the show(io::IO, data) to display data of some
    specific type to the user. Remember in Julia you can define methods to work on
    generic abstract types; however, you can also add methods dealing with more concrete
    types, which is what you would want to do in this situation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向 Julia 的 show 函数添加一个方法来定义一个替代视图。Julia 的交互式环境（REPL）使用 show(io::IO, data)
    来向用户显示某些特定类型的数据。记住，在 Julia 中，你可以定义方法来处理通用抽象类型；然而，你也可以添加处理更具体类型的方法，这正是你在这个情况下想要做的。
- en: Listing 9.6 Defining string representation of Radian and DMS objects
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 定义弧度和 DMS 对象的字符串表示
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will learn more about the show and IO objects in chapter 11\. But for now,
    this gives you a nice way of looking at DMS angles:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第 11 章中了解更多关于 show 和 IO 对象的内容。但就目前而言，这为你提供了一个查看 DMS 角度的不错方式：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 9.3.5 Defining type conversions
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.5 定义类型转换
- en: Now that you have the basics in place, you want to be able to do something useful
    with these angles. You may want to use them with functions such as sin and cos,
    but these just take plain numbers that are radians. You need to define conversions,
    so DMS angles can be turned into radians.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了基础知识，你想要能够对这些角度做一些有用的事情。你可能想要使用它们与 sin 和 cos 等函数一起，但这些函数只接受纯数字，即弧度。你需要定义转换，以便
    DMS 角度可以转换为弧度。
- en: Listing 9.7 Definining methods for direct and indirect type conversion
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 定义直接和间接类型转换的方法
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Convert the DMS value to a Radian value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 DMS 值转换为弧度值。
- en: ❷ Convert the Radian value to a DMS value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将弧度值转换为 DMS 值。
- en: This contains a number of new things I’ll discuss in greater detail. Notice
    that the convert method definitions don’t specify the name of the argument, only
    its type. This is similar to the rocket example, where you defined the mass of
    a Rutherford engines as
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了一些我将更详细讨论的新内容。注意，转换方法定义没有指定参数的名称，只指定了其类型。这与火箭示例类似，在那里你将 Rutherford 发动机的质量定义为
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You could have written engine::Rutherford, but what would the point be? The
    Rutherford composite type did not have any fields you could access. Likewise Type{Radian}
    and Type{DMS} don’t have any fields you are interested in accessing in the convert
    definition. With these conversions in place you can implement versions of sin
    and cos that take numbers with units as arguments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写成 engine::Rutherford，但这有什么意义呢？Rutherford 组合类型没有任何可以访问的字段。同样，Type{Radian}
    和 Type{DMS} 没有任何你在 convert 定义中感兴趣的字段。有了这些转换，你可以实现接受具有单位数字作为参数的 sin 和 cos 的版本。
- en: Listing 9.8 Overriding standard sin and cos functions to use DMS and Radian
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 覆盖标准 sin 和 cos 函数以使用 DMS 和弧度
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case you are not importing sin and cos before creating the methods.
    This is because you actually want to shadow the *real* sin and cos functions,
    since you don’t want people to accidentally call these functions using plain numbers.
    You want them to use radians or degrees explicitly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您在创建方法之前没有导入 sin 和 cos。这是因为您实际上想覆盖 *真实* 的 sin 和 cos 函数，因为您不希望人们意外地使用纯数字调用这些函数。您希望他们明确使用弧度或度：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now you cannot accidentally use an angle as input to a trigonometric function
    without having specified whether it is given in radians or degrees.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您不能在没有指定角度是以弧度还是度为单位给出时，意外地将角度用作三角函数的输入。
- en: 9.3.6 Making pretty literals
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.6 制作漂亮的字面量
- en: This is nice, but it would look a lot better if you could write sin(90°) instead
    of sin(Degree(90)) and sin(1.5rad) instead of sin(Radian(1.5)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但如果您能写 sin(90°) 而不是 sin(Degree(90))，以及 sin(1.5rad) 而不是 sin(Radian(1.5))，那就更好了。
- en: In fact, you can achieve this. Observe that Julia interprets 1.5rad as 1.5*rad.
    Thus by defining multiplication of regular scalars with units of degrees or radians
    you have *magically* solved the problem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以实现这一点。观察 Julia 将 1.5rad 解释为 1.5*rad。因此，通过定义常规标量与度或弧度单位的乘法，您可以*神奇地*解决这个问题。
- en: Listing 9.9 Operations and constants to allow pretty angle literals
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 允许漂亮角度字面量的运算和常数
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last two lines show the secret sauce. They mean 90° is read by Julia as
    90 * Degree(1), which, when computed, will result in Degree(90):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行展示了秘诀。它们意味着 Julia 将 90° 读取为 90 * Degree(1)，当计算时，将得到 Degree(90)：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 9.3.7 Type promotions
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.7 类型提升
- en: 'The simple but labor-intensive way of adding support for doing arithmetic with
    different angle units would mean defining lots of functions with all possible
    combinations. Imagine you had another angle type: MetricDegree. It would quickly
    cause a combinatorial explosion, as shown in the following listing.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对不同角度单位进行算术运算的支持的简单但劳动密集型方法意味着定义大量具有所有可能组合的函数。想象一下，如果您还有一个角度类型：MetricDegree。它将迅速导致组合爆炸，如下面的列表所示。
- en: Listing 9.10 Combinatorial explosion of arithmetic operations
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 算术运算的组合爆炸
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I have not even shown all the combinations. The point I am making is that you
    get many combinations that are hard to manage. Instead, the better solution is
    defining generic functions for different units, as shown in the following listing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至没有展示所有组合。我想要表达的观点是，您会得到许多难以管理的组合。相反，更好的解决方案是定义针对不同单位的通用函数，如下面的列表所示。
- en: Listing 9.11 Simplifying arithmetic operations by utilizing promotion
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 通过利用提升简化算术运算
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only remaining problem is that you have not told promote how to promote
    angle types. It only knows about Number types. A first guess of how to add the
    temperature type would be adding another promote method, but that’s not how it
    works. Instead, promote does its job by calling a function called promote_rule.
    You need to register your types by defining promote_rule methods for *your* types.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一问题是您没有告诉 promote 如何提升角度类型。它只知道 Number 类型。一个关于如何添加温度类型的初步猜测是添加另一个 promote
    方法，但这不是它的工作方式。相反，promote 通过调用一个名为 promote_rule 的函数来完成其工作。您需要通过为 *您的* 类型定义 promote_rule
    方法来注册您的类型。
- en: Listing 9.12 Defining type promotion of Radian and DMS
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 定义弧度和 DMS 的类型提升
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These methods are unusual, as all the arguments are type objects. In addition,
    you haven’t given a name to any of the arguments because the type objects are
    not used for anything but getting multiple dispatch to select the correct method
    of the promote_ rule function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是不寻常的，因为所有参数都是类型对象。此外，您没有为任何参数命名，因为类型对象不用于任何目的，只是用于通过多态选择 promote_rule 函数的正确方法。
- en: 'The promote_rule function takes two type objects as arguments and returns another
    type object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: promote_rule 函数接受两个类型对象作为参数，并返回另一个类型对象：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can pose the promotion rule as the following question: given two different
    types, what type should they all be promoted to? Now you have put all the pieces
    in place. You have plugged into the Julia convert and promote machinery by implementing
    methods for the convert and promote_rule functions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将提升规则表述为以下问题：给定两种不同的类型，它们应该提升为哪种类型？现在您已经将所有部件放在一起。您通过实现 convert 和 promote_rule
    函数的方法，将它们连接到 Julia 的转换和提升机制中：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example gives you a hint about the advantages of using a multiple-dispatch
    language, such as Julia. Implementing this behavior using object-oriented programming
    is harder and gets increasingly difficult as you add more types into the mix.
    If you defined each angle as a class, you would need several methods for every
    operation—one for each type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子给你一个关于使用多分派语言（如 Julia）的优点提示。使用面向对象编程来实现这种行为会更难，并且随着你添加更多类型而变得越来越困难。如果你将每个角度定义为类，你将需要为每个操作定义几个方法——每个类型一个。
- en: 'And there are more practical problems with the object-oriented approach. Should
    you ever need to add another angle unit, it will require the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 并且面向对象方法还有更多实际问题。如果你需要添加另一个角度单位，它将需要以下步骤：
- en: Adding another class with four methods for each operator
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个运算符添加一个包含四个方法的新类
- en: Modifying every other angle class, including the base class, Angle, by adding
    a version of each operator handling the new angle unit
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加处理新角度单位版本的每个运算符，修改其他每个角度类，包括基类 Angle
- en: Adding another constructor in each class to handle the new angle unit (to allow
    conversion)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个类中添加另一个构造函数来处理新的角度单位（以允许转换）
- en: 'This obviously does not scale, and it breaks the open-close principle^([1](#pgfId-1017573))
    in object-oriented programming. The open-close principle can be summed up in the
    following saying: *open for extension, closed for modification*.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然无法扩展，并且违反了面向对象编程中的开放-封闭原则^([1](#pgfId-1017573))。开放-封闭原则可以用以下说法来概括：*对扩展开放，对修改封闭*。
- en: If angle units were provided as a library, you could not extend it with other
    units without modifying the library itself. That is obviously impractical.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果角度单位作为库提供，则无法在不修改库本身的情况下扩展它。这显然是不切实际的。
- en: Julia elegantly solves this by *not* making functions a part of the types. Thus,
    you can add new constructor functions to a type without modifying the type definition
    itself. Adding convert and promote_rule functions does not require modification
    of the library providing the types you are attempting to define promotion rules
    and conversion for.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 通过 *不* 将函数作为类型的一部分来优雅地解决这个问题。因此，你可以在不修改类型定义本身的情况下向类型添加新的构造函数。添加 convert
    和 promote_rule 函数不需要修改提供你试图定义提升规则和转换的类型的库。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Type promotion is handled in Julia by defining promotion rules. This is done
    by adding methods to the promote_rule function.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 通过定义提升规则来处理类型提升。这是通过向 promote_rule 函数添加方法来完成的。
- en: 'Conversion of a value x to a type T is accomplished via two different approaches:
    T(x) and convert(T, x). The latter is used when dealing with implicit conversions.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值 x 转换为类型 T 的操作通过两种不同的方法完成：T(x) 和 convert(T, x)。后者用于处理隐式转换。
- en: An object x can have a type T. Type{T} is the type of a type object T. This
    knowledge helps you to add methods to the convert function correctly.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象 x 可以具有类型 T。Type{T} 是类型对象 T 的类型。这一知识有助于你正确地向 convert 函数添加方法。
- en: By defining your own promotion rules and conversion functions, you can add new
    number types to Julia or add units such as degrees, meters, feet, celsius, or
    fahrenheit to Julia numbers. Units help make numerical code more robust. New number
    types can help improve accuracy in calculations, reduce memory requirements, and
    improve performance.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义自己的提升规则和转换函数，你可以将新的数字类型添加到 Julia 中，或者将度、米、英尺、摄氏度或华氏度等单位添加到 Julia 数字中。单位有助于使数值代码更加健壮。新的数字类型可以帮助提高计算的准确性，减少内存需求，并提高性能。
- en: To add methods to a function defined in another module, you need to explicitly
    import those functions from the module. If you don’t, you will end up shadowing
    those functions, which will usually not provide your desired result.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向在另一个模块中定义的函数添加方法，你需要显式地从该模块导入这些函数。如果不这样做，你将最终覆盖这些函数，这通常不会提供你期望的结果。
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)*Object Oriented Software Construction*, Bertrand Meyer, Prentice Hall,
    1988, p 23.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ^[1]*面向对象软件构造*，伯特兰·梅耶，普伦蒂斯·霍尔，1988年，第 23 页。
