- en: 4 Designing function signatures and types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 设计函数签名和类型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Designing good function signatures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计良好的函数签名
- en: Fine-grained control over the inputs to a function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对函数输入的精细控制
- en: Using `Unit` as a more flexible alternative to `void`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Unit` 作为 `void` 的更灵活的替代品
- en: The principles we’ve covered so far define FP in general, regardless of whether
    you’re programming in a statically typed language like C# or a dynamically typed
    language like JavaScript. In this chapter, you’ll learn some functional techniques
    that are specific to statically typed languages. Having functions and their arguments
    typed opens up a whole set of interesting considerations..
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所讨论的原则定义了泛型 FP，无论你是在使用 C# 这样的静态类型语言编程，还是在使用 JavaScript 这样的动态类型语言编程。在本章中，你将学习一些特定于静态类型语言的函数技术。函数及其参数的类型化打开了一系列有趣的考虑。
- en: Functions are the building blocks of a functional program, so getting the function
    signature right is paramount. And because a function signature is defined in terms
    of the types of its inputs and outputs, getting those types right is just as important.
    Type design and function signature design are really two faces of the same coin.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是函数程序的基本构建块，因此正确地获取函数签名至关重要。由于函数签名是在其输入和输出的类型的基础上定义的，因此正确地获取这些类型同样重要。类型设计和函数签名设计实际上是同一枚硬币的两个面。
- en: You may think that after years of defining classes and interfaces, you know
    how to design your types and functions. But it turns out that FP brings a number
    of interesting concepts to the table that can help you increase the robustness
    of your programs and the usability of your APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为经过多年的定义类和接口，你知道如何设计你的类型和函数。但结果是，FP 带来了一系列有趣的概念，可以帮助你提高程序的健壮性和 API 的可用性。
- en: 4.1 Designing function signatures
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 设计函数签名
- en: A function’s signature tells you the types of its inputs and outputs; if the
    function is named, it also includes the function’s name. As you code more functionally,
    you’ll find yourself looking at function signatures more often. Defining function
    signatures is an important step in your development process, often the first thing
    you do as you approach a problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名告诉了你其输入和输出的类型；如果函数有名称，它还包括函数的名称。随着你更多地以函数方式编程，你会发现你更频繁地查看函数签名。定义函数签名是你在开发过程中的一个重要步骤，通常是你接近问题时做的第一件事。
- en: I’ll start by introducing a notation for function signatures that’s standard
    in the FP community. We’ll use it throughout the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先介绍一个在 FP 社区中标准的函数签名符号。我们将全书使用它。
- en: 4.1.1 Writing functions signatures with arrow notation
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 使用箭头符号编写函数签名
- en: 'In FP, function signatures are usually expressed in *arrow notation*. There’s
    great benefit to learning it because you’ll find it in books, articles, and blogs
    on FP: it’s the lingua franca used by functional programmers from different languages.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FP 中，函数签名通常使用 *箭头符号* 来表达。学习它有很大的好处，因为你会发现它在 FP 的书籍、文章和博客中：它是不同语言的功能程序员使用的通用语言。
- en: 'Let’s say we have a function `f` from `int` to `string`; it takes an `int`
    as input and yields a `string` as output. We’ll notate the signature like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个从 `int` 到 `string` 的函数 `f`；它接受一个 `int` 作为输入并返回一个 `string` 作为输出。我们将这样表示其签名：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In English, you’d read that as `f` has type of `int` to `string` or `f` takes
    an `int` and yields a `string`. In C#, a function with this signature is assignable
    to `Func<int,` `string>`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，你会读到 `f` 的类型是 `int` 到 `string`，或者 `f` 接受一个 `int` 并返回一个 `string`。在 C# 中，具有此签名的函数可以赋值给
    `Func<int, string>`。
- en: You’ll probably agree that the arrow notation is more readable than the C# type,
    and that’s why we’ll use it when discussing signatures. When we have no input
    or no output (`void` or `Unit`), we’ll indicate this with `()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会同意，箭头符号比 C# 类型更易读，这就是为什么我们在讨论签名时会使用它。当我们没有输入或输出（`void` 或 `Unit`）时，我们将使用
    `()` 来表示。
- en: Let’s look at some examples. Table 4.1 shows function types expressed in arrow
    notation side by side with the corresponding C# delegate type and an example implementation
    of a function that has the given signature in lambda notation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子。表 4.1 显示了使用箭头符号表达的函数类型与相应的 C# 委托类型以及具有给定签名的函数的 lambda 表达式示例并排展示。
- en: Table 4.1 Expressing function signatures with arrow notation
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 使用箭头符号表达函数签名
- en: '| Function signature | C# type | Example |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 函数签名 | C# 类型 | 示例 |'
- en: '| `int` `→` `string` | `Func<int, string>` | `(int i) => i.ToString()` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `int` `→` `string` | `Func<int, string>` | `(int i) => i.ToString()` |'
- en: '| `()` `→` `string` | `Func<string>` | `() => "hello"` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `()` `→` `string` | `Func<string>` | `() => "hello"` |'
- en: '| `int` `→` `()` | `Action<int>` | `(int i) => WriteLine($"gimme {i}")` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `int` `→` `()` | `Action<int>` | `(int i) => WriteLine($"gimme {i}")` |'
- en: '| `()` `→` `()` | `Action` | `() => WriteLine("Hello World!")` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `()` `→` `()` | `Action` | `() => WriteLine("Hello World!")` |'
- en: '| `(int, int)` `→` `int` | `Func<int, int, int>` | `(int a, int b) => a + b`
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `(int, int)` `→` `int` | `Func<int, int, int>` | `(int a, int b) => a + b`
    |'
- en: 'The last example in table 4.1 shows multiple input arguments: we just group
    them with parentheses. (Parentheses indicate tuples, so in fact, we’re notating
    a binary function as a unary function whose input argument is a binary tuple.)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4.1 的最后一个例子显示了多个输入参数：我们只需用括号将它们分组。括号表示元组，因此实际上我们是在将二元函数表示为一元函数，其输入参数是一个二元元组。
- en: 'Now, let’s move on to more complex signatures, namely those of HOFs. Let’s
    start with the following method (from listing 2.10) that takes a `string` and
    a function from `IDbConnection` to `R` and returns an `R`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向更复杂的签名，即那些高阶函数（HOFs）的签名。让我们从以下方法开始，该方法接受一个 `string` 和一个从 `IDbConnection`
    到 `R` 的函数，并返回一个 `R`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'How would you notate this signature? The second argument is itself a function,
    so it can be notated as `IDbConnection → R`. The HOF’s signature is notated as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何表示这个签名？第二个参数本身就是一个函数，因此它可以表示为 `IDbConnection → R`。HOF 的签名如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this is the corresponding C# type:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的 C# 类型：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The arrow syntax is slightly more lightweight and is more readable, especially
    as the complexity of the signature increases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头语法稍微轻量一些，并且更易于阅读，尤其是在签名的复杂性增加时。
- en: 4.1.2 How informative is a signature?
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 签名有多大的信息量？
- en: 'Some function signatures are more expressive than others, by which I mean that
    they give us more information about what the function is doing, what inputs are
    permissible, and what outputs we can expect. The signature `()` `→` `()`, for
    example, gives us no information at all: it may print some text, increment a counter,
    launch a spaceship . . . who knows? On the other hand, consider this signature:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数签名比其他签名更具表达性，我的意思是它们给我们提供了更多关于函数做什么、允许哪些输入以及我们可以期望什么输出的信息。例如，签名 `()` `→`
    `()` 完全没有提供任何信息：它可能打印一些文本，增加一个计数器，发射一艘宇宙飞船……谁知道呢？另一方面，考虑以下签名：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Take a minute and see if you can guess what a function with this signature does.
    Of course, you can’t really know for sure without seeing the actual implementation,
    but you can make an educated guess. The function returns a list of `T`’s and takes
    a list of `T`’s, as well as a second argument, which is a function from `T` to
    `bool`, a *predicate* on `T`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 花一分钟时间看看你是否能猜出具有此签名的函数做什么。当然，没有看到实际的实现，你无法确切知道，但你可以做出一个有根据的猜测。该函数返回一个 `T` 的列表，并接受一个
    `T` 的列表，以及第二个参数，它是一个从 `T` 到 `bool` 的函数，即 `T` 的一个 *断言*。
- en: 'It’s reasonable to assume that the function uses the predicate on `T` to filter
    the elements in the list. In short, it’s a filtering function. Indeed, this is
    exactly the signature of `Enumerable.Where`. Let’s look at another example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 合理地假设该函数使用 `T` 上的断言来过滤列表中的元素。简而言之，它是一个过滤函数。实际上，这正是 `Enumerable.Where` 的签名。让我们看看另一个例子：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Can you guess what the function does? It returns a sequence of `C`’s and takes
    a sequence of `A`’s, a sequence of `B`’s, and a function that computes a `C` from
    an `A` and a `B`. It’s reasonable to assume that this function applies the computation
    to elements from the two input sequences, returning a third sequence with the
    computed results. This function could be the `Enumerable.Zip` function, which
    we discussed in section 3.2.3.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出这个函数的作用吗？它返回一个 `C` 的序列，并接受一个 `A` 的序列，一个 `B` 的序列，以及一个从 `A` 和 `B` 计算出 `C`
    的函数。合理地假设这个函数将计算应用于两个输入序列的元素，并返回一个包含计算结果的第三个序列。这个函数可能是我们第 3.2.3 节讨论过的 `Enumerable.Zip`
    函数。
- en: These last two signatures are so expressive that you can make a good guess at
    the implementation, which is a desirable trait. When you write an API, you want
    it to be clear, and if the signature goes hand in hand with good naming in expressing
    the intent of the function, all the better.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个最后的签名如此具有表达性，以至于你可以对实现做出很好的猜测，这是一个可取的特性。当你编写 API 时，你希望它清晰，如果签名与良好的命名一起表达函数的意图，那就更好了。
- en: Of course, there are limits to how much a function signature can express. For
    instance, `Enumerable.TakeWhile`, a function that traverses a given sequence,
    yielding all elements as long as a given predicate evaluates to true, has the
    same signature as `Enumerable.Where`. This makes sense because `TakeWhile` can
    also be viewed as a filtering function, but one that works differently than `Where`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数签名所能表达的内容是有限的。例如，`Enumerable.TakeWhile`是一个遍历给定序列的函数，只要给定的谓词评估为真，就会产生所有元素，它与`Enumerable.Where`具有相同的签名。这很有道理，因为`TakeWhile`也可以被视为一个过滤函数，但它的工作方式与`Where`不同。
- en: In summary, some signatures are more expressive than others. As you develop
    your APIs, make your signatures as expressive as possible—this facilitates the
    consumption of your APIs and adds robustness to your programs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，一些签名比其他签名更具表现力。随着你开发你的API，尽量让你的签名尽可能具有表现力——这有助于你的API被消费，并为你的程序增加鲁棒性。
- en: 4.2 Capturing data with data objects
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 使用数据对象捕获数据
- en: 'Functions and data are like the two sides of a coin: functions consume and
    produce data. A good API needs functions with clear signatures and well-designed
    data types to represent the inputs and outputs of these functions. In FP (unlike
    OOP), it’s natural to draw a separation between logic and data:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和数据就像硬币的两面：函数消耗数据并产生数据。一个好的API需要具有清晰签名的函数和精心设计的用于表示这些函数输入和输出的数据类型。在FP（与OOP不同），在逻辑和数据之间进行区分是自然的：
- en: Logic is encoded in functions.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑被编码在函数中。
- en: Data is captured with data objects, which are used as inputs and outputs of
    these functions.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据通过数据对象被捕获，这些数据对象被用作这些函数的输入和输出。
- en: In this section, we’ll look at some basic ideas for designing data objects.
    We’ll then move on to the somewhat more abstract concepts of representing the
    absence of data (section 4.3) or the possible absence of data (chapter 5).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些设计数据对象的基本思想。然后，我们将继续探讨表示数据缺失（第4.3节）或可能的数据缺失（第5章）的相对抽象的概念。
- en: 'Imagine that you’re in the business of life insurance. You need to write a
    function that calculates a customer’s risk profile based on their age. The risk
    profile will be captured with an `enum`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你从事人寿保险业务。你需要编写一个函数，根据客户的年龄计算其风险配置文件。风险配置文件将通过一个`enum`来捕获：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You’re pair programming with David, a trainee who comes from a dynamically
    typed language, and he has a stab at implementing the function. He runs it in
    the REPL with a few inputs to see that it works as expected:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你和David一起结对编程，David是一名来自动态类型语言的实习生，他尝试实现这个函数。他在REPL中用几个输入运行它，以确认它按预期工作：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although the implementation does seem to work when given reasonable inputs,
    you’re surprised by David’s choice of `dynamic` as the argument type. You show
    him that his implementation allows client code to invoke the function with a `string`,
    causing a run-time error:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在给定的合理输入下，实现似乎可以工作，但你还是对David选择`dynamic`作为参数类型感到惊讶。你向他展示他的实现允许客户端代码用`string`调用该函数，导致运行时错误：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You explain to David that you can tell the compiler what type of input your
    function expects, so that invalid inputs can be ruled out. You rewrite the function,
    taking an `int` as the type of the input argument:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你向David解释说，你可以告诉编译器你的函数期望什么类型的输入，这样就可以排除无效的输入。你重写了函数，将输入参数的类型改为`int`：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Is there still room for improvement?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是否还有改进的空间？
- en: 4.2.1 Primitive types are often not specific enough
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 原始类型通常不够具体
- en: 'As you keep testing your function, you find that the implementation still allows
    for invalid inputs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续测试你的函数时，你会发现实现仍然允许无效的输入：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Clearly, these are not valid values for a customer’s age. What’s a valid age,
    anyway? You have a word with the business to clarify this, and they indicate that
    a reasonable value for an age must be positive and less than 120\. Your first
    instinct is to add some validation to your function—if the given age is outside
    of the valid range, throw an exception:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些不是客户年龄的有效值。那么，什么才是有效的年龄呢？你和业务方进行了讨论，以澄清这一点，他们指出合理的年龄值必须是正数且小于120。你的第一反应是在你的函数中添加一些验证——如果给定的年龄超出了有效范围，则抛出异常：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you type this, you’re thinking that this is rather annoying:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入这些内容时，你可能会想这相当烦人：
- en: You’ll have to write additional unit tests for the cases in which validation
    fails.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将不得不为验证失败的案例编写额外的单元测试。
- en: There are other areas of the application where an age is expected, so you’re
    probably going to need this validation there as well. This may lead to some code
    duplication.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的其他区域也需要年龄，因此您可能需要在那些地方也需要进行验证。这可能会导致一些代码重复。
- en: '*Duplication* is usually a sign that separation of concerns has been broken:
    the `CalculateRiskProfile` function, which should only concern itself with the
    calculation, now also concerns itself with validation. Is there a better way?'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*重复* 通常意味着关注点的分离已被破坏：`CalculateRiskProfile` 函数，它只应关注计算，现在也关注验证。有没有更好的方法？'
- en: 4.2.2 Constraining inputs with custom types
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 使用自定义类型约束输入
- en: In the meantime, your colleague Frida, who comes from a statically typed functional
    language, joins the session. She looks at your code so far and finds that the
    problem lies in your use of `int` to represent age. She comments, “You can tell
    the compiler what type of input your function expects so that invalid inputs can
    be ruled out.”
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，您的同事弗里达，她来自静态类型函数式语言，加入了会议。她看了看您到目前为止的代码，发现问题是您使用 `int` 来表示年龄。她评论说：“您可以让编译器知道您的函数期望什么类型的输入，这样就可以排除无效的输入。”
- en: David listens in amazement because those were the very words you patronized
    him with a few moments earlier. You’re not sure what she means exactly, so she
    starts to implement `Age` as a custom type that can only represent a valid value
    for an age as in the following listing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 戴维惊讶地听着，因为这些正是您几分钟前用来夸奖他的话。您不确定她确切的意思，于是她开始实现 `Age`，作为一个只能表示有效年龄值的自定义类型，如下所示。
- en: Listing 4.1 A custom type that can only be instantiated with a valid value
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 仅能使用有效值实例化的自定义类型
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This implementation still uses an `int` as the underlying representation for
    an age, but the constructor ensures that the `Age` type can only be instantiated
    with a valid value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现仍然使用 `int` 作为年龄的底层表示，但构造函数确保 `Age` 类型只能用有效值实例化。
- en: 'This is a good example of functional thinking: the `Age` type is created precisely
    to represent the domain of the `CalculateRiskProfile` function. This can now be
    rewritten as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个功能思维的很好例子：`Age` 类型正是为了表示 `CalculateRiskProfile` 函数的域而创建的。现在可以重写如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This new implementation has several advantages:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的实现有几个优点：
- en: You’re guaranteeing that only valid values can be given.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您确保只能提供有效的值。
- en: '`CalculateRiskProfile` no longer causes run-time errors.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculateRiskProfile` 不再导致运行时错误。'
- en: The concern of validating the age value is captured in the constructor of the
    `Age` type, removing the need for duplicating validation wherever an age is processed.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证年龄值的担忧被 `Age` 类型的构造函数所捕捉，从而消除了在处理年龄时重复验证的需要。
- en: You’re still throwing an exception in the `Age` constructor, but we’ll remedy
    that in section 5.4.3\. There’s still some room for improvement, however.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然在 `Age` 构造函数中抛出异常，但我们在第 5.4.3 节中会解决这个问题。然而，仍有改进的空间。
- en: 'In the preceding implementation, we used `Value` to extract the underlying
    value of the age, so we’re still comparing two integers. There are a couple of
    problems with that:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的实现中，我们使用了 `Value` 来提取年龄的底层值，所以我们仍然是在比较两个整数。这有几个问题：
- en: Reading the `Value` property not only creates a bit of noise, but it also means
    that the client code knows about the internal representation of `Age`, which you
    might want to change in the future.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 `Value` 属性不仅会带来一些噪音，还意味着客户端代码知道了 `Age` 的内部表示，您可能希望在将来更改它。
- en: Because you’re performing integer comparison, you’re also not protected if,
    say, someone accidentally changes the threshold value of `60` to `600`, which
    is a valid `int` but not a valid `Age`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为您正在进行整数比较，所以如果有人不小心将 `60` 的阈值值更改为 `600`（这是一个有效的 `int` 但不是有效的 `Age`），您将不会受到保护。
- en: You can address these issues by modifying the definition of `Age`, as the following
    listing shows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过修改 `Age` 的定义来解决这些问题，如下所示。
- en: Listing 4.2 Encapsulating the internal representation of the age
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 封装年龄的内部表示
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Keeps the internal representation private
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保持内部表示私有
- en: ❷ Logic for comparing an `Age` with another `Age`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 比较一个 `Age` 与另一个 `Age` 的逻辑
- en: ❸ For ease of use, makes it possible to compare an `Age` with an `int`; the
    `int` is first converted into an `Age`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为了便于使用，使得可以将一个 `Age` 与一个 `int` 进行比较；首先将 `int` 转换为 `Age`。
- en: 'Now the internal representation of an age is encapsulated, and the logic for
    comparison is within the `Age` class. You can rewrite your function as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在年龄的内部表示被封装起来，比较逻辑在 `Age` 类中。你可以将你的函数重写如下：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What happens now is that a new `Age` is constructed from the value `60` so that
    the usual validation is applied. (If this throws a run-time error, that’s fine
    because it indicates a developer error; more about this in chapter 8.) When the
    input age is then compared, this comparison happens in the `Age` class, using
    the comparison operators you’ve defined. Overall, the code is just as readable
    as before, but more robust.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发生的情况是，从值 `60` 构造一个新的 `Age`，以便应用常规验证。（如果这抛出一个运行时错误，那没关系，因为这表明开发者错误；关于这一点，请参阅第
    8 章。）当输入年龄进行比较时，这个比较是在 `Age` 类中进行的，使用你定义的比较运算符。总的来说，代码与之前一样易于阅读，但更健壮。
- en: In summary, primitive types are often used too liberally (this has become known
    as *primitive obsession*). If you need to constrain the inputs of your functions,
    it’s usually better to define a custom type. This follows the idea of making invalid
    state unrepresentable. In the preceding example, you can’t represent an age outside
    of the valid bounds.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，原始类型通常被过于自由地使用（这已经成为 *原始类型迷恋* 的代名词）。如果你需要限制你函数的输入，通常更好的做法是定义一个自定义类型。这遵循了使无效状态不可表示的想法。在前面的例子中，你不能表示超出有效范围的年龄。
- en: The new implementation of `CalculateRiskProfile` is identical to its original
    implementation, except for the input type, which is now `Age`, and this ensures
    the validity of the data and makes the function signature more explicit. A functional
    programmer might say that now the function is *honest*. What does that mean?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculateRiskProfile` 的新实现与其原始实现相同，除了输入类型现在是 `Age`，这确保了数据的有效性并使函数签名更加明确。一个函数式程序员可能会说，现在函数是
    *诚实的*。这是什么意思？'
- en: 4.2.3 Writing honest functions
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 编写诚实的函数
- en: 'You might hear functional programmers talk about *honest* or *dishonest* functions.
    An honest function is simply one that does what it says on the tin: it honors
    its signature—*always*. For instance, consider the function we ended up with in
    section 4.2.2:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会听到函数式程序员谈论 *诚实* 或 *不诚实* 的函数。一个诚实的函数简单地说就是它所说的那样：它始终遵守其签名——*总是*。例如，考虑我们在
    4.2.2 节中最终得到的函数：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Its signature is `Age` `→` `Risk`, which declares, “Give me an `Age`, and I
    will give you back a `Risk`.” Indeed, there’s no other possible outcome.[¹](#pgfId-1107839)
    This function behaves as a mathematical function, mapping each element from the
    domain to an element of the codomain, as figure 4.1 shows.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其签名是 `Age` `→` `Risk`，声明，“给我一个 `Age`，我会给你一个 `Risk`。”确实，没有其他可能的输出。[¹](#pgfId-1107839)
    这个函数的行为就像一个数学函数，将域中的每个元素映射到陪域中的一个元素，如图 4.1 所示。
- en: '![](Images/CH04_F01_Buonanno2.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F01_Buonanno2.png)'
- en: 'Figure 4.1 An honest function does exactly what the signature says: it maps
    all possible values of the input type(s) to a valid value of the output type.
    This makes the behavior of your functions predictable and your program more robust.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 一个诚实的函数正好做其签名所说的：它将输入类型（的）所有可能值映射到输出类型的有效值。这使得你函数的行为可预测，并且你的程序更健壮。
- en: 'Compare this to the previous implementation, which looked like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与之前的实现进行比较，其看起来如下：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember, a signature is a contract. The signature `int` `→` `Risk` says, “Give
    me an `int` (*any* of the 232 possible values for `int`), and I’ll return a `Risk`.”
    But the implementation doesn’t abide by its signature, throwing an `ArgumentException`
    for what it considers invalid input (see figure 4.2).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，签名是一个合同。签名 `int` `→` `Risk` 表示，“给我一个 `int`（`int` 的 232 个可能值中的任何一个），我会返回一个
    `Risk`。”但实现并没有遵守其签名，对于它认为无效的输入抛出一个 `ArgumentException`（见图 4.2）。
- en: '![](Images/CH04_F02_Buonanno2.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F02_Buonanno2.png)'
- en: Figure 4.2 A dishonest function can have an outcome that isn’t accounted for
    in the signature.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 一个不诚实的函数可能会有在签名中没有考虑到的结果。
- en: That means this function is *dishonest*—what it *really* should say is “Give
    me an `int`, and I *may* return a `Risk`, or I may throw an exception instead.”
    Sometimes there are legitimate reasons why a computation can fail, but in this
    example, constraining the function input so that the function always returns a
    valid value is a much cleaner solution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个函数是 *不诚实* 的——它 *真正* 应该说的是“给我一个 `int`，我 *可能* 返回一个 `Risk`，或者我可能抛出一个异常。”有时有合法的理由导致计算失败，但在这个例子中，限制函数输入，使函数始终返回一个有效值是一个更干净的解决方案。
- en: 'In summary, a function is honest if its behavior can be predicted by its signature:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果一个函数的行为可以通过其签名预测，那么这个函数就是诚实的：
- en: It returns a value of the declared type.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回声明类型的价值。
- en: It doesn’t throw exceptions.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会抛出异常。
- en: It never returns `null`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它永远不会返回`null`。
- en: Note that these requirements are less stringent and less formal than function
    purity. Notably, a function that performs I/O can still be honest. In this case,
    its return type should typically convey that the function may fail or take a long
    time (for example, by returning its result wrapped in an `Exceptional` or a `Task`,
    which I’ll discuss in chapters 8 and 16, respectively.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些要求比函数纯度要求宽松且正式性较低。值得注意的是，一个执行I/O操作的函数仍然可以是诚实的。在这种情况下，其返回类型通常应该传达该函数可能会失败或需要很长时间（例如，通过返回一个包裹在`Exceptional`或`Task`中的结果，我将在第8章和第16章分别讨论这些内容。）
- en: 4.2.4 Composing values into complex data objects
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 将值组合成复杂的数据对象
- en: 'You might require more data to fine-tune the implementation of your calculation
    of health risk. For instance, women statistically live longer than men, so you
    may want to account for this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要更多数据来微调你的健康风险计算实现。例如，从统计上看，女性的寿命通常比男性长，因此你可能想要考虑这一点：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The signature of the function thus defined is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该函数的签名如下：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'How many possible input values are there? Well, there are 2 possible values
    for `Gender` in this admittedly simplistic model and 120 values for `Age`, so
    in total, there are 2 × 120 = 240 possible inputs. Notice that if you define a
    tuple of `Age` and `Gender`, 240 tuples are possible. The same is true if you
    define a type to hold that same data like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少可能的输入值？在这个显然是简化的模型中，`Gender`有2个可能的值，`Age`有120个值，所以总共有2 × 120 = 240个可能的输入。注意，如果你定义一个包含`Age`和`Gender`的元组，可能存在240个元组。同样，如果你定义一个类型来存储相同的数据，情况也是如此：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Whether you call a binary function that accepts an `Age` and a `Gender`, or
    a unary function that takes a `HealthData`, 240 distinct inputs are possible.
    They’re just packaged up a bit differently.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是调用接受`Age`和`Gender`的二元函数，还是调用接受`HealthData`的单元函数，都有240种不同的输入可能。它们只是包装得略有不同。
- en: Earlier I said that types represent sets, so the `Age` type represents a set
    of 120 elements, and `Gender`, a set of 2 elements. What about more complex types
    such as `HealthData`, which is defined in terms of the former two?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我说过，类型代表集合，所以`Age`类型代表一个包含120个元素的集合，而`Gender`代表一个包含2个元素的集合。那么，更复杂的类型，如`HealthData`，它是在前两种类型的基础上定义的，又该如何呢？
- en: Essentially, creating an instance of `HealthData` is equivalent to taking all
    the possible combinations of the two sets, `Age` and `Gender` (a Cartesian product),
    and picking one element. More generally, every time you add a field to a type
    (or a tuple), you’re creating a Cartesian product and adding a dimension to the
    space of possible values of the object, as figure 4.3 illustrates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，创建一个`HealthData`实例相当于从两个集合`Age`和`Gender`的所有可能组合（笛卡尔积）中选择一个元素。更普遍地说，每次你向类型（或元组）添加一个字段，你就在创建一个笛卡尔积，并为对象可能值的范围增加一个维度，如图4.3所示。
- en: '![](Images/CH04_F03_Buonanno2.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F03_Buonanno2.png)'
- en: Figure 4.3 An object or tuple can be viewed as a Cartesian product.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 对象或元组可以被视为笛卡尔积。
- en: For this reason, in type theory, types that are defined by aggregating other
    types (whether in a tuple, a record, a struct or a class) are called *product
    types*. In contrast, you have *sum types*. For instance, if types `A` and `B`
    are the two only concrete implementations of `C`, then
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在类型理论中，通过聚合其他类型（无论是在元组、记录、结构或类中）定义的类型被称为*积类型*。相比之下，你有*和类型*。例如，如果类型`A`和`B`是`C`的两个唯一具体实现，那么
- en: '*|C| = |A| + |B|*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*|C| = |A| + |B|*'
- en: The number of possible `C`’s is the *sum* of all possible `A`’s and all possible
    `B`’s. (Sum types are also known as *union types*, *discriminated unions*, and
    a number of other names.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的`C`的数量是所有可能的`A`和所有可能的`B`的总和。（求和类型也被称为*联合类型*、*区分联合*以及许多其他名称。）
- en: 'This concludes our brief foray into data object design. The main takeaway is
    that you should model your data objects in a way that gives you fine control over
    the range of inputs that your functions will need to handle. Counting the number
    of possible instances can bring clarity. Once you have control over these simple
    types, it’s easy to aggregate them into more complex data objects. Now, let’s
    move on to the simplest type of all: the empty tuple or `Unit`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对数据对象设计的简要探索。主要的收获是，你应该以一种方式来建模你的数据对象，这样你就可以精细控制你的函数需要处理的数据范围。计算可能的实例数量可以带来清晰度。一旦你控制了这些简单类型，就很容易将它们聚合为更复杂的数据对象。现在，让我们继续探讨所有类型中最简单的一种：空元组或`Unit`。
- en: 4.3 Modeling the absence of data with Unit
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用`Unit`建模数据缺失
- en: We’ve discussed how to represent data; what about when there is no data to represent?
    Many functions are called for their side effects and return `void`. But `void`
    doesn’t play well with many functional techniques, so in this section, I’ll introduce
    `Unit`, a type that we can use to represent the absence of data without the problems
    of `void`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何表示数据；那么当没有数据可以表示时怎么办？许多函数被调用是为了它们的副作用，并返回`void`。但是`void`与许多函数式技术不兼容，所以在本节中，我将介绍`Unit`，这是一种我们可以用来表示数据缺失的类型，而不会遇到`void`的问题。
- en: 4.3.1 Why void isn’t ideal
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 为什么`void`不是理想的选择
- en: Let me start by illustrating why `void` is less than ideal. In section 2.1.2,
    we covered the all-purpose `Func` and `Action` delegate families. If they’re so
    all-purpose, why do we need two of them? Why can’t we use `Func<Void>` to represent
    a function that returns nothing just like we use `Func<string>` to represent a
    function that returns a `string`? The problem is that although the framework has
    the `System.Void` type and the `void` keyword to represent *no return value*,
    `Void` receives special treatment by the compiler and can’t therefore be used
    as a return type. (In fact, it can’t be used at all from C# code.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先说明一下为什么`void`不是理想的选择。在第2.1.2节中，我们介绍了通用的`Func`和`Action`委托家族。如果它们是通用的，为什么我们需要两个？为什么我们不能使用`Func<Void>`来表示一个不返回任何值的函数，就像我们使用`Func<string>`来表示一个返回`string`的函数一样？问题在于，尽管框架有`System.Void`类型和`void`关键字来表示没有返回值，但`Void`在编译器中受到特殊处理，因此不能用作返回类型。（实际上，它根本不能从C#代码中使用。）
- en: 'Let’s see why this can be a problem in practice. Say you need to gain some
    insight as to how long certain operations take, and to do so, you write a HOF
    that starts a stopwatch, runs the given function, and stops the stopwatch, printing
    out some diagnostic information. This is a typical example of the setup/teardown
    scenario I demonstrated in section 2.3\. Here’s the implementation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么这在实践中可能成为一个问题。假设你需要了解某些操作所需的时间，为此，你编写了一个高阶函数（HOF），它启动计时器，运行给定的函数，然后停止计时器，并打印出一些诊断信息。这是我在第2.3节中演示的设置/拆除场景的典型例子。以下是实现代码：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you wanted to read the contents of a file and log how long the operation
    takes, you could use this function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要读取文件的内容并记录操作所需的时间，你可以使用这个函数：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It would be quite natural to want to use this with a `void`-returning function.
    For example, you might want to time how long it takes to *write* to a file, so
    you’d like to write this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 很自然地，你可能会想要使用这个与返回`void`的函数一起。例如，你可能想要测量写入文件所需的时间，所以你希望编写如下代码：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The problem is that `AppendAllText` returns `void`, so it can’t be represented
    as a `Func`. To make the preceding code work, you need to add an overload of `Instrumentation.Time`
    that takes an `Action`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`AppendAllText`返回`void`，因此它不能表示为`Func`。为了使前面的代码正常工作，你需要添加一个`Instrumentation.Time`的重载，它接受一个`Action`：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is terrible! You have to duplicate the entire implementation just because
    of the incompatibility between the `Func` and `Action` delegates. (A similar dichotomy
    exists in the world of asynchronous operations between `Task` and `Task<T>`.)
    How can you avoid this?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这太糟糕了！你不得不因为`Func`和`Action`委托之间的不兼容性而复制整个实现。（在异步操作的世界中，`Task`和`Task<T>`之间也存在类似的二分法。）你该如何避免这种情况？
- en: 4.3.2 Bridging the gap between Action and Func
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 在`Action`和`Func`之间架起桥梁
- en: If you’re going to use functional programming, it’s useful to have a different
    representation for *no return value*. Instead of using `void`, which is a special
    language construct, we’ll use a special value, the empty tuple (also called `Unit`).
    The empty tuple has no members, so it can only have one possible value. Because
    it contains no information whatsoever, that’s as good as no value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用函数式编程，有一个表示*无返回值*的不同表示形式是有用的。我们不会使用特殊的语言构造`void`，而是使用一个特殊值，空元组（也称为`Unit`）。空元组没有成员，因此它只有一个可能的值。因为它不包含任何信息，所以这相当于没有值。
- en: The empty tuple is available in the `System` namespace. Uninspiringly, it’s
    called `ValueTuple`, but I’ll follow the FP convention of calling it `Unit`:[²](#pgfId-1107972)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 空元组在`System`命名空间中可用。不引人注目的是，它被称为`ValueTuple`，但我会遵循FP惯例，称它为`Unit`:[²](#pgfId-1107972)
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Technically, `void` and `Unit` differ in that
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`void`和`Unit`不同之处在于
- en: '`void` is a type that represents an empty set; as such, it’s not possible to
    create an instance of it.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`是一个表示空集合的类型；因此，无法创建其实例。'
- en: '`Unit` represents a set with a single value; as such, any instance of `Unit`
    is equivalent to any other and, therefore, carries no information.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unit`代表一个包含单个值的集合；因此，任何`Unit`的实例都与任何其他实例等效，并且因此不携带任何信息。'
- en: If you have a HOF that takes a `Func` but you want to use it with an `Action`,
    how can you go about this? In chapter 2, I introduced the idea that you can write
    *adapter* functions to modify existing functions to suit your needs. In this case,
    you want a way to easily convert an `Action` into a `Func<Unit>`. The next listing
    provides the definition of the `ToFunc` function, which does just that. It is
    included in my functional library, `LaYumba .Functional`, which I developed to
    support the teaching in this book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个接受`Func`的HOF，但你想用它与`Action`一起使用，你该如何操作？在第2章中，我介绍了你可以编写*适配器*函数来修改现有函数以适应你的需求的想法。在这种情况下，你想要一种轻松地将`Action`转换为`Func<Unit>`的方法。接下来的列表提供了`ToFunc`函数的定义，它正是这样做的。它包含在我的函数式库`LaYumba
    .Functional`中，我开发这个库是为了支持本书的教学。
- en: Listing 4.3 Converting `Action` into `Func<Unit>`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 将`Action`转换为`Func<Unit>`
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Aliases the empty tuple as `Unit`
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将空元组别名为`Unit`
- en: ❷ This file-scoped namespace includes all of the following code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此文件作用域命名空间包括以下所有代码。
- en: ❸ Adapter functions that convert an `Action` into a `Unit`-returning `Func`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将`Action`转换为返回`Unit`的`Func`的适配器函数
- en: When you call `ToFunc` with a given `Action`, you get back a `Func<Unit>`. This
    is a function that when invoked runs the `Action` and returns `Unit`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用给定的`Action`调用`ToFunc`时，你得到一个`Func<Unit>`。这是一个当被调用时运行`Action`并返回`Unit`的函数。
- en: TIP This listing includes a *file-scoped namespace*, a feature introduced in
    C# 10 to reduce indentation. The declared namespace applies to the contents of
    the file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 此列表包含一个*文件作用域命名空间*，这是C# 10中引入的一个特性，用于减少缩进。声明的命名空间适用于文件的内容。
- en: With this in place, you can expand the `Instrumentation` class with a method
    that accepts an `Action`, converts it into a `Func<Unit>`, and calls the existing
    overload that works with any `Func<T>`. The following listing shows this approach.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，你可以扩展`Instrumentation`类，添加一个接受`Action`、将其转换为`Func<Unit>`并调用与任何`Func<T>`一起工作的现有重载的方法。接下来的列表展示了这种方法。
- en: Listing 4.4 HOFs that take a `Func` or an `Action` without duplication
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 不重复的接受`Func`或`Action`的HOF
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Includes an overload that takes an `Action`
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含一个接受`Action`的重载
- en: ❷ Converts the `Action` to a `Func<Unit>` and passes it to the overload taking
    a `Func<T>`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将`Action`转换为`Func<Unit>`并将其传递给接受`Func<T>`的重载
- en: As you can see, this enables you to avoid duplicating any logic in the implementation
    of `Time`. You must still expose the overload taking an `Action`. But given the
    constraints of the language, this is the best compromise for handling both `Action`
    and `Func`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这使你能够在`Time`的实现中避免重复任何逻辑。你仍然必须公开接受`Action`的重载。但考虑到语言的限制，这是处理`Action`和`Func`的最佳折衷方案。
- en: While you may not be fully sold on `Unit` based on this example alone, you’ll
    see more examples in this book where `Unit` and `ToFunc` are needed to take advantage
    of functional techniques. In summary,
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管仅凭这个例子你可能不会完全接受`Unit`，但在这本书中你将看到更多需要`Unit`和`ToFunc`来利用函数式技术的例子。总的来说，
- en: Use `void` to indicate the absence of data, meaning that your function is only
    called for side effects and returns no information.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`void`来表示数据的缺失，这意味着你的函数仅用于副作用调用，不返回任何信息。
- en: Use `Unit` as an alternative, more flexible representation when there’s a need
    for consistency in the handling of `Func` and `Action`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要保持`Func`和`Action`处理一致性时，使用`Unit`作为替代，更灵活的表现形式。
- en: 'NOTE C# 7 introduced tuple notation, allowing you to write, say, `(1,` `"hello")`
    to represent a binary tuple, so logically you’d expect to be able to write `(1)`
    for a unary tuple, and `()` for the nullary tuple. Unfortunately, because of how
    parentheses work in C# syntax, this is not possible: only tuples with two or more
    elements can be written using parentheses. We’ll therefore stick with `Unit` in
    our C# code and `()` when using arrow notation. For example, I’ll notate a `Func<int,`
    `Unit>` as `int` `→` `()`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：C# 7 引入了元组表示法，允许你编写，例如，`(1,` `"hello")`来表示一个二元元组，所以从逻辑上讲，你可能会期望能够编写`(1)`来表示一元元组，以及`()`来表示零元元组。不幸的是，由于C#语法中括号的工作方式，这是不可能的：只有包含两个或更多元素的元组才能使用括号编写。因此，在我们的C#代码中我们将坚持使用`Unit`，而在使用箭头表示法时使用`()`。例如，我将一个`Func<int,`
    `Unit>`表示为`int` `→` `()`。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Make your function signatures as specific as possible. This makes them easier
    to consume and less error-prone.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使你的函数签名尽可能具体。这使得它们更容易消费且更不容易出错。
- en: Make your functions honest. An honest function always does what its signature
    says, and given an input of the expected type, it yields an output of the expected
    type—no `Exception`s, no `null`s.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的函数诚实。诚实的函数总是做其签名所说的，并且给定预期的输入类型，它产生预期的输出类型——没有`Exception`s，没有`null`s。
- en: Use custom types rather than ad hoc validation code to constrain the input values
    of a function.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义类型而不是临时的验证代码来约束函数的输入值。
- en: Use `Unit` as an alternative to `void` when you need a more flexible representation
    for functions that return no data.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要为不返回数据的函数提供一个更灵活的表现形式时，使用`Unit`作为`void`的替代。
- en: '* * *'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ There is, however, the possibility of hardware failure, of the program running
    out of memory, and so on, but these are not intrinsic to the function implementation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 然而，也存在硬件故障、程序耗尽内存等情况的可能性，但这些不是函数实现的内在属性。
- en: ² Until recently, functional libraries have tended to define their own `Unit`
    type as a struct with no members. The obvious downside is that these custom implementations
    aren’t compatible, so I would call for library developers to adopt the nullary
    `ValueTuple` as the standard representation for `Unit`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ² 直到最近，函数库倾向于定义自己的`Unit`类型，作为一个没有成员的结构体。明显的缺点是这些自定义实现不兼容，因此我呼吁库开发者采用零参数的`ValueTuple`作为`Unit`的标准表示形式。
