- en: 5 Managing component state with the useRef hook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 使用`useRef`钩子管理组件状态
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Calling the `useRef` hook to obtain a ref
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`useRef`钩子以获取引用
- en: Updating a ref by assigning values to its `current` property
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将值分配给其`current`属性来更新引用
- en: Updating state without triggering re-renders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无触发重新渲染的状态更新
- en: Setting the `ref` attribute in JSX to assign DOM element references to a ref
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JSX中设置`ref`属性以将DOM元素引用分配给引用
- en: Accessing DOM element properties and methods via a ref
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用访问DOM元素属性和方法
- en: While most of the values stored by your component will be directly represented
    in the user interface of your application, sometimes you’ll use a variable only
    for the mechanics of your app rather than for consumption by users. You may want
    to use `setTimeout` or `setInterval` as part of an animation, so you need to keep
    hold of the IDs they return. Or you may want to work with DOM form elements as
    uncontrolled inputs, so you need to keep hold of references to those elements.
    Either way, you may not need to display these values to the user, and so changing
    them shouldn’t automatically trigger a re-render.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你组件存储的大多数值将直接表示在应用程序的用户界面中，但有时你可能会使用一个变量仅用于应用程序的机制，而不是供用户消费。你可能需要使用`setTimeout`或`setInterval`作为动画的一部分，因此你需要保留它们返回的ID。或者你可能想以非受控输入的形式与DOM表单元素一起工作，因此你需要保留对这些元素的引用。无论如何，你可能不需要向用户显示这些值，因此更改它们不应自动触发重新渲染。
- en: 'This chapter starts with two examples that explore changing state without updating
    the UI: first a comparison of managing state with `useState` and `useRef`, then
    a longer example as we manage timers for the `BookablesList` component’s new Presentation
    Mode. The second half of the chapter has two more examples, this time exploring
    references to DOM elements: automatically setting focus in the `BookablesList`
    component and reading the date from a text box for the `WeekPicker` component.
    The mix of examples will give you a good understanding of how the `useRef` hook
    helps you manage state in your components.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从两个示例开始，探讨在不更新UI的情况下改变状态：首先是比较使用`useState`和`useRef`管理状态，然后是一个更长的示例，展示如何为`BookablesList`组件的新演示模式管理计时器。本章的后半部分有两个更多示例，这次是探索对DOM元素的引用：在`BookablesList`组件中自动设置焦点，以及从文本框中读取`WeekPicker`组件的日期。这些示例的混合将帮助你更好地理解`useRef`钩子如何帮助你管理组件中的状态。
- en: Okay, 1, 2, 3, let’s go!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，1，2，3，我们出发吧！
- en: 5.1 Updating state without causing a re-render
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 无重新渲染状态更新
- en: In this section, we use a simple `Counter` component to introduce refs as a
    way of persisting state across renders. With the `useState` hook, calling a state
    value’s updater function usually triggers a re-render. With the `useRef` hook,
    we can update our value without a corresponding change to the UI. We start by
    looking at how the `Counter` component behaves when a user clicks away on its
    buttons, incrementing the counters (but not necessarily the UI), and the code
    required to make it behave that way. Then, having seen `useRef` in action, we
    focus on the new hook’s API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用一个简单的`Counter`组件来介绍引用作为在渲染之间持久化状态的一种方式。使用`useState`钩子，调用状态值的更新器函数通常会导致重新渲染。使用`useRef`钩子，我们可以更新我们的值而不需要相应的UI变化。我们首先看看当用户点击其按钮时`Counter`组件的行为，增加计数器（但不一定是UI），以及实现这种行为的代码。然后，在看到`useRef`的实际应用后，我们关注新钩子的API。
- en: 5.1.1 Comparing useState and useRef when updating state values
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 比较更新状态值时使用`useState`和`useRef`
- en: Figure 5.1 shows four screenshots of the `Counter` component UI with two buttons,
    one labeled *count* and one labeled *ref.current*. Each button also has a counter
    appended to its button text. The buttons behave in different ways.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1显示了`Counter`组件UI的四个截图，其中有两个按钮，一个标有*count*，另一个标有*ref.current*。每个按钮旁边还有一个附加到按钮文本的计数器。按钮的行为方式不同。
- en: Clicking the Count button increments its counter, as you can see in the figure,
    which shows the original component and the result when it’s clicked three times.
    The button counter goes up from 1 to 2 to 3 to 4\. Each increase is accompanied
    by a re-render, so the `Counter` component shows the latest value.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 点击计数按钮会增加其计数，如图所示，图中显示了原始组件和点击三次的结果。按钮计数从1增加到2，再到3，然后到4。每次增加都伴随着重新渲染，因此`Counter`组件显示了最新的值。
- en: '![](../Images/5-1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/5-1.png)'
- en: Figure 5.1 Clicking the Count button increases the count by 1 each time. Because
    the event handler increments the count by calling its updater function, React
    re-renders the component after each change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1每次点击Count按钮都会将计数增加1。因为事件处理程序通过调用其更新函数来增加计数，所以React在每次更改后都会重新渲染组件。
- en: Figure 5.2 shows the result when you then click the Ref.current button three
    times. Its counter doesn’t seem to change. The component shows 1, then 1, then
    1\. In fact, the value *does* increase, from 1 to 2 to 3 to 4\. It’s just that
    changing the `ref.current` value doesn’t cause React to re-render, so the `Counter`
    component continues to show an old value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2显示了随后点击Ref.current按钮三次的结果。其计数器似乎没有变化。组件显示1，然后1，然后1。实际上，值*确实*在增加，从1增加到2，然后到3，最后到4。只是改变`ref.current`的值并不会导致React重新渲染，所以`Counter`组件继续显示旧值。
- en: '![](../Images/5-2.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-2.png)'
- en: Figure 5.2 Clicking the Ref.current button three times seems to have no effect.
    In fact, the event handler does increment `ref.current` to 2, then 3, then 4,
    but React does not re-render the component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2点击Ref.current按钮三次似乎没有效果。实际上，事件处理程序确实将`ref.current`增加到2，然后是3，然后是4，但React没有重新渲染组件。
- en: Clicking the Count button one more time increments its counter from 4 to 5\.
    React re-renders the component to show the latest value, shown in figure 5.3\.
    Doing so also updates the value shown by the Ref.current button, and it jumps
    to 4, its current value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 再次点击Count按钮将计数器从4增加到5。React重新渲染组件以显示最新的值，如图5.3所示。这样做也会更新Ref.current按钮显示的值，并跳转到4，其当前值。
- en: '![](../Images/5-3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-3.png)'
- en: Figure 5.3 Clicking the Count button one more time increases the count to 5\.
    React re-renders the component, which now shows the latest values of `count` and
    `ref.current`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3再次点击Count按钮将计数增加到5。React重新渲染组件，现在显示了`count`和`ref.current`的最新值。
- en: In previous chapters, you’ve seen how to implement a button like the Count button
    by using the `useState` hook. How do we implement the Ref.current button, where
    state is persisted across renders but updating the ref doesn’t cause a re-render?
    The following listing shows the code for the button example, including a call
    to the `useRef` hook for the first time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经看到了如何通过使用`useState`钩子来实现像Count按钮这样的按钮。我们如何实现Ref.current按钮，其中状态在渲染之间保持不变，但更新ref不会导致重新渲染？以下列表显示了按钮示例的代码，包括第一次调用`useRef`钩子。
- en: '*Live*: [https://gh6xz.csb.app/](https://gh6xz.csb.app/), *Code*: [https://codesandbox.io/s/counterstatevsref-gh6xz](https://codesandbox.io/s/counterstatevsref-gh6xz)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://gh6xz.csb.app/](https://gh6xz.csb.app/), *Code*: [https://codesandbox.io/s/counterstatevsref-gh6xz](https://codesandbox.io/s/counterstatevsref-gh6xz)'
- en: Listing 5.1 Comparing `useState` and `useRef` when updating state
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1比较更新状态时`useState`和`useRef`。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Initialize the count value with useState.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用useState初始化计数值。
- en: ❷ Initialize the ref value with useRef.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用useRef初始化ref值。
- en: ❸ Define a handler that calls setCount to increment count.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义一个处理程序，该处理程序调用setCount来增加计数。
- en: ❹ Define a handler that updates the “current” property of the ref.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义一个更新ref的“current”属性的处理器。
- en: ❺ Call the handler for the count value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用计数值的处理程序。
- en: ❻ Call the handler for the ref value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 调用ref值的处理程序。
- en: So, why do the buttons behave differently? Well, one uses the `useState` hook,
    and one uses the `useRef` hook.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么按钮的行为不同呢？嗯，一个使用`useState`钩子，另一个使用`useRef`钩子。
- en: The Count button gets React to manage its counter state value by calling `useState`.
    The button’s event handler changes the counter with the state value’s updater
    function, `setCount`. Calling the updater function changes the state and triggers
    a re-render. React persists the state across renders, each time passing it back
    to the component, where it is assigned to the `count` variable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Count按钮通过调用`useState`来让React管理其计数状态值。按钮的事件处理程序使用状态值的更新函数`setCount`来更改计数器。调用更新函数会改变状态并触发重新渲染。React在渲染之间保持状态，每次都将它传回组件，其中它被分配给`count`变量。
- en: The Ref.current button gets React to manage its counter state value by calling
    `useRef`. The hook returns an object, a *ref*, which we use to store the state
    value. Changing the value stored on the ref doesn’t trigger a re-render. React
    persists the state across renders, each time passing the same ref object back
    to the component, where it is assigned to the `ref` variable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Ref.current按钮通过调用`useRef`让React管理其计数状态值。这个钩子返回一个对象，一个*ref*，我们用它来存储状态值。改变存储在ref上的值不会触发重新渲染。React在渲染之间保持状态，每次都将相同的ref对象传递回组件，其中它被分配给`ref`变量。
- en: Both buttons in listing 5.1 include a state value in their button text, `{count}`
    and `{ref.current}`, and call a handler function when the user clicks them. But
    what’s with the `.current` business? Let’s take a closer look at how to work with
    `useRef`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1中的两个按钮都包含在按钮文本中的状态值，`{count}`和`{ref.current}`，并在用户点击它们时调用一个处理函数。但`.current`是什么意思？让我们更仔细地看看如何使用`useRef`。
- en: 5.1.2 Calling useRef
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 调用useRef
- en: 'In listing 5.1, we obtain a ref from React by calling `useRef`, passing it
    an initial value of `1`. We assign the ref to a variable, `ref`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表5.1中，我们通过调用`useRef`并传递一个初始值`1`从React获取一个ref。我们将ref分配给一个变量，`ref`：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `useRef` function returns an object with a `current` property, as shown
    in figure 5.4\. Every time React runs the component code, each call to `useRef`
    will return the same ref object for that call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef`函数返回一个具有`current`属性的对象，如图5.4所示。每次React运行组件代码时，每次对`useRef`的调用都将返回相同的ref对象。'
- en: '![](../Images/5-4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/5-4.png)'
- en: Figure 5.4 `useRef` returns an object with a current property.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 `useRef`返回一个具有current属性的对象。
- en: 'The first time React invokes the component code, it assigns the initial value
    you pass the `useRef` function to the ref object’s `current` property:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次React调用组件代码时，它将你传递给`useRef`函数的初始值分配给ref对象的`current`属性：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On subsequent renders, React assigns the same ref objects to the respective
    variables, based on the order of the `useRef` calls. You can persist state values
    by assigning them to the `current` properties of the refs:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的渲染中，React根据`useRef`调用的顺序将相同的ref对象分配给相应的变量。你可以通过将它们分配给refs的`current`属性来持久化状态值：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Assigning new values to the `current` properties of the ref objects doesn’t
    trigger a re-render. But as React always returns the same ref objects, the new
    values are available when the component runs again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将新值分配给ref对象的`current`属性不会触发重新渲染。但作为React总是返回相同的ref对象，新值在组件再次运行时是可用的。
- en: Okay, the button example was a bit simple and a bit weird—who wants broken buttons?
    The time has come for a bit more complexity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，按钮示例有点简单，也有点奇怪——谁会想要坏掉的按钮？现在是时候增加一点复杂性了。
- en: 5.2 Storing timer IDs with a ref
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 使用ref存储计时器ID
- en: In the previous section, you saw how to use the `useRef` hook to maintain state
    across renders for our function components. To update the ref returned from `useRef`,
    we set its `current` property to the value we want to store. Changing the `current`
    property in this way doesn’t cause a re-render of the component. In this section,
    we look at a slightly more complicated example, using the `useRef` hook to enlist
    React’s help managing the IDs of timers. We return to the bookings app as our
    context.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到了如何使用`useRef`钩子在渲染之间为我们的函数组件保持状态。要更新`useRef`返回的ref，我们将它的`current`属性设置为我们要存储的值。以这种方式更改`current`属性不会导致组件重新渲染。在本节中，我们来看一个稍微复杂一点的例子，使用`useRef`钩子来请求React帮助管理计时器的ID。我们回到预订应用作为我们的上下文。
- en: Say your boss wants you to create a Presentation Mode for the `BookablesList`
    component. Until you click the Stop button, the component should automatically
    select each bookable in turn on a timer, showing its details, as you can see in
    figure 5.5\. Your boss thinks this would be great for that foyer screen the company
    bought last year.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的老板想要你为`BookablesList`组件创建一个演示模式。在你点击停止按钮之前，组件应该自动依次选择每个可预订项，显示其详细信息，就像你在图5.5中看到的那样。你的老板认为这会非常适合公司去年购买的接待室屏幕。
- en: '![](../Images/5-5.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/5-5.png)'
- en: Figure 5.5 In Presentation Mode, the application will automatically advance
    to each bookable in turn, showing its details, until you click the Stop button
    (top right).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 在演示模式下，应用程序将自动依次前进到每个可预订项，显示其详细信息，直到你点击停止按钮（右上角）。
- en: Left alone in Presentation Mode, the component cycles through all of the bookables
    in a group, wrapping back to the first when it leaves the last. We’ll use a timer
    to schedule when the component should move on to the next bookable. If the user
    clicks the Stop button, Presentation Mode ends, and we cancel any running timer.
    The following listing shows the ref we use to store the timer ID, the new effect
    that sets up the timer, and the UI for the Stop button.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示模式下独立运行时，组件会遍历组中的所有可预订项，当它离开最后一个时，会回到第一个。我们将使用定时器来安排组件何时移动到下一个可预订项。如果用户点击停止按钮，演示模式结束，我们将取消任何正在运行的定时器。以下列表显示了用于存储定时器ID的ref、设置定时器的新效果以及停止按钮的UI。
- en: 'Branch: 0501-timer-ref, File: /src/components/Bookables/BookablesList.js'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0501-timer-ref，文件：/src/components/Bookables/BookablesList.js
- en: Listing 5.2 Using a ref to hold a timer ID for Presentation Mode
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 使用ref保持演示模式下的定时器ID
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Import the useRef hook.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入useRef钩子。
- en: ❷ Assign a ref to the timerRef variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将ref分配给timerRef变量。
- en: ❸ Run an effect when the component first mounts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当组件首次挂载时运行一个效果。
- en: ❹ Start an interval timer and assign its ID to the ref’s current property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 启动一个间隔定时器，并将其ID分配给ref的`current`属性。
- en: ❺ Return a function to clear the timer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回一个清除定时器的函数。
- en: ❻ Use the timer ID to clear the timer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用定时器ID清除定时器。
- en: ❼ Include a Stop button.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 包含一个停止按钮。
- en: ❽ Call the stopPresentation function from the button.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 从按钮调用stopPresentation函数。
- en: 'When we set up the timer in the new effect, the browser’s `setInterval` method
    returns an ID. We can use the ID to clear the timer if necessary (if the user
    clicks the Stop button or navigates to another page in the app). The `stopPresentation`
    function needs to access the ID so it can clear the timer. We need to store the
    ID, but there’s no need to re-render the component when we start or stop the timer,
    so we don’t want to use the `useState` hook. We use the `useRef` hook instead,
    so we need to import it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在新效果中设置定时器时，浏览器的`setInterval`方法返回一个ID。如果需要（如果用户点击停止按钮或导航到应用中的另一个页面），我们可以使用该ID来清除定时器。`stopPresentation`函数需要访问ID以便它可以清除定时器。我们需要存储ID，但当我们开始或停止定时器时，无需重新渲染组件，因此我们不想使用`useState`钩子。我们使用`useRef`钩子，因此我们需要导入它：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We call `useRef`, passing it `null` as the initial value because there’s no
    timer yet. Every time the component runs, `useRef` returns us the same ref object,
    which we assign to the `timerRef` variable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`useRef`，将其`null`作为初始值传递，因为还没有定时器。每次组件运行时，`useRef`都会返回相同的ref对象，我们将它分配给`timerRef`变量：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We use the ref to store our timer ID by assigning the ID to the ref ’s `current`
    property:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用ref来存储我们的定时器ID，通过将ID分配给ref的`current`属性：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `stopPresentation` function uses the ID stored in `timerRef.current` to
    clear the timer and end Presentation Mode. The function runs when a user clicks
    the Stop button and, thanks to the second effect returning it as a cleanup function,
    when the user navigates to another page in the app and the component unmounts:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`stopPresentation`函数使用存储在`timerRef.current`中的ID来清除定时器并结束演示模式。该函数在用户点击停止按钮时运行，并且由于第二个效果将其作为清理函数返回，当用户导航到应用中的另一个页面且组件卸载时：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This section presented another example of using a ref to store state so that
    updating the state doesn’t cause the component to re-render. There’s no need to
    re-run the component code when setting and clearing the timer ID, so using a ref
    to store its value makes sense. The next section looks at a very common use case
    for refs, keeping references to DOM elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了使用ref存储状态以避免更新状态导致组件重新渲染的另一个示例。在设置和清除定时器ID时，无需重新运行组件代码，因此使用ref来存储其值是有意义的。下一节将探讨refs的一个非常常见的用例，即保持对DOM元素的引用。
- en: 5.3 Keeping references to DOM elements
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 保持对DOM元素的引用
- en: 'If you’re an old hand at working with refs, you may have been surprised at
    the use we put them to in section 5.2, updating state without re-rendering. If
    that’s the case, you’re back in your element in this section, where we call on
    the `useRef` hook to help us store references to buttons and form fields. Such
    references to DOM elements let us interact with the elements directly, bypassing
    the usual React state-to-UI flow. In particular, we look at two common use cases:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是处理refs的老手，你可能会对我们在第5.2节中使用的它们感到惊讶，在那里我们更新状态而不重新渲染。如果是这样，你将回到本节，我们将调用`useRef`钩子来帮助我们存储对按钮和表单字段的引用。这样的DOM元素引用让我们能够直接与元素交互，绕过通常的React状态到UI的流程。特别是，我们来看两个常见的用例：
- en: Setting focus on an element in response to an event
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应事件对元素设置焦点
- en: Reading the value of an uncontrolled text box
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取未受控文本框的值
- en: We see how to get React to automatically assign DOM element references to our
    refs’ `current` properties, so we can manipulate or read from those elements directly.
    Both examples use components from the bookings app. In section 5.3.2, we add a
    text box to the `WeekPicker` component. But first, we focus on the `BookablesList`
    component, making it easier for users to move from one bookable to the next using
    the keyboard.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何让 React 自动将 DOM 元素引用分配给我们的 refs 的 `current` 属性，这样我们就可以直接操作或读取这些元素。这两个例子都使用了预订应用程序的组件。在第
    5.3.2 节中，我们在 `WeekPicker` 组件中添加了一个文本框。但首先，我们关注 `BookablesList` 组件，使用户能够通过键盘从一个可预订项切换到下一个，变得更加容易。
- en: 5.3.1 Setting focus on an element in response to an event
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 响应事件对元素设置焦点
- en: Your boss is back with a new suggestion for the bookings app. Forget Presentation
    Mode! Wouldn’t it be great if, when a user chooses a bookable, the focus automatically
    shifts to the Next button? Then the user could just press the spacebar to move
    from bookable to bookable! Figure 5.6 shows the situation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您的老板又提出了关于预订应用程序的新建议。忘记演示模式吧！当用户选择一个可预订项时，焦点自动转移到“下一步”按钮不是很好吗？然后用户只需按空格键就可以从一个可预订项切换到另一个！图
    5.6 展示了这种情况。
- en: '![](../Images/5-6.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-6.png)'
- en: Figure 5.6 When a user selects a bookable, the focus is automatically set on
    the Next button.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 当用户选择一个可预订项时，焦点会自动设置在“下一步”按钮上。
- en: 'We could add an extra piece of state, maybe `nextHasFocus`, and re-render whenever
    it changes to give the Next button focus. But the browser has a `focus` method,
    so if we just had a reference to the button element, we could call `focus` and
    the job would be done:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个额外的状态，比如 `nextHasFocus`，并在它改变时重新渲染，以给“下一步”按钮聚焦。但是浏览器有一个 `focus` 方法，所以如果我们只有一个按钮元素的引用，我们可以调用
    `focus` 并完成工作：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But, having chosen to use React, we prefer to stay within its state-to-UI flow
    as much as possible. The timing of directly reaching out to the DOM with `getElementById`
    could get tricky as React updates the DOM in response to state changes. Also,
    it’s common for the same component to be used multiple times in an app, so using
    multiple instances of what should be unique `id` attributes to identify component
    elements ends up causing problems rather than solving them. Fortunately, React
    provides a way of automatically assigning DOM element references to refs created
    with the `useRef` hook.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，既然我们选择了使用 React，我们更倾向于尽可能保持在它的状态到 UI 流程中。直接使用 `getElementById` 调用 DOM 的时机可能会变得复杂，因为
    React 会根据状态变化更新 DOM。此外，在应用程序中，同一个组件可能会被多次使用，因此使用多个实例的应该是唯一的 `id` 属性来识别组件元素，这最终会导致问题而不是解决问题。幸运的是，React
    提供了一种方法，可以自动将 DOM 元素引用分配给使用 `useRef` 钩子创建的 refs。
- en: 'Listing 5.3 shows the `BookablesList` component code with three additions to
    enable our desired Next button focus behavior. We do the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 展示了 `BookablesList` 组件代码，增加了三个功能以实现我们想要的“下一步”按钮聚焦行为。我们做了以下操作：
- en: Create a new ref, `nextButtonRef`, to hold a reference to the Next button element.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 ref，`nextButtonRef`，用于保存对“下一步”按钮元素的引用。
- en: Use the special `ref` attribute in the JSX to ask React to automatically assign
    a reference to the button element to `nextButtonRef.current`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JSX 中的特殊 `ref` 属性来请求 React 自动将一个引用分配给按钮元素到 `nextButtonRef.current`。
- en: Use our reference, `nextButtonRef.current`, to set the focus on the Next button.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的引用，`nextButtonRef.current`，来设置对“下一步”按钮的焦点。
- en: 'Branch: 0502-set-focus, File: /src/components/Bookables/BookablesList.js'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0502-set-focus，文件：/src/components/Bookables/BookablesList.js
- en: Listing 5.3 Using a ref to set focus
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 使用 ref 设置焦点
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Call useRef and assign the ref to the nextButtonRef variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 useRef 并将 ref 分配给 nextButtonRef 变量。
- en: ❷ Use the ref to focus the Next button.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 ref 来聚焦“下一步”按钮。
- en: ❸ Assign nextButtonRef to the ref attribute in JSX.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 nextButtonRef 分配给 JSX 中的 ref 属性。
- en: 'In listing 5.3, we call the `useRef` hook and assign the ref it returns to
    the `nextButtonRef` variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 5.3 中，我们调用 `useRef` 钩子并将它返回的 ref 分配给 `nextButtonRef` 变量：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We don’t assign an initial value; we’re going to get React to automatically
    assign a value to the `nextButtonRef.current` property for us. We need to focus
    the Next button, so, rather than reaching out into the DOM ourselves, we assign
    our ref to the special `ref` attribute of the button in the JSX for the user interface:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有分配一个初始值；我们将让 React 自动为我们分配 `nextButtonRef.current` 属性的值。我们需要聚焦“Next”按钮，所以，而不是我们自己深入
    DOM，我们将我们的引用分配给用户界面 JSX 中按钮的特殊 `ref` 属性：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once React has created the button element for the DOM, it assigns a reference
    to the element to the `nextButtonRef.current` property. We use that reference
    in the `changeBookable` function to focus the button by calling the element’s
    `focus` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 React 为 DOM 创建了按钮元素，它就会将对该元素的引用分配给 `nextButtonRef.current` 属性。我们在 `changeBookable`
    函数中使用这个引用，通过调用元素的 `focus` 方法来聚焦按钮：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The component calls the `changeBookable` function whenever a user directly selects
    a bookable in the list of bookables. So, directly selecting a bookable will shift
    focus to the Next button. That’s exactly what the boss wanted! Good job.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 组件在用户直接在可预订列表中选择可预订时调用 `changeBookable` 函数。因此，直接选择可预订将焦点转移到“Next”按钮上。这正是老板想要的！做得好。
- en: This example shows how you can create a ref by using the `useRef` hook and then
    ask React to assign a reference for a DOM element to that ref. I’ll admit it’s
    a little contrived, but it does show the steps involved. Do be careful when programmatically
    setting the focus of elements on the page; be sure it doesn’t confound users’
    expectations, making your app harder to use. It’s a valid technique but may require
    careful user testing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何使用 `useRef` 钩子创建一个引用，然后让 React 将 DOM 元素的引用分配给该引用。我必须承认这有点牵强，但它确实展示了涉及的步骤。当程序化设置页面上的元素焦点时，请务必小心；确保它不会混淆用户的期望，使您的应用更难使用。这是一个有效的技术，但可能需要仔细的用户测试。
- en: 5.3.2 Managing a text box via a ref
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 通过引用管理文本框
- en: Chapter 3 introduced the `WeekPicker` component as a way to navigate from week
    to week in the bookings app. The user could click the Prev and Next buttons to
    switch weeks or click the Today button to display the week containing the current
    day’s date. Chapter 3’s version of `WeekPicker` is in figure 5.7.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章介绍了 `WeekPicker` 组件，作为在预订应用中从一周导航到另一周的方式。用户可以点击“Prev”和“Next”按钮来切换周次，或者点击“Today”按钮来显示包含当前日期的周。第
    3 章的 `WeekPicker` 版本如图 5.7 所示。
- en: '![](../Images/5-7.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-7.png)'
- en: Figure 5.7 The `WeekPicker` component from chapter 3 with buttons for switching
    weeks and jumping to the week containing today’s date
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 第 3 章的 `WeekPicker` 组件，带有切换周次和跳转到包含今天日期的周的按钮
- en: But if someone working at the company wants to book a meeting room for an event
    in a couple of months, they have to click the Next button again and again until
    they reach the date they want. Entering a specific date and jumping straight to
    that week would be better. Figure 5.8 shows an improved `WeekPicker` UI with a
    text box and a Go button.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果公司里有人在几个月后要预订会议室举办活动，他们必须一次又一次地点击“Next”按钮，直到达到他们想要的日期。输入特定日期并直接跳转到该周会更好。图
    5.8 显示了一个改进的带有文本框和“Go”按钮的 `WeekPicker` UI。
- en: '![](../Images/5-8.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-8.png)'
- en: Figure 5.8 The `WeekPicker` component with a text box and a Go button, for direct
    date entry
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 带有文本框和“Go”按钮的 `WeekPicker` 组件，用于直接输入日期
- en: The reducer for the `WeekPicker` component already has a `SET_DATE` action;
    let’s put it to use. In the following listing, we add to `WeekPicker` with a text
    box and Go button for the UI, a ref for the text box, and a `goToDate` handler
    function for the Go button.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeekPicker` 组件的 reducer 已经有了 `SET_DATE` 动作；让我们来使用它。在下面的列表中，我们为具有文本框和“Go”按钮的
    UI 添加了 `WeekPicker`，文本框的引用，以及“Go”按钮的 `goToDate` 处理函数。'
- en: 'Branch: 0503-text-box, File: /src/components/Bookings/WeekPicker.js'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0503-text-box，文件：/src/components/Bookings/WeekPicker.js
- en: Listing 5.4 The `WeekPicker` with a text box and Go button
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 带有文本框和“Go”按钮的 `WeekPicker`
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Create a ref to hold the reference to the text box.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个引用来保存文本框的引用。
- en: ❷ Define a handler for the Go button.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为“Go”按钮定义一个处理程序。
- en: ❸ Dispatch the SET_DATE action.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 分发 SET_DATE 动作。
- en: ❹ Use the ref to get the text value in the text box.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用引用获取文本框中的文本值。
- en: ❺ Add a text box with a ref attribute to the UI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将具有引用属性的文本框添加到 UI 中。
- en: ❻ Add the Go button to the UI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将“Go”按钮添加到 UI 中。
- en: ❼ Assign the handler to set the date.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将处理程序分配给设置日期。
- en: 'After it renders the component and updates the DOM, React assigns a reference
    to the input element, our text box, to the `textboxRef` variable’s `current` property.
    The `goToDate` function uses that reference to grab the text from the text box
    when the user clicks the Go button:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染组件并更新 DOM 之后，React 将输入元素、我们的文本框的引用分配给 `textboxRef` 变量的 `current` 属性。`goToDate`
    函数使用这个引用在用户点击“Go”按钮时从文本框中获取文本：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, `textboxRef.current` holds a reference to the input element, the text box,
    and then `textboxRef.current.value` is the text in the text box.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`textboxRef.current` 持有一个对输入元素、文本框的引用，然后 `textboxRef.current.value` 就是文本框中的文本。
- en: Uncontrolled components
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 未受控组件
- en: The text in the `WeekPicker` text box is part of our component’s state. In this
    example, our component is not managing the text box state. Our component is not
    interested while the user types characters into the text box, although the browser
    does show the new characters as the user types. Only when the user clicks the
    Go button do we read the text state from the DOM, via our ref, and dispatch it
    to the reducer. Components that let the DOM manage their state in this way are
    called *uncontrolled components*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeekPicker` 文本框中的文本是我们组件状态的一部分。在这个例子中，我们的组件没有管理文本框的状态。当用户在文本框中输入字符时，组件并不感兴趣，尽管浏览器会在用户输入时显示新字符。只有当用户点击“Go”按钮时，我们才会通过我们的
    ref 从 DOM 中读取文本状态并将其发送到 reducer。允许 DOM 以这种方式管理其状态的组件被称为 *未受控组件*。'
- en: While the `WeekPicker` example demonstrates how to use a ref with a form field,
    the approach doesn’t really fit with the philosophy of managing state with `useState`
    and `useReducer` and then displaying that state in the UI. React recommends using
    *controlled components* that make the most of React’s help managing the state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `WeekPicker` 示例演示了如何使用 ref 与表单字段一起使用，但这种方法并不真正符合使用 `useState` 和 `useReducer`
    管理状态并在 UI 中显示状态的哲学。React 推荐使用 *受控组件*，以充分利用 React 管理状态的帮助。
- en: Controlled components
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 受控组件
- en: 'To convert the `WeekPicker` component to be fully controlled, we could take
    back the text box state from the DOM, using a call to the `useState` hook instead:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `WeekPicker` 组件转换为完全受控组件，我们可以通过调用 `useState` 钩子从 DOM 中取回文本框的状态：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We could then set the `dateText` state as the `value` property for the text
    box and use the accompanying updater function, `setDateText`, to change the state
    whenever the user types in the text box:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将 `dateText` 状态设置为文本框的 `value` 属性，并使用随附的更新函数 `setDateText` 在用户在文本框中输入时更改状态：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Use the dateText state as the value for the text box.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 dateText 状态作为文本框的值。
- en: ❷ Update the dateText state whenever the user types in the text box.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当用户在文本框中输入时，更新 dateText 状态。
- en: 'Finally, in the `goToDate` function, we would no longer need the reference
    to the text box and could simply dispatch the `dateText` value to the reducer:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `goToDate` 函数中，我们不再需要文本框的引用，可以直接将 `dateText` 值发送到 reducer：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With controlled components, the data flow is from the component to the DOM,
    in line with the standard React approach.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在受控组件中，数据流是从组件到 DOM，这与标准的 React 方法一致。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Call the `useRef` hook when you want React to manage a state value but don’t
    want changes to the value to trigger a re-render. For example, use it for storing
    IDs for `setTimeout` and `setInterval` or for references to DOM elements. You
    can pass it an initial value if required. It returns an object with a `current`
    property set to the initial value:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您希望 React 管理一个状态值但不想更改值触发重新渲染时，请调用 `useRef` 钩子。例如，用于存储 `setTimeout` 和 `setInterval`
    的 ID 或 DOM 元素的引用。如果需要，您可以传递一个初始值。它返回一个具有 `current` 属性的对象，该属性设置为初始值：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A call to `useRef` will return the same ref object each time the component
    runs. Persist values in the ref across renders by assigning them to the ref ’s
    `current` property:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次组件运行时，`useRef` 调用都会返回相同的 ref 对象。通过将它们分配给 ref 的 `current` 属性来在渲染之间持久化 ref 中的值：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'React can automatically assign DOM element references to your ref ’s `current`
    property. Assign your ref variable to an element’s `ref` attribute in JSX:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 可以自动将 DOM 元素引用分配给 ref 的 `current` 属性。将您的 ref 变量分配给 JSX 中元素的 `ref` 属性：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Create a ref.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 创建一个 ref。
- en: ❷ Specify the ref in the JSX ref attribute.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ 在 JSX 中指定 ref 属性。
- en: ❸ The current property will now reference the button element.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❸ 现在的 `current` 属性将引用按钮元素。
- en: 'Use the ref to interact with the DOM element. For example, set focus on the
    element:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ref 与 DOM 元素交互。例如，设置元素的焦点：
- en: '[PRE22]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Components that read their state from the DOM are called *uncontrolled components*.
    You can use refs to access and update the state.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 DOM 中读取状态的组件被称为 *非受控组件*。您可以使用 refs 来访问和更新状态。
- en: React recommends you use *controlled components*. Use the `useState` hook or
    the `useReducer` hook to manage the state and get React to update the DOM with
    the latest state values. Your component will be the one source of truth rather
    than splitting state between the component and the DOM.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 推荐您使用 *受控组件*。使用 `useState` 钩子或 `useReducer` 钩子来管理状态，并让 React 使用最新的状态值更新
    DOM。您的组件将成为唯一的真相来源，而不是在组件和 DOM 之间分割状态。
