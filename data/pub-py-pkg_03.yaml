- en: 3 The anatomy of a minimal Python package
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 Python 最小包的解剖结构
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The Python package build system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 包构建系统
- en: Building a package using Setuptools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Setuptools 构建 Python 包
- en: The directory structure of a Python package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 包的目录结构
- en: Building a package for multiple targets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为多个目标构建包
- en: Python package builds are the product of coordination between a few different
    tools driven by a standardized process. One of the biggest choices you have as
    a package author is which set of tools to use. It can be difficult to assess the
    nuances of each, especially if you’re new to packaging. Fortunately, tools are
    standardizing around the same core workflow, so once you learn it, you’ve got
    the agility to switch between tools with minimal effort. This chapter covers what
    each category of these tools accomplishes and how they work together to produce
    a package, as well as how package builds vary for different systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包构建是几个不同工具在标准化流程驱动下的协调产物。作为包作者，你面临的最大选择之一是使用哪套工具。评估每个工具的细微差别可能很困难，尤其是如果你是新手的话。幸运的是，工具正在围绕相同的核心工作流程进行标准化，所以一旦你学会了它，你就可以以最小的努力在工具之间切换。本章将介绍这些工具的每个类别能完成什么，以及它们如何协同工作以生成一个包，以及不同系统的包构建有何不同。
- en: Important Before reading on, visit appendix B to install the tools you’ll need
    for this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：在继续阅读之前，请访问附录 B 安装本章所需的工具。
- en: You can use the code companion ([http://mng.bz/69A5](http://mng.bz/69A5)) to
    check your work for the exercises in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用代码伴侣 ([http://mng.bz/69A5](http://mng.bz/69A5)) 来检查本章练习中的工作。
- en: 3.1 The Python build workflow
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 Python 构建工作流程
- en: The following sections cover what happens when you build a package and what
    you need to do to build a package successfully. You first need to learn about
    the pieces of the Python build system itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将介绍当你构建一个包时会发生什么，以及你需要做什么才能成功构建一个包。首先，你需要了解 Python 构建系统的各个部分。
- en: 3.1.1 Parts of the Python build system
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 Python 构建系统的各个部分
- en: 'In the root directory for your project, start by running `build` using the
    following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目的根目录中，首先运行以下命令来执行 `build`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because your package has no content yet, you should see an error like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的包还没有内容，你应该会看到一个如下所示的错误：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output makes two file suggestions. pyproject.toml is the newer standard
    file for configuring Python packaging introduced in PEP 518 ([https://www.python.org/dev/peps/pep-0518/](https://www.python.org/dev/peps/pep-0518/))
    and should be preferred unless a third-party tool you want to use is only compatible
    with setup.py. The file uses TOML ([https://toml.io/en/](https://toml.io/en/)),
    an INI-like language, to split configuration into relevant sections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提出了两个文件建议。pyproject.toml 是 PEP 518 ([https://www.python.org/dev/peps/pep-0518/](https://www.python.org/dev/peps/pep-0518/))
    中引入的用于配置 Python 打包的新标准文件，除非你想要使用的第三方工具仅与 setup.py 兼容，否则应优先考虑。该文件使用 TOML ([https://toml.io/en/](https://toml.io/en/))，一种类似于
    INI 的语言，将配置分割到相关部分。
- en: Tip If you’re following the practices in this book on one of your existing packages
    and it uses the setup.py file, you should consider migrating to the pyproject.toml
    file and the setup.cfg file covered later in this chapter if your project uses
    static metadata ([http://mng.bz/ZAdZ](http://mng.bz/ZAdZ)). Some features of Setuptools
    still require setup.py; see chapter 4.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你在现有的包上遵循本书中的实践，并且它使用 setup.py 文件，那么如果你的项目使用静态元数据，你应该考虑迁移到本章后面将介绍的 pyproject.toml
    文件和 setup.cfg 文件。Setuptools 的一些功能仍然需要 setup.py；请参阅第 4 章。
- en: 'Teaching TOML is beyond the scope of this book, but the pieces you need for
    your packaging will be included and explained where needed in this book. Create
    the pyproject.toml file using the following command to correct the error:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 教学TOML超出了本书的范围，但你需要用于打包的组件将包含在本书中，并在需要的地方进行解释。使用以下命令创建 pyproject.toml 文件以纠正错误：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the `pyproject-build` command again. This time the build should run successfully,
    and you should see a large amount of output with a few notable lines, as shown
    in listing 3.1\. What’s happening here? At a high level, the build command consumes
    your source code and the metadata you supply, along with some files it generates,
    to create the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `pyproject-build` 命令。这次构建应该会成功运行，你应该会看到大量输出和一些显著的行，如列表 3.1 所示。这里发生了什么？从高层次来看，构建命令消耗了你的源代码和提供的元数据，以及它生成的某些文件，以创建以下内容：
- en: '*A source distribution package*—A Python source distribution, or sdist, is
    a compressed archive file of the source code with a .tgz extension.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*源代码分布软件包*——一个 Python 源代码分布，或 sdist，是一个带有 .tgz 扩展名的源代码压缩存档文件。'
- en: '*A binary distribution package*—A Python built distribution package is a binary
    file. The current standard for built distributions is what’s known as a wheel
    or bdist_wheel, a file with a .whl extension.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二进制分布软件包*——一个 Python 构建分布软件包是一个二进制文件。当前构建分布的标准是众所周知的 wheel 或 bdist_wheel，一个以
    .whl 扩展名结尾的文件。'
- en: Whereas a source distribution allows almost anyone to build your code on their
    platform, a binary distribution is prebuilt for a given platform and saves users
    the work of building it themselves. The importance of these two distribution types
    will be covered in depth in chapter 4.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与源代码分布允许几乎任何人在他们的平台上构建您的代码相比，二进制分布是为特定平台预先构建的，从而节省了用户自己构建的工作。这两种分发类型的重要性将在第
    4 章中深入探讨。
- en: Listing 3.1 The result of building an empty Python package
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 构建空 Python 软件包的结果
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Setuptools and the wheel package are used for the build backend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Setuptools 和 wheel 软件包用于构建后端。
- en: ❷ The source distribution package is built by the build_sdist hook.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 源代码分布软件包是由 build_sdist 钩子构建的。
- en: ❸ The build process expects a README file in one of a few formats.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 构建过程期望在几种格式之一中包含一个 README 文件。
- en: ❹ The build process expects a name and a URL for the package.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 构建过程期望软件包的名称和 URL。
- en: ❺ The build process expects an author or maintainer of the package.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 构建过程期望软件包的作者或维护者。
- en: ❻ The package is called UNKNOWN because no name was specified.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 该软件包被命名为 UNKNOWN，因为没有指定名称。
- en: ❼ The source distribution is a compressed archive file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 源代码分布是一个压缩的存档文件。
- en: ❽ The binary wheel distribution package is built by the build_wheel hook.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 二进制轮分布软件包是由 build_wheel 钩子构建的。
- en: ❾ The binary wheel distribution is a .whl file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 二进制轮分布是一个 .whl 文件。
- en: Because you haven’t supplied any metadata yet, the build process alerts you
    to the fact that it’s missing some important information like a README file, the
    author, and so on. Adding this information is covered later in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您尚未提供任何元数据，构建过程会提醒您缺少一些重要信息，如 README 文件、作者等。在本章的后面将介绍如何添加这些信息。
- en: Notice that the build process installs the `setuptools` and `wheel` packages.
    Setuptools ([https://setuptools.readthedocs.io](https://setuptools.readthedocs.io))
    is a library that was, for a long time, one of the only ways to create Python
    packages. Now, Setuptools is one of a variety of available *build backends* for
    Python package builds.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构建过程会安装 `setuptools` 和 `wheel` 软件包。Setuptools ([https://setuptools.readthedocs.io](https://setuptools.readthedocs.io))
    是一个库，长期以来一直是创建 Python 软件包的唯一方法之一。现在，Setuptools 是 Python 软件包构建的多种可用 *构建后端* 之一。
- en: Definition A *build backend* is a Python object that provides several required
    and optional hooks that implement packaging behavior. The core build backend interface
    is defined in PEP 517 ([http://mng.bz/o5Rj](http://mng.bz/o5Rj)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *构建后端* 是一个提供几个必需和可选钩子的 Python 对象，这些钩子实现了打包行为。核心构建后端接口在 PEP 517 ([http://mng.bz/o5Rj](http://mng.bz/o5Rj))
    中定义。
- en: A build backend does the logistical work of creating package artifacts during
    the build process, namely through the `build_sdist` and `build_wheel` hooks. Setuptools
    uses the `wheel` package to build the wheel during the `build_wheel` step. The
    `build` tool uses Setuptools as a build backend by default when you don’t specify
    one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 构建后端在构建过程中执行创建软件包工件的后勤工作，即通过 `build_sdist` 和 `build_wheel` 钩子。Setuptools 在 `build_wheel`
    步骤中使用 `wheel` 软件包来构建 wheel。默认情况下，如果您没有指定，`build` 工具将使用 Setuptools 作为构建后端。
- en: The presence of build *backends* may leave you wondering if there may be build
    *frontends* as well. As it turns out, you’ve been using a build frontend already.
    The `build` tool is a build frontend!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建后端的出现可能会让您想知道是否也存在构建 *前端*。实际上，您已经使用了一个构建前端。`build` 工具就是一个构建前端！
- en: Definition A *build frontend* is a tool you run to initiate building a package
    from source code. The build frontend provides a user interface and integrates
    with the build backend via the hook interface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *构建前端* 是您运行以从源代码启动构建软件包的工具。构建前端提供用户界面并通过钩子界面与构建后端集成。
- en: To recap, you use a build frontend tool like `build` to trigger a build backend
    like Setuptools to create package artifacts from your source code and metadata
    (see figure 3.1).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾，您使用 `build` 等构建前端工具来触发构建后端（如 Setuptools），以从您的源代码和元数据创建软件包工件（见图 3.1）。
- en: '![](../../OEBPS/Images/03-01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-01.png)'
- en: Figure 3.1 The Python build system consists of a frontend user interface that
    integrates with a backend to build package artifacts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 Python 构建系统由一个前端用户界面组成，该界面与后端集成以构建包的工件。
- en: 'Because the build process creates package artifacts, you can now check the
    effect of running the build. List the contents of the root directory for your
    project now. You should see the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因为构建过程会创建包的工件，你现在可以检查运行构建的效果。现在列出你项目的根目录内容。你应该看到以下内容：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The UKNOWN.egg-info/ and build/ directories are intermediate artifacts. List
    the contents of the dist/ directory, where you should see the source and binary
    `wheel` package files, as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: UKNOWN.egg-info/ 和 build/ 目录是中间工件。列出 dist/ 目录的内容，你应该会看到源和二进制 `wheel` 包文件，如下所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Other build system tools
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其他构建系统工具
- en: As I mentioned earlier, other options exist for both build frontends and backends.
    Some packages provide both a frontend and a backend. Through the rest of this
    book, continue using `build` and Setuptools as the frontend and backend for your
    builds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，构建前端和后端都有其他选项。一些包同时提供前端和后端。在这本书的其余部分，继续使用 `build` 和 Setuptools 作为构建的前端和后端。
- en: If you want to explore some alternative build tools, check out Poetry ([https://python-poetry.org/](https://python-poetry.org/)),
    flit ([https://flit.readthedocs.io](https://flit.readthedocs.io)), and hatch ([https://hatch.pypa.io](https://hatch.pypa.io)).
    Each build system makes different trade-offs between ease of configuration, capability,
    and user interface. As an example, flit and poetry are geared toward pure-Python
    packages, whereas Setuptools can support extensions in other languages. Chapter
    4 covers this in more detail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索一些替代的构建工具，请查看 Poetry ([https://python-poetry.org/](https://python-poetry.org/))、flit
    ([https://flit.readthedocs.io](https://flit.readthedocs.io)) 和 hatch ([https://hatch.pypa.io](https://hatch.pypa.io))。每个构建系统在配置的简便性、功能和用户界面之间都有不同的权衡。例如，flit
    和 poetry 主要针对纯 Python 包，而 Setuptools 可以支持其他语言的扩展。第 4 章将更详细地介绍这一点。
- en: 'You can switch to another build system in a few steps, shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几个步骤切换到另一个构建系统，如下所示：
- en: Install the new build frontend package.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装新的构建前端包。
- en: Update pyproject.toml to specify the new build backend and its requirements.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 pyproject.toml 更新为指定新的构建后端及其需求。
- en: Move the metadata about the package to the location expected by the new build
    backend.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包的元数据移动到新构建后端期望的位置。
- en: 'Recall that `build` used Setuptools as the fallback build backend because you
    didn’t specify one. You can specify Setuptools as the build backend for your package
    by adding the lines in listing 3.2 to pyproject.toml. These lines specify the
    following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`build` 使用 Setuptools 作为后备构建后端，因为你没有指定它。你可以通过将列表 3.2 中的行添加到 pyproject.toml
    中来指定 Setuptools 作为你的包的构建后端。这些行指定以下内容：
- en: '`build-system`—This section describes the package build system.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build-system`—这一部分描述了包的构建系统。'
- en: '`requires`—These are a list of dependencies, as strings, which must be installed
    for the build system to work. A Setuptools build system needs Setuptools and wheel,
    as you saw earlier in this chapter.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`requires`—这是一个依赖项列表，以字符串形式表示，构建系统必须安装这些依赖项才能工作。Setuptools 构建系统需要 Setuptools
    和 wheel，正如你在本章前面所看到的。'
- en: '`build-backend`—This identifies the entry point to the build backend object,
    using the dotted path as a string. The Setuptools build backend object is available
    at `setuptools.build_meta`.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build-backend`—这通过字符串形式使用点分路径来标识构建后端对象的入口点。Setuptools 构建后端对象在 `setuptools.build_meta`
    中可用。'
- en: These represent the complete configuration you need to specify the build backend.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代表你需要指定的完整配置，以指定构建后端。
- en: Listing 3.2 A build system backend specification to use Setuptools
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 使用 Setuptools 的构建系统后端规范
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Opens a new TOML section
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打开一个新的 TOML 部分
- en: ❷ List of package names as strings
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将包名作为字符串的列表
- en: ❸ Dotted path to the object as a string
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将对象作为字符串的点分路径
- en: 'Once you’ve added the build system information, run the build again. Nothing
    should change in the output: you’ve just locked in Setuptools as the explicit
    backend instead of letting `build` fall back to it as a default. Now that you’ve
    got a handle on the Python package build system, you need to add some metadata
    about your package.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了构建系统信息，再次运行构建。输出中不应该有任何变化：你只是将 Setuptools 锁定为显式后端，而不是让 `build` 作为默认值回退到它。现在你已经掌握了
    Python 包构建系统，你需要添加一些关于你的包的元数据。
- en: 3.2 Authoring package metadata
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 编写包元数据
- en: You learned that each build backend may look for package metadata in different
    places and formats. For the Setuptools backend, you can specify static metadata
    in an INI-style file called setup.cfg in the root directory of your project. You’ll
    add sections of key-value pairs to this file that provide information about the
    package and its contents.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到每个构建后端可能会在不同的位置和格式中寻找包元数据。对于Setuptools后端，你可以在项目根目录中一个名为setup.cfg的INI风格文件中指定静态元数据。你将在该文件中添加键值对的部分，以提供有关包及其内容的信息。
- en: Some metadata is essential to build a package that can be identified properly.
    When you ran the build, it resulted in files with “UNKNOWN-0.0.0” in the name,
    which is the result of some missing core metadata. Start by fixing these core
    metadata issues first.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些元数据对于构建一个能够被正确识别的包是必不可少的。当你运行构建时，结果生成了文件名中包含“UNKNOWN-0.0.0”的文件，这是由于缺少一些核心元数据的结果。首先，先修复这些核心元数据问题。
- en: 3.2.1 Required core metadata
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 所需核心元数据
- en: To fix the names of your package files, start by creating the setup.cfg file
    in the root directory of your project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复你的包文件名，首先在你的项目根目录中创建setup.cfg文件。
- en: Note PEP 621 ([https://www.python.org/dev/peps/pep-0621/](https://www.python.org/dev/peps/pep-0621/))
    describes a standard for declaring static metadata in the pyproject.toml file.
    Although it’s been accepted, the standard is not yet widely adopted. In particular,
    as of the time of writing, Setuptools does not yet support it ([https://github.com/pypa/setuptools/issues/1688](https://github.com/pypa/setuptools/issues/1688)),
    though some alternatives may. This and future chapters attempt to balance the
    developer experience for packaging, testing, code quality, and so on across setup.py,
    setup.cfg, and pyproject.toml accordingly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意PEP 621 ([https://www.python.org/dev/peps/pep-0621/](https://www.python.org/dev/peps/pep-0621/))描述了在pyproject.toml文件中声明静态元数据的标准。尽管它已被接受，但该标准尚未得到广泛采用。特别是，截至撰写本文时，Setuptools尚不支持它([https://github.com/pypa/setuptools/issues/1688](https://github.com/pypa/setuptools/issues/1688))，尽管可能有其他替代方案。本书和未来的章节试图在setup.py、setup.cfg和pyproject.toml之间平衡打包、测试、代码质量等方面的开发者体验。
- en: 'Two fields are minimally required for a package: `name` and `version`. These
    distinguish a distributed version of your package from other packages and other
    versions of your own package. Add the fields to `setup.cfg` in a section called
    `metadata`. It should look like the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个包，至少需要两个字段：`name`和`version`。这些字段区分了你的包的分布式版本与其他包以及你自己的包的其他版本。将这些字段添加到名为`metadata`的部分的`setup.cfg`中。它应该看起来像以下这样：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ This is the "metadata" section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是“元数据”部分。
- en: ❷ Sections contain one or more key-value pairs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 部分包含一个或多个键值对。
- en: 'After you save the file, remove the dist/ directory and run the build process
    again. List the contents of the newly generated dist/ directory, where you should
    see the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，删除dist/目录，并再次运行构建过程。列出新生成的dist/目录的内容，你应该看到以下内容：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This confirms that you’ve supplied the name and version correctly. The build
    process recognized the values you supplied and used them to populate the filenames
    of the package artifacts. “UNKNOWN” has been replaced by a normalized version
    of “first-python-package,” and “0.0.0” has been replaced by “0.0.1” (see table
    3.1).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了你已正确提供了名称和版本。构建过程识别了你提供的值，并使用它们来填充包工件文件名。“UNKNOWN”已被“first-python-package”的规范化版本所替代，“0.0.0”已被“0.0.1”所替代（见表3.1）。
- en: Table 3.1 Filename comparison
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 文件名比较
- en: '| Before | After |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 之前 | 之后 |'
- en: '| UNKNOWN-0.0.0.tar.gz | first-python-package-0.0.1.tar.gz |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| UNKNOWN-0.0.0.tar.gz | first-python-package-0.0.1.tar.gz |'
- en: '| UNKNOWN-0.0.0-py3-none-any.whl | first-python-package-0.0.1-py3-none-any.whl
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| UNKNOWN-0.0.0-py3-none-any.whl | first-python-package-0.0.1-py3-none-any.whl
    |'
- en: 'To confirm that the package contains the intended files, you can manually inspect
    its contents. Change to the dist/ directory and unpack the source distribution
    package using the following commands:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认包包含预期的文件，你可以手动检查其内容。切换到`dist/`目录，并使用以下命令解包源代码分发包：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This creates a first-python-package-0.0.1/ directory next to the package file,
    containing the files packaged from your project along with a few generated files.
    You should see the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在包文件旁边创建一个名为first-python-package-0.0.1/的目录，其中包含从你的项目中打包的文件以及一些生成的文件。你应该看到以下内容：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ The source distribution contains several generated files.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 源代码分发包含几个生成的文件。
- en: ❷ The source distribution also contains files you created in your project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 源代码分发也包含你在项目中创建的文件。
- en: Tip You can also use the `tree` command ([https://linux.die.net/man/1/tree](https://linux.die.net/man/1/tree))
    for nicely formatted output. If you don’t have `tree` installed, you may be able
    to get it from your platform’s system package manager.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：你也可以使用`tree`命令([https://linux.die.net/man/1/tree](https://linux.die.net/man/1/tree))来获得格式良好的输出。如果你没有安装`tree`，你可能可以从你的平台系统包管理器中获取它。
- en: 'You can also confirm that the metadata you specified has been faithfully reproduced
    in the package. Open either of the PKG-INFO files and take a look at the contents.
    The PKG-INFO file contains a normalized version of the metadata. You should see
    the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以确认你指定的元数据已经忠实地复制到包中。打开任一PKG-INFO文件，查看其内容。PKG-INFO文件包含元数据的规范化版本。你应该看到以下内容：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The package name you specified maps to the Name field.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你指定的包名映射到名称字段。
- en: ❷ The package version you specified maps to the Version field.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你指定的包版本映射到版本字段。
- en: ❸ Fields you haven’t specified yet show as UNKNOWN.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 你尚未指定的字段显示为“未知”。
- en: The package name and version you specified show up here, but there are several
    other fields that are still `UNKNOWN`. The build process is still alerting you
    to a missing URL, README, and author information as well. Next, you’ll fix these
    issues and flesh out the metadata a bit further to tell people about the package.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你指定的包名和版本将显示在这里，但还有几个其他字段仍然是“未知”。构建过程仍在提醒你缺少URL、README和作者信息。接下来，你将修复这些问题，并进一步完善元数据，以便让人们了解这个包。
- en: 3.2.2 Optional core metadata
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 可选核心元数据
- en: The name and version are the only two strictly required fields, per the core
    metadata specification ([http://mng.bz/nez8](http://mng.bz/nez8)), but several
    other fields are indexed by search engines or surfaced in highly visible ways
    on sites like PyPI. If you want others to find and use your package, it’s a good
    idea to supply information for as many of the fields as possible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据核心元数据规范([http://mng.bz/nez8](http://mng.bz/nez8))，名称和版本是唯一两个严格要求的字段，但其他几个字段被搜索引擎索引或在PyPI等网站上以高度可见的方式呈现。如果你想让人们找到并使用你的包，为尽可能多的字段提供信息是个好主意。
- en: A rundown on package metadata
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 包元数据的概述
- en: 'If you want to learn all the different fields available and how they’ve evolved
    over time, the following PEPs ([https://www.python.org/dev/peps/](https://www.python.org/dev/peps/))
    deal with the package metadata specification:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解所有可用的字段以及它们随时间的变化，以下PEPs([https://www.python.org/dev/peps/](https://www.python.org/dev/peps/))处理包元数据规范：
- en: '*PEP 241: Metadata for Python Software Packages* ([https://www.python.org/dev/peps/pep-0241/](https://www.python.org/dev/peps/pep-0241/))
    introduces the PKG-INFO file.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP 241: Python软件包的元数据* ([https://www.python.org/dev/peps/pep-0241/](https://www.python.org/dev/peps/pep-0241/))
    介绍了PKG-INFO文件。'
- en: '*PEP 301: Package Index and Metadata for Distutils* ([https://www.python.org/dev/peps/pep-0301/](https://www.python.org/dev/peps/pep-0301/))
    introduces the idea of a centralized Python package index as well as classifiers
    to better distinguish Python packages.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP 301: Distutils的包索引和元数据* ([https://www.python.org/dev/peps/pep-0301/](https://www.python.org/dev/peps/pep-0301/))
    提出了集中式Python包索引以及分类器，以更好地区分Python包。'
- en: '*PEP 314: Metadata for Python Software Packages v1.1* ([https://www.python.org/dev/peps/pep-0314/](https://www.python.org/dev/peps/pep-0314/))
    augments PEP 241 with additional fields.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP 314: Python软件包的元数据v1.1* ([https://www.python.org/dev/peps/pep-0314/](https://www.python.org/dev/peps/pep-0314/))
    在PEP 241的基础上增加了额外的字段。'
- en: '*PEP 345: Metadata for Python Software Packages 1.2* ([https://www.python.org/dev/peps/pep-0345/](https://www.python.org/dev/peps/pep-0345/))
    augments PEP 314 with additional fields, changed fields, and deprecated fields.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP 345: Python软件包的元数据1.2* ([https://www.python.org/dev/peps/pep-0345/](https://www.python.org/dev/peps/pep-0345/))
    在PEP 314的基础上增加了额外的字段、更改的字段和已弃用的字段。'
- en: '*PEP 566: Metadata for Python Software Packages 2.1* ([https://www.python.org/dev/peps/pep-0566/](https://www.python.org/dev/peps/pep-0566/))
    augments PEP 345 with the core metadata specification, stricter allowable values
    for package names, additional fields, and a canonical transform of package metadata
    to JSON.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP 566: Python软件包的元数据2.1* ([https://www.python.org/dev/peps/pep-0566/](https://www.python.org/dev/peps/pep-0566/))
    在PEP 345的基础上增加了核心元数据规范、更严格的包名允许值、额外的字段以及将包元数据规范转换为JSON的规范转换。'
- en: '*PEP 621: Storing project metadata in pyproject.toml* ([https://www.python.org/dev/peps/pep-0621/](https://www.python.org/dev/peps/pep-0621/))
    defines a standard for providing package metadata in the pyproject.toml file as
    opposed to files like setup.py or setup.cfg. This has been accepted but doesn’t
    yet have wide adoption by packaging tools.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP 621: 将项目元数据存储在pyproject.toml中* ([https://www.python.org/dev/peps/pep-0621/](https://www.python.org/dev/peps/pep-0621/))
    定义了在pyproject.toml文件中提供包元数据的标准，而不是像setup.py或setup.cfg这样的文件。这已经被接受，但尚未被打包工具广泛采用。'
- en: '*PEP 639: Metadata for Python Software Packages 2.2* ([https://www.python.org/dev/peps/pep-0639/](https://www.python.org/dev/peps/pep-0639/))
    proposes an approach to standardizing how licenses are specified for packages.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP 639: Python软件包元数据2.2* ([https://www.python.org/dev/peps/pep-0639/](https://www.python.org/dev/peps/pep-0639/))
    提出了一种标准化包中指定许可证的方法。'
- en: The core metadata specification provides the most current list of available
    fields and their format.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 核心元数据规范提供了当前可用的字段及其格式的最新列表。
- en: 'The build process is still alerting you to a missing URL and author information.
    Add the following fields to the `[metadata]` section in the setup.cfg file, filling
    in your personal information where appropriate:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程仍然在提醒你缺少URL和作者信息。请将以下字段添加到setup.cfg文件中的[metadata]部分，并在适当的位置填写你的个人信息：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the build again, and you should no longer see the alerts about a missing
    URL and author. Unpack the source distribution file and view the PKG-INFO file
    again. You should see the following, with the new values you’ve added:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行构建，你应该不再会看到关于缺少URL和作者的警告。解压源分发文件，再次查看PKG-INFO文件。你应该看到以下内容，包括你添加的新值：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The url field maps to Home-page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ url字段映射到Home-page。
- en: ❷ The author and author_email fields map to Author and Author-email.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ author和author_email字段映射到Author和Author-email。
- en: 'The summary is still showing as `UNKNOWN`. The summary is a short description
    of the package’s purpose. You can think of this as an elevator pitch for your
    package: it’s what people will see most often when they’re searching for packages
    to use. If you’re reading this book, chances are that you want to learn how to
    share your code. If you skimp on the metadata, it’s likely that no one will find
    it. Metadata ensures that your package will be as discoverable as possible further
    down the line. In Setuptools, the summary is called `description`. Add the `description`
    field to your metadata now, like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要仍然显示为`UNKNOWN`。摘要是对包目的的简短描述。你可以将其视为你包的电梯演讲：这是人们在搜索要使用的包时最常看到的内容。如果你正在阅读这本书，那么你很可能会想学习如何分享你的代码。如果你在元数据上节省，那么很可能没有人会找到它。元数据确保你的包在将来尽可能容易被发现。在Setuptools中，摘要被称为`description`。现在将`description`字段添加到你的元数据中，如下所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There’s also that unlabeled `UNKNOWN` lurking at the end of the file. That
    space is for the package’s long description, which can provide more details about
    how to install and use the package or what problems it solves. Recall that the
    build process is still complaining about a missing README file. You can fix both
    these issues in one pass by creating a README file and referencing it in the metadata.
    Create a README.md file now, with content something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 文件末尾还有一个未标记的`UNKNOWN`。这个空间是用于包的长描述，它可以提供有关如何安装和使用包或它解决的问题的更多详细信息。回想一下，构建过程仍在抱怨缺少README文件。你可以通过创建一个README文件并在元数据中引用它来一次解决这两个问题。现在创建一个README.md文件，内容如下所示：
- en: '[PRE15]shell'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]shell'
- en: $ python -m pip install first-python-package
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: $ python -m pip install first-python-package
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In setup.cfg, you can now use the `long_description` field to reference your
    README file using the special `file:` directive. The `file:` directive accepts
    the path to a file, relative to setup.cfg, whose contents should be taken as the
    value for the field. In addition, you also need to specify the `long_description_content_type`
    field to indicate that your README is something other than plain text. Because
    your file is a Markdown file, you should specify the `text/markdown` content type.
    Add both of these fields to your metadata now:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在setup.cfg中，你现在可以使用`long_description`字段通过特殊的`file:`指令来引用你的README文件。`file:`指令接受相对于setup.cfg的文件路径，其内容应作为字段的值。此外，你还需要指定`long_description_content_type`字段来指示你的README不是纯文本。因为你的文件是Markdown文件，你应该指定`text/markdown`内容类型。现在将这两个字段添加到你的元数据中：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the build, extract the source distribution, and inspect PKG-INFO again.
    You should see the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建，提取源分发，并再次检查PKG-INFO。你应该看到以下内容：
- en: The `Summary` field is populated with the short description.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Summary` 字段填充了简短描述。'
- en: The file now contains a `Description-Content-Type` with a value of `text/markdown`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件现在包含一个 `Description-Content-Type`，其值为 `text/markdown`。
- en: The `UNKNOWN` at the end of the file is now replaced with the contents of your
    README.md file.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件末尾的 `UNKNOWN` 现在已被你的 README.md 文件内容替换。
- en: When you update your README file, those changes will be pulled into the next
    version of the package you build. This automation reduces the issue of remembering
    to update your documentation in multiple places. The license is the last `UNKNOWN`
    field you’ll address for now, and it requires some special attention.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新你的 README 文件时，这些更改将被拉入你构建的下一个版本的包中。这种自动化减少了在多个地方记住更新你的文档的问题。许可证是现在你要处理的最后一个
    `UNKNOWN` 字段，并且需要一些特别的注意。
- en: 3.2.3 Specifying a license
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 指定许可证
- en: In most regions, software is protected by copyright by default. If you don’t
    provide any license, you’re not giving anyone permission to use your code—even
    if you publish it as open source software (see Tal Einat, “Over 10% of Python
    Packages on PyPI Are Distributed without Any License,” *Snyk*, [http://mng.bz/vX9q](http://mng.bz/vX9q)).
    Licenses are important because they help your users understand the conditions
    under which they’re allowed to use your software. The detailed process of choosing
    a specific license is outside the scope of this book, but sites like Choose a
    License ([https://choosealicense.com](https://choosealicense.com)) guide you through
    the process by asking you what freedoms and restrictions you want to provide with
    your software.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数地区，软件默认受版权保护。如果你不提供任何许可证，你并没有给予任何人使用你的代码的权限——即使你将其作为开源软件发布（参见 Tal Einat，“Over
    10% of Python Packages on PyPI Are Distributed without Any License，” *Snyk*，[http://mng.bz/vX9q](http://mng.bz/vX9q)）。许可证很重要，因为它们帮助你的用户了解他们可以在什么条件下使用你的软件。选择特定许可证的详细过程超出了本书的范围，但像
    Choose a License ([https://choosealicense.com](https://choosealicense.com)) 这样的网站会通过询问你希望提供哪些自由和限制来引导你完成这个过程。
- en: License granularity
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证粒度
- en: Most often, you need to specify the license that pertains to your entire package
    only once at the package metadata level. If you need to give a more permissive
    or restrictive license to a specific file or files, you can include the overriding
    license directly in those files. The Python packaging process doesn’t provide
    a way to handle complex per-file license granularity within a project, but third-party
    tools may exist to help with this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你只需要在包元数据级别指定一次适用于你整个包的许可证。如果你需要向特定的文件或文件集提供更宽松或更严格的许可证，你可以在那些文件中直接包含覆盖许可证。Python
    打包过程不提供在项目内部处理复杂文件级许可证粒度的方法，但可能存在第三方工具来帮助处理这个问题。
- en: Once you choose a license, you need to declare that license alongside your code
    so that users can identify whether they can work with your software. Sites like
    GitHub automatically discover license information from a few files like LICENSE
    or LICENSE.txt. At the same time, you need to provide your license in your source
    and binary package distributions so people who install your package can view the
    license as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了一个许可证，你需要在代码旁边声明该许可证，以便用户可以识别他们是否可以使用你的软件。像 GitHub 这样的网站会自动从几个文件（如 LICENSE
    或 LICENSE.txt）中发现许可证信息。同时，你需要在你的源和二进制包分布中提供你的许可证，以便安装你的包的人也可以查看许可证。
- en: 'To properly identify your license of choice and to include the license information
    in your built package distributions, use a combination of the following three
    fields:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确识别你选择的许可证并将许可证信息包含在你的构建包分布中，使用以下三个字段的组合：
- en: '`license`—Specifies the identifier from the SPDX license list ([https://spdx.org/licenses/](https://spdx.org/licenses/))
    that corresponds to your chosen license'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license`—指定与你的选择许可证对应的 SPDX 许可证列表 ([https://spdx.org/licenses/](https://spdx.org/licenses/))
    中的标识符'
- en: '`license_files`—Specifies the path to one or more license files, relative to
    setup.cfg'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license_files`—指定一个或多个许可证文件的路径，相对于 setup.cfg'
- en: '`classifiers`—Specifies any relevant trove classifiers ([https://pypi.org/classifiers/](https://pypi.org/classifiers/))
    your package falls under for discovery purposes'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classifiers`—指定任何相关的 trove 分类器 ([https://pypi.org/classifiers/](https://pypi.org/classifiers/))，你的包在发现目的下属于哪个分类'
- en: 'As an example, if you were to choose the MIT License ([https://mit-license.org/](https://mit-license.org/)),
    you’d place a copy of the license text in a LICENSE file in the root directory
    of your project, and then add the following fields to your metadata:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你选择 MIT 许可证 ([https://mit-license.org/](https://mit-license.org/))，你应在项目的根目录中放置一份许可证文本的副本，然后在你的元数据中添加以下字段：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now you’ve learned how to specify a variety of metadata about your package for
    the Setuptools build backend, and you’ve seen how the build system normalizes
    and uses that metadata when it builds distribution packages. The flow of metadata
    between input files and output files is summarized in figure 3.2.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何为 Setuptools 构建后端指定关于你的包的各种元数据，你也看到了构建系统在构建分发包时如何标准化和使用这些元数据。输入文件和输出文件之间的元数据流总结在图
    3.2 中。
- en: '![](../../OEBPS/Images/03-02.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-02.png)'
- en: Figure 3.2 The flow of metadata between input project files and output distribution
    package files
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 输入项目文件与输出分发包文件之间的元数据流
- en: Now that you understand how the metadata flows from your project into the distribution
    package files, it’s time to learn how your source code does the same.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了元数据是如何从你的项目中流入分发包文件的，现在是时候学习你的源代码是如何做到这一点的了。
- en: 3.3 Controlling source code and file discovery
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 控制源代码和文件发现
- en: Imagine you’ve finally finished creating a package, complete with 100% unit
    test coverage. You publish it, only to start getting reports of a bug. It turns
    out that you ran your tests against the raw source code instead of the packaged
    code CarCorp actually received when they installed the package, and you packaged
    the code incorrectly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你终于完成了创建一个包，包括100%的单元测试覆盖率。你发布了它，但开始收到有关错误的报告。结果是你在运行测试时针对的是原始源代码，而不是CarCorp在安装包时实际收到的打包代码，而你打包的代码是错误的。
- en: Python doesn’t impose a specific directory structure for your code and your
    tests. This flexibility can be helpful, but it also leads naturally to multiple
    conventions. Some conventions are open to practices that lead you to create broken
    packages due to missing files or incorrect imports. Use a convention that discourages
    these practices by forcing you to test the packaged code. Running the packaging
    manually often can become tedious as a result, but tools to remove that burden
    are covered in chapter 5.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不对你的代码和测试代码指定特定的目录结构。这种灵活性可能很有帮助，但也自然会引导出多种约定。一些约定可能允许你创建因缺少文件或导入错误而损坏的包。使用一种约定，通过强制你测试打包的代码来阻止这些做法。因此，手动运行打包通常会很繁琐，但第5章将介绍一些减轻这种负担的工具。
- en: 'Keeping your tests separate from your implementation code altogether limits
    the possibility of running the tests against the raw source accidentally. (See
    Ionel Cristian Mărieș, “Packaging a Python Library,” [http://mng.bz/49Bg.](http://mng.bz/49Bg))
    In the following model, the implementation modules and the test modules are each
    nested in their own directory:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的测试代码与实现代码完全分开，可以限制意外运行原始源代码测试的可能性。（参见 Ionel Cristian Mărieș，“打包 Python 库”，[http://mng.bz/49Bg.](http://mng.bz/49Bg))
    在以下模型中，实现模块和测试模块各自嵌套在其自己的目录中：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ This is the root directory of the distribution package.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是分发包的根目录。
- en: ❷ This directory contains the implementation code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此目录包含实现代码。
- en: ❸ This is the import package.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是导入包。
- en: ❹ This directory contains the tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此目录包含测试代码。
- en: Note You’ll learn more about testing the packaged code in chapter 5.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你将在第5章中学习更多关于测试打包代码的内容。
- en: 'This approach also makes the purpose of each top-level directory clearer to
    someone who happens upon your project: the src/ directory likely contains the
    implementation, and the test/ directory likely contains code that tests the implementation.
    By separating the tests from the implementation, you’ve also decoupled the structure
    of the two areas. Although it can make sense for the tests and the implementation
    to share a similar hierarchy, you’re not bound to that.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也使偶然发现你的项目的每个人都更清楚地了解每个顶级目录的目的：src/ 目录可能包含实现代码，而 test/ 目录可能包含测试实现代码的代码。通过将测试与实现分开，你也将这两个区域的结构解耦了。尽管测试和实现共享相似层次结构可能是有意义的，但你并不受此限制。
- en: Exercise 3.1
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.1
- en: 'Create the layout for your package. You should create the following structural
    pieces:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的包创建布局。你应该创建以下结构组件：
- en: An src/ directory
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 src/ 目录
- en: A test/ directory
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 test/ 目录
- en: An import package called `imppkg` containing an empty module called `hello.py`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `imppkg` 的导入包，包含一个名为 `hello.py` 的空模块
- en: 'After you’re done, you should have the following directories and files in addition
    to the files you created earlier in this chapter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该拥有以下目录和文件，除了您在本章早期创建的文件：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the build process and unpack the distribution file. Notice anything missing?
    The `imppkg` code files aren’t there. Due to the flexibility of project layouts,
    and because you can distribute multiple import packages in a single distribution
    package, some build systems will require more specificity than you might think
    to discover your code. Setuptools needs to know the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建过程并解压缩发行版文件。注意到有什么缺失吗？`imppkg` 代码文件不在那里。由于项目布局的灵活性，并且因为您可以在单个发行版包中分发多个导入包，一些构建系统可能需要比您想象的更具体的设置来发现您的代码。Setuptools
    需要知道以下信息：
- en: In which directories to look for packages
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪些目录中查找包
- en: The names of specific (sub)packages to look for, or a directive to recursively
    find them all automatically
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查找的特定（子）包的名称，或一个递归自动查找它们的指令
- en: How to map any found package directories to different import names, if desired
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将任何找到的包目录映射到不同的导入名称（如果需要）
- en: 'For the layout you’ve created, you can accomplish this with the following additional
    sections and fields in setup.cfg:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您创建的布局，您可以通过以下额外的部分和字段在 setup.cfg 中实现这一点：
- en: '`[options]`—This section provides additional options for Setuptools package
    builds.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[options]`—此部分为 Setuptools 包构建提供额外的选项。'
- en: '`[options].package_dir`—This is a list of key-value pairs to map discovered
    directories to import paths. An empty key means the “root,” such that any directory
    mapped to the root will be removed from the import path and only its child directories
    will be included.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[options].package_dir`—这是一个键值对列表，用于将发现的目录映射到导入路径。空键表示“根”，这意味着映射到根的任何目录都将从导入路径中删除，并且只包括其子目录。'
- en: '`[options].packages`—This is either an explicit list of packages or the special
    `find:` directive that tells Setuptools to recursively search for any packages.
    `find:` is often the best choice, because you won’t need to update it if you add
    new packages later.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[options].packages`—这是一个显式的包列表或特殊的 `find:` 指令，告诉 Setuptools 递归地搜索任何包。`find:`
    通常是最好的选择，因为如果您以后添加了新包，您不需要更新它。'
- en: '`[options.packages.find]`—This section provides options to the Setuptools package
    discovery process triggered by the `find:` directive.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[options.packages.find]`—此部分为由 `find:` 指令触发的 Setuptools 包发现过程提供选项。'
- en: '`[options.packages.find].where`—This tells Setuptools which directory to look
    in for packages.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[options.packages.find].where`—这告诉 Setuptools 在哪个目录中查找包。'
- en: Add those options to your setup.cfg now. The configuration should look something
    like the next listing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将那些选项添加到您的 setup.cfg 中。配置应该看起来像下面的列表。
- en: Listing 3.3 A configuration for discovering packages with Setuptools
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 使用 Setuptools 发现包的配置
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Configures which directories should map to which imports
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置哪些目录应映射到哪些导入
- en: ❷ Maps the root to src so only its child directories will be included in import
    paths
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将根目录映射到 src，因此只有其子目录将包含在导入路径中
- en: ❸ Tells Setuptools to find packages automatically instead of listing them
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 告诉 Setuptools 自动查找包而不是列出它们
- en: '❹ Provides additional options to the find: directive'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ 为 find: 指令提供额外的选项'
- en: ❺ Tells Setuptools to find packages in the src/ directory
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 告诉 Setuptools 在 src/ 目录中查找包
- en: This configuration will cause Setuptools to search in the src/ directory, find
    the `imppkg` package there, map the src/imppkg/ directory to the `imppkg` import
    package, and include any modules within the imppkg/ directory in the distribution
    package.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将导致 Setuptools 在 src/ 目录中搜索，找到那里的 `imppkg` 包，将 src/imppkg/ 目录映射到 `imppkg`
    导入包，并将 imppkg/ 目录中的任何模块包含在发行版包中。
- en: Notably, this configuration does not include anything from the test/ directory.
    It’s common to exclude tests from distribution packages to reduce the package
    size and also because users rarely run the tests for third-party packages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，此配置不包括 test/ 目录中的任何内容。通常，从发行版包中排除测试是为了减少包的大小，同时也因为用户很少运行第三方包的测试。
- en: 'Tip You may wish to add a field in `options.packages.find` to explicitly exclude
    any test modules from the package in case any accidentally make their way outside
    the test/ directory in the future, as shown next:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：您可能希望在 `options.packages.find` 中添加一个字段，以显式排除任何测试模块，以防将来任何测试模块意外地出现在 test/
    目录之外，如下所示：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will exclude any (sub)packages that begin with `test` from the distribution
    package.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将排除以`test`开头的任何（子）包从分发包中。
- en: Run the build process and unpack the distribution again. This time, it contains
    the `imppkg` package with its `hello.py` module faithfully reproduced there. You’ve
    got a working build! Although you’ve successfully packaged your Python files,
    there’s still one configuration needed to ensure that non-Python files are included
    in your package.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建过程并再次解压分发包。这次，它包含具有其`hello.py`模块忠实复制的`imppkg`包。您已经得到了一个可工作的构建！尽管您已经成功打包了Python文件，但仍需要一项配置来确保非Python文件包含在您的包中。
- en: 3.4 Including non-Python files in a package
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 在包中包含非Python文件
- en: CarCorp has received your latest package, and the bug they’d been dealing with
    is fixed. Unfortunately, a new bug has reared its head—the JSON file containing
    input data seems to be missing!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: CarCorp已经收到了您最新的包，他们一直在处理的bug已经修复。不幸的是，一个新的bug出现了——包含输入数据的JSON文件似乎丢失了！
- en: You’ve successfully packaged up your Python code and your metadata, but you
    haven’t accounted for non-Python files yet. Create a data.json file in the same
    directory as your `hello.py` module now. Run the build process and observe that
    the data.json file is not present in the distribution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经成功打包了Python代码和元数据，但您还没有考虑到非Python文件。现在在`hello.py`模块相同的目录中创建一个data.json文件。运行构建过程并观察data.json文件不在分发中。
- en: With Setuptools, one of the most straightforward approaches to including non-Python
    files is using the MANIFEST.in file. This file contains directives that specify
    how to treat a matching set of files. The directives deal with including or excluding
    and have varying levels of granularity (figure 3.3).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Setuptools，包含非Python文件的最直接方法之一是使用MANIFEST.in文件。此文件包含指定如何处理匹配文件集的指令。指令涉及包含或排除，并且具有不同的粒度级别（图3.3）。
- en: '![](../../OEBPS/Images/03-03.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-03.png)'
- en: Figure 3.3 MANIFEST.in file directives to include non-Python files in packages
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 包含非Python文件到包中的MANIFEST.in文件指令
- en: 'One of the quickest ways to start is by including all files in the src/ directory
    and recursively excluding some files generated by Python. You can achieve this
    by creating the MANIFEST.in file in the root directory of your project with the
    following content:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最快开始的方式之一是包含src/目录中的所有文件，并递归地排除由Python生成的某些文件。您可以通过在项目的根目录中创建包含以下内容的MANIFEST.in文件来实现这一点：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Includes all files from the src/ directory . . .
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含src/目录中的所有文件 . . .
- en: ❷ . . . except __pycache__ directories or files that end in .pyc, .pyo, or .pyd
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ . . . 除了__pycache__目录或以.pyc、.pyo或.pyd结尾的文件
- en: 'Run the build process and check the source distribution for the data.json file.
    Now, check the binary wheel distribution using the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建过程并检查源分发中的data.json文件。现在，使用以下命令检查二进制轮分布：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Lists the contents of a ZIP archive without unpacking it
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列出ZIP存档的内容而不解压它
- en: 'The data.json file isn’t present. You can tell Setuptools to include any non-Python
    files contained in the source distribution into the binary distribution as well
    by adding the following field to the `[options]` section of your setup.cfg file
    as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: data.json文件不存在。您可以通过在setup.cfg文件的[options]部分添加以下字段来告诉Setuptools将源分发中包含的任何非Python文件也包含到二进制分发中：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The binary wheel distribution file is now configured such that the data.json
    file is included.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制轮分布文件现在已配置为包含data.json文件。
- en: Exercise 3.2
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.2
- en: 'Run the build process one more time and unpack both distributions. List the
    contents and confirm the presence of the data.json file. For reference, the file
    is located in the following places for each distribution:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行构建过程并解压两个分发包。列出内容并确认data.json文件的存在。为了参考，每个分发包中的文件位于以下位置：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You’ve learned how your source code, metadata, and supporting files can all
    be packaged together into single-file distributions. You’ve also learned the different
    pieces of the Python build system and how they interoperate to produce the package
    file. You’re ready for chapter 4, where you’ll get into the specifics of a project,
    installing third-party dependencies, and building for multiple target systems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何将源代码、元数据和辅助文件打包成单一文件的分发。您还学会了Python构建系统的不同部分以及它们如何交互以生成包文件。您已经准备好进入第4章，在那里您将深入了解项目细节、安装第三方依赖项以及为多个目标系统构建。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A Python package build needs a build frontend and backend, your source code,
    and your metadata.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python包构建需要一个构建前端和后端、您的源代码以及您的元数据。
- en: Build frontends and backends can be swapped for alternatives but use the same
    core workflow.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建前端和后端可以互换为替代品，但使用相同的核心工作流程。
- en: Packages rely on core required metadata to build properly, and systems rely
    on additional metadata to provide a rich discovery and browsing experience.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包需要依赖核心所需元数据来正确构建，而系统则依赖额外的元数据来提供丰富的发现和浏览体验。
- en: Structure may differ from project to project, and build backends must be configured
    accordingly to package the right code.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构可能因项目而异，构建后端必须相应配置以打包正确的代码。
- en: Build backends may need additional configuration to package non-Python files.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建后端可能需要额外的配置来打包非Python文件。
