- en: 11 Building a snack-pushing robot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 构建零食推动机器人
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Reading a list of QR codes and icons from a CSV file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 CSV 文件中读取二维码和图标列表
- en: Locating and pushing selected objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位和推动选定的对象
- en: Creating a user interface for video streaming and snack selection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于视频流和零食选择的用户界面
- en: Building a snack-pushing robot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建零食推动机器人
- en: This chapter aims to build a snack-pushing robot that can be controlled by a
    web-based Python application. The chapter starts by reading a list of snacks from
    a CSV file. Each snack will have a QR code and icon assigned. The QR code will
    be used to help the robot find the snack. The snack icon will be displayed with
    the code in the web application. Then, we take on the challenge of moving the
    robot to the selected snack and positioning it in an ideal position to push the
    snack off the ledge and into the hands of a hungry snack-eating human. The robot
    will then return to the starting position and wait for another snack request.
    In the final part of the chapter, we create a user interface and a web application
    that shows a live video stream from the robot camera and provides a list of available
    snacks. Select the snack, and watch the robot push it off the edge of the table.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在构建一个可以通过基于 Web 的 Python 应用程序控制的零食推动机器人。本章首先从 CSV 文件中读取零食列表。每个零食都将分配一个二维码和图标。二维码将用于帮助机器人找到零食。零食图标将与代码一起在
    Web 应用程序中显示。然后，我们接受挑战，将机器人移动到选定的零食并定位在理想的位置，以便将零食从边缘推下并送到饥饿的零食食用者手中。然后，机器人将返回起始位置并等待另一个零食请求。在章节的最后部分，我们创建了一个用户界面和
    Web 应用程序，该应用程序显示来自机器人摄像头的实时视频流并提供可用零食的列表。选择零食，并观看机器人将其从桌边推下。
- en: This application can be used as a launching point to create many different types
    of applications that can be controlled from a mobile device and have the robot
    seek and fetch different items from its environment. Robots that can drive around
    and use an arm to interact with their surroundings are quite versatile in their
    use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序可以用作创建许多不同类型的起点，这些类型的应用程序可以从移动设备控制，并让机器人从其环境中寻找和抓取不同的物品。能够驾驶并使用机械臂与其周围环境交互的机器人非常灵活。
- en: 11.1 Hardware stack
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 硬件堆栈
- en: Figure 11.1 shows the hardware stack, with the specific components used in this
    chapter highlighted. The robot will use the DC motors to move along the track
    in search of a specific target QR code. Images will be captured from the camera,
    and QR code detection will be applied on these images until a match is found.
    Next, the robot’s motors will stop. The robot will then use the motors to position
    the servo arm in an ideal position to push the detected snack. At this stage,
    the arm attached to the servo motor will be moved up and down to push the snack
    off the counter. For tips on how to position the snacks so that the robot can
    detect and push them with ease, refer to appendix C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 展示了硬件堆栈，本章中使用的特定组件被突出显示。机器人将使用直流电机沿着轨道移动以寻找特定的目标二维码。将从摄像头捕获图像，并在这些图像上应用二维码检测，直到找到匹配项。接下来，机器人的电机将停止。然后，机器人将使用电机将伺服臂定位在理想的位置以推动检测到的零食。在这个阶段，连接到伺服电机的臂将上下移动以将零食从柜台上推下。有关如何定位零食以便机器人能够轻松检测并推动它们的技巧，请参阅附录
    C。
- en: '![](../Images/CH11_F01_Alsabbagh.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F01_Alsabbagh.png)'
- en: 'Figure 11.1 Hardware stack: the servo motors will be used to push the snacks.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 硬件堆栈：伺服电机将被用来推动零食。
- en: 11.2 Software stack
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 软件堆栈
- en: Details of the specific software used in this chapter are shown in figure 11.2\.
    We first read the list of snacks from a CSV file using the `csv` library. Each
    snack has an emoji icon that is converted using the `emoji` library. Next, we
    create the `pusher_qr` library that will detect QR codes using OpenCV and push
    the snacks using the servo motors. We will employ the Tornado web framework to
    create the `pusher_web` application to allow users to control the robot from their
    mobile devices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的特定软件的详细信息如图 11.2 所示。我们首先使用 `csv` 库从 CSV 文件中读取零食列表。每个零食都有一个使用 `emoji` 库转换的
    emoji 图标。接下来，我们创建 `pusher_qr` 库，该库将使用 OpenCV 检测二维码并使用伺服电机推动零食。我们将使用 Tornado Web
    框架创建 `pusher_web` 应用程序，以便用户可以从他们的移动设备控制机器人。
- en: '![](../Images/CH11_F02_Alsabbagh.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F02_Alsabbagh.png)'
- en: 'Figure 11.2 Software stack: The `emoji` library will be used to convert emoji
    short codes for the icons.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 软件堆栈：将使用 `emoji` 库将图标转换为 emoji 短码。
- en: 11.3 Finding and pushing snacks
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 寻找和推动零食
- en: 'The first step will be to create a library to locate and push snacks based
    on their QR code. We need to create a Python library that meets the following
    requirements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是创建一个库，根据QR码定位和推动零食。我们需要创建一个满足以下要求的Python库：
- en: It should read the list of snacks from a CSV file and convert any emoji short
    codes found.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该从CSV文件中读取零食列表并将找到的任何表情符号简码转换为Unicode字符。
- en: The library should have a function that will swing the servo arm up and down.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库应该有一个函数可以上下移动伺服臂。
- en: The library should have a function that looks for a matching QR code and swings
    the arm when the code is found.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库应该有一个函数用于查找匹配的QR码并在找到代码时移动机械臂。
- en: This library will provide us with the core functionality for our robot. Figure
    11.3 shows a side view of the robot with the camera used to detect QR codes and
    the servo arm to push snacks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此库将为我们提供机器人的核心功能。图11.3显示了机器人的侧面视图，其中包含用于检测QR码的摄像头和用于推动零食的伺服臂。
- en: '![](../Images/CH11_F03_Alsabbagh.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F03_Alsabbagh.png)'
- en: 'Figure 11.3 Snack-pushing robot: the servo motor is used to push snacks.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 拍推机器人：伺服电机用于推动零食。
- en: Once the library is in place, we will be able to develop a web application to
    call different robot functions as needed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦库就位，我们就能开发一个网络应用程序，根据需要调用不同的机器人功能。
- en: 11.3.1 Reading the list of snacks
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 读取零食列表
- en: 'The first step is to install the emoji Python package. This module will let
    us convert emoji short codes to Unicode characters. We will use this package to
    create the icons in the application for each snack. Run the following command
    to install the package:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装emoji Python包。此模块将使我们能够将表情符号简码转换为Unicode字符。我们将使用此包为每个零食创建应用程序中的图标。运行以下命令安装包：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have everything we need installed, let’s open a read–evaluate–print
    loop (REPL) session and get to it. First, we will tackle the task of reading and
    parsing the snack list from a CSV file. We import the `DictReader` object to read
    CSV data as a list of dictionaries. We then import the function `pprint` to do
    a pretty print of our data structures:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有需要的软件，让我们打开一个读取-评估-打印循环（REPL）会话并开始工作。首先，我们将处理从CSV文件中读取和解析零食列表的任务。我们导入`DictReader`对象以将CSV数据作为字典列表读取。然后我们导入函数`pprint`以美化打印我们的数据结构：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The CSV file should be saved as `items.csv` on the Pi with the contents presented
    in listing 11.1.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件应保存为Pi上的`items.csv`，内容如列表11.1所示。
- en: 'Listing 11.1 `items.csv`: List of snack QR codes and icons'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 `items.csv`：零食QR码和图标列表
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first line of the file contains the field names. The `code` field stores
    the value for the QR code, and the `icon` field stores the value of the icon as
    an emoji short code. The first step will be to read the lines from the CSV file
    with the following line of code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一行包含字段名。`code`字段存储QR码的值，而`icon`字段存储表情符号简码的值。第一步将是使用以下代码从CSV文件中读取行：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now have a peek at what is in `lines`. It contains a list of strings.
    Each string is one line in the file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看`lines`中有什么。它包含一个字符串列表。每个字符串是文件中的一行：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We use `DictReader` to parse the lines and return a list of dictionaries:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`DictReader`解析行并返回一个字典列表：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now pretty print `items` to get a better look at what is inside:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以美化打印`items`以更好地查看其内部内容：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can grab the first item from the list and inspect the `code` and `icon`
    for that item:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从列表中获取第一个项目并检查该项目的`code`和`icon`：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s move on to converting emoji short codes. We will import the `emojize`
    function to convert the short codes and use `pathlib` to save a test HTML file
    to disk:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续将表情符号简码转换为Unicode字符。我们将导入`emojize`函数以转换简码，并使用`pathlib`将测试HTML文件保存到磁盘：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The emoji package page ([https://pypi.org/project/emoji/](https://pypi.org/project/emoji/))
    provides good documentation on using the module and links to the Unicode consortium
    pages that have a list of the official emoji short codes. Let’s convert some text
    by calling the `emojize` function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: emoji包页面([https://pypi.org/project/emoji/](https://pypi.org/project/emoji/))提供了关于使用模块的详细文档，并链接到Unicode联盟页面，其中列出了官方表情符号简码。让我们通过调用`emojize`函数来转换一些文本：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We want to see what the end result will look like in our web browser, so let’s
    add the text to some HTML and save it to a file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在网页浏览器中看到最终结果的样子，所以让我们将文本添加到一些HTML中，并保存到文件中：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, when we open the `pie.html` file in our web browser, we will be able to
    see what these emoji icons will look like. Figure 11.4 shows this HTML file as
    it would be displayed in a web browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们用我们的网络浏览器打开`pie.html`文件时，我们将能够看到这些表情符号图标将是什么样子。图11.4显示了在网页浏览器中显示的此HTML文件。
- en: '![](../Images/CH11_F04_Alsabbagh.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F04_Alsabbagh.png)'
- en: 'Figure 11.4 Emoji short codes: the emoji short code for pie was converted to
    Unicode.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 表情符号简码：派饼的表情符号简码被转换为Unicode。
- en: Now that we have read our list of snacks and figured out how to create some
    emoji icons, let’s move on to finding and pushing snacks with the robot.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经读取了我们的零食列表并了解了如何创建一些表情符号图标，那么让我们继续使用机器人寻找和推送零食。
- en: 11.3.2 Pushing snacks
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 推送零食
- en: 'We will create a library with several functions to help us locate and push
    snacks. We import the `dirname` function to get the path of our Python file and
    `csv` to parse our CSV snacks list. Then, we import `emojize` to help with the
    emoji icons and `crickit` to control the servo motors:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含几个功能的库，帮助我们定位和推送零食。我们导入`dirname`函数来获取我们的Python文件路径，以及`csv`来解析我们的CSV零食列表。然后，我们导入`emojize`来帮助处理表情符号图标，以及`crickit`来控制伺服电机：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we import `motor` to handle the forward and backward movements on our
    DC motors. The `os` module will access environment variables, and `time` will
    be used to pause between the servo arm movements. The `cv2` module will help perform
    QR code detection:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入`motor`来处理直流电机的向前和向后运动。`os`模块将访问环境变量，而`time`将用于在伺服臂运动之间暂停。`cv2`模块将帮助执行二维码检测：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The constant `ITEMS_FILE` points to our CSV file and `IMG_PATH` to our streaming
    image file. We limit the movement of the robot with `MAX_MOVES` and define the
    servo angles to move the servo arm up and down in `SERVO_ANGLES`. The `decoder`
    object will decode our QR codes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`ITEMS_FILE`指向我们的CSV文件，`IMG_PATH`指向我们的流式图像文件。我们使用`MAX_MOVES`限制机器人的移动，并在`SERVO_ANGLES`中定义伺服角度，以在伺服臂上下移动。`decoder`对象将解码我们的二维码：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `get_items` function opens our CSV file and converts all the emoji short
    codes for every line in the file. Next, we call `DictReader` to parse the CSV
    content and return a list of dictionaries:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_items`函数打开我们的CSV文件，并将文件中每一行的所有表情符号简码转换为emoji。接下来，我们调用`DictReader`来解析CSV内容，并返回一个字典列表：'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our reliable `decode_qr` function will do the job of decoding any QR codes
    we encounter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可靠的`decode_qr`函数将执行解码我们遇到的任何二维码的工作：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `goto` function moves the robot in the provided `direction` looking for
    a QR-code-matching `target`. We use `direction` to look up our movement function
    and save it in `motor_func`. Then, we loop through moving our robot in the desired
    direction and calling `decode_qr` to check whether we have encountered any QR
    codes. If we find a code-matching `target`, we return with a `True` value. Otherwise,
    if we are moving forward and reach the end of the track, we return with `False`.
    Likewise, if we have exceeded `MAX_MOVES` movement attempts, we return with `False`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`函数将机器人移动到提供的`direction`，寻找与二维码匹配的`target`。我们使用`direction`来查找我们的运动函数并将其保存到`motor_func`中。然后，我们循环移动我们的机器人到期望的方向，并调用`decode_qr`来检查我们是否遇到了任何二维码。如果我们找到一个匹配的`target`，我们返回一个`True`值。否则，如果我们向前移动并到达轨道的尽头，我们返回一个`False`。同样，如果我们超过了`MAX_MOVES`运动尝试次数，我们返回一个`False`：'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We use `swing_arm` to swing our servo arm up and knock the snacks over. We
    pause for half a second and swing the arm back down to its original position.
    The same servo motor is used to move the arm to the up and down positions. Figure
    11.5 shows the arm in the down position, which is used when driving along the
    track. Figure 11.6 shows the arm in the up position, which is used to knock over
    the snacks:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`swing_arm`来挥动我们的伺服臂向上并撞倒零食。我们暂停半秒钟，然后将臂挥回到原始位置。相同的伺服电机用于将臂移动到上下位置。图11.5显示了臂在向下位置，这是在沿着轨道行驶时使用的。图11.6显示了臂在向上位置，这是用来撞倒零食的：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/CH11_F05_Alsabbagh.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F05_Alsabbagh.png)'
- en: 'Figure 11.5 Arm down: the arm is kept in the down position when the robot is
    moving on the track.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 臂向下：当机器人在轨道上移动时，臂保持在向下位置。
- en: 'The `push_item` function is used to drive the robot forward in search of a
    QR-code-matching `code`. If found, we move the robot backward to position the
    servo arm in the center of our snack, and then we swing the arm by calling `swing_arm`.
    Finally, we call `goto` to drive the robot back to the starting position:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`push_item`函数用于驱动机器人向前移动以寻找匹配的二维码`code`。如果找到，我们将机器人向后移动，将伺服臂放置在我们的零食中心，然后通过调用`swing_arm`来摆动臂。最后，我们调用`goto`来驱动机器人返回起始位置：'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/CH11_F06_Alsabbagh.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F06_Alsabbagh.png)'
- en: 'Figure 11.6 Arm up: the arm is placed in the up position to knock over snacks.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 臂抬起：将臂放置在抬起位置以倾倒零食。
- en: The full script can be saved as `pusher_qr.py` on the Pi and then executed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`pusher_qr.py`在Pi上，然后执行。
- en: 'Listing 11.2 `pusher_qr.py`: Library to detect and push matching snacks'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 `pusher_qr.py`：用于检测和推送匹配零食的库
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can take this library for a test drive now. Just like we have done in the
    previous chapter, make sure to have `stream_save.py` running in another terminal.
    Place the robot at the starting position of the track pointing at the starting
    QR code. We can try out the library in a REPL session. First, we import the `pusher_qr`
    library:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以对这个库进行测试。就像我们在上一章中所做的那样，确保在另一个终端中运行`stream_save.py`。将机器人放置在轨道的起始位置，指向起始二维码。我们可以在REPL会话中尝试这个库。首先，我们导入`pusher_qr`库：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We call the `decode_qr` function, and it returns the code for our starting
    position as `start`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`decode_qr`函数，它返回我们起始位置的代码作为`start`：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now ask the robot to go to the end of the track with the following function
    call:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过以下函数调用让机器人前往轨道的末端：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function returned `True`, which means it successfully reached the end position.
    We can call `decode_qr` to confirm this. The function returns the `end` value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回了`True`，这意味着它成功到达了目标位置。我们可以调用`decode_qr`来确认这一点。函数返回的`end`值：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we return to the start position:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们返回到起始位置：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let us push the snack with code `candy` by calling the `push_item` function.
    The robot will move to the snack with QR code `candy`, push it with the servo
    arm, and then return to the starting position:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过调用`push_item`函数将带有代码`candy`的零食推出去。机器人将移动到带有二维码`candy`的零食处，用伺服臂将其推出去，然后返回到起始位置：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Like before, we can confirm the robot is at the starting position by calling
    `decode_qr`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们可以通过调用`decode_qr`来确认机器人是否在起始位置：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This session was a good way to take the library and the robot for a test drive
    before putting our web application in place as a front end to control the robot.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这次会议是我们在将我们的Web应用程序作为机器人控制前端之前，对库和机器人进行测试的好方法。
- en: 'Robots in the real world: Pick-and-place robots'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的机器人：拣选和放置机器人
- en: One very popular category of robots is pick-and-place robots. They are often
    used in manufacturing settings where produced items need to be packed so that
    they can be shipped. The robot in this chapter has the ability to locate specific
    items and push them off a counter. Imagine pushing the items onto a conveyor belt
    so that they can be taken to another part of a factory for further processing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人中一个非常受欢迎的类别是拣选和放置机器人。它们通常用于制造环境中，需要将生产出的物品打包以便运输。本章中的机器人具有定位特定物品并将它们从计数器上推下来的能力。想象一下将物品推到传送带上，以便运送到工厂的另一个部分进行进一步处理。
- en: Some of the benefits of rolling out pick-and-place robots are the increased
    speed and reliability compared to manual picking and placing. They come in many
    shapes and sizes, depending on the types of items they need to pick up and their
    characteristics. The 6 River Systems site ([https://6river.com/what-is-a-pick-and-place-robot](https://6river.com/what-is-a-pick-and-place-robot))
    covers the topic of pick-and-place robots very well and is a good place to learn
    more about different types of robots that are commonly used and their applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 推出拣选和放置机器人的好处是，与人工拣选和放置相比，速度和可靠性都有所提高。它们的形状和大小各不相同，这取决于它们需要拣选的物品类型及其特性。6 River
    Systems网站([https://6river.com/what-is-a-pick-and-place-robot](https://6river.com/what-is-a-pick-and-place-robot))对拣选和放置机器人进行了很好的介绍，是了解不同类型机器人和它们应用的好地方。
- en: 11.4 Creating the snack-pushing application
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 创建零食推送应用程序
- en: 'We can now dive into creating our web application to control our snack-pushing
    robot. We need to create a Python application that meets the following requirements:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以深入创建我们的Web应用程序来控制我们的零食推送机器人。我们需要创建一个满足以下要求的Python应用程序：
- en: It should show a list of snacks as buttons for selection to be made.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应显示一个零食按钮列表供选择。
- en: Once a snack is selected, the robot should drive to the snack and push it. Then
    it should return to the starting position.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦选择了零食，机器人应驶向零食并将其推动。然后它应返回起始位置。
- en: A live video stream of the robot camera should be included in the application.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在应用程序中包含机器人摄像头的实时视频流。
- en: There are a number of challenges ahead of us, so let’s break up the problem
    a bit. First, we will tackle listing and selecting items. Then, we will focus
    on how to use stylesheets to better control the layout and design of our user
    interface. Finally, we will add the live video stream to the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面前有许多挑战，所以让我们将问题分解一下。首先，我们将处理列出和选择项目。然后，我们将专注于如何使用样式表更好地控制用户界面的布局和设计。最后，我们将添加实时视频流到应用程序中。
- en: 11.4.1 Selecting snacks with the application
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 使用应用程序选择零食
- en: We will first focus on reading the list of snacks and presenting them as a series
    of buttons. Clicking on one of these snack buttons will then have our robot drive
    to the snack and do its magic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将专注于阅读零食列表，并将它们呈现为一系列按钮。点击这些零食按钮之一后，我们的机器人将驶向零食并施展其魔法。
- en: 'As we have done before, we import a number of functions and objects from the
    Tornado web framework to help us create our web application. These are all the
    same functions and objects we have used in previous chapters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们从Tornado网络框架导入了许多函数和对象来帮助我们创建网络应用程序。这些都是我们在前几章中使用过的相同函数和对象：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then import from the `os` module to obtain directory names and environment
    variables. We import `get_items` and `push_item` to list the available and push
    selected items:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着从`os`模块导入以获取目录名称和环境变量。我们导入`get_items`和`push_item`以列出可用的并推送选定的项目：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We save the settings for our application in `SETTINGS`. We use `static_path`
    so that we can serve static content like stylesheets:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用程序的设置保存在`SETTINGS`中。我们使用`static_path`以便我们可以提供静态内容，如样式表：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `MainHandler` object will handle incoming requests. For `GET` requests,
    we save the list of snacks and pass it in `items` to the template to render. When
    the index page is accessed, `name` will be blank, so we set it to the value `index`.
    Otherwise, the name of the page being accessed is directly mapped to the template
    name. When the snack selection form is submitted, the `post` method will handle
    the request by calling `push_item` to push the item and then calling `redirect`
    to take the browsers to the page listing all the items:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainHandler`对象将处理传入的请求。对于`GET`请求，我们将保存零食列表并将其传递给模板以进行渲染。当访问索引页面时，`name`将为空，因此我们将其设置为值`index`。否则，正在访问的页面的名称将直接映射到模板名称。当零食选择表单提交时，`post`方法将通过调用`push_item`来推送项目，然后调用`redirect`将浏览器带到列出所有项目的页面：'
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The final step is like the one we have already seen. We enable pretty logging
    and then create our application objection and have it listen on `port 8888` for
    incoming requests:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步与我们已经看到的类似。我们启用漂亮的日志记录，然后创建我们的应用程序对象并使其监听`端口8888`上的传入请求：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The full script can be saved as `pusher_web.py` on the Pi and then executed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`pusher_web.py`在Pi上，然后执行。
- en: 'Listing 11.3 `pusher_web.py`: Handling requests for the snack-pusher application'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3 `pusher_web.py`：处理零食推送应用程序的请求
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Before running this script, we will need to at least create one HTML template
    to be served to the web browser. Ultimately, the application will have a template
    to display the index page and one to display the list of snacks. We will tackle
    the list of snacks template first. Let’s have a look at the contents of this HTML
    template.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此脚本之前，我们至少需要创建一个HTML模板以供网页浏览器使用。最终，应用程序将有一个用于显示索引页面的模板和一个用于显示零食列表的模板。我们将首先处理零食列表模板。让我们看看这个HTML模板的内容。
- en: 'We start with the header portion of the HTML document. Here, we set the title
    of the page and use the `meta` tag to ensure the page renders well on mobile devices.
    Like before, we set a blank icon for the page. We then point to a stylesheet called
    `style.css` that will be part of our static content. We use the Tornado `static_url`
    function to generate the URL for this static content:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从HTML文档的标题部分开始。在这里，我们设置页面的标题并使用`meta`标签确保页面在移动设备上良好渲染。像之前一样，我们为页面设置一个空白图标。然后我们指向一个名为`style.css`的样式表，它将成为我们的静态内容的一部分。我们使用Tornado的`static_url`函数生成此静态内容的URL：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We now move on to the body of the document, which contains a form to be submitted
    using the POST method. We loop through each snack in the `items` variable. For
    each snack, we output a button with action defined by `code`. The text of the
    button will show both the value of `icon` and `code`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续到文档的主体部分，其中包含一个使用POST方法提交的表单。我们遍历`items`变量中的每个小吃。对于每个小吃，我们输出一个由`code`定义操作的按钮。按钮的文本将显示`icon`和`code`的值：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The full template can be saved as `items.html` in the templates folder of the
    application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完整模板可以保存为`items.html`，位于应用的模板文件夹中。
- en: 'Listing 11.4 `items.html`: HTML template showing the list of available items'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 `items.html`：显示可用项目列表的HTML模板
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we have enough of our application in place to run it and start testing
    parts of its functionality. Like before, make sure to have `stream_save.py` running
    in another terminal. Now go ahead and run our new `pusher_web.py` application.
    We can access the web application using a web browser on any computer or mobile
    device on the same network as the robot. Access the web application by visiting
    the address http://robopi
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用已经足够完善，可以运行并开始测试其功能的一部分。像之前一样，确保在另一个终端中运行`stream_save.py`。现在，继续运行我们新的`pusher_web.py`应用。我们可以使用同一网络上的任何计算机或移动设备上的网络浏览器访问Web应用。通过访问地址http://robopi
- en: :8888/items or by replacing `robopi` in the URL with the IP address of your
    robot. Figure
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: :8888/items或通过将URL中的`robopi`替换为机器人的IP地址。图
- en: 11.7 shows what this part of the application looks like. It has a list of our
    four defined snacks in our CSV file. Each snack has its icon and name shown. Press
    one of these buttons, and the robot will drive along, find the selected snack,
    and push it off of the counter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 11.7展示了应用这一部分的外观。它显示了我们在CSV文件中定义的四个小吃的列表。每个小吃都有其图标和名称显示。按下这些按钮之一，机器人将行驶，找到所选的小吃，并将其从柜台上推下。
- en: '![](../Images/CH11_F07_Alsabbagh.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F07_Alsabbagh.png)'
- en: 'Figure 11.7 Item listing: the list of snacks is shown in the application.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 项目列表：应用中显示的小吃列表。
- en: We have a good level of functionality in place. Now, let’s add some style to
    this app using stylesheets.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了良好的功能水平。现在，让我们通过样式表给这个应用添加一些样式。
- en: 11.4.2 Styling the web application
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 样式化Web应用
- en: We will create one stylesheet to style both our pages. We have some style elements
    common to both pages, so it makes sense to keep all the styles in one stylesheet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个样式表来样式化我们的两个页面。我们有一些样式元素在两个页面上都是通用的，所以将所有样式保存在一个样式表中是有意义的。
- en: We first style the content in the main body, links, and buttons. We set the
    font to use, center the text, and remove the link underlining by setting `text-decoration`
    to `none:`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对主体内容、链接和按钮进行样式化。我们设置要使用的字体，使文本居中，并通过将`text-decoration`设置为`none`来移除链接下划线：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will double the font size on the buttons and add a healthy amount of margin
    and padding to make them bigger and easier to press on mobile devices. We set
    them all to the same width of 140 px so that they can have a uniform size:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按钮的字体大小加倍，并添加适量的边距和填充，使它们更大，更容易在移动设备上按下。我们将它们都设置为140像素的相同宽度，以便它们具有统一的大小：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the next section, we will add a template for the index page. That page has
    an `iframe` that we would like to style. We make the `iframe` take up the full
    screen width and have a height of 300 px. We also remove the border so that it
    fits the look of the page more naturally:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加索引页的模板。该页面有一个我们想要样式化的`iframe`。我们使`iframe`占据整个屏幕宽度，并具有300像素的高度。我们还移除了边框，使其更自然地适应页面外观：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The stylesheet can be saved as `style.css` in the static content folder of the
    application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表可以保存为`style.css`，位于应用的静态内容文件夹中。
- en: 'Listing 11.5 `style.css`: Applying a stylesheet to the HTML templates'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 `style.css`：将样式表应用于HTML模板
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we can start our `pusher_web.py` application again to have a peek at our
    application. Visit the same URL to see how the page has changed. Figure 11.8 shows
    the new look for the page once the styles are applied. The buttons will appear
    much larger now and will be much easier to press on mobile devices with smaller
    screens.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次启动`pusher_web.py`应用，看看我们的应用。访问相同的URL，查看页面如何变化。图11.8显示了应用样式后页面的新外观。按钮现在将显得更大，并且在小屏幕的移动设备上按下将更容易。
- en: '![](../Images/CH11_F08_Alsabbagh.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F08_Alsabbagh.png)'
- en: 'Figure 11.8 Styled buttons: the buttons have been styled with a bigger font
    and more padding.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 样式化按钮：按钮已使用更大的字体和更多的填充进行样式化。
- en: With the stylesheets out of the way, we can tackle the final part of the application.
    The index page will combine the snack list with the live video stream.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完样式表之后，我们可以着手处理应用程序的最后部分。索引页面将结合零食列表和实时视频流。
- en: 11.4.3 Adding the live video stream to the application
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 将实时视频流添加到应用程序中
- en: Adding the live video stream to web applications is relatively simple. We just
    put the URL of the video streaming service into an `img` tag. The problem is that
    each time we select a snack by pressing a button, the web browser will submit
    the whole page. This will refresh the whole page and make us miss the most exciting
    part of the video stream, which is the robot rolling down its track in search
    of our snack. We can address this problem by putting our list of snacks in their
    own `iframe`. In that way, our video stream playback will never be interrupted,
    no matter how many snacks we select. We can now have a look at the template for
    the main index page.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将实时视频流添加到网络应用程序相对简单。我们只需将视频流服务的 URL 放入一个 `img` 标签中。问题是，每次我们通过按按钮选择零食时，网络浏览器都会提交整个页面。这将刷新整个页面，使我们错过视频流中最激动人心的部分，即机器人沿着轨道寻找我们的零食。我们可以通过将我们的零食列表放在自己的
    `iframe` 中来解决这个问题。这样，无论我们选择多少零食，视频流播放都不会被打断。现在我们可以看看主索引页面的模板。
- en: 'We have our usual tags in the header to set the language and title of the page.
    All the tags and values in the header are identical to what we have used in `items.html`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在标题中使用了我们常用的标签来设置页面的语言和标题。标题中的所有标签和值都与我们在 `items.html` 中使用的相同：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the body, we put a header with the page title at the top of the page. Then,
    we place our live video stream right after the header. We make sure to use the
    `host_name` value in the request so that the application works correctly regardless
    of whether you accessed it by the name of the host or IP address. Next, we load
    our page with the list of snacks in an `iframe`, right beneath the live video
    stream:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在主体中，我们在页面顶部放置了一个带有页面标题的标题。然后，我们在标题之后放置我们的实时视频流。我们确保使用请求中的 `host_name` 值，以便无论您是通过主机名还是
    IP 地址访问它，应用程序都能正确工作。接下来，我们在实时视频流下方加载包含零食列表的页面：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The full template can be saved as `index.html` in the templates folder of the
    application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完整模板可以保存为 `index.html`，位于应用程序的模板文件夹中。
- en: 'Listing 11.6 `index.html`: Template showing the live video stream and snack
    list'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 `index.html`：显示实时视频流和零食列表的模板
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: All the pieces of our application are now in place, and we can try out the final
    version. In addition to having `stream_save.py` running, make sure `stream_web.py`
    is also running so that the live video stream can be served to the application.
    Run the `pusher_web.py` script so that we can try our application. Access the
    web application by visiting the address http://robopi:8888/ or by the IP address
    of the robot. Figure 11.9 shows what the full application will look like. We can
    now see the live video stream and make our snack selections in the same application.
    We can select any of the snacks, and as the request is processed by the robot,
    the video stream will keep playing uninterrupted.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的所有部件现在都已就位，我们可以尝试最终版本。除了运行 `stream_save.py` 之外，确保 `stream_web.py` 也正在运行，以便将实时视频流提供给应用程序。运行
    `pusher_web.py` 脚本，以便我们可以尝试我们的应用程序。通过访问地址 http://robopi:8888/ 或机器人的 IP 地址来访问网络应用程序。图
    11.9 显示了完整应用程序的外观。现在我们可以看到实时视频流，并在同一应用程序中做出零食选择。我们可以选择任何零食，当请求被机器人处理时，视频流将保持不间断地播放。
- en: '![](../Images/CH11_F09_Alsabbagh.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F09_Alsabbagh.png)'
- en: 'Figure 11.9 Final application: the live video stream is shown while snacks
    are selected.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 最终应用程序：在选择零食时显示实时视频流。
- en: 'Going deeper: Video streams in applications'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：应用程序中的视频流
- en: This is the first time that we embed a live video stream into a web application,
    which is a very powerful feature of the HTML language. We can expand this functionality
    in many ways.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次将实时视频流嵌入到网络应用程序中，这是 HTML 语言的一个非常强大的功能。我们可以以多种方式扩展这个功能。
- en: We can create user interfaces with multiple video streams being displayed simultaneously.
    This is particularly useful for robots that have multiple cameras on board, with
    one facing forward and another facing backward. By displaying all the video feeds
    from the cameras at the same time, we can obtain a full view of the robot’s environment
    as it drives around.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建同时显示多个视频流的用户界面。这对于拥有多个摄像头的机器人尤其有用，一个面向前方，另一个面向后方。通过同时显示来自摄像头的所有视频流，我们可以在机器人行驶时获得其环境的全面视图。
- en: Another useful feature that we could add is the ability to continuously record
    and play back video streams. This could be done by creating a stream-archiving
    application that would save each new frame from the video stream into time-stamped
    filenames. Then we would add the option in the user interface to rewind back in
    time. If we left the video stream to be continually saved, the disk would eventually
    fill up, and we would run out of storage. We could address this by implementing
    a data-retention policy where we would only retain video stream data for the past
    24 hours. Any older data would be removed automatically, and then the application
    could maintain its record and playback features and not run out of disk space.
    Alternatively, we could sync the old video data to a centralized video archive
    server on the network. This is another common strategy for dealing with the limited
    local storage on robots.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以添加的有用功能是能够连续录制和播放视频流。这可以通过创建一个将视频流中的每一帧保存到带时间戳的文件名中的归档应用程序来实现。然后我们会在用户界面中添加回放选项。如果我们让视频流持续保存，磁盘最终会填满，我们会耗尽存储空间。我们可以通过实施数据保留策略来解决这个问题，其中我们只会保留过去24小时的视频流数据。任何更旧的数据都会自动删除，然后应用程序可以维护其记录和播放功能，不会耗尽磁盘空间。或者，我们可以将旧视频数据同步到网络上的集中式视频归档服务器。这是处理机器人有限本地存储的另一种常见策略。
- en: This last project has combined many different technologies to create a robot
    that can interact with its environment in powerful ways, and its functionality
    can be extended. We could add a function where the robot drives around and automatically
    does a stock check on the available items. Instead of pushing the items, we could
    create a pick-and-place robot that grabs items and places them in another location,
    similar to what a warehouse robot would do. There are many ways we could improve
    our robots, and we are only limited by our imagination.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的项目结合了许多不同的技术，创建了一个能够以强大方式与环境交互的机器人，并且其功能可以扩展。我们可以添加一个功能，让机器人自动检查可用的物品。而不是推动物品，我们可以创建一个抓取和放置机器人的功能，它抓取物品并将它们放置在另一个位置，类似于仓库机器人所做的那样。我们可以以许多方式改进我们的机器人，而我们唯一受限制的是我们的想象力。
- en: And there you have it. This is the end of a long fun journey bringing together
    a lot of different hardware and software components to make a robot we can control
    with a mobile device over a wireless network. With mobile in hand, select as many
    snacks as you like, and enjoy the robot whizzing around, searching and tossing
    whatever snacks your heart desires.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，这就是一个漫长而有趣的旅程的结束，它汇集了许多不同的硬件和软件组件，使我们能够通过无线网络使用移动设备控制机器人。手拿移动设备，选择你喜欢的任何小吃，享受机器人快速穿梭，寻找和抛出你心中所想的小吃。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The snack-pushing robot is controlled by a web-based Python application.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小吃推送机器人由一个基于Web的Python应用程序控制。
- en: The servo motor is used to move the servo arm up and down and push the snacks.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伺服电机用于移动伺服臂上下移动并推送小吃。
- en: The emoji Python package is used to convert emoji short codes to Unicode characters.
    These are used as icons for the snacks in the application.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用emoji Python包将表情符号简码转换为Unicode字符。这些用作应用程序中小吃图标。
- en: The list of snacks is read from a CSV file that contains the QR code and icon
    for each snack.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小吃列表是从包含每个小吃二维码和图标的CSV文件中读取的。
- en: A single stylesheet is used to style both template pages in the application.
    This is done because there are common style elements in both pages, so it is easier
    to have all styles in one stylesheet.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中，使用单个样式表来格式化模板页面。这样做是因为这两个页面中都有共同的样式元素，因此将所有样式放在一个样式表中会更加方便。
- en: An `iframe` is used to help us play the live video stream and submit snack selections
    in the same application without any interruption to video playback.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`iframe`帮助我们在这个应用程序中播放实时视频流并提交小吃选择，而不会中断视频播放。
