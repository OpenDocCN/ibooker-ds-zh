- en: Chapter 12\. Handling state mutation in a functional way
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章\. 以函数式方式处理状态变化
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Creating a functional random number generator
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数式随机数生成器
- en: Designing a generic API for handling state mutation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个通用的API来处理状态变化
- en: Handling and composing state operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和组合状态操作
- en: Using recursive state operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归状态操作
- en: Generic state handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用状态处理
- en: Building a state machine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建状态机
- en: In this chapter, you’ll learn how to handle state in a purely functional way.
    In the previous chapters, state mutation was avoided as much as possible, and
    you might have come to believe that state mutation is incompatible with functional
    programming. This isn’t true. In functional programming, it’s perfectly possible
    to handle state mutation. The only difference from what you may be used to is
    that you have to handle state mutation functionally, which means without resorting
    to side effects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何以纯函数式的方式处理状态。在前面的章节中，我们尽可能地避免了状态变化，你可能会认为状态变化与函数式编程不相容。这并不正确。在函数式编程中，处理状态变化是完全可能的。与你可能习惯的不同之处在于，你必须以函数式的方式处理状态变化，这意味着不依赖于副作用。
- en: For a programmer, there are many reasons for handling state mutations. One of
    the simplest examples is the random number generator. A random number generator
    is a component with a method that returns a random number. If the random number
    generator had no state (which means, in reality, no changing state), it would
    always return the same number. This is not what you expect.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，处理状态变化的理由有很多。一个最简单的例子是随机数生成器。随机数生成器是一个具有返回随机数字的方法的组件。如果随机数生成器没有状态（在现实中意味着没有变化的状态），它将始终返回相同的数字。这不是你期望的。
- en: On the other hand, because I’ve said many times in the previous chapters that
    a function, given the same argument, should return the same value, it might be
    difficult to imagine how such a generator would work.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，因为我已经在前面的章节中多次说过，一个函数，给定相同的参数，应该返回相同的值，所以你可能很难想象这样的生成器是如何工作的。
- en: 12.1\. A functional random number generator
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. 函数式随机数生成器
- en: 'There are many uses for a random number generator, but they can be grouped
    into two main categories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成器有许多用途，但可以将它们分为两大类：
- en: Generating numbers that are evenly distributed over a given range
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成在给定范围内均匀分布的数字
- en: Generating truly “random” numbers, which means numbers that you can’t predict
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成真正的“随机”数字，这意味着你无法预测的数字
- en: In the first case, you don’t need the numbers to be really random. What you
    need is that they be randomly distributed. So randomness, in this case, doesn’t
    apply to a single number, but to a series. Moreover, you want to be able to reproduce
    the series if needed. This will allow you to test your programs. If the generated
    numbers were really random (in the sense of being unpredictable), you wouldn’t
    be able to test the generator or the programs using it, because you wouldn’t know
    which values to expect.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你不需要数字真的随机。你需要的是它们是随机分布的。因此，在这种情况下，随机性不适用于单个数字，而是一系列数字。此外，你希望能够在需要时重现这一系列数字。这将允许你测试你的程序。如果生成的数字真的是随机的（在不可预测的意义上），你就无法测试生成器或使用它的程序，因为你不知道期望哪些值。
- en: In the second case, you really want the numbers to be unpredictable. For example,
    if you wanted to generate random test data to test other programs, it would be
    useless to generate the same data each time the tests were run.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，你真的希望数字是不可预测的。例如，如果你想要生成随机测试数据来测试其他程序，每次测试运行时生成相同的数据将毫无用处。
- en: 'Java has a random number generator. You can use it by calling the `nextInt`
    method (among others):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java有一个随机数生成器。你可以通过调用`nextInt`方法（以及其他方法）来使用它：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This program prints ... well, you don’t know. On each run, it will print a
    different result, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序打印...好吧，你不知道。每次运行，它都会打印不同的结果，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although this is sometimes what you want, this isn’t functional. The `nextInt`
    method of the random number generator isn’t a function because it doesn’t always
    return the same value when called with the same argument.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时你可能想要这样，但这不是函数式的。随机数生成器的`nextInt`方法不是一个函数，因为它在用相同的参数调用时并不总是返回相同的值。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Functions without arguments
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无参数的函数
- en: The fact that `nextInt` doesn’t take an argument is irrelevant. To be a function,
    it must simply always return the same value. Not taking an argument means, in
    fact, that it could take any argument, and this argument would have no influence
    on the returned value. This doesn’t contradict the definition of a function. This
    kind of function is simply a constant.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextInt` 不接受参数的事实并不重要。为了成为一个函数，它必须始终返回相同的值。不接受参数实际上意味着它可以接受任何参数，而这个参数对返回值没有任何影响。这并不违反函数的定义。这种函数只是一个常数。'
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s think about what’s happening. If the method takes no argument and returns
    a value, this value must come from somewhere. Of course, you’d guess that this
    somewhere is inside the random number generator. The fact that the value changes
    on each call means that the generator changes between each call; it has a mutable
    state. So the question is whether the value returned by the `nextInt` method depends
    only on the state of the generator, or whether it depends on something else.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下正在发生的事情。如果方法不接受参数并返回一个值，那么这个值必须来自某个地方。当然，你会猜测这个“某个地方”就在随机数生成器内部。值在每次调用时都会变化的事实意味着生成器在每次调用之间都会变化；它有一个可变的状态。所以问题是
    `nextInt` 方法返回的值是否只依赖于生成器的状态，或者它是否依赖于其他东西。
- en: 'If the returned value were to depend only on the state of the generator, it
    would be easy to make it functional. You’d just have to pass the state of the
    generator as an argument to the method. Of course, since the state will change
    as the method returns a result (in order for the generator to not always return
    the same value), the method would have to return the state of the generator together
    with the generated value. You know how to do this by simply returning a tuple,
    so the `nextInt` method signature would change as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的值只依赖于生成器的状态，那么让它成为功能性的将很容易。你只需将生成器的状态作为参数传递给方法。当然，由于状态会在方法返回结果时变化（以便生成器不会总是返回相同的值），方法必须返回生成器的状态以及生成的值。你知道如何通过简单地返回一个元组来完成这个操作，所以
    `nextInt` 方法的签名将如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The problem here is that the Java `Random` generator doesn’t work this way.
    The `next-Int` method returns a value that’s not only dependent on the state of
    the generator, but also on the system clock: the system clock is used to initialize
    the generator. In fact, the Java `Random` generator takes a `long` value to initialize
    itself. From this point, the series of generated numbers won’t vary, but this
    `long` value, called the *seed*, is by default based on the number of nanoseconds
    returned by the system clock. (Look at the `Random.java` source code for more
    details.) What’s important is that the approach taken by Java is to return unpredictable
    numbers unless a specific seed is provided to initialize the generator. So you
    can still use it for generating random numbers in a functional way.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于 Java 的 `Random` 生成器并不这样工作。`nextInt` 方法返回的值不仅依赖于生成器的状态，还依赖于系统时钟：系统时钟用于初始化生成器。实际上，Java
    的 `Random` 生成器使用一个 `long` 类型的值来初始化自己。从这一点开始，生成的数字序列将不会变化，但这个称为 *种子* 的 `long` 值默认基于系统时钟返回的纳秒数。（更多细节请查看
    `Random.java` 源代码。）重要的是，Java 采取的方法是返回不可预测的数字，除非提供特定的种子来初始化生成器。因此，你仍然可以用它以功能方式生成随机数。
- en: 12.1.1\. The random number generator interface
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1\. 随机数生成器接口
- en: You’ll now implement a functional random number generator. This won’t be the
    best example of a number generator, but because you’re just learning how to handle
    state mutation in a functional way, it will serve as an example of functional
    state handling.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将实现一个功能随机数生成器。这不会是最好的数字生成器示例，但因为你只是在学习如何以功能方式处理状态变化，它将作为一个功能状态处理的示例。
- en: First, you need to define the interface of the generator. Generating random
    numbers can be done in many different ways, so you could use different implementations.
    The quality of a generator, from the business point of view, is based on the impossibility
    of predicting the next number just by looking at the previous ones. So you might
    define a simple generator that produces somewhat predictable data at a low cost,
    or you might define a complex implementation for use cases where unpredictability
    is a matter of security.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要定义生成器的接口。生成随机数可以通过许多不同的方式完成，因此你可以使用不同的实现。从业务角度来看，生成器的质量基于仅通过查看前一个数字就无法预测下一个数字的不可能性。因此，你可能定义一个简单的生成器，以低廉的成本生成某种可预测的数据，或者你可能定义一个复杂的实现，用于需要不可预测性作为安全措施的用例。
- en: 'Here’s the interface of your generator:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的生成器接口：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 12.1.2\. Implementing the random number generator
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2\. 实现随机数生成器
- en: 'In this section, you’ll implement the random number generator as simply as
    possible by using the Java `Random` class. You must initialize it with a seed
    in order for the random number series to be reproducible. Here’s a possible implementation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将通过使用 Java `Random` 类尽可能简单地实现随机数生成器。你必须使用种子初始化它，以便随机数序列可以重复。以下是一个可能的实现：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All that’s left to do is to create a front-end component to make the random
    number generator more functional:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是创建一个前端组件，使随机数生成器更具功能性：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To see how this class can be used, let’s look at a unit test:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这个类如何使用，让我们看看一个单元测试：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the integer method of the `Generator` class is functional. You
    can run this test as many times as you want; it will always produce the same values.
    So although the value returned by the generator depends on the generator’s mutable
    state, the method is still referentially transparent.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Generator` 类的整数方法是函数式的。你可以运行这个测试任意多次；它总是会生成相同的值。所以尽管生成器返回的值依赖于生成器的可变状态，但该方法仍然是引用透明的。
- en: If you need to produce really unpredictable numbers, you can call the `JavaRNG.rng`
    method with a “random” long value; for example, the value returned by `System.nanoTime()`.
    Be aware, however, that the value returned doesn’t have the resolution of 1 nanosecond,
    so several successive invocations might return the same value. This can be avoided
    by caching the value returned by `nanoTime` and calling it again if the value
    hasn’t changed, until a different value is obtained. The `Random` class offers
    this service, so the simplest solution would be to create a second method initializing
    the random field with an unparameterized `Random()`. But once again, this chapter
    isn’t about generators, but about functionally handling state.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要生成真正不可预测的数字，你可以使用带有“随机”长值的 `JavaRNG.rng` 方法；例如，`System.nanoTime()` 返回的值。但是，请注意，返回的值没有
    1 纳秒的分辨率，所以连续多次调用可能会返回相同的值。这可以通过缓存 `nanoTime` 返回的值并在值未改变时再次调用它来避免，直到获得不同的值。`Random`
    类提供了这项服务，所以最简单的解决方案是创建一个初始化随机字段的无参数 `Random()` 的第二个方法。但再次强调，本章不是关于生成器，而是关于函数式处理状态。
- en: Exercise 12.1
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.1
- en: 'Write a method in the `Generator` class that returns a random positive integer
    lower than a value passed as a parameter, but greater than or equal to 0\. Here’s
    the signature:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Generator` 类中编写一个方法，该方法返回一个小于作为参数传递的值但大于或等于 0 的随机正整数。以下是签名：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Solution 12.1
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 12.1
- en: Simply get the next random value from the generator. For the first tuple member,
    create a new tuple using the absolute value of the rest of the division by the
    parameter. Leave the second member unchanged.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地从生成器中获取下一个随机值。对于第一个元组成员，使用除以参数的其余部分的绝对值创建一个新的元组。第二个成员保持不变。
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exercise 12.2
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.2
- en: 'Write a method returning a list of *n* random integers. It will also have to
    return the current state, which translates to the last `RNG`, so it can generate
    the next integer. Here’s the signature:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个返回一个包含 *n* 个随机整数的列表的方法。它还必须返回当前状态，这相当于最后一个 `RNG`，以便它可以生成下一个整数。以下是签名：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Hint
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Try not to use explicit recursion. Use methods from the `List` class, starting
    by creating a list of the requested size and folding it. Note that if you generate
    a list of random numbers, you might as well return it in reverse order (if that’s
    simpler). But you must ensure that the returned generator is up to date, which
    means it must be the last one returned by the `nextInt` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要使用显式递归。使用 `List` 类的方法，首先创建一个所需大小的列表，然后折叠它。注意，如果你生成一个随机数列表，你也可以将其以反向顺序返回（如果这样更简单）。但你必须确保返回的生成器是最新的，这意味着它必须是
    `nextInt` 方法返回的最后一个。
- en: Solution 12.2
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 12.2
- en: 'The idea is to create a list of the intended length, and then to fold it with
    the right function. You’ll do this with a list of integers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是创建一个所需长度的列表，然后使用正确的函数折叠它。你会用整数列表来做这件事：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a common pattern for replacing the indexed loops of imperative programming.
    Here, the `f` function ignores the integers in the list. This function adds the
    value produced by the generator to a list, starting with an empty list. So it
    seems it should be a function of the following type:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的模式，用于替换命令式编程中的索引循环。在这里，`f` 函数忽略了列表中的整数。这个函数将生成器产生的值添加到一个列表中，从空列表开始。所以它看起来应该是一个以下类型的函数：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But if you do this, you’ll have a problem. You might easily transform the resulting
    `List<Tuple<Integer, RNG>>` into a `List<Integer>`, but to reconstruct a `Tuple<List<Integer>,
    RNG>`, you’ll have to get the last `RNG` in the list. That’s because folding a
    list into another list reverses the order of the elements. The fact that the random
    values are in reverse order is irrelevant, but you need access to the last returned
    `RNG`, which, due to the fold, will be in last position. To access it, you’d have
    to reverse the list, which is neither efficient nor smart.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你这样做，你会遇到问题。你可能会轻易地将生成的 `List<Tuple<Integer, RNG>>` 转换为 `List<Integer>`，但要重建
    `Tuple<List<Integer>, RNG>`，你必须获取列表中的最后一个 `RNG`。这是因为将列表折叠到另一个列表中会反转元素的顺序。随机值顺序相反的事实并不重要，但你需要访问最后一个返回的
    `RNG`，由于折叠，它将位于最后一个位置。要访问它，你必须反转列表，这既不高效也不明智。
- en: 'A better solution is to carry the current `RNG` while folding the list of integers.
    The result will be a `Tuple<List<Tuple<Integer, RNG>>, RNG>`, and the function
    used to fold will be the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是在折叠整数列表时携带当前的 `RNG`。结果将是一个 `Tuple<List<Tuple<Integer, RNG>>, RNG>`，用于折叠的函数将是以下内容：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The type may look intimidating, but despite that, you shouldn’t make it explicit.
    The compiler will be able to infer this type, so you don’t have to write it. Here’s
    the complete fold:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可能看起来令人畏惧，但尽管如此，你不应该使其显式。编译器将能够推断出这个类型，所以你不必写它。以下是完整的折叠：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that you get a `Tuple<List<Tuple<Integer, RNG>>, RNG>`, it’s easy to construct
    the expected result:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你得到了一个 `Tuple<List<Tuple<Integer, RNG>>, RNG>`，构建预期的结果就很容易了：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the resulting list of random numbers is still in reverse order
    because of the way the singly linked list is constructed, but you don’t need to
    reverse the list. You don’t care about the first-generated number coming last.
    The only important thing is that the returned `RNG` will produce the correct number.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于单链表构建的方式，生成的随机数列表仍然是反向的，但你不需要反转列表。你不在乎第一个生成的数字最后出现。唯一重要的是返回的 `RNG` 将产生正确的数字。
- en: 'If you prefer, you could implement the method this way:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以这样实现该方法：
- en: '![](Images/327fig01_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/327fig01_alt.jpg)'
- en: 'Alternatively, you can use explicit recursion:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用显式递归：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Be aware, however, that functional programmers generally consider using explicit
    recursion a bad practice. They instead favor abstracting recursion by using folds.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，函数式程序员通常认为使用显式递归是一种不良做法。他们更倾向于通过使用折叠来抽象递归。
- en: 12.2\. A generic API for handling state
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2. 处理状态的泛型API
- en: As I said, the way you implemented `RNG` isn’t the best way to implement generators.
    This was just an example to show you how state can be handled in a functional
    way. What you can learn from that example is that your `RNG` represents the current
    state of the generator.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，你实现 `RNG` 的方式并不是实现生成器的最佳方式。这只是一个例子，用来向你展示状态如何在函数式方式中处理。你可以从那个例子中学到的是，你的
    `RNG` 代表了生成器的当前状态。
- en: 'But if you want to generate integers, you probably aren’t really interested
    in `RNG`. You’d probably prefer to make it transparent. In other words, what you’ve
    used so far is a function taking an `RNG` and returning the generated value, be
    it an `Integer`, a `List`, or whatever, as well as the new `RNG`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要生成整数，你可能对 `RNG` 并不真正感兴趣。你可能更希望使其透明。换句话说，你到目前为止使用的是一个接受 `RNG` 并返回生成的值（无论是
    `Integer`、`List` 还是其他什么）以及新的 `RNG` 的函数：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Wouldn’t it be better if you could get rid of the `RNG`? Is it possible to abstract
    the `RNG` handling in such a way that you don’t have to worry about it anymore?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能去掉 `RNG` 会更好吗？是否有可能以这种方式抽象处理 `RNG`，以至于你不再需要担心它？
- en: 'To abstract the `RNG` handling, you need to create a new type encapsulating
    the `RNG` parameter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抽象处理 `RNG`，你需要创建一个新的类型来封装 `RNG` 参数：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can now redefine the generating operations in terms of this new type. For
    example, you can replace the following method
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以用这个新类型来重新定义生成操作。例如，你可以替换以下方法
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'with a function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个函数：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 12.2.1\. Working with state operations
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1. 处理状态操作
- en: Having abstracted the `RNG`, you’re left with something that looks very similar
    to the parameterized types you’ve studied in previous chapters. What you get here
    is a computational context for some simple types. Remember `List` and `Result`?
    Those types were acting like computational contexts for other types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过抽象 `RNG`，你剩下的是与你在前面章节中学习过的参数化类型非常相似的东西。你在这里得到的是一个简单类型的计算上下文。还记得 `List` 和 `Result`
    吗？这些类型就像其他类型的计算上下文一样在起作用。
- en: A `List` of integers is a computational context for the `Integer` type. For
    example, it allows you to apply, to a list of integers, a function from `Integer`
    to another type, without caring about the number of elements in the list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 整数列表是 `Integer` 类型的计算上下文。例如，它允许你将一个从 `Integer` 到另一个类型的函数应用于整数列表，而无需关心列表中的元素数量。
- en: '`Result` is no different. It creates a computational context for a value, allowing
    you to apply a function to that value without caring whether a value is really
    present. In the same manner, `Random` allows you to apply computations to a value
    without having to handle the fact that the value is random.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 没有不同。它为值创建一个计算上下文，允许你对该值应用函数，而无需关心该值是否真的存在。同样地，`Random` 允许你对该值应用计算，而无需处理该值是随机的这一事实。'
- en: Can you define for `Random` the same abstractions you defined for `List` and
    `Result`? Let’s try.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你能为 `Random` 定义与 `List` 和 `Result` 相同的抽象吗？让我们试试。
- en: 'To start with, you need a way to create a `Random` from a single value. Although
    this might seem mostly useless in real life, it’s needed to create the other abstractions.
    You’ll call this method `unit`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一种方法从单个值创建一个 `Random`。尽管这在现实生活中可能看起来用处不大，但它对于创建其他抽象是必需的。你可以将这个方法命名为 `unit`：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The name `unit` is used by convention. You could have also used this name for
    `Result`, `Stream`, `List`, `Heap`, and so on, but you chose more business-related
    names instead, such as `list` and `success`. It’s the same concept applied to
    different types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`unit` 这个名称被使用。你也可以用这个名称来命名 `Result`、`Stream`、`List`、`Heap` 等等，但你选择了更与商业相关的名称，例如
    `list` 和 `success`。这是将相同的概念应用于不同类型。
- en: 'Let’s try going further. Can you use a function from `A` to `B` to transform
    a `Random<A>` into a `Random<B>`? Sure you can. For other types, this was called
    `map`. Let’s define a `map` method for `Random`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步。你能使用从 `A` 到 `B` 的函数将 `Random<A>` 转换为 `Random<B>` 吗？当然可以。对于其他类型，这被称为
    `map`。让我们为 `Random` 定义一个 `map` 方法：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method can be defined anywhere, such as in the `Random` interface.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以在任何地方定义，例如在 `Random` 接口中。
- en: Exercise 12.3
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.3
- en: Use the `map` method to generate a random `Boolean`. Do this by creating a function
    in the `Random` interface.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map` 方法生成一个随机的 `Boolean`。通过在 `Random` 接口中创建一个函数来完成此操作。
- en: Hint
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'Use the following function, which you just created:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下你刚刚创建的函数：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Solution 12.3
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 12.3
- en: 'The solution consists of mapping the result returned by the `intRnd` function
    with a function that converts an `int` into a `boolean`. Of course, if you want
    the result to have a 50% probability of being `true`, you must choose the function
    accordingly. The commonly used algorithm for this is to test whether the remainder
    of the division by 2 is 0:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案包括将 `intRnd` 函数返回的结果映射到一个将 `int` 转换为 `boolean` 的函数。当然，如果你想使结果有 50% 的概率为
    `true`，你必须相应地选择函数。常用的算法是测试除以 2 的余数是否为 0：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exercise 12.4
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.4
- en: Implement a function that returns a randomly generated `Double`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个返回随机生成`Double`的函数。
- en: Solution 12.4
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案12.4
- en: 'This works exactly like the `booleanRnd` function. The only difference is the
    function to map:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`booleanRnd`函数的工作方式完全相同。唯一的区别是映射的函数：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 12.2.2\. Composing state operations
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2. 组合状态操作
- en: In the previous section, you composed state operations with ordinary functions.
    What if you need to compose two or more state operations? This is what you did
    in exercise 12.2 to produce a `List` of randomly generated integers. Can you abstract
    this in the `Random` type? As a starting point, you might need a method to combine
    two `Random` instances, such as to generate a pair of random numbers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你使用普通函数组合了状态操作。如果你需要组合两个或多个状态操作呢？这就是你在练习12.2中做的，以生成一个随机生成的整数`List`。你能否在`Random`类型中抽象化这一点？作为一个起点，你可能需要一个方法来组合两个`Random`实例，例如生成一对随机数。
- en: Exercise 12.5
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.5
- en: Implement a function that takes an `RNG` and returns a pair of integers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个函数，该函数接受一个`RNG`并返回一对整数。
- en: Hint
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'First define a `map2` method in the `Random` interface that composes two calls
    to the random generator to produce a pair of values of generic types `A` and `B`,
    and then use them as parameters for a function that returns a third type `C`.
    Here’s its signature:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`Random`接口中定义一个`map2`方法，该方法组合两个对随机生成器的调用，以生成泛型类型`A`和`B`的值对，然后使用它们作为返回第三个类型`C`的函数的参数。以下是它的签名：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Solution 12.5
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案12.5
- en: 'This isn’t any more difficult than implementing `map`. You first have to pass
    the `rng` parameter to the first function. Then, extract the returned `RNG` from
    the result, and pass it to the second function. Finally, use the two values as
    input to the `f` function, and return the result together with the resulting `RNG`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不比实现`map`更困难。你首先必须将`rng`参数传递给第一个函数。然后从结果中提取返回的`RNG`，并将其传递给第二个函数。最后，使用这两个值作为`f`函数的输入，并返回结果以及生成的`RNG`：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using this method, you can define a function that returns a pair of random
    integers, as in the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你可以定义一个返回一对随机整数的函数，如下例所示：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Don’t use the same `RNG` for both values. Doing so would produce a pair of two
    identical integers!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用相同的`RNG`来生成两个值。这样做会产生一对相同的整数！
- en: Exercise 12.6
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.6
- en: Implement a function that takes an `RNG` and returns a list of randomly generated
    integers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个函数，该函数接受一个`RNG`并返回一个随机生成的整数列表。
- en: Hint
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The overall process is quite simple to describe. First, you have to generate
    a `List <Random<Integers>>`. Then, you must transform this into a `Random<List<Integer>>`.
    Does this remind you of something? It’s the same abstraction you implemented for
    `Result`, changing a `List<Result>` into a `Result<List>`, which you called `sequence`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程描述起来相当简单。首先，你必须生成一个`List<Random<Integers>>`。然后，你必须将这个列表转换成`Random<List<Integer>>`。这让你想起了什么吗？这是你为`Result`实现的相同抽象，将`List<Result>`转换为`Result<List>`，你称之为`sequence`。
- en: 'You can start by implementing a `sequence` method in the `Random` class. Here’s
    its signature:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从在`Random`类中实现一个`sequence`方法开始。以下是它的签名：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To generate the list, you can use the `List.fill()` method that’s defined in
    the `List` class with the following signature:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成列表，你可以使用在`List`类中定义的`List.fill()`方法，其签名如下：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Solution 12.6
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案12.6
- en: You can guess that you’ll have to iterate over the list. You don’t need to use
    explicit recursion for this, and you shouldn’t! You should instead use a fold.
    The starting value will be a `Random` constructed with an empty list. This is
    where the `unit` method starts to be a useful tool. Use a `foldLeft` or `foldRight`
    with a function that applies `map2` to the current accumulator value and the element
    of the list to process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以猜测你将需要遍历列表。你不需要为此使用显式递归，也不应该这样做！你应该使用折叠。起始值将是一个使用空列表构造的`Random`。这就是`unit`方法开始变得有用的地方。使用`foldLeft`或`foldRight`，并使用一个将`map2`应用于当前累加器值和要处理的列表元素的函数。
- en: 'This is much more difficult to describe than to code. Here’s an example using
    `foldLeft`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这比描述代码要困难得多。以下是一个使用`foldLeft`的示例：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then define the function returning a list of random integers. This time, the
    type is no longer `Random<Integer>`, because you have to deal with the additional
    `int` parameter representing the desired length of the list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义一个函数，返回一个随机整数的列表。这次，类型不再是`Random<Integer>`，因为你必须处理表示列表所需长度的额外`int`参数：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It’s interesting to compare this implementation with the solution of exercise
    12.2:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个实现与练习12.2的解决方案进行比较很有趣：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can see that the fold has been abstracted into the `sequence` method, and
    the intermediary result handling has been abstracted into the `map2` method. The
    resulting code is very clean and easy to understand (provided you understood the
    two abstractions). In the `integersRnd` function, you don’t have to manipulate
    the `RNG` generator. The same is true for the `sequence` and `map2` methods. As
    you can see, you’re very close to implementing a generic state–handling tool.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，折叠已经被抽象成`sequence`方法，中间结果处理已经被抽象成`map2`方法。生成的代码非常简洁且易于理解（前提是你理解了这两个抽象）。在`integersRnd`函数中，你不需要操作`RNG`生成器。对于`sequence`和`map2`方法也是如此。正如你所见，你非常接近实现一个通用的状态处理工具。
- en: 12.2.3\. Recursive state operations
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.3. 递归状态操作
- en: So far, you’ve seen how to call the generator several times to return several
    values. But you might have to handle a different use case. Imagine that you want
    to generate integers that shouldn’t be multiples of 5.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何多次调用生成器以返回多个值。但你可能需要处理不同的用例。想象一下，你想要生成不是5的倍数的整数。
- en: 'If you were writing an imperative program, you could simply generate a number
    and test it. If it wasn’t a multiple of 5, you’d return it. Otherwise, you’d generate
    the next number. In this implementation, you’d have to generate a second number
    in an average of one case out of five. You might think about something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个命令式程序，你可以简单地生成一个数字并测试它。如果不是5的倍数，你就返回它。否则，你生成下一个数字。在这个实现中，你平均每五个案例中就要生成第二个数字。你可能考虑以下方案：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But how can you access the `RNG` that must be passed to the recursive call to
    the `not-MultipleOfFiveRnd` function? This is the `RNG` resulting from the first
    call to the function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但你如何访问必须传递给`not-MultipleOfFiveRnd`函数递归调用的`RNG`？这是函数第一次调用产生的`RNG`。
- en: 'You *could* solve this problem by explicitly handling the result of the first
    function call:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你**可以**通过显式处理第一次函数调用的结果来解决这个问题：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: But it seems you’re returning to where you started from. What you really need
    here is a `flatMap` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但看起来你回到了起点。你真正需要的是`flatMap`方法。
- en: Exercise 12.7
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.7
- en: 'Write a `flatMap` method and use it to implement the `notMultipleOfFiveRnd`
    function. Here’s the `flatMap` method signature:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`flatMap`方法，并使用它来实现`notMultipleOfFiveRnd`函数。这是`flatMap`方法的签名：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Solution 12.7
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案12.7
- en: 'The `flatMap` method is very similar to the `map` method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`方法与`map`方法非常相似：'
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The difference is that instead of constructing a tuple and returning it, you
    simply pass the generated value to the `f` function, which gives you a `Random<B>`.
    Remember that this is, in reality, a `Function<RNG, Tuple<A, RNG>>`, so you pass
    the `RNG` resulting from the application of `s` to that function, which gives
    you a `Tuple<A, RNG>` that you can return.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，你不需要构造一个元组并返回它，而是简单地将生成的值传递给`f`函数，这个函数给你一个`Random<B>`。记住，实际上这是一个`Function<RNG,
    Tuple<A, RNG>>`，所以你将应用`s`到该函数的结果`RNG`传递给它，这给你一个可以返回的`Tuple<A, RNG>`。
- en: 'Now you can implement the `notMultipleOfFiveRnd` function in terms of `flatMap`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以用`flatMap`来实现`notMultipleOfFiveRnd`函数：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Exercise 12.8
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.8
- en: Implement `map` and `map2` in terms of `flatMap`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 用`flatMap`来实现`map`和`map2`。
- en: Hint
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'There’s a relationship between `map`, `flatMap`, and `unit`: `flatMap` is a
    combination of `map` and `unit`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之间存在着`map`、`flatMap`和`unit`的关系：`flatMap`是`map`和`unit`的组合。
- en: Solution 12.8
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案12.8
- en: 'Here are the two new implementations:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两种新的实现：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, `flatMap` gives you an additional level of abstraction, which
    allows you to write much clearer method implementations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`flatMap`为你提供了一个额外的抽象层次，这允许你编写更清晰的方法实现。
- en: 12.3\. Generic state handling
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 通用状态处理
- en: 'So far, all the methods and functions you’ve developed in this chapter have
    been used to generate random numbers. But you started with code that was specific
    to generating random numbers, and you ended with tools that are absolutely unrelated
    to random number generation. The methods of the `Random` interface are connected
    to random number generation only by the fact that this interface extends `Function
    <RNG, Tuple<A, RNG>>`. You could, in fact, redefine this interface to handle any
    kind of state:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你在这个章节中开发的全部方法和函数都用于生成随机数。但你从生成随机数的特定代码开始，并以与随机数生成完全无关的工具结束。`Random`接口的方法仅通过这个接口扩展`Function
    <RNG, Tuple<A, RNG>>`与随机数生成相关联。实际上，你可以重新定义这个接口来处理任何类型的状态：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You’re certainly aware that composition is better than inheritance, so you
    might prefer to define the `State` class using a delegate:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然知道组合优于继承，所以你可能更喜欢使用代理来定义`State`类：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now you can redefine `Random` as a specific case of `State`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将`Random`重新定义为`State`的一个特定情况：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Exercise 12.9
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.9
- en: Complete the `State` class by re-implementing the methods of the `Random` interface
    in a generic way.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以通用方式重新实现`Random`接口的方法，完成`State`类的实现。
- en: Hint
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Define the methods as instance methods, except, of course, for the `unit` method,
    which needs to be static. Each method will have to create a new `State`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法定义为实例方法，当然，`unit`方法需要是静态的。每个方法都必须创建一个新的`State`。
- en: Solution 12.9
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 12.9
- en: 'Here are your new methods:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您的新方法：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can now replace your `Random` interface with an alias for `State<RNG, A>`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以用`State<RNG, A>`的别名替换你的`Random`接口：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 12.3.1\. State patterns
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1\. 状态模式
- en: 'Imagine you need to generate three random integers to initialize a three-dimensional
    (3D) point:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要生成三个随机整数来初始化一个三维（3D）点：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can create a random `Point` as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个随机的`Point`如下所示：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This code simply modifies a state. But this modification could be simplified
    if you had a `get` method for reading the state and a `set` method for writing
    it. Then you could combine them to modify the state using a function `f` as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是修改了一个状态。但如果有一个`get`方法来读取状态和一个`set`方法来写入它，这种修改可以简化。然后你可以使用函数`f`将它们组合起来修改状态，如下所示：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This method returns a `State<S, Nothing>` because it doesn’t return a value.
    You’re only interested in the modified state. `Nothing` is a type you have to
    define as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回`State<S, Nothing>`，因为它不返回任何值。你只对修改后的状态感兴趣。"Nothing"是一个你必须如下定义的类型：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Instead of using the `Nothing` type, you could have returned `Void`, but instantiating
    `Void` is a bit tricky, using a dirty hack, so a cleaner solution is preferable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Void`类型而不是`Nothing`类型返回，但实例化`Void`有点棘手，使用一个肮脏的技巧，所以更清洁的解决方案更可取。
- en: 'The `get` method creates a function that simply returns the argument’s state
    both as the state and the value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法创建一个函数，该函数简单地返回参数的状态，既是状态也是值：'
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `set` method creates a function that returns the parameter’s state as the
    new state and the `Nothing` singleton as the value:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`方法创建一个函数，该函数返回参数的状态作为新状态，以及`Nothing`单例作为值：'
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 12.3.2\. Building a state machine
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2\. 构建状态机
- en: One of the most common tools for composing state mutations is the state machine.
    A state machine is a piece of code that processes inputs by conditionally switching
    from one state to another. Many business problems can be represented by such conditional
    state mutations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 组合状态变异的最常见工具之一是状态机。状态机是一段代码，它通过有条件地从一种状态切换到另一种状态来处理输入。许多业务问题可以通过此类条件状态变异来表示。
- en: By creating a parameterized state machine, you can abstract all the details
    about state handling. That way, you’ll be able to handle any such problem by simply
    listing the condition/transition pairs, and then feeding in the list of inputs
    to get the resulting state. The machine will handle the composition of the various
    transitions transparently.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个参数化状态机，你可以抽象出所有关于状态处理的所有细节。这样，你只需列出条件/转换对，然后输入输入列表以获取结果状态，就能简单地处理任何此类问题。机器将透明地处理各种转换的组合。
- en: 'First, you’ll define two interfaces to represent the conditions and the corresponding
    transitions. These interfaces aren’t absolutely necessary, because they’re simple
    functions, but they’ll simplify coding:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要定义两个接口来表示条件和相应的转换。这些接口并不是绝对必要的，因为它们是简单的函数，但它们将简化编码：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `StateTuple` class is also a helper class to simplify coding. It’s simply
    a tuple in which the two fields are called `value` and `state`. This is easier
    to read than `_1` and `_2` or `left` and `right`, because it’s easy to forget
    which of those is which.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateTuple` 类也是一个辅助类，用于简化编码。它只是一个字段名为 `value` 和 `state` 的元组。这比 `_1` 和 `_2`
    或 `left` 和 `right` 更容易阅读，因为很容易忘记哪个是哪个。'
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `StateMachine` class simply holds a function of type `Function<A, State<S,
    Nothing>>`. Returning the final value as part of the state is a matter of choice.
    Here, the final value is included in the state, so you don’t need to carry the
    value separately.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateMachine` 类简单地持有类型为 `Function<A, State<S, Nothing>>` 的函数。将最终值作为状态的一部分是选择问题。在这里，最终值包含在状态中，因此你不需要单独携带该值。'
- en: 'The state machine is constructed from a list of `<Tuple<Condition<A, S>, Transition<A,
    S>>`. In the constructor, the function is built as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机是由一个包含 `<Tuple<Condition<A, S>, Transition<A, S>>` 的列表构建的。在构造函数中，函数构建如下：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `State.sequence` method is defined like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`State.sequence` 方法定义如下：'
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This code may seem complex, but it simply builds a function that will compose
    all the conditional transitions received as the constructor’s parameter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能看起来很复杂，但它只是构建一个函数，该函数将组合所有作为构造函数参数接收的条件转换。
- en: 'The `StateMachine` class also defines a `process` method that receives a list
    of inputs to produce the resulting state:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateMachine` 类还定义了一个 `process` 方法，该方法接收一个输入列表以产生结果状态：'
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `State.compose()` method is defined as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`State.compose()` 方法定义如下：'
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Exercise 12.10
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.10
- en: 'Write an `Atm` class that simulates an automated teller machine. The inputs
    will be represented by the following interface:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `Atm` 类来模拟自动取款机。输入将由以下接口表示：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `Input` interface will have two implementations, `Deposit` and `Withdraw`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Input` 接口将有两个实现，`Deposit` 和 `Withdraw`：'
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To simplify the code, use an additional `Outcome` class representing the result
    tuple:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化代码，使用一个额外的 `Outcome` 类来表示结果元组：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see in this class, `Atm` produces an integer value representing the
    resulting balance of the account, and a list of integers representing the amounts
    of the operations (positive for a deposit, negative for a withdrawal).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在该类中看到的，`Atm` 生成一个表示账户最终余额的整数值，以及一个表示操作金额的整数列表（正数表示存款，负数表示取款）。
- en: 'The exercise is to implement the `Atm` class, which basically contains a method
    that constructs a `StateMachine`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 练习是要实现 `Atm` 类，它基本上包含一个构建 `StateMachine` 的方法：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Hint
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The `createMachine` implementation must first construct a list of tuples of
    conditions and corresponding transitions. These tuples will have to be ordered,
    with the more specific coming first. The last tuple will need a catch-all condition.
    This is like the default case in a switch structure (and also like the default
    case in exercise 3.2). This catch-all condition isn’t always needed, but it’s
    safer to always have one. The list of tuples will be used as the argument to the
    `StateMachine` constructor.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`createMachine` 的实现必须首先构建一个包含条件和相应转换的元组列表。这些元组必须按顺序排列，更具体的元组排在前面。最后一个元组需要一个通配符条件。这就像
    switch 结构中的默认情况（以及练习 3.2 中的默认情况）。这个通配符条件并不总是需要的，但总是有更安全的选择。这个元组列表将作为 `StateMachine`
    构造函数的参数。'
- en: 'You’ll have to run the resulting state machine to get an observable result.
    This can be done by applying the `run` function to a starting state, which will
    produce a resulting state, from which you can extract the value:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须运行生成的状态机以获得可观察的结果。这可以通过将 `run` 函数应用于起始状态来完成，这将产生一个结果状态，你可以从中提取值：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The running part of this code (the second line) can be abstracted into the
    `State` class by adding the following method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的运行部分（第二行）可以通过添加以下方法抽象到 `State` 类中：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With this added method, running the state machine is much neater:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加此方法，运行状态机变得更加整洁：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Solution 12.10
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 12.10
- en: 'The solution is like a program in an imperative language. It can be described
    in pseudo code like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案就像一种命令式语言中的程序。它可以像这样用伪代码描述：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Implementing this is easy:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点很容易：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you want to see the machine in action, just run the unit test that comes
    with the code accompanying this book.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到机器的实际运行情况，只需运行本书附带代码中的单元测试。
- en: This code works exactly like an imperative program, which, by the way, it is.
    It is imperative programming done functionally. Of course, using this kind of
    code to deal with such a simple problem would be overkill. The main drawback of
    this approach isn’t the complexity of the code (this code is very simple), but
    its verbosity. On the other hand, the benefit is that it can be extended at near
    to zero cost. All you have to do is insert the right condition/transition in the
    right place.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作方式与命令式程序完全一样，顺便说一下，它确实是。这是一种函数式命令式编程。当然，使用这种代码处理如此简单的问题可能是过度设计。这种方法的缺点主要不是代码的复杂性（这段代码非常简单），而是其冗长性。另一方面，好处是它几乎可以零成本扩展。你只需要在正确的位置插入正确的条件/转换即可。
- en: Exercise 12.11
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.11
- en: Modify the previous program so that errors such as trying to withdraw more than
    the account balance are reported.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 修改之前的程序，以便报告诸如尝试提取超过账户余额的错误等错误。
- en: Solution 12.11
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 12.11
- en: I have no written solution for this exercise, but I’ve provided one possible
    solution, along with the corresponding JUnit test, in the code accompanying this
    book.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有为这个练习提供书面解决方案，但在本书的代码中提供了一种可能的解决方案，以及相应的 JUnit 测试。
- en: 12.3.3\. When to use state and the state machine
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.3\. 何时使用状态和状态机
- en: It might seem that handling state functionally is an overly complex version
    of imperative programming. This is true for the very simple and small examples
    that can be described in a book. But if you think about complex programs that
    have a huge number of rules, the high level of abstraction of functional state
    handling is clearly beneficial. But this isn’t the only advantage—the main advantage
    is scalability. You can evolve an application simply by changing the rules or
    adding more of them without ever risking messing with the implementation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来在函数式编程中处理状态是一个过于复杂的命令式编程版本。对于可以在书中描述的非常简单和小的例子来说，这是真的。但如果你考虑具有大量规则的复杂程序，函数式状态处理的高度抽象显然是有益的。但这不是唯一的优点——主要优点是可扩展性。你可以通过更改规则或添加更多规则来简单地演进应用程序，而无需冒破坏实现的风险。
- en: You can make this even simpler. Describing the rules (the condition/transition)
    in Java is very verbose, but it’s possible to write them in a more concise form.
    You’d then just have to read them and translate them into Java.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使这更加简单。在 Java 中描述规则（条件/转换）非常冗长，但可以以更简洁的形式编写。然后你只需阅读它们并将它们转换为 Java。
- en: This could evolve into creating a domain-specific language (DSL). Of course
    you’d need a parser to process the programs written using this DSL, but such a
    parser could easily be created using the functional state machine. (A state machine
    is not the best solution for parsing all types of grammar, but that’s another
    story.)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能演变成创建一个领域特定语言（DSL）。当然，你需要一个解析器来处理使用此 DSL 编写的程序，但这样的解析器可以很容易地使用函数式状态机创建。（状态机不是解析所有类型语法的最佳解决方案，但这又是另一个故事。）
- en: 12.4\. Summary
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4\. 摘要
- en: Generating random numbers involves managing the state of a generator.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数涉及到管理生成器的状态。
- en: You can manage state in a functional way by using a representation for state
    operations.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用状态操作表示来以函数式方式管理状态。
- en: You can compose state operations with the help of methods like `map` and `flat-Map`.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用像 `map` 和 `flatMap` 这样的方法来组合状态操作。
- en: You can compose state operations recursively.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以递归地组合状态操作。
- en: The `State` type is a generic representation for state operations, which can
    be used as the basis for implementing a state machine.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State` 类型是对状态操作的泛型表示，可以用作实现状态机的基础。'
