- en: Chapter 11\. Developing production-ready services
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章\. 开发生产就绪服务
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Developing secure services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发安全服务
- en: Applying the Externalized configuration pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用外部化配置模式
- en: 'Applying the observability patterns:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用可观察性模式：
- en: Health check API
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查API
- en: Log aggregation
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志聚合
- en: Distributed tracing
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Exception tracking
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常跟踪
- en: Application metrics
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序度量
- en: Audit logging
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计日志
- en: Simplifying the development of services by applying the Microservice chassis
    pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用微服务底盘模式简化服务的开发
- en: 'Mary and her team felt that they had mastered service decomposition, interservice
    communication, transaction management, querying and business logic design, and
    testing. They were confident that they could develop services that met their functional
    requirements. But in order for a service to be ready to be deployed into production,
    they needed to ensure that it would also satisfy three critically important quality
    attributes: security, configurability, and observability.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽和她的团队认为他们已经掌握了服务分解、服务间通信、事务管理、查询和业务逻辑设计以及测试。他们有信心能够开发出满足其功能要求的服务。但是，为了使服务准备好部署到生产环境中，他们需要确保它还会满足三个至关重要的质量属性：安全性、可配置性和可观察性。
- en: The first quality attribute is *application security*. It’s essential to develop
    secure applications, unless you want your company to be in the headlines for a
    data breach. Fortunately, most aspects of security in a microservice architecture
    are not any different than in a monolithic application. The FTGO team knew that
    much of what they had learned over the years developing the monolith also applied
    to microservices. But the microservice architecture forces you to implement some
    aspects of application-level security differently. For example, you need to implement
    a mechanism to pass the identity of the user from one service to another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个质量属性是*应用安全*。开发安全的应用程序是至关重要的，除非你希望你的公司在数据泄露的新闻头条上。幸运的是，微服务架构中的大多数安全方面与单体应用程序没有太大区别。FTGO团队知道，他们在过去几年中开发单体应用程序所学到的大部分知识也适用于微服务。但是，微服务架构迫使你以不同的方式实现应用级安全的一些方面。例如，你需要实现一种机制，将用户的身份从一个服务传递到另一个服务。
- en: The second quality attribute you must address is *service configurability*.
    A service typically uses one or more external services, such as message brokers
    and databases. The network location and credentials of each external service often
    depend on the environment that the service is running in. You can’t hard-wire
    the configuration properties into the service. Instead, you must use an externalized
    configuration mechanism that provides a service with configuration properties
    at runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须解决的第二个质量属性是*服务可配置性*。服务通常使用一个或多个外部服务，例如消息代理和数据库。每个外部服务的网络位置和凭证通常取决于服务运行的环境。你不能将配置属性硬编码到服务中。相反，你必须使用一个外部化配置机制，该机制在运行时为服务提供配置属性。
- en: The third quality attribute is *observability*. The FTGO team had implemented
    monitoring and logging for the existing application. But a microservice architecture
    is a distributed system, and that presents some additional challenges. Every request
    is handled by the API gateway and at least one service. Imagine, for example,
    that you’re trying to determine which of six services is causing a latency issue.
    Or imagine trying to understand how a request is handled when the log entries
    are scattered across five different services. In order to make it easier to understand
    the behavior of your application and troubleshoot problems, you must implement
    several observability patterns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个质量属性是*可观察性*。FTGO团队已经为现有应用程序实现了监控和日志记录。但是，微服务架构是一个分布式系统，这带来了一些额外的挑战。每个请求都由API网关和至少一个服务处理。想象一下，例如，你正在尝试确定六个服务中的哪一个导致了延迟问题。或者想象一下，当日志条目分散在五个不同的服务中时，尝试理解请求是如何被处理的。为了使理解应用程序的行为和解决问题更容易，你必须实现几个可观察性模式。
- en: I begin this chapter by describing how to implement security in a microservice
    architecture. Next, I discuss how to design services that are configurable. I
    cover a couple of different service configuration mechanisms. After that I talk
    about how to make your services easier to understand and troubleshoot by using
    the observability patterns. I end the chapter by showing how to simplify the implementation
    of these and other concerns by developing your services on top of a microservice
    chassis framework.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我以描述如何在微服务架构中实现安全性开始本章。接下来，我讨论如何设计可配置的服务。我介绍了几种不同的服务配置机制。然后，我谈论如何通过使用可观察性模式使服务更容易理解和调试。我通过展示如何在微服务底盘框架之上开发服务来简化这些和其他问题的实现。
- en: Let’s first look at security.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看安全性。
- en: 11.1\. Developing secure services
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 开发安全服务
- en: Cybersecurity has become a critical issue for every organization. Almost every
    day there are headlines about how hackers have stolen a company’s data. In order
    to develop secure software and stay out of the headlines, an organization needs
    to tackle a diverse range of security issues, including physical security of the
    hardware, encryption of data in transit and at rest, authentication and authorization,
    and policies for patching software vulnerabilities. Most of these issues are the
    same regardless of whether you’re using a monolithic or microservice architecture.
    This section focuses on how the microservice architecture impacts security at
    the application level.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全已成为每个组织的重大问题。几乎每天都有关于黑客如何窃取公司数据的头条新闻。为了开发安全的软件并避免成为头条，组织需要解决各种安全问题，包括硬件的物理安全、传输和静止状态下的数据加密、身份验证和授权，以及修补软件漏洞的政策。大多数这些问题无论你使用单体架构还是微服务架构都是相同的。本节重点介绍微服务架构如何影响应用层的安全性。
- en: 'An application developer is primarily responsible for implementing four different
    aspects of security:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者主要负责实现安全性的四个不同方面：
- en: '***Authentication*—** Verifying the identity of the application or human (a.k.a.
    the *principal*) that’s attempting to access the application. For example, an
    application typically verifies a principal’s credentials, such as a user ID and
    password or an application’s API key and secret.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***身份验证***—**验证尝试访问应用程序的应用或人类（即*主体*）的身份。例如，应用程序通常验证主体的凭据，如用户ID和密码或应用程序的API密钥和密钥。'
- en: '***Authorization*—** Verifying that the principal is allowed to perform the
    requested operation on the specified data. Applications often use a combination
    of role-based security and access control lists (ACLs). Role-based security assigns
    each user one or more roles that grant them permission to invoke particular operations.
    ACLs grant users or roles permission to perform an operation on a particular business
    object, or aggregate.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***授权***—**验证主体是否被允许在指定数据上执行请求的操作。应用程序通常结合使用基于角色的安全和访问控制列表（ACL）。基于角色的安全为每个用户分配一个或多个角色，授予他们调用特定操作的权限。ACL授予用户或角色在特定业务对象或聚合上执行操作的权限。'
- en: '***Auditing*—** Tracking the operations that a principal performs in order
    to detect security issues, help customer support, and enforce compliance.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***审计***—**跟踪主体执行的操作，以检测安全问题、帮助客户支持和执行合规性。'
- en: '***Secure interprocess communication*—** Ideally, all communication in and
    out of services should be over Transport Layer Security (TLS). Interservice communication
    may even need to use authentication.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***安全进程间通信***—**理想情况下，所有服务内部和外部通信都应通过传输层安全性（TLS）进行。服务间通信甚至可能需要使用身份验证。'
- en: I describe auditing in detail in [section 11.3](#ch11lev1sec3) and touch on
    securing interservice communication when discussing service meshes in [section
    11.4.1](#ch11lev2sec11). This section focuses on implementing authentication and
    authorization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第11.3节](#ch11lev1sec3)中详细介绍了审计，并在[第11.4.1节](#ch11lev2sec11)讨论服务网格时简要提到了保护服务间通信。本节重点介绍实现身份验证和授权。
- en: I begin by first describing how security is implemented in the FTGO monolith
    application. I then describe the challenges with implementing security in a microservice
    architecture and how techniques that work well in a monolithic architecture can’t
    be used in a microservice architecture. After that I cover how to implement security
    in a microservice architecture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先描述FTGO单体应用程序中安全实现的细节。然后，我描述在微服务架构中实现安全的挑战，以及为什么在单体架构中效果良好的技术不能用于微服务架构。之后，我将介绍如何在微服务架构中实现安全。
- en: Let’s start by reviewing how the monolithic FTGO application handles security.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下单体FTGO应用程序如何处理安全。
- en: 11.1.1\. Overview of security in a traditional monolithic application
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1\. 传统单体应用程序中的安全概述
- en: The FTGO application has several kinds of human users, including consumers,
    couriers, and restaurant staff. They access the application using browser-based
    web applications and mobile applications. All FTGO users must log in to access
    the application. [Figure 11.1](#ch11fig01) shows how the clients of the monolithic
    FTGO application authenticate and make requests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序有几种人类用户，包括消费者、快递员和餐厅员工。他们通过基于浏览器的Web应用程序和移动应用程序访问应用程序。所有FTGO用户都必须登录才能访问应用程序。[图11.1](#ch11fig01)展示了单体FTGO应用程序的客户端如何进行身份验证和发出请求。
- en: Figure 11.1\. A client of the FTGO application first logs in to obtain a session
    token, which is often a cookie. The client includes the session token in each
    subsequent request it makes to the application.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1\. FTGO应用程序的客户端首先登录以获取会话令牌，这通常是一个cookie。客户端在其向应用程序发出的每个后续请求中都包含会话令牌。
- en: '![](Images/11fig01_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig01_alt.jpg)'
- en: When a user logs in with their user ID and password, the client makes a POST
    request containing the user’s credentials to the FTGO application. The FTGO application
    verifies the credentials and returns a session token to the client. The client
    includes the session token in each subsequent request to the FTGO application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用用户ID和密码登录时，客户端向FTGO应用程序发出包含用户凭据的POST请求。FTGO应用程序验证凭据并返回会话令牌给客户端。客户端在其向FTGO应用程序发出的每个后续请求中都包含会话令牌。
- en: '[Figure 11.2](#ch11fig02) shows a high-level view of how the FTGO application
    implements security. The FTGO application is written in Java and uses the Spring
    Security framework, but I’ll describe the design using generic terms that are
    applicable to other frameworks, such as Passport for NodeJS.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.2](#ch11fig02)展示了FTGO应用程序实现安全的高级视图。FTGO应用程序是用Java编写的，并使用Spring Security框架，但我会使用适用于其他框架的通用术语来描述设计，例如NodeJS的Passport。'
- en: Figure 11.2\. When a client of the FTGO application makes a login request, `Login
    Handler` authenticates the user, initializes the session user information, and
    returns a session token cookie, which securely identifies the session. Next, when
    the client makes a request containing the session token, `SessionBasedSecurityInterceptor`
    retrieves the user information from the specified session and establishes the
    security context. Request handlers, such as `OrderDetailsRequestHandler`, retrieve
    the user information from the security context.
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2\. 当FTGO应用程序的客户端发起登录请求时，`Login Handler`验证用户，初始化会话用户信息，并返回一个会话令牌cookie，该cookie安全地标识会话。接下来，当客户端发出包含会话令牌的请求时，`SessionBasedSecurityInterceptor`从指定的会话中检索用户信息并建立安全上下文。请求处理器，如`OrderDetailsRequestHandler`，从安全上下文中检索用户信息。
- en: '![](Images/11fig02_alt.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig02_alt.jpg)'
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using a security framework**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用安全框架**'
- en: 'Implementing authentication and authorization correctly is challenging. It’s
    best to use a proven security framework. Which framework to use depends on your
    application’s technology stack. Some popular frameworks include the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正确实现身份验证和授权具有挑战性。最好使用经过验证的安全框架。选择哪个框架取决于你的应用程序的技术堆栈。以下是一些流行的框架：
- en: '*Spring Security* ([https://projects.spring.io/spring-security/](https://projects.spring.io/spring-security/))—A
    popular framework for Java applications. It’s a sophisticated framework that handles
    authentication and authorization.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Security* ([https://projects.spring.io/spring-security/](https://projects.spring.io/spring-security/))—Java应用程序的流行框架。它是一个复杂的框架，用于处理身份验证和授权。'
- en: '*Apache Shiro* ([https://shiro.apache.org](https://shiro.apache.org))—Another
    Java framework.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apache Shiro* ([https://shiro.apache.org](https://shiro.apache.org))—另一个Java框架。'
- en: '*Passport* ([http://www.passportjs.org](http://www.passportjs.org))—A popular
    security framework for NodeJS applications that’s focused on authentication.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Passport* ([http://www.passportjs.org](http://www.passportjs.org))—一个专注于身份验证的NodeJS应用程序的流行安全框架。'
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: One key part of the security architecture is the session, which stores the principal’s
    ID and roles. The FTGO application is a traditional Java EE application, so the
    session is an `HttpSession` in-memory session. A *session* is identified by a
    session token, which the client includes in each request. It’s usually an opaque
    token such as a cryptographically strong random number. The FTGO application’s
    session token is an HTTP cookie called `JSESSIONID`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安全架构的一个关键部分是会话，它存储主体的ID和角色。FTGO应用程序是一个传统的Java EE应用程序，因此会话是一个内存中的`HttpSession`。会话通过会话令牌来识别，客户端将其包含在每个请求中。它通常是一个不透明的令牌，如具有强密码学随机数的令牌。FTGO应用程序的会话令牌是一个名为`JSESSIONID`的HTTP
    cookie。
- en: The other key part of the security implementation is the security *context*,
    which stores information about the user making the current request. The Spring
    Security framework uses the standard Java EE approach of storing the security
    context in a static, thread-local variable, which is readily accessible to any
    code that’s invoked to handle the request. A request handler can call `SecurityContextHolder.getContext().getAuthentication()`
    to obtain information about the current user, such as their identity and roles.
    In contrast, the Passport framework stores the security context as the `user`
    attribute of the `request`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安全实现的其他关键部分是安全*上下文*，它存储有关当前请求的用户的信息。Spring Security框架使用标准的Java EE方法，将安全上下文存储在静态的、线程局部变量中，这使得任何被调用以处理请求的代码都可以轻松访问。请求处理器可以调用`SecurityContextHolder.getContext().getAuthentication()`来获取有关当前用户的信息，例如其身份和角色。相比之下，Passport框架将安全上下文存储为`request`的`user`属性。
- en: 'The sequence of events shown in [Figure 11.2](#ch11fig02) is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.2](#ch11fig02)中显示的事件序列如下：'
- en: The client makes a login request to the FTGO application.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向FTGO应用程序发起登录请求。
- en: The login request is handled by `LoginHandler`, which verifies the credentials,
    creates the session, and stores information about the principal in the session.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录请求由`LoginHandler`处理，该处理器验证凭据，创建会话，并在会话中存储有关主体的信息。
- en: '`Login Handler` returns a session token to the client.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Login Handler`向客户端返回一个会话令牌。'
- en: The client includes the session token in requests that invoke operations.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端在其调用操作的请求中包含会话令牌。
- en: These requests are first processed by `SessionBasedSecurityInterceptor`. The
    interceptor authenticates each request by verifying the session token and establishes
    a security context. The security context describes the principal and its roles.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些请求首先由`SessionBasedSecurityInterceptor`处理。拦截器通过验证会话令牌来验证每个请求，并建立安全上下文。安全上下文描述了主体及其角色。
- en: A request handler uses the security context to determine whether to allow a
    user to perform the requested operation and obtain their identity.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求处理器使用安全上下文来确定是否允许用户执行请求的操作并获取其身份。
- en: The FTGO application uses *role-based* authorization. It defines several roles
    corresponding to the different kinds of users, including `CONSUMER`, `RESTAURANT`,
    `COURIER`, and `ADMIN`. It uses Spring Security’s declarative security mechanism
    to restrict access to URLs and service methods to specific roles. Roles are also
    interwoven into the business logic. For example, a consumer can only access their
    orders, whereas an administrator can access all orders.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序使用*基于角色的*授权。它定义了几个与不同类型用户相对应的角色，包括`CONSUMER`、`RESTAURANT`、`COURIER`和`ADMIN`。它使用Spring
    Security的声明式安全机制来限制对URL和服务方法的访问，仅限于特定角色。角色也编织到业务逻辑中。例如，消费者只能访问他们的订单，而管理员可以访问所有订单。
- en: The security design used by the monolithic FTGO application is only one possible
    way to implement security. For example, one drawback of using an in-memory session
    is that it requires all requests for a particular session to be routed to the
    same application instance. This requirement complicates load balancing and operations.
    You must, for example, implement a session draining mechanism that waits for all
    sessions to expire before shutting down an application instance. An alternative
    approach, which avoids these problems, is to store the session in a database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 单体FTGO应用所使用的安全设计只是实现安全的一种可能方式。例如，使用内存中会话的一个缺点是它要求所有特定会话的请求都路由到同一个应用实例。这一要求使得负载均衡和操作变得复杂。例如，你必须实现一个会话排空机制，在关闭应用实例之前等待所有会话过期。一种避免这些问题的替代方法是将会话存储在数据库中。
- en: You can sometimes eliminate the server-side session entirely. For example, many
    applications have API clients that provide their credentials, such as an API key
    and secret, in every request. As a result, there’s no need to maintain a server-side
    session. Alternatively, the application can store session state in the session
    token. Later in this section, I describe one way to use a session token to store
    the session state. But let’s begin by looking at the challenges of implementing
    security in a microservice architecture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可以完全消除服务器端会话。例如，许多应用程序都有API客户端，它们在每次请求中都提供其凭证，例如API密钥和密钥。因此，不需要维护服务器端会话。或者，应用程序可以将会话状态存储在会话令牌中。在本节稍后，我将描述一种使用会话令牌存储会话状态的方法。但让我们首先看看在微服务架构中实现安全的挑战。
- en: 11.1.2\. Implementing security in a microservice architecture
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2. 在微服务架构中实现安全
- en: A microservice architecture is a distributed architecture. Each external request
    is handled by the API gateway and at least one service. Consider, for example,
    the `getOrderDetails()` query, discussed in [chapter 8](kindle_split_016.xhtml#ch08).
    The API gateway handles this query by invoking several services, including `Order
    Service`, `Kitchen Service`, and `Accounting Service`. Each service must implement
    some aspects of security. For instance, `Order Service` must only allow a consumer
    to see their orders, which requires a combination of authentication and authorization.
    In order to implement security in a microservice architecture we need to determine
    who is responsible for authenticating the user and who is responsible for authorization.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一种分布式架构。每个外部请求都由API网关和至少一个服务处理。例如，考虑第8章中讨论的`getOrderDetails()`查询。API网关通过调用多个服务来处理这个查询，包括`订单服务`、`厨房服务`和`会计服务`。每个服务都必须实现一些安全方面。例如，`订单服务`必须只允许消费者查看他们的订单，这需要认证和授权的组合。为了在微服务架构中实现安全，我们需要确定谁负责认证用户，谁负责授权。
- en: 'One challenge with implementing security in a microservices application is
    that we can’t just copy the design from a monolithic application. That’s because
    two aspects of the monolithic application’s security architecture are nonstarters
    for a microservice architecture:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务应用程序中实现安全的一个挑战是我们不能简单地从单体应用程序复制设计。这是因为单体应用程序安全架构的两个方面对于微服务架构来说是不切实际的：
- en: '***In-memory security context*—** Using an in-memory security context, such
    as a thread-local, to pass around user identity. Services can’t share memory,
    so they can’t use an in-memory security context, such as a thread-local, to pass
    around the user identity. In a microservice architecture, we need a different
    mechanism for passing user identity from one service to another.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存安全上下文**—**使用内存安全上下文，如线程局部，来传递用户身份。由于服务不能共享内存，因此它们不能使用内存安全上下文，如线程局部，来传递用户身份。在微服务架构中，我们需要一种不同的机制来从一个服务传递用户身份到另一个服务。'
- en: '***Centralized session*—** Because an in-memory security context doesn’t make
    sense, neither does an in-memory session. In theory, multiple services could access
    a database-based session, except that it would violate the principle of loose
    coupling. We need a different session mechanism in a microservice architecture.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式会话**—**由于内存安全上下文没有意义，内存会话也没有意义。理论上，多个服务可以访问基于数据库的会话，但这会违反松耦合原则。在微服务架构中，我们需要不同的会话机制。'
- en: Let’s begin our exploration of security in a microservice architecture by looking
    at how to handle authentication.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过看看如何处理认证来开始我们对微服务架构中安全的探索。
- en: Handling authentication in the API gateway
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在API网关中处理身份验证
- en: There are a couple of different ways to handle authentication. One option is
    for the individual services to authenticate the user. The problem with this approach
    is that it permits unauthenticated requests to enter the internal network. It
    relies on every development team correctly implementing security in all of their
    services. As a result, there’s a significant risk of an application containing
    security vulnerabilities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 处理身份验证有几种不同的方法。一种选择是让各个服务单独对用户进行身份验证。这种方法的缺点是它允许未经身份验证的请求进入内部网络。它依赖于每个开发团队在其所有服务中正确实现安全性。因此，存在应用程序包含安全漏洞的重大风险。
- en: Another problem with implementing authentication in the services is that different
    clients authenticate in different ways. Pure API clients supply credentials with
    each request using, for example, basic authentication. Other clients might first
    log in and then supply a session token with each request. We want to avoid requiring
    services to handle a diverse set of authentication mechanisms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中实现身份验证的另一个问题是不同的客户端以不同的方式身份验证。纯API客户端在每个请求中提供凭证，例如使用基本身份验证。其他客户端可能首先登录，然后在每个请求中提供会话令牌。我们希望避免要求服务处理各种不同的身份验证机制。
- en: A better approach is for the API gateway to authenticate a request before forwarding
    it to the services. Centralizing API authentication in the API gateway has the
    advantage that there’s only one place to get right. As a result, there’s a much
    smaller chance of a security vulnerability. Another benefit is that only the API
    gateway has to deal with the various different authentication mechanisms. It hides
    this complexity from the services.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是让API网关在将请求转发到服务之前先对请求进行身份验证。在API网关中集中处理API身份验证的优势在于，只有一个地方需要正确设置。因此，安全漏洞的风险大大降低。另一个好处是，只有API网关需要处理各种不同的身份验证机制。它将这种复杂性隐藏在服务之外。
- en: '[Figure 11.3](#ch11fig03) shows how this approach works. Clients authenticate
    with the API gateway. API clients include credentials in each request. Login-based
    clients `POST` the user’s credentials to the API gateway’s authentication and
    receive a session token. Once the API gateway has authenticated a request, it
    invokes one or more services.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.3](#ch11fig03)展示了这种方法是如何工作的。客户端与API网关进行身份验证。API客户端在每个请求中包含凭证。基于登录的客户端将用户的凭证`POST`到API网关的认证，并接收一个会话令牌。一旦API网关验证了请求，它就会调用一个或多个服务。'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Access token**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：访问令牌**'
- en: The API gateway passes a token containing information about the user, such as
    their identity and their roles, to the services that it invokes. See [http://microservices.io/patterns/security/access-token.html](http://microservices.io/patterns/security/access-token.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: API网关将包含用户信息（如身份和角色）的令牌传递给它调用的服务。请参阅[http://microservices.io/patterns/security/access-token.html](http://microservices.io/patterns/security/access-token.html)。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 11.3\. The API gateway authenticates requests from clients and includes
    a security token in the requests it makes to services. The services use the token
    to obtain information about the principal. The API gateway can also use the security
    token as a session token.
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3。API网关对客户端的请求进行身份验证，并在对服务发出的请求中包含安全令牌。服务使用令牌来获取有关主体的信息。API网关还可以将安全令牌用作会话令牌。
- en: '![](Images/11fig03_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig03_alt.jpg)'
- en: A service invoked by the API gateway needs to know the principal making the
    request. It must also verify that the request has been authenticated. The solution
    is for the API gateway to include a token in each service request. The service
    uses the token to validate the request and obtain information about the principal.
    The API gateway might also give the same token to session-oriented clients to
    use as the session token.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由API网关调用的服务需要知道发起请求的主体。它还必须验证请求是否已通过身份验证。解决方案是API网关在每个服务请求中包含一个令牌。服务使用该令牌来验证请求并获取有关主体的信息。API网关还可能将相同的令牌提供给面向会话的客户端，供其作为会话令牌使用。
- en: 'The sequence of events for API clients is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: API客户端的事件序列如下：
- en: A client makes a request containing credentials.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发出包含凭证的请求。
- en: The API gateway authenticates the credentials, creates a security token, and
    passes that to the service or services.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关验证凭证，创建安全令牌，并将其传递给服务或多个服务。
- en: 'The sequence of events for login-based clients is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基于登录的客户端的事件序列如下：
- en: A client makes a login request containing credentials.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发起一个包含凭证的登录请求。
- en: The API gateway returns a security token.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关返回一个安全令牌。
- en: The client includes the security token in requests that invoke operations.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端在调用操作的请求中包含安全令牌。
- en: The API gateway validates the security token and forwards it to the service
    or services.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关验证安全令牌并将其转发到服务或服务。
- en: 'A little later in this chapter, I describe how to implement tokens, but let’s
    first look at the other main aspect of security: authorization.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后，我将描述如何实现令牌，但首先让我们看看安全的另一个主要方面：授权。
- en: Handling authorization
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理授权
- en: Authenticating a client’s credentials is important but insufficient. An application
    must also implement an authorization mechanism that verifies that the client is
    allowed to perform the requested operation. For example, in the FTGO application
    the `getOrderDetails()` query can only be invoked by the consumer who placed the
    `Order` (an example of instance-based security) and a customer service agent who
    is helping the consumer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端凭证的验证很重要，但不足以。应用程序还必须实现一个授权机制，以验证客户端是否有权执行请求的操作。例如，在FTGO应用程序中，`getOrderDetails()`查询只能由放置`Order`（实例化安全的一个例子）的消费者调用，以及帮助消费者的客户服务代表。
- en: One place to implement authorization is the API gateway. It can, for example,
    restrict access to `GET /orders/{orderId}` to only users who are consumers and
    customer service agents. If a user isn’t allowed to access a particular path,
    the API gateway can reject the request before forwarding it on to the service.
    As with authentication, centralizing authorization within the API gateway reduces
    the risk of security vulnerabilities. You can implement authorization in the API
    gateway using a security framework, such as Spring Security.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实现授权的一个地方是API网关。例如，它可以限制对`GET /orders/{orderId}`的访问，仅限于消费者和客户服务代表。如果用户不允许访问特定的路径，API网关可以在将其转发到服务之前拒绝该请求。与身份验证一样，在API网关中集中授权可以降低安全漏洞的风险。您可以使用安全框架，如Spring
    Security，在API网关中实现授权。
- en: One drawback of implementing authorization in the API gateway is that it risks
    coupling the API gateway to the services, requiring them to be updated in lockstep.
    What’s more, the API gateway can typically only implement role-based access to
    URL paths. It’s generally not practical for the API gateway to implement ACLs
    that control access to individual domain objects, because that requires detailed
    knowledge of a service’s domain logic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在API网关中实现授权的一个缺点是，它可能会将API网关与服务耦合，需要它们同步更新。更重要的是，API网关通常只能实现基于角色的对URL路径的访问控制。对于API网关来说，实现控制对单个域对象的访问的ACL（访问控制列表）通常是不切实际的，因为这需要详细了解服务的域逻辑。
- en: The other place to implement authorization is in the services. A service can
    implement role-based authorization for URLs and for service methods. It can also
    implement ACLs to manage access to aggregates. `Order Service` can, for example,
    implement the role-based and ACL-based authorization mechanism for controlling
    access to orders. Other services in the FTGO application implement similar authorization
    logic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实现授权的另一个地方是在服务中。服务可以为URL和服务方法实现基于角色的授权。它还可以实现ACL来管理对聚合的访问。例如，`Order Service`可以实现基于角色和基于ACL的授权机制来控制对订单的访问。FTGO应用程序中的其他服务实现类似的授权逻辑。
- en: Using JWTs to pass user identity and roles
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用JWT传递用户身份和角色
- en: When implementing security in a microservice architecture, you need to decide
    which type of token an API gateway should use to pass user information to the
    services. There are two types of tokens to choose from. One option is to use *opaque*
    tokens, which are typically UUIDs. The downside of opaque tokens is that they
    reduce performance and availability and increase latency. That’s because the recipient
    of such a token must make a synchronous RPC call to a security service to validate
    the token and retrieve the user information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中实现安全时，您需要决定API网关应该使用哪种类型的令牌将用户信息传递给服务。有几种类型的令牌可供选择。一个选项是使用*不透明*令牌，通常是UUID。不透明令牌的缺点是它们会降低性能和可用性，并增加延迟。这是因为令牌的接收者必须向安全服务发出同步RPC调用以验证令牌并检索用户信息。
- en: An alternative approach, which eliminates the call to the security service,
    is to use a *transparent* token containing information about the user. One such
    popular standard for transparent tokens is the JSON Web Token (JWT). JWT is standard
    way to securely represent claims, such as user identity and roles, between two
    parties. A JWT has a payload, which is a JSON object that contains information
    about the user, such as their identity and roles, and other metadata, such as
    an expiration date. It’s signed with a secret that’s only known to the creator
    of the JWT, such as the API gateway and the recipient of the JWT, such as a service.
    The secret ensures that a malicious third party can’t forge or tamper with a JWT.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法，它消除了对安全服务的调用，是使用包含有关用户信息的*透明*令牌。透明令牌的一个流行标准是JSON Web Token（JWT）。JWT是安全表示两个当事人之间声明的标准方式，例如用户身份和角色。JWT有一个有效载荷，它是一个包含有关用户信息的JSON对象，例如他们的身份和角色，以及其他元数据，例如过期日期。它使用只有JWT的创建者（如API网关）和JWT的接收者（如服务）所知的秘密进行签名。秘密确保恶意第三方无法伪造或篡改JWT。
- en: One issue with JWT is that because a token is self-contained, it’s irrevocable.
    By design, a service will perform the request operation after verifying the JWT’s
    signature and expiration date. As a result, there’s no practical way to revoke
    an individual JWT that has fallen into the hands of a malicious third party. The
    solution is to issue JWTs with short expiration times, because that limits what
    a malicious party could do. One drawback of short-lived JWTs, though, is that
    the application must somehow continually reissue JWTs to keep the session active.
    Fortunately, this is one of the many protocols that are solved by a security standard
    calling OAuth 2.0\. Let’s look at how that works.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的一个问题是，由于令牌是自包含的，因此它是不可撤销的。按照设计，服务将在验证JWT签名和过期日期后执行请求操作。因此，没有实际的方法可以撤销落入恶意第三方手中的单个JWT。解决方案是颁发具有短过期时间的JWT，因为这限制了恶意方可能做的事情。然而，短期JWT的一个缺点是，应用程序必须以某种方式不断重新颁发JWT以保持会话活跃。幸运的是，这是许多由名为OAuth
    2.0的安全标准解决的协议之一。让我们看看它是如何工作的。
- en: Using OAuth 2.0 in a microservice architecture
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在微服务架构中使用OAuth 2.0
- en: Let’s say you want to implement a `User Service` for the FTGO application that
    manages a user database containing user information, such as credentials and roles.
    The API gateway calls the `User Service` to authenticate a client request and
    obtain a JWT. You could design a `User Service` API and implement it using your
    favorite web framework. But that’s generic functionality that isn’t specific to
    the FTGO application—developing such a service wouldn’t be an efficient use of
    development resources.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想为FTGO应用程序实现一个`用户服务`，该服务管理包含用户信息（如凭证和角色）的用户数据库。API网关调用`用户服务`以验证客户端请求并获取JWT。您可以为`用户服务`API进行设计并使用您喜欢的Web框架实现它。但这是一种通用的功能，并不特定于FTGO应用程序——开发此类服务不会是开发资源的有效利用。
- en: Fortunately, you don’t need to develop this kind of security infrastructure.
    You can use an off-the-shelf service or framework that implements a standard called
    OAuth 2.0\. OAuth 2.0 is an authorization protocol that was originally designed
    to enable a user of a public cloud service, such as GitHub or Google, to grant
    a third-party application access to its information without revealing its password.
    For example, OAuth 2.0 is the mechanism that enables you to securely grant a third
    party cloud-based Continuous Integration (CI) service access to your GitHub repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您不需要开发这种安全基础设施。您可以使用现成的服务或框架，这些服务或框架实现了名为OAuth 2.0的标准。OAuth 2.0是一种授权协议，最初设计用于允许公共云服务的用户，例如GitHub或Google，在不泄露其密码的情况下，授予第三方应用程序访问其信息的权限。例如，OAuth
    2.0是使您能够安全地授予第三方基于云的持续集成（CI）服务访问您GitHub存储库的机制。
- en: Although the original focus of OAuth 2.0 was authorizing access to public cloud
    services, you can also use it for authentication and authorization in your application.
    Let’s take a quick look at how a microservice architecture might use OAuth 2.0.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OAuth 2.0的原始重点是授权访问公共云服务，但您也可以在您的应用程序中使用它进行身份验证和授权。让我们快速了解一下微服务架构可能如何使用OAuth
    2.0。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**About OAuth 2.0**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于OAuth 2.0**'
- en: OAuth 2.0 is a complex topic. In this chapter, I can only provide a brief overview
    and describe how it can be used in a microservice architecture. For more information
    on OAuth 2.0, check out the online book *OAuth 2.0 Servers* by Aaron Parecki ([www.oauth.com](http://www.oauth.com)).
    [Chapter 7](kindle_split_015.xhtml#ch07) of *Spring Microservices in Action* (Manning,
    2017) also covers this topic ([https://livebook.manning.com/#!/book/spring-microservices-in-action/chapter-7/](https://livebook.manning.com/#!/book/spring-microservices-in-action/chapter-7/)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 是一个复杂的话题。在本章中，我只能提供一个简要概述，并描述它如何在微服务架构中使用。有关 OAuth 2.0 的更多信息，请参阅 Aaron
    Parecki 编写的在线书籍 *OAuth 2.0 Servers* ([www.oauth.com](http://www.oauth.com))。*Spring
    Microservices in Action* (Manning, 2017) 的第 7 章 ([https://livebook.manning.com/#!/book/spring-microservices-in-action/chapter-7/](https://livebook.manning.com/#!/book/spring-microservices-in-action/chapter-7/))
    也涵盖了这一主题。
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The key concepts in OAuth 2.0 are the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 的关键概念如下：
- en: '**`Authorization Server`—** Provides an API for authenticating users and obtaining
    an access token and a refresh token. Spring OAuth is a great example of a framework
    for building an OAuth 2.0 authorization server.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`授权服务器`—** 提供用于验证用户和获取访问令牌和刷新令牌的 API。Spring OAuth 是构建 OAuth 2.0 授权服务器框架的一个很好的例子。'
- en: '**`Access Token`—** A token that grants access to a `Resource Server`. The
    format of the access token is implementation dependent. But some implementations,
    such as Spring OAuth, use JWTs.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`访问令牌`—** 一种授予对 `资源服务器` 访问权限的令牌。访问令牌的格式取决于实现。但某些实现，例如 Spring OAuth，使用 JWT。'
- en: '**`Refresh Token`—** A long-lived yet revocable token that a `Client` uses
    to obtain a new `AccessToken`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`刷新令牌`—** 一个长期有效但可撤销的令牌，客户端使用它来获取新的 `访问令牌`。'
- en: '**`Resource Server`—** A service that uses an access token to authorize access.
    In a microservice architecture, the services are resource servers.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`资源服务器`—** 使用访问令牌来授权访问的服务。在微服务架构中，服务是资源服务器。'
- en: '**`Client`—** A client that wants to access a `Resource Server`. In a microservice
    architecture, `API Gateway` is the OAuth 2.0 client.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`客户端`—** 想要访问 `资源服务器` 的客户端。在微服务架构中，`API 网关` 是 OAuth 2.0 客户端。'
- en: Later in this section, I describe how to support login-based clients. But first,
    let’s talk about how to authenticate API clients.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节后面，我将描述如何支持基于登录的客户端。但首先，让我们谈谈如何验证 API 客户端。
- en: '[Figure 11.4](#ch11fig04) shows how the API gateway authenticates a request
    from an API client. The API gateway authenticate the API client by making a request
    to the OAuth 2.0 authorization server, which returns an access token. The API
    gateway then makes one or more requests containing the access token to the services.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.4](#ch11fig04) 展示了 API 网关如何验证来自 API 客户端的请求。API 网关通过向 OAuth 2.0 授权服务器发送请求来验证
    API 客户端，该服务器返回一个访问令牌。然后，API 网关向服务发送包含访问令牌的一个或多个请求。'
- en: Figure 11.4\. An API gateway authenticates an API client by making a Password
    Grant request to the OAuth 2.0 authentication server. The server returns an access
    token, which the API gateway passes to the services. A service verifies the token’s
    signature and extracts information about the user, including their identity and
    roles.
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.4\. API 网关通过向 OAuth 2.0 认证服务器发送密码授权请求来验证 API 客户端。服务器返回一个访问令牌，API 网关将其传递给服务。服务验证令牌的签名并提取有关用户的信息，包括他们的身份和角色。
- en: '![](Images/11fig04_alt.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig04_alt.jpg)'
- en: 'The sequence of events shown in [figure 11.4](#ch11fig04) is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.4](#ch11fig04) 中所示的事件序列如下：'
- en: The client makes a request, supplying its credentials using basic authentication.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端通过基本身份验证提供其凭据来发送请求。
- en: The API gateway makes an OAuth 2.0 Password Grant request ([www.oauth.com/oauth2-servers/access-tokens/password-grant/](http://www.oauth.com/oauth2-servers/access-tokens/password-grant/))
    to the OAuth 2.0 authentication server.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 网关向 OAuth 2.0 认证服务器发送 OAuth 2.0 密码授权请求 ([www.oauth.com/oauth2-servers/access-tokens/password-grant/](http://www.oauth.com/oauth2-servers/access-tokens/password-grant/))。
- en: The authentication server validates the API client’s credentials and returns
    an access token and a refresh token.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证服务器验证 API 客户端的凭据，并返回一个访问令牌和一个刷新令牌。
- en: The API gateway includes the access token in the requests it makes to the services.
    A service validates the access token and uses it to authorize the request.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 网关将其请求中包含的访问令牌传递给服务。服务验证访问令牌并使用它来授权请求。
- en: An OAuth 2.0-based API gateway can authenticate session-oriented clients by
    using an OAuth 2.0 access token as a session token. What’s more, when the access
    token expires, it can obtain a new access token using the refresh token. [Figure
    11.5](#ch11fig05) shows how an API gateway can use OAuth 2.0 to handle session-oriented
    clients. An API client initiates a session by POSTing its credentials to the API
    gateway’s `/login` endpoint. The API gateway returns an access token and a refresh
    token to the client. The API client then supplies both tokens when it makes requests
    to the API gateway.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于OAuth 2.0的API网关可以通过使用OAuth 2.0访问令牌作为会话令牌来验证面向会话的客户端。更重要的是，当访问令牌过期时，它可以使用刷新令牌获取新的访问令牌。[图11.5](#ch11fig05)展示了API网关如何使用OAuth
    2.0处理面向会话的客户端。API客户端通过向API网关的`/login`端点POST其凭据来启动会话。API网关向客户端返回访问令牌和刷新令牌。然后，API客户端在向API网关发出请求时提供这两个令牌。
- en: Figure 11.5\. A client logs in by POSTing its credentials to the API gateway.
    The API gateway authenticates the credentials using the OAuth 2.0 authentication
    server and returns the access token and refresh token as cookies. A client includes
    these tokens in the requests it makes to the API gateway.
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.5。客户端通过将凭据POST到API网关来登录。API网关使用OAuth 2.0认证服务器验证凭据，并将访问令牌和刷新令牌作为cookie返回。客户端将这些令牌包含在它向API网关发出的请求中。
- en: '![](Images/11fig05_alt.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig05_alt.jpg)'
- en: 'The sequence of events is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列如下：
- en: The login-based client POSTs its credentials to the API gateway.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于登录的客户端将其凭据POST到API网关。
- en: The API gateway’s `Login Handler` makes an OAuth 2.0 Password Grant request
    ([www.oauth.com/oauth2-servers/access-tokens/password-grant/](http://www.oauth.com/oauth2-servers/access-tokens/password-grant/))
    to the OAuth 2.0 authentication server.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关的`登录处理器`向OAuth 2.0认证服务器发出OAuth 2.0密码授权请求([www.oauth.com/oauth2-servers/access-tokens/password-grant/](http://www.oauth.com/oauth2-servers/access-tokens/password-grant/))。
- en: The authentication server validates the client’s credentials and returns an
    access token and a refresh token.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证服务器验证客户端的凭据，并返回访问令牌和刷新令牌。
- en: The API gateway returns the access and refresh tokens to the client—as cookies,
    for example.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关将访问和刷新令牌返回给客户端——例如，作为cookie。
- en: The client includes the access and refresh tokens in requests it makes to the
    API gateway.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将其访问和刷新令牌包含在它向API网关发出的请求中。
- en: The API gateway’s `Session Authentication Interceptor` validates the access
    token and includes it in requests it makes to the services.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关的`会话认证拦截器`验证访问令牌，并将其包含在它向服务发出的请求中。
- en: If the access token has expired or is about to expire, the API gateway obtains
    a new access token by making an OAuth 2.0 Refresh Grant request ([www.oauth.com/oauth2-servers/access-tokens/refreshing-access-tokens/](http://www.oauth.com/oauth2-servers/access-tokens/refreshing-access-tokens/)),
    which contains the refresh token, to the authorization server. If the refresh
    token hasn’t expired or been revoked, the authorization server returns a new access
    token. `API Gateway` passes the new access token to the services and returns it
    to the client.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果访问令牌已过期或即将过期，API网关通过向授权服务器发出包含刷新令牌的OAuth 2.0刷新授权请求([www.oauth.com/oauth2-servers/access-tokens/refreshing-access-tokens/](http://www.oauth.com/oauth2-servers/access-tokens/refreshing-access-tokens/))来获取新的访问令牌。如果刷新令牌尚未过期或未被撤销，授权服务器将返回一个新的访问令牌。`API网关`将新的访问令牌传递给服务并返回给客户端。
- en: 'An important benefit of using OAuth 2.0 is that it’s a proven security standard.
    Using an off-the-shelf OAuth 2.0 `Authentication Server` means you don’t have
    to waste time reinventing the wheel or risk developing an insecure design. But
    OAuth 2.0 isn’t the only way to implement security in a microservice architecture.
    Regardless of which approach you use, the three key ideas are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0的一个重要好处是它是一个经过验证的安全标准。使用现成的OAuth 2.0 `认证服务器`意味着你不必浪费时间重新发明轮子或冒着开发不安全设计的风险。但OAuth
    2.0并不是在微服务架构中实现安全性的唯一方式。无论你使用哪种方法，三个关键思想如下：
- en: The API gateway is responsible for authenticating clients.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关负责验证客户端。
- en: The API gateway and the services use a transparent token, such as a JWT, to
    pass around information about the principal.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关和服务使用一个透明的令牌，例如JWT，来传递有关主体的信息。
- en: A service uses the token to obtain the principal’s identity and roles.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务使用令牌来获取主体的身份和角色。
- en: Now that we’ve looked at how to make services secure, let’s see how to make
    them configurable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使服务安全，让我们看看如何使它们可配置。
- en: 11.2\. Designing configurable services
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 设计可配置的服务
- en: Imagine that you’re responsible for `Order History Service`. As [figure 11.6](#ch11fig06)
    shows, the service consumes events from Apache Kafka and reads and writes AWS
    DynamoDB table items. In order for this service to run, it needs various configuration
    properties, including the network location of Apache Kafka and the credentials
    and network location for AWS DynamoDB.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责`订单历史服务`。如图11.6所示，该服务从Apache Kafka消费事件，并读取和写入AWS DynamoDB表项。为了使此服务运行，它需要各种配置属性，包括Apache
    Kafka的网络位置以及AWS DynamoDB的凭证和网络位置。
- en: Figure 11.6\. `Order History Service` uses Apache Kafka and AWS DynamoDB. It
    needs to be configured with each service’s network location, credentials, and
    so on.
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.6\. `订单历史服务`使用Apache Kafka和AWS DynamoDB。它需要配置每个服务的网络位置、凭证等。
- en: '![](Images/11fig06_alt.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig06_alt.jpg)'
- en: The values of these configuration properties depend on which environment the
    service is running in. For example, the developer and production environments
    will use different Apache Kafka brokers and different AWS credentials. It doesn’t
    make sense to hard-wire a particular environment’s configuration property values
    into the deployable service because that would require it to be rebuilt for each
    environment. Instead, a service should be built once by the deployment pipeline
    and deployed into multiple environments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置属性的值取决于服务运行的环境。例如，开发和生产环境将使用不同的Apache Kafka代理和不同的AWS凭证。将特定环境的配置属性值硬编码到可部署的服务中是没有意义的，因为这需要为每个环境重新构建它。相反，服务应由部署管道构建一次，然后部署到多个环境中。
- en: Nor does it make sense to hard-wire different sets of configuration properties
    into the source code and use, for example, the Spring Framework’s profile mechanism
    to select the appropriate set at runtime. That’s because doing so would introduce
    a security vulnerability and limit where it can be deployed. Additionally, sensitive
    data such as credentials should be stored securely using a secrets storage mechanism,
    such as Hashicorp Vault ([www.vaultproject.io](http://www.vaultproject.io)) or
    AWS Parameter Store ([https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html)).
    Instead, you should supply the appropriate configuration properties to the service
    at runtime by using the Externalized configuration pattern.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将不同的配置属性集硬编码到源代码中，并使用例如Spring框架的配置文件机制在运行时选择适当的集合，也没有意义。这样做会引入安全漏洞并限制其部署位置。此外，敏感数据，如凭证，应使用如Hashicorp
    Vault ([www.vaultproject.io](http://www.vaultproject.io)) 或AWS参数存储 ([https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html))
    这样的秘密存储机制安全存储。相反，您应该通过使用外部化配置模式在运行时向服务提供适当的配置属性。
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Externalized configuration**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：外部化配置**'
- en: Supply configuration property values, such as database credentials and network
    location, to a service at runtime. See [http://microservices.io/patterns/externalized-configuration.html](http://microservices.io/patterns/externalized-configuration.html).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时向服务提供配置属性值，例如数据库凭证和网络位置。请参阅 [http://microservices.io/patterns/externalized-configuration.html](http://microservices.io/patterns/externalized-configuration.html)。
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'An externalized configuration mechanism provides the configuration property
    values to a service instance at runtime. There are two main approaches:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 外部化配置机制在运行时向服务实例提供配置属性值。主要有两种方法：
- en: '***Push model*—** The deployment infrastructure passes the configuration properties
    to the service instance using, for example, operating system environment variables
    or a configuration file.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***推送模型*—** 部署基础设施通过例如操作系统环境变量或配置文件将配置属性传递给服务实例。'
- en: '***Pull model*—** The service instance reads its configuration properties from
    a configuration server.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***拉模型*—** 服务实例从配置服务器读取其配置属性。'
- en: We’ll look at each approach, starting with the push model.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨每种方法，从推送模型开始。
- en: 11.2.1\. Using push-based externalized configuration
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1\. 使用基于推送的外部化配置
- en: The push model relies on the collaboration of the deployment environment and
    the service. The deployment environment supplies the configuration properties
    when it creates a service instance. It might, as [figure 11.7](#ch11fig07) shows,
    pass the configuration properties as environment variables. Alternatively, the
    deployment environment may supply the configuration properties using a configuration
    file. The service instance then reads the configuration properties when it starts
    up.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 推送模型依赖于部署环境和服务的协作。当部署环境创建服务实例时，它会提供配置属性。如图11.7所示，它可能将配置属性作为环境变量传递。或者，部署环境也可以使用配置文件来提供配置属性。服务实例在启动时会读取这些配置属性。
- en: Figure 11.7\. When the deployment infrastructure creates an instance of `Order
    History Service`, it sets the environment variables containing the externalized
    configuration. `Order History Service` reads those environment variables.
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.7。当部署基础设施创建`订单历史服务`的实例时，它会设置包含外部化配置的环境变量。`订单历史服务`会读取这些环境变量。
- en: '![](Images/11fig07_alt.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7](Images/11fig07_alt.jpg)'
- en: The deployment environment and the service must agree on how the configuration
    properties are supplied. The precise mechanism depends on the specific deployment
    environment. For example, [chapter 12](kindle_split_020.xhtml#ch12) describes
    how you can specify the environment variables of a Docker container.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 部署环境和服务必须就配置属性的提供方式达成一致。确切的机制取决于特定的部署环境。例如，[第12章](kindle_split_020.xhtml#ch12)描述了如何指定Docker容器的环境变量。
- en: Let’s imagine that you’ve decided to supply externalized configuration property
    values using environment variables. Your application could call `System.getenv()`
    to obtain their values. But if you’re a Java developer, it’s likely that you’re
    using a framework that provides a more convenient mechanism. The FTGO services
    are built using Spring Boot, which has an extremely flexible externalized configuration
    mechanism that retrieves configuration properties from a variety of sources with
    well-defined precedence rules ([https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html)).
    Let’s look at how it works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你已经决定使用环境变量来提供外部化配置属性的值。你的应用程序可以调用`System.getenv()`来获取它们的值。但如果你是Java开发者，你很可能正在使用一个提供更方便机制的框架。FTGO服务是使用Spring
    Boot构建的，它具有非常灵活的外部化配置机制，可以从各种来源检索配置属性，并具有定义良好的优先级规则（[https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html)）。让我们看看它是如何工作的。
- en: 'Spring Boot reads properties from a variety of sources. I find the following
    sources useful in a microservice architecture:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot从各种来源读取属性。我发现以下来源在微服务架构中很有用：
- en: Command-line arguments
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: '`SPRING_APPLICATION_JSON`, an operating system environment variable or JVM
    system property that contains JSON'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SPRING_APPLICATION_JSON`，一个包含JSON的操作系统环境变量或JVM系统属性'
- en: JVM System properties
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM系统属性
- en: Operating system environment variables
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统环境变量
- en: A configuration file in the current directory
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前目录下的配置文件
- en: A particular property value from a source earlier in this list overrides the
    same property from a source later in this list. For example, operating system
    environment variables override properties read from a configuration file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中较早来源的特定属性值会覆盖列表中较晚来源的相同属性。例如，操作系统环境变量会覆盖从配置文件中读取的属性。
- en: 'Spring Boot makes these properties available to the Spring Framework’s `ApplicationContext`.
    A service can, for example, obtain the value of a property using the `@Value`
    annotation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot将这些属性提供给Spring框架的`ApplicationContext`。例如，一个服务可以使用`@Value`注解来获取属性的值：
- en: '[PRE0]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Spring Framework initializes the `awsRegion` field to the value of the `aws.region`
    property. This property is read from one of the sources listed earlier, such as
    a configuration file or from the `AWS_REGION` environment variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架将`awsRegion`字段初始化为`aws.region`属性的值。这个属性是从前面列出的某个来源读取的，例如配置文件或`AWS_REGION`环境变量。
- en: The push model is an effective and widely used mechanism for configuring a service.
    One limitation, however, is that reconfiguring a running service might be challenging,
    if not impossible. The deployment infrastructure might not allow you to change
    the externalized configuration of a running service without restarting it. You
    can’t, for example, change the environment variables of a running process. Another
    limitation is that there’s a risk of the configuration property values being scattered
    throughout the definition of numerous services. As a result, you may want to consider
    using a pull-based model. Let’s look at how it works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 推送模型是配置服务的一种有效且广泛使用的机制。然而，一个限制是，重新配置运行中的服务可能具有挑战性，甚至可能不可能。部署基础设施可能不允许在不重新启动的情况下更改运行服务的配置属性。例如，您不能更改运行进程的环境变量。另一个限制是，配置属性值可能会分散在多个服务的定义中，存在风险。因此，您可能希望考虑使用基于拉的模型。让我们看看它是如何工作的。
- en: 11.2.2\. Using pull-based externalized configuration
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2\. 使用基于拉的配置外部化
- en: In the pull model, a service instance reads its configuration properties from
    a configuration server. [Figure 11.8](#ch11fig08) shows how it works. On startup,
    a service instance queries the configuration service for its configuration. The
    configuration properties for accessing the configuration server, such as its network
    location, are provided to the service instance via a push-based configuration
    mechanism, such as environment variables.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉模型中，服务实例从配置服务器读取其配置属性。[图 11.8](#ch11fig08) 展示了它是如何工作的。在启动时，服务实例查询配置服务以获取其配置。访问配置服务器的配置属性，如其网络位置，通过基于推送的配置机制（如环境变量）提供给服务实例。
- en: Figure 11.8\. On startup, a service instance retrieves its configuration properties
    from a configuration server. The deployment infrastructure provides the configuration
    properties for accessing the configuration server.
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.8\. 在启动时，服务实例从配置服务器检索其配置属性。部署基础设施提供了访问配置服务器的配置属性。
- en: '![](Images/11fig08_alt.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig08_alt.jpg)'
- en: 'There are a variety of ways to implement a configuration server, including
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实现配置服务器有多种方式，包括以下几种：
- en: Version control system such as Git
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制系统，如 Git
- en: SQL and NoSQL databases
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 和 NoSQL 数据库
- en: Specialized configuration servers, such as Spring Cloud Config Server, Hashicorp
    Vault, which is a store for sensitive data such as credentials, and AWS Parameter
    Store
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门的配置服务器，如 Spring Cloud Config Server、Hashicorp Vault（用于存储敏感数据，如凭据）和 AWS Parameter
    Store
- en: The Spring Cloud Config project is a good example of a configuration server-based
    framework. It consists of a server and a client. The server supports a variety
    of backends for storing configuration properties, including version control systems,
    databases, and Hashicorp Vault. The client retrieves configuration properties
    from the server and injects them into the Spring `ApplicationContext`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config 项目是一个基于配置服务器的框架的绝佳示例。它由一个服务器和一个客户端组成。服务器支持多种后端来存储配置属性，包括版本控制系统、数据库和
    Hashicorp Vault。客户端从服务器检索配置属性并将它们注入到 Spring `ApplicationContext` 中。
- en: 'Using a configuration server has several benefits:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置服务器具有几个优点：
- en: '***Centralized configuration*—** All the configuration properties are stored
    in one place, which makes them easier to manage. What’s more, in order to eliminate
    duplicate configuration properties, some implementations let you define global
    defaults, which can be overridden on a per-service basis.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***集中式配置*—** 所有配置属性都存储在一个地方，这使得它们更容易管理。更重要的是，为了消除重复的配置属性，一些实现允许您定义全局默认值，这些默认值可以在每个服务的基础上进行覆盖。'
- en: '***Transparent decryption of sensitive data*—** Encrypting sensitive data such
    as database credentials is a security best practice. One challenge of using encryption,
    though, is that usually the service instance needs to decrypt them, which means
    it needs the encryption keys. Some configuration server implementations automatically
    decrypt properties before returning them to the service.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***透明解密敏感数据*—** 加密敏感数据，如数据库凭据，是安全最佳实践。然而，使用加密的一个挑战是，通常服务实例需要解密它们，这意味着它需要加密密钥。一些配置服务器实现会在将属性返回给服务之前自动解密属性。'
- en: '***Dynamic reconfiguration*—** A service could potentially detect updated property
    values by, for example, polling, and reconfigure itself.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***动态重新配置*—** 服务实例可以通过例如轮询等方式检测更新的属性值，并重新配置自身。'
- en: The primary drawback of using a configuration server is that unless it’s provided
    by the infrastructure, it’s yet another piece of infrastructure that needs to
    be set up and maintained. Fortunately, there are various open source frameworks,
    such as Spring Cloud Config, which make it easier to run a configuration server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置服务的主要缺点是，除非它由基础设施提供，否则它又是一个需要设置和维护的基础设施组件。幸运的是，有各种开源框架，例如Spring Cloud Config，它们使运行配置服务器变得更加容易。
- en: Now that we’ve looked at how to design configurable services, let’s talk about
    how to design observable services.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何设计可配置的服务，让我们谈谈如何设计可观察的服务。
- en: 11.3\. Designing observable services
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 设计可观察的服务
- en: 'Let’s say you’ve deployed the FTGO application into production. You probably
    want to know what the application is doing: requests per second, resource utilization,
    and so on. You also need to be alerted if there’s a problem, such as a failed
    service instance or a disk filling up—ideally before it impacts a user. And, if
    there’s a problem, you need to be able to troubleshoot and identify the root cause.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经将FTGO应用程序部署到生产环境中。你可能想知道应用程序正在做什么：每秒请求次数、资源利用率等等。如果出现问题，例如服务实例失败或磁盘空间不足——理想情况下在影响用户之前——你也需要收到警报。而且，如果出现问题，你需要能够进行故障排除并确定根本原因。
- en: Many aspects of managing an application in production are outside the scope
    of the developer, such as monitoring hardware availability and utilization. These
    are clearly the responsibility of operations. But there are several patterns that
    you, as a service developer, must implement to make your service easier to manage
    and troubleshoot. These patterns, shown in [figure 11.9](#ch11fig09), expose a
    service instance’s behavior and health. They enable a monitoring system to track
    and visualize the state of a service and generate alerts when there’s a problem.
    These patterns also make troubleshooting problems easier.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中管理应用程序的许多方面都不在开发者的职责范围内，例如监控硬件可用性和利用率。这些显然是运维的责任。但作为服务开发者，你必须实现一些模式来使你的服务更容易管理和故障排除。这些模式，如图11.9所示，揭示了服务实例的行为和健康状况。它们使监控系统能够跟踪和可视化服务的状态，并在出现问题时生成警报。这些模式还使问题排除变得更加容易。
- en: Figure 11.9\. The observability patterns enable developers and operations to
    understand the behavior of an application and troubleshoot problems. Developers
    are responsible for ensuring that their services are observable. Operations are
    responsible for the infrastructure that collects the information exposed by the
    services.
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.9\. 可观察性模式使开发者和运维人员能够理解应用程序的行为并排除问题。开发者负责确保他们的服务是可观察的。运维负责收集服务暴露的信息的基础设施。
- en: '![](Images/11fig09_alt.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片11.9](Images/11fig09_alt.jpg)'
- en: 'You can use the following patterns to design observable services:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下模式来设计可观察的服务：
- en: '***Health check API*—** Expose an endpoint that returns the health of the service.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***健康检查API*—** 暴露一个返回服务健康状况的端点。'
- en: '***Log aggregation*—** Log service activity and write logs into a centralized
    logging server, which provides searching and alerting.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***日志聚合*—** 记录服务活动并将日志写入集中式日志服务器，该服务器提供搜索和警报功能。'
- en: '***Distributed tracing*—** Assign each external request a unique ID and trace
    requests as they flow between services.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***分布式跟踪*—** 为每个外部请求分配一个唯一的ID，并跟踪请求在服务之间流动的情况。'
- en: '***Exception tracking*—** Report exceptions to an exception tracking service,
    which de-duplicates exceptions, alerts developers, and tracks the resolution of
    each exception.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***异常跟踪*—** 将异常报告给异常跟踪服务，该服务会去重异常、通知开发者并跟踪每个异常的解决情况。'
- en: '***Application metrics*—** Services maintain metrics, such as counters and
    gauges, and expose them to a metrics server.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***应用程序度量*—** 服务维护度量，如计数器和仪表，并将它们暴露给度量服务器。'
- en: '***Audit logging*—** Log user actions.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***审计日志*—** 记录用户行为。'
- en: A distinctive feature of most of these patterns is that each pattern has a developer
    component and an operations component. Consider, for example, the Health check
    API pattern. The developer is responsible for ensuring that their service implements
    a health check endpoint. Operations is responsible for the monitoring system that
    periodically invokes the health check API. Similarly, for the Log aggregation
    pattern, a developer is responsible for ensuring that their services log useful
    information, whereas operations is responsible for log aggregation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式的大部分特点在于每个模式都有一个开发组件和一个运维组件。以健康检查API模式为例。开发者负责确保他们的服务实现一个健康检查端点。运维负责定期调用健康检查API的监控系统。同样，对于日志聚合模式，开发者负责确保他们的服务记录有用的信息，而运维负责日志聚合。
- en: Let’s take a look at each of these patterns, starting with the Health check
    API pattern.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些模式，从健康检查API模式开始。
- en: 11.3.1\. Using the Health check API pattern
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1. 使用健康检查API模式
- en: Sometimes a service may be running but unable to handle requests. For instance,
    a newly started service instance may not be ready to accept requests. The FTGO
    `Consumer Service`, for example, takes around 10 seconds to initialize the messaging
    and database adapters. It would be pointless for the deployment infrastructure
    to route HTTP requests to a service instance until it’s ready to process them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个服务可能正在运行但无法处理请求。例如，一个新启动的服务实例可能还没有准备好接受请求。例如，FTGO的`Consumer Service`大约需要10秒钟来初始化消息和数据库适配器。对于部署基础设施在服务实例准备好处理请求之前将HTTP请求路由到服务实例来说，这是毫无意义的。
- en: Also, a service instance can fail without terminating. For example, a bug might
    cause an instance of `Consumer Service` to run out of database connections and
    be unable to access the database. The deployment infrastructure shouldn’t route
    requests to a service instance that has failed yet is still running. And, if the
    service instance does not recover, the deployment infrastructure must terminate
    it and create a new instance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个服务实例可能会失败而不会终止。例如，一个错误可能会导致`Consumer Service`实例耗尽数据库连接，无法访问数据库。部署基础设施不应将请求路由到已失败但仍在运行的服务实例。而且，如果服务实例无法恢复，部署基础设施必须终止它并创建一个新的实例。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Health check API**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：健康检查API**'
- en: A service exposes a health check API endpoint, such as `GET /health`, which
    returns the health of the service. See [http://microservices.io/patterns/observability/healthcheck-api.html](http://microservices.io/patterns/observability/healthcheck-api.html).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 服务公开一个健康检查API端点，例如`GET /health`，它返回服务的健康状况。请参阅[http://microservices.io/patterns/observability/healthcheck-api.html](http://microservices.io/patterns/observability/healthcheck-api.html)。
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A service instance needs to be able to tell the deployment infrastructure whether
    or not it’s able to handle requests. A good solution is for a service to implement
    a health check endpoint, which is shown in [figure 11.10](#ch11fig10). The Spring
    Boot Actuator Java library, for example, implements a `GET /actuator/health` endpoint,
    which returns 200 if and only if the service is healthy, and 503 otherwise. Similarly,
    the HealthChecks .NET library implements a `GET /hc` endpoint ([https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/monitor-app-health](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/monitor-app-health)).
    The deployment infrastructure periodically invokes this endpoint to determine
    the health of the service instance and takes the appropriate action if it’s unhealthy.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实例需要能够通知部署基础设施它是否能够处理请求。一个不错的解决方案是服务实现一个健康检查端点，如图11.10所示。例如，Spring Boot Actuator
    Java库实现了一个`GET /actuator/health`端点，如果服务健康则返回200，否则返回503。同样，HealthChecks .NET库实现了一个`GET
    /hc`端点（[https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/monitor-app-health](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/monitor-app-health)）。部署基础设施定期调用此端点以确定服务实例的健康状况，并在不健康时采取适当的行动。
- en: Figure 11.10\. A service implements a health check endpoint, which is periodically
    invoked by the deployment infrastructure to determine the health of the service
    instance.
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.10。服务实现了一个健康检查端点，部署基础设施定期调用此端点以确定服务实例的健康状况。
- en: '![](Images/11fig10_alt.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig10_alt.jpg)'
- en: A `Health Check Request Handler` typically tests the service instance’s connections
    to external services. It might, for example, execute a test query against a database.
    If all the tests succeed, `Health Check Request Handler` returns a healthy response,
    such as an HTTP 200 status code. If any of them fails, it returns an unhealthy
    response, such as an HTTP 500 status code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health Check Request Handler` 通常会测试服务实例与外部服务的连接。例如，它可能对数据库执行测试查询。如果所有测试都成功，`Health
    Check Request Handler` 返回一个健康响应，如 HTTP 200 状态码。如果有任何测试失败，它返回一个不健康响应，如 HTTP 500
    状态码。'
- en: '`Health Check Request Handler` might simply return an empty HTTP response with
    the appropriate status code. Or it might return a detailed description of the
    health of each of the adapters. The detailed information is useful for troubleshooting.
    But because it may contain sensitive information, some frameworks, such as Spring
    Boot Actuator, let you configure the level of detail in the health endpoint response.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health Check Request Handler` 可能简单地返回一个带有适当状态码的空 HTTP 响应。或者，它可能返回每个适配器的详细健康状况描述。详细信息对于故障排除很有用。但由于它可能包含敏感信息，一些框架，如
    Spring Boot Actuator，允许您配置健康端点响应的详细程度。'
- en: There are two issues you need to consider when using health checks. The first
    is the implementation of the endpoint, which must report back on the health of
    the service instance. The second issue is how to configure the deployment infrastructure
    to invoke the health check endpoint. Let’s first look at how to implement the
    endpoint.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用健康检查时，您需要考虑两个问题。第一个问题是端点的实现，它必须报告服务实例的健康状况。第二个问题是如何配置部署基础设施以调用健康检查端点。让我们首先看看如何实现端点。
- en: Implementing the health check endpoint
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现健康检查端点
- en: The code that implements the health check endpoint must somehow determine the
    health of the service instance. One simple approach is to verify that the service
    instance can access its external infrastructure services. How to do this depends
    on the infrastructure service. The health check code can, for example, verify
    that it’s connected to an RDBMS by obtaining a database connection and executing
    a test query. A more elaborate approach is to execute a synthetic transaction
    that simulates the invocation of the service’s API by a client. This kind of health
    check is more thorough, but it’s likely to be more time consuming to implement
    and take longer to execute.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实现健康检查端点的代码必须以某种方式确定服务实例的健康状况。一种简单的方法是验证服务实例可以访问其外部基础设施服务。如何做到这一点取决于基础设施服务。例如，健康检查代码可以通过获取数据库连接并执行测试查询来验证它是否连接到一个
    RDBMS。更复杂的方法是执行一个模拟客户端调用服务 API 的合成事务。这种类型的健康检查更为彻底，但实现起来可能更耗时，执行时间也更长。
- en: A great example of a health check library is Spring Boot Actuator. As mentioned
    earlier, it implements a `/actuator/health` endpoint. The code that implements
    this endpoint returns the result of executing a set of health checks. By using
    convention over configuration, Spring Boot Actuator implements a sensible set
    of health checks based on the infrastructure services used by the service. If,
    for example, a service uses a JDBC `DataSource`, Spring Boot Actuator configures
    a health check that executes a test query. Similarly, if the service uses the
    RabbitMQ message broker, it automatically configures a health check that verifies
    that the RabbitMQ server is up.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查库的一个优秀例子是 Spring Boot Actuator。如前所述，它实现了一个 `/actuator/health` 端点。实现此端点的代码返回执行一系列健康检查的结果。通过使用约定优于配置，Spring
    Boot Actuator 根据服务使用的底层基础设施服务实现了一套合理的健康检查。例如，如果一个服务使用 JDBC `DataSource`，Spring
    Boot Actuator 会配置一个执行测试查询的健康检查。同样，如果服务使用 RabbitMQ 消息代理，它会自动配置一个健康检查来验证 RabbitMQ
    服务器是否运行正常。
- en: You can also customize this behavior by implementing additional health checks
    for your service. You implement a custom health check by defining a class that
    implements the `HealthIndicator` interface. This interface defines a `health()`
    method, which is called by the implementation of the `/actuator/health` endpoint.
    It returns the outcome of the health check.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过为您的服务实现额外的健康检查来自定义此行为。您通过定义一个实现 `HealthIndicator` 接口的类来实现自定义健康检查。此接口定义了一个
    `health()` 方法，该方法由 `/actuator/health` 端点的实现调用。它返回健康检查的结果。
- en: Invoking the health check endpoint
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用健康检查端点
- en: A health check endpoint isn’t much use if nobody calls it. When you deploy your
    service, you must configure the deployment infrastructure to invoke the endpoint.
    How you do that depends on the specific details of your deployment infrastructure.
    For example, as described in [chapter 3](kindle_split_011.xhtml#ch03), you can
    configure some service registries, such as Netflix Eureka, to invoke the health
    check endpoint in order to determine whether traffic should be routed to the service
    instance. [Chapter 12](kindle_split_020.xhtml#ch12) discusses how to configure
    Docker and Kubernetes to invoke a health check endpoint.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有人调用它，健康检查端点就没有什么用处。当你部署你的服务时，你必须配置部署基础设施来调用该端点。你如何做这取决于你的部署基础设施的具体细节。例如，如第
    3 章所述（[kindle_split_011.xhtml#ch03]），你可以配置一些服务注册表，例如 Netflix Eureka，以调用健康检查端点，以确定是否应该将流量路由到服务实例。[第
    12 章](kindle_split_020.xhtml#ch12) 讨论了如何配置 Docker 和 Kubernetes 来调用健康检查端点。
- en: 11.3.2\. Applying the Log aggregation pattern
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 应用日志聚合模式
- en: Logs are a valuable troubleshooting tool. If you want to know what’s wrong with
    your application, a good place to start is the log files. But using logs in a
    microservice architecture is challenging. For example, imagine you’re debugging
    a problem with the `getOrderDetails()` query. As described in [chapter 8](kindle_split_016.xhtml#ch08),
    the FTGO application implements this query using API composition. As a result,
    the log entries you need are scattered across the log files of the API gateway
    and several services, including `Order Service` and `Kitchen Service`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是一个有价值的故障排除工具。如果你想了解你的应用程序出了什么问题，一个好的起点是查看日志文件。但在微服务架构中使用日志具有挑战性。例如，想象你正在调试
    `getOrderDetails()` 查询的问题。如第 8 章所述（[kindle_split_016.xhtml#ch08]），FTGO 应用程序使用
    API 组合来实现这个查询。因此，你需要查看的日志条目分散在 API 网关和包括 `Order Service` 和 `Kitchen Service` 在内的几个服务的日志文件中。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Log aggregation**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：日志聚合**'
- en: Aggregate the logs of all services in a centralized database that supports searching
    and alerting. See [http://microservices.io/patterns/observability/application-logging.html](http://microservices.io/patterns/observability/application-logging.html).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有服务的日志聚合到一个支持搜索和警报的集中式数据库中。请参阅 [http://microservices.io/patterns/observability/application-logging.html](http://microservices.io/patterns/observability/application-logging.html)。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The solution is to use log aggregation. As [figure 11.11](#ch11fig11) shows,
    the log aggregation pipeline sends the logs of all of the service instances to
    a centralized logging server. Once the logs are stored by the logging server,
    you can view, search, and analyze them. You can also configure alerts that are
    triggered when certain messages appear in the logs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用日志聚合。如图 11.11 所示，日志聚合管道将所有服务实例的日志发送到一个集中的日志服务器。一旦日志被日志服务器存储，你就可以查看、搜索和分析它们。你还可以配置当某些消息出现在日志中时触发的警报。
- en: Figure 11.11\. The log aggregation infrastructure ships the logs of each service
    instance to a centralized logging server. Users can view and search the logs.
    They can also set up alerts, which are triggered when log entries match search
    criteria.
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.11\. 日志聚合基础设施将每个服务实例的日志发送到一个集中的日志服务器。用户可以查看和搜索日志。他们还可以设置警报，当日志条目匹配搜索条件时，警报会被触发。
- en: '![](Images/11fig11_alt.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig11_alt.jpg)'
- en: The logging pipeline and server are usually the responsibility of operations.
    But service developers are responsible for writing services that generate useful
    logs. Let’s first look at how a service generates a log.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 日志管道和服务器通常由运维负责。但服务开发者负责编写生成有用日志的服务。让我们首先看看服务是如何生成日志的。
- en: How a service generates a log
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务生成日志的方式
- en: As a service developer, there are a couple of issues you need to consider. First
    you need to decide which logging library to use. The second issue is where to
    write the log entries. Let’s first look at the logging library.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务开发者，你需要考虑几个问题。首先，你需要决定使用哪个日志库。第二个问题是日志条目的写入位置。让我们首先看看日志库。
- en: Most programming languages have one or more logging libraries that make it easy
    to generate correctly structured log entries. For example, three popular Java
    logging libraries are Logback, log4j, and JUL (java.util.logging). There’s also
    SLF4J, which is a logging facade API for the various logging frameworks. Similarly,
    Log4JS is a popular logging framework for NodeJS. One reasonable way to use logging
    is to sprinkle calls to one of these logging libraries in your service’s code.
    But if you have strict logging requirements that can’t be enforced by the logging
    library, you may need to define your own logging API that wraps a logging library.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一个或多个日志库，可以轻松生成正确结构的日志条目。例如，三个流行的Java日志库是Logback、log4j和JUL（java.util.logging）。还有SLF4J，它是各种日志框架的日志门面API。同样，Log4JS是NodeJS的一个流行的日志框架。使用日志的一个合理方式是在你的服务代码中调用这些日志库之一。但是，如果你有严格的日志要求，这些要求不能通过日志库强制执行，你可能需要定义自己的日志API，该API封装了一个日志库。
- en: You also need to decide where to log. Traditionally, you would configure the
    logging framework to write to a log file in a well-known location in the filesystem.
    But with the more modern deployment technologies, such as containers and serverless,
    described in [chapter 12](kindle_split_020.xhtml#ch12), this is often not the
    best approach. In some environments, such as AWS Lambda, there isn’t even a “permanent”
    filesystem to write the logs to! Instead, your service should log to `stdout`.
    The deployment infrastructure will then decide what to do with the output of your
    service.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要决定在哪里记录日志。传统上，你会配置日志框架将日志写入文件系统中的一个已知位置的日志文件。但是，随着更现代的部署技术，如容器和无服务器，如第12章[12](kindle_split_020.xhtml#ch12)中所述，这通常不是最佳方法。在某些环境中，例如AWS
    Lambda，甚至没有“永久”的文件系统来写入日志！相反，你的服务应该记录到`stdout`。然后，部署基础设施将决定如何处理你的服务的输出。
- en: The log aggregation infrastructure
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 日志聚合基础设施
- en: 'The logging infrastructure is responsible for aggregating the logs, storing
    them, and enabling the user to search them. One popular logging infrastructure
    is the ELK stack. ELK consists of three open source products:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 日志基础设施负责聚合日志、存储它们并使用户能够搜索它们。一个流行的日志基础设施是ELK堆栈。ELK由三个开源产品组成：
- en: '***Elasticsearch*—** A text search-oriented NoSQL database that’s used as the
    logging server'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Elasticsearch*—** 一个以文本搜索为导向的NoSQL数据库，用作日志服务器'
- en: '***Logstash*—** A log pipeline that aggregates the service logs and writes
    them to Elasticsearch'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Logstash*—** 一个聚合服务日志并将其写入Elasticsearch的日志管道'
- en: '***Kibana*—** A visualization tool for Elasticsearch'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Kibana*—** 用于Elasticsearch的可视化工具'
- en: Other open source log pipelines include Fluentd and Apache Flume. Examples of
    logging servers include cloud services, such as AWS CloudWatch Logs, as well as
    numerous commercial offerings. Log aggregation is a useful debugging tool in a
    microservice architecture.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其他开源日志管道包括Fluentd和Apache Flume。日志服务器示例包括云服务，如AWS CloudWatch Logs，以及众多商业产品。日志聚合是微服务架构中一个有用的调试工具。
- en: Let’s now look at distributed tracing, which is another way of understanding
    the behavior of a microservices-based application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看分布式追踪，这是理解基于微服务应用程序行为的另一种方式。
- en: 11.3.3\. Using the Distributed tracing pattern
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3\. 使用分布式追踪模式
- en: Imagine you’re a FTGO developer who is investigating why the `getOrderDetails()`
    query has slowed down. You’ve ruled out the problem being an external networking
    issue. The increased latency must be caused by either the API gateway or one of
    the services it has invoked. One option is to look at each service’s average response
    time. The trouble with this option is that it’s an average across requests rather
    than the timing breakdown for an individual request. Plus more complex scenarios
    might involve many nested service invocations. You may not even be familiar with
    all services. As a result, it can be challenging to troubleshoot and diagnose
    these kinds of performance problems in a microservice architecture.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你是一名FTGO开发者，正在调查`getOrderDetails()`查询为何变慢。你已经排除了外部网络问题导致问题的可能性。延迟的增加必定是由API网关或它调用的某个服务引起的。一个选择是查看每个服务的平均响应时间。这个选项的问题在于它是请求的平均值，而不是单个请求的时间分解。此外，更复杂的场景可能涉及许多嵌套的服务调用。你可能甚至不熟悉所有服务。因此，在微服务架构中，诊断这类性能问题可能具有挑战性。
- en: '|  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Distributed tracing**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：分布式追踪**'
- en: Assign each external request a unique ID and record how it flows through the
    system from one service to the next in a centralized server that provides visualization
    and analysis. See [http://microservices.io/patterns/observability/distributed-tracing.html](http://microservices.io/patterns/observability/distributed-tracing.html).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个外部请求分配一个唯一的ID，并在提供可视化和分析的集中式服务器中记录它从服务到下一个服务的流动情况。请参阅[http://microservices.io/patterns/observability/distributed-tracing.html](http://microservices.io/patterns/observability/distributed-tracing.html)。
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A good way to get insight into what your application is doing is to use distributed
    tracing. *Distributed tracing* is analogous to a performance profiler in a monolithic
    application. It records information (for example, start time and end time) about
    the tree of service calls that are made when handling a request. You can then
    see how the services interact during the handling of external requests, including
    a breakdown of where the time is spent.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的应用程序正在做什么的一个好方法是使用分布式追踪。*分布式追踪*在单体应用程序中类似于性能分析器。它记录了处理请求时做出的服务调用树的信息（例如，开始时间和结束时间）。然后你可以看到服务在处理外部请求时的交互，包括时间花费的分解。
- en: '[Figure 11.12](#ch11fig12) shows an example of how a distributed tracing server
    displays what happens when the API gateway handles a request. It shows the inbound
    request to the API gateway and the request that the gateway makes to `Order Service`.
    For each request, the distributed tracing server shows the operation that’s performed
    and the timing of the request.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.12](#ch11fig12) 展示了分布式追踪服务器如何显示API网关处理请求时发生的情况。它显示了API网关的入站请求和网关对`订单服务`发出的请求。对于每个请求，分布式追踪服务器显示了执行的操作和请求的时间。'
- en: Figure 11.12\. The Zipkin server shows how the FTGO application handles a request
    that’s routed by the API gateway to `Order Service`. Each request is represented
    by a trace. A trace is a set of spans. Each span, which can contain child spans,
    is the invocation of a service. Depending on the level of detail collected, a
    span can also represent the invocation of an operation inside a service.
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.12\. Zipkin服务器显示了FTGO应用程序如何处理由API网关路由到`订单服务`的请求。每个请求都由一个追踪表示。一个追踪是一系列跨度。每个跨度，可以包含子跨度，代表一个服务的调用。根据收集的详细程度，跨度也可以代表服务内部操作的调用。
- en: '![](Images/11fig12_alt.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig12_alt.jpg)'
- en: '[Figure 11.12](#ch11fig12) shows what in distributed tracing terminology is
    called a *trace*. A trace represents an external request and consists of one or
    more spans. A *span* represents an operation, and its key attributes are an operation
    name, start timestamp, and end time. A span can have one or more child spans,
    which represent nested operations. For example, a top-level span might represent
    the invocation of the API gateway, as is the case in [figure 11.12](#ch11fig12).
    Its child spans represent the invocations of services by the API gateway.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.12](#ch11fig12) 展示了在分布式追踪术语中被称为*追踪*的内容。一个追踪代表一个外部请求，由一个或多个跨度组成。一个*跨度*代表一个操作，其关键属性是操作名称、开始时间戳和结束时间。一个跨度可以有零个或多个子跨度，它们代表嵌套操作。例如，顶层跨度可能代表API网关的调用，正如[图11.12](#ch11fig12)中所示。其子跨度代表API网关对服务的调用。'
- en: 'A valuable side effect of distributed tracing is that it assigns a unique ID
    to each external request. A service can include the request ID in its log entries.
    When combined with log aggregation, the request ID enables you to easily find
    all log entries for a particular external request. For example, here’s an example
    log entry from `Order Service`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪的一个宝贵副作用是它为每个外部请求分配一个唯一的ID。一个服务可以将请求ID包含在其日志条目中。当与日志聚合结合使用时，请求ID可以让你轻松地找到特定外部请求的所有日志条目。例如，下面是从`订单服务`的一个示例日志条目：
- en: '[PRE1]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `[ftgo-order-service,8d8fdc37be104cc6,8d8fdc37be104cc6,false]` part of
    the log entry (the SLF4J Mapped Diagnostic Context—see [www.slf4j.org/manual.html](http://www.slf4j.org/manual.html))
    contains information from the distributed tracing infrastructure. It consists
    of four values:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 日志条目中的`[ftgo-order-service,8d8fdc37be104cc6,8d8fdc37be104cc6,false]`部分（SLF4J映射诊断上下文—见[www.slf4j.org/manual.html](http://www.slf4j.org/manual.html)）包含了分布式追踪基础设施的信息。它由四个值组成：
- en: '**`ftgo-order-service`—** The name of the application'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ftgo-order-service`—** 应用程序名称'
- en: '**`8d8fdc37be104cc6`—** The `traceId`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`8d8fdc37be104cc6`—** `traceId`'
- en: '**`8d8fdc37be104cc6`—** The `spanId`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`8d8fdc37be104cc6`—** `spanId`'
- en: '**`false`—** Indicates that this span wasn’t exported to the distributed tracing
    server'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`false`—** 表示这个跨度没有被导出到分布式追踪服务器'
- en: If you search the logs for `8d8fdc37be104cc6`, you’ll find all log entries for
    that request.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在日志中搜索`8d8fdc37be104cc6`，您将找到该请求的所有日志条目。
- en: '[Figure 11.13](#ch11fig13) shows how distributed tracing works. There are two
    parts to distributed tracing: an instrumentation library, which is used by each
    service, and a distributed tracing server. The instrumentation library manages
    the traces and spans. It also adds tracing information, such as the current trace
    ID and the parent span ID, to outbound requests. For example, one common standard
    for propagating trace information is the B3 standard ([https://github.com/openzipkin/b3-propagation](https://github.com/openzipkin/b3-propagation)),
    which uses headers such as `X-B3-TraceId` and `X-B3-ParentSpanId`. The instrumentation
    library also reports traces to the distributed tracing server. The distributed
    tracing server stores the traces and provides a UI for visualizing them.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13](#ch11fig13)展示了分布式跟踪的工作原理。分布式跟踪有两个部分：一个仪表化库，每个服务都使用它，以及一个分布式跟踪服务器。仪表化库管理跟踪和跨度。它还向出站请求添加跟踪信息，例如当前的跟踪ID和父跨度ID。例如，传播跟踪信息的一个常见标准是B3标准（[https://github.com/openzipkin/b3-propagation](https://github.com/openzipkin/b3-propagation)），它使用如`X-B3-TraceId`和`X-B3-ParentSpanId`这样的头信息。仪表化库还将跟踪报告给分布式跟踪服务器。分布式跟踪服务器存储跟踪并提供一个用于可视化的UI。'
- en: Figure 11.13\. Each service (including the API gateway) uses an instrumentation
    library. The instrumentation library assigns an ID to each external request, propagates
    tracing state between services, and reports spans to the distributed tracing server.
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.13。每个服务（包括API网关）都使用一个仪表化库。仪表化库为每个外部请求分配一个ID，在服务之间传播跟踪状态，并将跨度报告给分布式跟踪服务器。
- en: '![](Images/11fig13_alt.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig13_alt.jpg)'
- en: Let’s take a look at the instrumentation library and the distribution tracing
    server, beginning with the library.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看仪表化库和分布式跟踪服务器，从库开始。
- en: Using an instrumentation library
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用仪表化库
- en: The instrumentation library builds the tree of spans and sends them to the distributed
    tracing server. The service code could call the instrumentation library directly,
    but that would intertwine the instrumentation logic with business and other logic.
    A cleaner approach is to use interceptors or aspect-oriented programming (AOP).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表化库构建跨度树并将它们发送到分布式跟踪服务器。服务代码可以直接调用仪表化库，但这会将仪表化逻辑与业务和其他逻辑交织在一起。一种更干净的方法是使用拦截器或面向切面编程（AOP）。
- en: A great example of an AOP-based framework is Spring Cloud Sleuth. It uses the
    Spring Framework’s AOP mechanism to automagically integrate distributed tracing
    into the service. As a result, you have to add Spring Cloud Sleuth as a project
    dependency. Your service doesn’t need to call a distributed tracing API except
    in those cases that aren’t handled by Spring Cloud Sleuth.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 基于AOP（面向切面编程）框架的一个优秀例子是Spring Cloud Sleuth。它利用Spring框架的AOP机制自动将分布式跟踪集成到服务中。因此，您必须将Spring
    Cloud Sleuth作为项目依赖项添加。除非在Spring Cloud Sleuth无法处理的情况下，您的服务不需要调用分布式跟踪API。
- en: About the distributed tracing server
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于分布式跟踪服务器
- en: The instrumentation library sends the spans to a distributed tracing server.
    The distributed tracing server stitches the spans together to form complete traces
    and stores them in a database. One popular distributed tracing server is Open
    Zipkin. Zipkin was originally developed by Twitter. Services can deliver spans
    to Zipkin using either HTTP or a message broker. Zipkin stores the traces in a
    storage backend, which is either a SQL or NoSQL database. It has a UI that displays
    traces, as shown earlier in [figure 11.12](#ch11fig12). AWS X-ray is another example
    of a distributed tracing server.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表化库将跨度发送到分布式跟踪服务器。分布式跟踪服务器将跨度拼接在一起形成完整的跟踪，并将它们存储在数据库中。一个流行的分布式跟踪服务器是Open Zipkin。Zipkin最初由Twitter开发。服务可以通过HTTP或消息代理将跨度发送到Zipkin。Zipkin将跟踪存储在存储后端，该后端可以是SQL或NoSQL数据库。它有一个UI，用于显示跟踪，如图11.12中所示。AWS
    X-ray是另一个分布式跟踪服务器的例子。
- en: 11.3.4\. Applying the Application metrics pattern
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.4. 应用应用程序度量模式
- en: A key part of the production environment is monitoring and alerting. As [figure
    11.14](#ch11fig14) shows, the monitoring system gathers metrics, which provide
    critical information about the health of an application, from every part of the
    technology stack. Metrics range from infrastructure-level metrics, such as CPU,
    memory, and disk utilization, to application-level metrics, such as service request
    latency and number of requests executed. `Order Service`, for example, gathers
    metrics about the number of placed, approved, and rejected orders. The metrics
    are collected by a metrics service, which provides visualization and alerting.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境的一个关键部分是监控和警报。如图11.14所示，监控系统从技术栈的每个部分收集指标，这些指标提供了关于应用程序健康状况的关键信息。指标范围从基础设施级别的指标，如CPU、内存和磁盘利用率，到应用程序级别的指标，如服务请求延迟和执行的请求数量。例如，`Order
    Service`收集有关已放置、批准和拒绝的订单的指标。这些指标由提供可视化和警报的指标服务收集。
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Application metrics**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：应用程序指标**'
- en: Services report metrics to a central server that provides aggregation, visualization,
    and alerting.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将指标报告给一个提供聚合、可视化和警报的中心服务器。
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 11.14\. Metrics at every level of the stack are collected and stored
    in a metrics service, which provides visualization and alerting.
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.14\. 栈的每一层都收集并存储在指标服务中，该服务提供可视化和警报。
- en: '![](Images/11fig14_alt.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig14_alt.jpg)'
- en: 'Metrics are sampled periodically. A metric sample has the following three properties:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 指标是定期采样的。一个指标样本具有以下三个属性：
- en: '***Name*—** The name of the metric, such as `jvm_memory_max_bytes` or `placed_orders`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***名称*—** 指标的名称，例如`jvm_memory_max_bytes`或`placed_orders`'
- en: '***Value*—** A numeric value'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***值*—** 一个数值'
- en: '***Timestamp*—** The time of the sample'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***时间戳*—** 样本的时刻'
- en: In addition, some monitoring systems support the concept of *dimensions*, which
    are arbitrary name-value pairs. For example, `jvm_memory_max_bytes` is reported
    with dimensions such as `area="heap",id="PS Eden Space"` and `area="heap",id="PS
    Old Gen"`. Dimensions are often used to provide additional information, such as
    the machine name or service name, or a service instance identifier. A monitoring
    system typically *aggregates* (sums or averages) metric samples along one or more
    dimensions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些监控系统支持*维度*的概念，它们是任意的名称-值对。例如，`jvm_memory_max_bytes`与`area="heap",id="PS
    Eden Space"`和`area="heap",id="PS Old Gen"`等维度一起报告。维度通常用于提供额外的信息，例如机器名或服务名，或服务实例标识符。监控系统通常在一条或多条维度上*聚合*（求和或平均）指标样本。
- en: Many aspects of monitoring are the responsibility of operations. But a service
    developer is responsible for two aspects of metrics. First, they must instrument
    their service so that it collects metrics about its behavior. Second, they must
    expose those service metrics, along with metrics from the JVM and the application
    framework, to the metrics server.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 监控的许多方面是运维的责任。但是，服务开发者负责指标的两个方面。首先，他们必须对其服务进行仪表化，以便收集有关其行为的数据。其次，他们必须将那些服务指标，以及JVM和应用框架的指标，公开给指标服务器。
- en: Let’s first look at how a service collects metrics.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看服务是如何收集指标的。
- en: Collecting service-level metrics
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收集服务级指标
- en: How much work you need to do to collect metrics depends on the frameworks that
    your application uses and the metrics you want to collect. A Spring Boot-based
    service can, for example, gather (and expose) basic metrics, such as JVM metrics,
    by including the Micrometer Metrics library as a dependency and using a few lines
    of configuration. Spring Boot’s autoconfiguration takes care of configuring the
    metrics library and exposing the metrics. A service only needs to use the Micrometer
    Metrics API directly if it gathers application-specific metrics.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做多少工作来收集指标取决于你的应用程序使用的框架以及你想要收集的指标。例如，一个基于Spring Boot的服务可以通过将Micrometer Metrics库作为依赖项并使用几行配置来收集（并公开）基本指标，如JVM指标。Spring
    Boot的自动配置负责配置指标库并公开指标。如果服务需要收集特定于应用程序的指标，它只需直接使用Micrometer Metrics API。
- en: The following listing shows how `OrderService` can collect metrics about the
    number of orders placed, approved, and rejected. It uses `MeterRegistry`, which
    is the interface-provided Micrometer Metrics, to gather custom metrics. Each method
    increments an appropriately named counter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了`OrderService`如何收集有关已放置、批准和拒绝的订单数量的指标。它使用`MeterRegistry`，这是由接口提供的Micrometer
    Metrics，来收集自定义指标。每个方法都会增加一个适当命名的计数器。
- en: Listing 11.1\. `OrderService` tracks the number of orders placed, approved,
    and rejected.
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. `OrderService`跟踪已下单、批准和拒绝的订单数量。
- en: '[PRE2]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* The Micrometer Metrics library API for managing application-specific
    meters**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于管理应用程序特定仪表的Micrometer Metrics库API**'
- en: '***2* Increments the placedOrders counter when an order has successfully been
    placed**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当订单成功下单时增加`placedOrders`计数器**'
- en: '***3* Increments the approvedOrders counter when an order has been approved**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当订单被批准时增加`approvedOrders`计数器**'
- en: '***4* Increments the rejectedOrders counter when an order has been rejected**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当订单被拒绝时增加`rejectedOrders`计数器**'
- en: Delivering metrics to the metrics service
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将指标发送到指标服务
- en: 'A service delivers metrics to the Metrics Service in one of two ways: push
    or pull. With the *push* model, a service instance sends the metrics to the Metrics
    Service by invoking an API. AWS Cloudwatch metrics, for example, implements the
    push model.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务通过以下两种方式之一将指标发送到指标服务：推送或拉取。在*推送*模式下，服务实例通过调用API将指标发送到指标服务。例如，AWS Cloudwatch指标实现了推送模式。
- en: With the *pull* model, the Metrics Service (or its agent running locally) invokes
    a service API to retrieve the metrics from the service instance. Prometheus, a
    popular open source monitoring and alerting system, uses the pull model.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在*拉取*模式下，指标服务（或其在本地上运行的代理）调用服务API以从服务实例检索指标。Prometheus，一个流行的开源监控和警报系统，使用拉取模式。
- en: 'The FTGO application’s `Order Service` uses the `micrometer-registry-prometheus`
    library to integrate with Prometheus. Because this library is on the classpath,
    Spring Boot exposes a `GET /actuator/prometheus` endpoint, which returns metrics
    in the format that Prometheus expects. The custom metrics from `OrderService`
    are reported as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序的`Order Service`使用`micrometer-registry-prometheus`库与Prometheus集成。因为这个库在类路径上，Spring
    Boot暴露了一个`GET /actuator/prometheus`端点，该端点以Prometheus期望的格式返回指标。`OrderService`的自定义指标报告如下：
- en: '[PRE3]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `placed_orders` counter is, for example, reported as a metric of type `counter`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`placed_orders`计数器报告为类型为`counter`的指标。
- en: The Prometheus server periodically polls this endpoint to retrieve metrics.
    Once the metrics are in Prometheus, you can view them using Grafana, a data visualization
    tool ([https://grafana.com](https://grafana.com)). You can also set up alerts
    for these metrics, such as when the rate of change for `placed_orders_total` falls
    below some threshold.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus服务器定期轮询此端点以检索指标。一旦指标在Prometheus中，您可以使用Grafana，一个数据可视化工具（[https://grafana.com](https://grafana.com)）来查看它们。您还可以为这些指标设置警报，例如，当`placed_orders_total`的变化率低于某个阈值时。
- en: 'Application metrics provide valuable insights into your application’s behavior.
    Alerts triggered by metrics enable you to quickly respond to a production issue,
    perhaps before it impacts users. Let’s now look at how to observe and respond
    to another source of alerts: exceptions.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序指标提供了对应用程序行为的宝贵见解。由指标触发的警报使您能够快速响应生产问题，可能在它影响用户之前。现在让我们看看如何观察和响应另一个警报源：异常。
- en: 11.3.5\. Using the Exception tracking pattern
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.5\. 使用异常跟踪模式
- en: 'A service should rarely log an exception, and when it does, it’s important
    that you identify the root cause. The exception might be a symptom of a failure
    or a programming bug. The traditional way to view exceptions is to look in the
    logs. You might even configure the logging server to alert you if an exception
    appears in the log file. There are, however, several problems with this approach:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 服务很少记录异常，当它这样做时，重要的是要确定根本原因。异常可能是失败或编程错误的症状。查看异常的传统方式是查看日志。您甚至可以配置日志服务器，如果日志文件中出现异常，则提醒您。然而，这种方法存在一些问题：
- en: Log files are oriented around single-line log entries, whereas exceptions consist
    of multiple lines.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件以单行日志条目为导向，而异常由多行组成。
- en: There’s no mechanism to track the resolution of exceptions that occur in log
    files. You would have to manually copy/paste the exception into an issue tracker.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有机制来跟踪日志文件中发生的异常的解决情况。您必须手动将异常复制/粘贴到问题跟踪器中。
- en: There are likely to be duplicate exceptions, but there’s no automatic mechanism
    to treat them as one.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很可能存在重复的异常，但没有自动机制将它们视为一个。
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Exception tracking**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：异常跟踪**'
- en: Services report exceptions to a central service that de-duplicates exceptions,
    generates alerts, and manages the resolution of exceptions. See [http://microservices.io/patterns/observability/audit-logging.html](http://microservices.io/patterns/observability/audit-logging.html).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将异常报告给一个中央服务，该服务去重异常、生成警报并管理异常的解决。请参阅[http://microservices.io/patterns/observability/audit-logging.html](http://microservices.io/patterns/observability/audit-logging.html)。
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A better approach is to use an exception tracking service. As [figure 11.15](#ch11fig15)
    shows, you configure your service to report exceptions to an exception tracking
    service via, for example, a REST API. The exception tracking service de-duplicates
    exceptions, generates alerts, and manages the resolution of exceptions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用异常跟踪服务。如图11.15所示，您可以通过例如REST API配置您的服务向异常跟踪服务报告异常。异常跟踪服务去重异常、生成警报并管理异常的解决。
- en: Figure 11.15\. A service reports exceptions to an exception tracking service,
    which de-duplicates exceptions and alerts developers. It has a UI for viewing
    and managing exceptions.
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.15\. 一个服务将异常报告给异常跟踪服务，该服务去重异常并向开发者发出警报。它有一个用于查看和管理异常的用户界面。
- en: '![](Images/11fig15_alt.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig15_alt.jpg)'
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Exception tracking services**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常跟踪服务**'
- en: There are several exception tracking services. Some, such as Honeybadger ([www.honeybadger.io](http://www.honeybadger.io)),
    are purely cloud-based. Others, such as Sentry.io ([https://sentry.io/welcome/](https://sentry.io/welcome/)),
    also have an open source version that you can deploy on your own infrastructure.
    These services receive exceptions from your application and generate alerts. They
    provide a console for viewing exceptions and managing their resolution. An exception
    tracking service typically provides client libraries in a variety of languages.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个异常跟踪服务。其中一些，如Honeybadger([www.honeybadger.io](http://www.honeybadger.io))，是纯云基础的。其他，如Sentry.io([https://sentry.io/welcome/](https://sentry.io/welcome/))，也有一个开源版本，您可以在自己的基础设施上部署。这些服务接收来自您应用程序的异常并生成警报。它们提供了一个控制台用于查看异常和管理它们的解决。异常跟踪服务通常提供多种语言的客户端库。
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: There are a couple of ways to integrate the exception tracking service into
    your application. Your service could invoke the exception tracking service’s API
    directly. A better approach is to use a client library provided by the exception
    tracking service. For example, HoneyBadger’s client library provides several easy-to-use
    integration mechanisms, including a Servlet Filter that catches and reports exceptions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将异常跟踪服务集成到您的应用程序中。您的服务可以直接调用异常跟踪服务的API。更好的方法是使用异常跟踪服务提供的客户端库。例如，HoneyBadger的客户端库提供了几个易于使用的集成机制，包括一个Servlet
    Filter，它可以捕获并报告异常。
- en: The Exception tracking pattern is a useful way to quickly identify and respond
    to production issues.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 异常跟踪模式是快速识别和响应生产问题的有用方法。
- en: It’s also important to track user behavior. Let’s look at how to do that.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪用户行为也同样重要。让我们看看如何做到这一点。
- en: 11.3.6\. Applying the Audit logging pattern
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.6\. 应用审计日志模式
- en: The purpose of audit logging is to record each user’s actions. An audit log
    is typically used to help customer support, ensure compliance, and detect suspicious
    behavior. Each audit log entry records the identity of the user, the action they
    performed, and the business object(s). An application usually stores the audit
    log in a database table.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志的目的是记录每位用户的行为。审计日志通常用于帮助客户支持、确保合规性以及检测可疑行为。每个审计日志条目记录了用户的身份、他们执行的操作以及业务对象。应用程序通常将审计日志存储在数据库表中。
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Audit logging**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：审计日志**'
- en: Record user actions in a database in order to help customer support, ensure
    compliance, and detect suspicious behavior. See [http://microservices.io/patterns/observability/audit-logging.html](http://microservices.io/patterns/observability/audit-logging.html).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中记录用户行为，以帮助客户支持、确保合规性以及检测可疑行为。请参阅[http://microservices.io/patterns/observability/audit-logging.html](http://microservices.io/patterns/observability/audit-logging.html)。
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'There are a few different ways to implement audit logging:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 实现审计日志有多种不同的方法：
- en: Add audit logging code to the business logic.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将审计日志代码添加到业务逻辑中。
- en: Use aspect-oriented programming (AOP).
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用面向方面编程（AOP）。
- en: Use event sourcing.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件溯源。
- en: Let’s look at each option.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每个选项。
- en: Add audit logging code to the business logic
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将审计日志代码添加到业务逻辑
- en: The first and most straightforward option is to sprinkle audit logging code
    throughout your service’s business logic. Each service method, for example, can
    create an audit log entry and save it in the database. The drawback with this
    approach is that it intertwines auditing logging code and business logic, which
    reduces maintainability. The other drawback is that it’s potentially error prone,
    because it relies on the developer writing audit logging code.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最直接的选择是在服务业务逻辑中散布审计日志代码。例如，每个服务方法都可以创建一个审计日志条目并将其保存到数据库中。这种方法的一个缺点是它将审计日志代码与业务逻辑交织在一起，这降低了可维护性。另一个缺点是它可能存在错误，因为它依赖于开发者编写审计日志代码。
- en: Use aspect-oriented programming
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用面向切面编程
- en: The second option is to use AOP. You can use an AOP framework, such as Spring
    AOP, to define advice that automatically intercepts each service method call and
    persists an audit log entry. This is a much more reliable approach, because it
    automatically records every service method invocation. The main drawback of using
    AOP is that the advice only has access to the method name and its arguments, so
    it might be challenging to determine the business object being acted upon and
    generate a business-oriented audit log entry.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用AOP。你可以使用AOP框架，如Spring AOP，来定义建议，该建议可以自动拦截每个服务方法调用并持久化一个审计日志条目。这是一个更可靠的方案，因为它自动记录每个服务方法的调用。使用AOP的主要缺点是建议只能访问方法名称及其参数，因此可能难以确定正在操作的业务对象并生成面向业务的活动审计日志条目。
- en: Use event sourcing
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用事件溯源
- en: The third and final option is to implement your business logic using event sourcing.
    As mentioned in [chapter 6](kindle_split_014.xhtml#ch06), *event sourcing* automatically
    provides an audit log for create and update operations. You need to record the
    identity of the user in each event. One limitation with using event sourcing,
    though, is that it doesn’t record queries. If your service must create log entries
    for queries, then you’ll have to use one of the other options as well.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种也是最后一种选择是使用事件溯源来实现你的业务逻辑。如[第6章](kindle_split_014.xhtml#ch06)所述，*事件溯源*自动为创建和更新操作提供审计日志。你需要在每个事件中记录用户的身份。然而，使用事件溯源的一个局限性是它不记录查询。如果你的服务必须为查询创建日志条目，那么你将不得不使用其他选项之一。
- en: 11.4\. Developing services using the Microservice chassis pattern
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4. 使用微服务底盘模式开发服务
- en: This chapter has described numerous concerns that a service must implement,
    including metrics, reporting exceptions to an exception tracker, logging and health
    checks, externalized configuration, and security. Moreover, as described in [chapter
    3](kindle_split_011.xhtml#ch03), a service may also need to handle service discovery
    and implement circuit breakers. That’s not something you’d want to set up from
    scratch each time you implement a new service. If you did, it would potentially
    be days, if not weeks, before you wrote your first line of business logic.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了服务必须实现的各种问题，包括指标、向异常跟踪器报告异常、日志记录和健康检查、外部化配置以及安全性。此外，如[第3章](kindle_split_011.xhtml#ch03)所述，服务还可能需要处理服务发现和实现断路器。这不是每次实现新服务时都希望从头开始设置的事情。如果你这样做，可能需要几天甚至几周的时间才能编写第一行业务逻辑。
- en: '|  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Microservice chassis**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：微服务底盘**'
- en: Build services on a framework or collection of frameworks that handle cross-cutting
    concerns, such as exception tracking, logging, health checks, externalized configuration,
    and distributed tracing. See [http://microservices.io/patterns/microservice-chassis.html](http://microservices.io/patterns/microservice-chassis.html).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理跨切面关注点（如异常跟踪、日志记录、健康检查、外部化配置和分布式跟踪）的框架或框架集合上构建服务。请参阅[http://microservices.io/patterns/microservice-chassis.html](http://microservices.io/patterns/microservice-chassis.html)。
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A much faster way to develop services is to build your services upon a microservices
    chassis. As [figure 11.16](#ch11fig16) shows, a *microservice chassis* is a framework
    or set of frameworks that handle these concerns. When using a microservice chassis,
    you write little, if any, code to handle these concerns.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 开发服务的一个更快的方法是在微服务底盘上构建你的服务。如图11.16所示，*微服务底盘*是一个框架或一系列框架，用于处理这些问题。当使用微服务底盘时，你几乎不需要编写代码来处理这些问题。
- en: Figure 11.16\. A microservice chassis is a framework that handles numerous concerns,
    such as exception tracking, logging, health checks, externalized configuration,
    and distributed tracing.
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.16\. 微服务框架是一个处理众多问题的框架，例如异常跟踪、日志记录、健康检查、外部化配置和分布式跟踪。
- en: '![](Images/11fig16.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig16.jpg)'
- en: In this section, I first describe the concept of a microservice chassis and
    suggest some excellent microservice chassis frameworks. After that I introduce
    the concept of a service mesh, which at the time of writing is emerging as an
    intriguing alternative to using frameworks and libraries.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我首先描述微服务框架的概念，并提出一些优秀的微服务框架。然后，我介绍服务网格的概念，在写作时，它正成为使用框架和库的有趣替代品。
- en: Let’s first look at the idea of a microservice chassis.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看微服务框架的想法。
- en: 11.4.1\. Using a microservice chassis
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1\. 使用微服务框架
- en: 'A microservices chassis is a framework or set of frameworks that handle numerous
    concerns including the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务框架是一个或一组框架，处理包括以下在内的众多问题：
- en: Externalized configuration
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部化配置
- en: Health checks
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查
- en: Application metrics
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序指标
- en: Service discovery
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Circuit breakers
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: Distributed tracing
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: It significantly reduces the amount of code you need to write. You may not even
    need to write any code. Instead, you configure the microservice chassis to fit
    your requirements. A microservice chassis enables you to focus on developing your
    service’s business logic.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 它显著减少了你需要编写的代码量。你可能甚至不需要编写任何代码。相反，你配置微服务框架以满足你的需求。微服务框架使你能够专注于开发你服务的业务逻辑。
- en: The FTGO application uses Spring Boot and Spring Cloud as the microservice chassis.
    Spring Boot provides functions such as externalized configuration. Spring Cloud
    provides functions such as circuit breakers. It also implements client-side service
    discovery, although the FTGO application relies on the infrastructure for service
    discovery. Spring Boot and Spring Cloud aren’t the only microservice chassis frameworks.
    If, for example, you’re writing services in GoLang, you could use either Go Kit
    ([https://github.com/go-kit/kit](https://github.com/go-kit/kit)) or Micro ([https://github.com/micro/micro](https://github.com/micro/micro)).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序使用Spring Boot和Spring Cloud作为微服务框架。Spring Boot提供外部化配置等功能。Spring Cloud提供断路器等功能。它还实现了客户端服务发现，尽管FTGO应用程序依赖于基础设施进行服务发现。Spring
    Boot和Spring Cloud并不是唯一的微服务框架。例如，如果你在GoLang中编写服务，你可以使用Go Kit ([https://github.com/go-kit/kit](https://github.com/go-kit/kit))
    或 Micro ([https://github.com/micro/micro](https://github.com/micro/micro))。
- en: One drawback of using a microservice chassis is that you need one for every
    language/platform combination that you use to develop services. Fortunately, it’s
    likely that many of the functions implemented by a microservice chassis will instead
    be implemented by the infrastructure. For example, as described in [chapter 3](kindle_split_011.xhtml#ch03),
    many deployment environments handle service discovery. What’s more, many of the
    network-related functions of a microservice chassis will be handled by what’s
    known as a service mesh, an infrastructure layer running outside of the services.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务框架的一个缺点是，你需要为每个你用来开发服务的语言/平台组合使用一个。幸运的是，许多微服务框架实现的功能可能会由基础设施来实现。例如，如第3章所述，许多部署环境处理服务发现。更重要的是，微服务框架的许多网络相关功能将由所谓的服务网格来处理，这是一个运行在服务之外的基础设施层。
- en: 11.4.2\. From microservice chassis to service mesh
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.2\. 从微服务框架到服务网格
- en: A microservice chassis is a good way to implement various cross-cutting concerns,
    such as circuit breakers. But one obstacle to using a microservice chassis is
    that you need one for each programming language you use. For example, Spring Boot
    and Spring Cloud are useful if you’re a Java/Spring developer, but they aren’t
    any help if you want to write a NodeJS-based service.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务框架是实现各种横切关注点的好方法，例如断路器。但使用微服务框架的一个障碍是，你需要为每种编程语言使用一个。例如，如果你是Java/Spring开发者，Spring
    Boot和Spring Cloud很有用，但如果你想编写基于NodeJS的服务，它们就帮不上忙了。
- en: '|  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Service mesh**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：服务网格**'
- en: Route all network traffic in and out of services through a networking layer
    that implements various concerns, including circuit breakers, distributed tracing,
    service discovery, load balancing, and rule-based traffic routing. See [http://microservices.io/patterns/deployment/service-mesh.html](http://microservices.io/patterns/deployment/service-mesh.html).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有网络流量通过一个实现各种关注点的网络层进出服务，包括断路器、分布式跟踪、服务发现、负载均衡和基于规则的流量路由。请参阅[http://microservices.io/patterns/deployment/service-mesh.html](http://microservices.io/patterns/deployment/service-mesh.html)。
- en: '|  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: An emerging alternative that avoids this problem is to implement some of this
    functionality outside of the service in what’s known as a service mesh. A *service
    mesh* is networking infrastructure that mediates the communication between a service
    and other services and external applications. As [figure 11.17](#ch11fig17) shows,
    all network traffic in and out of a service goes through the service mesh. It
    implements various concerns including circuit breakers, distributed tracing, service
    discovery, load balancing, and rule-based traffic routing. A service mesh can
    also secure interprocess communication by using TLS-based IPC between services.
    As a result, you no longer need to implement these particular concerns in the
    services.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 一种避免此问题的新兴替代方案是在所谓的服务网格之外实现一些此功能。*服务网格*是一种网络基础设施，它调解服务与其他服务和外部应用程序之间的通信。如图11.17所示，所有进出服务的网络流量都通过服务网格。它实现了包括断路器、分布式跟踪、服务发现、负载均衡和基于规则的流量路由在内的各种关注点。服务网格还可以通过在服务之间使用基于TLS的IPC来确保进程间通信。因此，你不再需要在服务中实现这些特定的关注点。
- en: Figure 11.17\. All network traffic in and out of a service flows through the
    service mesh. The service mesh implements various functions including circuit
    breakers, distributed tracing, service discovery, and load balancing. Fewer functions
    are implemented by the microservice chassis. It also secures interprocess communication
    by using TLS-based IPC between services.
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.17。所有进出服务的网络流量都通过服务网格。服务网格实现了包括断路器、分布式跟踪、服务发现和负载均衡在内的各种功能。微服务底盘实现的功能较少。它还通过在服务之间使用基于TLS的IPC来确保进程间通信。
- en: '![](Images/11fig17_alt.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig17_alt.jpg)'
- en: When using a service mesh, the microservice chassis is much simpler. It only
    needs to implement concerns that are tightly integrated with the application code,
    such as externalized configuration and health checks. The microservice chassis
    must support distributed tracing by propagating distributed tracing information,
    such as the B3 standard headers I discussed earlier in [section 11.3.3](#ch11lev2sec7).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用服务网格时，微服务底盘要简单得多。它只需要实现与应用程序代码紧密集成的关注点，例如外部化配置和健康检查。微服务底盘必须通过传播分布式跟踪信息（如我之前在[11.3.3节](#ch11lev2sec7)中讨论的B3标准头）来支持分布式跟踪。
- en: The service mesh concept is an extremely promising idea. It frees the developer
    from having to deal with various cross-cutting concerns. Also, the ability of
    a service mesh to route traffic enables you to separate deployment from release.
    It gives you the ability to deploy a new version of a service into production
    but only release it to certain users, such as internal test users. [Chapter 12](kindle_split_020.xhtml#ch12)
    discusses this concept further when describing how to deploy services using Kubernetes.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格的概念是一个极具前景的想法。它使开发者免于处理各种横切关注点。此外，服务网格路由流量的能力使您能够将部署与发布分离。它使您能够将服务的全新版本部署到生产环境中，但仅向某些用户（如内部测试用户）发布。[第12章](kindle_split_020.xhtml#ch12)在描述如何使用Kubernetes部署服务时进一步讨论了这一概念。
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The current state of service mesh implementations**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务网格实现的当前状态**'
- en: 'There are various service mesh implementations, including the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种服务网格实现，包括以下：
- en: Istio ([https://istio.io](https://istio.io))
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio ([https://istio.io](https://istio.io))
- en: Linkerd ([https://linkerd.io](https://linkerd.io))
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linkerd ([https://linkerd.io](https://linkerd.io))
- en: Conduit ([https://conduit.io](https://conduit.io))
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Conduit ([https://conduit.io](https://conduit.io))
- en: As of the time of writing, Linkerd is the most mature, with Istio and Conduit
    still under active development. For more information about this exciting new technology,
    take a look at each product’s documentation.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 到写作时为止，Linkerd是最成熟的，而Istio和Conduit仍在积极开发中。有关这项激动人心的新技术的更多信息，请查看每个产品的文档。
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: It’s essential that a service implements its functional requirements, but it
    must also be secure, configurable, and observable.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务实现其功能需求是至关重要的，但它还必须是安全的、可配置的和可观察的。
- en: Many aspects of security in a microservice architecture are no different than
    in a monolithic architecture. But there are some aspects of application security
    that are necessarily different, including how user identity is passed between
    the API gateway and the services and who is responsible for authentication and
    authorization. A commonly used approach is for the API gateway to authenticate
    clients. The API gateway includes a transparent token, such as a JWT, in each
    request to a service. The token contains the identity of the principal and their
    roles. The services use the information in the token to authorize access to resources.
    OAuth 2.0 is a good foundation for security in a microservice architecture.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务架构中的许多安全方面与单体架构并无二致。但也有一些应用安全方面的考虑是必然不同的，包括用户身份如何在API网关和服务之间传递，以及谁负责认证和授权。常用的方法是由API网关对客户端进行认证。API网关在每个请求中包含一个透明的令牌，例如JWT，发送到服务。令牌包含主体的身份及其角色。服务使用令牌中的信息来授权对资源的访问。OAuth
    2.0是微服务架构中安全性的良好基础。
- en: A service typically uses one or more external services, such as message brokers
    and databases. The network location and credentials of each external service often
    depend on the environment that the service is running in. You must apply the Externalized
    configuration pattern and implement a mechanism that provides a service with configuration
    properties at runtime. One commonly used approach is for the deployment infrastructure
    to supply those properties via operating system environment variables or a properties
    file when it creates a service instance. Another option is for a service instance
    to retrieve its configuration from a configuration properties server.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务通常使用一个或多个外部服务，例如消息代理和数据库。每个外部服务的网络位置和凭证通常取决于服务运行的环境。你必须应用外部化配置模式并实现一种机制，在运行时为服务提供配置属性。一种常用的方法是部署基础设施在创建服务实例时通过操作系统环境变量或属性文件提供这些属性。另一种选择是服务实例从配置属性服务器检索其配置。
- en: Operations and developers share responsibility for implementing the observability
    patterns. Operations is responsible for the observability infrastructure, such
    as servers that handle log aggregation, metrics, exception tracking, and distributed
    tracing. Developers are responsible for ensuring that their services are observable.
    Services must have health check API endpoints, generate log entries, collect and
    expose metrics, report exceptions to an exception tracking service, and implement
    distributed tracing.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运维和开发人员共同负责实现可观察性模式。运维负责可观察性基础设施，例如处理日志聚合、指标、异常跟踪和分布式跟踪的服务器。开发人员负责确保他们的服务是可观察的。服务必须具有健康检查API端点、生成日志条目、收集和公开指标、向异常跟踪服务报告异常以及实现分布式跟踪。
- en: In order to simplify and accelerate development, you should develop services
    on top of a microservices chassis. A microservices chassis is framework or set
    of frameworks that handle various cross-cutting concerns, including those described
    in this chapter. Over time, though, it’s likely that many of the networking-related
    functions of a microservice chassis will migrate into a service mesh, a layer
    of infrastructure software through which all of a service’s network traffic flows.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化并加速开发，你应该在微服务框架之上开发服务。微服务框架是一个或一组框架，用于处理各种横切关注点，包括本章中描述的那些。然而，随着时间的推移，许多与微服务框架相关的网络功能可能会迁移到服务网格，这是一个基础设施软件层，所有服务的网络流量都通过它流动。
