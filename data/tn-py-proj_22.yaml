- en: '21 Tic-Tac-Toe: Exploring state'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21 井字棋：探索状态
- en: '| One of my favorite movies is the 1983 release *War Games* starring Matthew
    Broderick, whose character, David, plays a young hacker who enjoys cracking into
    computer systems ranging from his school’s grade book to a Pentagon server that
    has the potential to launch intercontinental ballistic missiles. Central to the
    plot is the game of Tic-Tac-Toe, a game so simple that it usually ends in a draw
    between the two players. | ![](../Images/21-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 我最喜欢的电影之一是1983年上映的*《战争游戏》*，由马修·布罗德里克主演，他的角色大卫是一个喜欢破解从学校成绩册到可能发射洲际弹道导弹的五角大楼服务器的年轻黑客。情节的核心是井字棋游戏，这是一个如此简单的游戏，通常以平局结束。|
    ![图片](../Images/21-unnumb-1.png) |'
- en: In the movie, David engages Joshua, an artificial intelligence (AI) agent, who
    is capable of playing lots of nice games like chess. David would rather play the
    game Global Thermonuclear War with Joshua. Eventually David realizes that Joshua
    is using the simulation of a war game to trick the US military into initiating
    a nuclear first strike against the Soviet Union. Understanding the mutually assured
    destruction (MAD) doctrine, David asks Joshua to play himself at Tic-Tac-Toe so
    that he can explore the futility of games that can never result in victory. After
    hundreds or thousands of rounds all ending in draws, Joshua concludes that “the
    only winning move is not to play,” at which point Joshua stops trying to destroy
    the Earth and suggests instead that they could play “a nice game of chess.”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影中，大卫与人工智能（AI）代理约书亚互动，约书亚能够玩很多很好的游戏，比如国际象棋。大卫更愿意与约书亚玩全球热核战争游戏。最终，大卫意识到约书亚正在使用战争游戏的模拟来欺骗美国军方对苏联进行核首先打击。理解相互确保摧毁（MAD）学说后，大卫要求约书亚自己玩井字棋，这样他就可以探索那些永远无法取得胜利的游戏的无意义。经过数百或数千轮都以平局结束，约书亚得出结论，“唯一的胜利策略是不玩”，这时约书亚停止了试图摧毁地球，并建议他们可以玩“一场美好的国际象棋游戏”。
- en: I assume you already know the game of Tic-Tac-Toe, but we’ll review briefly
    in case your childhood missed countless games of this with your friends. The game
    starts out with a 3-by-3 square grid. There are two players who take turns marking
    first X and then O in the cells. A player wins by placing their mark in any three
    squares in a straight line, horizontally, vertically, or diagonally. This is usually
    impossible, as each player will generally use their moves to block a potential
    win by their opponent.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经知道井字棋游戏，但为了以防你的童年错过了无数与朋友玩的游戏，我们将简要回顾。游戏从一个3x3的方格网格开始。有两个玩家轮流在单元格中标记X和O。一个玩家通过在水平、垂直或对角线上放置标记在任意三个单元格中获胜。这通常是不可能的，因为每个玩家通常都会利用他们的移动来阻止对手可能的胜利。
- en: We will spend the last two chapters writing Tic-Tac-Toe. We will explore ideas
    for representing and tracking program *state*, which is a way of thinking about
    how the pieces of a program change over time. For instance, we’ll start off with
    a blank board, and the first player to go is X. Play alternates between the X
    and O, and after each round two cells on the board will have been taken by the
    two players. We’ll need to keep track of these moves and more, so that, at any
    moment, we always know the state of the game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在最后两章中编写井字棋。我们将探讨表示和跟踪程序*状态*的想法，这是一种思考程序组件随时间变化的方式。例如，我们将从一个空白的棋盘开始，第一个行动的玩家是X。玩家轮流在单元格中标记X和O，每一轮后，棋盘上的两个单元格将被两位玩家占据。我们需要记录这些移动以及更多内容，以便在任何时刻，我们都能知道游戏的状态。
- en: If you recall, the hidden state of the `random` module proved to be a problem
    in chapter 20, where an early solution we explored produced inconsistent results
    depending on the order of the operations that used the module. In this exercise,
    we’re going to think about ways to make the state of our game, and any changes
    to it, explicit.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在第二十章中，`random`模块的隐藏状态证明是一个问题，我们探索的一个早期解决方案产生了不一致的结果，这取决于使用该模块的操作顺序。在这个练习中，我们将思考如何使我们的游戏状态及其任何更改明确化。
- en: In this chapter, we’ll write a program that plays just one turn of the game;
    then in the next chapter we’ll expand the program to handle a full game. This
    version of the program will be given a string that represents the state of the
    playing board at any time during a game. The default is the empty board at the
    beginning of the game, before either player has made a move. The program may also
    be given one move to add to that board. It will print a picture of the board and
    report if there is a winner after making the move.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个程序，该程序只玩一次游戏；然后在下一章中，我们将扩展程序以处理完整游戏。这个版本的程序将得到一个表示游戏过程中任何时刻棋盘状态的字符串。默认情况下，是游戏开始时空棋盘的状态，在任一玩家移动之前。程序还可以得到一个要添加到该棋盘上的移动。程序将打印棋盘的图片，并在移动后报告是否有赢家。
- en: 'For this program, we need to track at least two ideas in our state:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个程序，我们需要在我们的状态中跟踪至少两个想法：
- en: The board, identifying which player has marked which squares of the grid
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋盘，标识哪个玩家标记了网格中的哪个方格
- en: The winner, if there is one
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有赢家
- en: For the next version, we’ll write an interactive version of the game where we
    will need to track and update several more items in the state through a complete
    game of Tic-Tac-Toe.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个版本，我们将编写一个交互式游戏版本，其中我们需要通过完整的一局井字棋来跟踪和更新状态中的更多项目。
- en: In this exercise, you will
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将
- en: Consider how to use elements like strings and lists to represent aspects of
    a program’s state
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑如何使用字符串和列表等元素来表示程序的状态方面
- en: Enforce the rules of a game in code, such as preventing a player from playing
    in a cell that has already been taken
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中强制执行游戏的规则，例如防止玩家在已被占用的单元格中玩游戏
- en: Use a regular expression to validate the initial board
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式验证初始棋盘
- en: Use `and` and `or` to reduce combinations of Boolean values to a single value
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`and`和`or`将布尔值的组合减少到单个值
- en: Use lists of lists to find a winning board
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表的列表来找到获胜的棋盘
- en: Use the `enumerate()` function to iterate a `list` with the index and value
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`enumerate()`函数迭代带有索引和值的`list`
- en: 21.1 Writing tictactoe.py
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.1 编写tictactoe.py
- en: You will create a program called tictactoe.py in the 21_tictactoe directory.
    As usual, I would recommend you start the program using new.py or template.py.
    Let’s discuss the parameters for the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在21_tictactoe目录下创建一个名为tictactoe.py的程序。像往常一样，我建议你使用new.py或template.py来启动程序。让我们来讨论程序的参数。
- en: 'The initial state of the board will come from a `-b` or `--board` option that
    describes which cells are occupied by which players. Since there are nine cells,
    we’ll use a string that is nine characters long, composed only of the characters
    `X` and `O`, or the period (`.`) to indicate that the cell is open. The default
    board will be a string of nine dots. When you display the board, you will either
    display the player’s mark in a cell or the cell’s number, from one to nine. In
    the next version of the game, this number will be used by the player to identify
    a cell for their move. As there is no winner for the default board, the program
    should print “No winner”:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘的初始状态将来自`-b`或`--board`选项，该选项描述了哪个单元格被哪个玩家占据。由于有九个单元格，我们将使用一个九个字符长的字符串，只由字符`X`和`O`组成，或者用句点（`.`）表示单元格是开放的。默认棋盘将是一个由九个点组成的字符串。当你显示棋盘时，你将显示玩家的标记或单元格的编号，从一到九。在游戏的下一个版本中，这个数字将被玩家用来识别他们的移动。由于默认棋盘没有赢家，程序应打印“没有赢家”：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `--board` option will describe which cells should be marked for which player,
    where the positions in the string describe the different cells, ascending from
    1 to 9\. In the string `X.O..O..X`, the positions 1 and 9 are occupied by “X”
    and positions 3 and 6 by “O” (see figure 21.1).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`--board`选项将描述哪个单元格应该被哪个玩家标记，字符串中的位置描述了不同的单元格，从1到9递增。在字符串`X.O..O..X`中，位置1和9被“X”占据，位置3和6被“O”占据（见图21.1）。'
- en: '![](../Images/21-1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/21-1.png)'
- en: Figure 21.1 The board is nine characters describing the nine cells of the board.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.1 棋盘由九个字符描述棋盘的九个单元格。
- en: 'Here is how that grid would be rendered by the program:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序如何渲染该网格的：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can additionally modify the given `--board` by passing a `-c` or `--cell`
    option of 1-9 *and* a `-p` or `--player` option of “X” or “O.” For instance, we
    can mark the first cell as “X” like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过传递`-c`或`--cell`选项1-9和`-p`或`--player`选项“X”或“O”来修改给定的`--board`。例如，我们可以这样标记第一个单元格为“X”：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The winner, if any, should be declared with gusto:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有赢家，应该热情地宣布：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As usual, we’ll use a test suite to ensure that our program works properly.
    Figure 21.2 shows the string diagram.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将使用测试套件来确保我们的程序正常工作。图 21.2 显示了字符串图。
- en: '![](../Images/21-2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/21-2.png)'
- en: Figure 21.2 Our Tic-Tac-Toe program will play one turn of the game using a board,
    player, and cell. It should print the board and winner.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.2 我们的井字棋程序将使用棋盘、玩家和单元格进行一回合的游戏。它应该打印棋盘和胜者。
- en: 21.1.1 Validating user input
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1.1 验证用户输入
- en: 'There’s a fair bit of input validation that needs to happen. The `--board`
    needs to ensure that any argument is exactly 9 characters and is composed only
    of `X`, `O`, and `.`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行相当多的输入验证。`--board` 需要确保任何参数恰好是 9 个字符，并且仅由 `X`、`O` 和 `.` 组成：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Likewise, the `--player` can only be `X` or `O`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`--player` 只能是 `X` 或 `O`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And the `--cell` can only be an integer value from 1 to 9:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cell` 只能是一个从 1 到 9 的整数：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Both `--player` and `--cell` must be present together, or neither can be present:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`--player` 和 `--cell` 必须同时存在，或者两者都不存在：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, if the `--cell` specified is already occupied by an `X` or an `O`,
    the program should error out:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果指定的 `--cell` 已经被 `X` 或 `O` 占据，程序应该报错：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I would recommend you put all this error checking into `get_args()` so that
    you can use `parser.error()` to throw the errors and halt the program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你将这些错误检查放入 `get_args()` 中，这样你就可以使用 `parser.error()` 抛出错误并停止程序。
- en: 21.1.2 Altering the board
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1.2 更改棋盘
- en: The initial board, once validated, describes which cells are occupied by which
    player. This board can be altered by adding the `--player` and `--cell` arguments.
    It may seem silly to not just pass in the already altered `--board`, but this
    is necessary practice for writing the interactive version.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 初始棋盘，一旦验证通过，将描述哪些单元格被哪个玩家占据。可以通过添加 `--player` 和 `--cell` 参数来更改这个棋盘。虽然直接传递已经更改的
    `--board` 可能看起来很愚蠢，但这对于编写交互式版本是必要的练习。
- en: If you represent `board` as a `str` value, like `'XX.O.O..X'`, and you need
    to change cell 3 to an `X`, for instance, how will you do that? For one thing,
    cell 3 is not found at *index* `3` in the given `board`--the index is *one less*
    than the cell number. The other issue is that a `str` is immutable. Just as in
    chapter 10’s Telephone program, you’ll need to figure out a way to modify one
    character in the board value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `board` 表示为一个 `str` 值，例如 `'XX.O.O..X'`，并且你需要将单元格 3 改为 `X`，例如，你将如何做？首先，单元格
    3 并不在给定的 `board` 的 *index* `3` 位置——索引比单元格号少一个。另一个问题是 `str` 是不可变的。就像第 10 章的电话程序一样，你需要想出一个方法来修改棋盘值中的一个字符。
- en: 21.1.3 Printing the board
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1.3 打印棋盘
- en: 'Once you have a board, you’ll need to format it with ASCII characters to create
    a grid. I recommend you make a function called `format_board()` that takes the
    `board` string as an argument and returns a `str` that uses dashes (`-`) and vertical
    pipes (`|`) to create a table. I have provided a unit.py file that contains the
    following test for the default, unoccupied grid:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了棋盘，你需要使用 ASCII 字符来格式化它，以创建一个网格。我建议你创建一个名为 `format_board()` 的函数，该函数接受 `board`
    字符串作为参数，并返回一个使用破折号 (`-`) 和垂直管道 (`|`) 创建表格的 `str`。我已经提供了一个包含以下测试的 unit.py 文件，用于默认的、未被占据的网格：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Use triple quotes because the string has embedded newlines. The final str.strip()
    call will remove the trailing newline used to format the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用三引号，因为字符串中嵌入了换行。最后的 str.strip() 调用将移除用于格式化代码的尾部换行符。
- en: ② If you multiply a string by an integer value, Python will repeat the given
    string that number of times. Here we create a string of nine dots as the input
    to format_board(). We expect the return should be an empty board as formatted
    here.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果你将一个字符串乘以一个整数值，Python 将重复给定的字符串该次数。这里我们创建了一个由九个点组成的字符串作为 format_board()
    的输入。我们期望返回的是一个格式化后的空棋盘，如下所示。
- en: 'Now try formatting a board with some other combination. Here’s another test
    I wrote that you might like to use, but feel free to write your own:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用其他组合格式化一个棋盘。以下是我编写的一个你可能想使用的测试，但当然你也可以编写自己的：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① The given board should have the first and third rows open and the second row
    with “OXX.”
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ① 给定的棋盘应该第一行和第三行是开放的，第二行是“OXX”。
- en: It would be impractical to test every possible combination for the board. When
    you’re writing tests, you’ll often have to rely on spot-checking your code. Here
    I am checking the empty board and a non-empty board. Presumably if the function
    can handle these two arguments, it can handle any others.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试棋盘的每一种可能组合都是不切实际的。当你编写测试时，你通常会依赖于对代码进行抽查。这里我正在检查空棋盘和非空棋盘。假设函数可以处理这两个参数，它应该可以处理任何其他参数。
- en: 21.1.4 Determining a winner
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1.4 确定赢家
- en: 'Once you have validated the input and printed the board, your last task is
    to declare a winner if there is one. I chose to write a function called `find_winner()`
    that returns either `X` or `O` if one of those is the winner, or returns `None`
    if there is no winner. To test this, I wrote out every possible winning board,
    to test my function with values for both players. You are welcome to use this
    test:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你验证了输入并打印了棋盘，你的最后一个任务是如果有的话宣布赢家。我选择编写一个名为`find_winner()`的函数，如果其中一个玩家是赢家，则返回`X`或`O`，如果没有赢家，则返回`None`。为了测试这个，我编写了每个可能的获胜棋盘，以测试我的函数和两个玩家的值。你可以使用这个测试：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① This is a list of the board indexes that, if occupied by the same player,
    would win.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这是一个列表，如果棋盘索引被同一玩家占据，就会赢。
- en: ② Check for both players, X and O.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ② 检查X和O两个玩家。
- en: ③ Determine which is the opposite player from X or O.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 确定X或O的对立玩家。
- en: ④ Iterate through each of the winning combinations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 遍历每个获胜组合。
- en: ⑤ Change all the P (for “player”) values in the given board to the player that
    we’re checking.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将给定棋盘中的所有P（代表“玩家”）值更改为我们要检查的玩家。
- en: ⑥ Find the indexes of the open cells (indicated by a dot).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 找到空格的索引（用点表示）。
- en: ⑦ Randomly sample two open cells. We will mutate these, so I call them mut.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 随机抽取两个空格。我们将对这些空格进行变异，所以我称它们为mut。
- en: ⑧ Alter the board to change the two selected mut cells to other_player.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 将棋盘改变，将两个选定的mut单元格更改为other_player。
- en: ⑨ Assert that find_winner() will determine that this board wins for the given
    player.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 断言find_winner()将确定这个棋盘为给定玩家赢得比赛。
- en: 'I also wanted to be sure I would not falsely claim that a losing board is winning,
    so I also wrote the following test to ensure that `None` is returned when there
    is no winner:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想要确保我不会错误地声称一个输掉的棋盘是赢的，所以我写了以下测试来确保在没有赢家时返回`None`：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① No matter how this board is arranged, it cannot win, as there are only two
    marks for each player.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ① 无论这个棋盘如何排列，它都不能赢，因为每个玩家只有两个标记。
- en: ② Run 10 tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ② 运行10次测试。
- en: ③ Shuffle the losing board into another configuration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将输掉的棋盘打乱成另一种配置。
- en: ④ Assert that, no matter how the board is arranged, we will still find no winner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 断言无论棋盘如何排列，我们都不会找到赢家。
- en: If you choose the same function names as I did, you can run `pytest` `-xv` `unit.py`
    to run the unit tests I wrote. If you wish to write different functions, you can
    create your own unit tests either inside your tictactoe.py file or in another
    unit file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择与我相同的函数名，你可以运行`pytest` `-xv` `unit.py`来运行我编写的单元测试。如果你希望编写不同的函数，你可以在你的`tictactoe.py`文件内或另一个单元文件中创建自己的单元测试。
- en: After printing the board, be sure to print “{Winner} has won!” or “No winner”
    depending on the outcome. All righty, you have your orders, so get marching!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印棋盘后，务必打印“{Winner}赢得了比赛！”或“没有赢家”取决于结果。好了，你有了命令，所以开始行动吧！
- en: 21.2 Solution
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.2 解决方案
- en: We’re taking baby steps towards the full, interactive game in the next chapter.
    Right now we need to cement some basics on how just one turn will be played. It’s
    good to make iterations of difficult programs, where you start as simply as possible
    and slowly add features to build a more complex idea.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在朝着下一章的完整、交互式游戏迈出第一步。现在我们需要巩固一些基本知识，即如何进行一回合的游戏。制作困难的程序迭代是很好的，你从尽可能简单开始，然后逐渐添加功能来构建更复杂的概念。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① The --board will default to nine dots. If you use the multiplication operator
    (*) with a string value and an integer (in any order), the result is the string
    value repeated that many times. So “'.' * 9” will produce '.........'.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ① 程序默认的棋盘是九个点。如果你使用乘法运算符（*）与一个字符串值和一个整数（任意顺序）相乘，结果是字符串值重复那么多次。所以“'.' * 9”将产生'.........'。
- en: ② The --player must be either X or O, which can be validated using choices.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ② --player必须是X或O，可以使用choices进行验证。
- en: ③ The --cell must be an integer from 1 to 9, which can be validated with type=int
    and choices=range(1, 10), remembering that the upper bound (10) is not included.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ③ --cell必须是从1到9的整数，可以使用type=int和choices=range(1, 10)进行验证，记住上限（10）不包括在内。
- en: ④ The combination of any() and all() is a way to test that both arguments are
    present or neither is.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ④ any()和all()的组合是一种测试两个参数是否都存在或都不存在的方法。
- en: ⑤ Use a regular expression to check that --board is comprised of exactly nine
    valid characters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用正则表达式检查--board是否由恰好九个有效字符组成。
- en: ⑥ If both --player and --cell are present and valid, verify that the cell in
    the board is not currently occupied.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果--player和--cell都存在且有效，验证棋盘中的单元格目前没有被占据。
- en: ⑦ Since we may need to alter the board, it’s easiest to convert it to a list.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 由于我们可能需要修改棋盘，因此将其转换为列表是最容易的。
- en: ⑧ Modify the board if both cell and player are “truthy.” Since the arguments
    are validated in get_args(), it’s safe to use them here. That is, I won’t accidentally
    assign an index value that is out of range because I have taken the time to check
    that the cell value is acceptable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 如果单元格和玩家都是“真值”，则修改棋盘。由于在get_args()中验证了参数，因此在这里使用它们是安全的。也就是说，我不会意外地分配一个超出范围的索引值，因为我已经花时间检查单元格值是否可接受。
- en: ⑨ Since the cells start numbering at 1, subtract 1 from the cell to change the
    correct index in board.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 由于单元格从1开始编号，因此从单元格中减去1以更改棋盘中的正确索引。
- en: ⑩ Print the board.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 打印棋盘。
- en: ⑪ Look for a winner in the board.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 在棋盘中寻找胜者。
- en: ⑫ Print the outcome of the game. The find_winner() function returns either X
    or O if one of the players has won, or None to no indicate no winner.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 打印游戏结果。如果某个玩家获胜，`find_winner()`函数返回X或O，如果没有胜者，则返回`None`。
- en: ⑬ Define a function to format the board. The function does not print() the board
    because that would make it hard to test. The function returns a new string value
    that can be printed or tested.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个用于格式化棋盘的函数。该函数不使用print()打印棋盘，因为这会使测试变得困难。函数返回一个新的字符串值，该值可以被打印或测试。
- en: ⑭ Iterate through the cells in the board and decide whether to print the player,
    if the cell is occupied, or the cell number, if it is not.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 遍历棋盘中的单元格，并决定是否打印玩家，如果单元格被占用，或者单元格编号，如果它没有被占用。
- en: ⑮ The return from the function is a new string created by joining all the lines
    of the grid on newlines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 函数的返回值是由所有网格行通过换行符连接而成的新字符串。
- en: ⑯ Define a function that returns a winner or the value None if there is no winner.
    Again, the function does not print() the winner but only returns an answer that
    can be printed or tested.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 定义一个函数，该函数返回胜者或如果没有胜者则返回`None`。同样，该函数不使用print()打印胜者，而只返回可以打印或测试的答案。
- en: ⑰ There are eight winning boards, which are defined as eight lists of the cells
    that need to be occupied by the same player. Note that I chose here to represent
    the actual zero-offset index values and not the 1-based values I expect from the
    user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 有八个获胜的棋盘，这些棋盘定义为八个需要由同一玩家占用的单元格列表。请注意，我选择在这里表示实际的零偏移索引值，而不是我期望的用户提供的基于1的值。
- en: ⑱ Iterate through both players, X and O.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ⑱ 遍历两个玩家，X和O。
- en: ⑲ Iterate through each winning combination of cells, unpacking them into the
    variables i, j, and k.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ⑲ 遍历每个获胜的单元格组合，将它们解包到变量i、j和k中。
- en: ⑳ Create a combo that is the value of the board for each of i, j, and k.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ⑳ 为每个i、j和k创建一个组合，该组合是棋盘的值。
- en: ㉑ Check if the combo is the same player in every position.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ㉑ 检查组合是否在每个位置上都是同一玩家。
- en: ㉒ If that is True, return the player. If this is never True for any of the combinations,
    we exit the function without returning a value, and so None is returned by default.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ㉒ 如果这是真的，则返回玩家。如果这些组合中的任何一个永远不会为真，我们将不返回值地退出函数，因此默认返回`None`。
- en: 21.2.1 Validating the arguments and mutating the board
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2.1 验证参数和修改棋盘
- en: 'Most of the validation can be handled by using `argparse` effectively. Both
    the `--player` and `--cell` options can be handled by the `choices` option. It’s
    worth taking time to appreciate the use of `any()` and `all()` in this code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数验证可以通过有效地使用`argparse`来处理。`--player`和`--cell`选项都可以通过`choices`选项来处理。花时间欣赏`any()`和`all()`在此代码中的使用是值得的：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can play with these functions in the REPL. The `any()` function is the same
    as using `or` in between Boolean values:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在REPL中玩这些函数。`any()`函数与在布尔值之间使用`or`相同：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If *any* of the items in a given `list` is “truthy,” the whole expression will
    evaluate to `True`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定`list`中的任何项是“真值”，则整个表达式将评估为`True`：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If `cell` is a non-zero value, and `player` is not the empty string, they are
    both “truthy”:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cell`是一个非零值，并且`player`不是空字符串，它们都是“真值”：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `all()` function is the same as using `and` in between all the elements
    in a `list`, so *all* of the elements need to be “truthy” in order for the whole
    expression to be `True`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()`函数与在`list`的所有元素之间使用`and`相同，因此为了使整个表达式为`True`，所有元素都需要是“真值”：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Why does that return `X`? It returns the last “truthy” value, which is the
    `player` value, so if we reverse the arguments, we’ll get the `cell` value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么返回`X`？它返回最后一个“真值”，即`player`值，因此如果我们反转参数，我们将得到`cell`值：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we use `all()`, it evaluates the truthiness of `and`ing the values, which
    will be `True`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `all()`，它将评估 `and` 值的真值，这将返回 `True`：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are trying to figure out if the user has provided only *one* of the arguments
    for `--player` and `--cell`, because we need both or we want neither. So we pretend
    `cell` is `None` (the default) but `player` is `X`. It’s true that `any()` of
    those values is “truthy”:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在试图弄清楚用户是否只提供了 `--player` 和 `--cell` 这两个参数中的一个，因为我们需要两者，或者我们都不需要。所以我们将 `cell`
    假设为 `None`（默认值），而 `player` 是 `X`。确实，`any()` 这些值中的任何一个都是“真值”：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But it’s not true that they *both* are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们 *两个* 都不是：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So when we `and` those two expressions, they return `False`,
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们 `and` 这两个表达式时，它们返回 `False`，
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'because that is the same as saying this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这等同于说：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The default for `--board` is provided as nine dots, and we can use a regular
    expression to verify that it’s correct:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`--board` 的默认值是九个点，我们可以使用正则表达式来验证它是否正确：'
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our regular expression creates a character class composed of the dot (`.`),
    “X,” and “O” by using `[.XO]`. The `{9}` indicates that there must be exactly
    9 characters, and the `^` and `$` characters anchor the expression to the beginning
    and end of the string, respectively (see figure 21.3).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的正则表达式通过使用 `[.XO]` 创建了一个由点（`.`）、“X”和“O”组成的字符类。`{9}` 表示必须有恰好9个字符，`^` 和 `$`
    字符分别将表达式锚定到字符串的开始和结束（见图21.3）。
- en: '![](../Images/21-3.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-3.png)'
- en: Figure 21.3 We can use a regular expression to exactly describe a valid `--board`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.3 我们可以使用正则表达式精确地描述一个有效的 `--board`。
- en: 'You could manually validate this using the magic of `all()` again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `all()` 的魔法手动验证这一点：
- en: Is the length of `board` exactly 9 characters?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board` 的长度是否正好是9个字符？'
- en: Is it true that each of the characters is one of those allowed?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否每个字符都是允许的字符之一？
- en: 'Here is one way to write it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种编写方式：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `all()` part is checking this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()` 部分正在检查这一点：'
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since each character `c` (“cell”) in `board` is in the allowed set of characters,
    all the comparisons are `True`. If we change one of the characters, a `False`
    will show up:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `board` 中的每个字符 `c`（“单元格”）都在允许的字符集中，所有比较都是 `True`。如果我们更改其中一个字符，就会显示 `False`：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Any `False` value in an `all()` expression will return `False`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()` 表达式中的任何 `False` 值都会返回 `False`：'
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last piece of validation checks if the `--cell` being set to `--player`
    is already occupied:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的验证检查即将设置的 `--cell` 为 `--player` 是否已被占用：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because `--cell` starts counting from 1 instead of 0, we must subtract 1 when
    we use it as an index into the `--board` argument. Given the following inputs,
    the first cell has been set to `X`, and now `O` wants the same cell:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `--cell` 从1开始计数而不是0，所以当我们用它作为 `--board` 参数的索引时，我们必须减去1。给定以下输入，第一个单元格已被设置为
    `X`，现在 `O` 想要相同的单元格：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can ask if the value in `board` at `cell` `-` `1` has already been set:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以询问 `board` 中 `cell` `-` `1` 的值是否已经被设置：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or you could instead check if that position is *not* a dot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以检查该位置是否 *不是* 点：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It’s rather exhausting to validate all the inputs, but this is the only way
    to ensure that the game is played properly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 验证所有输入相当累人，但这是确保游戏正确进行的唯一方法。
- en: 'In the `main()` function, we might need to alter the `board` of the game if
    there are arguments for both cell and player. I decided to make `board` into a
    `list` precisely because I might need to alter it in this way:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，如果存在单元格和玩家的参数，我们可能需要更改游戏的 `board`。我决定将 `board` 变成一个 `list`，正是因为我可能需要以这种方式更改它：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 21.2.2 Formatting the board
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2.2 格式化网格
- en: 'Now it’s time to create the grid. I chose to create a function that returns
    a string value that I could test rather than directly printing the grid. Here
    is my version:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建网格了。我选择创建一个返回字符串值的函数，这样我就可以测试它，而不是直接打印网格。这是我的版本：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① I used a list comprehension to iterate through each position and character
    of board using the enumerate() function. Because I would rather start counting
    from index position 1 than 0, I used the start=1 option. If the character is a
    dot, I want to print the position as the cell number; otherwise, I print the character,
    which will be X or O.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我使用列表推导式通过 `enumerate()` 函数遍历 `board` 的每个位置和字符。因为我更愿意从索引位置1开始计数而不是0，所以我使用了
    `start=1` 选项。如果字符是点，我想打印位置作为单元格编号；否则，我打印字符，这将可能是X或O。
- en: ② The asterisk, or “splat” (*), is shorthand to expand the list returned by
    the list slice operation into values that the str.format() function can use.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ② 星号，或“splat” (*)，是展开列表切片操作返回的列表的简写，以便 `str.format()` 函数可以使用。
- en: 'The “splat” syntax of `*cell[:3]` is a shorter way of writing the code, like
    so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`*cell[:3]`的“展开”语法是编写代码的更简短方式，如下所示：'
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `enumerate()` function returns a `list` of tuples that include the index
    and value of each element in a `list` (see figure 21.4). Since it’s a lazy function,
    I must use the `list()` function in the REPL to view the values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`函数返回一个包含列表中每个元素的索引和值的元组列表（见图21.4）。由于它是一个惰性函数，我必须在REPL中使用`list()`函数来查看值：'
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](../Images/21-4.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/21-4.png)'
- en: Figure 21.4 The `enumerate()` function will return the index and value of items
    in a series. By default, the initial index is 0.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.4 `enumerate()`函数将返回一系列中的项的索引和值。默认情况下，初始索引为0。
- en: 'In this instance, I would rather start counting at 1, so I can use the `start=1`
    option:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我宁愿从1开始计数，所以我可以使用`start=1`选项：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This list comprehension could alternatively be written as a `for` loop:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表推导式也可以写成`for`循环的形式：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Initialize an empty list to hold the cells.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化一个空列表来存储单元格。
- en: ② Unpack each tuple of the index (starting at 1) and value of each character
    in board into the variables i (for “integer”) and char.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将棋盘上每个字符的索引（从1开始）和值分别解包到变量i（代表“整数”）和char中。
- en: ③ If the char is a dot, use the string version of the i value; otherwise, use
    the char value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果char是一个点，使用i值的字符串版本；否则，使用char值。
- en: Figure 21.5 illustrates how `enumerate()` is unpacked into `i` and `char`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.5说明了`enumerate()`是如何解包到`i`和`char`中的。
- en: '![](../Images/21-5.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/21-5.png)'
- en: Figure 21.5 The tuples containing the indexes and values returned by `enumerate()`
    can be assigned to two variables in the `for` loop.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.5 `enumerate()` 返回的包含索引和值的元组可以被分配到`for`循环中的两个变量中。
- en: This version of `format_board()` passes all the tests found in unit.py.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`format_board()`通过了在unit.py中找到的所有测试。
- en: 21.2.3 Finding the winner
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2.3 寻找获胜者
- en: The last major piece to this program is determining if either player has won
    by placing three of their marks in a row horizontally, vertically, or diagonally.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一个主要部分是确定是否有玩家通过在水平、垂直或对角线上放置三个标记来获胜。
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① There are eight winning positions--the three horizontal rows, the three vertical
    columns, and the two diagonals--so I decided to create a list where each element
    is also a list that contains the three cells in a winning configuration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ① 有八个获胜位置——三个水平行、三个垂直列和两个对角线，所以我决定创建一个列表，其中每个元素也是一个列表，包含获胜配置中的三个单元格。
- en: ② It’s typical to use i as a variable name for “integer” values, especially
    when their life is rather brief, as here. When more similar names are needed in
    the same scope, it’s also common to use j, k, l, etc. You may prefer to use names
    like cell1, cell2, and cell3, which are more descriptive but also longer to type.
    The unpacking of the cell values is exactly the same as the unpacking of the tuples
    in the previous enumerate() code (see figure 21.6).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ② 通常使用i作为“整数”值的变量名，尤其是当它们的生命周期相对较短时，就像这里一样。当需要在同一作用域中使用更多类似的名字时，也常见使用j、k、l等。你可能更喜欢使用cell1、cell2和cell3这样的名字，这些名字更具描述性，但打字也更长。单元格值的解包与之前`enumerate()`代码中的元组解包完全相同（见图21.6）。
- en: '![](../Images/21-6.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/21-6.png)'
- en: Figure 21.6 As with the unpacking of the `enumerate()` tuples, each list of
    three elements can be unpacked into three variables in the `for` loop.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.6 与`enumerate()`元组的展开类似，三个元素的列表可以在`for`循环中解包到三个变量中。
- en: 'The rest of the code checks if either `X` or `O` is the only character at each
    of the three positions. I worked out half a dozen ways to write this, but I’ll
    just share this one alternate version that uses two of my favorite functions,
    `all()` and `map()`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码检查`X`或`O`是否是三个位置中唯一的字符。我找到了六种不同的写法，但我会分享这个使用两个我最喜欢的函数`all()`和`map()`的替代版本：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Iterate through each combination of cells in winning.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ① 遍历获胜的每个单元格组合。
- en: ② Use map() to get the value of board at each position in the combination.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用`map()`获取组合中每个位置的棋盘值。
- en: ③ Check for each player, X and O.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 检查每个玩家，X和O。
- en: ④ See if all the values in the group are equal to the given player.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 检查组中的所有值是否都等于给定玩家。
- en: ⑤ If so, return that player.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果是这样，返回那个玩家。
- en: 'If a function has no explicit `return` or never executes a `return`, as would
    be the case here when there is no winner, Python will use the `None` value as
    the default `return`. We’ll interpret `None` to mean there is no winner when we
    print the outcome of the game:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数没有明确的`return`语句或者从未执行过`return`语句，就像这里没有胜者的情况一样，Python将使用`None`值作为默认的`return`。当我们打印游戏的输出结果时，我们将`None`解释为没有胜者：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That covers this version of the game that plays just one turn of Tic-Tac-Toe.
    In the next chapter, we’ll expand these ideas into an interactive version that
    starts with a blank board and dynamically requests user input to play the game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了只玩一局井字棋的这个游戏版本。在下一章中，我们将扩展这些想法，将其扩展为一个交互式版本，该版本从空白棋盘开始，并动态请求用户输入来玩游戏。
- en: 21.3 Going further
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.3 进一步探索
- en: Write a game that will play one hand of a card game like Blackjack (Twenty-one)
    or War.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个游戏，该游戏将玩一局类似黑杰克（二十一点）或战争牌类的游戏。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This program uses a `str` value to represent the Tic-Tac-Toe board with nine
    characters representing `X`, `O`, or `.` to indicate a taken or empty cell. We
    sometimes convert that to a `list` to make it easier to modify.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个程序使用一个`str`值来表示井字棋棋盘，用九个字符表示`X`、`O`或`.`来指示已占用的或空白的单元格。我们有时将其转换为`list`，以便更容易修改。
- en: A regular expression is a handy way to validate the initial board. We can declaratively
    describe that it should be a string exactly nine characters long composed only
    of the characters `.`, `X`, and `O`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式是一种方便的方式来验证初始棋盘。我们可以声明性地描述它应该是一个由`.`、`X`和`O`字符组成的、恰好九个字符长的字符串。
- en: The `any()` function is like chaining `or` between multiple Boolean values.
    It will return `True` if *any* of the values is “truthy.”
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any()`函数类似于在多个布尔值之间使用`or`。如果任何值是“真值”，它就会返回`True`。'
- en: The `all()` function is like using `and` between multiple Boolean values. It
    will return `True` only if every one of the values is “truthy.”
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all()`函数类似于在多个布尔值之间使用`and`。只有当所有值都是“真值”时，它才会返回`True`。'
- en: The `enumerate()` function will return the list index and value for each element
    in an iterable like a `list`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate()`函数将为可迭代对象（如`list`）中的每个元素返回索引和值。'
