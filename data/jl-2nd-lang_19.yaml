- en: 15 Functional programming in Julia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 Julia 中的函数式编程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why understanding functional programming is important in Julia
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在 Julia 中理解函数式编程很重要
- en: The differences between functional and object-oriented program design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程与面向对象程序设计之间的区别
- en: Practical usage of higher-order functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数的实际应用
- en: Making your code more readable with function chaining
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数链提高代码的可读性
- en: Developing a password-keeping service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发密码管理服务
- en: Julia is a multi-paradigm programming language, but a functional programming
    style is far more common in Julia than in other mainstream languages you may be
    familiar with, such as Python, Ruby, Java, or C++. Thus, it is natural to have
    an understanding of the principles of functional programming to become a good
    Julia developer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 是一种多范式编程语言，但在 Julia 中，函数式编程风格比你在可能熟悉的其他主流语言（如 Python、Ruby、Java 或 C++）中更为常见。因此，了解函数式编程的原则对于成为一名优秀的
    Julia 开发者来说是自然而然的。
- en: Functional programming is not always the best approach to solving every problem.
    In this chapter, you will learn to build up a password-keeping service in both
    an object-oriented and a functional style, allowing you to explore the pros and
    cons of different programming styles (paradigms). Before building up a larger
    code example you will look at the core building blocks of functional programming,
    such as higher-order functions, closures, function chaining, and composition.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程并不总是解决每个问题的最佳方法。在本章中，你将学习以面向对象和函数式风格构建密码管理服务，让你能够探索不同编程风格（范式）的优缺点。在构建更大的代码示例之前，你将查看函数式编程的核心构建块，如高阶函数、闭包、函数链和组合。
- en: 15.1 How does functional programming differ from object-oriented programming?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 函数式编程与面向对象编程有何不同？
- en: Let’s take a high-level perspective on what functional programming is and why
    its covered in a Julia programming book. The first problem when discussing functional
    programming is that there is no single clear definition. In this chapter, I will
    use what I deem a pragmatic definition. Figure 15.1 shows how functional programming
    fits in with other programming paradigms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从高层次的角度来看一下函数式编程是什么以及为什么它在 Julia 编程书中被涵盖。讨论函数式编程的第一个问题是，没有单一的明确定义。在本章中，我将使用我认为是实用主义的方法。图
    15.1 展示了函数式编程如何与其他编程范式相结合。
- en: '![15-01](../Images/15-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![15-01](../Images/15-01.png)'
- en: Figure 15.1 Diagram of different programming paradigms and how they are related
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 不同编程范式及其相互关系图
- en: The most important thing I want to highlight in figure 15.1 is that *procedural*
    programming and *functional* programming are *not* the same thing. Writing code
    with a bunch of functions rather than using an object-oriented approach does not
    automatically make your code functional. That technique has been used for a long
    time in languages such as C, Fortran, and Pascal in an approach called procedural
    programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在图 15.1 中强调的最重要的一点是，**过程式**编程和**函数式**编程**不是**同一回事。用一大堆函数编写代码而不是使用面向对象的方法并不能自动使你的代码成为函数式。这种技术已经在
    C、Fortran 和 Pascal 等语言中使用了很长时间，称为过程式编程。
- en: 'Instead, functional programming usually involves a variety of different practices
    and approaches:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，函数式编程通常涉及各种不同的实践和方法：
- en: Handling functions as *first class objects*, meaning you can pass around functions
    and store them as if they were regular data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为**一等对象**处理，这意味着你可以传递函数并将它们存储为常规数据
- en: Supporting *higher-order functions*, which are functions taking functions as
    arguments
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持高阶函数，即接受函数作为参数的函数
- en: Using map, filter, and reduce instead of for loops when iterating over collections
    to perform different operations on them
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在迭代集合时使用 map、filter 和 reduce 而不是 for 循环来对它们执行不同的操作
- en: Preferring *closures* or *lambdas* instead of objects with methods to manage
    state
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先选择**闭包**或**lambda**而不是具有方法的对象来管理状态
- en: Functional programming offers many ways to combine functions in different ways
    and modularize your code at a function level.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程提供了许多不同的方法来组合函数，并在函数级别模块化你的代码。
- en: 15.2 How and why you should learn to think functionally
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 如何以及为什么你应该学会以函数式的方式思考
- en: In functional programming, we try to avoid modifying (mutating) input data,
    which makes reasoning about the flow of data through your code easier. Functions
    take inputs and transform those inputs to produce outputs, which allows you to
    think about your programs as elaborate pipelines through which data flows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们试图避免修改（改变）输入数据，这使得推理代码中数据流变得更容易。函数接受输入并将这些输入转换成输出，这允许您将程序视为数据流过的复杂管道。
- en: The following listing illustrates this concept with the camel_case function
    from chapter 11, which is a nesting of multiple function calls. Each call produces
    input for the next function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表使用第 11 章中的 camel_case 函数来说明这个概念，这是一个多个函数调用的嵌套。每个调用都为下一个函数提供输入。
- en: Listing 15.1 Converting snake case to camel case
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.1 将蛇形命名法转换为驼峰命名法
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can use a data-flow diagram to visualize how the data flows between functions.
    The rounded boxes represent data transformations in a data-flow diagram, and the
    arrows are annotated with the type of data that flows along them. For instance
    string and character data flows into split, and then an array of strings flows
    out of split and into map.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数据流图来可视化函数之间数据流动的方式。数据流图中的圆形框代表数据转换，箭头标注了沿着它们流动的数据类型。例如，字符串和字符数据流入 split，然后字符串数组从
    split 流出并进入 map。
- en: Imperative programming styles, such as object-oriented programming, often make
    it very hard to perform such an analysis of data flow because functions or methods
    mutate their inputs. Instead of thinking about flows of data getting transformed,
    it is better to conceptualize the process as objects sending messages to each
    other to mutate their state.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程风格，如面向对象编程，通常使得对数据流的这种分析变得非常困难，因为函数或方法会改变它们的输入。与其思考数据流如何被转换，不如将这个过程概念化为对象相互发送消息以改变它们的状态。
- en: 15.3 Avoid deeply nested calls with function chaining
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 避免使用函数链进行深度嵌套调用
- en: Before building up larger code examples demonstrating pros and cons of functional
    programming, I want you to get a better grasp of some of the fundamental building
    blocks you have at your disposal. The camel_case function in the previous section
    was implemented in quite a functional manner but isn’t very easy to read because
    it is deeply nested. You don’t end up with anything looking like the neat pipeline
    in figure 15.2.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建展示函数式编程优缺点的大型代码示例之前，我希望您更好地掌握一些您可用的基本构建块。上一节中的 camel_case 函数以相当函数式的方式实现，但阅读起来并不容易，因为它深度嵌套。您最终得到的并不像图
    15.2 中的整洁管道。
- en: '![15-02](../Images/15-02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![15-02](../Images/15-02.png)'
- en: Figure 15.2 Data flow for the camel_case function
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 camel_case 函数的数据流
- en: However, it is possible to build something like that figure using the Julia
    pipe operator |>. It allows you to pipe the output from one function into another
    function. The following is a complete example, which I’ll break down afterward.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 Julia 的管道操作符 |> 可以构建类似该图的东西。它允许您将一个函数的输出传递到另一个函数中。以下是一个完整的示例，我将在之后对其进行分解。
- en: Listing 15.2 Camel case through function chaining
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.2 通过函数链实现驼峰命名法
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the REPL you can experiment with how the splitter and mapper functions work:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中，您可以试验分隔符和映射器函数的工作方式：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To understand listing 15.2 you need to understand the -> and |> operators. The
    -> operator is used to define what are called *anonymous functions* in Julia.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解列表 15.2，您需要了解 -> 和 |> 操作符。-> 操作符用于在 Julia 中定义所谓的 *匿名函数*。
- en: 15.3.1 Understanding anonymous functions and closures
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1 理解匿名函数和闭包
- en: An anonymous function is a function without a name. You can create one-line
    anonymous functions with the -> operator. Without anonymous functions, you would
    need to write splitter and mapper, as shown in the following listing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是没有名称的函数。您可以使用 -> 操作符创建一行匿名函数。如果没有匿名函数，您将需要编写如以下列表所示的分隔符和映射器。
- en: Listing 15.3 splitter and mapper without anonymous functions
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.3 没有匿名函数的分隔符和映射器
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The return is not needed; it is just added to emphasize that f is returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回值不是必需的；这只是添加了强调 f 被返回。
- en: ❷ This return is also not needed, but the last expression is returned anyway.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个返回值也不是必需的，但最后表达式仍然被返回。
- en: The example shows that the names of the functions being returned is not important.
    To the users of splitter and mapper it is not important that internally these
    functions got named f and g. Thus, anonymous functions are used whenever the name
    is not important. You can take one of the code examples from chapter 4 dealing
    with degrees and sine and make it neater, as in the following listing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例表明，返回的函数的名字并不重要。对于拆分器和映射器的用户来说，这些函数在内部被命名为 f 和 g 并不重要。因此，当名字不重要时，可以使用匿名函数。你可以从第
    4 章中处理度数和正弦的代码示例中取一个，使其更整洁，如下所示。
- en: Listing 15.4 Simplifying code with anonymous functions
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.4 使用匿名函数简化代码
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Named function variant
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 命名函数变体
- en: ❷ One-line variant
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 单行变体
- en: ❸ Multi-line variant
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 多行变体
- en: If you cannot fit an anonymous function within a single line, then the -> operator
    is impractical. In these cases you can use the do-end form shown at the end of
    listing 15.4.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法将匿名函数放入单行中，那么 -> 操作符就不实用了。在这些情况下，你可以使用列表 15.4 结尾所示 do-end 形式。
- en: The f and g functions returned by splitter and mapper are called closures. A
    *closure* is a function that has captured some external state not supplied as
    an argument. The f function only accepts a string str as an argument. The delimiter
    dlm used to split the string str was captured from its enclosing scope. In this
    case the splitter function definition defines the scope f inside.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分器和映射器返回的 f 和 g 函数被称为闭包。一个 *闭包* 是一个捕获了一些外部状态（不是作为参数提供的）的函数。f 函数只接受一个字符串 str
    作为参数。用于拆分字符串 str 的分隔符 dlm 是从其包围的作用域中捕获的。在这种情况下，拆分器函数定义定义了作用域 f 内部。
- en: The g function only takes collection of data xs to work on. The function fn
    to apply to each element in xs was captured from its enclosing scope defined by
    the mapper function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: g 函数只接受要处理的数据集合 xs。应用于 xs 中每个元素的函数 fn 是从由映射器函数定义的作用域中捕获的。
- en: Closures don’t need to be named. The splitter and mapper functions in listing
    15.2 return anonymous functions. These anonymous functions are also closures,
    as they capture variables from their enclosing scope. In fact, it is a fairly
    common misunderstanding to believe that a closure is just a fancy term for an
    *anonymous function*. That is not a surprising misconception, given that anonymous
    functions are so frequently used to define closures.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包不需要命名。列表 15.2 中的拆分器和映射器函数返回匿名函数。这些匿名函数也是闭包，因为它们从它们的作用域中捕获变量。事实上，认为闭包只是 *匿名函数*
    的一个花哨术语是一种相当常见的误解。考虑到匿名函数经常被用来定义闭包，这种误解并不令人惊讶。
- en: 15.3.2 Using the pipe operator |>
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2 使用管道操作符 |>
- en: Julia pipeline syntax is used to chain together functions taking single arguments
    as inputs. That allows you to rewrite a call such as f(g(x)) to x |> g |> f.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 管道语法用于将接受单个参数作为输入的函数链接在一起。这允许你将如 f(g(x)) 这样的调用重写为 x |> g |> f。
- en: 'That fact helps explain why you had to make the splitter and mapper functions.
    Normal split and map functions require multiple inputs and thus cannot be used
    with the pipe operator |>. The functions (closures) returned by splitter and mapper
    can be used in a pipeline:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实有助于解释为什么你需要创建拆分器（splitter）和映射器（mapper）函数。正常的拆分（split）和映射（map）函数需要多个输入，因此不能与管道操作符
    |> 一起使用。拆分器和映射器返回的函数（闭包）可以在管道中使用：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next important functional concept, *partial application*, is arrived at
    by simply asking the following questions: Why do you need to use the name splitter
    and mapper? Can’t you just call them split and map as well?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的函数概念，*部分应用*，是通过简单地提出以下问题而得到的：为什么你需要使用 splitter 和 mapper 的名字？难道你不能直接将它们命名为
    split 和 map 吗？
- en: 15.3.3 Conveniently produce new functions using partial application
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3 使用部分应用方便地产生新函数
- en: In computer science, *partial function application* refers to the process of
    fixing a number of arguments to a function, producing another function accepting
    fewer arguments. This definition of partial application may sound complicated,
    but with a practical example you will see that it is a lot easier than it sounds.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*部分函数应用*指的是将一定数量的参数固定到函数中，从而产生另一个接受较少参数的函数的过程。这种部分应用的定义可能听起来很复杂，但通过一个实际例子，你会发现它比听起来容易得多。
- en: If you import the split and map functions you can add new methods to them taking
    only single arguments, and thus you can define a slightly more elegant version
    of the camel_case function, as in the following listing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入了 split 和 map 函数，你可以为它们添加只接受单个参数的新方法，因此你可以定义 camel_case 函数的一个稍微更优雅的版本，如下所示。
- en: Listing 15.5 Camel case with partial application
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.5 使用部分应用实现驼峰式命名
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ To allow us to extend the split and map functions
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许我们扩展`split`和`map`函数
- en: ❷ Fixing the delimiter argument dlm of split
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 修复`split`函数的分隔符参数`dlm`
- en: ❸ Fixing the mapping function fn of map
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 修复`map`函数的映射函数`fn`
- en: In essence you allow the user of the split function to *fix* the dlm argument.
    The new split function returned as the dlm value fixed. The same principle applies
    to map. This process of fixing specific arguments to a function is partial function
    application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，您允许`split`函数的用户*固定*`dlm`参数。新的`split`函数作为固定的`dlm`值返回。同样的原则适用于`map`。将特定参数固定到函数的过程是部分函数应用。
- en: 'Since such capability is so practical many functions in the Julia standard
    library have been extended, with methods taking a subset of all required arguments,
    instead returning a function taking the rest of the arguments. Let me clarify
    with some built-in functions from the Base module (the built-in Julia module that
    is always loaded):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种能力非常实用，Julia标准库中的许多函数都进行了扩展，方法接受所有必需参数的子集，而不是返回接受其余参数的函数。让我通过Base模块（始终加载的内置Julia模块）的一些内置函数来澄清：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can verify for yourself that when the endswith function is only given a
    single argument it calls a method returning a function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以亲自验证，当`endswith`函数只提供一个参数时，它会调用一个返回函数的方法：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are some good examples of mixing and matching functions in clever ways,
    which is a large part of what functional programmers do.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些混合匹配函数的巧妙示例，这是函数式程序员所做的大量工作的一部分。
- en: 15.4 Implementing Caesar and substitution ciphers
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4 实现凯撒密码和替换密码
- en: I promised I would demonstrate how to build a password encryption service both
    in an object-oriented and a functional style. Before I do that, I need to explain
    how you can use ciphers to encrypt and decrypt passwords.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我承诺将演示如何以面向对象和函数式风格构建密码加密服务。在我这样做之前，我需要解释您如何使用密码来加密和解密密码。
- en: A *cipher* is an algorithm that takes as input what is called the *message*
    and, using a secret key, encrypts the message to produce what is called the *cipher
    text*. When you can use the same key to encrypt and decrypt it is called *symmetric*
    encryption (figure 15.3).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码*是一种算法，它接受称为*消息*的输入，并使用一个密钥加密消息，生成称为*密文*的内容。当您可以使用相同的密钥进行加密和解密时，这被称为*对称*加密（图15.3）。'
- en: '![15-03](../Images/15-03.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![15-03](../Images/15-03.png)'
- en: Figure 15.3 Symmetric encryption using a secret key
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 使用密钥进行对称加密
- en: 'I will demonstrate implementing two different ciphers: the Caesar cipher and
    the substitution cipher (figure 15.4). By making two ciphers, I will show you
    how to configure a password-keeping service to use different ciphers. Making ciphers
    exchangeable requires making abstractions, which provides an opportunity to compare
    how abstractions are built using object-oriented principles and functional programming
    principles.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我将演示实现两种不同的密码：凯撒密码和替换密码（图15.4）。通过制作两种密码，我将向您展示如何配置密码保管服务以使用不同的密码。使密码可交换需要创建抽象，这提供了一个比较使用面向对象原则和函数式编程原则构建抽象的机会。
- en: '![15-04](../Images/15-04.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![15-04](../Images/15-04.png)'
- en: Figure 15.4 The inner dial of a Caesar cipher can rotate. The inner dial of
    a substitution cipher is fixed, but the order of the alphabet will be random.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 凯撒密码的内圈盘可以旋转。替换密码的内圈盘是固定的，但字母表的顺序将是随机的。
- en: Each cipher algorithm is based on looking up a letter in the input message on
    the outer dial. Next, you will look at the corresponding letter at the inner dial
    to figure out what it should be translated to in the cipher text.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个密码算法都是基于在外圈盘上查找输入消息中的字母。接下来，您将查看内圈盘上的相应字母，以确定它在密文中应该翻译成什么。
- en: In the Caesar cipher, you can see that the letter A will translate to C, while
    B will be translated to D, and so on. Both the inner and outer dials of the Caesar
    cipher are alphabetical. The cipher *key* is how much you have rotated the inner
    dial (shifted two letters counterclockwise).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在凯撒密码中，您可以看到字母A将翻译成C，而B将翻译成D，依此类推。凯撒密码的内圈和外圈盘都是字母表。密码*密钥*是您旋转内圈盘（顺时针移动两个字母）的量。
- en: When Roman generals sent secret messages to each other, each general would have
    to know this secret key to know how much the inner dial had been rotated. Should
    the enemy learn this secret they could decrypt any message intercepted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当罗马将军们互相发送秘密信息时，每位将军都必须知道这个秘密密钥，才能知道内部拨盘旋转了多少。如果敌人得知这个秘密，他们就能解密任何截获的信息。
- en: The substitution cipher is more complex in that the inner dial itself is the
    secret key. You don’t rotate the dial but replace it entirely. For two parties
    to send secret messages to each other they need to have the same inner dial installed.
    We characterize the substitution cipher as a mapping between two alphabets. The
    letters on the outer dial form one alphabet, which is mapped to the letters on
    the inner dial; this is known as the *substitution alphabet*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代换密码更复杂，因为内部拨盘本身是秘密密钥。你不需要旋转拨盘，而是完全替换它。为了两个当事人能够互相发送秘密信息，他们需要安装相同的内部拨盘。我们将代换密码描述为两个字母表之间的映射。外部拨盘上的字母形成一个字母表，它映射到内部拨盘上的字母；这被称为*代换字母表*。
- en: I will start by demonstrating a straightforward implementation of both ciphers
    before showing an inflexible password-keeping service, which is hardwired to a
    single cipher. The next step involves showing how you can modify the ciphers and
    password-keeping service to allow the cipher used for encrypting and decrypting
    passwords to be swapped out. In the first approach, I will show how this goal
    can be accomplished using an object-oriented design, then I will demonstrate a
    functional approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先展示两种密码的简单实现，然后再展示一个不灵活的密码保管服务，该服务与单个密码硬编码在一起。下一步是展示如何修改密码和密码保管服务，以便可以更换用于加密和解密密码的密码。在第一种方法中，我将展示如何使用面向对象的设计来实现这个目标，然后我将演示一种功能性的方法。
- en: 15.4.1 Implementing the Caesar cipher
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4.1 实现凯撒密码
- en: In listing 15.6, I demonstrate implementing the Caesar cipher. The number of
    letters rotated is passed in the shift argument, and ch is the character being
    encrypted or decrypted. For both caesar_encrypt and caesar_decrypt, you need to
    check if the input character ch is actually in the alphabet. This ensures special
    symbols and whitespace will not get encrypted or decrypted.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表15.6中，我演示了实现凯撒密码。旋转的字母数量通过shift参数传递，ch是要加密或解密的字符。对于caesar_encrypt和caesar_decrypt，你需要检查输入字符ch是否实际上在字母表中。这确保了特殊符号和空白字符不会被加密或解密。
- en: Listing 15.6 Caesar cipher encryption and decryption
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.6 凯撒密码加密和解密
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Ignore characters not in the alphabet.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 忽略不在字母表中的字符。
- en: ❷ Use mod to cause a wraparound when at the end of the alphabet.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用mod在字母表末尾时产生环绕。
- en: ❸ The character is not in the alphabet, so the return is unchanged.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 字符不在字母表中，所以返回值不变。
- en: 'In figure 15.4 you will notice that we get a wrap-around effect. The letters
    at the end of the alphabet, such as Y and Z, map to letters at the beginning A
    and B. That is why you cannot just add a Shift to each letter, ch + shift. The
    mod function (modulo operator) makes your numbers work akin to what you see on
    a 12-hour analog clock:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在图15.4中，你会注意到我们得到了一个环绕效果。字母表末尾的字母，如Y和Z，映射到字母表开头的A和B。这就是为什么你不能只是给每个字母加上一个Shift，ch
    + shift。模函数（取模运算符）让你的数字工作得像你在12小时模拟时钟上看到的那样：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ The input is larger than 12, so it wraps around.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 输入大于12，所以它环绕。
- en: 'In this example, I input ch - ''A'' to mod, so that I can turn letters into
    values in the range 0 to 25\. This makes it easier to calculate the wrap-around
    value. Afterward, I need to turn the numbers from 0 to 25 into a letter. Fortunately,
    Julia math operations between numbers and letters are set up to do that for you
    in a predictable manner, as illustrated in the next REPL session:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将ch - 'A'输入到mod中，这样我就可以将字母转换成0到25的值。这使得计算环绕值更容易。之后，我需要将0到25的数字转换成字母。幸运的是，Julia在数字和字母之间的数学运算已经设置为以可预测的方式为你完成这项工作，如下一个REPL会话所示：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ You can separate statements with a semicolon.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你可以用分号分隔语句。
- en: ❷ Z wraps around to become B.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Z环绕成为B。
- en: You may notice that I am using the same shift value as used in figure 15.4.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我正在使用与图15.4中相同的位移值。
- en: 'Now you know how to encrypt a single character, but how can you use that knowledge
    to encrypt and decrypt whole messages? You can use the map function to encrypt
    a message and then attempt to decrypt it afterward to make sure you get back what
    you put in:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何加密单个字符，但你是如何使用这些知识来加密和解密整个消息的呢？你可以使用 map 函数来加密一条消息，然后尝试在之后解密它，以确保你得到你输入的内容：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice I used the *do-end* form to call decrypt, so you can compare code readability.
    Sometimes I find the do-end form to be easier to read, even if only dealing with
    a single line of code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我使用了 *do-end* 形式来调用解密，这样你可以比较代码的可读性。有时我发现 do-end 形式更容易阅读，即使只是处理一行代码。
- en: 15.4.2 Implementing substitution ciphers
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4.2 实现替换密码
- en: To create a substitution cipher, I need to create a mapping between two alphabets.
    For this purpose I need to use the shuffle function found in the Random module.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建替换密码，我需要在两个字母表之间创建一个映射。为此，我需要使用在 Random 模块中找到的 shuffle 函数。
- en: Notice in the following code the use of the range 'A':'Z' to quickly create
    a string containing all the letters in the alphabet. collect applied to this range
    would have given an array of letters, but in this case I want a string, so I use
    join instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码中使用了 'A':'Z' 的范围来快速创建包含字母表中所有字母的字符串。将 collect 应用到此范围将给出一个字母数组，但在此情况下，我需要一个字符串，所以我使用
    join。
- en: 'shuffle will randomly rearrange the elements in an array. Remember that a range
    is a subtype of AbstractArray, which is why you can shuffle a range as if it were
    a regular array:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: shuffle 将随机重新排列数组中的元素。记住，range 是 AbstractArray 的子类型，这就是为什么你可以像处理常规数组一样对 range
    进行 shuffle：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These functions provide the tools needed to create a dictionary mapping between
    the two alphabets. When creating a dictionary you normally need key-value pairs,
    but in the following code, keys and values are created as separate arrays, so
    how can I make a dictionary out of this?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数提供了在两个字母表之间创建字典映射所需的工具。在创建字典时，通常需要键值对，但在以下代码中，键和值作为单独的数组创建，那么我如何从这些中创建一个字典呢？
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Use range A-F to make examples shorter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 A-F 的范围来缩短示例。
- en: 'The zip function solves this problem. zip can take two arrays of elements and
    turn them into an iterable object, which when collected provides an array of pairs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: zip 函数解决了这个问题。zip 可以接受两个元素数组，并将它们转换成一个可迭代对象，当收集时提供一个成对的数组：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can take the iterable object returned from the zip function and feed it
    to the Dict constructor. Because this iterable object returns value pairs on each
    iteration I will use the object returned from zip to create a dictionary:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 zip 函数返回的可迭代对象传递给 Dict 构造函数。因为此可迭代对象在每次迭代时返回值对，所以我会使用 zip 返回的对象来创建一个字典：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This provides input data that can be used with an encryption function for the
    substitution cipher.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了可以用于替换密码加密函数的输入数据。
- en: Listing 15.7 Substitution cipher encryption based on dictionary lookup
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.7 基于字典查找的替换密码加密
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is one glaring problem with this approach: decryption requires a reverse
    lookup. Looking at the mapping as equivalent to the encryption key is a bad solution.
    For symmetric encryption it is best to use the same key for both encryption and
    decryption. Thus, instead of doing lookup using a dictionary, I will instead search
    an array of pairs, as shown in the following listing.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个明显的问题：解密需要反向查找。将映射视为等同于加密密钥是一个糟糕的解决方案。对于对称加密，最好使用相同的密钥进行加密和解密。因此，而不是使用字典进行查找，我将搜索一个成对的数组，如下所示。
- en: Listing 15.8 Substitution cipher encryption based on an array lookup
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.8 基于数组查找的替换密码加密
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Find the index where first character is equal to ch.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 找到第一个字符等于 ch 的索引。
- en: ❷ If the character isn’t in the mapping, nothing is returned.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果字符不在映射中，则不返回任何内容。
- en: ❸ Return the second character at mapping row i.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回映射行 i 的第二个字符。
- en: The solution is similar to the Caesar cipher solution in that you don’t need
    to perform any encryption or decryption if the character ch is not in the alphabet.
    It is based on a linear search with the findfirst function to find the index of
    the tuple with the key you are interested in. If row is the tuple ('B', 'Q'),
    then first(row) is 'B', and last(row) is 'Q'. When doing encryption, first use
    first(row) as the lookup key then last(row) as the lookup key when doing decryption.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案与凯撒密码解决方案类似，即如果字符ch不在字母表中，则不需要执行任何加密或解密操作。它基于findfirst函数的线性搜索来查找你感兴趣键的元组索引。如果row是元组('B',
    'Q')，那么first(row)是'B'，而last(row)是'Q'。在加密时，首先使用first(row)作为查找键，然后在使用解密时使用last(row)作为查找键。
- en: You might ask, *Isn’t doing a linear search through an array a lot slower than
    doing a dictionary lookup?* No. For such a short array of simple values, a linear
    search would be faster. You would need at least 100 entries before there would
    be any noticeable difference in lookup performance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，*通过数组进行线性搜索难道不会比使用字典查找慢得多吗？* 不。对于这样短的简单值数组，线性搜索会更快。你至少需要100个条目，查找性能才会有明显差异。
- en: 15.5 Creating a cipher-algorithm-agnostic service
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5 创建一个与加密算法无关的服务
- en: Imagine you have a service using a cipher and want to make it easier to swap
    out which cipher you are using. Here I will present a toy example to convey the
    concept of using a password-keeping service. It maintains a dictionary with logins
    as keys and encrypted passwords as values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个使用加密的服务，并希望使其更容易更换所使用的加密方式。在这里，我将提供一个玩具示例来传达使用密码存储服务的概念。它维护一个以登录名作为键、加密密码作为值的字典。
- en: Listing 15.9 Password keeping service
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.9 密码存储服务
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Vault is made mutable, since it must be possible to add passwords.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保险库被设置为可变的，因为必须能够添加密码。
- en: ❷ Initialize with the empty passwords dictionary.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用空密码字典进行初始化。
- en: ❸ Add an encrypted password to the password dictionary.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将加密密码添加到密码字典中。
- en: ❹ Look up the password for the login name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找登录名对应的密码。
- en: 'While the code works, there are numerous problems with this approach:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码可以工作，但这种方法存在许多问题：
- en: 'It is hardcoded to only support one encryption scheme: using a Caesar cipher.
    There should be a choice of any cipher.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它被硬编码为仅支持一种加密方案：使用凯撒密码。应该有选择任何加密方案的能力。
- en: The service assumes encryption, and decryption is done one character at a time.
    Encryption should be generalized to deal with whole strings because it is not
    necessarily implemented as character substitution.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该服务假设加密，解密是逐字符进行的。加密应该被泛化以处理整个字符串，因为加密不一定是字符替换。
- en: 15.6 Building an encryption service using object-oriented programming
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6 使用面向对象编程构建加密服务
- en: In code listing 15.9 the cipher is hardcoded; you want to be able to swap the
    cipher with a different one. Let’s look at how that can be achieved.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码列表15.9中，加密是硬编码的；你希望能够用不同的加密方式替换它。让我们看看如何实现这一点。
- en: The solution is an abstract interface to the ciphers, so users of a password
    service do not need to know any particular details about each type of cipher.
    Listing 15.10 illustrates an object-oriented approach to this problem. First I
    define a Cipher as an abstract type, with a number of functions it has to support.
    I will add methods to each of these functions to add support for my particular
    cipher.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是一个对密码加密的抽象接口，因此密码服务的用户不需要了解每种加密类型的具体细节。列表15.10展示了对此问题的面向对象方法。首先，我将Cipher定义为一个抽象类型，它必须支持一系列函数。我将为这些函数中的每一个添加方法以支持我特定的加密。
- en: Listing 15.10 Defining an abstract cipher interface
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.10 定义抽象密码接口
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The way this code has been set up, I have made implementing encrypt and decrypt
    for *message strings* and *cipher text strings* optional. The default implementation
    will use encrypt and decrypt of single characters. However, in your own code,
    if you have not implemented these you will get an error message if you try to
    perform encryption or decryption with your cipher.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码的设置方式使得实现加密和解密对于*消息字符串*和*密文字符串*是可选的。默认实现将使用单字符的加密和解密。然而，在你的代码中，如果你没有实现这些，当你尝试使用你的加密方式执行加密或解密时，你会得到一个错误信息。
- en: You may notice that I have taken a slightly different approach in specifying
    interfaces here than I took in chapter 12\. The normal recommended approach is
    defining functions and documenting which methods the user of your API is supposed
    to implement. Here I make an explicit error message explaining what you need to
    do. It is useful to know both practices. In this case, I felt it was more practical,
    as the same functions exist for dealing with strings as for dealing with individual
    characters. First, I will implement the Cipher interface for the Caesar cipher.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我在这里指定接口的方法与第 12 章中采取的方法略有不同。通常推荐的方法是定义函数并记录你的 API 用户应该实现的方法。在这里，我明确地提供了一个错误信息，说明了你需要做什么。了解这两种实践都是有用的。在这种情况下，我认为这更实用，因为处理字符串和处理单个字符的函数是相同的。首先，我将实现凯撒密码的
    Cipher 接口。
- en: Listing 15.11 Caesar cipher implementing the Cipher interface
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.11 实现 Cipher 接口的凯撒密码
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This new Caesar cipher implementation is almost exactly like the previous implementation
    (listing 15.6), except in this example, I obtain the shift from the cipher object
    instead of getting it directly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的凯撒密码实现几乎与之前的实现（列表 15.6）完全相同，只是在这次示例中，我从加密对象中获取偏移量，而不是直接获取。
- en: Listing 15.12 shows the object-oriented substitution cipher. It is similar to
    the original implementation (listing 15.8), except I am storing the mapping in
    the SubstitutionCipher object, and calling to encrypt and decrypt requires passing
    the cipher object rather than the mapping.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.12 展示了面向对象的替换密码。它与原始实现（列表 15.8）相似，除了我将映射存储在 SubstitutionCipher 对象中，调用加密和解密时需要传递加密对象而不是映射。
- en: Listing 15.12 Substitution cipher implementing the Cipher interface
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.12 实现 Cipher 接口的替换密码
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Used to look up what a character should be encrypted as
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于查找字符应该加密为什么
- en: ❷ Create a list of character pairs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个字符对列表。
- en: ❸ Create an instance of SubstitutionCipher.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个 SubstitutionCipher 实例。
- en: You can now modify your password-keeping service to point to an abstract cipher
    rather than a concrete one (listing 15.13). That allows you to swap out the cipher
    used with any concrete cipher implementing the Cipher interface.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以修改你的密码存储服务，使其指向一个抽象的加密算法，而不是具体的加密算法（列表 15.13）。这允许你用任何实现 Cipher 接口的具体加密算法来替换所使用的加密算法。
- en: Listing 15.13 Cipher-algorithm-agnostic password-keeping service
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.13 通用密码算法密码存储服务
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I can now try the upgraded password-keeping service with different ciphers.
    I’ll show an example with a Caesar cipher first. I start by creating a vault to
    store the passwords in. The vault is initialized with the cipher it will use to
    encrypt and decrypt passwords stored within it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以用不同的加密算法尝试升级后的密码存储服务。我将首先使用凯撒密码来展示一个例子。我首先创建一个保险库来存储密码。保险库使用它将用于加密和解密存储在其内的密码的加密算法进行初始化。
- en: 'Next I call addlogin! to add passwords to the vault. Afterward I use getpassword
    to make sure I get the same passwords out that I put in:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我调用 addlogin! 来向保险库中添加密码。之后，我使用 getpassword 来确保我取出的密码与放入的密码相同：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next I’ll show an example with the substitution cipher. In this case, I initialize
    the substitution cipher with a substitution alphabet. You can see from this that
    the letters ABC would get replaced by CQP:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将通过替换密码的例子进行展示。在这种情况下，我使用替换字母表初始化替换密码。你可以看到，字母 ABC 将被替换为 CQP：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 15.7 Building an encryption service using functional programming
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7 使用函数式编程构建加密服务
- en: The point of showing how to accomplish the abstraction using an object-oriented
    approach first is that more programmers are already familiar with this approach.
    In this case *object oriented* means I am solving the problem by thinking in terms
    of type hierarchies and objects. I represented the cipher as an object and defined
    functions with methods that operated on these cipher objects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先展示如何使用面向对象的方法实现抽象的目的，是因为更多的程序员已经熟悉这种方法。在这种情况下，*面向对象*意味着我通过考虑类型层次和对象来解决问题。我将加密算法表示为一个对象，并定义了在加密对象上操作的方法。
- en: 'With the functional approach, I will instead aim to solve the problem by thinking
    in terms of functions: higher-order functions and closures. The purpose is exposing
    you to two different mindsets on solving programming problems. To be a good Julia
    programmer you need to understand both.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式方法，我将致力于通过考虑函数（高阶函数和闭包）来解决问题。目的是让你了解两种不同的编程问题解决思路。要成为一名优秀的 Julia 程序员，你需要理解这两种思路。
- en: 15.7.1 Defining a functional Caesar cipher
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7.1 定义功能凯撒密码
- en: I will define a Caesar cipher by using the partial application technique first
    shown in listing 15.5\. This approach allows expansion of the original solution
    developed with the caesar_encrypt and caesar_decrypt functions (listing 15.6).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先使用列表 15.5 中首次展示的部分应用技术来定义凯撒密码。这种方法允许扩展使用 caesar_encrypt 和 caesar_decrypt
    函数（列表 15.6）开发的原始解决方案。
- en: Notice in listing 15.14 how there are no cipher types in the code anymore. There
    is no data object representing the Caesar cipher. Instead I am adding new methods
    to the caesar_ encrypt and caesar_decrypt to allow partial application, so when
    only a shift argument is provided I will return a function taking a character
    rather than an character in the cipher text.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在列表 15.14 中，代码中不再有密码类型。没有表示凯撒密码的数据对象。相反，我正在向 caesar_encrypt 和 caesar_decrypt
    添加新方法以允许部分应用，因此当只提供一个移位参数时，我将返回一个接受字符而不是加密文本中的字符的函数。
- en: Listing 15.14 A Caesar cipher with functional flavor
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.14 带有函数风格的凯撒密码
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Trick to avoid implementing nearly identical code
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 避免实现几乎相同代码的技巧
- en: ❷ Return closure capturing shift
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回捕获移位的闭包
- en: 'Let’s look at how these functions get used. I’ll start by calling caesar_encrypt
    with a shift value of 1\. It returns a function meant to be used for encryption.
    I’ll then use that function to encrypt the text string "ABC". A similar pattern
    is used to create and use the decryption function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些函数是如何使用的。我将首先使用 1 的移位值调用 caesar_encrypt。它返回一个用于加密的函数。然后，我将使用该函数加密文本字符串
    "ABC"。创建和解密函数的类似模式也被使用：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ This works because map can map across individual characters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是因为 map 可以映射到单个字符。
- en: 'A benefit of this solution is that it is easy to chain together results with
    the pipe operator |>:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的一个优点是，它很容易使用管道操作符 |> 连接结果：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 15.7.2 Defining a functional substitution cipher
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7.2 定义功能替换密码
- en: To make the substitution cipher, I will expand on the substitution cipher code
    written in listing 15.8\. I will employ the partial application technique again,
    adding two methods to the existing substitution_encrypt and substitution_decrypt
    (listing 15.15). They only take mapping as an argument but return cipher functions,
    which will encrypt or decrypt a message given to them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作替换密码，我将在列表 15.8 中编写的替换密码代码的基础上进行扩展。我将再次使用部分应用技术，向现有的 substitution_encrypt
    和 substitution_decrypt（列表 15.15）添加两个方法。它们只接受映射作为参数，但返回加密或解密消息的加密函数。
- en: Listing 15.15 A substitution cipher with functional flavor
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.15 带有函数风格的替换密码
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I will use the substitution cipher in a similar fashion to the Caesar cipher.
    The main difference is that I use a mapping instead of a shift as the cipher key:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以类似凯撒密码的方式使用替换密码。主要区别在于，我使用映射而不是移位作为密码密钥：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now you know the pieces to make a password keeper based on functional design
    principles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经知道了基于功能设计原则制作密码保管库的各个部分。
- en: 15.7.3 Implementing a functional password-keeper service
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7.3 实现功能密码保管服务
- en: Now let’s put it all together and create a password keeper that uses the encryption
    and decryption functions to allow logins and passwords to be stored and retrieved.
    There are many ways of doing this. In listing 15.16, I will deliberately go over
    the top to create a strong contrast with the object-oriented solution.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将所有这些放在一起，创建一个使用加密和解密函数来允许存储和检索登录和密码的密码保管库。有多种实现方式。在列表 15.16 中，我将故意做得过分，以与面向对象解决方案形成强烈对比。
- en: Listing 15.16 A password-keeper service with excessively functional style
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.16 过度功能风格的密码保管服务
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s look at an example of using this implementation to define a password
    keeper using a Caesar cipher. The Vault gets initialized with two function objects
    produced by calls to caesar_encrypt and caesar_decrypt, respectively:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用此实现定义基于凯撒密码的密码保管库的示例。保险库通过调用 caesar_encrypt 和 caesar_decrypt 分别初始化为两个函数对象：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the substitution cipher there is a bit more setup to create the mapping
    vector. In all other aspects the password-keeper vault is set up the same way
    as the Caesar cipher:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换密码时，需要设置更多的映射向量。在其他所有方面，密码保管库的设置方式与凯撒密码相同：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now it is time to take a few steps back and reflect upon why exactly you would
    want to design the closures in the way shown in the examples. The objective is
    the same as that of the object-oriented case: presenting a generic interface to
    ciphers, so you can change which cipher is used without changing the implementation
    of the password-keeper implementation.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候退后几步，反思一下为什么你想要以示例中所示的方式设计闭包了。目标是与面向对象的情况相同：向加密提供通用接口，这样你就可以在不更改密码管理实现的情况下更改所使用的加密方式。
- en: I did this by returning encryption and decryption functions, which don’t expose
    any implementation details in their function signature. A *function signature*
    refers to what arguments a function takes, their order, and their type. The Caesar
    cipher and substitution cipher produce encryption and decryption functions with
    the same signatures. That is why they are interchangeable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过返回加密和解密函数来实现这一点，这些函数在其函数签名中不暴露任何实现细节。**函数签名**指的是函数接受的参数、它们的顺序和类型。凯撒密码和替换密码产生具有相同签名的加密和解密函数。这就是为什么它们可以互换使用。
- en: I attempted to make each presented solution as different as possible to make
    it clearer what the difference between functional and object-oriented programming
    is. Sometimes a caricature is helpful in getting a point across. Yet for real
    solutions you should always try to use good taste and find a sensible balance
    between an object-oriented and a functional approach.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图使每个展示的解决方案尽可能不同，以更清楚地说明函数式编程和面向对象编程之间的差异。有时夸张可以有助于传达观点。然而，对于实际解决方案，你应该始终尝试使用良好的品味，并在面向对象和函数式方法之间找到一个合理的平衡。
- en: In the case of making a password-keeper solution, the object-oriented approach
    was superior in my opinion, while converting snake case to camel case worked very
    well with a functional approach. Why the difference? Functional programming works
    very well when your problem can be reduced to some sort of data transformation.
    Instead, when you are dealing with something inherently stateful, such as a password-keeper
    service, an object-oriented approach is a more natural fit, as object-oriented
    programming is all about modifying state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作密码管理解决方案的情况下，我认为面向对象的方法更优越，而将蛇形命名法转换为驼峰命名法与函数式方法配合得非常好。为什么会有这种差异？当你的问题可以简化为某种数据转换时，函数式编程工作得非常好。相反，当你处理本质上具有状态的东西，比如密码管理服务时，面向对象的方法更自然，因为面向对象编程的全部都是修改状态。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Functional and procedural programming are often thought of as being interchangeable,
    but they are not the same. In functional programming, functions are first-class
    objects that can be passed around and manipulated with higher-order functions.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性和过程式编程通常被认为是可以互换的，但它们并不相同。在函数式编程中，函数是一等对象，可以用高阶函数传递和处理。
- en: Functionally oriented code is easier to analyze and debug, as it forms a clearer
    flow of data.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以功能为导向的代码更容易分析和调试，因为它形成了一个更清晰的数据流。
- en: Difficult-to-read function call nesting can be solved by using the function
    chaining operator |>.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用函数链操作符 |> 解决难以阅读的函数调用嵌套。
- en: '*Anonymous functions* are functions without names. They help simplify the creation
    of inline closures.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名函数**是没有名称的函数。它们有助于简化内联闭包的创建。'
- en: Anonymous functions can be created with the -> operator or the *do-end* form.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 -> 操作符或 *do-end* 形式创建匿名函数。
- en: A *closure* is a function that captures state from its enclosing scope; it is
    a function with memory. Closures can be used to mimic objects with state, facilitate
    partial application, and manage resource acquisition and release (opening and
    closing a file).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闭包**是一个捕获其封装作用域状态的函数；它是一个具有记忆的函数。闭包可以用来模拟具有状态的对象，促进部分应用，以及管理资源获取和释放（打开和关闭文件）。'
- en: '*Partial application* is a technique in which you return a function rather
    than a result when not all arguments have been provided to a function. This simplifies
    creating function arguments to higher-order functions, such as map, filter, and
    reduce.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分应用**是一种技术，当没有向函数提供所有参数时，你返回一个函数而不是一个结果。这简化了创建用于高阶函数（如 map、filter 和 reduce）的函数参数。'
- en: Elements in an array can be randomly shuffled around with the shuffle function
    from the Random built-in module. Many encryption algorithms need randomly shuffled
    input, and this is also a good way of creating input to test sorting functions
    on.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组中的元素可以使用来自 Random 内置模块的 shuffle 函数随机打乱。许多加密算法需要随机打乱的输入，这也是测试排序函数输入的好方法。
- en: Combine functional and object-oriented techniques for optimal results in Julia.
    Different problems require different approaches. Through practice you will develop
    a better intuition for when one approach is better than the other.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，结合函数式和面向对象的技术以获得最佳结果。不同的问题需要不同的方法。通过实践，你会培养出更好的直觉，知道何时一种方法比另一种方法更优。
