- en: Part 2\. C# 2–5
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分。C# 2–5
- en: This part of the book covers all the features introduced between C# 2 (shipped
    with Visual Studio 2005) and C# 5 (shipped with Visual Studio 2012). This is the
    same set of features that took up the entire third edition of this book. Much
    of it feels like ancient history now; for example, we simply take it for granted
    that C# includes generics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书这部分内容涵盖了从C# 2（随Visual Studio 2005发布）到C# 5（随Visual Studio 2012发布）之间引入的所有功能。这正是本书第三版全部内容所涵盖的功能集。其中许多现在感觉就像古老的历史；例如，我们简单地认为C#包含了泛型。
- en: This was a tremendously productive period for C#. Some of the features I’ll
    cover in this part are generics, nullable value types, anonymous methods, method
    group conversions, iterators, partial types, static classes, automatically implemented
    properties, implicitly typed local variables, implicitly typed arrays, object
    initializers, collection initializers, anonymous types, lambda expressions, extension
    methods, query expressions, dynamic typing, optional parameters, named arguments,
    COM improvements, generic covariance and contravariance, async/await, and caller
    information attributes. Phew!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对C#来说一个非常富有成效的时期。我在这部分内容中将要介绍的一些功能包括泛型、可空值类型、匿名方法、方法组转换、迭代器、部分类型、静态类、自动实现属性、隐式类型局部变量、隐式类型数组、对象初始化器、集合初始化器、匿名类型、Lambda表达式、扩展方法、查询表达式、动态类型、可选参数、命名参数、COM改进、泛型协变和逆变、async/await以及调用者信息属性。哇！
- en: 'I expect most of you to be at least somewhat familiar with most of the features,
    so I ramp up pretty fast in this part. Likewise, for the sake of reasonable brevity,
    I haven’t gone into as much detail as I did in the third edition. The intention
    is to cover a variety of reader needs:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计你们中的大多数人至少对大多数功能有些熟悉，所以我在这部分内容中会快速展开。同样，为了合理地简短，我没有像第三版那样详细地介绍。目的是覆盖各种读者的需求：
- en: An introduction to features you may have missed along the way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍您在过程中可能错过的功能
- en: A reminder of the features you once knew about but have forgotten
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提醒您曾经了解但已遗忘的功能
- en: 'An explanation of the reasons behind the features: why they were introduced
    and why they were designed in the way they were'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释功能背后的原因：为什么它们被引入以及为什么它们被设计成这样的方式
- en: A quick reference in case you know what you want to do but have forgotten some
    syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您知道您想做什么但忘记了某些语法，这是一个快速参考
- en: If you want more detail, please refer to the third edition. As a reminder, purchase
    of the fourth edition entitles you to an e-book copy of the third edition.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多细节，请参阅第三版。作为提醒，购买第四版您将有权获得第三版的电子书副本。
- en: 'There’s one exception to this brief coverage rule: I’ve completely rewritten
    the coverage of async/await, which is the largest feature in C# 5\. [Chapter 5](kindle_split_020_split_000.html#ch05)
    covers what you need to know to use async/await, and [chapter 6](kindle_split_021_split_000.html#ch06)
    addresses how it’s implemented behind the scenes. If you’re new to async/await,
    you’ll almost certainly want to wait until you’ve used it a bit before you read
    [chapter 6](kindle_split_021_split_000.html#ch06), and even then, you shouldn’t
    expect it to be a simple read. I’ve tried to explain things as accessibly as I
    can, but the topic is fundamentally complex. I do encourage you to try, though;
    understanding async/await at a deep level can help boost your confidence when
    using the feature, even if you never need to dive into the IL the compiler generates
    for your own code. The good news is that after [chapter 6](kindle_split_021_split_000.html#ch06),
    you’ll find a little relief in the form of [chapter 7](kindle_split_022_split_000.html#ch07).
    It’s the shortest chapter in the book and a chance to recover before exploring
    C# 6.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例外：我完全重写了关于async/await的介绍，这是C# 5中最大的功能。[第五章](kindle_split_020_split_000.html#ch05)涵盖了您使用async/await所需了解的内容，而[第六章](kindle_split_021_split_000.html#ch06)则讨论了它在幕后是如何实现的。如果您对async/await是新手，您几乎肯定会在阅读[第六章](kindle_split_021_split_000.html#ch06)之前先使用一下它，即使那样，您也不应该期望它是一个简单的阅读。我已经尽力以尽可能易于理解的方式解释事物，但这个主题本质上很复杂。我确实鼓励您尝试；在深度理解async/await之后，即使您永远不需要深入研究编译器为您自己的代码生成的IL，这也能帮助您在使用该功能时增强信心。好消息是，在[第六章](kindle_split_021_split_000.html#ch06)之后，您会发现[第七章](kindle_split_022_split_000.html#ch07)带来了一丝轻松。这是书中最短的一章，也是探索C#
    6之前恢复的机会。
- en: With all introductions out of the way, brace yourself for an onslaught of features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有介绍都完成之后，准备好迎接功能的大潮。
- en: Chapter 2\. C# 2
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章。C# 2
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Using generic types and methods for flexible, safe code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型类型和方法编写灵活、安全的代码
- en: Expressing the absence of information with nullable value types
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可空值类型表达信息缺失
- en: Constructing delegates relatively easily
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对容易地构建代表
- en: Implementing iterators without writing boilerplate code
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需编写样板代码即可实现迭代器
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If your experience with C# goes far enough back, this chapter will be a reminder
    of just how far we’ve come and a prompt to be grateful for a dedicated and smart
    language design team. If you’ve never programmed C# without generics, you may
    end up wondering how C# ever took off without these features.^([[1](kindle_split_017_split_000.html#ch02fn1)])
    Either way, you may still find features you weren’t aware of or details you’ve
    never considered listed here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 C# 经验足够久远，这一章将提醒我们我们已经走了多远，并促使我们感激一个专注且聪明的语言设计团队。如果你从未使用泛型编写过 C#，你可能会想知道
    C# 没有这些功能是如何起飞的。[^1](kindle_split_017_split_000.html#ch02fn1)] 无论哪种情况，你仍然可能会在这里找到你之前不知道的功能或从未考虑过的细节。
- en: ¹
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For me, the answer to this one is simple: C# 1 was a more productive language
    for many developers than Java was at the time.'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于我来说，这个问题的答案很简单：C# 1 对于许多开发者来说比当时的 Java 更有效率。
- en: 'It’s been more than 10 years since C# 2 was released (with Visual Studio 2005),
    so it can be hard to get excited about features in the rearview mirror. You shouldn’t
    underestimate how important its release was at the time. It was also painful:
    the upgrade from C# 1 and .NET 1.x to C# 2 and .NET 2.0 took a long time to roll
    through the industry. Subsequent evolutions have been much quicker. The first
    feature from C# 2 is the one almost all developers consider to be the most important:
    generics.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 C# 2（与 Visual Studio 2005 一起发布）发布以来已经超过 10 年了，因此很难对后视镜中的功能感到兴奋。你不应该低估它在当时的重要性。它也是一个痛苦的过程：从
    C# 1 和 .NET 1.x 升级到 C# 2 和 .NET 2.0 花了很长时间才在业界推广。随后的演变要快得多。C# 2 的第一个特性是几乎所有开发者都认为最重要的特性：泛型。
- en: 2.1\. Generics
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 泛型
- en: 'Generics allow you to write general-purpose code that’s type safe at compile
    time using the same type in multiple places without knowing what that type is
    beforehand. When generics were first introduced, their primary use was for collections,
    but in modern C# code, they crop up everywhere. They’re probably most heavily
    used for the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许你编写通用代码，在编译时使用相同的类型在多个地方进行类型安全，而不必事先知道该类型是什么。当泛型最初引入时，它们的主要用途是集合，但在现代 C#
    代码中，它们无处不在。它们可能最常用于以下方面：
- en: Collections (they’re just as useful in collections as they ever were)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合（它们在集合中的用途和以前一样有用）
- en: Delegates, particularly in LINQ
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表们，尤其是在 LINQ 中
- en: Asynchronous code, where a `Task<T>` is a promise of a future value of type
    `T`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步代码，其中 `Task<T>` 是类型为 `T` 的未来值的承诺
- en: Nullable value types, which I’ll talk about more in [section 2.2](kindle_split_017_split_000.html#ch02lev1sec2)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空值类型，我将在[第 2.2 节](kindle_split_017_split_000.html#ch02lev1sec2)中详细介绍
- en: This isn’t the limit of their usefulness by any means, but even those four bullets
    mean that C# programmers use generics on a daily basis. Collections provide the
    simplest way of explaining the benefits of generics, because you can look at collections
    in .NET 1 and compare them with the generic collections in .NET 2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是它们有用性的极限，但即使这四个要点也意味着 C# 程序员每天都在使用泛型。集合提供了解释泛型优势的最简单方式，因为你可以查看 .NET 1 中的集合，并将它们与
    .NET 2 中的泛型集合进行比较。
- en: '2.1.1\. Introduction by example: Collections before generics'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 以示例为例：泛型之前的集合
- en: '.NET 1 had three broad kinds of collections:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 1 有三种主要的集合类型：
- en: '*Arrays*—These have direct language and runtime support. The size is fixed
    at initialization.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组*—这些具有直接的语言和运行时支持。大小在初始化时固定。'
- en: '*Object-based collections*—Values (and keys where relevant) are described in
    the API by using `System.Object`. These have no collection-specific language or
    runtime support, although language features such as indexers and `foreach` statements
    can be used with them. `ArrayList` and `Hashtable` are the most commonly used
    examples.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于对象的集合*—值（以及相关的键）通过 `System.Object` 在 API 中描述。它们没有特定的集合语言或运行时支持，尽管可以使用诸如索引器和
    `foreach` 语句之类的语言功能。`ArrayList` 和 `Hashtable` 是最常用的例子。'
- en: '*Specialized collections*—Values are described in the API with a specific type,
    and the collection can be used for only that type. `StringCollection` is a collection
    of strings, for example; its API looks like `ArrayList` but using `String` instead
    of `Object` for anything referring to a value.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专用集合**——值在 API 中用特定类型描述，并且集合只能用于该类型。例如，`StringCollection` 是一个字符串集合；它的 API
    看起来像 `ArrayList`，但使用 `String` 而不是 `Object` 来引用值。'
- en: Arrays and specialized collections are *statically typed*, by which I mean that
    the API prevents you from putting the wrong kind of value in a collection, and
    when you fetch a value from the collection, you don’t need to cast the result
    back to the type you expect it to be.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和专用集合是 **静态类型**，我的意思是 API 阻止你将错误类型的值放入集合中，当你从集合中获取值时，你不需要将结果转换回你期望的类型。
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Reference type arrays are only *mostly* safe when storing values because of
    array covariance. I view array covariance as an early design mistake that’s beyond
    the scope of this book. Eric Lippert wrote about this at [http://mng.bz/gYPv](http://mng.bz/gYPv)
    as part of his series of blog posts on covariance and contravariance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型数组在存储值时由于数组协变而 **大部分是安全的**。我认为数组协变是一个早期的设计错误，超出了本书的范围。Eric Lippert 在他的关于协变和逆变的博客帖子系列中讨论了这一点，请参阅
    [http://mng.bz/gYPv](http://mng.bz/gYPv)。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s make this concrete: suppose you want to create a collection of strings
    in one method (`GenerateNames`) and print those strings out in another method
    (`PrintNames`). You’ll look at three options to keep the collection of names—arrays,
    `ArrayList`, and `StringCollection`—and weigh the pros and cons of each. The code
    looks similar in each case (particularly for `PrintNames`), but bear with me.
    We’ll start with arrays.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体分析一下：假设你想要在一个方法（`GenerateNames`）中创建一个字符串集合，并在另一个方法（`PrintNames`）中打印这些字符串。你将考虑三种保持名字集合的方法——数组、`ArrayList`
    和 `StringCollection`——并权衡每种方法的优缺点。每种情况下的代码看起来都很相似（尤其是对于 `PrintNames`），但请耐心等待。我们将从数组开始。
- en: Listing 2.1\. Generating and printing names by using arrays
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 使用数组生成和打印名字
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Size of array needs to be known at creation time**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 数组的大小需要在创建时已知**'
- en: I haven’t used an array initializer here, because I want to mimic the situation
    where the names are discovered only one at a time, such as when reading them from
    a file. Notice that you need to allocate the array to be the right size to start
    with, though. If you really were reading from a file, you’d either need to find
    out how many names there were before you started, or you’d need to write more-complicated
    code. For example, you could allocate one array to start with, copy the contents
    to a larger array if the first one filled up, and so on. You’d then need to consider
    creating a final array of just the right size if you ended up with an array larger
    than the exact number of names.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里没有使用数组初始化器，因为我想模拟只发现一个名字的情况，比如从文件中读取它们。请注意，你一开始就需要分配正确的数组大小。如果你真的从文件中读取，你可能需要在开始之前找出有多少个名字，或者你可能需要编写更复杂的代码。例如，你可以一开始分配一个数组，如果第一个数组满了，就复制内容到一个更大的数组，依此类推。如果你最终得到的数组比确切的名字数量大，你可能还需要考虑创建一个正好大小的最终数组。
- en: The code used to keep track of the size of our collection so far, reallocate
    an array, and so on is repetitive and can be encapsulated in a type. As it happens,
    that’s just what `ArrayList` does.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用来跟踪我们集合大小、重新分配数组等的代码是重复的，可以被封装在一种类型中。实际上，这正是 `ArrayList` 所做的。
- en: Listing 2.2\. Generating and printing names by using `ArrayList`
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 使用 `ArrayList` 生成和打印名字
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* What happens if the ArrayList contains a nonstring?**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果 ArrayList 包含非字符串会发生什么？**'
- en: 'That’s cleaner in terms of our `GenerateNames` method: you don’t need to know
    how many names you have before you start adding to the collection. But equally,
    there’s nothing to stop you from adding a nonstring to the collection; the type
    of the `ArrayList.Add` parameter is just `Object`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `GenerateNames` 方法中，这样做更简洁：在开始向集合添加内容之前，你不需要知道你有多少个名字。但同样，也没有什么可以阻止你向集合中添加非字符串；`ArrayList.Add`
    参数的类型只是 `Object`。
- en: Furthermore, although the `PrintNames` method looks safe in terms of types,
    it’s not. The collection can contain any kind of object reference. What would
    you expect to happen if you added a completely different type (a `WebRequest`,
    as an odd example) to the collection, and then tried to print it? The `foreach`
    loop hides an implicit cast, from `object` to `string`, because of the type of
    the `name` variable. That cast can fail in the normal way with an `InvalidCastException`.
    Therefore, you’ve fixed one problem but caused another. Is there anything that
    solves both of these?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管 `PrintNames` 方法在类型方面看起来很安全，但实际上并不安全。集合可以包含任何类型的对象引用。如果你向集合中添加了一个完全不同的类型（例如一个
    `WebRequest`，作为一个奇怪的例子），然后尝试打印它，你会期望发生什么？由于 `name` 变量的类型，`foreach` 循环隐藏了一个隐式转换，从
    `object` 转换为 `string`。这种转换可能会以正常的方式失败，抛出 `InvalidCastException`。因此，你解决了一个问题，但引发了另一个。有什么东西可以解决这两个问题？
- en: Listing 2.3\. Generating and printing names by using `StringCollection`
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3. 使用 `StringCollection` 生成和打印名称
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Listing 2.3](kindle_split_017_split_000.html#ch02ex03) is identical to [listing
    2.2](kindle_split_017_split_000.html#ch02ex02) except for replacing `ArrayList`
    with `StringCollection` everywhere. That’s the whole point of `StringCollection`:
    it should feel like a pleasant general-purpose collection but specialized to only
    handle strings. The parameter type of `StringCollection.Add` is `String`, so you
    can’t add a `WebRequest` to it through some odd bug in our code. The resulting
    effect is that when you print the names, you can be confident that the `foreach`
    loop won’t encounter any nonstring references. (You could still see a null reference,
    admittedly.)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.3](kindle_split_017_split_000.html#ch02ex03) 与 [列表 2.2](kindle_split_017_split_000.html#ch02ex02)
    完全相同，只是将所有 `ArrayList` 替换为 `StringCollection`。这就是 `StringCollection` 的全部意义：它应该感觉像是一个令人愉快的通用集合，但仅限于处理字符串。`StringCollection.Add`
    的参数类型是 `String`，因此你不能通过我们代码中的某个奇怪错误将其添加一个 `WebRequest`。结果是，当你打印名称时，你可以确信 `foreach`
    循环不会遇到任何非字符串引用。（当然，你仍然可能看到空引用。） '
- en: That’s great if you always need only strings. But if you need a collection of
    some other type, you have to either hope that there’s already a suitable collection
    type in the framework or write one yourself. This was such a common task that
    there’s a `System.Collections.CollectionBase` abstract class to make the work
    somewhat less repetitive. There are also code generators to avoid having to write
    it all by hand.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你总是只需要字符串，那当然很好。但如果你需要其他类型的集合，你必须要么希望框架中已经存在一个合适的集合类型，要么自己编写一个。这是一个如此常见的任务，以至于有一个
    `System.Collections.CollectionBase` 抽象类来使工作不那么重复。还有代码生成器来避免手动编写所有内容。
- en: That solves both problems from the previous solution, but the cost of having
    all these extra types around is way too high. There’s a maintenance cost in keeping
    them up-to-date as the code generator changes. There are efficiency costs in terms
    of compilation time, assembly size, JITting time, and keeping the code in memory.
    Most important, there’s a human cost in keeping track of all the collection classes
    available.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了之前解决方案中的两个问题，但所有这些额外类型的成本实在太高了。在代码生成器更改时，保持它们更新需要维护成本。在编译时间、程序集大小、JIT 编译时间和保持代码在内存中等方面存在效率成本。最重要的是，跟踪所有可用的集合类需要人力成本。
- en: Even if those costs weren’t too high, you’d be missing the ability to write
    a method that can work on any collection type in a statically typed way, potentially
    using the collection’s element type in another parameter or in the return type.
    For example, say you want to write a method to create a copy of the first *N*
    elements of a collection into a new one, which was then returned. You could write
    a method that returns an `ArrayList`, but that loses the goodness of static typing.
    If you pass in a `StringCollection`, you’d want a `StringCollection` back. The
    string aspect is part of the input to the method, which then needs to be propagated
    to the output as well. You had no way of expressing that in the language when
    using C# 1\. Enter generics.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这些成本并不太高，你也会错过编写一种可以在静态类型方式下适用于任何集合类型的方法的能力，可能还会使用集合的元素类型作为另一个参数或返回类型。例如，假设你想编写一个方法来将集合的前
    *N* 个元素复制到一个新的集合中，然后返回。你可以编写一个返回 `ArrayList` 的方法，但这会失去静态类型的好处。如果你传入一个 `StringCollection`，你希望返回一个
    `StringCollection`。字符串方面是方法输入的一部分，然后需要将其传播到输出。在使用 C# 时，你无法表达这一点。1. 进入泛型时代。
- en: 2.1.2\. Generics save the day
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2. 泛型拯救了世界
- en: Let’s get straight to the solution for our `GenerateNames`/`PrintNames` code
    and use the `List<T>` generic type. `List<T>` is a collection in which `T` is
    the element type of the collection—`string`, in our case. You can replace `StringCollection`
    with `List<string>` everywhere.^([[2](kindle_split_017_split_000.html#ch02fn2)])
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接解决我们的 `GenerateNames`/`PrintNames` 代码的解决方案，并使用 `List<T>` 泛型类型。`List<T>`
    是一个集合，其中 `T` 是集合的元素类型——在我们的例子中是 `string`。您可以在任何地方用 `List<string>` 替换 `StringCollection`。^([[2](kindle_split_017_split_000.html#ch02fn2)])
- en: ²
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’m deliberately not going into the possibility of using interfaces for return
    types and parameters. That’s an interesting topic, but I don’t want to distract
    you from generics.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我故意不讨论使用接口作为返回类型和参数的可能性。这是一个有趣的话题，但我不想让您从泛型中分心。
- en: Listing 2.4\. Generating and printing names with `List<T>`
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 使用 `List<T>` 生成和打印名称
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`List<T>` solves all the problems we talked about before:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 解决了我们之前讨论的所有问题：'
- en: You don’t need to know the size of the collection beforehand, unlike with arrays.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组不同，您不需要事先知道集合的大小。
- en: The exposed API uses `T` everywhere it needs to refer to the element type, so
    you know that a `List<string>` will contain only string references. You’ll get
    a compile-time error if you try to add anything else, unlike with `ArrayList`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露的 API 在需要引用元素类型的地方都使用 `T`，因此您知道 `List<string>` 将只包含字符串引用。如果您尝试添加其他任何东西，将会得到编译时错误，这与
    `ArrayList` 不同。
- en: You can use it with any element type without worrying about generating code
    and managing the result, unlike with `StringCollection` and similar types.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用任何元素类型，而无需担心生成代码和管理结果，这与 `StringCollection` 和类似类型不同。
- en: Generics also solve the problem of expressing an element type as an input to
    a method. To delve into that aspect more deeply, you’ll need more terminology.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型还解决了将元素类型作为方法输入表达的问题。要更深入地探讨这个方面，您需要更多的术语。
- en: Type parameters and type arguments
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型参数和类型参数
- en: The terms *parameter* and *argument* predate generics in C# and have been used
    in other languages for decades. A method declares its inputs as parameters, and
    they’re provided by calling code in the form of arguments. [Figure 2.1](kindle_split_017_split_000.html#ch02fig01)
    shows how the two relate to each other.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *参数* 和 *参数* 在 C# 中的泛型出现之前就已经存在，并且在其他语言中使用了几十年。一个方法声明其输入为参数，它们以参数的形式由调用代码提供。[图
    2.1](kindle_split_017_split_000.html#ch02fig01) 展示了这两个术语是如何相互关联的。
- en: Figure 2.1\. Relationship between method parameters and arguments
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 方法参数和参数之间的关系
- en: '![](../Images/02fig01_alt.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig01_alt.jpg)'
- en: The values of the arguments are used as the initial values for the parameters
    within the method. In generics, you have *type parameters* and *type arguments*,
    which are the same idea but applied to types. The declaration of a generic type
    or method includes type parameters in angle brackets after the name. Within the
    body of the declaration, the code can use the type parameter as a normal type
    (just one it doesn’t know much about).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的值用作方法内部参数的初始值。在泛型中，您有 *类型参数* 和 *类型参数*，这是相同的概念，但应用于类型。泛型类型或方法的声明包括在名称之后使用尖括号声明的类型参数。在声明的主体内部，代码可以使用类型参数作为正常类型（只是它对它了解不多）。
- en: The code using the generic type or method then specifies the type arguments
    in angle brackets after the name as well. [Figure 2.2](kindle_split_017_split_000.html#ch02fig02)
    shows this relationship in the context of `List<T>`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型类型或方法的代码随后在名称之后也指定了类型参数。[图 2.2](kindle_split_017_split_000.html#ch02fig02)
    展示了在 `List<T>` 上下文中这种关系。
- en: Figure 2.2\. Relationship between type parameters and type arguments
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2\. 类型参数和类型参数之间的关系
- en: '![](../Images/02fig02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig02.jpg)'
- en: 'Now imagine the complete API of `List<T>`: all the method signatures, properties,
    and so on. If you’re using the `list` variable shown in the figure, any `T` that
    appears in the API becomes `string`. For example, the `Add` method in `List<T>`
    has the following signature:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下 `List<T>` 的完整 API：所有的方法签名、属性等等。如果您使用图中的 `list` 变量，API 中的任何 `T` 都将变为 `string`。例如，`List<T>`
    中的 `Add` 方法具有以下签名：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But if you type `list.Add(` into Visual Studio, IntelliSense will prompt you
    as if the `item` parameter had been declared with a type of `string`. If you try
    to pass in an argument of another type, it will result in a compile-time error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您在 Visual Studio 中输入 `list.Add(`，IntelliSense 将会提示您，好像 `item` 参数已经被声明为 `string`
    类型。如果您尝试传递其他类型的参数，将会导致编译时错误。
- en: 'Although [figure 2.2](kindle_split_017_split_000.html#ch02fig02) refers to
    a generic class, methods can be generic as well. The method declares type parameters,
    and those type parameters can be used within other parts of the method signature.
    Method type parameters are often used as type arguments to other types within
    the signature. The following listing shows a solution to the method you couldn’t
    implement earlier: something to create a new collection containing the first *N*
    elements of an existing one but in a statically typed way.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [图 2.2](kindle_split_017_split_000.html#ch02fig02) 指的是泛型类，但方法也可以是泛型的。方法声明类型参数，并且这些类型参数可以在方法签名的其他部分中使用。方法类型参数通常用作签名中其他类型的类型参数。以下列表显示了之前无法实现的方法的解决方案：创建一个包含现有集合中前
    *N* 个元素的新集合，但以静态类型的方式。
- en: Listing 2.5\. Copying elements from one collection to another
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5\. 将元素从一个集合复制到另一个集合
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Method declares a type parameter T and uses it in parameters and return
    type.**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 方法声明一个类型参数 T 并在参数和返回类型中使用它。**'
- en: '***2* Type parameter used in method body**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在方法体中使用类型参数**'
- en: '***3* Call to method using int as the type parameter**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 int 作为类型参数的方法调用**'
- en: Plenty of generic methods use the type parameter only once in the signature^([[3](kindle_split_017_split_000.html#ch02fn3)])
    and without it being a type argument to any generic types. But the ability to
    use a type parameter to express a relationship between the types of regular parameters
    and the return type is a huge part of the power of generics.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 许多泛型方法在签名中只使用一次类型参数^([[3](kindle_split_017_split_000.html#ch02fn3)])，并且它不是任何泛型类型的类型参数。但使用类型参数来表达常规参数类型与返回类型之间关系的能力是泛型功能的重要组成部分。
- en: ³
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although it’s valid to write a generic method that doesn’t use the type parameter
    anywhere else in the signature, that’s rarely useful.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然编写一个在签名中其他地方没有使用类型参数的泛型方法是有效的，但这通常没有太大用处。
- en: 'Likewise, generic types can use their type parameters as type arguments when
    declaring a base class or an implemented interface. For example, the `List<T>`
    type implements the `IEnumerable<T>` interface, so the class declaration could
    be written like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，泛型类型可以在声明基类或实现接口时使用它们的类型参数作为类型参数。例如，`List<T>` 类型实现了 `IEnumerable<T>` 接口，因此类声明可以写成这样：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In reality, `List<T>` implements multiple interfaces; this is a simplified form.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`List<T>` 实现了多个接口；这是一个简化的形式。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Arity of generic types and methods
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 泛型类型和方法的度数
- en: 'Generic types or methods can declare multiple type parameters by separating
    them with commas within the angle brackets. For example, the generic equivalent
    of the .NET 1 `Hashtable` class is declared like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型或方法可以通过在尖括号内用逗号分隔来声明多个类型参数。例如，.NET 1 `Hashtable` 类的泛型等效声明如下：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The generic *arity* of a declaration is the number of type parameters it has.
    To be honest, this is a term that’s more useful to authors than in everyday usage
    when writing code, but I’d argue it’s still worth knowing. You can think of a
    nongeneric declaration as one with generic arity 0.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的泛型 *度数* 是它拥有的类型参数的数量。说实话，这是一个在日常编写代码时比作者更有用的术语，但我认为它仍然值得了解。你可以将非泛型声明视为具有泛型度数
    0 的声明。
- en: 'The generic arity of a declaration is effectively part of what makes it unique.
    As an example, I’ve already referred to the `IEnumerable<T>` interface introduced
    in .NET 2.0, but that’s a distinct type from the nongeneric `IEnumerable` interface
    that was already part of .NET 1.0\. Likewise, you can write methods with the same
    name but a different generic arity, even if their signatures are otherwise the
    same:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的泛型度数实际上是使其独特的一部分。例如，我已经提到了在 .NET 2.0 中引入的 `IEnumerable<T>` 接口，但它与 .NET 1.0
    中已经存在的非泛型 `IEnumerable` 接口是不同的类型。同样，即使它们的签名在其他方面相同，你也可以编写具有相同名称但不同泛型度数的方法：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Nongeneric method (generic arity 0)**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 非泛型方法（泛型度数 0）**'
- en: '***2* Method with generic arity 1**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 泛型度数为 1 的方法**'
- en: '***3* Method with generic arity 2**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 泛型度数为 2 的方法**'
- en: 'When declaring types with different generic arity, the types don’t have to
    be of the same kind, although they usually are. As an extreme example, consider
    these type declarations that can all coexist in one highly confusing assembly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明具有不同泛型度数的类型时，这些类型不必属于同一类型，尽管它们通常是这样的。作为一个极端的例子，考虑以下可以在一个高度混乱的程序集中共存的类型声明：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although I’d strongly discourage code like the above, one reasonably common
    pattern is to have a nongeneric static class providing helper methods that refer
    to other generic types with the same name (see [section 2.5.2](kindle_split_017_split_000.html#ch02lev2sec22)
    for more about static classes). For example, you’ll see the `Tuple` class in [section
    2.1.4](kindle_split_017_split_000.html#ch02lev2sec4), which is used to create
    instances of the various generic `Tuple` classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我强烈反对上述代码，但一个相对常见的模式是有一个非泛型静态类提供辅助方法，这些方法引用具有相同名称的其他泛型类型（有关静态类的更多信息，请参阅[第2.5.2节](kindle_split_017_split_000.html#ch02lev2sec22)）。例如，你会在[第2.1.4节](kindle_split_017_split_000.html#ch02lev2sec4)中看到
    `Tuple` 类，它用于创建各种泛型 `Tuple` 类的实例。
- en: 'Just as multiple types can have the same name but different generic arity,
    so can generic methods. It’s like creating overloads based on the parameters,
    except this is overloading based on the number of type parameters. Note that although
    the generic arity keeps declarations separate, type parameter names don’t. For
    example, you can’t declare two methods like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像多个类型可以有相同的名字但不同的泛型参数数量一样，泛型方法也是如此。这就像基于参数创建重载，但这是基于类型参数数量的重载。请注意，尽管泛型参数数量保持了声明之间的分离，但类型参数名称并没有。例如，你不能声明如下两个方法：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Compile-time error; can’t overload solely by type parameter name**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 编译时错误；不能仅通过类型参数名称进行重载**'
- en: These are deemed to have equivalent signatures, so they aren’t permitted under
    the normal rules of method overloading. You can write method overloads that use
    different type parameter names so long as the methods differ in other ways (such
    as the number of regular parameters), although I can’t remember ever wanting to
    do so.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被认为具有等效的签名，因此它们在方法重载的正常规则下是不被允许的。只要方法在其他方面有所不同（例如常规参数的数量），你就可以编写使用不同类型参数名称的方法重载，尽管我不记得曾经想要这样做。
- en: 'While we’re on the subject of multiple type parameters, you can’t give two
    type parameters in the same declaration the same name just like you can’t declare
    two regular parameters the same name. For example, you can’t declare a method
    like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论多个类型参数时，你不可能在同一个声明中给两个类型参数相同的名字，就像你不能声明两个常规参数具有相同的名字一样。例如，你不能声明如下方法：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Compile-time error; duplicate type parameter T**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 编译时错误；重复的类型参数 T**'
- en: It’s fine for two type arguments to be the same, though, and that’s often what
    you want. For example, to create a string-to-string mapping, you might use a `Dictionary<string,
    string>`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两个类型参数相同是可以的，而且这通常是你的需求。例如，为了创建字符串到字符串的映射，你可能使用 `Dictionary<string, string>`。
- en: The earlier example of `IAmConfusing` used an enum as the nongeneric type. That
    was no coincidence, because I wanted to use it to demonstrate my next point.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前 `IAmConfusing` 的例子使用了枚举作为非泛型类型。这不是巧合，因为我想要用它来展示我的下一个观点。
- en: 2.1.3\. What can be generic?
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3\. 什么是泛型？
- en: Not all types or type members can be generic. For types, it’s reasonably simple,
    partly because relatively few kinds of types can be declared. Enums can’t be generic,
    but classes, structs, interfaces, and delegates all can be.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类型或类型成员都可以是泛型的。对于类型来说，这相对简单，部分原因是因为可以声明的类型种类相对较少。枚举不能是泛型，但类、结构体、接口和委托都可以。
- en: For type members, it’s slightly more confusing; some members may look like they’re
    generic because they use other generic types. Remember that a declaration is generic
    only if it introduces new type parameters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型成员，这可能会稍微有些令人困惑；一些成员可能看起来像是泛型，因为它们使用了其他泛型类型。记住，只有当声明引入了新的类型参数时，声明才是泛型的。
- en: 'Methods and nested types can be generic, but all of the following have to be
    nongeneric:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和嵌套类型可以是泛型的，但以下所有都必须是非泛型的：
- en: Fields
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段
- en: Properties
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Indexers
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引器
- en: Constructors
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Events
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Finalizers
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构函数
- en: 'As an example of how you might be tempted to think of a field as being generic
    even though it’s not, consider this generic class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你可能倾向于将字段视为泛型，尽管它不是泛型的例子，考虑以下泛型类：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Lots of other members**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 许多其他成员**'
- en: I’ve named the type parameter `TItem` simply to differentiate it from the `T`
    type parameter of `List<T>`. Here, the `items` field is of type `List<TItem>`.
    It uses the type parameter `TItem` as a type argument for `List<T>`, but that’s
    a type parameter introduced by the class declaration, not by the field declaration.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我将类型参数命名为 `TItem`，只是为了将其与 `List<T>` 的 `T` 类型参数区分开来。在这里，`items` 字段是 `List<TItem>`
    类型。它使用类型参数 `TItem` 作为 `List<T>` 的类型参数，但这是由类声明引入的类型参数，而不是由字段声明引入的。
- en: For most of these, it’s hard to conceive how the member could be generic. Occasionally,
    I’ve wanted to write a generic constructor or indexer, though, and the answer
    is almost always to write a generic method instead.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些中的大多数，很难想象成员可以是泛型的。偶尔，我想要编写一个泛型构造函数或索引器，但答案几乎总是编写一个泛型方法。
- en: Speaking of generic methods, I gave only a simplified description of type arguments
    earlier when I was describing the way generic methods are called. In some cases,
    the compiler can determine the type arguments for a call without you having to
    provide them in the source code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 说到泛型方法，我在描述泛型方法的调用方式时，只给出了类型参数的简化描述。在某些情况下，编译器可以确定调用中的类型参数，而无需你在源代码中提供它们。
- en: 2.1.4\. Type inference for type arguments to methods
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.4\. 方法的类型参数类型推断
- en: 'Let’s look back at the crucial parts of [listing 2.5](kindle_split_017_split_000.html#ch02ex05).
    You have a generic method declared like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[列表2.5](kindle_split_017_split_000.html#ch02ex05)的关键部分。你有一个这样声明的泛型方法：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, in the `Main` method, you declare a variable of type `List<int>` and
    later use that as an argument to the method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Main`方法中，你声明一个类型为`List<int>`的变量，稍后将其用作方法的参数：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I’ve highlighted the method call here. You need a type argument to the `CopyAtMost`
    call, because it has a type parameter. But you don’t have to specify that type
    argument in the source code. You can rewrite that code as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里突出了方法调用。你需要为`CopyAtMost`调用提供一个类型参数，因为它有一个类型参数。但你不必在源代码中指定该类型参数。你可以将那段代码重写如下：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is exactly the same method call in terms of the IL the compiler will generate.
    But you haven’t had to specify the type argument of `int`; the compiler inferred
    that for you. It did that based on your argument for the first parameter in the
    method. You’re using an argument of type `List<int>` as the value for a parameter
    of type `List<T>`, so `T` has to be `int`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是编译器在IL中生成的完全相同的调用方法。但你不必指定`int`的类型参数；编译器为你推断出了这个类型。它是根据你在方法中的第一个参数的参数推断出来的。你使用类型为`List<int>`的参数作为类型为`List<T>`的参数的值，因此`T`必须是`int`。
- en: Type inference can use only the arguments you pass to a method, not what you
    do with the result. It also has to be complete; you either explicitly specify
    all the type arguments or none of them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断只能使用你传递给方法的参数，而不能使用你对结果所做的操作。它还必须是完整的；你必须显式指定所有类型参数或根本不指定。
- en: 'Although type inference applies only to methods, it can be used to more easily
    construct instances of generic types. For example, consider the `Tuple` family
    of types introduced in .NET 4.0\. This consists of a nongeneric static `Tuple`
    class and multiple generic classes: `Tuple<T1>`, `Tuple<T1, T2>`, `Tuple<T1, T2,
    T3>`, and so forth. The static class has a set of overloaded `Create` factory
    methods like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型推断仅适用于方法，但它可以用来更轻松地构造泛型类型的实例。例如，考虑.NET 4.0中引入的`Tuple`类型家族。它由一个非泛型的静态`Tuple`类和多个泛型类组成：`Tuple<T1>`、`Tuple<T1,
    T2>`、`Tuple<T1, T2, T3>`等等。静态类有一组重载的`Create`工厂方法，如下所示：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These look pointlessly trivial, but they allow type inference to be used where
    otherwise the type arguments would have to be explicitly specified when creating
    tuples. Instead of this
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来毫无意义，但它们允许在创建元组时使用类型推断，否则在创建元组时必须显式指定类型参数。而不是这样做
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'you can write this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写出这个：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a powerful technique to be aware of; it’s generally simple to implement
    and can make working with generic code a lot more pleasant.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要了解的强大技术；它通常很容易实现，可以使处理泛型代码变得更加愉快。
- en: I’m not going to go into the details of how generic type inference works. It’s
    changed a lot over time as the language designers figure out ways of making it
    work in more cases. Overload resolution and type inference are closely tied together,
    and they intersect with all kinds of other features (such as inheritance, conversions,
    and optional parameters in C# 4). This is the area of the specification I find
    the most complex,^([[4](kindle_split_017_split_000.html#ch02fn4)]) and I couldn’t
    do it justice here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨泛型类型推断的工作原理。随着时间的推移，语言设计者找到了使其在更多情况下工作的方式，因此它发生了很大的变化。重载解析和类型推断紧密相连，并且与所有各种其他特性（如继承、转换和C#
    4中的可选参数）相交。这是我认为最复杂的规范领域，^([[4](kindle_split_017_split_000.html#ch02fn4)])，在这里我无法做到公正。
- en: ⁴
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’m not alone in this. At the time of this writing, the spec for overload resolution
    is broken. Efforts to fix it for the C# 5 ECMA standard failed; we’re going to
    try again for the next edition.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我并不孤单。在撰写本文时，重载解析的规范已经破裂。为C# 5 ECMA标准修复它的努力失败了；我们将为下一版再次尝试。
- en: 'Fortunately, this is one area where understanding the details wouldn’t help
    very much in day-to-day coding. In any particular situation, three possibilities
    exist:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是理解细节在日常编码中不会帮助很大的一个领域。在任何特定情况下，存在三种可能性：
- en: Type inference succeeds and gives you the result you want. Hooray.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断成功并给出了你想要的结果。太好了。
- en: Type inference succeeds but gives you a result you didn’t want. Just explicitly
    specify type arguments or cast some of the arguments. For example, if you wanted
    a `Tuple<int, object, int>` from the preceding `Tuple.Create` call, you could
    specify the type arguments to `Tuple.Create` explicitly or just call `new Tuple<int,
    object, int>(`...`)` or call `Tuple.Create(10, (object) "x", 20)`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断成功但给出了你不想得到的结果。只需显式指定类型参数或对一些参数进行类型转换。例如，如果你从前面的`Tuple.Create`调用中想要一个`Tuple<int,
    object, int>`，你可以显式指定`Tuple.Create`的类型参数，或者只是调用`new Tuple<int, object, int>(...)`，或者调用`Tuple.Create(10,
    (object) "x", 20)`。
- en: Type inference fails at compile time. Sometimes this can be fixed by casting
    some of your arguments. For example, the `null` literal doesn’t have a type, so
    type inference will fail for `Tuple.Create(null, 50)` but succeed for `Tuple.Create((string)
    null, 50)`. Other times you just need to explicitly specify the type arguments.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断在编译时失败。有时可以通过对一些参数进行类型转换来修复。例如，`null`字面量没有类型，所以对于`Tuple.Create(null, 50)`类型推断会失败，但对于`Tuple.Create((string)
    null, 50)`则会成功。有时你只需要显式指定类型参数。
- en: For the last two cases, the option you pick rarely makes much difference to
    readability in my experience. Understanding the details of type inference can
    make it easier to predict what will work and what won’t, but it’s unlikely to
    repay the time invested in studying the specification. If you’re curious, I’d
    never actively discourage anyone from reading the specification. Just don’t be
    surprised when you find it alternates between feeling like a maze of twisty little
    passages, all alike, and a maze of twisty little passages, all different.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我个人的经验中，对于最后两种情况，你选择的选项很少对可读性有很大影响。理解类型推断的细节可以使预测哪些会工作以及哪些不会变得更容易，但不太可能回报你在研究规范上投入的时间。如果你好奇，我永远不会积极阻止任何人阅读规范。只是当你发现它交替地感觉像是一个迷宫，所有的通道都一样，然后是一个迷宫，所有的通道都不同时，不要感到惊讶。
- en: This alarmist talk of complicated language details shouldn’t detract from the
    convenience of type inference, though. C# is considerably easier to use because
    of its presence.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关于复杂语言细节的夸张谈话不应该影响类型推断的便利性。由于它的存在，C#的使用要容易得多。
- en: So far, all the type parameters we’ve talked about have been unconstrained.
    They could stand in for any type. That’s not always what you want, though; sometimes,
    you want only certain types to be used as type arguments for a particular type
    parameter. That’s where type constraints come in.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有类型参数都是无约束的。它们可以代表任何类型。但这并不总是你想要的；有时，你只想让某些类型作为特定类型参数的类型参数。这就是类型约束发挥作用的地方。
- en: 2.1.5\. Type constraints
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.5\. 类型约束
- en: 'When a type parameter is declared by a generic type or method, it can also
    specify *type constraints* that restrict which types can be provided as type arguments.
    Suppose you want to write a method that formats a list of items and ensures that
    you format them in a particular culture instead of the default culture of the
    thread. The `IFormattable` interface provides a suitable `ToString(string, IFormatProvider)`
    method, but how can you make sure you have an appropriate list? You might expect
    a signature like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个泛型类型或方法声明一个类型参数时，它也可以指定*类型约束*，以限制哪些类型可以作为类型参数提供。假设你想编写一个方法，格式化一个项目列表，并确保你使用特定的文化格式化而不是线程的默认文化。`IFormattable`接口提供了一个合适的`ToString(string,
    IFormatProvider)`方法，但你如何确保你有一个合适的列表？你可能期望一个这样的签名：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But that would hardly ever be useful. You couldn’t pass a `List<decimal>` to
    it, for example, even though `decimal` implements `IFormattable`; a `List<decimal>`
    isn’t convertible to `List<IFormattable>`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但这几乎永远不会很有用。例如，你不能传递一个`List<decimal>`给它，即使`decimal`实现了`IFormattable`；`List<decimal>`不能转换为`List<IFormattable>`。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll go into the reasons for this more deeply in [chapter 4](kindle_split_019_split_000.html#ch04),
    when we consider generic variance. For the moment, just treat this as a simple
    example for constraints.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章中更深入地探讨这个原因，当我们考虑泛型方差时。现在，只需将其视为一个约束的简单示例。
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'What you need to express is that the parameter is a list of some element type,
    where the element type implements the `IFormattable` interface. The “some element
    type” part suggests that you might want to make the method generic, and “where
    the element type implements the `IFormattable` interface” is precisely the ability
    that type constraints give us. You add a `where` clause at the end of the method
    declaration, like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要表达的是参数是一个某些元素类型的列表，其中元素类型实现了 `IFormattable` 接口。"某些元素类型" 部分暗示你可能想使该方法泛型，而
    "where the element type implements the `IFormattable` interface" 正是类型约束给我们的能力。你可以在方法声明的末尾添加一个
    `where` 子句，如下所示：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The way you’ve constrained `T` here doesn’t just change which values can be
    passed to the method; it also changes what you can do with a value of type `T`
    within the method. The compiler knows that `T` implements `IFormattable`, so it
    allows the `IFormattable.ToString(string, IFormatProvider)` method to be called
    on any `T` value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里对 `T` 的约束不仅改变了可以传递给方法的价值；它还改变了在方法内部可以使用 `T` 类型的值做什么。编译器知道 `T` 实现了 `IFormattable`，因此它允许在任意的
    `T` 值上调用 `IFormattable.ToString(string, IFormatProvider)` 方法。
- en: Listing 2.6\. Printing items in the invariant culture by using type constraints
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. 使用类型约束在不变文化中打印项目
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Without the type constraints, that `ToString` call wouldn’t compile; the only
    `ToString` method the compiler would know about for `T` is the one declared in
    `System.Object`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没有类型约束，那个 `ToString` 调用就不会编译；编译器对 `T` 所知的唯一 `ToString` 方法是在 `System.Object`
    中声明的。
- en: 'Type constraints aren’t limited to interfaces. The following type constraints
    are available:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束不仅限于接口。以下类型约束可用：
- en: '*Reference type constraint*—`where T : class`. The type argument must be a
    reference type. (Don’t be fooled by the use of the `class` keyword; it can be
    any reference type, including interfaces and delegates.)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引用类型约束*—`where T : class`。类型参数必须是一个引用类型。（不要被 `class` 关键字的用法所迷惑；它可以是任何引用类型，包括接口和委托。）'
- en: '*Value type constraint*—`where T : struct`. The type argument must be a non-nullable
    value type (either a struct or an enum). Nullable value types (described in [section
    2.2](kindle_split_017_split_000.html#ch02lev1sec2)) don’t meet this constraint.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值类型约束*—`where T : struct`。类型参数必须是非可空值类型（要么是结构体，要么是枚举）。可空值类型（在第 2.2 节中描述）不满足此约束。'
- en: '*Constructor constraint*—`where T : new()`. The type argument must have a public
    parameterless constructor. This enables the use of `new T()` within the body of
    the code to construct a new instance of `T`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构造函数约束*—`where T : new()`。类型参数必须有一个公共的无参数构造函数。这允许在代码体中使用 `new T()` 来构造 `T`
    的新实例。'
- en: '*Conversion constraint*—`where T : SomeType`. Here, `SomeType` can be a class,
    an interface, or another type parameter as shown here:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转换约束*—`where T : SomeType`。在这里，`SomeType` 可以是一个类、一个接口或另一个类型参数，如下所示：'
- en: '`where T :` `Control`'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T :` `Control`'
- en: '`where T :` `IFormattable`'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T :` `IFormattable`'
- en: '`where T1 :` `T2`'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T1 :` `T2`'
- en: Moderately complex rules indicate how constraints can be combined. In general,
    the compiler error message makes it obvious what’s wrong when you break these
    rules.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 中等复杂的规则说明了如何组合约束。一般来说，当你违反这些规则时，编译器错误信息会清楚地表明问题所在。
- en: 'One interesting and reasonably common form of constraint uses the type parameter
    in the constraint itself:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有趣且相对常见的约束形式是使用约束本身中的类型参数：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The constraint uses `T` as the type argument to the generic `IComparable<T>`
    interface. This allows our sorting method to compare elements from the `items`
    parameter pairwise using the `CompareTo` method from `IComparable<T>`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 该约束使用 `T` 作为泛型 `IComparable<T>` 接口类型参数。这允许我们的排序方法通过 `IComparable<T>` 的 `CompareTo`
    方法成对比较 `items` 参数中的元素：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I’ve used interface-based type constraints more than any other kind, although
    I suspect what you use depends greatly on the kind of code you’re writing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我比其他任何类型都更多地使用了基于接口的类型约束，尽管我怀疑你使用什么很大程度上取决于你编写的代码类型。
- en: 'When multiple type parameters exist in a generic declaration, each type parameter
    can have an entirely different set of constraints as in the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当在泛型声明中存在多个类型参数时，每个类型参数都可以有完全不同的约束集，如下例所示：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Generic method with two type parameters, TArg and TResult**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 具有两个类型参数的通用方法，TArg 和 TResult**'
- en: '***2* TArg must implement IComparable<TArg>.**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* TArg 必须实现 IComparable<TArg>。**'
- en: '***3* TResult must be a reference type with a parameterless constructor.**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* TResult 必须是一个具有无参数构造函数的引用类型。**'
- en: We’ve nearly finished our whirlwind tour of generics, but I have a couple of
    topics left to describe. I’ll start with the two type-related operators available
    in C# 2.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了对泛型的快速浏览，但我还有一些主题要描述。我将从 C# 2 中可用的两个类型相关操作符开始。
- en: 2.1.6\. The default and typeof operators
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.6\. 默认和 typeof 操作符
- en: C# 1 already had the `typeof()` operator accepting a type name as its only operand.
    C# 2 added the `default()` operator and expanded the use of `typeof` slightly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: C# 1 已经有了 `typeof()` 操作符，它只接受类型名称作为其唯一的操作数。C# 2 添加了 `default()` 操作符并稍微扩展了 `typeof`
    的使用。
- en: The `default` operator is easily described. The operand is the name of a type
    or type parameter, and the result is the default value for that type—the same
    value you’d get if you declared a field and didn’t immediately assign a value
    to it. For reference types, that’s a null reference; for non-nullable value types,
    it’s the “all zeroes” value (0, 0.0, 0.0m, false, the UTF-16 code unit with a
    numerical value of 0, and so on); and for nullable value types, it’s the null
    value for the type.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 操作符很容易描述。操作数是类型或类型参数的名称，结果是该类型的默认值——如果你声明了一个字段但没有立即为其赋值，你会得到相同的值。对于引用类型，这是一个空引用；对于不可为
    null 的值类型，它是“全零”值（0、0.0、0.0m、false、数值为 0 的 UTF-16 代码单元等）；对于可为 null 的值类型，它是该类型的
    null 值。'
- en: 'The `default` operator can be used with type parameters and with generic types
    with appropriate type arguments supplied (where those arguments can be type parameters,
    too). For example, in a generic method declaring a type parameter T, all of these
    are valid:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 操作符可以与类型参数以及提供适当类型参数的泛型类型一起使用（这些参数也可以是类型参数）。例如，在声明类型参数为 T 的泛型方法中，所有这些都是有效的：'
- en: '`default(T)`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default(T)`'
- en: '`default(int)`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default(int)`'
- en: '`default(string)`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default(string)`'
- en: '`default(List<T>)`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default(List<T>)`'
- en: '`default(List<List<string>>)`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default(List<List<string>>)`'
- en: 'The type of the `default` operator is the type that’s named inside it. It’s
    most frequently used with generic type parameters, because otherwise you can usually
    specify the default value in a different way. For example, you might want to use
    the default value as the initial value for a local variable that may or may not
    be assigned a different value later. To make this concrete, here’s a simplistic
    implementation of a method that may be familiar to you:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 操作符的类型是其中命名的类型。它最常与泛型类型参数一起使用，因为否则你通常可以用不同的方式指定默认值。例如，你可能想使用默认值作为可能或可能不会在以后分配不同值的局部变量的初始值。为了使这一点具体化，这里有一个可能熟悉你的方法的简单实现：'
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Declare a local variable and assign the default value of T to it.**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个局部变量并将其赋值为 T 的默认值。**'
- en: '***2* Replace the local variable value with the current one in the sequence.**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 用序列中的当前值替换局部变量的值。**'
- en: '***3* Return the last-assigned value.**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回最后分配的值。**'
- en: 'The `typeof` operator is slightly more complex. There are four broad cases
    to consider:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 操作符稍微复杂一些。有四种主要情况需要考虑：'
- en: No generics involved at all; for example, `typeof(string)`
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全不涉及泛型；例如，`typeof(string)`
- en: Generics involved but no type parameters; for example, `typeof(List<int>)`
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及泛型但没有类型参数；例如，`typeof(List<int>)`
- en: Just a type parameter; for example, `typeof(T)`
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只是一个类型参数；例如，`typeof(T)`
- en: Generics involved using a type parameter in the operand; for example, `typeof(List<TItem>)`
    within a generic method declaring a type parameter called `TItem`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作数中使用类型参数涉及泛型；例如，在声明类型参数为 `TItem` 的泛型方法中，`typeof(List<TItem>)`
- en: Generics involved but no type arguments specified in the operand; for example,
    `typeof(List<>)`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及泛型但在操作数中没有指定类型参数；例如，`typeof(List<>)`
- en: 'The first of these is simple and hasn’t changed at all. All the others need
    a little more care, and the last introduces a new kind of syntax. The `typeof`
    operator is still defined to return a `Type` value, so what should it return in
    each of these cases? The `Type` class was augmented to know about generics. There
    are multiple situations to be considered; the following are a few examples:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一个很简单，没有任何变化。其他所有情况都需要更多的注意，最后一种引入了一种新的语法。`typeof` 操作符仍然被定义为返回一个 `Type` 值，那么在这些情况下它应该返回什么？`Type`
    类被扩展以了解泛型。有多个情况需要考虑；以下是一些示例：
- en: If you list the types within the assembly containing `List<T>`, for example,
    you’d expect to get `List<T>` without any specific type argument for `T`. It’s
    a *generic type definition*.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你列出包含`List<T>`的程序集中的类型，例如，你预计会得到没有为`T`指定任何特定类型参数的`List<T>`。这是一个*泛型类型定义*。
- en: If you call `GetType()` on a `List<int>` object, you’d want to get a type that
    has the information about the type argument.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在一个`List<int>`对象上调用`GetType()`，你将希望得到一个包含类型参数信息的类型。
- en: If you ask for the base type of the generic type definition of a class declared
    as
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你询问一个声明为
- en: '[PRE26]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: you’d end up with a type with one “concrete” type argument (`string`, for the
    `TKey` type parameter of `Dictionary<TKey, TValue>`) and one type argument that’s
    still a type parameter (`T`, for the `TValue` type parameter).
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 的类的泛型类型定义的基本类型，你将得到一个包含一个“具体”类型参数（对于`Dictionary<TKey, TValue>`的`TKey`类型参数是`string`）和一个仍然是类型参数的类型参数（对于`TValue`类型参数是`T`）的类型。
- en: Frankly, it’s all very confusing, but that’s inherent in the problem domain.
    Lots of methods and properties in `Type` let you go from a generic type definition
    to a type with all the type arguments provided, or vice versa, for example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，这非常令人困惑，但这在问题域中是固有的。`Type`中的许多方法和属性允许你从一个泛型类型定义转换到具有所有类型参数的类型，或者反之亦然，例如。
- en: Let’s come back to the `typeof` operator. The simplest example to understand
    is `typeof(List<int>)`. That returns the `Type` representing `List<T>` with a
    type argument of `int` just as if you’d called `new List<int>().GetType()`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`typeof`运算符。理解的最简单例子是`typeof(List<int>)`。它返回代表具有`int`类型参数的`List<T>`的`Type`，就像你调用`new
    List<int>().GetType()`一样。
- en: The next case, `typeof(T)`, returns whatever the type argument for `T` is at
    that point in the code. This will always be a *closed, constructed type*, which
    is the specification’s way of saying it’s a real type with no type parameters
    involved anywhere. Although in most places I try to explain terminology thoroughly,
    the terminology around generics (open, closed, constructed, bound, unbound) is
    confusing and almost never useful in real life. We’ll need to talk about closed,
    constructed types later, but I won’t touch on the rest.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个案例，`typeof(T)`，返回在代码中该点`T`的类型参数是什么。这始终是一个*封闭的、构造的类型*，这是规范中指明它是没有涉及任何类型参数的真正类型的方式。尽管我在大多数地方都试图彻底解释术语，但泛型（开放、封闭、构造、绑定、未绑定）的术语令人困惑，并且在现实生活中几乎从未有用过。我们稍后会讨论封闭的、构造的类型，但不会涉及其他内容。
- en: It’s easiest to demonstrate what I mean about `typeof(T)`, and you can look
    at `typeof(List<T>)` in the same example. The following listing declares a generic
    method that prints the result of both `typeof(T)` and `typeof(List<T>)` to the
    console and then calls that method with two different type arguments.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易演示的是关于`typeof(T)`的含义，你可以在同一个例子中查看`typeof(List<T>)`。下面的列表声明了一个泛型方法，该方法将`typeof(T)`和`typeof(List<T>)`的结果打印到控制台，然后使用两个不同的类型参数调用该方法。
- en: Listing 2.7\. Printing the result of the `typeof` operator
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 打印typeof运算符的结果
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Prints both typeof(T) and typeof(List<T>)**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印typeof(T)和typeof(List<T>)**'
- en: '***2* Calls the method with a type argument of string**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用字符串类型参数调用方法**'
- en: '***3* Calls the method with a type argument of int**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用整数类型参数调用方法**'
- en: 'The result of [listing 2.7](kindle_split_017_split_000.html#ch02ex07) is shown
    here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.7](kindle_split_017_split_000.html#ch02ex07)的结果如下所示：'
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The important point is that when you’re running in a context where the type
    argument for `T` is `string` (during the first call), the result of `typeof(T)`
    is the same as `typeof(string)`. Likewise, the result of `typeof(List<T>)` is
    the same as the result of `typeof(List<string>)`. When you call the method again
    with `int` as the type argument, you get the same results as for `typeof(int)`
    and `typeof(List<int>)`. Whenever code is executing within a generic type or method,
    the type parameter always refers to a closed, constructed type.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当你在一个类型参数为`string`（在第一次调用期间）的环境中运行时，`typeof(T)`的结果与`typeof(string)`相同。同样，`typeof(List<T>)`的结果与`typeof(List<string>)`的结果相同。当你再次使用`int`作为类型参数调用该方法时，你得到与`typeof(int)`和`typeof(List<int>)`相同的结果。当代码在泛型类型或方法中执行时，类型参数始终指代一个封闭的、构造的类型。
- en: Another takeaway from this output is the format of the name of a generic type
    when you’re using reflection. The ``List`1`` indicates that this is a generic
    type called `List` with generic arity 1 (one type parameter), and the type arguments
    are shown in square brackets afterward.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，另一个可以吸取的经验是使用反射时泛型类型的名称格式。`List`1`表示这是一个名为`List`的泛型类型，具有1个泛型秩（一个类型参数），类型参数随后显示在方括号中。
- en: The final bullet in our earlier list was `typeof(List<>)`. That appears to be
    missing a type argument altogether. This syntax is valid only in the `typeof`
    operator and refers to the generic type definition. The syntax for types with
    generic arity 1 is just `TypeName<>`; for each additional type parameter, you
    add a comma within the angle brackets. To get the generic type definition for
    `Dictionary<TKey, TValue>`, you’d use `typeof(Dictionary<,>)`. To get the definition
    for `Tuple<T1, T2, T3>`, you’d use `typeof(Tuple<,,>)`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前列表中的最后一项是`typeof(List<>)`。这似乎完全缺少了一个类型参数。这种语法仅在`typeof`运算符中有效，并指代泛型类型定义。对于具有1个泛型秩的类型，语法是`TypeName<>`；对于每个额外的类型参数，你需要在尖括号内添加一个逗号。要获取`Dictionary<TKey,
    TValue>`的泛型类型定义，你会使用`typeof(Dictionary<,>)`。要获取`Tuple<T1, T2, T3>`的定义，你会使用`typeof(Tuple<,,>)`。
- en: 'Understanding the difference between a generic type definition and a closed,
    constructed type is crucial for our final topic: how types are initialized and
    how type-wide (static) state is handled.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 理解泛型类型定义与关闭的、已构造类型之间的区别对于我们最终话题至关重要：类型是如何初始化的，以及类型范围内的（静态）状态是如何处理的。
- en: 2.1.7\. Generic type initialization and state
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.7\. 泛型类型初始化和状态
- en: As you saw when using the `typeof` operator, `List<int>` and `List<string>`
    are effectively different types that are constructed from the same generic type
    definition. That’s not only true for how you use the types but also true for how
    types are initialized and how static fields are handled. Each closed, constructed
    type is initialized separately and has its own independent set of static fields.
    The following listing demonstrates this with a simple (and not thread-safe) generic
    counter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在使用`typeof`运算符时看到的，`List<int>`和`List<string>`实际上是不同的类型，它们是由相同的泛型类型定义构造的。这不仅适用于你如何使用这些类型，也适用于类型是如何初始化的，以及静态字段是如何处理的。每个关闭的、已构造的类型都是单独初始化的，并且有自己的独立静态字段集合。以下列表通过一个简单的（非线程安全）泛型计数器演示了这一点。
- en: Listing 2.8\. Exploring static fields in generic types
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8\. 探索泛型类型中的静态字段
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* One field per closed, constructed type**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每个关闭的、已构造的类型有一个字段**'
- en: '***2* Triggers initialization for GenericCounter<string>**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 触发GenericCounter<string>的初始化**'
- en: '***3* Triggers initialization for GenericCounter<int>**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 触发GenericCounter<int>的初始化**'
- en: 'The output of [listing 2.8](kindle_split_017_split_000.html#ch02ex08) is as
    follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.8](kindle_split_017_split_000.html#ch02ex08)的输出如下：'
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are two results to focus on in that output. First, the `GenericCounter<string>`
    value is independent of `GenericCounter<int>`. Second, the static constructor
    is run twice: once for each closed, constructed type. If you didn’t have a static
    constructor, there would be fewer timing guarantees for exactly when each type
    would be initialized, but essentially you can regard `GenericCounter<string>`
    and `GenericCounter<int>` as independent types.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个输出中，有两个结果需要关注。首先，`GenericCounter<string>`的值与`GenericCounter<int>`是独立的。其次，静态构造函数运行了两次：一次为每个关闭的、已构造的类型。如果你没有静态构造函数，那么对于每个类型确切初始化的时间保证会更少，但本质上你可以将`GenericCounter<string>`和`GenericCounter<int>`视为独立的类型。
- en: 'To complicate things further, generic types can be nested within other generic
    types. When that occurs, there’s a separate type for each combination of type
    arguments. For example, consider classes like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步复杂化问题，泛型类型可以嵌套在其他泛型类型中。当这种情况发生时，对于每个类型参数的组合都有一个单独的类型。例如，考虑以下类：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using `int` and `string` as type arguments, the following types are independent
    and each has its own `value` field:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`int`和`string`作为类型参数，以下类型是独立的，并且每个都有自己的`value`字段：
- en: '`Outer<string>.Inner<string>`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Outer<string>.Inner<string>`'
- en: '`Outer<string>.Inner<int>`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Outer<string>.Inner<int>`'
- en: '`Outer<int>.Inner<string>`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Outer<int>.Inner<string>`'
- en: '`Outer<int>.Inner<int>`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Outer<int>.Inner<int>`'
- en: In most code this occurs relatively rarely, and it’s simple enough to handle
    when you’re aware that what’s important is the fully specified type, including
    any type arguments for both the leaf type and any enclosing types.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数代码中，这种情况相对较少见，当你意识到重要的是完全指定的类型，包括叶类型和任何封装类型的任何类型参数时，处理起来就足够简单了。
- en: That’s it for generics, which is by far the biggest single feature in C# 2 and
    a huge improvement over C# 1\. Our next topic is nullable value types, which are
    firmly based on generics.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是泛型，它是C# 2中最大的单一特性，并且比C# 1有了巨大的改进。我们接下来要讨论的是可空值类型，它们牢牢地基于泛型。
- en: 2.2\. Nullable value types
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. 可空值类型
- en: Tony Hoare introduced null references into Algol in 1965 and has subsequently
    called it his “billion-dollar mistake.” Countless developers have become frustrated
    when their code throws `NullReferenceException` (.NET), `NullPointerException`
    (Java), or other equivalents. There are canonical Stack Overflow questions with
    hundreds of other questions pointing at them because it’s such a common problem.
    If nullity is so bad, why was more of it introduced in C# 2 and .NET 2.0 in the
    form of nullable value types? Before we look at the implementation of the feature,
    let’s consider the problem it’s trying to solve and the previous workarounds.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 托尼·霍尔（Tony Hoare）在1965年将空引用引入到ALGOL中，并随后称其为他的“十亿美元的错误”。无数的开发者在他们的代码抛出`NullReferenceException`
    (.NET)、`NullPointerException` (Java)或其他等效异常时感到沮丧。Stack Overflow上有许多标准问题，有数百个其他问题指向它们，因为这是一个非常普遍的问题。如果空值如此糟糕，为什么在C#
    2和.NET 2.0中引入了更多的空值类型？在我们查看该功能的实现之前，让我们考虑它试图解决的问题和之前的工作方案。
- en: '2.2.1\. Aim: Expressing an absence of information'
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1. 目标：表达信息缺失
- en: 'Sometimes it’s useful to have a variable to represent some information, but
    that information won’t be present in every situation. Here are a few simple examples:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候有一个变量来表示某些信息是有用的，但并不是在每种情况下都会存在这种信息。这里有一些简单的例子：
- en: You’re modeling a customer order, including the company’s details, but the customer
    may not be ordering on behalf of a company.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在模拟一个客户订单，包括公司的详细信息，但客户可能不是代表公司订购。
- en: You’re modeling a person, including their date of birth and date of death, but
    the person may still be alive.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在模拟一个人，包括他们的出生日期和死亡日期，但这个人可能仍然活着。
- en: You’re modeling a filter for products, including a price range, but the customer
    may not have specified a maximum price.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在模拟一个产品的过滤器，包括价格范围，但客户可能没有指定最大价格。
- en: These are all one specific form of wanting to represent the absence of a value;
    you can have complete information but still need to model the absence. In other
    situations, you may have incomplete information. In the second example, you may
    not know the person’s date of birth not because they weren’t born, but because
    your system doesn’t have that information. Sometimes you need to represent the
    difference between “known to be absent” and “unknown” within your data, but often
    just the absence of information is enough.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是想要表示值缺失的一种特定形式；你可能拥有完整的信息，但仍需要模拟缺失。在其他情况下，你可能拥有不完整的信息。在第二个例子中，你可能不知道某人的出生日期，并不是因为他们没有出生，而是因为你的系统没有这方面的信息。有时你需要在数据中表达“已知缺失”和“未知”之间的差异，但通常只是信息的缺失就足够了。
- en: 'For reference types, you already have a way of representing an absence of information:
    a null reference. If you have a `Company` class and your `Order` class has a reference
    to the company associated with the order, you can set it to null if the customer
    doesn’t specify a company.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型，你已经有一种表示信息缺失的方法：空引用。如果你有一个`Company`类，并且你的`Order`类有一个与订单关联的公司引用，你可以将其设置为null，如果客户没有指定公司。
- en: 'For value types in C# 1, there was no equivalent. There were two common ways
    of representing this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C# 1中的值类型，没有等效的方法。有两种常见的方法来表示这一点：
- en: Use a reserved value to represent missing data. For example, you might use `decimal.MaxValue`
    in a price filter to represent “no maximum price specified.”
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用保留值来表示缺失的数据。例如，你可能会在价格过滤器中使用`decimal.MaxValue`来表示“未指定最大价格”。
- en: Keep a separate Boolean flag to indicate whether another field has a real value
    or the value should be ignored. So long as you check the flag before using the
    other field, its value is irrelevant in the absent case.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护一个单独的布尔标志来指示另一个字段是否有实际值或应该被忽略的值。只要你在使用其他字段之前检查标志，其值在缺失的情况下就是无关紧要的。
- en: Neither of these is ideal. The first approach reduces the set of valid values
    (not so bad for `decimal` but more of a problem for `byte`, where it’s more likely
    that you need the full range). The second approach leads to a lot of tedious and
    repetitive logic.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都不是理想的。第一种方法减少了有效值的集合（对于`decimal`来说问题不大，但对于`byte`来说则是一个问题，因为可能需要完整的范围）。第二种方法会导致大量的繁琐和重复的逻辑。
- en: More important, both are error prone. Both require you to perform a check before
    using the value that might or might not be valid. If you don’t perform that check,
    your code will proceed using inappropriate data. It’ll silently do the wrong thing
    and quite possibly propagate the mistake to other parts of the system. Silent
    failure is the worst kind, because it can be hard to track down and hard to undo.
    I prefer nice loud exceptions that stop the broken code in its tracks.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，两者都容易出错。两者都需要你在使用可能有效或无效的值之前进行检查。如果你不执行这个检查，你的代码将继续使用不适当的数据。它将默默地做错事情，并且很可能会将错误传播到系统的其他部分。静默失败是最糟糕的，因为它很难追踪，也很难撤销。我更喜欢那种大声的异常，它能够立即停止错误的代码。
- en: 'Nullable value types encapsulate the second approach shown previously: they
    keep an extra flag along with the value to say whether it should be used. The
    encapsulation is key here; the simplest way of using the value is also a safe
    one because it throws an exception if you try to use it inappropriately. The consistent
    use of a single type to represent a possibly missing value enables the language
    to make our lives easier, and library authors have an idiomatic way of representing
    it in their API surface, too.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 可空值类型封装了之前展示的第二种方法：它们保留了一个额外的标志和值，以表示是否应该使用它。封装在这里是关键；使用值的简单方式也是安全的，因为如果你尝试在不适当的情况下使用它，它将抛出异常。使用单一类型一致地表示可能缺失的值使得语言能够使我们的生活更轻松，并且库作者也有一种在他们的
    API 表面表示它的习惯方式。
- en: With that conceptual introduction out of the way, let’s look at what the framework
    and the CLR provide in terms of nullable value types. After you’ve built that
    foundation, I’ll show you the extra features C# has adopted to make it easy to
    work with them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个概念介绍之后，让我们看看框架和 CLR 在可空值类型方面提供了什么。在你建立了这个基础之后，我会向你展示 C# 采纳的额外特性，使它们易于使用。
- en: '2.2.2\. CLR and framework support: The Nullable<T> struct'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. CLR 和框架支持：`Nullable<T>` 结构
- en: 'The core of nullable value type support is the `Nullable<T>` struct. A primitive
    version of `Nullable<T>` would look like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可空值类型支持的核心是 `Nullable<T>` 结构。`Nullable<T>` 的原始版本看起来像这样：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Generic struct with T constrained to be a non-nullable value type**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 具有约束 T 为非可空值类型的泛型结构体**'
- en: '***2* Constructor to provide a value**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 构造函数以提供值**'
- en: '***3* Property to check whether there’s a real value**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 属性以检查是否存在实际值**'
- en: '***4* Access to the value, throwing an exception if it’s missing**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 访问值，如果值缺失则抛出异常**'
- en: 'As you can see, the only declared constructor sets `hasValue` to `true`, but
    like all structs, there’s an implicit parameterless constructor that will leave
    `hasValue` as `false` and `value` as the default value of `T`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，唯一声明的构造函数将 `hasValue` 设置为 `true`，但像所有结构体一样，存在一个隐式的无参构造函数，它将 `hasValue`
    设置为 `false` 并将 `value` 设置为 `T` 的默认值：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Prints False**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 False**'
- en: 'The `where T : struct` constraint on `Nullable<T>` allows `T` to be any value
    type except another `Nullable<T>`. It works with primitive types, enums, system-provided
    structs, and user-defined structs. All of the following are valid:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nullable<T>` 上对 `where T : struct` 的约束允许 `T` 是任何值类型，除了另一个 `Nullable<T>`。它与原始类型、枚举、系统提供的结构体和用户定义的结构体一起工作。以下都是有效的：'
- en: '`Nullable<int>`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<int>`'
- en: '`Nullable<FileMode>`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<FileMode>`'
- en: '`Nullable<Guid>`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<Guid>`'
- en: '`Nullable<LocalDate>` (from Noda Time)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<LocalDate>` (来自 Noda Time)'
- en: 'But the following are invalid:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下是不合法的：
- en: '`Nullable<string>` (`string` is a reference type)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<string>` (`string` 是引用类型)'
- en: '`Nullable<int[]>` (arrays are reference types, even if the element type is
    a value type)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<int[]>` (数组是引用类型，即使元素类型是值类型)'
- en: '`Nullable<ValueType>` (`ValueType` itself isn’t a value type)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<ValueType>` (`ValueType` 本身不是值类型)'
- en: '`Nullable<Enum>` (`Enum` itself isn’t a value type)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<Enum>` (`Enum` 本身不是值类型)'
- en: '`Nullable<Nullable<int>>` (`Nullable<int>` is nullable)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<Nullable<int>>` (`Nullable<int>` 是可空的)'
- en: '`Nullable<Nullable<Nullable<int>>>` (trying to nest the nullabilty further
    doesn’t help)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<Nullable<Nullable<int>>>` (尝试进一步嵌套可空性并不会有所帮助)'
- en: The type `T` is also known as the *underlying type* of `Nullable<T>`. For example,
    the underlying type of `Nullable<int>` is `int`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `T` 也被称为 `Nullable<T>` 的 *基础类型*。例如，`Nullable<int>` 的基础类型是 `int`。
- en: 'With just this part in place and no extra CLR, framework, or language support,
    you can safely use type to display the maximum price filter:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 只需这部分就位，没有额外的 CLR、框架或语言支持，你就可以安全地使用类型来显示最大价格过滤器：
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That’s well-behaved code that checks before using the value, but what about
    poorly written code that forgets to check first or checks the wrong thing? You
    can’t accidentally use an inappropriate value; if you try to access `maxPriceFilter.Value`
    when its `HasValue` property is `false`, an exception will be thrown.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段行为良好的代码，在使用值之前进行了检查，但关于那些忘记先检查或检查错误的内容的糟糕代码怎么办？你不能意外地使用不适当的价值；如果你在`maxPriceFilter.Value`的`HasValue`属性为`false`时尝试访问它，将会抛出异常。
- en: '|  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'I know I made this point earlier, but I think it’s important enough to restate:
    progress doesn’t come just from making it easier to write correct code; it also
    comes from making it harder to write broken code or making the consequences less
    severe.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我之前已经提到过这一点，但我认为这很重要，值得再次强调：进步不仅仅来自于使编写正确代码更容易；它也来自于使编写错误代码更困难或使后果更轻微。
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The `Nullable<T>` struct has methods and operators available, too:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nullable<T>`结构体也有可用的方法和运算符：'
- en: The parameterless `GetValueOrDefault()` method will return the value in the
    struct or the default value for the type if `HasValue` is `false`.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无参数的`GetValueOrDefault()`方法将在`struct`中返回值或如果`HasValue`是`false`，则返回该类型的默认值。
- en: The parameterized `GetValueOrDefault(T defaultValue)` method will return the
    value in the struct or the specified default value if `HasValue` is `false`.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化的`GetValueOrDefault(T defaultValue)`方法将在`struct`中返回值或如果`HasValue`是`false`，则返回指定的默认值。
- en: The `Equals(object)` and `GetHashCode()` methods declared in `object` are overridden
    in a reasonably obvious way, first comparing the `HasValue` properties and then
    comparing the `Value` properties for equality if `HasValue` is `true` for both
    values.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`object`中声明的`Equals(object)`和`GetHashCode()`方法以一种合理明显的方式被重写，首先比较`HasValue`属性，然后在两个值的`HasValue`都是`true`的情况下比较`Value`属性以检查相等性。
- en: There’s an implicit conversion from `T` to `Nullable<T>`, which always succeeds
    and returns a value where `HasValue` is `true`. This is equivalent to calling
    the parameterized constructor.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`T`到`Nullable<T>`存在隐式转换，这总是成功并返回一个`HasValue`为`true`的值。这相当于调用参数化构造函数。
- en: There’s an explicit conversion from `Nullable<T>` to `T`, which either returns
    the encapsulated value (if `HasValue` is `true`) or throws an `InvalidOperationException`
    (if `HasValue` is `false`). This is equivalent to using the `Value` property.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Nullable<T>`到`T`存在显式转换，它要么返回封装的值（如果`HasValue`是`true`），要么如果`HasValue`是`false`，则抛出`InvalidOperationException`。这相当于使用`Value`属性。
- en: 'I’ll return to the topic of conversions when I talk about language support.
    So far, the only place you’ve seen where the CLR needs to understand `Nullable<T>`
    is to enforce the `struct` type constraint. Another aspect of CLR behavior is
    nullable-specific, though: boxing.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在讨论语言支持时回到转换这个话题。到目前为止，你唯一看到CLR需要理解`Nullable<T>`的地方是强制`struct`类型约束。CLR行为的另一个方面是特定于可空的：装箱。
- en: Boxing behavior
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 装箱行为
- en: 'Nullable value types behave differently than non-nullable value types when
    it comes to boxing. When a value of a non-nullable value type is boxed, the result
    is a reference to an object of a type that’s the boxed form of the original type.
    Say, for example, you write this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可空值类型在装箱方面与非可空值类型的行为不同。当一个非可空值类型的值被装箱时，结果是原始类型的装箱形式的类型对象的引用。比如说，如果你写下这个：
- en: '[PRE35]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The value of `o` is a reference to an object of type “boxed `int`.” The difference
    between boxed `int` and `int` isn’t normally visible via C#. If you call `o.GetType()`,
    the `Type` returned will be equal to `typeof(int)`, for example. Some other languages
    (such as C++/CLI) allow developers to differentiate between the original value
    type and its boxed equivalent.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`o`的值是一个指向类型为“装箱`int`”的对象的引用。装箱`int`和`int`之间的区别通常在C#中不可见。如果你调用`o.GetType()`，返回的`Type`将等于`typeof(int)`，例如。一些其他语言（如C++/CLI）允许开发者区分原始值类型及其装箱等效类型。'
- en: 'Nullable value types have no boxed equivalent, however. The result of boxing
    a value of type `Nullable<T>` depends on the `HasValue` property:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可空值类型没有装箱等效类型。装箱类型`Nullable<T>`的值的结果取决于`HasValue`属性：
- en: If `HasValue` is `false`, the result is a null reference.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`HasValue`是`false`，结果是空引用。
- en: If `HasValue` is `true`, the result is a reference to an object of type “boxed
    `T`.”
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`HasValue`是`true`，结果是类型为“装箱`T`”的对象的引用。
- en: The following listing demonstrates both of these points.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表演示了这两个点。
- en: Listing 2.9\. The effects of boxing nullable value type values
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.9\. 装箱可空值类型值的影响
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Boxes a value where HasValue is false**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当 HasValue 为 false 时装箱一个值**'
- en: '***2* Prints True: the result of boxing is a null reference.**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 True：装箱的结果是空引用。**'
- en: '***3* Boxes a value where HasValue is true**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当 HasValue 为 true 时装箱一个值**'
- en: '***4* Prints System.Int32: the result is a boxed int.**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印 System.Int32：结果是装箱的 int。**'
- en: When you’re aware of this behavior, it’s almost always what you want. This has
    one bizarre side effect, however. The `GetType()` method declared on `System.Object`
    is nonvirtual, and the somewhat complex rules around when boxing occurs mean that
    if you call `GetType()` on a value type value, it always needs to be boxed first.
    Normally, that’s a little inefficient but doesn’t cause any confusion. With nullable
    value types, it’ll either cause a `NullReferenceException` or return the underlying
    non-nullable value type. The following listing shows examples of these.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当你意识到这种行为时，几乎总是你想要的。然而，这有一个奇怪的副作用。在`System.Object`上声明的`GetType()`方法是不可变的，并且关于装箱何时发生的复杂规则意味着，如果你对一个值类型值调用`GetType()`，它总是需要先装箱。通常，这有点低效，但不会引起任何混淆。对于可空值类型，它将导致`NullReferenceException`或返回基础的非可空值类型。下面的列表显示了这些示例。
- en: Listing 2.10\. Calling GetType on nullable values leads to surprising results
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.10\. 在可空值上调用 GetType 导致令人惊讶的结果
- en: '[PRE37]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Would throw NullReferenceException**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 会抛出 NullReferenceException**'
- en: '***2* Prints System.Int32, the same as if you’d used typeof(int)**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 System.Int32，与使用 typeof(int) 相同**'
- en: You’ve seen framework support and CLR support, but the C# language goes even
    further to make nullable value types easier to work with.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了框架支持和 CLR 支持，但 C# 语言更进一步，使可空值类型更容易使用。
- en: 2.2.3\. Language support
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 语言支持
- en: 'It would’ve been possible for C# 2 to have shipped with the compiler knowing
    only about nullable value types when enforcing the `struct` type constraint. It
    would’ve been awful, but it’s useful to consider the absolute minimum support
    required in order to appreciate all the features that have been added to make
    nullable value types fit into the language more idiomatically. Let’s start with
    the simplest part: simplifying nullable value type names.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 本来可以在强制`struct`类型约束时只让编译器知道可空值类型。那会很糟糕，但考虑为了使可空值类型更符合语言习惯而添加的所有功能，了解所需的最小支持是很有用的。让我们从最简单的一部分开始：简化可空值类型名称。
- en: The ? type suffix
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '? 类型后缀'
- en: 'If you add a `?` to the end of the name of a non-nullable value type, that’s
    precisely equivalent to using `Nullable<T>` for the same type. It works for the
    keyword shortcuts for the simple types (`int`, `double`, and so forth) as well
    as full type names. For example, these four declarations are precisely equivalent:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`?`添加到非可空值类型的名称末尾，这正好等同于为同一类型使用`Nullable<T>`。它适用于简单类型的关键字简写（如`int`、`double`等）以及完整的类型名称。例如，这四个声明是精确等价的：
- en: '`Nullable<int> x;`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<int> x;`'
- en: '`Nullable<Int32> x;`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<Int32> x;`'
- en: '`int? x;`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int? x;`'
- en: '`Int32? x;`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int32? x;`'
- en: You can mix and match them however you like. The generated IL won’t change at
    all. In practice, I end up using the `?` suffix everywhere, but other teams may
    have different conventions. For clarity, I’ve used `Nullable<T>` within the remainder
    of the text here, because the `?` can become confusing when used in prose, but
    in code that’s rarely an issue.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意混合使用它们。生成的 IL 不会改变。在实践中，我最终在所有地方都使用`?`后缀，但其他团队可能有不同的约定。为了清晰起见，我在本节的其余部分使用了`Nullable<T>`，因为当在散文中使用时，`?`可能会造成混淆，但在代码中这很少是问题。
- en: That’s the simplest language enhancement, but the theme of allowing you to write
    concise code continues through the rest of this section. The `?` suffix is about
    expressing a type easily; the next feature focuses on expressing a value easily.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的语言增强，但允许你编写简洁代码的主题贯穿本节的其余部分。`?`后缀是关于轻松表达类型；下一个特性专注于轻松表达值。
- en: The null literal
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 空字面量
- en: 'In C# 1, the expression `null` always referred to a null reference. In C# 2,
    that meaning is expanded to a null value: either a null reference or a value of
    a nullable value type where `HasValue` is `false`. This can be used for assignments,
    method arguments, comparisons—any manner of places. It’s important to understand
    that when it’s used for a nullable value type, it really does represent the value
    of that type where `HasValue` is `false` rather than being a null reference; if
    you try to work null references into your mental model of nullable value types,
    it’ll get confusing quickly. The following two lines are equivalent:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 1 中，表达式 `null` 总是指向一个空引用。在 C# 2 中，这个含义扩展到了空值：要么是一个空引用，要么是一个 `HasValue`
    为 `false` 的可空值类型的值。这可以用于赋值、方法参数、比较——任何方式。重要的是要理解，当它用于可空值类型时，它实际上代表的是该类型在 `HasValue`
    为 `false` 时的值，而不是一个空引用；如果你试图将空引用融入到你对可空值类型的心理模型中，它很快就会变得混乱。以下两行是等价的：
- en: '[PRE38]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'I typically prefer to use the null literal over explicitly calling the parameterless
    constructor (I’d write the second of the preceding lines rather than the first),
    but when it comes to comparisons, I’m ambivalent about the two options. For example,
    these two lines are equivalent:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常更喜欢使用空字面量而不是显式调用无参数构造函数（我宁愿写前面几行中的第二行而不是第一行），但在比较方面，我对这两种选择持中立态度。例如，这两行是等价的：
- en: '[PRE39]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I suspect I’m not even consistent about which I use. I’m not advocating for
    inconsistency, but this is an area where it doesn’t hurt very much. You can always
    change your mind later with no compatibility concerns.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑我甚至没有关于使用哪种方法的连贯性。我并不提倡不一致性，但这是一个不会造成很大伤害的领域。你总是可以在以后改变主意，而不用担心兼容性问题。
- en: Conversions
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换
- en: 'You’ve already seen that `Nullable<T>` provides an implicit conversion from
    `T` to `Nullable<T>` and an explicit conversion from `Nullable<T>` to `T`. The
    language takes that set of conversions further by allowing certain conversions
    to chain together. Where there are two non-nullable value types `S` and `T` and
    there’s a conversion from `S` to `T` (for example, the conversion from `int` to
    `decimal`), the following conversions are also available:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到 `Nullable<T>` 提供了从 `T` 到 `Nullable<T>` 的隐式转换和从 `Nullable<T>` 到 `T` 的显式转换。语言通过允许某些转换链式连接来进一步扩展这一组转换。当有两个非可空值类型
    `S` 和 `T` 并且存在从 `S` 到 `T` 的转换（例如，从 `int` 到 `decimal` 的转换）时，以下转换也是可用的：
- en: '`Nullable<S>` to `Nullable<T>` (implicit or explicit, depending on the original
    conversion)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<S>` 到 `Nullable<T>`（隐式或显式，取决于原始转换）'
- en: '`S` to `Nullable<T>` (implicit or explicit, depending on the original conversion)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S` 到 `Nullable<T>`（隐式或显式，取决于原始转换）'
- en: '`Nullable<S>` to `T` (always explicit)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<S>` 到 `T`（总是显式）'
- en: These work in a reasonably obvious way by propagating null values and using
    the `S` to `T` conversion as required. This process of extending an operation
    to propagate nulls appropriately is called *lifting*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作通过传播空值并按需使用 `S` 到 `T` 的转换以合理明显的方式工作。将操作扩展到适当地传播空值的过程称为*提升*。
- en: 'One point to note: it’s possible to explicitly provide conversions to both
    nullable and non-nullable types. LINQ to XML uses this to great effect. For example,
    there are explicit conversions from `XElement` to both `int` and `Nullable<int>`.
    Many operations in LINQ to XML will return a null reference if you ask them to
    find an element that doesn’t exist, and the conversion to `Nullable<int>` converts
    a null reference to a null value and propagates the nullity without throwing an
    exception. If you try to convert a null `XElement` reference to the non-nullable
    `int` type, however, an exception will be thrown. The existence of both conversions
    makes it easy to handle optional and required elements safely.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是：可以显式提供到可空和非可空类型的转换。LINQ to XML 就利用了这一点。例如，存在从 `XElement` 到 `int` 和
    `Nullable<int>` 的显式转换。如果你要求 LINQ to XML 查找一个不存在的元素，许多操作会返回一个空引用，并且将空引用转换为空值并传播空性而不抛出异常。然而，如果你尝试将空
    `XElement` 引用转换为非可空的 `int` 类型，则会抛出异常。存在这两种转换使得安全地处理可选和必需元素变得容易。
- en: Conversions are one form of operator that can be built into C# or user-defined.
    Other operators defined on non-nullable types receive a similar sort of treatment
    in their nullable counterparts.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 转换是一种可以构建到 C# 或用户定义的运算符形式。在非可空类型上定义的其他运算符在其可空对应物中也会得到类似的处理。
- en: Lifted operators
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提升运算符
- en: 'C# allows the following operators to be overloaded:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: C# 允许以下运算符被重载：
- en: 'Unary: `+ ++` `-` `-- ! ~ true false`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元运算符：`+ ++` `-` `-- ! ~ true false`
- en: Binary:^([[5](kindle_split_017_split_000.html#ch02fn5)]) `+ - * / % & | ^ <<
    >>`
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制操作符：`+ - * / % & | ^ << >>`
- en: ⁵
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: The equality and relational operators are also binary operators, but they behave
    slightly differently from the others, hence their separation in this list.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等价性和关系运算符也是二元运算符，但它们的行为与其他运算符略有不同，因此它们被单独列出。
- en: 'Equality: `== !=`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等价性：`== !=`
- en: 'Relational: `< > <= >=`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算：`< > <= >=`
- en: 'When these operators are overloaded for a non-nullable value type `T`, the
    `Nullable<T>` type has the same operators with slightly different operand and
    result types. These are called *lifted operators* whether they’re predefined operators,
    such as addition on numeric types, or user-defined operators, such as adding a
    `TimeSpan` to a `DateTime`. A few restrictions apply:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些运算符用于非可空值类型 `T` 时，`Nullable<T>` 类型具有相同的运算符，但操作数和结果类型略有不同。这些被称为 *提升运算符*，无论它们是预定义运算符，如数值类型上的加法，还是用户定义运算符，如将
    `TimeSpan` 添加到 `DateTime`。以下是一些限制条件：
- en: The `true` and `false` operators are never lifted. They’re incredibly rare in
    the first place, though, so this is no great loss.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true` 和 `false` 运算符永远不会提升。它们最初就非常罕见，所以这不是什么大损失。'
- en: Only operators with non-nullable value types for the operands are lifted.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有操作数类型为非可空值类型的运算符才会提升。
- en: For the unary and binary operators (other than equality and relational operators),
    the return type of the original operator has to be a non-nullable value type.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一元和二元运算符（除了等价性和关系运算符），原始运算符的返回类型必须是非可空值类型。
- en: For the equality and relational operators, the return type of the original operator
    has to be `bool`.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于等价性和关系运算符，原始运算符的返回类型必须是 `bool`。
- en: The `&` and `|` operators on `Nullable<bool>` have separately defined behaviors,
    which we’ll consider presently.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable<bool>` 上的 `&` 和 `|` 运算符有分别定义的行为，我们将在下面讨论。'
- en: For all the operators, the operand types become their nullable equivalents.
    For the unary and binary operators, the return type also becomes nullable, and
    a null value is returned if any of the operands is a null value. The equality
    and relational operators keep their non-nullable Boolean return types. For equality,
    two null values are considered equal, and a null value and any non-null value
    are considered different. The relational operators always return `false` if either
    operand is a null value. When neither of the operands is a null value, the operator
    of the non-nullable type is invoked in the obvious way.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有运算符，操作数类型变为它们的 nullable 等价类型。对于一元和二元运算符，返回类型也变为 nullable，如果任何操作数是 null 值，则返回
    null 值。等价性和关系运算符保持它们的非 nullable 布尔返回类型。对于等价性，两个 null 值被认为是相等的，null 值和任何非 null
    值被认为是不同的。关系运算符在任一操作数是 null 值时总是返回 `false`。当两个操作数都不是 null 值时，调用非 nullable 类型的运算符以明显的方式。
- en: All these rules sound more complicated than they are; for the most part, everything
    works as you probably expect it to. It’s easiest to see what happens with a few
    examples, and because `int` has so many predefined operators (and integers can
    be so easily expressed), it’s the natural demonstration type. [Table 2.1](kindle_split_017_split_000.html#ch02table01)
    shows a number of expressions, the lifted operator signature, and the result.
    It’s assumed that there are variables `four`, `five`, and `nullInt`, each with
    type `Nullable<int>` and with the obvious values.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些规则听起来比实际复杂；大部分情况下，一切都会按照你预期的进行。通过几个例子最容易看出会发生什么，而由于 `int` 有许多预定义的运算符（并且整数可以很容易地表示），它是一个自然的演示类型。[表
    2.1](kindle_split_017_split_000.html#ch02table01) 显示了多个表达式、提升运算符签名和结果。假设存在变量 `four`、`five`
    和 `nullInt`，每个变量类型为 `Nullable<int>`，并且具有明显的值。
- en: Table 2.1\. Examples of lifted operators applied to nullable integers
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.1\. 可 nullable 整数应用提升运算符的示例
- en: '| Expression | Lifted operator | Result |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 提升运算符 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| -nullInt | int? -(int? x) | null |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| -nullInt | int? -(int? x) | null |'
- en: '| -five | int? -(int? x) | -5 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| -five | int? -(int? x) | -5 |'
- en: '| five + nullInt | int? +(int? x, int? y) | null |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| five + nullInt | int? +(int? x, int? y) | null |'
- en: '| five + five | int? +(int? x, int? y) | 10 |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| five + five | int? +(int? x, int? y) | 10 |'
- en: '| four & nullInt | int? &(int? x, int? y) | null |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| four & nullInt | int? &(int? x, int? y) | null |'
- en: '| four & five | int? &(int? x, int? y) | 4 |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| four & five | int? &(int? x, int? y) | 4 |'
- en: '| nullInt == nullInt | bool ==(int? x, int? y) | true |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| nullInt == nullInt | bool ==(int? x, int? y) | true |'
- en: '| five == five | bool ==(int? x, int? y) | true |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| five == five | bool ==(int? x, int? y) | true |'
- en: '| five == nullInt | bool ==(int? x, int? y) | false |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| five == nullInt | bool ==(int? x, int? y) | false |'
- en: '| five == four | bool ==(int? x, int? y) | false |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| five == four | bool ==(int? x, int? y) | false |'
- en: '| four < five | bool <(int? x, int? y) | true |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| four < five | bool <(int? x, int? y) | true |'
- en: '| nullInt < five | bool <(int? x, int? y) | false |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| nullInt < five | bool <(int? x, int? y) | false |'
- en: '| five < nullInt | bool <(int? x, int? y) | false |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| five < nullInt | bool <(int? x, int? y) | false |'
- en: '| nullInt < nullInt | bool <(int? x, int? y) | false |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| nullInt < nullInt | bool <(int? x, int? y) | false |'
- en: '| nullInt <= nullInt | bool <=(int? x, int? y) | false |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| nullInt <= nullInt | bool <=(int? x, int? y) | false |'
- en: 'Possibly the most surprising line of the table is the last one: that a null
    value isn’t deemed less than or equal to another null value even though they are
    deemed to be equal to each other (as per the seventh row)! This is very odd, but
    it’s unlikely to cause problems in real life, in my experience. In the list of
    restrictions regarding operator lifting, I mentioned that `Nullable<bool>` works
    slightly differently from the other types.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中最令人惊讶的一行可能是最后一行：即使两个空值被认为彼此相等（如第七行所示），它们也不被认为小于或等于彼此！这非常奇怪，但根据我的经验，这不太可能在现实生活中引起问题。在关于运算符提升的限制列表中，我提到`Nullable<bool>`与其他类型的工作略有不同。
- en: Nullable logic
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可空逻辑
- en: Truth tables are often used to demonstrate Boolean logic with all possible input
    combinations and the result. Although the same approach can be used for `Nullable<Boolean>`
    logic, we have three values to consider (`true`, `false`, and `null`) for each
    input instead of just `true` and `false`. There are no conditional logical operators
    (the short-circuiting `&&` and `||` operators) defined for `Nullable<bool>`, which
    makes life simpler.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 真值表通常用于演示所有可能的输入组合和结果的布尔逻辑。尽管可以使用相同的方法来处理`Nullable<Boolean>`逻辑，但我们对于每个输入需要考虑三个值（`true`、`false`和`null`），而不是仅仅`true`和`false`。没有为`Nullable<bool>`定义条件逻辑运算符（短路运算符`&&`和`||`），这使得生活更加简单。
- en: Only the logical AND and inclusive OR operators (`&` and `|`, respectively)
    have special behavior. The other operators—unary logical negation (`!`) and exclusive
    OR (`^`)—follow the same rules as other lifted operators. For the sake of completeness,
    [table 2.2](kindle_split_017_split_000.html#ch02table02) gives the truth table
    for all four valid `Nullable<bool>` logical operators. I’ve highlighted the results
    that would be different if the extra rules didn’t exist for `Nullable<bool>`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 只有逻辑与和包含或运算符（分别用`&`和`|`表示）具有特殊行为。其他运算符——一元逻辑否定（`!`）和异或（`^`）——遵循其他提升运算符的相同规则。为了完整性，[表
    2.2](kindle_split_017_split_000.html#ch02table02) 给出了所有四个有效`Nullable<bool>`逻辑运算符的真值表。我突出显示了如果不存在针对`Nullable<bool>`的特殊规则，结果将会不同的结果。
- en: Table 2.2\. Truth table for `Nullable<bool>` operators
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.2\. 可空布尔运算符的真值表
- en: '| x | y | x & y | x &#124; y | x ^ y | !x |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| x | y | x & y | x &#124; y | x ^ y | !x |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| true true true false false false null null null | true false null true false
    null true false null | true false null false false **false** null **false** null
    | true true **true** true false null **true** null null | false true null true
    false null null null null | false false false true true true null null null |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| true true true false false false null null null | true false null true false
    null true false null | true false null false false **false** null **false** null
    | true true **true** true false null **true** null null | false true null true
    false null null null null | false false false true true true null null null |'
- en: If you find reasoning about rules easier to understand than looking up values
    in tables, the idea is that a null `bool?` value is in some senses a maybe. If
    you imagine that each null entry in the input side of the table is a variable
    instead, you’ll always get a null value on the output side of the table if the
    result depends on the value of that variable. For instance, looking at the third
    line of the table, the expression `true & y` will be true only if `y` is true,
    but the expression `true | y` will always be true whatever the value of `y` is,
    so the nullable results are `null` and `true`, respectively.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现理解规则比在表中查找值更容易，那么一个空`bool?`值在某种程度上是一个可能值。如果你想象表输入侧的每个空值都是一个变量，那么如果结果取决于该变量的值，你将在表的输出侧始终得到一个空值。例如，查看表的第三行，表达式`true
    & y`只有在`y`为`true`时才为真，但表达式`true | y`无论`y`的值如何都始终为真，因此可空结果分别是`null`和`true`。
- en: 'When considering the lifted operators and particularly how nullable logic works,
    the language designers had two slightly contradictory sets of existing behavior:
    C# 1 null references and SQL NULL values. In many cases, these don’t conflict
    at all; C# 1 had no concept of applying logical operators to null references,
    so there was no problem in using the SQL-like results given earlier. The definitions
    you’ve seen may surprise some SQL developers, though, when it comes to comparisons.
    In standard SQL, the result of comparing two values (in terms of equality or greater
    than/less than) is always unknown if either value is NULL. The result in C# 2
    is never null, and two null values are considered to be equal to each other.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑提升运算符以及特别是可空逻辑如何工作时，语言设计者面临两组略微矛盾的行为：C# 1的null引用和SQL NULL值。在许多情况下，它们根本不冲突；C#
    1没有将逻辑运算符应用于null引用的概念，因此使用前面给出的类似SQL的结果没有问题。然而，当涉及到比较时，你看到的定义可能会让一些SQL开发者感到惊讶。在标准SQL中，如果两个值（就相等或大于/小于而言）中的任何一个值为NULL，比较的结果总是未知。在C#
    2中，结果永远不会是null，并且两个null值被认为是彼此相等。
- en: '|  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Results of lifted operators are specific to C#**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**提升运算符的结果是C#特有的**'
- en: The lifted operators and conversions, along with the `Nullable<bool>` logic
    described in this section, are all provided by the C# compiler and not by the
    CLR or the framework itself. If you use ildasm on code that evaluates any of these
    nullable operators, you’ll find that the compiler has created all the appropriate
    IL to test for null values and dealt with them accordingly.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 提升运算符和转换，以及本节中描述的`Nullable<bool>`逻辑，都是由C#编译器提供的，而不是由CLR或框架本身提供的。如果你在评估这些可空运算符的代码上使用ildasm，你会发现编译器已经创建了所有适当的IL来测试null值并相应地处理它们。
- en: Different languages can behave differently on these matters, and this is definitely
    something to look out for if you need to port code between different .NET-based
    languages. For example, VB treats lifted operators far more like SQL, so the result
    of `x < y` is `Nothing` if `x` or `y` is `Nothing`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言在这些方面可能会有不同的行为，如果你需要在不同的.NET语言之间移植代码，这绝对是一件需要注意的事情。例如，VB将提升运算符处理得远比SQL更像，所以如果`x`或`y`是`Nothing`，则`x
    < y`的结果是`Nothing`。
- en: '|  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Another familiar operator is now available with nullable value types, and it
    behaves as you’d probably expect it to if you consider your existing knowledge
    of null references and just tweak it to be in terms of null values.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在另一个熟悉的运算符也适用于可空值类型，并且如果考虑你对null引用的现有知识并进行适当的调整，它的行为可能正如你所预期的那样。
- en: The as operator and nullable value types
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`as`运算符和可空值类型'
- en: 'Prior to C# 2, the `as` operator was available only for reference types. As
    of C# 2, it can now be applied to nullable value types as well. The result is
    a value of that nullable type: the `null` value if the original reference was
    the wrong type or null or a meaningful value otherwise. Here’s a short example:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 2之前，`as`运算符仅适用于引用类型。从C# 2开始，它现在也可以应用于可空值类型。结果是该可空类型的值：如果原始引用是错误类型或null，则为null值；否则为有意义值。以下是一个简短的例子：
- en: '[PRE40]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Prints 5**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印5**'
- en: '***2* Prints null**'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印null**'
- en: This allows you to safely convert from an arbitrary reference to a value in
    a single step, although you’d normally check whether the result is null afterward.
    In C# 1, you’d have had to use the `is` operator followed by a cast, which is
    inelegant; it’s essentially asking the CLR to perform the same type check twice.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你安全地将任意引用转换为值，尽管你通常会在之后检查结果是否为null。在C# 1中，你将不得不使用`is`运算符然后进行转换，这并不优雅；这本质上是在要求CLR执行相同的类型检查两次。
- en: '|  |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `as` operator with nullable types is surprisingly slow. In most code,
    this is unlikely to matter (it’s not going to be slow compared with any I/O, for
    example), but it’s slower than `is` and then a cast in all the framework and compiler
    combinations I’ve tried.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`as`运算符与可空类型相比非常慢。在大多数代码中，这不太可能成为问题（与任何I/O相比都不会慢），但它比`is`运算符然后进行转换要慢，我在尝试的所有框架和编译器组合中都是这样。
- en: '|  |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: C# 7 has an even better solution for most cases where I’ve used the `as` operator
    with nullable value types using pattern matching (described in [chapter 12](kindle_split_029_split_000.html#ch12)).
    If your intended result type really is a `Nullable<T>`, though, the `as` operator
    is handy. Finally, C# 2 introduced an entirely new operator specifically for handling
    null values elegantly.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 为大多数我使用 `as` 运算符与可空值类型结合模式匹配（在第 12 章中描述）的情况提供了一个更好的解决方案。如果你的预期结果类型确实是 `Nullable<T>`，那么
    `as` 运算符很方便。最后，C# 2 引入了一个全新的运算符，专门用于优雅地处理空值。
- en: The null-coalescing ?? operator
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 空合并 ?? 运算符
- en: It’s reasonably common to want to use nullable value types—or indeed, reference
    types—and provide a sort of default value if a particular expression evaluates
    to null. C# 2 introduced the `??` operator, also known as the *null-coalescing
    operator*, for precisely this purpose.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使用可空值类型——或者实际上，引用类型——并在特定表达式评估为空时提供一个默认值的情况相当常见。C# 2 引入了 `??` 运算符，也称为 *空合并运算符*，正是为了这个目的。
- en: '`??` is a binary operator that evaluates an expression of `first ?? second`
    by going through the following steps (roughly speaking):'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`??` 是一个二元运算符，通过以下步骤（大致来说）评估 `first ?? second` 的表达式：'
- en: Evaluate `first`.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估 `first`。
- en: If the result is non-null, that’s the result of the whole expression.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果是非空的，那么这就是整个表达式的结果。
- en: Otherwise, evaluate `second`, and use that as the result of the whole expression.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，评估 `second`，并使用它作为整个表达式的结果。
- en: I say roughly speaking because the formal rules in the specification have to
    deal with situations involving conversions between the types of `first` and `second`.
    These aren’t important in most uses of the operator, and I don’t intend to go
    through them. They’re easy to find in the specification if you need them.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我说大致来说，因为规范中的正式规则必须处理涉及 `first` 和 `second` 类型之间转换的情况。在大多数使用情况下，这些并不重要，我也不打算详细说明。如果你需要，它们在规范中很容易找到。
- en: 'One aspect of those rules is worth highlighting. If the type of the first operand
    is a nullable value type and the type of the second operand is the underlying
    type of the first operand, the type of the whole expression is that (non-nullable)
    underlying type. For example, this code is perfectly valid:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则中的一个方面值得强调。如果第一个操作数的类型是可空值类型，而第二个操作数的类型是第一个操作数的底层类型，则整个表达式的类型就是那个（非可空）底层类型。例如，以下代码是完全有效的：
- en: '[PRE41]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that you’re assigning directly to `c` even though its type is the non-nullable
    `int` type. You can do this only because `b` is non-nullable, so you know that
    the overall result can’t be null. The `??` operator composes well with itself;
    an expression such as `x ?? y ?? z` will evaluate `y` only if `x` evaluates to
    null and will evaluate `z` only if both `x` and `y` evaluate to null.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `c` 的类型是非可空的 `int` 类型，你仍然可以直接将其赋值。你之所以能这样做，仅仅是因为 `b` 是非可空的，因此你知道整体结果不可能是空的。`??`
    运算符可以很好地与自身组合；例如，表达式 `x ?? y ?? z` 只有在 `x` 评估为空时才会评估 `y`，只有在 `x` 和 `y` 都评估为空时才会评估
    `z`。
- en: Null values become even easier to work with—and more likely as expression results—in
    C# 6 with the `?.` null conditional operator, as you’ll see in [section 10.3](kindle_split_026_split_000.html#ch10lev1sec3).
    Combining `?.` and `??` can be a powerful way of handling possible nulls at various
    points of execution. Like all techniques, this is best used in moderation. If
    you find your code’s readability going downhill, you might want to consider using
    multiple statements to avoid trying to do too much in one go.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 中，使用 `?.` 空条件运算符使处理空值变得更加容易——并且作为表达式结果的可能性更大，正如你将在 [第 10.3 节](kindle_split_026_split_000.html#ch10lev1sec3)
    中看到的。结合 `?.` 和 `??` 可以是处理执行过程中各个点的可能空值的一种强大方式。像所有技术一样，最好适度使用。如果你发现代码的可读性在下降，你可能想要考虑使用多个语句来避免一次尝试做太多。
- en: That’s it for nullable value types in C# 2\. We’ve now covered the two most
    important features of C# 2, but we have a couple of fairly large features still
    to talk about, along with a raft of smaller ones. Next up is delegates.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 中关于可空值类型的讨论就到这里。我们已经涵盖了 C# 2 的两个最重要的特性，但还有一些相当大的特性以及一系列较小的特性尚未讨论。接下来是委托。
- en: 2.3\. Simplified delegate creation
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 简化的委托创建
- en: 'The basic purpose of delegates hasn’t changed since they were first introduced:
    to encapsulate a piece of code so that it can be passed around and executed as
    necessary in a type-safe fashion in terms of the return type and parameters. Back
    in the days of C# 1, that was almost always used for event handling or starting
    threads. This was mostly still the case when C# 2 was introduced in 2005\. It
    was only in 2008 that LINQ helped C# developers feel comfortable with the idea
    of passing a function around for all kinds of reasons.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 委托的基本目的自它们首次引入以来没有改变：封装一段代码，以便可以在类型安全的方式下传递并执行，这涉及到返回类型和参数。在 C# 1 的时代，这几乎总是用于事件处理或启动线程。当
    C# 2 在 2005 年引入时，情况仍然大致如此。直到 2008 年，LINQ 帮助 C# 开发者对传递函数的各种原因感到舒适。
- en: C# 2 brought three new ways of creating delegate instances as well as the ability
    to declare generic delegates, such as `EventHandler<TEventArgs>` and `Action<T>`.
    We’ll start with method group conversions.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 引入了创建委托实例的三种新方法，以及声明泛型委托的能力，例如 `EventHandler<TEventArgs>` 和 `Action<T>`。我们将从方法组转换开始。
- en: 2.3.1\. Method group conversions
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 方法组转换
- en: 'A *method group* refers to one or more methods with the same name. Every C#
    developer has been using them forever without necessarily thinking about it, because
    every method invocation uses one. For example, consider this trivial code:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法组* 指的是具有相同名称的一个或多个方法。每个 C# 开发者一直在使用它们，而无需刻意思考，因为每次方法调用都会使用到它们。例如，考虑以下简单的代码：'
- en: '[PRE42]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The expression `Console.WriteLine` is a method group. The compiler then looks
    at the arguments to work out which of the overloads within that method group should
    be invoked. Other than method invocations, C# 1 used method groups in *delegate
    creation expressions* as the only way the language provided to create a delegate
    instance. For example, say you have a method like this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `Console.WriteLine` 是一个方法组。编译器随后查看参数以确定应该调用该方法组中的哪个重载。除了方法调用之外，C# 1 使用方法组在
    *委托创建表达式* 中作为创建委托实例的唯一方式。例如，假设你有一个如下所示的方法：
- en: '[PRE43]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then you could create an `EventHandler`^([[6](kindle_split_017_split_000.html#ch02fn6)])
    instance like this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个 `EventHandler`^([[6](kindle_split_017_split_000.html#ch02fn6)]) 实例，如下所示：
- en: ⁶
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For reference, `EventHandler` has a signature of `public delegate void EventHandler(object
    sender, EventArgs e`).
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仅供参考，`EventHandler` 的签名是 `public delegate void EventHandler(object sender, EventArgs
    e)`。
- en: '[PRE44]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'C# 2 introduced *method group conversions* as a sort of shorthand: a method
    group is implicitly convertible to any delegate type with a signature that’s compatible
    with one of the overloads. You’ll explore the notion of compatibility further
    in [section 2.3.3](kindle_split_017_split_000.html#ch02lev2sec13), but for the
    moment you’ll look at methods that exactly match the signature of the delegate
    you’re trying to convert to.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 引入了 *方法组转换* 作为一种简写方式：方法组可以隐式转换为任何与其中某个重载兼容的委托类型。你将在 [2.3.3 节](kindle_split_017_split_000.html#ch02lev2sec13)
    中进一步探索兼容性的概念，但此时你将查看与你要转换到的委托签名完全匹配的方法。
- en: 'In the case of our preceding `EventHandler` code, C# 2 allows you to simplify
    the creation of the delegate to this:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面提到的 `EventHandler` 代码的情况下，C# 2 允许你将委托的创建简化为如下形式：
- en: '[PRE45]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This works for event subscription and removal, too:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于事件订阅和移除：
- en: '[PRE46]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The same code is generated as for the delegate creation expression, but it’s
    much more concise. These days, I rarely see delegate creation expressions in idiomatic
    code. Method group conversions save a few characters when creating a delegate
    instance, but anonymous methods achieve a lot more.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码与用于创建委托表达式的代码相同，但更加简洁。如今，我在惯用代码中很少看到委托创建表达式。方法组转换在创建委托实例时节省了一些字符，但匿名方法却能实现更多。
- en: 2.3.2\. Anonymous methods
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 匿名方法
- en: 'You might reasonably expect a lot of detail on anonymous methods here. I’m
    going to save most of that information for the successor of anonymous methods:
    lambda expressions. They were introduced in C# 3, and I expect that if they’d
    existed before anonymous methods, the latter would never have been introduced
    at all.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会合理地期待在这里看到很多关于匿名方法的细节。我将把大部分信息留到匿名方法的继承者：lambda 表达式。它们是在 C# 3 中引入的，我预计如果它们在匿名方法之前就存在，那么后者可能根本就不会被引入。
- en: 'Even so, their introduction in C# 2 made me think about delegates in a whole
    different way. Anonymous methods allow you to create a delegate instance without
    having a real method to refer to^([[7](kindle_split_017_split_000.html#ch02fn7)])
    just by writing some code inline wherever you want to create the instance. You
    just use the `delegate` keyword, optionally include some parameters, and then
    write some code in braces. For example, if you wanted an event handler that just
    logged to the console when it was fired, you could do that very simply:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，C# 2中的引入让我对委托有了全新的认识。匿名方法允许你通过在需要创建实例的任何地方编写一些代码来创建委托实例，而不需要一个真正的要引用的方法^([[7](kindle_split_017_split_000.html#ch02fn7)])。你只需使用`delegate`关键字，可选地包含一些参数，然后在花括号中编写一些代码。例如，如果你想要一个在触发时仅将日志记录到控制台的事件处理程序，你可以非常简单地做到这一点：
- en: ⁷
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In your source code, anyway. The method still exists in the IL.
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你的源代码中。该方法仍然存在于IL中。
- en: '[PRE47]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'That doesn’t call `Console.WriteLine` immediately; instead it creates a delegate
    that’ll call `Console.WriteLine` when it’s invoked. To see the type of the sender
    and event arguments, you need appropriate parameters:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会立即调用`Console.WriteLine`；相反，它创建了一个在调用时将调用`Console.WriteLine`的委托。要查看发送者和事件参数的类型，你需要适当的参数：
- en: '[PRE48]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The real power comes when you use an anonymous method as a *closure*. A closure
    is able to access all the variables that are in scope at the point of its declaration,
    even if those variables normally wouldn’t be available anymore when the delegate
    is executed. You’ll look at closures in a lot more detail (including how the compiler
    treats them) when you look at lambda expressions. For now, here’s a single brief
    example; it’s an `AddClickLogger` method that adds a `Click` handler to any control
    with a custom message that’s passed into `AddClickLogger`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用匿名方法作为*闭包*时，真正的力量才显现出来。闭包能够访问其声明点处所有作用域内的变量，即使这些变量在委托执行时通常不再可用。当你查看lambda表达式时，你将更详细地了解闭包（包括编译器如何处理它们）。现在，这里有一个简单的例子；这是一个`AddClickLogger`方法，它将一个带有自定义消息的`Click`处理程序添加到任何控件中：
- en: '[PRE49]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here the `message` variable is a parameter to the method, but it’s captured
    by the anonymous method. The `AddClickLogger` method doesn’t execute the event
    handler itself; it just adds it as a handler for the `Click` event. By the time
    the code in the anonymous method executes, `AddClickLogger` will have returned.
    How does the parameter still exist? In short, the compiler handles it all for
    you to avoid you having to write boring code. [Section 3.5.2](kindle_split_018_split_000.html#ch03lev2sec12)
    provides more details when you look at capturing variables in lambda expressions.
    There’s nothing special about `EventHandler` here; it’s just a well-known delegate
    type that’s been part of the framework forever. For the final part of our whirlwind
    tour of C# 2 delegate improvements, let’s come back to the idea of compatibility,
    which I mentioned when talking about method group conversions.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`message`变量是方法的参数，但它被匿名方法捕获。`AddClickLogger`方法本身并不执行事件处理程序；它只是将其添加为`Click`事件的处理器。当匿名方法中的代码执行时，`AddClickLogger`已经返回。参数是如何仍然存在的呢？简而言之，编译器为你处理所有这些，以避免你不得不编写无聊的代码。[第3.5.2节](kindle_split_018_split_000.html#ch03lev2sec12)提供了在查看lambda表达式中的变量捕获时的更多详细信息。这里关于`EventHandler`没有什么特别之处；它只是一个框架中一直存在的知名委托类型。对于C#
    2委托改进的最后一部分，让我们回到兼容性的想法，我在讨论方法组转换时提到了它。
- en: 2.3.3\. Delegate compatibility
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3. 委托兼容性
- en: 'In C# 1, you needed a method with a signature with exactly the same return
    type and parameter types (and `ref`/`out` modifiers) to create a delegate instance.
    For example, suppose you had this delegate declaration and method:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 1中，你需要一个具有完全相同返回类型和参数类型（以及`ref`/`out`修饰符）的方法签名来创建委托实例。例如，假设你有一个这样的委托声明和方法：
- en: '[PRE50]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now imagine you wanted to create an instance of `Printer` to effectively wrap
    the `PrintAnything` method. It feels like it should be okay; a `Printer` will
    always be given a `string` reference, and that’s convertible to an `object` reference
    via an identity conversion. C# 1 wouldn’t allow that, though, because the parameter
    types don’t match. C# 2 allows this for delegate creation expressions and for
    method group conversions:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你想要创建一个`Printer`实例来有效地包装`PrintAnything`方法。这似乎应该是可以的；`Printer`将始终被赋予一个`string`引用，并且可以通过身份转换转换为`object`引用。C#
    1不允许这样做，因为参数类型不匹配。C# 2允许在委托创建表达式和方法组转换中这样做：
- en: '[PRE51]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Additionally, you can create one delegate to wrap another one with a compatible
    signature. Suppose you had a second delegate type that coincidentally did match
    the `PrintAnything` method:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以创建一个委托来包装另一个具有兼容签名的委托。假设你有一个第二个委托类型，它偶然与`PrintAnything`方法匹配：
- en: '[PRE52]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you already have a `GeneralPrinter`, you can create a `Printer` from it:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了一个`GeneralPrinter`，你可以从它创建一个`Printer`：
- en: '[PRE53]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Any way you might create a GeneralPrinter delegate**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 你可能创建GeneralPrinter委托的任何方式'
- en: '***2* Constructs a Printer to wrap the GeneralPrinter**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 构建一个Printer来包装GeneralPrinter'
- en: 'The compiler lets you do that because it’s safe; any argument that can be passed
    to a `Printer` can safely be passed to a `GeneralPrinter`. The compiler is happy
    to do the same in the other direction for return types, as shown in the following
    example:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器允许你这样做，因为它很安全；任何可以传递给`Printer`的参数都可以安全地传递给`GeneralPrinter`。编译器也愿意在返回类型上以相同的方式做相同的事情，如下面的示例所示：
- en: '[PRE54]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Parameterless delegates returning values**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 无参数委托返回值'
- en: '***2* Any way you might create a StringProvider**'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 你可能创建StringProvider的任何方式'
- en: '***3* Creates an ObjectProvider to wrap the StringProvider**'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 创建一个ObjectProvider来包装StringProvider'
- en: Again, this is safe because any value that `StringProvider` can return would
    definitely be fine to return from an `ObjectProvider`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是安全的，因为`StringProvider`可以返回的任何值肯定适合从`ObjectProvider`返回。
- en: 'It doesn’t always work the way you might want it to, though. The compatibility
    between different parameter or return types has to be in terms of an *identity
    conversion* that doesn’t change the representation of the value at execution time.
    For example, this code doesn’t compile:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它并不总是按你希望的方式工作。不同参数或返回类型之间的兼容性必须是在执行时不会改变值表示的*恒等转换*。例如，以下代码无法编译：
- en: '[PRE55]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Delegates accepting 32- and 64-bit integers**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 接受32位和64位整数的委托'
- en: '***2* Any way you might create an Int64Printer**'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 你可能创建Int64Printer的任何方式'
- en: '***3* Error! Can’t wrap the Int64Printer in an Int32Printer**'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 错误！无法将Int64Printer包装在Int32Printer中'
- en: The two delegate signatures here aren’t compatible; although there’s an implicit
    conversion from `int` to `long`, it’s not an identity conversion. You might argue
    that the compiler could’ve silently created a method that performed the conversion
    for you, but it doesn’t do so. In a way, that’s helpful, because this behavior
    fits in with the *generic variance* feature you’ll see in [chapter 4](kindle_split_019_split_000.html#ch04).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个委托签名不兼容；尽管存在从`int`到`long`的隐式转换，但它不是一个恒等转换。你可能会争辩说编译器可以默默地创建一个为你执行转换的方法，但它并没有这样做。从某种意义上说，这是有帮助的，因为这种行为与你在第4章中将要看到的*泛型方差*功能相吻合。
- en: It’s important to understand that although this feature looks a bit like generic
    variance, they are different features. Aside from anything else, this wrapping
    really does create a new instance of the delegate instead of just treating the
    existing delegate as an instance of a different type. I’ll go into more detail
    when you look at the feature fully, but I wanted to highlight as early as possible
    that they’re not the same.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，尽管这个功能看起来有点像泛型方差，但它们是不同的功能。除此之外，这种包装实际上确实创建了一个新的委托实例，而不是仅仅将现有的委托视为不同类型的一个实例。当你全面查看这个功能时，我会详细介绍，但我希望尽可能早地强调，它们并不相同。
- en: 'That’s it for delegates in C# 2\. Method group conversions are still widely
    used, and often the compatibility aspect will be used without anyone even thinking
    about it. Anonymous methods aren’t seen much these days, because lambda expressions
    can do almost anything anonymous methods can, but I still look on them fondly
    as my first taste of the power of closures. Speaking of one feature that led to
    another, let’s look at the forerunner of C# 5’s asynchrony: iterator blocks.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C#中的委托就到这里。方法组转换仍然被广泛使用，并且通常兼容性方面会被使用，甚至没有人会去想它。如今匿名方法很少见，因为lambda表达式几乎可以做匿名方法能做的任何事情，但我仍然怀念它们，因为它们是我对闭包力量的第一次体验。说到一个功能导致另一个功能，让我们看看C#
    5异步的前身：迭代器块。
- en: 2.4\. Iterators
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 迭代器
- en: Relatively few interfaces have specific language support in C# 2\. `IDisposable`
    has support via the `using` statement, and the language makes guarantees about
    the interfaces that arrays implement, but apart from that, only the enumerable
    interfaces have direct support. `IEnumerable` has always had support for consumption
    in the form of the `foreach` statement, and C# 2 extended that to its new-to-.NET-2
    generic counterpart `IEnumerable<T>` in a reasonably obvious way.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 2中，相对较少的接口具有特定的语言支持。`IDisposable`通过`using`语句提供支持，语言对数组实现的接口做出保证，但除此之外，只有可枚举接口有直接支持。`IEnumerable`始终以`foreach`语句的形式提供消费支持，C#
    2以一种相当明显的方式将其扩展到.NET 2的新泛型对应物`IEnumerable<T>`。
- en: The enumerable interfaces represent sequences of items, and although consuming
    them is extremely common, it’s also entirely reasonable to want to *produce* a
    sequence. Implementing either the generic or nongeneric interfaces manually can
    be tedious and error prone, so C# 2 introduced a new feature called *iterators*
    to make it simpler.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 可枚举接口表示一系列项目，尽管消费它们非常常见，但想要*生成*一个序列也是完全合理的。手动实现泛型或非泛型接口可能会很繁琐且容易出错，因此C# 2引入了一个名为*迭代器*的新功能，以使其更简单。
- en: 2.4.1\. Introduction to iterators
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 迭代器简介
- en: 'An *iterator* is a method or property implemented with an *iterator block*,
    which is in turn just a block of code using the `yield return` or `yield break`
    statements. Iterator blocks can be used only to implement methods or properties
    with one of the following return types:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器*是通过*迭代器块*实现的，而迭代器块只是使用`yield return`或`yield break`语句的代码块。迭代器块只能用于实现具有以下返回类型的方法或属性：'
- en: '`IEnumerable`'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable`'
- en: '`IEnumerable<T>` (where `T` can be a type parameter or a regular type)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`（其中`T`可以是类型参数或常规类型）'
- en: '`IEnumerator`'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerator`'
- en: '`IEnumerator<T>` (where `T` can be a type parameter or a regular type)'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerator<T>`（其中`T`可以是类型参数或常规类型）'
- en: Each iterator has a *yield type* based on its return type. If the return type
    is one of the nongeneric interfaces, the yield type is `object`. Otherwise, it’s
    the type argument provided to the interface. For example, the yield type of a
    method returning `IEnumerator<string>` is `string`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 每个迭代器都有一个基于其返回类型的*yield类型*。如果返回类型是非泛型接口之一，则yield类型为`object`。否则，它是提供给接口的类型参数。例如，返回`IEnumerator<string>`的方法的yield类型是`string`。
- en: The `yield return` statements provide values for the returned sequence, and
    a `yield break` statement will terminate a sequence. Similar constructs, sometimes
    called *generators*, exist in some other languages, such as Python.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield return`语句为返回的序列提供值，而`yield break`语句将终止序列。在某些其他语言中，如Python，存在类似的构造，有时被称为*生成器*。'
- en: The following listing shows a simple iterator method that you can analyze further.
    I’ve highlighted the `yield return` statements in the method.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个简单的迭代器方法，您可以进一步分析。我在方法中突出显示了`yield return`语句。
- en: Listing 2.11\. A simple iterator yielding integers
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.11\. 一个简单的生成整数迭代器
- en: '[PRE56]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'With that method in place, you can call the method and iterate over the results
    with a regular `foreach` loop:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该方法后，您可以调用该方法，并使用常规的`foreach`循环遍历结果：
- en: '[PRE57]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'That loop will print the following output:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环将打印以下输出：
- en: '[PRE58]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: So far, this isn’t terribly exciting. You could change the method to create
    a `List<int>`, replace each `yield return` statement with a call to `Add()`, and
    then return the list at the end of the method. The loop output would be exactly
    the same, but it wouldn’t execute in the same way at all. The huge difference
    is that iterators are executed lazily.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这并不特别令人兴奋。你可以将方法更改为创建`List<int>`，将每个`yield return`语句替换为对`Add()`的调用，然后在方法末尾返回列表。循环输出将完全相同，但执行方式却完全不同。巨大的区别在于迭代器是懒执行的。
- en: 2.4.2\. Lazy execution
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 懒执行
- en: 'Lazy execution, or lazy evaluation, was invented as part of lambda calculus
    in the 1930s. The basic idea of it is simple: execute code only when you need
    the value that it’ll compute. There are uses of it well beyond iterators, but
    they’re all we need it for right now.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 懒执行，或称为懒评估，是在20世纪30年代作为lambda演算的一部分被发明的。其基本思想很简单：只有在需要计算出的值时才执行代码。它在迭代器之外也有很好的应用，但就目前而言，我们只需要用它来处理迭代器。
- en: To explain how the code executes, the following listing expands the `foreach`
    loop into mostly equivalent code that uses a `while` loop instead. I’ve still
    used the syntactic sugar of a `using` statement that will call `Dispose` automatically,
    just for simplicity.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释代码是如何执行的，以下列表将 `foreach` 循环扩展为大部分等效的代码，该代码使用 `while` 循环代替。为了简单起见，我仍然使用了
    `using` 语句的语法糖，它会自动调用 `Dispose`。
- en: Listing 2.12\. The expansion of a `foreach` loop
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.12\. `foreach` 循环的展开
- en: '[PRE59]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Calls the iterator method**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用迭代器方法**'
- en: '***2* Gets an IEnumerator<T> from an IEnumerable<T>**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 `IEnumerable<T>` 获取 `IEnumerator<T>**'
- en: '***3* Moves to the next value, if there is one**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果有，移动到下一个值**'
- en: '***4* Fetches the current value**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取当前值**'
- en: 'If you’ve never looked at the `IEnumerable`/`IEnumerator` pair of interfaces
    (and their generic equivalents) before, now is a good time to make sure you understand
    the difference between them. An `IEnumerable` is a sequence that can be iterated
    over, whereas an `IEnumerator` is like a cursor within a sequence. Multiple `IEnumerator`
    instances can probably iterate over the same `IEnumerable` without changing its
    state at all. Compare that with an `IEnumerator`, which naturally *does* have
    mutable state: each time you call `MoveNext()`, you’re asking it to move the cursor
    to the next element of the sequence it’s iterating over.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未看过 `IEnumerable`/`IEnumerator` 这对接口（以及它们的泛型等效物），现在是确保你理解它们之间差异的好时机。`IEnumerable`
    是一个可以迭代的序列，而 `IEnumerator` 则是序列中的一个游标。多个 `IEnumerator` 实例可以迭代同一个 `IEnumerable`，而不会改变其状态。将此与
    `IEnumerator` 进行比较，它自然地 *确实* 有可变状态：每次你调用 `MoveNext()`，你都是在要求它将其游标移动到正在迭代的序列的下一个元素。
- en: 'If that didn’t make much sense, you might want to think about an `IEnumerable`
    as a book and an `IEnumerator` as a bookmark. There can be multiple bookmarks
    within a book at any one time. Moving a bookmark to the next page doesn’t change
    the book or any of the other bookmarks, but it does change that bookmark’s state:
    its position within the book. The `IEnumerable.GetEnumerator()` method is a sort
    of bootstrapping: it asks the sequence to create an `IEnumerator` that’s set up
    to iterate over that sequence, just like putting a new bookmark at the start of
    a book.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这没有太多意义，你可能想要将 `IEnumerable` 视为一本书，将 `IEnumerator` 视为一个书签。在任何时候，一本书中可以有多个书签。将书签移动到下一页不会改变书或任何其他书签，但它确实会改变该书签的状态：它在书中的位置。`IEnumerable.GetEnumerator()`
    方法是一种启动机制：它要求序列创建一个 `IEnumerator`，该 `IEnumerator` 被设置为迭代该序列，就像在书的开始处放置一个新的书签一样。
- en: After you have an `IEnumerator`, you repeatedly call `MoveNext()`; if it returns
    `true`, that means you’ve moved to another value that you can access with the
    `Current` property. If `MoveNext()` returns `false`, you’ve reached the end of
    the sequence.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有了 `IEnumerator` 之后，你反复调用 `MoveNext()`；如果它返回 `true`，这意味着你已经移动到了另一个可以访问的值，你可以使用
    `Current` 属性来访问它。如果 `MoveNext()` 返回 `false`，你已到达序列的末尾。
- en: 'What does this have to do with lazy evaluation? Well, now that you know exactly
    what the code using the iterator will call, you can look at when the method body
    starts executing. Just as a reminder, here’s the method from [listing 2.11](kindle_split_017_split_000.html#ch02ex11):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这与延迟评估有什么关系？好吧，既然你现在确切地知道使用迭代器的代码会调用什么，你可以看看方法体何时开始执行。提醒一下，这是来自 [列表 2.11](kindle_split_017_split_000.html#ch02ex11)
    的方法：
- en: '[PRE60]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When `CreateSimpleIterator()` is called, none of the method body is executed.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `CreateSimpleIterator()` 时，方法体没有任何执行。
- en: If you put a breakpoint on the first line (`yield return 10`) and step through
    the code, you won’t hit the breakpoint when you call the method. You won’t hit
    the breakpoint when you call `GetEnumerator()`, either. The method body starts
    executing only when `MoveNext()` is called. But what happens then?
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将断点放在第一行 (`yield return 10`) 上并逐步执行代码，当你调用方法时，你不会遇到断点。当你调用 `GetEnumerator()`
    时，你也不会遇到断点。方法体只有在调用 `MoveNext()` 时才会开始执行。但那时会发生什么？
- en: 2.4.3\. Evaluation of yield statements
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3\. `yield` 语句的评估
- en: 'Even when the method starts executing, it goes only as far as it needs to.
    It stops executing when any of the following occurs:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 即使方法开始执行，它也只会执行到需要的地方。当以下任何一种情况发生时，它就会停止执行：
- en: An exception is thrown.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常。
- en: It reaches the end of the method.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它到达了方法的末尾。
- en: It reaches a `yield break` statement.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它到达了 `yield break` 语句。
- en: It has evaluated the operand to a `yield return` statement, so it is ready to
    yield the value.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它已经评估了操作数到 `yield return` 语句，因此它准备好产生该值。
- en: If an exception is thrown, that exception is propagated as normal. If the end
    of the method is reached or it hits a `yield break` statement, the `MoveNext()`
    method returns `false` to indicate that you’ve reached the end of the sequence.
    If you reach a yield return statement, the `Current` property is set to the value
    you’re yielding, and `MoveNext()` returns `true`.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出异常，该异常会像正常一样传播。如果达到方法末尾或遇到`yield break`语句，`MoveNext()`方法返回`false`以指示您已达到序列的末尾。如果您遇到`yield
    return`语句，`Current`属性设置为要产生的值，并且`MoveNext()`返回`true`。
- en: '|  |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To clarify the preceding paragraph, the exception is propagated as normal, assuming
    you’re already executing the iterator code. Don’t forget that until the calling
    code iterates over the returned sequence, you won’t start executing the iterator
    code. It’s the `MoveNext()` call that will throw the exception, not the initial
    call to the iterator method.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明前面的段落，异常会像正常一样传播，假设您已经在执行迭代器代码。别忘了，直到调用代码迭代返回的序列，您才不会开始执行迭代器代码。是`MoveNext()`调用会抛出异常，而不是迭代器方法的初始调用。
- en: '|  |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In our simple example, as soon as `MoveNext()` starts iterating, it reaches
    the `yield return 10;` statement, sets `Current` to 10, and then returns `true`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，一旦`MoveNext()`开始迭代，它就会到达`yield return 10;`语句，将`Current`设置为10，然后返回`true`。
- en: That all sounds simple for the first call to `MoveNext()`, but what about subsequent
    ones? You can’t start again from scratch; otherwise, the sequence would be 10
    repeated an infinite number of times. Instead, when `MoveNext()` returns, it’s
    as if the method is paused. The generated code keeps track of the point you’ve
    reached in the method along with any other state, such as the local variable `i`
    in your loop. When `MoveNext()` is called again, execution picks up from the point
    you’ve reached and keeps going. That’s what makes it lazy, and that’s the part
    that’s difficult to get right when you’re writing the code yourself.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`MoveNext()`的第一个调用来说，这一切听起来都很简单，但随后的调用呢？您不能从头开始；否则，序列将是无限次重复的10。相反，当`MoveNext()`返回时，就像方法被暂停了一样。生成的代码会跟踪您在方法中达到的点以及任何其他状态，例如循环中的局部变量`i`。当再次调用`MoveNext()`时，执行将从您达到的点继续进行。这就是它懒惰的原因，这也是您自己编写代码时难以做对的部分。
- en: 2.4.4\. The importance of being lazy
  id: totrans-530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.4. 懒惰的重要性
- en: To give you an idea of why this is important, let’s write some code to print
    out the Fibonacci sequence until you hit the first value over 1,000\. The following
    listing shows a `Fibonacci()` method that returns an infinite sequence and then
    a method that iterates over that sequence until it hits a limit.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解为什么这很重要，让我们编写一些代码来打印出斐波那契数列，直到您遇到第一个大于1,000的值。下面的列表显示了返回无限序列的`Fibonacci()`方法和一个迭代该序列直到达到限制的方法。
- en: Listing 2.13\. Iterating over the Fibonacci sequence
  id: totrans-532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.13. 迭代斐波那契数列
- en: '[PRE61]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Infinite loop? Only if you keep asking for more**'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无限循环？只有当你不断请求更多时**'
- en: '***2* Yields the current Fibonacci value**'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回当前的斐波那契值**'
- en: '***3* Calls the method to obtain the sequence**'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用方法以获取序列**'
- en: '***4* Prints the current value**'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印当前值**'
- en: '***5* Break condition**'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 跳出条件**'
- en: How would you do something like this without iterators? You could change the
    method to create a `List<int>` and populate it until you hit the limit. But that
    list could be big if the limit is large, and why should the method that knows
    the details of the Fibonacci sequence also know how you want to stop? Suppose
    you sometimes want to stop based on how long you’ve been printing out values,
    sometimes based on how many values you’ve printed, and sometimes based on the
    current value. You don’t want to implement the method three times.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有迭代器，您会如何做类似的事情？您可以将方法更改为创建一个`List<int>`并填充它，直到达到限制。但如果限制很大，这个列表可能会很大，而且为什么知道斐波那契数列细节的方法也应该知道您想要如何停止？假设您有时想根据打印值的时长停止，有时根据打印的值的数量停止，有时根据当前值停止。您不希望实现这个方法三次。
- en: You could avoid creating the list by printing the value in the loop, but that
    makes your `Fibonacci()` method even more tightly coupled to the one thing you
    happen to want to do with the values right now. What if you wanted to add the
    values together instead of printing them? Would you write a second method? It’s
    all a ghastly violation of the separation of concerns.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在循环中打印值来避免创建列表，但这会使你的`Fibonacci()`方法与当前想要使用值的那个东西耦合得更紧密。如果你想要将值相加而不是打印它们呢？你会写第二个方法吗？这完全是违反关注点分离的可怕行为。
- en: 'The iterator solution is exactly what you want: a representation of an infinite
    sequence, and that’s all. The calling code can iterate over it as far as it wants^([[8](kindle_split_017_split_000.html#ch02fn8)])
    and use the values however it wants.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器解决方案正是你想要的：一个无限序列的表示，仅此而已。调用代码可以迭代它，直到它想要的程度，并按需使用这些值。
- en: ⁸
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At least until it overflows the range of `int`. At that point, it might throw
    an exception or underflow to a large negative number depending on whether the
    code is in a checked context.
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 至少直到它超出`int`的范围。在那个点上，它可能会抛出一个异常，或者根据代码是否处于检查上下文中，可能会下溢到一个很大的负数。
- en: Implementing the Fibonacci sequence manually wouldn’t be terribly hard. There’s
    little state to maintain between calls, and the flow control is simple. (The fact
    that there’s only one `yield return` statement helps there.) But as soon as the
    code gets more complicated, you don’t want to be writing this code yourself. The
    compiler not only generates code that keeps track of where the code has reached,
    but it’s also smart about how to handle `finally` blocks, which aren’t quite as
    simple as you might think.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 手动实现斐波那契序列并不难。调用之间几乎没有状态需要维护，流程控制也很简单。（只有一个`yield return`语句的事实对此有所帮助。）但是，一旦代码变得更加复杂，你就不想自己编写这段代码。编译器不仅生成跟踪代码到达位置的代码，而且它还非常聪明地处理`finally`块，而这些块并不像你可能想象的那样简单。
- en: 2.4.5\. Evaluation of finally blocks
  id: totrans-546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.5. finally块的评估
- en: It may seem odd that I’d focus on `finally` blocks out of all the syntax that
    C# has for managing execution flow, but the way that they’re handled in iterators
    is both interesting and important for the usefulness of the feature. In reality,
    it’s far more likely that you’ll use `using` statements than the raw `finally`
    blocks, but you can view `using` statements as effectively built with `finally`
    blocks, so the same behavior holds.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有用于管理执行流程的C#语法中，我专注于`finally`块似乎有些奇怪，但在迭代器中处理它们的方式既有趣又对特性的实用性很重要。实际上，你更有可能使用`using`语句而不是原始的`finally`块，但你可以将`using`语句视为实际上是使用`finally`块构建的，因此行为相同。
- en: To demonstrate how the execution flow works, the following listing shows a trivial
    iterator block that yields two items within a `try` block and writes its progress
    to the console. You’ll then use the method in a couple of ways.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示执行流程是如何工作的，以下列表显示了一个简单的迭代器块，在`try`块中产生两个项目，并将它的进度写入控制台。然后你将以几种方式使用这个方法。
- en: Listing 2.14\. An iterator that logs its progress
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.14. 记录其进度的迭代器
- en: '[PRE62]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Before you run it, think about what you’d expect this to print if you just
    iterate over the sequence returned by the method. In particular, would you expect
    to see `In finally block` in the console when `first` is returned? There are two
    ways of thinking about it:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，想想如果你只是迭代方法返回的序列，你会期望它打印什么。特别是，你会期望在控制台看到`在finally块中`吗？有两种思考方式：
- en: If you consider execution to be paused by the `yield return` statement, then
    logically it’s still inside the `try` block, and there’s no need to execute the
    `finally` block.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你认为执行被`yield return`语句暂停，那么逻辑上它仍然在`try`块内部，就没有必要执行`finally`块。
- en: If you think about the code having to actually return to the `MoveNext()` caller
    when it hits the `yield return` statement, then it feels like you’re exiting the
    `try` block and should execute the `finally` block as normal.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你认为代码在遇到`yield return`语句时必须实际返回到`MoveNext()`调用者，那么感觉你是在退出`try`块，并且应该像平常一样执行`finally`块。
- en: Without wanting to spoil the surprise, the pause model wins. It’s much more
    useful and avoids other aspects that seem counterintuitive. It would be odd to
    execute each statement in a `try` block just once but execute its `finally` block
    three times, for example—once for each time you yield a value and then when you
    execute the rest of the method.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 不想剧透惊喜，暂停模型获胜。它更有用，并避免了其他看似反直觉的方面。例如，只执行 `try` 块中的每个语句一次，但执行其 `finally` 块三次，这会显得很奇怪——每次你产生一个值，然后当你执行方法的其余部分时。
- en: Let’s prove that it works that way. The following listing calls the method and
    iterates over the values in the sequence and prints them as it goes.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们证明它是这样工作的。下面的列表调用该方法，遍历序列中的值，并在过程中打印它们。
- en: Listing 2.15\. A simple `foreach` loop to iterate and log
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.15\. 一个简单的 `foreach` 循环用于迭代和记录
- en: '[PRE63]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output of [listing 2.15](kindle_split_017_split_000.html#ch02ex15) shows
    that the `finally` block is executed only once at the end:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.15](kindle_split_017_split_000.html#ch02ex15) 的输出显示 `finally` 块只在结束时执行一次：'
- en: '[PRE64]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This also proves that lazy evaluation is working: the output from the `Main()`
    method is interleaved with the output from the `Iterator()` method, because the
    iterator is repeatedly paused and resumed.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这也证明了延迟求值正在工作：`Main()` 方法的输出与 `Iterator()` 方法的输出交织在一起，因为迭代器被反复暂停和恢复。
- en: So far, so simple, but that relied on you iterating through the whole of the
    sequence. What if you want to stop halfway through? If the code that’s fetching
    items from an iterator calls `MoveNext()` only once (if it needs only the first
    value from the sequence, for example), does that leave the iterator paused in
    the `try` block forever without ever executing the `finally` block?
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很简单，但这依赖于你遍历整个序列。如果你想在中间停止怎么办？如果从迭代器获取项的代码只调用一次 `MoveNext()`（例如，如果它只需要序列的第一个值），那么这会留下迭代器在
    `try` 块中暂停，永远不执行 `finally` 块吗？
- en: The answer is yes and no. If you write all the calls to the `IEnumerator<T>`
    manually and call `MoveNext()` just once, the finally block will indeed never
    get executed. But if you write a `foreach` loop and happen to exit it without
    looping over the whole sequence, the `finally` block *will* get executed. The
    following listing demonstrates that by breaking out of the loop as soon as it
    sees a non-null value (which it will do immediately, of course). It’s the same
    as [listing 2.15](kindle_split_017_split_000.html#ch02ex15) but with the addition
    of the part in bold.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是是和否。如果你手动编写所有对 `IEnumerator<T>` 的调用，并且只调用一次 `MoveNext()`，那么 `finally` 块确实永远不会被执行。但是如果你编写了一个
    `foreach` 循环，并且在不遍历整个序列的情况下退出它，那么 `finally` 块*将会*被执行。下面的列表通过在看到非空值时立即退出循环来演示这一点。它与
    [列表 2.15](kindle_split_017_split_000.html#ch02ex15) 相同，但增加了粗体部分。
- en: Listing 2.16\. Breaking out of a `foreach` loop by using an iterator
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.16\. 通过使用迭代器退出 `foreach` 循环
- en: '[PRE65]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output of [listing 2.16](kindle_split_017_split_000.html#ch02ex16) is as
    follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.16](kindle_split_017_split_000.html#ch02ex16) 的输出如下：'
- en: '[PRE66]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The last line is the important one: you’re still executing the `finally` block.
    That happens automatically when you exit the `foreach` loop, because that has
    a hidden `using` statement. [Listing 2.17](kindle_split_017_split_000.html#ch02ex17)
    shows what [listing 2.16](kindle_split_017_split_000.html#ch02ex16) would look
    like if you couldn’t use a `foreach` loop and had to write the equivalent code
    by hand. If this looks familiar, it’s because you did the same thing in [listing
    2.12](kindle_split_017_split_000.html#ch02ex12), but this time you’re paying more
    attention to the `using` statement.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是重要的一行：你仍然在执行 `finally` 块。当你退出 `foreach` 循环时，这会自动发生，因为 `foreach` 循环有一个隐藏的
    `using` 语句。[列表 2.17](kindle_split_017_split_000.html#ch02ex17) 展示了如果你不能使用 `foreach`
    循环而必须手动编写等效代码时，[列表 2.16](kindle_split_017_split_000.html#ch02ex16) 会是什么样子。如果这看起来很熟悉，那是因为你在
    [列表 2.12](kindle_split_017_split_000.html#ch02ex12) 中做了同样的事情，但这次你更加关注 `using`
    语句。
- en: Listing 2.17\. Expansion of [listing 2.16](kindle_split_017_split_000.html#ch02ex16)
    to not use a `foreach` loop
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.17\. [列表 2.16](kindle_split_017_split_000.html#ch02ex16) 的扩展，以不使用 `foreach`
    循环
- en: '[PRE67]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The important part is the `using` statement. That makes sure that however you
    leave it, you’ll call `Dispose` on the `IEnumerator<string>`. If the iterator
    method is “paused” within the `try` block at that point, the `Dispose` method
    ends up executing the `finally` block. Isn’t it clever?
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的部分是 `using` 语句。这确保了无论你如何离开它，你都会在 `IEnumerator<string>` 上调用 `Dispose`。如果迭代器方法在那个点被
    `try` 块“暂停”，`Dispose` 方法最终会执行 `finally` 块。这不是很聪明吗？
- en: 2.4.6\. The importance of finally handling
  id: totrans-571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.6. 最后处理的重要性
- en: This may sound like a minor detail, but it makes a huge difference in how applicable
    iterators are. It means they can be used for methods that acquire resources that
    need disposing of, such as file handles. It also means that they can be used to
    chain to other iterators with the same requirement. You’ll see in [chapter 3](kindle_split_018_split_000.html#ch03)
    that LINQ to Objects uses sequences a lot, and reliable disposal is crucial to
    being able to work with files and other resources.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像是一个小细节，但它对迭代器的适用性有很大影响。这意味着它们可以用于需要释放的资源的方法，例如文件句柄。这也意味着它们可以用于链接到具有相同要求的其他迭代器。你将在
    [第 3 章](kindle_split_018_split_000.html#ch03) 中看到 LINQ to Objects 大量使用序列，可靠的释放是能够处理文件和其他资源的关键。
- en: '|  |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**All of this requires the caller to dispose of the iterator**'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有这些都要求调用者释放迭代器**'
- en: If you don’t call `Dispose` on an iterator (and you haven’t iterated to the
    end of the sequence), you can leak resources or at least delay cleanup. This should
    be avoided.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在迭代器上调用 `Dispose`（并且你没有迭代到序列的末尾），你可能会泄露资源或至少延迟清理。这应该被避免。
- en: The nongeneric `IEnumerator` interface doesn’t extend `IDisposable`, but the
    `foreach` loop checks whether the runtime implementation also implements `IDisposable`,
    and calls `Dispose` if necessary. The generic `IEnumerator<T>` interface does
    extend `IDisposable`, making things simpler.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型的 `IEnumerator` 接口不扩展 `IDisposable`，但 `foreach` 循环会检查运行时实现是否也实现了 `IDisposable`，并在必要时调用
    `Dispose`。泛型的 `IEnumerator<T>` 接口确实扩展了 `IDisposable`，这使得事情变得简单。
- en: If you’re iterating by calling `MoveNext()` manually (which can definitely have
    its place), you should do the same thing. If you’re iterating over a generic `IEnumerable<T>`,
    you can just use a `using` statement as I have in my expanded `foreach` loop listings.
    If you’re in the unfortunate position of iterating over a nongeneric sequence,
    you should perform the same interface check that the compiler does in `foreach`.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过手动调用 `MoveNext()` 来迭代（这当然有其适用场景），你应该做同样的事情。如果你正在迭代一个泛型的 `IEnumerable<T>`，你可以像我在扩展的
    `foreach` 循环列表中那样使用一个 `using` 语句。如果你不幸地正在迭代一个非泛型序列，你应该执行与编译器在 `foreach` 中执行相同的接口检查。
- en: '|  |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As an example of how useful it can be to acquire resources in iterator blocks,
    consider the following listing of a method that returns a sequence of lines read
    from a file.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在迭代器块中获取资源的有用性的一个例子，考虑以下从文件中读取行序列的方法列表。
- en: Listing 2.18\. Reading lines from a file
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.18. 从文件中读取行
- en: '[PRE68]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: A method like this was introduced in .NET 4.0 (`File.ReadLines`), but the framework
    method doesn’t work well if you call the method once but iterate over the result
    multiple times; it opens the file only once. The method in [listing 2.18](kindle_split_017_split_000.html#ch02ex18)
    opens the file each time you iterate, making it simpler to reason about. This
    has the downside, however, of delaying any exception due to the file not existing
    or not being readable. Tricky trade-offs always exist in API design.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是在 .NET 4.0 中引入的（`File.ReadLines`），但如果一次调用方法但多次迭代结果，框架方法就不太适用；它只打开文件一次。列表
    2.18 中的方法每次迭代都会打开文件，这使得推理变得简单。然而，这也有一个缺点，即延迟由于文件不存在或不可读而引发的任何异常。在 API 设计中总是存在棘手的权衡。
- en: The point of showing you this method is to demonstrate how important it is that
    iterator disposal is handled properly. If a `foreach` loop that threw an exception
    or returned early resulted in a dangling open file handle, the method would be
    close to useless. Before we leave iterators, let’s peek behind the curtain briefly
    and see how they’re implemented.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 展示这个方法的目的是为了说明正确处理迭代器释放是多么重要。如果一个抛出异常或提前返回的 `foreach` 循环导致悬挂的打开文件句柄，该函数几乎毫无用处。在我们离开迭代器之前，让我们简要地揭开面纱，看看它们是如何实现的。
- en: 2.4.7\. Implementation sketch
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.7. 实现草图
- en: I always find it useful to see roughly what the compiler does with code, particularly
    for complicated situations such as iterators, async/await, and anonymous functions.
    This section provides only a taste; an article at [http://csharpindepth.com](http://csharpindepth.com)
    provides far more detail. Please be aware that the exact details are implementation
    specific; you may find different compilers take slightly different approaches.
    I’d expect most to have the same basic strategy, though.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是发现看到编译器对代码做了什么很有用，尤其是对于像迭代器、async/await 和匿名函数这样的复杂情况。本节仅提供一种味道；[http://csharpindepth.com](http://csharpindepth.com)
    上的文章提供了更多的细节。请注意，确切细节是特定实现的；你可能发现不同的编译器采取了略有不同的方法。虽然如此，我预计大多数都会有一个相同的基本策略。
- en: The first thing to understand is that even though you’ve written a method,^([[9](kindle_split_017_split_000.html#ch02fn9)])
    the compiler generates a whole new type for you to implement the relevant interfaces.
    Your method body is moved into a `MoveNext()` method in this generated type and
    adjusted for the execution semantics of iterators. To demonstrate the generated
    code, we’ll look at the code that the compiler generates for the following listing.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是，尽管你已经编写了一个方法，^([[9](kindle_split_017_split_000.html#ch02fn9)))，编译器为你生成一个全新的类型来实现相关接口。你的方法主体被移动到这个生成的类型中的
    `MoveNext()` 方法中，并调整以适应迭代器的执行语义。为了演示生成的代码，我们将查看编译器为以下列表生成的代码。
- en: ⁹
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use iterators to write property accessors as well, but I’ll just talk
    about iterator methods for the rest of this section, just to be concise. The implementation
    is the same for property accessors.
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你也可以使用迭代器来编写属性访问器，但为了简洁起见，我将在本节的其余部分只讨论迭代器方法。实现方式对于属性访问器是相同的。
- en: Listing 2.19\. Sample iterator method to decompile
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.19\. 样本迭代器方法用于反编译
- en: '[PRE69]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[Listing 2.19](kindle_split_017_split_000.html#ch02ex19) shows a relatively
    simple method in its original form, but I’ve deliberately included five aspects
    that may not seem obvious:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.19](kindle_split_017_split_000.html#ch02ex19) 展示了其原始形式中相对简单的方法，但我故意包括了五个可能不那么明显方面：'
- en: A parameter
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参数
- en: A local variable that needs to be preserved across `yield return` statements
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在 `yield return` 语句之间保留的局部变量
- en: A local variable that doesn’t need to be preserved across `yield return` statements
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要在 `yield return` 语句之间保留的局部变量
- en: Two `yield return` statements
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 `yield return` 语句
- en: A `finally` block
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `finally` 块
- en: 'The method iterates over its loop `count` times and yields two integers on
    each iteration: the iteration number and double the same value. For example, if
    you pass in 5, it will yield 0, 0, 1, 2, 2, 4, 3, 6, 4, 8.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法遍历其循环 `count` 次，并在每次迭代中产生两个整数：迭代次数和相同值的两倍。例如，如果你传入 5，它将产生 0, 0, 1, 2, 2,
    4, 3, 6, 4, 8。
- en: The downloadable source code contains a full, manually tweaked, decompiled form
    of the generated code. It’s pretty long, so I haven’t included it in its entirety
    here. Instead, I want to give you a flavor of what’s generated. The following
    listing shows most of the infrastructure but none of the implementation details.
    I’ll explain that, and then you’ll look at the `MoveNext()` method, which does
    most of the real work.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 可下载的源代码包含生成的代码的完整、手动调整的反编译形式。它相当长，所以我没有在这里全部包含。相反，我想给你一个生成的感觉。以下列表显示了大部分基础设施，但没有实现细节。我将解释这一点，然后你将查看
    `MoveNext()` 方法，它做了大部分实际工作。
- en: Listing 2.20\. Infrastructure of the generated code for an iterator
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.20\. 迭代器生成的代码的基础设施
- en: '[PRE70]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* Stub method with the original declared signature**'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 带有原始声明签名的存根方法**'
- en: '***2* Generated class to represent the state machine**'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 生成的类用于表示状态机**'
- en: '***3* All the fields in the state machine with varying purposes**'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 状态机中具有不同目的的所有字段**'
- en: '***4* Constructor called by both the stub method and GetEnumerator**'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 由存根方法和 GetEnumerator 调用的构造函数**'
- en: '***5* Main body of state machine code**'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 状态机代码的主体**'
- en: '***6* Creates a new state machine if necessary**'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果需要，创建一个新的状态机**'
- en: '***7* Generated iterators never support Reset**'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 生成的迭代器从不支持重置**'
- en: '***8* Executes any finally blocks, if required**'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 如果需要，执行任何 finally 块**'
- en: '***9* Current property to return last-yielded value**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 当前属性用于返回最后一个产生的值**'
- en: '***10* Body of a finally block for use in MoveNext and Dispose**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 用于 MoveNext 和 Dispose 的 finally 块的主体**'
- en: '***11* Explicit implementation of nongeneric interface members**'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 显式实现非泛型接口成员**'
- en: Yes, that’s the simplified version. The important point to understand is that
    the compiler generates a *state machine* for you, as a private nested class. A
    lot of the names generated by the compiler aren’t valid C# identifiers, but I’ve
    provided valid ones for simplicity. The compiler still emits a method with the
    signature declared in the original source code, and that’s what any callers will
    use. All that does is create an instance of the state machine, copy any parameter
    to it, and return the state machine to the caller. None of the original source
    code is called, which corresponds to the lazy behavior you’ve already seen.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是简化版本。需要理解的重要点是，编译器为你生成一个*状态机*，作为一个私有嵌套类。编译器生成的许多名称都不是有效的C#标识符，但我为了简单起见提供了有效的名称。编译器仍然会发出在原始源代码中声明的签名的方法，这就是任何调用者将使用的。这一切只是创建状态机的一个实例，将任何参数复制到它，并将状态机返回给调用者。没有调用原始源代码，这与你已经看到的懒加载行为相对应。
- en: 'The state machine contains everything it needs to implement the iterator:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机包含实现迭代器所需的一切：
- en: An indicator of where you are within the method. This is similar to an instruction
    counter in a CPU but simpler because you need to distinguish between only a few
    states
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示你在方法中位置的指示器。这类似于CPU中的指令计数器，但更简单，因为你只需要区分几个状态
- en: A copy of all the parameters, so you can obtain their values when you need them
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数的副本，以便你在需要时可以获取它们的值
- en: Local variables within the method
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法内的局部变量
- en: The last-yielded value, so the caller can obtain it with the `Current` property
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一次返回的值，以便调用者可以通过`Current`属性获取它
- en: 'You’d expect the caller to perform the following sequence of operations:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 你会期望调用者执行以下操作序列：
- en: Call `GetEnumerator()` to obtain an `IEnumerator<int>`.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`GetEnumerator()`以获取`IEnumerator<int>`。
- en: Repeatedly call `MoveNext()` and then `Current` on the `IEnumerator<int>`, until
    `MoveNext()` returns `false`.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复调用`MoveNext()`然后在`IEnumerator<int>`上调用`Current`，直到`MoveNext()`返回`false`。
- en: Call `Dispose` for any cleanup that’s required, whether an exception was thrown
    or not.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Dispose`进行任何必要的清理，无论是否抛出异常。
- en: In almost all cases, the state machine is used only once and only on the same
    thread it was created on. The compiler generates code to optimize for this case;
    the `GetEnumerator()` method checks for it and returns `this` if the state machine
    is still in its original state and is on the same thread. That’s why the state
    machine implements both `IEnumerable<int>` and `IEnumerator<int>`, which would
    be unusual to see in normal code.^([[10](kindle_split_017_split_000.html#ch02fn10)])
    If `GetEnumerator()` is called from a different thread or multiple times, those
    calls create a new instance of the state machine with the initial parameter values
    copied in.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，状态机仅使用一次，并且仅在创建它的同一个线程上使用。编译器生成代码以优化这种情况；`GetEnumerator()`方法会检查它，如果状态机仍然处于原始状态并且位于同一线程上，则返回`this`。这就是为什么状态机实现了`IEnumerable<int>`和`IEnumerator<int>`，这在正常代码中是不常见的.^([[10](kindle_split_017_split_000.html#ch02fn10)])
    如果从不同的线程或多次调用`GetEnumerator()`，这些调用将创建一个新的状态机实例，并将初始参数值复制进去。
- en: ^(10)
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the original method returns only `IEnumerator<T>`, the state machine implements
    only that.
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果原始方法只返回`IEnumerator<T>`，状态机只实现那个。
- en: The `MoveNext()` method is the complicated bit. The first time it’s called,
    it just needs to start executing the code written in the method as normal; but
    on subsequent calls, however, it needs to effectively jump to the right point
    in the method. The local variables need to be preserved between calls as well,
    so they’re stored in fields in the state machine.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveNext()`方法是复杂的部分。第一次调用时，它只需要像正常一样执行方法中编写的代码；但在随后的调用中，它需要有效地跳转到方法中的正确点。局部变量需要在调用之间保持不变，因此它们被存储在状态机的字段中。'
- en: 'In an optimized build, some local variables don’t have to be copied into fields.
    The point of using a field is so you can keep track of the value you set in one
    `MoveNext()` call when you come back in the next `MoveNext()` call. If you look
    at the `doubled` local variable from [listing 2.19](kindle_split_017_split_000.html#ch02ex19),
    it’s never used like that:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化构建中，一些局部变量不需要复制到字段中。使用字段的目的在于，你可以跟踪在`MoveNext()`调用中设置的值，当你再次调用`MoveNext()`时。如果你查看[列表2.19](kindle_split_017_split_000.html#ch02ex19)中的`doubled`局部变量，它从未像那样使用过：
- en: '[PRE71]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: All you do is initialize the variable, print it out, and then yield it. When
    you return to the method, that value is irrelevant so the compiler can optimize
    it into a real local variable in a release build. In a debug build, it may still
    be present to improve the debugging experience. Notice that if you swapped the
    last two bold lines in the preceding code—yielded the value and *then* printed
    it—the optimization wouldn’t be possible.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 你所做的一切就是初始化变量，打印它，然后产生它。当你返回到该方法时，该值是无关紧要的，因此编译器可以将其优化为发布构建中的实际局部变量。在调试构建中，它可能仍然存在，以改善调试体验。注意，如果你交换了前面代码中的最后两行粗体内容——先产生值然后打印它——优化将不可行。
- en: What does a `MoveNext()` method look like? It’s difficult to give real code
    without getting stuck in too much detail, so the following listing gives a sketch
    of the structure.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveNext()`方法看起来是什么样子？在不陷入过多细节的情况下给出真实代码是困难的，所以下面的列表提供了一个结构的草图。'
- en: Listing 2.21\. Simplified `MoveNext()` method
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.21\. 简化的`MoveNext()`方法
- en: '[PRE72]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* Jump table to get to the right part of the rest of the method**'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 跳转表以到达方法的其余部分的正确部分**'
- en: '***2* Method code returning at each yield return**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在每个`yield return`返回时返回方法代码**'
- en: '***3* Fault block executed only on exceptions**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 故障块仅在异常发生时执行**'
- en: '***4* Clean up on exceptions**'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 异常清理**'
- en: 'The state machine contains a variable (in our case, called `state`) that remembers
    where it reached. The precise values used depend on the implementation, but in
    the version of Roslyn I happened to use, the states were effectively as follows:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机包含一个变量（在我们的例子中，称为`state`），它记住它到达的位置。确切使用的值取决于实现，但在我所使用的Roslyn版本中，状态实际上如下所示：
- en: '*–3*—`MoveNext()`currently executing'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*–3*—`MoveNext()`当前正在执行'
- en: '*–2*—`GetEnumerator()` not yet called'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*–2*—`GetEnumerator()`尚未调用'
- en: '*–1*—Completed (whether successfully or not)'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*–1*—完成（无论成功与否）'
- en: '*0*—`GetEnumerator()` called but `MoveNext()` not yet called (start of method)'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*0*—`GetEnumerator()`已调用但`MoveNext()`尚未调用（方法开始）'
- en: '*1*—At the first `yield return` statement'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*1*—在第一个`yield return`语句'
- en: '*2*—At the second `yield return` statement'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2*—在第二个`yield return`语句'
- en: When `MoveNext()` is called, it uses this state to jump to the right place in
    the method to either start executing for the first time or resume from the previous
    `yield return` statement. Notice that there aren’t any states for positions in
    the code such as “just assigned a value to the `doubled` variable,” because you
    never need to resume from there; you need to resume only from where you previously
    paused.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`MoveNext()`时，它使用此状态跳转到方法中的正确位置，以开始第一次执行或从之前的`yield return`语句恢复。注意，没有关于代码中位置的状态，例如“刚刚给`doubled`变量赋值”，因为你从不需要从那里恢复；你需要从之前暂停的地方恢复。
- en: The `fault` block near the end of [listing 2.21](kindle_split_017_split_000.html#ch02ex21)
    is an IL construct with no direct equivalent in C#. It’s like a `finally` block
    that executes when an exception is thrown but without catching the exception.
    This is used to perform any cleanup operations required; in our case, that’s the
    `finally` block. The code in that `finally` block is moved into a separate method
    that’s called from `Dispose()` (if an exception has been thrown) and `MoveNext()`
    (if you reach it without an exception). The `Dispose()` method checks the state
    to see what cleanup is required. That becomes more complicated the more `finally`
    blocks there are.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.21](kindle_split_017_split_000.html#ch02ex21)末尾的`fault`块是一个没有直接C#等价的IL构造。它就像一个在抛出异常时执行的`finally`块，但没有捕获异常。这用于执行所需的任何清理操作；在我们的例子中，那就是`finally`块。`finally`块中的代码被移动到一个单独的方法中，该方法从`Dispose()`（如果已抛出异常）和`MoveNext()`（如果你在没有异常的情况下到达那里）调用。`Dispose()`方法检查状态以查看需要什么清理。如果有更多的`finally`块，这会变得更加复杂。'
- en: Looking at the implementation isn’t enlightening in terms of teaching you more
    C# coding techniques, but it’s great for building an appreciation of how much
    the compiler is capable of doing on your behalf. The same ideas come into play
    again in C# 5 with async/await, where instead of pausing until the `MoveNext()`
    is called again, asynchronous methods effectively pause until an asynchronous
    operation has completed.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 查看实现并不能在教你更多C#编码技术方面提供帮助，但它对于建立对编译器能够为你做什么的欣赏是极好的。在C# 5中，同样的想法再次在async/await中发挥作用，在这种情况下，异步方法实际上暂停，直到异步操作完成，而不是暂停直到再次调用`MoveNext()`。
- en: We’ve now covered the biggest features of C# 2, but several smaller features
    were introduced at the same time. These features are reasonably simple to describe,
    which is why I’ve lumped them all together here. They’re not otherwise related,
    but sometimes that’s just the way language design happens.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了C# 2的最大功能，但当时还引入了一些较小的功能。这些功能描述起来相对简单，这就是为什么我把它们都放在一起。它们在其他方面没有关联，但有时语言设计就是这样发生的。
- en: 2.5\. Minor features
  id: totrans-649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 小功能
- en: 'Some of the features described in this section are rarely used in my experience,
    but others are common in any modern C# codebase. The time it takes to describe
    a feature doesn’t always correlate with how useful it is. In this section, you’ll
    look at the following:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的经验中，本节中描述的一些功能很少使用，但其他功能在任何现代C#代码库中都很常见。描述一个功能所需的时间并不总是与其实用性相关。在本节中，你将查看以下内容：
- en: Partial types that allow code for a single type to be split across multiple
    source files
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分类型允许将单个类型的代码拆分到多个源文件中
- en: Static classes for utility types
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态实用类型类
- en: Separate accessibility (public, private, and so on) for `get` and `set` accessors
    in properties
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性中的`get`和`set`访问器具有单独的可访问性（公共、私有等）
- en: Improvements to namespace aliases to make it easier to work with code that uses
    the same names in multiple namespaces or assemblies
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对命名空间别名进行改进，以便更容易处理在多个命名空间或程序集中使用相同名称的代码
- en: Pragma directives that allow additional compiler-specific features such as temporarily
    disabling warnings
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用额外的编译器特定功能，如暂时禁用警告的指令
- en: Fixed-size buffers for inline data in unsafe code
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不安全代码中用于内联数据的固定大小缓冲区
- en: The `[InternalsVisibleTo]` attribute, which makes testing simpler
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[InternalsVisibleTo]` 属性，它使测试更简单'
- en: Each feature is independent of the others, and the order in which I’ve described
    them is unimportant. If you know just enough about one of these sections to know
    it’s irrelevant to you, you can safely skip it without that becoming a problem
    later.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 每个功能都是独立的，我描述它们的顺序并不重要。如果你对其中任何一个部分了解得足够多，知道它对你来说无关紧要，你可以安全地跳过它，而不会在以后成为问题。
- en: 2.5.1\. Partial types
  id: totrans-659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1\. 部分类型
- en: Partial types allow a single class, struct, or interface to be declared in multiple
    parts and usually across multiple source files. This is typically used with code
    generators. Multiple code generators can contribute different parts to the same
    type, and these can be further augmented by manually written code. The various
    parts are combined by the compiler and act as if they were all declared together.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类型允许单个类、结构体或接口在多个部分中声明，通常跨越多个源文件。这通常与代码生成器一起使用。多个代码生成器可以为同一类型贡献不同的部分，并且这些部分可以通过手动编写的代码进一步扩展。不同的部分由编译器组合，并像它们一起声明一样行动。
- en: Partial types are declared by adding the `partial` modifier to the type declaration.
    This must be present in every part. The following listing shows an example with
    two parts and demonstrates how a method declared in one part can be used in a
    different part.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类型通过在类型声明中添加`partial`修饰符来声明。这必须存在于每个部分中。以下列表显示了一个包含两个部分的示例，并演示了如何在不同的部分中使用在一个部分中声明的方。
- en: Listing 2.22\. A simple partial class
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.22\. 一个简单的部分类
- en: '[PRE73]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Uses method declaredin second part**'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用第二部分中声明的方**'
- en: '***2* Method used by first part**'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第一部分使用的方法**'
- en: If the type is generic, every part has to declare the same set of type parameters
    with the same names, although if multiple declarations constrain the same type
    parameter, those constraints must be the same. Different parts can contribute
    different interfaces that a type implements, and the implementation doesn’t need
    to be in the part that specifies the interface.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型是泛型的，每个部分都必须声明具有相同名称的相同类型参数集，尽管如果多个声明约束了相同的类型参数，则这些约束必须相同。不同的部分可以贡献类型实现的不同接口，而实现不需要在指定接口的部分中。
- en: Partial methods (C# 3)
  id: totrans-667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部分方法（C# 3）
- en: C# 3 introduced an extra feature to partial types called *partial methods*.
    These are methods declared without a body in one part and then optionally implemented
    in another part. Partial methods are implicitly private and must be `void` with
    no `out` parameters. (It’s fine to use `ref` parameters.) At compile time, only
    partial methods that have implementations are retained; if a partial method hasn’t
    been implemented, all calls to it are removed. This sounds odd, but it allows
    generated code to provide optional hooks for manually written code to add extra
    behavior. It turns out to be useful indeed. The following listing provides an
    example with two partial methods, one of which is implemented and one of which
    isn’t.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3 引入了一个名为*局部方法*的额外特性，用于部分类型。这些方法在一个部分中声明而没有主体，然后可选地在另一个部分中实现。局部方法是隐式私有的，必须是`void`且没有`out`参数。（可以使用`ref`参数。）在编译时，只有具有实现的局部方法被保留；如果一个局部方法没有被实现，那么对其的所有调用都会被移除。这听起来很奇怪，但它允许生成代码为手动编写的代码提供可选的钩子，以便添加额外的行为。实际上，这确实很有用。以下列表提供了一个具有两个局部方法的示例，其中一个已实现，另一个未实现。
- en: Listing 2.23\. Two partial methods—one implemented, one not
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.23\. 两个局部方法——一个已实现，一个未实现
- en: '[PRE74]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Call to unimplemented partial method**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用未实现的局部方法**'
- en: '***2* Call to implemented partial method**'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用已实现的局部方法**'
- en: '***3* Partial method declarations**'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 局部方法声明**'
- en: '***4* Partial method implementation**'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 局部方法实现**'
- en: In [listing 2.23](kindle_split_017_split_000.html#ch02ex23), the first part
    would most likely be generated code, thereby allowing for additional behavior
    on construction and when obtaining a string representation of the object. The
    second part corresponds to manually written code that doesn’t need to customize
    construction but does want to change the string representation returned by `ToString()`.
    Even though the `CustomizeToString` method can’t return a value directly, it can
    effectively pass information back to its caller with a `ref` parameter.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 2.23](kindle_split_017_split_000.html#ch02ex23)中，第一部分很可能是生成代码，从而允许在构造时和获取对象字符串表示时添加额外的行为。第二部分对应于手动编写的代码，它不需要自定义构造，但希望更改`ToString()`返回的字符串表示。尽管`CustomizeToString`方法不能直接返回值，但它可以通过`ref`参数有效地将信息传递回其调用者。
- en: Because `OnConstruction` is never implemented, it’s completely removed by the
    compiler. If a partial method with parameters is called, the arguments are never
    even evaluated when there’s no implementation.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`OnConstruction`从未被实现，所以它会被编译器完全移除。如果调用了一个带有参数的局部方法，在没有实现的情况下，这些参数甚至不会被评估。
- en: If you ever find yourself writing a code generator, I strongly encourage you
    to make it generate partial classes. You may also find it useful to create partial
    classes in purely handwritten code; I’ve used this to split tests for large classes
    into multiple source files for easy organization, for example.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经编写过代码生成器，我强烈建议你让它生成局部类。你也许还会发现，在纯手工编写的代码中创建局部类很有用；例如，我使用这种方法将大型类的测试拆分为多个源文件，以便于组织。
- en: 2.5.2\. Static classes
  id: totrans-678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.2\. 静态类
- en: '*Static classes* are classes declared with the `static` modifier. If you’ve
    ever found yourself writing utility classes composed entirely of static methods,
    those are prime candidates to be static classes. Static classes can’t declare
    instance methods, properties, events, or constructors, but they can contain regular
    nested types.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态类*是使用`static`修饰符声明的类。如果你曾经发现自己编写了完全由静态方法组成的实用工具类，那么这些类是成为静态类的理想候选。静态类不能声明实例方法、属性、事件或构造函数，但可以包含常规嵌套类型。'
- en: Although it’s perfectly valid to declare a regular class with only static members,
    adding the `static` modifier signals your intent in terms of how you expect the
    class to be used. The compiler knows that static classes can never be instantiated,
    so it prevents them from being used as either variable types or type arguments.
    The following listing gives a brief example of what’s allowed and what’s not.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然声明仅包含静态成员的常规类是完全有效的，但添加`static`修饰符会表明你的意图，即你期望如何使用该类。编译器知道静态类永远不会被实例化，因此它阻止它们被用作变量类型或类型参数。以下列表提供了一个简要示例，说明了允许和不允许的内容。
- en: Listing 2.24\. Demonstration of static classes
  id: totrans-681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.24\. 静态类的演示
- en: '[PRE75]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Fine: static classes can declare static methods.**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 正确：静态类可以声明静态方法。**'
- en: '***2* Invalid: static classes can’t declare instance methods.**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 无效：静态类不能声明实例方法。**'
- en: '***3* Fine: static classes can declare regular nested types.**'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 合法：静态类可以声明常规嵌套类型。**'
- en: '***4* Fine: a regular type nested in a static class can declare an instance
    method.**'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 合法：静态类中嵌套的常规类型可以声明实例方法。**'
- en: '***5* Fine: calling a static method from a static class**'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 合法：从静态类中调用静态方法**'
- en: '***6* Invalid: can’t declare a variable of a static class**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 无效：不能声明静态类的变量**'
- en: '***7* Invalid: can’t use a static class as a type argument**'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 无效：不能将静态类用作类型参数**'
- en: Static classes have additional special behavior in that extension methods (introduced
    in C# 3) can be declared only in non-nested, nongeneric, static classes.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类具有额外的特殊行为，即扩展方法（在C# 3中引入）只能声明在非嵌套、非泛型、静态类中。
- en: 2.5.3\. Separate getter/setter access for properties
  id: totrans-691
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.3\. 属性的单独获取器/设置器访问
- en: 'It’s hard to believe, but in C# 1, a property had only a single access modifier
    that was used for both the getter and the setter, assuming both were present.
    C# 2 introduced the ability to make one accessor more private than the other by
    adding a modifier to that more-private accessor. This is almost always used to
    make the setter more private than the getter, and by far the most common combination
    is to have a public getter and a private setter, like this:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 很难相信，但在C# 1中，属性只有一个访问修饰符，用于获取器和设置器，假设两者都存在。C# 2引入了通过向更私有的访问器添加修饰符来使一个访问器比另一个更私有的能力。这几乎总是用来使设置器比获取器更私有，最常见的情况是具有公共获取器和私有设置器，如下所示：
- en: '[PRE76]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this example, any code that has access to the property setter could just
    set the field value directly, but in more complex situations, you may want to
    add validation or change notification. Using a property allows behavior like this
    to be encapsulated nicely. Although this could be put in a method instead, using
    a property feels more idiomatic in C#.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，任何可以访问属性设置器的代码都可以直接设置字段值，但在更复杂的情况下，您可能希望添加验证或更改通知。使用属性允许这种行为被很好地封装。尽管这可以放在方法中，但在C#中使用属性感觉更符合惯例。
- en: 2.5.4\. Namespace aliases
  id: totrans-695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.4\. 命名空间别名
- en: Namespaces are used to allow multiple types with the same name to be declared
    but in different namespaces. This avoids long and convoluted type names just for
    the sake of uniqueness. C# 1 already supported namespaces and even *namespace
    aliases* so you could make it clear which type you meant if you had a single piece
    of code that needed to use types with the same name from different namespaces.
    The following listing shows how one method can refer to the `Button` classes from
    both Windows Forms and ASP.NET Web Forms.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间用于允许在多个命名空间中声明具有相同名称的类型。这避免了仅仅为了唯一性而使用长而复杂的类型名称。C# 1已经支持命名空间，甚至*命名空间别名*，因此如果您有一段需要使用来自不同命名空间的同名类型的代码，可以清楚地指明您指的是哪个类型。以下列表显示了如何一个方法可以引用Windows
    Forms和ASP.NET Web Forms中的`Button`类。
- en: Listing 2.25\. Namespace aliases in C# 1
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.25\. C# 1中的命名空间别名
- en: '[PRE77]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Introduces namespace aliases**'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 介绍命名空间别名**'
- en: '***2* Uses the aliases to qualify a name**'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用别名限定名称**'
- en: C# 2 extends the support for namespace aliases in three important ways.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2在三个重要方面扩展了对命名空间别名的支持。
- en: Namespace alias qualifier syntax
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名空间别名限定符语法
- en: 'The `WinForms.Button` syntax in [listing 2.25](kindle_split_017_split_000.html#ch02ex25)
    works fine so long as there isn’t a type called `WinForms` as well. At that point,
    the compiler would treat `WinForms.Button` as an attempt to use a member called
    `Button` within the type `WinForms` instead of using the namespace alias. C# 2
    solves this by introducing a new piece of syntax called a *namespace alias qualifier*,
    which is just a pair of colons. This is used only for namespace aliases, thereby
    removing any ambiguity. Using namespace alias qualifiers, the `Main` method in
    [listing 2.25](kindle_split_017_split_000.html#ch02ex25) would become the following:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表2.25](kindle_split_017_split_000.html#ch02ex25)中的`WinForms.Button`语法在没有任何名为`WinForms`的类型存在的情况下是有效的。在这种情况下，编译器会将`WinForms.Button`视为在类型`WinForms`中使用名为`Button`的成员的尝试，而不是使用命名空间别名。C#
    2通过引入一个名为*命名空间别名限定符*的新语法来解决此问题，它只是一个由两个冒号组成的对。这仅用于命名空间别名，从而消除了任何歧义。使用命名空间别名限定符，[列表2.25](kindle_split_017_split_000.html#ch02ex25)中的`Main`方法将变为以下内容：
- en: '[PRE78]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Resolving ambiguity is useful for more than just helping the compiler. More
    important, it helps anyone reading your code understand that the identifier before
    the `::` is expected to be a namespace alias, not a type name. I suggest using
    `::` anywhere you use a namespace alias.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 解决歧义不仅对帮助编译器有用。更重要的是，它帮助任何阅读你代码的人理解在 `::` 前的标识符预期是一个命名空间别名，而不是类型名。我建议在任何使用命名空间别名的地方都使用
    `::`。
- en: The global namespace alias
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 全局命名空间别名
- en: Although it’s unusual to declare types in the global namespace in production
    code, it can happen. Prior to C# 2, there was no way of fully qualifying a reference
    to a type in the namespace. C# 2 introduces `global` as a namespace alias that
    always refers to the global namespace. In addition to referring to types in the
    global namespace, the global namespace alias can be used as a sort of “root” for
    fully qualified names, and this is how I’ve used it most often.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在生产代码中声明全局命名空间中的类型是不常见的，但它确实可能发生。在 C# 2 之前，没有完全限定对命名空间中类型的引用的方法。C# 2 引入了 `global`
    作为命名空间别名，它始终指向全局命名空间。除了引用全局命名空间中的类型外，全局命名空间别名还可以用作完全限定名称的“根”，这就是我最常使用它的方式。
- en: As an example, recently I was dealing with some code with a lot of methods using
    `DateTime` parameters. When another type called `DateTime` was introduced into
    the same namespace, that caused problems for these method declarations. Although
    I could’ve introduced a namespace alias for the `System` namespace, it was simpler
    to replace each method parameter type with `global::System.DateTime`. I find that
    namespace aliases in general, and particularly the global namespace alias, are
    especially useful when writing code generators or working with generated code
    where collisions are more likely to occur.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，最近我处理了一些代码，其中有很多方法使用 `DateTime` 参数。当另一个名为 `DateTime` 的类型被引入到同一命名空间中时，这给这些方法声明带来了问题。尽管我可以为
    `System` 命名空间引入一个命名空间别名，但用 `global::System.DateTime` 替换每个方法参数类型更简单。我发现，在编写代码生成器或处理可能发生冲突的生成代码时，命名空间别名，尤其是全局命名空间别名，特别有用。
- en: Extern aliases
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 外部别名
- en: 'So far I’ve been talking about naming collisions between multiple types with
    the same name but in different namespaces. What about a more worrying collision:
    two types with the same name in the same namespace but provided by different assemblies?'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在谈论具有相同名称但位于不同命名空间的多类型之间的命名冲突。那么，更令人担忧的冲突是什么：同一命名空间中具有相同名称但由不同汇编提供的两个类型？
- en: 'This is definitely a corner case, but it can come up, and C# 2 introduced *extern
    aliases* to handle it. Extern aliases are declared in source code without any
    specified association, like this:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个边缘情况，但它可能会发生，C# 2 引入了 *外部别名* 来处理这种情况。外部别名在源代码中声明，没有任何指定的关联，如下所示：
- en: '[PRE79]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the same source code, you can then use the alias in `using` directives or
    writing fully qualified type names. For example, if you were using Json.NET but
    had an additional assembly that declared `Newtonsoft.Json.Linq.JObject`, you could
    write code like this:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的源代码中，然后可以在 `using` 指令或编写完全限定类型名称时使用该别名。例如，如果你正在使用 Json.NET 但有一个额外的汇编声明了
    `Newtonsoft.Json.Linq.JObject`，你可以编写如下代码：
- en: '[PRE80]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Uses the regular Json.NET JObject type**'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用常规 Json.NET JObject 类型***'
- en: '***2* Uses the JObject type in the alternative assembly**'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在替代汇编中使用 JObject 类型***'
- en: 'That leaves one problem: associating each extern alias with an assembly. The
    mechanism for doing this is implementation specific. For example, it could be
    specified in project options or on the compiler command line.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了一个问题：将每个外部别名与一个汇编关联起来。执行此操作的具体机制是实现的特定。例如，它可以在项目选项或编译器命令行中指定。
- en: I can’t remember ever having to use extern aliases myself, and I’d normally
    expect them to be used as a stopgap solution while alternative approaches were
    being found to avoid the naming collision to start with. But I’m glad they exist
    to allow those temporary solutions.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我不记得自己曾经需要使用外部别名，我通常期望它们被用作临时解决方案，在找到避免命名冲突的其他方法时使用。但我很高兴它们存在，以便允许这些临时解决方案。
- en: 2.5.5\. Pragma directives
  id: totrans-719
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.5\. 预处理指令
- en: '*Pragma directives* are implementation-specific directives that give extra
    information to the compiler. A pragma directive can’t change the behavior of the
    program to contravene anything within the C# language specification, but it can
    do anything outside the scope of the specification. If the compiler doesn’t understand
    a particular pragma directive, it can issue a warning but not an error. The syntax
    for pragma directives is simple: it’s just `#pragma` as the first nonwhitespace
    part of a line followed by the text of the pragma directive.'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '*预处理指令*是特定于实现的指令，它向编译器提供额外信息。预处理指令不能改变程序的行为以违反C#语言规范中的任何内容，但它可以在规范范围之外做任何事情。如果编译器不理解特定的预处理指令，它可以发出警告但不能报错。预处理指令的语法很简单：它只是作为行中第一个非空白部分的`#pragma`，后面跟着预处理指令的文本。'
- en: 'The Microsoft C# compiler supports pragma directives for warnings and checksums.
    I’ve always seen checksum pragmas only in generated code, but warning pragmas
    are useful for disabling and reenabling specific warnings. For example, to disable
    warning CS0219 (“variable is assigned but its value is never used”) for a specific
    piece of code, you might write this:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft C#编译器支持用于警告和校验和的预处理指令。我总是只在生成的代码中看到校验和预处理指令，但警告预处理指令对于禁用和重新启用特定警告很有用。例如，要禁用针对特定代码段的警告CS0219（“变量已分配但其值从未使用”），你可能写出如下代码：
- en: '[PRE81]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Until C# 6, warnings could be specified only using numbers. Roslyn makes the
    compiler pipeline more extensible, thereby allowing other packages to contribute
    warnings as part of the build. To accommodate this, the language was changed to
    allow a prefix (for example, `CS` for the C# compiler) to be specified as part
    of the warning identifier as well. I recommend always including the prefix (CS0219
    rather than just 0219 in the preceding example) for clarity.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 6之前，警告只能使用数字指定。Roslyn使编译器管道更加可扩展，从而允许其他包在构建过程中贡献警告。为了适应这一点，语言被修改为允许在警告标识符中指定前缀（例如，`CS`代表C#编译器）。我建议始终包含前缀（例如，在前面的示例中，使用CS0219而不是仅使用0219）以提高清晰度。
- en: If you omit a specific warning identifier, *all* warnings will be disabled or
    restored. I’ve never used this facility, and I recommend against it in general.
    Usually, you want to fix warnings instead of disabling them, and disabling them
    on a blanket basis hides information about problems that might be lurking in your
    code.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略特定的警告标识符，*所有*警告都将被禁用或恢复。我从未使用过这个功能，并且通常不推荐使用它。通常，你希望修复警告而不是禁用它们，而全面禁用警告会隐藏可能潜藏在代码中的问题信息。
- en: 2.5.6\. Fixed-size buffers
  id: totrans-725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.6\. 固定大小的缓冲区
- en: Fixed-size buffers are another feature I’ve never used in production code. That
    doesn’t mean you won’t find them useful, particularly if you use interop with
    native code a lot.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小的缓冲区是我从未在生产代码中使用过的另一个功能。这并不意味着你不会发现它们有用，尤其是如果你大量使用与本地代码的互操作。
- en: Fixed-size buffers can be used only in unsafe code and only within structs.
    They effectively allocate a chunk of memory inline within the struct using the
    `fixed` modifier. The following listing shows a trivial example of a struct that
    represents 16 bytes of arbitrary data and two 32-bit integers to represent the
    major and minor versions of that data.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小的缓冲区只能在非安全代码和结构体内部使用。它们通过使用`fixed`修饰符在结构体内部有效地分配一块内存。以下列表展示了表示16字节任意数据和两个32位整数（用于表示数据的版本号）的结构的简单示例。
- en: Listing 2.26\. Using fixed-size buffers for a versioned chunk of binary data
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.26\. 使用固定大小的缓冲区处理版本化的二进制数据块
- en: '[PRE82]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: I’d expect the size of a value of this struct type to be 24 bytes or possibly
    32 bytes if the runtime aligned the fields to 8-byte boundaries. The important
    point is that all of the data is directly within the value; there’s no reference
    to a separate byte array. This struct could be used for interoperability with
    native code or just used within regular managed code.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计这种结构类型值的尺寸将是24字节，或者如果运行时将字段对齐到8字节边界，可能是32字节。重要的是所有的数据都直接在值内；没有引用到单独的字节数组。这个结构可以用于与本地代码的互操作性，或者仅用于常规托管代码中。
- en: '|  |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Although I provide a general warning about using sample code in this book, I
    feel compelled to give a more specific one for this example. To keep the code
    short, I haven’t attempted to provide any encapsulation in this struct. It should
    be used only to get an impression of the syntax for fixed-size buffers.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我在本书中提供了关于使用示例代码的一般警告，但我仍觉得有必要为这个例子给出一个更具体的警告。为了使代码更简洁，我没有尝试在这个结构体中提供任何封装。它应该仅用于获取固定大小缓冲区的语法印象。
- en: '|  |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Improved access to fixed-sized buffers in fields in C# 7.3
  id: totrans-735
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: C# 7.3中字段中固定大小缓冲区的访问得到改进
- en: '[Listing 2.26](kindle_split_017_split_000.html#ch02ex26) demonstrated accessing
    a fixed-sized buffer via a local variable. If the `versioned` variable had been
    a field instead, accessing elements of `versioned.Data` would’ve required a `fixed`
    statement to create a pointer prior to C# 7.3\. As of C# 7.3, you can access fixed-sized
    buffers in fields directly, although the code still needs to be in an unsafe context.'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.26](kindle_split_017_split_000.html#ch02ex26) 展示了通过局部变量访问固定大小的缓冲区。如果 `versioned`
    变量是一个字段而不是变量，那么在C# 7.3之前访问 `versioned.Data` 的元素将需要使用 `fixed` 语句创建指针。从C# 7.3开始，你可以在字段中直接访问固定大小的缓冲区，尽管代码仍然需要在非安全上下文中。'
- en: 2.5.7\. InternalsVisibleTo
  id: totrans-737
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.7\. InternalsVisibleTo
- en: 'The final feature for C# 2 is as much a framework and runtime feature as anything
    else. It isn’t even mentioned in the language specification, although I’d expect
    any modern C# compiler to be aware of it. The framework exposes an attribute called
    `[InternalsVisibleToAttribute]`, which is an assembly-level attribute with a single
    parameter specifying another assembly. This allows internal members of the assembly
    containing the attribute to be used by the assembly specified in the attribute,
    as shown in the following example:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2的最后一个特性既是一个框架特性，也是一个运行时特性。它甚至没有在语言规范中提及，尽管我预计任何现代的C#编译器都应该知道它。该框架公开了一个名为
    `[InternalsVisibleToAttribute]` 的属性，这是一个具有单个参数的模块级属性，该参数指定了另一个模块。这允许包含该属性的模块的内部成员可以被属性中指定的模块使用，如下面的示例所示：
- en: '[PRE83]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'When the assembly is signed, you need to include the public key in the assembly
    name. For example, in Noda Time I have this:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序集被签名时，需要在程序集名称中包含公钥。例如，在Noda Time中，我有以下内容：
- en: '[PRE84]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The real public key is much longer than that, of course. Using this attribute
    with signed assemblies is never pretty, but you don’t need to look at the code
    often. I’ve used the attribute in three kinds of situations, one of which I later
    regretted:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的公钥当然要长得多。使用此属性与签名程序集一起从不漂亮，但你不需要经常查看代码。我已在这三种情况下使用该属性，其中之一我后来后悔了：
- en: Allowing a test assembly access to internal members to make testing easier
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许测试程序集访问内部成员以简化测试
- en: Allowing tools (which are never published) access to internal members to avoid
    code duplication
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许工具（这些工具从未发布）访问内部成员以避免代码重复
- en: Allowing one library access to internal members in another closely related library
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许一个库访问另一个紧密相关的库中的内部成员
- en: The last of these was a mistake. We’re used to expecting that we can change
    internal code without worrying about versioning, but when internal code is exposed
    to another library that’s versioned independently, it takes on the same versioning
    characteristics as public code. I don’t intend to do that again.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的最后一个是一个错误。我们习惯于期望我们可以更改内部代码而不必担心版本控制，但当内部代码暴露给另一个独立版本化的库时，它就具有与公共代码相同的版本特性。我不打算再次这样做。
- en: For testing and tools, however, I’m a big fan of making the internals visible.
    I know there’s testing dogma around testing only the public API surface, but often
    if you’re trying to keep the public surface small, allowing your tests access
    to the internal code allows you to write much simpler tests, which means you’re
    likely to write more of them.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于测试和工具，我非常支持使内部成员可见。我知道关于只测试公共API表面的测试教条，但通常如果你试图保持公共表面较小，允许测试访问内部代码可以使你编写更简单的测试，这意味着你可能会编写更多的测试。
- en: Summary
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The changes in C# 2 made an enormous difference to the look and feel of idiomatic
    C#. Working without generics or nullable types is frankly horrible.
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 2的变化对惯用C#的外观和感觉产生了巨大的影响。在没有泛型或可空类型的情况下工作实际上是可怕的。
- en: Generics allow both types and methods to say more about the types in their API
    signatures. This promotes compile-time type safety without a lot of code duplication.
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型允许类型和方法在其API签名中表达更多关于类型的信息。这促进了编译时类型安全，而无需大量代码重复。
- en: Reference types have always had the ability to use a null value to express an
    absence of information. Nullable value types apply that idea to value types with
    support in the language, runtime, and framework to make them easy to work with.
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型始终具有使用空值来表示信息缺失的能力。可空值类型将这一理念应用于值类型，并在语言、运行时和框架中提供支持，使它们易于使用。
- en: Delegates became easier to work with in C# 2, and method group conversions for
    regular methods and anonymous methods provide even more power and brevity.
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 2 中，委托的使用变得更加容易，常规方法和匿名方法的方组转换提供了更多的功能和简洁性。
- en: Iterators allow code to produce sequences that are lazily evaluated, which effectively
    pauses a method until the next value is requested.
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器允许代码产生延迟评估的序列，这实际上会在请求下一个值之前暂停方法。
- en: Not all features are huge. Small features such as partial types and static classes
    can still have a significant impact. Some of these won’t affect every developer
    but will be vital for niche use cases.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有功能都是巨大的。像部分类型和静态类这样的小功能仍然可以产生重大影响。其中一些可能不会影响每位开发者，但对于特定用例却至关重要。
- en: 'Chapter 3\. C# 3: LINQ and everything that comes with it'
  id: totrans-755
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章. C# 3：LINQ 及其所有相关内容
- en: '|  |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Implementing trivial properties simply
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单实现平凡属性
- en: Initializing objects and collections more concisely
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简洁地初始化对象和集合
- en: Creating anonymous types for local data
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为本地数据创建匿名类型
- en: Using lambda expressions to build delegates and expression trees
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式构建委托和表达式树
- en: Expressing complex queries simply with query expressions
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询表达式简单表达复杂查询
- en: '|  |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The new features of C# 2 were mostly independent of each other. Nullable value
    types depended on generics, but they were still separate features that didn’t
    build toward a common goal.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 的新功能大多相互独立。可空值类型依赖于泛型，但它们仍然是独立的功能，并没有朝着共同的目标构建。
- en: C# 3 was different. It consisted of many new features, each of which was useful
    in its own right, but almost all of which built toward the larger goal of LINQ.
    This chapter shows each feature individually and then demonstrates how they fit
    together. The first feature we’ll look at is the only one that has no direct relationship
    with LINQ.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3 是不同的。它包含了许多新功能，每个功能本身都有用，但几乎都是朝着 LINQ 的更大目标构建的。本章将分别展示每个功能，然后演示它们是如何结合在一起的。我们将首先查看的唯一一个与
    LINQ 没有直接关系的功能。
- en: 3.1\. Automatically implemented properties
  id: totrans-766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 自动实现属性
- en: 'Prior to C# 3, every property had to be implemented manually with bodies for
    the `get` and/or `set` accessors. The compiler was happy to provide an implementation
    for field-like events but not properties. That meant there were a lot of properties
    like this:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 3 之前，每个属性都必须手动实现，包括 `get` 和/或 `set` 访问器的主体。编译器乐于为字段类似的事件提供实现，但不为属性提供。这意味着有很多这样的属性：
- en: '[PRE85]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Formatting would vary by code style, but whether the property was one long line,
    11 short ones, or five lines in between (as in the preceding example), it was
    always just noise. It was a very long-winded way of expressing the intention to
    have a field and expose its value to callers via a property.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 格式会根据代码风格而变化，但无论属性是一行很长、11 行很短，还是在中间有 5 行（如前面的示例所示），它始终只是噪音。这是一种非常冗长的表达意图的方式，即有一个字段，并通过属性将其值暴露给调用者。
- en: 'C# 3 made this much simpler by using *automatically implemented properties*
    (often referred to as *automatic properties* or even *autoprops*). These are properties
    with no accessor bodies; the compiler provides the implementation. The whole of
    the preceding code can be replaced with a single line:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3 通过使用 *自动实现属性*（通常称为 *自动属性* 或甚至 *autoprops*）使这一切变得更加简单。这些属性没有访问器主体；编译器提供实现。前面的所有代码都可以用一行替换：
- en: '[PRE86]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note that there’s no field declaration in the source code now. There’s still
    a field, but it’s created for you automatically by the compiler and given a name
    that can’t be referred to anywhere in the C# code.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在源代码中没有字段声明。仍然有一个字段，但它是由编译器自动创建的，并赋予一个在 C# 代码中无法引用的名字。
- en: 'In C# 3, you can’t declare read-only automatically implemented properties,
    and you can’t provide an initial value at the point of declaration. Both of those
    features were introduced (finally!) in C# 6 and are described in [section 8.2](kindle_split_024_split_000.html#ch08lev1sec2).
    Before C# 6, it was a reasonably common practice to fake read-only properties
    by giving them a private `set` accessor like this:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 3 中，你不能声明只读的自动实现属性，也不能在声明点提供初始值。这两个特性最终在 C# 6 中被引入，并在[第 8.2 节](kindle_split_024_split_000.html#ch08lev1sec2)中描述。在
    C# 6 之前，通过给它们一个私有的 `set` 访问器来伪造只读属性是一种相当常见的做法：
- en: '[PRE87]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The introduction of automatically implemented properties in C# 3 had a huge
    effect in reducing boilerplate code. They’re useful only when the property simply
    fetches and sets the field value, but that accounts for a large proportion of
    properties in my experience.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3 中自动实现属性的引入对减少样板代码产生了巨大影响。它们只有在属性仅仅获取和设置字段值时才有用，但根据我的经验，这占了属性的大多数比例。
- en: 'As I mentioned, automatically implemented properties don’t directly contribute
    to LINQ. Let’s move on to the first feature that does: implicit typing for arrays
    and local variables.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，自动实现属性并不直接贡献于 LINQ。让我们继续到第一个确实有贡献的特性：数组和局部变量的隐式类型。
- en: 3.2\. Implicit typing
  id: totrans-777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 隐式类型
- en: In order to be as clear as possible about the features introduced in C# 3, I
    need to define a few terms first.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能清晰地定义 C# 3 中引入的特性，我需要首先定义一些术语。
- en: 3.2.1\. Typing terminology
  id: totrans-779
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 类型术语
- en: 'Many terms are used to describe the way programming languages interact with
    their type system. Some people use the terms *weakly typed* and *strongly typed*,
    but I try to avoid those because they’re not clearly defined and mean different
    things to different developers. Two other aspects have more consensus: static/dynamic
    typing and explicit/implicit typing. Let’s look at each of those in turn.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 用来描述编程语言与其类型系统交互的术语有很多。有些人使用 *弱类型* 和 *强类型* 这些术语，但我尽量避免使用它们，因为它们没有明确的定义，对不同开发者意味着不同的事情。另外两个方面有更多的共识：静态/动态类型和显式/隐式类型。让我们依次看看这些。
- en: Static and dynamic typing
  id: totrans-781
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态和动态类型
- en: Languages that are *statically typed* are typically compiled languages; the
    compiler is able to determine the type of each expression and check that it’s
    used correctly. For example, if you make a method call on an object, the compiler
    can use the type information to check that there’s a suitable method to call based
    on the type of the expression the method is called on, the name of the method,
    and the number and types of the arguments. Determining the meaning of something
    like a method call or field access is called *binding*. Languages that are *dynamically
    typed* leave all or most of the binding to execution time.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*静态类型*的语言是编译型语言；编译器能够确定每个表达式的类型并检查其是否被正确使用。例如，如果你对一个对象调用方法，编译器可以使用类型信息来检查是否存在一个适合调用该方法的方法，基于方法调用的表达式类型、方法名称以及参数的数量和类型。确定像方法调用或字段访问这样的含义的过程称为*绑定*。*动态类型*的语言将所有或大部分的绑定留给执行时。
- en: '|  |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As you’ll see in various places, some expressions in C# don’t have a type when
    considered in source code, such as the null literal. But the compiler always works
    out a type based on the context in which the expression is used, at which point
    that type can be used for checking how the expression is used.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在各个地方看到的那样，C# 中的一些表达式在源代码中考虑时没有类型，例如空字面量。但编译器始终根据表达式使用的上下文来确定类型，此时该类型可以用于检查表达式的使用方式。
- en: '|  |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Aside from the dynamic binding introduced in C# 4 (and described in [chapter
    4](kindle_split_019_split_000.html#ch04)), C# is a statically typed language.
    Even though the choice of which implementation of a virtual method should be executed
    depends on the execution-time type of the object it’s called on, the binding process
    of determining the method signature all happens at compile time.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 C# 4 中引入的动态绑定（并在[第 4 章](kindle_split_019_split_000.html#ch04)中描述）之外，C# 是一种静态类型语言。尽管选择执行哪个虚拟方法实现取决于被调用对象在执行时的类型，但确定方法签名的绑定过程全部发生在编译时。
- en: Explicit and implicit typing
  id: totrans-788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显式和隐式类型
- en: In a language that’s *explicitly typed*, the source code specifies all the types
    involved. This could be for local variables, fields, method parameters, or method
    return types, for example. A language that’s *implicitly typed* allows the developer
    to omit the types from the source code so some other mechanism (whether it’s a
    compiler or something at execution time) can infer which type is meant based on
    other context.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个**显式类型**的语言中，源代码指定了所有涉及的类型。这可能包括局部变量、字段、方法参数或方法返回类型等。一个**隐式类型**的语言允许开发者从源代码中省略类型，以便其他机制（无论是编译器还是执行时的某些机制）可以根据其他上下文推断出期望的类型。
- en: C# is mostly explicitly typed. Even before C# 3, there was some implicit typing,
    such as type inference for generic type arguments as you saw in [section 2.1.4](kindle_split_017_split_000.html#ch02lev2sec4).
    Arguably, the presence of implicit conversions (such as `int` to `long`) make
    the language less explicitly typed, too.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: C# 主要为显式类型。即使在 C# 3 之前，也存在一些隐式类型，例如，正如你在[第 2.1.4 节](kindle_split_017_split_000.html#ch02lev2sec4)中看到的泛型类型参数的类型推断。可以说，存在隐式转换（如
    `int` 到 `long`）也使得语言不那么显式地类型化。
- en: With those different aspects of typing separated, you can look at the C# 3 features
    around implicit typing. We’ll start with implicitly typed local variables.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些不同的类型方面分开，你可以查看 C# 3 的隐式类型功能。我们将从隐式类型局部变量开始。
- en: 3.2.2\. Implicitly typed local variables (var)
  id: totrans-792
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 隐式类型局部变量（var）
- en: 'Implicitly typed local variables are variables declared with the contextual
    keyword `var` instead of the name of a type, such as the following:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型局部变量是使用上下文关键字 `var` 而不是类型名称声明的变量，如下所示：
- en: '[PRE88]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The result of declaring a local variable with `var` instead of with the name
    of a type is still a local variable with a known type; the only difference is
    that the type is inferred by the compiler from the compile-time type of the value
    assigned to it. The preceding code will generate the exact same result as this:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 而不是类型名称声明局部变量的结果仍然是一个具有已知类型的局部变量；唯一的区别是类型是由编译器从分配给它的值的编译时类型推断出来的。前面的代码将生成与以下代码完全相同的结果：
- en: '[PRE89]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '|  |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-798
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: When C# 3 first came out, a lot of developers avoided `var` because they thought
    it would remove a lot of compile-time checks or lead to execution-time performance
    problems. It doesn’t do that at all; it only infers the type of the local variable.
    After the declaration, the variable acts exactly as if it had been declared with
    an explicit type name.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 当 C# 3 首次发布时，许多开发者避免使用 `var`，因为他们认为它会移除很多编译时检查或导致执行时性能问题。它根本不是这样；它只是推断局部变量的类型。在声明之后，变量表现得就像它已经使用显式类型名称声明一样。
- en: '|  |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The way the type is inferred leads to two important rules for implicitly typed
    local variables:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断的方式导致隐式类型局部变量有两个重要的规则：
- en: The variable must be initialized at the point of declaration.
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量必须在声明点进行初始化。
- en: The expression used to initialize the variable must have a type.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化变量的表达式必须有一个类型。
- en: 'Here’s some invalid code to demonstrate these rules:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些无效代码，用于演示这些规则：
- en: '[PRE90]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* No initial value provided**'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 未提供初始值**'
- en: '***2* Initial value has no type.**'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 初始值没有类型。**'
- en: It would’ve been possible to avoid these rules in some cases by analyzing all
    the assignments performed to the variable and inferring the type from those. Some
    languages do that, but the C# language designers preferred to keep the rules as
    simple as possible.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析分配给变量的所有赋值并从中推断类型，在某些情况下可以避免这些规则。一些语言这样做，但 C# 语言设计者更喜欢将规则保持得尽可能简单。
- en: Another restriction is that `var` can be used for only local variables. Many
    times I’ve longed for implicitly typed fields, but they’re still not available
    (as of C# 7.3, anyway).
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个限制是 `var` 只能用于局部变量。很多时候，我渴望有隐式类型的字段，但它们仍然不可用（至少在 C# 7.3 的情况下）。
- en: 'In the preceding example, there was little benefit, if any, in using `var`.
    The explicit declaration is feasible and just as readable. There are generally
    three reasons for using `var`:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用 `var` 的好处很少，如果有的话，显式声明是可行的，并且同样易于阅读。通常有三个原因使用 `var`：
- en: When the type of the variable can’t be named because it’s anonymous. You’ll
    look at anonymous types in [section 3.4](kindle_split_018_split_000.html#ch03lev1sec4).
    This is the LINQ-related part of the feature.
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当变量的类型无法命名因为它是不具名的。你将在[第 3.4 节](kindle_split_018_split_000.html#ch03lev1sec4)中查看匿名类型。这是该功能的
    LINQ 相关部分。
- en: When the type of the variable has a long name and can easily be inferred by
    a human reader based on the expression used to initialize it.
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当变量的类型有一个长名称，并且可以根据初始化它的表达式很容易地由人类读者推断出来时。
- en: When the *precise* type of the variable isn’t particularly important, and the
    expression used to initialize it gives enough information to anyone reading the
    code.
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当变量的*精确*类型不是特别重要时，并且用于初始化它的表达式为阅读代码的人提供了足够的信息。
- en: 'I’ll save examples of the first bullet point for [section 3.4](kindle_split_018_split_000.html#ch03lev1sec4),
    but it’s easy to show the second. Suppose you want to create a dictionary that
    maps a name to a list of decimal values. You can do that with an explicitly typed
    variable:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 我会将第一个项目符号的示例保存在[第3.4节](kindle_split_018_split_000.html#ch03lev1sec4)中，但第二个示例很容易展示。假设你想创建一个将名称映射到十进制值列表的字典。你可以通过显式类型化的变量来实现这一点：
- en: '[PRE91]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'That’s really ugly. I had to wrap it on two lines just to make it fit on the
    page, and there’s a lot of duplication. That duplication can be entirely avoided
    by using `var`:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很丑陋。我不得不将它分成两行，只是为了让它适合页面，而且有很多重复。这种重复可以通过使用`var`完全避免：
- en: '[PRE92]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This expresses the same amount of information in less text, so there’s less
    to distract you from other code. Of course, this works only when you want the
    type of the variable to be exactly the type of the initialization expression.
    If you wanted the type of the mapping variable to be `IDictionary<string, List<decimal>>`—the
    interface instead of the class—then `var` wouldn’t help. But for local variables,
    that sort of separation between interface and implementation is usually less important.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以以更少的文字表达相同的信息量，因此有更少的内容会分散你对其他代码的注意力。当然，这仅在你想变量的类型与初始化表达式的类型完全一致时才有效。如果你希望映射变量的类型是`IDictionary<string,
    List<decimal>>`——接口而不是类——那么`var`就不会有帮助。但对于局部变量来说，这种接口和实现之间的分离通常不太重要。
- en: When I wrote the first edition of *C# in Depth*, I was wary of implicitly typed
    local variables. I rarely used them outside LINQ, apart from when I was calling
    a constructor directly, as in the preceding example. I was worried that I wouldn’t
    be able to easily work out the type of the variable when just reading the code.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 当我撰写《C# 深入》的第一版时，我对隐式类型化的局部变量持谨慎态度。我很少在LINQ之外使用它们，除了直接调用构造函数的情况，就像前面的例子一样。我担心在阅读代码时无法轻松地确定变量的类型。
- en: Ten years later, that caution has mostly gone. I use `var` for almost all my
    local variables in test code and extensively in production code, too. My fears
    weren’t realized; in almost every case, I’m easily able to infer what the type
    should be just by inspection. Where that isn’t the case, I’ll happily use an explicit
    declaration instead.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 十年后，这种谨慎态度大部分已经消失。我在测试代码中几乎使用`var`来声明所有局部变量，在生产代码中也广泛使用。我的担忧并没有成真；在几乎所有情况下，我都能通过检查轻松地推断出应该是什么类型。在那种情况下，我会高兴地使用显式声明。
- en: I don’t claim to be entirely consistent about this, and I’m certainly not dogmatic.
    Because explicitly typed variables generate the exact same code as implicitly
    typed variables, it’s fine to change your mind later in either direction. I suggest
    you discuss this with the other people who’ll work with your code the most (whether
    those are colleagues or open source collaborators), get a sense of everyone’s
    comfort level, and try to abide by that. The other aspect of implicit typing in
    C# 3 is somewhat different. It’s not directly related to `var`, but it has the
    same aspect of removing a type name to let the compiler infer it.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 我不声称自己在这一点上完全一致，我当然也不是教条主义者。因为显式类型化的变量会生成与隐式类型化的变量完全相同的代码，所以你可以随时改变主意，无论是向哪个方向改变。我建议你与将最多与你合作的其他人（无论是同事还是开源合作者）讨论这个问题，了解每个人的舒适度，并尽量遵守这一点。C#
    3中隐式类型化的另一个方面有些不同。它与`var`没有直接关系，但它有相同的方面，即移除类型名称以让编译器推断它。
- en: 3.2.3\. Implicitly typed arrays
  id: totrans-822
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3. 隐式类型化数组
- en: 'Sometimes you need to create an array without populating it and keep all the
    elements with their default values. The syntax for that hasn’t changed since C#
    1; it’s always something like this:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要创建一个未填充的数组，并保留所有元素及其默认值。自C# 1以来，这种语法的语法没有改变；它总是像这样：
- en: '[PRE93]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'But you often want to create an array with specific initial content. Before
    C# 3, there were two ways of doing this:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 但你通常希望创建一个具有特定初始内容的数组。在C# 3之前，有两种实现方式：
- en: '[PRE94]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The first form of this is valid only when it’s part of a variable declaration
    that specifies the array type. This is invalid, for example:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式仅在它是变量声明的一部分，并指定了数组类型时才有效。例如，这是无效的：
- en: '[PRE95]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* Invalid**'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效**'
- en: 'The second form is always valid, so the second line in the preceding example
    could’ve been as follows:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式始终有效，因此前一个示例中的第二行可以如下所示：
- en: '[PRE96]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'C# 3 introduced a third form in which the type of the array is implicit based
    on the content:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3 引入了一种第三种形式，其中数组的类型基于内容隐式指定：
- en: '[PRE97]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This can be used anywhere, so long as the compiler is able to infer the array
    element type from the array elements specified. It also works with multidimensional
    arrays, as in the following example:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在任何地方使用，只要编译器能够从指定的数组元素中推断出数组元素类型。它也适用于多维数组，如下面的示例所示：
- en: '[PRE98]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The next obvious question is how the compiler infers that type. As is so often
    the case, the *precise* details are complex in order to handle all kinds of corner
    cases, but the simplified sequence of steps is as follows:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个明显的问题是编译器是如何推断出类型的。正如经常发生的那样，为了处理各种边缘情况，精确的细节很复杂，但简化的步骤顺序如下：
- en: Find a set of *candidate types* by considering the type of each array element
    that has a type.
  id: totrans-837
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过考虑具有类型的每个数组元素的类型，找到一组 *候选类型*。
- en: For each candidate type, check whether every array element has an implicit conversion
    to that type. Remove any candidate type that doesn’t meet this condition.
  id: totrans-838
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个候选类型，检查每个数组元素是否可以隐式转换为该类型。删除任何不满足此条件的候选类型。
- en: If there’s exactly one type left, that’s the inferred element type, and the
    compiler creates an appropriate array. Otherwise (if there are no types or more
    than one type left), a compile-time error occurs.
  id: totrans-839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果只剩下一个类型，那么这就是推断出的元素类型，编译器将创建一个适当的数组。否则（如果没有类型或类型超过一个），将发生编译时错误。
- en: The array element type must be the type of one of the expressions in the array
    initializer. There’s no attempt to find a common base class or a commonly implemented
    interface. [Table 3.1](kindle_split_018_split_000.html#ch03table01) gives some
    examples that illustrate the rules.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素类型必须是数组初始化器中某个表达式的类型。没有尝试找到公共基类或公共实现接口。 [表 3.1](kindle_split_018_split_000.html#ch03table01)
    给出了一些说明规则的示例。
- en: Table 3.1\. Examples of type inference for implicitly typed arrays
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.1\. 隐式类型数组的类型推断示例
- en: '| Expression | Result | Notes |'
  id: totrans-842
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 结果 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-843
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| new[] { 10, 20 } | int[] | All elements are of type int. |'
  id: totrans-844
  prefs: []
  type: TYPE_TB
  zh: '| new[] { 10, 20 } | int[] | 所有元素都是 int 类型。|'
- en: '| new[] { null, null } | Error | No elements have types. |'
  id: totrans-845
  prefs: []
  type: TYPE_TB
  zh: '| new[] { null, null } | 错误 | 没有元素具有类型。|'
- en: '| new[] { "xyz", null } | string[] | Only candidate type is string, and the
    null literal can be converted to string. |'
  id: totrans-846
  prefs: []
  type: TYPE_TB
  zh: '| new[] { "xyz", null } | string[] | 只有一个候选类型是 string，并且 null 文字面量可以转换为 string。|'
- en: '| new[] { "abc", new object() } | object[] | Candidate types of string and
    object; implicit conversion from string to object but not vice versa. |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
  zh: '| new[] { "abc", new object() } | object[] | 候选类型为 string 和 object；从 string
    到 object 的隐式转换，但反之则不行。|'
- en: '| new[] { 10, new DateTime() } | Error | Candidate types of int and DateTime
    but no conversion from either to the other. |'
  id: totrans-848
  prefs: []
  type: TYPE_TB
  zh: '| new[] { 10, new DateTime() } | 错误 | 候选类型为 int 和 DateTime，但没有从任一类型到另一类型的转换。|'
- en: '| new[] { 10, null } | Error | Only candidate type is int, but there’s no conversion
    from null to int. |'
  id: totrans-849
  prefs: []
  type: TYPE_TB
  zh: '| new[] { 10, null } | 错误 | 只有一个候选类型是 int，但没有从 null 转换到 int 的转换。|'
- en: Implicitly typed arrays are mostly a convenience to reduce the source code required
    except for anonymous types, where the array type can’t be stated explicitly even
    if you want to. Even so, they’re a convenience I’d definitely miss now if I had
    to work without them.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型的数组主要是为了减少源代码的需要而提供便利，除了匿名类型，即使你想显式地声明数组类型，也无法这样做。即便如此，如果我现在不得不在没有它们的情况下工作，我肯定会怀念这种便利。
- en: The next feature continues the theme of making it simpler to create and initialize
    objects, but in a different way.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个特性继续了使创建和初始化对象更简单的主题，但以不同的方式。
- en: 3.3\. Object and collection initializers
  id: totrans-852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 对象和集合初始化器
- en: '*Object initializers* and *collection initializers* make it easy to create
    new objects or collections with initial values, just as you can create and populate
    an array in a single expression. This functionality is important for LINQ because
    of the way queries are translated, but it turns out to be extremely useful elsewhere,
    too. It does require types to be mutable, which can be annoying if you’re trying
    to write code in a functional style, but where you *can* apply it, it’s great.
    Let’s look at a simple example before diving into the details.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象初始化器*和*集合初始化器*使得创建具有初始值的新对象或集合变得简单，就像您可以在单个表达式中创建和填充数组一样。这种功能对于LINQ来说很重要，因为查询的翻译方式，但它也证明在其他地方也非常有用。它确实要求类型是可变的，如果您试图以函数式风格编写代码，这可能会很烦人，但您可以在适用的地方使用它，它就很好。在深入细节之前，让我们看看一个简单的例子。'
- en: 3.3.1\. Introduction to object and collection initializers
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 对象和集合初始化器简介
- en: As a *massively* oversimplified example, let’s consider what an order in an
    e-commerce system might look like. The following listing shows three classes to
    model an order, a customer, and a single item within an order.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简化的例子，让我们考虑电子商务系统中的一个订单可能看起来是什么样子。下面的列表显示了三个类来模拟订单、客户以及订单中的单个项目。
- en: Listing 3.1\. Modeling an order in an e-commerce system
  id: totrans-856
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. 在电子商务系统中建模订单
- en: '[PRE99]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How do you create an order? Well, you need to create an instance of `Order`
    and assign to its `OrderId` and `Customer` properties. You can’t assign to the
    `Items` property, because it’s read-only. Instead, you can add items to the list
    it returns. The following listing shows how you might do this if you didn’t have
    object and collection initializers and couldn’t change the classes to make things
    simpler.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何创建一个订单？嗯，您需要创建一个`Order`实例，并将其`OrderId`和`Customer`属性赋值。您不能赋值给`Items`属性，因为它只读。相反，您可以向它返回的列表中添加项目。下面的列表显示了如果您没有对象和集合初始化器，并且无法更改类以简化事物，您可能会如何做。
- en: Listing 3.2\. Creating and populating an order without object and collection
    initializers
  id: totrans-859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.2\. 没有对象和集合初始化器创建和填充订单
- en: '[PRE100]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '***1* Creates the Customer**'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建客户**'
- en: '***2* Creates the first OrderItem**'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建第一个OrderItem**'
- en: '***3* Creates the second OrderItem**'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建第二个OrderItem**'
- en: '***4* Creates the order**'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建订单**'
- en: This code could be simplified by adding constructors to the various classes
    to initialize properties based on the parameters. Even with object and collection
    initializers available, that’s what I’d do. But for the sake of brevity, I’m going
    to ask you to trust me that it’s not always feasible, for all kinds of reasons.
    Aside from anything else, you don’t always control the code for the classes you’re
    using. Object and collection initializers make it much simpler to create and populate
    our order, as shown in the following listing.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以通过为各种类添加构造函数来简化，以便根据参数初始化属性。即使有对象和集合初始化器可用，我也会这样做。但为了简洁起见，我将要求您相信，出于各种原因，这并不总是可行的。除此之外，您并不总是控制您所使用的类的代码。对象和集合初始化器使得创建和填充我们的订单变得简单得多，如下面的列表所示。
- en: Listing 3.3\. Creating and populating an order with object and collection initializers
  id: totrans-866
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3\. 使用对象和集合初始化器创建和填充订单
- en: '[PRE101]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: I can’t speak for everyone, but I find [listing 3.3](kindle_split_018_split_000.html#ch03ex03)
    much more readable than [listing 3.2](kindle_split_018_split_000.html#ch03ex02).
    The structure of the object becomes apparent in the indentation, and less repetition
    occurs. Let’s look more closely at each part of the code.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能代表所有人，但我发现[列表3.3](kindle_split_018_split_000.html#ch03ex03)比[列表3.2](kindle_split_018_split_000.html#ch03ex02)更容易阅读。对象的结构在缩进中变得明显，重复出现的次数也减少了。让我们更仔细地看看代码的每一部分。
- en: 3.3.2\. Object initializers
  id: totrans-869
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 对象初始化器
- en: Syntactically, an object initializer is a sequence of *member initializers*
    within braces. Each member initializer is of the form `property = initializer-value`,
    where `property` is the name of the field or property being initialized and `initializer-value`
    is an expression, a collection initializer, or another object initializer.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 语法上，对象初始化器是一系列在大括号内的*成员初始化器*。每个成员初始化器具有`property = initializer-value`的形式，其中`property`是要初始化的字段或属性的名称，而`initializer-value`是一个表达式、一个集合初始化器或另一个对象初始化器。
- en: '|  |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-872
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Object initializers are most commonly used with properties, and that’s how
    I’ve described them in this chapter. Fields don’t have accessors, but the obvious
    equivalents apply: reading the field instead of calling a get accessor and writing
    the field instead of calling a set accessor.'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化器通常与属性一起使用，这就是我在本章中描述它们的方式。字段没有访问器，但显然的等效操作适用：读取字段而不是调用获取访问器，以及写入字段而不是调用设置访问器。
- en: '|  |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Object initializers can be used only as part of a constructor call or another
    object initializer. The constructor call can specify arguments as usual, but if
    you don’t want to specify any arguments, you don’t need an argument list at all,
    so you can omit the `()`. A constructor call without an argument list is equivalent
    to supplying an empty argument list. For example, these two lines are equivalent:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化器只能作为构造函数调用或另一个对象初始化器的一部分使用。构造函数调用可以像往常一样指定参数，但如果你不想指定任何参数，你根本不需要参数列表，因此你可以省略
    `()`。没有参数列表的构造函数调用等同于提供一个空参数列表。例如，这两行是等效的：
- en: '[PRE102]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You can omit the constructor argument list only if you provide an object or
    collection initializer. This is invalid:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在提供对象或集合初始化器的情况下，你才能省略构造函数参数列表。这是无效的：
- en: '[PRE103]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '***1* Invalid**'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效**'
- en: An object initializer simply says how to initialize each of the properties it
    mentions in its member initializers. If the `initializer-value` part (the part
    to the right of the `=` sign) is a normal expression, that expression is evaluated,
    and the value is passed to the property set accessor. That’s how most of the object
    initializers in [listing 3.3](kindle_split_018_split_000.html#ch03ex03) work.
    The `Items` property uses a *collection initializer*, which you’ll see shortly.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化器只是说明了如何初始化它在成员初始化器中提到的每个属性。如果 `initializer-value` 部分（等号右侧的部分）是一个正常表达式，则该表达式将被评估，并将值传递给属性设置访问器。这就是
    [列表 3.3](kindle_split_018_split_000.html#ch03ex03) 中的大多数对象初始化器工作的方式。`Items` 属性使用了一个
    *集合初始化器*，你很快就会看到。
- en: If `initializer-value` is another object initializer, the set accessor is never
    called. Instead, the get accessor is called, and then the nested object initializer
    is applied to the value returned by the property. As an example, [listing 3.4](kindle_split_018_split_000.html#ch03ex04)
    creates an `HttpClient` and modifies the set of default headers that are sent
    with each request. The code sets the `From` and `Date` headers, which I chose
    only because they’re the simplest ones to set.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `initializer-value` 是另一个对象初始化器，则设置访问器永远不会被调用。相反，将调用获取访问器，然后嵌套对象初始化器应用于属性返回的值。例如，[列表
    3.4](kindle_split_018_split_000.html#ch03ex04) 创建了一个 `HttpClient` 并修改了每个请求发送的默认头信息集合。代码设置了
    `From` 和 `Date` 头信息，我之所以选择它们，仅仅是因为它们是最简单的设置。
- en: Listing 3.4\. Modifying default headers on a new `HttpClient` with a nested
    object initializer
  id: totrans-882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. 使用嵌套对象初始化器修改新 `HttpClient` 的默认头信息
- en: '[PRE104]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '***1* Property get accessor called for DefaultRequestHeaders**'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用 DefaultRequestHeaders 属性获取访问器**'
- en: '***2* Property set accessor called for From**'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用 From 属性设置访问器**'
- en: '***3* Property set accessor called for Date**'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用日期属性设置访问器**'
- en: 'The code in [listing 3.4](kindle_split_018_split_000.html#ch03ex04) is equivalent
    to the following code:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.4](kindle_split_018_split_000.html#ch03ex04) 中的代码等同于以下代码：'
- en: '[PRE105]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: A single object initializer can include a mixture of nested object initializers,
    collection initializers, and normal expressions in the sequence of member initializers.
    Speaking of collection initializers, let’s look at those now.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 单个对象初始化器可以在成员初始化器的序列中包含嵌套对象初始化器、集合初始化器和正常表达式的混合。说到集合初始化器，让我们现在看看它们。
- en: 3.3.3\. Collection initializers
  id: totrans-890
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 集合初始化器
- en: 'Syntactically, a collection initializer is a comma-separated list of *element
    initializers* in curly braces. Each element initializer is either a single expression
    or a comma-separated list of expressions also in curly braces. Collection initializers
    can be used only as part of a constructor call or part of an object initializer.
    Further restrictions exist on the types they can be used with, which we’ll come
    to shortly. In [listing 3.3](kindle_split_018_split_000.html#ch03ex03), you saw
    a collection initializer being used as part of an object initializer. Here’s the
    listing again with the collection initializer highlighted in bold:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 语法上，集合初始化器是花括号内逗号分隔的 *元素初始化器* 列表。每个元素初始化器要么是一个单独的表达式，要么是花括号内逗号分隔的表达式列表。集合初始化器只能作为构造函数调用或对象初始化器的一部分使用。它们可以使用的类型存在进一步的限制，我们将在稍后讨论。在
    [列表 3.3](kindle_split_018_split_000.html#ch03ex03) 中，你看到了集合初始化器作为对象初始化器的一部分的使用。以下是带有集合初始化器加粗的列表：
- en: '[PRE106]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Collection initializers might be more commonly used when creating new collections,
    though. For example, this line declares a new variable for a list of strings and
    populates the list:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新集合时，集合初始化器可能更常用。例如，此行声明了一个字符串列表的新变量并填充了列表：
- en: '[PRE107]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The compiler compiles that into a constructor call followed by a sequence of
    calls to an `Add` method:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将其编译为一个构造函数调用，后跟一系列对 `Add` 方法的调用：
- en: '[PRE108]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'But what if the collection type you’re using doesn’t have an `Add` method with
    a single parameter? That’s where element initializers with braces come in. After
    `List<T>`, the second most common generic collection is probably `Dictionary<TKey,
    TValue>` with an `Add(key, value)` method. A dictionary can be populated with
    a collection initializer like this:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你使用的集合类型没有带单个参数的 `Add` 方法呢？这就是花括号内元素初始化器发挥作用的地方。在 `List<T>` 之后，第二常见的通用集合可能是带有
    `Add(key, value)` 方法的 `Dictionary<TKey, TValue>`。可以使用如下方式使用集合初始化器来填充字典：
- en: '[PRE109]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The compiler treats each element initializer as a separate `Add` call. If the
    element initializer is a simple one without braces, the value is passed as a single
    argument to `Add`. That’s what happened for the elements in our `List<string>`
    collection initializer.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将每个元素初始化器视为单独的 `Add` 调用。如果元素初始化器是一个没有花括号的简单表达式，则值作为单个参数传递给 `Add`。这就是我们 `List<string>`
    集合初始化器中的元素所发生的情况。
- en: 'If the element initializer uses braces, it’s still treated as a single call
    to `Add`, but with one argument for each expression within the braces. The preceding
    dictionary example is effectively equivalent to this:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素初始化器使用了花括号，它仍然被视为对 `Add` 的单个调用，但每个花括号内的表达式都有一个参数。前面的字典示例实际上等同于以下内容：
- en: '[PRE110]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Overload resolution then proceeds as normal to find the most appropriate `Add`
    method, including performing type inference if there are any generic `Add` methods.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行重载解析，以找到最合适的 `Add` 方法，包括如果有任何泛型 `Add` 方法，则执行类型推断。
- en: 'Collection initializers are valid only for types that implement `IEnumerable`,
    although they don’t have to implement `IEnumerable<T>`. The language designers
    looked at the types in the framework that had `Add` methods and determined that
    the best way of separating them into collections and noncollections was to look
    at whether they implemented `IEnumerable`. As an example of why that’s important,
    consider the `DateTime.Add(TimeSpan)` method. The `DateTime` type clearly isn’t
    a collection, so it’d be odd to be able to write this:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 集合初始化器仅适用于实现 `IEnumerable` 的类型，尽管它们不必实现 `IEnumerable<T>`。语言设计者检查了具有 `Add` 方法的框架中的类型，并确定将它们分为集合和非集合的最佳方式是查看它们是否实现了
    `IEnumerable`。作为一个为什么这很重要的例子，考虑 `DateTime.Add(TimeSpan)` 方法。显然，`DateTime` 类型不是一个集合，所以能够编写如下代码会很奇怪：
- en: '[PRE111]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '***1* Invalid**'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效**'
- en: The compiler never uses the implementation of `IEnumerable` when compiling a
    collection initializer. I’ve sometimes found it convenient to create types in
    test projects with `Add` methods and an implementation of `IEnumerable` that just
    throws a `NotImplementedException`. This can be useful for constructing test data,
    but I don’t advise doing it in production code. I’d appreciate an attribute that
    let me express the idea that this type should be usable for collection initializers
    without implementing `IEnumerable`, but I doubt that’ll ever happen.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在编译集合初始化器时永远不会使用`IEnumerable`的实现。我有时发现，在测试项目中使用具有`Add`方法和仅抛出`NotImplementedException`的`IEnumerable`实现的类型很方便。这可以用于构建测试数据，但我不建议在生产代码中这样做。我会很感激有一个属性可以让我表达这个想法，即这个类型应该可用于集合初始化器而不需要实现`IEnumerable`，但我怀疑这永远不会发生。
- en: 3.3.4\. The benefits of single expressions for initialization
  id: totrans-907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4. 初始化的单个表达式的优势
- en: You may be wondering what all of this has to do with LINQ. I said that almost
    all the features in C# 3 built up to LINQ, so how do object and collection initializers
    fit into the picture? The answer is that other LINQ features require code to be
    expressible as a single expression. (For example, in a query expression, you can’t
    write a `select` clause that requires multiple statements to produce the output
    for a given input.)
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道所有这些与LINQ有什么关系。我说C# 3中的几乎所有特性都是为了构建LINQ，那么对象和集合初始化器是如何融入这个图景的呢？答案是，其他LINQ特性要求代码可以表示为单个表达式。（例如，在查询表达式中，你不能编写一个需要多个语句来生成给定输入输出的`select`子句。）
- en: The ability to initialize new objects in a single expression isn’t useful only
    for LINQ, however. It can also be important to simplify field initializers, method
    arguments, or even the operands in a conditional `?:` operator. I find it particularly
    useful for static field initializers to build up useful lookup tables, for example.
    Of course, the larger the initialization expression becomes, the more you may
    want to consider separating it out.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个表达式中初始化新对象的能力不仅对LINQ有用。它还可以简化字段初始化、方法参数，甚至条件`?:`运算符中的操作数。我发现它特别适用于静态字段初始化，例如构建有用的查找表。当然，初始化表达式越大，你可能就越想考虑将其分离出来。
- en: It’s even recursively important to the feature itself. For example, if we couldn’t
    use an object initializer to create our `OrderItem` objects, the collection initializer
    wouldn’t be nearly as convenient to populate the `Order.Items` property.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至对特性本身也是递归重要的。例如，如果我们不能使用对象初始化器来创建我们的`OrderItem`对象，集合初始化器在填充`Order.Items`属性时就不会那么方便。
- en: In the rest of this book, whenever I refer to a new or improved feature as having
    a special case for a single expression (such as lambda expressions in [section
    3.5](kindle_split_018_split_000.html#ch03lev1sec5) or expression-bodied members
    in [section 8.3](kindle_split_024_split_000.html#ch08lev1sec3)), it’s worth remembering
    that object and collection initializers immediately make that feature more useful
    than it’d be otherwise.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，每当提到一个新特性或改进特性具有针对单个表达式的特殊情况（例如，[第3.5节](kindle_split_018_split_000.html#ch03lev1sec5)中的lambda表达式或[第8.3节](kindle_split_024_split_000.html#ch08lev1sec3)中的表达式主体成员）时，值得记住的是，对象和集合初始化器立即使该特性比其他情况下更有用。
- en: Object and collection initializers allow for more concise code to create an
    instance of a type and populate it, but they do require that you already have
    an appropriate type to construct. Our next feature, anonymous types, allows you
    to create objects without even declaring the type of the object beforehand. It’s
    not *quite* as strange as it sounds.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和集合初始化器允许编写更简洁的代码来创建类型的实例并填充它，但它们确实要求你已经有一个合适的类型来构造。我们的下一个特性，匿名类型，允许你创建对象，甚至不需要事先声明对象的类型。这听起来可能有些奇怪，但并不像听起来那么奇怪。
- en: 3.4\. Anonymous types
  id: totrans-913
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 匿名类型
- en: Anonymous types allow you to build objects that you can refer to in a statically
    typed way without having to declare a type beforehand. This sounds like types
    might be created dynamically at execution time, but the reality is a little more
    subtle than that. We’ll look at what anonymous types look like in source code,
    how the compiler handles them, and a few of their limitations.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型允许你在不事先声明类型的情况下，以静态类型方式引用对象。这听起来像类型可能在执行时动态创建，但实际情况要微妙得多。我们将探讨匿名类型在源代码中的样子，编译器如何处理它们，以及它们的一些限制。
- en: 3.4.1\. Syntax and basic behavior
  id: totrans-915
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1. 语法和基本行为
- en: The simplest way to explain anonymous types is to start with an example. The
    following listing shows a simple piece of code to create an object with `Name`
    and `Score` properties.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 解释匿名类型的简单方法是从一个例子开始。以下列表显示了一段创建具有 `Name` 和 `Score` 属性的对象的简单代码。
- en: Listing 3.5\. Anonymous type with `Name` and `Score` properties
  id: totrans-917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5\. 带有 `Name` 和 `Score` 属性的匿名类型
- en: '[PRE112]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '***1* Creates an object of an anonymous type with Name and Score properties**'
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建具有名称和分数属性的匿名类型对象**'
- en: '***2* Displays the property values**'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示属性值**'
- en: 'This brief example demonstrates important points about anonymous types:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的例子展示了关于匿名类型的重要观点：
- en: The syntax is a little like object initializers but without specifying a type
    name; it’s just `new`, open brace, properties, close brace. This is called an
    *anonymous object creation expression*. The property values can be nested anonymous
    object creation expressions.
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法有点像对象初始化器，但没有指定类型名称；只是 `new`，开括号，属性，闭括号。这被称为 *匿名对象创建表达式*。属性值可以是嵌套的匿名对象创建表达式。
- en: You’re using `var` for the declaration of the `player` variable, because the
    type has no name for you to use instead of `var`. (The declaration would work
    if you used `object` instead, but it wouldn’t be nearly as useful.)
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用 `var` 来声明 `player` 变量，因为类型没有为你提供替代 `var` 的名称。（如果你使用 `object`，声明将有效，但几乎没什么用。）
- en: This code is still statically typed. Visual Studio can autocomplete the `Name`
    and `Score` properties of the `player` variable. If you ignore that and try to
    access a property that doesn’t exist (if you try to use `player.Points`, for example),
    the compiler will raise an error. The property types are inferred from the values
    assigned to them; `player.Name` is a `string` property, and `player.Score` is
    an `int` property.
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码仍然是静态类型的。Visual Studio 可以自动完成 `player` 变量的 `Name` 和 `Score` 属性。如果你忽略这一点并尝试访问一个不存在的属性（例如尝试使用
    `player.Points`），编译器将引发错误。属性类型是从分配给它们的值推断出来的；`player.Name` 是一个 `string` 属性，而 `player.Score`
    是一个 `int` 属性。
- en: That’s what anonymous types look like, but what are they used for? This is where
    LINQ comes in. When performing a query, whether that’s using an SQL database as
    the underlying data store or using a collection of objects, it’s common to want
    a specific shape of data that isn’t the original type and may not have much meaning
    outside the query.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是匿名类型的样子，但它们是用来做什么的呢？这就是 LINQ 发挥作用的地方。在执行查询时，无论是使用 SQL 数据库作为底层数据存储还是使用对象集合，通常都希望得到一个特定形状的数据，而不是原始类型，并且可能在外部查询中意义不大。
- en: 'For example, suppose you’re building a query using a set of people, each of
    which has expressed a favorite color. You might want the result to be a histogram:
    each entry in the resulting collection is the color and the number of people who
    chose that as their favorite. That type representing a favorite color and type
    isn’t likely to be useful anywhere else, but it is useful in this specific context.
    Anonymous types allow us to express those one-off cases concisely without losing
    the benefits of static typing.'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在使用一组表示各自表达过最喜欢的颜色的人来构建一个查询。你可能希望结果是一个直方图：结果集合中的每个条目都是颜色和选择该颜色作为他们最喜欢的颜色的人数。这种表示最喜欢的颜色和类型的类型可能在其他地方不太有用，但在这种特定上下文中很有用。匿名类型允许我们简洁地表达这些一次性情况，同时不失静态类型的好处。
- en: '|  |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Comparison with Java anonymous classes**'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '**与 Java 匿名类的比较**'
- en: If you’re familiar with Java, you may be wondering about the relationship between
    C#’s anonymous types and Java’s anonymous classes. They sound like they’d be similar,
    but they differ greatly both in syntax and purpose.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Java，你可能想知道 C# 的匿名类型和 Java 的匿名类之间的关系。它们听起来可能很相似，但在语法和目的上都有很大的不同。
- en: Historically, the principal use for anonymous classes in Java was to implement
    interfaces or extend abstract classes to override just one or two methods. C#’s
    anonymous types don’t allow you to implement an interface or derive from any class
    other than `System.Object`; their purpose is much more about data than executable
    code.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，Java 中匿名类的主要用途是实现接口或扩展抽象类以覆盖一个或两个方法。C# 的匿名类型不允许你实现接口或从 `System.Object`
    之外的其他类派生；它们的目的更多的是关于数据而不是可执行代码。
- en: '|  |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'C# provides one extra piece of shorthand in anonymous object creation expressions
    where you’re effectively copying a property or field from somewhere else and you’re
    happy to use the same name. This syntax is called a *projection initializer*.
    To give an example, let’s go back to our simplified e-commerce data model. You
    have three classes:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: C# 在匿名对象创建表达式中提供了一种额外的简写方式，当你从其他地方复制属性或字段，并且愿意使用相同的名称时。这种语法称为*投影初始化器*。为了举例说明，让我们回到我们简化的电子商务数据模型。你有三个类：
- en: '`Order`—`OrderId`, `Customer`, `Items`'
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Order`—`OrderId`, `Customer`, `Items`'
- en: '`Customer`—`Name`, `Address`'
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Customer`—`Name`, `Address`'
- en: '`OrderItem`—`ItemId`, `Quantity`'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderItem`—`ItemId`, `Quantity`'
- en: 'At some point in your code, you may want an object with all this information
    for a specific order item. If you have variables of the relevant types called
    `order`, `customer`, and `item`, you can easily use an anonymous type to represent
    the flattened information:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码的某个地方，你可能想要一个包含所有这些信息的特定订单项的对象。如果你有名为`order`、`customer`和`item`的相关类型的变量，你可以轻松地使用匿名类型来表示扁平化的信息：
- en: '[PRE113]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In this example, every property except `CustomerName` uses a projection initializer.
    The result is identical to this code, which specifies the property names in the
    anonymous type explicitly:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，除了`CustomerName`属性外，每个属性都使用了投影初始化器。结果是等同于以下代码，它明确指定了匿名类型中的属性名称：
- en: '[PRE114]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Projection initializers are most useful when you’re either performing a query
    and want to select only a subset of properties or to combine properties from multiple
    objects into one. If the name you want to give the property in the anonymous type
    is the same as the name of the field or property you’re copying from, the compiler
    can infer that name for you. So instead of writing this
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 投影初始化器在你执行查询并只想选择属性子集或从多个对象中合并属性到一个对象时最有用。如果你想要在匿名类型中给属性取的名称与你要复制的字段或属性的名称相同，编译器可以为你推断出这个名称。所以你不需要写这个
- en: '[PRE115]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'you can just write this:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地写这个：
- en: '[PRE116]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Projection initializers can significantly reduce the amount of duplication in
    your source code if you’re copying multiple properties. It can easily make the
    difference between an expression being short enough to keep on one line or long
    enough to merit a separate line per property.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在复制多个属性，投影初始化器可以显著减少你的源代码中的重复。它可以使表达式足够短，可以保持在同一行，或者足够长，值得为每个属性单独一行。
- en: '|  |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Refactoring and projection initializers**'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构和投影初始化器**'
- en: Although it’s accurate to say that the results of the two preceding listings
    are the same, that doesn’t mean they behave identically in other ways. Consider
    a rename of the `Address` property to `CustomerAddress`.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以说前两个列表的结果是相同的，但这并不意味着它们在其他方面表现相同。考虑将`Address`属性重命名为`CustomerAddress`。
- en: In the version with projection initializers, the property name in the anonymous
    type would change too. In the version with the explicit property name, it wouldn’t.
    That’s rarely an issue in my experience, but it’s worth being aware of as a difference.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用投影初始化器的版本中，匿名类型中的属性名称也会改变。在显式属性名称的版本中，则不会。在我的经验中，这很少成为问题，但了解这种差异是值得的。
- en: '|  |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: I’ve described the syntax of anonymous types, and you know the resulting objects
    have properties you can use as if they were normal types. But what’s going on
    behind the scenes?
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经描述了匿名类型的语法，你知道生成的对象具有你可以像使用普通类型一样使用的属性。但是幕后发生了什么？
- en: 3.4.2\. The compiler-generated type
  id: totrans-951
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 编译器生成的类型
- en: 'Although the type never appears in source code, the compiler does generate
    a type. There’s no magic for the runtime to contend with; it just sees a type
    that happens to have a name that would be invalid in C#. That type has a few interesting
    aspects to it. Some are guaranteed by the specification; others aren’t. When using
    the Microsoft C# compiler, an anonymous type has the following characteristics:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该类型从未出现在源代码中，编译器确实生成了一个类型。运行时没有魔法要处理；它只是看到了一个恰好具有在C#中无效名称的类型。这个类型有几个有趣的特点。其中一些由规范保证；其他则不是。当使用Microsoft
    C#编译器时，匿名类型具有以下特性：
- en: It’s a class (guaranteed).
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个类（保证）。
- en: Its base class is `object` (guaranteed).
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的基类是`object`（保证）。
- en: It’s sealed (not guaranteed, although it would be hard to see how it would be
    useful to make it unsealed).
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是密封的（虽然不保证，但很难想象使其非密封会有什么用）。
- en: The properties are all read-only (guaranteed).
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性都是只读的（保证）。
- en: The constructor parameters have the same names as the properties (not guaranteed;
    can be useful for reflection occasionally).
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数参数的名称与属性相同（不保证；偶尔对反射可能有用）。
- en: It’s internal to the assembly (not guaranteed; can be irritating when working
    with dynamic typing).
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是程序集内部的（不保证；在处理动态类型时可能会很烦人）。
- en: It overrides `GetHashCode()` and `Equals()` so that two instances are equal
    only if all their properties are equal. (It handles properties being null.) The
    fact that these methods are overridden is guaranteed, but the precise way of computing
    the hash code isn’t.
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它重写了`GetHashCode()`和`Equals()`方法，使得只有当两个实例的所有属性都相等时，它们才被认为是相等的。（它处理了属性为null的情况。）这些方法被重写是保证的，但计算哈希码的确切方式并没有保证。
- en: It overrides `ToString()` in a helpful way and lists the property names and
    their values. This isn’t guaranteed, but it is super helpful when diagnosing issues.
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以有帮助的方式重写了`ToString()`方法，并列出了属性名称及其值。这并不是保证的，但在诊断问题时非常有帮助。
- en: The type is generic with one type parameter for each property. Multiple anonymous
    types with the same property names but different property types will use different
    type arguments for the same generic type. This isn’t guaranteed and could easily
    vary by compiler.
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型是泛型的，每个属性有一个类型参数。具有相同属性名称但不同属性类型的多个匿名类型将使用不同的类型参数来表示相同的泛型类型。这并不保证，并且可能会根据编译器而容易变化。
- en: If two anonymous object creation expressions use the same property names in
    the same order with the same property types in the same assembly, the result is
    guaranteed to be two objects of the same type.
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个匿名对象创建表达式在同一个程序集中使用相同的属性名称、相同的顺序和相同的属性类型，那么结果保证是相同类型的两个对象。
- en: 'The last point is important for variable reassignment and for implicitly typed
    arrays using anonymous types. In my experience, it’s relatively rare that you
    want to reassign a variable initialized with an anonymous type, but it’s nice
    that it’s feasible. For example, this is entirely valid:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点对于变量重新赋值和使用匿名类型隐式数组的数组非常重要。根据我的经验，你很少想要重新赋值一个用匿名类型初始化的变量，但很高兴它可行。例如，这完全是有效的：
- en: '[PRE117]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Likewise, it’s fine to create an array by using anonymous types using the implicitly
    typed array syntax described in [section 3.2.3](kindle_split_018_split_000.html#ch03lev2sec3):'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用[第3.2.3节](kindle_split_018_split_000.html#ch03lev2sec3)中描述的隐式数组语法创建匿名类型数组是完全可以的：
- en: '[PRE118]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Note that the properties must have the same names and types and be in the same
    order for two anonymous object creation expressions to use the same type. For
    example, this would be invalid because the order of properties in the second array
    element is different from the others:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使两个匿名对象创建表达式使用相同的类型，属性必须具有相同的名称和类型，并且顺序相同。例如，这将是无效的，因为第二个数组元素中属性的顺序与其他元素不同：
- en: '[PRE119]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Although each array element is valid individually, the type of the second element
    stops the compiler from inferring the array type. The same would be true if you
    added an extra property or changed the type of one of the properties.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个数组元素单独都是有效的，但第二个元素的类型阻止了编译器推断数组类型。如果你添加一个额外的属性或更改某个属性的类型，情况也会相同。
- en: Although anonymous types are useful within LINQ, that doesn’t make this feature
    the right tool for every problem. Let’s look briefly at places you may not want
    to use them.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然匿名类型在LINQ中很有用，但这并不意味着这个特性是每个问题的正确工具。让我们简要地看看你可能不想使用它们的地方。
- en: 3.4.3\. Limitations
  id: totrans-971
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3. 限制
- en: Anonymous types are great when you want a localized representation of just data.
    By *localized*, I mean that the data shape you’re interested in is relevant only
    within that specific method. As soon as you want to represent the same shape in
    multiple places, you need to look for a different solution. Although it’s possible
    to return instances of anonymous types from methods or accept them as parameters,
    you can do so only by using either generics or the `object` type. The fact that
    the types are anonymous prevents you from expressing them in method signatures.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想对数据进行本地化表示时，匿名类型非常出色。通过“本地化”，我的意思是，你感兴趣的数据形状仅在特定方法内相关。一旦你想要在多个地方表示相同的形状，你就需要寻找不同的解决方案。虽然可以从方法中返回匿名类型的实例或作为参数接受它们，但你只能通过使用泛型或`object`类型来实现。类型是匿名的，这阻止你在方法签名中表达它们。
- en: Until C# 7, if you wanted to use a common data structure in more than one method,
    you’d normally declare your own class or struct for it. C# 7 has introduced tuples,
    as you’ll see in [chapter 11](kindle_split_028_split_000.html#ch11), which can
    work as an alternative solution, depending on how much encapsulation you desire.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 C# 7，如果你想在多个方法中使用公共数据结构，你通常需要为它声明自己的类或结构。C# 7 引入了元组，正如你将在 [第 11 章](kindle_split_028_split_000.html#ch11)
    中看到的，它可以作为一个替代解决方案，具体取决于你想要的封装程度。
- en: Speaking of encapsulation, anonymous types basically don’t provide any. You
    can’t place any validation in the type or add extra behavior to it. If you find
    yourself wanting to do so, that’s a good indication that you should probably be
    creating your own type instead.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 说到封装，匿名类型基本上不提供任何封装。你无法在类型中放置任何验证或为其添加额外的行为。如果你发现自己想要这样做，那可能是一个很好的迹象，表明你可能应该创建自己的类型。
- en: Finally, I mentioned earlier that using anonymous types across assemblies via
    C# 4’s dynamic typing is made more difficult because the types are internal. I’ve
    usually seen this attempted in MVC web applications where the model for a page
    may be built using anonymous types and then accessed in the view using the `dynamic`
    type (which you’ll look at in [chapter 4](kindle_split_019_split_000.html#ch04)).
    This works if either the two pieces of code are in the same assembly or the assembly
    containing the model code has made its internal members visible to the assembly
    containing the view code using `[InternalsVisibleTo]`. Depending on the framework
    you’re using, it may be awkward to arrange for either of these to be true. Given
    the benefits of static typing anyway, I generally recommend declaring the model
    as a regular type instead. It’s more up-front work than using an anonymous type
    but is likely to save you time in the long term.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我之前提到，由于类型是内部的，通过 C# 4 的动态类型在程序集之间使用匿名类型变得更加困难。我通常在 MVC 网络应用程序中看到这种尝试，其中页面的模型可能使用匿名类型构建，然后在视图中使用
    `dynamic` 类型（你将在 [第 4 章](kindle_split_019_split_000.html#ch04) 中了解）进行访问。如果这两段代码在同一个程序集中，或者包含模型代码的程序集已经使用
    `[InternalsVisibleTo]` 使其内部成员对包含视图代码的程序集可见，那么这就可以工作。根据你使用的框架，安排这两者中的任何一个可能都有些棘手。鉴于静态类型的好处，我通常建议将模型声明为常规类型。这比使用匿名类型需要更多的工作，但可能会在长期内节省你的时间。
- en: '|  |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Visual Basic has anonymous types too, but they don’t behave in quite the same
    way. In C#, all properties are used in determining equality and hash codes, and
    they’re all read-only. In VB, only properties declared with the `Key` modifier
    behave like that. Nonkey properties are read/write and don’t affect equality or
    hash codes.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Basic 也有匿名类型，但它们的行为并不完全相同。在 C# 中，所有属性都用于确定相等性和哈希码，并且它们都是只读的。在 VB 中，只有使用
    `Key` 修饰符声明的属性才具有这种行为。非键属性是可读/写的，并且不影响相等性或哈希码。
- en: '|  |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We’re about halfway through the C# 3 features, and so far they’ve all had to
    do with data. The next features focus more on executable code, first with lambda
    expressions and then extension methods.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 C# 3 特性的大约一半，到目前为止，它们都与数据有关。接下来的特性更多地关注可执行代码，首先是 lambda 表达式，然后是扩展方法。
- en: 3.5\. Lambda expressions
  id: totrans-981
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. Lambda 表达式
- en: 'In [chapter 2](kindle_split_017_split_000.html#ch02), you saw how anonymous
    methods made it much easier to create delegate instances by including their code
    inline like this:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](kindle_split_017_split_000.html#ch02) 中，你看到了如何通过像这样内联包含它们的代码来使创建委托实例变得容易得多：
- en: '[PRE120]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '***1* Creates delegate using an anonymous method**'
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用匿名方法创建委托**'
- en: '***2* Invokes the delegate**'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用委托**'
- en: '*Lambda expressions* were introduced in C# 3 to make this even more concise.
    The term *anonymous function* is used to refer to both anonymous methods and lambda
    expressions. I’ll use it at various points in the rest of this book, and it’s
    widely used in the C# specification.'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda 表达式* 在 C# 3 中引入，以使其更加简洁。术语 *匿名函数* 用于指代匿名方法和 lambda 表达式。我将在本书的其余部分中多次使用它，并且在
    C# 规范中广泛使用。'
- en: '|  |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-988
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The name *lambda expressions* comes from lambda calculus, a field of mathematics
    and computer science started by Alonzo Church in the 1930s. Church used the Greek
    lambda character (λ) in his notation for functions, and the name stuck.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: “Lambda 表达式”这个名字来源于 lambda 演算，这是由 Alonzo Church 在 1930 年代开创的数学和计算机科学领域。Church
    在他的函数表示法中使用了希腊字母 lambda（λ），这个名字就留了下来。
- en: '|  |'
  id: totrans-990
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: There are various reasons that it was useful for the language designers to put
    so much effort into streamlining delegate instance creation, but LINQ is the most
    important one. When you look at query expressions in [section 3.7](kindle_split_018_split_000.html#ch03lev1sec7),
    you’ll see that they’re effectively translated into code that uses lambda expressions.
    You can use LINQ without using query expressions, though, and that almost always
    involves using lambda expressions directly in your source code.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多原因使得语言设计者投入大量精力来简化委托实例的创建是有用的，但 LINQ 是最重要的一个。当你查看 [第 3.7 节](kindle_split_018_split_000.html#ch03lev1sec7)
    中的查询表达式时，你会发现它们实际上被转换成了使用 lambda 表达式的代码。尽管如此，你也可以不使用查询表达式来使用 LINQ，而这几乎总是涉及到在你的源代码中直接使用
    lambda 表达式。
- en: First, we’ll look at the syntax for lambda expressions and then some of the
    details of how they behave. Finally, we’ll talk about *expression trees* that
    represent code as data.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看 lambda 表达式的语法以及它们的一些行为细节。最后，我们将讨论表示代码为数据的 *表达式树*。
- en: 3.5.1\. Lambda expression syntax
  id: totrans-993
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1\. Lambda 表达式语法
- en: 'The basic syntax for lambda expressions is always of this form:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式的基本语法始终是这样的形式：
- en: '[PRE121]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Both the parameter list and the body, however, have multiple representations.
    In its most explicit form, the parameter list for a lambda expression looks like
    a normal method or anonymous method parameter list. Likewise, the body of a lambda
    expression can be a block: a sequence of statements all within a pair of curly
    braces. In this form, the lambda expression looks similar to an anonymous method:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，参数列表和体都有多种表示形式。在它的最明确的形式中，lambda 表达式的参数列表看起来像正常方法或匿名方法的参数列表。同样，lambda 表达式的体可以是块：一系列都在一对花括号内的语句。在这种形式中，lambda
    表达式看起来类似于匿名方法：
- en: '[PRE122]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: So far, this doesn’t look much better; you’ve traded the `delegate` keyword
    for `=>`, but that’s all. But special cases allow the lambda expression to become
    shorter.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这看起来并没有好多少；你只是将 `delegate` 关键字换成了 `=>`，但仅此而已。但是，特殊情况下可以使 lambda 表达式变得更短。
- en: 'Let’s start by making the body more concise. A body that consists of just a
    return statement or a single expression can be reduced to that single expression.
    The return keyword is removed if there was one. In the preceding example, the
    body of our lambda expression was just a method invocation, so you can simplify
    it:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使体更简洁开始。由单个返回语句或单个表达式组成的体可以简化为那个单一表达式。如果有，将移除返回关键字。在上面的例子中，我们的 lambda 表达式的体只是一个方法调用，因此你可以简化它：
- en: '[PRE123]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: You’ll look at an example returning a value shortly. Lambda expressions shortened
    like this are said to have *expression bodies*, whereas lambda expressions using
    braces are said to have *statement bodies*.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到一个返回值的例子。这样缩短的 lambda 表达式被称为有 *表达式体*，而使用花括号的 lambda 表达式被称为有 *语句体*。
- en: Next, you can make the parameter list shorter if the compiler can infer the
    parameter types based on the type you’re attempting to convert the lambda expression
    to. Lambda expressions don’t have a type but are convertible to compatible delegate
    types, and the compiler can often infer the parameter type as part of that conversion.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果你能根据你试图将 lambda 表达式转换到的类型推断出参数类型，你可以使参数列表更短。Lambda 表达式没有类型，但可以转换为兼容的委托类型，编译器通常可以在转换过程中推断出参数类型。
- en: 'For example, in the preceding code, the compiler knows that an `Action<string>`
    has a single parameter of type `string`, so it’s capable of inferring that parameter
    type. When the compiler can infer the parameter type, you can omit it. Therefore,
    our example can be shortened:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的代码中，编译器知道 `Action<string>` 有一个类型为 `string` 的单个参数，因此它能够推断出该参数类型。当编译器可以推断出参数类型时，你可以省略它。因此，我们的例子可以缩短：
- en: '[PRE124]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Finally, if the lambda expression has exactly one parameter, and that parameter’s
    type is inferred, the parentheses can be dropped from the parameter list:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 lambda 表达式恰好有一个参数，并且该参数的类型被推断出来，则可以省略参数列表中的括号：
- en: '[PRE125]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now let’s look at a couple of examples that return values. In each case, you’ll
    apply every step you can to make it shorter. First, you’ll construct a delegate
    to multiply two integers together and return the result:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看几个返回值的例子。在每种情况下，你将应用你能做的每一个步骤来使其更短。首先，你将构造一个委托来相乘两个整数并返回结果：
- en: '[PRE126]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '***1* Longest form**'
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 最长形式**'
- en: '***2* Uses an expression body**'
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用表达式体**'
- en: '***3* Infers parameter types**'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 推断参数类型**'
- en: 'Next, you’ll use a delegate to take the length of a string, multiply that length
    by itself, and return the result:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用一个委托来获取一个字符串的长度，将这个长度乘以自身，并返回结果：
- en: '[PRE127]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '***1* Longest form**'
  id: totrans-1014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 最长形式**'
- en: '***2* Infers parameter type**'
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 推断参数类型**'
- en: '***3* Removes parentheses for single parameter**'
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 移除单个参数的括号**'
- en: 'If you were happy to evaluate the `Length` property twice, you could reduce
    this second example:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意两次评估 `Length` 属性，你可以简化这个第二个例子：
- en: '[PRE128]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: That’s not the same kind of change as the others, though; that’s changing the
    *behavior* (however slightly) rather than just the syntax. It may seem odd to
    have all of these special cases, but in practice all of them apply in a large
    number of cases, particularly within LINQ. Now that you understand the syntax,
    you can start looking at the behavior of the delegate instance, particularly in
    terms of any variables it has captured.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这与其他类型的改变不同；这是改变 *行为*（尽管可能很微小），而不仅仅是语法。拥有所有这些特殊情况可能看起来很奇怪，但在实践中，所有这些情况都适用于大量情况，尤其是在
    LINQ 中。现在你了解了语法，你可以开始查看委托实例的行为，特别是它捕获的任何变量。 '
- en: 3.5.2\. Capturing variables
  id: totrans-1020
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 捕获变量
- en: In [section 2.3.2](kindle_split_017_split_000.html#ch02lev2sec12), when I described
    captured variables in anonymous methods, I promised that we’d return to the topic
    in the context of lambda expressions. This is probably the most confusing part
    of lambda expressions. It’s certainly been the cause of lots of Stack Overflow
    questions.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2.3.2 节](kindle_split_017_split_000.html#ch02lev2sec12)中，当我描述匿名方法中的捕获变量时，我承诺会在
    lambda 表达式的上下文中回到这个话题。这可能是 lambda 表达式中最令人困惑的部分。它肯定也是 Stack Overflow 上许多问题的原因。
- en: To create a delegate instance from a lambda expression, the compiler converts
    the code in the lambda expression to a method somewhere. The delegate can then
    be created at execution time exactly as if you had a method group. This section
    shows the kind of transformation the compiler performs. I’ve written this as if
    the compiler translates the source code into more source code that doesn’t contain
    lambda expressions, but of course the compiler never needs that translated source
    code. It can just emit the appropriate IL.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 lambda 表达式创建委托实例，编译器会将 lambda 表达式中的代码转换为某个地方的方法。然后，委托可以在执行时创建，就像你有一个方法组一样。本节展示了编译器执行的类型转换。我将其写成编译器将源代码转换为不包含
    lambda 表达式的更多源代码，但当然编译器不需要这种转换后的源代码。它可以直接生成适当的 IL。
- en: Let’s start with a recap of what counts as a captured variable. Within a lambda
    expression, you can use any variable that you’d be able to use in regular code
    at that point. That could be a static field, an instance field (if you’re writing
    the lambda expression within an instance method^([[1](kindle_split_018_split_000.html#ch03fn1)])),
    the `this` variable, method parameters, or local variables. All of these are captured
    variables, because they’re variables declared outside the immediate context of
    the lambda expression. Compare that with parameters to the lambda expression or
    local variables declared within the lambda expression; those *aren’t* captured
    variables. The following listing shows a lambda expression that captures various
    variables. You’ll then look at how the compiler handles that code.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾一下什么算是捕获变量开始。在 lambda 表达式中，你可以使用任何在那个点你能在常规代码中使用的变量。这可能是一个静态字段，一个实例字段（如果你在实例方法中编写
    lambda 表达式^([[1](kindle_split_018_split_000.html#ch03fn1)]))，`this` 变量，方法参数或局部变量。所有这些都是捕获变量，因为它们是在
    lambda 表达式直接上下文之外声明的变量。将此与 lambda 表达式的参数或 lambda 表达式内部声明的局部变量进行比较；那些 *不是* 捕获变量。以下列表显示了一个捕获各种变量的
    lambda 表达式。然后你将查看编译器如何处理这段代码。
- en: ¹
  id: totrans-1024
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can write lambda expressions in constructors, property accessors, and so
    on as well, but for the sake of simplicity, I’ll assume you’re writing them in
    methods.
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你也可以在构造函数、属性访问器等地方编写 lambda 表达式，但为了简单起见，我将假设你在方法中编写它们。
- en: Listing 3.6\. Capturing variables in a lambda expression
  id: totrans-1027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 在 lambda 表达式中捕获变量
- en: '[PRE129]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Lots of variables are involved here:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及了很多变量：
- en: '`instanceField` is an instance field in the `CapturedVariablesDemo` class and
    is captured by the lambda expression.'
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceField` 是 `CapturedVariablesDemo` 类中的一个实例字段，并且被 lambda 表达式捕获。'
- en: '`methodParameter` is a parameter in the `CreateAction` method and is captured
    by the lambda expression.'
  id: totrans-1031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methodParameter` 是 `CreateAction` 方法中的一个参数，并且被 lambda 表达式捕获。'
- en: '`methodLocal` is a local variable in the `CreateAction` method and is captured
    by the lambda expression.'
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methodLocal` 是`CreateAction`方法中的局部变量，并被lambda表达式捕获。'
- en: '`uncaptured` is a local variable in the `CreateAction` method, but it’s never
    used by the lambda expression, so it’s not captured by it.'
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uncaptured` 是`CreateAction`方法中的局部变量，但它从未被lambda表达式使用，因此没有被它捕获。'
- en: '`lambdaParameter` is a parameter in the lambda expression itself, so it isn’t
    a captured variable.'
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambdaParameter` 是lambda表达式本身中的参数，因此它不是捕获的变量。'
- en: '`lambdaLocal` is a local variable in the lambda expression, so it isn’t a captured
    variable.'
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambdaLocal` 是lambda表达式中的局部变量，因此它不是捕获的变量。'
- en: It’s important to understand that the lambda expression captures the variables
    themselves, *not* the values of the variables at the point when the delegate is
    created.^([[2](kindle_split_018_split_000.html#ch03fn2)]) If you modified any
    of the captured variables between the time at which the delegate is created and
    when it’s invoked, the output would reflect those changes. Likewise, the lambda
    expression can change the value of the captured variables. How does the compiler
    make all of that work? How does it make sure all those variables are still available
    to the delegate when it’s invoked?
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 理解lambda表达式捕获的是变量本身，*而不是*在创建委托时变量的值是非常重要的。[^([2](kindle_split_018_split_000.html#ch03fn2))]
    如果你在创建委托和调用它之间修改了任何捕获的变量，输出将反映这些更改。同样，lambda表达式也可以更改捕获变量的值。编译器是如何使所有这些工作正常进行的？它是如何确保在调用时所有这些变量仍然可用给委托的？
- en: ²
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I will repeat this multiple times, for which I make no apology. If you’re new
    to captured variables, this can take a while to get used to.
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我会多次重复这一点，对此我并不道歉。如果你对捕获的变量是新手，这可能需要一段时间才能习惯。
- en: Implementing captured variables with a generated class
  id: totrans-1040
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用生成的类实现捕获的变量
- en: 'There are three broad cases to consider:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要情况需要考虑：
- en: If no variables are captured at all, the compiler can create a static method.
    No extra context is required.
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有捕获任何变量，编译器可以创建一个静态方法。不需要额外的上下文。
- en: If the only variables captured are instance fields, the compiler can create
    an instance method. Capturing one instance field is equivalent to capturing 100
    of them, because you need access only to `this`.
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果捕获的唯一变量是实例字段，编译器可以创建一个实例方法。捕获一个实例字段相当于捕获了100个，因为你只需要访问`this`。
- en: If local variables or parameters are captured, the compiler creates a private
    nested class to contain that context and then an instance method in that class
    containing the lambda expression code. The method containing the lambda expression
    is changed to use that nested class for every access to the captured variables.
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果捕获了局部变量或参数，编译器会创建一个私有嵌套类来包含该上下文，然后在那个类中创建一个包含lambda表达式代码的实例方法。包含lambda表达式的那个方法会改为使用那个嵌套类来访问捕获的变量。
- en: '|  |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Implementation details may vary**'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现细节可能有所不同**'
- en: You may see some variation in what I’ve described. For example, with a lambda
    expression with no captured variables, the compiler may create a nested class
    with a single instance instead of a static method. There can be subtle differences
    in the efficiency of executing delegates based on exactly how they’re created.
    In this section, I’ve described the minimum work that the compiler *must* do in
    order to make captured variables available. It can introduce more complexity if
    it wants to.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到我所描述的内容有所变化。例如，对于没有捕获变量的lambda表达式，编译器可能会创建一个具有单个实例的嵌套类，而不是静态方法。根据它们创建的具体方式，执行委托的效率可能会有细微的差异。在本节中，我描述了编译器为了使捕获的变量可用而必须执行的最小工作。如果它想引入更多的复杂性，它可以这样做。
- en: '|  |'
  id: totrans-1048
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The last case is obviously the most complex one, so we’ll focus on that. Let’s
    start with [listing 3.6](kindle_split_018_split_000.html#ch03ex06). As a reminder,
    here’s the method that creates the lambda expression; I’ve omitted the class declaration
    for brevity:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况显然是最复杂的一种，所以我们将重点关注它。让我们从[列表3.6](kindle_split_018_split_000.html#ch03ex06)开始。作为提醒，以下是创建lambda表达式的那个方法；为了简洁起见，我省略了类声明：
- en: '[PRE130]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'As I described before, the compiler creates a private nested class for the
    extra context it’ll need and then an instance method in that class for the code
    in the lambda expression. The context is stored in instance variables of the nested
    class. In our case, that means the following:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所描述的，编译器为所需的额外上下文创建一个私有嵌套类，然后在那个类中创建一个用于lambda表达式代码的实例方法。上下文存储在嵌套类的实例变量中。在我们的例子中，这意味着以下内容：
- en: A reference to the original instance of `CapturedVariablesDemo` so that you
    can access `instanceField` later
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`CapturedVariablesDemo`原始实例的引用，以便你可以在以后访问`instanceField`
- en: A string variable for the captured method parameter
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于捕获方法参数的字符串变量
- en: A string variable for the captured local variable
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于捕获局部变量的字符串变量
- en: The following listing shows the nested class and how it’s used by the `CreateAction`
    method.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了嵌套类以及它是如何被`CreateAction`方法使用的。
- en: Listing 3.7\. Translation of a lambda expression with captured variables
  id: totrans-1056
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.7\. 带有捕获变量的lambda表达式的翻译
- en: '[PRE131]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '***1* Generated class to hold the captured variables**'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 生成类以保存捕获的变量**'
- en: '***2* Captured variables**'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 捕获变量**'
- en: '***3* Body of lambda expression becomes an instance method.**'
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Lambda表达式的主体成为一个实例方法。**'
- en: '***4* Generated class is used for all captured variables.**'
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 生成的类用于所有捕获的变量。**'
- en: Note how the `context.methodLocal` is modified near the end of the `CreateAction`
    method. When the delegate is finally invoked, it’ll “see” that modification. Likewise,
    if the delegate modified any of the captured variables, each invocation would
    see the results of the previous invocations. This is just reinforcing that the
    compiler ensures that the variable is captured rather than a snapshot of its value.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`CreateAction`方法接近结束时对`context.methodLocal`的修改。当委托最终被调用时，它将“看到”这个修改。同样，如果委托修改了任何捕获的变量，每次调用都会看到之前调用的结果。这只是在强调编译器确保捕获变量而不是其值的快照。
- en: In [listings 3.6](kindle_split_018_split_000.html#ch03ex06) and [3.7](kindle_split_018_split_000.html#ch03ex07),
    you had to create only a single context for the captured variables. In the terminology
    of the specification, each of the local variables was instantiated only once.
    Let’s make things a little more complicated.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表3.6](kindle_split_018_split_000.html#ch03ex06)和[3.7](kindle_split_018_split_000.html#ch03ex07)中，你只需要为捕获的变量创建一个上下文。在规范的术语中，每个局部变量只实例化了一次。让我们使事情变得稍微复杂一些。
- en: Multiple instantiations of local variables
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 局部变量的多次实例化
- en: To make things a little simpler, you’ll capture one local variable this time
    and no parameters or instance fields. The following listing shows a method to
    create a list of actions and then execute them one at a time. Each action captures
    a `text` variable.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情稍微简单一些，这次你将捕获一个局部变量，没有参数或实例字段。下面的列表展示了一个创建动作列表并逐个执行它们的方法。每个动作捕获一个`text`变量。
- en: Listing 3.8\. Instantiating a local variable multiple times
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.8\. 多次实例化一个局部变量
- en: '[PRE132]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '***1* Declares a local variable within the loop**'
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在循环内声明一个局部变量**'
- en: '***2* Captures the variable in a lambda expression**'
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在lambda表达式中捕获变量**'
- en: The fact that `text` is declared inside the loop is very important indeed. Each
    time you reach that declaration, the variable is instantiated. Each lambda expression
    captures a different instantiation of the variable. There are effectively five
    different `text` variables, each of which has been captured separately. They’re
    completely independent variables. Although this code happens not to modify them
    after the initial assignment, it certainly could do so either inside the lambda
    expression or elsewhere within the loop. Modifying one variable would have no
    effect on the others.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是`text`在循环内部声明非常重要。每次到达那个声明时，变量都会被实例化。每个lambda表达式捕获变量的不同实例。实际上有五个不同的`text`变量，每个变量都被单独捕获。它们是完全独立的变量。尽管这个代码在初始赋值后没有修改它们，但它确实可以在lambda表达式内部或循环内的其他地方进行修改。修改一个变量不会对其他变量产生影响。
- en: The compiler models this behavior by creating a different instance of the generated
    type for each instantiation. Therefore, the `CreateAction` method of [listing
    3.8](kindle_split_018_split_000.html#ch03ex08) could be translated into the following
    listing.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过为每个实例化创建生成的类型的不同实例来模拟这种行为。因此，[列表3.8](kindle_split_018_split_000.html#ch03ex08)中的`CreateAction`方法可以翻译成以下列表。
- en: Listing 3.9\. Creating multiple context instances, one for each instantiation
  id: totrans-1072
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.9\. 为每个实例化创建多个上下文实例
- en: '[PRE133]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '***1* Creates a new context for each loop iteration**'
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为每个循环迭代创建一个新的上下文**'
- en: '***2* Uses the context to create an action**'
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用上下文创建一个动作**'
- en: Hopefully, that still makes sense. You’ve gone from having a single context
    for the lambda expression to one for each iteration of the loop. I’m going to
    finish this discussion of captured variables with an even more complicated example,
    which is a mixture of the two.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这仍然有意义。你已经从为 lambda 表达式有一个上下文变成了为循环的每次迭代有一个上下文。我将通过一个更复杂的例子来结束对捕获变量的讨论，这是一个两者的混合体。
- en: Capturing variables from multiple scopes
  id: totrans-1077
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从多个作用域捕获变量
- en: It was the *scope* of the text variable that meant it was instantiated once
    for each iteration of the loop. But multiple scopes can exist within a single
    method, and each scope can contain local variable declarations, and a single lambda
    expression can capture variables from multiple scopes. [Listing 3.10](kindle_split_018_split_000.html#ch03ex10)
    gives an example. You create two delegate instances, each of which captures two
    variables. They both capture the same `outerCounter` variable, but each captures
    a separate `innerCounter` variable. The delegates simply print out the current
    values of the counters and increment them. You execute each delegate twice, which
    makes the difference between the captured variables clear.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 是文本变量的作用域意味着它在循环的每次迭代中只实例化一次。但单个方法中可以存在多个作用域，每个作用域可以包含局部变量声明，而单个 lambda 表达式可以捕获多个作用域的变量。[列表
    3.10](kindle_split_018_split_000.html#ch03ex10) 提供了一个示例。你创建了两个委托实例，每个实例都捕获两个变量。它们都捕获相同的
    `outerCounter` 变量，但每个实例都捕获一个单独的 `innerCounter` 变量。委托简单地打印出计数器的当前值并增加它们。你执行每个委托两次，这使得捕获变量的差异变得明显。
- en: Listing 3.10\. Capturing variables from multiple scopes
  id: totrans-1079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. 从多个作用域捕获变量
- en: '[PRE134]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '***1* One variable captured by both delegates**'
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 两个委托都捕获的一个变量**'
- en: '***2* New variable for each loop iteration**'
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每次循环迭代一个新变量**'
- en: '***3* Displays and increments counters**'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示并增加计数器**'
- en: '***4* Calls each delegate twice**'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 调用每个委托两次**'
- en: 'The output of [listing 3.10](kindle_split_018_split_000.html#ch03ex10) is as
    follows:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.10](kindle_split_018_split_000.html#ch03ex10) 的输出如下：'
- en: '[PRE135]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The first two lines are printed by the first delegate. The last two lines are
    printed by the second delegate. As I described before the listing, the same outer
    counter is used by both delegates, but they have independent inner counters.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行是由第一个委托打印的。最后两行是由第二个委托打印的。正如我之前所描述的列表，两个委托都使用了相同的循环外部计数器，但它们有独立的内部计数器。
- en: What does the compiler do with this? Each delegate needs its own context, but
    that context needs to also refer to a shared context. The compiler creates two
    private nested classes instead of one. The following listing shows an example
    of how the compiler could treat [listing 3.10](kindle_split_018_split_000.html#ch03ex10).
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会对此做什么呢？每个委托都需要自己的上下文，但这个上下文还需要引用共享的上下文。编译器创建两个私有嵌套类而不是一个。以下列表显示了编译器如何处理[列表
    3.10](kindle_split_018_split_000.html#ch03ex10)的示例。
- en: Listing 3.11\. Capturing variables from multiple scopes leads to multiple classes
  id: totrans-1089
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. 从多个作用域捕获变量导致多个类
- en: '[PRE136]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '***1* Context for the outer scope**'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 外部作用域的上下文**'
- en: '***2* Context for the inner scope with reference to outer context**'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 引用外部上下文的内部作用域上下文**'
- en: '***3* Method used to create delegate**'
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建委托的方法**'
- en: '***4* Creates a single outer context**'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个单独的外部上下文**'
- en: '***5* Creates an inner context per loop iteration**'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 每次循环迭代创建一个内部上下文**'
- en: You’ll rarely need to look at the generated code like this, but it can make
    a difference in terms of performance. If you use a lambda expression in a performance-critical
    piece of code, you should be aware of how many objects will be created to support
    the variables it captures.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少需要查看这样的生成代码，但它可以在性能方面产生影响。如果你在性能关键代码中使用 lambda 表达式，你应该意识到将创建多少对象来支持它捕获的变量。
- en: I could give even more examples with multiple lambda expressions in the same
    scope capturing different sets of variables or lambda expressions in methods of
    value types. I find it fascinating to explore compiler-generated code, but you
    probably wouldn’t want a whole book of it. If you ever find yourself wondering
    how the compiler treats a particular lambda expression, it’s easy enough to run
    a decompiler or ildasm over the result.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以给出更多例子，其中在相同的作用域内使用多个 lambda 表达式捕获不同的变量集或值类型方法中的 lambda 表达式。我发现探索编译器生成的代码非常有趣，但你可能不想看一整本书。如果你想知道编译器是如何处理特定的
    lambda 表达式的，运行反编译器或 ildasm 在结果上就足够简单了。
- en: 'So far, you’ve looked only at converting lambda expressions to delegates, which
    you could already do with anonymous methods. Lambda expressions have another superpower,
    however: they can be converted to expression trees.'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只看到了将 lambda 表达式转换为委托的过程，这你本来就可以用匿名方法做到。然而，lambda 表达式还有一个超级能力：它们可以被转换为表达式树。
- en: 3.5.3\. Expression trees
  id: totrans-1099
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.3\. 表达式树
- en: '*Expression trees* are representations of code as data. This is the heart of
    how LINQ is able to work efficiently with data providers such as SQL databases.
    The code you write in C# can be analyzed at execution time and converted into
    SQL.'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式树* 是代码作为数据的表示。这是 LINQ 能够高效地与如 SQL 数据库等数据提供者一起工作的核心。你编写的 C# 代码可以在执行时进行分析，并转换为
    SQL。'
- en: Whereas delegates provide code you can run, expression trees provide code you
    can inspect, a little like reflection. Although you *can* build up expression
    trees directly in code, it’s more common to ask the compiler to do this for you
    by converting a lambda expression into an expression tree. The following listing
    gives a trivial example of this by creating an expression tree just to add two
    numbers together.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然委托提供了可以运行的代码，但表达式树提供了可以检查的代码，有点像反射。虽然你 *可以* 在代码中直接构建表达式树，但更常见的是要求编译器为你这样做，通过将
    lambda 表达式转换为表达式树。以下列表通过创建一个仅用于将两个数字相加的表达式树来给出一个简单的例子。
- en: Listing 3.12\. A simple expression tree to add two integers
  id: totrans-1102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.12\. 一个简单的表达式树，用于添加两个整数
- en: '[PRE137]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Considering it’s only two lines of code, there is a lot going on. Let’s start
    with the output. If you try to print out a regular delegate, the result will be
    just the type with no indication of the behavior. The output of [listing 3.12](kindle_split_018_split_000.html#ch03ex12)
    shows exactly what the expression tree does, though:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这只有两行代码，其中包含了很多内容。让我们从输出开始。如果你尝试打印一个常规的委托，结果将只是类型，没有任何行为指示。[列表 3.12](kindle_split_018_split_000.html#ch03ex12)
    的输出显示了表达式树的确切作用：
- en: '[PRE138]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The compiler isn’t cheating by hardcoding a string somewhere. That string representation
    is constructed from the expression tree. This demonstrates that the code is available
    for examination at execution time, which is the whole point of expression trees.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器并没有通过在某个地方硬编码一个字符串来作弊。这个字符串表示形式是由表达式树构建的。这表明代码在执行时是可检查的，这正是表达式树的全部意义。
- en: 'Let’s look at the type of `adder`: `Expression<Func<int, int, int>>`. It’s
    simplest to split it into two parts: `Expression<TDelegate>` and `Func<int, int,
    int>`. The second part is used as a type argument to the first. The second part
    is a delegate type with two integer parameters and an integer return type. (The
    return type is expressed by the last type parameter, so a `Func<string, double,
    int>` would accept a `string` and a `double` as inputs and return an `int`.)'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `adder` 的类型：`Expression<Func<int, int, int>>`。最简单的方法是将它分成两部分：`Expression<TDelegate>`
    和 `Func<int, int, int>`。第二部分用作第一部分的类型参数。第二部分是一个具有两个整数参数和一个整数返回类型的委托类型。（返回类型由最后一个类型参数表示，因此
    `Func<string, double, int>` 将接受一个 `string` 和一个 `double` 作为输入，并返回一个 `int`。）
- en: '`Expression<TDelegate>` is the expression tree type associated with `TDelegate`,
    which must be a delegate type. (That’s not expressed as a type constraint, but
    it’s enforced at execution time.) This is only one of the many types involved
    in expression trees. They’re all in the `System.Linq.Expressions` namespace. The
    nongeneric `Expression` class is the abstract base class for all the other expression
    types, and it’s also used as a convenient container for factory methods to create
    instances of the concrete subclasses.'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expression<TDelegate>` 是与 `TDelegate` 关联的表达式树类型，`TDelegate` 必须是一个委托类型。（这没有作为类型约束表达出来，但在执行时强制执行。）这是涉及表达式树的许多类型之一。它们都在
    `System.Linq.Expressions` 命名空间中。非泛型的 `Expression` 类是所有其他表达式类型的抽象基类，它也被用作创建具体子类实例的工厂方法的方便容器。'
- en: Our `adder` variable type is an expression tree representation of a function
    accepting two integers and returning an integer. You then use a lambda expression
    to assign a value to that variable. The compiler generates code to build the appropriate
    expression tree at execution time. In this case, it’s reasonably simple. You can
    write the same code yourself, as shown in the following listing.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `adder` 变量类型是一个接受两个整数并返回整数的函数的表达式树表示。然后你使用 lambda 表达式为该变量赋值。编译器在执行时生成代码来构建适当的表达式树。在这种情况下，它相当简单。你可以自己编写相同的代码，如下面的列表所示。
- en: Listing 3.13\. Handwritten code to create an expression tree to add two integers
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.13\. 编写代码以创建添加两个整数的表达式树
- en: '[PRE139]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This is a small example, and it’s still significantly more long-winded than
    the lambda expression. By the time you add method calls, property accesses, object
    initializers, and so on, it gets complex and error prone. That’s why it’s so important
    that the compiler can do the work for you by converting lambda expressions into
    expression trees. There are a few rules around this, though.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小例子，但它仍然比lambda表达式长得多。当你添加方法调用、属性访问、对象初始化器等等时，它会变得复杂且容易出错。这就是为什么编译器能够通过将lambda表达式转换为表达式树为你做这项工作如此重要的原因。尽管如此，还有一些规则。
- en: Limitations of conversions to expression trees
  id: totrans-1113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换为表达式树的限制
- en: 'The most important restriction is that only *expression-bodied* lambda expressions
    can be converted to expression trees. Although our earlier lambda expression of
    `(x, y) => x + y` was fine, the following code would cause a compilation error:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的限制是只有*表达式体*的lambda表达式可以转换为表达式树。虽然我们之前的`(x, y) => x + y`lambda表达式是好的，但以下代码会导致编译错误：
- en: '[PRE140]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The expression tree API has expanded since .NET 3.5 to include blocks and other
    constructs, but the C# compiler still has this restriction, and it’s consistent
    with the use of expression trees for LINQ. This is one reason that object and
    collection initializers are so important: they allow initialization to be captured
    in a single expression, which means it can be used in an expression tree.'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 自从.NET 3.5以来，表达式树API已经扩展，包括块和其他结构，但C#编译器仍然有这个限制，这与表达式树在LINQ中的使用是一致的。这是对象和集合初始化器如此重要的一个原因：它们允许初始化被捕获在一个单独的表达式中，这意味着它可以在表达式树中使用。
- en: Additionally, the lambda expression can’t use the assignment operator, or use
    C# 4’s dynamic typing, or use C# 5’s asynchrony. (Although object and collection
    initializers do use the `=` symbol, that’s not the assignment operator in that
    context.)
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，lambda表达式不能使用赋值运算符，也不能使用C# 4的动态类型，或者使用C# 5的异步操作。（尽管对象和集合初始化器确实使用了`=`符号，但那个上下文中的`=`不是赋值运算符。）
- en: Compiling expression trees to delegates
  id: totrans-1118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将表达式树编译为委托
- en: The ability to execute queries against remote data sources, as I referred to
    earlier, isn’t the only use for expression trees. They can be a powerful way of
    constructing efficient delegates dynamically at execution time, although this
    is typically an area where at least part of the expression tree is built with
    handwritten code rather than converted from a lambda expression.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，能够对远程数据源执行查询并不是表达式树的唯一用途。它们可以在执行时动态构建高效委托的强大方式，尽管这通常是一个至少部分表达式树是用手写代码构建而不是从lambda表达式转换而来的领域。
- en: '`Expression<TDelegate>` has a `Compile()` method that returns the delegate
    type. You can then handle this delegate as you do any other. As a trivial example,
    the following listing takes our earlier adder expression tree, compiles that to
    a delegate, and then invokes it, producing an output of 5.'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expression<TDelegate>`有一个`Compile()`方法，它返回委托类型。然后你可以像处理任何其他委托一样处理这个委托。作为一个简单的例子，下面的列表将我们之前添加的表达式树编译为委托，然后调用它，输出结果为5。'
- en: Listing 3.14\. Compiling an expression tree to a delegate and invoking the result
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.14。将表达式树编译为委托并调用结果
- en: '[PRE141]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '***1* Compiles the expression tree to a delegate**'
  id: totrans-1123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将表达式树编译为委托**'
- en: '***2* Invokes the delegate as normal**'
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 正常调用委托**'
- en: This approach can be used in conjunction with reflection for property access
    and method invocation to produce delegates and then cache them. The result is
    as efficient as if you’d written the equivalent code by hand. For a single method
    call or property access, there are already methods to create delegates directly,
    but sometimes you need additional conversion or manipulation steps, which are
    easily represented in expression trees.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以与反射结合使用，用于属性访问和方法调用以生成委托并缓存它们。结果是如果你手动编写等效代码一样高效。对于单个方法调用或属性访问，已经存在直接创建委托的方法，但有时你需要额外的转换或操作步骤，这些步骤在表达式树中很容易表示。
- en: We’ll come back to why expression trees are so important in LINQ when we tie
    everything together. You have only two more language features to look at. Extension
    methods come next.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一切联系起来时，我们将回到为什么表达式树在LINQ中如此重要的原因。你还有两个语言特性要查看。扩展方法接下来。
- en: 3.6\. Extension methods
  id: totrans-1127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 扩展方法
- en: 'Extension methods sound pointless when they’re first described. They’re static
    methods that can be called as if they’re instance methods, based on their first
    parameter. Suppose you have a static method call like this:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法在最初描述时听起来可能没有意义。它们是静态方法，可以基于它们的第一个参数像实例方法一样调用。假设你有一个这样的静态方法调用：
- en: '[PRE142]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'If you turn `ExampleClass.Method` into an extension method, you can call it
    like this instead:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `ExampleClass.Method` 转换为扩展方法，你可以这样调用它：
- en: '[PRE143]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: That’s all extension methods do. It’s one of the simplest transformations the
    C# compiler does. It makes all the difference in terms of code readability when
    it comes to chaining method calls together, however. You’ll look at that later,
    finally using real examples from LINQ, but first let’s look at the syntax.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法就是这样。这是 C# 编译器所做的最简单的转换之一。当涉及到链式调用方法时，它在代码可读性方面有很大的影响。你将在后面查看这一点，最终使用 LINQ
    的真实示例，但首先让我们看看语法。
- en: 3.6.1\. Declaring an extension method
  id: totrans-1133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1\. 声明扩展方法
- en: Extension methods are declared by adding the keyword `this` before the first
    parameter. The method must be declared in a non-nested, nongeneric static class,
    and until C# 7.2, the first parameter can’t be a `ref` parameter. (You’ll see
    more about that in [section 13.5](kindle_split_030_split_000.html#ch13lev1sec5).)
    Although the class containing the method can’t be generic, the extension method
    itself can be.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法通过在第一个参数之前添加关键字 `this` 来声明。方法必须在非嵌套、非泛型静态类中声明，并且在 C# 7.2 之前，第一个参数不能是 `ref`
    参数。（你将在[第 13.5 节](kindle_split_030_split_000.html#ch13lev1sec5)中了解更多关于这一点。）虽然包含方法的类不能是泛型的，但扩展方法本身可以是。
- en: The type of the first parameter is sometimes called the *target* of the extension
    method and sometimes called the *extended type*. (The specification doesn’t give
    this concept a name, unfortunately.)
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数的类型有时被称为扩展方法的 *目标* 或 *扩展类型*。（不幸的是，规范没有给这个概念命名。）
- en: As an example from Noda Time, we have an extension method to convert from `DateTimeOffset`
    to `Instant`. There’s already a static method within the `Instant` struct to do
    this, but it’s useful to have as an extension method, too. [Listing 3.15](kindle_split_018_split_000.html#ch03ex15)
    shows the code for the method. For once, I’ve included the namespace declaration,
    as that’s going to be important when you see how the C# compiler finds extension
    methods.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Noda Time 为例，我们有一个将 `DateTimeOffset` 转换为 `Instant` 的扩展方法。`Instant` 结构体中已经有一个静态方法来做这个转换，但将其作为扩展方法也很有用。[列表
    3.15](kindle_split_018_split_000.html#ch03ex15) 展示了该方法的代码。这一次，我包括了命名空间声明，因为当你看到
    C# 编译器如何找到扩展方法时，这将是重要的。
- en: Listing 3.15\. `ToInstant` extension method targeting `DateTimeOffset` from
    Noda Time
  id: totrans-1137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.15\. Noda Time 中针对 `DateTimeOffset` 的 `ToInstant` 扩展方法
- en: '[PRE144]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The compiler adds the `[Extension]` attribute to both the method and the class
    declaring it, and that’s all. This attribute is in the `System.Runtime.CompilerServices`
    namespace. It’s a marker indicating the intent that a developer should be able
    to call `ToInstant()` as if it were declared as an instance method in `DateTimeOffset`.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将 `[Extension]` 属性添加到方法和声明它的类上，仅此而已。这个属性位于 `System.Runtime.CompilerServices`
    命名空间中。它是一个标记，表示开发人员应该能够像在 `DateTimeOffset` 中声明实例方法一样调用 `ToInstant()`。
- en: 3.6.2\. Invoking an extension method
  id: totrans-1140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.2\. 调用扩展方法
- en: 'You’ve already seen the syntax to invoke an extension method: you call it as
    if it were an instance method on the type of the first parameter. But you need
    to make sure that the compiler can find the method as well.'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了调用扩展方法的语法：你就像调用第一个参数类型的实例方法一样调用它。但你需要确保编译器也能找到这个方法。
- en: 'First, there’s a matter of priority: if there’s a regular instance method that’s
    valid for the method invocation, the compiler will always prefer that over an
    extension method. It doesn’t matter whether the extension method has “better”
    parameters; if the compiler can use an instance method, it won’t even look for
    extension methods.'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个优先级问题：如果有一个适用于方法调用的常规实例方法，编译器总是会优先选择它，而不管扩展方法是否有“更好”的参数；如果编译器可以使用实例方法，它甚至不会寻找扩展方法。
- en: After it has exhausted its search for instance methods, the compiler will look
    for extension methods based on the namespace the calling code is in and any `using`
    directives present. Suppose you’re making a call from the `ExtensionMethodInvocation`
    class in the `CSharpInDepth.Chapter03` namespace.^([[3](kindle_split_018_split_000.html#ch03fn3)])
    The following listing shows how to do that, giving the compiler all the information
    it needs to find the extension method.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 在它耗尽对实例方法的搜索后，编译器将根据调用代码所在的命名空间和任何存在的`using`指令查找扩展方法。假设你从`CSharpInDepth.Chapter03`命名空间中的`ExtensionMethodInvocation`类中进行调用.^([[3](kindle_split_018_split_000.html#ch03fn3)])
    下面的列表显示了如何进行操作，为编译器提供所有它需要找到扩展方法的信息。
- en: ³
  id: totrans-1144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you’re following along with the downloaded code, you may have noticed that
    the samples are in namespaces of Chapter01, Chapter02, and so on, for simplicity.
    I’ve made an exception here for the sake of showing the hierarchical nature of
    the namespace checks.
  id: totrans-1146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在跟随下载的代码，你可能已经注意到示例位于Chapter01、Chapter02等命名空间中，为了简单起见。我在这里做了例外，以便展示命名空间检查的层次结构性质。
- en: Listing 3.16\. Invoking the `ToInstant()` extension method outside Noda Time
  id: totrans-1147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.16\. 在Noda Time外部调用`ToInstant()`扩展方法
- en: '[PRE145]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '***1* Imports the NodaTime.Extensions namespace**'
  id: totrans-1149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入NodaTime.Extensions命名空间**'
- en: '***2* Calls the extension method**'
  id: totrans-1150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用扩展方法**'
- en: 'The compiler will check for extension methods in the following:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将在以下方面检查扩展方法：
- en: Static classes in the `CSharpInDepth.Chapter03` namespace.
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpInDepth.Chapter03`命名空间中的静态类。'
- en: Static classes in the `CSharpInDepth` namespace.
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpInDepth`命名空间中的静态类。'
- en: Static classes in the global namespace.
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局命名空间中的静态类。
- en: Static classes in namespaces specified with using namespace directives. (Those
    are the using directives that just specify a namespace, like `using System`.)
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用using namespace指令指定的命名空间中的静态类。（这些是只指定命名空间的using指令，如`using System`。）
- en: In C# 6 only, static classes specified with using static directives. We’ll come
    back to that in [section 10.1](kindle_split_026_split_000.html#ch10lev1sec1).
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C# 6中仅限，使用using static指令指定的静态类。我们将在[第10.1节](kindle_split_026_split_000.html#ch10lev1sec1)中回到这一点。
- en: The compiler effectively works its way outward from the deepest namespace out
    toward the global namespace and looks at each step for static classes either in
    that namespace or provided by classes made available by using directives in the
    namespace declaration. The details of the ordering are almost never important.
    If you find yourself in a situation where moving a using directive changes which
    extension method is used, it’s probably best to rename one of them. But it’s important
    to understand that within each step, multiple extension methods can be found that
    would be valid for the call. In that situation, the compiler performs normal overload
    resolution between all the extension methods it found in that step. After the
    compiler has located the right method to invoke, the IL it generates for the call
    is exactly the same as if you’d written a regular static method call instead of
    using its capabilities as an extension method.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器有效地从最深层的命名空间向外扩展，直到全局命名空间，并在每一步检查该命名空间中的静态类或通过在命名空间声明中使用指令提供的类。排序的细节几乎从不重要。如果你发现自己处于一种情况，即移动一个using指令会改变所使用的扩展方法，那么最好是将其中一个重命名。但重要的是要理解，在每一步中，可以找到多个对于调用有效的扩展方法。在这种情况下，编译器将在该步骤中找到的所有扩展方法之间执行正常的重载解析。编译器定位到要调用的正确方法后，它为调用生成的IL（中间语言）与如果你用扩展方法的能力而不是用常规静态方法调用写出来的情况完全相同。
- en: '|  |'
  id: totrans-1158
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Extension methods can be called on null values**'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展方法可以在null值上调用**'
- en: 'Extension methods differ from instance methods in terms of their null handling.
    Let’s look back at our initial example:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法在null处理方面与实例方法不同。让我们回顾一下我们的初始示例：
- en: '[PRE146]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: If `Method` were an instance method and `x` were a null reference, that would
    throw a `NullReferenceException`. Instead, if `Method` is an extension method,
    it’ll be called with `x` as the first argument even if `x` is null. Sometimes
    the method will specify that the first argument must not be null, in which case
    it should validate it and throw an `ArgumentNullException`. In other cases, the
    extension method may have been explicitly designed to handle a null first argument
    gracefully.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Method`是一个实例方法并且`x`是一个空引用，那么会抛出`NullReferenceException`。相反，如果`Method`是一个扩展方法，即使`x`是空，它也会以`x`作为第一个参数被调用。有时方法会指定第一个参数不能为空，在这种情况下，它应该验证它并抛出`ArgumentNullException`。在其他情况下，扩展方法可能已经被明确设计来优雅地处理空第一个参数。
- en: '|  |'
  id: totrans-1163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s get back to why extension methods are important to LINQ. It’s time for
    our first query.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到为什么扩展方法对 LINQ 很重要的原因。是我们第一次查询的时候了。
- en: 3.6.3\. Chaining method calls
  id: totrans-1165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.3\. 方法调用链
- en: '[Listing 3.17](kindle_split_018_split_000.html#ch03ex17) shows a simple query.
    It takes a sequence of words, filters them by length, orders them in the natural
    way, and then converts them to uppercase. It uses lambda expressions and extension
    methods but no other C# 3 features. We’ll put everything else together at the
    end of the chapter. For the moment, I want to focus on the readability of this
    simple code.'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.17](kindle_split_018_split_000.html#ch03ex17) 展示了一个简单的查询。它接受一系列单词，通过长度过滤它们，以自然方式排序，然后将它们转换为大写。它使用了
    lambda 表达式和扩展方法，但没有使用其他 C# 3 特性。我们将在本章末尾将所有其他内容组合在一起。目前，我想专注于这段简单代码的可读性。'
- en: Listing 3.17\. A simple query on strings
  id: totrans-1167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.17\. 字符串上的简单查询
- en: '[PRE147]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '***1* A simple data source**'
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 简单的数据源**'
- en: '***2* Filters, orders, transforms**'
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 过滤器、排序、转换**'
- en: '***3* Displays the results**'
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示结果**'
- en: Notice the ordering of the `Where`, `OrderBy`, and `Select` calls in our code.
    That’s the order in which the operations happen. The lazy and streaming-where-possible
    nature of LINQ makes it complicated to talk about exactly what happens when, but
    the query reads in the same order as it executes. The following listing is the
    same query but without taking advantage of the fact that these methods are extension
    methods.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们代码中`Where`、`OrderBy`和`Select`调用的顺序。这是操作发生的顺序。LINQ的延迟和尽可能流式处理的本性使得很难确切地说出何时发生什么，但查询的读取顺序与执行顺序相同。下面的列表是相同的查询，但没有利用这些方法是扩展方法的事实。
- en: Listing 3.18\. A simple query without using extension methods
  id: totrans-1173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.18\. 不使用扩展方法的简单查询
- en: '[PRE148]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'I’ve formatted [listing 3.18](kindle_split_018_split_000.html#ch03ex18) as
    readably as I can, but it’s still awful. The calls are laid out in the opposite
    order in the source code to how they’ll execute: `Where` is the first thing to
    execute but the last method call in the listing. Next, it’s not obvious which
    lambda expression goes with which call: `word => word.ToUpper()` is part of the
    `Select` call, but a huge amount of code is between those two pieces of text.'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经尽可能地将[列表 3.18](kindle_split_018_split_000.html#ch03ex18)格式化为可读的形式，但它仍然很糟糕。调用在源代码中的顺序与它们执行顺序相反：`Where`是首先执行的操作，但在列表中是最后一个方法调用。接下来，不清楚哪个
    lambda 表达式与哪个调用相对应：`word => word.ToUpper()`是`Select`调用的一部分，但在这两段文本之间有大量的代码。
- en: You can tackle this in another way by assigning the result of each method call
    to a local variable and then making the method call via that. [Listing 3.19](kindle_split_018_split_000.html#ch03ex19)
    shows one option for doing this. (In this case, you could’ve just declared the
    query to start with and reassigned it on each line, but that wouldn’t always be
    the case.) This time, I’ve also used `var`, just for brevity.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将每个方法调用的结果分配给一个局部变量，然后通过该变量进行方法调用来解决这个问题。[列表 3.19](kindle_split_018_split_000.html#ch03ex19)展示了这样做的一个选项。（在这种情况下，你可以在每一行开始时声明查询，并在每一行重新分配它，但并不总是如此。）这次，我也使用了`var`，只是为了简洁。
- en: Listing 3.19\. A simple query in multiple statements
  id: totrans-1177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.19\. 多语句中的简单查询
- en: '[PRE149]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This is better than [listing 3.18](kindle_split_018_split_000.html#ch03ex18);
    the operations are back in the right order, and it’s obvious which lambda expression
    is used for which operation. But the extra local variable declarations are a distraction,
    and it’s easy to end up using the wrong one.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 这比[列表 3.18](kindle_split_018_split_000.html#ch03ex18)要好；操作顺序已经恢复正确，并且很明显哪个 lambda
    表达式用于哪个操作。但是额外的局部变量声明会分散注意力，并且很容易使用错误的变量。
- en: The benefits of method chaining aren’t limited to LINQ, of course. Using the
    result of one call as the starting point of another call is common. But extension
    methods allow you to do this in a readable way for any type, rather than the type
    itself declaring the methods that support chaining. `IEnumerable<T>` doesn’t know
    anything about LINQ; its sole responsibility is to represent a general sequence.
    It’s the `System.Linq.Enumerable` class that adds all the operations for filtering,
    grouping, joining, and so on.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链式调用的好处不仅限于LINQ。使用一次调用的结果作为另一次调用的起点是常见的。但是扩展方法允许你以可读的方式对任何类型执行此操作，而不是类型本身声明支持链式调用的方法。`IEnumerable<T>`对LINQ一无所知；它的唯一责任是表示一个通用序列。是`System.Linq.Enumerable`类添加了所有过滤、分组、连接等操作。
- en: C# 3 could’ve stopped here. The features described so far would already have
    added a lot of power to the language and enabled many LINQ queries to be written
    in a perfectly readable form. But when queries get more complex, particularly
    when they include joins and groupings, using the extension methods directly can
    get complicated. Enter query expressions.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3本可以到此为止。到目前为止描述的特性已经为语言增添了大量功能，并使得许多LINQ查询能够以完美的可读性形式编写。但是当查询变得更加复杂，尤其是当它们包括连接和分组时，直接使用扩展方法可能会变得复杂。这时就出现了查询表达式。
- en: 3.7\. Query expressions
  id: totrans-1182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7. 查询表达式
- en: 'Although almost all features in C# 3 contribute to LINQ, only *query expressions*
    are specific to LINQ. Query expressions allow you to write concise code by using
    query-specific clauses (`select`, `where`, `let`, `group by`, and so on). The
    query is then translated into a nonquery form by the compiler and compiled as
    normal.^([[4](kindle_split_018_split_000.html#ch03fn4)]) Let’s start with a brief
    example to make this clearer. As a reminder, in [listing 3.17](kindle_split_018_split_000.html#ch03ex17)
    you had this query:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C# 3中的几乎所有特性都对LINQ有贡献，但只有*查询表达式*是LINQ特有的。查询表达式允许你通过使用查询特定的子句（`select`、`where`、`let`、`group
    by`等）来编写简洁的代码。然后，编译器将查询转换为非查询形式，并按常规编译.^([[4](kindle_split_018_split_000.html#ch03fn4)])
    让我们从简短的例子开始，以便使这一点更清晰。作为提醒，在[列表3.17](kindle_split_018_split_000.html#ch03ex17)中，你有了这个查询：
- en: ⁴
  id: totrans-1184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This sounds like macros in C, but it’s a little more involved than that. C#
    still doesn’t have macros.
  id: totrans-1186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这听起来像是C语言中的宏，但它比那要复杂一些。C#仍然没有宏。
- en: '[PRE150]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The following listing shows the same query written as a query expression.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了以查询表达式编写的相同查询。
- en: Listing 3.20\. Introductory query expression with filtering, ordering, and projection
  id: totrans-1189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.20. 带有过滤、排序和投影的查询表达式简介
- en: '[PRE151]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The section of [listing 3.20](kindle_split_018_split_000.html#ch03ex20) in bold
    is the query expression, and it’s very concise indeed. The repetitive use of `word`
    as a parameter to lambda expressions has been replaced by specifying the name
    of a *range variable* once in the `from` clause, and then using it in each of
    the other clauses. What happens to the query expression in [listing 3.20](kindle_split_018_split_000.html#ch03ex20)?
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体显示的[列表3.20](kindle_split_018_split_000.html#ch03ex20)部分是查询表达式，它确实非常简洁。将`word`作为lambda表达式的参数重复使用，已经被在`from`子句中一次指定一个*范围变量*的名称，然后在其他每个子句中使用它所取代。列表3.20中的查询表达式会发生什么？
- en: 3.7.1\. Query expressions translate from C# to C#
  id: totrans-1192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.1. 查询表达式从C#转换为C#
- en: In this book, I’ve expressed many language features in terms of more C# source
    code. For example, when looking at captured variables in [section 3.5.2](kindle_split_018_split_000.html#ch03lev2sec12),
    I showed C# code that you could’ve written to achieve the same result as using
    a lambda expression. That’s just for the purpose of explaining the code generated
    by the compiler. I wouldn’t expect the compiler to generate any C#. The specification
    describes the effects of capturing variables rather than a source code translation.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我通过更多的C#源代码来表述了许多语言特性。例如，当查看[第3.5.2节](kindle_split_018_split_000.html#ch03lev2sec12)中捕获的变量时，我展示了你可以编写的C#代码，以实现与使用lambda表达式相同的结果。这只是为了解释编译器生成的代码。我不期望编译器生成任何C#代码。规范描述了捕获变量的效果，而不是源代码的转换。
- en: Query expressions work differently. The specification describes them as a syntactic
    translation that occurs before any overload resolution or binding. The code in
    [listing 3.20](kindle_split_018_split_000.html#ch03ex20) doesn’t just have the
    same eventual effect as [listing 3.17](kindle_split_018_split_000.html#ch03ex17);
    it’s really translated into the code in [listing 3.17](kindle_split_018_split_000.html#ch03ex17)
    before further processing. The language has no specific expectation about what
    the result of that further processing will be. In many cases, the result of the
    translation will be calls to extension methods, but that’s not required by the
    language specification. They could be instance method calls or invocations of
    delegates returned by properties named `Select`, `Where`, and so on.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式的工作方式不同。规范描述它们为在任何重载解析或绑定之前发生的语法转换。[列表 3.20](kindle_split_018_split_000.html#ch03ex20)
    中的代码不仅仅具有与 [列表 3.17](kindle_split_018_split_000.html#ch03ex17) 相同的最终效果；它实际上在进一步处理之前被转换成了
    [列表 3.17](kindle_split_018_split_000.html#ch03ex17) 中的代码。语言对进一步处理的结果没有具体期望。在许多情况下，转换的结果将是调用扩展方法，但这不是语言规范的要求。它们可以是实例方法调用或由名为
    `Select`、`Where` 等属性的属性返回的委托的调用。
- en: The specification of query expressions puts in place an expectation of certain
    methods being available, but there’s no specific requirement for them all to be
    present. For example, if you write an API with suitable `Select`, `OrderBy`, and
    `Where` methods, you could use the kind of query shown in [listing 3.20](kindle_split_018_split_000.html#ch03ex20)
    even though you couldn’t use a query expression that includes a `join` clause.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式的规范设定了对某些方法存在的期望，但并没有具体要求它们都必须存在。例如，如果你编写了一个包含合适的 `Select`、`OrderBy` 和
    `Where` 方法的 API，即使你不能使用包含 `join` 子句的查询表达式，你仍然可以使用[列表 3.20](kindle_split_018_split_000.html#ch03ex20)
    中所示的那种查询。
- en: Although we’re not going to look at every clause available in query expressions
    in detail, I need to draw your attention to two related concepts. In part, these
    provide greater justification for the language designers introducing query expressions
    into the language.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会详细查看查询表达式中所有可用的子句，但我需要引起你的注意两个相关概念。在某种程度上，这些为语言设计者将查询表达式引入语言提供了更大的合理性。
- en: 3.7.2\. Range variables and transparent identifiers
  id: totrans-1197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.2\. 范围变量和透明标识符
- en: 'Query expressions introduce *range variables*, which aren’t like any other
    regular variables. They act as the per item input within each clause of the query.
    You’ve already seen how the `from` clause at the start of a query expression introduces
    a range variable. Here’s the query expression from [listing 3.20](kindle_split_018_split_000.html#ch03ex20)
    again with the range variable highlighted:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式引入了*范围变量*，它们与其他任何常规变量都不一样。它们在每个查询子句中充当每个项目的输入。你已经看到了查询表达式开头处的 `from` 子句是如何引入范围变量的。以下是将
    [列表 3.20](kindle_split_018_split_000.html#ch03ex20) 中的查询表达式再次列出，并突出显示范围变量：
- en: '[PRE152]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '***1* Introduces range variable in a from clause**'
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 FROM 子句中引入范围变量**'
- en: '***2* Uses the range variable in the following clauses**'
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在以下子句中使用范围变量**'
- en: That’s simple to understand when there’s only one range variable, but that initial
    `from` clause isn’t the only way a range variable can be introduced. The simplest
    example of a clause that introduces a new range variable is probably `let`. Suppose
    you want to refer to the length of the word multiple times in your query without
    having to call the `Length` property every time. For example, you could `orderby`
    it and include it in the output. The `let` clause allows you to write the query
    as shown in the following listing.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个范围变量时，这一点很容易理解，但最初的 `from` 子句并不是引入范围变量的唯一方式。引入新范围变量的子句中最简单的例子可能是 `let`。假设你希望在查询中多次引用单词的长度，而不必每次都调用
    `Length` 属性。例如，你可以按顺序排列它并将其包含在输出中。`let` 子句允许你将查询编写如下所示。
- en: Listing 3.21\. A `let` clause introducing a new range variable
  id: totrans-1203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.21\. 引入新范围变量的 `let` 子句
- en: '[PRE153]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: You now have two range variables in scope at the same time, as you can see from
    the use of both `length` and `word` in the `select` clause. That raises the question
    of how this can be represented in the query translation. You need a way of taking
    our original sequence of words and creating a sequence of word/length pairs, effectively.
    Then within the clauses that can use those range variables, you need to access
    the relevant item within the pair. The following listing shows how [listing 3.21](kindle_split_018_split_000.html#ch03ex21)
    is translated by the compiler using an anonymous type to represent the pair of
    values.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在同时有多个范围变量在作用域内，正如你在`select`子句中使用`length`和`word`时可以看到的。这引发了一个问题：如何在查询翻译中表示这一点。你需要一种方法来获取我们原始的单词序列，并创建一个单词/长度对的序列，实际上就是这样做。然后，在可以使用这些范围变量的子句中，你需要访问对中的相关项。以下列表显示了编译器如何使用匿名类型来表示值对，将[列表3.21](kindle_split_018_split_000.html#ch03ex21)翻译成查询。
- en: Listing 3.22\. Query translation using a transparent identifier
  id: totrans-1206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.22\. 使用透明标识符进行查询翻译
- en: '[PRE154]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The name `tmp` here isn’t part of the query translation. The specification uses
    `*` instead, and there’s no indication of what name should be given to the parameter
    when building an expression tree representation of the query. The name doesn’t
    matter because you don’t see it when you write the query. This is called a *transparent
    identifier*.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的名称`tmp`不是查询翻译的一部分。规范使用`*`代替，并且在构建查询表达式树表示时没有指明应该给参数赋予什么名称。名称并不重要，因为你编写查询时看不到它。这被称为*透明标识符*。
- en: I’m not going into all the details of query translation. That could be a whole
    chapter on its own. But I wanted to bring up transparent identifiers for two reasons.
    First, if you’re aware of how extra range variables are introduced, you won’t
    be surprised when you see them if you ever decompile a query expression. Second,
    they provide the biggest motivation for using query expressions, in my experience.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨查询翻译的所有细节。那可能是一整章的内容。但我提到透明标识符有两个原因。首先，如果你了解额外范围变量的引入方式，当你看到它们时就不会感到惊讶，尤其是当你反编译一个查询表达式时。其次，它们为我提供了使用查询表达式的最大动力。
- en: 3.7.3\. Deciding when to use which syntax for LINQ
  id: totrans-1210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.3\. 决定何时使用哪种LINQ语法的时机
- en: 'Query expressions can be appealing, but they’re not always the simplest way
    of representing a query. They always require a `from` clause to start with and
    either a `select` or `group by` clause to end with. That sounds reasonable, but
    it means that if you want a query that performs a single filtering operation,
    for example, you end up with quite a lot of baggage. For example, if you take
    just the filtering part of our word-based query, you’d have the following query
    expression:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式可能很有吸引力，但它们并不总是表示查询的最简单方式。它们总是需要以一个`from`子句开始，并以一个`select`或`group by`子句结束。这听起来合理，但这也意味着，如果你想进行单个过滤操作的查询，例如，你最终会得到相当多的冗余。例如，如果你只取我们基于单词的查询中的过滤部分，你会得到以下查询表达式：
- en: '[PRE155]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Compare that with the method syntax version of the query:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与查询的方法语法版本进行比较：
- en: '[PRE156]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: They both compile to the same code,^([[5](kindle_split_018_split_000.html#ch03fn5)])
    but I’d use the second syntax for such a simple query.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都会编译成相同的代码，^([[5](kindle_split_018_split_000.html#ch03fn5)]) 但对于如此简单的查询，我会使用第二种语法。
- en: ⁵
  id: totrans-1216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-1217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The compiler has special handling for `select` clauses that select just the
    current query item.
  id: totrans-1218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译器对仅选择当前查询项的`select`子句有特殊处理。
- en: '|  |'
  id: totrans-1219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There’s no single ubiquitous term for not using query expression syntax. I’ve
    seen it called *method syntax*, *dot syntax*, *fluent syntax*, and *lambda syntax*,
    to name just four. I’ll call it *method syntax* consistently, but if you hear
    other terms for it, don’t try to look for a subtle difference in meaning.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用查询表达式语法的做法，没有单一的通用术语。我见过它被称为*方法语法*、*点语法*、*流畅语法*和*lambda语法*，仅举四例。我会一致地称其为*方法语法*，但如果听到其他术语，请不要试图寻找其细微的意义差异。
- en: '|  |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Even when the query gets a little more complicated, method syntax can be more
    flexible. Many methods are available within LINQ that have no corresponding query
    expression syntax, including overloads of `Select` and `Where` that present the
    index of the item within the sequence as well as the item itself. Additionally,
    if you want a method call at the end of the query (for example, `ToList()` to
    materialize the result as a `List<T>`), you have to put the whole query expression
    in parentheses, whereas with method syntax you add the call on the end.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 即使查询变得稍微复杂一些，方法语法也可以更加灵活。LINQ 中有许多方法没有对应的查询表达式语法，包括 `Select` 和 `Where` 的重载，它们不仅提供了序列中项的索引，还提供了项本身。此外，如果你想在查询的末尾进行方法调用（例如，`ToList()`
    将结果实体化为 `List<T>`），你必须将整个查询表达式放在括号中，而使用方法语法，你可以在末尾添加调用。
- en: I’m not as down on query expressions as that may sound. In many cases, there’s
    no clear winner between the two syntax options, and I’d probably include our earlier
    filter, order, project example in that set. Query expressions really shine when
    the compiler is doing more work for you by handling all those transparent identifiers.
    You can do it all by hand, of course, but I’ve found that building up anonymous
    types as results and deconstructing them in each subsequent step gets annoying
    quickly. Query expressions make all of that much easier.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不像听起来那样反对查询表达式。在许多情况下，两种语法选项之间没有明显的胜者，我可能会把我们的早期过滤、排序、投影示例包括在内。查询表达式在编译器为你处理所有那些透明标识符时表现得尤为出色。当然，你可以手动完成所有这些，但我发现构建匿名类型作为结果并在每个后续步骤中解构它们很快就变得令人厌烦。查询表达式使所有这些变得更加容易。
- en: The upshot of all of this is that I strongly recommend that you become comfortable
    in both styles of query. If you tie yourself to always using query expressions
    or never using query expressions, you’ll be missing out on opportunities to make
    your code more readable. We’ve covered all the features in C# 3, but I’m going
    to take a moment to step back and show how they fit together to form LINQ.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果是，我强烈建议你熟悉这两种查询风格。如果你总是使用查询表达式或从不使用查询表达式，你将错过使你的代码更易读的机会。我们已经涵盖了 C# 3
    中的所有功能，但我要花一点时间回顾一下它们是如何组合在一起形成 LINQ 的。
- en: '3.8\. The end result: LINQ'
  id: totrans-1226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8. 最终结果：LINQ
- en: 'I’m not going to attempt to cover the various LINQ providers available these
    days. The LINQ technology I use most (by far) is LINQ to Objects, using the `Enumerable`
    static class and delegates. But in order to show how all the pieces come into
    play, let’s imagine that you have a query from something like Entity Framework.
    This isn’t real code that you can test, but it would be fine if you had a suitable
    database structure:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会尝试涵盖目前可用的各种 LINQ 提供者。我使用最多的 LINQ 技术是 LINQ to Objects，使用 `Enumerable` 静态类和委托。但为了展示所有这些部分是如何结合起来的，让我们假设你有一个来自类似
    Entity Framework 的查询。这不是你可以测试的真实代码，但如果你有一个合适的数据库结构，这将是完全可以接受的：
- en: '[PRE157]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'In this single example of a mere four lines, all of these features are used:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个仅有四行的简单示例中，所有这些特性都被使用了：
- en: Anonymous types, including projection initializers (to select just the name
    and price of the product)
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类型，包括投影初始化器（仅选择产品的名称和价格）
- en: Implicit typing using `var`, because otherwise you couldn’t declare the type
    of the `products` variable in a useful way
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `var` 进行隐式类型，因为否则你无法以有用的方式声明 `products` 变量的类型
- en: Query expressions, which you could do without in this case, but which make life
    a lot simpler for more-complicated queries
  id: totrans-1232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询表达式，在这种情况下你可以不用，但它们使更复杂的查询生活变得更加简单
- en: Lambda expressions, which are the result of the query expression translation
  id: totrans-1233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式，这是查询表达式翻译的结果
- en: Extension methods, which allow the translated query to be expressed via the
    `Queryable` class because of `dbContext.Products` implementing `IQueryable<Product>`
  id: totrans-1234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法允许通过实现 `IQueryable<Product>` 的 `dbContext.Products` 表达翻译后的查询，因为它们使用了 `Queryable`
    类
- en: Expression trees, which allow the logic in the query to be passed to the LINQ
    provider as data, so it can be converted into SQL and executed efficiently at
    the database
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式树，它允许将查询中的逻辑作为数据传递给 LINQ 提供者，以便它可以被转换为 SQL 并在数据库中高效执行
- en: Take away any one of these features, and LINQ would be significantly less useful.
    Sure, you could have in-memory collection processing without expression trees.
    You could write readable simple queries without query expressions. You could have
    dedicated classes with all the relevant methods without using extension methods.
    But it all fits together beautifully.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 取消任何一项功能，LINQ都将变得非常有用。当然，没有表达式树，你可以在内存中进行集合处理。你可以编写没有查询表达式的可读性简单的查询。你可以有所有相关方法的专用类，而不使用扩展方法。但所有这些功能都完美地结合在一起。
- en: Summary
  id: totrans-1237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: All the features in C# 3 are related to working with data in some form or other,
    and most are critical parts of LINQ.
  id: totrans-1238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 3中的所有功能都与以某种形式处理数据相关，其中大多数是LINQ的关键部分。
- en: Automatically implemented properties provide a concise way of exposing state
    that doesn’t need any extra behavior.
  id: totrans-1239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动实现属性提供了一种简洁的方式来暴露不需要额外行为的状态。
- en: Implicit typing with the `var` keyword (and for arrays) is necessary for working
    with anonymous types but also convenient to avoid long-winded repetition.
  id: totrans-1240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`var`关键字（以及数组）进行隐式类型转换对于处理匿名类型是必要的，同时也方便避免冗长的重复。
- en: Object and collection initializers make initialization simpler and more readable.
    They also allow initialization to occur as a single expression, which is crucial
    for working with other aspects of LINQ.
  id: totrans-1241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和集合初始化器使初始化更加简单和可读。它们还允许初始化作为一个单独的表达式发生，这对于处理LINQ的其他方面至关重要。
- en: Anonymous types allow you to effectively create a type just for a single local
    purpose in a lightweight way.
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类型允许你以轻量级的方式为单个局部目的创建一个类型。
- en: Lambda expressions provide an even simpler way of constructing delegates than
    anonymous methods. They also allow code to be expressed as data via expression
    trees, which can be used by LINQ providers to convert C# queries into other forms
    such as SQL.
  id: totrans-1243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式提供了一种比匿名方法更简单的方式来构造委托。它们还允许代码通过表达式树以数据的形式表达，这些表达式树可以被LINQ提供者用来将C#查询转换为其他形式，如SQL。
- en: Extension methods are static methods that can be called as if they were instance
    methods elsewhere. This allows for fluent interfaces to be written even for types
    that weren’t originally designed that way.
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法是可以像实例方法一样在其他地方调用的静态方法。这允许为原本未设计为这种方式的类型编写流畅的接口。
- en: Query expressions are translated into more C# that uses lambda expressions to
    express the query. Although these are great for complex queries, simpler ones
    are often easier to write using method syntax.
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询表达式被转换成更多使用lambda表达式来表示查询的C#代码。虽然这些对于复杂查询来说很棒，但简单的查询通常使用方法语法更容易编写。
- en: 'Chapter 4\. C# 4: Improving interoperability'
  id: totrans-1246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章：C# 4：提高互操作性
- en: '|  |'
  id: totrans-1247
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Using dynamic typing for interoperability and simpler reflection
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态类型以实现互操作性和更简单的反射
- en: Providing default values for parameters so the caller doesn’t need to specify
    them
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为参数提供默认值，这样调用者就不需要指定它们
- en: Specifying names for arguments to make calls clearer
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为参数指定名称以使调用更清晰
- en: Coding against COM libraries in a more streamlined fashion
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以更简洁的方式对COM库进行编码
- en: Converting between generic types with generic variance
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型方差在泛型类型之间进行转换
- en: '|  |'
  id: totrans-1254
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: C# 4 was an interesting release. The most dramatic change was the introduction
    of dynamic typing with the `dynamic` type. This feature makes C# statically typed
    (for most code) and dynamically typed (when using `dynamic`) in the same language.
    That’s rare within programming languages.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: C# 4版本是一个有趣的发布。最引人注目的变化是引入了`dynamic`类型的动态类型。这个特性使得C#在大多数代码中是静态类型（对于静态类型），而在使用`dynamic`时是动态类型。这在编程语言中是很少见的。
- en: Dynamic typing was introduced for interoperability, but that’s turned out not
    to be relevant in many developers’ day-to-day work. The major features in other
    releases (generics, LINQ, async/await) have become a natural part of most C# developers’
    toolkits, but dynamic typing is still used relatively rarely. I’m sure it’s useful
    to those who need it, and at the very least it’s an interesting feature.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型是为了互操作性而引入的，但结果发现它在许多开发者的日常工作中并不相关。其他版本中的主要功能（泛型、LINQ、async/await）已经成为大多数C#开发者工具箱的自然部分，但动态类型仍然相对较少使用。我相信它对需要它的人来说是有用的，至少它是一个有趣的功能。
- en: The other features in C# 4 also improve interoperability, particularly with
    COM. Some improvements are specific to COM, such as named indexers, implicit ref
    arguments, and embedded interop types. Optional parameters and named arguments
    are useful with COM, but they can also be used in purely managed code. These two
    are the features from C# 4 that I use on a daily basis.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: C# 4中的其他特性也提高了互操作性，尤其是与COM。一些改进是针对COM的，例如命名索引器、隐式引用参数和嵌入式互操作类型。可选参数和命名参数在COM中很有用，但它们也可以用于纯托管代码。这两个特性是我在日常使用中从C#
    4中使用的特性。
- en: 'Finally, C# 4 exposes a feature of generics that was present in the CLR from
    v2 (the first runtime version that included generics). Generic variance is simultaneously
    simple and complex. At first glance, it sounds obvious: a sequence of strings
    is obviously a sequence of objects, for example. But then we discover that a list
    of strings isn’t a list of objects, dashing the expectations of some developers.
    It’s a useful feature, but one that’s prone to inducing headaches when you examine
    it closely. Most of the time, you can take advantage of it without even being
    aware that you’re doing so. Hopefully, the coverage in this chapter will mean
    that if you do need to look closer because your code isn’t working as you expect,
    you’ll be in a good position to fix the problem without getting confused. We’ll
    start off by looking at dynamic typing.'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C# 4公开了从v2（包含泛型的第一个运行时版本）以来在CLR中存在的泛型特性。泛型方差既简单又复杂。乍一看，这似乎很明显：字符串序列显然是对象序列，例如。但后来我们发现字符串列表不是对象列表，这打破了某些开发者的预期。这是一个有用的特性，但当你仔细检查时，它容易引起头痛。大多数时候，你可以利用它，甚至不需要意识到你在这样做。希望本章的覆盖范围意味着，如果你需要更仔细地查看，因为你的代码没有按预期工作，你将处于一个很好的位置来解决问题，而不会感到困惑。我们将从查看动态类型开始。
- en: 4.1\. Dynamic typing
  id: totrans-1259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 动态类型
- en: 'Some features come with a lot of new syntax, but after you’ve explained the
    syntax, there’s not much left to say. Dynamic typing is the exact opposite: the
    syntax is extremely simple, but I could go into almost endless detail about the
    impact and implementation. This section shows you the basics and then goes into
    some of the details before closing with a few suggestions about how and when to
    use dynamic typing.'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特性伴随着大量的新语法，但解释完语法之后，就没有太多可说的了。动态类型则正好相反：语法极其简单，但我可以几乎无穷尽地详细说明其影响和实现。本节将向您展示基础知识，然后深入一些细节，最后提出一些关于如何以及何时使用动态类型的一些建议。
- en: 4.1.1\. Introduction to dynamic typing
  id: totrans-1261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 动态类型简介
- en: Let’s start with an example. The following listing shows two attempts to take
    a substring from some text. At the moment, I’m not trying to explain why you’d
    want to use dynamic typing, just what it does.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。以下列表显示了从某些文本中获取子字符串的两个尝试。目前，我并不是试图解释为什么你想使用动态类型，只是说明它做了什么。
- en: Listing 4.1\. Taking a substring by using dynamic typing
  id: totrans-1263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 使用动态类型获取子字符串
- en: '[PRE158]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '***1* Declares a variable with the dynamic type**'
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个动态类型的变量**'
- en: '***2* Calls the Substring method; this works.**'
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用`Substring`方法；这是可行的。**'
- en: '***3* Tries to call SUBSTR; this throws an exception.**'
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 尝试调用SUBSTR；这会抛出异常。**'
- en: A lot is going on here for such a small amount of code. The most important aspect
    is that it compiles at all. If you changed the first line to declare `text` by
    using the `string` type, the call to `SUBSTR` would fail at compile time. Instead,
    the compiler is happy to compile it without even looking for a method called `SUBSTR`.
    It doesn’t look for `Substring` either. Instead, both lookups are performed at
    execution time.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此少的代码中，发生了许多事情。最重要的方面是它能够编译。如果你将第一行改为使用`string`类型声明`text`，`SUBSTR`的调用将在编译时失败。相反，编译器乐于编译它，甚至不需要寻找名为`SUBSTR`的方法。它也不会寻找`Substring`。相反，这两个查找都是在执行时进行的。
- en: At execution time, the second line will look for a method called `Substring`
    that can be called with an argument of 6\. That method is found and returns a
    string, which you then assign to the `world` variable and print in a regular way.
    When the code looks for a method called `SUBSTR` that can be called with an argument
    of 6, it doesn’t find any such method, and the code fails with a `RuntimeBinderException`.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，第二行将寻找一个可以接受6个参数的名为`Substring`的方法。找到了该方法，并返回一个字符串，然后将其分配给`world`变量，并以常规方式打印。当代码寻找一个可以接受6个参数的名为`SUBSTR`的方法时，找不到这样的方法，代码将因`RuntimeBinderException`而失败。
- en: As mentioned in [chapter 3](kindle_split_018_split_000.html#ch03), this process
    of looking up the meaning of a name in a certain context is called *binding*.
    Dynamic typing is all about changing when binding happens from compile time to
    execution time. Instead of just generating IL that calls a method with a precise
    signature determined at execution time, the compiler generates IL that performs
    the binding and then acts on the result. All of this is triggered by using the
    `dynamic` type.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 3 章](kindle_split_018_split_000.html#ch03) 中所述，在特定上下文中查找名称含义的过程称为 *绑定*。动态类型完全是关于将绑定发生的时间从编译时改为执行时。编译器不是仅仅生成在执行时具有精确签名的
    IL 来调用方法，而是生成执行绑定并在结果上操作的 IL。所有这些都是由使用 `dynamic` 类型触发的。
- en: What is the dynamic type?
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是动态类型？
- en: '[Listing 4.1](kindle_split_019_split_000.html#ch04ex01) declared the `text`
    variable as being of type `dynamic`:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.1](kindle_split_019_split_000.html#ch04ex01) 声明了 `text` 变量为 `dynamic`
    类型：'
- en: '[PRE159]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: What is the `dynamic` type? It’s different from other types you see in C#, because
    it exists only as far as the C# language is concerned. There’s no `System.Type`
    associated with it, and the CLR doesn’t know about it at all. Anytime you use
    `dynamic` in C#, the IL uses `object` decorated with `[Dynamic]` if necessary.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 `dynamic` 类型？它与你在 C# 中看到的其他类型不同，因为它只存在于 C# 语言范围内。与它相关的 `System.Type` 不存在，CLR
    完全不知道它。任何时候你在 C# 中使用 `dynamic`，如果需要，IL 会使用带有 `[Dynamic]` 装饰的 `object`。
- en: '|  |'
  id: totrans-1275
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If the dynamic type is used in a method signature, the compiler needs to make
    that information available for code compiling against it. There’s no need to do
    this for local variables.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动态类型用于方法签名，编译器需要将此信息提供给针对它编译的代码。对于局部变量则不需要这样做。
- en: '|  |'
  id: totrans-1278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The basic rules of the `dynamic` type are simple:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic` 类型的基本规则很简单：'
- en: There’s an implicit conversion from any nonpointer type to `dynamic`.
  id: totrans-1280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何非指针类型到 `dynamic` 的隐式转换。
- en: There’s an implicit conversion from an expression of type `dynamic` to any nonpointer
    type.
  id: totrans-1281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从类型 `dynamic` 的表达式到任何非指针类型的隐式转换。
- en: Expressions that involve a value of type `dynamic` are usually bound at execution
    time.
  id: totrans-1282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 涉及类型 `dynamic` 值的表达式通常在执行时绑定。
- en: Most expressions that involve a value of type `dynamic` have a compile-time
    type of `dynamic` as well.
  id: totrans-1283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数涉及类型 `dynamic` 值的表达式在编译时类型也是 `dynamic`。
- en: 'You’ll look at the exceptions to the last two points shortly. Using this list
    of rules, you can look at [listing 4.1](kindle_split_019_split_000.html#ch04ex01)
    again with fresh eyes. Let’s consider the first two lines:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到最后两个点的例外。使用这个规则列表，你可以再次用新的眼光看 [列表 4.1](kindle_split_019_split_000.html#ch04ex01)。让我们考虑前两行：
- en: '[PRE160]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'In the first line, you’re converting from `string` to `dynamic`, which is fine
    because of rule 1\. The second line demonstrates all three of the other rules:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，你将 `string` 转换为 `dynamic`，这是可以的，因为规则 1。第二行演示了其他三个规则：
- en: '`text.Substring(6)` is bound at execution time (rule 3).'
  id: totrans-1287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text.Substring(6)` 在执行时绑定（规则 3）。'
- en: The compile-time type of that expression is `dynamic` (rule 4).
  id: totrans-1288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该表达式的编译时类型是 `dynamic`（规则 4）。
- en: There’s an implicit conversion from that expression to `string` (rule 2).
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从该表达式到 `string` 的隐式转换（规则 2）。
- en: The conversion from an expression of type `dynamic` to a nondynamic type is
    dynamically bound, too. If you declared the `world` variable to be of type `int`,
    that would compile but fail at execution time with a `RuntimeBinderException`.
    If you declared it to be of type `XNamespace`, that would compile and then at
    execution time the binder would use the user-defined implicit conversion from
    `string` to `XNamespace`. With this in mind, let’s look at more examples of dynamic
    binding.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型 `dynamic` 的表达式到非动态类型的转换也是动态绑定的。如果你将 `world` 变量声明为 `int` 类型，那么代码可以编译但在执行时会产生
    `RuntimeBinderException` 异常。如果你将其声明为 `XNamespace` 类型，那么代码可以编译，并在执行时绑定器会使用用户定义的从
    `string` 到 `XNamespace` 的隐式转换。考虑到这一点，让我们看看更多关于动态绑定的示例。
- en: Applying dynamic binding in a variety of contexts
  id: totrans-1291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在各种上下文中应用动态绑定
- en: So far, you’ve seen dynamic binding based on the dynamic target of a method
    call and then a conversion, but almost any aspect of execution can be dynamic.
    The following listing demonstrates this in the context of the addition operator
    and performs three kinds of addition based on the type of the dynamic value at
    execution time.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了基于方法调用动态目标和转换的动态绑定，但几乎任何执行方面都可以是动态的。以下列表在加法运算符的上下文中演示了这一点，并基于执行时动态值的类型执行三种类型的加法。
- en: Listing 4.2\. Addition of dynamic values
  id: totrans-1293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 动态值的添加
- en: '[PRE161]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '***1* Performs addition based on the type at execution time**'
  id: totrans-1295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根据执行时的类型执行加法**'
- en: '***2* Calls the method with different values**'
  id: totrans-1296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用不同值调用方法**'
- en: 'The results of [listing 4.2](kindle_split_019_split_000.html#ch04ex02) are
    as follows:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.2](kindle_split_019_split_000.html#ch04ex02) 的结果如下：'
- en: '[PRE162]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Each kind of addition makes sense for the type involved, but in a statically
    typed context, they’d look different. As one final example, the following listing
    shows how method overloading behaves with dynamic method arguments.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的加法对于涉及的类型都有意义，但在静态类型上下文中，它们看起来会不同。作为一个最后的例子，以下列表显示了动态方法参数的方法重载行为。
- en: Listing 4.3\. Dynamic method overload resolution
  id: totrans-1300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 动态方法重载解析
- en: '[PRE163]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '***1* Calls SampleMethod dynamically**'
  id: totrans-1302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 动态调用 SampleMethod**'
- en: '***2* Indirectly calls SampleMethod with different types**'
  id: totrans-1303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 间接使用不同类型调用 SampleMethod**'
- en: 'The output of [listing 4.3](kindle_split_019_split_000.html#ch04ex03) is as
    follows:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.3](kindle_split_019_split_000.html#ch04ex03) 的输出如下：'
- en: '[PRE164]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The third and fourth lines of the output are particularly interesting. They
    show that the overload resolution at execution time is still aware of conversions.
    In the third line, a `long` value is converted to `decimal` rather than `int`,
    despite being an integer in the range of `int`. In the fourth line, a `string`
    value is converted to `object`. The aim is that, as far as possible, the binding
    at execution time should behave the same way it would’ve at compile time, just
    using the types of the dynamic values as they’re discovered at execution time.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第三行和第四行特别有趣。它们显示执行时的重载解析仍然了解转换。在第三行中，一个 `long` 值被转换为 `decimal` 而不是 `int`，尽管它在
    `int` 的范围内。在第四行中，一个 `string` 值被转换为 `object`。目标是尽可能使执行时的绑定行为与编译时相同，只是使用在执行时发现的动态值的类型。
- en: '|  |'
  id: totrans-1307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Only dynamic values are considered dynamically**'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '**只有动态值被认为是动态的**'
- en: The compiler works hard to make sure the right information is available at execution
    time. When binding involves multiple values, the compile-time type is used for
    any values that are statically typed, but the execution-time type is used for
    any values of type dynamic. Most of the time, this nuance is irrelevant, but I’ve
    provided an example with comments in the downloadable source code.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器努力确保在执行时提供正确的信息。当绑定涉及多个值时，编译时类型用于任何静态类型值，但执行时类型用于任何类型为 dynamic 的值。大多数情况下，这种细微差别并不重要，但我已在可下载的源代码中提供了一个带有注释的示例。
- en: '|  |'
  id: totrans-1310
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The result of any dynamically bound method call has a compile-time type of
    `dynamic`. When binding occurs, if the chosen method has a `void` return type
    and the result of the method was used (for example, being assigned to a variable),
    then binding fails. That’s the case for most dynamically bound operations: the
    compiler has little information about what the dynamic operation will entail.
    That rule has a few exceptions.'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 任何动态绑定方法调用的编译时类型都是 `dynamic`。当绑定发生时，如果选择的方法具有 `void` 返回类型并且方法的结果被使用（例如，被分配给变量），则绑定失败。大多数动态绑定操作都是这种情况：编译器对动态操作将涉及什么知之甚少。该规则有一些例外。
- en: What can the compiler check in dynamically bound contexts?
  id: totrans-1312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译器在动态绑定上下文中可以检查什么？
- en: 'If the context of a method call is known at compile time, the compiler is able
    to check what methods exist with the specified name. If no methods could possibly
    match at execution time, a compile-time error is still reported. This applies
    to the following:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编译时已知方法调用的上下文，编译器能够检查存在哪些具有指定名称的方法。如果在执行时没有可能匹配的方法，编译器仍然会报告编译时错误。这适用于以下情况：
- en: Instance methods and indexers where the target isn’t a dynamic value
  id: totrans-1314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法和索引器，其中目标不是动态值
- en: Static methods
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: Constructors
  id: totrans-1316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: The following listing shows various examples of calls using dynamic values that
    fail at compile time.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用动态值进行调用并在编译时失败的多种示例。
- en: Listing 4.4\. Examples of compile-time failures involving dynamic values
  id: totrans-1318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 涉及动态值的编译时失败示例
- en: '[PRE165]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '***1* No String.Substring method with four paramet**'
  id: totrans-1320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 没有四个参数的 String.Substring 方法**'
- en: '***2* No generic String.Equals method**'
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 没有泛型 String.Equals 方法**'
- en: '***3* No String constructors with two parameters accepting a string as a second
    argument**'
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 没有两个参数的 String 构造函数接受字符串作为第二个参数**'
- en: '***4* No String indexer with two parameters**'
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 没有两个参数的 String 索引器**'
- en: Just because the compiler is able to tell that these particular examples are
    definitely broken doesn’t mean it’ll always be able to do so. Dynamic binding
    is always a bit of a leap into the unknown unless you’re very careful about the
    values involved.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为编译器能够确定这些特定的例子肯定是有问题的，并不意味着它总能做到这一点。除非你非常小心地处理涉及的值，否则动态绑定总是一种对未知的跳跃。
- en: The examples I’ve given would still use dynamic binding if they compiled. There
    are only a few cases where that’s not the case.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 我给出的例子如果编译的话，仍然会使用动态绑定。只有少数情况下不是这样。
- en: What operations involving dynamic values aren’t dynamically bound?
  id: totrans-1326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 涉及动态值的操作哪些不是动态绑定的？
- en: 'Almost everything you do with a dynamic value involves binding of some kind
    and finding the right method call, property, conversion, operator, and so on.
    There are just a few things that the compiler doesn’t need to generate any binding
    code for:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎你用动态值做的每一件事都涉及到某种绑定和找到正确的方法调用、属性、转换、运算符等等。只有少数事情编译器不需要生成任何绑定代码：
- en: Assignments to a variable of type `object` or `dynamic`. No conversion is required,
    so the compiler can just copy the existing reference.
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值赋给 `object` 或 `dynamic` 类型的变量。不需要转换，因此编译器可以直接复制现有的引用。
- en: Passing an argument to a method with a corresponding parameter of type `object`
    or `dynamic`. That’s like assigning a variable, but the variable is the parameter.
  id: totrans-1329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数传递给具有相应类型 `object` 或 `dynamic` 的方法。这就像赋值一样，但变量是参数。
- en: Testing a value’s type with the `is` operator.
  id: totrans-1330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `is` 运算符测试值的类型。
- en: Attempting to convert a value with the `as` operator.
  id: totrans-1331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 `as` 运算符转换值。
- en: Although the execution-time binding infrastructure is happy to find user-defined
    conversions if you convert a dynamic value to a specific type with a cast or just
    do so implicitly, the `is` and `as` operators never use user-defined conversions,
    so no binding is required. In a similar way, *almost* all operations with dynamic
    values have a result that is also dynamic.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管执行时绑定基础设施乐于在将动态值转换为特定类型时找到用户定义的转换，无论是通过类型转换还是隐式地这样做，但 `is` 和 `as` 运算符永远不会使用用户定义的转换，因此不需要绑定。以类似的方式，*几乎*所有涉及动态值的操作都有也是动态的结果。
- en: What operations involving dynamic values still have a static type?
  id: totrans-1333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 涉及动态值的操作哪些仍然具有静态类型？
- en: 'Again, the compiler wants to help as much as it can. If an expression can always
    be of only one specific type, the compiler is happy to make that the compile-time
    type of the expression. For example, if `d` is a variable of type `dynamic`, the
    following are true:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，编译器尽可能地提供帮助。如果一个表达式始终只能是特定类型，编译器很乐意将其作为表达式的编译时类型。例如，如果 `d` 是 `dynamic`
    类型的变量，以下都是正确的：
- en: The expression `new SomeType(d)` has a compile-time type of `SomeType`, even
    though the constructor is bound dynamically at execution time.
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 `new SomeType(d)` 在编译时的类型是 `SomeType`，尽管构造函数在执行时是动态绑定的。
- en: The expression `d is SomeType` has a compile-time type of `bool`.
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 `d is SomeType` 在编译时的类型是 `bool`。
- en: The expression `d as SomeType` has a compile-time type of `SomeType`.
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 `d as SomeType` 在编译时的类型是 `SomeType`。
- en: That’s all the detail you need for this introduction. In [section 4.1.4](kindle_split_019_split_000.html#ch04lev2sec4),
    you’ll look at unexpected twists, both at compile time and execution time. But
    now that you have the flavor of dynamic typing, you can look at some of its power
    beyond performing regular binding at execution time.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本介绍所需的全部细节。在 [第 4.1.4 节](kindle_split_019_split_000.html#ch04lev2sec4) 中，你将看到编译时和执行时的一些意外转折。但现在你已经了解了动态类型的感觉，你可以看看它在执行时进行常规绑定之外的强大功能。
- en: 4.1.2\. Dynamic behavior beyond reflection
  id: totrans-1339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 超越反射的动态行为
- en: One use for dynamic typing is to effectively ask the compiler and framework
    to perform reflection operations for you based on the members declared in types
    in the usual way. Although that’s a perfectly reasonable use, dynamic typing is
    more extensible. Part of the reason for its introduction was to allow better interoperability
    with dynamic languages that allow on-the-fly changes in binding. Many dynamic
    languages allow interception of calls at execution time. This has usages such
    as transparent caching and logging or making it look like there are functions
    and fields that are never declared by name in the source code.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型的一个用途是有效地请求编译器和框架根据在类型中声明的成员以通常的方式为你执行反射操作。尽管这是一个完全合理的用途，但动态类型具有更好的扩展性。引入它的部分原因是为了允许与允许动态绑定即时更改的动态语言更好地互操作。许多动态语言允许在执行时拦截调用。这有如透明缓存和日志记录或使看起来有函数和字段从未在源代码中以名称声明等用途。
- en: Imaginary example of database access
  id: totrans-1341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据库访问的想象示例
- en: 'As an (unimplemented) example of the kind of thing you might want to do, imagine
    you have a database containing a table of books, including their authors. Dynamic
    typing would make this sort of code possible:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 作为（未实现）的一个例子，想象一下你可能想要做的类似事情，比如你有一个包含书籍及其作者的数据库表。动态类型可以使这种代码成为可能：
- en: '[PRE166]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This would involve the following dynamic operations:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 这将涉及以下动态操作：
- en: The `Database` class would respond to a request for the `Books` property by
    querying the database schema for a table called `Books` and returning some sort
    of table object.
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Database` 类会响应对 `Books` 属性的请求，通过查询名为 `Books` 的数据库模式表，并返回某种类型的表对象。'
- en: That table object would respond to the `SearchByAuthor` method call by spotting
    that it started with `SearchBy` and looking for a column called `Author` within
    the schema. It would then generate SQL to query by that column using the provided
    argument and return a list of row objects.
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个表对象会响应 `SearchByAuthor` 方法调用，注意到它以 `SearchBy` 开头，并在模式中寻找名为 `Author` 的列。然后它会生成使用提供的参数查询该列的
    SQL 语句，并返回一个行对象列表。
- en: Each row object would respond to the `Title` property by returning the value
    of the `Title` column.
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个行对象会响应 `Title` 属性，通过返回 `Title` 列的值。
- en: 'If you’re used to Entity Framework or a similar object-relational mapping (ORM),
    this may not sound like anything new. You can write classes fairly easily that
    enable the same kind of querying code or generate those classes from the schema.
    The difference here is that it’s all dynamic: there’s no `Book` or `BooksTable`
    class. It all just happens at execution time. In [section 4.1.5](kindle_split_019_split_000.html#ch04lev2sec5),
    I’ll talk about whether that’s a good or a bad thing in general, but I hope you
    can at least see how it could be useful in some situations.'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了 Entity Framework 或类似的对象关系映射（ORM），这可能听起来并不新鲜。你可以轻松编写启用相同查询代码的类，或者从模式生成这些类。这里的区别在于它全部是动态的：没有
    `Book` 或 `BooksTable` 类。所有这些都是在执行时发生的。在 [4.1.5 节](kindle_split_019_split_000.html#ch04lev2sec5)
    中，我将讨论这通常是一个好是坏的事情，但我希望你能至少看到它在某些情况下可能是有用的。
- en: Before I introduce you to the types that allow all of this to happen, let’s
    look at two examples that *are* implemented. First, you’ll look at a type in the
    framework, and then at Json.NET.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向你介绍允许这一切发生的类型之前，让我们看看两个已实现的示例。首先，你将查看框架中的一个类型，然后是 Json.NET。
- en: 'ExpandoObject: A dynamic bag of data and methods'
  id: totrans-1350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ExpandoObject：动态的数据和方法集合
- en: The .NET Framework provides a type called `ExpandoObject` in the namespace `System.Dynamic`.
    It operates in two modes depending on whether you’re using it as a dynamic value.
    The following listing gives a brief example to help you make sense of the description
    that follows it.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架在 `System.Dynamic` 命名空间中提供了一个名为 `ExpandoObject` 的类型。它根据你是否将其用作动态值在两种模式下运行。以下列表提供了一个简短的示例，以帮助您理解随后的描述。
- en: Listing 4.5\. Storing and retrieving items in an `ExpandoObject`
  id: totrans-1352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 在 `ExpandoObject` 中存储和检索项
- en: '[PRE167]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '***1* Assigns data to a property**'
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将数据分配给属性**'
- en: '***2* Assigns a delegate to a property**'
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将委托分配给属性**'
- en: '***3* Accesses the data and delegate dynamically**'
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 动态访问数据和委托**'
- en: '***4* Treats the ExpandoObject as a dictionary to print the keys**'
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 ExpandoObject 作为字典来打印键**'
- en: '***5* Populates data with the static context and fetches it from the dynamic
    value**'
  id: totrans-1358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用静态上下文填充数据并从动态值中获取它**'
- en: When `ExpandoObject` is used in a statically typed context, it’s a dictionary
    of name/value pairs, and it implements `IDictionary<string, object>` as you’d
    expect from a normal dictionary. You can use it that way, looking up keys that
    are provided at execution time and so on.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ExpandoObject`在静态类型上下文中使用时，它是一个键/值对的字典，并实现了`IDictionary<string, object>`，正如您从普通字典中期望的那样。您可以那样使用它，查找在执行时提供的键，等等。
- en: More important, it also implements `IDynamicMetaObjectProvider`. This is the
    entry point for dynamic behavior. You’ll look at the interface itself later, but
    `ExpandoObject` implements it so you can access the dictionary keys by name within
    code. When you invoke a method on an `ExpandoObject` in a dynamic context, it’ll
    look up the method name as a key in the dictionary. If the value associated with
    that key is a delegate with appropriate parameters, the delegate is executed,
    and the result of the delegate is used as the result of the method call.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，它还实现了`IDynamicMetaObjectProvider`。这是动态行为的入口点。您稍后会查看该接口本身，但`ExpandoObject`实现了它，这样您可以在代码中通过名称访问字典键。当您在动态上下文中对一个`ExpandoObject`调用方法时，它将在字典中查找方法名作为键。如果与该键关联的值是一个具有适当参数的委托，则执行该委托，并将委托的结果用作方法调用的结果。
- en: '[Listing 4.5](kindle_split_019_split_000.html#ch04ex05) stored only one data
    value and one delegate, but you can store many with whatever names you want. It’s
    just a dictionary that can be accessed dynamically.'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4.5](kindle_split_019_split_000.html#ch04ex05) 仅存储了一个数据值和一个委托，但您可以存储许多具有任何名称的数据。它只是一个可以动态访问的字典。'
- en: 'You could implement much of the earlier database example by using `ExpandoObject`.
    You’d create one to represent the `Books` table and then represent each book with
    a separate `ExpandoObject`, too. The table would have a key of `SearchByAuthor`
    with a suitable delegate value to execute the query. Each book would have a key
    of `Title` storing the title and so on. In practice, though, you’d want to implement
    `IDynamicMetaObjectProvider` directly or use `DynamicObject`. Before diving into
    those types, let’s take a look at another implementation: accessing JSON data
    dynamically.'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`ExpandoObject`来实现大部分早期的数据库示例。您会创建一个来表示`Books`表，然后使用单独的`ExpandoObject`来表示每本书。表将有一个`SearchByAuthor`键，以及一个合适的委托值来执行查询。每本书将有一个`Title`键来存储标题等等。然而，在实践中，您可能希望直接实现`IDynamicMetaObjectProvider`或使用`DynamicObject`。在深入研究这些类型之前，让我们看看另一种实现：动态访问JSON数据。
- en: The dynamic view of Json.NET
  id: totrans-1363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Json.NET的动态视图
- en: JSON is everywhere these days, and one of the most popular libraries for consuming
    and creating JSON is Json.NET.^([[1](kindle_split_019_split_000.html#ch04fn1)])
    It provides multiple ways of handling JSON, including parsing straight to user-provided
    classes and parsing to an object model that’s closer to LINQ to XML. The latter
    is called *LINQ to JSON* with types such as `JObject`, `JArray`, and `JProperty`.
    It can be used like LINQ to XML, with access via strings, or it can be used dynamically.
    The following listing shows both approaches for the same JSON.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: JSON现在无处不在，而用于消费和创建JSON最受欢迎的库之一是Json.NET.^([[1](kindle_split_019_split_000.html#ch04fn1)])
    它提供了多种处理JSON的方法，包括直接解析到用户提供的类以及解析到一个更接近LINQ to XML的对象模型。后者被称为 *LINQ to JSON*，具有`JObject`、`JArray`和`JProperty`等类型。它可以像LINQ
    to XML一样使用，通过字符串进行访问，或者可以动态使用。以下列表展示了相同JSON的两种方法。
- en: ¹
  id: totrans-1365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Other JSON libraries are available, of course. I just happen to be most familiar
    with Json.NET.
  id: totrans-1367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，还有其他JSON库可用。我只是恰好对Json.NET最熟悉。
- en: Listing 4.6\. Using JSON data dynamically
  id: totrans-1368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. 动态使用JSON数据
- en: '[PRE168]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '***1* Hardcoded sample JSON**'
  id: totrans-1370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 硬编码的样本JSON**'
- en: '***2* Parses the JSON to a JObject**'
  id: totrans-1371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将JSON解析为JObject**'
- en: '***3* Uses the statically typed view**'
  id: totrans-1372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用静态类型视图**'
- en: '***4* Uses the dynamically typed view**'
  id: totrans-1373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用动态类型视图**'
- en: This JSON is simple but includes a nested object. The second half of the code
    shows how that can be accessed by either using the indexers within LINQ to JSON
    or using the dynamic view it provides.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON很简单，但包含一个嵌套对象。代码的第二部分展示了如何通过使用LINQ to JSON中的索引器或使用它提供的动态视图来访问它。
- en: Which of these do you prefer? Arguments exist for and against each approach.
    Both are prone to typos, whether within a string literal or the dynamic property
    access. The statically typed view lends itself to extracting the property names
    into constants for reuse, but the dynamically typed view is simpler to read when
    prototyping. I’ll make some suggestions for when and where dynamic typing is appropriate
    in [section 4.1.5](kindle_split_019_split_000.html#ch04lev2sec5), but it’s worth
    reflecting on your initial reactions before you get there. Next we’ll take a quick
    look at how to do all of this yourself.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 你更喜欢哪一个？每种方法都有支持和反对的理由。两者都容易出错，无论是在字符串字面量中还是在动态属性访问中。静态类型视图有利于将属性名称提取到常量中以供重用，但动态类型视图在原型设计时更容易阅读。我将在
    [第 4.1.5 节](kindle_split_019_split_000.html#ch04lev2sec5) 中提出一些关于何时何地使用动态类型建议，但在到达那里之前，值得反思你的初始反应。接下来，我们将快速看一下如何自己完成所有这些。
- en: Implementing dynamic behavior in your own code
  id: totrans-1376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在自己的代码中实现动态行为
- en: Dynamic behavior is complicated. Let’s get that out of the way to start with.
    Please don’t expect to come away from this section ready to write a production-ready
    optimized implementation of whatever amazing idea you have. This is only a starting
    point. That said, it should be enough to let you explore and experiment so you
    can decide how much effort you wish to invest in learning all the details.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 动态行为很复杂。让我们先把这个讲清楚。请不要期望从这个部分离开后就能准备好编写一个针对任何令人惊叹的想法的生产就绪的优化实现。这只是一个起点。话虽如此，这应该足以让你探索和实验，以便你可以决定你愿意投入多少精力去学习所有细节。
- en: 'When I presented `ExpandoObject`, I mentioned that it implements the interface
    `IDynamicMetaObjectProvider`. This is the interface signifying that an object
    implements its own dynamic behavior instead of just being happy to let the reflection-based
    infrastructure work in the normal way. As an interface, it looks deceptively simple:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 当我介绍 `ExpandoObject` 时，我提到它实现了 `IDynamicMetaObjectProvider` 接口。这个接口表示一个对象实现了自己的动态行为，而不是仅仅满足于让基于反射的基础设施按正常方式工作。作为一个接口，它看起来欺骗性地简单：
- en: '[PRE169]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The complexity lies in `DynamicMetaObject`, which is the class that drives
    everything else. Its official documentation gives a clue as to the level you need
    to think at when working with it:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性在于 `DynamicMetaObject`，这是驱动其他一切的东西的类。它的官方文档给出了当你与它一起工作时需要思考的水平的一个线索：
- en: Represents the dynamic binding and a binding logic of an object participating
    in the dynamic binding.
  id: totrans-1381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表示参与动态绑定的对象的动态绑定和绑定逻辑。
- en: 'Even having used the class, I wouldn’t like to claim I fully understand that
    sentence, nor could I write a better description. Typically, you’d create a class
    deriving from `DynamicMetaObject` and override some of the virtual methods it
    provides. For example, if you want to handle method invocations dynamically, you’d
    override this method:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用了这个类，我也不敢声称我完全理解那个句子，也无法写出更好的描述。通常，你会创建一个从 `DynamicMetaObject` 继承的类，并重写它提供的一些虚拟方法。例如，如果你想动态处理方法调用，你会重写这个方法：
- en: '[PRE170]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The `binder` parameter gives information such as the name of the method being
    called and whether the caller expects binding to be performed case sensitively.
    The `args` parameter provides the arguments provided by the caller in the form
    of more `DynamicMetaObject` values. The result is yet another `DynamicMetaObject`
    representing how the method call should be handled. It doesn’t perform the call
    immediately but creates an expression tree representing what the call would do.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '`binder` 参数提供了有关被调用方法名称和调用者是否期望按大小写敏感地执行绑定等信息。`args` 参数提供了调用者以更多 `DynamicMetaObject`
    值的形式提供的参数。结果是另一个 `DynamicMetaObject`，表示应该如何处理方法调用。它不会立即执行调用，而是创建一个表达式树，表示调用将会做什么。'
- en: 'All of this is extremely complicated but allows for complex situations to be
    handled efficiently. Fortunately, you don’t have to implement `IDynamicMetaObjectProvider`
    yourself, and I’m not going to try to do so. Instead, I’ll give an example using
    a much friendlier type: `DynamicObject`.'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都极其复杂，但允许高效地处理复杂情况。幸运的是，你不必自己实现 `IDynamicMetaObjectProvider`，我也不打算尝试这样做。相反，我将给出一个使用更友好的类型的示例：`DynamicObject`。
- en: The `DynamicObject` class acts as a base class for types that want to implement
    dynamic behavior as simply as possible. The result may not be as efficient as
    directly implementing `IDynamicMetaObjectProvider` yourself, but it’s much easier
    to understand.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '`DynamicObject` 类作为想要尽可能简单实现动态行为的类型的基类。结果可能不如直接实现 `IDynamicMetaObjectProvider`
    那样高效，但它更容易理解。'
- en: 'As a simple example, you’re going to create a class (`SimpleDynamicExample`)
    with the following dynamic behavior:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的例子，你将创建一个具有以下动态行为的类 (`SimpleDynamicExample`)：
- en: Invoking any method on it prints a message to the console, including the method
    name and arguments.
  id: totrans-1388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在它上调用任何方法都会在控制台打印一条消息，包括方法名称和参数。
- en: Fetching a property usually returns that property name with a prefix to show
    you really called into the dynamic behavior.
  id: totrans-1389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取属性通常返回带有前缀的属性名称，以显示你确实调用了动态行为。
- en: The following listing shows how you would use the class.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用该类。
- en: Listing 4.7\. Example of intended use of dynamic behavior
  id: totrans-1391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 动态行为预期使用示例
- en: '[PRE171]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The output should be as follows:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE172]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: There’s nothing special about the names `CallSomeMethod` and `SomeProperty`,
    but you could’ve reacted to specific names in different ways if you’d wanted to.
    Even the simple behavior described so far would be tricky to get right using the
    low-level interface, but the following listing shows how easy it is with `DynamicObject`.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallSomeMethod` 和 `SomeProperty` 这两个名称并没有什么特别之处，但如果你想要对特定的名称做出不同的反应，你完全可以这样做。即使到目前为止所描述的简单行为，使用低级接口来实现也是相当棘手的，但下面的列表展示了使用
    `DynamicObject` 是多么简单。'
- en: Listing 4.8\. Implementing `SimpleDynamicExample`
  id: totrans-1396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 实现 `SimpleDynamicExample`
- en: '[PRE173]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '***1* Handles method calls**'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理方法调用**'
- en: '***2* Handles property access**'
  id: totrans-1399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 处理属性访问**'
- en: As with the methods on `DynamicMetaObject`, you still receive binders when overriding
    the methods in `DynamicObject`, but you don’t need to worry about expression trees
    or other `DynamicMetaObject` values anymore. The return value from each method
    indicates whether the dynamic object successfully handled the operation. If you
    return `false`, a `RuntimeBinderException` will be thrown.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 `DynamicMetaObject` 上的方法一样，当你覆盖 `DynamicObject` 中的方法时，你仍然会收到绑定器，但你不再需要担心表达式树或其他
    `DynamicMetaObject` 值了。每个方法的返回值都指示动态对象是否成功处理了操作。如果你返回 `false`，将会抛出 `RuntimeBinderException`。
- en: 'That’s all I’m going to show you in terms of implementing dynamic behavior,
    but I hope the simplicity of [listing 4.8](kindle_split_019_split_000.html#ch04ex08)
    will encourage you to experiment with `DynamicObject`. Even if you never use it
    in production, playing with it can be a lot of fun. If you want to give it a try
    but don’t have concrete ideas, you could always try implementing the `Database`
    example I gave at the start of this section. As a reminder, here’s the code you’d
    be trying to enable:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现动态行为方面，我就要展示这些内容了，但我希望 [列表 4.8](kindle_split_019_split_000.html#ch04ex08)
    的简单性能够鼓励你尝试使用 `DynamicObject`。即使你永远不会在生产环境中使用它，玩弄它也可以很有趣。如果你想尝试但还没有具体想法，你始终可以尝试实现我在本节开头给出的
    `Database` 示例。作为提醒，以下是你要尝试启用的代码：
- en: '[PRE174]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Next, you’ll take a look at the code the C# compiler generates when it encounters
    dynamic values.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将查看 C# 编译器在遇到动态值时生成的代码。
- en: 4.1.3\. A brief look behind the scenes
  id: totrans-1404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 简要了解幕后情况
- en: You’re probably aware by now that I enjoy looking at the IL that the C# compiler
    uses to implement its various features. You’ve already looked at how captured
    variables in lambda expressions can result in extra classes being generated and
    how lambda expressions converted to expression trees result in calls to methods
    in the `Expression` class. Dynamic typing works a little bit like expression trees
    in terms of creating a data representation of the source code, but on a larger
    scale.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经知道，我喜欢查看 C# 编译器用来实现其各种功能的 IL（中间语言）。你已经看到了 lambda 表达式中的捕获变量如何导致生成额外的类，以及
    lambda 表达式转换为表达式树如何导致调用 `Expression` 类中的方法。动态类型在创建源代码的数据表示方面与表达式树类似，但规模更大。
- en: This section goes into even less detail than the previous one. Although the
    details are interesting, you almost certainly won’t need to know them.^([[2](kindle_split_019_split_000.html#ch04fn2)])
    The good news is that it’s all open source, so you can go as low-level as you
    want to if you find yourself tantalized by this brief introduction to the topic.
    We’ll start off by considering which subsystem is responsible for what aspect
    of dynamic typing.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节比上一节更不详细。虽然细节很有趣，但你几乎肯定不需要知道它们.^([[2](kindle_split_019_split_000.html#ch04fn2)])
    好消息是，它全部都是开源的，所以如果你被这个主题的简要介绍所吸引，你可以深入到底层。我们将从考虑哪个子系统负责动态类型的哪个方面开始。
- en: ²
  id: totrans-1407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And to be honest, I don’t know enough details to do the whole topic justice.
  id: totrans-1409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 坦白说，我对细节了解得不够，无法对整个主题进行公正的讨论。
- en: Who does what?
  id: totrans-1410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 谁负责什么？
- en: 'Normally when you consider a C# feature, it’s natural to divide responsibility
    into three areas:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当你考虑一个 C# 功能时，很自然地将其责任分为三个领域：
- en: The C# compiler
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 编译器
- en: The CLR
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR
- en: The framework libraries
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架库
- en: Some features are purely in the domain of the C# compiler. Implicit typing is
    an example of this. The framework doesn’t need to provide any types to support
    `var`, and the runtime is blissfully unaware of whether you used implicit or explicit
    typing.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 一些功能纯粹属于 C# 编译器的领域。隐式类型就是一个例子。框架不需要提供任何类型来支持 `var`，而运行时对你是使用隐式还是显式类型毫无察觉。
- en: 'At the other end of the spectrum is generics, which require significant compiler
    support, runtime support, and framework support in terms of the reflection APIs.
    LINQ is somewhere in between: the compiler provides the various features you saw
    in [chapter 3](kindle_split_018_split_000.html#ch03), and the framework provides
    not only the implementation of LINQ to Objects but also the API for expression
    trees. On the other hand, the runtime didn’t need to change. For dynamic typing,
    the picture is a little more complicated. [Figure 4.1](kindle_split_019_split_000.html#ch04fig01)
    gives a graphical representation of the elements involved.'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的另一端是泛型，它们需要大量的编译器支持、运行时支持和框架支持，特别是在反射 API 方面。LINQ 处于中间位置：编译器提供了你在[第 3 章](kindle_split_018_split_000.html#ch03)中看到的各种功能，而框架不仅提供了
    LINQ to Objects 的实现，还提供了表达式树的 API。另一方面，运行时不需要进行任何更改。对于动态类型，情况要复杂一些。[图 4.1](kindle_split_019_split_000.html#ch04fig01)
    给出了涉及元素的图形表示。
- en: Figure 4.1\. Graphical representation of components involved in dynamic typing
  id: totrans-1417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 动态类型中涉及的组件的图形表示
- en: '![](../Images/04fig01_alt.jpg)'
  id: totrans-1418
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig01_alt.jpg)'
- en: 'The CLR didn’t require changes, although I believe there were optimizations
    from v2 to v4 that were somewhat driven by this work. The compiler is obviously
    involved in generating different IL, and we’ll look at an example of this in a
    moment. For framework/library support, there are two aspects. The first is the
    *Dynamic Language Runtime* (DLR), which provides language-agnostic infrastructure
    such as `DynamicMetaObject`. That’s responsible for executing all the dynamic
    behavior. But a second library isn’t part of the core framework itself: Microsoft.CSharp.dll.'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 没有要求进行更改，尽管我相信从 v2 到 v4 的优化在一定程度上是由这项工作驱动的。编译器显然参与了生成不同的 IL，我们将在稍后的例子中看到这一点。对于框架/库支持，有两个方面。第一个是
    *动态语言运行时* (DLR)，它提供了一些语言无关的基础设施，如 `DynamicMetaObject`。它负责执行所有的动态行为。但第二个库并不是核心框架本身的一部分：Microsoft.CSharp.dll。
- en: '|  |'
  id: totrans-1420
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This library ships with the framework but isn’t part of the system framework
    libraries as such. I find it helpful to think of it as if it were a third-party
    dependency, where the third party happens to be Microsoft. On the other hand,
    the Microsoft C# compiler is fairly tightly coupled to it. It doesn’t fit into
    any box particularly neatly.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库与框架一起分发，但并不是系统框架库的一部分。我发现把它想象成一个第三方依赖很有帮助，而这个第三方恰好是微软。另一方面，微软的 C# 编译器与它相当紧密地耦合在一起。它不适合任何盒子特别整齐地放入。
- en: '|  |'
  id: totrans-1423
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This library is responsible for anything C# specific. For example, if you make
    a method call in which one argument is a dynamic value, it’s this library that
    performs the overload resolution at execution time. It’s a copy of the part of
    the C# compiler responsible for binding, but it does so in the context of all
    the dynamic APIs.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库负责所有与 C# 相关的事情。例如，如果你在一个方法调用中使用了动态值作为参数，那么在执行时进行重载解析的就是这个库。它是 C# 编译器负责绑定的部分的副本，但在所有动态
    API 的上下文中进行操作。
- en: If you’ve ever seen a reference to Microsoft.CSharp.dll in your project and
    wondered what it was for, that’s the reason. If you don’t use dynamic typing anywhere,
    you can safely remove the reference. If you do use dynamic typing but remove the
    reference, you’ll get a compile-time error as the C# compiler generates calls
    into that assembly. Speaking of code generated by the C# compiler, let’s have
    a look at some now.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在你的项目中看到过对 Microsoft.CSharp.dll 的引用并想知道它是用来做什么的，那就是原因。如果你在任何地方都没有使用动态类型，你可以安全地移除这个引用。如果你使用了动态类型但移除了引用，你将在编译时遇到错误，因为
    C# 编译器会生成对该程序集的调用。说到由 C# 编译器生成的代码，让我们现在看看一些。
- en: The IL generated for dynamic typing
  id: totrans-1426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为动态类型生成的 IL 代码
- en: 'We’re going to go right back to our initial example of dynamic typing but make
    it even shorter. Here are the first two lines of dynamic code I showed you:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到我们最初的动态类型示例，但让它更简短。以下是您看到的动态代码的前两行：
- en: '[PRE175]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Pretty simple, right? There are two dynamic operations here:'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？这里有两个动态操作：
- en: The call to the `Substring` method
  id: totrans-1430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `Substring` 方法的调用
- en: The conversion from the result to a string
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果转换为字符串
- en: The following listing is a decompiled version of the code generated from those
    two lines. I’ve included the surrounding context of a class declaration and `Main`
    method just for clarity.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表是上述两行代码生成的代码的反编译版本。为了清晰起见，我包括了类声明和 `Main` 方法的周围上下文。
- en: Listing 4.9\. The result of decompiling two simple dynamic operations
  id: totrans-1433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. 解析两个简单动态操作的输出结果
- en: '[PRE176]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '***1* Cache of call sites**'
  id: totrans-1435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用位置的缓存**'
- en: '***2* Creates a call site for the method call if necessary**'
  id: totrans-1436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果需要，为方法调用创建调用位置**'
- en: '***3* Creates a call site for the conversion if necessary**'
  id: totrans-1437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果需要，创建转换的调用位置**'
- en: '***4* Invokes the method call site**'
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 调用方法调用位置**'
- en: '***5* Invokes the conversion call site**'
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 调用转换调用位置**'
- en: I apologize for this formatting. I’ve done what I can to make it readable, but
    it’s a lot of code that involves a lot of long names. The good news is, you’re
    almost certain to never need to look at code like this except for the sake of
    interest. One point to note is that `CallSite` is in the `System.Runtime.CompilerServices`
    namespace as it’s language neutral, whereas the `Binder` class being used is from
    `Microsoft.CSharp .RuntimeBinder`.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个格式化表示歉意。我已经尽我所能使其可读，但它涉及很多长名字的代码。好消息是，你几乎肯定永远不需要查看这样的代码，除非是出于兴趣。有一点需要注意，`CallSite`
    在 `System.Runtime.CompilerServices` 命名空间中，因为它语言中立，而使用的 `Binder` 类来自 `Microsoft.CSharp.RuntimeBinder`。
- en: As you can tell, a lot of *call sites* are involved. Each call site is cached
    by the generated code, and multiple levels of caching are within the DLR as well.
    Binding is a reasonably involved process. The cache within the call site improves
    performance by storing the result of each binding operation to avoid redundant
    work while being aware that the same call could end up with different binding
    results if some of the context changes between calls.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，涉及了很多 *调用位置*。每个调用位置都被生成的代码缓存，DLR 也有多级缓存。绑定是一个相当复杂的过程。调用位置内的缓存通过存储每个绑定操作的结果来提高性能，以避免重复工作，同时意识到如果某些上下文在调用之间发生变化，相同的调用可能会得到不同的绑定结果。
- en: The result of all this effort is a system that’s remarkably efficient. It doesn’t
    perform quite as well as statically typed code, but it’s surprisingly close. I
    expect that in most cases where dynamic typing is an appropriate choice for other
    reasons, its performance won’t be a limiting factor. To wrap up the coverage of
    dynamic typing, I’ll explain a few limitations you may encounter and then give
    a little guidance around when and how dynamic typing is an effective choice.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些努力的结果是一个非常高效的系统。它的性能并不如静态类型代码，但出奇地接近。我预计，在大多数情况下，如果动态类型是其他原因下的合适选择，其性能不会成为限制因素。为了总结动态类型的覆盖范围，我将解释你可能会遇到的一些局限性，并给出一些关于何时以及如何使用动态类型作为有效选择的指导。
- en: 4.1.4\. Limitations and surprises in dynamic typing
  id: totrans-1443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4\. 动态类型中的局限性和惊喜
- en: Integrating dynamic typing into a language that was designed from the start
    to be statically typed is difficult. It’s no surprise that in a few places, the
    two don’t play nicely together. I’ve put together a list of some of the aspects
    of dynamic typing that include limitations or potential surprises to encounter
    at execution time. The list isn’t exhaustive, but it covers the most commonly
    seen problems.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 将动态类型集成到一个从一开始就被设计为静态类型的语言中是困难的。两个不和谐相处并不奇怪。我整理了一份关于动态类型的一些方面的列表，包括在执行时可能遇到的限制或潜在惊喜。这个列表并不全面，但它涵盖了最常见的常见问题。
- en: The dynamic type and generics
  id: totrans-1445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态类型和泛型
- en: 'Using the `dynamic` type with generics can be interesting. Rules are applied
    at compile time about where you can use `dynamic`:'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型中的 `dynamic` 类型可能很有趣。编译时应用了关于你可以在哪里使用 `dynamic` 的规则：
- en: A type can’t specify that it implements an interface using `dynamic` anywhere
    in a type argument.
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型不能在类型参数的任何位置使用 `dynamic` 来指定它实现了接口。
- en: You can’t use `dynamic` anywhere in type constraints.
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在类型约束中任何地方使用 `dynamic`。
- en: A class can specify a base class that uses `dynamic` in a type argument, even
    as part of an interface type argument.
  id: totrans-1449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以指定一个在类型参数中使用 `dynamic` 的基类，即使它是接口类型参数的一部分。
- en: You can use `dynamic` as an interface type argument for variables.
  id: totrans-1450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将 `dynamic` 用作变量接口类型参数。
- en: 'Here are some examples of invalid code:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些无效代码的示例：
- en: '[PRE177]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'But all of these are valid:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有这些都是有效的：
- en: '[PRE178]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Extension methods
  id: totrans-1455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展方法
- en: The execution-time binder doesn’t resolve extension methods. It could conceivably
    do so, but it’d need to keep additional information about every relevant `using`
    directive at every method call site. It’s important to note that this doesn’t
    affect statically bound calls that happen to use a dynamic type somewhere within
    a type argument. So, for example, the following listing compiles and runs with
    no problems.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时绑定器不会解析扩展方法。理论上它可以这样做，但它需要在每个方法调用位置保留有关每个相关 `using` 指令的额外信息。重要的是要注意，这不会影响静态绑定的调用，即使类型参数中某处使用了动态类型。所以，例如，以下列表可以编译并运行而不会出现任何问题。
- en: Listing 4.10\. A LINQ query over a list of dynamic values
  id: totrans-1457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 在动态值列表上进行的 LINQ 查询
- en: '[PRE179]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The only dynamic operations here are the multiplication (`x * 2`) and the overload
    resolution in `Console.WriteLine`. The call to `Select` is bound as normal at
    compile time. As an example of what will fail, let’s try making the source itself
    dynamic and simplify the LINQ operation you’re using to `Any()`. (If you kept
    using `Select` as before, you’d run into another problem that you’ll look at in
    a moment.) The following listing shows the changes.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一动态操作是乘法 (`x * 2`) 和 `Console.WriteLine` 中的重载解析。`Select` 的调用在编译时被正常绑定。作为一个失败的例子，让我们尝试将源本身设置为动态，并将你使用的
    LINQ 操作简化为 `Any()`。 （如果你像之前一样继续使用 `Select`，你将遇到另一个问题，你将在下一刻看到。）以下列表显示了更改。
- en: Listing 4.11\. Attempting to call an extension method on a dynamic target
  id: totrans-1460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 尝试在动态目标上调用扩展方法
- en: '[PRE180]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: I haven’t included the output part, because execution doesn’t reach there. Instead,
    it fails with a `RuntimeBinderException` because `List<T>` doesn’t include a method
    called `Any`.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有包括输出部分，因为执行不会到达那里。相反，它因为 `List<T>` 不包含名为 `Any` 的方法而失败，并抛出 `RuntimeBinderException`。
- en: 'If you want to call an extension method as if its target were a dynamic value,
    you need to do so as a regular static method call. For example, you could rewrite
    the last line of [listing 4.11](kindle_split_019_split_000.html#ch04ex11) to the
    following:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要像目标是一个动态值一样调用扩展方法，你需要将其作为常规静态方法调用。例如，你可以将 [列表 4.11](kindle_split_019_split_000.html#ch04ex11)
    的最后一行重写为以下内容：
- en: '[PRE181]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The call will still be bound at execution time, but only in terms of overload
    resolution.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 调用仍然会在执行时绑定，但仅限于重载解析。
- en: Anonymous functions
  id: totrans-1466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Anonymous functions have three limitations. For the sake of simplicity, I’ll
    show them all with lambda expressions.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数有三个限制。为了简单起见，我将使用 lambda 表达式展示它们。
- en: 'First, anonymous methods can’t be assigned to a variable of type `dynamic`,
    because the compiler doesn’t know what kind of delegate to create. It’s fine if
    you either cast or use an intermediate statically typed variable (and then copy
    the value), and you can invoke the delegate dynamically, too. For example, this
    is invalid:'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，匿名方法不能分配给类型为 `dynamic` 的变量，因为编译器不知道要创建哪种委托。如果你要么进行类型转换，要么使用中间的静态类型变量（然后复制值），并且也可以动态地调用委托，这是可以的。例如，以下是不合法的：
- en: '[PRE182]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'But this is fine and prints 1.5:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 但这没问题，会打印出 1.5：
- en: '[PRE183]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Second, and for the same underlying reason, lambda expressions can’t appear
    within dynamically bound operations. This is the reason I didn’t use `Select`
    in [listing 4.11](kindle_split_019_split_000.html#ch04ex11) to demonstrate the
    problem with extension methods. Here’s what [listing 4.11](kindle_split_019_split_000.html#ch04ex11)
    would’ve looked like otherwise:'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于相同的原因，lambda 表达式不能出现在动态绑定操作中。这就是为什么我没有在 [列表 4.11](kindle_split_019_split_000.html#ch04ex11)
    中使用 `Select` 来演示扩展方法的问题。以下是 [列表 4.11](kindle_split_019_split_000.html#ch04ex11)
    在其他情况下可能的样子：
- en: '[PRE184]'
  id: totrans-1473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'You know that wouldn’t work at execution time because it wouldn’t be able to
    find the `Select` extension method, but it doesn’t even compile because of the
    use of the lambda expression. The workaround for the compile-time issue is the
    same as before: just cast the lambda expression to a delegate type or assign it
    to a statically typed variable first. That would still fail at execution time
    for extension methods such as `Select`, but it would be fine if you were calling
    a regular method such as `List<T>.Find`, for example.'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道在执行时这不会工作，因为它找不到 `Select` 扩展方法，但它甚至无法编译，因为使用了 lambda 表达式。编译时问题的解决方案与之前相同：只需将
    lambda 表达式转换为委托类型或先将其分配给静态类型变量。对于 `Select` 这样的扩展方法，这仍然会在执行时失败，但如果调用的是像 `List<T>.Find`
    这样的常规方法，那就没问题了。
- en: Finally, lambda expressions that are converted to expression trees must not
    contain any dynamic operations. This may sound slightly odd, given the way the
    DLR uses expression trees internally, but it’s rarely an issue in practice. In
    most cases where expression trees are useful, it’s unclear what dynamic typing
    means or how it could possibly be implemented.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，转换为表达式树的 lambda 表达式不能包含任何动态操作。考虑到 DLR 内部使用表达式树的方式，这听起来可能有些奇怪，但在实践中很少成为问题。在大多数情况下，表达式树是有用的，但动态类型意味着什么或如何实现并不清楚。
- en: As an example, you can attempt to tweak [listing 4.10](kindle_split_019_split_000.html#ch04ex10)
    (with the statically typed `source` variable) to use `IQueryable<T>`, as shown
    in the following listing.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以尝试调整 [列表 4.10](kindle_split_019_split_000.html#ch04ex10)（使用静态类型的 `source`
    变量）以使用 `IQueryable<T>`，如下所示。
- en: Listing 4.12\. Attempting to use a dynamic element type in an `IQueryable<T>`
  id: totrans-1477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 尝试在 `IQueryable<T>` 中使用动态元素类型
- en: '[PRE185]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '***1* This line now fails to compile.**'
  id: totrans-1479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这行代码现在无法编译。**'
- en: The result of the `AsQueryable()` call is an `IQueryable<dynamic>`. This is
    statically typed, but its `Select` method accepts an expression tree rather than
    a delegate. That means the lambda expression (`x => x * 2`) would have to be converted
    to an expression tree, but it’s performing a dynamic operation, so it fails to
    compile.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsQueryable()` 调用的结果是 `IQueryable<dynamic>`。这是静态类型，但其 `Select` 方法接受一个表达式树而不是委托。这意味着
    lambda 表达式 (`x => x * 2`) 必须转换为表达式树，但它执行了一个动态操作，因此无法编译。'
- en: Anonymous types
  id: totrans-1481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 匿名类型
- en: 'I mentioned this issue when I first covered anonymous types, but it bears repeating:
    anonymous types are generated as regular classes in IL by the C# compiler. They
    have `internal` access, so nothing can use them outside the assembly they’re declared
    in. Normally that’s not an issue, as each anonymous type is typically used only
    within a single method. With dynamic typing, you can read properties of instances
    of anonymous types, but only if that code has access to the generated class. The
    following listing shows an example of this where it *is* valid.'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第一次介绍匿名类型时提到了这个问题，但值得再次强调：C# 编译器会将匿名类型作为常规类在 IL 中生成。它们具有 `internal` 访问权限，因此无法在声明它们的程序集之外使用。通常情况下这不是问题，因为匿名类型通常只在一个方法中使用。使用动态类型，你可以读取匿名类型实例的属性，但前提是代码可以访问生成的类。以下列表展示了这种情况下的一个示例，其中它是有效的。
- en: Listing 4.13\. Dynamic access to a property of an anonymous type
  id: totrans-1483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. 动态访问匿名类型的属性
- en: '[PRE186]'
  id: totrans-1484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This listing has two anonymous types, but the binding process doesn’t care whether
    it’s binding against an anonymous type. It does check that it has access to the
    properties it finds, though. If you split this code across two assemblies, that
    would cause a problem; the binder would spot that the anonymous type is internal
    to the assembly where it’s created and throw a `RuntimeBinderException`. If you
    run into this problem and can use `[InternalsVisibleTo]` to allow the assembly
    performing the dynamic binding to have access to the assembly where the anonymous
    type is created, that’s a reasonable workaround.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表有两个匿名类型，但绑定过程并不关心它是否绑定到匿名类型。不过，它确实会检查它是否有权访问它找到的属性。如果您将此代码拆分到两个程序集中，这将导致问题；绑定器会注意到匿名类型是在创建它的程序集内部，并抛出
    `RuntimeBinderException`。如果您遇到这个问题，并且可以使用 `[InternalsVisibleTo]` 允许执行动态绑定的程序集访问创建匿名类型的程序集，那么这是一个合理的解决方案。
- en: Explicit interface implementation
  id: totrans-1486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显式接口实现
- en: The execution-time binder uses the execution-time type of any dynamic value
    and then binds in the same way as if you’d written that as the compile-time type
    of a variable. Unfortunately, that doesn’t play nicely with the existing C# feature
    of explicit interface implementation. When you use explicit interface implementation,
    that effectively says that the member being implemented is available only when
    you’re using the interface view over the object instead of the type itself.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时绑定器使用任何动态值的运行时类型，然后以您将其作为变量的编译时类型的方式绑定。不幸的是，这并不与现有的 C# 特性显式接口实现很好地配合。当您使用显式接口实现时，这实际上意味着正在实现的成员仅在您使用对象上的接口视图而不是类型本身时才可用。
- en: It’s easier to show this than to explain it. The following listing uses `List<T>`
    as an example.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 展示这一点比解释它更容易。下面的列表使用 `List<T>` 作为示例。
- en: Listing 4.14\. Example of explicit interface implementation
  id: totrans-1489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 显式接口实现的示例
- en: '[PRE187]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '***1* Compile-time error**'
  id: totrans-1491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 编译时错误**'
- en: '***2* Succeeds; prints False**'
  id: totrans-1492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 成功；打印 False**'
- en: '***3* Execution-time error**'
  id: totrans-1493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 运行时错误**'
- en: '`List<T>` implements the `IList` interface. The interface has a property called
    `IsFixedSize`, but the `List<T>` class implements that explicitly. Any attempt
    to access it via an expression with a static type of `List<T>` will fail at compile
    time. You can access it via an expression with a static type of `IList`, and it’ll
    always return `false`. But what about accessing it dynamically? The binder will
    always use the concrete type of the dynamic value, so it fails to find the property,
    and a `RuntimeBinderException` is thrown. The workaround here is to convert the
    dynamic value back to the interface (via casting or a separate variable) if you
    know that you want to use an interface member.'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 实现了 `IList` 接口。该接口有一个名为 `IsFixedSize` 的属性，但 `List<T>` 类显式地实现了它。任何尝试通过具有静态类型为
    `List<T>` 的表达式访问它的尝试都会在编译时失败。您可以通过具有静态类型为 `IList` 的表达式来访问它，并且它总是返回 `false`。但是，动态访问它呢？绑定器将始终使用动态值的实际类型，因此找不到该属性，并抛出
    `RuntimeBinderException`。这里的解决方案是，如果您知道您想使用接口成员，请将动态值转换回接口（通过强制转换或单独的变量）。'
- en: I’m sure that anyone who works with dynamic typing on a regular basis would
    be able to regale you with a long list of increasingly obscure corner cases, but
    the preceding items should keep you from being surprised *too* often. We’ll complete
    our coverage of dynamic typing with a little guidance about when and how to use
    it.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，任何经常使用动态类型的人都能给你一个越来越难以理解的边缘案例的长列表，但前面提到的项目应该能让你不会太频繁地感到惊讶。我们将通过一些关于何时以及如何使用动态类型的指导来完成对动态类型的覆盖。
- en: 4.1.5\. Usage suggestions
  id: totrans-1496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.5\. 使用建议
- en: 'I’ll be up front about this: I’m generally not a fan of dynamic typing. I can’t
    remember the last time I used it in production code, and I’d do so only warily
    and after a lot of testing for correctness and performance.'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 我会坦白地说：我通常不是动态类型的粉丝。我不记得我上次在生产代码中使用它是什么时候，而且我只会谨慎地使用它，并在进行了大量的正确性和性能测试之后。
- en: 'I’m a sucker for static typing. In my experience, it gives four significant
    benefits:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 我对静态类型情有独钟。根据我的经验，它提供了四个显著的好处：
- en: When I make mistakes, I’m likely to discover them earlier—at compile time rather
    than execution time. That’s particularly important with code paths that may be
    hard to test exhaustively.
  id: totrans-1499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我犯错误时，我可能会更早地发现它们——在编译时而不是运行时。这对于可能难以彻底测试的代码路径尤其重要。
- en: Editors can provide code completion. This isn’t particularly important in terms
    of speed of typing, but it’s great as a way of exploring what I might want to
    do next, particularly if I’m using a type I’m unfamiliar with. Editors for dynamic
    languages can provide remarkable code-completion facilities these days, but they’ll
    never be quite as precise as those for statically typed languages, because there
    just isn’t as much information available.
  id: totrans-1500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器可以提供代码补全。这在打字速度方面并不是特别重要，但作为探索我可能想要做什么的方式，尤其是如果我在使用一个我不熟悉的类型时，是非常好的。如今，动态语言的编辑器可以提供令人瞩目的代码补全功能，但它们永远不会像静态类型语言的那些一样精确，因为可用的信息少得多。
- en: 'It makes me think about the API I’m providing, in terms of parameters, return
    types, and so on. After I’ve made decisions about which types to accept and return,
    that acts as ready-made documentation: I need to add comments only for anything
    that isn’t otherwise obvious, such as the range of acceptable values.'
  id: totrans-1501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这让我思考我提供的API，包括参数、返回类型等方面。在我决定接受和返回哪些类型之后，这就像现成的文档：我只需要为那些不明显的内容添加注释，例如可接受值的范围。
- en: By doing work at compile time instead of execution time, statically typed code
    usually has performance benefits over dynamically typed code. I don’t want to
    emphasize this too much, as modern runtimes can do amazing things, but it’s certainly
    worth considering.
  id: totrans-1502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在编译时而不是执行时进行工作，静态类型代码通常比动态类型代码具有性能优势。我不想过分强调这一点，因为现代运行时可以做到惊人的事情，但这确实值得考虑。
- en: I’m sure a dynamic typing aficionado would be able to give you a similar list
    of awesome benefits of dynamic typing, but I’m not the right person to do so.
    I suspect those benefits are more readily available in a language designed with
    dynamic typing right from the start. C# is *mostly* a statically typed language,
    and its heritage is clear, which is why the corner cases I listed earlier exist.
    That said, here are a few suggestions about when you might want to use dynamic
    typing.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信一个动态类型爱好者能够给你列出动态类型的一些类似的好处，但我不太适合做这件事。我怀疑这些好处在从一开始就设计为动态类型的语言中更容易获得。C# *主要*
    是一种静态类型语言，其遗产是明显的，这也是为什么之前提到的边缘情况存在。话虽如此，以下是一些建议，关于你可能想要使用动态类型的情况。
- en: Simpler reflection
  id: totrans-1504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更简单的反射
- en: 'Suppose you find yourself using reflection to access a property or method;
    you know the name at compile time, but you can’t refer to the static type for
    whatever reason. It’s much simpler to use dynamic typing to ask the runtime binder
    to perform that access than to do it directly with the reflection API. The benefit
    increases if you’d otherwise need to perform multiple steps of reflection. For
    example, consider a code snippet like this:'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你发现自己正在使用反射来访问属性或方法；你编译时知道名称，但由于某种原因不能引用静态类型。使用动态类型请求运行时绑定器执行该访问比直接使用反射API要简单得多。如果你原本需要执行多个反射步骤，这种好处会更大。例如，考虑以下代码片段：
- en: '[PRE188]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The reflection steps involved would be as follows:'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的反射步骤如下：
- en: Fetch the `PropertyInfo` based on the type of the initial value.
  id: totrans-1508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据初始值的类型获取`PropertyInfo`。
- en: Fetch the value of that property and remember it.
  id: totrans-1509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取该属性的值并记住它。
- en: Fetch the `MethodInfo` based on the type of the property result.
  id: totrans-1510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据属性结果的类型获取`MethodInfo`。
- en: Execute the method on the property result.
  id: totrans-1511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性结果上执行方法。
- en: By the time you’ve added validation to check that the property and method both
    exist, you’re looking at several lines of code. The result would be no safer than
    the dynamic approach shown previously, but it would be a lot harder to read.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 在你添加验证以确保属性和方法都存在之前，你将看到几行代码。其结果将不会比之前展示的动态方法更安全，但阅读起来会更困难。
- en: Common members without a common interface
  id: totrans-1513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 没有共同接口的常见成员
- en: Sometimes you do know all the possible types of a value in advance, and you
    want to use a member with the same name on all of them. If the types implement
    a common interface or share a common base class that declares the member, that’s
    great, but that doesn’t always happen. If each of them declares that member independently
    (and if you can’t change that), you’re left with unpleasant choices.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你确实可以提前知道一个值的所有可能类型，并且你想要在它们上面使用具有相同名称的成员。如果这些类型实现了一个共同接口或共享一个声明该成员的共同基类，那很好，但这种情况并不总是发生。如果每个都独立声明该成员（如果你不能改变这一点），你将面临不愉快的选择。
- en: This time, you don’t need to use reflection, but you might need to perform several
    repetitive steps of check the type, cast, access the member. C# 7 patterns make
    this significantly simpler, but it can still be repetitive. Instead, you can use
    dynamic typing to effectively say “Trust me, I know this member will be present,
    even though I can’t express it in a statically typed way.” I’d be comfortable
    doing this within tests (where the cost of being wrong is a test failure), but
    in production code I’d be much more cautious.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你不需要使用反射，但可能需要执行几个重复的步骤，比如检查类型、转换、访问成员。C# 7 的模式使这变得显著简单，但它仍然可能是重复的。相反，你可以使用动态类型来有效地表达“相信我，我知道这个成员将会存在，即使我无法用静态类型的方式表达。”我会在测试中这样做（因为错误成本是测试失败），但在生产代码中我会更加谨慎。
- en: Using a library built for dynamic typing
  id: totrans-1516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用为动态类型构建的库
- en: The .NET ecosystem is pretty rich and is getting better all the time. Developers
    are creating all kinds of interesting libraries, and I suspect some may embrace
    dynamic typing. For example, I can imagine a library designed to allow for easy
    prototyping with REST- or RPC-based APIs with no code generation involved. That
    could be useful in the initial phase of development while everything is quite
    fluid before generating a statically typed library for later development.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 生态系统相当丰富，并且一直在不断改进。开发者正在创建各种有趣的库，我怀疑有些人可能会接受动态类型。例如，我可以想象一个库，它允许通过 REST
    或 RPC 基于的 API 进行易于原型设计，而不涉及任何代码生成。这在开发初期，当一切都很灵活时，可能会很有用，在生成用于后续开发的静态类型库之前。
- en: This is similar to the Json.NET example you looked at earlier. You may well
    want to write classes to represent your data model after that model is well-defined,
    but when prototyping, it may be simpler to change the JSON and then the code that’s
    accessing it dynamically. Likewise, you’ll see later how COM improvements mean
    that often you can end up working with dynamic typing instead of performing a
    lot of casting.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您之前看到的 Json.NET 示例类似。在模型定义良好之后，你可能很乐意编写表示数据模型的类，但在原型设计时，可能更简单的是先更改 JSON，然后是动态访问它的代码。同样，你稍后会发现
    COM 的改进意味着你通常可以最终使用动态类型而不是执行大量的转换。
- en: In a nutshell, I think it still makes sense to use static typing where it’s
    simple to do so, but you should accept dynamic typing as a potentially useful
    tool for some situations. I encourage you to weigh the pros and cons in each context.
    Code that’s acceptable for a prototype or even in test code may not be suitable
    for production code, for example.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我认为在简单易行的情况下使用静态类型仍然是有意义的，但你应该接受动态类型作为某些情况可能有用的工具。我鼓励你在每个上下文中权衡利弊。例如，适用于原型或甚至测试代码的代码可能不适合生产代码。
- en: Beyond code that you might write for professional purposes, the ability to respond
    with dynamic behavior by using `DynamicObject` or `IDynamicMetaObjectProvider`
    certainly gives a lot of scope for fun development. However much I may shy away
    from dynamic typing myself, it’s been well designed and implemented in C# and
    provides a rich avenue for exploration.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，通过使用 `DynamicObject` 或 `IDynamicMetaObjectProvider` 来实现动态行为的能力，确实为有趣的发展提供了很多空间。尽管我可能对动态类型有所保留，但它在
    C# 中已经得到了良好的设计和实现，为探索提供了丰富的途径。
- en: 'Our next feature is somewhat different, although both will come together when
    you look at COM interoperability. We’re back to static typing and one specific
    aspect of it: providing arguments for parameters.'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个特性在某种程度上有些不同，尽管当你查看 COM 互操作性时，两者会结合在一起。我们回到了静态类型，以及它的一个特定方面：为参数提供参数。
- en: 4.2\. Optional parameters and named arguments
  id: totrans-1522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2. 可选参数和命名参数
- en: 'Optional parameters and named arguments have a limited scope: given a method,
    constructor, indexer, or delegate that you want to call, how do you provide the
    arguments for the call? *Optional parameters* allow the caller to omit an argument
    entirely, and *named arguments* allow the caller to make it clear to both the
    compiler and any human reader which parameter an argument is intended to relate
    to.'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数和命名参数的适用范围有限：给定一个你想要调用的方法、构造函数、索引器或委托，你如何提供调用参数？*可选参数* 允许调用者完全省略一个参数，而 *命名参数*
    允许调用者向编译器和任何人类读者清楚地表明参数与哪个参数相关联。
- en: Let’s start with a simple example and then dive into the details. In this whole
    section, I’m going to consider only methods. The same rules apply to all the other
    kinds of members that can have parameters.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始，然后深入细节。在本节中，我将只考虑方法。相同的规则适用于所有可以具有参数的其他类型的成员。
- en: 4.2.1\. Parameters with default values and arguments with names
  id: totrans-1525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 带默认值的参数和带名称的参数
- en: The following listing shows a simple method with three parameters, two of which
    are optional. Multiple calls to the method then demonstrate different features.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个简单的有三个参数的方法，其中两个是可选的。对方法的多次调用展示了不同的功能。
- en: Listing 4.15\. Calling a method with optional parameters
  id: totrans-1527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.15\. 调用一个带有可选参数的方法
- en: '[PRE189]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '***1* One required parameter, two optional**'
  id: totrans-1529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个必需参数，两个可选**'
- en: '***2* Just print the parameter values.**'
  id: totrans-1530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 只打印参数值。**'
- en: '***3* x=1; y=2; z=3**'
  id: totrans-1531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* x=1; y=2; z=3**'
- en: '***4* x=1; y=2; z=10**'
  id: totrans-1532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* x=1; y=2; z=10**'
- en: '***5* x=1; y=5; z=3**'
  id: totrans-1533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* x=1; y=5; z=3**'
- en: '***6* x=1; y=5; z=10**'
  id: totrans-1534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* x=1; y=5; z=10**'
- en: '[Figure 4.2](kindle_split_019_split_000.html#ch04fig02) shows the same method
    declaration and one method call, just to make the terminology clear.'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.2](kindle_split_019_split_000.html#ch04fig02) 展示了相同的方法声明和一个方法调用，以使术语清晰。'
- en: Figure 4.2\. Syntax of optional/required parameters and named/positional arguments
  id: totrans-1536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. 可选/必需参数和命名/位置参数的语法
- en: '![](../Images/04fig02_alt.jpg)'
  id: totrans-1537
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig02_alt.jpg)'
- en: 'The syntax is simple:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 语法很简单：
- en: A parameter can specify a *default value* after its name with an equal sign
    between the name and the value. Any parameter with a default value is *optional*;
    any parameter without a default value is *required*. Parameters with `ref` or
    `out` modifiers aren’t permitted to have default values.
  id: totrans-1539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参数可以在其名称之后指定一个*默认值*，名称和值之间用等号分隔。任何具有默认值的参数都是*可选的*；任何没有默认值的参数都是*必需的*。不允许对具有
    `ref` 或 `out` 修饰符的参数使用默认值。
- en: An argument can specify a name before the value with a colon between the name
    and the value. An argument without a name is called a *positional argument*.
  id: totrans-1540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参数可以在值之前指定一个名称，名称和值之间用冒号分隔。没有名称的参数称为*位置参数*。
- en: 'The default value for a parameter must be one of the following expressions:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的默认值必须是以下表达式之一：
- en: A compile-time constant, such as a numeric or string literal, or the null literal.
  id: totrans-1542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编译时常量，例如数字或字符串字面量，或空字面量。
- en: A default expression, such as `default(CancellationToken)`. As you’ll see in
    [section 14.5](kindle_split_031_split_000.html#ch14lev1sec5), C# 7.1 introduces
    the *default literal*, so you can write `default` instead of `default(CancellationToken)`.
  id: totrans-1543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个默认表达式，例如 `default(CancellationToken)`。正如你将在[第14.5节](kindle_split_031_split_000.html#ch14lev1sec5)中看到的那样，C#
    7.1引入了*默认字面量*，因此你可以写 `default` 而不是 `default(CancellationToken)`。
- en: A new expression, such as `new Guid()` or `new CancellationToken()`. This is
    valid only for value types.
  id: totrans-1544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新表达式，例如 `new Guid()` 或 `new CancellationToken()`。这仅适用于值类型。
- en: All optional parameters must come after all required parameters, with an exception
    for parameter arrays. (Parameter arrays are parameters with the `params` modifier.)
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可选参数都必须在所有必需参数之后，但参数数组除外。（参数数组是具有 `params` 修饰符的参数。）
- en: '|  |'
  id: totrans-1546
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-1547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Even though you can declare a method with an optional parameter followed by
    a parameter array, it ends up being confusing to call. I urge you to avoid this,
    and I won’t go into how calls to such methods are resolved.
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以声明一个带有可选参数后跟参数数组的方法，但调用起来会让人困惑。我强烈建议你避免这样做，并且我不会深入探讨如何解析此类方法的调用。
- en: '|  |'
  id: totrans-1549
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The purpose of making a parameter optional is to allow the caller to omit it
    if the value it *would* supply is the same as the default value. Let’s look at
    what how the compiler handles a method call that can involve default parameters
    and/or named arguments.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 使参数可选的目的是允许调用者省略它，如果它提供的值与默认值相同。让我们看看编译器如何处理可能涉及默认参数和/或命名参数的方法调用。
- en: 4.2.2\. Determining the meaning of a method call
  id: totrans-1551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 确定方法调用的含义
- en: If you read the specification, you’ll see that the process of working out which
    argument corresponds to which parameter is part of overload resolution and is
    intertwined with type inference. This is more complicated than you might otherwise
    expect, so I’m going to simplify things here. We’ll focus on a single method signature,
    assume it’s the one that has already been chosen by overload resolution, and take
    it from there.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了规范，你会看到确定哪个参数对应哪个参数的过程是重载解析的一部分，并且与类型推断交织在一起。这比你可能预期的要复杂，所以我会在这里简化一下。我们将关注一个单独的方法签名，假设它已经被重载解析选中，然后从那里开始。
- en: 'The rules are reasonably simple to list:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 规则列出来是相当简单的：
- en: All positional arguments must come before all named arguments. This rule is
    relaxed slightly in C# 7.2, as you’ll see in [section 14.6](kindle_split_031_split_000.html#ch14lev1sec6).
  id: totrans-1554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有位置参数必须位于所有命名参数之前。在 C# 7.2 中，这个规则略有放宽，如第 14.6 节[section 14.6](kindle_split_031_split_000.html#ch14lev1sec6)中所示。
- en: Positional arguments always correspond to a parameter in the same position in
    the method signature. The first positional argument corresponds to the first parameter,
    the second positional argument corresponds to the second parameter, and so on.
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数始终对应于方法签名中相同位置的参数。第一个位置参数对应第一个参数，第二个位置参数对应第二个参数，依此类推。
- en: 'Named arguments match by name instead of position: an argument named `x` corresponds
    to a parameter named `x`. Named arguments can be specified in any order.'
  id: totrans-1556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名参数通过名称而不是位置匹配：名为 `x` 的参数对应于名为 `x` 的参数。命名参数可以按任何顺序指定。
- en: Any parameter can have only one corresponding argument. You can’t specify the
    same name in two named arguments, and you can’t use a named argument for a parameter
    that already has a corresponding positional argument.
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何参数只能有一个相应的参数。你不能在两个命名参数中指定相同的名称，也不能为已经有一个位置参数对应的参数使用命名参数。
- en: Every required parameter must have a corresponding argument to provide a value.
  id: totrans-1558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个必需参数都必须有一个相应的参数来提供值。
- en: Optional parameters are permitted not to have a corresponding argument, in which
    case the compiler will supply the default value as an argument.
  id: totrans-1559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数可以没有相应的参数，在这种情况下，编译器将提供默认值作为参数。
- en: 'To see these rules in action, let’s consider our original simple method signature:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这些规则的实际应用，让我们考虑我们的原始简单方法签名：
- en: '[PRE190]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: You can see that `x` is a required parameter because it doesn’t have a default
    value, but `y` and `z` are optional parameters. [Table 4.1](kindle_split_019_split_000.html#ch04table01)
    shows several valid calls and their results.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `x` 是一个必需参数，因为它没有默认值，但 `y` 和 `z` 是可选参数。[表 4.1](kindle_split_019_split_000.html#ch04table01)
    显示了几个有效调用及其结果。
- en: Table 4.1\. Examples of valid method calls for named arguments and optional
    parameters
  id: totrans-1563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1\. 命名参数和可选参数的有效方法调用示例
- en: '| Call | Resulting arguments | Notes |'
  id: totrans-1564
  prefs: []
  type: TYPE_TB
  zh: '| 调用 | 结果参数 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-1565
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Method(1, 2, 3) | x=1; y=2; z=3 | All positional arguments. Regular call
    from before C# 4. |'
  id: totrans-1566
  prefs: []
  type: TYPE_TB
  zh: '| 方法(1, 2, 3) | x=1; y=2; z=3 | 所有位置参数。C# 4.0 之前的常规调用。 |'
- en: '| Method(1) | x=1; y=5; z=10 | Compiler supplies values for y and z, as there
    are no corresponding arguments. |'
  id: totrans-1567
  prefs: []
  type: TYPE_TB
  zh: '| 方法(1) | x=1; y=5; z=10 | 编译器为 y 和 z 提供值，因为没有相应的参数。 |'
- en: '| Method() | n/a | Invalid: no argument corresponds to x. |'
  id: totrans-1568
  prefs: []
  type: TYPE_TB
  zh: '| 方法() | n/a | 无效：没有参数对应于 x。 |'
- en: '| Method(y: 2) | n/a | Invalid: no argument corresponds to x. |'
  id: totrans-1569
  prefs: []
  type: TYPE_TB
  zh: '| 方法(y: 2) | n/a | 无效：没有参数对应于 x。 |'
- en: '| Method(1, z: 3) | x=1; y=5; z=3 | Compiler supplies value for y as there’s
    no corresponding argument. It was skipped by using a named argument for z. |'
  id: totrans-1570
  prefs: []
  type: TYPE_TB
  zh: '| 方法(1, z: 3) | x=1; y=5; z=3 | 编译器为 y 提供值，因为没有相应的参数。它通过使用 z 的命名参数而跳过。 |'
- en: '| Method(1, x: 2, z: 3) | n/a | Invalid: two arguments correspond to x. |'
  id: totrans-1571
  prefs: []
  type: TYPE_TB
  zh: '| 方法(1, x: 2, z: 3) | n/a | 无效：两个参数对应于 x。 |'
- en: '| Method(1, y: 2, y: 2) | n/a | Invalid: two arguments correspond to y. |'
  id: totrans-1572
  prefs: []
  type: TYPE_TB
  zh: '| 方法(1, y: 2, y: 2) | n/a | 无效：两个参数对应于 y。 |'
- en: '| Method(z: 3, y: 2, x: 1) | x=1; y=2; z=3 | Named arguments can be in any
    order, |'
  id: totrans-1573
  prefs: []
  type: TYPE_TB
  zh: '| 方法(z: 3, y: 2, x: 1) | x=1; y=2; z=3 | 命名参数可以按任何顺序， |'
- en: 'There are two more important aspects to note when it comes to evaluating method
    calls. First, arguments are evaluated in the order they appear in the source code
    for the method call, left to right. In most cases, this wouldn’t matter, but if
    argument evaluation has side effects, it can. As an example, consider these two
    calls to our sample method:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估方法调用时，有两个重要方面需要注意。首先，参数的评估顺序与它们在方法调用源代码中出现的顺序相同，从左到右。在大多数情况下，这不会产生影响，但如果参数评估有副作用，则可能会产生影响。作为一个例子，考虑我们对示例方法的这两个调用：
- en: '[PRE191]'
  id: totrans-1575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '***1* x=0; y=1; z=2**'
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* x=0; y=1; z=2**'
- en: '***2* x=2; y=1; z=0**'
  id: totrans-1577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* x=2; y=1; z=0**'
- en: 'The two calls differ only in terms of the order of their named arguments, but
    that affects the values that are passed into the method. In both cases, the code
    is harder to read than it might be. When side effects of argument evaluation are
    important, I encourage you to evaluate them as separate statements and assign
    to new local variables that are then passed directly to the method as arguments,
    like this:'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个调用仅在命名参数的顺序上有所不同，但这会影响传递给方法的价值。在两种情况下，代码的阅读难度都比可能的情况要高。当参数评估的副作用很重要时，我鼓励你将它们作为单独的语句进行评估，并将结果赋值给新的局部变量，然后将这些变量直接作为参数传递给方法，如下所示：
- en: '[PRE192]'
  id: totrans-1579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: At this point, whether you name the arguments doesn’t change the behavior; you
    can choose whichever form you find most readable. The separation of argument evaluation
    from method invocation makes the order of argument evaluation simpler to understand,
    in my opinion.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，无论你是否命名参数，都不会改变行为；你可以选择你认为最易读的任何形式。在我看来，将参数评估与方法调用分离使得理解参数评估的顺序更加简单。
- en: The second point to note is that if the compiler has to specify any default
    values for parameters, those values are embedded in the IL for the calling code.
    There’s no way for the compiler to say “I don’t have a value for this parameter;
    please use whatever default you have.” That’s why the default values have to be
    compile-time constants, and it’s one of the ways in which optional parameters
    affect versioning.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的点是，如果编译器必须为参数指定任何默认值，这些值将嵌入到调用代码的IL中。编译器无法说“这个参数我没有值；请使用你有的任何默认值。”这就是为什么默认值必须是编译时常量，这也是可选参数影响版本化的方式之一。
- en: 4.2.3\. Impact on versioning
  id: totrans-1582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 对版本化的影响
- en: Versioning of public APIs in libraries is a hard problem. It’s really hard and
    significantly less clear-cut than we like to pretend. Although semantic versioning
    says that any breaking change means you need to move to a new major version, pretty
    much any change can break some code that depends on the library, if you’re willing
    to include obscure cases. That said, optional parameters and named arguments are
    particularly tricky for versioning. Let’s have a look at the various factors.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 在库中版本化公共API是一个难题。这真的很困难，并且比我们愿意假装的要复杂得多。尽管语义版本化表示任何破坏性变更都意味着你需要迁移到新的主要版本，但如果你愿意包括一些晦涩的情况，几乎任何变更都可能破坏依赖于库的某些代码。话虽如此，可选参数和命名参数在版本化方面尤其棘手。让我们看看各种因素。
- en: Parameter name changes are breaking
  id: totrans-1584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数名称更改是破坏性的
- en: 'Suppose you have a library containing the method that you previously looked
    at, but it’s public:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含你之前查看的方法的库，但它是公开的：
- en: '[PRE193]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Now suppose you want to change that to the following in a new version:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想要在新版本中将以下内容进行更改：
- en: '[PRE194]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: That’s a breaking change; any code that uses named arguments when calling the
    method will be broken, as the names they specified before no longer exist. Check
    your parameter names as carefully as you check your type and member names!
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个破坏性的变更；任何在调用方法时使用命名参数的代码都将被破坏，因为它们之前指定的名称已不再存在。请像检查你的类型和成员名称一样仔细检查你的参数名称！
- en: Default value changes are at least surprising
  id: totrans-1590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认值更改至少是令人惊讶的
- en: As I’ve noted, default values are compiled into the IL of the calling code.
    When that’s within the same assembly, changing the default value doesn’t cause
    a problem. When it’s in a different assembly, a change to the default value will
    be visible only when the calling code is recompiled.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，默认值被编译到调用代码的IL中。当它在同一个程序集内时，更改默认值不会引起问题。当它在不同的程序集内时，更改默认值只有在调用代码重新编译时才会可见。
- en: That’s not always a problem, and if you anticipate that you might want to change
    the default value, it’s not entirely unreasonable to state that explicitly in
    the method documentation. But it could definitely surprise some developers using
    your code, particularly if complicated dependency chains are involved. One way
    of avoiding this is to use a dedicated default value that always means “Let the
    method choose at execution time.” For example, if you have a method that would
    normally have an `int` parameter, you could use `Nullable<int>` instead, with
    a default value of `null` meaning “the method will choose.” You can change the
    implementation of the method later to make a different choice, and every caller
    using the new version will get the new behavior, whether they’ve recompiled or
    not.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是问题，如果你预计你可能想要更改默认值，那么在方法文档中明确地声明这一点并不完全不合理。但这可能会让一些使用你代码的开发者感到惊讶，尤其是如果涉及到复杂的依赖链。避免这种情况的一种方法是用一个始终意味着“让方法在执行时选择”的专用默认值。例如，如果你有一个通常具有`int`参数的方法，你可以使用`Nullable<int>`代替，默认值为`null`表示“方法将选择”。你可以稍后更改方法的实现以做出不同的选择，并且使用新版本的每个调用者都会得到新的行为，无论他们是否重新编译。
- en: Adding overloads is fiddly
  id: totrans-1593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加重载很麻烦
- en: If you thought overload resolution was tricky in a single-version scenario,
    it becomes a lot worse when you’re trying to add an overload without breaking
    anyone. All original method signatures must be present in the new version to avoid
    breaking binary compatibility, and all calls against the original methods should
    either resolve to the same calls, or at least *equivalent* calls, in the new version.
    Whether a parameter is required or optional isn’t part of the method signature
    itself; you don’t break binary compatibility by changing an optional parameter
    to be required, or vice versa. But you might break source compatibility. If you’re
    not careful, you can easily introduce ambiguity in overload resolution by adding
    a new method with more optional parameters.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为在单版本场景下重载解析已经棘手，那么在你尝试添加重载而不破坏任何人的情况下，问题会变得更加严重。所有原始方法签名都必须在新版本中存在，以避免破坏二进制兼容性，并且所有针对原始方法的调用在新版本中应该解析为相同的调用，或者至少是*等效*的调用。一个参数是必需的还是可选的不是方法签名本身的一部分；通过将可选参数更改为必需的，或者相反，你不会破坏二进制兼容性。但你可能会破坏源兼容性。如果你不小心，你很容易通过添加一个具有更多可选参数的新方法来引入重载解析的歧义。
- en: If two methods are both applicable within overload resolution (both make sense
    with respect to the call) and neither is better than the other in terms of the
    argument-to-parameter conversions involved, then default parameters can be used
    as a tiebreak. A method that has no optional parameters without corresponding
    arguments is “better” than a method with at least one optional parameter without
    a corresponding argument. But a method with one unfilled parameter is no better
    than a method with two such parameters.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个方法在重载解析中都适用（与调用相关），并且就涉及的参数到参数的转换而言，没有一个比另一个更好，那么可以使用默认参数作为决定性因素。没有对应参数的没有可选参数的方法比至少有一个没有对应参数的可选参数的方法“更好”。但一个未填写的参数的方法并不比有两个此类参数的方法“更好”。
- en: If you can possibly get away without adding overloads to methods when optional
    parameters are involved, I strongly advise that you do so—and, ideally, bear that
    in mind from the start. One pattern to consider for methods that might have a
    lot of options is to create a class representing all those options and then take
    that as an optional parameter in method calls. You can then add new options by
    adding properties to the options class without changing the method signature at
    all.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在涉及可选参数的情况下，你可以避免向方法添加重载，我强烈建议你这样做——并且，理想情况下，从一开始就记住这一点。对于可能有很多选项的方法，可以考虑创建一个表示所有这些选项的类，然后在方法调用中将它作为可选参数。然后，你可以通过向选项类添加属性来添加新选项，而无需更改方法签名。
- en: 'Despite all these caveats, I’m still in favor of optional parameters when they
    make sense to simplify calling code for common cases, and I’m a big fan of the
    ability to name arguments to clarify calling code. This is particularly relevant
    when multiple parameters of the same type could be confused with each other. As
    one example, I always use them when I need to call the Windows Forms `MessageBox.Show`
    method. I can never remember whether the title of the message box or the text
    comes first. IntelliSense can help me when I’m writing the code, but it’s not
    as obvious when I’m reading it, unless I use named arguments:'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有所有这些警告，我还是支持在合理简化常见情况下的调用代码时使用可选参数，并且我是命名参数以澄清调用代码能力的忠实粉丝。这在多个相同类型的参数可能相互混淆的情况下尤其相关。作为一个例子，我总是在需要调用Windows
    Forms的`MessageBox.Show`方法时使用它们。我总是记不清消息框的标题或文本哪个在前。IntelliSense在编写代码时能帮助我，但在阅读代码时并不明显，除非我使用命名参数：
- en: '[PRE195]'
  id: totrans-1598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Our next topic is one that many readers may have no need for and other readers
    will use every day. Although COM is a legacy technology in many contexts, a huge
    amount of code still uses it.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的主题可能是许多读者不需要的，而其他读者则可能每天都会用到。尽管在许多情况下COM是一种遗留技术，但仍然有大量的代码在使用它。
- en: 4.3\. COM interoperability improvements
  id: totrans-1600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3. COM互操作性改进
- en: Before C# 4, VB was simply a better language to use if you wanted to interoperate
    with COM components. It’s always been a somewhat more relaxed language, at least
    if you ask it to be, and it has had named arguments and optional parameters from
    the start. C# 4 makes life much simpler for those working with COM. That said,
    if you’re not using COM, you won’t miss out on anything important by skipping
    this section. None of the features I go into here is relevant outside COM.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 4之前，如果你想要与COM组件进行交互，VB（Visual Basic）是一个更好的选择。它一直是一个相对宽松的语言，至少如果你要求它如此的话，并且它从一开始就支持命名参数和可选参数。C#
    4让与COM交互的工作变得更加简单。尽管如此，如果你不使用COM，跳过这一节你也不会错过任何重要的内容。这里提到的所有功能都与COM无关。
- en: '|  |'
  id: totrans-1602
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: COM is the Component Object Model introduced by Microsoft in 1993 as a cross-language
    form of interoperability on Windows. A full description is beyond the scope of
    this book, but you’re likely to know about it if you need to know about it. The
    most commonly used COM libraries are probably those for Microsoft Office.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: COM是微软在1993年引入的组件对象模型，它是一种在Windows上的跨语言互操作性形式。完整的描述超出了本书的范围，但如果你需要了解它，你很可能已经知道了。最常用的COM库可能是Microsoft
    Office的库。
- en: '|  |'
  id: totrans-1605
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s start with a feature that goes beyond the language. It’s mostly about
    deployment, although it also impacts how the operations are exposed.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从超越语言本身的一个特性开始。这主要关于部署，尽管它也影响了操作如何被暴露。
- en: 4.3.1\. Linking primary interop assemblies
  id: totrans-1607
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1. 链接主要互操作程序集
- en: When you code against a COM type, you use an assembly generated for the component
    library. Usually, you use a *primary interop assembly* (PIA) generated by the
    component publisher. You can use the Type Library Importer tool (`tlbimp`) to
    generate this for your own COM libraries.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 当你针对COM类型进行编码时，你使用为组件库生成的程序集。通常，你使用组件发布者生成的*主要互操作程序集*（PIA）。你可以使用类型库导入工具（`tlbimp`）为你自己的COM库生成这个程序集。
- en: Before C# 4, the complete PIA had to be present on the machine where the code
    finally ran, and it had to be the same version as the one that you compiled against.
    This either meant shipping the PIA along with your application or trusting that
    the right version would already be installed.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 4之前，完整的PIA必须在代码最终运行的机器上存在，并且它必须与编译时使用的版本相同。这意味着要么将PIA与应用程序一起分发，要么相信正确的版本已经安装。
- en: From C# 4 and Visual Studio 2010 onward, you can choose to *link* the PIA instead
    of *referencing* it. In Visual Studio, in the property page for the reference,
    this is the Embed Interop Types option.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 4和Visual Studio 2010开始，你可以选择链接PIA（Primary Interop Assembly）而不是引用它。在Visual
    Studio中，在引用的属性页中，这是嵌入互操作类型选项。
- en: When this option is set to True, the relevant parts of the PIA are embedded
    directly into your assembly. Only the bits you use within your application are
    included. When the code runs, it doesn’t matter whether the exact same version
    of the component you used to compile against is present on the client machine,
    so long as it has everything that your application needs. [Figure 4.3](kindle_split_019_split_000.html#ch04fig03)
    shows the difference between referencing (the old way) and linking (the new way)
    in terms of how the code runs.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 当此选项设置为 True 时，PIA 的相关部分将直接嵌入到你的程序集中。只包含你应用程序中使用的位。当代码运行时，只要客户端机器上有你应用程序所需的一切，无论你用于编译的组件的确切版本是否相同，都没有关系。[图
    4.3](kindle_split_019_split_000.html#ch04fig03) 显示了在代码运行方面引用（旧方法）和链接（新方法）之间的差异。
- en: Figure 4.3\. Comparing referencing and linking
  id: totrans-1612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 比较引用和链接
- en: '![](../Images/04fig03_alt.jpg)'
  id: totrans-1613
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig03_alt.jpg)'
- en: In addition to deployment changes, linking the PIA affects how the VARIANT type
    is treated within the COM type. When the PIA is referenced, any operations returning
    a `VARIANT` value would be exposed using the `object` type in C#. You’d then have
    to cast that to the appropriate type to use its methods and properties.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 除了部署更改外，将 PIA 链接会影响 COM 类型中 VARIANT 类型的处理方式。当引用 PIA 时，任何返回 VARIANT 值的操作都会在 C#
    中使用 `object` 类型公开。然后你必须将其转换为适当的类型以使用其方法和属性。
- en: When the PIA is linked instead, `dynamic` is returned instead of `object`. As
    you saw earlier, there’s an implicit conversion from an expression of type `dynamic`
    to any nonpointer type, which is then checked at execution time. The following
    listing shows an example of opening Excel and populating 20 cells in a range.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PIA 被链接时，返回的是 `dynamic` 而不是 `object`。正如你之前看到的，从 `dynamic` 类型的表达式到任何非指针类型的隐式转换是存在的，然后在执行时进行检查。以下列表显示了一个打开
    Excel 并填充一个范围内的 20 个单元格的示例。
- en: Listing 4.16\. Setting a range of values in Excel with implicit dynamic conversion
  id: totrans-1616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.16\. 使用隐式动态转换在 Excel 中设置一系列值
- en: '[PRE196]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[Listing 4.16](kindle_split_019_split_000.html#ch04ex16) silently uses some
    of the features coming up later, but for the moment focus on the assignments to
    `sheet`, `start`, and `end`. Each would need a cast normally, as the value being
    assigned would be of type `object`. You don’t have to specify the static types
    for the variables; if you used `var` or `dynamic` for the variable types, you’d
    be using dynamic typing for more operations. I prefer to specify the static type
    where I know what I expect it to be, partly for the implicit validation this performs
    and partly to enable IntelliSense in the code that follows.'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.16](kindle_split_019_split_000.html#ch04ex16) 静默地使用了一些即将出现的功能，但此时请关注对
    `sheet`、`start` 和 `end` 的赋值。每个赋值通常都需要转换，因为被赋值的值将是 `object` 类型。你不必指定变量的静态类型；如果你为变量类型使用了
    `var` 或 `dynamic`，你将使用动态类型进行更多操作。我更喜欢在我知道期望它是什么类型的地方指定静态类型，部分是因为它执行的隐式验证，部分是为了在后续代码中启用
    IntelliSense。'
- en: For COM libraries that use `VARIANT` extensively, this is one of the most important
    benefits of dynamic typing. The next COM feature also builds on a new feature
    in C# 4 and takes optional parameters to a new level.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于广泛使用 VARIANT 的 COM 库，这是动态类型最重要的好处之一。下一个 COM 功能也是基于 C# 4 中的一个新特性，并将可选参数提升到了新的水平。
- en: 4.3.2\. Optional parameters in COM
  id: totrans-1620
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. COM 中的可选参数
- en: Some COM methods have a *lot* of parameters, and often they’re all `ref` parameters.
    This meant that prior to C# 4, a simple act like saving a file in Word could be
    extremely painful.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 COM 方法有很多参数，而且通常它们都是 `ref` 参数。这意味着在 C# 4 之前，像在 Word 中保存文件这样的简单操作可能会非常痛苦。
- en: Listing 4.17\. Creating a Word document and saving it before C# 4
  id: totrans-1622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17\. 在 C# 4 之前创建 Word 文档并保存
- en: '[PRE197]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '***1* Placeholder variable for ref parameters**'
  id: totrans-1624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ref 参数的占位符变量**'
- en: '***2* Starts Word**'
  id: totrans-1625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 启动 Word**'
- en: '***3* Creates and populates a document**'
  id: totrans-1626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建并填充文档**'
- en: '***4* Saves the document**'
  id: totrans-1627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 保存文档**'
- en: '***5* Closes Word**'
  id: totrans-1628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 关闭 Word**'
- en: A lot of code is required just to create and save a document, including 20 occurrences
    of `ref missing`. It’s hard to see the useful part of the code within the forest
    of arguments you don’t care about.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了创建和保存文档就需要大量的代码，包括 20 次的 `ref missing` 出现。在你不关心的参数森林中，很难看到代码的有用部分。
- en: 'C# 4 provides features that all work together to make this much simpler:'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: C# 4 提供了使这一过程变得简单得多的功能：
- en: Named arguments can be used to make it clear which argument should correspond
    to which parameter, as you’ve already seen.
  id: totrans-1631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名参数可用于明确指定哪个参数对应哪个参数，正如您已经看到的。
- en: Just for COM libraries, values can be specified directly as arguments for `ref`
    parameters. The compiler will create a local variable behind the scenes and pass
    that by reference.
  id: totrans-1632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对于 COM 库，可以直接将值作为 `ref` 参数的参数指定。编译器将在幕后创建一个局部变量并将其通过引用传递。
- en: Just for COM libraries, `ref` parameters can be optional and then omitted in
    the calling code. `Type.Missing` is used as the default value.
  id: totrans-1633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对于 COM 库，`ref` 参数可以是可选的，并且在调用代码中省略。使用 `Type.Missing` 作为默认值。
- en: With all of these features in play, you can transform [listing 4.17](kindle_split_019_split_000.html#ch04ex17)
    into much shorter and cleaner code.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些功能都起作用的情况下，您可以将 [列表 4.17](kindle_split_019_split_000.html#ch04ex17) 转换为更短、更干净的代码。
- en: Listing 4.18\. Creating a Word document and saving it using C# 4
  id: totrans-1635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.18\. 使用 C# 4 创建并保存 Word 文档
- en: '[PRE198]'
  id: totrans-1636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '***1* Optional parameters omitted everywhere**'
  id: totrans-1637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在所有地方省略了可选参数**'
- en: '***2* Named argument used for clarity**'
  id: totrans-1638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用命名参数提高清晰度**'
- en: This is a dramatic transformation in readability. All 20 occurrences of `ref
    missing` are gone, as is the variable itself. As it happens, the argument you
    pass to `SaveAs2` corresponds to the first parameter of the method. You could
    use a positional argument instead of a named argument, but specifying the name
    adds clarity. If you also wanted to specify a value for a later parameter, you
    could do so by name without providing values for all the other parameters in between.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 这在可读性方面是一个巨大的转变。所有 20 个 `ref missing` 出现的地方以及该变量本身都消失了。碰巧的是，传递给 `SaveAs2` 的参数对应于方法的第一参数。您可以使用位置参数而不是命名参数，但指定名称会增加清晰度。如果您还想为后续参数指定值，您可以通过名称指定，而无需为所有其他参数提供值。
- en: That argument to `SaveAs2` also demonstrates the implicit `ref` feature. Instead
    of having to declare a variable within an initial value of `demo2.docx` and then
    pass that by reference, you can pass the value directly, as far as our source
    code is concerned. The compiler handles turning it into a `ref` parameter for
    you. The final COM-related feature exposes another aspect where VB is slightly
    richer than C#.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 那个传递给 `SaveAs2` 的参数也展示了隐式 `ref` 功能。在我们的源代码中，您可以直接传递值，而不是在 `demo2.docx` 的初始值中声明一个变量然后通过引用传递它。编译器会为您将其转换为
    `ref` 参数。最终的 COM 相关功能揭示了 VB 在某些方面比 C# 更丰富。
- en: 4.3.3\. Named indexers
  id: totrans-1641
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3\. 命名索引器
- en: 'Indexers have been present in C# since the beginning. They’re primarily used
    for collections: retrieving an element from a list by index or retrieving a value
    from a dictionary by key, for example. But C# indexers are never named in source
    code. You can write only the *default indexer* for the type. You can specify a
    name by using an attribute, and that name will be consumed by other languages,
    but C# doesn’t let you differentiate between indexers by name. At least, it didn’t
    until C#4.'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器自 C# 诞生以来就存在。它们主要用于集合：例如，通过索引从列表中检索元素或通过键从字典中检索值。但 C# 的索引器在源代码中从不命名。您只能为类型编写
    *默认索引器*。您可以使用属性指定名称，并且该名称将被其他语言消费，但 C# 不允许您通过名称区分索引器。至少，在 C# 4 之前是这样的。
- en: Other languages allow you to write and consume indexers with names, so you can
    access different aspects of an object via indexes using the name to make it clear
    what you want. C# still doesn’t do this for regular .NET code, but it makes an
    exception just for COM types. An example will make this clearer.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言允许您编写和消费具有名称的索引器，因此您可以通过名称访问对象的不同方面，以明确您想要的内容。C# 仍然没有为常规 .NET 代码做这件事，但它为
    COM 类型做出了例外。以下示例将使这一点更清晰。
- en: 'The `Application` type in Word exposes a named indexer called `SynonymInfo`.
    It’s declared like this:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: Word 中的 `Application` 类型公开了一个名为 `SynonymInfo` 的命名索引器。它的声明如下：
- en: '[PRE199]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Prior to C# 4, you could call the indexer as if it were a method called `get_SynonymInfo`,
    but that’s somewhat awkward. In C# 4, you can access it by name, as shown in the
    following listing.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 4 之前，您可以像调用方法 `get_SynonymInfo` 一样调用索引器，但这有些尴尬。在 C# 4 中，您可以通过名称访问它，如下面的列表所示。
- en: Listing 4.19\. Accessing a named indexer
  id: totrans-1647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.19\. 访问命名索引器
- en: '[PRE200]'
  id: totrans-1648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '***1* Accessing synonyms prior to C# 4**'
  id: totrans-1649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 C# 4 之前访问同义词**'
- en: '***2* Simpler code using a named indexer**'
  id: totrans-1650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用命名索引器编写更简洁的代码**'
- en: '[Listing 4.19](kindle_split_019_split_000.html#ch04ex19) shows how optional
    parameters can be used in named indexers as well as regular method calls. The
    code for before C# 4 has to declare a variable and pass it by reference to the
    awkwardly named method. With C# 4, you can use the indexer by name, and you can
    omit the argument for the second parameter.'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.19](kindle_split_019_split_000.html#ch04ex19) 展示了如何在命名索引器和常规方法调用中使用可选参数。在
    C# 4 之前，代码必须声明一个变量并将其通过引用传递给名称古怪的方法。在 C# 4 中，你可以通过名称使用索引器，并且可以省略第二个参数的参数。'
- en: That was a brief run through the COM-related features in C# 4, but I hope the
    benefits are obvious. Even though I don’t work with COM regularly, the changes
    shown here would make me a lot less despondent if I ever need to in the future.
    The extent of the benefit will depend on how the COM library you’re working with
    is structured. For example, if it uses a lot of `ref` parameters and `VARIANT`
    return types, the difference will be more significant than a library with few
    parameters and concrete return types. But even just the option of linking the
    PIA could make deployment significantly simpler.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对 C# 4 中 COM 相关特性的简要概述，但我希望其好处是显而易见的。尽管我并不经常与 COM 一起工作，但这里显示的更改如果将来需要，会让我感到少些沮丧。好处的程度将取决于你正在工作的
    COM 库的结构。例如，如果它使用了大量的 `ref` 参数和 `VARIANT` 返回类型，那么与参数较少且具有具体返回类型的库相比，差异将更加显著。但即使只是链接
    PIA 的选项，也能使部署显著简化。
- en: We’re coming toward the end of C# 4 now. The final feature can be a bit tricky
    to get your head around, but it’s also one you may use without even thinking about
    it.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正接近 C# 4 的尾声。最后一个特性可能有点难以理解，但你可能在不经意间就使用了它。
- en: 4.4\. Generic variance
  id: totrans-1654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 泛型变体
- en: Generic variance is easier to show than to describe. It’s about safely converting
    between generic types based on their type arguments and paying particular attention
    to the direction in which data travels.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型变体比描述起来更容易展示。它涉及到基于它们的类型参数安全地在泛型类型之间进行转换，并特别注意数据流动的方向。
- en: 4.4.1\. Simple examples of variance in action
  id: totrans-1656
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 变体在行动中的简单示例
- en: 'We’ll start with an example using a familiar interface, `IEnumerable<T>`, which
    represents a sequence of elements of type `T`. It makes sense that any sequence
    of strings is also a sequence of objects, and variance allows that:'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个使用熟悉接口的示例开始，即 `IEnumerable<T>`，它表示类型 `T` 的元素序列。任何字符串序列也是对象序列是有意义的，变体允许这一点：
- en: '[PRE201]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: That may seem so natural that you’d be surprised if it failed to compile, but
    that’s exactly what would’ve happened before C# 4.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来如此自然，以至于你会惊讶它无法编译，但这正是 C# 4 之前会发生的事情。
- en: '|  |'
  id: totrans-1660
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I’m using `string` and `object` consistently in these examples because they’re
    classes that all C# developers know about and aren’t tied to any particular context.
    Other classes with the same base class/derived class relationship would work just
    as well.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我始终使用 `string` 和 `object`，因为它们是所有 C# 开发者都知道的类，并且与任何特定上下文无关。具有相同基类/派生类关系的其他类也会以同样的方式工作。
- en: '|  |'
  id: totrans-1663
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'There are potentially more surprises to come; not everything that sounds like
    it should work does work, even with C# 4\. For example, you might try to extend
    the reasoning about sequences to lists. Is any list of strings a list of objects?
    You might think so, but it’s not:'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有更多的惊喜在等着我们；即使是在 C# 4 中，也不是所有听起来应该工作的事情都能工作。例如，你可能会尝试将关于序列的推理扩展到列表。任何字符串列表是否都是对象列表？你可能这么认为，但事实并非如此：
- en: '[PRE202]'
  id: totrans-1665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '***1* Invalid: no conversion from IList<string> to IList<object>**'
  id: totrans-1666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效：无法从 `IList<string>` 转换到 `IList<object>`**'
- en: 'What’s the difference between `IEnumerable<T>` and `IList<T>`? Why isn’t this
    allowed? The answer is that it wouldn’t be safe, because the methods within `IList<T>`
    allow values of type `T` as inputs as well as outputs. Every way you can use an
    `IEnumerable<T>` ends up with `T` values being returned as output, but `IList<T>`
    has methods like `Add` that accept a `T` value as input. That would make it dangerous
    to allow variance. You can see this if you try to extend our invalid example a
    little:'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>` 和 `IList<T>` 之间有什么区别？为什么不允许这样做？答案是这不会是安全的，因为 `IList<T>` 中的方法允许
    `T` 类型的值作为输入和输出。你使用 `IEnumerable<T>` 的任何方式最终都会返回 `T` 类型的值作为输出，但 `IList<T>` 有像
    `Add` 这样的方法，它接受一个 `T` 类型的值作为输入。这会使允许变体变得危险。如果你尝试稍微扩展我们的无效示例，你会看到这一点：'
- en: '[PRE203]'
  id: totrans-1668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '***1* Adds an object to the list**'
  id: totrans-1669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 向列表中添加一个对象**'
- en: '***2* Retrieves it as a string**'
  id: totrans-1670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 以字符串的形式检索它**'
- en: Every line other than the second one makes sense on its own. It’s fine to add
    an `object` reference to an `IList<object>`, and it’s fine to take a string reference
    from an `IList<string>`. But if you can treat a list of strings as a list of objects,
    those two abilities come into conflict. The language rules that make the second
    line invalid are effectively protecting the rest of the code.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第二行之外的其他每一行单独来看都是有意义的。将一个`object`引用添加到`IList<object>`中是可以的，从`IList<string>`中获取一个字符串引用也是可以的。但是，如果你可以将字符串列表视为对象列表，那么这两个能力就会产生冲突。使第二行无效的语言规则实际上是在保护代码的其余部分。
- en: So far, you’ve seen values being returned as output (`IEnumerable<T>`) and values
    being used as both input and output (`IList<T>`). In some APIs, values are always
    used only as input. The simplest example of this is the `Action<T>` delegate,
    where you pass in a value of type `T` when you invoke the delegate. Variance still
    applies here, but in the opposite direction. This can be confusing to start with.
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了值作为输出返回（`IEnumerable<T>`）和值既用作输入又用作输出（`IList<T>`）。在某些API中，值始终只用作输入。这个例子最简单，就是`Action<T>`委托，当你调用委托时，你会传递一个类型为`T`的值。可变性仍然适用，但方向相反。一开始这可能会让人感到困惑。
- en: 'If you have an `Action<object>` delegate, that can accept any object reference.
    It can definitely accept a string reference, and the language rules allow you
    to convert from `Action<object>` to `Action<string>`:'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个`Action<object>`委托，它可以接受任何对象引用。它肯定可以接受一个字符串引用，并且语言规则允许你从`Action<object>`转换为`Action<string>`：
- en: '[PRE204]'
  id: totrans-1674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'With those examples in hand, I can define some terminology:'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些例子，我可以定义一些术语：
- en: '*Covariance* occurs when values are returned only as output.'
  id: totrans-1676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*协变*发生在只返回值作为输出的情况下。'
- en: '*Contravariance* occurs when values are accepted only as input.'
  id: totrans-1677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逆变*发生在只接受值作为输入的情况下。'
- en: '*Invariance* occurs when values are used as input and output.'
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不变性*发生在值既用作输入又用作输出的情况下。'
- en: Those definitions are deliberately slightly vague for now. They’re more about
    the general concepts than they are about C#. We can tighten them up after you’ve
    looked at the syntax C# uses to specify variance.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义现在故意有些模糊。它们更多地关于一般概念，而不是C#。在你看过C#用来指定可变性的语法之后，我们可以使它们更精确。
- en: 4.4.2\. Syntax for variance in interface and delegate declarations
  id: totrans-1680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2. 接口和委托声明中可变性的语法
- en: 'The first thing to know about variance in C# is that it can be specified only
    for interfaces and delegates. You can’t make a class or struct covariant, for
    example. Next, variance is defined separately for each type parameter. Although
    you might loosely say “`IEnumerable<T>` is covariant,” it would be more precise
    to say “`IEnumerable<T>` is covariant *in T*.” That then leads to syntax for interface
    and delegate declarations in which each type parameter has a separate modifier.
    Here are the declarations for the `IEnumerable<T>` and `IList<T>` interfaces and
    `Action<T>` delegate:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C#中的可变性，首先要知道的是，它只能指定为接口和委托。例如，你不能使类或结构体协变。接下来，每个类型参数的可变性是分别定义的。尽管你可能会松散地说“`IEnumerable<T>`是协变的”，但更精确的说法是“`IEnumerable<T>`在T上是协变的。”这导致了接口和委托声明中的语法，其中每个类型参数都有一个单独的修饰符。以下是`IEnumerable<T>`和`IList<T>`接口以及`Action<T>`委托的声明：
- en: '[PRE205]'
  id: totrans-1682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'As you can see, the modifiers `in` and `out` are used to specify the variance
    of a type parameter:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`in`和`out`修饰符被用来指定类型参数的可变性：
- en: A type parameter with the `out` modifier is covariant.
  id: totrans-1684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`out`修饰符的类型参数是协变的。
- en: A type parameter with the `in` modifier is contravariant.
  id: totrans-1685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`in`修饰符的类型参数是逆变的。
- en: A type parameter with no modifiers is invariant.
  id: totrans-1686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有修饰符的类型参数是不变的。
- en: 'The compiler checks that the modifier you’ve used is suitable given the rest
    of the declaration. For example, this delegate declaration is invalid because
    a covariant type parameter is used as input:'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会检查你使用的修饰符是否适合整个声明中的其余部分。例如，这个委托声明是无效的，因为协变类型参数被用作输入：
- en: '[PRE206]'
  id: totrans-1688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'And this interface declaration is invalid because a contravariant type parameter
    is used as output:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个接口声明是无效的，因为逆变类型参数被用作输出：
- en: '[PRE207]'
  id: totrans-1690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Any single type parameter can have only one of these modifiers, but two type
    parameters in the same declaration can have different modifiers. For example,
    consider the `Func<T, TResult>` delegate. That accepts a value of type `T` and
    returns a value of type `TResult`. It’s natural for `T` to be contravariant and
    `TResult` to be covariant. The delegate declaration is as follows:'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 任何单个类型参数只能有一个这些修饰符，但在同一声明中的两个类型参数可以有不同的修饰符。例如，考虑`Func<T, TResult>`委托。它接受类型为`T`的值并返回类型为`TResult`的值。对于`T`来说，逆变性和对于`TResult`来说的可变性是自然的。委托声明如下：
- en: '[PRE208]'
  id: totrans-1692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: In everyday development, you’re likely to use existing variant interfaces and
    delegates more often than you declare them. A few restrictions exist in terms
    of the type arguments you can use. Let’s look at them now.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常开发中，你可能会比声明它们更频繁地使用现有的可变接口和委托。在可以使用类型参数方面存在一些限制。现在让我们来看看它们：
- en: 4.4.3\. Restrictions on using variance
  id: totrans-1694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3\. 使用可变性的限制
- en: 'To reiterate a point made earlier, variance can be declared only in interfaces
    and delegates. That variance isn’t inherited by classes or structs implementing
    interfaces; classes and structs are always invariant. As an example, suppose you
    were to create a class like this:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 重申之前提到的观点，可变性只能在接口和委托中声明。这种可变性不会被实现接口的类或结构体继承；类和结构体始终是不变的。例如，假设你创建了一个这样的类：
- en: '[PRE209]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '***1* The out modifier isn’t permitted here.**'
  id: totrans-1697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在这里不允许使用out修饰符。**'
- en: '***2* Implementation**'
  id: totrans-1698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 实现**'
- en: You still couldn’t convert from `SimpleEnumerable<string>` to a `SimpleEnumerable<object>`.
    You *could* convert from `SimpleEnumerable<string>` to `IEnumerable<object>` using
    the covariance of `IEnumerable<T>`.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然无法将`SimpleEnumerable<string>`转换为`SimpleEnumerable<object>`。你可以使用`IEnumerable<T>`的可变性将`SimpleEnumerable<string>`转换为`IEnumerable<object>`。
- en: 'Let’s assume you’re dealing with a delegate or interface with some covariant
    or contravariant type parameters. What conversions are available? You need definitions
    to explain the rules:'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理具有某些可变或逆变类型参数的委托或接口。有哪些可用的转换？你需要定义来解释规则：
- en: A conversion involving variance is called a *variance conversion*.
  id: totrans-1701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到可变性的转换被称为*可变性转换*。
- en: Variance conversion is one example of a *reference conversion*. A reference
    conversion is one that doesn’t change the value involved (which is always a reference);
    it only changes the compile-time type.
  id: totrans-1702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性转换是*引用转换*的一个例子。引用转换是一种不改变涉及值的转换（该值始终是引用）；它只改变编译时类型。
- en: An *identity conversion* is a conversion from one type to the same type as far
    as the CLR is concerned. This might be the same type from a C# perspective, too
    (from `string` to `string`, for example), or it might be between types that are
    different only as far as the C# language is concerned, such as from `object` to
    `dynamic`.
  id: totrans-1703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*恒等转换*是从一个类型到与CLR相关的相同类型的转换。这可能是从C#的角度来看相同的类型（例如，从`string`到`string`），或者它可能是仅从C#语言的角度来看不同的类型之间的转换，例如从`object`到`dynamic`。'
- en: 'Suppose you want to convert from `IEnumerable<A>` to `IEnumerable<B>` for some
    type arguments `A` and `B`. That’s valid if there’s an identity or implicit reference
    conversion from `A` to `B`. For example, these conversions are valid:'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将`IEnumerable<A>`转换为`IEnumerable<B>`，对于某些类型参数`A`和`B`。如果存在从`A`到`B`的恒等或隐式引用转换，这是有效的。例如，这些转换是有效的：
- en: '`IEnumerable<string>` to `IEnumerable<object>`: there’s an implicit reference
    conversion from a class to its base class (or its base class’s base class, and
    so forth).'
  id: totrans-1705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<string>` to `IEnumerable<object>`: 从一个类到其基类（或其基类的基类，等等）存在隐式引用转换。'
- en: '`IEnumerable<string>` to `IEnumerable<IConvertible>`: there’s an implicit reference
    conversion from a class to any interface it implements.'
  id: totrans-1706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<string>` to `IEnumerable<IConvertible>`: 从一个类到它实现的任何接口存在隐式引用转换。'
- en: '`IEnumerable<IDisposable>` to `IEnumerable<object>`: there’s an implicit reference
    conversion from any reference type to `object` or `dynamic`.'
  id: totrans-1707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<IDisposable>` to `IEnumerable<object>`: 从任何引用类型到`object`或`dynamic`存在隐式引用转换。'
- en: 'These conversions are invalid:'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换是无效的：
- en: '`IEnumerable<object>` to `IEnumerable<string>`: there’s an *explicit* reference
    conversion from `object` to `string`, but not an *implicit* one.'
  id: totrans-1709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<object>` to `IEnumerable<string>`: 从`object`到`string`存在*显式*引用转换，但不是*隐式*的。'
- en: '`IEnumerable<string> to IEnumerable<Stream>`: the string and Stream classes
    are unrelated.'
  id: totrans-1710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<string> to IEnumerable<Stream>`: 字符串和Stream类之间没有关联。'
- en: '`IEnumerable<int>` to `IEnumerable<IConvertible>`: there’s an implicit conversion
    from `int` to `IConvertible`, but it’s a boxing conversion rather than a reference
    conversion.'
  id: totrans-1711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<int>` 到 `IEnumerable<IConvertible>`：存在从 `int` 到 `IConvertible`
    的隐式转换，但这是一种装箱转换而不是引用转换。'
- en: '`IEnumerable<int>` to `IEnumerable<long>`: there’s an implicit conversion from
    `int` to `long`, but it’s a numeric conversion rather than a reference conversion.'
  id: totrans-1712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<int>` 到 `IEnumerable<long>`：存在从 `int` 到 `long` 的隐式转换，但这是一种数值转换而不是引用转换。'
- en: As you can see, the requirement that the conversion between type arguments is
    a reference or identity conversion affects value types in a way that you might
    find surprising.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，类型参数之间转换的要求是引用或等价转换，这会影响值类型，可能让您感到惊讶。
- en: That example using `IEnumerable<T>` has only a single type argument to consider.
    What about when you have multiple type arguments? Effectively, they’re checked
    pairwise from the source of the conversion to the target, making sure that each
    conversion is appropriate for the type parameter involved.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 那个使用 `IEnumerable<T>` 的例子只有一个需要考虑的类型参数。那么当您有多个类型参数时怎么办？实际上，它们是从转换的源到目标成对检查的，确保每个转换都适合相关的类型参数。
- en: 'To put this more formally, consider a generic type declaration with `n` type
    parameters: `T<X``[1]``, ..., X``[n]``>`. A conversion from `T<A``[1]``, ...,
    A``[n]``>` to `T<B``[1]``, ..., B``[n]``>` is considered in terms of each type
    parameter and pair of type arguments in turn. For each `i` between 1 and `n`:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更正式地说明，考虑一个具有 `n` 个类型参数的泛型类型声明：`T<X``[1]``, ..., X``[n]``>`。从 `T<A``[1]``,
    ..., A``[n]``>` 到 `T<B``[1]``, ..., B``[n]``>` 的转换是按每个类型参数及其对应的类型参数对依次考虑的。对于 `1`
    到 `n` 之间的每个 `i`：
- en: If `X``[i]` is covariant, there must be an identity or implicit reference conversion
    from `A``[i]` to `B``[i]`.
  id: totrans-1716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `X``[i]` 是协变的，那么必须存在从 `A``[i]` 到 `B``[i]` 的等价或隐式引用转换。
- en: If `X``[i]` is contravariant, there must be an identity or implicit reference
    conversion from `B``[i]` to `A``[i]`.
  id: totrans-1717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `X``[i]` 是逆变的，那么必须存在从 `B``[i]` 到 `A``[i]` 的等价或隐式引用转换。
- en: If `X``[i]` is invariant, there must be an identity conversion from `A``[i]`
    to `B``[i]`.
  id: totrans-1718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `X``[i]` 是不变的，那么必须存在从 `A``[i]` 到 `B``[i]` 的等价转换。
- en: 'To put this into a concrete example, let’s consider `Func<in T, out TResult>`.
    The rules mean the following:'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此具体化，让我们考虑 `Func<in T, out TResult>`。规则意味着以下内容：
- en: There’s a valid conversion from `Func<object, int>` to `Func<string, int>` because
  id: totrans-1720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `Func<object, int>` 到 `Func<string, int>` 存在一个有效的转换，因为
- en: The first type parameter is contravariant, and there’s an implicit reference
    conversion from `string` to `object`.
  id: totrans-1721
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个类型参数是逆变的，并且存在从 `string` 到 `object` 的隐式引用转换。
- en: The second type parameter is covariant, and there’s an identity conversion from
    `int` to `int`.
  id: totrans-1722
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个类型参数是协变的，并且存在从 `int` 到 `int` 的等价转换。
- en: There’s a valid conversion from `Func<dynamic, string>` to `Func<object, IConvertible>`
    because
  id: totrans-1723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `Func<dynamic, string>` 到 `Func<object, IConvertible>` 存在一个有效的转换，因为
- en: The first type parameter is contravariant, and there’s an identity conversion
    from `dynamic` to `object`.
  id: totrans-1724
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个类型参数是逆变的，并且存在从 `dynamic` 到 `object` 的等价转换。
- en: The second type parameter is covariant, and there’s an implicit reference conversion
    from `string` to `IConvertible`.
  id: totrans-1725
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个类型参数是协变的，并且存在从 `string` 到 `IConvertible` 的隐式引用转换。
- en: There’s no conversion from `Func<string, int>` to `Func<object, int>` because
  id: totrans-1726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `Func<string, int>` 到 `Func<object, int>` 没有转换，因为
- en: The first type parameter is contravariant, and there’s no implicit reference
    conversion from `object` to `string`.
  id: totrans-1727
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个类型参数是逆变的，并且不存在从 `object` 到 `string` 的隐式引用转换。
- en: The second type parameter doesn’t matter; the conversion is already invalid
    because of the first type parameter.
  id: totrans-1728
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个类型参数无关紧要；由于第一个类型参数，转换已经无效。
- en: Don’t worry if all of this is a bit overwhelming; 99% of the time you won’t
    even notice you’re using generic variance. I’ve provided this detail to help you
    just in case you receive a compile-time error and don’t understand why.^([[3](kindle_split_019_split_000.html#ch04fn3)])
    Let’s wrap up by looking at a couple of examples of when generic variance is useful.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切都让您感到有些不知所措，请不要担心；99% 的时间您甚至不会注意到您正在使用泛型变异性。我提供了这些细节，以防您在编译时遇到错误且不理解原因.^([[3](kindle_split_019_split_000.html#ch04fn3)])
    让我们通过查看几个泛型变异性有用的例子来总结。
- en: ³
  id: totrans-1730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If this proves insufficient for a particular error, I suggest turning to the
    third edition, which has even more detail.
  id: totrans-1732
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这不足以证明某个特定错误，我建议转向第三版，其中包含更多细节。
- en: 4.4.4\. Generic variance in practice
  id: totrans-1733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4\. 实际中的泛型变异性
- en: A lot of the time, you may end up using generic variance without even being
    conscious of doing so, because things just work as you’d probably want them to.
    There’s no particular need to be aware that you’re using generic variance, but
    I’ll point out a couple of examples of where it’s useful.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 很多的时间，你可能会在不自觉的情况下使用泛型变体，因为事情就像你可能会希望的那样工作。没有特别必要意识到你正在使用泛型变体，但我将指出几个它有用的例子。
- en: First, let’s consider LINQ and `IEnumerable<T>`. Suppose you have strings that
    you want to perform a query on, but you want to end up with a `List<object>` instead
    of a `List<string>`. For example, you may need to add other items to the list
    afterward. The following listing shows how before covariance, the simplest way
    to do this would be to use an extra `Cast` call.
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑 LINQ 和 `IEnumerable<T>`。假设你有一些字符串想要进行查询，但你希望最终得到一个 `List<object>` 而不是
    `List<string>`。例如，你可能需要在之后向列表中添加其他项。下面的列表显示了在协变之前，这样做最简单的方法是使用额外的 `Cast` 调用。
- en: Listing 4.20\. Creating a `List<object>` from a string query without variance
  id: totrans-1736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.20\. 从字符串查询创建一个没有变体的 `List<object>`
- en: '[PRE210]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: That feels annoying to me. Why create a whole extra step in the pipeline just
    to change the type in a way that’ll always work? With variance, you can specify
    a type argument to the `ToList()` call instead, to specify the type of list you
    want, as in the following listing.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我来说感觉有点烦恼。为什么要在管道中创建一个额外的步骤只是为了改变类型，而这总是会成功？有了变体，你可以在 `ToList()` 调用中指定一个类型参数，以指定你想要的列表类型，如下面的列表所示。
- en: Listing 4.21\. Creating a `List<object>` from a string query by using variance
  id: totrans-1739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.21\. 通过使用变体从字符串查询创建一个 `List<object>`
- en: '[PRE211]'
  id: totrans-1740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: This works because the output of the `Where` call is an `IEnumerable<string>`,
    and you’re asking the compiler to treat the input of the `ToList()` call as an
    `IEnumerable<object>`. That’s fine because of variance.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `Where` 调用的输出是一个 `IEnumerable<string>`，而你要求编译器将 `ToList()` 调用的输入视为
    `IEnumerable<object>`。这很好，因为存在变体。
- en: I’ve found contravariance to be useful in conjunction with `IComparer<T>`, the
    interface for ordering comparisons of another type. As an example, suppose you
    have a `Shape` base class with an `Area` property and then `Circle` and `Rectangle`
    derived classes. You can write an `AreaComparer` that implements `IComparer<Shape>`,
    and that’s fine for sorting a `List<Shape>` in place using `List<T>.Sort()`. But
    if you have a `List<Circle>` or a `List<Rectangle>`, how do you sort that? Various
    workarounds existed before generic variance, but the following listing shows how
    it’s trivial now.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现协变与 `IComparer<T>`（用于对其他类型进行排序比较的接口）结合使用很有用。例如，假设你有一个具有 `Area` 属性的 `Shape`
    基类，以及 `Circle` 和 `Rectangle` 派生类。你可以编写一个实现 `IComparer<Shape>` 的 `AreaComparer`，这对于使用
    `List<T>.Sort()` 在原地对 `List<Shape>` 进行排序是不错的。但是，如果你有一个 `List<Circle>` 或 `List<Rectangle>`，你该如何排序呢？在泛型变体出现之前，存在各种解决方案，但下面的列表显示了现在这变得多么简单。
- en: Listing 4.22\. Sorting a `List<Circle>` with an `IComparer<Shape>`
  id: totrans-1743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.22\. 使用 `IComparer<Shape>` 对 `List<Circle>` 进行排序
- en: '[PRE212]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: The full source for the types used by [listing 4.22](kindle_split_019_split_000.html#ch04ex22)
    is in the downloadable code, but they’re as simple as you’d expect them to be.
    The key point is that you can convert `AreaComparer` to `IComparer<Circle>` for
    the `Sort` method call. That wasn’t the case before C# 4.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.22](kindle_split_019_split_000.html#ch04ex22) 中使用的类型的完整源代码在可下载的代码中，但它们就像你预期的那样简单。关键点是你可以将
    `AreaComparer` 转换为 `IComparer<Circle>` 以用于 `Sort` 方法调用。在 C# 4 之前并不是这样。'
- en: If you declare your own generic interfaces or delegates, it’s always worth considering
    whether the type parameters can be covariant or contravariant. I wouldn’t normally
    try to force the issue if it doesn’t fall out that way naturally, but it’s worth
    taking a moment to think about it. It can be annoying to use an interface that
    *could* have variant type parameters but where the developer just hadn’t considered
    whether it might be useful to someone.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明自己的泛型接口或委托，始终值得考虑类型参数是否可以是协变的或逆变的。如果它不是自然地这样，我通常不会尝试强迫这个问题，但花点时间思考一下是值得的。使用一个可能具有变体型参数的接口，但开发者没有考虑它可能对某人有用，这可能会让人感到烦恼。
- en: Summary
  id: totrans-1747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: C# 4 supports *dynamic typing*, which defers binding from compile time to execution
    time.
  id: totrans-1748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 4 支持动态类型，它将绑定从编译时推迟到执行时。
- en: Dynamic typing supports custom behavior via `IDynamicMetaObjectProvider` and
    the `DynamicObject` class.
  id: totrans-1749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类型通过 `IDynamicMetaObjectProvider` 和 `DynamicObject` 类支持自定义行为。
- en: Dynamic typing is implemented with both compiler and framework features. The
    framework optimizes and caches heavily to make it reasonably efficient.
  id: totrans-1750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类型通过编译器和框架功能实现。框架通过优化和大量缓存来提高效率。
- en: C# 4 allows parameters to specify default values. Any parameter with a default
    value is an *optional parameter* and doesn’t have to be provided by the caller.
  id: totrans-1751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 4 允许参数指定默认值。任何具有默认值的参数都是 *可选参数*，调用者不必提供。
- en: C# 4 allows arguments to specify the name of the parameter for which it’s intended
    to provide the value. This works with optional parameters to allow you to specify
    arguments for some parameters but not others.
  id: totrans-1752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 4 允许参数指定它打算提供值的参数名称。这与可选参数一起工作，允许您为某些参数指定参数，而不为其他参数指定。
- en: C# 4 allows COM primary interop assemblies (PIAs) to be *linked* rather than
    *referenced*, which leads to a simpler deployment model.
  id: totrans-1753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 4 允许 COM 主要互操作程序集 (PIAs) 被链接而不是引用，这导致了一个更简单的部署模型。
- en: Linked PIAs expose variant values via dynamic typing, which avoids a lot of
    casting.
  id: totrans-1754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过动态类型公开变体值的链接PIAs，这避免了大量的类型转换。
- en: Optional parameters are extended for COM libraries to allow `ref` parameters
    to be optional.
  id: totrans-1755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数在 COM 库中被扩展，允许 `ref` 参数是可选的。
- en: Ref parameters in COM libraries can be specified by value.
  id: totrans-1756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COM 库中的引用参数可以通过值指定。
- en: Generic variance allows safe conversions for generic interfaces and delegates
    based on whether values act as input or output.
  id: totrans-1757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型方差允许基于值作为输入或输出进行安全转换的泛型接口和委托。
- en: Chapter 5\. Writing asynchronous code
  id: totrans-1758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 编写异步代码
- en: '|  |'
  id: totrans-1759
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: What it means to write asynchronous code
  id: totrans-1761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写异步代码的含义
- en: Declaring asynchronous methods with the `async` modifier
  id: totrans-1762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `async` 修饰符声明异步方法
- en: Waiting asynchronously with the `await` operator
  id: totrans-1763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `await` 操作符异步等待
- en: Language changes in async/await since C# 5
  id: totrans-1764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自 C# 5 以来 async/await 的语言变化
- en: Following usage guidelines for asynchronous code
  id: totrans-1765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循异步代码的使用指南
- en: '|  |'
  id: totrans-1766
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Asynchrony has been a thorn in the side of developers for years. It’s been known
    to be useful as a way of avoiding tying up a thread while waiting for some arbitrary
    task to complete, but it’s also been a pain in the neck to implement correctly.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 异步已经多年困扰着开发者。它已知可以作为避免在等待某些任意任务完成时占用线程的一种方式是有用的，但它正确实现起来也很痛苦。
- en: 'Even within the .NET Framework (which is still relatively young in the grand
    scheme of things), we’ve had three models to try to make things simpler:'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在.NET框架（在事物的大背景下仍然相对较年轻）中，我们也尝试了三种模型来使事情变得更简单：
- en: The `BeginFoo`/`EndFoo` approach from .NET 1.x, using `IAsyncResult` and `AsyncCallback`
    to propagate results
  id: totrans-1769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 1.x 中的 `BeginFoo`/`EndFoo` 方法，使用 `IAsyncResult` 和 `AsyncCallback` 来传播结果
- en: The event-based asynchronous pattern from .NET 2.0, as implemented by `BackgroundWorker`
    and `WebClient`
  id: totrans-1770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 2.0 中的基于事件的异步模式，由 `BackgroundWorker` 和 `WebClient` 实现
- en: The Task Parallel Library (TPL) introduced in .NET 4.0 and expanded in .NET
    4.5
  id: totrans-1771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 4.0 中引入并在 .NET 4.5 中扩展的任务并行库 (TPL)
- en: Despite the TPL’s generally excellent design, writing robust and readable asynchronous
    code with it was hard. Although the support for parallelism was great, some aspects
    of general asynchrony are much better fixed in a language instead of purely in
    libraries.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TPL的设计总体上非常优秀，但用它来编写健壮且易于阅读的异步代码仍然很困难。尽管对并行性的支持很好，但一些通用异步的方面在语言中固定得更好，而不是仅仅在库中。
- en: The main feature of C# 5 is typically called *async/await*, and it builds on
    the TPL. It allows you to write synchronous-looking code that uses asynchrony
    where appropriate. Gone is the spaghetti of callbacks, event subscriptions, and
    fragmented error handling; instead, asynchronous code expresses its intentions
    clearly and in a form that builds on the structures that developers are already
    familiar with. The language construct introduced in C# 5 allows you to await an
    asynchronous operation. This awaiting looks very much like a normal blocking call
    in that the rest of your code won’t continue until the operation has completed,
    but it manages to do this without blocking the currently executing thread. Don’t
    worry if that statement sounds completely contradictory; all will become clear
    over the course of the chapter.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5 的主要特性通常被称为 *async/await*，它建立在 TPL 的基础上。它允许你在适当的地方编写看起来同步的代码，使用异步。回调、事件订阅和碎片化错误处理的混乱已经消失；相反，异步代码清晰地表达了其意图，并以开发者已经熟悉的结构为基础。C#
    5 中引入的语言结构允许你等待异步操作。这种等待看起来非常像正常的阻塞调用，即你的代码在操作完成之前不会继续执行，但它设法在不阻塞当前执行线程的情况下做到这一点。如果你觉得这个陈述听起来完全矛盾，不要担心；所有这些都会在章节的进程中变得清晰。
- en: Async/await has evolved a little over time, and for simplicity I’ve included
    the new features from C# 6 and C# 7 alongside the original C# 5 descriptions.
    I’ve called out those changes so you know when you need a C# 6 or C# 7 compiler.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: Async/await 在时间上有所发展，为了简化，我将 C# 6 和 C# 7 的新特性与原始的 C# 5 描述一起包含在内。我已经指出了这些变化，以便你知道何时需要
    C# 6 或 C# 7 编译器。
- en: The .NET Framework embraced asynchrony wholeheartedly in version 4.5, exposing
    asynchronous versions of a great many operations following a *task-based asynchronous
    pattern* to give a consistent experience across multiple APIs. Similarly, the
    Windows Runtime platform, which is the basis of Universal Windows Applications
    (UWA/UWP), enforces asynchrony for all long-running (or potentially long-running)
    operations. Many other modern APIs rely heavily on asynchrony, such as Roslyn
    and `HttpClient`. In short, most C# developers will have to use asynchrony in
    at least *some* part of their work.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 在 4.5 版本中完全拥抱了异步，通过遵循 *基于任务的异步模式* 提供了许多操作的异步版本，以在多个 API 中提供一致的经验。同样，Windows
    运行时平台（它是通用 Windows 应用程序（UWA/UWP）的基础）对所有长时间运行（或可能长时间运行）的操作强制执行异步。许多其他现代 API 也大量依赖异步，例如
    Roslyn 和 `HttpClient`。简而言之，大多数 C# 开发者至少需要在他们的工作中使用异步的*某些*部分。
- en: '|  |'
  id: totrans-1776
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The Windows Runtime platform is commonly known as *WinRT*; it’s not to be confused
    with Windows RT, which was an edition of Windows 8.x for ARM processors. *Universal
    Windows Applications* are an evolution of Windows Store applications. *UWP* is
    a further evolution of UWA from Windows 10 onward.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 运行时平台通常被称为 *WinRT*；它不要与 Windows RT 混淆，Windows RT 是为 ARM 处理器设计的 Windows
    8.x 版本。*通用 Windows 应用程序* 是 Windows Store 应用的一个演变。*UWP* 是从 Windows 10 开始对 UWA 的进一步演变。
- en: '|  |'
  id: totrans-1779
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To be clear, C# hasn’t become omniscient, guessing where you might want to perform
    operations concurrently or asynchronously. The compiler is smart, but it doesn’t
    attempt to remove the *inherent* complexity of asynchronous execution. You still
    need to think carefully, but the beauty of async/await is that all the tedious
    and confusing boilerplate code that used to be required has gone. Without the
    distraction of all the fluff required to make your code asynchronous to start
    with, you can concentrate on the hard bits.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点，C# 并没有变得无所不知，猜测你可能想要在哪里执行并发或异步操作。编译器很聪明，但它不会尝试消除异步执行的*固有*复杂性。你仍然需要仔细思考，但
    async/await 的美妙之处在于，所有那些曾经需要的繁琐且令人困惑的样板代码都消失了。没有一开始就需要使代码异步的所有干扰，你可以专注于难点。
- en: 'A word of warning: this topic is reasonably advanced. It has the unfortunate
    properties of being incredibly important (realistically, even entry-level developers
    need to have a reasonable understanding of it) but also quite tricky to get your
    head around to start with.'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一句：这个主题相当高级。它具有不幸的特性，即它非常重要（实际上，即使是入门级开发者也需要对此有合理的理解），但一开始又相当难以理解。
- en: This chapter focuses on asynchrony from a “regular developer” perspective, so
    you can use async/await without needing to understand too much of the detail.
    [Chapter 6](kindle_split_021_split_000.html#ch06) goes into a lot more of the
    complexity of the implementation. I feel you’ll be a better developer if you understand
    what’s going on behind the scenes, but you can certainly take what you’ll learn
    from this chapter and be productive with async/await before diving deeper. Even
    within this chapter, you’ll be looking at the feature in an iterative process,
    with more detail the further you go.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从“普通开发者”的角度关注异步性，因此你可以使用async/await而无需了解太多细节。[第6章](kindle_split_021_split_000.html#ch06)将深入探讨实现的复杂性。我认为如果你了解幕后发生的事情，你会成为一个更好的开发者，但你当然可以在深入了解之前，从本章中学到的东西来使用async/await并变得高效。即使在本书中，你也会以迭代的方式查看这个功能，随着你深入，细节会越来越多。
- en: 5.1\. Introducing asynchronous functions
  id: totrans-1783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 异步函数的介绍
- en: So far, I’ve claimed that C# 5 makes async easier, but I’ve given only a tiny
    description of the features involved. Let’s fix that and then look at an example.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我声称C# 5使异步操作更容易，但我只给出了涉及功能的微小描述。让我们来解决这个问题，然后看看一个例子。
- en: C# 5 introduces the concept of an *asynchronous function*. This is always either
    a method or an anonymous function that’s declared with the `async` modifier, and
    it can use the `await` operator for await expressions.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5引入了异步函数的概念。这始终是一个方法或使用`async`修饰符声明的匿名函数，它可以使用`await`运算符进行await表达式。
- en: '|  |'
  id: totrans-1786
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As a reminder, an anonymous function is either a lambda expression or an anonymous
    method.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，匿名函数可以是lambda表达式或匿名方法。
- en: '|  |'
  id: totrans-1789
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The *await expressions* are the points where things get interesting from a
    language perspective: if the operation the expression is awaiting hasn’t completed
    yet, the asynchronous function will return immediately, and it’ll then continue
    where it left off (in an appropriate thread) when the value becomes available.
    The natural flow of not executing the next statement until this one has completed
    is still maintained but without blocking. I’ll break down that woolly description
    into more-concrete terms and behavior later, but you need to see an example before
    it’s likely to make any sense.'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: '*await表达式*是语言角度上事物变得有趣的地方：如果表达式所等待的操作尚未完成，异步函数将立即返回，并在值变得可用时（在适当的线程中）继续执行。在执行下一个语句之前等待这一语句完成的自然流程仍然保持，但不会阻塞。我将在稍后用更具体的概念和行为来解释这个模糊的描述，但在你理解它之前，你需要先看到一个例子。'
- en: 5.1.1\. First encounters of the asynchronous kind
  id: totrans-1791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 异步类型的首次接触
- en: Let’s start with something simple that demonstrates asynchrony in a practical
    way. We often curse network latency for causing delays in our real applications,
    but latency does make it easy to show why asynchrony is so important—particularly
    when using a GUI framework such as Windows Forms. Our first example is a tiny
    Windows Forms app that fetches the text of this book’s homepage and displays the
    length of the HTML in a label.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的内容开始，以实际的方式展示异步性。我们经常诅咒网络延迟导致我们的实际应用中延迟，但延迟确实使展示异步性为何如此重要变得容易——尤其是在使用Windows
    Forms这样的GUI框架时。我们的第一个例子是一个微型的Windows Forms应用程序，它获取这本书主页的文本，并在标签中显示HTML的长度。
- en: Listing 5.1\. Displaying a page length asynchronously
  id: totrans-1793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. 异步显示页面长度
- en: '[PRE213]'
  id: totrans-1794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '***1* Wires up event handler**'
  id: totrans-1795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 连接事件处理器**'
- en: '***2* Starts fetching the page**'
  id: totrans-1796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 开始获取页面**'
- en: '***3* Updates the UI**'
  id: totrans-1797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 更新UI**'
- en: '***4* Entry point; just runs the form**'
  id: totrans-1798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 入口点；仅运行表单**'
- en: The first part of this code creates the UI and hooks up an event handler for
    the button in a straightforward way. It’s the `DisplayWebSiteLength` method that’s
    of interest here. When you click the button, the text of the homepage is fetched,
    and the label is updated to display the HTML length in characters.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这一部分以直接的方式创建了用户界面，并为按钮连接了一个事件处理器。这里感兴趣的是`DisplayWebSiteLength`方法。当你点击按钮时，会获取主页的文本，并将标签更新以显示HTML的字符长度。
- en: '|  |'
  id: totrans-1800
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'I’m not disposing of the task returned by `GetStringAsync`, even though `Task`
    implements `IDisposable`. Fortunately, you don’t need to dispose of tasks in general.
    The background of this is somewhat complicated, but Stephen Toub explains it in
    a blog post dedicated to the topic: [http://mng.bz/E6L3](http://mng.bz/E6L3).'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 我并没有释放`GetStringAsync`返回的任务，尽管`Task`实现了`IDisposable`。幸运的是，你通常不需要释放任务。这个背景有些复杂，但Stephen
    Toub在一篇专门讨论这个主题的博客文章中解释了它：[http://mng.bz/E6L3](http://mng.bz/E6L3)。
- en: '|  |'
  id: totrans-1803
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I could’ve written a smaller example program as a console app, but hopefully
    [listing 5.1](kindle_split_020_split_000.html#ch05ex01) makes a more convincing
    demo. In particular, if you remove the `async` and `await` contextual keywords,
    change `HttpClient` to `WebClient`, and change `GetStringAsync` to `DownloadString`,
    the code will still compile and work, but the UI will freeze while it fetches
    the contents of the page. If you run the async version (ideally, over a slow network
    connection), you’ll see that the `UI` is responsive; you can still move the window
    around while the web page is fetching.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 我本来可以写一个更小的示例程序作为控制台应用程序，但希望[列表 5.1](kindle_split_020_split_000.html#ch05ex01)能提供一个更有说服力的演示。特别是，如果你移除了`async`和`await`上下文关键字，将`HttpClient`改为`WebClient`，并将`GetStringAsync`改为`DownloadString`，代码仍然可以编译并运行，但在获取页面内容时UI会冻结。如果你运行异步版本（理想情况下，通过慢速网络连接），你会看到`UI`是响应的；在网页获取内容的同时，你仍然可以移动窗口。
- en: '|  |'
  id: totrans-1805
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`HttpClient` is in some senses the new and improved `WebClient`; it’s the preferred
    HTTP API for .NET 4.5 onward, and it contains only asynchronous operations.'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些意义上，`HttpClient`是改进后的`WebClient`；它是从.NET 4.5开始的推荐HTTP API，并且只包含异步操作。
- en: '|  |'
  id: totrans-1808
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Most developers are familiar with the two golden rules of threading in Windows
    Forms development:'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者都熟悉在 Windows Forms 开发中线程的两大黄金法则：
- en: Don’t perform any time-consuming action on the UI thread.
  id: totrans-1810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在UI线程上执行任何耗时操作。
- en: Don’t access any UI controls *other* than on the UI thread.
  id: totrans-1811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在UI线程上访问任何UI控件*之外*的控件。
- en: You may regard Windows Forms as a legacy technology these days, but most GUI
    frameworks have the same rules, and they’re easier to state than to obey. As an
    exercise, you might want to try a few ways of creating code similar to [listing
    5.1](kindle_split_020_split_000.html#ch05ex01) without using async/await. For
    this extremely simple example, it’s not too bad to use the event-based `WebClient.DownloadStringAsync`
    method, but as soon as more complex flow control (error handling, waiting for
    multiple pages to complete, and so on) comes into the equation, the legacy code
    quickly becomes hard to maintain, whereas the C# 5 code can be modified in a natural
    way.
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能认为Windows Forms是一种过时的技术，但大多数GUI框架都有相同的规则，而且它们比遵守起来更容易。作为一个练习，你可能想尝试几种不使用async/await创建类似[列表
    5.1](kindle_split_020_split_000.html#ch05ex01)的代码的方法。对于这个极其简单的示例，使用基于事件的`WebClient.DownloadStringAsync`方法还不错，但一旦涉及到更复杂的流程控制（错误处理、等待多个页面完成等），旧代码很快就会变得难以维护，而C#
    5代码可以自然地修改。
- en: 'At this point, the `DisplayWebSiteLength` method feels somewhat magical: you
    know it does what you need it to, but you have no idea how. Let’s take it apart
    a little bit and save the gory details for later.'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`DisplayWebSiteLength`方法感觉有些神奇：你知道它做了你需要它做的事情，但你不知道它是如何做到的。让我们稍微分解一下，并将细节留到以后再说。
- en: 5.1.2\. Breaking down the first example
  id: totrans-1814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2. 分解第一个示例
- en: 'You’ll start by slightly expanding the method. In [listing 5.1](kindle_split_020_split_000.html#ch05ex01),
    I used `await` directly on the return value of `HttpClient.GetStringAsync`, but
    you can separate the call from the awaiting part:'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从稍微扩展该方法开始。在[列表 5.1](kindle_split_020_split_000.html#ch05ex01)中，我直接在`HttpClient.GetStringAsync`的返回值上使用了`await`，但你也可以将调用与等待部分分开：
- en: '[PRE214]'
  id: totrans-1816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Notice that the type of `task` is `Task<string>`, but the type of the `await
    task` expression is simply `string`. In this sense, the `await` operator performs
    an unwrapping operation—at least when the value being awaited is a `Task<TResult>`.
    (As you’ll see, you can await other types, too, but `Task<TResult>` is a good
    starting point.) That’s one aspect of `await` that doesn’t seem directly related
    to asynchrony but makes life easier.
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`task`的类型是`Task<string>`，但`await task`表达式的类型仅仅是`string`。从这个意义上说，`await`操作符执行了解包操作——至少当被等待的值是`Task<TResult>`时。（正如你将看到的，你也可以等待其他类型，但`Task<TResult>`是一个好的起点。）这是`await`的一个方面，它似乎与异步性没有直接关系，但使生活变得更简单。
- en: The main purpose of `await` is to avoid blocking while you wait for time-consuming
    operations to complete. You may be wondering how this all works in the concrete
    terms of threading. You’re setting `label.Text` at the start and end of the method,
    so it’s reasonable to assume that both of those statements are executed on the
    UI thread, and yet you’re clearly not blocking the UI thread while you wait for
    the web page to download.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 的主要目的是在你等待耗时操作完成时避免阻塞。你可能想知道这一切在具体的线程术语中是如何工作的。你在方法的开头和结尾设置 `label.Text`，因此可以合理地假设这两个语句都是在
    UI 线程上执行的，而你显然在等待网页下载时并没有阻塞 UI 线程。'
- en: The trick is that the method returns as soon as it hits the await expression.
    Until that point, it executes synchronously on the UI thread, like any other event
    handler would. If you put a breakpoint on the first line and hit it in the debugger,
    you’ll see that the stack trace shows that the button is busy raising its `Click`
    event, including the `Button.OnClick` method. When you reach the `await`, the
    code checks whether the result is already available, and if it’s not (which will
    almost certainly be the case), it schedules a continuation to be executed when
    the web operation has completed. In this example, the continuation executes the
    rest of the method, effectively jumping to the end of the await expression. The
    continuation is executed in the UI thread, which is what you need so that you
    can manipulate the UI.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍在于方法在遇到 await 表达式时立即返回。直到那时，它像任何其他事件处理器一样在 UI 线程上同步执行。如果你在第一行设置断点并在调试器中触发它，你会看到堆栈跟踪显示按钮正在忙于引发其
    `Click` 事件，包括 `Button.OnClick` 方法。当你到达 `await` 时，代码检查结果是否已经可用，如果不可用（这几乎肯定是这样），它将调度一个后续操作在网页操作完成时执行。在这个例子中，后续操作执行方法的其余部分，实际上跳转到
    await 表达式的末尾。后续操作在 UI 线程上执行，这是你所需要的，以便你可以操作 UI。
- en: '|  |'
  id: totrans-1820
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-1821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: 'A *continuation* is effectively a callback to be executed when an asynchronous
    operation (or any `Task`) has completed. In an async method, the continuation
    maintains the state of the method. Just as a closure maintains its environment
    in terms of variables, a continuation remembers the point where it reached, so
    it can continue from there when it’s executed. The `Task` class has a method specifically
    for attaching continuations: `Task.ContinueWith`.'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *后续操作* 有效地是一个在异步操作（或任何 `Task`）完成时要执行的回调。在异步方法中，后续操作保持方法的状态。就像闭包在变量方面保持其环境一样，后续操作会记住它达到的点，因此当它执行时可以从那里继续。`Task`
    类有一个专门用于附加后续操作的方法：`Task.ContinueWith`。
- en: '|  |'
  id: totrans-1823
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you then put a breakpoint in the code after the await expression and run
    the code again, then assuming that the await expression needed to schedule the
    continuation, you’ll see that the stack trace no longer has the `Button.OnClick`
    method in it. That method finished executing long ago. The call stack will now
    effectively be the bare Windows Forms event loop with a few layers of async infrastructure
    on top. The call stack will be similar to what you’d see if you called `Control.Invoke`
    from a background thread in order to update the UI appropriately, but it’s all
    been done for you. At first it can be unnerving to notice the call stack change
    dramatically under your feet, but it’s absolutely necessary for asynchrony to
    be effective.
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你然后在 await 表达式之后的代码中设置一个断点并再次运行代码，那么假设 await 表达式需要调度后续操作，你会发现堆栈跟踪中不再包含 `Button.OnClick`
    方法。该方法早已执行完毕。调用堆栈现在实际上将是一个裸露的 Windows Forms 事件循环，上面有几层异步基础设施。调用堆栈将类似于你在后台线程中调用
    `Control.Invoke` 以适当地更新 UI 时所看到的情况，但所有这些都已经为你完成了。一开始可能会觉得脚下调用堆栈的变化令人不安，但这对异步操作的有效性是绝对必要的。
- en: The compiler achieves all of this by creating a complicated state machine. That’s
    an implementation detail you’ll look at in [chapter 6](kindle_split_021_split_000.html#ch06),
    but for now you’re going to concentrate on the functionality that async/await
    provides. First, you need a more concrete description of what you’re trying to
    achieve and what the language specifies.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过创建一个复杂的状态机来实现所有这些。这是你将在第 6 章中查看的实现细节，但就目前而言，你需要集中精力研究 async/await 提供的功能。首先，你需要一个更具体的描述，说明你试图实现什么以及语言指定了什么。
- en: 5.2\. Thinking about asynchrony
  id: totrans-1826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 考虑异步操作
- en: If you ask a developer to describe asynchronous execution, chances are they’ll
    start talking about multithreading. Although that’s an important part of *typical*
    uses of asynchrony, it’s not required for asynchronous execution. To fully appreciate
    how the async feature of C# 5 works, it’s best to strip away any thoughts of threading
    and go back to basics.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要求一个开发者描述异步执行，他们很可能会开始谈论多线程。尽管那是异步使用的*典型*部分，但它并不是异步执行所必需的。要完全理解C# 5的异步功能是如何工作的，最好是抛开任何关于线程的想法，回到基础。
- en: 5.2.1\. Fundamentals of asynchronous execution
  id: totrans-1828
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1. 异步执行的基本原理
- en: 'Asynchrony strikes at the very heart of the execution model that C# developers
    are familiar with. Consider simple code like this:'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 异步攻击了C#开发者熟悉的执行模型的核心。考虑以下简单的代码：
- en: '[PRE215]'
  id: totrans-1830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: You expect the first call to complete and then the second call to start. Execution
    flows from one statement to the next, in order. But an asynchronous execution
    model doesn’t work that way. Instead, it’s all about *continuations*. When you
    start doing something, you tell that operation what you want to happen when that
    operation has completed. You may have heard (or used) the term *callback* for
    the same idea, but that has a broader meaning than the one we’re after here. In
    the context of asynchrony, I’m using the term to refer to callbacks that preserve
    the state of the program rather than arbitrary callbacks for other purposes, such
    as GUI event handlers.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望第一次调用完成之后，第二次调用才开始。执行流程是从一个语句到下一个语句，按顺序进行。但是异步执行模型并不是这样工作的。相反，它完全是关于*延续*。当你开始做某事时，你告诉那个操作，当那个操作完成时你希望发生什么。你可能听说过（或使用过）*回调*这个术语，但它的含义比我们在这里追求的含义更广泛。在异步的上下文中，我使用这个术语来指代那些保留程序状态的回调，而不是用于其他目的的任意回调，例如GUI事件处理器。
- en: Continuations are naturally represented as delegates in .NET, and they’re typically
    actions that receive the results of the asynchronous operation. That’s why, to
    use the asynchronous methods in `WebClient` prior to C# 5, you’d wire up various
    events to say what code should be executed in the case of success, failure, and
    so on. The trouble is, creating all those delegates for a complicated sequence
    of steps ends up being very complicated, even with the benefit of lambda expressions.
    It’s even worse when you try to make sure that your error handling is correct.
    (On a good day, I can be reasonably confident that the success paths of handwritten
    asynchronous code are correct. I’m typically less certain that it reacts the right
    way on failure.)
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 延续在.NET中自然地表示为委托，并且通常是接收异步操作结果的动作。这就是为什么，在C# 5之前使用`WebClient`的异步方法时，你需要连接各种事件，以说明在成功、失败等情况下的代码应该执行什么。问题是，为复杂的一系列步骤创建所有这些委托最终变得非常复杂，即使有lambda表达式的帮助也是如此。当你试图确保错误处理正确时，情况变得更糟。（在好日子里，我可以相当自信地认为手写的异步代码的成功路径是正确的。我通常不太确定它在失败时是否反应正确。）
- en: Essentially, all that `await` in C# does is ask the compiler to build a continuation
    for you. For an idea that can be expressed so simply, however, the consequences
    for readability and developer serenity are remarkable.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，C#中的所有`await`所做的只是要求编译器为你构建一个延续。然而，对于这样一个可以如此简单表达的想法，它对可读性和开发者宁静的影响是显著的。
- en: 'My earlier description of asynchrony was an idealized one. The reality in the
    task-based asynchronous pattern is slightly different. Instead of the continuation
    being passed to the asynchronous operation, the asynchronous operation starts
    and returns a token you can use to provide the continuation later. It represents
    the ongoing operation, which may have completed before it has returned to the
    calling code or may still be in progress. That token is then used whenever you
    want to express this idea: I can’t proceed any further until this operation has
    completed. Typically, the token is in the form of a `Task` or `Task<TResult>`,
    but it doesn’t have to be.'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前对异步的描述是一个理想化的描述。在基于任务的异步模式中，现实情况略有不同。不是将延续传递给异步操作，而是异步操作开始并返回一个你可以用来稍后提供延续的令牌。这个令牌代表了正在进行的操作，这个操作可能在返回到调用代码之前已经完成，也可能仍在进行中。这个令牌在你想表达这个想法时被使用：我无法继续进行，直到这个操作完成。通常，这个令牌的形式是`Task`或`Task<TResult>`，但它不必是。
- en: '|  |'
  id: totrans-1835
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The token described here isn’t the same as a cancellation token, although both
    have the same emphasis on the fact that you don’t need to know what’s going on
    behind the scenes; you only need to know what the token allows you to do.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的令牌与取消令牌不同，尽管两者都强调你不需要了解幕后发生的事情；你只需要知道令牌允许你做什么。
- en: '|  |'
  id: totrans-1838
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The execution flow in an asynchronous method in C# 5 typically follows these
    lines:'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 5 中，异步方法的执行流程通常遵循以下步骤：
- en: Do some work.
  id: totrans-1840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一些工作。
- en: Start an asynchronous operation and remember the token it returns.
  id: totrans-1841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个异步操作并记住它返回的令牌。
- en: Possibly do some more work. (Often, you can’t make any further progress until
    the asynchronous operation has completed, in which case this step is empty.)
  id: totrans-1842
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能还会执行更多工作。（通常，直到异步操作完成，你才能取得进一步进展，在这种情况下，这一步是空的。）
- en: Wait for the asynchronous operation to complete (via the token).
  id: totrans-1843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待异步操作完成（通过令牌）。
- en: Do some more work.
  id: totrans-1844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行更多工作。
- en: Finish.
  id: totrans-1845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成。
- en: If you didn’t care about exactly what the wait part meant, you could do all
    of this in C# 4\. If you’re happy to *block* until the asynchronous operation
    completes, the token will normally provide you some way of doing so. For a `Task`,
    you could simply call `Wait()`. At that point, though, you’re taking up a valuable
    resource (a thread) and not doing any useful work. It’s a little like phoning
    for a delivery pizza and then standing at your front door until it arrives. What
    you really want to do is get on with something else and ignore the pizza until
    it arrives. That’s where `await` comes in.
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎等待部分的确切含义，你可以在 C# 4 中完成所有这些。如果你愿意阻塞直到异步操作完成，令牌通常会提供一种方法让你这样做。对于 `Task`，你可以简单地调用
    `Wait()`。然而，在那个时刻，你正在占用一个宝贵的资源（一个线程）而没有做任何有用的工作。这有点像打电话订购送货披萨，然后站在你家门前直到它到达。你真正想做的应该是继续做其他事情，忽略披萨直到它到达。这就是
    `await` 的作用。
- en: When you wait for an asynchronous operation, you’re saying “I’ve gone as far
    as I can go for now. Keep going when the operation has completed.” But if you’re
    not going to block the thread, what can you do? Very simply, you can return right
    then and there. You’ll continue asynchronously yourself. And if you want your
    caller to know when your asynchronous method has completed, you’ll pass a token
    back to the caller, which they can block on if they want or (more likely) use
    with another continuation. Often, you’ll end up with a whole stack of asynchronous
    methods calling each other; it’s almost as if you go into an “async mode” for
    a section of code. Nothing in the language states that it has to be done that
    way, but the fact that the same code that consumes asynchronous operations also
    behaves as an asynchronous operation certainly encourages it.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 当你等待异步操作时，你是在说“我现在已经走到尽头了。操作完成后继续。”但如果你不想阻塞线程，你能做什么呢？非常简单，你可以在那里直接返回。你将自行继续异步操作。而且，如果你想让你的调用者知道你的异步方法何时完成，你可以将令牌传回调用者，他们可以选择阻塞或者（更可能的是）使用另一个延续。通常，你最终会得到一整个堆栈的异步方法相互调用；这几乎就像你进入了一段代码的“异步模式”。语言中没有规定必须这样做，但消耗异步操作的同一段代码也表现出异步操作的行为，这确实鼓励了这样做。
- en: 5.2.2\. Synchronization contexts
  id: totrans-1848
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 同步上下文
- en: Earlier I mentioned that one of the golden rules of UI code is that you mustn’t
    update the user interface unless you’re on the right thread. In [listing 5.1](kindle_split_020_split_000.html#ch05ex01),
    which checked the length of a web page asynchronously, you needed to ensure that
    the code after the await expression executed on the UI thread. Asynchronous functions
    get back to the right thread by using `SynchronizationContext`, a class that’s
    existed since .NET 2.0 and is used by other components such as `BackgroundWorker`.
    A `SynchronizationContext` generalizes the idea of executing a delegate on an
    appropriate thread; its `Post` (asynchronous) and `Send` (synchronous) messages
    are similar to `Control .BeginInvoke` and `Control.Invoke` in Windows Forms.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到，UI 代码的黄金法则之一是，除非你在正确的线程上，否则你不应该更新用户界面。在[列表 5.1](kindle_split_020_split_000.html#ch05ex01)中，该列表异步检查网页长度，你需要确保
    await 表达式之后的代码在 UI 线程上执行。异步函数通过使用 `SynchronizationContext` 返回正确的线程，这是一个自 .NET
    2.0 以来就存在的类，也被其他组件如 `BackgroundWorker` 使用。`SynchronizationContext` 通用化在适当线程上执行委托的想法；它的
    `Post`（异步）和 `Send`（同步）消息类似于 Windows Forms 中的 `Control.BeginInvoke` 和 `Control.Invoke`。
- en: Different execution environments use different contexts; for example, one context
    may let any thread from the thread pool execute the action it’s given. More contextual
    information exists than in the synchronization context, but if you start wondering
    how asynchronous methods manage to execute exactly where you want them to, it’s
    the synchronization context that you need to focus on.
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的执行环境使用不同的上下文；例如，一个上下文可能允许线程池中的任何线程执行它给出的操作。在同步上下文中存在更多的上下文信息，但如果你开始想知道异步方法是如何精确地在你想要它们执行的地方执行的，那么你需要关注的是同步上下文。
- en: 'For more information on `SynchronizationContext`, read Stephen Cleary’s MSDN
    magazine article on the topic ([http://mng.bz/5cDw](http://mng.bz/5cDw)). In particular,
    pay careful attention if you’re an ASP.NET developer; the ASP.NET context can
    easily trap unwary developers into creating deadlocks within code that looks fine.
    The story changes slightly for ASP.NET Core, but Stephen has another blog post
    covering that: [http://mng.bz/5YrO](http://mng.bz/5YrO).'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `SynchronizationContext` 的信息，请阅读 Stephen Cleary 在 MSDN 杂志上关于该主题的文章（[http://mng.bz/5cDw](http://mng.bz/5cDw)）。特别是，如果你是
    ASP.NET 开发者，请特别注意；ASP.NET 上下文很容易使粗心的开发者在其看似良好的代码中创建死锁。对于 ASP.NET Core，情况略有不同，Stephen
    另有一篇博客文章涵盖了这个话题：[http://mng.bz/5YrO](http://mng.bz/5YrO)。
- en: '|  |'
  id: totrans-1852
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Use of Task.Wait() and Task.Result in examples**'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例中 Task.Wait() 和 Task.Result 的使用**'
- en: I’ve used `Task.Wait()` and `Task.Result` in some of the sample code because
    it leads to simple examples. It’s usually safe to do so in a console application
    because in that case there’s no synchronization context; continuations for async
    methods will always execute in the thread pool.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一些示例代码中使用了 `Task.Wait()` 和 `Task.Result`，因为这会导致简单的示例。在控制台应用程序中这样做通常是安全的，因为在这种情况下没有同步上下文；异步方法的继续执行总是在线程池中。
- en: In real-world applications, you should take great care using these methods.
    They both block until they complete, which means if you call them from a thread
    that a continuation needs to execute on, you can easily deadlock your application.
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，使用这些方法时应格外小心。它们都会阻塞直到完成，这意味着如果你从需要在该线程上执行继续操作的线程中调用它们，你很容易使应用程序发生死锁。
- en: '|  |'
  id: totrans-1856
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: With the theory out of the way, let’s take a closer look at the concrete details
    of asynchronous methods. Asynchronous anonymous functions fit into the same mental
    model, but it’s much easier to talk about asynchronous methods.
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 理论部分已经讲完，让我们更仔细地看看异步方法的具体细节。异步匿名函数符合相同的思维模型，但讨论异步方法要容易得多。
- en: 5.2.3\. Modeling asynchronous methods
  id: totrans-1858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. 模拟异步方法
- en: I find it useful to think about asynchronous methods as shown in [figure 5.1](kindle_split_020_split_000.html#ch05fig01).
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现将异步方法想象成 [图 5.1](kindle_split_020_split_000.html#ch05fig01) 中展示的那样是有用的。
- en: Figure 5.1\. Modeling asynchronous boundaries
  id: totrans-1860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. 模拟异步边界
- en: '![](../Images/05fig01_alt.jpg)'
  id: totrans-1861
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig01_alt.jpg)'
- en: Here you have three blocks of code (the methods) and two boundary types (the
    method return types). As a simple example, in a console-based version of our page-length
    fetching application, you might have code like the following.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你有三个代码块（方法）和两种边界类型（方法返回类型）。作为一个简单的例子，在我们的页面长度获取应用程序的控制台版本中，你可能会有以下代码。
- en: Listing 5.2\. Retrieving a page length in an asynchronous method
  id: totrans-1863
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 在异步方法中检索页面长度
- en: '[PRE216]'
  id: totrans-1864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[Figure 5.2](kindle_split_020_split_000.html#ch05fig02) shows how the concrete
    details in [listing 5.2](kindle_split_020_split_000.html#ch05ex02) map to the
    concepts in [figure 5.1](kindle_split_020_split_000.html#ch05fig01).'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.2](kindle_split_020_split_000.html#ch05fig02) 展示了 [列表 5.2](kindle_split_020_split_000.html#ch05ex02)
    中的具体细节如何映射到 [图 5.1](kindle_split_020_split_000.html#ch05fig01) 中的概念。'
- en: Figure 5.2\. Applying the details of [listing 5.2](kindle_split_020_split_000.html#ch05ex02)
    to the general pattern shown in [figure 5.1](kindle_split_020_split_000.html#ch05fig01)
  id: totrans-1866
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 将 [列表 5.2](kindle_split_020_split_000.html#ch05ex02) 的细节应用于 [图 5.1](kindle_split_020_split_000.html#ch05fig01)
    中显示的通用模式
- en: '![](../Images/05fig02_alt.jpg)'
  id: totrans-1867
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig02_alt.jpg)'
- en: You’re mainly interested in the `GetPageLengthAsync` method, but I’ve included
    `PrintPageLength` so you can see how the methods interact. In particular, you
    definitely need to know about the valid types at the method boundaries. I’ll repeat
    this diagram in various forms through the chapter.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 你主要对 `GetPageLengthAsync` 方法感兴趣，但我包括了 `PrintPageLength`，这样你可以看到这些方法是如何交互的。特别是，你绝对需要了解方法边界处的有效类型。我将在本章中以各种形式重复这个图。
- en: You’re finally ready to look at writing async methods and the way they’ll behave.
    There’s a lot to cover here, as what you can do and what happens when you do it
    blend together to a large extent.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 你终于准备好查看编写异步方法及其行为方式了。这里有很多内容需要介绍，因为你可以做的事情和当你这样做时会发生的事情在很大程度上是融合在一起的。
- en: 'There are only two new pieces of syntax: `async` is a modifier used when declaring
    an asynchronous method, and the `await` operator is used to consume asynchronous
    operations. But following the way information is transferred between parts of
    your program gets complicated quickly, especially when you have to consider what
    happens when things go wrong. I’ve tried to separate out the different aspects,
    but your code will be dealing with everything at once. If you find yourself asking
    “But what about...?” while reading this section, keep reading; chances are your
    question will be answered soon.'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两处新的语法：`async`是在声明异步方法时使用的修饰符，而`await`运算符用于消费异步操作。但是，随着信息在程序各部分之间传递的方式变得复杂，尤其是在你必须考虑出错时，这会变得特别复杂。我已经尝试将不同的方面分开，但你的代码将一次性处理所有这些。如果你在阅读这一节时发现自己正在问“但是……怎么办？”的问题，请继续阅读；很可能你的问题很快就会得到解答。
- en: 'The next three sections look at an asynchronous method in three stages:'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个部分将探讨异步方法在三个阶段的表现：
- en: Declaring the async method
  id: totrans-1872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明异步方法
- en: Using the `await` operator to asynchronously wait for operations to complete
  id: totrans-1873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`await`运算符异步等待操作完成
- en: Returning a value when your method is complete
  id: totrans-1874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法完成时返回值
- en: '[Figure 5.3](kindle_split_020_split_000.html#ch05fig03) shows how these sections
    fit into our conceptual model.'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.3](kindle_split_020_split_000.html#ch05fig03)展示了这些章节如何融入我们的概念模型。'
- en: Figure 5.3\. Demonstrating how [sections 5.3](kindle_split_020_split_000.html#ch05lev1sec3),
    [5.4](kindle_split_020_split_000.html#ch05lev1sec4), and [5.5](kindle_split_020_split_000.html#ch05lev1sec5)
    fit into the conceptual model of asynchrony
  id: totrans-1876
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 展示[5.3节](kindle_split_020_split_000.html#ch05lev1sec3)、[5.4节](kindle_split_020_split_000.html#ch05lev1sec4)和[5.5节](kindle_split_020_split_000.html#ch05lev1sec5)如何融入异步概念模型
- en: '![](../Images/05fig03_alt.jpg)'
  id: totrans-1877
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig03_alt.jpg)'
- en: Let’s start with the method declaration itself; that’s the easiest bit.
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从方法声明本身开始；这是最容易的部分。
- en: 5.3\. Async method declarations
  id: totrans-1879
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 异步方法声明
- en: 'The syntax for an async method declaration is exactly the same as for any other
    method, except it has to include the `async` contextual keyword. This can appear
    anywhere before the return type. All of these are valid:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法声明的语法与任何其他方法的语法完全相同，只是它必须包含`async`上下文关键字。这个关键字可以出现在返回类型之前的任何位置。所有这些都是有效的：
- en: '[PRE217]'
  id: totrans-1881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: My preference is to keep the `async` modifier immediately before the return
    type, but there’s no reason you shouldn’t come up with your own convention. As
    always, discuss it with your team and try to be consistent within one codebase.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 我的偏好是将`async`修饰符直接放在返回类型之前，但没有任何理由你不应该制定自己的约定。像往常一样，与你的团队讨论，并尽量在单个代码库中保持一致性。
- en: 'Now, the `async` contextual keyword has a little secret: the language designers
    didn’t need to include it at all. In the same way the compiler goes into a sort
    of iterator block mode when you try to use `yield return` or `yield break` in
    a method with a suitable return type, the compiler could have spotted the use
    of `await` inside a method and used that to go into async mode. But I’m pleased
    that `async` is required, because it makes it much easier to read code written
    using asynchronous methods. It sets your expectations immediately, so you’re actively
    looking for await expressions, and you can actively look for any blocking calls
    that should be turned into an async call and an await expression.'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`async`上下文关键字有一个小小的秘密：语言设计者其实根本不需要包含它。就像编译器在方法中使用`yield return`或`yield break`时进入一种迭代器块模式一样，编译器本可以检测到方法中`await`的使用，并利用这一点进入异步模式。但我很高兴`async`是必需的，因为它使得使用异步方法编写的代码更容易阅读。它立即设定了你的期望，因此你会主动寻找`await`表达式，你可以主动寻找任何应该转换为异步调用和`await`表达式的阻塞调用。
- en: The fact that the `async` modifier has no representation in the generated code
    is important, though. As far as the calling method is concerned, it’s a normal
    method that happens to return a task. You can change an existing method (with
    an appropriate signature) to use `async`, or you could go in the other direction;
    it’s a compatible change in terms of both source and binary. The fact that it’s
    a detail of the implementation of the method means that you can’t declare an abstract
    method or a method in an interface using `async`. It’s perfectly possible for
    there to be an interface specifying a method with a return type of `Task<int>`;
    one implementation of that interface can use async/await while another implementation
    uses a regular method.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`async`修饰符在生成的代码中没有表示，但这很重要。从调用方法的角度来看，它是一个正常的方法，碰巧返回一个任务。你可以将现有的方法（具有适当的签名）更改为使用
    `async`，或者你可以朝相反的方向进行；这是源代码和二进制文件兼容的更改。由于这是方法实现的一个细节，因此你不能使用 `async` 声明抽象方法或接口中的方法。完全可能存在一个指定方法返回类型为
    `Task<int>` 的接口；该接口的一个实现可以使用 async/await，而另一个实现则使用常规方法。
- en: 5.3.1\. Return types from async methods
  id: totrans-1885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. 异步方法的返回类型
- en: 'Communication between the caller and the async method is effectively in terms
    of the value returned. In C# 5, asynchronous functions are limited to the following
    return types:'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者与异步方法之间的通信实际上是以返回的值来进行的。在 C# 5 中，异步函数限制为以下返回类型：
- en: '`void`'
  id: totrans-1887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`'
- en: '`Task`'
  id: totrans-1888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task`'
- en: '`Task<TResult>` (for some type `TResult`, which could itself be a type parameter)'
  id: totrans-1889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task<TResult>`（对于某种类型 `TResult`，该类型本身也可以是类型参数）'
- en: In C# 7, this list is expanded to include *task types*. You’ll come back to
    those in [section 5.8](kindle_split_020_split_000.html#ch05lev1sec8) and then
    again in [chapter 6](kindle_split_021_split_000.html#ch06).
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7 中，这个列表扩展到包括 *任务类型*。你将在 [5.8 节](kindle_split_020_split_000.html#ch05lev1sec8)
    和 [第 6 章](kindle_split_021_split_000.html#ch06) 中再次回到这些内容。
- en: The .NET 4 `Task` and `Task<TResult>` types both represent an operation that
    may not have completed yet; `Task<TResult>` derives from `Task`. The difference
    between the two is that `Task<TResult>` represents an operation that returns a
    value of type `TResult`, whereas `Task` need not produce a result at all. It’s
    still useful to return a `Task`, though, because it allows the calling code to
    attach its own continuations to the returned task, detect when the task has failed
    or completed, and so on. In some cases, you can think of `Task` as being like
    a `Task<void>` type, if such a thing were valid.
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 4 的 `Task` 和 `Task<TResult>` 类型都表示一个可能尚未完成的操作；`Task<TResult>` 继承自 `Task`。这两个之间的区别在于，`Task<TResult>`
    表示返回类型为 `TResult` 的操作，而 `Task` 不必产生任何结果。尽管如此，返回 `Task` 仍然很有用，因为它允许调用代码将其自己的延续附加到返回的任务上，检测任务何时失败或完成，等等。在某些情况下，你可以将
    `Task` 视为类似于 `Task<void>` 类型，如果这样的类型是有效的话。
- en: '|  |'
  id: totrans-1892
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: F# developers can be justifiably smug about the `Unit` type at this point, which
    is similar to `void` but is a real type. The disparity between `Task` and `Task<TResult>`
    can be frustrating. If you could use `void` as a type argument, you wouldn’t need
    the `Action` family of delegates either; `Action<string>` is equivalent to `Func<string,
    void>`, for example.
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，F# 开发者可以理直气壮地夸耀 `Unit` 类型，它与 `void` 类似，但是一个真正的类型。`Task` 和 `Task<TResult>`
    之间的差异可能会令人沮丧。如果你可以使用 `void` 作为类型参数，你就不需要 `Action` 家族的委托了；例如，`Action<string>` 等同于
    `Func<string, void>`。
- en: '|  |'
  id: totrans-1895
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The ability to return `void` from an async method is designed for compatibility
    with event handlers. For example, you might have a UI button click handler like
    this:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法能够返回 `void` 是为了与事件处理器兼容。例如，你可能有一个这样的 UI 按钮点击处理器：
- en: '[PRE218]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: This is an asynchronous method, but the calling code (the button `OnClick` method
    or whatever piece of framework code is raising the event) doesn’t care. It doesn’t
    need to know when you’ve finished handling the event—when you’ve loaded the stock
    price and updated the UI. It simply calls the event handler that it’s been given.
    The fact that the code generated by the compiler will end up with a state machine
    attaching a continuation to whatever is returned by `FetchPriceAsync` is an implementation
    detail.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个异步方法，但调用代码（按钮的 `OnClick` 方法或引发事件的任何框架代码片段）并不关心。它不需要知道你何时完成事件处理——何时加载股票价格并更新用户界面。它只是调用它被提供的那个事件处理器。编译器生成的代码最终会变成一个状态机，将一个延续附加到
    `FetchPriceAsync` 返回的任何内容上，这是一个实现细节。
- en: 'You can subscribe to an event with the preceding method as if it were any other
    event handler:'
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用前面的方法订阅事件，就像它是任何其他事件处理器一样：
- en: '[PRE219]'
  id: totrans-1900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: After all (and yes, I’m laboring this deliberately), it’s just a normal method
    as far as calling code is concerned. It has a `void` return type and parameters
    of type `object` and `EventArgs`, which makes it suitable as the action for an
    `EventHandler` delegate instance.
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 最终（是的，我故意这样做的），对调用代码来说，它只是一个普通的方法。它有一个`void`返回类型和类型为`object`和`EventArgs`的参数，这使得它适合作为`EventHandler`委托实例的动作。
- en: '|  |'
  id: totrans-1902
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-1903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Event subscription is pretty much the only time I’d recommend returning `void`
    from an asynchronous method. Any other time you don’t need to return a specific
    value, it’s best to declare the method to return `Task`. That way, the caller
    is able to await the operation completing, detect failures, and so on.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 事件订阅几乎是唯一推荐从异步方法返回`void`的情况。在其他任何不需要返回特定值的情况下，最好将方法声明为返回`Task`。这样，调用者就能`await`操作完成，检测失败等。
- en: '|  |'
  id: totrans-1905
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Although the return type of async methods is fairly tightly restricted, most
    other aspects are as normal: async methods can be generic, static or nonstatic,
    and specify any of the regular access modifiers. Restrictions exist on the parameters
    you can use, however.'
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管异步方法的返回类型相当严格，但大多数其他方面都很正常：异步方法可以是泛型、静态或非静态，并指定任何常规访问修饰符。然而，对你可以使用的参数存在限制。
- en: 5.3.2\. Parameters in async methods
  id: totrans-1907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2. 异步方法中的参数
- en: 'None of the parameters in an async method can use the `out` or `ref` modifiers.
    This makes sense because those modifiers are for communicating information back
    to the calling code; some of the async method may not have run by the time control
    returns to the caller, so the value of the by-reference parameter might not have
    been set. Indeed, it could get stranger than that: imagine passing a local variable
    as an argument for a `ref` parameter; the async method could end up trying to
    set that variable after the calling method had already completed. It doesn’t make
    a lot of sense to try to do this, so the compiler prohibits it. Additionally,
    pointer types can’t be used as async method parameter types.'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步方法中，没有任何参数可以使用`out`或`ref`修饰符。这很有道理，因为那些修饰符是用来将信息传回调用代码的；异步方法可能还没有运行，当控制权返回给调用者时，引用参数的值可能还没有被设置。实际上，情况可能比这还要复杂：想象一下将局部变量作为`ref`参数的参数传递；异步方法最终可能会在调用方法已经完成后尝试设置该变量。尝试这样做并没有太多意义，因此编译器禁止这样做。此外，指针类型不能用作异步方法参数类型。
- en: After you’ve declared the method, you can start writing the body and awaiting
    other asynchronous operations. Let’s look at how and where you can use await expressions.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 在你声明了方法之后，你可以开始编写方法体并`await`其他异步操作。让我们看看你可以在哪里以及如何使用`await`表达式。
- en: 5.4\. Await expressions
  id: totrans-1910
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. `await`表达式
- en: 'The whole point of declaring a method with the `async` modifier is to use await
    expressions in that method. Everything else about the method looks pretty normal:
    you can use all kinds of control flow—loops, exceptions, `using` statements, anything.
    So where can you use an await expression, and what does it do?'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 声明带有`async`修饰符的方法的整个目的是在该方法中使用`await`表达式。关于方法的其他方面看起来都很正常：你可以使用各种控制流——循环、异常、`using`语句，等等。那么，你可以在哪里使用`await`表达式，它做什么呢？
- en: 'The syntax for an await expression is simple: it’s the `await` operator followed
    by another expression that produces a value. You can await the result of a method
    call, a variable, a property. It doesn’t have to be a simple expression either.
    You can chain method calls together and await the result:'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`表达式的语法很简单：它是`await`运算符后跟另一个产生值的表达式。你可以`await`方法调用的结果、变量、属性。它不必是一个简单的表达式。你可以将方法调用链接起来并`await`其结果：'
- en: '[PRE220]'
  id: totrans-1913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'The precedence of the `await` operator is lower than that of the dot operator,
    so this code is equivalent to the following:'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`运算符的优先级低于点运算符，因此以下代码与以下代码等价：'
- en: '[PRE221]'
  id: totrans-1915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Restrictions limit which expressions you can await, though. They have to be
    *awaitable*, and that’s where the awaitable pattern comes in.
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对可以`await`的表达式有限制。它们必须是`awaitable`的，这就是`awaitable`模式的作用所在。
- en: 5.4.1\. The awaitable pattern
  id: totrans-1917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1. `awaitable`模式
- en: 'The *awaitable pattern* is used to determine types that can be used with the
    `await` operator. [Figure 5.4](kindle_split_020_split_000.html#ch05fig04) is a
    reminder that I’m talking about the second boundary from [figure 5.1](kindle_split_020_split_000.html#ch05fig01):
    how the async method interacts with another asynchronous operation. The awaitable
    pattern is a way of codifying what we mean by an *asynchronous operation.*'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: '*awaitable pattern* 用于确定可以使用 `await` 操作符的类型。[图5.4](kindle_split_020_split_000.html#ch05fig04)
    是一个提醒，我在谈论第二个边界从 [图5.1](kindle_split_020_split_000.html#ch05fig01)：异步方法如何与另一个异步操作交互。awaitable
    pattern 是一种将我们所说的异步操作进行编码的方式。'
- en: Figure 5.4\. The awaitable pattern enables async methods to asynchronously wait
    for operations to complete
  id: totrans-1919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4。awaitable pattern 允许异步方法异步等待操作完成
- en: '![](../Images/05fig04_alt.jpg)'
  id: totrans-1920
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig04_alt.jpg)'
- en: 'You might expect this to be expressed in terms of interfaces in the same way
    the compiler requires a type to implement `IDisposable` in order to support the
    `using` statement. Instead, it’s based on a pattern. Imagine that you have an
    expression of type `T` that you want to await. The compiler performs the following
    checks:'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望这将以接口的形式表达，就像编译器要求类型实现 `IDisposable` 以支持 `using` 语句一样。相反，它基于一个模式。想象一下，您有一个类型为
    `T` 的表达式，您想等待它。编译器执行以下检查：
- en: '`T` must have a parameterless `GetAwaiter()` instance method, or there must
    be an extension method accepting a single parameter of type `T`. The `GetAwaiter`
    method has to be nonvoid. The return type of the method is called the *awaiter
    type*.'
  id: totrans-1922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T` 必须有一个无参数的 `GetAwaiter()` 实例方法，或者必须有一个接受单个参数类型为 `T` 的扩展方法。`GetAwaiter` 方法不能是
    void。该方法的返回类型被称为 *awaiter type*。'
- en: 'The awaiter type must implement the `System.Runtime.INotifyCompletion` interface.
    That interface has a single method: `void OnCompleted (Action)`.'
  id: totrans-1923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: awaiter 类型必须实现 `System.Runtime.INotifyCompletion` 接口。该接口有一个方法：`void OnCompleted
    (Action)`。
- en: The awaiter type must have a readable instance property called `IsCompleted`
    of type `bool`.
  id: totrans-1924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: awaiter 类型必须有一个可读的实例属性 `IsCompleted`，其类型为 `bool`。
- en: The awaiter type must have a nongeneric parameterless instance method called
    `GetResult`.
  id: totrans-1925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: awaiter 类型必须有一个非泛型的无参数实例方法 `GetResult`。
- en: The members listed previously don’t have to be public, but they need to be accessible
    from the async method you’re trying to await the value from. (Therefore, it’s
    possible that you can await a value of a particular type from some code but not
    in all code. That’s highly unusual, though.)
  id: totrans-1926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出的成员不必是公共的，但它们需要从您尝试从其中获取值的异步方法中可访问。（因此，您可能可以从某些代码中等待特定类型的值，但不能从所有代码中等待。但这非常不寻常。）
- en: If `T` passes all of those checks, congratulations—you can await a value of
    type `T`! The compiler needs one more piece of information, though, to determine
    what the type of the await expression should be. That’s determined by the return
    type of the `GetResult` method of the awaiter type. It’s fine for it to be a `void`
    method, in which case the await expression is classified as an expression with
    no result, like an expression that calls a `void` method directly. Otherwise,
    the await expression is classified as producing a value of the same type as the
    return type of `GetResult`.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `T` 通过了所有这些检查，恭喜您——您可以从类型 `T` 等待一个值！但是，编译器还需要更多信息来确定 await 表达式的类型。这由 awaiter
    类型的 `GetResult` 方法的返回类型确定。如果它是一个 `void` 方法，那么 await 表达式被分类为无结果的表达式，就像直接调用 `void`
    方法的表达式一样。否则，await 表达式被分类为产生与 `GetResult` 返回类型相同类型的值。
- en: 'As an example, let’s consider the static `Task.Yield()` method. Unlike most
    other methods on `Task`, the `Yield()` method doesn’t return a task itself; it
    returns a `YieldAwaitable`. Here’s a simplified version of the types involved:'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑静态 `Task.Yield()` 方法。与其他大多数 `Task` 上的方法不同，`Yield()` 方法本身不返回任务；它返回一个
    `YieldAwaitable`。以下是涉及类型的简化版本：
- en: '[PRE222]'
  id: totrans-1929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'As you can see, `YieldAwaitable` follows the awaitable pattern described previously.
    Therefore, this is valid:'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`YieldAwaitable` 遵循之前描述的 awaitable pattern。因此，这是有效的：
- en: '[PRE223]'
  id: totrans-1931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '***1* Valid**'
  id: totrans-1932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 有效**'
- en: 'But the following is invalid, because it tries to use the result of awaiting
    a `YieldAwaitable`:'
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下是不合法的，因为它试图使用等待 `YieldAwaitable` 的结果：
- en: '[PRE224]'
  id: totrans-1934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '***1* Invalid; this await expression doesn’t produce a value.**'
  id: totrans-1935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效；这个 await 表达式不会产生值。**'
- en: 'The middle line of `InvalidPrintYieldPrint` is invalid for exactly the same
    reason that it would be invalid to write this:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvalidPrintYieldPrint` 的中间行无效，原因与直接编写此代码无效的原因完全相同：'
- en: '[PRE225]'
  id: totrans-1937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: No result is produced, so you can’t assign it to a variable.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 没有产生任何结果，因此你不能将其分配给一个变量。
- en: Unsurprisingly, the awaiter type for `Task` has a `GetResult` method with a
    `void` return type, whereas the awaiter type for `Task<TResult>` has a `GetResult`
    method returning `TResult`.
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，`Task`的awaiter类型有一个返回`void`类型的`GetResult`方法，而`Task<TResult>`的awaiter类型有一个返回`TResult`的`GetResult`方法。
- en: '|  |'
  id: totrans-1940
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Historical importance of extension methods**'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展方法的历史重要性**'
- en: The fact that `GetAwaiter` can be an extension method is of more historical
    than contemporary importance. C# 5 was released in the same time frame as .NET
    4.5, which introduced the `GetAwaiter` methods into `Task` and `Task<TResult>`.
    If `GetAwaiter` had to be a genuine instance method, that would’ve stranded developers
    who were tied to .NET 4.0\. But with support for extension methods, `Task` and
    `Task<TResult>` could be async/await-enabled by using a NuGet package to provide
    those extension methods separately. This also meant that the community could test
    prereleases of the C# 5 compiler without testing prereleases of .NET 4.5.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAwaiter`可以是一个扩展方法这一事实，其历史重要性大于当代重要性。C# 5与.NET 4.5在同一时间段发布，而.NET 4.5引入了`GetAwaiter`方法到`Task`和`Task<TResult>`中。如果`GetAwaiter`必须是一个真正的实例方法，那么这将会使那些依赖于.NET
    4.0的开发者陷入困境。但是，由于扩展方法的支持，`Task`和`Task<TResult>`可以通过使用NuGet包来分别提供这些扩展方法，从而实现async/await功能。这也意味着社区可以在不测试.NET
    4.5预发布版本的情况下测试C# 5编译器的预发布版本。'
- en: In code targeting modern frameworks in which all the relevant `GetAwaiter` methods
    are already present, you’ll rarely need to use the ability to make an existing
    type awaitable via extension methods.
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 在针对现代框架的代码中，其中所有相关的`GetAwaiter`方法都已经存在，你很少需要使用通过扩展方法使现有类型可await的能力。
- en: '|  |'
  id: totrans-1944
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll see more details about exactly how the members in the awaitable pattern
    are used in [section 5.6](kindle_split_020_split_000.html#ch05lev1sec6), when
    you consider the execution flow of asynchronous methods. You’re not quite done
    with await expressions, though; a few restrictions exist.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第5.6节](kindle_split_020_split_000.html#ch05lev1sec6)中看到更多关于awaitable模式中成员如何使用的详细信息，当你考虑异步方法的执行流程时。尽管如此，你对await表达式的工作还没有完成；存在一些限制。
- en: 5.4.2\. Restrictions on await expressions
  id: totrans-1946
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. await表达式的限制
- en: Like `yield return`, restrictions limit where you can use await expressions.
    The most obvious restriction is that you can use them only in async methods and
    async anonymous functions (which you’ll look at in [section 5.7](kindle_split_020_split_000.html#ch05lev1sec7)).
    Even within async methods, you can’t use the `await` operator within an anonymous
    function unless that’s async, too.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 与`yield return`一样，限制限制了你可以使用await表达式的位置。最明显的限制是，你只能在异步方法和异步匿名函数（你将在[第5.7节](kindle_split_020_split_000.html#ch05lev1sec7)中看到）中使用它们。即使在异步方法中，你也不能在匿名函数中使用`await`运算符，除非那个匿名函数也是异步的。
- en: The `await` operator also isn’t allowed within an unsafe context. That doesn’t
    mean you can’t use unsafe code within an async method; you just can’t use the
    `await` operator within that part. The following listing shows a contrived example
    in which a pointer is used to iterate over the characters in a string to find
    the total of the UTF-16 code units in that string. It doesn’t do anything truly
    useful, but it demonstrates the use of an unsafe context within an async method.
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`运算符也不允许在不安全上下文中使用。这并不意味着你无法在异步方法中使用不安全代码；只是你不能在那个部分使用`await`运算符。以下列表显示了一个虚构的例子，其中使用指针遍历字符串中的字符以找到该字符串中UTF-16代码单元的总数。它并没有做任何真正有用的事情，但它演示了在异步方法中使用不安全上下文。'
- en: Listing 5.3\. Using unsafe code in an async method
  id: totrans-1949
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. 在异步方法中使用不安全代码
- en: '[PRE226]'
  id: totrans-1950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '***1* It’s fine to have an unsafe context in an async method.**'
  id: totrans-1951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在异步方法中有一个不安全上下文是可以的。**'
- en: '***2* But, the await expression can’t be inside it.**'
  id: totrans-1952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 但是，await表达式不能在其中使用。**'
- en: You also can’t use the `await` operator within a lock. If you ever find yourself
    wanting to hold a lock while an asynchronous operation completes, you should redesign
    your code. Don’t work around the compiler restriction by calling `Monitor.TryEnter`
    and `Monitor.Exit` manually with a `try`/`finally` block; change your code so
    you don’t need the lock during the operation. If this is really, really awkward
    in your situation, consider using `SemaphoreSlim` instead, with its `WaitAsync`
    method.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不能在 `lock` 中使用 `await` 操作符。如果你发现自己想在异步操作完成时保持锁定，你应该重新设计你的代码。不要通过手动调用 `Monitor.TryEnter`
    和 `Monitor.Exit` 并使用 `try`/`finally` 块来规避编译器的限制；改变你的代码，以便在操作期间不需要锁定。如果这种情况真的很尴尬，考虑使用
    `SemaphoreSlim`，它具有 `WaitAsync` 方法。
- en: The monitor used by a `lock` statement can be released only by the same thread
    that originally acquired it, which goes against the distinct possibility that
    the thread executing the code before an await expression will be different from
    the one executing the code after it. Even if the same thread is used (for example,
    because you’re in a GUI synchronization context), some other code may well have
    executed on the same thread between the start and end of the asynchronous operation,
    and that other code would’ve been able to enter a `lock` statement for the same
    monitor, which almost certainly isn’t what you intended. Basically, `lock` statements
    and asynchrony don’t go well together.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock` 语句使用的监视器只能由最初获取它的同一线程释放，这与在 `await` 表达式之前执行代码的线程将不同于之后执行代码的线程的明确可能性相矛盾。即使使用的是同一线程（例如，因为你处于
    GUI 同步上下文），在异步操作的开始和结束之间，同一线程上可能已经执行了其他代码，并且那其他代码能够进入同一监视器的 `lock` 语句，这几乎肯定不是你想要的。基本上，`lock`
    语句和异步操作不太相容。'
- en: 'There’s one final set of contexts in which the `await` operator was invalid
    in C# 5 but is valid from C# 6 onward:'
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，`await` 操作符在 C# 5 中无效，但从 C# 6 开始是有效的：
- en: Any `try` block with a `catch` block
  id: totrans-1956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何带有 `catch` 块的 `try` 块
- en: Any `catch` block
  id: totrans-1957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 `catch` 块
- en: Any `finally` block
  id: totrans-1958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 `finally` 块
- en: It’s always been okay to use the `await` operator in a `try` block that has
    only a `finally` block, which means it’s always been okay to use `await` in a
    `using` statement. The C# design team didn’t figure out how to safely and reliably
    include await expressions in the contexts listed previously before C# 5 shipped.
    This was occasionally inconvenient, and the team worked out how to build the appropriate
    state machine while implementing C# 6, so the restriction is lifted there.
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 在只有一个 `finally` 块的 `try` 块中使用 `await` 操作符一直是可以的，这意味着在 `using` 语句中使用 `await`
    一直是可以的。在 C# 5 发布之前，C# 设计团队没有想出如何在之前列出的上下文中安全可靠地包含 `await` 表达式。这偶尔会不方便，团队在实现 C#
    6 时找到了构建适当状态机的方法，因此那里的限制被取消了。
- en: You now know how to declare an async method and how the `await` operator can
    be used within it. What about when you’ve completed your work? Let’s look at how
    values are returned back to the calling code.
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了如何声明一个异步方法以及如何在其中使用 `await` 操作符。当你完成工作后怎么办？让我们看看如何将值返回到调用代码。
- en: 5.5\. Wrapping of return values
  id: totrans-1961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 返回值的包装
- en: We’ve looked at how to declare the boundary between the calling code and the
    async method and how to wait for any asynchronous operations within the async
    method. Now let’s look at how return statements are used to implement that first
    boundary in terms of returning a value to the calling code; see [figure 5.5](kindle_split_020_split_000.html#ch05fig05).
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何声明调用代码和异步方法之间的边界以及如何在异步方法内等待任何异步操作。现在让我们看看如何使用返回语句来实现将值返回到调用代码的第一个边界；参见[图
    5.5](kindle_split_020_split_000.html#ch05fig05)。
- en: Figure 5.5\. Returning a result from an async method to its caller
  id: totrans-1963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 从异步方法返回结果到其调用者
- en: '![](../Images/05fig05_alt.jpg)'
  id: totrans-1964
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig05_alt.jpg)'
- en: 'You’ve already seen an example that returned data, but let’s look at it again,
    this time focusing on the return aspect alone. Here’s the relevant part of [listing
    5.2](kindle_split_020_split_000.html#ch05ex02):'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一个返回数据的例子，但让我们再次看看它，这次只关注返回方面。这里是[列表 5.2](kindle_split_020_split_000.html#ch05ex02)的相关部分：
- en: '[PRE227]'
  id: totrans-1966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'You can see that the type of `length` is `int`, but the return type of the
    method is `Task<int>`. The generated code takes care of the wrapping for you,
    so the caller gets a `Task<int>`, which will eventually have the value returned
    from the method when it completes. A method returning a nongeneric `Task` is like
    a normal `void` method: it doesn’t need a return statement at all, and any return
    statements it does have must be simply `return` rather than trying to specify
    a value. In either case, the task will also propagate any exception thrown within
    the async method. (You’ll look at exceptions in more detail in [section 5.6.5](kindle_split_020_split_000.html#ch05lev2sec14).)'
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`length`的类型是`int`，但方法的返回类型是`Task<int>`。生成的代码会为你处理包装，所以调用者会得到一个`Task<int>`，当它完成时将包含方法返回的值。返回非泛型`Task`的方法就像一个普通的`void`方法：它根本不需要返回语句，并且任何返回语句都必须是简单的`return`，而不是尝试指定一个值。在任何情况下，任务也会传播在异步方法中抛出的任何异常。（你将在[第5.6.5节](kindle_split_020_split_000.html#ch05lev2sec14)中更详细地了解异常。）
- en: Hopefully, by now you should have a good intuition about why this wrapping is
    necessary; the method will almost certainly return to the caller before it hits
    the `return` statement, and it has to propagate the information to that caller
    somehow. A `Task<TResult>` (often known as a *future* in computer science) is
    the promise of a value—or an exception—at a later time.
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在，你应该对为什么这种包装是必要的有一个很好的直觉；方法几乎肯定会在到达`return`语句之前返回给调用者，并且它必须以某种方式将信息传播给那个调用者。`Task<TResult>`（在计算机科学中通常被称为*future*）是在未来某个时间点返回一个值或异常的承诺。
- en: As with normal execution flow, if the `return` statement occurs within the scope
    of a `try` block that has an associated `finally` block (including when all of
    this happens because of a `using` statement), the expression used to compute the
    return value is evaluated immediately, but it doesn’t become the result of the
    task until everything has been cleaned up. If the `finally` block throws an exception,
    you don’t get a task that both succeeds and fails; the whole thing will fail.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 与正常的执行流程一样，如果`return`语句出现在与一个相关联的`finally`块（包括所有这些因为`using`语句而发生）的作用域内，用于计算返回值的表达式将立即被评估，但它不会成为任务的结果，直到所有清理工作都完成。如果`finally`块抛出异常，你不会得到一个既成功又失败的任务；整个操作将失败。
- en: 'To reiterate a point I made earlier, it’s the combination of automatic wrapping
    and unwrapping that makes the async feature work so well with composition; async
    methods can consume the results of async methods easily, so you can build up complex
    systems from lots of small blocks. You can think of this as being a bit like LINQ:
    you write operations on each element of a sequence in LINQ, and the wrapping and
    unwrapping means you can apply those operations to sequences and get sequences
    back. In an async world, you rarely need to explicitly handle a task; instead,
    you `await` the task to consume it, and produce a result task automatically as
    part of the mechanism of the async method. Now that you know what an asynchronous
    method looks like, it’s easier to give examples to demonstrate the execution flow.'
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重申我之前提到的一个观点，正是自动包装和解除包装的组合使得异步功能与组合工作得如此之好；异步方法可以轻松消费异步方法的输出，因此你可以从许多小块构建复杂的系统。你可以将这看作是类似于LINQ：你在LINQ中对序列的每个元素执行操作，包装和解除包装意味着你可以将这些操作应用于序列，并返回序列。在异步世界中，你很少需要显式处理任务；相反，你`await`任务来消费它，并且作为异步方法机制的一部分自动生成一个结果任务。现在你了解了异步方法的样子，更容易给出示例来展示执行流程。
- en: 5.6\. Asynchronous method flow
  id: totrans-1971
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6. 异步方法流程
- en: 'You can think about async/await at multiple levels:'
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从多个层面来思考async/await：
- en: You can simply expect that awaiting will do what you want without defining exactly
    what that means.
  id: totrans-1973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以简单地期望await会做你想做的事情，而不必精确地定义这意味着什么。
- en: You can reason about how the code will execute, in terms of what happens when
    and in which thread, but without understanding how that’s achieved.
  id: totrans-1974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以就代码将如何执行进行推理，从何时以及在哪条线程上发生什么的角度来看，但无需理解它是如何实现的。
- en: You can dig deeply into the infrastructure that makes all of this happen.
  id: totrans-1975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以深入了解使这一切发生的基础设施。
- en: So far, we’ve mostly been thinking at the first level, dipping down to the second
    occasionally. This section focuses on the second level, effectively looking at
    what the language promises. We’ll leave the third bullet to the next chapter,
    where you’ll see what the compiler is doing under the covers. (Even then, you
    could always go further; this book doesn’t talk about anything below the IL level.
    We don’t get into the operating system or hardware support for asynchrony and
    threading.)
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要是在第一层思考，偶尔会深入到第二层。本节重点讨论第二层，实际上是在查看语言所承诺的内容。我们将把第三点留到下一章，在那里你会看到编译器在幕后做了什么。（即使那样，你仍然可以更进一步；这本书不讨论低于IL层的内容。我们不会涉及操作系统或对异步和线程的硬件支持。）
- en: For the vast majority of the time when you’re developing, it’s fine to switch
    between the first two levels, depending on your context. Unless I’m writing code
    that’s coordinating multiple operations, I rarely need to even think at the second
    level of detail. Most of the time, I’m happy to just let things work. What’s important
    is that you can think about the details when you need to.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开发的大部分时间里，根据你的上下文在第一和第二层之间切换是完全可以的。除非我正在编写需要协调多个操作的代码，否则我很少需要深入到第二层细节。大多数时候，我只是让事情按自己的方式运行。重要的是，当你需要时，你可以思考细节。
- en: 5.6.1\. What is awaited and when?
  id: totrans-1978
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1. 什么是await以及何时使用？
- en: 'Let’s start by simplifying things a bit. Sometimes `await` is used with the
    result of a chained method call or occasionally a property, like this:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先简化一下事情。有时`await`会与链式方法调用的结果或偶尔的属性一起使用，如下所示：
- en: '[PRE228]'
  id: totrans-1980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'This makes it look as if `await` can modify the meaning of the whole expression.
    In reality, `await` always operates on only a single value. The preceding line
    is equivalent to this:'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`await`似乎可以改变整个表达式的意义。实际上，`await`始终只作用于单个值。前面的行等价于以下行：
- en: '[PRE229]'
  id: totrans-1982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Similarly, the result of an await expression can be used as a method argument
    or within another expression. Again, it helps if you can mentally separate out
    the `await`-specific part from everything else.
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，await表达式的结果可以用作方法参数或另一个表达式的一部分。再次强调，如果你能从其他所有内容中分离出`await`特定的部分，那就更好了。
- en: 'Imagine you have two methods, `GetHourlyRateAsync()` and `GetHoursWorkedAsync()`,
    returning a `Task<decimal>` and a `Task<int>`, respectively. You might have this
    complicated statement:'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个方法，`GetHourlyRateAsync()`和`GetHoursWorkedAsync()`，分别返回`Task<decimal>`和`Task<int>`。你可能会有这样一个复杂的语句：
- en: '[PRE230]'
  id: totrans-1985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'The normal rules of C# expression evaluation apply, and the left operand of
    the `*` operator has to be completely evaluated before the right operand is evaluated,
    so the preceding statement can be expanded as follows:'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: C#表达式评估的正常规则适用，并且`*`运算符的左操作数必须在右操作数评估之前完全评估，因此前面的语句可以展开如下：
- en: '[PRE231]'
  id: totrans-1987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'How you write the code is a different matter. If you find the single statement
    version easier to read, that’s fine; if you want to expand it all out, you’ll
    end up with more code, but it may be simpler to understand and debug. You could
    decide to use a third form that looks similar but isn’t quite the same:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写代码的方式是另一回事。如果你发现单行版本更容易阅读，那很好；如果你想全部展开，你将得到更多的代码，但这可能更容易理解和调试。你可以决定使用一种看起来相似但实际上并不完全相同的形式：
- en: '[PRE232]'
  id: totrans-1989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: I find that this is the most readable form, and it has potential performance
    benefits, too. You’ll come back to this example in [section 5.10.2](kindle_split_020_split_000.html#ch05lev2sec18).
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这是最易读的形式，并且它也有潜在的性能优势。你将在[第5.10.2节](kindle_split_020_split_000.html#ch05lev2sec18)中再次回到这个例子。
- en: The key takeaway from this section is that you need to be able to work out what’s
    being awaited and when. In this case, the tasks returned from `GetHourlyRateAsync`
    and `GetHoursWorkedAsync` are being awaited. In every case, they’re being awaited
    before the call to `AddPayment` is executed, which makes sense, because you need
    the intermediate results so you can multiply them together and pass the result
    of that multiplication as an argument. If this were using synchronous calls, all
    of this would be obvious; my aim is to demystify the awaiting part. Now that you
    know how to simplify complex code into the value you’re awaiting and when you’re
    awaiting it, you can move on to what happens when you’re in the awaiting part
    itself.
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键要点是您需要能够弄清楚正在等待什么以及何时等待。在这种情况下，从`GetHourlyRateAsync`和`GetHoursWorkedAsync`返回的任务正在被等待。在所有情况下，它们都是在执行`AddPayment`调用之前被等待的，这是有意义的，因为您需要中间结果，以便可以将它们相乘并将乘积的结果作为参数传递。如果这是使用同步调用，所有这些都会很明显；我的目标是揭开等待部分的神秘面纱。现在您知道了如何将复杂代码简化为等待的值以及何时等待它，您可以继续了解在等待部分本身发生的事情。
- en: 5.6.2\. Evaluation of await expressions
  id: totrans-1992
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2. `await`表达式的评估
- en: 'When execution reaches the await expression, you have two possibilities: either
    the asynchronous operation you’re awaiting has already completed or it hasn’t.
    If the operation has already completed, the execution flow is simple: it keeps
    going. If the operation failed and it captured an exception to represent that
    failure, the exception is thrown. Otherwise, any result from the operation is
    obtained (for example, extracting the `string` from a `Task<string>`) and you
    move on to the next part of the program. All of this is done without any thread
    context switching or attaching continuations to anything.'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行到达`await`表达式时，你有两种可能性：要么你等待的异步操作已经完成，要么还没有。如果操作已经完成，执行流程很简单：它继续进行。如果操作失败并捕获异常来表示该失败，则抛出异常。否则，从操作中获取任何结果（例如，从`Task<string>`中提取`string`）并继续程序的下一部分。所有这些都是在没有任何线程上下文切换或将延续附加到任何东西的情况下完成的。
- en: 'In the more interesting scenario, the asynchronous operation is still ongoing.
    In this case, the method waits asynchronously for the operation to complete and
    then continues in an appropriate context. This asynchronous waiting really means
    the method isn’t executing at all. A continuation is attached to the asynchronous
    operation, and the method returns. The async infrastructure makes sure that the
    continuation executes on the right thread: typically, either a thread-pool thread
    (where it doesn’t matter which thread is used) or the UI thread where that makes
    sense. This depends on the synchronization context (discussed in [section 5.2.2](kindle_split_020_split_000.html#ch05lev2sec4))
    and can also be controlled using `Task.ConfigureAwait`, which we’ll talk about
    in [section 5.10.1](kindle_split_020_split_000.html#ch05lev2sec17).'
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 在更有趣的场景中，异步操作仍在进行中。在这种情况下，方法异步等待操作完成，然后在适当的环境中继续。这种异步等待实际上意味着方法根本就没有执行。将延续附加到异步操作上，方法返回。异步基础设施确保延续在正确的线程上执行：通常是线程池线程（在这种情况下，使用哪个线程无关紧要）或UI线程，这在有意义的场景中。这取决于同步上下文（在第5.2.2节中讨论），也可以使用`Task.ConfigureAwait`来控制，我们将在第5.10.1节中讨论。
- en: '|  |'
  id: totrans-1995
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Returning vs. completing**'
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回与完成**'
- en: Possibly the hardest part of describing asynchronous behavior is talking about
    when the method *returns* (either to the original caller or to whatever called
    a continuation) and when the method *completes*. Unlike most methods, an asynchronous
    method can return multiple times—effectively, when it has no more work it can
    do for the moment.
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 描述异步行为最难的部分可能是谈论方法何时*返回*（无论是返回给原始调用者还是返回给调用延续的任何东西）以及何时*完成*。与大多数方法不同，异步方法可以多次返回——实际上，当它暂时没有更多工作可做时。
- en: To return to our earlier pizza delivery analogy, if you have an `EatPizzaAsync`
    method that involves calling the pizza company to place an order, meeting the
    delivery person, waiting for the pizza to cool down a bit, and then finally eating
    it, the method might return after each of the first three parts, but it won’t
    complete until the pizza is eaten.
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的比萨饼配送类比，如果你有一个`EatPizzaAsync`方法，它涉及到调用比萨饼公司下单、遇到配送员、等待比萨饼稍微冷却一下，然后最后吃掉它，该方法可能会在第一部分的每个部分之后返回，但只有在比萨饼被吃掉之后才会完成。
- en: '|  |'
  id: totrans-1999
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: From the developer’s point of view, this feels like the method is paused while
    the asynchronous operation completes. The compiler makes sure that all the local
    variables used within the method have the same values as they did before the continuation,
    as it does with iterator blocks.
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，这感觉就像方法在异步操作完成时被暂停了。编译器确保方法内部使用的所有局部变量在继续之前与它们具有相同的值，就像迭代器块一样。
- en: Let’s look at an example of the two cases with a small console application that
    uses a single asynchronous method awaiting two tasks. `Task.FromResult` always
    returns a completed task, whereas `Task.Delay` returns a task that completes after
    the specified delay.
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小型的控制台应用程序的例子来看这两个情况，该应用程序使用单个异步方法等待两个任务。`Task.FromResult`总是返回一个已完成的任务，而`Task.Delay`返回一个在指定延迟后完成的任务。
- en: Listing 5.4\. Awaiting completed and noncompleted tasks
  id: totrans-2002
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4\. 等待完成和未完成的任务
- en: '[PRE233]'
  id: totrans-2003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '***1* Calls the async method**'
  id: totrans-2004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用异步方法**'
- en: '***2* Blocks until the task completes**'
  id: totrans-2005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待任务完成**'
- en: '***3* Awaits a completed task**'
  id: totrans-2006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 等待一个完成的任务**'
- en: '***4* Awaits a noncompleted task**'
  id: totrans-2007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 等待一个未完成的任务**'
- en: 'The output from [listing 5.4](kindle_split_020_split_000.html#ch05ex04) is
    as follows:'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.4](kindle_split_020_split_000.html#ch05ex04)的输出如下：'
- en: '[PRE234]'
  id: totrans-2009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'The important aspects of the ordering are as follows:'
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 排序的重要方面如下：
- en: The async method doesn’t return when awaiting the completed task; the method
    keeps executing synchronously. That’s why you see the first two lines with nothing
    between.
  id: totrans-2011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当await完成的任务时，异步方法不会返回；方法继续以同步方式执行。这就是为什么你会看到前两行之间没有任何内容。
- en: The async method does return when awaiting the delay task. That’s why the third
    line is `Method returned`, printed in the `Main` method. The async method can
    tell that the operation it’s waiting for (the delay task) hasn’t completed yet,
    so it returns to avoid blocking.
  id: totrans-2012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当await延迟任务时，异步方法确实会返回。这就是为什么在`Main`方法中打印出第三行`Method returned`。异步方法可以知道它等待的操作（延迟任务）尚未完成，因此返回以避免阻塞。
- en: The task returned from the async method completes only when the method completes.
    That’s why `Task completed` is printed after `After second await`.
  id: totrans-2013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从异步方法返回的任务只有在方法完成时才会完成。这就是为什么在`After second await`之后打印出`Task completed`。
- en: I’ve attempted to capture the await expression flow in [figure 5.6](kindle_split_020_split_000.html#ch05fig06),
    although classic flowcharts weren’t really designed with asynchronous behavior
    in mind.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试在[图5.6](kindle_split_020_split_000.html#ch05fig06)中捕捉await表达式的流程，尽管经典的流程图并不是真正考虑到异步行为。
- en: Figure 5.6\. User-visible model of await handling
  id: totrans-2015
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. await处理的用户可见模型
- en: '![](../Images/05fig06.jpg)'
  id: totrans-2016
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig06.jpg)'
- en: You could think of the dotted line as being another line coming into the top
    of the flowchart as an alternative. Note that I’m assuming the target of the await
    expression has a result. If you’re awaiting a plain `Task` or something similar,
    *fetch result* really means check that the operation completed successfully.
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将虚线看作是流向流程图顶部的另一条线作为替代。请注意，我假设await表达式的目标是有一个结果。如果你正在等待一个普通的`Task`或类似的东西，*获取结果*实际上意味着检查操作是否成功完成。
- en: 'It’s worth stopping to think briefly about what it means to return from an
    asynchronous method. Again, two possibilities exist:'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 值得停下来简要思考一下从异步方法返回意味着什么。再次强调，有两种可能性存在：
- en: This is the first await expression you’ve had to wait for, so you still have
    the original caller somewhere in your stack. (Remember that until you really need
    to wait, the method executes synchronously.)
  id: totrans-2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是你必须等待的第一个await表达式，所以你的堆栈中仍然有原始调用者。（记住，在你真正需要等待之前，方法以同步方式执行。）
- en: You’ve already awaited something else that hadn’t already completed, so you’re
    in a continuation that has been called by *something*. Your call stack will almost
    certainly have changed significantly from the one you’d have seen when you first
    entered the method.
  id: totrans-2020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经等待了其他尚未完成的事情，所以你在一个由*某物*调用的继续中。你的调用堆栈几乎肯定会与你在第一次进入方法时看到的堆栈有显著不同。
- en: In the first case, you’ll usually end up returning a `Task` or `Task<TResult>`
    to the caller. Obviously, you don’t have the result of the method yet; even if
    there’s no value to return as such, you don’t know whether the method will complete
    without exceptions. Because of this, the task you’ll be returning has to be a
    noncompleted one.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你通常会返回一个`Task`或`Task<TResult>`给调用者。显然，你还没有方法的结果；即使没有要返回的值，你也不知道方法是否会无异常地完成。因此，你将返回的任务必须是一个未完成的任务。
- en: In the latter case, the something calling you back depends on your context.
    For example, in a Windows Forms UI, if you started your async method on the UI
    thread and didn’t deliberately switch away from it, the whole method would execute
    on the UI thread. For the first part of the method, you’ll be in some event handler
    or other—whatever kicked off the async method. Later, however, you’d be called
    back by the Windows Forms internal machinery (usually known as the *message pump*)
    pretty directly, as if you were using `Control.BeginInvoke(continuation)`. Here,
    the calling code—whether it’s the Windows Forms message pump, part of the thread-pool
    machinery, or something else—doesn’t care about your task.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种情况下，调用你的东西取决于你的上下文。例如，在一个Windows Forms UI中，如果你在UI线程上启动了你的异步方法并且没有故意切换到其他线程，整个方法就会在UI线程上执行。在方法的前一部分，你会在某个事件处理器或其他地方——无论是什么触发了异步方法。然而，稍后，你将直接由Windows
    Forms内部机制（通常称为*消息泵*）调用，就像你使用`Control.BeginInvoke(continuation)`一样。在这里，调用代码——无论是Windows
    Forms消息泵、线程池机制的一部分还是其他东西——都不关心你的任务。
- en: As a reminder, until you hit the first truly asynchronous `await` expression,
    the method executes entirely synchronously. Calling an asynchronous method *isn’t*
    like firing up a new task in a separate thread, and it’s up to you to make sure
    that you always write async methods so they return quickly. Admittedly, it depends
    on the context in which you’re writing code, but you should generally avoid performing
    long-running blocking work in an async method. Separate it out into another method
    that you can create a `Task` for.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，直到你遇到第一个真正的异步`await`表达式，方法完全以同步方式执行。调用异步方法*并不*像在单独的线程中启动一个新任务，确保你始终编写快速返回的异步方法是你的责任。诚然，这取决于你编写代码的上下文，但你应该通常避免在异步方法中执行长时间运行的阻塞工作。将其分离到另一个方法中，你可以为它创建一个`Task`。
- en: 'I’d like to briefly revisit the case where the value you’re awaiting is already
    complete. You might be wondering why an operation that completes immediately would
    be represented with asynchrony in the first place. It’s a little bit like calling
    the `Count()` method on a sequence in LINQ: in the general case, you may need
    to iterate over every item in the sequence, but in some situations (such as when
    the sequence turns out to be a `List<T>`), an easy optimization is available.
    It’s useful to have a single abstraction that covers both scenarios, but without
    paying an execution-time price.'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 我想简要回顾一下你等待的值已经完成的情况。你可能想知道为什么一个立即完成的操作最初要以异步方式表示。这有点像在LINQ中对序列调用`Count()`方法：在一般情况下，你可能需要遍历序列中的每个项目，但在某些情况下（例如，当序列最终是一个`List<T>`时），可以有一个简单的优化。有一个单一的抽象来覆盖这两种情况是有用的，但不需要支付执行时间的代价。
- en: As a real-world example in the asynchronous API case, consider reading asynchronously
    from a stream associated with a file on disk. All the data you want to read may
    already have been fetched from disk into memory, perhaps as part of previous `ReadAsync`
    call request, so it makes sense to use it immediately without going through all
    the other async machinery. As another example, you may have a cache within your
    architecture; that can be transparent if you have an asynchronous operation that
    fetches a value either from the in-memory cache (returning a completed task) or
    hits storage (returning a noncompleted task that’ll complete when the storage
    call completes). Now that you know the basics of the flow, you can see where the
    awaitable pattern fits into the jigsaw.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 作为异步API案例中的现实世界示例，考虑从与磁盘上的文件关联的流中异步读取。你可能已经从磁盘中检索了你想要读取的所有数据并将其加载到内存中，可能是作为之前的`ReadAsync`调用请求的一部分，因此立即使用它而不需要通过所有其他异步机制是有意义的。作为另一个例子，你可能在你的架构中有一个缓存；如果你有一个异步操作，它可以从内存缓存（返回一个完成的任务）或击中存储（返回一个非完成的任务，当存储调用完成时完成），那么这将是透明的。现在你了解了流程的基本知识，你可以看到可等待模式如何融入拼图。
- en: 5.6.3\. The use of awaitable pattern members
  id: totrans-2026
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.3. 可等待模式成员的使用
- en: In [section 5.4.1](kindle_split_020_split_000.html#ch05lev2sec8), I described
    the *awaitable pattern* that a type has to implement in order for you to be able
    to await an expression of that type. You can now map the different bits of the
    pattern onto the behavior you’re trying to achieve. [Figure 5.7](kindle_split_020_split_000.html#ch05fig07)
    is the same as [figure 5.6](kindle_split_020_split_000.html#ch05fig06) but expanded
    a little and reworded to use the awaitable pattern instead of general descriptions.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5.4.1 节](kindle_split_020_split_000.html#ch05lev2sec8)中，我描述了类型必须实现的可等待模式，以便你能够等待该类型的表达式。你现在可以将模式的各个部分映射到你试图实现的行为。![图
    5.7](kindle_split_020_split_000.html#ch05fig07)与[图 5.6](kindle_split_020_split_000.html#ch05fig06)相同，但略有扩展并重新措辞，以使用可等待模式而不是一般描述。
- en: Figure 5.7\. Await handling via the awaitable pattern
  id: totrans-2028
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.7\. 通过可等待模式处理 await
- en: '![](../Images/05fig07_alt.jpg)'
  id: totrans-2029
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig07_alt.jpg)'
- en: When it’s written like this, you might be wondering what all the fuss is about;
    why is it worth having language support at all? Attaching a continuation is more
    complex than you might imagine, though. In simple cases, when the control flow
    is entirely linear (do some work, await something, do some more work, await something
    else), it’s pretty easy to imagine what the continuation might look like as a
    lambda expression, even if it wouldn’t be pleasant. As soon as the code contains
    loops or conditions, however, and you want to keep the code within one method,
    life becomes much more complicated. It’s here that the benefits of async/await
    really kick in. Although you could argue that the compiler is merely applying
    syntactic sugar, there’s an enormous difference in readability between manually
    creating the continuations and getting the compiler to do so for you.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 当它写成这样时，你可能想知道所有这些喧嚣是什么意思；为什么语言支持本身就有价值？尽管附加一个延续可能比你想象的要复杂，但。在简单的情况下，当控制流完全线性（做一些工作，等待某事，做更多的工作，等待其他事情）时，很容易想象延续可能看起来像
    lambda 表达式，即使它可能并不愉快。然而，一旦代码包含循环或条件，并且你希望将代码保持在单个方法中，生活就会变得复杂得多。正是在这里，async/await
    的好处真正显现出来。尽管你可以争论编译器只是在应用语法糖，但手动创建延续和让编译器为你这样做之间的可读性差异是巨大的。
- en: So far, I’ve described the happy path where all the values we await complete
    successfully. What happens on failure?
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我描述了所有我们等待的值都成功完成的愉快路径。失败会发生什么呢？
- en: 5.6.4\. Exception unwrapping
  id: totrans-2032
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.4\. 异常展开
- en: The idiomatic way of representing failures in .NET is via exceptions. Like returning
    a value to the caller, exception handling requires extra support from the language.
    When you await an asynchronous operation that’s failed, it may have failed a long
    time ago on a completely different thread. The regular synchronous way of propagating
    exceptions up the stack doesn’t occur naturally. Instead, the async/await infrastructure
    takes steps to make the experience of handling asynchronous failures as similar
    as possible to synchronous failures. If you think of failure as another kind of
    result, it makes sense that exceptions and return values are handled similarly.
    You’ll look at how exceptions are propagated out of an asynchronous method in
    [section 5.6.5](kindle_split_020_split_000.html#ch05lev2sec14), but before that,
    you’ll see what happens when you await a failed operation.
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，表示失败的传统方式是通过异常。就像向调用者返回一个值一样，异常处理需要语言提供额外的支持。当你等待一个失败的异步操作时，它可能很久以前在完全不同的线程上失败了。常规的同步方式向上传播异常并不自然。相反，async/await
    基础设施采取了一些步骤，使处理异步失败的经历尽可能类似于同步失败。如果你认为失败是另一种结果，那么异常和返回值以类似方式处理是有意义的。你将在[第 5.6.5
    节](kindle_split_020_split_000.html#ch05lev2sec14)中看到异常是如何从一个异步方法中传播出来的，但在那之前，你将看到当你等待一个失败的操作时会发生什么。
- en: In the same way that the `GetResult()` method of an awaiter is meant to fetch
    the return value if there is one, it’s also responsible for propagating any exceptions
    from the asynchronous operation back to the method. This isn’t *quite* as simple
    as it sounds, because in an asynchronous world, a single `Task` can represent
    multiple operations, leading to multiple failures. Although other awaitable pattern
    implementations are available, it’s worth considering `Task` and `Task<TResult>`
    specifically, as they’re the types you’re likely to be awaiting for the vast majority
    of the time.
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 就像等待器的 `GetResult()` 方法旨在获取返回值（如果有的话）一样，它也负责将异步操作中发生的任何异常传播回方法。这并不像听起来那么简单，因为在异步世界中，一个
    `Task` 可以代表多个操作，从而导致多个失败。尽管有其他可等待模式实现，但具体考虑 `Task` 和 `Task<TResult>` 是有价值的，因为它们是你可能要等待的大多数时间所使用的类型。
- en: '`Task` and `Task<TResult>` indicate failures in multiple ways:'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 和 `Task<TResult>` 以多种方式指示失败：'
- en: The `Status` of a task becomes `Faulted` when the asynchronous operation has
    failed (and `IsFaulted` returns `true`).
  id: totrans-2036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当异步操作失败时（`IsFaulted` 返回 `true`），任务的状态变为 `Faulted`。
- en: The `Exception` property returns an `AggregateException` that contains all the
    (potentially multiple) exceptions that caused the task to fail or `null` if the
    task isn’t faulted.
  id: totrans-2037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception` 属性返回一个包含所有（可能多个）导致任务失败的异常的 `AggregateException`，如果任务没有出错则返回 `null`。'
- en: The `Wait()` method throws an `AggregateException` if the task ends up in a
    faulted state.
  id: totrans-2038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务最终处于错误状态，`Wait()` 方法将抛出一个 `AggregateException`。
- en: The `Result` property of `Task<TResult>` (which also waits for completion) likewise
    throws an `AggregateException`.
  id: totrans-2039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task<TResult>` 的 `Result` 属性（它也等待完成）同样会抛出一个 `AggregateException`。'
- en: Additionally, tasks support the idea of cancellation via `CancellationTokenSource`
    and `CancellationToken`. If a task is canceled, the `Wait()` method and `Result`
    properties will throw an `AggregateException` containing an `OperationCanceledException`
    (in practice, a `TaskCanceledException` that derives from `OperationCanceledException`),
    but the status becomes `Canceled` instead of `Faulted`.
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任务支持通过 `CancellationTokenSource` 和 `CancellationToken` 实现取消操作的概念。如果一个任务被取消，`Wait()`
    方法以及 `Result` 属性将抛出一个包含 `OperationCanceledException`（实际上是一个从 `OperationCanceledException`
    派生的 `TaskCanceledException`）的 `AggregateException`，但状态变为 `Canceled` 而不是 `Faulted`。
- en: When you await a task, if it’s either faulted or canceled, an exception will
    be thrown but not the `AggregateException`. Instead, for convenience (in most
    cases), the first exception *within* the `AggregateException` is thrown. In most
    cases, this is what you want. It’s in the spirit of the async feature to allow
    you to write asynchronous code that looks much like the synchronous code you’d
    otherwise write. For example, consider the following listing, which tries to fetch
    one URL at a time until either one of them succeeds or you run out of URLs to
    try.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 当你等待一个任务时，如果它处于错误或取消状态，将抛出一个异常，但不是 `AggregateException`。相反，为了方便（在大多数情况下），将抛出
    `AggregateException` 中的第一个异常。在大多数情况下，这正是你想要的。这与异步功能的精神相符，允许你编写看起来与同步代码非常相似的异步代码。例如，考虑以下列表，它尝试一次获取一个
    URL，直到其中一个成功或你尝试的 URL 已用尽。
- en: Listing 5.5\. Catching exceptions when fetching web pages
  id: totrans-2042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 在获取网页时捕获异常
- en: '[PRE235]'
  id: totrans-2043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '***1* Returns the string if successful**'
  id: totrans-2044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果成功则返回字符串**'
- en: '***2* Catches and displays the failure otherwise**'
  id: totrans-2045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 捕获并显示失败，否则**'
- en: For the moment, ignore the fact that you’re losing all the original exceptions
    and that you’re fetching all the pages sequentially. The point I’m trying to make
    is that catching `HttpRequestException` is what you’d expect here; you’re trying
    an asynchronous operation with an `HttpClient`, and if something fails, it’ll
    throw an `HttpRequestException`. You want to catch and handle that, right? That
    certainly *feels* like what you’d want to do—but the `GetStringAsync()` call can’t
    throw an `HttpRequestException` for an error such as the server timing out because
    the method only *starts* the operation. By the time it spots that error, the method
    has returned. All it can do is return a task that ends up being faulted and containing
    an `HttpRequestException`. If you simply called `Wait()` on the task, an `AggregateException`
    would be thrown that contains the `HttpRequestException` within it. The task awaiter’s
    `GetResult` method throws the `HttpRequestException` instead, and it’s caught
    by the `catch` block as normal.
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，忽略你丢失了所有原始异常以及你正在按顺序获取所有页面的情况。我试图说明的是，在这里捕获 `HttpRequestException` 是你所期望的；你正在尝试使用
    `HttpClient` 进行异步操作，如果出现错误，它将抛出 `HttpRequestException`。你想要捕获并处理它，对吧？这确实 *感觉* 是你想要做的——但是
    `GetStringAsync()` 调用不能因为服务器超时等错误抛出 `HttpRequestException`，因为该方法只 *开始* 操作。在它发现错误时，方法已经返回了。它所能做的就是返回一个最终失败的包含
    `HttpRequestException` 的任务。如果你简单地调用任务的 `Wait()`，将抛出一个包含其内部的 `HttpRequestException`
    的 `AggregateException`。任务等待器的 `GetResult` 方法会抛出 `HttpRequestException`，并且它会被 `catch`
    块正常捕获。
- en: Of course, this can lose information. If there are multiple exceptions in a
    faulted task, `GetResult` can throw only one of them, and it arbitrarily uses
    the first. You might want to rewrite the preceding code so that on failure, the
    caller can catch an `AggregateException` and examine *all* the causes of the failure.
    Importantly, some framework methods do this. For example, `Task.WhenAll()` is
    a method that’ll asynchronously wait for multiple tasks (specified in the method
    call) to complete. If any of them fails, the result is a failure that’ll contain
    the exceptions from all the faulted tasks. But if you await only the task returned
    by `WhenAll()`, you’ll see only the first exception. Typically, if you want to
    check the exceptions in detail, the simplest approach is to use `Task.Exception`
    for each of the original tasks.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可能会丢失信息。如果一个有故障的任务中有多个异常，`GetResult` 只能抛出一个，并且它任意地使用了第一个。你可能想要重写前面的代码，以便在失败时，调用者可以捕获一个
    `AggregateException` 并检查失败的 *所有* 原因。重要的是，一些框架方法就是这样做的。例如，`Task.WhenAll()` 是一个异步等待多个任务（在方法调用中指定）完成的异步方法。如果其中任何一个失败，结果将是一个包含所有有故障任务异常的失败。但是，如果你只等待
    `WhenAll()` 返回的任务，你将只会看到第一个异常。通常，如果你想详细检查异常，最简单的方法是使用 `Task.Exception` 对每个原始任务进行操作。
- en: To conclude, you know that the awaiter type’s `GetResult()` method is used to
    propagate both successful results and exceptions when awaiting. In the case of
    `Task` and `Task<TResult>`, `GetResult()` unwraps a failed task’s `AggregateException`
    to throw the first of its inner exceptions. That explains how an async method
    consumes another asynchronous operation—but how does it propagate its own result
    to calling code?
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你知道在等待时，awaiter 类型的 `GetResult()` 方法用于传播成功的结果和异常。在 `Task` 和 `Task<TResult>`
    的情况下，`GetResult()` 解包失败任务的 `AggregateException` 以抛出其内部异常的第一个。这就解释了异步方法是如何消耗另一个异步操作的——但是它是如何将自身的返回结果传播给调用代码的呢？
- en: 5.6.5\. Method completion
  id: totrans-2049
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.5. 方法完成
- en: 'Let’s recap a few points:'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾几个要点：
- en: An async method usually returns before it completes.
  id: totrans-2051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步方法通常在完成之前就返回了。
- en: It returns as soon as it hits an await expression where the operation that’s
    being awaited hasn’t already finished.
  id: totrans-2052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦遇到一个 await 表达式，其中等待的操作尚未完成，它就会立即返回。
- en: 'Assuming it’s not a `void` method (in which case the caller has no easy way
    of telling what’s going on), the value the method returns will be a task of some
    kind: `Task` or `Task<TResult>` before C# 7, with the option of a custom task
    type (which is explained in [section 5.8](kindle_split_020_split_000.html#ch05lev1sec8))
    in C# 7 and onward. For the moment, let’s assume it’s a `Task<TResult>` for simplicity.'
  id: totrans-2053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设它不是一个 `void` 方法（在这种情况下，调用者没有简单的方法来了解发生了什么），方法返回的值将是一个某种类型的任务：在 C# 7 之前是 `Task`
    或 `Task<TResult>`，从 C# 7 开始有自定义任务类型的选项（这将在 [第 5.8 节](kindle_split_020_split_000.html#ch05lev1sec8)
    中解释）。为了简单起见，让我们假设它是一个 `Task<TResult>`。
- en: That task is responsible for indicating when and how the async method completes.
    If the method completes normally, the task status changes to `RanToCompletion`
    and the `Result` property holds the return value. If the method body throws an
    exception, the task status changes to `Faulted` (or `Canceled` depending on the
    exception) and the exception is wrapped into an `AggregateException` for the task’s
    `Exception` property.
  id: totrans-2054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该任务负责指示异步方法何时以及如何完成。如果方法正常完成，任务状态将变为`RanToCompletion`，并且`Result`属性包含返回值。如果方法体抛出异常，任务状态将变为`Faulted`（或根据异常变为`Canceled`），异常将被包装到任务的`Exception`属性中的`AggregateException`中。
- en: When the task status changes to any of these terminal states, any continuations
    associated with it (such as code in any asynchronous method awaiting the task)
    can be scheduled to run.
  id: totrans-2055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务状态变为这些终端状态之一时，与其关联的任何延续（例如，在等待任务的任何异步方法中的代码）都可以被安排运行。
- en: '|  |'
  id: totrans-2056
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Yes, this sounds like it’s repetition**'
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的，这听起来像是重复**'
- en: You may be wondering whether you’ve accidentally skipped back a couple of pages
    and read them twice. Didn’t you just look at the same ideas when you awaited something?
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道是否不小心跳回了几页并读了两遍。您在等待某事时不是刚刚看到了同样的想法吗？
- en: 'Absolutely. All I’m doing is showing what the async method does to indicate
    how it completes rather than how an await expression examines how something else
    has completed. If these didn’t feel the same, that would be odd, because usually
    async methods are chained together: the value you’re awaiting in one async method
    is probably the value returned by another async method. In fancier terms, async
    operations *compose* easily.'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对如此。我所做的只是展示异步方法如何指示其完成情况，而不是展示await表达式如何检查其他事物的完成情况。如果这些感觉不同，那就很奇怪，因为通常异步方法会串联在一起：您在一个异步方法中等待的值可能是由另一个异步方法返回的值。用更华丽的词来说，异步操作*易于组合*。
- en: '|  |'
  id: totrans-2060
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: All of this is done for you by the compiler with the help of a fair amount of
    infrastructure. You’ll look at some of those details in the next chapter (although
    not every single nook and cranny; even I have limits). This chapter is more about
    the behavior you can rely on in your code.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工作都是由编译器在大量基础设施的帮助下为您完成的。您将在下一章中看到其中的一些细节（尽管不是每一个角落和缝隙；即使是我也有限制）。本章更多地关注您可以在代码中依赖的行为。
- en: Returning successfully
  id: totrans-2062
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 成功返回
- en: 'The success case is the simplest one: if the method is declared to return a
    `Task <TResult>`, the return statement has to provide a value of type `T` (or
    something that can be converted to `TResult`), and the async infrastructure propagates
    that to the task.'
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: 成功情况是最简单的情况：如果方法声明为返回`Task<TResult>`，则返回语句必须提供类型为`T`（或可以转换为`TResult`的类型）的值，并且异步基础设施将此值传播到任务中。
- en: If the return type is `Task` or `void`, any return statements have to be of
    the form `return` without a value, or it’s fine to let execution reach the end
    of the method, like a nonasync `void` method. In both cases, there’s no value
    to propagate, but the status of the task changes appropriately.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回类型是`Task`或`void`，任何返回语句都必须是`return`形式，不带值，或者允许执行到达方法的末尾，就像非异步`void`方法一样。在这两种情况下，都没有要传播的值，但任务的状态会相应地改变。
- en: Lazy exceptions and argument validation
  id: totrans-2065
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 懒异常和参数验证
- en: The most important point to note about exceptions is that an async method never
    directly throws an exception. Even if the first thing the method body does is
    throw an exception, it’ll return a faulted task. (The task will be immediately
    faulted in this case.) This is a bit of a pain in terms of argument validation.
    Suppose you want to do some work in an async method after validating that the
    parameters don’t have null values. If you validate the parameters as you would
    in a normal synchronous code, the caller won’t have any indication of the problem
    until the task is awaited. The following listing gives an example.
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异常的最重要的一点是，异步方法永远不会直接抛出异常。即使方法体首先做的事情是抛出异常，它也会返回一个故障任务。（在这种情况下，任务将立即故障。）这在参数验证方面有点麻烦。假设您想在异步方法中验证参数没有null值之后做一些工作。如果您像在正常同步代码中那样验证参数，调用者直到任务被等待时才会发现问题。以下列表提供了一个示例。
- en: Listing 5.6\. Broken argument validation in an async method
  id: totrans-2067
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 异步方法中的断言参数验证错误
- en: '[PRE236]'
  id: totrans-2068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '***1* Deliberately passes a bad argument**'
  id: totrans-2069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 故意传递一个错误的参数**'
- en: '***2* Awaits the result**'
  id: totrans-2070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待结果**'
- en: '***3* Throws an exception as early as possible**'
  id: totrans-2071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 尽早抛出异常**'
- en: '***4* Simulates real asynchronous work**'
  id: totrans-2072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 模拟真实异步工作**'
- en: The output shows `Fetched the task` before it fails. The exception has been
    thrown synchronously before that output is written, because there are no `await`
    expressions before the validation, but the calling code won’t see it until it
    awaits the returned task. Some argument validation can sensibly be done up front
    without taking a long time (or incurring other asynchronous operations). In these
    cases, it’d be better if the failure were reported immediately, before the system
    can get itself into further trouble. As an example, `HttpClient.GetStringAsync`
    will throw an exception immediately if you pass it a null reference.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 输出在失败之前显示了 `Fetched the task`。由于在验证之前没有 `await` 表达式，异常在输出之前就已经同步抛出了，但调用代码直到它等待返回的任务时才会看到它。某些参数验证可以合理地在前端进行，而不会花费很长时间（或产生其他异步操作）。在这些情况下，如果失败能够立即报告，在系统陷入更大的麻烦之前，那就更好了。例如，如果你向
    `HttpClient.GetStringAsync` 传递一个 null 引用，它将立即抛出异常。
- en: '|  |'
  id: totrans-2074
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’ve ever written an iterator method that needs to validate its arguments,
    this may sound familiar. It’s not quite the same, but it has a similar effect.
    In iterator blocks, any code in the method, including argument validation, doesn’t
    execute at all until the first call to `MoveNext()` on the sequence returned by
    the method. In the asynchronous case, the argument validation occurs immediately,
    but the exception won’t be obvious until you await the result.
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经编写过需要验证其参数的迭代器方法，这可能会听起来很熟悉。它并不完全相同，但它有类似的效果。在迭代器块中，方法中的任何代码，包括参数验证，都不会在方法返回的序列上的第一次调用
    `MoveNext()` 之前执行。在异步情况下，参数验证立即发生，但异常直到你等待结果时才会变得明显。
- en: '|  |'
  id: totrans-2077
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You may not be too worried about this. Eager argument validation may be regarded
    as a nice-to-have feature in many cases. I’ve certainly become a lot less pedantic
    about this in my own code, as a matter of pragmatism; in most cases, the difference
    in timing isn’t terribly important. But if you do want to throw an exception synchronously
    from a method returning a task, you have three options, all of which are variations
    on the same theme.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会对此过于担忧。在许多情况下，急切参数验证可能被视为一个锦上添花的特性。我当然在我的代码中对此变得不那么吹毛求疵了，这是一个实用主义的问题；在大多数情况下，时间上的差异并不十分重要。但是，如果你确实想在返回任务的方法中同步抛出异常，你有三种选择，它们都是基于相同主题的变体。
- en: 'The idea is to write a *nonasync* method that returns a task and is implemented
    by validating the arguments and then calling a separate async function that assumes
    the argument has already been validated. The three variations are in terms of
    how the async function is represented:'
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是编写一个返回任务的非异步方法，通过验证参数然后调用一个假设参数已经被验证的单独的异步函数来实现。这三种变体在于异步函数的表示方式：
- en: You can use a separate async method.
  id: totrans-2080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用一个单独的异步方法。
- en: You can use an async anonymous function (which you’ll see in the next section).
  id: totrans-2081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用异步匿名函数（你将在下一节中看到）。
- en: In C# 7 and above, you can use a local async method.
  id: totrans-2082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 7 及以上版本中，你可以使用局部异步方法。
- en: My preference is the last of these; it has the benefit of not introducing another
    method into the class without the downside of having to create a delegate. [Listing
    5.7](kindle_split_020_split_000.html#ch05ex07) shows the first option, as that
    doesn’t rely on anything we haven’t already covered, but the code for the other
    options is similar (and is in the downloadable code for book). This is only the
    `ComputeLengthAsync` method; the calling code doesn’t need to change.
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 我的偏好是最后一种；它有好处，即不会在类中引入另一个方法，而不需要创建代理。[列表 5.7](kindle_split_020_split_000.html#ch05ex07)
    展示了第一种选择，因为那不依赖于我们尚未涵盖的内容，但其他选项的代码是相似的（并且可以在书籍的可下载代码中找到）。这只是一个 `ComputeLengthAsync`
    方法；调用代码不需要更改。
- en: Listing 5.7\. Eager argument validation with a separate method
  id: totrans-2084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 使用单独方法的急切参数验证
- en: '[PRE237]'
  id: totrans-2085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '***1* Nonasync method so exceptions aren’t wrapped in a task**'
  id: totrans-2086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 非异步方法，因此异常不会被封装在任务中**'
- en: '***2* After validation, delegate to implementation method.**'
  id: totrans-2087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证后，委托给实现方法。**'
- en: '***3* Implementation async method assumes validated input**'
  id: totrans-2088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实现异步方法假设已验证的输入**'
- en: Now when `ComputeLengthAsync` is called with a null argument, the exception
    is thrown synchronously rather than returning a faulted task.
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当 `ComputeLengthAsync` 被一个 null 参数调用时，异常会同步抛出，而不是返回一个已故障的任务。
- en: Before moving on to asynchronous anonymous functions, let’s briefly revisit
    cancellation. I’ve mentioned this a couple of times in passing, but it’s worth
    considering in a bit more detail.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论异步匿名函数之前，让我们简要回顾一下取消操作。我曾在几个地方提到过这一点，但更详细地考虑一下是有价值的。
- en: Handling cancellation
  id: totrans-2091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理取消
- en: 'The Task Parallel Library (TPL) introduced a uniform cancellation model into
    .NET 4 using two types: `CancellationTokenSource` and `CancellationToken`. The
    idea is that you can create a `CancellationTokenSource` and then ask it for a
    `CancellationToken`, which is passed to an asynchronous operation. You can perform
    the cancellation on only the source, but that’s reflected to the token. (Therefore,
    you can pass out the same token to multiple operations and not worry about them
    interfering with each other.) There are various ways of using the cancellation
    token, but the most idiomatic approach is to call `ThrowIfCancellationRequested`,
    which will throw `OperationCanceledException` if the token has been canceled and
    will do nothing otherwise.^([[1](kindle_split_020_split_000.html#ch05fn1)]) The
    same exception is thrown by synchronous calls (such as `Task.Wait`) if they’re
    canceled.'
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 任务并行库（TPL）在 .NET 4 中引入了统一的取消模型，使用了两种类型：`CancellationTokenSource`和`CancellationToken`。想法是你可以创建一个`CancellationTokenSource`，然后请求一个`CancellationToken`，这个令牌会被传递给一个异步操作。你可以在源上执行取消操作，但这会反映到令牌上。（因此，你可以将相同的令牌传递给多个操作，而不必担心它们之间相互干扰。）有各种使用取消令牌的方法，但最符合习惯的方法是调用`ThrowIfCancellationRequested`，如果令牌已被取消，它将抛出`OperationCanceledException`，否则不做任何操作.^([[1](kindle_split_020_split_000.html#ch05fn1)])
    同样的异常也会在同步调用（如`Task.Wait`）被取消时抛出。
- en: ¹
  id: totrans-2093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-2094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An example of this is available in the downloadable source code.
  id: totrans-2095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下是一个可下载源代码中的示例。
- en: How this interacts with asynchronous methods is undocumented in the C# specification.
    According to the specification, if an asynchronous method body throws *any* exception,
    the task returned by the method will be in a faulted state. The exact meaning
    of *faulted* is implementation specific, but in reality, if an asynchronous method
    throws an `OperationCanceledException` (or a derived exception type, such as `TaskCanceledException`),
    the returned task will end up with a status of `Canceled`. You can demonstrate
    that it’s only the type of exception that determines the status by throwing an
    `OperationCanceledException` directly without the use of any cancellation tokens.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 规范中，关于这如何与异步方法交互没有文档记录。根据规范，如果一个异步方法体抛出*任何*异常，该方法返回的任务将处于错误状态。*错误*的确切含义是特定于实现的，但现实中，如果一个异步方法抛出`OperationCanceledException`（或其派生类型，如`TaskCanceledException`），返回的任务最终将具有`Canceled`状态。你可以通过直接抛出`OperationCanceledException`而不使用任何取消令牌来证明只有异常类型决定了状态。
- en: Listing 5.8\. Creating a canceled task by throwing `OperationCanceledException`
  id: totrans-2097
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8\. 通过抛出`OperationCanceledException`创建已取消的任务
- en: '[PRE238]'
  id: totrans-2098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: This outputs `Canceled` rather than the `Faulted` you might expect from the
    specification. If you `Wait()` on the task or ask for its result (in the case
    of a `Task<TResult>`), the exception is still thrown within an `AggregateException`,
    so it’s not like you need to explicitly start checking for cancellation on every
    task you use.
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: 这输出的是`Canceled`，而不是你根据规范可能期望的`Faulted`。如果你在任务上调用`Wait()`或请求其结果（在`Task<TResult>`的情况下），异常仍然会在`AggregateException`内部抛出，所以你不需要在使用的每个任务上显式开始检查取消。
- en: '|  |'
  id: totrans-2100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Off to the races?**'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: '**比赛开始了吗？**'
- en: You might be wondering if there’s a race condition in [listing 5.8](kindle_split_020_split_000.html#ch05ex08).
    After all, you’re calling an asynchronous method and then immediately expecting
    the status to be fixed. If this code were starting a new thread, that would be
    dangerous—but it’s not.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道在[列表 5.8](kindle_split_020_split_000.html#ch05ex08)中是否存在竞态条件。毕竟，你调用了一个异步方法，然后立即期望状态被固定。如果这段代码是启动一个新线程，那将是危险的——但事实并非如此。
- en: Remember that before the first await expression, an asynchronous method runs
    synchronously. It still performs result and exception wrapping, but the fact that
    it’s in an asynchronous method doesn’t necessarily mean there are any more threads
    involved. The `ThrowCancellationException` method doesn’t contain any await expressions,
    so the whole method runs synchronously; you know that we’ll have a result by the
    time it returns. Visual Studio issues a warning for any asynchronous function
    that doesn’t contain any await expressions, but in this case it’s exactly what
    you want.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在第一个`await`表达式之前，异步方法以同步方式运行。它仍然执行结果和异常包装，但它是异步方法的事实并不一定意味着涉及更多的线程。`ThrowCancellationException`方法不包含任何`await`表达式，所以整个方法以同步方式运行；你知道它返回时会有一个结果。Visual
    Studio会对任何不包含任何`await`表达式的异步函数发出警告，但在这个情况下，这正是你想要的。
- en: '|  |'
  id: totrans-2104
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Importantly, if you await an operation that’s canceled, the original `OperationCanceledException`
    is thrown. Consequently, unless you take any direct action, the task returned
    from the asynchronous method will also be canceled; cancellation is propagated
    in a natural fashion.
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，如果你等待一个被取消的操作，将会抛出原始的`OperationCanceledException`。因此，除非你采取任何直接行动，否则异步方法返回的任务也将被取消；取消会以自然的方式传播。
- en: Congratulations on making it this far. You’ve now covered most of the hard parts
    for this chapter. You still have a couple of features to learn about, but they’re
    much easier to understand than the preceding sections. It’ll get tough again in
    the next chapter when we dissect what the compiler’s doing behind the scenes,
    but for now you can enjoy relative simplicity.
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你走到了这一步。你现在已经覆盖了本章大部分的难点。你仍然需要学习一些功能，但它们比前面的部分容易理解得多。在下一章，当我们剖析编译器在幕后所做的工作时，难度会再次增加，但到目前为止，你可以享受相对的简单性。
- en: 5.7\. Asynchronous anonymous functions
  id: totrans-2107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7\. 异步匿名函数
- en: 'I won’t spend much time on asynchronous anonymous functions. As you’d probably
    expect, they’re a combination of two features: anonymous functions (lambda expressions
    and anonymous methods) and asynchronous functions (code that can include `await`
    expressions). They allow you to create delegates that represent asynchronous operations.
    Everything you’ve learned so far about asynchronous methods applies to asynchronous
    anonymous functions, too.'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在异步匿名函数上花费太多时间。正如你可能预期的那样，它们是两个功能的组合：匿名函数（lambda表达式和匿名方法）和异步函数（可以包含`await`表达式的代码）。它们允许你创建代表异步操作的委托。你迄今为止关于异步方法所学的所有内容也适用于异步匿名函数。
- en: '|  |'
  id: totrans-2109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-2110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In case you were wondering, you can’t use asynchronous anonymous functions to
    create expression trees.
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有所疑问，你不能使用异步匿名函数来创建表达式树。
- en: '|  |'
  id: totrans-2112
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You create an asynchronous anonymous function like any other anonymous method
    or lambda expression by simply adding the `async` modifier at the start. Here’s
    an example:'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在开始处添加`async`修饰符来创建异步匿名函数，就像创建其他匿名方法或lambda表达式一样简单。以下是一个示例：
- en: '[PRE239]'
  id: totrans-2114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: The delegate you create has to have a signature with a return type that would
    be suitable for an asynchronous method (`void`, `Task`, or `Task<TResult>` for
    C# 5 and 6, with the option of a custom task type in C# 7). You can capture variables,
    as with other anonymous functions, and add parameters. Also, the asynchronous
    operation doesn’t start until the delegate is invoked, and multiple invocations
    create multiple operations. Delegate invocation *does* start the operation, though;
    as with a call to an async method, it’s not awaiting the task that starts an operation,
    and you don’t have to use `await` with the result of an asynchronous anonymous
    function at all. The following listing shows a slightly fuller (although still
    pointless) example.
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的委托必须具有适合异步方法的签名（对于C# 5和6，是`void`、`Task`或`Task<TResult>`，C# 7中可以选择自定义任务类型）。你可以像其他匿名函数一样捕获变量，并添加参数。异步操作不会在委托被调用之前开始，多次调用会创建多个操作。尽管委托调用会启动操作，但与对异步方法的调用一样，它不是在等待启动操作的任务，你也不必在异步匿名函数的结果上使用`await`。以下列表显示了一个稍微更完整（尽管仍然没有意义）的示例。
- en: Listing 5.9\. Creating and calling an asynchronous function using a lambda expression
  id: totrans-2116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. 使用lambda表达式创建和调用异步函数
- en: '[PRE240]'
  id: totrans-2117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'I’ve deliberately chosen the values here so that the second operation completes
    quicker than the first. But because you’re waiting for the first to finish before
    printing the results (using the `Result` property, which blocks until the task
    has completed—again, be careful where you run this), the output looks like this:'
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意选择了这些值，以便第二个操作比第一个操作完成得更快。但是，因为你需要在打印结果之前等待第一个操作完成（使用 `Result` 属性，它会在任务完成之前阻塞——再次提醒，注意你运行此代码的位置），所以输出看起来是这样的：
- en: '[PRE241]'
  id: totrans-2119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: All of this behaves exactly the same as if you’d put the asynchronous code into
    an asynchronous method.
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些行为都完全相同，就像你将异步代码放入异步方法中一样。
- en: 'I’ve written far more async methods than async anonymous functions, but they
    can be useful, particularly with LINQ. You can’t use them in LINQ query expressions,
    but calling the equivalent methods directly works. It has limitations, though:
    because an async function can never return `bool`, you can’t call `Where` with
    an async function, for example. I’ve most commonly used `Select` to transform
    a sequence of tasks of one type to a sequence of tasks of a different type. Now
    I’ll address a feature I’ve referred to a few times already: an extra level of
    generalization introduced by C# 7.'
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 我写的异步方法比异步匿名函数多得多，但它们非常有用，尤其是在 LINQ 中。你无法在 LINQ 查询表达式中使用它们，但直接调用等效方法是可以的。尽管如此，它也有一些限制：因为异步函数永远不能返回
    `bool`，所以你不能用异步函数调用 `Where`，例如。我通常使用 `Select` 将一个类型的任务序列转换为另一个类型的任务序列。现在我将讨论我已经多次提到的功能：C#
    7 引入的额外泛化级别。
- en: 5.8\. Custom task types in C# 7
  id: totrans-2122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8\. C# 7 中的自定义任务类型
- en: In C# 5 and C# 6, asynchronous functions (that is, async methods and async anonymous
    functions) could return only `void`, `Task`, or `Task<TResult>`. C# 7 loosens
    this restriction slightly and allows any type that’s decorated in a particular
    way to be used as a return type for asynchronous functions.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 5 和 C# 6 中，异步函数（即异步方法和异步匿名函数）只能返回 `void`、`Task` 或 `Task<TResult>`。C# 7
    稍微放宽了这一限制，允许任何以特定方式装饰的类型用作异步函数的返回类型。
- en: As a reminder, the async/await feature has always allowed us to *await* custom
    types that follow the awaitable pattern. The new feature here permits writing
    an async method that *returns* a custom type.
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，async/await 功能始终允许我们等待遵循可等待模式的自定义类型。这里的新功能允许编写返回自定义类型的异步方法。
- en: This is simultaneously complex and simple. It’s complex in that if you want
    to create your own task type, you have some fiddly work ahead of you. It’s not
    for the fainthearted. It’s simple in that you’re almost certainly not going to
    want to do this other than for experimentation; you’re going to want to use `ValueTask<TResult>`.
    Let’s look at that now.
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 这既复杂又简单。它之所以复杂，是因为如果你想要创建自己的任务类型，你将面临一些繁琐的工作。这不是给胆小的人准备的。它之所以简单，是因为你几乎肯定不会想这么做，除非是为了实验；你将想要使用
    `ValueTask<TResult>`。现在让我们来看看它。
- en: '5.8.1\. The 99.9% case: ValueTask<TResult>'
  id: totrans-2126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.1\. 99.9% 的情况：ValueTask<TResult>
- en: At the time of this writing, the `System.Threading.ValueTask<TResult>` type
    is present out of the box only in the netcoreapp2.0 framework, but it’s also available
    in the `System.Threading.Tasks.Extensions` package from NuGet, which makes it
    far more widely applicable. (Most important, that package includes a target for
    netstandard1.0.)
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`System.Threading.ValueTask<TResult>` 类型仅在 netcoreapp2.0 框架中作为内置类型存在，但它也通过
    NuGet 的 `System.Threading.Tasks.Extensions` 包提供，这使得它具有更广泛的应用性。（最重要的是，该包包括对 netstandard1.0
    的目标。）
- en: '`ValueTask<TResult>` is simple to describe: it’s like `Task<TResult>`, but
    it’s a value type. It has an `AsTask` method that allows you to obtain a regular
    task from it when you want (for example, to include as one element in a `Task.WhenAll`
    or `Task.WhenAny` call), but most of the time, you’ll want to await it as you
    would a task.'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueTask<TResult>` 的描述很简单：它就像 `Task<TResult>`，但它是值类型。它有一个 `AsTask` 方法，允许你在需要时（例如，在
    `Task.WhenAll` 或 `Task.WhenAny` 调用中将它作为一个元素包含）从它获取一个常规任务，但大多数时候，你将像等待一个任务一样等待它。'
- en: What’s the benefit of `ValueTask<TResult>` over `Task<TResult>`? It all comes
    down to heap allocation and garbage collection. `Task<TResult>` is a class, and
    although the async infrastructure reuses completed `Task<TResult>` objects in
    some cases, most async methods will need to create a new `Task<TResult>`. Allocating
    objects in .NET is cheap enough that in many cases you don’t need to worry about
    it, but if you’re doing it a lot or if you’re working under tight performance
    constraints, you want to avoid that allocation if possible.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueTask<TResult>`相对于`Task<TResult>`的优势是什么？这全部归结于堆分配和垃圾收集。`Task<TResult>`是一个类，尽管在某些情况下异步基础设施会重用完成的`Task<TResult>`对象，但大多数异步方法仍然需要创建一个新的`Task<TResult>`。在.NET中分配对象成本足够低，在许多情况下你不需要担心它，但如果你在做很多或者如果你在严格的性能约束下工作，你想要尽可能地避免这种分配。'
- en: If an async method uses an `await` expression on something that’s incomplete,
    object allocation is unavoidable. It’ll return immediately, but it has to schedule
    a continuation to execute the rest of the method when the awaited operation has
    completed. In most async methods, this is the common case; you don’t expect the
    operation you’re awaiting to have completed before you await it. In those cases,
    `ValueTask<TResult>` provides no benefit and can even be a little more expensive.
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个异步方法在某个不完整的事物上使用`await`表达式，对象分配是不可避免的。它将立即返回，但必须安排一个后续操作在等待的操作完成时执行方法的其余部分。在大多数异步方法中，这是常见的情况；你不会期望你等待的操作在你等待之前完成。在这些情况下，`ValueTask<TResult>`没有提供任何优势，甚至可能更昂贵。
- en: In a few cases, though, the already completed case is the most common one, and
    that’s where `ValueTask<TResult>` is useful. To demonstrate this, let’s consider
    a simplified version of a real-world example. Suppose you want to read a byte
    at a time from a `System.IO.Stream` and do so asynchronously. You can easily add
    a buffering abstraction layer to avoid calling `ReadAsync` on the underlying `Stream`
    too often, but you’d then want to add an async method to encapsulate the operation
    of populate the buffer from the stream where necessary, then return the next byte.
    You can use `byte?` with a null value to indicate that you’ve reached the end
    of the data. That method is easy to write, but if every call to it allocates a
    new `Task<byte?>`, you’ll be hammering the garbage collector pretty hard. With
    `ValueTask<TResult>`, heap allocation is required only in the rare cases when
    you need to refill the buffer from the stream. The following listing shows the
    wrapper type (`ByteStream`) and an example of using it.
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在少数情况下，已经完成的案例是最常见的一种，这就是`ValueTask<TResult>`发挥作用的地方。为了演示这一点，让我们考虑一个简化版的真实世界示例。假设你想要逐字节从`System.IO.Stream`读取，并且异步地这样做。你可以轻松地添加一个缓冲抽象层来避免在底层`Stream`上频繁调用`ReadAsync`，但随后你可能需要添加一个异步方法来封装从流中填充缓冲区的操作，然后返回下一个字节。你可以使用`byte?`与空值来表示你已经到达了数据的末尾。这个方法很容易编写，但如果每次调用它都分配一个新的`Task<byte?>`，你将非常频繁地敲打垃圾收集器。使用`ValueTask<TResult>`，只有在需要从流中重新填充缓冲区的情况下才需要堆分配。以下列表显示了包装类型（`ByteStream`）及其使用示例。
- en: Listing 5.10\. Wrapping a stream for efficient asynchronous byte-wise access
  id: totrans-2132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 包装流以实现高效的异步字节访问
- en: '[PRE242]'
  id: totrans-2133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '***1* Next buffer index to return**'
  id: totrans-2134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 下一个要返回的缓冲区索引**'
- en: '***2* Number of read bytes in the buffer**'
  id: totrans-2135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 缓冲区中读取的字节数**'
- en: '***3* An 8 KB buffer will mean you rarely need to await.**'
  id: totrans-2136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 8 KB 缓冲区意味着你很少需要等待。**'
- en: '***4* Refills the buffer if necessary**'
  id: totrans-2137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果需要则填充缓冲区**'
- en: '***5* Asynchronously reads from underlying stream**'
  id: totrans-2138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 异步从底层流读取**'
- en: '***6* Configures await operation to ignore context**'
  id: totrans-2139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 配置等待操作以忽略上下文**'
- en: '***7* Indicates end of stream where appropriate**'
  id: totrans-2140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在适当的位置指示流的末尾**'
- en: '***8* Returns the next byte from the buffer**'
  id: totrans-2141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 从缓冲区返回下一个字节**'
- en: '***9* Uses the byte in some way**'
  id: totrans-2142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 以某种方式使用字节**'
- en: For the moment, you can ignore the `ConfigureAwait` call within `ReadByteAsync`.
    You’ll come back to that in [section 5.10](kindle_split_020_split_000.html#ch05lev1sec10),
    when you look at how to use async/await effectively. The rest of the code is straightforward,
    and all of it could be written without `ValueTask<TResult>`; it’d just be much
    less efficient.
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以忽略`ReadByteAsync`中的`ConfigureAwait`调用。当你查看如何有效地使用async/await时，你将回到这一点，在[第5.10节](kindle_split_020_split_000.html#ch05lev1sec10)。其余的代码很简单，所有这些都可以在不使用`ValueTask<TResult>`的情况下编写；它只是效率要低得多。
- en: In this case, most invocations of our `ReadByteAsync` method wouldn’t even use
    the `await` operator because you’d still have buffered data to return, but it’d
    be equally useful if you were awaiting another value that’s usually complete immediately.
    As I explained in [section 5.6.2](kindle_split_020_split_000.html#ch05lev2sec11),
    when you await an operation that’s already complete, the execution continues synchronously,
    which means you don’t need to schedule a continuation and can avoid object allocations.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们 `ReadByteAsync` 方法的多数调用甚至不会使用 `await` 操作符，因为你仍然有缓冲的数据可以返回，但如果你在等待另一个通常立即完成的值，这同样是有用的。正如我在
    [5.6.2节](kindle_split_020_split_000.html#ch05lev2sec11) 中解释的那样，当你等待一个已经完成的操作时，执行会同步继续，这意味着你不需要安排一个后续操作，可以避免对象分配。
- en: This is a simplified version of a prototype of the `CodedInputStream` class
    from the `Google.Protobuf` package, the .NET implementation of Google’s Protocol
    Buffers serialization protocol. In reality, there are multiple methods, each reading
    a small amount of data either synchronously or asynchronously. Deserializing a
    message with lots of integer fields can involve a lot of method calls, and making
    the asynchronous methods return a `Task<TResult>` each time would’ve been prohibitively
    inefficient.
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Google.Protobuf` 包中 `CodedInputStream` 类原型的简化版本，是 Google 协议缓冲区序列化协议的 .NET
    实现。实际上，有多个方法，每个方法要么同步要么异步地读取一小部分数据。使用包含大量整数字段的消息进行反序列化可能涉及大量的方法调用，并且每次使异步方法返回
    `Task<TResult>` 都会非常低效。
- en: '|  |'
  id: totrans-2146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may be wondering what to do if you have an async method that doesn’t return
    a value (so would normally have a return type of `Task`), but that still falls
    into the category of completing without having to schedule any continuations.
    In this case, you can stick to returning `Task`: the async/await infrastructure
    caches a task that it can return from any async method declared to return `Task`
    that completes synchronously and without an exception. If the method completes
    synchronously but with an exception, the cost of allocating a `Task` object likely
    will be dwarfed by the exception overhead anyway.'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，如果你有一个不返回值（通常返回类型为 `Task`）的异步方法，但仍然属于无需安排任何后续操作即可完成的情况，你应该怎么做。在这种情况下，你可以坚持返回
    `Task`：async/await 基础设施会缓存一个任务，它可以返回任何声明为返回 `Task` 且同步完成且无异常的异步方法。如果方法同步完成但带有异常，分配
    `Task` 对象的成本很可能会被异常开销所淹没。
- en: '|  |'
  id: totrans-2149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For most of us, the ability to use `ValueTask<TResult>` as a return type for
    async methods is the real benefit of C# 7 in terms of asynchrony. But this has
    been implemented in a general-purpose way, allowing you to create your own return
    types for async methods.
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们大多数人来说，能够将 `ValueTask<TResult>` 用作异步方法的返回类型是 C# 7 在异步方面真正的优势。但这已经被以通用方式实现，允许你为异步方法创建自己的返回类型。
- en: '5.8.2\. The 0.1% case: Building your own custom task type'
  id: totrans-2151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.2\. 0.1%的情况：构建自己的自定义任务类型
- en: I’d like to emphasize again that you’re almost certainly never going to need
    this information. I’m not going to even try to provide a use case beyond `ValueTask<TResult>`,
    because anything I could think of would be obscure. That said, this book would
    be incomplete if I didn’t show the pattern the compiler uses to determine that
    a type is a task type. I’ll show the details of how the compiler uses the pattern
    in the next chapter, when you look at the code that gets generated for an async
    method.
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次强调，你几乎肯定永远不需要这些信息。我甚至不会尝试提供超出 `ValueTask<TResult>` 的用例，因为我能想到的任何用例都可能很晦涩。话虽如此，如果我不展示编译器用来确定一个类型是任务类型的模式的例子，这本书就不完整。我将在下一章中展示编译器如何使用这个模式，届时你将看到为异步方法生成的代码。
- en: Obviously, a custom task type has to implement the awaitable pattern, but there’s
    much more to it than that. To create a custom task type, you have to write a corresponding
    *builder type* and use the `System.Runtime.CompilerServices.AsyncMethodBuilderAttribute`
    to let the compiler know the relationship between the two types. This is a new
    attribute available in the same NuGet package as `ValueTask<TResult>`, but if
    you don’t want the extra dependency, you can include your own declaration of the
    attribute (in the right namespace and with the appropriate `BuilderType` property).
    The compiler will then accept that as a way of decorating task types.
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，自定义任务类型必须实现可等待模式，但这不仅仅是可等待模式。要创建自定义任务类型，你必须编写相应的*构建器类型*，并使用`System.Runtime.CompilerServices.AsyncMethodBuilderAttribute`来让编译器知道这两个类型之间的关系。这是一个与`ValueTask<TResult>`相同的NuGet包中可用的新属性，但如果你不想有额外的依赖项，你可以包含自己声明的属性（在正确的命名空间中，并具有适当的`BuilderType`属性）。然后编译器将接受这作为装饰任务类型的一种方式。
- en: The task type can be generic in a single type parameter or nongeneric. If it’s
    generic, that type parameter must be the type of `GetResult` in the awaiter type;
    if it’s nongeneric, `GetResult` must have a `void` return type.^([[2](kindle_split_020_split_000.html#ch05fn2)])
    The builder must be generic or nongeneric in the same way as the task type.
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 任务类型可以是单个类型参数的泛型或非泛型。如果是泛型，则该类型参数必须是awaiter类型中`GetResult`的类型；如果是非泛型，则`GetResult`必须有一个`void`返回类型.^([[2](kindle_split_020_split_000.html#ch05fn2)])
    构建器必须与任务类型一样是泛型或非泛型。
- en: ²
  id: totrans-2155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-2156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This surprised me somewhat. It means you can’t write a custom task type that
    always represents an operation returning a string, for example. Given how niche
    the whole feature is, the likelihood of anyone really wanting a niche use case
    within the feature is pretty small.
  id: totrans-2157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这让我有些惊讶。这意味着你不能编写一个总是表示返回字符串的操作的自定义任务类型，例如。鉴于整个功能的细分程度，真正想要在该功能中实现细分用例的可能性相当小。
- en: The builder type is the part where the compiler interacts with your code when
    it’s compiling a method returning your custom type. It needs to know how to create
    your custom task, propagate completion or exceptions, resume after a continuation,
    and so on. The set of methods and properties you need to provide is significantly
    more complex than the awaitable pattern. It’s easiest to show a complete example,
    in terms of the members you need to provide, without any implementation.
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器类型是编译器在编译返回你的自定义类型的方法时与你的代码交互的部分。它需要知道如何创建你的自定义任务，传播完成或异常，在延续后恢复，等等。你需要提供的方法和属性集比可等待模式复杂得多。最容易的方式是展示一个完整的示例，关于你需要提供的成员，而不涉及任何实现。
- en: Listing 5.11\. Skeleton of the members required for a generic task type
  id: totrans-2159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. 泛型任务类型所需的成员框架
- en: '[PRE243]'
  id: totrans-2160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: This code shows a generic custom task type. For a nongeneric type, the only
    difference in the builder would be that `SetResult` would be a parameterless method.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了一个泛型自定义任务类型。对于非泛型类型，构建器中唯一的区别是`SetResult`将是一个无参数的方法。
- en: One interesting requirement is the `AwaitUnsafeOnCompleted` method. As you’ll
    see in the next chapter, the compiler has the notion of *safe* *awaiting* and
    *unsafe* *awaiting*, where the latter relies on the awaitable type to handle context
    propagation. A custom task builder type has to handle resuming from both kind
    of awaiting.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的要求是`AwaitUnsafeOnCompleted`方法。正如你将在下一章中看到的，编译器有*安全*等待和*不安全*等待的概念，后者依赖于可等待类型来处理上下文传播。自定义任务构建器类型必须处理从这两种等待中恢复。
- en: '|  |'
  id: totrans-2163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The term *unsafe* here isn’t directly related to the `unsafe` keyword, although
    similarities exist in terms of “here be dragons, take care!”
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“*不安全*”一词与`unsafe`关键字没有直接关系，尽管在“这里可能有龙，小心！”这一方面存在相似之处。
- en: '|  |'
  id: totrans-2166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To reiterate one final time, you almost certainly don’t want to be doing this
    except as a matter of interest. I don’t expect to ever implement my own task type
    for production code, but I’ll certainly use `ValueTask<TResult>`, so I’m still
    grateful that the feature exists.
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调一次，你几乎肯定不希望这样做，除非是出于兴趣。我不期望在生产代码中实现自己的任务类型，但我肯定会使用`ValueTask<TResult>`，所以我对这个功能的存在仍然感到非常感激。
- en: Speaking of useful new features, C# 7.1 has one additional feature to mention.
    Fortunately, it’s considerably simpler than custom task types.
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: 说到有用的新功能，C# 7.1还有一个额外的功能要提一下。幸运的是，它比自定义任务类型简单得多。
- en: 5.9\. Async main methods in C# 7.1
  id: totrans-2169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.9\. C# 7.1中的异步主方法
- en: 'The requirements for the entry point have remained the same in C# for a long
    time:'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于入口点的需求在C#中已经保持不变很长时间了：
- en: It must be a method called `Main`.
  id: totrans-2171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是一个名为`Main`的方法。
- en: It must be static.
  id: totrans-2172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是静态的。
- en: It must have a `void` or `int` return type.
  id: totrans-2173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须有`void`或`int`返回类型。
- en: It must either be parameterless or have a single (non-`ref`, non-`out`) parameter
    of type `string[]`.
  id: totrans-2174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是无参数的，或者有一个单一的非`ref`、非`out`类型的`string[]`参数。
- en: It must be nongeneric and declared in a nongeneric type (including any containing
    types being nongeneric, if it’s declared in a nested type).
  id: totrans-2175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是非泛型的，并且在非泛型类型中声明（包括任何包含的非泛型类型，如果它在嵌套类型中声明）。
- en: It can’t be a partial method without implementation.
  id: totrans-2176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能是一个没有实现的部分方法。
- en: It can’t have the `async` modifier.
  id: totrans-2177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能有`async`修饰符。
- en: With C# 7.1, the final requirement has been dropped but with a slightly different
    requirement around the return type. In C# 7.1, you can write an async entry point
    (still called `Main`, not `MainAsync`), but it has to have a return type of either
    `Task` or `Task<int>` corresponding to a synchronous return type of `void` or
    `int`. Unlike most async methods, an async entry point can’t have a return type
    of `void` or use a custom task type.
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.1中，最终要求已经被取消，但关于返回类型的要求略有不同。在C# 7.1中，您可以编写一个异步入口点（仍然称为`Main`，而不是`MainAsync`），但它必须有`Task`或`Task<int>`的返回类型，对应于同步返回类型`void`或`int`。与大多数异步方法不同，异步入口点不能有`void`返回类型或使用自定义任务类型。
- en: Beyond that, it’s a regular async method. For example, the following listing
    shows an async entry point that prints two lines to the console with a delay between
    them.
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，它就是一个普通的异步方法。例如，以下列表显示了一个异步入口点，该入口点在控制台打印两行文本，并在它们之间有延迟。
- en: Listing 5.12\. A simple async entry point
  id: totrans-2180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.12\. 一个简单的异步入口点
- en: '[PRE244]'
  id: totrans-2181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'The compiler handles async entry points by creating a synchronous wrapper method
    that it marks as the real entry point into the assembly. The wrapper method is
    either parameterless or has a `string[]` parameter and either returns `void` or
    `int`, depending on what the async entry point has in terms of parameters and
    return type. The wrapper method calls the real code and then calls `GetAwaiter()`
    on the returned task and `GetResult()` on the awaiter. For example, the wrapper
    method generated for [listing 5.11](kindle_split_020_split_000.html#ch05ex11)
    would look something like this:'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过创建一个同步包装方法来处理异步入口点，并将其标记为进入程序集的真实入口点。包装方法要么是无参数的，要么有一个`string[]`参数，要么返回`void`，要么返回`int`，具体取决于异步入口点的参数和返回类型。包装方法调用实际代码，然后对返回的任务调用`GetAwaiter()`，对等待者调用`GetResult()`。例如，为[列表5.11](kindle_split_020_split_000.html#ch05ex11)生成的包装方法可能看起来像这样：
- en: '[PRE245]'
  id: totrans-2183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '***1* Method has a name that’s invalid in C# but valid in IL.**'
  id: totrans-2184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 方法在C#中名称无效但在IL中有效。**'
- en: Async entry points are handy for writing small tools or exploratory code that
    uses an async-oriented API such as Roslyn.
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: 异步入口点对于编写使用异步API（如Roslyn）的小工具或探索性代码来说非常方便。
- en: Those are all the async features from a language perspective. But knowing the
    capabilities of the language is different from knowing how to use those capabilities
    effectively. That’s particularly true for asynchrony, which is an inherently complex
    topic.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是从语言角度的异步功能。但了解语言的能力与了解如何有效地使用这些能力是不同的。这对于异步来说尤其如此，因为异步是一个本质上复杂的话题。
- en: 5.10\. Usage tips
  id: totrans-2187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.10\. 使用技巧
- en: This section could never be a complete guide to using asynchrony effectively;
    that could fill an entire book on its own. We’re coming to the end of a chapter
    that’s already long, so I’ve restrained myself to offer just the most important
    tips in my experience. I strongly encourage you to read the perspectives of other
    developers. In particular, Stephen Cleary and Stephen Toub have written reams
    of blog posts and articles that go into many aspects in great depth. In no particular
    order, this section provides the most useful suggestions I can make reasonably
    concisely.
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 本节永远不能成为有效使用异步的完整指南；那可以填满一本整本书。我们即将结束一个已经非常长的章节，所以我只限制自己提供我经验中最重要的一些提示。我强烈建议您阅读其他开发者的观点。特别是，Stephen
    Cleary和Stephen Toub已经撰写了大量博客文章和文章，深入探讨了众多方面。不分先后，本节提供了我可以合理简洁地提出的最有用的建议。
- en: 5.10.1\. Avoid context capture by using ConfigureAwait (where appropriate)
  id: totrans-2189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.10.1\. 使用ConfigureAwait（在适当的情况下）避免上下文捕获
- en: In [sections 5.2.2](kindle_split_020_split_000.html#ch05lev2sec4) and [5.6.2](kindle_split_020_split_000.html#ch05lev2sec11),
    I described synchronization contexts and their effect on the `await` operator.
    For example, if you’re running on a UI thread in WPF or Win-Forms and you await
    an asynchronous operation, the UI synchronization context and the async infrastructure
    make sure that the continuation that runs *after* the `await` operator still runs
    on that same UI thread. That’s exactly what you want in UI code, because you can
    then safely access the UI afterward.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5.2.2节](kindle_split_020_split_000.html#ch05lev2sec4)和[5.6.2节](kindle_split_020_split_000.html#ch05lev2sec11)中，我描述了同步上下文及其对`await`操作符的影响。例如，如果你在WPF或Win-Forms的UI线程上运行，并等待一个异步操作，UI同步上下文和异步基础设施将确保在`await`操作符之后运行的延续仍然在同一个UI线程上执行。这正是UI代码所希望看到的，因为这样你就可以在之后安全地访问UI。
- en: But when you’re writing library code—or code in an application that doesn’t
    touch the UI—you don’t want to come back to the UI thread, even if you were originally
    running in it. In general, the less code that executes in the UI thread, the better.
    This allows the UI to update more smoothly and avoids the UI thread being a bottleneck.
    Of course, if you’re writing a UI library, you probably do want to return to the
    UI thread, but most libraries—for business logic, web services, database access
    and the like—don’t need this.
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你正在编写库代码——或者编写不接触UI的应用程序代码时——你不想回到UI线程，即使你最初就是在它上面运行的。一般来说，在UI线程上执行的代码越少，越好。这可以让UI更新得更平滑，并避免UI线程成为瓶颈。当然，如果你正在编写UI库，你可能确实想回到UI线程，但大多数库——如业务逻辑、网络服务、数据库访问等——并不需要这样做。
- en: 'The `ConfigureAwait` method is designed precisely for this purpose. It takes
    a parameter that determines whether the returned awaitable will capture the context
    when it’s awaited. In practice, I think I’ve always seen the value `false` passed
    in as an argument. In library code, you wouldn’t write the page-length-fetching
    code as you saw it earlier:'
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureAwait`方法正是为此目的而设计的。它接受一个参数，用于确定返回的awaitable在等待时是否会捕获上下文。在实践中，我想我总是看到将值`false`作为参数传递。在库代码中，你不会像之前看到的那样编写页面长度获取代码：'
- en: '[PRE246]'
  id: totrans-2193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '***1* Imagine more code here**'
  id: totrans-2194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 想象更多的代码在这里**'
- en: 'Instead, you’d call `ConfigureAwait(false)` on the task returned by `client.GetStringAsync(url)`
    and await the result:'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你会在`client.GetStringAsync(url)`返回的任务上调用`ConfigureAwait(false)`并等待结果：
- en: '[PRE247]'
  id: totrans-2196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '***1* Same additional code**'
  id: totrans-2197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 相同的附加代码**'
- en: 'I’ve cheated a little here by using implicit typing for the `fetchTextTask`
    variable. In the first example, it’s a `Task<int>`; in the second, it’s a `ConfiguredTaskAwaitable<int>`.
    Most code I’ve seen awaits the result directly anyway, though, like this:'
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里稍微作弊了一下，为`fetchTextTask`变量使用了隐式类型。在第一个例子中，它是一个`Task<int>`；在第二个例子中，它是一个`ConfiguredTaskAwaitable<int>`。然而，我看到的绝大多数代码都是直接等待结果，就像这样：
- en: '[PRE248]'
  id: totrans-2199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: The result of calling `ConfigureAwait(false)` is that the continuation won’t
    be scheduled against the original synchronization context; it’ll execute on a
    thread-pool thread. Note that the behavior differs from the original code only
    if the task hasn’t already completed by the time it’s awaited. If it has already
    completed, the method continues executing synchronously, even in the face of `ConfigureAwait(false)`.
    Therefore, every task you await in a library should be configured like this. You
    can’t just call `ConfigureAwait(false)` on the first task in an async method and
    rely on the rest of the method executing on a thread-pool thread.
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`ConfigureAwait(false)`的结果是，延续不会针对原始同步上下文进行调度；它将在线程池线程上执行。请注意，只有当任务在等待时还没有完成，这种行为才会与原始代码不同。如果它已经完成，即使在`ConfigureAwait(false)`的情况下，方法也会继续同步执行。因此，在库中等待的每个任务都应该这样配置。你不可能只在异步方法中的第一个任务上调用`ConfigureAwait(false)`并依赖于方法的其他部分在线程池线程上执行。
- en: All of this means you need to be careful when writing library code. I expect
    that eventually a better solution may exist (setting the default for a whole assembly,
    for example), but for the moment, you need to be vigilant. I recommend using a
    Roslyn analyzer to spot where you’ve forgotten to configure a task before awaiting
    it. I’ve had positive experiences with the `ConfigureAwaitChecker.Analyzer` NuGet
    package, but others are available, too.
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都意味着你在编写库代码时需要小心。我预计最终可能存在更好的解决方案（例如，设置整个程序集的默认值），但到目前为止，你需要保持警惕。我建议使用Roslyn分析器来查找你忘记在等待之前配置任务的地方。我使用`ConfigureAwaitChecker.Analyzer`
    NuGet包有积极的体验，但其他分析器也是可用的。
- en: In case you’re worried about what this does to the caller, you don’t need to
    be. Suppose the caller is awaiting the task returned by `GetPageLengthAsync` and
    then updating a user interface to display the result. Even if the continuation
    within `GetPageLengthAsync` runs on a thread-pool thread, the `await` expression
    performed in the UI code will capture the UI context and schedule *its* continuation
    to run on the UI thread, so the UI can still be updated after that.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心这会对调用者造成什么影响，你不必担心。假设调用者正在等待`GetPageLengthAsync`返回的任务，然后更新用户界面以显示结果。即使`GetPageLengthAsync`中的延续在线程池线程上运行，UI代码中执行的`await`表达式也会捕获UI上下文并安排*它*的延续在UI线程上运行，因此UI仍然可以在之后更新。
- en: 5.10.2\. Enable parallelism by starting multiple independent tasks
  id: totrans-2203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.10.2\. 通过启动多个独立任务启用并行性
- en: 'In [section 5.6.1](kindle_split_020_split_000.html#ch05lev2sec10), you looked
    at multiple pieces of code to achieve the same goal: find out how much to pay
    an employee based on their hourly rate and how many hours they’d worked. The last
    two pieces of code were like this:'
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5.6.1节](kindle_split_020_split_000.html#ch05lev2sec10)中，你查看了几段代码以实现相同的目标：找出根据员工的时薪和工时来确定应支付多少工资。最后两段代码如下所示：
- en: '[PRE249]'
  id: totrans-2205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: and this
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: 和这个
- en: '[PRE250]'
  id: totrans-2207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: In addition to being shorter, the second piece of code introduces parallelism.
    Both tasks can be started independently, because you don’t need the output of
    the second task as input into the first task. This doesn’t mean that the async
    infrastructure creates any more threads. For example, if the two asynchronous
    operations here are web services, both requests to the web services can be in
    flight without any threads being blocked on the result.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更短之外，第二段代码引入了并行性。两个任务可以独立启动，因为你不需要第二个任务的输出作为第一个任务的输入。这并不意味着异步基础设施创建了更多的线程。例如，如果这里的两个异步操作是网络服务，那么对网络服务的两个请求可以在没有任何线程被阻塞在结果上时同时进行。
- en: 'The shortness aspect is only incidental here. If you want the parallelism but
    like having the separate variables, that’s fine:'
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: 短小在这里只是附带的好处。如果你想要并行性但喜欢有单独的变量，那也行：
- en: '[PRE251]'
  id: totrans-2210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: The only difference between this and the original code is that I swapped the
    second and third lines. Instead of awaiting `hourlyRateTask` and then starting
    `hoursWorkedTask`, you start both tasks and then await both tasks.
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始代码之间的唯一区别是我交换了第二行和第三行。不是等待`hourlyRateTask`然后启动`hoursWorkedTask`，而是同时启动两个任务，然后等待两个任务。
- en: In most cases, if you can perform independent work in parallel, it’s a good
    idea to do so. Be aware that if `hourlyRateTask` fails, you won’t observe the
    result of `hoursWorkedTask`, including any failures in that task. If you need
    to log all task failures, for example, you might want to use `Task.WhenAll` instead.
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，如果你可以并行执行独立的工作，那么这样做是个好主意。请注意，如果`hourlyRateTask`失败，你将不会观察到`hoursWorkedTask`的结果，包括该任务中的任何失败。例如，如果你需要记录所有任务失败，你可能想使用`Task.WhenAll`。
- en: Of course, this sort of parallelization relies on the tasks being independent
    to start with. In some cases, the dependency may not be entirely obvious. If you
    have one task that’s authenticating a user and another task performing an action
    on their behalf, you’d want to wait until you’d checked the authentication before
    starting the action, even if you *could* write the code to execute in parallel.
    The async/await feature can’t make these decisions for you, but it makes it easy
    to parallelize asynchronous operations when you’ve decided that it’s appropriate.
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种并行化依赖于任务一开始就是独立的。在某些情况下，依赖关系可能并不完全明显。如果你有一个任务正在验证用户身份，另一个任务代表他们执行操作，你希望在开始操作之前等待验证完成，即使*可以*编写并行执行的代码。异步/等待特性不能为你做出这些决定，但它使得在决定适当的情况下并行化异步操作变得容易。
- en: 5.10.3\. Avoid mixing synchronous and asynchronous code
  id: totrans-2214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.10.3\. 避免混合同步和异步代码
- en: Although asynchrony isn’t entirely all or nothing, it gets much harder to implement
    correctly when some of your code is synchronous and other parts are asynchronous.
    Switching between the two approaches is fraught with difficulties—some subtle,
    others less so. If you have a network library that exposes only synchronous operations,
    writing an asynchronous wrapper for those operations is difficult to do safely,
    and likewise in reverse.
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异步不是完全非此即彼，但当你的代码中既有同步部分又有异步部分时，正确实现会变得更加困难。在两种方法之间切换充满了困难——有些微妙，有些不那么微妙。如果你有一个只公开同步操作的网络库，为这些操作编写异步包装器是难以安全完成的，反之亦然。
- en: In particular, be aware of the dangers of using the `Task<TResult>.Result` property
    and `Task.Wait()` methods to try to synchronously retrieve the result of an asynchronous
    operation. This can easily lead to deadlock. In the most common case, the asynchronous
    operation requires a continuation to execute in a thread that’s blocked, waiting
    for the operation to compete.
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意使用`Task<TResult>.Result`属性和`Task.Wait()`方法来尝试同步检索异步操作的结果的危险。这很容易导致死锁。在最常见的情况下，异步操作需要在被阻塞等待操作完成的线程上执行后续操作。
- en: 'Stephen Toub has a pair of excellent and detailed blog posts on this topic:
    “Should I expose synchronous wrappers for asynchronous methods?” and “Should I
    expose asynchronous wrappers for synchronous methods?” (Spoiler alert: the answer
    is no in both cases, as you’ve probably guessed.) As with all rules, there are
    exceptions, but I strongly advise that you make sure you thoroughly understand
    the rule before breaking it.'
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: Stephen Toub关于这个主题有两篇优秀且详细的博客文章：“我应该为异步方法公开同步包装器吗？”和“我应该为同步方法公开异步包装器吗？”（剧透：正如你可能猜到的，两种情况下的答案都是否定的。）与所有规则一样，总有一些例外，但我强烈建议你在打破规则之前彻底理解规则。
- en: 5.10.4\. Allow cancellation wherever possible
  id: totrans-2218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.10.4\. 尽可能允许取消
- en: Cancellation is one area that doesn’t have a strong equivalent in synchronous
    code, where you usually have to wait for a method to return before continuing.
    The ability to cancel an asynchronous operation is extremely powerful, but it
    does rely on cooperation throughout the stack. If you want to use a method that
    doesn’t allow you to pass in a cancellation token, there’s not an awful lot you
    can do about it. You can write somewhat-intricate code so that your async method
    completes with a canceled status and ignore the final result of the noncancelable
    task, but that’s far from ideal. You really want to be able to stop any work in
    progress, and you also don’t want to have to worry about any disposable resources
    that could be returned by the asynchronous method when it does eventually complete.
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: 取消是一个在同步代码中没有强大对应物的领域，在同步代码中，你通常必须等待方法返回才能继续。取消异步操作的能力非常强大，但它确实依赖于整个堆栈的合作。如果你想要使用不允许你传递取消令牌的方法，你几乎无能为力。你可以编写一些复杂的代码，以便你的异步方法以取消状态完成，并忽略不可取消任务的最终结果，但这远非理想。你真正想要的是能够停止任何正在进行的工作，而且你也不想担心异步方法最终完成时可能返回的任何可丢弃的资源。
- en: Fortunately, most low-level asynchronous APIs do expose a cancellation token
    as a parameter. All you need to do is follow the same pattern yourself, typically
    passing the same cancellation token you receive in the parameter as an argument
    to all asynchronous methods you call. Even if you don’t currently have any requirements
    to allow cancellation, I advise providing the option consistently right from the
    start, because it’s painful to add later.
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数低级异步API确实将取消令牌作为参数暴露出来。你所需要做的就是遵循相同的模式，通常是将你在参数中接收到的相同的取消令牌作为参数传递给所有你调用的异步方法。即使你目前没有允许取消的要求，我也建议从一开始就提供这一选项，因为后来添加它会很痛苦。
- en: Again, Stephen Toub has an excellent blog post on the subtle difficulties of
    trying to work around noncancelable asynchronous operations. Search for “How do
    I cancel non-cancelable async operations?” to find it.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Stephen Toub有一篇关于尝试绕过不可取消的异步操作的微妙困难的优秀博客文章。搜索“如何取消不可取消的异步操作？”以找到它。
- en: 5.10.5\. Testing asynchrony
  id: totrans-2222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.10.5\. 测试异步
- en: Testing asynchronous code can be extremely tricky, particularly if you want
    to test the asynchrony itself. (Tests that answer questions such as “What happens
    if I cancel the operation between the second and third asynchronous calls within
    the method?” require quite elaborate work.)
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异步代码可能非常棘手，尤其是如果你想测试异步本身。例如，“如果在方法中的第二次和第三次异步调用之间取消操作会发生什么？”这样的测试需要相当复杂的工作。
- en: It’s not impossible, but be prepared for an uphill battle if you want to test
    comprehensively. When I wrote the third edition of this book, I hoped that by
    2019 there would be robust frameworks to make all of this relatively simple. Unfortunately,
    I’m disappointed.
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 这并非不可能，但如果要进行全面测试，则要做好打一场艰难的战斗的准备。当我撰写这本书的第三版时，我希望到2019年会有稳健的框架使所有这些相对简单。不幸的是，我感到失望。
- en: 'Most unit-test frameworks do have support for asynchronous tests, however.
    That support is pretty much vital to write tests for asynchronous methods, for
    all the reasons I mentioned before about the difficulties in mixing synchronous
    and asynchronous code. Typically, writing an asynchronous test is as simple as
    writing a test method with the `async` modifier and declaring it to return `Task`
    instead of `void`:'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数单元测试框架都支持异步测试。这种支持对于编写异步方法的测试来说几乎是必不可少的，原因如我之前提到的，混合同步和异步代码的困难。通常，编写一个异步测试就像编写一个带有
    `async` 修饰符的测试方法，并声明它返回 `Task` 而不是 `void` 一样简单：
- en: '[PRE252]'
  id: totrans-2226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '***1* Code to test your FooAsync production method**'
  id: totrans-2227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1. 测试你的 FooAsync 生产方法的代码**'
- en: Test frameworks often provide an `Assert.ThrowsAsync` method for testing that
    a call to an asynchronous method returns a task that eventually becomes faulted.
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架通常提供了一个 `Assert.ThrowsAsync` 方法来测试异步方法的调用最终返回一个变成故障的任务。
- en: When testing asynchronous code, often you’ll want to create a task that’s already
    completed, with a particular result or fault. The methods `Task.FromResult`, `Task.FromException`,
    and `Task.FromCanceled` are useful here.
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试异步代码时，你通常会想要创建一个已经完成的任务，并带有特定的结果或错误。`Task.FromResult`、`Task.FromException`
    和 `Task.FromCanceled` 方法在这里非常有用。
- en: For more flexibility, you can use `TaskCompletionSource<TResult>`. This type
    is used by a lot of the async infrastructure in the framework. It effectively
    allows you to create a task representing an ongoing operation and then set the
    result (including any exception or cancellation) later, at which point the task
    will complete. This is extremely useful when you want to return a task from a
    mocked dependency but make that returned task complete later in the test.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更大的灵活性，你可以使用 `TaskCompletionSource<TResult>`。这种类型在框架的许多异步基础设施中被使用。它有效地允许你创建一个表示正在进行的操作的任务，然后在稍后设置结果（包括任何异常或取消），此时任务将完成。当你想要从模拟的依赖项返回一个任务，但希望在测试中稍后完成该任务时，这非常有用。
- en: One aspect of `TaskCompletionSource<TResult>` to know about is that when you
    set the result, continuations attached to the associated task can run synchronously
    on the same thread. The exact details of how the continuations are run depend
    on various aspects of the threads and synchronization contexts involved, and after
    you’re aware of it as a possibility, it’s relatively easy to take account of.
    Now you’re aware and can hopefully avoid wasting the time being baffled in the
    way that I was.
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `TaskCompletionSource<TResult>` 有一个方面需要了解，那就是当你设置结果时，附加到相关任务上的延续可以在同一线程上同步运行。延续如何运行的精确细节取决于涉及的线程和同步上下文的各个方面，在你意识到这是一个可能性之后，相对容易考虑到这一点。现在你已经意识到了，希望可以避免像我曾经那样浪费时间感到困惑。
- en: This is an incomplete summary of what I’ve learned over the last four years
    or so of writing asynchronous code, but I don’t want to lose sight of the topic
    of the book (the C# language, not asynchrony). You’ve seen what the async/await
    feature does, from the developer’s perspective. You haven’t looked at what happens
    under the hood in any detail yet, although the awaitable pattern provides some
    clues.
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我过去四五年编写异步代码所学到的知识的不完整总结，但我不想失去本书主题（C# 语言，而不是异步）的焦点。你已经从开发者的角度看到了 async/await
    功能的作用，但你还没有详细查看底层发生了什么，尽管可等待模式提供了一些线索。
- en: If you haven’t played with async/await yet, I *strongly* advise that you do
    so now, before taking on the next chapter, which looks at the implementation details.
    Those details are important but are tricky to understand at the best of times
    and will be hard to understand if you don’t have some experience of using async/await.
    If you don’t have that experience yet and don’t particularly want to put the time
    in right now, I advise skipping the next chapter for now. It’s only about the
    implementation details of asynchrony; I promise you won’t miss anything else.
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有尝试过 async/await，我强烈建议你在开始下一章之前先尝试一下，下一章将探讨实现细节。这些细节很重要，但在最好的情况下也难以理解，如果你没有使用
    async/await 的经验，理解起来会更困难。如果你还没有这种经验，现在也不特别想花时间，我建议你现在跳过下一章。它只关于异步的实现细节；我保证你不会错过任何其他内容。
- en: Summary
  id: totrans-2234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The core of asynchrony is about starting an operation and then later continuing
    when the operation has completed without having to block in the middle.
  id: totrans-2235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步的核心是关于开始一个操作，然后在操作完成时继续，而不需要在中间阻塞。
- en: Async/await allows you to write familiar-looking code that acts asynchronously.
  id: totrans-2236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Async/await 允许你编写看起来熟悉的异步代码。
- en: Async/await handles synchronization contexts so UI code can start an asynchronous
    operation and then continue on the UI thread when that operation has finished.
  id: totrans-2237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Async/await 处理同步上下文，以便UI代码可以在异步操作完成后在UI线程上继续执行。
- en: Successful results and exceptions are propagated through asynchronous operations.
  id: totrans-2238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步操作中的成功结果和异常会传播。
- en: Restrictions limit where you can use the `await` operator, but C# 6 (and later)
    versions have fewer restrictions than C# 5.
  id: totrans-2239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制条件限制了你可以使用 `await` 操作符的位置，但C# 6（及以后）版本的限制比C# 5少。
- en: The compiler uses the awaitable pattern to determine which types can be awaited.
  id: totrans-2240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器使用可等待模式来确定哪些类型可以被等待。
- en: C# 7 allows you to create your own custom task type, but you almost certainly
    want to use `ValueTask<TResult>`.
  id: totrans-2241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7 允许你创建自己的自定义任务类型，但你几乎肯定想使用 `ValueTask<TResult>`。
- en: C# 7.1 allows you to write async `Main` methods as program entry points.
  id: totrans-2242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7.1 允许你将异步 `Main` 方法作为程序入口点。
- en: Chapter 6\. Async implementation
  id: totrans-2243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 异步实现
- en: '|  |'
  id: totrans-2244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: The structure of asynchronous code
  id: totrans-2246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步代码的结构
- en: Interacting with the framework builder types
  id: totrans-2247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与框架构建器类型交互
- en: Performing a single step in an async method
  id: totrans-2248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异步方法中执行单个步骤
- en: Understanding execution context flow across await expressions
  id: totrans-2249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 await 表达式之间的执行上下文流
- en: Interacting with custom task types
  id: totrans-2250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与自定义任务类型交互
- en: '|  |'
  id: totrans-2251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: I vividly remember the evening of October 28, 2010\. Anders Hejlsberg was presenting
    async/await at PDC, and shortly before his talk started, an avalanche of downloadable
    material was made available, including a draft of the changes to the C# specification,
    a Community Technology Preview (CTP) of the C# 5 compiler, and the slides Anders
    was presenting. At one point, I was watching the talk live and skimming through
    the slides while the CTP installed. By the time Anders had finished, I was writing
    async code and trying things out.
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 我清晰地记得2010年10月28日晚。安德斯·海尔斯伯格在PDC上介绍 async/await，在他的演讲开始前不久，大量可下载的材料被发布，包括C#规范变更的草案、C#
    5编译器的社区技术预览（CTP），以及安德斯将要展示的幻灯片。在某个时刻，我正在实时观看演讲并快速浏览幻灯片，同时CTP正在安装。当安德斯演讲结束时，我正在编写异步代码并尝试各种操作。
- en: 'In the next few weeks, I started taking bits apart and looking at exactly what
    code the compiler was generating, trying to write my own simplistic implementation
    of the library that came with the CTP, and generally poking at it from every angle.
    As new versions came out, I worked out what had changed and became more and more
    comfortable with what was going on behind the scenes. The more I saw, the more
    I appreciated how much boilerplate code the compiler is happy to write on our
    behalf. It’s like looking at a beautiful flower under a microscope: the beauty
    is still there to be admired, but there’s so much more to it than can be seen
    at first glance.'
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几周里，我开始拆解代码，查看编译器生成的确切代码，试图编写与CTP一起提供的库的简单实现，并从各个角度对其进行检查。随着新版本的发布，我了解了发生了什么变化，并对幕后发生的事情越来越熟悉。我看到的越多，就越欣赏编译器为我们编写的样板代码。这就像在显微镜下观察一朵美丽的花朵：美丽依然存在，但其中还有更多东西超出了第一眼所见。
- en: Not everyone is like me, of course. If you just want to rely on the behavior
    I’ve already described and simply trust that the compiler will do the right thing,
    that’s absolutely fine. Alternatively, you won’t miss out on anything if you skip
    this chapter for now and come back to it at a later date; none of the rest of
    the book relies on it. It’s unlikely that you’ll ever have to debug your code
    down to the level that you’ll look at here, but I believe this chapter will give
    you more insight into how async/await hangs together. Both the awaitable pattern
    and the requirements for custom task types make more sense after you’ve looked
    at the generated code. I don’t want to get too mystical about this, but there’s
    a certain connection between the language and the developer that’s enriched by
    studying these implementation details.
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并不是每个人都像我一样。如果你只想依赖我已经描述的行为，并且简单地相信编译器会做正确的事情，那绝对是完全可以的。或者，如果你现在跳过这一章，稍后再回来，你也不会错过任何内容；这本书的其余部分都不依赖于它。你不太可能需要将你的代码调试到这里的程度，但我相信这一章会给你更多关于
    async/await 如何协同工作的洞察。在查看生成的代码之后，可等待模式和对自定义任务类型的要求会更有意义。我不想对此过于神秘化，但通过研究这些实现细节，语言和开发者之间确实存在某种联系，这种联系因研究这些实现细节而变得更加丰富。
- en: As a rough approximation, we’ll pretend that the C# compiler performs a transformation
    from C# code using async/await to C# code without using async/await. Of course,
    the compiler is able to operate at a lower level than this with intermediate representations
    that can be emitted as IL. Indeed, in some aspects of async/await, the IL generated
    can’t be represented in regular C#, but it’s easy enough to explain those places.
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种粗略的近似，我们将假设 C# 编译器将使用 async/await 的 C# 代码转换成不使用 async/await 的 C# 代码。当然，编译器能够以比这更低的级别操作，使用可以发出
    IL 的中间表示形式。实际上，在 async/await 的某些方面，生成的 IL 无法用常规的 C# 表示，但解释这些地方很容易。
- en: '|  |'
  id: totrans-2256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Debug and release builds differ, and future implementations may, too**'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试和发布构建不同，未来的实现可能也是如此**'
- en: 'While writing this chapter, I became aware of a difference between debug and
    release builds of async code: in debug builds, the generated state machines are
    classes rather than structs. (This is to give a better debugger experience; in
    particular, it gives more flexibility in Edit and Continue scenarios.) This wasn’t
    true when I wrote the third edition; the compiler implementation has changed.
    It may change again in the future, too. If you decompile async code compiled by
    a C# 8 compiler, it could look slightly different from what’s presented here.'
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这一章的过程中，我意识到异步代码的调试和发布构建之间存在差异：在调试构建中，生成的状态机是类而不是结构体。（这是为了提供更好的调试体验；特别是，它为编辑和继续场景提供了更多的灵活性。）在我编写第三版时并非如此；编译器实现已经改变。未来也可能再次改变。如果你反编译由
    C# 8 编译器编译的异步代码，它可能看起来与这里展示的略有不同。
- en: Although this is surprising, it shouldn’t be too alarming. By definition, implementation
    details can change over time. None of this invalidates any of the insight to be
    gained from studying a particular implementation. Just be aware that this is a
    different kind of learning from “these are the rules of C#, and they’ll change
    only in well-specified ways.”
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很令人惊讶，但也不应该过于令人担忧。根据定义，实现细节可能会随时间而改变。这并不会使从研究特定实现中获得的所有洞察力失效。只需意识到，这与“这些是
    C# 的规则，并且它们只会以良好定义的方式改变”这种学习方式不同。
- en: In this chapter, I show the code generated by a release build. The differences
    mostly affect performance, and I believe most readers will be more interested
    in the performance of release builds than debug builds.
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将展示发布构建生成的代码。这些差异主要影响性能，我相信大多数读者对发布构建的性能比对调试构建的性能更感兴趣。
- en: '|  |'
  id: totrans-2261
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The generated code is somewhat like an onion; it has layers of complexity.
    We’ll start from the very outside and work our way in toward the tricky bit: await
    expressions and the dance of awaiters and continuations. For the sake of brevity,
    I’m going to present only asynchronous methods, not async anonymous functions;
    the machinery between the two is the same anyway, so there’s nothing particularly
    interesting to learn by repeating the work.'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码有点像洋葱；它有复杂的层次结构。我们将从最外面开始，逐步深入到棘手的部分：await 表达式和 awaiter 与 continuation
    的舞蹈。为了简洁起见，我将只展示异步方法，而不是异步匿名函数；两者之间的机制是一样的，所以重复这项工作没有什么特别有趣的内容可以学习。
- en: 6.1\. Structure of the generated code
  id: totrans-2263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 生成代码的结构
- en: As I mentioned in [chapter 5](kindle_split_020_split_000.html#ch05), the implementation
    (both in this approximation and in the code generated by the real compiler) is
    in the form of a *state machine*. The compiler will generate a private nested
    struct to represent the asynchronous method, and it must also include a method
    with the same signature as the one you’ve declared. I call this the *stub method*;
    there’s not much to it, but it starts all of the rest going.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在[第5章](kindle_split_020_split_000.html#ch05)中提到的，实现（无论是这种近似还是由真实编译器生成的代码）都是以状态机的形式进行的。编译器将生成一个私有的嵌套结构来表示异步方法，并且它还必须包含一个与您声明的签名相同的函数。我称这个为*存根方法*；它并没有什么特别的，但它启动了所有其他的过程。
- en: '|  |'
  id: totrans-2265
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-2266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'Frequently, I’m going to talk about the state machine *pausing*. This corresponds
    to a point where the async method reaches an await expression and the operation
    being awaited hasn’t completed yet. As you may remember from [chapter 5](kindle_split_020_split_000.html#ch05),
    when that happens, a continuation is scheduled to execute the rest of the async
    method when the awaited operation has completed, and then the async method returns.
    Similarly, it’s useful to talk about the async method taking a *step*: the code
    it executes between pauses, effectively. These aren’t official terms, but they’re
    useful as shorthand.'
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，我会谈论状态机的*暂停*。这对应于异步方法达到`await`表达式，而等待的操作尚未完成的情况。如您从[第5章](kindle_split_020_split_000.html#ch05)中记得的那样，当这种情况发生时，会安排一个延续来在等待的操作完成后执行异步方法的其余部分，然后异步方法返回。同样，谈论异步方法采取*步骤*也很有用：它在暂停之间执行的代码。这些不是官方术语，但作为缩写很有用。
- en: '|  |'
  id: totrans-2268
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The state machine keeps track of where you are within the async method. Logically,
    there are four kinds of state, in common execution order:'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机跟踪你在异步方法中的位置。从逻辑上讲，有四种状态，按常见的执行顺序如下：
- en: Not started
  id: totrans-2270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未开始
- en: Executing
  id: totrans-2271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行中
- en: Paused
  id: totrans-2272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停
- en: Complete (either successfully or faulted)
  id: totrans-2273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成（无论是成功还是故障）
- en: Only the Paused set of states depends on the structure of the async method.
    Each await expression within the method is a distinct state to be returned to
    in order to trigger more execution. While the state machine is executing, it doesn’t
    need to keep track of the exact piece of code that’s executing; at that point,
    it’s just regular code, and the CPU keeps track of the instruction pointer just
    as with synchronous code. The state is recorded when the state machine needs to
    pause; the whole purpose is to allow it to continue the code execution later from
    the point it reached. [Figure 6.1](kindle_split_021_split_000.html#ch06fig01)
    shows the transitions between the possible states.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 只有暂停的状态集依赖于异步方法的结构。方法内的每个`await`表达式都是一个独特的状态，以便返回以触发更多执行。当状态机正在执行时，它不需要跟踪正在执行的精确代码片段；在那个点上，它只是常规代码，CPU就像同步代码一样跟踪指令指针。状态是在状态机需要暂停时记录的；整个目的就是允许它从达到的点继续代码执行。[图6.1](kindle_split_021_split_000.html#ch06fig01)显示了可能状态之间的转换。
- en: Figure 6.1\. State transition diagram
  id: totrans-2275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 状态转换图
- en: '![](../Images/06fig01.jpg)'
  id: totrans-2276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig01.jpg)'
- en: Let’s make this concrete with a real piece of code. The following listing shows
    a simple async method. It’s not quite as simple as you could make it, but it can
    demonstrate a few things at the same time.
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个实际的代码片段来具体说明。下面的列表显示了一个简单的异步方法。它并不像你可以让它那样简单，但它可以同时演示几个事情。
- en: Listing 6.1\. Simple introductory async method
  id: totrans-2278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 简单的异步方法介绍
- en: '[PRE253]'
  id: totrans-2279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Three points to note at this stage are as follows:'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段有三个需要注意的点：
- en: You have a parameter that you’ll need to use in the state machine.
  id: totrans-2281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个参数需要在状态机中使用。
- en: The method includes two await expressions.
  id: totrans-2282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法包含两个`await`表达式。
- en: The method returns `Task`, so you need to return a task that will complete after
    the final line is printed, but there’s no specific result.
  id: totrans-2283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法返回`Task`，因此你需要返回一个任务，该任务将在最后一行打印后完成，但没有特定的结果。
- en: This is nice and simple because you have no loops or `try`/`catch`/`finally`
    blocks to worry about. The control flow is simple, apart from the awaiting, of
    course. Let’s see what the compiler generates for this code.
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，也很简单，因为你没有循环或需要担心的`try`/`catch`/`finally`块。控制流程很简单，当然，除了等待之外。让我们看看编译器为这段代码生成了什么。
- en: '|  |'
  id: totrans-2285
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Do try this at home**'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: '**请务必在家尝试**'
- en: I typically use a mixture of ildasm and Redgate Reflector for this sort of work,
    setting the Optimization level to C# 1 to prevent the decompiler from reconstructing
    the async method for us. Other decompilers are available, but whichever one you
    pick, I recommend checking the IL as well. I’ve seen subtle bugs in decompilers
    when it comes to `await`, often in terms of the execution order.
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常使用ildasm和Redgate Reflector的混合体来做这类工作，将优化级别设置为C# 1，以防止反编译器为我们重建异步方法。其他反编译器也可用，但无论你选择哪个，我都建议检查IL。我在`await`方面看到过反编译器中的微妙错误，通常与执行顺序有关。
- en: You don’t have to do any of this if you don’t want to, but if you find yourself
    wondering what the compiler does with a particular code construct, and this chapter
    doesn’t provide the answer, just go for it. Don’t forget the difference between
    debug and release builds, though, and don’t be put off by the names generated
    by the compiler, which can make the result harder to read.
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想做这些，那也行，但如果你发现自己想知道编译器对某个特定代码结构做了什么，而这章没有提供答案，那就去做吧。不过，别忘了调试和发布构建之间的区别，也不要被编译器生成的名称所困扰，这些名称可能会使结果更难阅读。
- en: '|  |'
  id: totrans-2289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using the tools available, you can decompile [listing 6.1](kindle_split_021_split_000.html#ch06ex01)
    into something like [listing 6.2](kindle_split_021_split_000.html#ch06ex02). Many
    of the names that the C# compiler generates aren’t valid C#; I’ve rewritten them
    as valid identifiers for the sake of getting runnable code. In other cases, I’ve
    renamed the identifiers to make the code more readable. Later, I’ve taken a few
    liberties with how the cases and labels for the state machine are ordered; it’s
    absolutely logically equivalent to the generated code, but much easier to read.
    In other places, I’ve used a `switch` statement even with only two cases, where
    the compiler might effectively use `if`/`else`. In these places, the `switch`
    statement represents the more general case that can work when there are multiple
    points to jump to, but the compiler can generate simpler code for simpler situations.
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可用的工具，你可以将[列表 6.1](kindle_split_021_split_000.html#ch06ex01)反编译成类似[列表 6.2](kindle_split_021_split_000.html#ch06ex02)的东西。C#
    编译器生成的许多名称都不是有效的 C# 名称；为了得到可运行的代码，我已经将它们重写为有效的标识符。在其他情况下，我已将标识符重命名，使代码更易于阅读。后来，我对状态机的案例和标签的顺序做了一些调整；它与生成的代码在逻辑上是完全等价的，但更容易阅读。在其他地方，即使只有两个案例，我也使用了`switch`语句，而编译器可能会有效地使用`if`/`else`。在这些地方，`switch`语句代表更通用的案例，可以在有多个跳转点时工作，但编译器可以为更简单的情况生成更简单的代码。
- en: Listing 6.2\. Generated code for [listing 6.1](kindle_split_021_split_000.html#ch06ex01)
    (except for `MoveNext`)
  id: totrans-2291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2. [列表 6.1](kindle_split_021_split_000.html#ch06ex01)（除`MoveNext`外）生成的代码
- en: '[PRE254]'
  id: totrans-2292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '***1* Initializes the state machine, including method parameters**'
  id: totrans-2293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 初始化状态机，包括方法参数**'
- en: '***2* Runs the state machine until it needs to wait**'
  id: totrans-2294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 运行状态机直到它需要等待**'
- en: '***3* Returns the task representing the async operation**'
  id: totrans-2295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回表示异步操作的任务**'
- en: '***4* State of the state machine (where to resume)**'
  id: totrans-2296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 状态机的状态（从哪里恢复**）'
- en: '***5* The builder hooking into async infrastructure types**'
  id: totrans-2297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 构建器连接到异步基础设施类型**'
- en: '***6* Awaiter to fetch result from when resuming**'
  id: totrans-2298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在恢复时从其中获取结果的等待者**'
- en: '***7* Original method parameter**'
  id: totrans-2299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 原始方法参数**'
- en: '***8* Main state machine work goes here.**'
  id: totrans-2300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 主要状态机的工作内容在这里。**'
- en: '***9* Connects the builder and the boxed state machine**'
  id: totrans-2301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 连接构建器和装箱状态机**'
- en: This listing looks somewhat complicated already, but I should warn you that
    the bulk of the work is done in the `MoveNext` method, and I’ve completely removed
    the implementation of that for now. The point of [listing 6.2](kindle_split_021_split_000.html#ch06ex02)
    is to set the scene and provide the structure so that when you get to the `MoveNext`
    implementation, it makes sense. Let’s look at the pieces of the listing in turn,
    starting with the stub method.
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表看起来已经相当复杂了，但我应该警告你，大部分工作都是在`MoveNext`方法中完成的，我现在已经完全移除了该方法的实现。列表 6.2 的目的是设定场景并提供结构，这样当你到达`MoveNext`实现时，它就有意义了。让我们依次查看列表的各个部分，从存根方法开始。
- en: '6.1.1\. The stub method: Preparation and taking the first step'
  id: totrans-2303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1. 存根方法：准备和迈出第一步
- en: The stub method from [listing 6.2](kindle_split_021_split_000.html#ch06ex02)
    is simple apart from the `AsyncTaskMethodBuilder`. This is a value type, and it’s
    part of the common async infrastructure. You’ll see over the rest of the chapter
    how the state machine interacts with the builder.
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`AsyncTaskMethodBuilder`之外，[列表6.2](kindle_split_021_split_000.html#ch06ex02)中的存根方法很简单。这是一个值类型，它是通用异步基础设施的一部分。你将在本章的其余部分看到状态机如何与构建器交互。
- en: '[PRE255]'
  id: totrans-2305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'The attributes applied to the method are essentially for tooling. They have
    no effect on regular execution, and you don’t need to know any details about them
    in order to understand the generated asynchronous code. The state machine is always
    created in the stub method with three pieces of information:'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到方法上的属性基本上是为了工具。它们对常规执行没有影响，你不需要了解任何关于它们的细节就能理解生成的异步代码。状态机始终在存根方法中创建，带有三块信息：
- en: Any parameters (in this case, just `delay`), each as separate fields in the
    state machine
  id: totrans-2307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何参数（在这个例子中，就是`delay`），每个都在状态机中作为单独的字段
- en: The builder, which varies depending on the return type of the async method
  id: totrans-2308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建器，它取决于异步方法的返回类型
- en: The initial state, which is always –1
  id: totrans-2309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始状态始终是-1
- en: '|  |'
  id: totrans-2310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-2311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The name `AsyncTaskMethodBuilder` may make you think of reflection, but it’s
    not creating a method in IL or anything like that. The builder provides functionality
    that the generated code uses to propagate success and failure, handle awaiting,
    and so forth. If the name “helper” works better for you, feel free to think of
    it that way.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`AsyncTaskMethodBuilder`可能会让你想到反射，但它并不是在IL中创建方法或类似操作。构建器提供了生成代码用来传播成功和失败、处理等待等功能。如果你觉得“辅助器”这个名字更适合你，请随意这样想。
- en: '|  |'
  id: totrans-2313
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'After creating the state machine, the stub method asks the machine’s builder
    to start it, passing the machine itself by reference. You’ll see quite a lot of
    passing by reference in the following few pages, and this comes down to a need
    for efficiency and consistency. Both the state machine and the `AsyncTaskMethodBuilder`
    are *mutable* value types. Passing `machine` by reference to the `Start` method
    avoids making a copy of the state, which is more efficient and ensures that any
    changes made to the state within `Start` are still visible when the `Start` method
    returns. In particular, the `builder` state within the machine may well change
    during `Start`. That’s why it’s important that you use `machine.builder` for both
    the `Start` call and the `Task` property afterward. Suppose you extracted `machine.builder`
    to a local variable, like this:'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建状态机后，存根方法请求机器的构建器启动它，通过引用传递机器本身。你将在接下来的几页中看到很多通过引用传递的情况，这归结于对效率和一致性的需求。状态机和`AsyncTaskMethodBuilder`都是可变的值类型。通过引用传递`machine`到`Start`方法避免了复制状态，这更高效并确保在`Start`方法返回时，对状态所做的任何更改仍然可见。特别是，机器内部的`builder`状态可能在`Start`期间发生变化。这就是为什么在使用`machine.builder`进行`Start`调用和随后的`Task`属性很重要的原因。假设你将`machine.builder`提取到一个局部变量中，如下所示：
- en: '[PRE256]'
  id: totrans-2315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '***1* Invalid attempt at refactoring**'
  id: totrans-2316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效的重构尝试**'
- en: With that code, state changes made directly within `builder.Start()` wouldn’t
    be seen within `machine.builder` (or vice versa) because it would be a copy of
    the builder. This is where it’s important that `machine.builder` refers to a field,
    not a property. You don’t want to operate on a copy of the builder in the state
    machine; rather, you want to operate directly on the value that the state machine
    contains. This is precisely the sort of detail that you don’t want to have to
    deal with yourself and is why mutable value types and public fields are almost
    always a bad idea. (You’ll see in [chapter 11](kindle_split_028_split_000.html#ch11)
    how they can be useful when carefully considered.)
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用那段代码，在`builder.Start()`内部直接做出的状态更改不会被`machine.builder`（或反之）看到，因为那将是一个构建器的副本。这就是为什么`machine.builder`引用一个字段而不是属性很重要的原因。你不想在状态机中操作构建器的副本；相反，你希望直接操作状态机包含的值。这正是你不想自己处理的细节，也是为什么可变值类型和公共字段几乎总是坏主意的原因。（你将在[第11章](kindle_split_028_split_000.html#ch11)中看到，在仔细考虑的情况下，它们可以是有用的。）
- en: Starting the machine doesn’t create any new threads. It just runs the state
    machine’s `MoveNext()` method until either the state machine needs to pause while
    it awaits another asynchronous operation or completes. In other words, it takes
    one step. Either way, `MoveNext()` returns, at which point `machine.builder.Start()`
    returns, and you can return a task representing the overall asynchronous method
    back to our caller. The builder is responsible for creating the task and ensuring
    that it changes state appropriately over the course of the asynchronous method.
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: 启动机器不会创建任何新线程。它只是运行状态机的`MoveNext()`方法，直到状态机需要暂停以等待另一个异步操作或完成。换句话说，它只迈出一小步。无论如何，`MoveNext()`都会返回，此时`machine.builder.Start()`也会返回，然后你可以返回一个表示整体异步方法的任务给我们的调用者。构建器负责创建任务并确保在异步方法的过程中适当地改变状态。
- en: That’s the stub method. Now let’s look at the state machine itself.
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是存根方法。现在让我们看看状态机本身。
- en: 6.1.2\. Structure of the state machine
  id: totrans-2320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 状态机的结构
- en: 'I’m still omitting the majority of the code from the state machine (in the
    `MoveNext()` method), but here’s a reminder of the structure of the type:'
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然省略了状态机的大部分代码（在`MoveNext()`方法中），但这里是对类型结构的提醒：
- en: '[PRE257]'
  id: totrans-2322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '***1* Implementation omitted**'
  id: totrans-2323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实现省略**'
- en: 'Again, the attributes aren’t important. The important aspects of the type are
    as follows:'
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，属性并不重要。类型的重要方面如下：
- en: It implements the `IAsyncStateMachine` interface, which is used for the async
    infrastructure. The interface has only the two methods shown.
  id: totrans-2325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了`IAsyncStateMachine`接口，该接口用于异步基础设施。该接口只有两个显示的方法。
- en: The fields, which store the information the state machine needs to remember
    between one step and the next.
  id: totrans-2326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段，用于存储状态机在一步与下一步之间需要记住的信息。
- en: The `MoveNext()` method, which is called once when the state machine is started
    and once each time it resumes after being paused.
  id: totrans-2327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveNext()`方法，当状态机启动时调用一次，每次在暂停后恢复时也调用一次。'
- en: The `SetStateMachine()` method, which always has the same implementation (in
    release builds).
  id: totrans-2328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetStateMachine()`方法，它始终具有相同的实现（在发布版本中）。'
- en: 'You’ve seen one use of the type implementing `IAsyncStateMachine` already,
    although it was somewhat hidden: `AsyncTaskMethodBuilder.Start()` is a generic
    method with a constraint that the type parameter has to implement `IAsyncStateMachine`.
    After performing a bit of housekeeping, `Start()` calls `MoveNext()` to make the
    state machine take the first step of the async method.'
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一个实现`IAsyncStateMachine`类型的用法，尽管它有些隐藏：`AsyncTaskMethodBuilder.Start()`是一个泛型方法，其类型参数必须实现`IAsyncStateMachine`。在执行一些家务后，`Start()`调用`MoveNext()`使状态机执行异步方法的第一步。
- en: 'The fields involved can be broadly split into five categories:'
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的字段可以大致分为五类：
- en: The current state (for example, not started, paused at a particular await expression,
    and so forth)
  id: totrans-2331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前状态（例如，未开始、在特定的await表达式处暂停等）
- en: The method builder used to communicate with the async infrastructure and to
    provide the `Task` to return
  id: totrans-2332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法构建器用于与异步基础设施通信并提供要返回的`Task`
- en: Awaiters
  id: totrans-2333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待者
- en: Parameters and local variables
  id: totrans-2334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数和局部变量
- en: Temporary stack variables
  id: totrans-2335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时栈变量
- en: 'The state and builder are fairly simple. The state is just an integer with
    one of the following values:'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和构建器相当简单。状态只是一个具有以下值的整数：
- en: '*–1*—Not started, or currently executing (it doesn’t matter which)'
  id: totrans-2337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*–1*—未开始，或当前正在执行（无论哪种情况）'
- en: '*–2*—Finished (either successfully or faulted)'
  id: totrans-2338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*–2*—完成（无论是成功还是故障）'
- en: '*Anything else*—Paused at a particular await expression'
  id: totrans-2339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他任何情况*—在特定的await表达式处暂停'
- en: As I mentioned before, the type of the builder depends on the return type of
    the async method. Before C# 7, the builder type was always `AsyncVoidMethodBuilder`,
    `AsyncTaskMethodBuilder`, or `AsyncTaskMethodBuilder<T>`. With C# 7 and custom
    task types, the builder type specified by the `AsyncTaskMethodBuilderAttribute`
    is applied to the custom task type.
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，构建器的类型取决于异步方法的返回类型。在C# 7之前，构建器类型始终是`AsyncVoidMethodBuilder`、`AsyncTaskMethodBuilder`或`AsyncTaskMethodBuilder<T>`。随着C#
    7和自定义任务类型，由`AsyncTaskMethodBuilderAttribute`指定的构建器类型应用于自定义任务类型。
- en: The other fields are slightly trickier in that all of them depend on the body
    of the async method, and the compiler tries to use as few fields as it can. The
    crucial point to remember is that you need fields only for values that you need
    to come back to after the state machine resumes at some point. Sometimes the compiler
    can use fields for multiple purposes, and sometimes it can omit them entirely.
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字段稍微复杂一些，因为它们都依赖于异步方法的主体，编译器会尽量使用尽可能少的字段。需要记住的关键点是，你只需要为那些在状态机在某个时刻恢复后需要返回的值使用字段。有时编译器可以为多个目的使用字段，有时它可以完全省略它们。
- en: 'The first example of how the compiler can reuse fields is with awaiters. Only
    one awaiter is relevant at a time, because any particular state machine can await
    only one value at a time. The compiler creates a single field for each awaiter
    type that’s used. If you await two `Task<int>` values, one `Task<string>`, and
    three nongeneric `Task` values in an async method, you’ll end up with three fields:
    a `TaskAwaiter<int>`, a `TaskAwaiter<string>`, and a nongeneric `TaskAwaiter`.
    The compiler uses the appropriate field for each await expression based on the
    awaiter type.'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器重用字段的第一种例子是等待者。一次只有一个等待者是相关的，因为任何特定的状态机一次只能等待一个值。编译器为每种使用的等待者类型创建一个字段。如果你在一个异步方法中等待两个
    `Task<int>` 值、一个 `Task<string>` 和三个非泛型 `Task` 值，你将得到三个字段：一个 `TaskAwaiter<int>`、一个
    `TaskAwaiter<string>` 和一个非泛型 `TaskAwaiter`。编译器根据等待者类型使用适当的字段为每个 `await` 表达式。
- en: '|  |'
  id: totrans-2343
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: This assumes the awaiter is introduced by the compiler. If you call `GetAwaiter()`
    yourself and assign the result to a local variable, that’s treated like any other
    local variable. I’m talking about the awaiters that are produced as the result
    of await expressions.
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设等待者是由编译器引入的。如果你自己调用 `GetAwaiter()` 并将结果赋值给局部变量，那么它就像任何其他局部变量一样处理。我在谈论的是作为
    `await` 表达式结果产生的等待者。
- en: '|  |'
  id: totrans-2346
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Next, let’s consider local variables. Here, the compiler doesn’t reuse fields
    but can omit them entirely. If a local variable is used only between two await
    expressions rather than *across* await expressions, it can stay as a local variable
    in the `MoveNext()` method.
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑局部变量。在这里，编译器不会重用字段，但可以完全省略它们。如果一个局部变量只在使用两个 `await` 表达式之间而不是跨越 `await`
    表达式使用，它可以保持在 `MoveNext()` 方法中的局部变量。
- en: 'It’s easier to see what I mean with an example. Consider the following async
    method:'
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子更容易理解我的意思。考虑以下异步方法：
- en: '[PRE258]'
  id: totrans-2349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '***1* x is assigned before the await.**'
  id: totrans-2350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 在 `await` 之前将 `x` 赋值。'
- en: '***2* y is used only before the await.**'
  id: totrans-2351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** `y` 只在 `await` 之前使用。'
- en: '***3* x is used after the await.**'
  id: totrans-2352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 在 `await` 之后使用 `x`。'
- en: The compiler would generate a field for `x` because the value has to be preserved
    while the state machine is paused, but `y` can just be a local variable on the
    stack while the code is executing.
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会为 `x` 生成一个字段，因为当状态机暂停时，必须保留其值，但 `y` 在代码执行期间可以只是一个栈上的局部变量。
- en: '|  |'
  id: totrans-2354
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The compiler does a pretty good job of creating only as many fields as it needs.
    But at times, you might spot an optimization that the compiler could perform but
    doesn’t. For example, if two variables have the same type and are both used across
    await expressions (so they need fields), but they’re never both in scope at the
    same time, the compiler could use just one field for both as it does for awaiters.
    At the time of this writing, it doesn’t, but who knows what the future could hold?
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在创建所需字段数量方面做得相当不错。但有时，你可能会发现编译器可以执行但未执行的优化。例如，如果有两个变量具有相同的类型并且都在 `await`
    表达式中使用（因此需要字段），但它们从未同时处于作用域中，编译器可以为它们使用一个字段，就像它对等待者所做的那样。在撰写本文时，它并没有这样做，但谁知道未来会怎样呢？
- en: '|  |'
  id: totrans-2357
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Finally, there are temporary stack variables. These are introduced when an
    await expression is used as part of a bigger expression and some intermediate
    values need to be remembered. Our simple example in [listing 6.1](kindle_split_021_split_000.html#ch06ex01)
    doesn’t need any, which is why [listing 6.2](kindle_split_021_split_000.html#ch06ex02)
    shows only four fields: the state, builder, awaiter, and parameter. As an example
    of this, consider the following method:'
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有临时栈变量。这些是在将 `await` 表达式用作更大表达式的一部分并且需要记住一些中间值时引入的。在我们的简单示例 [列表 6.1](kindle_split_021_split_000.html#ch06ex01)
    中不需要这些，这就是为什么 [列表 6.2](kindle_split_021_split_000.html#ch06ex02) 只显示了四个字段：状态、构建器、等待者和参数。作为一个例子，考虑以下方法：
- en: '[PRE259]'
  id: totrans-2359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: The C# rules for operand evaluation don’t change just because you’re within
    an async method. The properties `now.Second` and `now.Hours` both have to be evaluated
    before the task is awaited, and their results have to be remembered in order to
    perform the arithmetic later, after the state machine resumes when the task completes.
    That means it needs to use fields.
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: C# 对操作数评估的规则不会因为你在一个异步方法中而改变。属性 `now.Second` 和 `now.Hours` 都必须在任务被等待之前被评估，并且它们的必须被记住以便在状态机在任务完成后恢复时执行算术运算。这意味着它需要使用字段。
- en: '|  |'
  id: totrans-2361
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this case, you know that `Task.FromResult` always returns a completed task.
    But the compiler doesn’t know that, and it has to generate the state machine in
    a way that would let it pause and resume if the task weren’t complete.
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你知道 `Task.FromResult` 总是返回一个完成的任务。但是编译器不知道这一点，并且它必须以某种方式生成状态机，以便在任务未完成时可以暂停和恢复。
- en: '|  |'
  id: totrans-2364
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can think of it as if the compiler rewrites the code to introduce extra
    local variables:'
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把它想象成编译器重写代码以引入额外的局部变量：
- en: '[PRE260]'
  id: totrans-2366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Then the local variables are converted into fields. Unlike real local variables,
    the compiler does reuse temporary stack variables of the same type and generates
    only as many fields as it needs to.
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将局部变量转换为字段。与真正的局部变量不同，编译器确实会重用相同类型的临时堆栈变量，并且只生成它需要的字段数量。
- en: That explains all the fields in the state machine. Next, you need to look at
    the `MoveNext()` method—but only conceptually, to start with.
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了状态机中的所有字段。接下来，你需要查看 `MoveNext()` 方法——但首先是概念上，为了开始。
- en: 6.1.3\. The MoveNext() method (high level)
  id: totrans-2369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. MoveNext() 方法（高级）
- en: I’m not going to show you the decompiled code for [listing 6.1](kindle_split_021_split_000.html#ch06ex01)’s
    `MoveNext()` method yet, because it’s long and scary.^([[1](kindle_split_021_split_000.html#ch06fn1)])
    After you know what the flow looks like, it’s more manageable, so I’ll describe
    it in the abstract here.
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在不会向你展示 [列表6.1](kindle_split_021_split_000.html#ch06ex01) 的 `MoveNext()` 方法的反编译代码，因为它很长且令人畏惧.^([[1](kindle_split_021_split_000.html#ch06fn1)])
    在你知道流程看起来像什么之后，它就更容易处理了，所以我将在这里以抽象的方式描述它。
- en: ¹
  id: totrans-2371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-2372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If *A Few Good Men* had been about async, the line would have been, “You want
    the MoveNext? You can’t handle the MoveNext!”
  id: totrans-2373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果《少数人统治》是关于异步的，那么台词将是：“你想要 MoveNext 吗？你处理不了 MoveNext！”
- en: 'Each time `MoveNext()` is called, the state machine takes another step. Each
    time it reaches an await expression, it’ll continue if the value being awaited
    has already completed and pause otherwise. `MoveNext()` returns if any of the
    following occurs:'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `MoveNext()` 时，状态机都会迈出另一步。每次它遇到一个 `await` 表达式时，如果等待的值已经完成，它将继续；否则，它将暂停。如果以下任何一种情况发生，`MoveNext()`
    将返回：
- en: The state machine needs to pause to await an incomplete value.
  id: totrans-2375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态机需要暂停以等待一个不完整的价值。
- en: Execution reaches the end of the method or a return statement.
  id: totrans-2376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行到达方法末尾或返回语句。
- en: An exception is thrown but not caught in the async method.
  id: totrans-2377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异步方法中抛出异常但没有被捕获。
- en: Note that in the final case, the `MoveNext()` method doesn’t end up throwing
    an exception. Instead, the task associated with the async call becomes faulted.
    (If that surprises you, see [section 5.6.5](kindle_split_020_split_000.html#ch05lev2sec14)
    for a reminder of the behavior of async methods with respect to exceptions.)
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最终情况下，`MoveNext()` 方法并没有最终抛出异常。相反，与异步调用关联的任务变得有故障。（如果你对此感到惊讶，请参阅 [第5.6.5节](kindle_split_020_split_000.html#ch05lev2sec14)
    以了解异步方法与异常行为的关系。）
- en: '[Figure 6.2](kindle_split_021_split_000.html#ch06fig02) shows a general flowchart
    of an async method that focuses on the `MoveNext()` method. I haven’t included
    exception handling in the figure, as flowcharts don’t have a way of representing
    `try`/`catch` blocks. You’ll see how that’s managed when you eventually look at
    the code. Likewise, I haven’t shown where `SetStateMachine` is called, as the
    flowchart is complicated enough as it is.'
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.2](kindle_split_021_split_000.html#ch06fig02) 展示了一个异步方法的一般流程图，该流程图专注于 `MoveNext()`
    方法。我没有在图中包含异常处理，因为流程图没有表示 `try`/`catch` 块的方法。当你最终查看代码时，你会看到它是如何处理的。同样，我没有显示 `SetStateMachine`
    被调用的位置，因为流程图本身已经足够复杂。'
- en: Figure 6.2\. Flowchart of an async method
  id: totrans-2380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 异步方法的流程图
- en: '![](../Images/06fig02_alt.jpg)'
  id: totrans-2381
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig02_alt.jpg)'
- en: 'One final point about the `MoveNext()` method: its return type is `void`, not
    a task type. Only the stub method needs to return the task, which it gets from
    the state machine’s builder after the builder’s `Start()` method has called `MoveNext()`
    to take the first step. All the other calls to `MoveNext()` are part of the infrastructure
    for resuming the state machine from a paused state, and those don’t need the associated
    task. You’ll see what all of this looks like in code in [section 6.2](kindle_split_021_split_000.html#ch06lev1sec2)
    (not long to go now), but first, a brief word on `SetStateMachine`.'
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`MoveNext()`方法的最后一个要点：它的返回类型是`void`，而不是任务类型。只有存根方法需要返回任务，它在状态机的构建器调用`Start()`方法并执行第一步后从状态机的构建器那里获得。所有其他对`MoveNext()`的调用都是基础设施的一部分，用于从暂停状态恢复状态机，这些调用不需要相关的任务。你将在[第6.2节](kindle_split_021_split_000.html#ch06lev1sec2)（现在不久了）中看到所有这些在代码中的样子，但首先，简要谈谈`SetStateMachine`。
- en: 6.1.4\. The SetStateMachine method and the state machine boxing dance
  id: totrans-2383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4\. `SetStateMachine`方法和状态机装箱舞蹈
- en: 'I’ve already shown the implementation of `SetStateMachine`. It’s simple:'
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示了`SetStateMachine`的实现。很简单：
- en: '[PRE261]'
  id: totrans-2385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'The implementation in release builds always looks like this. (In debug builds,
    where the state machine is a class, the implementation is empty.) The purpose
    of the method is easy to explain at a high level, but the details are fiddly.
    When a state machine takes its first step, it’s on the stack as a local variable
    of the stub method. If it pauses, it has to box itself (onto the heap) so that
    all that information is still in place when it resumes. After it’s been boxed,
    `SetStateMachine` is called on the boxed value using the boxed value as the argument.
    In other words, somewhere deep in the heart of the infrastructure, there’s code
    that looks a bit like this:'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 发布版本中的实现总是这样。（在调试版本中，由于状态机是一个类，实现是空的。）从高层次上解释该方法的目的很容易，但细节很繁琐。当状态机迈出第一步时，它作为存根方法的局部变量位于堆栈上。如果它暂停，它必须将自己装箱（到堆上），以便在它恢复时所有这些信息仍然在位。在装箱之后，使用装箱值作为参数在装箱值上调用`SetStateMachine`。换句话说，在基础设施的深处，有看起来有点像这样的代码：
- en: '[PRE262]'
  id: totrans-2387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: It’s not quite as simple as that, but that conveys the essence of what’s going
    on. The implementation of `SetStateMachine` then makes sure that the `AsyncTaskMethodBuilder`
    has a reference to the single boxed version of the state machine that it’s a part
    of. The method has to be called on the boxed value; it can be called only after
    boxing, because that’s when you have the reference to the boxed value, and if
    you called it on the unboxed value after boxing, that wouldn’t affect the boxed
    value. (Remember, `AsyncTaskMethodBuilder` is itself a value type.) This intricate
    dance ensures that when a continuation delegate is passed to the awaiter, that
    continuation will call `MoveNext()` on the same boxed instance.
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是那么简单，但已经传达了正在发生的事情的本质。然后`SetStateMachine`的实现确保`AsyncTaskMethodBuilder`有一个对其所参与的单个装箱状态机的引用。必须在装箱值上调用该方法；只能在装箱之后调用，因为那时你才有对装箱值的引用，如果在装箱之后在未装箱值上调用它，那么这不会影响装箱值。（记住，`AsyncTaskMethodBuilder`本身是一个值类型。）这种复杂的舞蹈确保当将延续委托传递给awaiter时，该延续将调用同一装箱实例的`MoveNext()`方法。
- en: The result is that the state machine isn’t boxed at all if it doesn’t need to
    be and is boxed exactly once if necessary. After it’s boxed, everything happens
    on the boxed version. It’s a lot of complicated code in the name of efficiency.
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，如果不需要装箱，状态机根本不会装箱；如果需要，则恰好装箱一次。在装箱之后，所有事情都在装箱版本上发生。这是一堆为了效率而编写的复杂代码。
- en: I find this little dance one of the most intriguing and bizarre bits of the
    whole async machinery. It sounds like it’s utterly pointless, but it’s necessary
    because of the way boxing works, and boxing is necessary to preserve information
    while the state machine is paused.
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这个小小的舞蹈是整个异步机制中最引人入胜和奇特的部分。听起来这似乎毫无意义，但这是由于装箱的工作方式所必需的，而装箱是必要的，以便在状态机暂停时保留信息。
- en: It’s absolutely fine not to fully understand this code. If you ever find yourself
    debugging async code at a low level, you can come back to this section. For all
    other intents and purposes, this code is more of a novelty than anything else.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不必完全理解这段代码。如果你发现自己正在低级别调试异步代码，可以回到这一节。对于所有其他目的和用途，这段代码更像是一个新奇事物，而不是其他任何东西。
- en: That’s what the state machine consists of. Most of the rest of the chapter is
    devoted to the `MoveNext()`method and how it operates in various situations. We’ll
    start with the simple case and work up from there.
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是状态机的组成部分。本章的大部分内容都致力于 `MoveNext()` 方法以及它在各种情况下的操作。我们将从简单的情况开始，然后逐步深入。
- en: 6.2\. A simple MoveNext() implementation
  id: totrans-2393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 一个简单的 MoveNext() 实现
- en: We’re going to start with the simple async method that you saw in [listing 6.1](kindle_split_021_split_000.html#ch06ex01).
    It’s simple not because it’s short (although that helps) but because it doesn’t
    contain any loops, `try` statements, or `using` statements. It has simple control
    flow, which leads to a relatively simple state machine. Let’s get cracking.
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从你在 [列表 6.1](kindle_split_021_split_000.html#ch06ex01) 中看到的简单异步方法开始。它之所以简单，并不是因为它很短（尽管这也有帮助），而是因为它不包含任何循环、`try`
    语句或 `using` 语句。它有简单的控制流程，这导致了一个相对简单的状态机。让我们开始吧。
- en: 6.2.1\. A full concrete example
  id: totrans-2395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 一个完整的具体示例
- en: 'I’m going to show you the full method to start with. Don’t expect this to all
    make sense yet, but do spend a few minutes looking through it. With this concrete
    example in hand, the more general structure is easier to understand, because you
    can always look back to see how each part of that structure is present in this
    example. At the risk of boring you, here’s [listing 6.1](kindle_split_021_split_000.html#ch06ex01)
    yet again as a reminder of the compiler’s input:'
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先展示完整的方法。不要期望这一切现在都能理解，但请花几分钟时间仔细查看。有了这个具体的例子，更通用的结构更容易理解，因为你可以随时回顾，看看结构中的每一部分是如何体现在这个例子中的。冒着让你感到无聊的风险，这里再次列出
    [列表 6.1](kindle_split_021_split_000.html#ch06ex01) 作为编译器输入的提醒：
- en: '[PRE263]'
  id: totrans-2397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: The following listing is a version of the decompiled code that has been slightly
    rewritten for readability. (Yes, this is the easy-to-read version.)
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是经过轻微重写以提高可读性的反编译代码版本。（是的，这是易于阅读的版本。）
- en: Listing 6.3\. The decompiled `MoveNext()` method from [listing 6.1](kindle_split_021_split_000.html#ch06ex01)
  id: totrans-2399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 从 [列表 6.1](kindle_split_021_split_000.html#ch06ex01) 反编译的 `MoveNext()`
    方法
- en: '[PRE264]'
  id: totrans-2400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: That’s a lot of code, and you may notice that it has a lot of `goto` statements
    and code labels, which you hardly ever see in handwritten C#. At the moment, I
    expect it to be somewhat impenetrable, but I wanted to show you a concrete example
    to start with, so you can refer to it anytime it’s useful to you. I’m going to
    break this down further into general structure and then the specifics of await
    expressions. By the end of this section, [listing 6.3](kindle_split_021_split_000.html#ch06ex03)
    will probably still look extremely ugly to you, but you’ll be in a better position
    to understand what it’s doing and why.
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很多，你可能注意到它有很多 `goto` 语句和代码标签，这在手写的 C# 中几乎很少见。目前，我预计它可能有些难以理解，但我想要先展示一个具体的例子，这样你就可以在需要的时候随时参考。我将进一步将其分解为一般结构和
    `await` 表达式的具体细节。到本节结束时，[列表 6.3](kindle_split_021_split_000.html#ch06ex03) 可能仍然对你来说非常丑陋，但你将更好地理解它在做什么以及为什么这么做。
- en: 6.2.2\. MoveNext() method general structure
  id: totrans-2402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. MoveNext() 方法的一般结构
- en: We’re into the next layer of the async onion. The `MoveNext()` method is at
    the heart of the async state machine, and its complexity is a reminder of how
    hard it is to get async code right. The more complex the state machine, the more
    reason you have to be grateful that it’s the C# compiler that has to write the
    code rather than you.
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进入了异步洋葱的下一层。`MoveNext()` 方法是异步状态机的核心，其复杂性提醒我们异步代码的正确实现是多么困难。状态机越复杂，你就越有理由感激是
    C# 编译器而不是你自己在编写代码。
- en: '|  |'
  id: totrans-2404
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-2405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s time to introduce more terminology for the sake of brevity. At each await
    expression, the value being awaited may already have completed or may still be
    incomplete. If it has already completed by the time you await it, the state machine
    keeps executing. I call this the *fast path*. If it hasn’t already completed,
    the state machine schedules a continuation and pauses. I call this the *slow path*.
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，现在是时候引入更多术语了。在每一个 `await` 表达式中，被等待的值可能已经完成或可能仍然不完整。如果你等待它的时候它已经完成，状态机将继续执行。我称之为
    *快速路径*。如果它还没有完成，状态机将安排一个后续操作并暂停。我称之为 *慢速路径*。
- en: '|  |'
  id: totrans-2407
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As a reminder, the `MoveNext()` method is invoked once when the async method
    is first called and then once each time it needs to resume from being paused at
    an await expression. (If every await expression takes the fast path, `MoveNext()`
    will be called only once.) The method is responsible for the following:'
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，`MoveNext()`方法在异步方法首次调用时被调用一次，然后在每次从await表达式暂停处恢复时再次调用。 (如果每个await表达式都采取快速路径，则`MoveNext()`只会被调用一次。)该方法负责以下内容：
- en: Executing from the right place (whether that’s the start of the original async
    code or partway through)
  id: totrans-2409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从正确的位置执行（无论是原始异步代码的开始还是中途）
- en: Preserving state when it needs to pause, both in terms of local variables and
    location within the code
  id: totrans-2410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要暂停时保留状态，无论是局部变量还是代码中的位置
- en: Scheduling a continuation when it needs to pause
  id: totrans-2411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要暂停时安排延续
- en: Retrieving return values from awaiters
  id: totrans-2412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从awaiter检索返回值
- en: Propagating exceptions via the builder (rather than letting `MoveNext()` itself
    fail with an exception)
  id: totrans-2413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建器传播异常（而不是让`MoveNext()`自身因异常而失败）
- en: Propagating any return value or method completion via the builder
  id: totrans-2414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建器传播任何返回值或方法完成
- en: With this in mind, the following listing shows pseudocode for the general structure
    of a `MoveNext()` method. You’ll see in later sections how this can end up being
    more complicated because of extra control flow, but it’s a natural extension.
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，以下列表显示了`MoveNext()`方法的一般结构伪代码。你将在后面的章节中看到，由于额外的控制流，这可能会变得更加复杂，但它是一个自然的扩展。
- en: Listing 6.4\. Pseudocode of a `MoveNext()` method
  id: totrans-2416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. `MoveNext()`方法的伪代码
- en: '[PRE265]'
  id: totrans-2417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '***1* As many cases as there are await expressions**'
  id: totrans-2418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 有多少个await表达式就有多少种情况**'
- en: '***2* Code before the first await expression**'
  id: totrans-2419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在第一个await表达式之前的代码**'
- en: '***3* Sets up the first awaiter**'
  id: totrans-2420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置第一个awaiter**'
- en: '***4* Code resuming from a continuation**'
  id: totrans-2421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从延续处恢复代码**'
- en: '***5* Fast and slow paths rejoin**'
  id: totrans-2422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 快速路径和慢速路径重新汇合**'
- en: '***6* Remainder of code, with more labels, awaiters, and so on**'
  id: totrans-2423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 代码的其余部分，有更多的标签、awaiter等**'
- en: '***7* Propagates all exceptions via the builder**'
  id: totrans-2424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 通过构建器传播所有异常**'
- en: '***8* Propagates method completion via the builder**'
  id: totrans-2425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 通过构建器传播方法完成**'
- en: The big `try`/`catch` block covers all the code from the original async method.
    If anything in there throws an exception, however it’s thrown (via awaiting a
    faulted operation, calling a synchronous method that throws, or simply throwing
    an exception directly), that exception is caught and then propagated via the builder.
    Only special exceptions (`ThreadAbortException` and `StackOverflowException`,
    for example) will ever cause `MoveNext()` to end with an exception.
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: 大的`try`/`catch`块覆盖了原始异步方法的所有代码。如果其中任何内容抛出异常，无论通过等待故障操作、调用抛出异常的同步方法，还是直接抛出异常，该异常都会被捕获并通过构建器传播。只有特殊的异常（例如`ThreadAbortException`和`StackOverflowException`）才会导致`MoveNext()`以异常结束。
- en: Within the `try`/`catch` block, the start of the `MoveNext()` method is always
    effectively a `switch` statement used to jump to the right piece of code within
    the method based on the state. If the state is non-negative, that means you’re
    resuming after an await expression. Otherwise, it’s assumed that you’re executing
    `MoveNext()` for the first time.
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`/`catch`块中，`MoveNext()`方法的开始始终是一个用于根据状态跳转到方法中正确代码的`switch`语句。如果状态为非负，这意味着你在await表达式之后恢复。否则，假设你正在第一次执行`MoveNext()`。
- en: '|  |'
  id: totrans-2428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What about other states?**'
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于其他状态呢？**'
- en: In [section 6.1](kindle_split_021_split_000.html#ch06lev1sec1), I listed the
    possible states as not started, executing, paused, and complete (where paused
    is a separate state per await expression). Why doesn’t the state machine handle
    not started, executing, and complete differently?
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6.1节](kindle_split_021_split_000.html#ch06lev1sec1)中，我列出了可能的状态为未开始、执行中、暂停和完成（其中暂停是每个await表达式的独立状态）。为什么状态机不对未开始、执行中和完成状态进行不同的处理？
- en: The answer is that `MoveNext()` should never end up being called in the executing
    or complete states. You can force it to by writing a broken awaiter implementation
    or by using reflection, but under normal operation, `MoveNext()` is called only
    to start or resume the state machine. There aren’t even distinct state numbers
    for not started and executing; both use –1\. There’s a state number of –2 for
    completed, but the state machine never checks for that value.
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`MoveNext()`在执行或完成状态下永远不会最终被调用。你可以通过编写有缺陷的等待者实现或使用反射来强制这样做，但在正常操作中，`MoveNext()`只被调用以启动或恢复状态机。甚至没有未开始和执行的不同状态编号；两者都使用-1。完成状态有一个-2的状态编号，但状态机永远不会检查该值。
- en: '|  |'
  id: totrans-2432
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: One bit of trickiness to be aware of is the difference between a return statement
    in the state machine and a return statement in the original async code. Within
    the state machine, `return` is used when the state machine is paused after scheduling
    a continuation for an awaiter. Any return statement in the original code ends
    up dropping to the bottom part of the state machine outside the `try`/`catch`
    block, where the method completion is propagated via the builder.
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个小技巧是状态机中的return语句与原始异步代码中的return语句之间的区别。在状态机内部，`return`用于在为awaiter安排了继续执行后状态机暂停时。原始代码中的任何return语句最终都会下降到状态机底部的`try`/`catch`块之外，方法完成通过构建器传播。
- en: If you compare [listings 6.3](kindle_split_021_split_000.html#ch06ex03) and
    [6.4](kindle_split_021_split_000.html#ch06ex04), hopefully you can see how our
    concrete example fits into the general pattern. At this point, I’ve explained
    almost everything about the code generated by the simple async method you started
    with. The only bit that’s missing is exactly what happens around await expressions.
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较[列表6.3](kindle_split_021_split_000.html#ch06ex03)和[6.4](kindle_split_021_split_000.html#ch06ex04)，希望你能看到我们的具体示例如何融入一般模式。到目前为止，我已经几乎解释了关于你开始时简单异步方法生成的代码的各个方面。唯一缺失的部分就是await表达式周围的确切发生情况。
- en: 6.2.3\. Zooming into an await expression
  id: totrans-2435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3. 深入研究await表达式
- en: 'Let’s think again about what has to happen each time you hit an await expression
    when executing an async method, assuming you’ve already evaluated the operand
    to get something that’s awaitable:'
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次思考，当你执行异步方法并遇到await表达式时，每次必须发生什么，假设你已经评估操作数以获取可以await的东西：
- en: You fetch the awaiter from the awaitable by calling `GetAwaiter()`, storing
    it on the stack.
  id: totrans-2437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你通过调用`GetAwaiter()`从awaitable中获取等待者，并将其存储在堆栈上。
- en: You check whether the awaiter has already completed. If it has, you can skip
    straight to fetching the result (step 9). This is the fast path.
  id: totrans-2438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你检查等待者是否已经完成。如果是，你可以直接跳转到获取结果（步骤9）。这是快速路径。
- en: It looks like you’re on the slow path. Oh well. Remember where you reached via
    the state field.
  id: totrans-2439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来你正在走慢路。哦，好吧。记住你通过状态字段达到的位置。
- en: Remember the awaiter in a field.
  id: totrans-2440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住字段中的等待者。
- en: Schedule a continuation with the awaiter, making sure that when the continuation
    is executed, you’ll be back to the right state (doing the boxing dance, if necessary).
  id: totrans-2441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用等待者安排一个继续执行，确保当继续执行时，你会回到正确的状态（如果需要，做装箱舞蹈）。
- en: Return from the `MoveNext()` method either to the original caller, if this is
    the first time you’ve paused, or to whatever scheduled the continuation otherwise.
  id: totrans-2442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`MoveNext()`方法返回，无论是第一次暂停，还是由什么安排了继续执行。
- en: When the continuation fires, set your state back to *running* (value of –1).
  id: totrans-2443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当继续执行时，将你的状态设置回*运行中*（值为-1）。
- en: Copy the awaiter out of the field and back onto the stack, clearing the field
    in order to potentially help the garbage collector. Now you’re ready to rejoin
    the fast path.
  id: totrans-2444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将等待者从字段中复制出来，并将其放回堆栈上，以清除字段，这可能会帮助垃圾收集器。现在你准备好重新加入快速路径。
- en: Fetch the result from the awaiter, which is on the stack at this point regardless
    of which path you took. You have to call `GetResult()` even if there isn’t a result
    *value* to let the awaiter propagate errors if necessary.
  id: totrans-2445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从堆栈上的等待者获取结果，无论你选择了哪条路径。即使没有结果*值*，你也必须调用`GetResult()`，以便等待者可以传播错误（如果需要的话）。
- en: Continue on your merry way, executing the rest of the original code using the
    result value if there was one.
  id: totrans-2446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续你的愉快之旅，使用结果值（如果有的话）执行原始代码的其余部分。
- en: With that list in mind, let’s review a section of [listing 6.3](kindle_split_021_split_000.html#ch06ex03)
    that corresponds to our first await expression.
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 在记住这个列表的情况下，让我们回顾一下[列表6.3](kindle_split_021_split_000.html#ch06ex03)中对应我们第一个await表达式的部分。
- en: Listing 6.5\. A section of [listing 6.3](kindle_split_021_split_000.html#ch06ex03)
    corresponding to a single await
  id: totrans-2448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5\. 对应单个`await`的[列表6.3](kindle_split_021_split_000.html#ch06ex03)的一部分
- en: '[PRE266]'
  id: totrans-2449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'Unsurprisingly, the code follows the set of steps precisely.^([[2](kindle_split_021_split_000.html#ch06fn2)])
    The two labels represent the two places you have to jump to, depending on the
    path:'
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，代码精确地遵循了步骤集合。^([[2](kindle_split_021_split_000.html#ch06fn2)]) 两个标签代表根据路径必须跳转的两个地方：
- en: ²
  id: totrans-2451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-2452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s unsurprising in that it would have been pretty odd of me to write that
    list of steps and then present code that didn’t follow the list.
  id: totrans-2453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这并不奇怪，因为我写了一系列步骤，然后展示的代码没有遵循这些步骤，那就太奇怪了。
- en: In the fast path, you jump over the slow-path code.
  id: totrans-2454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在快速路径中，你跳过了慢速路径的代码。
- en: In the slow path, you jump back into the middle of the code when the continuation
    is called. (Remember, that’s what the `switch` statement at the start of the method
    is for.)
  id: totrans-2455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在慢速路径中，当调用后续操作时，你会跳回代码的中间部分。（记住，这就是方法开头`switch`语句的作用。）
- en: The call to `builder.AwaitUnsafeOnCompleted(ref awaiter1, ref this)` is the
    part that does the boxing dance with a call back into `SetStateMachine` (if necessary;
    it happens only once per state machine) and schedules the continuation. In some
    cases, you’ll see a call to `AwaitOnCompleted` instead of `AwaitUnsafeOnCompleted`.
    These differ only in terms of how the execution context is handled. You’ll look
    at this in more detail in [section 6.5](kindle_split_021_split_000.html#ch06lev1sec5).
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: 对`builder.AwaitUnsafeOnCompleted(ref awaiter1, ref this)`的调用是执行与`SetStateMachine`（如果需要；每个状态机只发生一次）的回调并安排后续操作的部分。在某些情况下，你会看到对`AwaitOnCompleted`而不是`AwaitUnsafeOnCompleted`的调用。这些调用在处理执行上下文方面有所不同。你将在[第6.5节](kindle_split_021_split_000.html#ch06lev1sec5)中更详细地了解这一点。
- en: One aspect that may seem slightly unclear is the use of the `num` local variable.
    It’s always assigned a value at the same time as the `state` field but is always
    read instead of the field. (Its initial value is copied out of the field, but
    that’s the only time the field is read.) I believe this is purely for optimization.
    Whenever you read `num`, it’s fine to think of it as `this.state` instead.
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一个方面看起来稍微有点不清楚，那就是对`num`局部变量的使用。它总是在与`state`字段相同的时间被赋值，但总是读取字段而不是变量。（它的初始值是从字段中复制出来的，但这是字段唯一被读取的时候。）我相信这纯粹是为了优化。每次你读取`num`时，都可以将其视为`this.state`。
- en: 'Looking at [listing 6.5](kindle_split_021_split_000.html#ch06ex05), that’s
    16 lines of code for what was originally just the following:'
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[列表6.5](kindle_split_021_split_000.html#ch06ex05)，这16行代码原本只是以下内容：
- en: '[PRE267]'
  id: totrans-2459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: The good news is that you almost never need to see all that code unless you’re
    going through this kind of exercise. There’s a small amount of bad news in that
    the code inflation means that even small async methods—even those using `ValueTask<TResult>`—can’t
    be sensibly inlined by the JIT compiler. In most cases, that’s a miniscule price
    to pay for the benefits afforded by async/await, though.
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，除非你正在做这种类型的练习，否则你几乎不需要看到所有这些代码。坏消息是，代码膨胀意味着即使是小的异步方法——即使是使用`ValueTask<TResult>`的方法——也无法被JIT编译器合理地内联。尽管如此，在大多数情况下，这只是为了异步/await带来的好处而付出的微小代价。
- en: That’s the *simple* case with *simple* control flow. With that background, you
    can explore a couple of more-complex cases.
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是控制流简单的简单情况。有了这个背景，你可以探索一些更复杂的情况。
- en: 6.3\. How control flow affects MoveNext()
  id: totrans-2462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 控制流如何影响MoveNext()
- en: The example you’ve been looking at so far has just been a sequence of method
    calls with only the `await` operator introducing complexity. Life gets a little
    harder when you want to write real code with all the normal control-flow statements
    you’re used to.
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的例子只是一个方法调用的序列，其中只有`await`操作符引入了复杂性。当你想要编写带有所有你习惯的正常控制流语句的真实代码时，生活就会变得有点艰难。
- en: 'In this section, I’ll show you just two elements of control flow: loops and
    `try`/`finally` statements. This isn’t intended to be comprehensive, but it should
    give you enough of a glimpse at the control-flow gymnastics the compiler has to
    perform to help you understand other situations if you need to.'
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示控制流的两个元素：循环和`try`/`finally`语句。这不是要全面介绍，但它应该足以让你窥见编译器必须执行的控件流技巧，以便在需要时帮助你理解其他情况。
- en: 6.3.1\. Control flow between await expressions is simple
  id: totrans-2465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. `await`表达式之间的控制流简单
- en: Before we get into the tricky part, I’ll give an example of where introducing
    control flow doesn’t add to the generated code complexity any more than it would
    in the synchronous code. In the following listing, a loop is introduced into our
    example method, so you print `Between delays` three times instead of once.
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到棘手的部分之前，我将给出一个例子，说明引入控制流不会使生成的代码复杂性增加，就像在同步代码中一样。在下面的列表中，我们在示例方法中引入了一个循环，所以你打印了三次`Between
    delays`而不是一次。
- en: Listing 6.6\. Introducing a loop between await expressions
  id: totrans-2467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. 在await表达式之间引入循环
- en: '[PRE268]'
  id: totrans-2468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: What does this look like when decompiled? Very much like [listing 6.2](kindle_split_021_split_000.html#ch06ex02)!
    The only difference is this
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 反编译后是什么样子？非常像[列表6.2](kindle_split_021_split_000.html#ch06ex02)！唯一的区别是这一点
- en: '[PRE269]'
  id: totrans-2470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'becomes the following:'
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 变成以下：
- en: '[PRE270]'
  id: totrans-2472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: The change in the state machine is exactly the same as the change in the original
    code. There are no extra fields and no complexities in terms of how to continue
    execution; it’s just a loop.
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机的变化与原始代码的变化完全相同。没有额外的字段，也没有关于如何继续执行方面的复杂性；它只是一个循环。
- en: The reason I bring this up is to help you think about why extra complexity is
    required in our next examples. In [listing 6.6](kindle_split_021_split_000.html#ch06ex06),
    you never need to jump into the loop from outside, and you never need to pause
    execution and jump out of the loop, thereby pausing the state machine. Those are
    the situations introduced by await expressions when you await *within* the loop.
    Let’s do that now.
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以提到这一点，是为了帮助你思考为什么在接下来的例子中需要额外的复杂性。在[列表6.6](kindle_split_021_split_000.html#ch06ex06)中，你从不需要从外部跳入循环，也从不需要暂停执行并跳出循环，从而暂停状态机。这些都是await表达式在循环内部等待时引入的情况。现在让我们这样做。
- en: 6.3.2\. Awaiting within a loop
  id: totrans-2475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 循环中的等待
- en: Our example so far has contained two await expressions. To keep the code somewhat
    manageable as I introduce other complexities, I’m going to reduce that to one.
    The following listing shows the async method you’re going to decompile in this
    subsection.
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止的例子中包含了两个await表达式。为了在引入其他复杂性时保持代码的相对可控性，我将将其减少到一。下面的列表显示了你在本节中将反编译的异步方法。
- en: Listing 6.7\. Awaiting in a loop
  id: totrans-2477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 循环中的等待
- en: '[PRE271]'
  id: totrans-2478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: The `Console.WriteLine` calls are mostly present as signposts within the decompiled
    code, which makes it easier to map to the original listing.
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console.WriteLine` 调用在反编译代码中主要作为标记存在，这使得将其映射到原始列表变得更加容易。'
- en: What does the compiler generate for this? I’m not going to show the complete
    code, because most of it is similar to what you’ve seen before. (It’s all in the
    downloadable source, though.) The stub method and state machine are almost exactly
    as they were for earlier examples but with one additional field in the state machine
    corresponding to `i`, the loop counter. The interesting part is in `MoveNext()`.
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为这个生成了什么？我不会展示完整的代码，因为其中大部分都是你之前见过的。（它都在可下载的源代码中。）状态机和方法几乎与之前的例子完全相同，只是在状态机中增加了一个对应于`i`（循环计数器）的字段。有趣的部分在`MoveNext()`中。
- en: You can represent the code faithfully in C# but not using a loop construct.
    The problem is that after the state machine returns from pausing at `Task.Delay`,
    you want to jump into the middle of the original loop. You can’t do that with
    a `goto` statement in C#; the language forbids a `goto` statement specifying a
    label if the `goto` statement isn’t in the scope of that label.
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用C#忠实地表示这段代码，但不使用循环结构。问题是，在状态机从`Task.Delay`暂停返回后，你想要跳入原始循环的中间部分。在C#中你不能用`goto`语句做到这一点；如果`goto`语句不在该标签的作用域内，语言禁止指定标签的`goto`语句。
- en: That’s okay; you can implement your `for` loop with a lot of `goto` statements
    without introducing any extra scopes at all. That way, you can jump to the middle
    of it without a problem. The following listing shows the bulk of the decompiled
    code for the body of the `MoveNext()` method. I’ve included only the part within
    the `try` block, as that’s what we’re focusing on here. (The rest is simple boilerplate.)
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的；你可以用很多`goto`语句实现`for`循环，而不引入任何额外的作用域。这样，你可以毫无问题地跳到其中。下面的列表显示了`MoveNext()`方法主体的反编译代码的大部分。我只包括了`try`块内的部分，因为这是我们这里关注的重点。（其余的都是简单的样板代码。）
- en: Listing 6.8\. Decompiled loop without using any loop constructs
  id: totrans-2483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8\. 不使用任何循环结构的反编译循环
- en: '[PRE272]'
  id: totrans-2484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '***1* For loop initializer**'
  id: totrans-2485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* for循环初始化器**'
- en: '***2* Skips straight to checking the loop condition**'
  id: totrans-2486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 直接跳转到检查循环条件**'
- en: '***3* Body of the for loop**'
  id: totrans-2487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* for循环的主体**'
- en: '***4* Target for jump when the state machine resumes**'
  id: totrans-2488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 状态机恢复时的跳转目标**'
- en: '***5* For loop iterator**'
  id: totrans-2489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 循环迭代器**'
- en: '***6* Checks for loop condition and jumps back to body if it holds**'
  id: totrans-2490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 检查循环条件并在条件成立时跳回主体**'
- en: I could’ve skipped this example entirely, but it brings up a few interesting
    points. First, the C# compiler doesn’t convert an async method into equivalent
    C# that doesn’t use async/await. It only has to generate appropriate IL. In some
    places, C# has rules that are stricter than those in IL. (The set of valid identifiers
    is another example of this.)
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以完全跳过这个示例，但它提出了几个有趣的观点。首先，C# 编译器不会将异步方法转换为不使用 async/await 的等效 C# 代码。它只需要生成适当的
    IL。在某些地方，C# 的规则比 IL 更严格。（有效标识符的集合就是这种情况的另一个例子。）
- en: Second, although decompilers can be useful when looking at async code, sometimes
    they produce invalid C#. When I first decompiled the output of [listing 6.7](kindle_split_021_split_000.html#ch06ex07),
    the output included a `while` loop containing a label and a `goto` statement outside
    that loop trying to jump into it. You can sometimes get valid (but harder-to-read)
    C# by telling the decompiler not to work as hard to produce idiomatic C#, at which
    point you’ll see an awful lot of `goto` statements.
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，虽然反编译器在查看异步代码时可能很有用，但有时它们会产生无效的 C# 代码。当我第一次反编译 [列表 6.7](kindle_split_021_split_000.html#ch06ex07)
    的输出时，输出包括一个包含标签的 `while` 循环和一个试图跳入该循环的 `goto` 语句。有时，通过告诉反编译器不要那么努力地生成惯用的 C# 代码，你可以得到有效的（但更难阅读的）C#
    代码，这时你会看到大量的 `goto` 语句。
- en: Third, in case you weren’t already convinced, you don’t want to be writing this
    sort of code by hand. If you had to write C# 4 code for this sort of task, you’d
    no doubt do it in a very different way, but it would still be significantly uglier
    than the async method you can use in C# 5.
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，即使你还没有被说服，你也不想手动编写这种类型的代码。如果你必须为这种任务编写 C# 4 代码，你无疑会以非常不同的方式来做，但它仍然会比 C# 5
    中可用的异步方法要丑陋得多。
- en: 'You’ve seen how awaiting within a loop might cause humans some stress, but
    it doesn’t cause the compiler to break a sweat. For our final control-flow example,
    you’ll give it some harder work to do: a `try`/`finally` block.'
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在循环中等待可能会给人类带来一些压力，但这不会让编译器感到压力。对于我们的最后一个控制流示例，你将给它一些更困难的工作来做：一个 `try`/`finally`
    块。
- en: 6.3.3\. Awaiting within a try/finally block
  id: totrans-2495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 在 try/finally 块中等待
- en: Just to remind you, it’s always been valid to use `await` in a `try` block,
    but in C# 5, it was invalid to use it in a `catch` or `finally` block. That restriction
    was lifted in C# 6, although I’m not going to show any code that takes advantage
    of it.
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了提醒你，在 `try` 块中使用 `await` 一直是有效的，但在 C# 5 中，在 `catch` 或 `finally` 块中使用它是无效的。这种限制在
    C# 6 中被取消，尽管我不会展示任何利用它的代码。
- en: '|  |'
  id: totrans-2497
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are simply too many possibilities to go through here. The aim of this
    chapter is to give you insight into the kind of thing the C# compiler does with
    async/await rather than provide an exhaustive list of translations.
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多可能性，无法一一列举。本章的目的是让你了解 C# 编译器对 async/await 所做的事情，而不是提供一个详尽的翻译列表。
- en: '|  |'
  id: totrans-2500
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, I’m only going to show you an example of awaiting within a
    `try` block that has just a `finally` block. That’s probably the most common kind
    of `try` block, because it’s the one that `using` statements are equivalent to.
    The following listing shows the async method you’re going to decompile. Again,
    all the console output is present only to make it simpler to understand the state
    machine.
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我只将展示一个在只有一个 `finally` 块的 `try` 块中等待的示例。这可能是最常见的 `try` 块类型，因为它与 `using`
    语句等价。下面的列表显示了你要反编译的异步方法。同样，所有的控制台输出都只是为了使状态机的理解更简单。
- en: Listing 6.9\. Awaiting within a `try` block
  id: totrans-2502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 在 `try` 块中等待
- en: '[PRE273]'
  id: totrans-2503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'You might imagine that the decompiled code would look something like this:'
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象反编译后的代码看起来可能像这样：
- en: '[PRE274]'
  id: totrans-2505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'Here, each ellipsis (`...`) represents more code. There’s a problem with that
    approach, though: even in IL, you’re not allowed to jump from outside a `try`
    block to inside it. It’s a little bit like the problem you saw in the previous
    section with loops, but this time instead of a C# rule, it’s an IL rule.'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，每个省略号（`...`）代表更多的代码。但这种方法有一个问题：即使在 IL 中，你也不允许从一个 `try` 块外部跳转到内部。这有点像你在上一节中看到的循环问题，但这次不是
    C# 规则，而是 IL 规则。
- en: To achieve this, the C# compiler uses a technique I like to think of as a *trampoline.*
    (This isn’t official terminology, although the term is used elsewhere for similar
    purposes.) It jumps to just before the `try` block, and then the first thing inside
    the `try` block is a piece of code that jumps to the right place within the block.
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，C# 编译器使用了一种我愿意称之为 *弹跳板* 的技术。（这不是官方术语，尽管在其他类似用途中使用了这个术语。）它跳转到 `try` 块之前，然后
    `try` 块中的第一段代码就是跳转到块内正确位置的代码。
- en: 'In addition to the trampoline, the `finally` block needs to be handled with
    care, too. There are three situations in which you’ll execute the `finally` block
    of the generated code:'
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: 除了弹跳板之外，`finally` 块也需要小心处理。有三种情况下你会执行生成的代码中的 `finally` 块：
- en: You reach the end of the `try` block.
  id: totrans-2509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你到达了 `try` 块的末尾。
- en: The `try` block throws an exception.
  id: totrans-2510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try` 块抛出一个异常。'
- en: You need to pause within the `try` block because of an await expression.
  id: totrans-2511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在 `try` 块内暂停，因为有一个 `await` 表达式。
- en: '(If the async method contained a return statement, that would be another option.)
    If the `finally` block is executing because you’re pausing the state machine and
    returning to the caller, the code in the original async method’s `finally` block
    shouldn’t execute. After all, you’re logically paused inside the `try` block and
    will be resuming there when the delay completes. Fortunately, this is easy to
    detect: the `num` local variable (which always has the same as the `state` field)
    is negative if the state machine is still executing or finished and non-negative
    if you’re pausing.'
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: （如果异步方法包含一个返回语句，那将是一个选项。）如果 `finally` 块正在执行，是因为你暂停了状态机并返回到调用者，原始异步方法的 `finally`
    块中的代码不应该执行。毕竟，你逻辑上在 `try` 块内暂停，当延迟完成时你将从中恢复。幸运的是，这很容易检测：如果状态机仍在执行或已完成，局部变量 `num`（它始终与
    `state` 字段相同）将是负数；如果你在暂停，它将是非负数。
- en: All of this together leads to the following listing, which again is the code
    within the outer `try` block of `MoveNext()`. Although there’s still a lot of
    code, most of it is similar to what you’ve seen before. I’ve highlighted the `try`/`finally`-specific
    aspects in bold.
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些加在一起导致了以下列表，这又是 `MoveNext()` 的外部 `try` 块中的代码。尽管代码仍然很多，但大部分都是你之前见过的。我用粗体突出了
    `try`/`finally`-specific 的方面。
- en: Listing 6.10\. Decompiled await within `try/finally`
  id: totrans-2514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10. `try/finally` 中的反编译 await
- en: '[PRE275]'
  id: totrans-2515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '***1* Jumps to just before the trampoline, so it can bounce execution to the
    right place**'
  id: totrans-2516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 跳转到弹跳板之前，以便可以将执行弹跳到正确位置**'
- en: '***2* Trampoline within the try block**'
  id: totrans-2517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* try 块内的弹跳板**'
- en: '***3* Real continuation target**'
  id: totrans-2518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实际的继续目标**'
- en: '***4* Effectively ignores finally block if you’re pausing**'
  id: totrans-2519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果暂停，则有效忽略 finally 块**'
- en: That’s the final decompilation in the chapter, I promise. I wanted to get to
    that level of complexity to help you navigate the generated code if you ever need
    to. That’s not to say you won’t need to keep your wits about you when looking
    through it, particularly bearing in mind the many transformations the compiler
    can perform to make the code simpler than what I’ve shown. As I said earlier,
    where I’ve always used a `switch` statement for “jump to X” pieces of code, the
    compiler can sometimes use simpler branching code. Consistency in multiple situations
    is important when reading source code, but that doesn’t matter to the compiler.
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
  zh: 我保证这是本章的最后一段反编译内容。我想达到这个复杂程度，以便在你需要时帮助你导航生成的代码。这并不是说你在查看它时不需要保持清醒，尤其是考虑到编译器可以执行许多转换，使代码比我展示的更简单。正如我之前所说的，我总是使用
    `switch` 语句来处理“跳转到 X”的代码片段，编译器有时可以使用更简单的分支代码。在阅读源代码时，在多种情况下保持一致性很重要，但这对于编译器来说并不重要。
- en: One of the aspects I’ve skimmed over so far is why awaiters have to implement
    `INotifyCompletion` but can also implement `ICriticalNotifyCompletion`, and the
    effect that has on the generated code. Let’s take a closer look now.
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 我到目前为止略过的一个方面是，为什么 awaiter 必须实现 `INotifyCompletion` 但也可以实现 `ICriticalNotifyCompletion`，以及这对生成的代码产生的影响。现在让我们更仔细地看看。
- en: 6.4\. Execution contexts and flow
  id: totrans-2522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4. 执行上下文和流程
- en: 'In [section 5.2.2](kindle_split_020_split_000.html#ch05lev2sec4), I described
    synchronization contexts, which are used to govern the thread that code executes
    on. This is just one of many contexts in .NET, although it’s probably the best
    known. Context provides an ambient way of maintaining information transparently.
    For example, `SecurityContext` keeps track of the current security principal and
    code access security. You don’t need to pass all that information around explicitly;
    it just follows your code, doing the right thing in almost all cases. A single
    class is used to manage all the other contexts: `ExecutionContext`.'
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5.2.2 节](kindle_split_020_split_000.html#ch05lev2sec4) 中，我描述了同步上下文，这些上下文用于控制代码执行的线程。这是
    .NET 中许多上下文之一，尽管它可能是最知名的。上下文提供了一种透明地维护信息的环境方式。例如，`SecurityContext` 跟踪当前的安全主体和代码访问安全。你不需要明确传递所有这些信息；它只是跟随你的代码，在几乎所有情况下都做正确的事情。一个类用于管理所有其他上下文：`ExecutionContext`。
- en: '|  |'
  id: totrans-2524
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Deep and scary stuff**'
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: '**深入且令人畏惧的内容**'
- en: I almost didn’t include this section. It’s at the very limits of my knowledge
    about async. If you ever need to know the intimate details, you’ll want to know
    far more about the topic than I’ve included here.
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎不包括这一节。这已经是我对异步了解的极限了。如果你需要了解其细节，你将需要比这里包含的更多关于这个主题的知识。
- en: I’ve covered this at all only because otherwise there’d be no explanation whatsoever
    for having both `AwaitOnCompleted` and `AwaitUnsafeOnCompleted` in the builder
    or why awaiters usually implement `ICriticalNotifyCompletion`.
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以详细说明这一点，仅仅是因为否则就没有任何解释可以解释为什么在构建器中既有 `AwaitOnCompleted` 和 `AwaitUnsafeOnCompleted`，以及为什么等待者通常实现
    `ICriticalNotifyCompletion`。
- en: '|  |'
  id: totrans-2528
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As a reminder, `Task` and `Task<T>` manage the synchronization context for any
    tasks being awaited. If you’re on a UI thread and you await a task, the continuation
    of your async method will be executed on the UI thread, too. You can opt out of
    that by using `Task.ConfigureAwait`. You need that in order to explicitly say
    “I know I don’t need the rest of my method to execute in the same synchronization
    context.” Execution contexts aren’t like that; you pretty much always want the
    same execution context when your async method continues, even if it’s on a different
    thread.
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，`Task` 和 `Task<T>` 管理任何正在等待的任务的同步上下文。如果你在 UI 线程上等待一个任务，你的异步方法的后继将在 UI 线程上执行。你可以通过使用
    `Task.ConfigureAwait` 来选择退出这种模式。你需要这样做，以便明确表示“我知道我的方法的其他部分不需要在相同的同步上下文中执行。”执行上下文并不像那样；当你异步方法继续执行时，你几乎总是希望保持相同的执行上下文，即使它是在不同的线程上。
- en: This preservation of the execution context is called *flow*. An execution context
    is said to flow across await expressions, meaning that all your code operates
    in the same execution context. What makes sure that happens? Well, `AsyncTaskMethodBuilder`
    always does, and `TaskAwaiter` sometimes does. This is where things get tricky.
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
  zh: 这种保持执行上下文的行为被称为 *流*。执行上下文被说成是跨越 await 表达式流动，这意味着所有代码都在相同的执行上下文中操作。是什么确保了这一点呢？嗯，`AsyncTaskMethodBuilder`
    总是这样做，而 `TaskAwaiter` 有时会这样做。这就是事情变得复杂的地方。
- en: The `INotifyCompletion.OnCompleted` method is just a normal method; anyone can
    call it. By contrast, `ICriticalNotifyCompletion.UnsafeOnCompleted` is marked
    with `[SecurityCritical]`. It can be called only by trusted code, such as the
    framework’s `AsyncTaskMethodBuilder` class.
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: '`INotifyCompletion.OnCompleted` 方法只是一个普通的方法；任何人都可以调用它。相比之下，`ICriticalNotifyCompletion.UnsafeOnCompleted`
    被标记为 `[SecurityCritical]`。它只能由受信任的代码调用，例如框架的 `AsyncTaskMethodBuilder` 类。'
- en: If you ever write your own awaiter class and you care about running code correctly
    and safely in partially trusted environments, you should ensure that your `INotifyCompletion.OnCompleted`
    code flows the execution context (via `ExecutionContext.Capture` and `ExecutionContext.Run`).
    You can also implement `ICriticalNotifyCompletion` and not flow the execution
    context in that case, trusting that the async infrastructure will already have
    done so. Effectively, this is an optimization for the common case in which awaiters
    are used only by the async infrastructure. There’s no point in capturing and restoring
    the execution context twice in cases where you can safely do it only once.
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写自己的等待者类，并且关心在部分受信任的环境中正确且安全地运行代码，你应该确保你的 `INotifyCompletion.OnCompleted`
    代码使执行上下文流动（通过 `ExecutionContext.Capture` 和 `ExecutionContext.Run`）。你也可以实现 `ICriticalNotifyCompletion`，在这种情况下不使执行上下文流动，相信异步基础设施已经这样做了。实际上，这为
    awaiter 只由异步基础设施使用的常见情况提供了一种优化。在你可以安全地只做一次的情况下，没有必要捕获和恢复执行上下文两次。
- en: When compiling an async method, the compiler will create a call to either `builder.AwaitOnCompleted`
    or `builder.AwaitUnsafeOnCompleted` at each await expression, depending on whether
    the awaiter implements `ICriticalNotifyCompletion`. Those builder methods are
    generic and have constraints to ensure that the awaiters that are passed into
    them implement the appropriate interface.
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译异步方法时，编译器会在每个 `await` 表达式处创建对 `builder.AwaitOnCompleted` 或 `builder.AwaitUnsafeOnCompleted`
    的调用，具体取决于 `awaiter` 是否实现了 `ICriticalNotifyCompletion`。这些构建器方法是泛型的，并具有约束以确保传递给它们的
    `awaiter` 实现了适当的接口。
- en: 'If you ever implement your own custom task type (and again, that’s extremely
    unlikely for anything other than educational purposes), you should follow the
    same pattern as `AsyncTaskMethodBuilder`: capture the execution context in both
    `AwaitOnCompleted` and `AwaitUnsafeOnCompleted`, so it’s safe to call `ICriticalNotifyCompletion.UnsafeOnCompleted`
    when you’re asked to. Speaking of custom tasks, let’s review the requirements
    for a custom task builder now that you’ve seen how the compiler uses `AsyncTaskMethodBuilder`.'
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经实现过自己的自定义任务类型（并且，再次强调，除了教育目的之外，这几乎是不可能的），你应该遵循 `AsyncTaskMethodBuilder`
    的相同模式：在 `AwaitOnCompleted` 和 `AwaitUnsafeOnCompleted` 中捕获执行上下文，这样在需要时调用 `ICriticalNotifyCompletion.UnsafeOnCompleted`
    是安全的。说到自定义任务，既然你已经看到了编译器如何使用 `AsyncTaskMethodBuilder`，现在让我们回顾一下自定义任务构建器的需求。
- en: 6.5\. Custom task types revisited
  id: totrans-2535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 重新审视自定义任务类型
- en: '[Listing 6.11](kindle_split_021_split_000.html#ch06ex11) shows a repeat of
    the builder part of [listing 5.10](kindle_split_020_split_000.html#ch05ex10),
    where you first looked at custom task types. The set of methods may feel a lot
    more familiar now after you’ve looked at so many decompiled state machines. You
    can use this section as a reminder of how the methods on `AsyncTaskMethodBuilder`
    are called, as the compiler treats all builders the same way.'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6.11](kindle_split_021_split_000.html#ch06ex11) 显示了 [列表 5.10](kindle_split_020_split_000.html#ch05ex10)
    中构建器部分的重复，你首先在那里查看自定义任务类型。在查看了许多反编译的状态机之后，这组方法可能感觉要熟悉得多。你可以使用本节作为 `AsyncTaskMethodBuilder`
    上的方法如何被调用的提醒，因为编译器以相同的方式处理所有构建器。'
- en: Listing 6.11\. A sample custom task builder
  id: totrans-2537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 一个示例自定义任务构建器
- en: '[PRE276]'
  id: totrans-2538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: I’ve grouped the methods in the normal chronological order in which they’re
    called.
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
  zh: 我已按它们被调用的正常时间顺序将方法分组。
- en: The stub method calls `Create` to create a builder instance as part of the newly
    created state machine. It then calls `Start` to make the state machine take the
    first step and returns the result of the `Task` property.
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 存根方法调用 `Create` 来创建构建器实例，作为新创建的状态机的一部分。然后它调用 `Start` 使状态机采取第一步，并返回 `Task` 属性的结果。
- en: Within the state machine, each await expression will generate a call to `AwaitOnCompleted`
    or `AwaitUnsafeOnCompleted` as discussed in the previous section. Assuming a task-like
    design, the first such call will end up calling `IAsyncStateMachine.SetStateMachine`,
    which will in turn call the builder’s `SetStateMachine` so that any boxing is
    resolved in a consistent way. See [section 6.1.4](kindle_split_021_split_000.html#ch06lev2sec4)
    for a reminder of the details.
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态机内部，每个 `await` 表达式将生成对 `AwaitOnCompleted` 或 `AwaitUnsafeOnCompleted` 的调用，正如前一小节所讨论的。假设一个类似任务的设计，第一个这样的调用最终将调用
    `IAsyncStateMachine.SetStateMachine`，这将反过来调用构建器的 `SetStateMachine`，以便以一致的方式解决任何装箱问题。有关详细信息的提醒，请参阅[第
    6.1.4 节](kindle_split_021_split_000.html#ch06lev2sec4)。
- en: Finally, a state machine indicates that the async operation has completed by
    calling either `SetException` or `SetResult` on the builder. That final state
    should be propagated to the custom task that was originally returned by the stub
    method.
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，状态机通过在构建器上调用 `SetException` 或 `SetResult` 来指示异步操作已完成。该最终状态应传播到原始由存根方法返回的自定义任务。
- en: This chapter is by far the deepest dive in this book. Nowhere else do I look
    at the code generated by the C# compiler in such detail. To many developers, everything
    in this chapter would be superfluous; you don’t really need it to write correct
    async code in C#. But for curious developers, I hope it’s been enlightening. You
    may never need to decompile generated code, but having some idea of what’s going
    on under the hood can be useful. And if you ever do need to look at what’s going
    on in detail, I hope this chapter will help you make sense of what you see.
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
  zh: 这章是本书中迄今为止最深入的探讨。在其他地方，我没有如此详细地查看C#编译器生成的代码。对于许多开发者来说，本章中的所有内容似乎都是多余的；你实际上并不需要它来正确编写C#中的异步代码。但对于好奇的开发者，我希望它已经提供了启示。你可能永远不需要反编译生成的代码，但了解底层发生的事情可能会有所帮助。如果你确实需要详细查看正在发生的事情，我希望本章能帮助你理解你所看到的内容。
- en: I’ve taken two chapters to cover the one major feature of C# 5\. In the next
    short chapter, I’ll cover the remaining two features. After the details of async,
    they come as a bit of light relief.
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 我用两章的篇幅来介绍C# 5的一个主要特性。在下一章中，我将介绍剩下的两个特性。在异步的细节之后，它们会带来一些轻松的缓解。
- en: Summary
  id: totrans-2545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Async methods are converted into stub methods and state machines by using builders
    as async infrastructure.
  id: totrans-2546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步方法通过使用构建器作为异步基础设施被转换为存根方法和状态机。
- en: The state machine keeps track of the builder, method parameters, local variables,
    awaiters, and where to resume in a continuation.
  id: totrans-2547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态机跟踪构建器、方法参数、局部变量、awaiters以及在哪里继续执行。
- en: The compiler creates code to get back into the middle of a method when it resumes.
  id: totrans-2548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它恢复时，编译器创建代码以返回方法中的中间位置。
- en: The `INotifyCompletion` and `ICriticalNotifyCompletion` interfaces help control
    execution context flow.
  id: totrans-2549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INotifyCompletion`和`ICriticalNotifyCompletion`接口帮助控制执行上下文流。'
- en: The methods of custom task builders are called by the C# compiler.
  id: totrans-2550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义任务构建器的由C#编译器调用。
- en: Chapter 7\. C# 5 bonus features
  id: totrans-2551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. C# 5新增功能
- en: '|  |'
  id: totrans-2552
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Changes to variable capture in `foreach` loops
  id: totrans-2554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreach`循环中变量捕获的变化'
- en: Caller information attributes
  id: totrans-2555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者信息属性
- en: '|  |'
  id: totrans-2556
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If C# had been designed with book authors in mind, this chapter wouldn’t exist,
    or it’d be a more standard length. I could claim that I wanted to include a very
    short chapter as a sort of palette cleanser after the dish of asynchrony served
    by C# 5 and before the sweetness of C# 6, but the reality is that two more changes
    in C# 5 that need to be covered wouldn’t fit into the async chapters. The first
    of these isn’t so much a feature as a correction to an earlier mistake in the
    language design.
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C#的设计考虑到了图书作者，那么这一章就不会存在，或者它的长度会更标准。我可以说，我想包含一个非常短的章节，作为C# 5提供的异步代码和C# 6的甜蜜之间的调色板清洁剂，但现实是，C#
    5中需要涵盖的两个更多更改无法适应异步章节。其中之一与其说是一个特性，不如说是对语言设计早期错误的一种纠正。
- en: 7.1\. Capturing variables in foreach loops
  id: totrans-2558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 在`foreach`循环中捕获变量
- en: Before C# 5, `foreach` loops were described in the language specification as
    if each loop declared a single *iteration variable*, which was read-only within
    the original code but received a different value for each iteration of the loop.
    For example, in C# 3 a `foreach` loop over a `List<string>` like this
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 5之前，`foreach`循环在语言规范中被描述为每个循环声明一个单独的*迭代变量*，该变量在原始代码中是只读的，但在循环的每次迭代中都会获得不同的值。例如，在C#
    3中，对`List<string>`的`foreach`循环如下
- en: '[PRE277]'
  id: totrans-2560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'would be broadly equivalent to this:'
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 将广泛等同于以下内容：
- en: '[PRE278]'
  id: totrans-2562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '***1* Declaration of single iteration variable**'
  id: totrans-2563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 单个迭代变量的声明**'
- en: '***2* Invisible iterator variable**'
  id: totrans-2564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 不可见的迭代变量**'
- en: '***3* Assigns new value to iteration variable on each iteration**'
  id: totrans-2565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在每次迭代中为迭代变量分配新值**'
- en: '***4* Original body of the foreach loop**'
  id: totrans-2566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* `foreach`循环的原始主体**'
- en: '|  |'
  id: totrans-2567
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The specification has a lot of other details around possible conversions of
    both the collection and the elements, but they’re not relevant to this change.
    Additionally, the scope of the iteration variable is only the scope of the loop;
    you can imagine adding an extra pair of curly braces around the whole code.
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中还有许多关于集合和元素可能转换的其他细节，但它们与这次更改无关。此外，迭代变量的作用域仅限于循环的作用域；你可以想象在整段代码周围添加额外的花括号。
- en: '|  |'
  id: totrans-2570
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In C# 1, this was fine, but it started causing problems way back in C# 2 when
    anonymous methods were introduced. That was the first time that a variable could
    be *captured*, changing its lifetime significantly. A variable is captured when
    it’s used in an anonymous function, and the compiler has to do work behind the
    scenes to make its use feel natural. Although anonymous methods in C# 2 were useful,
    my impression is that it was C# 3, with its lambda expressions and LINQ, that
    really encouraged developers to use delegates more widely.
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 1 中，这没问题，但自从 C# 2 引入匿名方法以来，它开始引起问题。那是第一次一个变量可以被 *捕获*，从而显著改变其生命周期。当一个变量在匿名函数中使用时，它就会被捕获，编译器需要在幕后做工作以使其使用感觉自然。尽管
    C# 2 中的匿名方法很有用，但我的印象是，真正鼓励开发者更广泛地使用委托的是 C# 3，它引入了 lambda 表达式和 LINQ。
- en: What’s the problem with our earlier expansion of the `foreach` loop using just
    a single iteration variable? If that iteration variable is captured in an anonymous
    function for a delegate, then whenever the delegate is invoked, the delegate will
    use the current value of that single variable. The following listing shows a concrete
    example.
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用单个迭代变量扩展 `foreach` 循环时遇到了什么问题？如果这个迭代变量被用于委托的匿名函数中，那么每次委托被调用时，委托将使用该单个变量的当前值。以下列表显示了一个具体的例子。
- en: Listing 7.1\. Capturing the iteration variable in a `foreach` loop
  id: totrans-2573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 在 `foreach` 循环中捕获迭代变量
- en: '[PRE279]'
  id: totrans-2574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '***1* Iterates over the list of names**'
  id: totrans-2575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历名称列表**'
- en: '***2* Creates a delegate that captures name**'
  id: totrans-2576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个捕获名称的委托**'
- en: '***3* Executes all the delegates**'
  id: totrans-2577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 执行所有委托**'
- en: What would you have expected that to print out if I hadn’t been drawing your
    attention to the problem? Most developers would expect it to print `x`, then `y`,
    then `z`. That’s the useful behavior. In reality, with a C# compiler before version
    5, it would’ve printed `z` three times, which is really not helpful.
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有提醒你这个问题，你期望它会打印出什么？大多数开发者会期望它打印 `x`，然后 `y`，然后 `z`。这是有用的行为。实际上，在版本 5 之前的
    C# 编译器中，它会打印 `z` 三次，这实际上并不 helpful。
- en: As of C# 5, the specification for the `foreach` loop has been changed so that
    a new variable is introduced in each iteration of the loop. The exact same code
    in C# 5 and later produces the expected result of `x`, `y`, `z`.
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 5 开始，`foreach` 循环的规范已经改变，以便在循环的每次迭代中引入一个新的变量。在 C# 5 及以后的版本中，相同的代码会产生预期的
    `x`、`y`、`z` 结果。
- en: Note that this change affects only `foreach` loops. If you were to use a regular
    `for` loop instead, you’d still capture only a single variable. The following
    listing is the same as [listing 7.1](kindle_split_022_split_000.html#ch07ex01),
    other than the changes shown in bold.
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个更改仅影响 `foreach` 循环。如果你使用常规的 `for` 循环代替，你仍然只会捕获一个变量。以下列表与 [列表 7.1](kindle_split_022_split_000.html#ch07ex01)
    相同，除了显示加粗的更改。
- en: Listing 7.2\. Capturing the iteration variable in a `for` loop
  id: totrans-2581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 在 `for` 循环中捕获迭代变量
- en: '[PRE280]'
  id: totrans-2582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '***1* Iterates over the list of names**'
  id: totrans-2583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历名称列表**'
- en: '***2* Creates a delegate that captures names and i**'
  id: totrans-2584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个捕获名称和 i 的委托**'
- en: '***3* Executes all the delegates**'
  id: totrans-2585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 执行所有委托**'
- en: This doesn’t print the last name three times; it fails with an `ArgumentOutOfRangeException`,
    because by the time you start executing the delegates, the value of `i` is 3.
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会打印最后一个名字三次；它会因为 `ArgumentOutOfRangeException` 而失败，因为当你开始执行委托时，`i` 的值已经是 3。
- en: 'This isn’t an oversight on the part of the C# design team. It’s just that when
    a `for` loop initializer declares a local variable, it does so once for the whole
    duration of the loop. The syntax of the loop makes that model easy to see, whereas
    the syntax of `foreach` encourages a mental model of one variable per iteration.
    On to our final feature of C# 5: caller information attributes.'
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是 C# 设计团队的疏忽。只是当 `for` 循环初始化器声明一个局部变量时，它在整个循环期间只声明一次。循环的语法使得这种模型很容易看到，而 `foreach`
    循环的语法则鼓励一种每迭代一个变量的心理模型。接下来，我们来看看 C# 5 的最后一个特性：调用者信息属性。
- en: 7.2\. Caller information attributes
  id: totrans-2588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 通话者信息属性
- en: 'Some features are general, such as lambda expressions, implicitly typed local
    variables, generics, and the like. Others are more specific: LINQ is meant to
    be about querying data of some form or other, even though it’s aimed to generalize
    over many data sources. The final C# 5 feature is extremely targeted: there are
    two significant use cases (one obvious, one slightly less so), and I don’t expect
    it to be used much outside those situations.'
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
  zh: 一些功能是通用的，例如 lambda 表达式、隐式类型局部变量、泛型等。其他功能则更具体：LINQ 的目的是查询某种形式的数据，尽管它旨在泛化许多数据源。C#
    5 的最后一个功能非常具体：有两个重要的用例（一个明显，一个稍微不那么明显），我不期望它会在那些情况之外被广泛使用。
- en: 7.2.1\. Basic behavior
  id: totrans-2590
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 基本行为
- en: '.NET 4.5 introduced three new attributes:'
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 4.5 引入了三个新的属性：
- en: '`CallerFilePathAttribute`'
  id: totrans-2592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallerFilePathAttribute`'
- en: '`CallerLineNumberAttribute`'
  id: totrans-2593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallerLineNumberAttribute`'
- en: '`CallerMemberNameAttribute`'
  id: totrans-2594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallerMemberNameAttribute`'
- en: These are all in the `System.Runtime.CompilerServices` namespace. Just as with
    other attributes, when you apply any of these, you can omit the `Attribute` suffix.
    Because that’s the most common way of using attributes, I’ll abbreviate the names
    appropriately for the rest of the book.
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都在 `System.Runtime.CompilerServices` 命名空间中。就像其他属性一样，当你应用这些属性中的任何一个时，你可以省略
    `Attribute` 后缀。因为这是使用属性最常见的方式，所以我在本书的其余部分将适当地缩写这些名称。
- en: 'All three attributes can be applied only to parameters, and they’re useful
    only when they’re applied to optional parameters with appropriate types. The idea
    is simple: if the call site doesn’t provide the argument, the compiler will use
    the current file, line number, or member name to fill in the argument instead
    of taking the normal default value. If the caller does supply an argument, the
    compiler will leave it alone.'
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个属性只能应用于参数，并且只有在它们应用于具有适当类型的可选参数时才有用。这个想法很简单：如果调用位置没有提供参数，编译器将使用当前文件、行号或成员名称来填充参数，而不是采用正常的默认值。如果调用者提供了参数，编译器将保持不变。
- en: '|  |'
  id: totrans-2597
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-2598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The parameter types are almost always `int` or `string` in normal usage. They
    can be other types where appropriate conversions are available. See the specification
    for details if you’re interested, but I’d be surprised if you ever needed to know.
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常使用中，参数类型几乎总是 `int` 或 `string`。在适当的转换可用的情况下，它们可以是其他类型。如果你对此感兴趣，请参阅规范以获取详细信息，但我很惊讶你真的需要知道。
- en: '|  |'
  id: totrans-2600
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing is an example of all three attributes and a mixture of
    compiler-specified and user-specified values.
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是所有三个属性以及编译器指定和用户指定值混合的示例。
- en: Listing 7.3\. Basic demonstration of caller member attributes
  id: totrans-2602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 基本演示调用者成员属性
- en: '[PRE281]'
  id: totrans-2603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '***1* Compiler provides all three arguments from context**'
  id: totrans-2604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 编译器提供上下文中的所有三个参数**'
- en: '***2* Compiler provides only the member name from context**'
  id: totrans-2605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 编译器仅提供上下文中的成员名称**'
- en: 'The output of [listing 7.3](kindle_split_022_split_000.html#ch07ex03) on my
    machine is as follows:'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: 我机器上 [列表 7.3](kindle_split_022_split_000.html#ch07ex03) 的输出如下：
- en: '[PRE282]'
  id: totrans-2607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: You wouldn’t usually give a fake value for any of these arguments, but it’s
    useful to be able to pass the value explicitly, particularly if you want to log
    the current method’s caller using the same attributes.
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不会为这些参数中的任何一个提供虚假值，但能够显式传递这些值是有用的，尤其是如果你想使用相同的属性记录当前方法的调用者时。
- en: The member name works for all members normally in the obvious way. The default
    values for the attributes are usually irrelevant, but we’ll come back to some
    interesting corner cases in [section 7.2.4](kindle_split_022_split_000.html#ch07lev2sec4).
    First, we’ll look at the two common use cases I mentioned earlier. The most universal
    of these is logging.
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 成员名称以通常方式适用于所有成员。属性的默认值通常无关紧要，但我们将回到一些有趣的边缘情况，在[第 7.2.4 节](kindle_split_022_split_000.html#ch07lev2sec4)中。首先，我们将查看我之前提到的两个常见用例。其中最普遍的是日志记录。
- en: 7.2.2\. Logging
  id: totrans-2610
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 日志记录
- en: The most obvious case in which caller information is useful is when writing
    to a log file. Previously when logging, you’d usually construct a stack trace
    (using `System .Diagnostics.StackTrace`, for example) to find out where the log
    call came from. This is typically hidden from view in logging frameworks, but
    it’s still there—and ugly. It’s potentially an issue in terms of performance,
    and it’s brittle in the face of JIT compiler inlining.
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者信息最有用的明显情况是在写入日志文件时。以前在记录日志时，你通常会构建一个堆栈跟踪（例如使用 `System .Diagnostics.StackTrace`），以找出日志调用来自何处。这在日志框架中通常被隐藏起来，但它仍然存在——并且很丑陋。它可能在性能方面成为一个问题，并且面对
    JIT 编译器的内联时很脆弱。
- en: It’s easy to see how a logging framework can use the new feature to allow caller-only
    information to be logged cheaply, even preserving line numbers and member names
    in the face of a build that had debug information stripped and even after obfuscation.
    This doesn’t help when you want to log a full stack trace, of course, but it doesn’t
    take away your ability to do that, either.
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，日志框架如何利用新特性以低成本记录调用者信息，甚至在面对调试信息被移除的构建和混淆之后，仍然可以保留行号和成员名称。当然，这并不能帮助你记录完整的堆栈跟踪，但这也并没有剥夺你记录的能力。
- en: Based on a quick sampling performed at the end of 2017, it appears that this
    functionality hasn’t been used particularly widely yet.^([[1](kindle_split_022_split_000.html#ch07fn1)])
    In particular, I see no sign of it being used in the `ILogger` interface commonly
    used in ASP.NET Core. But it’d be entirely reasonable to write your own extension
    methods for `ILogger` that use these attributes and create an appropriate state
    object to be logged.
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: 基于在2017年底进行的快速抽样，似乎这个功能还没有被特别广泛地使用.^([[1](kindle_split_022_split_000.html#ch07fn1)])
    特别地，我没有看到它在ASP.NET Core中常用的`ILogger`接口中被使用。但是，为`ILogger`编写自己的扩展方法，使用这些属性并创建适当的要记录的状态对象是完全合理的。
- en: ¹
  id: totrans-2614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-2615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: NLog was the only logging framework I found with direct support and then only
    conditionally based on the target framework.
  id: totrans-2616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NLog是我找到的唯一一个具有直接支持的日志框架，而且仅基于目标框架的条件性支持。
- en: It’s not particularly uncommon for projects to include their own primitive logging
    frameworks, which could also be amenable to the use of these attributes. A project-specific
    logging framework is less likely to need to worry about targeting frameworks that
    don’t include the attributes, too.
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目来说，包含它们自己的原始日志框架并不特别罕见，这些日志框架也可能适合使用这些属性。项目特定的日志框架不太可能需要担心针对不包含这些属性的框架。
- en: '|  |'
  id: totrans-2618
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-2619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The lack of an efficient system-level logging framework is a thorny issue. This
    is particularly true for class library developers who wish to provide logging
    facilities but don’t want to add third-party dependencies and don’t know which
    logging frameworks their users will be targeting.
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏一个高效的系统级日志框架是一个棘手的问题。这对于希望提供日志功能但不想添加第三方依赖项且不知道用户将针对哪些日志框架的类库开发者来说尤其如此。
- en: '|  |'
  id: totrans-2621
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Whereas the logging use case needs specific thought on the part of frameworks,
    our second use case is a lot simpler to integrate.
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于日志用例，框架需要具体考虑，我们的第二个用例则简单得多。
- en: 7.2.3\. Simplifying INotifyPropertyChanged implementations
  id: totrans-2623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 简化INotifyPropertyChanged实现
- en: 'The less obvious use of just one of these attributes, `[CallerMemberName]`,
    may be obvious to you if you happen to implement `INotifyPropertyChanged` frequently.
    If you’re not familiar with the `INotifyPropertyChanged` interface, it’s commonly
    used for thick client applications (as opposed to web applications) to allow a
    user interface to respond to a change in model or view model. It’s in the `System.ComponentModel`
    namespace, so it’s not tied to any particular UI technology. It’s used in Windows
    Forms, WPF, and Xamarin Forms, for example. The interface is simple; it’s a single
    event of type `PropertyChangedEventHandler`. This is a delegate type with the
    following signature:'
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个属性，`[CallerMemberName]`的用法可能对经常实现`INotifyPropertyChanged`的人来说很明显。如果你不熟悉`INotifyPropertyChanged`接口，它通常用于厚客户端应用程序（与Web应用程序相对），以允许用户界面响应对模型或视图模型的变化。它在`System.ComponentModel`命名空间中，因此它与任何特定的UI技术无关。例如，它在Windows
    Forms、WPF和Xamarin Forms中使用。该接口很简单；它是一个类型为`PropertyChangedEventHandler`的单个事件。这是一个具有以下签名的委托类型：
- en: '[PRE283]'
  id: totrans-2625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '`PropertyChangedEventArgs`, in turn, has a single constructor:'
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyChangedEventArgs`类有一个单一的构造函数：'
- en: '[PRE284]'
  id: totrans-2627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: A typical implementation of `INotifyPropertyChanged` before C# 5 might look
    something like the following listing.
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 5之前，`INotifyPropertyChanged`的典型实现可能看起来像以下列表。
- en: Listing 7.4\. Implementing `INotifyPropertyChanged` the old way
  id: totrans-2629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 以旧方式实现`INotifyPropertyChanged`
- en: '[PRE285]'
  id: totrans-2630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: The purpose of the helper method is to avoid having to put the nullity check
    in each property. You could easily make it an extension method to avoid repeating
    it on each implementation.
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法的目的在于避免在每个属性中都要进行空值检查。你可以轻松地将其作为一个扩展方法，以避免在每个实现中重复。
- en: This isn’t just long-winded (which hasn’t changed); it’s also brittle. The problem
    is that the name of the property (`FirstValue`) is specified as a string literal,
    and if you refactor the property name to something else, you could easily forget
    to change the string literal. If you’re lucky, your tools and tests will help
    you spot the mistake, but it’s still ugly. You’ll see in [chapter 9](kindle_split_025_split_000.html#ch09)
    that the `nameof` operator introduced in C# 6 would make this code more refactoring
    friendly, but it’d still be prone to copy-and-paste errors.
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是冗长（这并没有改变）；它还非常脆弱。问题是属性的名称（`FirstValue`）被指定为一个字符串字面量，如果你将属性名称重构为其他名称，你很容易忘记更改字符串字面量。如果你很幸运，你的工具和测试将帮助你发现错误，但仍然很丑陋。你将在[第
    9 章](kindle_split_025_split_000.html#ch09)中看到，C# 6 中引入的 `nameof` 运算符将使此代码更易于重构，但它仍然容易受到复制粘贴错误的影响。
- en: With caller info attributes, the majority of the code stays the same, but you
    can make the compiler fill in the property name by using `CallerMemberName` in
    the helper method, as shown in the following listing.
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调用者信息属性，大部分代码保持不变，但你可以在辅助方法中使用 `CallerMemberName` 来让编译器填写属性名称，如下面的列表所示。
- en: Listing 7.5\. Using caller information to implement `INotifyPropertyChanged`
  id: totrans-2634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 使用调用者信息实现 `INotifyPropertyChanged`
- en: '[PRE286]'
  id: totrans-2635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '***1* Changes within the property setter**'
  id: totrans-2636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 属性设置器中的更改**'
- en: '***2* Same method body as before**'
  id: totrans-2637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 与之前相同的方法体**'
- en: I’ve shown only the sections of the code that have changed; it’s that simple.
    Now when you change the name of the property, the compiler will use the new name
    instead. It’s not an earth-shattering improvement, but it’s nicer nonetheless.
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: 我只展示了代码中更改的部分；就这么简单。现在当你更改属性名称时，编译器将使用新的名称。这不是一个翻天覆地的改进，但仍然更好。
- en: Unlike logging, this pattern has been embraced by model-view-viewmodel (MVVM)
    frameworks that provide base classes for view models and models. For example,
    in Xamarin Forms, the `BindableObject` class has an `OnPropertyChanged` method
    using `CallerMemberName`. Similarly, the Caliburn Micro MVVM framework has a `PropertyChangedBase`
    class with a `NotifyOfPropertyChange` method. That’s all you’re likely to need
    to know about caller information attributes, but a few interesting oddities exist,
    particularly with the caller member name.
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: 与日志记录不同，这种模式已被提供视图模型和模型基类的模型-视图-视图模型（MVVM）框架所接受。例如，在 Xamarin Forms 中，`BindableObject`
    类有一个使用 `CallerMemberName` 的 `OnPropertyChanged` 方法。同样，Caliburn Micro MVVM 框架有一个具有
    `NotifyOfPropertyChange` 方法的 `PropertyChangedBase` 类。这就是你可能需要了解的关于调用者信息属性的所有内容，但还有一些有趣的异常情况，尤其是与调用者成员名称相关。
- en: 7.2.4\. Corner cases of caller information attributes
  id: totrans-2640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4\. 调用者信息属性的边缘情况
- en: In almost all cases, it’s obvious which value the compiler should provide for
    caller information attributes. It’s interesting to look at places where it’s not
    obvious, though. I should emphasize that this is mostly a matter of curiosity
    and a spotlight on language design choices rather than on issues that will affect
    regular development. First, a little restriction.
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，很明显编译器应该为调用者信息属性提供哪个值。然而，看看那些不明显的地方也很有趣。我应该强调，这主要是一个好奇的问题和对语言设计选择的一个聚焦，而不是会影响常规开发的问题。首先，有一点限制。
- en: Dynamically invoked members
  id: totrans-2642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态调用的成员
- en: In many ways, the infrastructure around dynamic typing tries hard to apply the
    same rules at execution time as the regular compiler would at compile time. But
    caller information isn’t preserved for this purpose. If the member being invoked
    includes an optional parameter with a caller information attribute but the invocation
    doesn’t include a corresponding argument, the default value specified in the parameter
    is used as if the attribute weren’t present.
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，围绕动态类型的基础设施都尽力在执行时应用与常规编译器在编译时相同的规则。但调用者信息并未为此目的保留。如果被调用的成员包含一个具有调用者信息属性的可选参数，但调用没有包含相应的参数，则使用参数中指定的默认值，就像属性中没有该属性一样。
- en: Aside from anything else, the compiler would have to embed all the line-number
    information for every dynamically invoked member just in case it was required,
    thereby increasing the resulting assembly size for no benefit in 99.9% of cases.
    Then there’s the extra analysis required at execution time to check whether the
    caller information was required, which would potentially disrupt caching, too.
    I suspect that if the C# design team had considered this to be a common and important
    scenario, they’d have found a way to make it work, but I also think it’s entirely
    reasonable that they decided there were more valuable features to spend their
    time on. You just need to be aware of the behavior and accept it, basically. Workarounds
    exist in some cases, though.
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他任何事情之外，编译器必须为每个动态调用的成员嵌入所有行号信息，以防万一需要，从而在不影响99.9%的情况下增加生成的汇编大小。然后还有执行时所需的额外分析，以检查是否需要调用者信息，这可能会干扰缓存。我怀疑如果C#设计团队认为这是一个常见且重要的情况，他们会找到一种使其工作的方式，但我认为他们决定有更多有价值的功能要花费时间在上是完全合理的。基本上，你只需要了解这种行为并接受它。尽管在某些情况下存在解决方案。
- en: If you’re passing a method argument that happens to be dynamic but you don’t
    need it to be, you can cast to the appropriate type instead. At that point, the
    method invocation will be a regular one without any dynamic typing involved.^([[2](kindle_split_022_split_000.html#ch07fn2)])
    If you really need the dynamic behavior but you know that the member you’re invoking
    uses caller information attributes, you can explicitly call a helper method that
    uses the caller information attribute to return the value. It’s a little ugly,
    but this is a corner case anyway. The following listing shows the problem and
    both workarounds.
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递的方法参数碰巧是动态的，但你不需要它是动态的，你可以将其强制转换为适当类型。在那个点上，方法调用将是一个常规调用，不涉及任何动态类型。^([[2](kindle_split_022_split_000.html#ch07fn2)])
    如果你确实需要动态行为，但你知道你调用的成员使用调用者信息属性，你可以显式调用一个使用调用者信息属性来返回值的辅助方法。这有点难看，但这是一个边缘情况。以下列表显示了问题以及两种解决方案。
- en: ²
  id: totrans-2646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-2647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The call will have the additional benefits of compile-time checking that the
    member exists and improved execution-time efficiency, too.
  id: totrans-2648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该调用将具有额外的编译时检查成员存在的好处，以及改进的执行时间效率。
- en: Listing 7.6\. Caller information attributes and dynamic typing
  id: totrans-2649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 调用者信息属性和动态类型
- en: '[PRE287]'
  id: totrans-2650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '***1* Method you’re trying to call that uses the line number**'
  id: totrans-2651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你试图调用的方法，该方法使用行号**'
- en: '***2* Helper method for workaround 2**'
  id: totrans-2652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 解决方案 2 的辅助方法**'
- en: '***3* Simple dynamic call; line will be reported as 0.**'
  id: totrans-2653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 简单动态调用；行号将报告为0。**'
- en: '***4* Workaround 1: cast the value to remove dynamic typing.**'
  id: totrans-2654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 解决方案 1：将值强制转换为移除动态类型。**'
- en: '***5* Workaround 2: explicitly provide the line number using a helper method.**'
  id: totrans-2655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 解决方案 2：使用辅助方法显式提供行号。**'
- en: '[Listing 7.6](kindle_split_022_split_000.html#ch07ex06) prints a line number
    of 0 for the first call but the correct line number for both workarounds. It’s
    a trade-off between having simple code and retaining more information. Neither
    of these workarounds is appropriate when you need to use dynamic overload resolution,
    and some overloads need caller information and some don’t, of course. As limitations
    go, that’s pretty reasonable in my view. Next, let’s think about unusual names.'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.6](kindle_split_022_split_000.html#ch07ex06) 对于第一次调用打印出0行号，但对于两种解决方案都打印出正确的行号。这是在简单代码和保留更多信息之间的一种权衡。当需要使用动态重载解析时，这两种解决方案都不适用，当然，一些重载需要调用者信息，而一些则不需要。在我看来，作为限制来说，这是相当合理的。接下来，让我们考虑不寻常的名称。'
- en: Non-obvious member names
  id: totrans-2657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非直观的成员名称
- en: 'When the caller member name is provided by the compiler and that caller is
    a method, the name is obvious: it’s the name of the method. Not everything is
    a method, though. Here are some cases to consider:'
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用者成员名称由编译器提供且调用者是方法时，名称是明显的：它是方法的名称。但并非所有内容都是方法。以下是一些需要考虑的情况：
- en: Calls from an instance constructor
  id: totrans-2659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从实例构造函数中的调用
- en: Calls from a static constructor
  id: totrans-2660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从静态构造函数中的调用
- en: Calls from a finalizer
  id: totrans-2661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从终结器中的调用
- en: Calls from an operator
  id: totrans-2662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从运算符中的调用
- en: Calls as part of a field, event, or property initializer^([[3](kindle_split_022_split_000.html#ch07fn3)])
  id: totrans-2663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为字段、事件或属性初始化器一部分的调用^([[3](kindle_split_022_split_000.html#ch07fn3)])
- en: ³
  id: totrans-2664
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-2665
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Initializers for automatically implemented properties were introduced in C#
    6\. See [section 8.2.2](kindle_split_024_split_000.html#ch08lev2sec2) for details,
    but if you take a guess at what this means, you’re likely to be right.
  id: totrans-2666
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动实现的属性的初始化器是在C# 6中引入的。有关详细信息，请参阅[第8.2.2节](kindle_split_024_split_000.html#ch08lev2sec2)，但如果你猜测这是什么意思，你很可能会猜对。
- en: Calls from an indexer
  id: totrans-2667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自索引器的调用
- en: The first four of these are specified to be implementation dependent; it’s up
    to the compiler to decide how to treat them. The fifth (initializers) isn’t specified
    at all, and the final one (indexers) is specified to use the name `Item` unless
    `IndexerNameAttribute` has been applied to the indexer.
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个指定为实现相关；由编译器决定如何处理它们。第五个（初始化器）完全没有指定，最后一个（索引器）指定为使用名称`Item`，除非已应用`IndexerNameAttribute`到索引器上。
- en: 'The Roslyn compiler uses the names that are present in the IL for the first
    four: `.ctor`, `.cctor`, `Finalize`, and operator names such as `op_Addition`.
    For initializers, it uses the name of the field, event, or property being initialized.'
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn编译器使用IL中存在的名称，对于前四个：`.ctor`、`.cctor`、`Finalize`以及像`op_Addition`这样的运算符名称。对于初始化器，它使用正在初始化的字段、事件或属性的名称。
- en: 'The downloadable code contains a complete example showing all of these; I haven’t
    included the code here, as the results are more interesting than the code itself.
    All of the names are the most obvious ones to pick, and I’d be surprised to see
    a different compiler pick a different option. I have found a difference between
    compilers for another aspect, however: determining when the compiler should fill
    in caller information attributes at all.'
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
  zh: 可下载的代码包含了一个完整的示例，展示了所有这些内容；我没有在这里包含代码，因为结果比代码本身更有趣。所有的名字都是最明显的选择，我很难想象不同的编译器会选择不同的选项。然而，我在另一个方面发现编译器之间存在差异：确定编译器何时应该填充调用者信息属性。
- en: Implicit constructor invocations
  id: totrans-2671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐式构造函数调用
- en: The C# 5 language specification requires that caller information be used only
    when a function is explicitly invoked in source code, with the exception of query
    expressions that are deemed to be syntactic expansions. Other C# language constructs
    that are pattern based don’t apply to methods with optional parameters anyway,
    but constructor initializers definitely do. (Deconstruction is a C# 7 feature
    described in [section 12.2](kindle_split_029_split_000.html#ch12lev1sec2).) The
    language specification calls out constructors as an example in which caller member
    information isn’t provided by the compiler unless the call is explicit. The following
    listing shows a single abstract base class with a constructor using caller member
    information and three derived classes.
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5语言规范要求仅在源代码中显式调用函数时才使用调用者信息，除非是认为属于语法扩展的查询表达式。其他基于模式的C#语言结构无论如何都不适用于具有可选参数的方法，但构造函数初始化器肯定适用。（解构是C#
    7的一个特性，在[第12.2节](kindle_split_029_split_000.html#ch12lev1sec2)中描述。）语言规范将构造函数作为一个例子，指出除非调用是显式的，否则编译器不会提供调用者成员信息。以下列表显示了一个使用调用者成员信息的单个抽象基类和三个派生类。
- en: Listing 7.7\. Caller information in a constructor
  id: totrans-2673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 构造函数中的调用者信息
- en: '[PRE288]'
  id: totrans-2674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '***1* Base class constructor uses caller info attributes.**'
  id: totrans-2675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 基类构造函数使用调用者信息属性。**'
- en: '***2* Parameterless constructor is added implicitly.**'
  id: totrans-2676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加无参数构造函数是隐式的。**'
- en: '***3* Constructor with implicit call to base()**'
  id: totrans-2677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用隐式调用base()的构造函数**'
- en: '***4* Explicit call to base**'
  id: totrans-2678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显式调用base**'
- en: With Roslyn, only `Derived3` will result in real caller information being shown.
    Both `Derived1` and `Derived2`, in which the call to the `BaseClass` constructor
    is implicit, use the default values specified in the parameters rather than providing
    the filename, line number, and member name.
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Roslyn，只有`Derived3`会显示实际的调用者信息。在`Derived1`和`Derived2`中，由于对`BaseClass`构造函数的调用是隐式的，它们使用参数中指定的默认值，而不是提供文件名、行号和成员名。
- en: This is in line with the C# 5 specification, but I’d argue it’s a design flaw.
    I believe most developers would expect the three derived classes to be precisely
    equivalent. Interestingly, the Mono compiler (`mcs`) currently prints the same
    output for each of these derived classes. We’ll have to wait to see whether the
    language specification changes, the Mono compiler changes, or the incompatibility
    continues into the future.
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 C# 5 规范一致，但我认为这是一个设计缺陷。我相信大多数开发者会期望这三个派生类是精确等价的。有趣的是，Mono 编译器（`mcs`）目前为这些派生类中的每一个都打印出相同的输出。我们将不得不等待，看看语言规范是否会改变，Mono
    编译器是否会改变，或者不兼容性是否会延续到未来。
- en: Query expression invocations
  id: totrans-2681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询表达式调用
- en: As I mentioned before, the language specification calls out query expressions
    as one place where caller information is provided by the compiler even though
    the call is implicit. I doubt that this will be used often, but I’ve provided
    a complete example in the downloadable source code. It requires more code than
    would be sensible to include here, but its use looks like the following listing.
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，语言规范指出查询表达式是编译器提供调用者信息的一个地方，尽管调用是隐式的。我怀疑这会被经常使用，但我已经在可下载的源代码中提供了一个完整的示例。它需要的代码比在这里包含的更合理，但其使用看起来如下所示。
- en: Listing 7.8\. Caller information in query expressions
  id: totrans-2683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 查询表达式中的调用者信息
- en: '[PRE289]'
  id: totrans-2684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '***1* Query expression using methods capturing caller information**'
  id: totrans-2685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用捕获调用者信息的方法的查询表达式**'
- en: '***2* Logs the data**'
  id: totrans-2686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 记录数据**'
- en: '***3* Logs the caller information of the query**'
  id: totrans-2687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 记录查询的调用者信息**'
- en: 'Although it contains a regular query expression, I’ve introduced new extension
    methods (in the same namespace as the example, so they’re found before the `System.Linq`
    ones) containing caller information attributes. The output shows that the caller
    information is captured in the query as well as the data itself:'
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它包含了一个常规的查询表达式，但我引入了新的扩展方法（与示例相同的命名空间，因此它们在 `System.Linq` 之前被找到），包含调用者信息属性。输出显示调用者信息被捕获在查询中，以及数据本身：
- en: '[PRE290]'
  id: totrans-2689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: 'Is this useful? Probably not, to be honest. But it does highlight that when
    the language designers introduced the feature, they had to carefully consider
    a lot of situations. It would’ve been annoying if someone had found a good use
    for caller information from query expressions, but the specification hadn’t made
    it clear what should happen. We have one final kind of member invocation to consider,
    which feels to me like it’s even more subtle than constructor initializers and
    query expressions: attribute instantiation.'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: 这有用吗？坦白说，可能没有。但它确实突出了当语言设计者引入这个特性时，他们必须仔细考虑很多情况。如果有人发现查询表达式中的调用者信息有很好的用途，但规范没有明确说明应该发生什么，那将会很烦人。我们还有最后一种成员调用要考虑，这对我来说甚至比构造函数初始化和查询表达式更微妙：属性实例化。
- en: Attributes with caller information attributes
  id: totrans-2691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 带有调用者信息属性的属性
- en: I tend to think about applying attributes as just specifying extra data. It
    doesn’t feel like it’s invoking anything, but attributes are code too, and when
    an attribute object is constructed (usually to be returned from a reflection call),
    that calls constructors and property setters. What counts as the caller if you
    create an attribute that uses caller information attributes in its constructor?
    Let’s find out.
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于将应用属性视为只是指定额外的数据。它感觉不像是在调用什么，但属性也是代码，当属性对象被构造（通常是为了从反射调用中返回）时，它会调用构造函数和属性设置器。如果你创建一个在构造函数中使用调用者信息属性的属性，调用者是什么？让我们找出答案。
- en: First, you need an attribute class. This part is simple and is shown in the
    following listing.
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个属性类。这部分很简单，如下所示。
- en: Listing 7.9\. Attribute class that captures caller information
  id: totrans-2694
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.9\. 捕获调用者信息的属性类
- en: '[PRE291]'
  id: totrans-2695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: For brevity, this class uses a few features from C# 6, but the interesting aspect
    for now is that the constructor parameters use caller information attributes.
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，这个类使用了 C# 6 的几个特性，但现在的有趣之处在于构造函数参数使用了调用者信息属性。
- en: What happens when you apply our new `MemberDescriptionAttribute`? In the next
    listing, let’s apply it to a class and various aspects of a method and then see
    what you get.
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用我们新的 `MemberDescriptionAttribute` 时会发生什么？在下一个列表中，让我们将其应用于一个类和方法的各个方面，然后看看你得到什么。
- en: Listing 7.10\. Applying the attribute to a class and a method
  id: totrans-2698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 将属性应用于一个类和方法
- en: '[PRE292]'
  id: totrans-2699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '***1* Helps keep the reflection code short**'
  id: totrans-2700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 帮助保持反射代码简短**'
- en: '***2* Applies the attribute to a class**'
  id: totrans-2701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将属性应用于一个类**'
- en: '***3* Applies the attribute to a method in various ways**'
  id: totrans-2702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3. 以多种方式将属性应用于方法***'
- en: 'The `Main` method uses reflection to fetch the attribute from all the places
    you’ve applied it. You could apply `MemberDescriptionAttribute` to other places:
    fields, properties, indexers, and the like. Feel free to experiment with the downloadable
    code to find out exactly what happens. What I find interesting is that the compiler
    is perfectly happy to capture the line number and file path in all cases, but
    it doesn’t use the class name as the member name, so the output is as follows:'
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法使用反射从所有应用了属性的地方获取该属性。您可以将 `MemberDescriptionAttribute` 应用于其他地方：字段、属性、索引器等。请随意使用可下载的代码进行实验，以了解确切会发生什么。我发现有趣的是，编译器在所有情况下都乐于捕获行号和文件路径，但它不使用类名作为成员名称，因此输出如下：'
- en: '[PRE293]'
  id: totrans-2704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Again, this is in the C# 5 specification, to the extent that it specifies the
    behavior when the attribute is applied to a function member (method, property,
    event, and so on) but not to a type. Perhaps it would’ve been more useful to include
    types here as well. They’re defined to be members of namespaces, so it’s not unreasonable
    for a member name to map to a type name.
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这属于C# 5规范的一部分，它规定了当属性应用于函数成员（方法、属性、事件等）而不是类型时的行为。也许将类型也包括在内会更有用。因为类型被定义为命名空间成员，所以成员名称映射到类型名称是合情合理的。
- en: 'Just to reiterate, the reason I included this section was more than for the
    sake of completeness. It highlights some interesting language choices. When is
    it okay for language design to accept limitations to avoid implementation costs?
    When is it reasonable for a language design choice to conflict with user expectations?
    When does it make sense for the specification to explicitly turn a decision into
    an implementation choice? At a meta level, how much time should the language design
    team spend to specify corner cases for a relatively minor feature? One final piece
    of practical detail remains before we close the chapter: enabling this feature
    on frameworks where the attributes don’t exist.'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了再次强调，我包含这一部分的原因不仅仅是为了完整性。它突出了一些有趣的语言选择。在什么情况下，语言设计可以接受限制以避免实现成本？在什么情况下，语言设计的选择与用户期望发生冲突是合理的？在什么情况下，将决策明确转化为实现选择是有意义的？在元层面，语言设计团队应该花多少时间来指定相对较小特性的边缘情况？在我们结束这一章之前，还有最后一个实际细节：在属性不存在的框架上启用此功能。
- en: 7.2.5\. Using caller information attributes with old versions of .NET
  id: totrans-2707
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.5. 使用旧版.NET的调用者信息属性
- en: Hopefully, by now most readers will be targeting .NET 4.5+ or .NET Standard
    1.0+, both of which contain the caller information attributes. But in some cases,
    you’re still able to use a modern compiler but need to target old frameworks.
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在为止，大多数读者都将目标定位在.NET 4.5+或.NET Standard 1.0+上，这两个版本都包含调用者信息属性。但在某些情况下，您仍然可以使用现代编译器，但需要针对旧框架。
- en: In these cases, you can still use the caller information attributes, but you
    need to make the attributes available to the compiler. The simplest way of doing
    this is to use the `Microsoft.Bcl` NuGet package, which provides the attributes
    and many other features provided by later versions of the framework.
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您仍然可以使用调用者信息属性，但您需要使属性对编译器可用。最简单的方法是使用 `Microsoft.Bcl` NuGet 包，它提供了属性以及框架后续版本提供的许多其他功能。
- en: If you can’t use the NuGet package for some reason, you can provide the attributes
    yourself. They’re simple attributes with no parameters or properties, so you can
    copy the declaration directly from the API documentation. They still need to be
    in the `System.Runtime.CompilerServices` namespace. To avoid type collisions,
    you’ll want to make sure these are available only when the system-provided attributes
    aren’t available. This can be tricky (as all versioning tends to be), and the
    details are beyond the scope of this book.
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因您不能使用NuGet包，您可以自己提供属性。它们是没有任何参数或属性的简单属性，因此您可以直接从API文档中复制声明。它们仍然需要位于
    `System.Runtime.CompilerServices` 命名空间中。为了避免类型冲突，您需要确保这些属性仅在系统提供的属性不可用的情况下才可用。这可能很棘手（因为所有版本控制都倾向于如此），而且这些细节超出了本书的范围。
- en: When I started writing this chapter, I hadn’t expected to write as much about
    caller information attributes as I ended up with. I can’t say I use the feature
    much in my day-to-day work, but I find the design aspects fascinating. This isn’t
    in spite of it being a minor feature; it’s because it’s a minor feature. You’d
    expect major features—dynamic typing, generics, async/await—to require significant
    language design work, but minor features can have all kinds of corner cases, too.
    Features often interact with each other, so one of the dangers of introducing
    a new feature is that it might make a future feature harder to design or implement.
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始撰写这一章时，我没有预料到会写这么多关于通话者信息属性的内容。我无法说我日常工作中经常使用这个功能，但我发现其设计方面非常吸引人。这并不是因为这个功能是次要的；恰恰相反，正是因为它是次要的。你可能会预期主要功能——动态类型、泛型、async/await——需要大量的语言设计工作，但次要功能也可能存在各种边缘情况。功能之间通常会有交互，因此引入新功能的一个风险是它可能会使未来的功能设计或实现变得更加困难。
- en: Summary
  id: totrans-2712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Captured `foreach` iteration variables are more useful in C# 5.
  id: totrans-2713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 5 中，捕获的 `foreach` 迭代变量更有用。
- en: You can use caller information attributes to ask the compiler to fill in parameters
    based on the caller’s source file, line number, and member name.
  id: totrans-2714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用通话者信息属性来请求编译器根据调用者的源文件、行号和成员名称填写参数。
- en: Caller information attributes demonstrate the level of detail that language
    design often requires.
  id: totrans-2715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通话者信息属性展示了语言设计通常需要达到的详细程度。
