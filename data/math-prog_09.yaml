- en: Part 2\. Calculus and physical simulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：微积分与物理模拟
- en: In part 2 of this book, we embark on an overview of calculus. Broadly speaking,
    calculus is the study of continuous change, so we talk a lot about how to measure
    rates of change of different quantities and what these rates of change can tell
    us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二部分，我们开始对微积分进行概述。从广义上讲，微积分是连续变化的研究，因此我们谈论了很多如何测量不同量的变化率以及这些变化率可以告诉我们什么。
- en: 'In my opinion, calculus gets a bad rap as a difficult subject because of how
    much algebra is required, not because the concepts are unfamiliar. If you’ve ever
    owned or driven a car, you have an intuitive understanding of rates and cumulative
    values: a speedometer measures your *rate* of movement over time, while an odometer
    measures the *cumulative* miles driven. To some extent their measurements must
    agree. If your speedometer reads a higher value over a period of time, your odometer
    should increase by a larger amount, and vice versa.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，微积分之所以被认为是一门难学的科目，并不是因为其概念不熟悉，而是因为需要大量的代数知识。如果你曾经拥有或驾驶过汽车，你对速度和累积值的直观理解就存在：速度表测量你在一段时间内的移动速度，而里程表测量你驾驶的总里程数。在一定程度上，它们的测量必须一致。如果你的速度表在一段时间内显示的值更高，你的里程表应该增加更多，反之亦然。
- en: In calculus, we learn that if we have a function giving a cumulative value at
    any time, we can calculate its rate of change, also as a function of time. This
    operation of taking a “cumulative” function and returning a “rate” function is
    called a *derivative*. Similarly, if we start with a rate function, we can reconstruct
    a cumulative function that agrees with it, which is an operation called an *integral*.
    We spend all of chapter 8 making sure these conversions make conceptual sense,
    applying it to measured fluid volume (a cumulative function) and fluid flow rate
    (a corresponding rate function). In chapter 9, we extend these ideas to multiple
    dimensions. To simulate a moving object in a video game engine, we need to consider
    the relationship between speed and position in each coordinate independently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在微积分中，我们了解到如果我们有一个在任何时间给出累积值的函数，我们可以计算其变化率，这也是一个随时间变化的函数。将“累积”函数转换为“率”函数的操作称为*导数*。同样，如果我们从一个率函数开始，我们可以重建一个与它一致的累积函数，这称为*积分*操作。我们在第8章中花费了全部时间确保这些转换在概念上是合理的，将其应用于测量的流体体积（一个累积函数）和流体流速（相应的率函数）。在第9章中，我们将这些思想扩展到多个维度。为了在视频游戏引擎中模拟移动对象，我们需要独立考虑每个坐标中速度和位置之间的关系。
- en: Once you get a conceptual understanding of calculus in chapters 8 and 9, we’ll
    cover the mechanics in chapter 10\. We’ll have more fun with this than in an ordinary
    calculus class, because Python will do most of the formula crunching for us. We
    model mathematical expressions like little computer programs, which we can parse
    and transform to find their derivatives and integrals. Chapter 10, therefore,
    shows quite a different approach to doing math in code, and this approach is called
    *symbolic programming*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在第8章和第9章中对微积分有了概念上的理解，我们将在第10章中介绍其机制。我们将比在普通的微积分课程中更有趣，因为Python将为我们做大部分公式计算。我们将数学表达式建模成小程序，我们可以解析和转换它们以找到它们的导数和积分。因此，第10章展示了在代码中做数学的相当不同的方法，这种方法被称为*符号编程*。
- en: In chapter 11, we return to calculus in multiple dimensions. While speed on
    a speedometer or fluid flow rate through a pipe are functions that vary over time,
    we can also have functions that vary over space. These functions take vectors
    as inputs and return numbers or vectors as outputs. For instance, representing
    the strength of gravity as a function over a 2D space allows us to add some interesting
    physics to our video game from chapter 7\. A key calculus operation for functions
    that vary over space is the *gradient*, an operation that tells us the spatial
    direction that a function increases at the highest rate. Because it measures a
    rate, a gradient is like a vector version of an ordinary derivative. In chapter
    12, we use the gradient to *optimize* a function or to find the input for which
    it returns the largest output. By following the direction of the gradient vector,
    we can find increasingly large outputs, and eventually, we can converge on a maximum
    value for the whole function.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章，我们回到多维微积分。虽然速度计上的速度或通过管道的流体流速是随时间变化的函数，但我们也可以有随空间变化的函数。这些函数以向量作为输入，并返回数字或向量作为输出。例如，将重力强度表示为二维空间上的函数，可以使我们为第7章的视频游戏添加一些有趣的物理元素。对于随空间变化的函数，一个关键的微积分操作是*梯度*，这是一个告诉我们函数在哪个空间方向上增加最快的操作。因为它是测量一个率，所以梯度就像是一个普通导数的向量版本。在第12章，我们使用梯度来*优化*一个函数或找到使其返回最大输出的输入。通过跟随梯度向量的方向，我们可以找到越来越大的输出，最终，我们可以收敛到整个函数的最大值。
- en: In chapter 13, we cover a completely different application of calculus. It turns
    out that the integral of a function tells us a lot about the geometry of the graph
    of a function. In particular, integrating the product of two functions tells us
    about how similar their graphs are. We’ll apply this kind of analysis to sound
    waves. A *sound wave* is a graph of a function describing a sound, and the graph
    tells us whether the sound is loud or soft, high or low pitched, and so on. Comparing
    a sound wave with different musical notes, we can find out the musical notes it
    contains. Thinking of a sound wave as a function corresponds to an important mathematical
    concept called a *Fourier series*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13章，我们介绍微积分的另一种完全不同的应用。结果证明，一个函数的积分可以告诉我们很多关于函数图形几何的信息。特别是，两个函数乘积的积分告诉我们它们的图形有多相似。我们将应用这种分析到声波上。*声波*是一个描述声音的函数的图形，这个图形告诉我们声音是响亮还是柔和，是高音还是低音，等等。通过比较不同音符的声波，我们可以找出它包含的音符。将声波视为一个函数，对应于一个重要的数学概念，称为*傅里叶级数*。
- en: As compared to part 1, part 2 is more of a smorgasbord of topics, but there
    are two main themes you should keep your eye on. The first is the concept of the
    rate of change of a function; whether a function is increasing or decreasing at
    a point tells us how to find bigger or smaller values. The second is the idea
    of an operation that takes functions as inputs and returns functions as outputs.
    In calculus, the answer to many questions comes in the form of a function. These
    two ideas will be key to our machine learning applications in part 3.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一部分相比，第二部分更像是一个主题拼盘，但有两个主要主题你应该关注。第一个是函数变化率的观念；一个函数在一点上是增加还是减少，这告诉我们如何找到更大或更小的值。第二个是关于一个操作，它以函数作为输入并返回函数作为输出。在微积分中，许多问题的答案都是以函数的形式出现的。这两个观念将是我们在第三部分机器学习应用中的关键。
