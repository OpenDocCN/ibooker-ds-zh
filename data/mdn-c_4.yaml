- en: Takeaways
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Takeaways
- en: '| **[A](kindle_split_005.html#pref02note01)** C and C++ are different: don’t
    mix them, and don’t mix them up. |  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| **[A](kindle_split_005.html#pref02note01)** C和C++不同：不要混淆它们，也不要将它们混淆。 |  |'
- en: '| **[B](kindle_split_008.html#ch01note01)** Don’t panic. |  |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| **[B](kindle_split_008.html#ch01note01)** 不要慌张。 |  |'
- en: '| **[1.1](kindle_split_008.html#ch01note02)** C is an imperative programming
    language. |  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| **[1.1](kindle_split_008.html#ch01note02)** C是一种命令式编程语言。 |  |'
- en: '| **[1.2](kindle_split_008.html#ch01note03)** C is a compiled programming language.
    |  |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **[1.2](kindle_split_008.html#ch01note03)** C是一种编译型编程语言。 |  |'
- en: '| **[1.3](kindle_split_008.html#ch01note04)** A correct C program is portable
    between different platforms. |  |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| **[1.3](kindle_split_008.html#ch01note04)** 正确的C程序可以在不同的平台上移植。 |  |'
- en: '| **[1.4](kindle_split_008.html#ch01note05)** A C program should compile cleanly
    without warnings. |  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| **[1.4](kindle_split_008.html#ch01note05)** 一个C程序应该无警告地干净编译。 |  |'
- en: '| **[2.1](kindle_split_009.html#ch02note01)** Punctuation characters can be
    used with several different meanings. |  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| **[2.1](kindle_split_009.html#ch02note01)** 标点符号可以有多种不同的含义。 |  |'
- en: '| **[2.2](kindle_split_009.html#ch02note02)** All identifiers in a program
    have to be declared. |  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| **[2.2](kindle_split_009.html#ch02note02)** 程序中的所有标识符都必须声明。 |  |'
- en: '| **[2.3](kindle_split_009.html#ch02note04)** Identifiers may have several
    consistent declarations. |  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **[2.3](kindle_split_009.html#ch02note04)** 标识符可以有多个一致的声明。 |  |'
- en: '| **[2.4](kindle_split_009.html#ch02note05)** Declarations are bound to the
    scope in which they appear. |  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **[2.4](kindle_split_009.html#ch02note05)** 声明绑定到它们出现的范围。 |  |'
- en: '| **[2.5](kindle_split_009.html#ch02note06)** Declarations specify identifiers,
    whereas definitions specify objects. |  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **[2.5](kindle_split_009.html#ch02note06)** 声明指定标识符，而定义指定对象。 |  |'
- en: '| **[2.6](kindle_split_009.html#ch02note07)** An object is defined at the same
    time it is initialized. |  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **[2.6](kindle_split_009.html#ch02note07)** 对象在初始化的同时被定义。 |  |'
- en: '| **[2.7](kindle_split_009.html#ch02note08)** Missing elements in initializers
    default to 0. |  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **[2.7](kindle_split_009.html#ch02note08)** 初始化器中缺失的元素默认为0。 |  |'
- en: '| **[2.8](kindle_split_009.html#ch02note09)** For an array with n elements,
    the first element has index 0, and the last has index n-1. |  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **[2.8](kindle_split_009.html#ch02note09)** 对于具有n个元素的数组，第一个元素的索引为0，最后一个元素的索引为n-1。
    |  |'
- en: '| **[2.9](kindle_split_009.html#ch02note10)** Each object or function must
    have exactly one definition. |  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **[2.9](kindle_split_009.html#ch02note10)** 每个对象或函数必须有一个确切的定义。 |  |'
- en: '| **[2.10](kindle_split_009.html#ch02note11)** Domain iterations should be
    coded with a **for** statement. |  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **[2.10](kindle_split_009.html#ch02note11)** 应使用**for**语句编写域迭代。 |  |'
- en: '| **[2.11](kindle_split_009.html#ch02note12)** The loop variable should be
    defined in the initial part of a **for**. |  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **[2.11](kindle_split_009.html#ch02note12)** 循环变量应在**for**语句的初始部分定义。 |  |'
- en: '| **[3.1](kindle_split_011.html#ch03note01)** The value 0 represents logical
    false. |  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **[3.1](kindle_split_011.html#ch03note01)** 值0表示逻辑假。 |  |'
- en: '| **[3.2](kindle_split_011.html#ch03note02)** Any value different from 0 represents
    logical true. |  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **[3.2](kindle_split_011.html#ch03note02)** 任何非0值表示逻辑真。 |  |'
- en: '| **[3.3](kindle_split_011.html#ch03note04)** Don’t compare to 0, **false**,
    or **true**. |  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **[3.3](kindle_split_011.html#ch03note04)** 不要与0、**false**或**true**进行比较。
    |  |'
- en: '| **[3.4](kindle_split_011.html#ch03note05)** All scalars have a truth value.
    |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **[3.4](kindle_split_011.html#ch03note05)** 所有标量都有一个真值。 |  |'
- en: '| **[3.5](kindle_split_011.html#ch03note09)** **case** values must be integer
    constant expressions. |  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **[3.5](kindle_split_011.html#ch03note09)** **case**值必须是整数常量表达式。 |  |'
- en: '| **[3.6](kindle_split_011.html#ch03note10)** **case** labels must not jump
    beyond a variable definition. |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **[3.6](kindle_split_011.html#ch03note10)** **case**标签不得跳过变量定义。 |  |'
- en: '| **[4.1](kindle_split_012.html#ch04note01)** The type **size_t** represents
    values in the range [0, **SIZE_MAX**]. |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **[4.1](kindle_split_012.html#ch04note01)** 类型**size_t**表示的范围是[0, **SIZE_MAX**]。
    |  |'
- en: '| **[4.2](kindle_split_012.html#ch04note03)** Unsigned arithmetic is always
    well defined. |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **[4.2](kindle_split_012.html#ch04note03)** 无符号算术始终有定义。 |  |'
- en: '| **[4.3](kindle_split_012.html#ch04note04)** The operations +, -, and * on
    **size_t** provide the mathematically correct result if it is representable as
    a **size_t**. |  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **[4.3](kindle_split_012.html#ch04note04)** 对于**size_t**上的+、-和*运算，如果结果可以表示为**size_t**，则提供数学上正确的结果。
    |  |'
- en: '| **[4.4](kindle_split_012.html#ch04note05)** For unsigned values, a == (a/b)*b
    + (a%b). |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **[4.4](kindle_split_012.html#ch04note05)** 对于无符号值，a == (a/b)*b + (a%b)。
    |  |'
- en: '| **[4.5](kindle_split_012.html#ch04note06)** Unsigned / and % are well defined
    only if the second operand is not 0. |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **[4.5](kindle_split_012.html#ch04note06)** 无符号除法和取模运算仅在第二个操作数不为0时定义良好。 |  |'
- en: '| **[4.6](kindle_split_012.html#ch04note07)** Arithmetic on **size_t** implicitly
    does the computation %(**SIZE_MAX**+1). |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **[4.6](kindle_split_012.html#ch04note07)** 对 **size_t** 的算术运算隐式执行计算 %(**SIZE_MAX**+1)。
    |  |'
- en: '| **[4.7](kindle_split_012.html#ch04note08)** In the case of overflow, unsigned
    arithmetic wraps around. |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **[4.7](kindle_split_012.html#ch04note08)** 在溢出情况下，无符号算术会进行环绕。 |  |'
- en: '| **[4.8](kindle_split_012.html#ch04note09)** The result of unsigned / and
    % is always smaller than the operands. |  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **[4.8](kindle_split_012.html#ch04note09)** 无符号除法和取模运算的结果总是小于操作数。 |  |'
- en: '| **[4.9](kindle_split_012.html#ch04note10)** Unsigned / and % can’t overflow.
    |  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **[4.9](kindle_split_012.html#ch04note10)** 无符号除法和取模运算不会溢出。 |  |'
- en: '| **[4.10](kindle_split_012.html#ch04note11)** Operators must have all their
    characters directly attached to each other. |  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **[4.10](kindle_split_012.html#ch04note11)** 运算符的所有字符必须直接相连。 |  |'
- en: '| **[4.11](kindle_split_012.html#ch04note12)** Side effects in value expressions
    are evil. |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **[4.11](kindle_split_012.html#ch04note12)** 值表达式中的副作用是邪恶的。 |  |'
- en: '| **[4.12](kindle_split_012.html#ch04note13)** Never modify more than one object
    in a statement. |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **[4.12](kindle_split_012.html#ch04note13)** 在一个语句中不要修改超过一个对象。 |  |'
- en: '| **[4.13](kindle_split_012.html#ch04note14)** Comparison operators return
    the value **false** or **true**. |  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **[4.13](kindle_split_012.html#ch04note14)** 比较运算符返回值 **false** 或 **true**。
    |  |'
- en: '| **[4.14](kindle_split_012.html#ch04note16)** Logic operators return the value
    **false** or **true**. |  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **[4.14](kindle_split_012.html#ch04note16)** 逻辑运算符返回值 **false** 或 **true**。
    |  |'
- en: '| **[4.15](kindle_split_012.html#ch04note19)** &&, &#124;&#124;, ?:, and ,
    evaluate their first operand first. |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **[4.15](kindle_split_012.html#ch04note19)** &&, ||, ?: 和 , 首先评估它们的第一操作数。
    |  |'
- en: '| **[4.16](kindle_split_012.html#ch04note20)** Don’t use the , operator. |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **[4.16](kindle_split_012.html#ch04note20)** 不要使用逗号运算符。 |  |'
- en: '| **[4.17](kindle_split_012.html#ch04note21)** Most operators don’t sequence
    their operands. |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **[4.17](kindle_split_012.html#ch04note21)** 大多数运算符不会对其操作数进行排序。 |  |'
- en: '| **[4.18](kindle_split_012.html#ch04note22)** Function calls don’t sequence
    their argument expressions. |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **[4.18](kindle_split_012.html#ch04note22)** 函数调用不会对其参数表达式进行排序。 |  |'
- en: '| **[4.19](kindle_split_012.html#ch04note23)** Functions that are called inside
    expressions should not have side effects. |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **[4.19](kindle_split_012.html#ch04note23)** 在表达式内部调用的函数不应有副作用。 |  |'
- en: '| **[5.1](kindle_split_013.html#ch05note01)** C programs primarily reason about
    values and not about their representation. |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **[5.1](kindle_split_013.html#ch05note01)** C程序主要处理值而不是它们的表示。 |  |'
- en: '| **[5.2](kindle_split_013.html#ch05note02)** All values are numbers or translate
    to numbers. |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **[5.2](kindle_split_013.html#ch05note02)** 所有值都是数字或者可以转换为数字。 |  |'
- en: '| **[5.3](kindle_split_013.html#ch05note03)** All values have a type that is
    statically determined. |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **[5.3](kindle_split_013.html#ch05note03)** 所有值都有一个静态确定的类型。 |  |'
- en: '| **[5.4](kindle_split_013.html#ch05note04)** Possible operations on a value
    are determined by its type. |  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **[5.4](kindle_split_013.html#ch05note04)** 值上可能进行的操作由其类型决定。 |  |'
- en: '| **[5.5](kindle_split_013.html#ch05note05)** A value’s type determines the
    results of all operations. |  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **[5.5](kindle_split_013.html#ch05note05)** 值的类型决定了所有操作的结果。 |  |'
- en: '| **[5.6](kindle_split_013.html#ch05note06)** A type’s binary representation
    determines the results of all operations. |  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **[5.6](kindle_split_013.html#ch05note06)** 类型的二进制表示决定了所有操作的结果。 |  |'
- en: '| **[5.7](kindle_split_013.html#ch05note07)** A type’s binary representation
    is observable. |  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **[5.7](kindle_split_013.html#ch05note07)** 类型二进制表示是可观察的。 |  |'
- en: '| **[5.8 (as-if)](kindle_split_013.html#ch05note08)** Programs execute **as
    if** following the abstract state machine. |  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **[5.8 (as-if)](kindle_split_013.html#ch05note08)** 程序执行 **as if** 遵循抽象状态机。
    |  |'
- en: '| **[5.9](kindle_split_013.html#ch05note09)** Type determines optimization
    opportunities. |  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **[5.9](kindle_split_013.html#ch05note09)** 类型决定了优化机会。 |  |'
- en: '| **[5.10](kindle_split_013.html#ch05note10)** Before arithmetic, narrow integer
    types are promoted to **signed int**. |  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **[5.10](kindle_split_013.html#ch05note10)** 在算术运算之前，窄整数类型会被提升为 **signed
    int**。 |  |'
- en: '| **[5.11](kindle_split_013.html#ch05note11)** Each of the four classes of
    base types has three distinct unpromoted types. |  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **[5.11](kindle_split_013.html#ch05note11)** 四种基本类型类中的每一个都有三个不同的未提升类型。 |  |'
- en: '| **[5.12](kindle_split_013.html#ch05note12)** Use **size_t** for sizes, cardinalities,
    or ordinal numbers. |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **[5.12](kindle_split_013.html#ch05note12)** 使用 **size_t** 表示大小、基数或序数。 |  |'
- en: '| **[5.13](kindle_split_013.html#ch05note13)** Use **unsigned** for small quantities
    that can’t be negative. |  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **[5.13](kindle_split_013.html#ch05note13)** 对于不能为负的小量，使用**unsigned**。 |  |'
- en: '| **[5.14](kindle_split_013.html#ch05note14)** Use **signed** for small quantities
    that bear a sign. |  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **[5.14](kindle_split_013.html#ch05note14)** 对于带有符号的小量，使用**signed**。 |  |'
- en: '| **[5.15](kindle_split_013.html#ch05note15)** Use **ptrdiff_t** for large
    differences that bear a sign. |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **[5.15](kindle_split_013.html#ch05note15)** 对于带有符号的大差异，使用**ptrdiff_t**。
    |  |'
- en: '| **[5.16](kindle_split_013.html#ch05note16)** Use **double** for floating-point
    calculations. |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **[5.16](kindle_split_013.html#ch05note16)** 对于浮点计算，使用**double**。 |  |'
- en: '| **[5.17](kindle_split_013.html#ch05note17)** Use **double** **complex** for
    complex calculations. |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **[5.17](kindle_split_013.html#ch05note17)** 对于复杂数学计算，使用**double** **complex**。
    |  |'
- en: '| **[5.18](kindle_split_013.html#ch05note18)** Consecutive string literals
    are concatenated. |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **[5.18](kindle_split_013.html#ch05note18)** 连续的字符串字面量会被连接。 |  |'
- en: '| **[5.19](kindle_split_013.html#ch05note19)** Numerical literals are never
    negative. |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **[5.19](kindle_split_013.html#ch05note19)** 数值字面量从不为负。 |  |'
- en: '| **[5.20](kindle_split_013.html#ch05note20)** Decimal integer constants are
    signed. |  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **[5.20](kindle_split_013.html#ch05note20)** 十进制整数常量是有符号的。 |  |'
- en: '| **[5.21](kindle_split_013.html#ch05note21)** A decimal integer constant has
    the first of the three signed types that fits it. |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **[5.21](kindle_split_013.html#ch05note21)** 十进制整数常量具有适合它的三个有符号类型中的第一个。 |  |'
- en: '| **[5.22](kindle_split_013.html#ch05note22)** The same value can have different
    types. |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **[5.22](kindle_split_013.html#ch05note22)** 同一个值可以有不同的类型。 |  |'
- en: '| **[5.23](kindle_split_013.html#ch05note23)** Don’t use octal or hexadecimal
    constants to express negative values. |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **[5.23](kindle_split_013.html#ch05note23)** 不要使用八进制或十六进制常量来表示负值。 |  |'
- en: '| **[5.24](kindle_split_013.html#ch05note24)** Use decimal constants to express
    negative values. |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **[5.24](kindle_split_013.html#ch05note24)** 使用十进制常量来表示负值。 |  |'
- en: '| **[5.25](kindle_split_013.html#ch05note25)** Different literals can have
    the same value. |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **[5.25](kindle_split_013.html#ch05note25)** 不同的字面量可以具有相同的值。 |  |'
- en: '| **[5.26](kindle_split_013.html#ch05note26)** The effective value of a decimal
    floating-point constant may be different from its literal value. |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **[5.26](kindle_split_013.html#ch05note26)** 十进制浮点常量的有效值可能与其字面值不同。 |  |'
- en: '| **[5.27](kindle_split_013.html#ch05note27)** Literals have value, type, and
    binary representations. |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **[5.27](kindle_split_013.html#ch05note27)** 字面量具有值、类型和二进制表示。 |  |'
- en: '| **[5.28](kindle_split_013.html#ch05note29)** I is reserved for the imaginary
    unit. |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **[5.28](kindle_split_013.html#ch05note29)** I 保留用于虚数单位。 |  |'
- en: '| **[5.29](kindle_split_013.html#ch05note30)** Unary - and + have the type
    of their promoted argument. |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **[5.29](kindle_split_013.html#ch05note30)** 一元减号（-）和加号（+）具有提升后的参数的类型。 |  |'
- en: '| **[5.30](kindle_split_013.html#ch05note31)** Avoid narrowing conversions.
    |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **[5.30](kindle_split_013.html#ch05note31)** 避免缩窄转换。 |  |'
- en: '| **[5.31](kindle_split_013.html#ch05note32)** Don’t use narrow types in arithmetic.
    |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **[5.31](kindle_split_013.html#ch05note32)** 在算术中不要使用窄类型。 |  |'
- en: '| **[5.32](kindle_split_013.html#ch05note33)** Avoid operations with operands
    of different signedness. |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **[5.32](kindle_split_013.html#ch05note33)** 避免具有不同符号的运算数。 |  |'
- en: '| **[5.33](kindle_split_013.html#ch05note34)** Use unsigned types whenever
    you can. |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **[5.33](kindle_split_013.html#ch05note34)** 在可能的情况下，使用无符号类型。 |  |'
- en: '| **[5.34](kindle_split_013.html#ch05note35)** Chose your arithmetic types
    such that implicit conversions are harmless. |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **[5.34](kindle_split_013.html#ch05note35)** 选择算术类型，以确保隐式转换无害。 |  |'
- en: '| **[5.35](kindle_split_013.html#ch05note36)** All variables should be initialized.
    |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **[5.35](kindle_split_013.html#ch05note36)** 所有变量都应该初始化。 |  |'
- en: '| **[5.36](kindle_split_013.html#ch05note37)** Use designated initializers
    for all aggregate data types. |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **[5.36](kindle_split_013.html#ch05note37)** 为所有聚合数据类型使用指定初始化器。 |  |'
- en: '| **[5.37](kindle_split_013.html#ch05note38)** {0} is a valid initializer for
    all object types that are not VLA. |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **[5.37](kindle_split_013.html#ch05note38)** {0}是所有非变长数组（VLA）对象类型的有效初始化器。
    |  |'
- en: '| **[5.38](kindle_split_013.html#ch05note39)** All constants with a particular
    meaning must be named. |  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **[5.38](kindle_split_013.html#ch05note39)** 所有具有特定含义的常量都必须命名。 |  |'
- en: '| **[5.39](kindle_split_013.html#ch05note40)** All constants with different
    meanings must be distinguished. |  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **[5.39](kindle_split_013.html#ch05note40)** 所有具有不同含义的常量都必须区分开来。 |  |'
- en: '| **[5.40](kindle_split_013.html#ch05note41)** An object of **const**-qualified
    type is read-only. |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **[5.40](kindle_split_013.html#ch05note41)** **const**-限定类型的对象是只读的。 |  |'
- en: '| **[5.41](kindle_split_013.html#ch05note42)** String literals are read-only.
    |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **[5.41](kindle_split_013.html#ch05note42)** 字符串字面量是只读的。 |  |'
- en: '| **[5.42](kindle_split_013.html#ch05note43)** Enumeration constants have either
    an explicit or a positional value. |  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **[5.42](kindle_split_013.html#ch05note43)** 枚举常量具有显式或位置值。 |  |'
- en: '| **[5.43](kindle_split_013.html#ch05note44)** Enumeration constants are of
    type **signed int**. |  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **[5.43](kindle_split_013.html#ch05note44)** 枚举常量是 **signed int** 类型。 |  |'
- en: '| **[5.44](kindle_split_013.html#ch05note45)** An integer constant expression
    doesn’t evaluate any object. |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **[5.44](kindle_split_013.html#ch05note45)** 整数常量表达式不评估任何对象。 |  |'
- en: '| **[5.45](kindle_split_013.html#ch05note46)** Macro names are in all caps.
    |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **[5.45](kindle_split_013.html#ch05note46)** 宏名称全部为大写。 |  |'
- en: '| **[5.46](kindle_split_013.html#ch05note47)** A compound literal defines an
    object. |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **[5.46](kindle_split_013.html#ch05note47)** 复合字面量定义了一个对象。 |  |'
- en: '| **[5.47](kindle_split_013.html#ch05note48)** Don’t hide a terminating semicolon
    inside a macro. |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **[5.47](kindle_split_013.html#ch05note48)** 不要在宏内部隐藏终止的分号。 |  |'
- en: '| **[5.48](kindle_split_013.html#ch05note49)** Right-indent continuation markers
    for macros to the same column. |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **[5.48](kindle_split_013.html#ch05note49)** 将宏的缩进续行符右缩进到同一列。 |  |'
- en: '| **[5.49](kindle_split_013.html#ch05note50)** The same value may have different
    binary representations. |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **[5.49](kindle_split_013.html#ch05note50)** 相同的值可能有不同的二进制表示。 |  |'
- en: '| **[5.50](kindle_split_013.html#ch05note51)** Unsigned arithmetic wraps nicely.
    |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **[5.50](kindle_split_013.html#ch05note51)** 无符号算术可以很好地回绕。 |  |'
- en: '| **[5.51](kindle_split_013.html#ch05note53)** The maximum value of any integer
    type is of the form 2*^p* – 1. |  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **[5.51](kindle_split_013.html#ch05note53)** 任何整数类型的最大值形式为 2^p – 1。 |  |'
- en: '| **[5.52](kindle_split_013.html#ch05note54)** Arithmetic on an unsigned integer
    type is determined by its precision. |  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **[5.52](kindle_split_013.html#ch05note54)** 无符号整数类型的算术由其精度决定。 |  |'
- en: '| **[5.53](kindle_split_013.html#ch05note56)** The second operand of a shift
    operation must be less than the precision. |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **[5.53](kindle_split_013.html#ch05note56)** 移位操作的第二操作数必须小于精度。 |  |'
- en: '| **[5.54](kindle_split_013.html#ch05note58)** Positive values are represented
    independently from signedness. |  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **[5.54](kindle_split_013.html#ch05note58)** 正值独立于符号表示。 |  |'
- en: '| **[5.55](kindle_split_013.html#ch05note59)** Once the abstract state machine
    reaches an undefined state, no further assumption about the continuation of the
    execution can be made. |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **[5.55](kindle_split_013.html#ch05note59)** 一旦抽象状态机达到未定义状态，就无法再对执行的后续进行任何假设。
    |  |'
- en: '| **[5.56](kindle_split_013.html#ch05note60)** It is your responsibility to
    avoid undefined behavior of all operations. |  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **[5.56](kindle_split_013.html#ch05note60)** 避免所有操作未定义行为是你的责任。 |  |'
- en: '| **[5.57](kindle_split_013.html#ch05note61)** Signed arithmetic may trap badly.
    |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **[5.57](kindle_split_013.html#ch05note61)** 有符号算术可能会产生严重错误。 |  |'
- en: '| **[5.58](kindle_split_013.html#ch05note62)** In two’s complement representation,
    **INT_MIN** < -**INT_MAX**. |  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **[5.58](kindle_split_013.html#ch05note62)** 在二进制补码表示中，**INT_MIN** < -**INT_MAX**。
    |  |'
- en: '| **[5.59](kindle_split_013.html#ch05note63)** Negation may overflow for signed
    arithmetic. |  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **[5.59](kindle_split_013.html#ch05note63)** 对于有符号算术，取反可能会溢出。 |  |'
- en: '| **[5.60](kindle_split_013.html#ch05note64)** Use unsigned types for bit operations.
    |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **[5.60](kindle_split_013.html#ch05note64)** 对于位操作，使用无符号类型。 |  |'
- en: '| **[5.61](kindle_split_013.html#ch05note67)** If the type uintN_t is provided,
    it is an unsigned integer type with exactly *N* bits of width and precision. |  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **[5.61](kindle_split_013.html#ch05note67)** 如果提供了 uintN_t 类型，它是一个具有精确 *N*
    位宽度和精度的无符号整数类型。 |  |'
- en: '| **[5.62](kindle_split_013.html#ch05note68)** If the type intN_t is provided,
    it is signed, with two’s complement representation and has a width of exactly
    *N* bits and a precision of *N* – 1. |  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **[5.62](kindle_split_013.html#ch05note68)** 如果提供了 intN_t 类型，它是有符号的，采用二进制补码表示，具有精确
    *N* 位的宽度和 *N* – 1 的精度。 |  |'
- en: '| **[5.63](kindle_split_013.html#ch05note69)** If types with the required properties
    exist for values of *N* = 8, 16, 32, and 64, types uintN_t and intN_t, respectively,
    must be provided. |  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **[5.63](kindle_split_013.html#ch05note69)** 如果存在具有所需属性的 *N* = 8, 16, 32,
    和 64 的值类型，则必须提供 uintN_t 和 intN_t 类型，分别对应无符号和有符号整数类型。 |  |'
- en: '| **[5.64](kindle_split_013.html#ch05note70)** For any of the fixed-width types
    that are provided, **_MIN** (only signed), maximum **_MAX**, and literals **_C**
    macros are provided, too. |  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **[5.64](kindle_split_013.html#ch05note70)** 对于提供的任何固定宽度类型，还提供了 **_MIN**（仅限有符号）、最大
    **_MAX** 和字面量 **_C** 宏。 |  |'
- en: '| **[5.65](kindle_split_013.html#ch05note73)** Floating-point operations are
    neither *associative*, *commutative*, nor *distributive*. |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **[5.65](kindle_split_013.html#ch05note73)** 浮点运算既不是*结合律*，也不是*交换律*，也不是*分配律*。
    |  |'
- en: '| **[5.66](kindle_split_013.html#ch05note74)** Never compare floating-point
    values for equality. |  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **[5.66](kindle_split_013.html#ch05note74)** 永远不要比较浮点值是否相等。 |  |'
- en: '| **[6.1](kindle_split_014.html#ch06note01)** Arrays are not pointers. |  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **[6.1](kindle_split_014.html#ch06note01)** 数组不是指针。 |  |'
- en: '| **[6.2](kindle_split_014.html#ch06note02)** An array in a condition evaluates
    to **true**. |  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **[6.2](kindle_split_014.html#ch06note02)** 在条件中评估数组为**true**。 |  |'
- en: '| **[6.3](kindle_split_014.html#ch06note03)** There are array objects but no
    array values. |  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **[6.3](kindle_split_014.html#ch06note03)** 存在数组对象，但没有数组值。 |  |'
- en: '| **[6.4](kindle_split_014.html#ch06note04)** Arrays can’t be compared. |  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **[6.4](kindle_split_014.html#ch06note04)** 数组不能进行比较。 |  |'
- en: '| **[6.5](kindle_split_014.html#ch06note05)** Arrays can’t be assigned to.
    |  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **[6.5](kindle_split_014.html#ch06note05)** 数组不能被赋值。 |  |'
- en: '| **[6.6](kindle_split_014.html#ch06note06)** VLAs can’t have initializers.
    |  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **[6.6](kindle_split_014.html#ch06note06)** 可变长度数组（VLA）不能有初始化器。 |  |'
- en: '| **[6.7](kindle_split_014.html#ch06note07)** VLAs can’t be declared outside
    functions. |  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **[6.7](kindle_split_014.html#ch06note07)** 可变长度数组（VLA）不能在函数外部声明。 |  |'
- en: '| **[6.8](kindle_split_014.html#ch06note08)** The length of an FLA is determined
    by an integer constant expression (ICE) or by an initializer. |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **[6.8](kindle_split_014.html#ch06note08)** 可变长度数组（FLA）的长度由整数常量表达式（ICE）或初始化器确定。
    |  |'
- en: '| **[6.9](kindle_split_014.html#ch06note09)** An array-length specification
    must be strictly positive. |  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **[6.9](kindle_split_014.html#ch06note09)** 数组长度规范必须是严格正数。 |  |'
- en: '| **[6.10](kindle_split_014.html#ch06note10)** An array with a length that
    is not an integer constant expression is a VLA. |  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **[6.10](kindle_split_014.html#ch06note10)** 长度不是整数常量表达式的数组是可变长度数组（VLA）。
    |  |'
- en: '| **[6.11](kindle_split_014.html#ch06note11)** The length of an array A is
    (**sizeof** A)/(**sizeof** A[0]). |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **[6.11](kindle_split_014.html#ch06note11)** 数组A的长度是（**sizeof** A）/（**sizeof**
    A[0]）。 |  |'
- en: '| **[6.12](kindle_split_014.html#ch06note12)** The innermost dimension of an
    array parameter to a function is lost. |  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **[6.12](kindle_split_014.html#ch06note12)** 函数数组参数的最内层维度丢失。 |  |'
- en: '| **[6.13](kindle_split_014.html#ch06note13)** Don’t use the **sizeof** operator
    on array parameters to functions. |  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **[6.13](kindle_split_014.html#ch06note13)** 不要在数组参数上使用**sizeof**运算符。 |  |'
- en: '| **[6.14](kindle_split_014.html#ch06note14)** Array parameters behave *as
    if* the array is *passed by reference**^C*. |  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **[6.14](kindle_split_014.html#ch06note14)** 数组参数的行为*就像*数组是通过引用传递的。 |  |'
- en: '| **[6.15](kindle_split_014.html#ch06note15)** A string is a 0-terminated array
    of **char**. |  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **[6.15](kindle_split_014.html#ch06note15)** 字符串是一个以0结尾的**char**数组。 |  |'
- en: '| **[6.16](kindle_split_014.html#ch06note17)** Using a string function with
    a non-string has undefined behavior. |  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **[6.16](kindle_split_014.html#ch06note17)** 使用非字符串的字符串函数会有未定义行为。 |  |'
- en: '| **[6.17](kindle_split_014.html#ch06note18)** Pointers are opaque objects.
    |  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **[6.17](kindle_split_014.html#ch06note18)** 指针是不透明对象。 |  |'
- en: '| **[6.18](kindle_split_014.html#ch06note19)** Pointers are valid, null, or
    indeterminate. |  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **[6.18](kindle_split_014.html#ch06note19)** 指针是有效的、空的或不确定的。 |  |'
- en: '| **[6.19](kindle_split_014.html#ch06note20)** Initialization or assignment
    with 0 makes a pointer null. |  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **[6.19](kindle_split_014.html#ch06note20)** 使用0进行初始化或赋值会使指针变为空。 |  |'
- en: '| **[6.20](kindle_split_014.html#ch06note21)** In logical expressions, pointers
    evaluate to **false** if they are null. |  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **[6.20](kindle_split_014.html#ch06note21)** 在逻辑表达式中，如果指针为空，则其评估结果为**false**。
    |  |'
- en: '| **[6.21](kindle_split_014.html#ch06note22)** Indeterminate pointers lead
    to undefined behavior. |  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **[6.21](kindle_split_014.html#ch06note22)** 不确定指针会导致未定义行为。 |  |'
- en: '| **[6.22](kindle_split_014.html#ch06note23)** Always initialize pointers.
    |  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **[6.22](kindle_split_014.html#ch06note23)** 总是初始化指针。 |  |'
- en: '| **[6.23](kindle_split_014.html#ch06note25)** Omitted **struct** initializers
    force the corresponding member to 0. |  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **[6.23](kindle_split_014.html#ch06note25)** 省略的结构体初始化器将相应的成员强制设置为0。 |  |'
- en: '| **[6.24](kindle_split_014.html#ch06note26)** A **struct** initializer must
    initialize at least one member. |  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **[6.24](kindle_split_014.html#ch06note26)** 结构体初始化器必须初始化至少一个成员。 |  |'
- en: '| **[6.25](kindle_split_014.html#ch06note27)** **struct** parameters are passed
    by value. |  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **[6.25](kindle_split_014.html#ch06note27)** 结构体参数是通过值传递的。 |  |'
- en: '| **[6.26](kindle_split_014.html#ch06note28)** Structures can be assigned with
    = but not compared with == or !=. |  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **[6.26](kindle_split_014.html#ch06note28)** 结构体可以用=赋值，但不能用==或!=比较。 |  |'
- en: '| **[6.27](kindle_split_014.html#ch06note30)** A structure layout is an important
    design decision. |  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **[6.27](kindle_split_014.html#ch06note30)** 结构布局是一个重要的设计决策。 |  |'
- en: '| **[6.28](kindle_split_014.html#ch06note31)** All **struct** declarations
    in a nested declaration have the same scope of visibility. |  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **[6.28](kindle_split_014.html#ch06note31)** 在嵌套声明中的所有 **struct** 声明具有相同的可见作用域。
    |  |'
- en: '| **[6.29](kindle_split_014.html#ch06note32)** Forward-declare a **struct**
    within a **typedef** using the same identifier as the tag name. |  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **[6.29](kindle_split_014.html#ch06note32)** 在 **typedef** 中使用与标签名相同的标识符来提前声明一个
    **struct**。 |  |'
- en: '| **[6.30](kindle_split_014.html#ch06note33)** A **typedef** only creates an
    alias for a type, but never a new type. |  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **[6.30](kindle_split_014.html#ch06note33)** **typedef** 只创建一个类型的别名，但永远不会创建一个新类型。
    |  |'
- en: '| **[6.31](kindle_split_014.html#ch06note34)** Identifier names terminating
    with **_t** are reserved. |  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **[6.31](kindle_split_014.html#ch06note34)** 以 **_t** 结尾的标识符名称是保留的。 |  |'
- en: '| **[7.1](kindle_split_015.html#ch07note01)** All functions must have prototypes.
    |  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **[7.1](kindle_split_015.html#ch07note01)** 所有函数都必须有原型。 |  |'
- en: '| **[7.2](kindle_split_015.html#ch07note03)** Functions have only one entry
    but can have several **return**s. |  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **[7.2](kindle_split_015.html#ch07note03)** 函数只有一个入口，但可以有多个 **return** 语句。
    |  |'
- en: '| **[7.3](kindle_split_015.html#ch07note04)** A function **return** must be
    consistent with its type. |  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **[7.3](kindle_split_015.html#ch07note04)** 函数的 **return** 必须与其类型一致。 |  |'
- en: '| **[7.4](kindle_split_015.html#ch07note05)** Reaching the end of the {} block
    of a function is equivalent to a **return** statement without an expression. |  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **[7.4](kindle_split_015.html#ch07note05)** 到达函数的 `{}` 块的末尾等同于没有表达式的 **return**
    语句。 |  |'
- en: '| **[7.5](kindle_split_015.html#ch07note06)** Reaching the end of the {} block
    of a function is only allowed for **void** functions. |  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **[7.5](kindle_split_015.html#ch07note06)** 只有对于 **void** 函数，才允许到达函数的 `{}`
    块的末尾。 |  |'
- en: '| **[7.6](kindle_split_015.html#ch07note07)** Use **EXIT_SUCCESS** and **EXIT_FAILURE**
    as return values for **main**. |  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **[7.6](kindle_split_015.html#ch07note07)** 将 **EXIT_SUCCESS** 和 **EXIT_FAILURE**
    作为 **main** 的返回值。 |  |'
- en: '| **[7.7](kindle_split_015.html#ch07note08)** Reaching the end of **main**
    is equivalent to a **return** with value **EXIT_SUCCESS**. |  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **[7.7](kindle_split_015.html#ch07note08)** 到达 **main** 的末尾等同于带有值 **EXIT_SUCCESS**
    的 **return** 语句。 |  |'
- en: '| **[7.8](kindle_split_015.html#ch07note09)** Calling **exit**(s) is equivalent
    to the evaluation of **return** s in **main**. |  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **[7.8](kindle_split_015.html#ch07note09)** 调用 **exit**(s) 等同于在 **main**
    中评估 **return** 语句。 |  |'
- en: '| **[7.9](kindle_split_015.html#ch07note10)** **exit** never fails and never
    returns to its caller. |  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **[7.9](kindle_split_015.html#ch07note10)** **exit** 从不失败，并且从不返回给其调用者。 |  |'
- en: '| **[7.10](kindle_split_015.html#ch07note12)** All command-line arguments are
    transferred as strings. |  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **[7.10](kindle_split_015.html#ch07note12)** 所有命令行参数都作为字符串传递。 |  |'
- en: '| **[7.11](kindle_split_015.html#ch07note13)** Of the arguments to **main**,
    argv[0] holds the name of the program invocation. |  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **[7.11](kindle_split_015.html#ch07note13)** 对于 **main** 的参数，`argv[0]` 包含程序调用的名称。
    |  |'
- en: '| **[7.12](kindle_split_015.html#ch07note14)** Of the arguments to **main**,
    argv[argc] is 0. |  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **[7.12](kindle_split_015.html#ch07note14)** 对于 **main** 的参数，`argv[argc]`
    是 0。 |  |'
- en: '| **[7.13](kindle_split_015.html#ch07note16)** Make all preconditions for a
    function explicit. |  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **[7.13](kindle_split_015.html#ch07note16)** 使一个函数的所有先决条件都明确。 |  |'
- en: '| **[7.14](kindle_split_015.html#ch07note17)** In a recursive function, first
    check the termination condition. |  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **[7.14](kindle_split_015.html#ch07note17)** 在递归函数中，首先检查终止条件。 |  |'
- en: '| **[7.15](kindle_split_015.html#ch07note18)** Ensure the preconditions of
    a recursive function in a wrapper function. |  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **[7.15](kindle_split_015.html#ch07note18)** 确保包装函数中递归函数的先决条件。 |  |'
- en: '| **[7.16](kindle_split_015.html#ch07note19)** Multiple recursion may lead
    to exponential computation times. |  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **[7.16](kindle_split_015.html#ch07note19)** 多重递归可能导致指数级的计算时间。 |  |'
- en: '| **[7.17](kindle_split_015.html#ch07note20)** A bad algorithm will never lead
    to a implementation that performs well. |  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **[7.17](kindle_split_015.html#ch07note20)** 一个糟糕的算法永远不会导致性能良好的实现。 |  |'
- en: '| **[7.18](kindle_split_015.html#ch07note21)** Improving an algorithm can dramatically
    improve performance. |  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **[7.18](kindle_split_015.html#ch07note21)** 改进算法可以显著提高性能。 |  |'
- en: '| **[8.1](kindle_split_016.html#ch08note02)** Failure is always an option.
    |  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **[8.1](kindle_split_016.html#ch08note02)** 失败始终是一个选项。 |  |'
- en: '| **[8.2](kindle_split_016.html#ch08note03)** Check the return value of library
    functions for errors. |  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **[8.2](kindle_split_016.html#ch08note03)** 检查库函数的返回值以查找错误。 |  |'
- en: '| **[8.3](kindle_split_016.html#ch08note04)** Fail fast, fail early, and fail
    often. |  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **[8.3](kindle_split_016.html#ch08note04)** 快速失败，尽早失败，频繁失败。 |  |'
- en: '| **[8.4](kindle_split_016.html#ch08note05)** Identifier names terminating
    with _s are reserved. |  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **[8.4](kindle_split_016.html#ch08note05)** 以 _s 结尾的标识符名称是保留的。 |  |'
- en: '| **[8.5](kindle_split_016.html#ch08note06)** Missed preconditions for the
    execution platform must abort compilation. |  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **[8.5](kindle_split_016.html#ch08note06)** 忽略执行平台的先决条件必须中止编译。 |  |'
- en: '| **[8.6](kindle_split_016.html#ch08note07)** Only evaluate macros and integer
    literals in a preprocessor condition. |  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **[8.6](kindle_split_016.html#ch08note07)** 仅在预处理器条件中评估宏和整数文字。 |  |'
- en: '| **[8.7](kindle_split_016.html#ch08note08)** In preprocessor conditions, unknown
    identifiers evaluate to 0. |  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **[8.7](kindle_split_016.html#ch08note08)** 在预处理器条件中，未知标识符评估为 0。 |  |'
- en: '| **[8.8](kindle_split_016.html#ch08note12)** Opaque types are specified through
    functional interfaces. |  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **[8.8](kindle_split_016.html#ch08note12)** 不透明类型通过功能接口指定。 |  |'
- en: '| **[8.9](kindle_split_016.html#ch08note13)** Don’t rely on implementation
    details of opaque types. |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **[8.9](kindle_split_016.html#ch08note13)** 不要依赖于不透明类型的实现细节。 |  |'
- en: '| **[8.10](kindle_split_016.html#ch08note14)** **puts** and **fputs** differ
    in their end-of-line handling. |  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **[8.10](kindle_split_016.html#ch08note14)** `puts` 和 `fputs` 在换行符处理上有所不同。
    |  |'
- en: '| **[8.11](kindle_split_016.html#ch08note15)** Text input and output converts
    data. |  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **[8.11](kindle_split_016.html#ch08note15)** 文本输入和输出转换数据。 |  |'
- en: '| **[8.12](kindle_split_016.html#ch08note16)** There are three commonly used
    conversions to encode end-of-line. |  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **[8.12](kindle_split_016.html#ch08note16)** 有三种常用的转换用于编码换行符。 |  |'
- en: '| **[8.13](kindle_split_016.html#ch08note17)** Text lines should not contain
    trailing white space. |  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **[8.13](kindle_split_016.html#ch08note17)** 文本行不应包含尾随空白。 |  |'
- en: '| **[8.14](kindle_split_016.html#ch08note18)** Parameters of **printf** must
    exactly correspond to the format specifiers. |  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **[8.14](kindle_split_016.html#ch08note18)** **printf** 的参数必须与格式说明符完全对应。
    |  |'
- en: '| **[8.15](kindle_split_017.html#ch08note19)** Use "%d" and "%u" formats to
    print integer values. |  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **[8.15](kindle_split_017.html#ch08note19)** 使用 "%d" 和 "%u" 格式来打印整数值。 |  |'
- en: '| **[8.16](kindle_split_017.html#ch08note20)** Use the "%x" format to print
    bit patterns. |  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **[8.16](kindle_split_017.html#ch08note20)** 使用 "%x" 格式来打印位模式。 |  |'
- en: '| **[8.17](kindle_split_017.html#ch08note21)** Use the "%g" format to print
    floating-point values. |  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **[8.17](kindle_split_017.html#ch08note21)** 使用 "%g" 格式来打印浮点值。 |  |'
- en: '| **[8.18](kindle_split_017.html#ch08note22)** Using an inappropriate format
    specifier or modifier makes the behavior undefined. |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **[8.18](kindle_split_017.html#ch08note22)** 使用不适当的格式说明符或修饰符会使行为未定义。 |  |'
- en: '| **[8.19](kindle_split_017.html#ch08note23)** Use "%+d", "%#X", and "%a" for
    conversions that have to be read later. |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **[8.19](kindle_split_017.html#ch08note23)** 对于以后需要读取的转换，使用 "%+d", "%#X",
    和 "%a"。 |  |'
- en: '| **[8.20](kindle_split_017.html#ch08note24)** Don’t use **gets**. |  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **[8.20](kindle_split_017.html#ch08note24)** 不要使用 **gets**。 |  |'
- en: '| **[8.21](kindle_split_017.html#ch08note25)** **fgetc** returns **int** to
    be able to encode a special error status, **EOF**, in addition to all valid characters.
    |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **[8.21](kindle_split_017.html#ch08note25)** `fgetc` 返回 `int` 以能够编码一个特殊错误状态，**EOF**，以及所有有效字符。
    |  |'
- en: '| **[8.22](kindle_split_017.html#ch08note26)** End of file can only be detected
    *after* a failed read. |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **[8.22](kindle_split_017.html#ch08note26)** 文件结束只能在使用失败的读取后检测到。 |  |'
- en: '| **[8.23](kindle_split_017.html#ch08note28)** The interpretation of numerically
    encoded characters depends on the execution character set. |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **[8.23](kindle_split_017.html#ch08note28)** 数值编码字符的解释取决于执行字符集。 |  |'
- en: '| **[8.24](kindle_split_017.html#ch08note32)** Regular program termination
    should use a **return** from **main**. |  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **[8.24](kindle_split_017.html#ch08note32)** 正常程序终止应使用从 **main** 的 **return**。
    |  |'
- en: '| **[8.25](kindle_split_017.html#ch08note33)** Use **exit** from a function
    that may terminate the regular control flow. |  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **[8.25](kindle_split_017.html#ch08note33)** 从可能终止常规控制流的函数中使用 **exit**。 |  |'
- en: '| **[8.26](kindle_split_017.html#ch08note34)** Don’t use functions other than
    **exit** for program termination, unless you have to inhibit the execution of
    library cleanups. |  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **[8.26](kindle_split_017.html#ch08note34)** 不要使用除 **exit** 之外的其他函数来终止程序，除非您必须抑制库清理的执行。
    |  |'
- en: '| **[8.27](kindle_split_017.html#ch08note36)** Use as many **assert**s as you
    can to confirm runtime properties. |  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **[8.27](kindle_split_017.html#ch08note36)** 尽可能多地使用 **assert** 来确认运行时属性。
    |  |'
- en: '| **[8.28](kindle_split_017.html#ch08note37)** In production compilations,
    use **NDEBUG** to switch off all **assert**. |  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **[8.28](kindle_split_017.html#ch08note37)** 在生产编译中，使用 **NDEBUG** 来关闭所有 **assert**。
    |  |'
- en: '| **[C](kindle_split_019.html#ch09note01)** All C code must be readable. |  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **[C](kindle_split_019.html#ch09note01)** 所有 C 语言代码都必须易于阅读。 |  |'
- en: '| **[9.1](kindle_split_019.html#ch09note02)** Short-term memory and the field
    of vision are small. |  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **[9.1](kindle_split_019.html#ch09note02)** 短时记忆和视野范围都很小。 |  |'
- en: '| **[9.2](kindle_split_019.html#ch09note03)** Coding style is not a question
    of taste but of culture. |  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **[9.2](kindle_split_019.html#ch09note03)** 编码风格不是品味问题，而是文化问题。 |  |'
- en: '| **[9.3](kindle_split_019.html#ch09note04)** When you enter an established
    project, you enter a new cultural space. |  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **[9.3](kindle_split_019.html#ch09note04)** 当你加入一个成熟的项目时，你就进入了一个新的文化空间。 |  |'
- en: '| **[9.4](kindle_split_019.html#ch09note05)** Choose a consistent strategy
    for white space and other text formatting. |  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **[9.4](kindle_split_019.html#ch09note05)** 选择一致的策略来处理空白和其他文本格式。 |  |'
- en: '| **[9.5](kindle_split_019.html#ch09note06)** Have your text editor automatically
    format your code correctly. |  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **[9.5](kindle_split_019.html#ch09note06)** 让你的文本编辑器自动格式化你的代码。 |  |'
- en: '| **[9.6](kindle_split_019.html#ch09note07)** Choose a consistent naming policy
    for all identifiers. |  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **[9.6](kindle_split_019.html#ch09note07)** 为所有标识符选择一致的命名策略。 |  |'
- en: '| **[9.7](kindle_split_019.html#ch09note09)** Any identifier that is visible
    in a header file must be conforming. |  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **[9.7](kindle_split_019.html#ch09note09)** 在头文件中可见的任何标识符都必须符合规范。 |  |'
- en: '| **[9.8](kindle_split_019.html#ch09note10)** Don’t pollute the global space
    of identifiers. |  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **[9.8](kindle_split_019.html#ch09note10)** 不要污染标识符的全局空间。 |  |'
- en: '| **[9.9](kindle_split_019.html#ch09note12)** Names must be recognizable and
    quickly distinguishable. |  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **[9.9](kindle_split_019.html#ch09note12)** 名称必须易于识别且易于区分。 |  |'
- en: '| **[9.10](kindle_split_019.html#ch09note13)** Naming is a creative act. |  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **[9.10](kindle_split_019.html#ch09note13)** 命名是一种创造性行为。 |  |'
- en: '| **[9.11](kindle_split_019.html#ch09note14)** File-scope identifiers must
    be comprehensive. |  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **[9.11](kindle_split_019.html#ch09note14)** 文件作用域的标识符必须全面。 |  |'
- en: '| **[9.12](kindle_split_019.html#ch09note15)** A type name identifies a concept.
    |  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **[9.12](kindle_split_019.html#ch09note15)** 类型名称标识一个概念。 |  |'
- en: '| **[9.13](kindle_split_019.html#ch09note16)** A global constant identifies
    an artifact. |  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **[9.13](kindle_split_019.html#ch09note16)** 全局常量标识一个工件。 |  |'
- en: '| **[9.14](kindle_split_019.html#ch09note17)** A global variable identifies
    state. |  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **[9.14](kindle_split_019.html#ch09note17)** 全局变量标识状态。 |  |'
- en: '| **[9.15](kindle_split_019.html#ch09note18)** A function or functional macro
    identifies an action. |  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **[9.15](kindle_split_019.html#ch09note18)** 函数或功能宏标识一个动作。 |  |'
- en: '| **[10.1 (what)](kindle_split_020.html#ch10note01)** Function interfaces describe
    *what* is done. |  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **[10.1 (what)](kindle_split_020.html#ch10note01)** 函数接口描述了*做什么*。 |  |'
- en: '| **[10.2 (what for)](kindle_split_020.html#ch10note02)** Interface comments
    document the purpose of a function. |  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **[10.2 (what for)](kindle_split_020.html#ch10note02)** 接口注释记录了函数的目的。 |  |'
- en: '| **[10.3 (how)](kindle_split_020.html#ch10note03)** Function code tells *how*
    the function is organized. |  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **[10.3 (how)](kindle_split_020.html#ch10note03)** 函数代码说明了函数是如何组织的。 |  |'
- en: '| **[10.4 (in which manner)](kindle_split_020.html#ch10note04)** Code comments
    explain the manner in which function details are implemented. |  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **[10.4 (in which manner)](kindle_split_020.html#ch10note04)** 代码注释解释了函数细节是如何实现的。
    |  |'
- en: '| **[10.5](kindle_split_020.html#ch10note05)** Separate interface and implementation.
    |  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **[10.5](kindle_split_020.html#ch10note05)** 分离接口和实现。 |  |'
- en: '| **[10.6](kindle_split_020.html#ch10note06)** Document the interface—explain
    the implementation. |  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **[10.6](kindle_split_020.html#ch10note06)** 记录接口——解释实现。 |  |'
- en: '| **[10.7](kindle_split_020.html#ch10note07)** Document interfaces thoroughly.
    |  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **[10.7](kindle_split_020.html#ch10note07)** 详尽地记录接口。 |  |'
- en: '| **[10.8](kindle_split_020.html#ch10note08)** Structure your code in units
    that have strong semantic connections. |  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **[10.8](kindle_split_020.html#ch10note08)** 以具有强语义连接的单元结构化代码。 |  |'
- en: '| **[10.9](kindle_split_020.html#ch10note09)** Implement literally. |  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **[10.9](kindle_split_020.html#ch10note09)** 逐字实现。 |  |'
- en: '| **[10.10](kindle_split_020.html#ch10note10)** Control flow must be obvious.
    |  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **[10.10](kindle_split_020.html#ch10note10)** 控制流必须明显。 |  |'
- en: '| **[10.11](kindle_split_020.html#ch10note11)** Macros should not change control
    flow in a surprising way. |  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **[10.11](kindle_split_020.html#ch10note11)** 宏不应以令人惊讶的方式改变控制流。 |  |'
- en: '| **[10.12](kindle_split_020.html#ch10note12)** Function-like macros should
    syntactically behave like function calls. |  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **[10.12](kindle_split_020.html#ch10note12)** 函数宏在语法上应像函数调用一样表现。 |  |'
- en: '| **[10.13](kindle_split_020.html#ch10note13)** Function parameters are passed
    by value. |  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **[10.13](kindle_split_020.html#ch10note13)** 函数参数按值传递。 |  |'
- en: '| **[10.14](kindle_split_020.html#ch10note14)** Global variables are frowned
    upon. |  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **[10.14](kindle_split_020.html#ch10note14)** 全局变量不受欢迎。 |  |'
- en: '| **[10.15](kindle_split_020.html#ch10note15)** Express small tasks as pure
    functions whenever possible. |  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **[10.15](kindle_split_020.html#ch10note15)** 在可能的情况下，将小任务表示为纯函数。 |  |'
- en: '| **[11.1](kindle_split_021.html#ch11note01)** Using * with an indeterminate
    or null pointer has undefined behavior. |  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **[11.1](kindle_split_021.html#ch11note01)** 使用 * 与不确定或空指针一起使用将产生未定义行为。 |  |'
- en: '| **[11.2](kindle_split_021.html#ch11note02)** A valid pointer refers to the
    first element of an array of the reference type. |  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **[11.2](kindle_split_021.html#ch11note02)** 一个有效的指针指向引用类型数组的第一个元素。 |  |'
- en: '| **[11.3](kindle_split_021.html#ch11note03)** The length of an array object
    cannot be reconstructed from a pointer. |  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **[11.3](kindle_split_021.html#ch11note03)** 无法从指针重建数组对象的长度。 |  |'
- en: '| **[11.4](kindle_split_021.html#ch11note04)** Pointers are not arrays. |  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **[11.4](kindle_split_021.html#ch11note04)** 指针不是数组。 |  |'
- en: '| **[11.5](kindle_split_021.html#ch11note05)** Only subtract pointers from
    elements of an array object. |  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **[11.5](kindle_split_021.html#ch11note05)** 只从数组对象的元素中减去指针。 |  |'
- en: '| **[11.6](kindle_split_021.html#ch11note06)** All pointer differences have
    type **ptrdiff_t**. |  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **[11.6](kindle_split_021.html#ch11note06)** 所有指针差都具有类型 **ptrdiff_t**。 |  |'
- en: '| **[11.7](kindle_split_021.html#ch11note07)** Use **ptrdiff_t** to encode
    signed differences of positions or sizes. |  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **[11.7](kindle_split_021.html#ch11note07)** 使用 **ptrdiff_t** 来编码位置或大小的有符号差。
    |  |'
- en: '| **[11.8](kindle_split_021.html#ch11note08)** For printing, cast pointer values
    to **void***, and use the format %p. |  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **[11.8](kindle_split_021.html#ch11note08)** 对于打印，将指针值转换为 **void***，并使用格式
    %p。 |  |'
- en: '| **[11.9](kindle_split_021.html#ch11note09)** Pointers have truth. |  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **[11.9](kindle_split_021.html#ch11note09)** 指针有真值。 |  |'
- en: '| **[11.10](kindle_split_021.html#ch11note10)** Set pointer variables to 0
    as soon as you can. |  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **[11.10](kindle_split_021.html#ch11note10)** 一旦可能，就将指针变量设置为 0。 |  |'
- en: '| **[11.11](kindle_split_021.html#ch11note11)** Accessing an object that has
    a trap representation of its type has undefined behavior. |  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **[11.11](kindle_split_021.html#ch11note11)** 访问具有其类型陷阱表示的对象将产生未定义行为。 |  |'
- en: '| **[11.12](kindle_split_021.html#ch11note12)** When dereferenced, a pointed-to
    object must be of the designated type. |  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **[11.12](kindle_split_021.html#ch11note12)** 解引用时，指向的对象必须是指定的类型。 |  |'
- en: '| **[11.13](kindle_split_021.html#ch11note13)** A pointer must point to a valid
    object or one position beyond a valid object or be null. |  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| **[11.13](kindle_split_021.html#ch11note13)** 指针必须指向一个有效的对象或一个有效对象之后的对象或为空。
    |  |'
- en: '| **[11.14](kindle_split_021.html#ch11note14)** Don’t use **NULL**. |  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **[11.14](kindle_split_021.html#ch11note14)** 不要使用 **NULL**。 |  |'
- en: '| **[11.15](kindle_split_021.html#ch11note15)** Don’t hide pointers in a **typedef**.
    |  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **[11.15](kindle_split_021.html#ch11note15)** 不要在 **typedef** 中隐藏指针。 |  |'
- en: '| **[11.16](kindle_split_021.html#ch11note16)** The two expressions A[i] and
    *(A+i) are equivalent. |  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **[11.16](kindle_split_021.html#ch11note16)** 两个表达式 A[i] 和 *(A+i) 是等价的。 |  |'
- en: '| **[11.17 (array decay)](kindle_split_021.html#ch11note17)** Evaluation of
    an array A returns &A[0]. |  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **[11.17 (数组衰减)](kindle_split_021.html#ch11note17)** 数组 A 的评估返回 &A[0]。 |  |'
- en: '| **[11.18](kindle_split_021.html#ch11note18)** In a function declaration,
    any array parameter rewrites to a pointer. |  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **[11.18](kindle_split_021.html#ch11note18)** 在函数声明中，任何数组参数都会重写为指针。 |  |'
- en: '| **[11.19](kindle_split_021.html#ch11note19)** Only the innermost dimension
    of an array parameter is rewritten. |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **[11.19](kindle_split_021.html#ch11note19)** 只重写数组参数的最内层维度。 |  |'
- en: '| **[11.20](kindle_split_021.html#ch11note20)** Declare length parameters before
    array parameters. |  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **[11.20](kindle_split_021.html#ch11note20)** 在数组参数之前声明长度参数。 |  |'
- en: '| **[11.21](kindle_split_021.html#ch11note21)** The validity of array arguments
    to functions must be guaranteed by the programmer. |  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **[11.21](kindle_split_021.html#ch11note21)** 函数的数组参数的有效性必须由程序员保证。 |  |'
- en: '| **[11.22 (function decay)](kindle_split_021.html#ch11note22)** A function
    *f* without a following opening ( decays to a pointer to its start. |  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **[11.22 (函数衰减)](kindle_split_021.html#ch11note22)** 没有后续开括号的函数 *f* 会衰减为其起始位置的指针。
    |  |'
- en: '| **[11.23](kindle_split_021.html#ch11note23)** Function pointers must be used
    with their exact type. |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **[11.23](kindle_split_021.html#ch11note23)** 函数指针必须使用其确切类型。 |  |'
- en: '| **[11.24](kindle_split_021.html#ch11note24)** The function call operator
    (...) applies to function pointers. |  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **[11.24](kindle_split_021.html#ch11note24)** 函数调用运算符 (...) 适用于函数指针。 |  |'
- en: '| **[12.1](kindle_split_022.html#ch12note01)** Pointer types with distinct
    base types are distinct. |  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **[12.1](kindle_split_022.html#ch12note01)** 具有不同基类型的指针类型是不同的。 |  |'
- en: '| **[12.2](kindle_split_022.html#ch12note02)** sizeof(char) is 1 by definition.
    |  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **[12.2](kindle_split_022.html#ch12note02)** 根据定义，sizeof(char) 是 1。 |  |'
- en: '| **[12.3](kindle_split_022.html#ch12note03)** Every object A can be viewed
    as **unsigned char**[**sizeof** A]. |  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **[12.3](kindle_split_022.html#ch12note03)** 每个对象 A 都可以看作是 **unsigned char**[**sizeof(A**)]。
    |  |'
- en: '| **[12.4](kindle_split_022.html#ch12note04)** Pointers to character types
    are special. |  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **[12.4](kindle_split_022.html#ch12note04)** 字符类型指针是特殊的。 |  |'
- en: '| **[12.5](kindle_split_022.html#ch12note05)** Use the type **char** for character
    and string data. |  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **[12.5](kindle_split_022.html#ch12note05)** 使用类型 **char** 用于字符和字符串数据。 |  |'
- en: '| **[12.6](kindle_split_022.html#ch12note06)** Use the type **unsigned char**
    as the atom of all object types. |  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **[12.6](kindle_split_022.html#ch12note06)** 使用类型 **unsigned char** 作为所有对象类型的原子。
    |  |'
- en: '| **[12.7](kindle_split_022.html#ch12note07)** The **sizeof** operator can
    be applied to objects and object types. |  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **[12.7](kindle_split_022.html#ch12note07)** **sizeof** 运算符可以应用于对象和对象类型。
    |  |'
- en: '| **[12.8](kindle_split_022.html#ch12note08)** The size of all objects of type
    T is given by **sizeof(**T). |  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **[12.8](kindle_split_022.html#ch12note08)** 类型 T 的所有对象的尺寸由 **sizeof(T**)
    给出。 |  |'
- en: '| **[12.9](kindle_split_022.html#ch12note09)** The in-memory order of the representation
    digits of an arithmetic type is implementation defined. |  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| **[12.9](kindle_split_022.html#ch12note09)** 算术类型表示数字的内存顺序是实现定义的。 |  |'
- en: '| **[12.10](kindle_split_022.html#ch12note10)** On most architectures, **CHAR_BIT**
    is 8 and **UCHAR_MAX** is 255. |  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **[12.10](kindle_split_022.html#ch12note10)** 在大多数架构上，**CHAR_BIT** 是 8，**UCHAR_MAX**
    是 255。 |  |'
- en: '| **[12.11 (Aliasing)](kindle_split_022.html#ch12note11)** With the exclusion
    of character types, only pointers of the same base type may alias. |  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **[12.11 (Aliasing)](kindle_split_022.html#ch12note11)** 除了字符类型外，只有相同基类型的指针可以别名。
    |  |'
- en: '| **[12.12](kindle_split_022.html#ch12note12)** Avoid the & operator. |  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **[12.12](kindle_split_022.html#ch12note12)** 避免使用 & 运算符。 |  |'
- en: '| **[12.13](kindle_split_022.html#ch12note13)** Any object pointer converts
    to and from **void***. |  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **[12.13](kindle_split_022.html#ch12note13)** 任何对象指针都可以转换为 **void** 并从 **void**
    转换回来。 |  |'
- en: '| **[12.14](kindle_split_022.html#ch12note14)** An object has storage, type,
    and value. |  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **[12.14](kindle_split_022.html#ch12note14)** 对象具有存储、类型和值。 |  |'
- en: '| **[12.15](kindle_split_022.html#ch12note15)** Converting an object pointer
    to **void*** and then back to the same type is the identity operation. |  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **[12.15](kindle_split_022.html#ch12note15)** 将对象指针转换为 **void** 并再转换回相同类型是恒等操作。
    |  |'
- en: '| **[12.16](kindle_split_022.html#ch12note16) (a***void*²***)** A*void* **void***.
    |  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **[12.16](kindle_split_022.html#ch12note16) (a***void*²***)** A*void* **void***。
    |  |'
- en: '| **[12.17](kindle_split_022.html#ch12note17)** Don’t use casts. |  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **[12.17](kindle_split_022.html#ch12note17)** 不要使用类型转换。 |  |'
- en: '| **[12.18 (Effective Type)](kindle_split_022.html#ch12note18)** Objects must
    be accessed through their effective type or through a pointer to a character type.
    |  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **[12.18 (Effective Type)](kindle_split_022.html#ch12note18)** 对象必须通过其有效类型或通过指向字符类型的指针来访问。
    |  |'
- en: '| **[12.19](kindle_split_022.html#ch12note19)** Any member of an object that
    has an effective **union** type can be accessed at any time, provided the byte
    representation amounts to a valid value of the access type. |  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **[12.19](kindle_split_022.html#ch12note19)** 如果字节表示相当于访问类型的有效值，则可以随时访问具有有效
    **union** 类型的对象的任何成员。 |  |'
- en: '| **[12.20](kindle_split_022.html#ch12note20)** The effective type of a variable
    or compound literal is the type of its declaration. |  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **[12.20](kindle_split_022.html#ch12note20)** 变量或复合字面量的有效类型是其声明类型。 |  |'
- en: '| **[12.21](kindle_split_022.html#ch12note21)** Variables and compound literals
    must be accessed through their declared type or through a pointer to a character
    type. |  |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **[12.21](kindle_split_022.html#ch12note21)** 变量和复合字面量必须通过其声明类型或通过指向字符类型的指针来访问。
    |  |'
- en: '| **[13.1](kindle_split_023.html#ch13note02)** Don’t cast the return of **malloc**
    and friends. |  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **[13.1](kindle_split_023.html#ch13note02)** 不要对 **malloc** 和其相关函数的返回值进行类型转换。
    |  |'
- en: '| **[13.2](kindle_split_023.html#ch13note04)** Storage that is allocated through
    **malloc** is uninitialized and has no type. |  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **[13.2](kindle_split_023.html#ch13note04)** 通过**malloc**分配的存储空间未初始化且没有类型。
    |  |'
- en: '| **[13.3](kindle_split_023.html#ch13note05)** **malloc** indicates failure
    by returning a null pointer value. |  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **[13.3](kindle_split_023.html#ch13note05)** **malloc**通过返回空指针值来指示失败。 |  |'
- en: '| **[13.4](kindle_split_023.html#ch13note06)** For every allocation, there
    must be a **free**. |  |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **[13.4](kindle_split_023.html#ch13note06)** 对于每个分配，必须有相应的**free**。 |  |'
- en: '| **[13.5](kindle_split_023.html#ch13note07)** For every **free**, there must
    be a **malloc**, **calloc**, **aligned_alloc**, or **realloc**. |  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **[13.5](kindle_split_023.html#ch13note07)** 对于每个**free**，必须有相应的**malloc**、**calloc**、**aligned_alloc**或**realloc**。
    |  |'
- en: '| **[13.6](kindle_split_023.html#ch13note08)** Only call **free** with pointers
    as they are returned by **malloc**, **calloc**, **aligned_alloc**, or **realloc**.
    |  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **[13.6](kindle_split_023.html#ch13note08)** 只用指针调用**free**，这些指针由**malloc**、**calloc**、**aligned_alloc**或**realloc**返回。
    |  |'
- en: '| **[13.7](kindle_split_023.html#ch13note09)** Identifiers only have visibility
    inside their scope, starting at their declaration. |  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **[13.7](kindle_split_023.html#ch13note09)** 标识符只在它们的声明作用域内可见，从它们的声明开始。 |  |'
- en: '| **[13.8](kindle_split_023.html#ch13note10)** The visibility of an identifier
    can be shadowed by an identifier of the same name in a subordinate scope. |  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **[13.8](kindle_split_023.html#ch13note10)** 标识符的可见性可能被从属作用域中具有相同名称的标识符所遮蔽。
    |  |'
- en: '| **[13.9](kindle_split_023.html#ch13note11)** Every definition of a variable
    creates a new, distinct object. |  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **[13.9](kindle_split_023.html#ch13note11)** 每个变量的定义都会创建一个新的、不同的对象。 |  |'
- en: '| **[13.10](kindle_split_023.html#ch13note12)** Read-only object literals may
    overlap. |  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **[13.10](kindle_split_023.html#ch13note12)** 只读对象字面量可以重叠。 |  |'
- en: '| **[13.11](kindle_split_023.html#ch13note13)** Objects have a lifetime outside
    of which they can’t be accessed. |  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **[13.11](kindle_split_023.html#ch13note13)** 对象有一个生命周期，在此生命周期之外它们无法被访问。
    |  |'
- en: '| **[13.12](kindle_split_023.html#ch13note14)** Referring to an object outside
    of its lifetime has undefined behavior. |  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **[13.12](kindle_split_023.html#ch13note14)** 在对象的生命周期之外引用对象具有未定义的行为。 |  |'
- en: '| **[13.13](kindle_split_023.html#ch13note15)** Objects with static storage
    duration are always initialized. |  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **[13.13](kindle_split_023.html#ch13note15)** 静态存储持续时间的对象总是初始化的。 |  |'
- en: '| **[13.14](kindle_split_023.html#ch13note16)** Unless they are VLA or temporary
    objects, automatic objects have a lifetime corresponding to the execution of their
    block of definition. |  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **[13.14](kindle_split_023.html#ch13note16)** 除非是VLA或临时对象，否则自动对象的生存期与它们的定义块的执行相对应。
    |  |'
- en: '| **[13.15](kindle_split_023.html#ch13note17)** Each recursive call creates
    a new local instance of an automatic object. |  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **[13.15](kindle_split_023.html#ch13note17)** 每次递归调用都会创建一个自动对象的新的局部实例。 |  |'
- en: '| **[13.16](kindle_split_023.html#ch13note18)** The & operator is not allowed
    for variables declared with **register**. |  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **[13.16](kindle_split_023.html#ch13note18)** 对于声明为**register**的变量，不允许使用&运算符。
    |  |'
- en: '| **[13.17](kindle_split_023.html#ch13note19)** Variables declared with **register**
    can’t alias. |  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **[13.17](kindle_split_023.html#ch13note19)** 声明为**register**的变量不能有别名。 |  |'
- en: '| **[13.18](kindle_split_023.html#ch13note20)** Declare local variables that
    are not arrays in performance-critical code as **register**. |  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **[13.18](kindle_split_023.html#ch13note20)** 在性能关键代码中将非数组局部变量声明为**register**。
    |  |'
- en: '| **[13.19](kindle_split_023.html#ch13note21)** Arrays with storage class **register**
    are useless. |  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **[13.19](kindle_split_023.html#ch13note21)** 存储类为**register**的数组是无用的。 |  |'
- en: '| **[13.20](kindle_split_023.html#ch13note22)** Objects of temporary lifetime
    are read-only. |  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **[13.20](kindle_split_023.html#ch13note22)** 临时生命周期的对象是只读的。 |  |'
- en: '| **[13.21](kindle_split_023.html#ch13note23)** Temporary lifetime ends at
    the end of the enclosing full expression. |  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **[13.21](kindle_split_023.html#ch13note23)** 临时生命周期的结束是在包含表达式的末尾。 |  |'
- en: '| **[13.22](kindle_split_023.html#ch13note24)** For an object that is not a
    VLA, lifetime starts when the scope of the definition is entered, and it ends
    when that scope is left. |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **[13.22](kindle_split_023.html#ch13note24)** 对于不是VLA的对象，其生命周期从进入定义的作用域开始，并在离开该作用域时结束。
    |  |'
- en: '| **[13.23](kindle_split_023.html#ch13note25)** Initializers of automatic variables
    and compound literals are evaluated each time the definition is met. |  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **[13.23](kindle_split_023.html#ch13note25)** 自动变量和复合字面量的初始化器在每次遇到定义时都会被评估。
    |  |'
- en: '| **[13.24](kindle_split_023.html#ch13note26)** For a VLA, lifetime starts
    when the definition is encountered and ends when the visibility scope is left.
    |  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| **[13.24](kindle_split_023.html#ch13note26)** 对于 VLA，生命周期从遇到定义开始，到离开可见作用域结束。
    |  |'
- en: '| **[13.25](kindle_split_023.html#ch13note27)** Objects of static or thread-storage
    duration are initialized by default. |  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **[13.25](kindle_split_023.html#ch13note27)** 静态或线程存储持续期的对象默认初始化。 |  |'
- en: '| **[13.26](kindle_split_023.html#ch13note28)** Objects of automatic or allocated
    storage duration must be initialized explicitly. |  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **[13.26](kindle_split_023.html#ch13note28)** 自动或分配存储持续期的对象必须显式初始化。 |  |'
- en: '| **[13.27](kindle_split_023.html#ch13note29)** Systematically provide an initialization
    function for each of your data types. |  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **[13.27](kindle_split_023.html#ch13note29)** 为你的每个数据类型系统地提供一个初始化函数。 |  |'
- en: '| **[14.1](kindle_split_024.html#ch14note01)** The string strto... conversion
    functions are not **const**-safe. |  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **[14.1](kindle_split_024.html#ch14note01)** 字符串 strto... 转换函数不是 **const**-安全的。
    |  |'
- en: '| **[14.2](kindle_split_024.html#ch14note02)** The **memchr** and **strchr**
    search functions are not **const**-safe. |  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **[14.2](kindle_split_024.html#ch14note02)** **memchr** 和 **strchr** 搜索函数不是
    **const**-安全的。 |  |'
- en: '| **[14.3](kindle_split_024.html#ch14note03)** The **strspn** and **strcspn**
    search functions are **const**-safe. |  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **[14.3](kindle_split_024.html#ch14note03)** **strspn** 和 **strcspn** 搜索函数是
    **const**-安全的。 |  |'
- en: '| **[14.4](kindle_split_024.html#ch14note04)** **sprintf** makes no provision
    against buffer overflow. |  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| **[14.4](kindle_split_024.html#ch14note04)** **sprintf** 没有提供防止缓冲区溢出的措施。
    |  |'
- en: '| **[14.5](kindle_split_024.html#ch14note05)** Use **snprintf** when formatting
    output of unknown length. |  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **[14.5](kindle_split_024.html#ch14note05)** 在格式化未知长度的输出时使用 **snprintf**。
    |  |'
- en: '| **[14.6](kindle_split_024.html#ch14note06)** Multibyte characters don’t contain
    null bytes. |  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| **[14.6](kindle_split_024.html#ch14note06)** 多字节字符不包含空字节。 |  |'
- en: '| **[14.7](kindle_split_024.html#ch14note07)** Multibyte strings are null terminated.
    |  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| **[14.7](kindle_split_024.html#ch14note07)** 多字节字符串以空字符结尾。 |  |'
- en: '| **[14.8](kindle_split_024.html#ch14note11)** Open streams on which you use
    **fread** or **fwrite** in binary mode. |  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **[14.8](kindle_split_024.html#ch14note11)** 在二进制模式下使用 **fread** 或 **fwrite**
    的打开流。 |  |'
- en: '| **[14.9](kindle_split_024.html#ch14note12)** Files that are written in binary
    mode are not portable between platforms. |  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **[14.9](kindle_split_024.html#ch14note12)** 以二进制模式写入的文件在不同平台之间不可移植。 |  |'
- en: '| **[14.10](kindle_split_024.html#ch14note13)** **fseek** and **ftell** are
    not suitable for very large file offsets. |  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| **[14.10](kindle_split_024.html#ch14note13)** **fseek** 和 **ftell** 不适合非常大的文件偏移量。
    |  |'
- en: '| **[14.11](kindle_split_024.html#ch14note15)** Labels for **goto** are visible
    in the entire function that contains them. |  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| **[14.11](kindle_split_024.html#ch14note15)** **goto** 标签在包含它们的整个函数中可见。 |  |'
- en: '| **[14.12](kindle_split_024.html#ch14note16)** **goto** can only jump to a
    label inside the same function. |  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| **[14.12](kindle_split_024.html#ch14note16)** **goto** 只能跳转到同一函数内的标签。 |  |'
- en: '| **[14.13](kindle_split_024.html#ch14note17)** **goto** should not jump over
    variable initializations. |  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **[14.13](kindle_split_024.html#ch14note17)** **goto** 不应跳过变量初始化。 |  |'
- en: '| **[D](kindle_split_026.html#ch15note01)** Premature optimization is the root
    of all evil. |  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| **[D](kindle_split_026.html#ch15note01)** 过早优化是万恶之源。 |  |'
- en: '| **[15.1](kindle_split_026.html#ch15note02)** Do not trade off safety for
    performance. |  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **[15.1](kindle_split_026.html#ch15note02)** 不要为了性能而牺牲安全。 |  |'
- en: '| **[15.2](kindle_split_026.html#ch15note03)** Optimizers are clever enough
    to eliminate unused initializations. |  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **[15.2](kindle_split_026.html#ch15note03)** 优化器足够聪明，可以消除未使用的初始化。 |  |'
- en: '| **[15.3](kindle_split_026.html#ch15note04)** The different notations of pointer
    arguments to functions result in the same binary code. |  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **[15.3](kindle_split_026.html#ch15note04)** 函数指针参数的不同表示方式导致相同的二进制代码。 |  |'
- en: '| **[15.4](kindle_split_026.html#ch15note05)** Not taking addresses of local
    variables helps the optimizer because it inhibits aliasing. |  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **[15.4](kindle_split_026.html#ch15note05)** 不取局部变量的地址有助于优化器，因为它抑制了别名。 |  |'
- en: '| **[15.5](kindle_split_026.html#ch15note06)** Inlining can open up a lot of
    optimization opportunities. |  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **[15.5](kindle_split_026.html#ch15note06)** 内联可以打开许多优化机会。 |  |'
- en: '| **[15.6](kindle_split_026.html#ch15note07)** Adding a compatible declaration
    without the **inline** keyword ensures the emission of the function symbol in
    the current TU. |  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **[15.6](kindle_split_026.html#ch15note07)** 添加一个兼容的声明而不使用 **inline** 关键字确保在当前
    TU 中发出函数符号。 |  |'
- en: '| **[15.7](kindle_split_026.html#ch15note08)** An **inline** function definition
    is visible in all TUs. |  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **[15.7](kindle_split_026.html#ch15note08)** 内联函数的定义在所有TUs中都是可见的。 |  |'
- en: '| **[15.8](kindle_split_026.html#ch15note09)** An **inline** *definition* goes
    in a header file. |  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **[15.8](kindle_split_026.html#ch15note09)** 内联的定义放在头文件中。 |  |'
- en: '| **[15.9](kindle_split_026.html#ch15note10)** An additional *declaration*
    without **inline** goes in exactly one TU. |  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **[15.9](kindle_split_026.html#ch15note10)** 没有使用**inline**的额外*声明*将放在恰好一个TUs中。
    |  |'
- en: '| **[15.10](kindle_split_026.html#ch15note11)** Only expose functions as **inline**
    if you consider them to be stable. |  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **[15.10](kindle_split_026.html#ch15note11)** 只有在你认为它们是稳定的时，才将函数暴露为**inline**。
    |  |'
- en: '| **[15.11](kindle_split_026.html#ch15note12)** All identifiers that are local
    to an **inline** function should be protected by a convenient naming convention.
    |  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **[15.11](kindle_split_026.html#ch15note12)** 所有属于内联函数本地的标识符都应该通过方便的命名约定来保护。
    |  |'
- en: '| **[15.12](kindle_split_026.html#ch15note13)** **inline** functions can’t
    access *identifiers* of **static** functions. |  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **[15.12](kindle_split_026.html#ch15note13)** 内联函数不能访问静态函数的*标识符*。 |  |'
- en: '| **[15.13](kindle_split_026.html#ch15note14)** **inline** functions can’t
    define or access *identifiers* of modifiable **static** objects. |  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **[15.13](kindle_split_026.html#ch15note14)** 内联函数不能定义或访问可修改的静态对象的*标识符*。
    |  |'
- en: '| **[15.14](kindle_split_026.html#ch15note15)** A **restrict**-qualified pointer
    has to provide exclusive access. |  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **[15.14](kindle_split_026.html#ch15note15)** 带有**restrict**限定符的指针必须提供独占访问。
    |  |'
- en: '| **[15.15](kindle_split_026.html#ch15note16)** A **restrict**-qualification
    constrains the caller of a function. |  |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **[15.15](kindle_split_026.html#ch15note16)** 当你考虑它们是稳定的时，才将函数暴露为**inline**。
    |  |'
- en: '| **[E](kindle_split_026.html#ch15note17)** Don’t speculate about the performance
    of code; verify it rigorously. |  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **[E](kindle_split_026.html#ch15note17)** 不要推测代码的性能；要严格验证。 |  |'
- en: '| **[15.16](kindle_split_026.html#ch15note18)** Complexity assessment of algorithms
    requires proofs. |  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **[15.16](kindle_split_026.html#ch15note18)** 算法复杂度评估需要证明。 |  |'
- en: '| **[15.17](kindle_split_026.html#ch15note19)** Performance assessment of code
    requires measurement. |  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **[15.17](kindle_split_026.html#ch15note19)** 代码的性能评估需要测量。 |  |'
- en: '| **[15.18](kindle_split_026.html#ch15note20)** All measurements introduce
    bias. |  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| **[15.18](kindle_split_026.html#ch15note20)** 所有测量都会引入偏差。 |  |'
- en: '| **[15.19](kindle_split_026.html#ch15note21)** Instrumentation changes compile-time
    and runtime properties. |  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| **[15.19](kindle_split_026.html#ch15note21)** 仪器更改会改变编译时和运行时属性。 |  |'
- en: '| **[15.20](kindle_split_026.html#ch15note22)** The relative standard deviation
    of run times must be in a low percentage range. |  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **[15.20](kindle_split_026.html#ch15note22)** 运行时间的相对标准偏差必须在低百分比范围内。 |  |'
- en: '| **[15.21](kindle_split_026.html#ch15note23)** Collecting higher-order moments
    of measurements to compute variance and skew is simple and cheap. |  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **[15.21](kindle_split_026.html#ch15note23)** 收集测量值的高阶矩以计算方差和偏斜是简单且经济的。 |  |'
- en: '| **[15.22](kindle_split_026.html#ch15note24)** Runtime measurements must be
    hardened with statistics. |  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| **[15.22](kindle_split_026.html#ch15note24)** 运行时测量必须通过统计方法来强化。 |  |'
- en: '| **[16.1](kindle_split_027.html#ch16note02)** Whenever possible, prefer an
    **inline** function to a functional macro. |  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **[16.1](kindle_split_027.html#ch16note02)** 在可能的情况下，优先选择内联函数而不是功能宏。 |  |'
- en: '| **[16.2](kindle_split_027.html#ch16note03)** A functional macro shall provide
    a simple interface to a complex task. |  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **[16.2](kindle_split_027.html#ch16note03)** 功能宏应提供一个简单的接口来执行复杂任务。 |  |'
- en: '| **[16.3](kindle_split_027.html#ch16note04)** Macro replacement is done in
    an early translation phase, before any other interpretation is given to the tokens
    that compose the program. |  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **[16.3](kindle_split_027.html#ch16note04)** 宏替换是在早期翻译阶段完成的，在给程序组成的标记赋予任何其他解释之前。
    |  |'
- en: '| **[16.4 (macro retention)](kindle_split_027.html#ch16note05)** If a functional
    macro is not followed by (), it is not expanded. |  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| **[16.4 (macro retention)](kindle_split_027.html#ch16note05)** 如果一个功能宏后面没有跟括号（()），则它不会被展开。
    |  |'
- en: '| **[16.5](kindle_split_027.html#ch16note06)** The line number in **__LINE__**
    may not fit into an **int**. |  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **[16.5](kindle_split_027.html#ch16note06)** **__LINE__**中的行号可能无法放入一个**int**中。
    |  |'
- en: '| **[16.6](kindle_split_027.html#ch16note07)** Using **__LINE__** is inherently
    dangerous. |  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| **[16.6](kindle_split_027.html#ch16note07)** 使用**__LINE__**固有的很危险。 |  |'
- en: '| **[16.7](kindle_split_027.html#ch16note08)** Stringification with the operator
    **#** does not expand macros in its argument. |  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| **[16.7](kindle_split_027.html#ch16note08)** 使用操作符**#**进行字符串化不会展开其参数中的宏。
    |  |'
- en: '| **[16.8](kindle_split_027.html#ch16note09)** When passed to a variadic parameter,
    all arithmetic types are converted as for arithmetic operations, with the exception
    of **float** arguments, which are converted to **double**. |  |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **[16.8](kindle_split_027.html#ch16note09)** 当传递给可变参数时，所有算术类型都按算术运算的方式转换，除了
    **float** 参数，它们被转换为 **double**。 |  |'
- en: '| **[16.9](kindle_split_027.html#ch16note10)** A variadic function has to receive
    valid information about the type of each argument in the variadic list. |  |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| **[16.9](kindle_split_027.html#ch16note10)** 可变参数函数必须接收有关可变列表中每个参数类型的有效信息。
    |  |'
- en: '| **[16.10](kindle_split_027.html#ch16note11)** Using variadic functions is
    not portable unless each argument is forced to a specific type. |  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **[16.10](kindle_split_027.html#ch16note11)** 除非每个参数都强制转换为特定类型，否则使用可变参数函数是不可移植的。
    |  |'
- en: '| **[16.11](kindle_split_027.html#ch16note12)** Avoid variadic functions for
    new interfaces. |  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| **[16.11](kindle_split_027.html#ch16note12)** 避免在新的接口中使用可变参数函数。 |  |'
- en: '| **[16.12](kindle_split_027.html#ch16note14)** The **va_arg** mechanism doesn’t
    give access to the length of the **va_list**. |  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **[16.12](kindle_split_027.html#ch16note14)** **va_arg** 机制不提供对 **va_list**
    长度的访问。 |  |'
- en: '| **[16.13](kindle_split_027.html#ch16note15)** A variadic function needs a
    specific convention for the length of the list. |  |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| **[16.13](kindle_split_027.html#ch16note15)** 可变参数函数需要一个特定的约定来指定列表的长度。 |  |'
- en: '| **[16.14](kindle_split_027.html#ch16note17)** The result type of a **_Generic**
    expression is the type of the chosen expression. |  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| **[16.14](kindle_split_027.html#ch16note17)** **_Generic** 表达式的结果类型是所选表达式的类型。
    |  |'
- en: '| **[16.15](kindle_split_027.html#ch16note18)** Using **_Generic** with **inline**
    functions adds optimization opportunities. |  |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| **[16.15](kindle_split_027.html#ch16note18)** 使用 **_Generic** 与 **inline**
    函数一起使用可以增加优化机会。 |  |'
- en: '| **[16.16](kindle_split_027.html#ch16note19)** The type expressions in a **_Generic**
    expression should only be unqualified types: no array types, and no function types.
    |  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| **[16.16](kindle_split_027.html#ch16note19)** **_Generic** 表达式中的类型表达式应该是无修饰的类型：没有数组类型，也没有函数类型。
    |  |'
- en: '| **[16.17](kindle_split_027.html#ch16note20)** The type expressions in a **_Generic**
    expression must refer to mutually incompatible types. |  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| **[16.17](kindle_split_027.html#ch16note20)** **_Generic** 表达式中的类型表达式必须引用相互不兼容的类型。
    |  |'
- en: '| **[16.18](kindle_split_027.html#ch16note21)** The type expressions in a **_Generic**
    expression cannot be a pointer to a VLA. |  |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **[16.18](kindle_split_027.html#ch16note21)** 在一个 **_Generic** 表达式中的类型表达式不能是一个指向
    VLA 的指针。 |  |'
- en: '| **[16.19](kindle_split_027.html#ch16note22)** All choices *expression1* ...
    *expressionN* in a **_Generic** must be valid. |  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| **[16.19](kindle_split_027.html#ch16note22)** 在 **_Generic** 中的所有选择 *expression1*
    ... *expressionN* 必须是有效的。 |  |'
- en: '| **[17.1](kindle_split_028.html#ch17note01)** Side effects in functions can
    lead to indeterminate results. |  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| **[17.1](kindle_split_028.html#ch17note01)** 函数中的副作用可能导致不确定的结果。 |  |'
- en: '| **[17.2](kindle_split_028.html#ch17note02)** The specific operation of any
    operator is sequenced after the evaluation of all its operands. |  |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| **[17.2](kindle_split_028.html#ch17note02)** 任何运算符的具体操作都排在所有操作数评估之后。 |  |'
- en: '| **[17.3](kindle_split_028.html#ch17note03)** The effect of updating an object
    with any of the assignment, increment, or decrement operators is sequenced after
    the evaluation of its operands. |  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **[17.3](kindle_split_028.html#ch17note03)** 使用任何赋值、增量或减量运算符更新对象的效果都排在它的操作数评估之后。
    |  |'
- en: '| **[17.4](kindle_split_028.html#ch17note04)** A function call is sequenced
    with respect to all evaluations of the caller. |  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **[17.4](kindle_split_028.html#ch17note04)** 函数调用相对于调用者的所有评估是有序的。 |  |'
- en: '| **[17.5](kindle_split_028.html#ch17note05)** Initialization-list expressions
    for array or structure types are indeterminately sequenced. |  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **[17.5](kindle_split_028.html#ch17note05)** 数组或结构类型初始化列表的表达式是有序不确定的。 |  |'
- en: '| **[17.6](kindle_split_028.html#ch17note06)** Each iteration defines a new
    instance of a local object. |  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| **[17.6](kindle_split_028.html#ch17note06)** 每次迭代定义了一个局部对象的新实例。 |  |'
- en: '| **[17.7](kindle_split_028.html#ch17note07)** **goto** should only be used
    for exceptional changes in control flow. |  |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **[17.7](kindle_split_028.html#ch17note07)** **goto** 应仅用于控制流中的异常变化。 |  |'
- en: '| **[17.8](kindle_split_028.html#ch17note08)** Each function call defines a
    new instance of a local object. |  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **[17.8](kindle_split_028.html#ch17note08)** 每个函数调用定义了一个局部对象的新实例。 |  |'
- en: '| **[17.9](kindle_split_028.html#ch17note09)** **longjmp** never returns to
    the caller. |  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **[17.9](kindle_split_028.html#ch17note09)** **longjmp** 从不返回到调用者。 |  |'
- en: '| **[17.10](kindle_split_028.html#ch17note10)** When reached through normal
    control flow, a call to **setjmp** marks the call location as a jump target and
    returns 0. |  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **[17.10](kindle_split_028.html#ch17note10)** 当通过正常控制流到达时，对 **setjmp** 的调用将标记调用位置为跳转目标，并返回
    0。 |  |'
- en: '| **[17.11](kindle_split_028.html#ch17note11)** Leaving the scope of a call
    to **setjmp** invalidates the jump target. |  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **[17.11](kindle_split_028.html#ch17note11)** 离开对 **setjmp** 的调用范围会使跳转目标无效。
    |  |'
- en: '| **[17.12](kindle_split_028.html#ch17note12)** A call to **longjmp** transfers
    control directly to the position that was set by **setjmp** as if that had returned
    the condition argument. |  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **[17.12](kindle_split_028.html#ch17note12)** 对 **longjmp** 的调用将直接转移到由 **setjmp**
    设置的位置，就像它返回了条件参数一样。 |  |'
- en: '| **[17.13](kindle_split_028.html#ch17note13)** A 0 as a condition parameter
    to **longjmp** is replaced by 1. |  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **[17.13](kindle_split_028.html#ch17note13)** 将 0 作为 **longjmp** 的条件参数时，会被替换为
    1。 |  |'
- en: '| **[17.14](kindle_split_028.html#ch17note14)** **setjmp** may be used only
    in simple comparisons inside controlling expression of conditionals. |  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **[17.14](kindle_split_028.html#ch17note14)** **setjmp** 只能在条件表达式的简单比较中使用。
    |  |'
- en: '| **[17.15](kindle_split_028.html#ch17note15)** Optimization interacts badly
    with calls to **setjmp**. |  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **[17.15](kindle_split_028.html#ch17note15)** 优化与对 **setjmp** 的调用交互不良。 |  |'
- en: '| **[17.16](kindle_split_028.html#ch17note16)** Objects that are modified across
    **longjmp** must be **volatile**. |  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **[17.16](kindle_split_028.html#ch17note16)** 在 **longjmp** 跨越时修改的对象必须是 **volatile**。
    |  |'
- en: '| **[17.17](kindle_split_028.html#ch17note17)** **volatile** objects are reloaded
    from memory each time they are accessed. |  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **[17.17](kindle_split_028.html#ch17note17)** **volatile** 对象在每次访问时都会从内存中重新加载。
    |  |'
- en: '| **[17.18](kindle_split_028.html#ch17note18)** **volatile** objects are stored
    to memory each time they are modified. |  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| **[17.18](kindle_split_028.html#ch17note18)** **volatile** 对象在每次修改时都会存储到内存中。
    |  |'
- en: '| **[17.19](kindle_split_028.html#ch17note19)** The **typedef** for **jmp_buf**
    hides an array type. |  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| **[17.19](kindle_split_028.html#ch17note19)** **jmp_buf** 的 **typedef** 隐藏了一个数组类型。
    |  |'
- en: '| **[17.20](kindle_split_028.html#ch17note20)** C’s signal-handling interface
    is minimal and should only be used for elementary situations. |  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| **[17.20](kindle_split_028.html#ch17note20)** C 的信号处理接口是最基本的，并且仅应用于基本情况。
    |  |'
- en: '| **[17.21](kindle_split_028.html#ch17note21)** Signal handlers can kick in
    at any point of execution. |  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **[17.21](kindle_split_028.html#ch17note21)** 信号处理程序可以在执行的任何点介入。 |  |'
- en: '| **[17.22](kindle_split_028.html#ch17note22)** After return from a signal
    handler, execution resumes exactly where it was interrupted. |  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **[17.22](kindle_split_028.html#ch17note22)** 从信号处理程序返回后，执行将从被中断的地方继续。 |  |'
- en: '| **[17.23](kindle_split_028.html#ch17note23)** A C statement may correspond
    to several processor instructions. |  |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **[17.23](kindle_split_028.html#ch17note23)** 一个 C 语句可能对应于多个处理器指令。 |  |'
- en: '| **[17.24](kindle_split_028.html#ch17note24)** Signal handlers need types
    with uninterruptible operations. |  |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| **[17.24](kindle_split_028.html#ch17note24)** 信号处理程序需要具有不可中断操作的类型。 |  |'
- en: '| **[17.25](kindle_split_028.html#ch17note25)** Objects of type **sig_atomic_t**
    should not be used as counters. |  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **[17.25](kindle_split_028.html#ch17note25)** **sig_atomic_t** 类型的对象不应用作计数器。
    |  |'
- en: '| **[17.26](kindle_split_028.html#ch17note26)** Unless specified otherwise,
    C library functions are not asynchronous signal safe. |  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **[17.26](kindle_split_028.html#ch17note26)** 除非另有指定，否则 C 库函数不是异步信号安全的。 |  |'
- en: '| **[18.1](kindle_split_029.html#ch18note01)** If a thread *T*[0] writes a
    non-atomic object that is simultaneously read or written by another thread *T*[1],
    the behavior of the execution becomes undefined. |  |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **[18.1](kindle_split_029.html#ch18note01)** 如果线程 *T*[0] 写入一个同时被另一个线程 *T*[1]
    读取或写入的非原子对象，则执行行为将变为未定义。 |  |'
- en: '| **[18.2](kindle_split_029.html#ch18note02)** In view of execution in different
    threads, standard operations on atomic objects are indivisible and linearizable.
    |  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **[18.2](kindle_split_029.html#ch18note02)** 考虑到不同线程的执行，原子对象的常规操作是不可分割的且可线性化的。
    |  |'
- en: '| **[18.3](kindle_split_029.html#ch18note03)** Use the specifier syntax **_Atomic(**T)
    for atomic declarations. |  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| **[18.3](kindle_split_029.html#ch18note03)** 使用 **_Atomic(**T**) 语法指定符进行原子声明。
    |  |'
- en: '| **[18.4](kindle_split_029.html#ch18note04)** There are no atomic array types.
    |  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **[18.4](kindle_split_029.html#ch18note04)** 没有原子数组类型。 |  |'
- en: '| **[18.5](kindle_split_029.html#ch18note05)** Atomic objects are the privileged
    tool to force the absence of race conditions. |  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| **[18.5](kindle_split_029.html#ch18note05)** 原子对象是强制消除竞争条件的特权工具。 |  |'
- en: '| **[18.6](kindle_split_029.html#ch18note06)** A properly initialized **FILE***
    can be used race-free by several threads. |  |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| **[18.6](kindle_split_029.html#ch18note06)** 正确初始化的 **FILE*** 可以被多个线程安全地使用。
    |  |'
- en: '| **[18.7](kindle_split_029.html#ch18note07)** Concurrent write operations
    should print entire lines at once. |  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **[18.7](kindle_split_029.html#ch18note07)** 并发写操作应一次打印整行。 |  |'
- en: '| **[18.8](kindle_split_029.html#ch18note08)** Destruction and deallocation
    of shared dynamic objects needs a lot of care. |  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| **[18.8](kindle_split_029.html#ch18note08)** 销毁和分配共享动态对象需要很多注意。 |  |'
- en: '| **[18.9](kindle_split_029.html#ch18note09)** Pass thread-specific data through
    function arguments. |  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| **[18.9](kindle_split_029.html#ch18note09)** 通过函数参数传递线程特定的数据。 |  |'
- en: '| **[18.10](kindle_split_029.html#ch18note10)** Keep thread-specific state
    in local variables. |  |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| **[18.10](kindle_split_029.html#ch18note10)** 将线程特定的状态保存在局部变量中。 |  |'
- en: '| **[18.11](kindle_split_029.html#ch18note12)** A **thread_local** variable
    has one separate instance for each thread. |  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| **[18.11](kindle_split_029.html#ch18note12)** **thread_local** 变量为每个线程都有一个单独的实例。
    |  |'
- en: '| **[18.12](kindle_split_029.html#ch18note13)** Use **thread_local** if initialization
    can be determined at compile time. |  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| **[18.12](kindle_split_029.html#ch18note13)** 如果初始化可以在编译时确定，请使用 **thread_local**。
    |  |'
- en: '| **[18.13](kindle_split_029.html#ch18note15)** Mutex operations provide linearizability.
    |  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| **[18.13](kindle_split_029.html#ch18note15)** 互斥锁操作提供线性化。 |  |'
- en: '| **[18.14](kindle_split_029.html#ch18note16)** Every mutex must be initialized
    with **mtx_init**. |  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| **[18.14](kindle_split_029.html#ch18note16)** 每个互斥锁都必须使用 **mtx_init** 进行初始化。
    |  |'
- en: '| **[18.15](kindle_split_029.html#ch18note17)** A thread that holds a nonrecursive
    mutex must not call any of the mutex lock functions for it. |  |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| **[18.15](kindle_split_029.html#ch18note17)** 持有非递归互斥锁的线程不得调用其互斥锁锁定函数。 |  |'
- en: '| **[18.16](kindle_split_029.html#ch18note18)** A recursive mutex is only released
    after the holding thread issues as many calls to **mtx_unlock** as it has acquired
    locks. |  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| **[18.16](kindle_split_029.html#ch18note18)** 递归互斥锁只有在持有线程对 **mtx_unlock**
    的调用次数与其获取的锁次数相同时才会释放。 |  |'
- en: '| **[18.17](kindle_split_029.html#ch18note19)** A locked mutex must be released
    before the termination of the thread. |  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| **[18.17](kindle_split_029.html#ch18note19)** 在线程终止之前必须释放已锁定的互斥锁。 |  |'
- en: '| **[18.18](kindle_split_029.html#ch18note20)** A thread must only call **mtx_unlock**
    on a mutex that it holds. |  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| **[18.18](kindle_split_029.html#ch18note20)** 线程必须只在对它持有的互斥锁上调用 **mtx_unlock**。
    |  |'
- en: '| **[18.19](kindle_split_029.html#ch18note21)** Each successful mutex lock
    corresponds to exactly one call to **mtx_unlock**. |  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| **[18.19](kindle_split_029.html#ch18note21)** 每次成功的互斥锁锁定对应于对 **mtx_unlock**
    的精确一次调用。 |  |'
- en: '| **[18.20](kindle_split_029.html#ch18note22)** A mutex must be destroyed at
    the end of its lifetime. |  |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| **[18.20](kindle_split_029.html#ch18note22)** 互斥锁必须在生命周期结束时被销毁。 |  |'
- en: '| **[18.21](kindle_split_029.html#ch18note23)** On return from a **cnd_t**
    wait, the expression must be checked again. |  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| **[18.21](kindle_split_029.html#ch18note23)** 从 **cnd_t** 等待返回后，必须再次检查表达式。
    |  |'
- en: '| **[18.22](kindle_split_029.html#ch18note24)** A condition variable can only
    be used simultaneously with one mutex. |  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| **[18.22](kindle_split_029.html#ch18note24)** 条件变量只能与一个互斥锁同时使用。 |  |'
- en: '| **[18.23](kindle_split_029.html#ch18note25)** A **cnd_t** must be initialized
    dynamically. |  |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| **[18.23](kindle_split_029.html#ch18note25)** **cnd_t** 必须动态初始化。 |  |'
- en: '| **[18.24](kindle_split_029.html#ch18note26)** A **cnd_t** must be destroyed
    at the end of its lifetime. |  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| **[18.24](kindle_split_029.html#ch18note26)** **cnd_t** 必须在其生命周期结束时被销毁。 |  |'
- en: '| **[18.25](kindle_split_029.html#ch18note27)** Returning from **main** or
    calling **exit** terminates all threads. |  |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| **[18.25](kindle_split_029.html#ch18note27)** 从 **main** 函数返回或调用 **exit**
    会终止所有线程。 |  |'
- en: '| **[18.26](kindle_split_029.html#ch18note28)** While blocking on **mtx_t**
    or **cnd_t**, a thread frees processing resources. |  |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **[18.26](kindle_split_029.html#ch18note28)** 在阻塞于 **mtx_t** 或 **cnd_t**
    时，线程会释放处理资源。 |  |'
- en: '| **[19.1](kindle_split_030.html#ch19note01)** Every evaluation has an effect.
    |  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| **[19.1](kindle_split_030.html#ch19note01)** 每次评估都有一个效果。 |  |'
- en: '| **[19.2](kindle_split_030.html#ch19note02)** If *F* is sequenced before *E*,
    then *F → E*. |  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| **[19.2](kindle_split_030.html#ch19note02)** 如果 *F* 在 *E* 之前顺序，则 *F → E*。
    |  |'
- en: '| **[19.3](kindle_split_030.html#ch19note03)** The set of modifications of
    an atomic object X are performed in an order that is consistent with the sequenced-before
    relation of any thread that deals with X. |  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| **[19.3](kindle_split_030.html#ch19note03)** 原子对象 X 的修改集以与处理 X 的任何线程的顺序关系一致的顺序执行。
    |  |'
- en: '| **[19.4](kindle_split_030.html#ch19note04)** An acquire operation *E* in
    a thread *T[E]* synchronizes with a release operation *F* if another thread *T[F]*
    if *E* reads the value that *F* has written. |  |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| **[19.4](kindle_split_030.html#ch19note04)** 在线程 *T[E]* 中的获取操作 *E* 与释放操作
    *F* 同步，如果另一个线程 *T[F]* 中 *E* 读取了 *F* 写入的值。 |  |'
- en: '| **[19.5](kindle_split_030.html#ch19note05)** If *F* synchronizes with *E*,
    all effects *X* that happened before F must be visible at all evaluations G that
    happen after E. |  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| **[19.5](kindle_split_030.html#ch19note05)** 如果 *F* 与 *E* 同步，所有在 *E* 之后发生的评估
    G 中必须可见的所有在 *F* 之前发生的效果 *X*。 |  |'
- en: '| **[19.6](kindle_split_030.html#ch19note06)** We only can conclude that one
    evaluation happened before another if we have a sequenced chain of synchronizations
    that links them. |  |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| **[19.6](kindle_split_030.html#ch19note06)** 只有在我们有一个将它们连接起来的同步序列链时，我们才能得出一个评估发生在另一个评估之前的结论。
    |  |'
- en: '| **[19.7](kindle_split_030.html#ch19note07)** If an evaluation *F* happened
    before *E*, all effects that are known to have happened before *F* are also known
    to have happened before *E*. |  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| **[19.7](kindle_split_030.html#ch19note07)** 如果评估 *F* 发生在 *E* 之前，所有已知在 *F*
    之前发生的效果也都是在 *E* 之前发生的。 |  |'
- en: '| **[19.8](kindle_split_030.html#ch19note08)** Critical sections that are protected
    by the same mutex occur sequentially. |  |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| **[19.8](kindle_split_030.html#ch19note08)** 由相同互斥锁保护的关键区是顺序发生的。 |  |'
- en: '| **[19.9](kindle_split_030.html#ch19note09)** In a critical section that is
    protected by the mutex mut, all effects of previous critical sections protected
    by mut are visible. |  |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| **[19.9](kindle_split_030.html#ch19note09)** 在由互斥锁 mut 保护的关键区中，所有由 mut 保护的前关键区的影响都是可见的。
    |  |'
- en: '| **[19.10](kindle_split_030.html#ch19note10)** **cnd_wait** and **cnd_timedwait**
    have release-acquire semantics for the mutex. |  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| **[19.10](kindle_split_030.html#ch19note10)** **cnd_wait** 和 **cnd_timedwait**
    对互斥锁具有释放-获取语义。 |  |'
- en: '| **[19.11](kindle_split_030.html#ch19note11)** Calls to **cnd_signal** and
    **cnd_broadcast** synchronize via the mutex. |  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| **[19.11](kindle_split_030.html#ch19note11)** 对 **cnd_signal** 和 **cnd_broadcast**
    的调用通过互斥锁进行同步。 |  |'
- en: '| **[19.12](kindle_split_030.html#ch19note12)** Calls to **cnd_signal** and
    **cnd_broadcast** should occur inside a critical section that is protected by
    the same mutex as the waiters. |  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| **[19.12](kindle_split_030.html#ch19note12)** 对 **cnd_signal** 和 **cnd_broadcast**
    的调用应发生在由等待者相同的互斥锁保护的临界区中。 |  |'
- en: '| **[19.13](kindle_split_030.html#ch19note13)** All atomic operations with
    sequential consistency occur in one global modification order, regardless of the
    atomic object they are applied to. |  |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| **[19.13](kindle_split_030.html#ch19note13)** 所有具有顺序一致性的原子操作都发生在全局修改顺序中，无论它们应用于哪个原子对象。
    |  |'
- en: '| **[19.14](kindle_split_030.html#ch19note14)** All operators and functional
    interfaces on atomics that don’t specify otherwise have sequential consistency.
    |  |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| **[19.14](kindle_split_030.html#ch19note14)** 所有原子上的操作符和未指定其他情况的函数式接口都具有顺序一致性。
    |  |'
- en: '| **[19.15](kindle_split_030.html#ch19note15)** Synchronizing functional interfaces
    for atomic objects have a form with **_explicit** appended that allows us to specify
    their consistency model. |  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| **[19.15](kindle_split_030.html#ch19note15)** 原子对象的同步功能接口有一个形式，其中附加了 **_显式**，这允许我们指定它们的一致性模型。
    |  |'
