- en: 11 Pathways to scalability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 条通往可扩展性的路径
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Scaling microservices to bigger development teams
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微服务扩展到更大的开发团队
- en: Scaling microservices to meet growing demand
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微服务扩展以满足不断增长的需求
- en: Understanding basic security concerns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基本的安全问题
- en: Strategies for converting a monolith to microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单体转换为微服务的策略
- en: Tips for building with microservices on a budget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在预算内使用微服务的技巧
- en: We’ve spent the whole book working towards a production microservices application,
    so where to now? It’s time to see what microservices can offer us in the future.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整本书都在致力于构建生产级的微服务应用程序，那么接下来呢？是时候看看微服务在未来能为我们提供什么了。
- en: Throughout this book, we’ve taken many shortcuts that helped us get started
    quickly and cheaply with microservices. These shortcuts make it simpler to learn
    microservices and to bootstrap our fledgling application. Even though FlixTube
    is a simple application built with a relatively simple process, we are still using
    microservices, and this is an architecture that provides us many pathways towards
    future scalability.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们采取了许多捷径，帮助我们快速、低成本地开始使用微服务。这些捷径使学习微服务和启动我们初出茅庐的应用程序变得更加简单。尽管 FlixTube
    是一个使用相对简单的过程构建的简单应用程序，但我们仍在使用微服务，这是一种提供许多通往未来可扩展性的路径的架构。
- en: In this chapter, we discuss how to manage a growing microservices application.
    How do we scale up to a bigger development team? How do we scale up to meet growing
    customer demand? We also need to talk about basic security concerns and how they
    relate to microservices. Then, we’ll briefly touch on what it takes to convert
    an existing monolith to microservices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论如何管理不断增长的微服务应用程序。我们如何扩大到更大的开发团队？我们如何扩大以满足不断增长的客户需求？我们还需要讨论基本的安全问题以及它们如何与微服务相关。然后，我们将简要介绍将现有单体应用程序转换为微服务所需的内容。
- en: We’ll finish the book by reiterating the techniques that can make bootstrapping
    a microservices application simpler, easier, and cheaper. This is practical advice
    that can help a small team, a startup, or a solo developer kickstart their own
    microservices application while still having a future full of possibilities for
    scalability!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过重申可以使启动微服务应用程序更简单、更轻松、更便宜的技术来结束本书。这是对小团队、初创公司或独立开发者启动自己的微服务应用程序同时仍拥有充满扩展可能性的未来的实用建议！
- en: 11.1 Our future is scalable
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 我们的未来是可扩展的
- en: Microservices offer us numerous pathways to achieve a scalable product. In this
    chapter, we will look at the kinds of things we must do moving forward to scale
    our application and workflow so that we can grow our development team around our
    growing application. We’ll follow up by looking at how to scale the performance
    of our application for greater capacity and throughput.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务为我们提供了许多通往可扩展产品的路径。在本章中，我们将探讨我们必须采取哪些措施来扩展我们的应用程序和工作流程，以便围绕不断增长的应用程序扩大我们的开发团队。我们将通过探讨如何扩展应用程序的性能以实现更大的容量和吞吐量来跟进。
- en: You probably don’t need any of these techniques yet; you only need these when
    your application has grown big enough to expand your development team. Or when
    your customer-base has increased and you need to scale up for better performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在还不需要这些技术；只有当你的应用程序足够大，需要扩大你的开发团队时，或者当你的客户群增加，你需要为了更好的性能而进行扩展时，你才需要这些技术。
- en: We are moving into very advanced territory here, and this chapter mostly gives
    you a taste of the ways in which you can scale your application in the future.
    This is really just the tip of the iceberg; but it’s enough to give you an awareness
    of the path ahead.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在进入一个非常高级的领域，本章主要为你提供未来如何扩展应用程序的方法的初步了解。这仅仅是冰山一角；但足以让你对未来的道路有所认识。
- en: The problems we’ll address in this chapter are good problems to have. If you
    come to the point where you must scale up, that’s a good thing. It means your
    business is successful. It means you have a growing customer base. At this point,
    you can be really happy you chose a microservices architecture because it makes
    scaling up much more straightforward.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将解决的问题都是好问题。如果你到了必须扩展的地步，那是一件好事。这意味着你的业务是成功的。这意味着你有一个不断增长的客户群。在这个时候，你可以非常高兴地选择微服务架构，因为它使扩展变得更加直接。
- en: This chapter isn’t intended to be hands on. Think of it as some insight as to
    where your microservices journey might go in the future. That said, many of these
    techniques are fairly easy to try, but in doing so, you might make a mistake and
    inadvertently break your application cluster.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的不是实际操作。将其视为一些洞察，了解您的微服务之旅未来可能走向何方。话虽如此，许多这些技术相当容易尝试，但在尝试的过程中，您可能会犯错误并无意中破坏您的应用程序集群。
- en: Don’t try any of this on your production infrastructure that existing staff
    or customers depend upon. But do feel free to go back to chapter 9 and follow
    the instructions there to boot a new production instance of FlixTube. You can
    use that for experimentation. That gives you a risk-free way to try out anything
    in this chapter that sounds interesting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产基础设施上尝试任何这些，这些基础设施是现有员工或客户所依赖的。但请随意回到第9章，并遵循那里的说明来启动FlixTube的新生产实例。您可以使用它进行实验。这为您提供了一个风险免费的方式来尝试本章中听起来有趣的内容。
- en: 11.2 Scaling the development process
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 扩展开发流程
- en: 'First, let’s tackle scaling our development process. In this book, so far,
    we have experienced the development process and production workflow from the point
    of view of a single developer working on a small microservices application. Let’s
    now raise our focus up to the level of the team. The simple process we have thus
    far used can actually work to a certain extent for a small team:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解决扩展我们的开发流程的问题。到目前为止，在这本书中，我们已经从单个开发者在小微服务应用程序上工作的角度体验了开发流程和生产工作流程。现在，让我们将我们的关注点提升到团队的水平。我们迄今为止使用的简单流程实际上对于一个小团队来说可以起到一定作用：
- en: Developers working on a single codebase, writing and testing code on their development
    workstations
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单一代码库上工作的开发者，在他们的开发工作站上编写和测试代码
- en: Developers pushing code changes to the hosted code repository, which triggers
    the continuous delivery (CD) pipeline to deploy the application to production
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者将代码更改推送到托管代码仓库，这会触发持续交付（CD）管道将应用程序部署到生产环境
- en: 'This simple process is a great way to get started and move quickly when building
    a new application. But we can only take it so far. Our fledgling development process
    suffers from the following problems:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的流程是开始构建新应用程序并快速推进的绝佳方式。但我们的初步开发流程存在以下问题：
- en: '*We don’t want code going directly from developers to customers.* We’d like
    our developers to be able to test their code in a production-like environment,
    but we want that “work in progress” to be buffered from customers to ensure that
    it works well before inflicting it on them.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们不希望代码直接从开发者流向客户。* 我们希望我们的开发者能够在类似生产环境的环境中测试他们的代码，但我们希望“正在进行的工作”能够从客户那里缓冲，以确保在将其施加于他们之前它能够良好运行。'
- en: '*We don’t want developers interfering with each other.* As we grow our development
    team, developers working in a single code base will be treading on each other’s
    toes more frequently (for example, causing merge conflicts and breaking the build).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们不希望开发者相互干扰。* 随着我们开发团队的扩大，在单一代码库中工作的开发者将更频繁地相互干扰（例如，导致合并冲突和破坏构建）。'
- en: '*Our single code repository and CD pipeline is not scalable.* To manage the
    complexity of our growing application, we must break it apart so that even though
    the application might grow extremely complex, each individual microservice remains
    small, simple, and manageable.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们的单一代码仓库和CD管道不可扩展。* 为了管理我们不断增长的应用程序的复杂性，我们必须将其拆分，即使应用程序可能变得极其复杂，每个单独的微服务仍然保持小型、简单且易于管理。'
- en: To build a scalable development process, expand to multiple teams, and make
    the most of microservices, we must do some restructuring.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个可扩展的开发流程，扩展到多个团队，并充分利用微服务，我们必须进行一些重组。
- en: 11.2.1 Multiple teams
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 多个团队
- en: As we evolve our application, we’ll be adding more microservices to the mix
    to implement features and expand our application’s capabilities. As the workload
    grows, we’ll also have to grow the team to handle it. At some point, when our
    single team grows too large, we’ll need to split it into multiple teams. This
    keeps our teams small and allows us to benefit from the communication and organizational
    advantages that come from small teams.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们应用的发展，我们将添加更多的微服务来实现功能并扩展应用程序的能力。随着工作量的增长，我们也需要扩大团队来处理它。在某个时候，当我们的单个团队变得太大时，我们需要将其拆分为多个团队。这使我们的团队保持小型化，并使我们能够从小型团队带来的沟通和组织优势中受益。
- en: '![](../Images/CH11_F01_Davis4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F01_Davis4.png)'
- en: Figure 11.1 When starting a new application, it should be small enough that
    one team can manage all microservices by themselves.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 当启动一个新应用程序时，它应该足够小，以至于一个团队可以自己管理所有微服务。
- en: Applications based on microservices provide natural seams that can be used to
    carve up the application for development by multiple teams. Figure 11.1 shows
    what our team structure looks like in the early stages of development, when we
    are using our simple development process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务的应用程序提供了自然缝隙，可以用来分割应用程序，供多个团队进行开发。图 11.1 展示了我们在开发早期阶段，使用简单开发过程时的团队结构。
- en: '![](../Images/CH11_F02_Davis4.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F02_Davis4.png)'
- en: Figure 11.2 As we grow our application, the development can be split so that
    separate teams are managing independent microservices or groups of microservices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 随着我们的应用程序不断增长，开发工作可以分割，以便不同的团队管理独立的微服务或微服务组。
- en: Figure 11.2 shows what our structure might look like after we have grown and
    split into separate teams. We have carved up the application so that each team
    is responsible for a different set of microservices with zero overlaps. This helps
    stop the teams from interfering with each other. Now, we can grow our team of
    teams to any size we like by dividing our application up along microservices boundaries.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 展示了我们在增长并分割成不同团队后的结构可能看起来是什么样子。我们将应用程序分割，使每个团队负责一组不同的微服务，且没有重叠。这有助于阻止团队之间相互干扰。现在，我们可以通过在微服务边界上分割应用程序来将我们的团队规模扩大到任何我们想要的规模。
- en: Each team *owns* one or more microservices, and typically, they are responsible
    for their own microservices-all the way from coding, through testing, and then
    into production. The team is usually responsible for the operational needs of
    their microservices, keeping these online, healthy, and performant.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队*拥有*一个或多个微服务，通常，他们负责自己的微服务——从编码、测试，到生产。团队通常负责其微服务的运营需求，保持这些微服务在线、健康和高效。
- en: Of course, there are many ways to implement this, and the team structure and
    development process for any two companies will differ in the details. But, this
    method of organizing self-reliant teams is *scalable*. This means we can grow
    a huge company around a huge application and still have an effective development
    process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有许多方法可以实现这一点，任何两家公司的团队结构和开发过程在细节上都会有所不同。但是，这种组织自给自足团队的方法是*可扩展的*。这意味着我们可以在一个巨大的应用程序周围发展一个庞大的公司，同时仍然有一个有效的开发过程。
- en: 11.2.2 Independent microservices
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 独立微服务
- en: To this point, the FlixTube application we have developed lives in a single
    code repository and has a single CD pipeline. You can see in figure 11.3 how this
    looks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们开发的 FlixTube 应用程序生活在单个代码仓库中，并有一个单一的 CD 流水线。您可以在图 11.3 中看到这是怎样的情况。
- en: Using a so-called *mono* (monolithic) repo (monorepo) is a great way to get
    started when working on any new microservices project. It makes the bootstrapping
    process simpler and easier, and we’ll spend much less time creating and maintaining
    our d*evelopment infrastructure* (the infrastructure that supports our development
    process).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何新的微服务项目时，使用所谓的*单*（单体）仓库（单代码仓库）是一个很好的开始方式。它使启动过程更简单、更容易，我们将花费更少的时间来创建和维护我们的*开发基础设施*（支持我们的开发过程的基础设施）。
- en: '![](../Images/CH11_F03_Davis4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F03_Davis4.png)'
- en: Figure 11.3 When starting a new microservices application, it is simpler to
    have a single code repository and a single CD pipeline for the entire application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 当启动一个新的微服务应用程序时，对于整个应用程序来说，拥有一个单一的代码仓库和一个单一的 CD 流水线会更简单。
- en: Having a monorepo and a single CD pipeline makes things easier at the start,
    but unfortunately, it eliminates a major benefit of using microservices. Having
    a single repo and CD pipeline means that we have to release all microservices
    in lockstep. We don’t actually have the ability to independently release updates
    to our microservices! This means that with each deployment, we risk breaking our
    entire application! This is a situation that’s no better than having a monolith!
    Our deployment process is *monolithic*!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个单代码仓库和单一的 CD 流水线在开始时会使事情变得简单，但不幸的是，它消除了使用微服务的主要好处。拥有单个仓库和 CD 流水线意味着我们必须同步发布所有微服务！实际上，我们没有能力独立发布微服务的更新！这意味着每次部署，我们都可能破坏整个应用程序！这种情况并不比单体架构更好！我们的部署过程是*单体的*！
- en: You might recall from way back in chapter 1 that we actually defined a microservice
    as *a small software process having its own independent deployment schedule* (see
    section 1.5). We haven’t actually achieved that yet, and to gain the most benefit
    from using microservices, we really have to make those independently deployable.
    How this should look is indicated in figure 11.4.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在第一章的开头，我们实际上将微服务定义为*一个拥有自己独立部署计划的独立软件过程*（参见1.5节）。我们还没有真正实现这一点，为了从使用微服务中获得最大好处，我们真的需要使它们具有独立的部署能力。这种样子在图11.4中有说明。
- en: Having separate code repositories and multiple CD pipelines allows more granular
    control over our deployments. If we can independently update our microservices
    one at a time, then we have a much lower deployment risk. Instead of breaking
    our entire application with each deployment, we only risk breaking a single microservice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有单独的代码仓库和多个CD管道允许我们对部署有更细粒度的控制。如果我们能够逐个独立更新我们的微服务，那么我们的部署风险就会大大降低。我们不必每次部署都冒着破坏整个应用的风险，我们只冒着破坏单个微服务的风险。
- en: '![](../Images/CH11_F04_Davis4.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F04_Davis4.png)'
- en: Figure 11.4 As we grow our application, we’ll need to split our microservices
    out to separate code repositories and CD pipelines to gain the benefit that comes
    with independently deployable microservices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 随着我们应用的增长，我们需要将我们的微服务拆分到单独的代码仓库和CD管道中，以获得独立部署的微服务带来的好处。
- en: If changing to multiple repos and CD pipelines seems like a huge amount of work
    and too much additional complexity, I completely sympathize with you! In fact,
    I’d argue that this one thing is responsible for much of the perceived complexity
    normally attributed to microservices.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将转换到多个仓库和CD管道看作是一项巨大的工作量并且增加了太多的额外复杂性，我完全理解你的感受！事实上，我会争辩说，这一件事是导致通常归因于微服务的感知复杂性的主要原因。
- en: At this point, I’d like to reiterate that having a monorepo and a single CD
    pipeline *is* still a good way to start any new microservices application. It
    keeps things simple in the early days of development. Once you convert to multiple
    code repositories and multiple CD pipelines, it becomes more complex to manage
    and maintain, at least at the application level. That just comes with the territory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我想再次强调，拥有一个单仓库和单一持续交付（CD）管道*仍然是开始任何新的微服务应用的不错方式*。它使得在开发的早期阶段事情保持简单。一旦你转换到多个代码仓库和多个CD管道，管理和维护就会变得更加复杂，至少在应用层面是这样。这仅仅是随着发展而来的。
- en: Even though our application as a whole will ultimately become incredibly complex
    (this is inevitable for modern enterprise applications), if we can switch our
    perspective down to a single microservice, the picture looks very different. Things
    suddenly seem a lot simpler. Because the complexity gets added slowly, it is more
    manageable. And by focusing on individual microservices (which are simple) rather
    than focusing on the whole application (which is bound to be complex), the overall
    complexity of the application becomes much less impactful.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的整体应用最终会变得极其复杂（这对现代企业应用来说是不可避免的），如果我们能够将我们的视角降低到单个微服务，画面看起来就完全不同了。事情突然看起来简单多了。因为复杂性是逐渐增加的，所以它更容易管理。而且，通过关注单个微服务（它们是简单的）而不是关注整个应用（注定是复杂的），应用的整体复杂性影响就会小得多。
- en: This is what actually saves the day for complexity in microservices applications.
    An individual microservice is a tiny and easily understood application with a
    small codebase. It has a relatively simple deployment process. Each microservice
    is simple and easy to manage, even though these work together to build powerful
    and complex applications. This change of perspective from complex application
    to simple microservice is important for managing complexity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是解决微服务应用复杂性的关键。单个微服务是一个微小且易于理解的程序，拥有较小的代码库。它有一个相对简单的部署过程。每个微服务都很简单，易于管理，尽管它们一起构建出强大而复杂的程序。从复杂的应用程序到简单的微服务的这种视角转变对于管理复杂性非常重要。
- en: Splitting our development process into microservice-sized chunks adds some additional
    complexity, but it pales in comparison to how complex our application may eventually
    become. By redirecting our focus from whole application complexity to individual
    microservices, we have essentially freed our application to scale to truly enormous
    proportions, even when each and every microservice remains just as simple to work
    with as it ever was.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的开发过程分割成微服务大小的块增加了一些额外的复杂性，但与我们的应用程序最终可能变得多么复杂相比，这微不足道。通过将我们的关注点从整个应用程序的复杂性转向单个微服务，我们实际上已经让我们的应用程序能够扩展到真正巨大的规模，即使每个微服务仍然像以前一样简单易用。
- en: Don’t be too enthusiastic about making this change to independently deployable
    microservices, however. If you make this change too early, you might find that
    you are paying for the cost of the transition at a time when it’s still too early
    to gain benefit from it. You don’t want to pay the cost before you can make use
    of the benefit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要过于热衷于将这种变更应用于可独立部署的微服务。如果你过早地做出这种变更，可能会发现你正在为过渡的成本买单，而此时还太早从中获益。你不想在能够利用好处之前就支付成本。
- en: Good software development is all about making good trade-offs. Stick with a
    monorepo and a single CD pipeline for as long as that makes sense for you. But
    be aware that it’s *not* supposed to be this way. As your application grows more
    complex and as you grow your team, this simple approach eventually breaks down.
    There comes a point when splitting our deployment pipelines is necessary to scale
    up, while maintaining a productive development process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的软件开发完全是关于做出良好的权衡。只要这对你有意义，就坚持使用单仓库和单个CD管道。但请注意，这并不是应该的方式。随着你的应用程序变得更加复杂，以及随着你团队的扩大，这种简单的方法最终会崩溃。最终会有一个时刻，分割我们的部署管道对于扩展规模是必要的，同时保持一个高效的开发过程。
- en: 11.2.3 Splitting the code repository
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 分割代码仓库
- en: Our first task is to split our monorepo into multiple code repositories so that
    we have a distinct and separate repository for every microservice. Each new repo
    will contain the code for a single microservice and the code for deploying it
    to production.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是分割我们的单仓库（monorepo）成多个代码仓库，以便为每个微服务拥有一个明确且独立的仓库。每个新的仓库将包含单个微服务的代码以及部署到生产环境的代码。
- en: We also need a separate code repository for the Terraform code that creates
    our infrastructure. This is the code that creates our container registry and Kubernetes
    cluster. This code doesn’t belong to any particular microservice, so it needs
    its own code repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个独立的代码仓库来存放创建我们基础设施的Terraform代码。这是创建我们的容器注册库和Kubernetes集群的代码。这段代码不属于任何特定的微服务，因此它需要一个自己的代码仓库。
- en: Figure 11.5 illustrates how we can take our FlixTube project from chapter 9
    and break it up into multiple code repositories. To build each new repo, we invoke
    `git init` to create a blank repo, then copy the code into the new repo and commit
    it. Otherwise, we might want to take the extra steps required to preserve our
    existing version history (see the following sidebar).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5说明了我们如何将第9章的FlixTube项目拆分成多个代码仓库。为了构建每个新的仓库，我们调用`git init`来创建一个空仓库，然后将代码复制到新仓库并提交。否则，我们可能需要采取额外的步骤来保留我们的现有版本历史（见下文边栏）。
- en: '![](../Images/CH11_F05_Davis4.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F05_Davis4.png)'
- en: Figure 11.5 When we split our repository, the subdirectory for each microservice
    becomes its own separate Git repository.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 当我们分割我们的仓库时，每个微服务的子目录成为它自己的独立Git仓库。
- en: Preserving the version history
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 保留版本历史
- en: 'When creating new code repositories from old ones, we can use the command `git
    filter-branch` with the `--subdirectory-filter` argument to save our existing
    version history. To so this, see the Git documentation for details:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在从旧仓库创建新的代码仓库时，我们可以使用带有`--subdirectory-filter`参数的`git filter-branch`命令来保存我们的现有版本历史。要这样做，请参阅Git文档以获取详细信息：
- en: '[https://git-scm.com/docs/git-filter-branch](https://git-scm.com/docs/git-filter-branch)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://git-scm.com/docs/git-filter-branch](https://git-scm.com/docs/git-filter-branch)'
- en: You can also search the web for examples of "filter-branch"-there are many!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上搜索“filter-branch”的例子——有很多！
- en: 11.2.4 Splitting the continuous delivery (CD) pipeline
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 分割持续交付（CD）管道
- en: Splitting apart our monorepo is fairly easy. At the same time, we must also
    split our monolithic CD pipeline and this is a more difficult task. We now need
    to create a separate deployment pipeline for each microservice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的monorepo拆分开来相对容易。同时，我们还必须拆分我们的单体CD流水线，这是一个更困难的任务。我们现在需要为每个微服务创建一个单独的部署流水线。
- en: Fortunately, we can create a single microservice deployment pipeline and then
    reuse it for every microservice (if necessary, making small changes for the custom
    requirements of each microservice). Our per-microservice CD pipeline will independently
    deploy a single microservice, triggered automatically when updated code is pushed
    to the microservice’s hosted code repository. Figure 11.6 illustrates this process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以创建一个单独的微服务部署流水线，然后为每个微服务重复使用它（如果需要，对每个微服务的定制需求进行少量修改）。我们的每个微服务的CD流水线将独立部署单个微服务，当更新后的代码推送到微服务的托管代码仓库时，会自动触发。图11.6说明了这个过程。
- en: '![](../Images/CH11_F06_Davis4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F06_Davis4.png)'
- en: Figure 11.6 Pushing code to the hosted code repository for a microservice triggers
    the CD pipeline, which deploys a single microservice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 将代码推送到微服务的托管代码仓库会触发CD流水线，部署单个微服务。
- en: The Terraform code for the deployment of a single microservice is like the code
    we saw in chapter 9; indeed, it is a cut-down version of that code. We can develop
    this Terraform code using an iterative process like we did throughout chapters
    6 and 7\. Once we are happy that the deployment pipeline works for a single microservice,
    we can copy it into the code repo for every microservice-with the code parameterized
    by name for each microservice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 单个微服务的Terraform部署代码类似于我们在第9章中看到的代码；实际上，它是该代码的简化版本。我们可以使用类似于我们在第6章和第7章中使用的迭代过程来开发这个Terraform代码。一旦我们确信部署流水线对单个微服务有效，我们就可以将其复制到每个微服务的代码仓库中——每个微服务的代码通过名称参数化。
- en: Each code repository then needs to have its pipeline enabled and configured.
    If you are using Bitbucket Pipelines for your CD like we did in chapters 7 and
    9, you can enable it for each repository as shown in section 7.7.2\. Then you
    must add a separate configuration file for each repository as illustrated in figure
    11.7.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代码仓库都需要启用并配置其流水线。如果您像我们在第7章和第9章中做的那样使用Bitbucket Pipelines进行持续交付（CD），您可以为每个仓库启用它，如7.7.2节中所示。然后，您必须为每个仓库添加一个单独的配置文件，如图11.7所示。
- en: '![](../Images/CH11_F07_Davis4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F07_Davis4.png)'
- en: Figure 11.7 The code repository for each microservice has its own separate configuration
    for continuous delivery (CD).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 每个微服务的代码仓库都有自己的持续交付（CD）配置。
- en: Extracting Docker builds from Terraform
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从Terraform中提取Docker构建
- en: At this point, we can revisit how we do Docker builds. We are now able to extract
    these from the Terraform code. If you remember from chapter 7, we kept things
    simple by having our entire deployment process performed within Terraform.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以回顾我们如何进行Docker构建。我们现在能够从Terraform代码中提取这些。如果您还记得第7章，我们通过在Terraform中执行整个部署过程来简化了事情。
- en: Actually, that’s not 100% true; I didn’t mention it at the time, but doing everything
    within Terraform was a necessary workaround due to how we created all of our infrastructure
    within Terraform in the first place. This included the creation of our container
    registry. If we had tried to extract Docker from Terraform, we’d have found that
    on the first deployment, we couldn’t push our images to the container registry
    because it hadn’t yet been created!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这并不完全正确；我当时没有提到，但由于我们最初在Terraform中创建所有基础设施，所以这样做是必要的解决方案。这包括创建我们的容器注册库。如果我们尝试从Terraform中提取Docker，我们会发现第一次部署时，我们无法将镜像推送到容器注册库，因为它尚未创建！
- en: This catch-22 situation is not helped by the fact that the Docker provider for
    Terraform does not support building and publishing Docker images (seriously, it
    should be upgraded to support this properly). This is why we were forced to use
    `local-exec` and `null_resource` in Terraform as a kind of ugly hack (see section
    7.6.2 for a reminder).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“进退两难”的情况并没有因为Terraform的Docker提供者不支持构建和发布Docker镜像（真的，它应该升级以正确支持这一点）而得到改善。这就是我们被迫在Terraform中使用`local-exec`和`null_resource`作为一种丑陋的解决方案的原因（有关提醒，请参阅7.6.2节）。
- en: Things are different now though. We’ve separated our Terraform code into multiple
    repositories, and our infrastructure code has been separated from our microservices
    code. In between creating our infrastructure and deploying our microservices,
    we can build and publish our Docker images simply by invoking Docker directly
    within the continuous delivery (CD) pipeline (using the `build` and `push` commands
    that we learned in chapter 3).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在情况不同了。我们已经将Terraform代码分离到多个仓库中，并且我们的基础设施代码已经与微服务代码分离。在创建基础设施和部署微服务之间，我们可以通过在持续交付（CD）管道中直接调用Docker（使用我们在第3章中学到的`build`和`push`命令）来简单地构建和发布Docker镜像。
- en: We can create a single configuration and then reuse it as a template for each
    microservice. Our “single microservice” configuration for Bitbucket Pipelines
    is shown in listing 11.1\. We have two steps in this deployment process. The first
    step directly uses Docker to build and publish the image for the microservice.
    The second step uses Terraform to deploy the microservice to our Kubernetes cluster.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个单独的配置，然后将其作为每个微服务的模板重复使用。我们的“单个微服务”配置（Bitbucket Pipelines）在列表11.1中展示。在这个部署过程中，我们有两个步骤。第一步直接使用Docker构建和发布微服务的镜像。第二步使用Terraform将微服务部署到我们的Kubernetes集群。
- en: Listing 11.1 Bitbucket Pipelines configuration file for a single microservice
    (bitbucket-pipelines.yaml)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 单个微服务的Bitbucket Pipelines配置文件（bitbucket-pipelines.yaml）
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Sets the base image as Terraform so we can use Terraform within the CD pipeline
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将基础镜像设置为Terraform，这样我们就可以在CD管道中使用Terraform
- en: '② Step 1: Builds and publishes the Docker microservice for the microservice'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ② 第1步：构建并发布微服务的Docker微服务
- en: ③ Enables the use of Docker within the CD pipeline
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 启用在CD管道中使用Docker
- en: ④ Uses the name of the code repository as the name of the microservice
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用代码仓库的名称作为微服务的名称
- en: ⑤ Uses the build number as the version number for the Docker image
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用构建号作为Docker镜像的版本号
- en: ⑥ Composes the image name from the name of the microservice and its version
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 从微服务的名称和版本中组合镜像名称
- en: ⑦ Builds the production version of the Docker image
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 构建Docker镜像的生产版本
- en: ⑧ Logs into our private container registry
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 登录到我们的私有容器注册库
- en: ⑨ Pushes the new Docker image to the container registry
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将新的Docker镜像推送到容器注册库
- en: '⑩ Step 2: Deploys the updated microservice to the Kubernetes cluster'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 第2步：将更新的微服务部署到Kubernetes集群
- en: ⑪ Tracks what’s currently deployed to production (you can then view what’s deployed
    in the Bitbucket Pipelines dashboard).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 跟踪当前部署到生产环境的内容（你可以在Bitbucket Pipelines仪表板中查看已部署的内容）。
- en: ⑫ Environment variables must be copied to each step.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 环境变量必须复制到每个步骤。
- en: ⑬ Executes the deployment shell script and uses Terraform to deploy the microservice
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 执行部署shell脚本，并使用Terraform部署微服务
- en: 11.2.5 The meta-repo
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5 元仓库
- en: Is using separate code repositories getting you down? Do you find yourself craving
    the simpler days of managing your application through a single code repository?
    Well, here’s some good news.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用独立的代码仓库让你感到沮丧吗？你是否怀念通过单个代码仓库管理应用程序的简单日子？好吧，这里有一些好消息。
- en: 'We can create a *meta-repo* that ties together all our separate repositories
    into a single aggregate code repository. You can think of the meta-repo as a kind
    of virtual code repository. This means we can claw back some of the simplicity
    and convenience of the monorepo without sacrificing the flexibility and independence
    of having separate repositories. To create a meta-repo, we need the meta tool,
    available here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个*元仓库*，将所有独立的仓库组合成一个单一的聚合代码仓库。你可以将元仓库视为一种虚拟代码仓库。这意味着我们可以在不牺牲独立仓库的灵活性和独立性的情况下，找回一些单仓库的简单性和便利性。要创建元仓库，我们需要meta工具，可在以下位置获取：
- en: '[https://github.com/mateodelnorte/meta](https://github.com/mateodelnorte/meta)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mateodelnorte/meta](https://github.com/mateodelnorte/meta)'
- en: A meta-repo is configured by creating a .meta configuration file that lists
    a collection of separate repositories. See figure 11.8 for an example of where
    a .meta file would live in relation to the FlixTube project. Listing 11.2 shows
    the structure of this file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个包含多个独立仓库列表的.meta配置文件来配置元仓库。请参见图11.8，了解.meta文件在FlixTube项目中的位置示例。列表11.2显示了该文件的结构。
- en: '![](../Images/CH11_F08_Davis4.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F08_Davis4.png)'
- en: Figure 11.8 The .meta configuration file ties together separate repositories
    into a meta-repo.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 .meta配置文件将独立的仓库组合成一个元仓库。
- en: Listing 11.2 Configuring FlixTube’s meta code repository (.meta)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.2 配置FlixTube的meta代码仓库 (.meta)
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Lists the separate code repositories that comprise this meta-repo
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ① 列出构成此meta-repo的独立代码仓库
- en: Note In the listing, the code repos link to Bitbucket code repositories, but
    these could just as easily be GitHub repositories or link to anywhere else where
    we host our code repositories.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在列表中，代码仓库链接指向Bitbucket代码仓库，但它们同样可以指向GitHub仓库或链接到我们托管代码仓库的任何其他地方。
- en: 'Using meta allows us to run single Git commands that affect the entire collection
    of repositories. For example, let’s say we’d like to pull code changes for all
    the microservices under the FlixTube project at once. We can use meta to do that
    with a single command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用meta允许我们运行影响整个仓库集合的单个Git命令。例如，假设我们想一次性拉取FlixTube项目下所有微服务的代码更改。我们可以使用meta通过单个命令来完成：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are still working with separate code repositories, but meta allows us to
    invoke commands simultaneously against multiple code repositories at once, so
    that it feels much like we are back to working with a monorepo.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍在使用独立的代码仓库，但meta允许我们同时对多个代码仓库执行命令，这样感觉就像我们又回到了使用单仓库的工作方式。
- en: Meta gives us a lot of additional flexibility. We can use it to create our own
    custom sets of microservices. As a developer on a big team, you can create a meta-repo
    just for the set of microservices that you normally work on. Other developers
    can have their own separate meta-repos. You might even like to create multiple
    meta-repos so that you can easily switch between different sets of microservices,
    depending on what you are currently working on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Meta为我们提供了很多额外的灵活性。我们可以用它来创建自己的自定义微服务集合。作为一个大型团队的开发者，你可以创建一个仅针对你通常工作的微服务集合的meta-repo。其他开发者可以拥有他们自己的独立meta-repos。你可能甚至喜欢创建多个meta-repos，这样你可以轻松地在不同的微服务集合之间切换，这取决于你目前正在做什么。
- en: As a team leader, you can create separate meta-repos for different configurations
    of your application, each with its own Docker Compose file. This makes it easy
    for your team members to clone the code for a complete set of microservices. Then
    they can use Docker Compose to boot that application configuration. This is a
    great way to provide an “instant” and manageable development environment for team
    members!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为团队领导，你可以为应用程序的不同配置创建独立的meta-repos，每个配置都有自己的Docker Compose文件。这使得团队成员克隆完整的微服务集合的代码变得容易。然后他们可以使用Docker
    Compose启动该应用程序配置。这是为团队成员提供一个“即时”且可管理的开发环境的一种极好方式！
- en: 11.2.6 Creating multiple environments
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.6 创建多个环境
- en: As we gain customers for our application, it becomes important that we buffer
    them against problems from ongoing “work in progress” or protect them from new
    features that are partially completed or only partially tested. The development
    team needs a production-like environment in which to test their code before putting
    it in front of customers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们为应用程序获得客户，确保他们免受持续进行的“工作进行中”的问题的影响或保护他们免受部分完成或仅部分测试的新功能变得非常重要。开发团队需要一个类似生产环境的环境来测试他们的代码，在将其展示给客户之前。
- en: Each developer must test their code on their development workstation, but that’s
    not enough. They must also test their code once it is integrated with changes
    from other developers. To make it as “real” as possible, this testing should be
    done in a production-like environment-just not the one that our customer is using!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者必须在他们的开发工作站上测试他们的代码，但这还不够。他们还必须在代码与其他开发者的更改集成后测试他们的代码。为了使其尽可能“真实”，这种测试应该在类似生产的环境中完成——只是不是我们的客户正在使用的那一个！
- en: We need a workflow for our developers to take their changes on a journey from
    development workstation, through an integration environment, into a test environ-ment,
    and finally, once all the tests have passed, on to the customer-facing environment.
    Although no two companies will have exactly the same workflow, you can see what
    a typical workflow looks like in figure 11.9.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个工作流程，让我们的开发者在从开发工作站，通过集成环境，进入测试环境，最终，一旦所有测试都通过，进入面向客户的环境之前，将他们的更改传递。尽管没有两家公司的流程完全相同，但你可以在图11.9中看到典型工作流程的样子。
- en: '![](../Images/CH11_F09_Davis4.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F09_Davis4.png)'
- en: Figure 11.9 Progressing code changes, through development and test environments,
    before getting to production
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 在进入生产之前，通过开发和测试环境推进代码更改
- en: Setting up multiple environments is actually simple, and we already have most
    of what we need in our existing Terraform code that was presented in chapter 9\.
    We had already parameterized our code with an `app_name` variable that we used
    to create separate application resources based on the name we assigned to it (revisit
    section 6.10 where we first added this variable).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 设置多个环境实际上很简单，我们已经在第 9 章中展示的现有 Terraform 代码中拥有了大部分所需内容。我们已经在代码中通过 `app_name`
    变量进行了参数化，我们使用这个变量根据我们为其指定的名称创建单独的应用程序资源（回顾第 6.10 节，我们首次添加了这个变量）。
- en: We could now use `app_name` (set from the command line) when invoking Terraform
    to create different instances of FlixTube for testing and production. We just
    need to provide different names for each instance. For example, we could set `app_name`
    to `flixtube-development`, `flixtube-test`, or `flixtube-production` to create
    our separate environments.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在调用 Terraform 创建 FlixTube 的不同实例（用于测试和生产）时使用 `app_name`（从命令行设置）。我们只需为每个实例提供不同的名称。例如，我们可以将
    `app_name` 设置为 `flixtube-development`、`flixtube-test` 或 `flixtube-production`
    以创建我们各自的环境。
- en: We can improve on this, though, as in listing 11.3\. We can make it simpler
    to create new environments by introducing a new variable called `environment`.
    We then convert `app_name` to a computed local variable that depends on the value
    of `environment`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还可以在列表 11.3 中进行改进。通过引入一个名为 `environment` 的新变量，我们可以使创建新环境变得更加简单。然后我们将
    `app_name` 转换为一个依赖于 `environment` 值的计算本地变量。
- en: Listing 11.3 Setting the `app_name` local variable to the environment name in
    Terraform (an update to chapter-9/example-1/scripts/variables.tf)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 在 Terraform 中设置 `app_name` 本地变量为环境名称（对第 9 章示例-1/scripts/variables.tf
    的更新）
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Adds a new Terraform variable that specifies the current environment. We need
    to provide this when running Terraform via the command line, setting it to development,
    test, or production, for example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ① 添加一个新的 Terraform 变量，指定当前环境。在通过命令行运行 Terraform 时，我们需要提供此变量，例如将其设置为开发、测试或生产。
- en: ② Creates a local variable for “app_name” that builds separate versions of the
    application for each environment (e.g., flixtube-development, flixtube-test, or
    flixtube-production).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个名为“app_name”的本地变量，为每个环境构建应用程序的不同版本（例如，flixtube-development、flixtube-test
    或 flixtube-production）。
- en: Introducing this new variable (`environment`) allows us to set the current environment
    from the command line. Listing 11.4 shows how we input a value from another variable
    called `ENVIRONMENT`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 引入这个新变量（`environment`）允许我们从命令行设置当前环境。列表 11.4 展示了如何从另一个名为 `ENVIRONMENT` 的变量中输入值。
- en: We can reuse the same Terraform project to create as many separate environments
    as we like, all hosted in the same cloud account but differentiated by name (e.g.,
    flixtube- development, flixtube-test, or flixtube-production). You can use this
    to create a workflow like that in figure 11.9 or something even more sophisticated,
    depending on what you need.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的 Terraform 项目创建尽可能多的单独环境，所有这些环境都托管在同一个云账户中，但通过名称区分（例如，flixtube-development、flixtube-test
    或 flixtube-production）。您可以使用此功能创建如图 11.9 所示的工作流程或更复杂的工作流程，具体取决于您的需求。
- en: Listing 11.4 Updated deployment script to set the environment (an update to
    chapter-9/example-1/scripts/deploy.sh)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 更新后的部署脚本以设置环境（对第 9 章示例-1/scripts/deploy.sh 的更新）
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Parameterizes our Terraform code by the environment name. We pass in the name
    of the environment being deployed through an OS environment variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ① 通过环境名称参数化我们的 Terraform 代码。我们通过操作系统环境变量传递正在部署的环境的名称。
- en: 11.2.7 Production workflow
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.7 生产工作流程
- en: We can now create multiple environments and use them to stitch together a testing
    workflow to protect our customers against broken code. The remaining question
    is, how do we trigger the deployment for any particular environment? This is simpler
    than you might think.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建多个环境，并使用它们来构建测试工作流程，以保护我们的客户免受损坏代码的影响。剩下的问题是，我们如何触发特定环境的部署？这比你想象的要简单。
- en: We can use separate branches in our code repository to target deployments to
    different environments. Figure 11.10 shows an example setup for this. It’s a fairly
    simple branching strategy, but there are more sophisticated versions in the wild.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码仓库中使用单独的分支来针对不同的环境进行部署。图 11.10 展示了这样一个示例设置。这是一个相当简单的分支策略，但在实际中还有更复杂的版本。
- en: '![](../Images/CH11_F10_Davis4.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F10_Davis4.png)'
- en: Figure 11.10 Code from development, test, and production branches is automatically
    deployed to the appropriate environment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 开发、测试和生产分支的代码自动部署到相应的环境。
- en: Our development team works in the development branch. When they push code to
    that branch, it triggers a CD pipeline that deploys to the development environment.
    This allows our whole team to integrate and test their changes frequently, together
    in a production-like environment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发团队在开发分支上工作。当他们向该分支推送代码时，会触发一个CD流水线，将其部署到开发环境。这允许我们的整个团队在一个类似生产的环境中频繁地集成和测试他们的更改。
- en: How frequently should the developers push code changes? As often as possible!
    Once per day, if not multiple times per day. The less time we have between code
    merges, the less we’ll see errors caused by conflicting changes and bad integrations.
    This is the idea behind *continuous integration*, an important practice that underpins
    continuous delivery (CD).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应该多久推送一次代码更改？尽可能频繁！每天至少一次，如果可能的话，每天多次。代码合并之间的时间越短，由于冲突更改和不良集成引起的错误就越少。这就是*持续集成*背后的理念，这是一个支撑持续交付（CD）的重要实践。
- en: Less frequently (say once per week), we’ll merge from the development branch
    to the test branch. This triggers the deployment to the test environment. Code
    merges from development to test are less frequent, and this gives us time to test,
    fix problems, and stabilize the code before we hand it over to our customers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不太频繁（比如每周一次），我们会从开发分支合并到测试分支。这会触发测试环境的部署。从开发到测试的代码合并频率较低，这给我们时间来测试、修复问题，并在将代码交给客户之前稳定代码。
- en: Finally, when the code in the test branch is good to go (say every 1-2 weeks),
    we then merge it to the production branch. This deploys updated microservices
    to production so that our customers can get their hands on whatever awesome new
    features and bug fixes we’ve added.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当测试分支中的代码准备就绪（比如每1-2周一次），我们就将其合并到生产分支。这样会将更新的微服务部署到生产环境，以便我们的客户能够使用我们添加的任何新特性和错误修复。
- en: This workflow can be applied with or without automated testing. It gives plenty
    of room for testing and allows managers to make a conscious decision to deploy
    to production. Of course, automated testing makes this so much better and much
    more scalable! If an automated test fails at any point in the workflow, the deployment
    is automatically not allowed. When such problems occur, the team must work together
    to rectify the situation. The addition of good automated testing means we can
    safely ramp up our deployment frequency, to the point where many modern companies
    deploy to production on a daily basis.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流程可以应用于是否包含自动化测试。它为测试提供了充足的空间，并允许管理者有意识地决定是否部署到生产环境。当然，自动化测试使这一切变得更好，并且更具可扩展性！如果在工作流程的任何点上自动化测试失败，则部署将自动不允许。当出现此类问题时，团队必须共同努力纠正情况。良好的自动化测试的加入意味着我们可以安全地提高我们的部署频率，达到许多现代公司每天部署到生产环境的程度。
- en: If we use Bitbucket Pipelines, we can easily configure separate CD pipelines
    for each branch as listing 11.5 shows. This version of the bitbucket-pipelines.yaml
    configuration file includes separate sections for each branch. Each section is
    essentially the same, but we can wire through separate environment variables to
    configure which production environment is used to deploy each branch.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Bitbucket Pipelines，我们可以轻松地为每个分支配置单独的CD流水线，如列表11.5所示。这个版本的bitbucket-pipelines.yaml配置文件为每个分支包含单独的部分。每个部分基本上是相同的，但我们可以通过不同的环境变量来配置用于部署每个分支的生产环境。
- en: Listing 11.5 Configuring separate CD pipelines for each branch (bitbucket-pipelines.yaml)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 为每个分支配置单独的CD流水线（bitbucket-pipelines.yaml）
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Creates separate CD pipelines for each branch in our Git repository
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为Git仓库中的每个分支创建单独的CD流水线
- en: ② Configures the pipeline for the development branch
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ② 配置开发分支的流水线
- en: ③ Deploys to the development environment
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 部署到开发环境
- en: ④ Configures the pipeline for the test branch
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 配置测试分支的流水线
- en: ⑤ Deploys to the test environment
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 部署到测试环境
- en: ⑥ Configures the pipeline for the production branch
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 配置生产分支的流水线
- en: ⑦ Deploys to the production environment
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 部署到生产环境
- en: One thing to pay attention to when you implement this multi-branch/multi-environment
    strategy is that each environment needs its own separate Terraform state. We first
    configured a Terraform backend for CD in section 7.7.4\. Back then, we hard coded
    the connection to Azure storage in the Terraform file backend.tf. We must change
    this now so that we can set the storage configuration from the command line. We’ll
    then change it for each separate environment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施这种多分支/多环境策略时需要注意的一点是，每个环境都需要其自己的独立Terraform状态。我们首先在第7.7.4节中配置了Terraform后端用于CD。当时，我们在Terraform文件backend.tf中硬编码了与Azure存储的连接。现在我们必须改变这一点，以便我们可以从命令行设置存储配置。然后我们将为每个独立的环境进行更改。
- en: To start with, we must remove the `key` field from our backend configuration
    as shown in the following listing. This is the value that we need to vary, depending
    on the environment. We’ll set it as a command-line argument rather than hard code
    it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须从我们的后端配置中移除`key`字段，如下所示。这个值需要根据环境的不同而变化，我们将将其设置为命令行参数而不是硬编码。
- en: Listing 11.6 Configuring backend storage for Terraform state with multiple environments
    (an update to chapter-9/example-1/scripts/backend.tf)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.6 配置Terraform状态的后端存储以支持多个环境（对第9章/example-1/scripts/backend.tf的更新）
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Configures the backend as in chapter 7, but we remove the “key” field, which
    we now set separately for each environment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ① 配置后端与第7章中相同，但我们移除了“key”字段，我们现在为每个环境单独设置它。
- en: ② You’ll have to choose a different name for your storage account. This is a
    globally unique name so you won’t be able to choose terraform.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ② 您必须为您的存储账户选择一个不同的名称。这是一个全局唯一的名称，因此您无法选择terraform。
- en: Now, we can configure the `key` field for the Terraform backend from the command
    line as shown in listing 11.7\. Essentially, what we do is to tell Terraform to
    store its state configuration in a file whose name is different, depending on
    the current environment being deployed. For example, it could be called terraform-development.tfstate
    for the file that tracks the state of the development environment, and terraform-test
    .tfstate and terraform-production.tfstate for the other two environments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从命令行配置Terraform后端的`key`字段，如列表11.7所示。本质上，我们做的是告诉Terraform将其状态配置存储在文件中，该文件名根据当前部署的环境而不同。例如，它可以被称为跟踪开发环境状态的terraform-development.tfstate文件，以及其他两个环境的terraform-test.tfstate和terraform-production.tfstate。
- en: Listing 11.7 Updated deployment script to set the backend configuration based
    on the environment (an update to chapter-9/example-1/scripts/deploy.sh)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7 更新后的部署脚本，根据环境设置后端配置（对第9章/example-1/scripts/deploy.sh的更新）
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Initializes the “key” field of the backend configuration for the environment
    we are currently deploying
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化当前部署环境的后端配置中的“key”字段
- en: 11.3 Scaling performance
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 性能缩放
- en: Not only can we scale microservices applications to larger development teams,
    we can also scale these up for better performance. Our application can then have
    a higher capacity and can handle a larger workload.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以将微服务应用程序扩展到更大的开发团队，还可以为了更好的性能而扩展它们。我们的应用程序然后可以具有更高的容量，并可以处理更大的工作负载。
- en: Using microservices gives us granular control over the performance of our application.
    We can easily measure the performance of our microservices (for an example, see
    figure 11.11) to find the ones that are performing poorly, overworked, or overloaded
    at times of peak demand.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务使我们能够对我们的应用程序性能进行细粒度控制。我们可以轻松地测量微服务的性能（例如，参见图11.11），以找到表现不佳、过度工作或在高需求时段过载的微服务。
- en: If using a monolith, however, we would have limited control over performance.
    We could vertically scale the monolith, but that’s basically it. Horizontally
    scaling a monolith is much more difficult. And we simply can’t independently scale
    any of the “parts” of a monolith. This is a bad situation because it might only
    be a small part of the monolith that causes the performance problem. Yet, we would
    have to vertically scale the entire monolith to fix it! Vertically scaling a large
    monolith can be an expensive proposition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用单体，我们对性能的控制将有限。我们可以垂直扩展单体，但这基本上就是全部了。水平扩展单体要困难得多。我们根本无法独立扩展单体中的任何“部分”。这是一个糟糕的情况，因为可能只有单体的一小部分导致了性能问题。然而，我们可能不得不垂直扩展整个单体来修复它！垂直扩展大型单体可能是一个昂贵的提议。
- en: 'Instead, with microservices, we have numerous options for scaling. We can independently
    fine-tune the performance of small parts of our system to eliminate bottlenecks
    and to get the right mix of performance outcomes. There are many advanced ways
    we could tackle performance issues, but in this section, we’ll overview the following
    (relatively) simple techniques for scaling our microservices application:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在微服务中，我们有多种扩展选项。我们可以独立微调系统小部分的性能，以消除瓶颈并获得正确的性能结果组合。我们可以用许多高级方法来解决性能问题，但在这个部分，我们将概述以下（相对）简单的扩展我们的微服务应用程序的技术：
- en: Vertically scaling the entire cluster
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个集群中进行纵向扩展
- en: Horizontally scaling the entire cluster
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个集群中进行横向扩展
- en: Horizontally scaling individual microservices
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横向扩展单个微服务
- en: Elastically scaling the entire cluster
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性扩展整个集群
- en: Elastically scaling individual microservices
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性扩展单个微服务
- en: Scaling the database
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展数据库
- en: Scaling often requires risky configuration changes to our cluster. Don’t try
    to make any of these changes directly to a production cluster that your customers
    or staff are depending on. At the end of this section, we’ll briefly look at *blue-green
    deployment*, a technique that helps us manage large infrastructure changes with
    much less risk.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展通常需要对我们的集群进行风险配置更改。不要尝试直接对客户或员工依赖的生产集群进行任何这些更改。在本节的末尾，我们将简要介绍*蓝绿部署*，这是一种帮助我们以更少的风险管理大型基础设施更改的技术。
- en: '![](../Images/CH11_F11_Davis4.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F11_Davis4.png)'
- en: Figure 11.11 Viewing CPU and memory usage for microservices in the Kubernetes
    dashboard
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 在Kubernetes仪表板中查看微服务的CPU和内存使用情况
- en: 11.3.1 Vertically scaling the cluster
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 纵向扩展集群
- en: As we grow our application, we might come to a point where our cluster generally
    doesn’t have enough compute, memory, or storage to run our application. As we
    add new microservices (or replicate existing microservices for redundancy), we
    will eventually max out the nodes in our cluster. (We can monitor this in the
    Azure portal or the Kubernetes dashboard.) At this point, we must increase the
    total amount of resources available to our cluster. When scaling microservices
    on a Kubernetes cluster, we can just as easily make use of either vertical or
    horizontal scaling.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序的增长，我们可能会达到一个点，我们的集群通常没有足够的计算、内存或存储来运行我们的应用程序。随着我们添加新的微服务（或复制现有的微服务以实现冗余），我们最终会耗尽集群中的节点。（我们可以在Azure门户或Kubernetes仪表板中监控这一点。）在这个时候，我们必须增加集群可用的总资源量。在Kubernetes集群上扩展微服务时，我们可以同样容易地使用纵向或横向扩展。
- en: Figure 11.12 shows what vertical scaling looks like for Kubernetes. We scale
    up our cluster by increasing the size of the virtual machines (VMs) in the node
    pool. We might start with three small-sized VMs and then increase their size so
    that we now have three large-sized VMs. We haven’t changed the number of VMs;
    we’ve just increased their size.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12显示了Kubernetes的纵向扩展看起来是什么样子。我们通过增加节点池中虚拟机（VM）的大小来扩展我们的集群。我们可能从三个小型的虚拟机开始，然后增加它们的大小，现在我们有三个大型的虚拟机。我们没有改变虚拟机的数量；我们只是增加了它们的大小。
- en: '![](../Images/CH11_F12_Davis4.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F12_Davis4.png)'
- en: Figure 11.12 Vertically scaling your cluster by increasing the size of the virtual
    machines (VMs)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 通过增加虚拟机（VM）的大小来纵向扩展您的集群
- en: 'In listing 11.8, we change the `vm_size` field from `Standard_B2ms` to `Standard_
    B4ms`. This upgrades the size of each VM in our Kubernetes node pool. Instead
    of two CPUs, we now have four (one for each VM). Memory and hard-drive are also
    increased. You can compare Azure VM sizes for yourself here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表11.8中，我们将`vm_size`字段从`Standard_B2ms`更改为`Standard_B4ms`。这升级了我们Kubernetes节点池中每个虚拟机的大小。现在我们有了四个CPU（每个虚拟机一个），内存和硬盘也增加了。您可以在这里自己比较Azure虚拟机大小：
- en: '[https://docs.microsoft.com/en-us/azure/virtual-machines/sizes-b-series-burstable](https://docs.microsoft.com/en-us/azure/virtual-machines/sizes-b-series-burstable)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/virtual-machines/sizes-b-series-burstable](https://docs.microsoft.com/en-us/azure/virtual-machines/sizes-b-series-burstable)'
- en: We still only have a single VM in our cluster, but we have increased the size
    of it. Scaling our cluster is as simple as a code change. Again we see power of
    *infrastructure-as-code*, the technique where we store our infrastructure configuration
    as code and make changes to our infrastructure by committing code changes that
    trigger our CD pipeline.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在集群中仍然只有一个虚拟机，但我们已经增加了它的大小。扩展我们的集群就像代码更改一样简单。我们再次看到了 *基础设施即代码* 的力量，这是一种技术，我们将基础设施配置存储为代码，并通过提交触发我们的
    CD 管道的代码更改来更改我们的基础设施。
- en: Listing 11.8 Vertically scaling the cluster with Terraform (an update to chapter-9/example-1/scripts/kubernetes-cluster.tf)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8 使用 Terraform 垂直扩展集群（更新至第 9 章示例 1 的 scripts/kubernetes-cluster.tf）
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Sets a bigger VM for each of the nodes in the cluster
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为集群中的每个节点设置更大的虚拟机
- en: 11.3.2 Horizontally scaling the cluster
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 水平扩展集群
- en: In addition to vertically scaling our cluster, we can also scale it horizontally.
    Our VMs can remain the same size, but we simply add more of these. By adding more
    VMs to our cluster, we spread the load of our application across more computers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了垂直扩展我们的集群外，我们还可以水平扩展它。我们的虚拟机可以保持相同的大小，但我们只是简单地添加更多。通过向我们的集群添加更多虚拟机，我们将应用程序的负载分散到更多的计算机上。
- en: Figure 11.13 illustrates how we can take our cluster from three VMs up to six.
    The size of each VM remains the same, but we gain more computing power by having
    more VMs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 展示了我们可以如何将我们的集群从三个虚拟机扩展到六个。每个虚拟机的大小保持不变，但通过拥有更多的虚拟机，我们获得了更多的计算能力。
- en: '![](../Images/CH11_F13_Davis4.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F13_Davis4.png)'
- en: Figure 11.13 Horizontally scaling your cluster by increasing the number of VMs
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 通过增加虚拟机数量水平扩展您的集群
- en: Listing 11.9 shows the code change we need to make to add more VMs to our node
    pool. Back in listing 11.8, we had `node_count` set to 1, but here we have changed
    it to 6! Note that we have reverted the `vm_size` field to the smaller size of
    `Standard_B2ms``.`
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.9 展示了我们需要进行的代码更改，以向我们的节点池添加更多虚拟机。在列表 11.8 中，我们将 `node_count` 设置为 1，但在这里我们将其更改为
    6！请注意，我们已经将 `vm_size` 字段恢复到较小的 `Standard_B2ms` 大小。`
- en: In this example, we increase the number of VMs, but not their size; although,
    there is nothing stopping us from increasing both the number and the size of our
    VMs. Generally, though, we might prefer horizontal scaling because it is less
    expensive than vertical scaling. That’s because using many smaller VMs is cheaper
    than using fewer but bigger and higher-priced VMs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们增加了虚拟机的数量，但没有增加其大小；尽管如此，我们也没有阻止自己同时增加虚拟机的数量和大小。不过，通常我们可能更倾向于水平扩展，因为它比垂直扩展更经济。这是因为使用许多较小的虚拟机比使用较少但更大、价格更高的虚拟机更便宜。
- en: Listing 11.9 Horizontal scaling the cluster with Terraform (update to chapter-9/example-1/scripts/kubernetes-cluster.tf)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.9 使用 Terraform 水平扩展集群（更新至第 9 章示例 1 的 scripts/kubernetes-cluster.tf）
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Increases the size of the node pool to 6\. The cluster is now powered by six
    VMs!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将节点池的大小增加到 6。现在集群由六个虚拟机供电！
- en: 11.3.3 Horizontally scaling an individual microservice
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 水平扩展单个微服务
- en: Assuming our cluster is scaled to an adequate size to host all the microservices
    with good performance, what do we do when individual microservices become overloaded?
    (This can be monitored in the Kubernetes dashboard.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的集群已经扩展到足够的大小，可以以良好的性能托管所有微服务，那么当单个微服务过载时我们该怎么办？（这可以在 Kubernetes 仪表板中监控。）
- en: The answer is that for any microservice that becomes a performance bottleneck,
    we can horizontally scale it to distribute its load over multiple instances. This
    is shown in figure 11.14\. We are effectively giving more compute, memory, and
    storage to this particular microservice so that it can handle a bigger workload.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，对于任何成为性能瓶颈的微服务，我们可以通过水平扩展它来在其多个实例之间分配其负载。这如图 11.14 所示。我们实际上为这个特定的微服务提供了更多的计算、内存和存储，以便它能够处理更大的工作负载。
- en: '![](../Images/CH11_F14_Davis4.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F14_Davis4.png)'
- en: Figure 11.14 Horizontally scaling a microservice by replicating it
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 通过复制微服务来水平扩展
- en: Again, we can make this change using code. In fact, we already did this in listing
    10.2 from chapter 10\. A snippet of the code is repeated again here in listing
    11.10.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用代码来做出这种更改。实际上，我们在第 10 章的列表 10.2 中已经做了这个操作。代码片段在此列表 11.10 中再次重复。
- en: We’ll set the `replicas` field to 3\. In chapter 10, we made this change for
    redundancy. Having multiple instances means that when any single instance fails
    the others can temporarily pick up its load while it restarts. Here we make the
    same change to the `replicas` field, but this time for performance reasons. Often,
    we need to make this change for both reasons. We’d like to have redundancy and
    good performance, and this is solved by creating replicas of our microservices
    where necessary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置 `replicas` 字段为 3。在第 10 章中，我们为了冗余进行了这个更改。拥有多个实例意味着当任何单个实例失败时，其他实例可以暂时接管其负载，直到它重新启动。这里我们对
    `replicas` 字段进行相同的更改，但这次是为了性能原因。我们通常需要出于这两个原因进行此更改。我们希望拥有冗余和良好的性能，而这通过在必要时创建我们的微服务的副本来解决。
- en: Listing 11.10 Horizontally scaling a microservice with Terraform (an update
    to chapter-9/example-1/scripts/modules/microservice/main.tf)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 使用 Terraform 横向扩展微服务（第 9 章示例-1/scripts/modules/microservice/main.tf
    的更新）
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Sets the number of replicas for the microservice to 3\. We can now distribute
    load evenly among three instances of this microservice.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将微服务的副本数量设置为 3。我们现在可以在这三个微服务实例之间均匀分配负载。
- en: 11.3.4 Elastic scaling for the cluster
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.4 集群的弹性扩展
- en: Moving into even more advanced territory, we can now think about *elastic scaling*,
    which is a technique where we automatically and dynamically scale our cluster
    to meet varying levels of demand. At periods of low demand, Kubernetes can automatically
    deallocate resources that aren’t needed. At periods of high demand, it can allocate
    new resources to meet the increased load. This makes for substantial cost savings
    because, at any given moment, we only pay for the resources that we need to handle
    the load on our application at that time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 进入更高级的领域，我们现在可以思考 *弹性扩展*，这是一种自动和动态调整我们的集群以满足不同需求水平的技术。在需求低峰期，Kubernetes 可以自动释放不需要的资源。在需求高峰期，它可以分配新的资源以满足增加的负载。这可以带来实质性的成本节约，因为在任何给定时刻，我们只为当时处理应用程序负载所需的资源付费。
- en: We can use elastic scaling at the cluster level to automatically grow our cluster
    when it’s nearing its resource limits. Yet again, this is just a code change.
    Listing 11.11 shows how we can enable the Kubernetes autoscaler and set the minimum
    and maximum size of our node pool.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在集群级别使用弹性扩展来自动扩展我们的集群，当它接近资源限制时。这同样只是一个代码更改。列表 11.11 展示了如何启用 Kubernetes
    自动扩展器并设置节点池的最小和最大大小。
- en: 'You can update the Terraform code in scripts/kubernetes-cluster.tf (from example-1
    in chapter 9) from the code in listing 11.11 to enable horizontal scaling for
    the FlixTube Kubernetes cluster. The scaling works by default, but there are many
    ways we can customize it. Search for “auto_scaler_profile” in the Terraform documentation
    to learn more:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Terraform 代码在 scripts/kubernetes-cluster.tf（第 9 章中的 example-1）中从列表 11.11
    中的代码更新为启用 FlixTube Kubernetes 集群的横向扩展。扩展默认情况下是启用的，但我们有很多方法可以自定义它。在 Terraform 文档中搜索“auto_scaler_profile”以了解更多信息：
- en: '[https://www.terraform.io/docs/providers/azurerm/r/kubernetes_cluster.html](https://www.terraform.io/docs/providers/azurerm/r/kubernetes_cluster.html)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.terraform.io/docs/providers/azurerm/r/kubernetes_cluster.html](https://www.terraform.io/docs/providers/azurerm/r/kubernetes_cluster.html)'
- en: Listing 11.11 Enabling elastic scaling for the cluster with Terraform(an update
    to chapter-9/example-1/scripts/kubernetes-cluster.tf)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.11 使用 Terraform 启用集群的弹性扩展（第 9 章示例-1/scripts/kubernetes-cluster.tf 的更新）
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Enables Kubernetes cluster autoscaling
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ① 启用 Kubernetes 集群自动扩展
- en: ② Sets the minimum node count to 3\. This cluster starts with three VMs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将最小节点数量设置为 3。这个集群从三个虚拟机开始。
- en: ③ Sets the maximum node count to 20\. This cluster can automatically scale up
    to 20 VMs to meet demand.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将最大节点数量设置为 20。这个集群可以自动扩展到 20 个虚拟机以满足需求。
- en: 11.3.5 Elastic scaling for an individual microservice
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.5 单个微服务的弹性扩展
- en: We can also enable elastic scaling at the individual microservice level. Listing
    11.12 is a sample of Terraform code that can give a microservice a “burstable”
    capability. The number of replicas for the microservice is expanded and contracted
    dynamically to meet the varying workload for the microservice (bursts of activity).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在单个微服务级别启用弹性扩展。列表 11.12 是一段 Terraform 代码示例，可以为微服务提供“爆发”能力。微服务的副本数量会根据微服务的不同工作量动态扩展和收缩（活动爆发）。
- en: 'You can add the code in listing 11.12 to the end of the Terraform code in the
    scripts/modules/microservice/main.tf file from example-1 in chapter 9\. Then,
    to enable elastic scaling for FlixTube microservices, invoke `terraform apply`.
    The scaling works by default, but can be customized to use other metrics. See
    the Terraform documentation to learn more:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将列表11.12中的代码添加到第9章example-1中的scripts/modules/microservice/main.tf文件Terraform代码的末尾。然后，为了为FlixTube微服务启用弹性扩展，调用`terraform
    apply`。默认情况下，扩展会生效，但可以根据需要自定义以使用其他指标。有关更多信息，请参阅Terraform文档：
- en: '[www.terraform.io/docs/providers/kubernetes/r/horizontal_pod_autoscaler.html](http://www.terraform.io/docs/providers/kubernetes/r/horizontal_pod_autoscaler.html)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.terraform.io/docs/providers/kubernetes/r/horizontal_pod_autoscaler.html](http://www.terraform.io/docs/providers/kubernetes/r/horizontal_pod_autoscaler.html)'
- en: 'To learn more about pod auto scaling in Kubernetes, see the Kubernetes docs
    at:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Kubernetes中Pod自动扩展的更多信息，请参阅以下Kubernetes文档：
- en: '[https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)'
- en: Listing 11.12 Enabling elastic scaling for a microservice with Terraform (an
    addition to chapter-9/example-1/scripts/modules/microservice/main.tf)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.12 使用Terraform为微服务启用弹性扩展（第9章/example-1/scripts/modules/microservice/main.tf的补充）
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Sets the range of instances for this microservice. It starts at 3 instances
    and can scale up to 20 to meet variable levels of demand.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置此微服务的实例范围。它从3个实例开始，可以扩展到20个实例以满足不同的需求水平。
- en: 11.3.6 Scaling the database
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.6 扩展数据库
- en: The last kind of scaling we’ll look at is scaling our database. Back in chapter
    4, you might remember we talked about the rule that *each microservice should
    have its own database* (see section 4.5.4).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的最后一种扩展方式是扩展我们的数据库。回顾第4章，你可能还记得我们讨论了这样一个规则：**每个微服务都应该有自己的数据库**（参见4.5.4节）。
- en: There are multiple problems in sharing databases between microservices; one
    is that it severely limits our scalability. Consider the situation depicted in
    figure 11.15\. We have multiple microservices sharing one database. This is a
    future scalability nightmare!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务之间共享数据库存在多个问题；其中一个是它严重限制了我们的可扩展性。考虑图11.15中描述的情况。我们有多达多个微服务共享一个数据库。这是一个未来的可扩展性噩梦！
- en: These microservices are not independent. The shared database is a fixed integration
    point among these, and it can become a serious performance bottleneck. If microservices
    share data, these will be tightly coupled. This severely limits our ability to
    restructure and refactor in the future. By sharing databases, we are hampering
    our own future ability to address performance problems.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些微服务不是独立的。共享数据库是这些服务之间固定的集成点，并且可能成为严重的性能瓶颈。如果微服务共享数据，这些服务将紧密耦合。这严重限制了我们在未来进行重构和重构的能力。通过共享数据库，我们阻碍了自己未来解决性能问题的能力。
- en: This scenario can completely destroy the “easy” scaling that we’ve worked so
    hard to achieve. If we want to structure our application like this, we might as
    well not be using microservices at all!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景可能会完全破坏我们费尽心思实现的“简单”扩展。如果我们想以这种方式构建我们的应用程序，我们不妨根本不使用微服务！
- en: '![](../Images/CH11_F15_Davis4.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F15_Davis4.png)'
- en: Figure 11.15 Why we don’t share databases between microservices (except possibly
    for replicas of the same microservice)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 为什么我们不共享微服务之间的数据库（除非可能是同一微服务的副本）
- en: Instead, our application should look like figure 11.16\. Every microservice
    has its own separate database. These microservices are independent, and that means
    we can easily apply horizontal scaling if necessary.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们的应用程序应该看起来像图11.16所示。每个微服务都有自己的独立数据库。这些微服务是独立的，这意味着如果需要，我们可以轻松地应用水平扩展。
- en: '![](../Images/CH11_F16_Davis4.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F16_Davis4.png)'
- en: Figure 11.16 Each separate microservice should have its own database.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 每个独立的微服务都应该有自己的数据库。
- en: At this point, I’d like to make it clear that just because we must have separate
    databases doesn’t mean we also require separate database servers. There is a cost
    to managing database servers, and usually, we’d like to keep that cost down. It’s
    perfectly OK to have a single database server that contains our separate databases
    as figure 11.17 illustrates. Having just one database server for your whole application
    makes it simpler and cheaper to get started with microservices.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我想明确指出，仅仅因为我们必须拥有独立的数据库，并不意味着我们也需要独立的数据库服务器。管理数据库服务器是有成本的，我们通常希望将这种成本降至最低。正如图
    11.17 所示，拥有一个包含我们独立数据库的单个数据库服务器可以使我们开始使用微服务更加简单和便宜。
- en: '![](../Images/CH11_F17_Davis4.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17](../Images/CH11_F17_Davis4.png)'
- en: Figure 11.17 It’s completely OK to have separate databases running on a shared
    database server (this is the simplest way to get started).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 在共享数据库服务器上运行独立的数据库是完全可行的（这是开始的最简单方式）。
- en: In the future, if we find that the workload for any particular database has
    grown too much, we can easily create a new database server and move that database
    to it as figure 11.18 shows. When needed, we can create dedicated servers for
    whichever of our databases need the extra compute, memory, or storage.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，如果我们发现任何特定数据库的工作负载增长过大，我们可以轻松创建一个新的数据库服务器，并将该数据库移动到其中，如图 11.18 所示。当需要时，我们可以为需要额外计算、内存或存储的任何数据库创建专用服务器。
- en: '![](../Images/CH11_F18_Davis4.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18](../Images/CH11_F18_Davis4.png)'
- en: Figure 11.18 As your application grows larger, you can scale it by splitting
    out large databases into their own independent database servers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 随着你的应用程序变大，你可以通过将大型数据库拆分到它们自己的独立数据库服务器上来进行扩展。
- en: Need an even more scalable database? We used MongoDB in this book, and it offers
    a database sharding feature (illustrated in figure 11.19). This allows us to distribute
    a single large database over multiple VMs. You might never need this level of
    scalability. It’s only required for extremely large databases, but it’s good to
    know we have this option if we ever need it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个更具可扩展性的数据库吗？在这本书中，我们使用了 MongoDB，它提供了一个数据库分片功能（如图 11.19 所示）。这允许我们将单个大型数据库分布在多个虚拟机上。你可能永远不需要这种级别的可扩展性。它仅适用于极大型数据库，但了解我们拥有这种选项是很好的，以防万一需要。
- en: '![](../Images/CH11_F19_Davis4.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18](../Images/CH11_F19_Davis4.png)'
- en: Figure 11.19 For extremely large databases, we might need MongoDB’s sharding
    feature to distribute a single large database across multiple VMs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 对于极大型数据库，我们可能需要 MongoDB 的分片功能，以将单个大型数据库分布在多个虚拟机上。
- en: 11.3.7 Managing changes to infrastructure
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.7 管理基础设施更改
- en: Making changes to infrastructure is a risky business, and it needs to be well
    managed. Make a mistake with any of the scaling techniques you have just read
    about and you can bring down your entire cluster. It’s best that we don’t make
    these kinds of changes to customer-facing infrastructure, so in this section,
    I present a technique for keeping such risky changes at arm’s length from our
    customers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对基础设施进行更改是一项风险业务，需要得到良好的管理。如果你在刚刚读到的任何扩展技术中犯了一个错误，你可能会使整个集群崩溃。我们最好不要对面向客户的基础设施进行这类更改，因此在本节中，我介绍了一种将此类风险更改与客户保持距离的技术。
- en: The technique is called *blue-green deployment*. We create two production environments
    and label these as *blue* and *green*. We can easily do this because in section
    11.2.6, we parameterized our Terraform code to create different environments distinguished
    by name.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为*蓝绿部署*。我们创建了两个生产环境，并将它们标记为*蓝色*和*绿色*。我们能够轻松做到这一点，因为在 11.2.6 节中，我们已经参数化了我们的
    Terraform 代码，以创建不同名称区分的环境。
- en: The first environment we create is labeled as the blue environment. Our customers
    use our application via our domain name (e.g., www.company.com). We then route
    them via DNS record to the blue environment. Now, to protect our customers, we’d
    prefer not to make any risky changes to the blue environment (regular and frequent
    updates to individual microservices are OK though, because that doesn’t risk any
    impact to the infrastructure).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个环境被标记为蓝色环境。我们的客户通过我们的域名（例如，www.company.com）使用我们的应用程序。然后，我们通过 DNS 记录将他们路由到蓝色环境。现在，为了保护我们的客户，我们宁愿不对蓝色环境进行任何风险性的更改（尽管对个别微服务的常规和频繁更新是可以接受的，因为这不会对基础设施造成任何影响）。
- en: To make any risky or experimental changes (like experimenting with scaling),
    we create a whole new production infrastructure that we label as the green environment.
    Our developers now work in the green environment, so any work they do is separated
    from the blue environment that our customers use. This is shown in figure 11.20.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行任何有风险的或实验性的更改（例如尝试扩展），我们创建了一个全新的生产基础设施，我们将其标记为绿色环境。我们的开发人员现在在绿色环境中工作，所以他们所做的任何工作都与客户使用的蓝色环境分开。这如图11.20所示。
- en: '![](../Images/CH11_F20_Davis4.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F20_Davis4.png)'
- en: Figure 11.20 Customers use the blue environment, while developers and testers
    work with the green environment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 客户使用蓝色环境，而开发人员和测试人员使用绿色环境。
- en: Once work on the green environment is completed, is tested, and is known to
    be working well, we can simply switch the DNS record from blue to green. Our customers
    can now use the green environment, and our developers and testers can change over
    to working with the blue environment. This is shown in figure 11.21.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦绿色环境的工作完成，经过测试，并且已知工作良好，我们只需将DNS记录从蓝色切换到绿色即可。我们的客户现在可以使用绿色环境，我们的开发人员和测试人员可以切换到与蓝色环境一起工作。这如图11.21所示。
- en: Should any issue be discovered with the new green environment, we can simply
    flip the DNS switch back to the blue environment and restore working functionality
    for our customers. In the future, we can continue to flip between blue and green
    environments, thus keeping our customers protected from potentially risky changes
    to our infrastructure.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现新的绿色环境有任何问题，我们可以简单地翻转DNS开关回到蓝色环境，为我们的客户恢复工作功能。在未来，我们可以继续在蓝色和绿色环境之间切换，从而保护我们的客户免受我们基础设施可能存在的风险更改的影响。
- en: '![](../Images/CH11_F21_Davis4.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F21_Davis4.png)'
- en: Figure 11.21 When the green environment is ready and tested, customers are switched
    over to it. Developers and testers then switch to the blue environment and continue
    working. When the blue environment is ready and tested, customers switch again,
    and the cycle continues.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 当绿色环境准备就绪并经过测试后，客户将切换到它。开发人员和测试人员随后切换到蓝色环境并继续工作。当蓝色环境准备就绪并经过测试后，客户再次切换，循环继续。
- en: 11.4 Security
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 安全
- en: We have briefly talked about security at various points throughout the book.
    We haven’t done it any justice though, because security is very important--even
    at the early stages of development. So much so that security really deserves its
    own book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中多个地方简要地讨论了安全问题。但我们并没有真正公正地对待它，因为安全非常重要——甚至在开发的早期阶段也是如此。如此重要，以至于安全真的值得有一本自己的书。
- en: 'Well, thankfully, there is a great book on security specifically for microservices:
    *Microservices Security in Action* by Prabath Siriwardena and Nuwan Dias (Manning,
    2020). For now though, let’s understand some of the basics.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，幸运的是，有一本关于微服务安全的优秀书籍：Prabath Siriwardena和Nuwan Dias合著的《Microservices Security
    in Action》（Manning，2020年）。不过，现在让我们先了解一些基础知识。
- en: Every application needs some level of security. Even if your data is not sensitive,
    you don’t want anyone to be able to fraudulently modify it. Even if your systems
    are not critical, you don’t want an attacker to disrupt your system and processes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都需要一定级别的安全。即使你的数据不是敏感的，你也不想任何人能够欺诈性地修改它。即使你的系统不是关键的，你也不想攻击者破坏你的系统和流程。
- en: 'We must make effective use of security techniques like authentication, authorization,
    and encryption to mitigate against malicious use of our application or data. We
    might also have to structure our data to protect the privacy and anonymity of
    our customers according to the regulations in our particular region. FlixTube
    doesn’t have any of this yet, although, we have taken some care already with the
    following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须有效地使用安全技术，如身份验证、授权和加密，以减轻对我们应用程序或数据的恶意使用。我们可能还必须根据我们特定地区的法规，对我们的数据进行结构化以保护客户的隐私和匿名性。尽管如此，FlixTube还没有这些，尽管我们已经对以下方面采取了一些措施：
- en: '*The only microservice exposed to the outside world (and, therefore, exposed
    to attack) is the gateway microservice.* This is by design! Our internal microservices
    are not directly accessible from outside our cluster.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*唯一暴露给外部世界（因此，暴露给攻击）的微服务是网关微服务。这是设计使然！我们的内部微服务不能从集群外部直接访问。'
- en: '*Although, initially, we exposed our RabbitMQ server and MongoDB database to
    the world for early experimentation, we quickly closed those off.* We did this
    to prevent direct external access to these crucial resources. This is important!
    Don’t expose such critical resources to the outside world unless you are 100%
    sure these are protected against attack.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽管最初，我们为了早期实验将我们的RabbitMQ服务器和MongoDB数据库暴露给世界，但我们很快关闭了这些服务。* 我们这样做是为了防止直接外部访问这些关键资源。这很重要！除非您100%确信这些资源受到攻击保护，否则不要将此类关键资源暴露给外界。'
- en: 'In the future, we’d like to upgrade FlixTube with at least the following security
    features:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们希望至少升级FlixTube以下安全特性：
- en: An authentication system at the gateway.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关处的认证系统。
- en: HTTPs for the connection with our customers. This will encrypt their communications,
    and using an external service like Cloudflare means you can get this online quickly.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTPS与我们的客户建立连接。这将加密他们的通信，使用像Cloudflare这样的外部服务意味着你可以快速上线。
- en: Of course, the level of security needed by any given application is only as
    important as the systems and data we are trying to protect. The amount of security
    we add to FlixTube is going to be much less than the security that’s needed by
    a banking application or government website.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何给定应用程序所需的安全级别的重要性仅与我们要保护的系统和数据有关。我们添加到FlixTube的安全性将远低于银行应用程序或政府网站所需的安全性。
- en: Security has to come from both ends of the organization. Your company should
    have security policies and a strategy that meets the requirements of the domain
    and your customers. Then, you and every other developer have a role to play in
    thinking about and implementing security according to the standards of your company.
    We should be writing simple, yet secure code. And as with defensive programming
    (see section 10.4.2), we should adopt a defensive mindset when it comes to security.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性必须来自组织的两端。您的公司应该有符合领域和客户要求的安全政策和策略。然后，您和每一位开发人员都有责任思考并按照公司的标准实施安全。我们应该编写简单但安全的代码。并且与防御性编程（见第10.4.2节）一样，在安全性方面，我们应该采取防御性的心态。
- en: 'First and foremost, when writing code and building microservices, we should
    ask how would someone attack this system? This primes our mind to proactively
    address security issues at the time when it can make the most difference: before
    we are attacked.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当编写代码和构建微服务时，我们应该问自己，有人会如何攻击这个系统？这使我们的思维处于主动应对安全问题的状态，在攻击发生之前，这可以产生最大的影响。
- en: 11.4.1 Trust models
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 信任模型
- en: FlixTube’s needs are simple enough that we can adopt a security model of *internal
    trust*, also known as *trust the network* (depicted in figure 11.22). In this
    model, we do *all* the authentication at the entry point to the system (the gateway
    microservice). The microservices within the cluster all trust each other implicitly
    and rely on the security of the underlying network to protect them from external
    attack.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube的需求足够简单，我们可以采用内部信任模型，也称为“信任网络”（如图11.22所示）。在这个模型中，我们在系统的入口点（网关微服务）进行所有认证。集群内的微服务相互信任，并依赖底层网络的安全性来保护它们免受外部攻击。
- en: The internal trust model is a simple way to get started with microservices.
    Simple is often better than complicated when it comes to security because simple
    offers fewer places for security problems to hide. We must be careful when introducing
    more complex security, because any kind of added complexity can actually introduce
    security loopholes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 内部信任模型是一种简单的方式来开始使用微服务。在安全性方面，简单往往比复杂更好，因为简单提供了更少的安全问题隐藏的地方。在引入更复杂的安全性时，我们必须小心，因为任何增加的复杂性实际上都可能引入安全漏洞。
- en: '![](../Images/CH11_F22_Davis4.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F22_Davis4.png)'
- en: Figure 11.22 An internal trust model. Authentication is applied to external
    requests at the gateway. Internal microservices trust each other and communicate
    without authentication.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 内部信任模型。在网关处应用认证。内部微服务相互信任，无需认证即可通信。
- en: If your security needs are higher than FlixTube’s, then the internal trust model
    might not be enough. This will also be the case if you have multiple clusters
    and you have microservices that need to communicate across clusters.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的安全需求高于FlixTube，那么内部信任模型可能不够。如果您有多个集群，并且需要跨集群通信的微服务，这也将是情况。
- en: A more secure model that you should consider is called *trust nothing* or *zero
    trust* (depicted in figure 11.23). In the zero trust model, all connections between
    microservices-both internal and external-are authenticated. Microservices do *not*
    automatically trust each other. We are making the assumption that any particular
    microservice could be hijacked or compromised, especially if the microservice
    is hosted externally in some other cluster.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑的一个更安全的模型被称为“零信任”或“无信任”（如图 11.23 所示）。在零信任模型中，所有微服务之间的连接——无论是内部还是外部——都需要进行身份验证。微服务之间不会自动信任彼此。我们假设任何特定的微服务都可能被劫持或受到损害，尤其是如果该微服务托管在其他集群中。
- en: '![](../Images/CH11_F23_Davis4.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F23_Davis4.png)'
- en: Figure 11.23 A trust nothing model. All connections, both internal and external,
    are authenticated. This model supports connections to external microservices.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 无信任模型。所有连接，无论是内部还是外部，都需要进行身份验证。此模型支持连接到外部微服务。
- en: 11.4.2 Sensitive configuration
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 敏感配置
- en: Any application has sensitive configuration data that needs to be protected.
    You might remember in chapter 7 that we stored our Azure credentials in Bitbucket
    repository variables (section 7.7.6). After splitting out the deployment code
    for infrastructure and microservices at the start of this chapter (in section
    11.2.3), we also needed a place to store credentials for our private container
    registry.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序都有需要保护的敏感配置数据。您可能记得在第 7 章中，我们将 Azure 凭据存储在 Bitbucket 仓库变量中（第 7.7.6 节）。在本章开头（第
    11.2.3 节）将基础设施和微服务的部署代码拆分出来后，我们也需要一个地方来存储私有容器注册表的凭据。
- en: As we build our application, there will be other passwords, tokens, and API
    keys that we’ll need to store *securely*. We could store any of this sensitive
    information in our code, and that would certainly be convenient. But it means
    that anyone who has or can get access to our code will also have access to operational
    information that can easily be used to subvert or take down our application.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建应用程序的过程中，我们还需要存储其他密码、令牌和 API 密钥，这些都需要安全地存储。我们可以在代码中存储任何这些敏感信息，这当然很方便。但这意味着任何拥有或能够访问我们的代码的人也将能够访问到可以轻松用于破坏或关闭我们的应用程序的操作信息。
- en: 'Bitbucket repository or account variables (or similar, depending on your CD
    provider) are a good way to store this information. You might, however, prefer
    to have a solution that’s independent of your source control or CD provider. For
    that scenario, Kubernetes has its own storage solution for secret configuration.
    You can read about it here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Bitbucket 仓库或账户变量（或类似项，取决于您的持续交付提供者）是存储此类信息的良好方式。然而，您可能更喜欢一个不依赖于您的源代码控制或持续交付提供者的解决方案。在这种情况下，Kubernetes
    为秘密配置提供了自己的存储解决方案。您可以在此处了解相关信息：
- en: '[https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/)'
- en: If that doesn’t suit your needs, there are various other products that can help.
    As an example, you might like to learn more about Vault, another open source product
    from Hashicorp (the developers of Terraform). Find out more at
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不符合您的需求，还有各种其他产品可以帮助您。例如，您可能想了解更多关于 Vault 的信息，这是 Hashicorp（Terraform 的开发者）的另一个开源产品。更多信息请访问
- en: '[https://www.vaultproject.io/](https://www.vaultproject.io/)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.vaultproject.io/](https://www.vaultproject.io/)'
- en: 11.5 Refactoring to microservices
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 微服务重构
- en: Way back in chapter 1 (section 1.1), I promised that after learning how to build
    a microservices application from scratch, that we’d eventually come back and discuss
    more on how to refactor an existing monolith to microservices. How we go about
    converting a monolith will be different in the details for any given monolith.
    There are so many ways we could go about this, but in this section, I’ll leave
    you with some basic strategies and tactics for conversion that anyone can use.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 章（第 1.1 节）中，我承诺在学习如何从头开始构建微服务应用程序之后，我们最终会回来讨论如何将现有的单体应用程序重构为微服务。对于任何给定的单体，我们将如何转换的细节会有所不同。我们可以用很多种方式来做这件事，但在这个部分，我将向您提供一些基本策略和战术，供任何人使用。
- en: The basic idea is the same as any development process. As was introduced in
    chapter 2 (section 2.4), it’s all about iteration, small and simple changes, and
    keeping the code working as you go (illustrated in figure 11.24).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想与任何开发过程相同。正如在第 2 章（第 2.4 节）中介绍的那样，它全部关于迭代、小而简单的更改，并在进行过程中保持代码的正常工作（如图 11.24
    所示）。
- en: Conversion of a monolith is a huge job (depending on the size and complexity
    of the monolith), and a *big bang* conversion is unlikely to be successful. The
    only safe way to get to the other side is through small and manageable chunks
    of work, with extremely thorough testing along the way.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的转换是一项巨大的工作（取决于单体的大小和复杂性），一次性的“大爆炸”转换不太可能成功。到达另一边的唯一安全方式是通过小而可控的工作块，并在过程中进行极其彻底的测试。
- en: We can’t just stop working on the product either. We still have a responsibility
    to add the features and fix the bugs that are requested by the business. It’s
    also essential that we keep the product working; we just can’t let problems build
    up.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不能停止对产品的开发。我们仍然有责任添加业务请求的功能和修复错误。同样重要的是，我们必须保持产品正常运行；我们只是不能让问题积累。
- en: '![](../Images/CH11_F24_Davis4.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F24_Davis4.png)'
- en: Figure 11.24 Refactoring a monolith to microservices can only be done in an
    iterative sequence of small and well-tested steps.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24 将单体重构为微服务只能通过一系列小而经过良好测试的迭代步骤来完成。
- en: Do you really need microservices?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的需要微服务吗？
- en: 'Before you start converting your monolith to microservices, you really need
    to ask: *are microservices really necessary?* The conversion to microservices
    is likely to be long and difficult. It will introduce significant complexity,
    and it will test the patience and resolve of your development team.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始将单体应用转换为微服务之前，你真的需要问自己：*微服务真的有必要吗？* 转换到微服务可能是一个漫长而困难的过程。它将引入显著的复杂性，并将考验你开发团队的耐心和决心。
- en: Is it really worth the cost of doing the conversion?
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个转换真的值得付出的代价吗？
- en: Do you really need to scale?
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你真的需要扩展吗？
- en: Do you really need the flexibility of microservices?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你真的需要微服务的灵活性吗？
- en: These are important questions. Make sure you have good answers.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是重要的问题。确保你有好的答案。
- en: Plan your conversion and involve everyone
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 规划你的转换并让每个人都参与
- en: You can’t simply strike out toward microservices in the dark! To stand the best
    chance of success, you need a documented vision about what your product will look
    like when you arrive.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在黑暗中简单地走向微服务！为了最大限度地提高成功的可能性，你需要一个关于你的产品到达时将是什么样子的文档化愿景。
- en: Use *domain driven design* (DDD) to model your business as microservices (see
    the end of this chapter for a book reference). Aim for a simple architecture.
    Plan for the immediate future and not for the far off uncertain future. Work backward
    from your architectural vision to what you have now. This is the sequence of changes
    you must make to convert to microservices. This doesn’t have to be planned in
    detail, but you do need a general idea of where you are going.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*领域驱动设计*（DDD）来将你的业务建模为微服务（参见本章末尾的书籍参考）。追求简单的架构。为眼前的未来而不是遥远的、不确定的未来做计划。从你的架构愿景倒退到现在。这是你必须做出的变化序列以转换为微服务。这不需要详细规划，但你确实需要有一个大致的方向。
- en: We need a vision of what we are building, an idea of how we are going to get
    there, and an understanding of why this is important. Plans always change. As
    they say, “a battle plan never survives contact with the enemy” (paraphrased from
    Helmuth von Moltke, the Elder). But this doesn’t mean we shouldn’t plan! Instead,
    we should be planning to allow for change to occur naturally during the process
    as we learn more about how our application should be structured. And we should
    revisit and revise our plan, updating it so that it remains relevant for as long
    as we follow the plan.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要有一个关于我们正在构建的愿景，一个关于我们如何到达那里的想法，以及为什么这很重要的理解。计划总是会发生变化的。正如他们所说，“战斗计划在与敌人的接触中永远不会存活”（转述自赫尔穆特·冯·毛奇，老将军）。但这并不意味着我们不应该计划！相反，我们应该计划让变化在过程中自然发生，因为我们更多地了解我们的应用程序应该如何构建。我们还应该回顾和修订我们的计划，更新它，以便在遵循计划的过程中保持相关性。
- en: The conversion plan should be created together with the team (or a subset of
    representatives) because implementing this conversion will be a shared and difficult
    exercise. You need to have everyone invested in it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 转换计划应该与团队（或代表的一部分）一起创建，因为实施这个转换将是一个共享且困难的练习。你需要让每个人都参与其中。
- en: It’s not enough just to have made a plan. Now you must communicate it to the
    wider company. Make sure the developers know what’s expected of them. Communicate
    with other business departments, describing it in a language that’s meaningful
    to them, so they know why this is taking place and the value it brings. Everyone,
    absolutely everyone, must understand the high stakes of this operation!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 只制定计划是不够的。现在你必须将其传达给更广泛的公司。确保开发者知道对他们有什么期望。与其他业务部门沟通，用对他们有意义的语言描述，让他们知道为什么这件事正在进行以及它带来的价值。每个人，绝对每个人，都必须理解这个操作的高风险！
- en: Know your legacy code
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的遗留代码
- en: Before and during the conversion, you should invest significant time getting
    to know your monolith. Create test plans. Conduct experiments. Understand its
    failure modes. Develop an idea of what parts of it are going to break through
    each step of the conversion.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换前后，你应该投入大量时间了解你的单体。创建测试计划。进行实验。了解其故障模式。对它在转换的每一步中哪些部分可能会突破有一个概念。
- en: Improve your automation
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 提升你的自动化
- en: Good automation is crucial to any microservice project. Before and during the
    conversion, you should be constantly investing in and improving your automation.
    If you aren’t already on top of your infrastructure and automation, you need to
    start working on it right away (even before starting the conversion!). You might
    find that changing your company’s mindset around automation is actually the *most*
    difficult part of this process.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的自动化对任何微服务项目至关重要。在转换前后，你应该持续投资并改进你的自动化。如果你还没有掌握你的基础设施和自动化，你需要立即开始工作（甚至在开始转换之前！）你可能会发现，改变公司对自动化的思维方式实际上是这个过程中最*难*的部分。
- en: You need reliable and fast automated deployment (chapters 6 and 7). Any features
    that you convert should either have automated testing already, or you should implement
    automated testing with good coverage while you are converting the feature to microservices
    (chapter 8).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要可靠且快速的自动化部署（第6章和第7章）。你转换的任何功能都应该已经具有自动化测试，或者你在将功能转换为微服务的同时实现良好的自动化测试（第8章）。
- en: With microservices, you can’t get away from automation. *If you can’t afford
    to invest in automation, you probably can’t afford to convert to* *microservices.*
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务，你无法摆脱自动化。*如果你无法承担投资自动化的费用，你可能也无法承担转换为* *微服务* *的费用。
- en: Build your microservices platform
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你的微服务平台
- en: Before the conversion starts, you need a platform on which you can host newly
    created microservices. You need a production environment to host microservices
    as these are incrementally extracted from your monolith (as shown in figure 11.25).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换开始之前，你需要一个平台，你可以在这个平台上托管新创建的微服务。你需要一个生产环境来托管微服务，因为这些是从你的单体中增量提取的（如图11.25所示）。
- en: 'In this book, you have the recipe to build one such platform. Create a private
    container registry and create your Kubernetes cluster according to chapters 6
    and 7\. After creating your first microservice, now create a shared template for
    your team: a blank microservice that can be the starting point for every other
    microservice. If you have different types of microservices, create multiple templates,
    one for each type.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你有了构建这样一个平台的秘方。根据第6章和第7章创建私有容器注册库，并创建你的Kubernetes集群。在创建你的第一个微服务之后，现在为你的团队创建一个共享模板：一个空白微服务，可以作为其他每个微服务的起点。如果你有不同的微服务类型，创建多个模板，每个类型一个。
- en: Create your automated testing pipeline and make it easy for developers to use.
    Create documentation, examples, and tutorials so your developers can quickly understand
    how to create and deploy new microservices to your platform.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的自动化测试流程，并使其易于开发者使用。创建文档、示例和教程，以便你的开发者可以快速了解如何创建和部署新的微服务到你的平台。
- en: '![](../Images/CH11_F24_Davis4.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F24_Davis4.png)'
- en: Figure 11.25 Small chunks of your monolith can be incrementally extracted and
    moved into your Kubernetes cluster.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25你的单体的小块可以增量提取并移动到你的Kubernetes集群中。
- en: Carve along natural seams
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着自然的缝隙雕刻
- en: Now look for existing components in your monolith that align with microservices
    in your architectural vision. These present great opportunities for chunk-by-chunk
    extraction of components from your monolith to microservices as figure 11.26 illustrates.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在寻找你单体中与你的架构愿景中的微服务相匹配的现有组件。这些为从单体中逐块提取组件到微服务提供了巨大的机会，如图11.26所示。
- en: If you struggle to find natural seams, your job will be much more difficult.
    If your monolith is a *giant ball of mud* or full of *spaghetti code*, you may
    have to refactor first or refactor during extraction. Either way, it’s going to
    be tricky. To be safe, your refactoring should be supported by automated testing.
    It will get messy--be prepared.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很难找到自然的缝隙，你的工作将会更加困难。如果你的单体应用是一个**巨大的泥球**或充满了**意大利面代码**，你可能必须首先重构或在进行提取时重构。无论如何，这将会很棘手。为了安全起见，你的重构应该由自动化测试支持。事情可能会变得混乱——做好准备。
- en: '![](../Images/CH11_F26_Davis4.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F26_Davis4.png)'
- en: Figure 11.26 A monolith will usually have natural seams. Use these to identify
    individual components that can be incrementally extracted to microservices.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 单体应用通常会有自然的缝隙。利用这些缝隙来识别可以逐步提取为微服务的单个组件。
- en: Extract the parts that change most frequently
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 提取变化最频繁的部分
- en: When deciding what order to convert components to microservices, prioritize
    those components that are changing the most. Having those parts of the monolith
    extracted early to microservices brings immediate and practical benefits, and
    you’ll start to feel the impact straightaway. This early *bang for the buck* should
    make a measurable improvement to your development pace. It will reduce your deployment
    risk, and it can help you convince others that the conversion is going well.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定将哪些组件转换为微服务时，优先考虑那些变化最多的组件。将这些部分从单体应用中早期提取出来作为微服务，会带来即时的实际效益，你将立即感受到其影响。这种早期的**性价比**应该会显著提高你的开发速度。它将降低你的部署风险，并有助于你说服他人转换正在进行得很好。
- en: And repeat . . .
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 并且重复……
- en: By repeatedly extracting small chunks to microservices and testing as we go,
    we’ll safely convert our monolith to a microservices-based application (figure
    11.27). It’s not going to be easy. It will probably take a long time (multiple
    years, depending on the size and complexity of your monolith). But it is doable!
    We just have to keep chipping away at it, one small piece by one small piece,
    until the job is done.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反复将小块内容提取到微服务中并边走边测试，我们将安全地将我们的单体应用转换为基于微服务的应用（图11.27）。这不会容易。可能需要很长时间（取决于单体应用的大小和复杂性，可能是数年）。但这是可行的！我们只需要一点一点地持续努力，直到工作完成。
- en: '![](../Images/CH11_F27_Davis4.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F27_Davis4.png)'
- en: Figure 11.27 Iteratively extract small chunks of your monolith to microservices,
    always testing and keeping it working. Eventually, your application will be decomposed
    to microservices.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27 逐步将单体应用的小块内容提取为微服务，始终进行测试并保持其运行。最终，你的应用将被分解为微服务。
- en: It doesn’t have to be perfect
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 不必追求完美
- en: When we establish our architectural vision, we are aiming for what I call *the
    developer’s utopia of microservices*. This is the place where we all want to live-*if
    only we could*. You have to be aware, though, that we aren’t really aiming for
    some perfect instantiation of a microservices application. Sure, that would be
    nice. But honestly, it’s probably not necessary to get all the way there.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确立我们的架构愿景时，我们追求的是我所说的**开发者的微服务乌托邦**。这是一个我们都希望居住的地方——如果我们能够的话。然而，你必须意识到，我们并不是真正追求一个完美的微服务应用实例。当然，那会很棒。但说实话，可能没有必要完全达到那里。
- en: Getting to perfection has a diminishing return on investment, and it’s rarely
    going to be worthwhile to try and push all the way through to it. Besides, it’s
    not possible to arrive at perfection because no one will ever agree completely
    on what that means. But it is still possible to move in that general direction
    and to make things much better along the way.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 达到完美的投资回报率会逐渐减少，而且很少值得尝试一直推进到那里。此外，由于没有人会完全同意这意味着什么，所以达到完美是不可能的。但仍然有可能朝着这个大致方向前进，并在过程中使事物变得更好。
- en: Every step on our journey to microservices should be selected to have a positive
    impact for our customers, our application, our development process, or our business.
    If at any time we find that continuing along the conversion is not delivering
    value, we must stop and reassess what we are doing.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通往微服务的旅程中的每一步都应该被选择，以便对我们的客户、我们的应用、我们的开发过程或我们的业务产生积极影响。如果我们发现继续转换不再产生价值，我们必须停止并重新评估我们所做的事情。
- en: Perhaps we are going about it the wrong way? Or, maybe we have now extracted
    all the value that is possible and pushing further ahead won’t continue to improve
    things. This could leave us with a partially converted monolith, but so what?
    Whatever works for you is OK. We are all aiming for good outcomes for our business,
    and we shouldn’t feel embarrassed at all about what it actually takes to achieve
    that, however it might look. If it does the job, it does the job. End of story.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们正在走错路？或者，也许我们已经提取了所有可能的价值，继续前进不会再继续改善事情。这可能会让我们得到一个部分转换的单体应用，但那又如何？对你有用的就是好的。我们都在为我们的业务寻求好的结果，而且我们不应该因为实现这些结果所付出的代价而感到尴尬，无论它看起来如何。如果它能完成任务，那就完成了。这就是故事的全部。
- en: A spectrum of possibilities
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性的光谱
- en: As you can see in figure 11.28, there is an infinite spectrum of possibilities
    between the monolith and the developer’s utopia of microservices. Who can say
    where on this continuum your application belongs? Certainly not me. Only you can
    decide that.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如图11.28所示，在单体和开发者的微服务乌托邦之间有一个无限的可能性光谱。谁能说你的应用程序在这个连续体上属于哪里？当然不是我。只有你能决定这一点。
- en: '![](../Images/CH11_F28_Davis4.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F28_Davis4.png)'
- en: Figure 11.28 A timeline of conversion to microservices. In the early days, you
    get a high return on your investment (ROI). As you proceed, however, you’ll get
    diminishing ROI, and it might not make sense to go all the way to the developer’s
    utopia of microservices.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28 微服务转换的时间线。在早期，你将获得很高的投资回报率（ROI）。然而，随着你继续前进，你将获得递减的投资回报率，而且可能没有必要完全过渡到开发者的微服务乌托邦。
- en: 11.6 Microservices on a budget
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 在预算内使用微服务
- en: Distributed architectures have always been a useful and powerful way to deliver
    complex applications. Microservices are popular now because of the current confluence
    and combination of cloud technologies, modern tools, and automation. This has
    made microservices more achievable and more cost-effective than ever before.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式架构一直是交付复杂应用的有用且强大的方式。由于当前云技术、现代工具和自动化的结合，微服务现在很受欢迎。这使得微服务比以往任何时候都更容易实现且成本效益更高。
- en: But a microservices application is still a complex thing to build. Even though
    each individual microservice is simple, you might struggle with the complexities
    of the application as a whole, especially if you are a small team, solo developer,
    or a lean startup.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但微服务应用仍然是一个复杂的构建任务。尽管每个单独的微服务都很简单，但你可能会在应用的整体复杂性上遇到困难，尤其是如果你是一个小团队、独立开发者或精益创业公司。
- en: Throughout this book, we have learned various tips and techniques that make
    it easier to learn microservices and get started with those. These will continue
    to help you in the future, should you need them. I present these insights here,
    again, in a more concise form.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们学习了各种技巧和技术，使学习微服务和开始使用它们变得更加容易。这些技巧在未来如果你需要时将继续帮助你。我再次以更简洁的形式呈现这些见解。
- en: '*Educate yourself to use modern tools and make the best use of those!* Rolling
    your own tools is time-consuming, difficult, and a distraction from what you should
    be doing: delivering features to your customers.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*教育自己使用现代工具，并充分利用这些工具！* 自己开发工具是耗时、困难且会分散你应做的事情：向客户交付功能。'
- en: '*Start with a single code repository and a single continuous delivery (CD)
    pipeline.* Later, when you have separated out multiple code repositories, create
    one or more *meta-repos* to bring these back together (as outlined in section
    11.2.5).'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从单个代码仓库和单个持续交付（CD）管道开始。* 之后，当你分离出多个代码仓库时，创建一个或多个*元仓库*将这些仓库重新组合在一起（如第11.2.5节所述）。'
- en: '*Use a single database server* that hosts one database per microservice.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用单个数据库服务器* 来托管每个微服务的一个数据库。'
- en: '*Create a Kubernetes cluster with a single VM.* Create only a single instance
    for each microservice (no replicas). In the beginning, you probably don’t need
    redundancy or performance. This helps keep costs down.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用单个虚拟机创建一个Kubernetes集群。* 为每个微服务创建一个实例（没有副本）。一开始，你可能不需要冗余或性能。这有助于降低成本。'
- en: '*Use external file storage and an external database server, making your cluster
    effectively stateless.* This lowers the risk for experimenting with your cluster.
    You might break your clusters, but you won’t lose your data. It also supports
    the blue- green deployment technique presented earlier (section 11.3.7).'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用外部文件存储和外部数据库服务器，使你的集群实际上是无状态的。* 这降低了你在集群上实验的风险。你可能会破坏你的集群，但你不会丢失你的数据。它还支持之前介绍的蓝绿部署技术（第11.3.7节）。'
- en: '*Use Docker Compose to simulate your application on your workstation for development
    and testing.* Employ live reload for fast development iterations.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Docker Compose在你的工作站上模拟你的应用程序进行开发和测试。* 使用实时重载进行快速的开发迭代。'
- en: '*In the early days, you might not need automated testing, but it is essential
    for building a large maintainable microservices application.* When building a
    minimal viable product (MVP) for a startup, however, you don’t need it. It is
    too early in the product’s lifecycle to make such a big commitment to infrastructure.
    We must prove our product before we can invest in the more advanced infrastructure!'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在早期，你可能不需要自动化测试，但对于构建一个可维护的微服务应用程序来说，它是必不可少的。然而，对于初创公司来说，构建一个最小可行产品（MVP）时，你可能不需要它。在产品的生命周期中，这还为时尚早，不能对基础设施做出如此大的承诺。我们必须在投资更先进的基础设施之前证明我们的产品！'
- en: '*You might not have automated testing, but you still need to test!* Set up
    for efficient and reliable manual testing. You need a script to quickly start
    your application on a development workstation, from nothing to a testable state,
    in a short amount of time. You can use Docker Compose and database fixtures to
    achieve this.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你可能没有自动化测试，但你仍然需要测试！* 设置高效且可靠的手动测试。你需要一个脚本来快速启动你的应用程序，从无到有，在短时间内进入可测试状态。你可以使用Docker
    Compose和数据库固定值来实现这一点。'
- en: '*Docker makes it easy to deploy third-party images to containers running in
    your cluster.* That’s how we deployed RabbitMQ in chapter 5\. You can find many
    other useful images on DockerHub: [https://hub.docker.com/](https://hub.docker.com/).'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker使得将第三方镜像部署到集群中运行的容器变得容易。* 这就是我们如何在第5章中部署RabbitMQ的方式。你可以在DockerHub上找到许多其他有用的镜像：[https://hub.docker.com/](https://hub.docker.com/).'
- en: '*Invest early in your automation, especially continuous delivery through automated
    deployment.* You will rely on this every working day, so make sure it works well.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽早投资于你的自动化，特别是通过自动化部署的持续交付。* 你将每天都会依赖它，所以请确保它运行良好。'
- en: 11.7 From simple beginnings . . .
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7 从简单的起点……
- en: Just look at how far we have come together! We started by creating a single
    microservice. Then we learned how to package and publish it using Docker. We learned
    how to develop and test multiple microservices on our development workstation
    using Docker Compose. Ultimately, we created a production environment in the cloud
    on Kubernetes and deployed our microservices-based application to it with Terraform.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 只看我们共同走过的路！我们从一个单一的微服务开始。然后我们学习了如何使用Docker打包和发布它。我们学习了如何在我们的开发工作站上使用Docker Compose开发和测试多个微服务。最终，我们在云上创建了一个生产环境，并使用Terraform将我们的基于微服务的应用程序部署到其中。
- en: Complexity management is at the heart of modern development. That’s why we invest
    time learning advanced architectural patterns like microservices.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性管理是现代发展的核心。这就是为什么我们投入时间学习高级架构模式，如微服务。
- en: What a great journey this has been! But I’m sad to say that our time together
    has come to an end. Your journey will continue, of course, and I wish you all
    the best in building your own complex applications with microservices.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是一次伟大的旅程！但我很遗憾地说，我们在一起的时间已经结束了。当然，你的旅程将继续，我祝愿你在使用微服务构建自己的复杂应用程序时一切顺利。
- en: '![](../Images/CH11_F29_Davis4.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F29_Davis4.png)'
- en: Figure 11.29 Our journey from a single microservice to multiple microservices
    running in production
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29 从单个微服务到在生产中运行的多个微服务的旅程
- en: 11.8 Continue your learning
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8 继续你的学习
- en: 'For one final time, let’s finish the chapter with some references to books
    that will help you learn more and carry your understanding and knowledge forward.
    To learn more about domain driven design (DDD), read the original book on it:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次，让我们通过一些书籍的引用来结束这一章，这些书籍将帮助你学习更多，并将你的理解和知识向前推进。要了解更多关于领域驱动设计（DDD）的信息，请阅读关于它的原始书籍：
- en: '*Domain Driven Design* by *Eric Evans (Addison-Wesley, 2004)*'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《领域驱动设计》* 由 *Eric Evans（Addison-Wesley，2004）*'
- en: 'If you don’t have much time, you can find a good summary in the free ebook,
    *Domain Driven Design Quickly* by Abel Avram and Floyd Marinescu (InfoQ, 2018),
    available here:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有太多时间，你可以在免费的电子书《领域驱动设计快速入门》中找到一个很好的总结，由Abel Avram和Floyd Marinescu（InfoQ，2018）编写，可在以下链接找到：
- en: '[https://www.infoq.com/minibooks/domain-driven-design-quickly/](https://www.infoq.com/minibooks/domain-driven-design-quickly/)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.infoq.com/minibooks/domain-driven-design-quickly/](https://www.infoq.com/minibooks/domain-driven-design-quickly/)'
- en: To better understand security for microservices, read
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解微服务的安全性，请阅读
- en: '*Microservices Security in Action* by *Prabath Siriwardena and Nuwan Dias (Manning,
    2020)*'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微服务实战安全》* 由 *Prabath Siriwardena 和 Nuwan Dias* 著（Manning, 2020）'
- en: 'To learn more details on theory on development with microservices, pick any
    of these books:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于使用微服务进行开发的细节理论，请选择以下任何一本书籍：
- en: '*The Tao of Microservices* by *Richard Rodger (Manning, 2017)*'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微服务之道》* 由 *Richard Rodger* 著（Manning, 2017）'
- en: '*Microservices Patterns* by *Chris Richardson (Manning, 2018)*'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微服务模式》* 由 *Chris Richardson* 著（Manning, 2018）'
- en: '*Microservices in Action* by *Morgan Bruce and Paulo A. Pereira (Manning, 2018)*'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微服务实战》* 由 *Morgan Bruce 和 Paulo A. Pereira* 著（Manning, 2018）'
- en: '*Microservices in .NET Core*, 2nd ed., by *Christian Horsdal Gammelgaard (Manning,
    2020)*'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《.NET Core 微服务》* 第 2 版，由 *Christian Horsdal Gammelgaard* 著（Manning, 2020）'
- en: '*Developing Microservice APIs with Python* by *José Haro Peralta (Manning,
    2020)*'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 Python 开发微服务 API》* 由 *José Haro Peralta* 著（Manning, 2020）'
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: To gain the most benefit from microservices, we must separate out our code repository
    and continuous delivery (CD) pipeline. This ensures that each microservice can
    be deployed independently. It also allows separate teams to take ownership for
    separate microservices.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了从微服务中获得最大利益，我们必须分离我们的代码仓库和持续交付（CD）管道。这确保了每个微服务都可以独立部署。它还允许不同的团队对不同的微服务负责。
- en: Using a meta-repo, we can regain some of the convenience of the monorepo (mono
    repository) after we have separated our code repositories.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元仓库，在我们分离代码仓库之后，我们可以恢复一些单仓库（单一仓库）的便利性。
- en: Having independent CD pipelines means we’ll have a scalable deployment pipeline.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有独立的 CD 管道意味着我们将拥有可扩展的部署管道。
- en: We can create multiple environments (e.g., development, test, and production)
    by parameterizing our Terraform deployment code.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过参数化我们的 Terraform 部署代码来创建多个环境（例如，开发、测试和生产）。
- en: We can configure separate CD pipelines for each branch (e.g., development, test
    and production) in our code repositories. Pushing code to a branch triggers the
    pipeline and deploys to the appropriate environment.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在代码仓库中为每个分支（例如，开发、测试和生产）配置独立的 CD 管道。将代码推送到分支会触发管道并部署到相应的环境。
- en: For increased performance, we have numerous options, including
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高性能，我们有多种选择，包括
- en: We can scale our cluster vertically and horizontally.
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以垂直和水平地扩展我们的集群。
- en: We can scale our microservices horizontally.
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以水平扩展我们的微服务。
- en: We can reserve dedicated compute for particular microservices.
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为特定的微服务预留专用计算资源。
- en: We can make use of elastic scaling to automatically scale our cluster and our
    microservices at times of peak demand.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用弹性扩展在需求高峰时自动扩展我们的集群和微服务。
- en: We should always have a single database per microservice so that we have options
    for scaling our data storage.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该为每个微服务保留单个数据库，这样我们就有选项来扩展我们的数据存储。
- en: Blue-green deployment switches our customers among alternating environments
    and is a safe way to manage potentially risky infrastructure upgrades.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝绿部署在交替环境中切换客户，是一种管理潜在风险基础设施升级的安全方式。
- en: Security for microservices is as important as any application, if not more so,
    given that a microservice application might have many gateways.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于微服务应用程序可能有许多网关，因此微服务的安全性与其他应用程序一样重要，甚至更为重要。
- en: We can employ security techniques such as authentication and authorization to
    protect access to our system.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以采用诸如身份验证和授权等安全技术来保护我们系统的访问权限。
- en: We can employ integrity protection techniques to protect our data and secure
    privacy and confidentiality for our customers.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以采用完整性保护技术来保护我们的数据，并为我们的客户确保隐私和机密性。
- en: Refactoring from a monolith to microservices can only be accomplished through
    a series of small and well-tested steps.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体架构重构到微服务只能通过一系列小而经过良好测试的步骤来完成。
- en: There are many ways we can make microservices more affordable and less complex
    when we are starting out. This makes microservices an effective and efficient
    starting point for startups, small teams, and solo developers.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们刚开始时，有许多方法可以使微服务更加经济实惠且不那么复杂。这使得微服务成为初创公司、小型团队和独立开发者一个有效且高效的起点。
