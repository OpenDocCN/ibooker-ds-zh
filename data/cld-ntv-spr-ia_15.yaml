- en: '12 Security: Authorization and auditing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 安全：授权和审计
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Authorization and roles with Spring Cloud Gateway and OAuth2
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway和OAuth2进行授权和角色
- en: Protecting APIs with Spring Security and OAuth2 (imperative)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security和OAuth2保护API（强制）
- en: Protecting APIs with Spring Security and OAuth2 (reactive)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security和OAuth2保护API（响应式）
- en: Protecting and auditing data with Spring Security and Spring Data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security和Spring Data保护并审计数据
- en: In the previous chapter, I introduced access control systems for cloud native
    applications. You saw how to add authentication to Edge Service with Spring Security
    and OpenID Connect, manage the user session life cycle, and address CORS and CSRF
    concerns when integrating an Angular frontend with Spring Boot.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我介绍了云原生应用的访问控制系统。你看到了如何使用Spring Security和OpenID Connect向边缘服务添加认证，管理用户会话生命周期，并在将Angular前端与Spring
    Boot集成时解决CORS和CSRF问题。
- en: By delegating the authentication step to Keycloak, Edge Service is not affected
    by the specific authentication strategy. For example, we used the login form feature
    offered by Keycloak, but we could also enable social login via GitHub or rely
    on an existing Active Directory to authenticate users. Edge Service only needs
    to support OIDC to verify that the authentication happened correctly and get information
    about the user via an ID Token.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将认证步骤委托给Keycloak，边缘服务不受特定认证策略的影响。例如，我们使用了Keycloak提供的登录表单功能，但我们也可以启用通过GitHub的社会登录或依赖于现有的Active
    Directory来认证用户。边缘服务只需要支持OIDC来验证认证是否正确发生，并通过ID令牌获取有关用户的信息。
- en: There are still a few issues we haven’t addressed. Polar Bookshop is a distributed
    system, and after a user authenticates successfully with Keycloak, Edge Service
    is supposed to interact with Catalog Service and Order Service on behalf of the
    user. How can we securely propagate the authentication context to the other system
    applications? This chapter will help you solve that problem using OAuth2 and Access
    Tokens.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些问题我们没有解决。极地书店是一个分布式系统，用户在成功通过Keycloak认证后，边缘服务应该代表用户与目录服务和订单服务交互。我们如何安全地将认证上下文传播到其他系统应用中？本章将帮助你使用OAuth2和访问令牌解决这个问题。
- en: 'After dealing with authentication, we will address the authorization step.
    Right now, both customers and employees of Polar Bookshop can perform any action
    on the system. This chapter will walk you through a few authorization scenarios
    handled with OAuth2, Spring Security, and Spring Data:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理认证之后，我们将解决授权步骤。目前，极地书店的客户和员工都可以在系统中执行任何操作。本章将指导你通过OAuth2、Spring Security和Spring
    Data处理几个授权场景：
- en: We’ll use a role-based access control (RBAC) strategy to protect the REST endpoints
    exposed by Spring Boot, depending on whether the user is a customer or an employee
    of the bookshop.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用基于角色的访问控制（RBAC）策略来保护Spring Boot暴露的REST端点，根据用户是否是书店的客户或员工。
- en: We’ll configure data auditing to keep track of which user made what changes.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将配置数据审计以跟踪哪个用户做了什么更改。
- en: We’ll enforce protection rules for data so that only its owner can access it.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将强制实施数据保护规则，以确保只有数据的所有者才能访问它。
- en: Finally, you’ll explore how you can test those changes using Spring Boot, Spring
    Security, and Testcontainers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将探索如何使用Spring Boot、Spring Security和Testcontainers测试这些更改。
- en: Note The source code for the examples in this chapter is available in the Chapter12/12-begin
    and Chapter12/12-end folders, containing the initial and final states of the project
    ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在Chapter12/12-begin和Chapter12/12-end文件夹中找到，包含项目的初始和最终状态（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: 12.1 Authorization and roles with Spring Cloud Gateway and OAuth2
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 使用Spring Cloud Gateway和OAuth2进行授权和角色
- en: In the previous chapter, we added user authentication features to Polar Bookshop.
    Edge Service is the access point to the system, so it’s an excellent candidate
    for addressing cross-cutting concerns like security. For that reason, we made
    it responsible for authenticating users. Edge Service initiates the authentication
    flow but delegates the actual authentication step to Keycloak using the OpenID
    Connect protocol.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向Polar Bookshop添加了用户认证功能。边缘服务是系统的访问点，因此它是解决诸如安全等横切关注点的绝佳候选者。因此，我们让它负责用户认证。边缘服务启动认证流程，但使用OpenID
    Connect协议将实际的认证步骤委托给Keycloak。
- en: Once a user authenticates successfully with Keycloak, Edge Service receives
    an ID Token from Keycloak with information about the authentication event and
    initiates an authenticated session with the user’s browser. At the same time,
    Keycloak also issues an *Access Token*, which is used to grant Edge Service access
    to downstream applications on behalf of the user as per OAuth2.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户通过Keycloak成功认证，边缘服务从Keycloak接收一个包含认证事件信息的ID令牌，并使用户的浏览器启动一个认证会话。同时，Keycloak还发放一个*访问令牌*，该令牌用于根据OAuth2协议代表用户授予边缘服务访问下游应用程序的权限。
- en: OAuth2 is an authorization framework that enables an application (called a *Client*)
    to obtain limited access to a protected resource provided by another application
    (called a *Resource Server*) on behalf of a user. When a user authenticates with
    Edge Service and asks to access their book orders, OAuth2 provides a solution
    for Edge Service to retrieve orders from Order Service on behalf of that user.
    This solution relies on a trusted party (called an *Authorization Server*), which
    issues an *Access Token* to Edge Service and grants access to the user’s book
    orders from Order Service.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2是一个授权框架，它使一个应用程序（称为*客户端*）能够代表用户获取对另一个应用程序（称为*资源服务器*）提供的受保护资源的有限访问权限。当用户通过边缘服务认证并请求访问其书籍订单时，OAuth2为边缘服务提供了一种解决方案，以便代表该用户从订单服务检索订单。此解决方案依赖于一个可信的第三方（称为*授权服务器*），该授权服务器向边缘服务发放*访问令牌*，并授予从订单服务访问用户书籍订单的权限。
- en: 'You might recognize some of these roles from the OIDC authentication flow we
    adopted in the previous chapter. As anticipated, OIDC is an identity layer built
    on top of OAuth2 and relies on the same basic concepts:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从我们在上一章中采用的OIDC认证流程中认出了这些角色。正如预期的那样，OIDC是建立在OAuth2之上的一个身份层，并依赖于相同的基本概念：
- en: '*Authorization Server*—The entity responsible for authenticating users and
    issuing, refreshing, and revoking Access Tokens. In Polar Bookshop, this is Keycloak.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*授权服务器*—负责认证用户并发放、刷新和撤销访问令牌的实体。在Polar Bookshop中，这是Keycloak。'
- en: '*User*—Also called the *Resource Owner*, this is the human logging in with
    the Authorization Server to get authenticated access to the Client application.
    It’s also the human or service granting a Client access to the protected resources
    provided by a Resource Server. In Polar Bookshop, it’s either a customer or an
    employee.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户*—也称为*资源所有者*，这是通过授权服务器登录以获取对客户端应用程序认证访问权限的人类。它也是授予客户端访问由资源服务器提供的受保护资源的人类或服务。在Polar
    Bookshop中，它可以是客户或员工。'
- en: '*Client*—The application requiring the user to be authenticated and asking
    the user for authorization to access protected resources on their behalf. It can
    be a mobile application, a browser-based application, a server-side application,
    or even a smart TV application. In Polar Bookshop, it’s Edge Service.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端*—需要用户认证并请求用户代表其访问受保护资源的应用程序。它可以是一个移动应用程序、基于浏览器的应用程序、服务器端应用程序，甚至是智能电视应用程序。在Polar
    Bookshop中，它是边缘服务。'
- en: '*Resource Server*—This is the application hosting the protected resources a
    Client wants to access on the user’s behalf. In Polar Bookshop, Catalog Service
    and Order Service are Resource Servers. Dispatcher Service is decoupled from the
    other applications and won’t be accessed on behalf of the user. As a result, it
    won’t participate in the OAuth2 setup.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源服务器*—这是托管客户端代表用户想要访问的受保护资源的应用程序。在Polar Bookshop中，目录服务和订单服务是资源服务器。调度服务与其他应用程序解耦，不会代表用户访问。因此，它不会参与OAuth2的设置。'
- en: Figure 12.1 shows how the four actors are mapped into the Polar Bookshop architecture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1显示了四个参与者如何在Polar Bookshop架构中映射。
- en: '![12-01](../Images/12-01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![12-01](../Images/12-01.png)'
- en: Figure 12.1 How the OIDC/OAuth2 roles are assigned to the entities in the Polar
    Bookshop architecture
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 Polar Bookshop架构中OIDC/OAuth2角色分配给实体的方式
- en: Edge Service can access downstream applications on behalf of the user through
    an Access Token issued by Keycloak during the OIDC authentication phase. In this
    section, you’ll see how to configure Spring Cloud Gateway in Edge Service to use
    the Access Token whenever a request is routed to Catalog Service and Order Service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务可以通过Keycloak在OIDC身份验证阶段颁发的访问令牌代表用户访问下游应用程序。在本节中，你将了解如何在边缘服务中配置Spring Cloud
    Gateway以在请求被路由到目录服务和订单服务时使用访问令牌。
- en: 'In the previous chapter, we defined two users: Isabelle has both the employee
    and customer roles, while Bjorn has just the customer role. In this section, you’ll
    also learn how to include that information in both ID Tokens and Access Tokens
    so Spring Security can read it and set up a role-based access control (RBAC) mechanism.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们定义了两个用户：伊莎贝尔同时拥有员工和客户角色，而比约恩只有客户角色。在本节中，你还将学习如何将此信息包含在ID令牌和访问令牌中，以便Spring
    Security可以读取它并设置基于角色的访问控制（RBAC）机制。
- en: Note In Polar Bookshop, the OAuth2 Client (Edge Service) and the OAuth2 Resource
    Servers (Catalog Service and Order Service) belong to the same system, but the
    same framework can be used when the OAuth2 Client is a third-party application.
    In fact, that was the original use case for OAuth2 and why it became so popular.
    Using OAuth2, services like GitHub or Twitter let you give third-party applications
    limited access to your account. For example, you could authorize a scheduling
    application to publish tweets on your behalf without exposing your Twitter credentials.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Polar Bookshop中，OAuth2客户端（边缘服务）和OAuth2资源服务器（目录服务和订单服务）属于同一系统，但当OAuth2客户端是第三方应用程序时，可以使用相同的框架。事实上，这正是OAuth2的原始用例，也是它为什么如此受欢迎的原因。使用OAuth2，像GitHub或Twitter这样的服务允许你授权第三方应用程序对你的账户进行有限的访问。例如，你可以授权一个调度应用程序代表你发布推文，而不必公开你的Twitter凭证。
- en: 12.1.1 Token relay from Spring Cloud Gateway to other services
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 从Spring Cloud Gateway到其他服务的令牌中继
- en: 'After a user successfully authenticates with Keycloak, Edge Service (the OAuth2
    Client) receives an ID Token and an Access Token:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用户成功通过Keycloak进行身份验证后，边缘服务（OAuth2客户端）会收到一个ID令牌和一个访问令牌：
- en: '*ID Token*—This represents a successful authentication event and includes information
    about the authenticated user.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ID令牌*——这代表一个成功的身份验证事件，并包含有关已认证用户的信息。'
- en: '*Access Token*—This represents the authorization given to the OAuth2 Client
    to access protected data provided by an OAuth2 Resource Server on the user’s behalf.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问令牌*——这代表授予OAuth2客户端代表用户访问由OAuth2资源服务器提供的受保护数据的授权。'
- en: In Edge Service, Spring Security uses the ID Token to extract information about
    the authenticated user, set up a context for the current user session, and make
    the data available through the OidcUser object. That’s what you saw in the previous
    chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘服务中，Spring Security使用ID令牌提取有关已认证用户的信息，为当前用户会话设置上下文，并通过OidcUser对象使数据可用。这正是你在上一章中看到的。
- en: The Access Token grants Edge Service authorized access to Catalog Service and
    Order Service (the OAuth2 Resource Servers) on behalf of the user. After we secure
    both applications, Edge Service will have to include the Access Token in all requests
    routed to them as an Authorization HTTP header. Unlike ID Tokens, Edge Service
    doesn’t read the Access Token’s content because it’s not the intended audience.
    It stores the Access Token received from Keycloak and then includes it as-is in
    any request to a protected endpoint downstream.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌授予边缘服务代表用户对目录服务和订单服务（OAuth2资源服务器）进行授权访问。在我们安全地保护了这两个应用程序之后，边缘服务必须在所有路由到它们的请求中包含访问令牌作为授权HTTP头。与ID令牌不同，边缘服务不会读取访问令牌的内容，因为它不是预期的受众。它存储从Keycloak接收到的访问令牌，并将其原样包含在任何请求到受保护端点的请求中。
- en: This pattern is called *token relay*, and it’s supported by Spring Cloud Gateway
    as a built-in filter, so you don’t need to implement anything yourself. When the
    filter is enabled, the Access Token is included automatically in all requests
    sent to one of the downstream applications. Figure 12.2 illustrates how the token
    relay pattern works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被称为*令牌中继*，Spring Cloud Gateway作为内置过滤器支持这种模式，因此你不需要自己实现任何内容。当过滤器启用时，访问令牌会自动包含在发送到下游应用程序之一的请求中。图12.2说明了令牌中继模式的工作原理。
- en: '![12-02](../Images/12-02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![12-02](../Images/12-02.png)'
- en: Figure 12.2 After a user is authenticated, Edge Service relays the Access Token
    to Order Service to call its protected endpoints on behalf of the user.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 用户认证后，边缘服务将访问令牌中继给订单服务，代表用户调用其受保护的端点。
- en: Let’s see how we can configure the Access Token relay in Edge Service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Edge Service中配置访问令牌中继。
- en: Note An Access Token has a validity period configured in Keycloak, and it should
    be as short as possible to reduce the exploitation time window in case the token
    gets leaked. An acceptable length is 5 minutes. When the token expires, the OAuth2
    Client can ask the Authorization Server for a new one using a third type of token
    called a *Refresh Token* (which also has a validity period). The refresh mechanism
    is handled by Spring Security transparently, and I won’t describe it further.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：访问令牌在Keycloak中配置了有效期，并且应该尽可能短，以减少令牌泄露时的利用时间窗口。可接受的长度是5分钟。当令牌过期时，OAuth2客户端可以使用一种称为*刷新令牌*的第三种令牌请求授权服务器的新令牌（该令牌也有有效期）。刷新机制由Spring
    Security透明地处理，这里不再进一步描述。
- en: Adopting the token relay pattern in Spring Cloud Gateway
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Gateway中采用令牌中继模式
- en: Spring Cloud Gateway implements the token relay pattern as a filter. In the
    Edge Service project (edge-service), open the application.yml file and add TokenRelay
    as a default filter, since we want it applied to all routes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway将令牌中继模式实现为一个过滤器。在Edge Service项目（edge-service）中，打开application.yml文件，将TokenRelay添加为默认过滤器，因为我们希望它应用于所有路由。
- en: Listing 12.1 Enabling the token relay pattern in Spring Cloud Gateway
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1 在Spring Cloud Gateway中启用令牌中继模式
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Enables the propagation of the Access Token when calling a downstream service
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启用在调用下游服务时传播访问令牌的功能
- en: 'With the filter enabled, Spring Cloud Gateway takes care of propagating the
    right Access Token as an Authorization header in all outgoing requests to Catalog
    Service and Order Service. For example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 启用过滤器后，Spring Cloud Gateway负责在所有发出的请求中将正确的访问令牌作为授权头传递给目录服务和订单服务。例如：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note Unlike ID Tokens which are JWTs, the OAuth2 framework doesn’t enforce a
    data format for Access Tokens. They can be of any String-based form. The most
    popular format is JWT, though, so that’s how we’ll parse Access Tokens on the
    consumer side (Catalog Service and Order Service).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与ID Tokens不同，ID Tokens是JWT，OAuth2框架不对访问令牌的数据格式进行强制要求。它们可以是任何基于字符串的形式。尽管如此，最流行的格式是JWT，因此我们将在消费者端（目录服务和订单服务）以这种方式解析访问令牌。
- en: By default, Spring Security stores the Access Tokens for the currently authenticated
    users in memory. When you have multiple instances of Edge Service running (which
    is always true in a cloud production environment to ensure high availability),
    you will encounter issues due to the statefulness of the application. Cloud native
    applications should be stateless. Let’s fix that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Security将当前认证用户的访问令牌存储在内存中。当你有多个边缘服务实例运行时（在云生产环境中始终如此，以确保高可用性），你将遇到由于应用程序的有状态性而产生的问题。云原生应用程序应该是无状态的。让我们解决这个问题。
- en: Storing Access Tokens in Redis
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redis中存储访问令牌
- en: Spring Security stores Access Tokens in an OAuth2AuthorizedClient object that
    is accessible through a ServerOAuth2AuthorizedClientRepository bean. The default
    implementation for that repository adopts an in-memory strategy for persistence.
    That’s what makes Edge Service a stateful application. How can we keep it stateless
    and scalable?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security将访问令牌存储在OAuth2AuthorizedClient对象中，该对象可以通过ServerOAuth2AuthorizedClientRepository
    bean访问。该存储库的默认实现采用内存策略进行持久化。这就是使边缘服务成为有状态应用程序的原因。我们如何使其无状态且可扩展？
- en: 'A simple way to do that is to store OAuth2AuthorizedClient objects in the web
    session rather than in memory so that Spring Session will pick them up automatically
    and save them in Redis, just like it does with ID Tokens. Fortunately, the framework
    already provides an implementation of the ServerOAuth2AuthorizedClientRepository
    interface to save data in the web session: WebSessionServerOAuth2AuthorizedClientRepository.
    Figure 12.3 illustrates how all the mentioned objects are related to each other.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个简单方法是将OAuth2AuthorizedClient对象存储在Web会话中而不是内存中，这样Spring Session就会自动将其拾取并存储在Redis中，就像它处理ID
    Tokens一样。幸运的是，框架已经提供了一个实现ServerOAuth2AuthorizedClientRepository接口的WebSessionServerOAuth2AuthorizedClientRepository实现。图12.3说明了所有提到的对象是如何相互关联的。
- en: '![12-03](../Images/12-03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![12-03](../Images/12-03.png)'
- en: Figure 12.3 The main classes involved in storing an Access Token for the currently
    authenticated user in Spring Security
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 存储当前认证用户访问令牌的Spring Security中涉及的主要类
- en: In the Edge Service project, open the SecurityConfig class and define a bean
    of type ServerOAuth2AuthorizedClientRepository using the implementation that stores
    Access Tokens in the web session.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Edge Service项目中，打开SecurityConfig类，并使用将访问令牌存储在Web会话中的实现来定义一个类型为ServerOAuth2AuthorizedClientRepository的bean。
- en: Listing 12.2 Saving OAuth2AuthorizedClient objects in the web session
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.2 在Web会话中保存OAuth2AuthorizedClient对象
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines a repository to store Access Tokens in the web session
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个存储访问令牌的Web会话的仓库
- en: Warning Access Tokens defined as JWTs should be handled with care. They are
    *bearer tokens*, meaning that any application can use them in an HTTP request
    and get access to an OAuth2 Resource Server. Handling the OIDC/ OAuth2 flow in
    the backend rather than in an SPA provides better security because we don’t expose
    any tokens to the browser. However, there might be other risks to manage, so carefully
    consider the *trust boundaries* of your system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：作为JWT定义的访问令牌应谨慎处理。它们是**携带令牌**，这意味着任何应用程序都可以在HTTP请求中使用它们，并访问OAuth2资源服务器。在后端而不是在单页应用（SPA）中处理OIDC/OAuth2流程提供了更好的安全性，因为我们不会向浏览器暴露任何令牌。然而，可能还有其他风险需要管理，因此请仔细考虑您系统的**信任边界**。
- en: In the next section you’ll see how to enhance ID Tokens and Access Tokens to
    propagate information about user roles.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到如何增强ID令牌和访问令牌，以传播有关用户角色的信息。
- en: 12.1.2 Customizing tokens and propagating user roles
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 自定义令牌和传播用户角色
- en: Both ID Tokens and Access Tokens can include different information about the
    user, which is formatted as *claims* in the JWT. Claims are simple key/value pairs
    in JSON format. For example, OpenID Connect defines several standard claims to
    carry information about the user, like given_name, family_name, preferred_username,
    and email.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ID令牌和访问令牌都可以包含有关用户的不同信息，这些信息以JWT中的**声明**格式呈现。声明是JSON格式中的简单键/值对。例如，OpenID Connect定义了几个标准声明来携带有关用户的信息，如given_name、family_name、preferred_username和email。
- en: Access to such claims is controlled through *scopes*, a mechanism provided by
    OAuth2 to limit what data an OAuth2 Client can access. You can think of scopes
    as roles assigned to applications rather than to users. In the previous chapter,
    we used Spring Security to make Edge Service an OAuth2 Client and configured it
    with the openid scope. That scope grants Edge Service access to the authenticated
    user’s identity (provided in the sub claim).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对此类声明的访问通过**作用域**进行控制，这是OAuth2提供的一种机制，用于限制OAuth2客户端可以访问的数据。您可以将作用域视为分配给应用程序而不是用户的角色。在前一章中，我们使用Spring
    Security将Edge Service配置为OAuth2客户端，并使用openid作用域进行配置。该作用域授予Edge Service访问认证用户身份（在sub声明中提供）的权限。
- en: Perhaps you have logged in to a third-party website using GitHub or Google (a
    social login based on OAuth2). If you did, you might have noticed that right after
    the authentication step, the service prompted you with a second request about
    what information from your GitHub or Google account you consented to allow the
    third party to access. That consent functionality is based on scopes, granting
    the third party (the OAuth2 Client) specific permissions depending on what scopes
    have been assigned.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可能您已经使用GitHub或Google（基于OAuth2的社会登录）登录到第三方网站。如果您这样做了，您可能已经注意到在认证步骤之后，服务向您提出了一个关于您同意第三方访问的GitHub或Google账户信息的第二个请求。这个同意功能基于作用域，根据分配的作用域授予第三方（OAuth2客户端）特定的权限。
- en: Regarding Edge Service, we can decide upfront what scopes it should be granted.
    This section will show you how to configure a roles claim with the list of roles
    assigned to the authenticated user. Then you’ll use a roles scope to grant Edge
    Service access to that claim and instruct Keycloak to include it in both ID Tokens
    and Access Tokens.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Edge Service，我们可以提前决定它应该被授予的作用域。本节将向您展示如何配置一个带有分配给认证用户的角色列表的角色声明。然后您将使用角色作用域来授予Edge
    Service访问该声明的权限，并指示Keycloak将其包含在ID令牌和访问令牌中。
- en: 'Before moving on, you’ll need a Keycloak container up and running. Open a Terminal
    window, navigate to the folder where you keep your Docker Compose file, and run
    the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要启动并运行一个Keycloak容器。打开一个终端窗口，导航到您保存Docker Compose文件的文件夹，并运行以下命令：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you haven’t followed along, you can refer to Chapter12/12-begin/polar-deployment/docker/docker-compose.yml
    in the accompanying repository.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有跟上，可以参考配套仓库中的Chapter12/12-begin/polar-deployment/docker/docker-compose.yml。
- en: Note Later I’ll provide you with a JSON file you can use to load the entire
    configuration when starting up the Keycloak container without being concerned
    with its persistence (as I did in the previous chapter). If you want to follow
    this second option directly, I still invite you to read through this section,
    since it provides the essential information you’ll need when moving on to the
    Spring Security part of the chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：稍后我会提供一个JSON文件，您可以在启动Keycloak容器时使用它来加载整个配置，而无需担心其持久性（正如我在上一章中所做的那样）。如果您想直接遵循这个第二个选项，我仍然邀请您阅读这一部分，因为它提供了您在进入本章的Spring
    Security部分时所需的必要信息。
- en: Configuring access to user roles in Keycloak
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Keycloak中配置用户角色的访问
- en: Keycloak comes preconfigured with a roles scope you can use to give an application
    access to the user roles contained in a roles claim. However, the default representation
    of the roles list is not very convenient to use because it’s defined as a nested
    object. Let’s change that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak预先配置了一个作用域，您可以使用它来授予应用程序访问包含在角色声明中的用户角色的权限。然而，默认的角色列表表示方式不太方便使用，因为它被定义为嵌套对象。让我们改变这一点。
- en: Once Keycloak is up and running, open a browser window, head to http://localhost:8080,
    log in to the administration console with the same credentials defined in the
    Docker Compose file (user/password), and choose the PolarBookshop realm. Then
    select Client Scopes from the left menu. On the new page (figure 12.4), you’ll
    find a list of all the preconfigured scopes in Keycloak, and you have the option
    to create new ones. In our case, we want to customize the existing roles scope,
    so click on it to open its settings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Keycloak启动并运行，打开一个浏览器窗口，转到http://localhost:8080，使用Docker Compose文件中定义的相同凭据（用户/密码）登录到管理控制台，并选择PolarBookshop领域。然后从左侧菜单中选择客户端作用域。在新页面上（图12.4），您将找到Keycloak中所有预配置的作用域列表，并且您可以选择创建新的作用域。在我们的情况下，我们想要自定义现有的角色作用域，因此点击它以打开其设置。
- en: '![12-04](../Images/12-04.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![12-04](../Images/12-04.png)'
- en: Figure 12.4 Creating and managing client scopes
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4创建和管理客户端作用域
- en: In the roles scope page, open the Mappers tab. That is where you can define
    the set of claims to which the given scope provides access (i.e., *mappings*).
    By default, Keycloak already has some mappers defined to map claims to the roles
    scope. We’re interested in the *realm roles* mapper, which maps the user realm
    roles (including employee and customer) to a JWT claim. Select that mapper.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在角色作用域页面中，打开映射器选项卡。在那里，您可以定义给定作用域提供的访问权限的声明集（即*映射*）。默认情况下，Keycloak已经定义了一些映射器来将声明映射到角色作用域。我们感兴趣的是*领域角色*映射器，它将用户领域角色（包括员工和客户）映射到一个JWT声明。选择该映射器。
- en: 'The settings page for the *realm roles* mapper provides a few options for customization.
    We want to change two things:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*领域角色*映射器的设置页面提供了一些自定义选项。我们想要改变两件事：'
- en: The token claim name should be roles instead of realm_access.roles (so we will
    remove the nested object).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌声明名称应该是roles而不是realm_access.roles（因此我们将删除嵌套对象）。
- en: The roles claim should be included in both ID Token and Access Token, so we
    must ensure that both options are enabled. We need both because Edge Service reads
    the claims from the ID Token while Catalog Service and Order Service read the
    claims from the Access Token. Edge Service is not the intended audience for the
    Access Token, which is forwarded to downstream applications as-is.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色声明应包含在ID令牌和访问令牌中，因此我们必须确保这两个选项都已启用。我们需要两者，因为边缘服务从ID令牌中读取声明，而目录服务和订单服务从访问令牌中读取声明。边缘服务不是访问令牌的目标受众，它将原始状态转发给下游应用程序。
- en: Figure 12.5 shows the final settings. When you’re done, click Save.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5显示了最终设置。完成操作后，请点击保存。
- en: '![12-05](../Images/12-05.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![12-05](../Images/12-05.png)'
- en: Figure 12.5 Configuring the mapper to include the user’s realm roles in a roles
    JWT claim
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5配置映射器以将用户的领域角色包含在角色JWT声明中
- en: Note In the source code repository accompanying the book, I included a JSON
    file you can use to load the entire configuration when starting up the Keycloak
    container in the future, including the latest changes regarding roles (Chapter12/12-end/polar-deployment/docker/keycloak/full-realm-config.json).
    I recommend updating your polar-keycloak container definition in Docker Compose
    to use this new JSON file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本书附带的源代码仓库中，我包含了一个 JSON 文件，您可以在将来启动 Keycloak 容器时使用它来加载整个配置，包括有关角色的最新更改（Chapter12/12-end/polar-deployment/docker/keycloak/full-realm-config.json）。我建议更新您的
    polar-keycloak 容器定义在 Docker Compose 中使用此新的 JSON 文件。
- en: Before moving on to the next section, stop any running containers (docker-compose
    down).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一节之前，停止任何正在运行的容器（docker-compose down）。
- en: Configuring access to user roles in Spring Security
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Security 中配置对用户角色的访问
- en: Keycloak is now configured to return the authenticated user roles in a roles
    claim included in both the ID Token and Access Token. However, the roles claim
    will only be returned if the OAuth2 Client (Edge Service) asks for the roles scope.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak 现在已配置为在 ID Token 和访问令牌中都返回认证用户角色，但只有当 OAuth2 客户端（边缘服务）请求角色范围时，才会返回角色声明。
- en: In the Edge Service project, open the application.yml file, and update the Client
    Registration configuration to include the roles scope.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘服务项目中，打开 application.yml 文件，并更新客户端注册配置以包括角色范围。
- en: Listing 12.3 Assigning the roles scope to Edge Service
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3 将角色范围分配给边缘服务
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Adds “roles” to the list of scopes so that Edge Service can get access to
    the user roles
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将“roles”添加到作用域列表中，以便边缘服务可以访问用户角色
- en: Next you’ll see how to extract the roles for the currently authenticated user
    from the ID Token.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将了解如何从 ID Token 中提取当前认证用户的角色。
- en: Extracting user roles from the ID Token
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ID Token 中提取用户角色
- en: In the previous chapter, we hardcoded the list of user roles in the UserController
    class of the Edge Service project because we didn’t have them in the ID Token
    yet. Now that we do, let’s refactor the implementation to fetch the roles for
    the currently authenticated user from the OidcUser class, which gives us access
    to the claims in the ID Token, including the brand-new roles claim.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在边缘服务项目的 UserController 类中硬编码了用户角色列表，因为我们还没有在 ID Token 中获得它们。现在我们有了，让我们重构实现，从
    OidcUser 类中获取当前认证用户的角色，该类使我们能够访问 ID Token 中的声明，包括全新的角色声明。
- en: Listing 12.4 Extracting the user roles list from the ID Token via OidcUser
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4 通过 OidcUser 从 ID Token 中提取用户角色列表
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Gets the “roles” claim and extracts it as a list of strings
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取“roles”声明并将其提取为字符串列表
- en: Finally, remember to update the test setup in UserControllerTests so that the
    mock ID Token contains a roles claim.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记得更新 UserControllerTests 中的测试设置，以便模拟 ID Token 包含角色声明。
- en: Listing 12.5 Adding roles list to the mock ID Token
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.5 将角色列表添加到模拟 ID Token
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Adds a “roles” claim to the mock ID Token
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向模拟 ID Token 添加“roles”声明
- en: 'You can verify that the changes are correct by running the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来验证更改是否正确：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note The roles claim configured in Keycloak will include our custom roles (employee
    and customer) together with a few extra roles managed and assigned by Keycloak
    itself.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Keycloak 中配置的角色声明将包括我们的自定义角色（员工和客户）以及一些由 Keycloak 本身管理和分配的额外角色。
- en: So far, we’ve configured Keycloak to include the user roles in the tokens and
    updated Edge Service to relay the Access Token to the applications downstream.
    We’re now ready to start securing Catalog Service and Order Service with Spring
    Security and OAuth2\.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置了 Keycloak 将用户角色包含在令牌中，并更新了边缘服务以将访问令牌转发给下游应用程序。我们现在可以开始使用 Spring
    Security 和 OAuth2 保护目录服务和订单服务了。
- en: 12.2 Protecting APIs with Spring Security and OAuth2 (imperative)
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 使用 Spring Security 和 OAuth2 保护 API（强制）
- en: When a user accesses the Polar Bookshop application, Edge Service initiates
    the OpenID Connect authentication flow through Keycloak and ultimately receives
    an Access Token granting it access to downstream services on behalf of that user.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问 Polar Bookshop 应用程序时，边缘服务通过 Keycloak 启动 OpenID Connect 认证流程，并最终收到一个代表该用户访问下游服务的访问令牌。
- en: 'In this section and the next one, you’ll see how to secure Catalog Service
    and Order Service by requiring a valid Access Token to access their protected
    endpoints. In the OAuth2 authorization framework, they play the role of OAuth2
    Resource Servers: the applications hosting protected data that a user can access
    through a third party (Edge Service, in our example).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和下一节中，您将了解如何通过要求有效的访问令牌来访问受保护端点来保护目录服务和订单服务。在 OAuth2 授权框架中，它们扮演 OAuth2 资源服务器的角色：托管受保护数据的应用程序，用户可以通过第三方（在我们的例子中是边缘服务）访问这些数据。
- en: OAuth2 Resource Servers don’t deal with user authentication. They receive an
    Access Token in the Authorization header of each HTTP request. Then they verify
    the signature and authorize the request according to the content of the token.
    We have already configured Edge Service to send over an Access Token when routing
    a request downstream. Now you’ll see how to use that token on the receiver side.
    This section will guide you through securing Catalog Service, built on the imperative
    Spring stack. The next section will show you how to achieve the same result in
    Order Service, built on the reactive Spring stack.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2 资源服务器不处理用户认证。它们在每个 HTTP 请求的授权头中接收一个访问令牌。然后它们验证签名并根据令牌的内容授权请求。我们已经配置了边缘服务在路由请求到下游时发送访问令牌。现在您将看到如何在接收端使用该令牌。本节将指导您如何保护基于强制式
    Spring 栈的目录服务。下一节将向您展示如何在基于反应式 Spring 栈的订单服务中实现相同的结果。
- en: 12.2.1 Securing Spring Boot as an OAuth2 Resource Server
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 将 Spring Boot 作为 OAuth2 资源服务器进行保护
- en: The first step in securing a Spring Boot application leveraging OAuth2 is to
    add a dependency on the dedicated Spring Boot starter that includes Spring Security
    and OAuth2 support for Resource Servers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 OAuth2 保护 Spring Boot 应用程序的第一步是添加一个依赖项，该依赖项包括 Spring Security 和 OAuth2 对资源服务器的支持。
- en: In the Catalog Service project (catalog-service), open the build.gradle file,
    and add the new dependency. Remember to refresh or reimport the Gradle dependencies
    after the new addition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录服务项目（catalog-service）中打开 build.gradle 文件，并添加新的依赖项。请记住，在添加新依赖项后刷新或重新导入 Gradle
    依赖项。
- en: Listing 12.6 Adding dependency for Spring Security OAuth2 Resource Server
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6 为 Spring Security OAuth2 资源服务器添加依赖项
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, let’s configure the integration between Spring Security and Keycloak.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置 Spring Security 和 Keycloak 之间的集成。
- en: Configuring the integration between Spring Security and Keycloak
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Spring Security 和 Keycloak 之间的集成
- en: 'Spring Security supports protecting endpoints using two data formats for the
    Access Token: JWT and opaque tokens. We’ll work with Access Tokens defined as
    JWTs, similar to what we did for ID Tokens. With Access Tokens, Keycloak grants
    Edge Service access to downstream applications on behalf of the user. When the
    Access Token is a JWT, we can also include relevant information as claims about
    the authenticated user and propagate this context to Catalog Service and Order
    Service with ease. In contrast, opaque tokens would require the application downstream
    to contact Keycloak every time to fetch the information associated with the token.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 支持使用两种数据格式保护端点使用访问令牌：JWT 和不透明令牌。我们将使用定义为 JWT 的访问令牌，类似于我们为 ID
    令牌所做的那样。使用访问令牌，Keycloak 代表用户授予边缘服务对下游应用程序的访问权限。当访问令牌是 JWT 时，我们还可以包括有关已认证用户的相关信息作为声明，并轻松地将此上下文传播到目录服务和订单服务。相比之下，不透明令牌将要求下游应用程序每次都联系
    Keycloak 以获取与令牌关联的信息。
- en: Configuring Spring Security to integrate with Keycloak as an OAuth2 Resource
    Server is more straightforward than the OAuth2 Client scenario. When working with
    JWTs, the application will contact Keycloak mainly to fetch the public keys necessary
    to verify the token’s signature. Using the issuer-uri property, similar to what
    we did for Edge Service, we’ll let the application auto-discover the Keycloak
    endpoint where it can find the public keys.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Spring Security 配置为与 Keycloak 集成作为 OAuth2 资源服务器比 OAuth2 客户端场景更简单。当处理 JWT 时，应用程序将主要联系
    Keycloak 以获取验证令牌签名所需的公钥。使用与边缘服务类似的方式，我们使用 issuer-uri 属性让应用程序自动发现可以找到公钥的 Keycloak
    端点。
- en: The default behavior is for the application to fetch the public keys lazily
    upon the first received HTTP request rather than at startup, both for performance
    and coupling reasons (you don’t need Keycloak up and running when starting the
    application). OAuth2 Authorization Servers provide their public keys using the
    JSON Web Key (JWK) format. The collection of public keys is called a *JWK Set*.
    The endpoint where Keycloak exposes its public keys is called the *JWK Set URI*.
    Spring Security will automatically rotate the public keys whenever Keycloak makes
    new ones available.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是应用程序在首次收到HTTP请求时懒加载公钥，而不是在启动时，这既是为了性能也是为了耦合原因（在启动应用程序时不需要Keycloak运行）。OAuth2授权服务器使用JSON
    Web Key（JWK）格式提供其公钥。公钥的集合称为*JWK Set*。Keycloak公开其公钥的端点称为*JWK Set URI*。Spring Security将在Keycloak提供新的公钥时自动轮换公钥。
- en: For each incoming request containing an Access Token in the Authorization header,
    Spring Security will automatically validate the token’s signature using the public
    keys provided by Keycloak and decode its claims via a JwtDecoder object, which
    is auto-configured behind the scenes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个包含在Authorization头中的访问令牌的传入请求，Spring Security将自动使用Keycloak提供的公钥验证令牌的签名，并通过JwtDecoder对象解码其声明，该对象在幕后自动配置。
- en: In the Catalog Service project (catalog-service), open the application.yml file,
    and add the following configuration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Catalog Service项目（catalog-service）中，打开application.yml文件，并添加以下配置。
- en: Listing 12.7 Configuring Catalog Service as an OAuth2 Resource Server
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.7 配置Catalog Service为OAuth2资源服务器
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ OAuth2 doesn’t enforce a data format for Access Tokens, so we must be explicit
    about our choice. In this case, we want to use JWT.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ OAuth2不强制执行访问令牌的数据格式，因此我们必须明确我们的选择。在这种情况下，我们想使用JWT。
- en: ❷ The Keycloak URL providing information about all the relevant OAuth2 endpoints
    for the specific realm
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提供有关特定领域所有相关OAuth2端点信息的Keycloak URL
- en: Note Explaining the cryptographic algorithm used to sign the Access Token is
    out of scope for this book. If you’d like to learn more about cryptography, you
    might want to look up *Real-World Cryptography* by David Wong (Manning, 2021).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：解释用于签名访问令牌的加密算法超出了本书的范围。如果您想了解更多关于密码学的信息，您可能想查阅David Wong的《Real-World Cryptography》（Manning，2021）。
- en: The integration between Catalog Service and Keycloak is now established. Next
    you’ll define some basic security policies to protect the application endpoints.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Catalog Service与Keycloak的集成现在已经建立。接下来，你将定义一些基本的安全策略来保护应用程序端点。
- en: Defining security policies for JWT authentication
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义JWT身份验证的安全策略
- en: 'For the Catalog Service application, we want to enforce the following security
    policies:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Catalog Service应用程序，我们想强制执行以下安全策略：
- en: GET requests to fetch books should be allowed without authentication.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取书籍的GET请求应允许无需身份验证。
- en: All other requests should require authentication.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他请求都应该需要身份验证。
- en: The application should be configured as an OAuth2 Resource Server and use JWT
    authentication.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该配置为OAuth2资源服务器并使用JWT身份验证。
- en: The flow for handling JWT authentication should be stateless.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理JWT身份验证的流程应该是无状态的。
- en: Let’s expand on the last policy. Edge Service triggers the user authentication
    flow and leverages the web session to store data like ID Tokens and Access Tokens
    that would otherwise get lost at the end of each HTTP request, forcing a user
    to authenticate at each request. To make it possible for the application to scale,
    we used Spring Session to store the web session data in Redis and keep the application
    stateless.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨最后一个策略。Edge Service触发用户身份验证流程并利用Web会话存储数据，如ID令牌和访问令牌，否则这些数据将在每个HTTP请求结束时丢失，迫使用户在每次请求时进行身份验证。为了使应用程序能够扩展，我们使用了Spring
    Session将Web会话数据存储在Redis中，并保持应用程序无状态。
- en: Unlike Edge Service, Catalog Service only needs an Access Token to authenticate
    a request. Since the token is always provided in each HTTP request to a protected
    endpoint, Catalog Service doesn’t need to store any data between requests. We
    call this strategy *stateless authentication* or *token-based authentication*.
    We use JWTs as Access Tokens, so we can also refer to it as *JWT authentication*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与Edge Service不同，Catalog Service只需要访问令牌来验证请求。由于令牌始终在每个HTTP请求中提供给受保护端点，因此Catalog
    Service不需要在请求之间存储任何数据。我们称这种策略为*无状态身份验证*或*基于令牌的身份验证*。我们使用JWT作为访问令牌，因此我们也可以将其称为*JWT身份验证*。
- en: Now on to the code. In the Catalog Service project, create a new SecurityConfig
    class in the com.polarbookshop.catalogservice.config package. Similar to what
    we did for Edge Service, we can use the DSL provided by HttpSecurity to build
    a SecurityFilterChain configured with the required security policies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到代码。在Catalog Service项目中，在com.polarbookshop.catalogservice.config包中创建一个新的SecurityConfig类。类似于我们对Edge
    Service所做的那样，我们可以使用HttpSecurity提供的DSL来构建配置了所需安全策略的SecurityFilterChain。
- en: Listing 12.8 Configuring security policies and JWT authentication
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.8 配置安全策略和JWT身份验证
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Enables Spring MVC support for Spring Security
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启用Spring MVC对Spring Security的支持
- en: ❷ Allows users to fetch greetings and books without being authenticated
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许用户在不进行认证的情况下获取问候语和书籍
- en: ❸ Any other request requires authentication.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 任何其他请求都需要进行认证。
- en: ❹ Enables OAuth2 Resource Server support using the default configuration based
    on JWT (JWT authentication)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 启用基于JWT（JWT身份验证）的默认配置的OAuth2资源服务器支持
- en: ❺ Each request must include an Access Token, so there’s no need to keep a user
    session alive between requests. We want it to be stateless.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 每个请求都必须包含一个访问令牌，因此无需在请求之间保持用户会话活跃。我们希望它是无状态的。
- en: ❻ Since the authentication strategy is stateless and doesn’t involve a browser-based
    client, we can safely disable the CSRF protection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 由于认证策略是无状态的，并且不涉及基于浏览器的客户端，我们可以安全地禁用CSRF保护。
- en: 'Let’s check if it works. First, the Polar UI, Keycloak, Redis, and PostgreSQL
    containers should be started. Open a Terminal window, navigate to the folder where
    you keep your Docker Compose configuration (polar-deployment/docker) and run the
    following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它是否工作。首先，应该启动Polar UI、Keycloak、Redis和PostgreSQL容器。打开一个终端窗口，导航到您保存Docker
    Compose配置的文件夹（polar-deployment/docker），并运行以下命令：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then run both Edge Service and Catalog Service (./gradlew bootRun from each
    project). Finally, open a browser window, and go to http://localhost:9000.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行边缘服务和目录服务（从每个项目执行./gradlew bootRun）。最后，打开一个浏览器窗口，转到http://localhost:9000。
- en: Ensure you can see the list of books in the catalog without being authenticated,
    but not add, update, or delete them. Then log in as Isabelle (isabelle/password).
    She is an employee of the bookshop, so she should be allowed to modify the books
    in the catalog. Next, log in as Bjorn (bjorn/password). He is a customer, so he
    shouldn’t be able to change anything in the catalog.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您可以在未经认证的情况下查看目录中的书籍列表，但不能添加、更新或删除它们。然后以Isabelle（isabelle/password）的身份登录。她是书店的员工，因此她应该被允许修改目录中的书籍。接下来，以Bjorn（bjorn/password）的身份登录。他是一位客户，因此他不应该能够更改目录中的任何内容。
- en: Under the hood, the Angular application fetches the user roles from the /user
    endpoint exposed by Edge Service and uses them to block pieces of functionality.
    That improves the user experience, but it’s not secure. The actual endpoints exposed
    by Catalog Service don’t take roles into account. We need to enforce role-based
    authorization. That’s the topic of the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Angular应用程序从Edge Service公开的/user端点获取用户角色，并使用它们来阻止部分功能。这提高了用户体验，但并不安全。目录服务公开的实际端点不考虑角色。我们需要强制执行基于角色的授权。这是下一节的主题。
- en: 12.2.2 Role-based access control with Spring Security and JWT
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 使用Spring Security和JWT进行基于角色的访问控制
- en: So far, when talking about authorization, we referred to granting an OAuth2
    Client (Edge Service) access to an OAuth2 Resource Server (like Catalog Service)
    on behalf of the user. Now we’ll move from application authorization to user authorization.
    What can an authenticated user do in the system?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在讨论授权时，我们提到了代表用户授予OAuth2客户端（边缘服务）对OAuth2资源服务器（如目录服务）的访问权限。现在我们将从应用程序授权转移到用户授权。认证用户在系统中能做什么？
- en: Spring Security associates each authenticated user with a list of GrantedAuthority
    objects that model the authorities the user has been granted. Granted authorities
    can be used to represent fine-grained permissions, roles, or even scopes and come
    from different sources depending on the authentication strategy. The authorities
    are available through the Authentication object representing the authenticated
    user and stored in the SecurityContext.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security将每个认证用户与一个GrantedAuthority对象列表关联，这些对象表示用户已被授予的权限。已授予的权限可以用来表示细粒度权限、角色，甚至范围，并且根据认证策略的不同来源而异。这些权限通过代表认证用户的Authentication对象和存储在SecurityContext中的权限可用。
- en: Since Catalog Service is configured as an OAuth2 Resource Server and uses JWT
    authentication, Spring Security extracts the list of scopes from the scopes claim
    of the Access Token and uses them as granted authorities for the given user automatically.
    Each GrantedAuthority object built in this way will be named with the SCOPE_ prefix
    and the scope value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目录服务配置为OAuth2资源服务器并使用JWT认证，Spring Security从访问令牌的scope声明中提取作用域列表，并将其用作给定用户的自动授权。这样构建的每个GrantedAuthority对象都将使用SCOPE_前缀和作用域值命名。
- en: The default behavior is acceptable in many scenarios where scopes are used to
    model permissions, but it doesn’t fit our case where we rely on user roles to
    know which privileges each user has. We want to set up a role-based access control
    (RBAC) strategy using the user roles provided in the roles claim of the Access
    Token (see figure 12.6). In this section, I’ll show you how to define a custom
    converter for the Access Token to build a list of GrantedAuthority objects using
    the values in the roles claim and the ROLE_ prefix. Then we’ll use those authorities
    to define authorization rules for the endpoints of Catalog Service.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多使用作用域来表示权限的场景中，默认行为是可以接受的，但它不适合我们依赖用户角色来了解每个用户有哪些权限的情况。我们希望设置一个基于角色的访问控制（RBAC）策略，使用访问令牌中角色声明提供的用户角色（见图12.6）。在本节中，我将向您展示如何定义一个自定义转换器，用于从角色声明中的值和ROLE_前缀构建GrantedAuthority对象列表。然后我们将使用这些权限来定义目录服务端点的授权规则。
- en: '![12-06](../Images/12-06.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![12-06](../Images/12-06.png)'
- en: Figure 12.6 How the user roles listed in the Access Token (JWT) are converted
    into GrantedAuthority objects used by Spring Security for RBAC
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 如何将访问令牌（JWT）中列出的用户角色转换为Spring Security用于RBAC的GrantedAuthority对象
- en: Note You might be wondering why we’re using the SCOPE_ or ROLE_ prefix. Since
    granted authorities can be used to represent different items (roles, scopes, permissions),
    Spring Security uses prefixes to group them. We’ll rely on this default naming
    convention for the Polar Bookshop example, but it’s possible to use different
    prefixes or even no prefixes at all. For more information, refer to the Spring
    Security documentation ([https://spring.io/projects/spring-security](https://spring.io/projects/spring-security)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能想知道为什么我们使用SCOPE_或ROLE_前缀。由于授权可以用来表示不同的项目（角色、作用域、权限），Spring Security使用前缀来分组它们。对于极地书店示例，我们将依赖此默认命名约定，但也可以使用不同的前缀，甚至完全不使用前缀。有关更多信息，请参阅Spring
    Security文档（[https://spring.io/projects/spring-security](https://spring.io/projects/spring-security)）。
- en: Extracting user roles from the Access Token
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从访问令牌中提取用户角色
- en: Spring Security provides a JwtAuthenticationConverter class we can use to define
    a custom strategy to extract information from a JWT. In our case, the JWT is an
    Access Token, and we want to configure how to build GrantedAuthority objects from
    the values in the roles claim. In the Catalog Service project (catalog-service),
    open the SecurityConfig class and define a new JwtAuthenticationConverter bean.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了一个JwtAuthenticationConverter类，我们可以用它来定义一个自定义策略，从JWT中提取信息。在我们的情况下，JWT是一个访问令牌，我们希望配置如何从角色声明中的值构建GrantedAuthority对象。在目录服务项目（catalog-service）中，打开SecurityConfig类并定义一个新的JwtAuthenticationConverter
    Bean。
- en: Listing 12.9 Mapping the roles from the JWT to granted authorities
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.9 将JWT中的角色映射到授权
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Defines a converter to map claims to GrantedAuthority objects
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个将声明映射到GrantedAuthority对象的转换器
- en: ❷ Applies the “ROLE_” prefix to each user role
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为每个用户角色应用“ROLE_”前缀
- en: ❸ Extracts the list of roles from the roles claim
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从角色声明中提取角色列表
- en: ❹ Defines a strategy to convert a JWT. We’ll only customize how to build granted
    authorities out of it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义一个转换JWT的策略。我们只会自定义如何从它构建授权。
- en: With this bean in place, Spring Security will associate a list of GrantedAuthority
    objects with each authenticated user, and we can use them to define authorization
    policies.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此Bean，Spring Security将为每个已认证用户关联一个GrantedAuthority对象列表，我们可以使用它们来定义授权策略。
- en: Defining authorization policies based on user roles
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户角色定义授权策略
- en: 'The Catalog Service endpoints should be protected according to the following
    policies:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目录服务端点应根据以下策略进行保护：
- en: All GET requests sent to the /,/books or /books/{isbn} endpoints should be allowed,
    even without authentication.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到/、/books或/books/{isbn}端点的所有GET请求都应被允许，即使没有认证。
- en: Any other request should require both user authentication and the employee role.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他请求都应该需要用户认证和员工角色。
- en: Spring Security provides an expression-based DSL for defining authorization
    policies. The most generic one is hasAuthority("ROLE_employee"), which you can
    use to check for any type of authority. In our case, authorities are roles, so
    we can use the most descriptive hasRole("employee") and drop the prefix (which
    is added by Spring Security under the hood).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 提供了一种基于表达式的 DSL，用于定义授权策略。其中最通用的是 hasAuthority("ROLE_employee")，您可以使用它来检查任何类型的权限。在我们的案例中，权限是角色，因此我们可以使用最描述性的
    hasRole("employee") 并删除前缀（这是 Spring Security 在底层添加的）。
- en: Listing 12.10 Applying RBAC to limit write access to users with the employee
    role
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.10 将 RBAC 应用于限制具有员工角色的用户的写访问
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Allows users to fetch greetings and books without being authenticated
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许用户在不进行身份验证的情况下获取问候语和书籍
- en: ❷ Any other request requires not only authentication but also the employee role
    (which is the same as the ROLE_employee authority).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 任何其他请求不仅需要身份验证，还需要员工角色（这与 ROLE_employee 权限相同）。
- en: Now you can rebuild and run Catalog Service (./gradlew bootRun) and go through
    the same flows as before. This time Catalog Service will ensure that only the
    bookshop employees are allowed to add, update, and delete books.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以重新构建并运行 Catalog Service（./gradlew bootRun），并按照之前的流程进行。这次 Catalog Service
    将确保只有书店员工可以添加、更新和删除书籍。
- en: Finally, stop the running applications (Ctrl-C) and containers (docker-compose
    down).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，停止运行中的应用程序（Ctrl-C）和容器（docker-compose down）。
- en: Note To learn more about the authorization architecture in Spring Security and
    the different strategies available for access control, you can refer to chapters
    7 and 8 in *Spring Security in Action* by Laurenţiu Spilcǎ (Manning, 2020), where
    they are explained in great detail.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要了解更多关于 Spring Security 中的授权架构和可用于访问控制的不同策略，您可以参考 Laurențiu Spilcǎ 所著的 *Spring
    Security in Action* 一书的第 7 章和第 8 章（Manning，2020），其中它们被详细解释。
- en: Next I’ll guide you through some techniques for testing security in an imperative
    Spring Boot application configured as an OAuth2 Resource Server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将指导您了解一些测试命令式 Spring Boot 应用程序（配置为 OAuth2 资源服务器）安全性的技术。
- en: 12.2.3 Testing OAuth2 with Spring Security and Testcontainers
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 使用 Spring Security 和 Testcontainers 测试 OAuth2
- en: When it comes to security, writing autotests is usually challenging. Fortunately,
    Spring Security provides us with convenient utilities to verify the security setup
    in slice tests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到安全性时，编写自动测试通常具有挑战性。幸运的是，Spring Security 为我们提供了方便的工具，用于在切片测试中验证安全性设置。
- en: This section will show you how to write slice tests for the web slice using
    mock Access Tokens and full integration tests relying on an actual Keycloak container
    run via Testcontainers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何使用模拟访问令牌编写针对 Web 切片的切片测试，以及依赖于通过 Testcontainers 运行的实际 Keycloak 容器的完整集成测试。
- en: Before starting, we need to add new dependencies on Spring Security Test and
    Testcontainers Keycloak. Open the build.gradle file for the Catalog Service project
    (catalog-service), and update it as follows. Remember to refresh or reimport the
    Gradle dependencies after the new addition.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要添加对 Spring Security Test 和 Testcontainers Keycloak 的新依赖项。打开 Catalog
    Service 项目（catalog-service）的 build.gradle 文件，并按照以下方式更新。记得在添加新依赖项后刷新或重新导入 Gradle
    依赖项。
- en: Listing 12.11 Adding dependencies to test Spring Security and Keycloak
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.11 添加测试 Spring Security 和 Keycloak 的依赖项
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ The version of Testcontainers Keycloak
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Testcontainers Keycloak 的版本
- en: ❷ Provides Keycloak testing utilities on top of Testcontainers
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 Testcontainers 上提供 Keycloak 测试工具
- en: Testing secured REST controllers with @WebMvcTest and Spring Security
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @WebMvcTest 和 Spring Security 测试受保护的 REST 控制器
- en: 'First, let’s update the BookControllerMvcTests class to cover the new scenarios,
    depending on the user authentication and authorization. For example, we could
    write test cases for DELETE operations in these situations:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新 BookControllerMvcTests 类以覆盖新的场景，这些场景取决于用户身份验证和授权。例如，我们可以为以下情况编写测试用例：
- en: The user is authenticated and has the employee role.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户已进行身份验证并且具有员工角色。
- en: The user is authenticated but doesn’t have the employee role.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户已进行身份验证但没有员工角色。
- en: The user is not authenticated.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户未进行身份验证。
- en: Delete operations are only allowed to the bookshop employees, so only the first
    request will return a successful answer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作仅允许书店员工进行，因此只有第一个请求将返回成功答案。
- en: As part of the OAuth2 Access Token validation, Spring Security relies on the
    public keys provided by Keycloak to verify the JWT signature. Internally, the
    framework configures a JwtDecoder bean to decode and verify a JWT using those
    keys. In the context of a web slice test, we can provide a mock JwtDecoder bean
    so that Spring Security skips the interaction with Keycloak (which we’ll validate
    later in a full integration test).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 OAuth2 访问令牌验证的一部分，Spring Security 依赖于 Keycloak 提供的公钥来验证 JWT 签名。内部，框架配置了一个
    JwtDecoder 实例来使用这些密钥解码和验证 JWT。在 Web Slice 测试的上下文中，我们可以提供一个模拟的 JwtDecoder 实例，这样
    Spring Security 就会跳过与 Keycloak 的交互（我们将在完整的集成测试中稍后验证）。
- en: Listing 12.12 Verifying security policies at the web layer with slice tests
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.12 使用切片测试验证网络层的安全策略
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Imports the application’s security configuration
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入应用程序的安全配置
- en: ❷ Mocks the JwtDecoder so that the application doesn’t try to call Keycloak
    and get the public keys for decoding the Access Token
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 模拟 JwtDecoder，使应用程序不尝试调用 Keycloak 并获取用于解码访问令牌的公钥
- en: ❸ Mutates the HTTP request with a mock JWT-formatted Access Token for a user
    with the “employee” role
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用模拟的 JWT 格式访问令牌，对具有“员工”角色的用户进行 HTTP 请求的修改
- en: ❹ Mutates the HTTP request with a mock JWT-formatted Access Token for a user
    with the “customer” role
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用模拟的 JWT 格式访问令牌，对具有“客户”角色的用户进行 HTTP 请求的修改
- en: 'Open a Terminal window, navigate to the Catalog Service root folder, and run
    the newly added tests as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到 Catalog Service 根目录，并按照以下方式运行新添加的测试：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Feel free to add more web slice autotests to cover GET, POST, and PUT requests.
    For inspiration, you can refer to the source code accompanying the book (Chapter12/
    12-end/catalog-service).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 随意添加更多用于覆盖 GET、POST 和 PUT 请求的 Web Slice 自动测试。为了获取灵感，您可以参考书中附带源代码（第12章/12-end/catalog-service）。
- en: Integration tests with @SpringBootTest, Spring Security, and Testcontainers
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @SpringBootTest、Spring Security 和 Testcontainers 进行集成测试
- en: The integration tests we wrote in the previous chapters will not work anymore
    for two reasons. First, all POST, PUT, and DELETE requests will fail because we
    are not providing any valid OAuth2 Access Token. Even if we were, there is no
    Keycloak up and running, required by Spring Security to fetch the public keys
    used to validate the Access Tokens.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中编写的集成测试将不再适用，原因有两个。首先，所有 POST、PUT 和 DELETE 请求都将失败，因为我们没有提供任何有效的 OAuth2
    访问令牌。即使我们有，也没有运行中的 Keycloak，Spring Security 需要它来获取用于验证访问令牌的公钥。
- en: 'You can verify the failure by running the following command from the Catalog
    Service root folder:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从 Catalog Service 根目录运行以下命令来验证失败：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have already seen how to use Testcontainers to write integration tests against
    data services like a PostgreSQL database, making our tests more reliable and ensuring
    environment parity. In this section we’ll do the same for Keycloak.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 Testcontainers 来编写针对数据服务（如 PostgreSQL 数据库）的集成测试，使我们的测试更加可靠并确保环境一致性。在本节中，我们将对
    Keycloak 执行相同的操作。
- en: Let’s start by configuring a Keycloak container via Testcontainers. Open the
    CatalogServiceApplicationTests class and add the following setup.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从通过 Testcontainers 配置 Keycloak 容器开始。打开 CatalogServiceApplicationTests 类并添加以下设置。
- en: Listing 12.13 Setup for a Keycloak test container
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.13 Keycloak 测试容器的设置
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Activates automatic startup and cleanup of test containers
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 激活测试容器的自动启动和清理
- en: ❷ Defines a Keycloak container for testing
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个用于测试的 Keycloak 容器
- en: ❸ Overwrites the Keycloak Issuer URI configuration to point to the test Keycloak
    instance
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 覆盖 Keycloak Issuer URI 配置，使其指向测试 Keycloak 实例
- en: The Keycloak test container is initialized via a configuration file I included
    in the code repository accompanying this book (Chapter12/12-end/catalog-service/src/test/resources/test-realm-config.json).
    Go ahead and copy it over to the src/test/resources folder of your Catalog Service
    project (catalog-service).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak 测试容器通过我包含在本书附带代码库中的配置文件（第12章/12-end/catalog-service/src/test/resources/test-realm-config.json）进行初始化。请将其复制到您的
    Catalog Service 项目（catalog-service）的 src/test/resources 文件夹中。
- en: In production, we would call Catalog Service via Edge Service, which is responsible
    for authenticating users and relaying Access Tokens to the downstream applications.
    We now want to test Catalog Service in isolation and verify different authorization
    scenarios. Therefore, we need to generate some Access Tokens first, so that we
    can use them to call the Catalog Service endpoints under testing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我们会通过边缘服务调用目录服务，该服务负责对用户进行身份验证并将访问令牌中继到下游应用程序。现在我们希望单独测试目录服务并验证不同的授权场景。因此，我们需要首先生成一些访问令牌，以便我们可以使用它们来调用正在测试的目录服务端点。
- en: The Keycloak configuration I provided in the JSON file includes the definition
    of a test Client (polar-test) that we can use to authenticate users via a username
    and password directly, instead of going through the browser-based flow we implemented
    in Edge Service. In OAuth2, such a flow is called a *Password Grant*, and it’s
    not recommended for production use. In the following section, we’ll use it just
    for testing purposes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 JSON 文件中提供的 Keycloak 配置包括测试客户端（polar-test）的定义，我们可以使用它通过用户名和密码直接对用户进行身份验证，而不是通过我们在边缘服务中实现的基于浏览器的流程。在
    OAuth2 中，这种流程称为 *密码授权*，并且不建议在生产环境中使用。在下一节中，我们仅将其用于测试目的。
- en: Let’s set up CatalogServiceApplicationTests to authenticate with Keycloak as
    Isabelle and Bjorn so that we can obtain the Access Tokens we need to call the
    Catalog Service’s protected endpoints. Keep in mind that Isabelle is both a customer
    and employee, whereas Bjorn is only a customer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置 CatalogServiceApplicationTests 以 Isabelle 和 Bjorn 身份进行身份验证，这样我们就可以获取调用目录服务受保护端点所需的访问令牌。请记住，Isabelle
    既是客户也是员工，而 Bjorn 只是一个客户。
- en: Listing 12.14 Setup for obtaining test Access Tokens
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.14 获取测试访问令牌的设置
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ A WebClient used to call Keycloak
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 WebClient 调用 Keycloak
- en: ❷ Authenticates as Isabelle and obtains an Access Token
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 以 Isabelle 身份进行身份验证并获取访问令牌
- en: ❸ Authenticates as Bjorn and obtains an Access Token
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 以 Bjorn 身份进行身份验证并获取访问令牌
- en: ❹ Uses the Password Grant flow to authenticate with Keycloak directly
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用密码授权流程直接通过 Keycloak 进行身份验证
- en: ❺ Blocks until a result is available. This is how we use WebClient imperatively
    rather than reactively.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 等待直到有结果可用。这就是我们强制使用 WebClient 而不是反应式使用的方式。
- en: ❻ Instructs Jackson to use this constructor when deserializing JSON into KeycloakToken
    objects
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 指示 Jackson 在反序列化 JSON 到 KeycloakToken 对象时使用此构造函数
- en: 'Finally, we can update the test cases in CatalogServiceApplicationTests to
    cover several authentication and authorization scenarios. For example, we could
    write test cases for POST operations in these situations:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更新 CatalogServiceApplicationTests 中的测试用例以涵盖几个身份验证和授权场景。例如，我们可以在以下情况下编写
    POST 操作的测试用例：
- en: The user is authenticated and has the employee role (extending the existing
    test case).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户已进行身份验证并具有员工角色（扩展现有测试用例）。
- en: The user is authenticated but doesn’t have the employee role (new test case).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户已进行身份验证，但没有员工角色（新测试用例）。
- en: The user is not authenticated (new test case).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户未进行身份验证（新测试用例）。
- en: Note In the context of an OAuth2 Resource Server, authentication means token
    authentication. In this case, it happens by providing an Access Token in the Authorization
    header of each HTTP request.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在 OAuth2 资源服务器上下文中，身份验证意味着令牌身份验证。在这种情况下，它通过在每个 HTTP 请求的授权头中提供访问令牌来实现。
- en: Create operations are only allowed to the bookshop employees, so only the first
    request will return a successful answer.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 创建操作仅允许书店员工进行，因此只有第一个请求将返回成功答案。
- en: Listing 12.15 Verifying security scenarios in integration tests
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.15 集成测试中验证安全场景
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Sends a request to add a book to the catalog as an authenticated employee
    user (Isabelle)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 以已验证的员工用户（Isabelle）的身份发送请求以将书籍添加到目录中
- en: ❷ The book has been successfully created (201).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 书籍已成功创建（201）。
- en: ❸ Sends a request to add a book to the catalog as an authenticated customer
    user (Bjorn)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 以已验证的客户用户（Bjorn）的身份发送请求以将书籍添加到目录中
- en: ❹ The book has not been created because the user doesn’t have the correct authorization,
    no “employee” role (403).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 由于用户没有正确的授权，没有“员工”角色（403），因此尚未创建书籍。
- en: ❺ Sends a request to add a book to the catalog as an unauthenticated user
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 以未验证用户身份发送请求以将书籍添加到目录中
- en: ❻ The book has not been created because the user is not authenticated (401).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 由于用户未进行身份验证（401），因此尚未创建书籍。
- en: 'Open a Terminal window, navigate to the Catalog Service root folder, and run
    the newly added tests as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到目录服务根目录，并按以下方式运行新添加的测试：
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are still tests failing. Go ahead and update them by including the right
    Access Token (Isabelle’s or Bjorn’s) in any POST, PUT, or DELETE request, as you
    learned in the previous example. When you’re done, rerun the tests and verify
    that they are all successful. For inspiration, you can refer to the source code
    accompanying this book (Chapter12/12-end/catalog-service).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些测试没有通过。按照之前示例中的方法，在任意的POST、PUT或DELETE请求中包含正确的访问令牌（Isabelle的或Bjorn的），然后继续更新它们。完成后，重新运行测试并验证它们是否全部成功。为了获得灵感，您可以参考本书附带源代码（第12章/12-end/catalog-service）。
- en: 12.3 Protecting APIs with Spring Security and OAuth2 (reactive)
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 使用Spring Security和OAuth2保护API（响应式）
- en: Securing reactive Spring Boot applications like Order Service is similar to
    what we did for Catalog Service. Spring Security provides intuitive and consistent
    abstractions across the two stacks, which makes it easy to move from one stack
    to the other.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 保护像订单服务这样的响应式Spring Boot应用程序与我们在目录服务中做的是相似的。Spring Security在这两个堆栈中提供了直观且一致的抽象，这使得从一个堆栈移动到另一个堆栈变得容易。
- en: In this section, I’ll guide you through configuring Order Service as an OAuth2
    Resource Server, enabling JWT authentication, and defining security policies for
    the web endpoints.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将指导您配置订单服务作为OAuth2资源服务器，启用JWT身份验证，并为Web端点定义安全策略。
- en: 12.3.1 Securing Spring Boot as an OAuth2 Resource Server
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 将Spring Boot作为OAuth2资源服务器进行保护
- en: The Spring Boot starter dependency that includes Spring Security and OAuth2
    support for Resource Servers is the same for both imperative and reactive applications.
    In the Order Service project (order-service), open the build.gradle file, and
    add the new dependency. Remember to refresh or reimport the Gradle dependencies
    after the new addition.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 包含Spring Security和OAuth2对资源服务器支持的Spring Boot启动器依赖项对于命令式和响应式应用程序都是相同的。在订单服务项目（order-service）中，打开build.gradle文件，并添加新的依赖项。请记住，在添加新依赖项后，刷新或重新导入Gradle依赖项。
- en: Listing 12.16 Adding dependency for Spring Security OAuth2 Resource Server
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.16 添加Spring Security OAuth2资源服务器依赖项
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next we’ll configure the integration between Spring Security and Keycloak.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置Spring Security与Keycloak之间的集成。
- en: Configuring the integration between Spring Security and Keycloak
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Spring Security与Keycloak之间的集成
- en: The strategy for integrating Spring Security with Keycloak will be similar to
    what we did in Catalog Service. Open the Order Service project (order-service),
    and update the application.yml file with the following configuration.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将Spring Security与Keycloak集成的策略将与我们在目录服务中做的一样。打开订单服务项目（order-service），并使用以下配置更新application.yml文件。
- en: Listing 12.17 Configuring Order Service as an OAuth2 Resource Server
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.17 将订单服务配置为OAuth2资源服务器
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ OAuth2 doesn’t enforce a data format for Access Tokens, so we must be explicit
    about our choice. In this case, we want to use JWT.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ OAuth2不强制执行访问令牌的数据格式，因此我们必须明确我们的选择。在这种情况下，我们想使用JWT。
- en: ❷ The Keycloak URL providing information about all the relevant OAuth2 endpoints
    for the specific realm
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提供特定领域所有相关OAuth2端点信息的Keycloak URL
- en: The integration between Order Service and Keycloak is now established. Next
    we’ll define the necessary security policies to protect the application endpoints.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 订单服务与Keycloak的集成现在已经建立。接下来，我们将定义必要的保护应用程序端点的安全策略。
- en: Defining security policies for JWT authentication
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 定义JWT身份验证的安全策略
- en: 'For the Order Service application, we want to enforce the following security
    policies:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于订单服务应用程序，我们想强制执行以下安全策略：
- en: All requests should require authentication.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有请求都应需要身份验证。
- en: The application should be configured as an OAuth2 Resource Server and use JWT
    authentication.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应配置为OAuth2资源服务器并使用JWT身份验证。
- en: The flow for handling JWT authentication should be stateless.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理JWT身份验证的流程应该是无状态的。
- en: 'There are two main differences here from what we did in Catalog Service:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在目录服务中做的不太一样的地方有两个：
- en: The reactive syntax is slightly different from its imperative counterpart, especially
    the part for enforcing JWT authentication (stateless).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式语法与其命令式对应物略有不同，尤其是在强制执行JWT身份验证（无状态）的部分。
- en: We’re not extracting user roles from the Access Token because the endpoints
    don’t have special requirements depending on user roles.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有从访问令牌中提取用户角色，因为端点没有根据用户角色有特殊要求。
- en: In the Order Service project, create a SecurityConfig class in a new com.polarbookshop.orderservice.config
    package. Then use the DSL provided by ServerHttpSecurity to build a SecurityWebFilterChain
    configured with the required security policies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在订单服务项目中，在新的com.polarbookshop.orderservice.config包中创建一个SecurityConfig类。然后使用ServerHttpSecurity提供的DSL构建一个配置了所需安全策略的SecurityWebFilterChain。
- en: Listing 12.18 Configuring security policies and JWT authentication for Order
    Service
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.18 为订单服务配置安全策略和JWT认证
- en: '[PRE24]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Enables Spring WebFlux support for Spring Security
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启用Spring WebFlux对Spring Security的支持
- en: ❷ All requests require authentication.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 所有请求都需要进行认证。
- en: ❸ Enables OAuth2 Resource Server support using the default configuration based
    on JWT (JWT authentication)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用基于JWT（JWT认证）的默认配置启用OAuth2资源服务器支持
- en: ❹ Each request must include an Access Token, so there’s no need to keep a session
    cache alive between requests. We want it to be stateless.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 每个请求都必须包含一个访问令牌，因此不需要在请求之间保持会话缓存活跃。我们希望它是无状态的。
- en: ❺ Since the authentication strategy is stateless and doesn’t involve a browser-based
    client, we can safely disable the CSRF protection.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 由于认证策略是无状态的，并且不涉及基于浏览器的客户端，我们可以安全地禁用CSRF保护。
- en: 'Let’s check if this works. First, we need to run the backing services (Polar
    UI, Keycloak, Redis, RabbitMQ, and PostgreSQL). Open a Terminal window, navigate
    to the folder where you keep your Docker Compose configuration (polar-deployment/docker)
    and run the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它是否工作。首先，我们需要运行后端服务（Polar UI、Keycloak、Redis、RabbitMQ和PostgreSQL）。打开一个终端窗口，导航到您保存Docker
    Compose配置的文件夹（polar-deployment/docker）并运行以下命令：
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then run Edge Service, Catalog Service, and Order Service on the JVM (./gradlew
    bootRun from each project). Finally, open a browser window, and go to http://localhost:9000.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在JVM上运行Edge Service、目录服务和订单服务（从每个项目运行./gradlew bootRun）。最后，打开一个浏览器窗口，并转到http://localhost:9000。
- en: Since Order Service doesn’t have particular requirements depending on the user’s
    role, you can log in with either Isabelle (isabelle/password) or Bjorn (bjorn/password).
    Then pick a book from the catalog, and submit an order for it. Since you’re authenticated,
    you’re allowed to create an order. When you’re done, you can visit the Orders
    page to check all the submitted orders.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于订单服务没有根据用户角色特定的要求，您可以使用Isabelle（isabelle/password）或Bjorn（bjorn/password）登录。然后从目录中选择一本书，并提交订单。由于您已认证，您被允许创建订单。完成操作后，您可以去订单页面查看所有提交的订单。
- en: “Wait a second! What do you mean, all the submitted orders?” I’m glad you asked.
    At the moment, each person can see the orders submitted by all users. Don’t worry!
    Later in the chapter, we’ll fix that.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: “等等！你说的所有提交的订单是什么意思？”我很高兴你问了。目前，每个人都可以看到所有用户提交的订单。别担心！在本章的后面部分，我们会解决这个问题。
- en: Before we do, though, we need to discuss how to test the new Order Service security
    policies. Stop the running applications (Ctrl-C) and containers (docker-compose
    down). The next section will show you how to test security in a reactive application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，我们需要讨论如何测试新的订单服务安全策略。停止运行中的应用程序（Ctrl-C）和容器（docker-compose down）。下一节将向您展示如何在响应式应用程序中测试安全性。
- en: 12.3.2 Testing OAuth2 with Spring Security and Testcontainers
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 使用Spring Security和Testcontainers测试OAuth2
- en: Testing secured reactive Spring Boot applications is similar to testing imperative
    applications. Before starting, we need to add new dependencies on Spring Security
    Test and Testcontainers Keycloak. The dependency adding JUnit5 support for Testcontainers
    is already there. Open the build.gradle file and update it as follows. Remember
    to refresh and reimport the Gradle dependencies after the new addition.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 测试受保护的响应式Spring Boot应用程序类似于测试命令式应用程序。在开始之前，我们需要在Spring Security Test和Testcontainers
    Keycloak上添加新的依赖项。Testcontainers的JUnit5支持依赖项已经存在。打开build.gradle文件，并按以下方式更新它。记得在添加新依赖项后刷新并重新导入Gradle依赖项。
- en: Listing 12.19 Adding dependencies to test Spring Security and Keycloak
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.19 向测试Spring Security和Keycloak添加依赖项
- en: '[PRE26]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ The version of Testcontainers Keycloak
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Testcontainers Keycloak的版本
- en: ❷ Provides Keycloak testing utilities on top of Testcontainers
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在Testcontainers之上提供Keycloak测试工具
- en: We can implement full integration tests using @SpringBootTest and Testcontainers
    Keycloak. Since the setup is the same as for Catalog Service, I won’t cover those
    tests here, but you can find them in the repository accompanying the book (Chapter12/12-end/order-service/src/test).
    Make sure you update those integration tests, or the application build will fail.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 @SpringBootTest 和 Testcontainers Keycloak 实现完整的集成测试。由于设置与 Catalog Service
    相同，这里不会介绍这些测试，但你可以在本书附带的存储库中找到它们（第 12 章/12-end/order-service/src/test）。确保你更新了这些集成测试，否则应用程序构建将失败。
- en: In this section, we’ll test the web slice of a reactive application when the
    endpoints are secured, much like we did for Catalog Service.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试当端点受保护时反应式应用程序的 Web Slice，这与我们对 Catalog Service 所做的一样。
- en: Testing secured REST controllers with @WebFluxTest and Spring Security
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @WebFluxTest 和 Spring Security 测试受保护的 REST 控制器
- en: We have already written autotests in OrderControllerWebFluxTests for the web
    slice using @WebFluxTest. Let’s see now how to update them to take security into
    account.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 OrderControllerWebFluxTests 中为 Web Slice 编写了 autotests，使用 @WebFluxTest。现在让我们看看如何更新它们以考虑安全性。
- en: As part of the OAuth2 Access Token validation, Spring Security relies on the
    public keys provided by Keycloak to verify the JWT signature. Internally, the
    framework configures a ReactiveJwtDecoder bean to decode and verify a JWT using
    those keys. In the context of a web slice test, we can provide a mock ReactiveJwtDecoder
    bean so that Spring Security skips the interaction with Keycloak (which will be
    validated by full integration tests).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 OAuth2 访问令牌验证的一部分，Spring Security 依赖于 Keycloak 提供的公钥来验证 JWT 签名。内部，框架配置了一个
    ReactiveJwtDecoder 实例来使用这些密钥解码和验证 JWT。在 Web Slice 测试的上下文中，我们可以提供一个模拟的 ReactiveJwtDecoder
    实例，这样 Spring Security 就会跳过与 Keycloak 的交互（这些交互将由完整的集成测试进行验证）。
- en: Listing 12.20 Verifying security policies at the web layer with slice tests
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.20 使用切片测试验证 Web 层的安全策略
- en: '[PRE27]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Imports the application security configuration
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入应用程序安全配置
- en: ❷ Mocks the ReactiveJwtDecoder so that the application doesn’t try to call Keycloak
    and get the public key for decoding the Access Token
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 模拟 ReactiveJwtDecoder，这样应用程序就不会尝试调用 Keycloak 并获取解码访问令牌的公钥
- en: ❸ Mutates the HTTP request with a mock, JWT-formatted Access Token for a user
    with the “customer” role
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用模拟的、JWT 格式的访问令牌，以“customer”角色的用户对 HTTP 请求进行修改
- en: 'Open a Terminal window, navigate to the Order Service root folder, and run
    the newly added tests as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到 Order Service 根目录，并按照以下方式运行新添加的测试：
- en: '[PRE28]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As always, you can find more test examples in the source code repository accompanying
    this book (Chapter12/12-end/order-service).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，你可以在本书附带的源代码存储库中找到更多测试示例（第 12 章/12-end/order-service）。
- en: 12.4 Protecting and auditing data with Spring Security and Spring Data
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 使用 Spring Security 和 Spring Data 保护和审计数据
- en: So far, we’ve looked at securing the APIs exposed by Spring Boot applications
    and handling concerns like authentication and authorization. What about data?
    Once you have Spring Security in place, you can also secure the business and data
    layers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 Spring Boot 应用程序暴露的 API 的安全性以及处理认证和授权等问题。那么数据呢？一旦你设置了 Spring Security，你还可以保护业务和数据层。
- en: Regarding the business logic, you can enable the method security feature to
    check for user authentication or authorization directly on business methods, leveraging
    annotations like @PreAuthorize. In the Polar Bookshop system, the business layer
    is not complex enough to require additional security policies, so I won’t describe
    that.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 关于业务逻辑，你可以启用方法安全特性，直接在业务方法上检查用户认证或授权，利用 @PreAuthorize 等注解。在 Polar Bookshop 系统中，业务层并不复杂，不需要额外的安全策略，所以这里不会描述这一点。
- en: Note To learn more about how to use method authentication and authorization,
    refer to chapter 8 of *Spring Security in Action* by Laurenţiu Spilcǎ (Manning,
    2020), where those topics are explained in great detail.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：想了解更多关于如何使用方法认证和授权的信息，请参阅 Laurențiu Spilcǎ 所著的 *Spring Security in Action*（Manning，2020）的第
    8 章，其中对这些主题进行了详细的解释。
- en: 'On the other hand, the data layer requires some extra work to address two main
    concerns:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，数据层需要一些额外的工作来解决两个主要问题：
- en: How can we tell which users created what data? Who changed it last?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何知道哪些用户创建了哪些数据？谁最后修改了它？
- en: How can we ensure that each user can only access their own book orders?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何确保每个用户只能访问他们自己的书籍订单？
- en: This section will address both concerns. First I’ll explain how to enable auditing
    for users’ actions on data in both Catalog Service and Order Service. Then I’ll
    walk you through the changes required by Order Service to keep the data private.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解决这两个问题。首先，我将解释如何在 Catalog 服务和 Order 服务中为用户对数据的行为启用审计。然后，我将指导你了解 Order 服务需要进行的更改以保持数据私有。
- en: 12.4.1 Auditing data with Spring Security and Spring Data JDBC
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1 使用 Spring Security 和 Spring Data JDBC 进行数据审计
- en: Let’s start by considering Catalog Service, where the data layer is implemented
    with Spring Data JDBC. In chapter 5, you learned how to enable JDBC data auditing,
    and you configured it to save both the creation date and last modified date for
    each data entity. Building on top of that, we can now extend the audit scope to
    include the usernames of the person who created the entity and the person who
    modified it last.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑 Catalog 服务开始，其中数据层使用 Spring Data JDBC 实现。在第 5 章中，你学习了如何启用 JDBC 数据审计，并将其配置为为每个数据实体保存创建日期和最后修改日期。在此基础上，我们现在可以扩展审计范围，包括创建实体的用户和最后修改实体的用户的用户名。
- en: First we need to tell Spring Data where to get the information about the currently
    authenticated user. In the previous chapter, you learned that Spring Security
    stores information about authenticated users in an Authentication object, which
    is stored in a SecurityContext object available through the SecurityContextHolder.
    We can use that object hierarchy to specify how to extract the principal for Spring
    Data.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要告诉 Spring Data 如何获取当前认证用户的信息。在上一章中，你了解到 Spring Security 将认证用户的信息存储在 Authentication
    对象中，该对象存储在通过 SecurityContextHolder 可用的 SecurityContext 对象中。我们可以使用这个对象层次结构来指定如何为
    Spring Data 提取主体。
- en: Defining an auditor to capture who created or updated a JDBC data entity
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 定义审计员以捕获谁创建了或更新了 JDBC 数据实体
- en: In the Catalog Service project (catalog-service), open the DataConfig class.
    That’s where we used the @EnableJdbcAuditing annotation to enable data auditing.
    Now, we’ll also define an AuditorAware bean that should return the principal—the
    currently authenticated user.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Catalog 服务项目（catalog-service）中，打开 DataConfig 类。那里我们使用了 @EnableJdbcAuditing
    注解来启用数据审计。现在，我们还将定义一个 AuditorAware bean，它应该返回主体——当前认证的用户。
- en: Listing 12.21 Configuring user auditing in Spring Data JDBC
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.21 在 Spring Data JDBC 中配置用户审计
- en: '[PRE29]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Enables entity auditing in Spring Data JDBC
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Spring Data JDBC 中启用实体审计
- en: ❷ Returns the currently authenticated user for auditing purposes
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回当前认证用户以进行审计目的
- en: ❸ Extracts the SecurityContext object for the currently authenticated user from
    SecurityContextHolder
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从 SecurityContextHolder 中提取当前认证用户的 SecurityContext 对象
- en: ❹ Extracts the Authentication object for the currently authenticated user from
    SecurityContext
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从 SecurityContext 中提取当前认证用户的 Authentication 对象
- en: ❺ Handles the case where a user is not authenticated, but is manipulating data.
    Since we protected all the endpoints, this case should never happen, but we’ll
    include it for completeness.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 处理用户未认证但操作数据的情况。由于我们保护了所有端点，这种情况不应该发生，但我们将其包括在内以确保完整性。
- en: ❻ Extracts the username for the currently authenticated user from the Authentication
    object
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从 Authentication 对象中提取当前认证用户的用户名
- en: Adding audit metadata for users who created or updated a JDBC data entity
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为创建或更新 JDBC 数据实体的用户添加审计元数据
- en: When an AuditorAware bean is defined and auditing is enabled, Spring Data will
    use it to extract the principal. In our case, it’s the username of the currently
    authenticated user, represented as a String. Then we can use @CreatedBy and @LastModifiedBy
    to annotate two new fields in the Book record. They will be populated by Spring
    Data automatically whenever a create or update operation is performed on the entity.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义了 AuditorAware bean 并启用了审计时，Spring Data 将使用它来提取主体。在我们的情况下，它是当前认证用户的用户名，表示为一个字符串。然后我们可以使用
    @CreatedBy 和 @LastModifiedBy 注解在 Book 记录中的两个新字段上。每当对实体执行创建或更新操作时，Spring Data 将自动填充这些字段。
- en: Listing 12.22 Fields to capture user audit metadata in a JDBC entity
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.22 在 JDBC 实体中捕获用户审计元数据的字段
- en: '[PRE30]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Who created the entity
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 谁创建了实体
- en: ❷ Who modified the entity the last time
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 谁是最后一次修改实体的用户
- en: After adding the new fields, we need to update a few classes using the Book
    all-args constructor, which now requires passing values for createdBy and lastModifiedBy.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新字段后，我们需要使用 Book 全参构造函数更新几个类，现在它需要传递 createdBy 和 lastModifiedBy 的值。
- en: The BookService class contains the logic for updating books. Open it and change
    the editBookDetails() method to ensure the audit metadata is correctly passed
    along when calling the data layer.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: BookService类包含更新图书的逻辑。打开它并将editBookDetails()方法更改为确保在调用数据层时正确传递审计元数据。
- en: Listing 12.23 Including the existing audit metadata when updating a book
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.23 更新图书时包含现有的审计元数据
- en: '[PRE31]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Who created the entity
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 谁创建了实体
- en: ❷ Who updated the entity last
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 谁最后更新了实体
- en: I’ll leave it to you to update the autotests in a similar way. You can also
    extend the tests in BookJsonTests to verify the serialization and deserialization
    of the new fields. As a reference, you can check Chapter12/12-end/catalog-service
    in the code repository accompanying this book. Make sure you update the tests
    that use the Book() constructor, or else the application build will fail.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留给你以类似的方式更新自动测试。你还可以扩展BookJsonTests中的测试，以验证新字段的序列化和反序列化。作为一个参考，你可以在伴随本书的代码仓库中的Chapter12/12-end/catalog-service检查。确保你更新了使用Book()构造函数的测试，否则应用程序构建将失败。
- en: Writing a Flyway migration to add the new audit metadata to the schema
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Flyway迁移以将新的审计元数据添加到模式中
- en: Since we changed the entity model, we need to update the database schema accordingly.
    Let’s assume that Catalog Service is already in production, so we need a Flyway
    migration to update the schema in the next release. In chapter 5, we introduced
    Flyway to add version control to our databases. Each change to a schema must be
    registered as a migration, ensuring robust schema evolution and reproducibility.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们更改了实体模型，我们需要相应地更新数据库模式。假设目录服务已经在生产中，因此我们需要一个Flyway迁移来更新下一个版本的方案。在第5章中，我们介绍了Flyway来为我们的数据库添加版本控制。对模式的任何更改都必须注册为迁移，以确保稳健的模式演变和可重复性。
- en: Any change to a database schema should also be backward compatible to support
    common deployment strategies for cloud native applications, like rolling upgrades,
    blue/green deployments, or canary releases (a subject we’ll cover in chapter 15).
    In this case, we need to add new columns to the book table. As long as we don’t
    make them mandatory, the change will be backward compatible. After we change the
    schema, any running instance of the previous release of Catalog Service will continue
    to work without errors, simply ignoring the new columns.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对数据库模式的更改都应该向后兼容，以支持云原生应用的常见部署策略，如滚动升级、蓝绿部署或金丝雀发布（我们将在第15章中讨论这个主题）。在这种情况下，我们需要向图书表添加新列。只要我们不使它们成为强制性的，更改将是向后兼容的。在更改模式后，任何运行的前一个版本的目录服务实例将继续无错误地工作，简单地忽略新列。
- en: In the src/main/resources/db/migration folder for the Catalog Service project,
    create a new V3__Add_user_audit.sql migration script to add two new columns to
    the book table. Ensure you type two underscores after the version number.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录服务项目的src/main/resources/db/migration文件夹中，创建一个新的V3__Add_user_audit.sql迁移脚本，向图书表添加两个新列。确保在版本号后输入两个下划线。
- en: Listing 12.24 Adding new audit metadata to the book table
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.24 向图书表添加新的审计元数据
- en: '[PRE32]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Add a column to hold the username of who created the row.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加一个列来存储创建行的用户名。
- en: ❷ Add a column to hold the username of who last updated the row.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加一个列来存储最后更新行的用户名。
- en: During the application’s startup, Flyway will automatically go through all the
    migration scripts and apply those not yet applied.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动期间，Flyway将自动遍历所有迁移脚本并应用尚未应用的脚本。
- en: 'The tradeoff of enforcing backward-compatible changes is that we now have to
    treat as optional two fields that we need to have always filled in, and that may
    possibly fail validation if they’re not. That is a common problem that can be
    solved over two subsequent releases of the application:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 强制向后兼容更改的权衡是，我们现在必须将两个我们需要始终填写且可能在没有它们的情况下失败验证的字段视为可选的。这是一个可以通过应用程序的两个后续版本解决的问题的常见问题：
- en: In the first release, you add the new columns as optional and implement a data
    migration to fill in the new columns for all the existing data. For Catalog Service,
    you could use a conventional value to represent that we don’t know who created
    or updated the entity, such as unknown or anonymous.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个版本中，你将新列作为可选添加，并实现数据迁移以填充所有现有数据的新列。对于目录服务，你可以使用传统值来表示我们不知道谁创建了或更新了实体，例如unknown或anonymous。
- en: In the second release, you can create a new migration to update the schema safely
    and make the new columns required.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个版本中，你可以创建一个新的迁移来安全地更新模式并使新列成为必需的。
- en: I’ll leave that up to you if you’d like to do that. If you’re interested in
    implementing data migrations, I recommend that you check out Flyway’s official
    documentation ([https://flywaydb.org](https://flywaydb.org)).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想这么做，那就由您决定。如果您对实现数据迁移感兴趣，我建议您查看Flyway的官方文档([https://flywaydb.org](https://flywaydb.org))。
- en: In the next section, you’ll see how to test user-related auditing in Spring
    Data JDBC.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到如何在Spring Data JDBC中测试与用户相关的审计。
- en: 12.4.2 Testing data auditing with Spring Data and @WithMockUser
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.2 使用Spring Data和@WithMockUser测试数据审计
- en: When we test security at the data layer, we’re not interested in which authentication
    strategy has been adopted. The only thing we need is to know whether the operation
    is performed in the context of an authenticated request.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在数据层测试安全性时，我们并不关心采用了哪种认证策略。我们唯一需要知道的是操作是否在认证请求的上下文中执行。
- en: The Spring Security Test project provides us with a handy @WithMockUser annotation
    we can use on test cases to make them run in an authenticated context. You can
    also add information about the mock user. Since we’re testing auditing, we want
    to define at least a username that can be used as the principal.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security Test项目为我们提供了一个方便的@WithMockUser注解，我们可以在测试用例中使用它，使它们在认证上下文中运行。您还可以添加有关模拟用户的信息。由于我们正在测试审计，我们至少需要定义一个可以用作principal的用户名。
- en: Let’s extend the BookRepositoryJdbcTests class with new test cases covering
    data auditing for users.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展BookRepositoryJdbcTests类，添加新的测试用例以覆盖用户的数据审计。
- en: Listing 12.25 Testing data auditing when users are authenticated or not
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.25 测试用户认证或未认证时的数据审计
- en: '[PRE33]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ This test case is executed in an unauthenticated context.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此测试用例是在未认证的上下文中执行的。
- en: ❷ No audit data when there is no authenticated user
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当没有经过身份验证的用户时没有审计数据
- en: ❸ This test case is executed in an authenticated context for the user “john.”
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此测试用例是在用户“john”的认证上下文中执行的。
- en: ❹ Audit data when there is an authenticated user
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当有经过身份验证的用户时审计数据
- en: 'Open a Terminal window, navigate to the Catalog Service root folder, and run
    the newly added tests as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到目录服务根目录，并按照以下方式运行新添加的测试：
- en: '[PRE34]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you experience any failures, it might be because you haven’t updated the
    test cases where the Book() constructor is used. We have added new fields to the
    domain model, so remember to update those test cases as well.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到任何失败，可能是因为您没有更新使用Book()构造函数的测试用例。我们已经向领域模型添加了新字段，所以请记得更新这些测试用例。
- en: 12.4.3 Protecting user data with Spring Security and Spring Data R2DBC
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.3 使用Spring Security和Spring Data R2DBC保护用户数据
- en: Similar to what we did in Catalog Service, this section will show you how to
    add data auditing for users in Order Service. Thanks to the abstractions provided
    by Spring Data and Spring Security, the implementation will not be much different,
    even though we’re using Spring Data R2DBC and reactive Spring.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在目录服务中所做的一样，本节将向您展示如何在订单服务中添加用户的数据审计。多亏了Spring Data和Spring Security提供的抽象，即使我们使用Spring
    Data R2DBC和响应式Spring，实现也不会有很大不同。
- en: Besides data auditing, Order Service has one additional critical requirement.
    Users should be able to access only their own orders. We need to ensure the privacy
    of all that data. This section will also walk you through the changes necessary
    to accomplish that result.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据审计外，订单服务还有一个额外的关键要求。用户应该只能访问他们自己的订单。我们需要确保所有这些数据的隐私。本节还将向您介绍实现该结果所需进行的更改。
- en: Defining an auditor to capture who created or updated an R2DBC data entity
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个审计器以捕获谁创建了或更新了R2DBC数据实体
- en: Even in this case, we need to tell Spring Data where to get the information
    about the currently authenticated user. Since it’s a reactive application, this
    time we’ll get the SecurityContext object for the principal from the ReactiveSecurityContextHolder.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这种情况下，我们也需要告诉Spring Data从哪里获取当前经过身份验证的用户的信息。由于这是一个响应式应用程序，这次我们将从ReactiveSecurityContextHolder获取principal的SecurityContext对象。
- en: In the Order Service project (order-service), open the DataConfig class and
    add a ReactiveAuditorAware bean to return the username of the currently authenticated
    user.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在订单服务项目（order-service）中，打开DataConfig类，并添加一个ReactiveAuditorAware bean以返回当前经过身份验证用户的用户名。
- en: Listing 12.26 Configuring user auditing in Spring Data R2DBC
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.26 配置Spring Data R2DBC中的用户审计
- en: '[PRE35]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Enables entity auditing in Spring Data R2DBC
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在Spring Data R2DBC中启用实体审计
- en: ❷ Returns the currently authenticated user for auditing purposes
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回当前经过身份验证的用户以供审计目的使用
- en: ❸ Extracts the SecurityContext object for the currently authenticated user from
    ReactiveSecurityContextHolder
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从 ReactiveSecurityContextHolder 中提取当前已认证用户的 SecurityContext 对象
- en: ❹ Extracts the Authentication object for the currently authenticated user from
    SecurityContext
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从 SecurityContext 中提取当前已认证用户的 Authentication 对象
- en: ❺ Handles the case where a user is not authenticated, but it is manipulating
    data. Since we protected all the endpoints, this case should never happen, but
    we’ll include it for completeness.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 处理用户未认证但正在操作数据的情况。由于我们保护了所有端点，这种情况不应该发生，但我们仍将其包括在内以示完整。
- en: ❻ Extracts the username of the currently authenticated user from the Authentication
    object
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从 Authentication 对象中提取当前已认证用户的用户名
- en: Adding audit metadata for users who created or updated an R2DBC data entity
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为创建或更新 R2DBC 数据实体的用户添加审计元数据
- en: When a ReactiveAuditorAware bean is defined and auditing is enabled, Spring
    Data will use it to extract the username of the currently authenticated user represented
    as a String. Even in this case, we can use @CreatedBy and @LastModifiedBy to annotate
    two new fields in the Order record. They will be populated by Spring Data automatically
    whenever a create or update operation is performed on the entity.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义了 ReactiveAuditorAware bean 并启用了审计功能时，Spring Data 将使用它来提取当前已认证用户的名字，表示为 String。即使在这种情况下，我们也可以使用
    @CreatedBy 和 @LastModifiedBy 注解 Order 记录中的两个新字段。每当对实体执行创建或更新操作时，Spring Data 将自动填充这些字段。
- en: Listing 12.27 Fields to capture user audit metadata in an R2DBC entity
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.27 在 R2DBC 实体中捕获用户审计元数据的字段
- en: '[PRE36]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Who created the entity
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 谁创建了实体
- en: ❷ Who modified the entity the last time
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 上次修改实体的用户是谁
- en: After adding the new fields, we need to update a few classes using the Order
    all-args constructor, which now requires you to pass values for createdBy and
    lastModifiedBy.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新字段后，我们需要使用 Order all-args 构造函数更新几个类，现在它要求你传递 createdBy 和 lastModifiedBy
    的值。
- en: The OrderService class contains the logic for updating dispatched orders. Open
    it and change the buildDispatchedOrder() method to ensure the audit metadata is
    correctly passed along when calling the data layer.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: OrderService 类包含更新已派发订单的逻辑。打开它，并将 buildDispatchedOrder() 方法更改为确保在调用数据层时正确传递审计元数据。
- en: Listing 12.28 Including the existing audit metadata when updating an order
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.28 更新订单时包含现有的审计元数据
- en: '[PRE37]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Who created the entity
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 谁创建了实体
- en: ❷ Who last updated the entity
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 上次更新实体的用户是谁
- en: I’ll leave it to you to update the autotests in a similar way. You can also
    extend the tests in OrderJsonTests to verify the serialization of the new fields.
    As a reference, you can check Chapter12/12-end/order-service in the code repository
    accompanying this book. Ensure that you update the tests using the Order() constructor,
    or the application build will fail.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留给你以类似的方式更新自动测试。你还可以扩展 OrderJsonTests 中的测试以验证新字段的序列化。作为参考，你可以检查随本书附带的代码库中的
    Chapter12/12-end/order-service。确保使用 Order() 构造函数或更新测试，否则应用程序构建将失败。
- en: Writing a Flyway migration to add the new audit metadata to the schema
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Flyway 迁移以向模式添加新的审计元数据
- en: Similar to what we did for Catalog Service, we need to write a migration to
    update the database schema with the two new fields hosting the usernames of who
    created an entity and who modified it last.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对 Catalog Service 所做的工作类似，我们需要编写一个迁移来更新数据库模式，添加两个新字段，用于存储创建实体和最后修改实体的用户名。
- en: In the src/main/resources/db/migration folder for the Order Service project,
    create a new V2__Add_user_audit.sql migration script to add two new columns to
    the orders table. Ensure you type two underscores after the version number.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Order Service 项目的 src/main/resources/db/migration 文件夹中，创建一个新的 V2__Add_user_audit.sql
    迁移脚本，向订单表添加两个新列。确保在版本号后输入两个下划线。
- en: Listing 12.29 Adding new audit metadata to the orders table
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.29 向订单表添加新的审计元数据
- en: '[PRE38]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Add a column for the username of who created the row.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为创建行的用户名添加一个列。
- en: ❷ Add a column for the username of who last updated the row.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为最后更新行的用户名添加一个列。
- en: Ensuring user data privacy
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 确保用户数据隐私
- en: 'There’s one last requirement we haven’t covered yet: ensuring that order data
    is only accessed by the users who created the orders. No user should be able to
    see the orders from another person.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个尚未涵盖的最后要求：确保订单数据只能由创建订单的用户访问。任何用户都不应该能够看到其他人的订单。
- en: 'There are a few different solutions for implementing this requirement in Spring.
    We’ll follow these steps:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 中实现此要求有几种不同的解决方案。我们将遵循以下步骤：
- en: Add a custom query to OrderRepository to filter orders based on the user who
    created them.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 OrderRepository 添加一个自定义查询，根据创建订单的用户过滤订单。
- en: Update OrderService to use the new query instead of the default findAll().
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 OrderService 以使用新的查询而不是默认的 findAll()。
- en: Update OrderController to extract the username of the currently authenticated
    user from the security context and pass it to OrderService when asking for orders.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 OrderController 以从安全上下文中提取当前认证用户的用户名，并在请求订单时将其传递给 OrderService。
- en: Warning We’ll rely on a specific solution that ensures each user can only access
    their own orders via the /orders endpoint. However, this won’t prevent developers
    from using the other methods exposed by OrderRepository in the future and leaking
    private data. If you’d like to know how to improve this solution, refer to chapter
    17 of *Spring Security in Action* by Laurențiu Spilcă (Manning, 2020).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 我们将依赖于一个特定的解决方案，确保每个用户只能通过 /orders 端点访问他们自己的订单。然而，这并不能阻止开发者在未来使用 OrderRepository
    提供的其他方法并泄露私人数据。如果你想了解如何改进这个解决方案，请参阅 Laurențiu Spilcă 所著的 *Spring Security in Action*
    一书的第 17 章（Manning，2020年）。
- en: Let’s start with OrderRepository. Using the conventions you learned in chapter
    5, define a method to find all orders created by the specified user. Spring Data
    will generate an implementation for it at runtime.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 OrderRepository 开始。使用你在第 5 章中学到的约定，定义一个方法来查找由指定用户创建的所有订单。Spring Data 将在运行时为它生成实现。
- en: Listing 12.30 Defining a method returning orders created by a user
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.30 定义一个返回由用户创建的订单的方法
- en: '[PRE39]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Custom method to query only the orders created by the given user
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查询仅由给定用户创建的订单的自定义方法
- en: Next we need to update the getAllOrders() method in OrderService to accept a
    username as input and use the new query method provided by OrderRepository.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新 OrderService 中的 getAllOrders() 方法，使其接受一个用户名作为输入并使用 OrderRepository
    提供的新查询方法。
- en: Listing 12.31 Returning orders only for the specified user
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.31 仅返回指定用户的订单
- en: '[PRE40]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ When requesting all orders, the response includes only those belonging to
    the given user.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当请求所有订单时，响应中只包括属于给定用户的订单。
- en: Finally, let’s update the getAllOrders() method in OrderController. As you learned
    in the previous chapter, you can autowire an object representing the currently
    authenticated user through the @AuthenticationPrincipal annotation. In Edge Service,
    the object was of type OidcUser because it’s based on OpenID Connect authentication.
    Since Order Service is configured with JWT authentication, the principal will
    be of type Jwt. We can use the JWT (an Access Token) to read the sub claim containing
    the username for which the Access Token was generated (the subject).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新 OrderController 中的 getAllOrders() 方法。正如你在上一章所学，你可以通过 @AuthenticationPrincipal
    注解自动装配代表当前认证用户的对象。在 Edge Service 中，该对象是 OidcUser 类型，因为它基于 OpenID Connect 认证。由于
    Order Service 配置了 JWT 认证，主体将是 Jwt 类型。我们可以使用 JWT（访问令牌）来读取包含生成访问令牌的用户名（主题）的 sub
    断言。
- en: Listing 12.32 Getting the username and returning only orders created by them
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.32 获取用户名并仅返回他们创建的订单
- en: '[PRE41]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Autowires the JWT representing the currently authenticated user
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 自动装配代表当前认证用户的 JWT
- en: ❷ Extracts the subject of the JWT and uses it as the user identifier
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提取 JWT 的主题并将其用作用户标识
- en: That’s it for Order Service. In the next section, you’ll write some autotests
    to verify the data auditing and protection requirements.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Order Service 的更新就到这里。在下一节中，你将编写一些自动测试来验证数据审计和保护要求。
- en: 12.4.4 Testing data auditing and protection with @WithMockUser and Spring Data
    R2DBC
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.4 使用 @WithMockUser 和 Spring Data R2DBC 测试数据审计和保护
- en: In the previous section we configured data auditing for users and enforced a
    policy to return only the orders for the currently authenticated user. This section
    will show you how to test the data auditing as a slice test. To verify the data
    protection requirement, you can refer to the repository accompanying the book
    and check how it’s been covered by the integration tests in the OrderServiceApplicationTests
    class (Chapter12/12-end/order-service/src/test/java).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们为用户配置了数据审计并强制执行了一个策略，只返回当前认证用户的订单。本节将向您展示如何作为切片测试来测试数据审计。为了验证数据保护要求，您可以参考书中附带的存储库，并检查它在
    OrderServiceApplicationTests 类（第 12 章/12-end/order-service/src/test/java）中的集成测试中是如何被覆盖的。
- en: Data auditing is applied at the repository level. We can extend the OrderRepositoryR2dbcTests
    class with extra test cases covering the scenario where the user is authenticated
    and when it is not.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 数据审计在存储库级别应用。我们可以通过添加额外的测试用例来扩展 OrderRepositoryR2dbcTests 类，覆盖用户认证和不认证的场景。
- en: Similar to what we did in Catalog Service, we can use the @WithMockUser annotation
    from Spring Security to execute a test method in an authenticated context, relying
    on a mock user representation.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在目录服务中做的一样，我们可以使用 Spring Security 的 @WithMockUser 注解在一个认证的上下文中执行测试方法，依赖于一个模拟用户表示。
- en: Listing 12.33 Testing data auditing when users are authenticated or not
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.33 测试用户认证与否时的数据审计
- en: '[PRE42]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ When the user is not authenticated, no audit metadata is saved.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当用户未认证时，不保存任何审计元数据。
- en: ❷ When the user is authenticated, the information about who created or updated
    the entity is correctly included in the data.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当用户认证时，关于谁创建或更新了实体的信息被正确地包含在数据中。
- en: 'Open a Terminal window, navigate to the Catalog Service root folder, and run
    the newly added tests as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到目录服务根目录，并按照以下方式运行新添加的测试：
- en: '[PRE43]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you experience any failures, it might be because you haven’t updated the
    test cases where the Order() constructor is used. We have added new fields to
    the domain model, so remember to update those test cases as well.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到任何失败，可能是因为你没有更新使用 Order() 构造函数的测试用例。我们已经添加了新的字段到领域模型中，所以记得也要更新这些测试用例。
- en: That concludes our discussion of authentication, authorization, and auditing
    for both imperative and reactive cloud native applications using Spring Boot,
    Spring Security, Spring Data, and Keycloak.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于使用 Spring Boot、Spring Security、Spring Data 和 Keycloak 对命令式和响应式云原生应用程序进行认证、授权和审计的讨论。
- en: Polar Labs
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Labs
- en: Feel free to apply what you have learned in the previous chapters and update
    Catalog Service and Order Service for deployment.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 随意应用你在前几章中学到的知识，并更新目录服务和订单服务以进行部署。
- en: Update the Docker Compose definitions for both applications to configure the
    Keycloak URL. You can use the container name (polar-keycloak:8080), which gets
    resolved by the built-in Docker DNS.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新两个应用程序的 Docker Compose 定义以配置 Keycloak URL。你可以使用容器名称（polar-keycloak:8080），它由内置的
    Docker DNS 解析。
- en: Update the Kubernetes manifests for both applications to configure the Keycloak
    URL. You can use the Keycloak Service name (polar-keycloak) as the URL, since
    all interactions happen within the cluster.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新两个应用程序的 Kubernetes 清单以配置 Keycloak URL。你可以使用 Keycloak 服务名称（polar-keycloak）作为
    URL，因为所有交互都在集群内部进行。
- en: You can refer to the Chapter12/12-end folder in the code repository accompanying
    the book to check the final results ([https://github.com/ThomasVitale/cloud-native
    -spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
    You can deploy the backing services from the manifests available in the Chapter12/12-end/polar-deployment/kubernetes/platform/development
    folder with kubectl apply -f services or the entire cluster with ./create-cluster.sh.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考代码仓库中与本书配套的 Chapter12/12-end 文件夹以检查最终结果（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。你可以使用
    kubectl apply -f services 从 Chapter12/12-end/polar-deployment/kubernetes/platform/development
    文件夹中的清单部署支持服务，或者使用 ./create-cluster.sh 部署整个集群。
- en: Summary
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In an OIDC/OAuth2 setup, the Client (Edge Service) is granted access to a Resource
    Server (Catalog Service and Order Service) on behalf of the user through an Access
    Token.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OIDC/OAuth2 设置中，客户端（边缘服务）代表用户通过访问令牌获得对资源服务器（目录服务和订单服务）的访问权限。
- en: Spring Cloud Gateway provides a TokenRelay filter to add the Access Token to
    any request routed downstream automatically.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway 提供了一个 TokenRelay 过滤器，可以自动将访问令牌添加到任何路由到下游的请求中。
- en: Following the JWT format, ID Tokens and Access Tokens can propagate relevant
    information as claims about the authenticated user. For example, you can add a
    roles claim and configure Spring Security with authorization policies depending
    on the user role.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循 JWT 格式，ID 令牌和访问令牌可以作为关于认证用户的声明传播相关信息。例如，你可以添加一个角色声明，并根据用户角色配置 Spring Security
    的授权策略。
- en: Spring Boot applications can be configured as OAuth2 Resource Servers using
    Spring Security.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 应用程序可以使用 Spring Security 配置为 OAuth2 资源服务器。
- en: In an OAuth2 Resource Server, the strategy for authenticating users is entirely
    based on a valid Access Token provided in the Authorization header of each request.
    We call it JWT authentication.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OAuth2 资源服务器中，用户认证的策略完全基于每个请求的授权头中提供的有效访问令牌。我们称之为 JWT 认证。
- en: In an OAuth2 Resource Server, security policies are still enforced through a
    SecurityFilterChain (imperative) or SecurityWebFilterChain (reactive) bean.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OAuth2 资源服务器中，安全策略仍然通过 SecurityFilterChain（命令式）或 SecurityWebFilterChain（响应式）bean
    来强制执行。
- en: Spring Security represents permissions, roles, and scopes as GrantedAuthority
    objects.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security 将权限、角色和作用域表示为 GrantedAuthority 对象。
- en: You can provide a custom JwtAuthenticationConverter bean to define how to extract
    granted authorities from a JWT, for example, using the roles claim.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以提供一个自定义 JwtAuthenticationConverter bean 来定义如何从 JWT 中提取授权权限，例如，使用角色声明。
- en: Granted authorities can be used to adopt an RBAC strategy and protect endpoints,
    depending on the user role.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权权限可用于采用 RBAC 策略并保护端点，具体取决于用户角色。
- en: The Spring Data libraries support auditing to track who created an entity and
    who updated it last. You can enable this feature in both Spring Data JDBC and
    Spring Data R2DBC by configuring an AuditorAware (or ReactiveAuditorAware) bean
    to return the username of the currently authenticated user.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data 库支持审计功能，以追踪谁创建了实体以及最后更新它的人。您可以通过配置一个 AuditorAware（或 ReactiveAuditorAware）bean
    来返回当前认证用户的用户名，在 Spring Data JDBC 和 Spring Data R2DBC 中启用此功能。
- en: When data auditing is enabled, you can use the @CreatedBy and @LastModifiedBy
    annotations to automatically inject the right values when a create or update operation
    occurs.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启用数据审计时，您可以使用 @CreatedBy 和 @LastModifiedBy 注解，在创建或更新操作发生时自动注入正确的值。
- en: Testing security is challenging, but Spring Security provides convenient utilities
    to make that easier, including expressions that mutate HTTP requests to include
    a JWT Access Token (.with(jwt()) or .mutateWith(mockJwt())) or to run a test case
    in a specific security context for a given user (@WithMockUser).
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试安全性具有挑战性，但 Spring Security 提供了方便的工具来简化这一过程，包括表达式，可以修改 HTTP 请求以包含 JWT 访问令牌（.with(jwt())
    或 .mutateWith(mockJwt())）或在一个特定安全上下文中为给定用户运行测试用例（@WithMockUser）。
- en: Testcontainers can help write full integration tests by using an actual Keycloak
    container to verify the interactions with Spring Security.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Testcontainers 可以通过使用实际的 Keycloak 容器来帮助编写完整的集成测试，以验证与 Spring Security 的交互。
