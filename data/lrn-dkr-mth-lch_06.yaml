- en: 6 Using Docker volumes for persistent storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 使用 Docker 卷进行持久化存储
- en: Containers are a perfect runtime for stateless applications. You can meet increased
    demand by running multiple containers on your cluster, knowing that every container
    will handle requests in the same way. You can release updates with an automated
    rolling upgrade, which keeps your app online the whole time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是状态无状态应用的理想运行时环境。您可以通过在您的集群上运行多个容器来满足增加的需求，知道每个容器将以相同的方式处理请求。您可以通过自动滚动升级来发布更新，这样您的应用程序在整个过程中都保持在线状态。
- en: But not all parts of your app will be stateless. There will be components that
    use disks to improve performance or for permanent data storage. And you can run
    those components in Docker containers too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但您的应用程序的并非所有部分都是无状态的。将会有一些组件使用磁盘来提高性能或进行永久数据存储。您也可以在 Docker 容器中运行这些组件。
- en: Storage does add complications, so you need to understand how to Dockerize stateful
    apps. This chapter takes you through Docker volumes and mounts, and shows you
    how the container filesystem works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 存储确实增加了复杂性，因此您需要了解如何 Docker 化有状态应用程序。本章将带您了解 Docker 卷和挂载，并展示容器文件系统是如何工作的。
- en: 6.1 Why data in containers is not permanent
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 为什么容器中的数据不是永久的
- en: 'A Docker container has a filesystem with a single disk drive, and the contents
    of that drive are populated with the files from the image. You’ve seen that already:
    when you use the `COPY` instruction in a Dockerfile, the files and directories
    you copy into the image are there when you run a container from the image. And
    you know Docker images are stored as multiple layers, so the container’s disk
    is actually a virtual filesystem that Docker builds up by merging all the image
    layers together.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器有一个包含单个磁盘驱动器的文件系统，该驱动器的内容由镜像中的文件组成。您已经看到了这一点：当您在 Dockerfile 中使用 `COPY`
    指令时，您复制到镜像中的文件和目录在您从镜像运行容器时是存在的。而且您知道 Docker 镜像是存储为多个层，因此容器的磁盘实际上是一个 Docker 通过合并所有镜像层构建的虚拟文件系统。
- en: Each container has its own filesystem, independent of other containers. You
    can run multiple containers from the same Docker image, and they will all start
    with the same disk contents. The application can alter files in one container,
    and that won’t affect the files in other containers--or in the image. That’s straightforward
    to see by running a couple of containers that write data, and then looking at
    their output.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都有自己的文件系统，与其他容器独立。您可以从相同的 Docker 镜像运行多个容器，它们都将使用相同的磁盘内容启动。应用程序可以更改一个容器中的文件，这不会影响其他容器中的文件--或镜像中的文件。通过运行几个写入数据的容器并查看它们的输出，可以直观地看到这一点。
- en: 'Try it now Open a terminal session and run two containers from the same image.
    The application in the image writes a random number to a file in the container:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 打开一个终端会话并运行两个来自同一镜像的容器。镜像中的应用程序将随机数字写入容器中的文件：
- en: '` docker container run --name rn1 diamol/ch06-random-number` ` docker container
    run --name rn2 diamol/ch06-random-number`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker container run --name rn1 diamol/ch06-random-number` ` docker container
    run --name rn2 diamol/ch06-random-number`'
- en: That container runs a script when it starts, and the script writes some random
    data to a text file and then ends, so those containers are in the exited state.
    The two containers started from the same image, but they will have different file
    contents. You learned in chapter 2 that Docker doesn’t delete the container’s
    filesystem when it exits--it’s retained so you can still access files and folders.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器在启动时运行一个脚本，该脚本将一些随机数据写入文本文件然后结束，因此这些容器处于已退出状态。这两个容器是从相同的镜像启动的，但它们将具有不同的文件内容。您在第二章中学到，Docker
    在退出时不会删除容器的文件系统--它被保留下来，这样您仍然可以访问文件和文件夹。
- en: The Docker CLI has the `docker` `container` `cp` command to copy files between
    containers and the local machine. You specify the name of the container and the
    file path, and you can use that to copy the generated random number files from
    these containers onto your host computer, so you can read the contents.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CLI 有 `docker` `container` `cp` 命令，用于在容器和本地机器之间复制文件。您指定容器的名称和文件路径，可以使用它将生成的随机数字文件从这些容器复制到您的宿主机上，以便您读取其内容。
- en: 'Try it now Use `docker` `container` `cp` to copy the random number file from
    each of the containers, and then check the contents:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 使用 `docker` `container` `cp` 将每个容器中的随机数字文件复制出来，然后检查其内容：
- en: '` docker container cp rn1:/random/number.txt number1.txt`  ` docker container
    cp rn2:/random/number.txt number2.txt`  ` cat number1.txt`  ` cat number2.txt`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker container cp rn1:/random/number.txt number1.txt`  ` docker container
    cp rn2:/random/number.txt number2.txt`  ` cat number1.txt`  ` cat number2.txt`'
- en: Your output will be similar to mine in figure 6.1\. Each container has written
    a file at the same path, `/random/number.txt` , but when the files are copied
    onto the local machine, you can see that the contents are different. This is a
    simple way of showing that every container has an independent filesystem. In this
    case it’s a single file that’s different, but these could be database containers
    that start with the same SQL engine running, but store completely different data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出将类似于图6.1中的我的输出。每个容器都在相同的路径上写了一个文件，即`/random/number.txt`，但当文件被复制到本地机器上时，您可以看到内容是不同的。这是一种简单的方法来展示每个容器都有一个独立的文件系统。在这种情况下，它是一个不同的单个文件，但这也可能是以相同的SQL引擎启动但存储完全不同数据的数据库容器。
- en: '![](../Images/6-1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图6-1](../Images/6-1.jpg)'
- en: Figure 6.1 Running containers that write data, and checking the data
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 运行写入数据的容器并检查数据
- en: 'The filesystem inside a container appears to be a single disk: `/dev/sda1`
    on Linux containers and `C:\` on Windows containers. But that disk is a virtual
    filesystem that Docker builds from several sources and presents to the container
    as a single unit. The basic sources for that filesystem are the image layers,
    which can be shared between containers, and the container’s writeable layer, which
    is unique to each container.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内的文件系统看起来像是一个单独的磁盘：Linux容器上的`/dev/sda1`和Windows容器上的`C:\`。但这个磁盘是一个虚拟文件系统，Docker从几个来源构建它，并将其作为一个单一单元呈现给容器。该文件系统的基本来源是图像层，这些层可以在容器之间共享，以及容器的可写层，它是每个容器独有的。
- en: 'Figure 6.2 shows how that looks for the random number image and the two containers.
    You should take away two important things from figure 6.2: image layers are shared
    so they have to be read-only, and there is one writeable layer per container,
    which has the same life cycle as the container. Image layers have their own life
    cycle--any images you pull will stay in your local cache until you remove them.
    But the container writeable layer is created by Docker when the container is started,
    and it’s deleted by Docker when the container is removed. (Stopping a container
    doesn’t automatically remove it, so a stopped container’s filesystem does still
    exist.)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2展示了随机数字图像和两个容器的外观。您应该从图6.2中提取两个重要信息：图像层是共享的，因此它们必须是只读的，每个容器都有一个可写层，其生命周期与容器相同。图像层有自己的生命周期——您拉取的任何图像都将保留在您的本地缓存中，直到您将其删除。但是，容器可写层是在容器启动时由Docker创建的，当容器被移除时由Docker删除。（停止容器不会自动移除它，因此停止容器的文件系统仍然存在。）
- en: '![](../Images/6-2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图6-2](../Images/6-2.jpg)'
- en: Figure 6.2 The container filesystem is built from image layers and a writeable
    layer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 容器文件系统是由图像层和可写层构建的。
- en: Of course, the writeable layer isn’t just for creating new files. A container
    can edit existing files from the image layers. But image layers are read-only,
    so Docker does some special magic to make that happen. It uses a copy-on-write
    process to allow edits to files that come from read-only layers. When the container
    tries to edit a file in an image layer, Docker actually makes a copy of that file
    into the writable layer, and the edits happen there. It’s all seamless for the
    container and the application, but it’s the cornerstone of Docker’s super-efficient
    use of storage.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可写层不仅仅用于创建新文件。容器可以编辑来自图像层的现有文件。但图像层是只读的，所以Docker进行了一些特殊的操作来实现这一点。它使用写时复制的过程来允许编辑来自只读层的文件。当容器尝试编辑图像层中的文件时，Docker实际上会将该文件复制到可写层，并在那里进行编辑。对于容器和应用程序来说，这一切都是无缝的，但这是Docker高效使用存储的基石。
- en: Let’s work through that with one more simple example, before we move on to running
    some more useful stateful containers. In this exercise you’ll run a container
    that prints out the contents of a file from an image layer. Then you’ll update
    the file contents and run the container again to see what’s changed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续运行一些更有用的有状态容器之前，让我们通过一个更简单的例子来分析这个问题。在这个练习中，您将运行一个容器，该容器从图像层打印出文件内容。然后您将更新文件内容并再次运行容器以查看发生了什么变化。
- en: 'Try it now Run these commands to start a container that prints out its file
    contents, then change the file, and start the container again to print out the
    new file contents:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行以下命令以启动一个打印其文件内容的容器，然后更改文件，并再次启动容器以打印新文件内容：
- en: '` docker container run --name f1 diamol/ch06-file-display`  ` echo "http://eltonstoneman.com"
    > url.txt`  ` docker container cp url.txt f1:/input.txt`  ` docker container start
    --attach f1`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker container run --name f1 diamol/ch06-file-display`  ` echo "http://eltonstoneman.com"
    > url.txt`  ` docker container cp url.txt f1:/input.txt`  ` docker container start
    --attach f1`'
- en: This time you’re using Docker to copy a file from your host computer into the
    container, and the target path is the file that the container displays. When you
    start the container again, the same script runs, but now it prints out different
    contents--you can see my output in figure 6.3.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你使用Docker将文件从你的主机计算机复制到容器中，目标路径是容器显示的文件。当你再次启动容器时，相同的脚本运行，但现在它打印出不同的内容——你可以在图6.3中看到我的输出。
- en: '![](../Images/6-3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3](../Images/6-3.jpg)'
- en: Figure 6.3 Modifying a container’s state and running it again
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 修改容器的状态并再次运行
- en: Modifying the file in the container affects how that container runs, but it
    doesn’t affect the image or any other containers from that image. The changed
    file only lives in the writeable layer for that one container--a new container
    will use the original contents from the image, and when container `f1` is removed,
    the updated file is gone.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 修改容器中的文件会影响该容器的运行方式，但不会影响镜像或该镜像的任何其他容器。更改的文件仅存在于该容器的可写层中——新的容器将使用镜像中的原始内容，当容器`f1`被移除时，更新的文件将消失。
- en: 'Try it now Start a new container to check that the file in the image is unchanged.
    Then remove the original container and confirm that the data is gone:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 启动一个新的容器来检查镜像中的文件是否未更改。然后移除原始容器并确认数据已消失：
- en: '` docker container run --name f2 diamol/ch06-file-display` ` docker container
    rm -f f1` ` docker container cp f1:/input.txt .`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker container run --name f2 diamol/ch06-file-display` ` docker container
    rm -f f1` ` docker container cp f1:/input.txt .`'
- en: You’ll see the same output as mine in figure 6.4\. The new container uses the
    original file from the image, and when you remove the original container, its
    filesystem is removed and the changed file is gone forever.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到与我图6.4中相同的输出。新的容器使用镜像中的原始文件，当你移除原始容器时，其文件系统被移除，更改的文件将永远消失。
- en: '![](../Images/6-4.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4](../Images/6-4.jpg)'
- en: Figure 6.4 Modifying files in a container does not affect the image, and the
    container’s data is transient.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 在容器中修改文件不会影响镜像，容器中的数据是瞬时的。
- en: The container filesystem has the same life cycle as the container, so when the
    container is removed, the writeable layer is removed, and any changed data in
    the container is lost. Removing containers is something you will do a lot. In
    production, you upgrade your app by building a new image, removing the old containers,
    and replacing them with new ones from the updated image. Any data that was written
    in your original app containers is lost, and the replacement containers start
    with the static data from the image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 容器文件系统与容器的生命周期相同，因此当容器被移除时，可写层也会被移除，容器中任何更改的数据都会丢失。移除容器是你将要做很多事情之一。在生产中，你通过构建新的镜像、移除旧容器并用更新镜像的新容器替换它们来升级应用程序。你在原始应用程序容器中写入的任何数据都会丢失，替换容器将以镜像中的静态数据开始。
- en: There are some scenarios where that’s fine, because your application only writes
    transient data--maybe to keep a local cache of data that is expensive to calculate
    or retrieve--and it’s fine for replacement containers to start with an empty cache.
    In other cases, it would be a disaster. You can run a database in a container,
    but you wouldn’t expect to lose all your data when you roll out an updated database
    version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这是可以的，因为你的应用程序只写入瞬态数据——可能是为了保持一个本地缓存，该缓存的数据计算或检索成本高昂——并且对于替换容器以空缓存开始是可行的。在其他情况下，那将是一场灾难。你可以在容器中运行数据库，但你不会期望在推出更新的数据库版本时丢失所有数据。
- en: Docker has you covered for those scenarios too. The virtual filesystem for the
    container is always built from image layers and the writeable layer, but there
    can be additional sources as well. Those are Docker volumes and mounts. They have
    a separate life cycle from containers, so they can be used to store data that
    persists between container replacements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Docker也为你覆盖了这些场景。容器的虚拟文件系统始终由镜像层和可写层构建，但也可能有其他来源。这些是Docker卷和挂载。它们有独立的生命周期，因此可以用来存储在容器替换之间持久化的数据。
- en: 6.2 Running containers with Docker volumes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 使用Docker卷运行容器
- en: A Docker volume is a unit of storage--you can think of it as a USB stick for
    containers. Volumes exist independently of containers and have their own life
    cycles, but they can be attached to containers. Volumes are how you manage storage
    for stateful applications when the data needs to be persistent. You create a volume
    and attach it to your application container; it appears as a directory in the
    container’s filesystem. The container writes data to the directory, which is actually
    stored in the volume. When you update your app with a new version, you attach
    the same volume to the new container, and all the original data is available.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 卷是存储单元--你可以将其视为容器的 USB 棒。卷独立于容器存在，有自己的生命周期，但可以附加到容器。当数据需要持久化时，卷是管理状态化应用存储的方式。你创建一个卷并将其附加到你的应用程序容器；它作为容器文件系统中的一个目录出现。容器将数据写入目录，实际上数据存储在卷中。当你用新版本更新你的应用时，你将相同的卷附加到新容器，所有原始数据都可用。
- en: 'There are two ways to use volumes with containers: you can manually create
    volumes and attach them to a container, or you can use a `VOLUME` instruction
    in the Dockerfile. That builds an image that will create a volume when you start
    a container. The syntax is simply `VOLUME` `<target-directory>` . Listing 6.1
    shows part of the multi-stage Dockerfile for the image `diamol/ch06-todo-list`
    , which is a stateful app that uses a volume.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器与卷有两种方式：你可以手动创建卷并将其附加到容器，或者你可以在 Dockerfile 中使用 `VOLUME` 指令。这会构建一个在启动容器时创建卷的镜像。语法很简单：`VOLUME`
    `<target-directory>` 。列表 6.1 展示了镜像 `diamol/ch06-todo-list` 的多阶段 Dockerfile 的部分，这是一个使用卷的状态化应用。
- en: Listing 6.1 Part of a multi-stage Dockerfile using a volume
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 使用卷的 Dockerfile 的部分
- en: '` FROM diamol/dotnet-aspnet` ` WORKDIR /app`  ` ENTRYPOINT ["dotnet", "ToDoList.dll"]`
    ` VOLUME /data` ` COPY --from=builder /out/ .`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM diamol/dotnet-aspnet` ` WORKDIR /app`  ` ENTRYPOINT ["dotnet", "ToDoList.dll"]`
    ` VOLUME /data` ` COPY --from=builder /out/ .`'
- en: When you run a container from this image, Docker will automatically create a
    volume and attach it to the container. The container will have a directory at
    `/data` (or `C:\data` on Windows containers), which it can read from and write
    to as normal. But the data is actually being stored in a volume, which will live
    on after the container is removed. You can see that if you run a container from
    the image and then check the volumes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从这个镜像运行容器时，Docker 将自动创建一个卷并将其附加到容器。容器将有一个位于 `/data`（或 Windows 容器上的 `C:\data`）的目录，它可以像通常一样从中读取和写入。但实际上数据是存储在卷中的，卷将在容器删除后继续存在。如果你从这个镜像运行一个容器并检查卷，你可以看到这一点。
- en: 'Try it now Run a container for the to-do list app, and have a look at the volume
    Docker created:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 Run 一个待办事项应用的容器，并查看 Docker 创建的卷：
- en: '` docker container run --name todo1 -d -p 8010:80 diamol/ch06-todo-list` ` docker
    container inspect --format ''{{.Mounts}}'' todo1` ` docker volume ls`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker container run --name todo1 -d -p 8010:80 diamol/ch06-todo-list` ` docker
    container inspect --format ''{{.Mounts}}'' todo1` ` docker volume ls`'
- en: You’ll see output like mine in figure 6.5\. Docker creates a volume for this
    container and attaches it when the container runs. I’ve filtered the volume list
    to show just the volume for my container.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在图 6.5 中看到类似我的输出。Docker 为此容器创建了一个卷，并在容器运行时将其附加。我已经过滤了卷列表，只显示我的容器的卷。
- en: '![](../Images/6-5.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-5.jpg)'
- en: Figure 6.5 Running a container with a volume declared in the Dockerfile
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 在 Dockerfile 中声明卷的容器运行
- en: 'Docker volumes are completely transparent to the app running in the container.
    Browse to http: */ /* localhost:8010 and you’ll see the to-do app. The app stores
    data in a file at the `/data` directory, so when you add items through the web
    page, they are being stored in the Docker volume. Figure 6.6 shows the app in
    action--it’s a special to-do list that works very well for people with workloads
    like mine; you can add items but you can’t ever remove them.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker 卷对容器中运行的应用程序是完全透明的。浏览到 http: */ /* localhost:8010，你会看到待办事项应用。该应用将数据存储在
    `/data` 目录下的文件中，因此当你通过网页添加项目时，它们实际上被存储在 Docker 卷中。图 6.6 展示了应用的实际运行情况--这是一个非常适合像我这样工作负载的人的特殊待办事项列表；你可以添加项目，但你永远无法删除它们。'
- en: '![](../Images/6-6.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-6.jpg)'
- en: Figure 6.6 The never-ending to-do list, running in a container using a Docker
    volume
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 永无止境的待办事项列表，在容器中使用 Docker 卷运行
- en: Volumes declared in Docker images are created as a separate volume for each
    container, but you can also share volumes between containers. If you start a new
    container running the to-do app, it will have its own volume, and the to-do list
    will start off being empty. But you can run a container with the `volumes-from`
    flag, which attaches another container’s volumes. In this example you could have
    two to-do app containers sharing the same data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 镜像中声明的卷为每个容器创建为单独的卷，但你也可以在容器之间共享卷。如果你启动一个新的运行待办事项应用程序的容器，它将有自己的卷，待办事项列表将从空开始。但是，你可以使用带有
    `volumes-from` 标志的容器来附加另一个容器的卷。在这个例子中，你可以有两个共享相同数据的待办事项应用程序容器。
- en: 'Try it now Run a second to-do list container and check the contents of the
    data directory. Then compare that to another new container that shares the volumes
    from the first container (the `exec` commands are slightly different for Windows
    and Linux):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：运行第二个待办事项列表容器并检查数据目录的内容。然后将其与另一个新容器进行比较，该容器共享第一个容器的卷（Windows 和 Linux 上的
    `exec` 命令略有不同）：
- en: '` # this new container will have its own volume` ` docker container run --name
    todo2 -d diamol/ch06-todo-list`  ` # on Linux:` ` docker container exec todo2
    ls /data`  ` # on Windows:` ` docker container exec todo2 cmd /C "dir C:\data"`
     ` # this container will share the volume from todo1` ` docker container run -d
    --name t3 --volumes-from todo1 diamol/ch06-todo-list`  ` # on Linux:` ` docker
    container exec t3 ls /data`  ` # on Windows:` ` docker container exec t3 cmd /C
    "dir C:\data"`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 这个新容器将有自己的卷` ` docker container run --name todo2 -d diamol/ch06-todo-list`
     ` # 在 Linux 上：` ` docker container exec todo2 ls /data`  ` # 在 Windows 上：` ` docker
    container exec todo2 cmd /C "dir C:\data"`  ` # 这个容器将共享 todo1 的卷` ` docker container
    run -d --name t3 --volumes-from todo1 diamol/ch06-todo-list`  ` # 在 Linux 上：`
    ` docker container exec t3 ls /data`  ` # 在 Windows 上：` ` docker container exec
    t3 cmd /C "dir C:\data"`'
- en: The output will look like figure 6.7 (I’m running on Linux for this example).
    The second container starts with a new volume, so the `/data` directory is empty.
    The third container uses the volumes from the first, so it can see the data from
    the original application container.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于图 6.7（本例中我在 Linux 上运行）。第二个容器以新卷开始，因此 `/data` 目录为空。第三个容器使用第一个容器的卷，因此可以看到原始应用程序容器的数据。
- en: '![](../Images/6-7.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 运行具有专用和共享卷的容器](../Images/6-7.jpg)'
- en: Figure 6.7 Running containers with dedicated and shared volumes
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 运行具有专用和共享卷的容器
- en: Sharing volumes between containers is straightforward, but it’s probably not
    what you want to do. Apps that write data typically expect exclusive access to
    the files, and they may not work correctly (or at all) if another container is
    reading and writing to the same file at the same time. Volumes are better used
    to preserve state between application upgrades, and then it’s better to explicitly
    manage the volumes. You can create a named volume and attach that to the different
    versions of your application container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器之间共享卷很简单，但这可能不是你想要做的。通常，写入数据的应用程序期望对文件有独占访问权限，如果另一个容器同时读取和写入同一文件，它们可能无法正确工作（或根本无法工作）。卷更适合在应用程序升级之间保留状态，此时最好显式管理卷。你可以创建一个命名卷并将其附加到应用程序容器的不同版本。
- en: 'Try it now Create a volume and use it in a container for version 1 of the to-do
    app. Then add some data in the UI and upgrade the app to version 2\. The filesystem
    paths for the container need to match the operating system, so I’m using variables
    to make copy and pasting easier:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：创建一个卷并在待办事项应用程序的版本 1 中使用它。然后在用户界面中添加一些数据并将应用程序升级到版本 2。容器的文件系统路径需要与操作系统匹配，所以我使用变量来简化复制和粘贴：
- en: '` # save the target file path in a variable:` ` target=''/data'' # for Linux
    containers` ` $target=''c:\data'' # for Windows containers`  ` # create a volume
    to store the data:` ` docker volume create todo-list`  ` # run the v1 app, using
    the volume for app storage:` ` docker container run -d -p 8011:80 -v todo-list:$target
    --name todo-v1 diamol/ch06-todo-list`  ` # add some data through the web app at
    http://localhost:8011`  ` # remove the v1 app container:` ` docker container rm
    -f todo-v1`  ` # and run a v2 container using the same volume for storage:` ` docker
    container run -d -p 8011:80 -v todo-list:$target --name todo-v2 diamol/ch06-todo-list:v2`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 将目标文件路径保存到变量中：` ` target=''/data'' # 对于 Linux 容器` ` $target=''c:\data''
    # 对于 Windows 容器`  ` # 创建一个卷来存储数据：` ` docker volume create todo-list`  ` # 运行 v1
    应用，使用卷进行应用存储：` ` docker container run -d -p 8011:80 -v todo-list:$target --name
    todo-v1 diamol/ch06-todo-list`  ` # 通过 http://localhost:8011 的 Web 应用添加一些数据`  ` #
    删除 v1 应用容器：` ` docker container rm -f todo-v1`  ` # 并运行一个使用相同卷进行存储的 v2 容器：` ` docker
    container run -d -p 8011:80 -v todo-list:$target --name todo-v2 diamol/ch06-todo-list:v2`'
- en: The output in figure 6.8 shows that the volume has its own life cycle. It exists
    before any containers are created, and it remains when containers that use it
    are removed. The application preserves data between upgrades because the new container
    uses the same volume as the old container.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 的输出显示卷有其自己的生命周期。它在创建任何容器之前就存在，当使用它的容器被移除时它仍然存在。应用程序在升级之间保留数据，因为新的容器使用与旧容器相同的卷。
- en: '![](../Images/6-8.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8](../Images/6-8.jpg)'
- en: Figure 6.8 Creating a named volume and using it to persist data between container
    updates
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 创建命名卷并使用它来在容器更新之间持久化数据
- en: 'Now when you browse to http: */ /* localhost:8011 you’ll see version 2 of the
    to-do application, which has had a UI makeover from an expensive creative agency.
    Figure 6.9 shows this is ready for production now.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你浏览到 http: */ /* localhost:8011 时，你会看到待办事项应用的第二个版本，它已经从一家昂贵的创意机构那里得到了界面改造。图
    6.9 显示它现在已准备好投入生产。'
- en: '![](../Images/6-9.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9](../Images/6-9.jpg)'
- en: Figure 6.9 The all-new to-do app UI
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 全新的待办事项应用 UI
- en: There’s one thing to make clear about Docker volumes before we move on. The
    `VOLUME` instruction in the Dockerfile and the `volume` (or `v` ) flag for running
    containers are separate features. Images built with a `VOLUME` instruction will
    always create a volume for a container if there is no volume specified in the
    `run` command. The volume will have a random ID, so you can use it after the container
    is gone, but only if you can work out which volume has your data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一件事需要明确关于 Docker 卷。Dockerfile 中的 `VOLUME` 指令和运行容器的 `volume`（或 `v`）标志是两个不同的功能。使用
    `VOLUME` 指令构建的镜像，如果 `run` 命令中没有指定卷，将始终为容器创建一个卷。卷将有一个随机 ID，因此容器消失后你可以使用它，但前提是你能够确定哪个卷包含你的数据。
- en: The `volume` flag mounts a volume into a container whether the image has a volume
    specified or not. If the image does have a volume, the volume flag can override
    it for the container by using an existing volume for the same target path--so
    a new volume won’t be created. That’s what happened with the to-do list containers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`volume` 标志无论镜像是否指定了卷，都会将卷挂载到容器中。如果镜像确实有卷，卷标志可以通过使用相同目标路径的现有卷来覆盖它，因此不会创建新的卷。这就是待办事项列表容器发生的情况。'
- en: You can use the exact same syntax and get the same results for containers where
    no volume is specified in the image. As an image author, you should use the `VOLUME`
    instruction as a fail-safe option for stateful applications. That way containers
    will always write data to a persistent volume even if the user doesn’t specify
    the `volume` flag. But as an image user, it’s better not to rely on the defaults
    and to work with named volumes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在镜像中没有指定卷的容器，你可以使用完全相同的语法并获得相同的结果。作为镜像的作者，你应该使用 `VOLUME` 指令作为有状态应用程序的备用选项。这样，即使用户没有指定
    `volume` 标志，容器也会始终将数据写入持久卷。但是，作为镜像的使用者，最好不要依赖默认设置，而应该使用命名卷。
- en: 6.3 Running containers with filesystem mounts
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 使用文件系统挂载运行容器
- en: Volumes are great for separating out the life cycle of storage and still have
    Docker manage all the resources for you. Volumes live on the host, so they are
    decoupled from containers. Docker also provides a more direct way of sharing storage
    between containers and hosts using bind mounts. A bind mount makes a directory
    on the host available as a path on a container. The bind mount is transparent
    to the container--it’s just a directory that is part of the container’s filesystem.
    But it means you can access host files from a container and vice versa, which
    unlocks some interesting patterns.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 卷非常适合分离存储的生命周期，同时让Docker为你管理所有资源。卷位于宿主机上，因此它们与容器解耦。Docker还提供了使用绑定挂载在容器和宿主机之间共享存储的更直接方式。绑定挂载将宿主机上的目录作为容器上的路径提供。绑定挂载对容器是透明的--它只是容器文件系统的一部分目录。但这意味着你可以从容器访问宿主机文件，反之亦然，这解锁了一些有趣的模式。
- en: Bind mounts let you explicitly use the filesystems on your host machine for
    container data. That could be a fast solid-state disk, a highly available array
    of disks, or even a distributed storage system that’s accessible across your network.
    If you can access that filesystem on your host, you can use it for containers.
    I could have a server with a RAID array and use that as reliable storage for my
    to-do list application database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载允许你显式地使用宿主机上的文件系统作为容器数据。这可以是快速固态硬盘、高可用性磁盘阵列，甚至是跨网络可访问的分布式存储系统。如果你可以访问宿主机上的文件系统，你就可以为容器使用它。我可能有一个带有RAID阵列的服务器，并使用它作为待办事项应用数据库的可靠存储。
- en: 'Try it now I really do have a server with a RAID array, but you may not, so
    we’ll just create a local directory on your host computer and bind mount it into
    a container. Again, the filesystem paths need to match the host operating system,
    so I’ve declared variables for the source path on your machine and the target
    path for the container. Note the different lines for Windows and Linux:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧，我确实有一个带有RAID阵列的服务器，但你可能没有，所以我们将在你的宿主机计算机上创建一个本地目录并将其绑定挂载到容器中。再次强调，文件系统路径需要与宿主机操作系统匹配，因此我已经为你的机器上的源路径和容器的目标路径声明了变量。注意Windows和Linux的不同行：
- en: '` $source="$(pwd)\databases".ToLower(); $target="c:\data" # Windows` ` source="$(pwd)/databases"
    && target=''/data''             # Linux` `  mkdir ./databases`  ` docker container
    run --mount type=bind,source=$source,target=$target -d -p 8012:80 diamol/ch06-todo-list`
     ` curl http://localhost:8012` ` ls ./databases`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '` $source="$(pwd)\databases".ToLower(); $target="c:\data" # Windows` ` source="$(pwd)/databases"
    && target=''/data''             # Linux` `  mkdir ./databases`  ` docker container
    run --mount type=bind,source=$source,target=$target -d -p 8012:80 diamol/ch06-todo-list`
     ` curl http://localhost:8012` ` ls ./databases`'
- en: This exercise uses the `curl` command (which is on Linux, Mac, and Windows systems)
    to make an HTTP request to the to-do app. That causes the app to start up, which
    creates the database file. The final command lists the contents of the local databases
    directory on your host, and that will show that the application’s database file
    is actually there on your host computer, as you see in figure 6.10.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习使用`curl`命令（该命令在Linux、Mac和Windows系统上都有）向待办事项应用发送HTTP请求。这会导致应用启动，从而创建数据库文件。最后的命令列出了宿主机上本地数据库目录的内容，这将显示应用程序的数据库文件实际上就在你的宿主机计算机上，如图6.10所示。
- en: The bind mount is bidirectional. You can create files in the container and edit
    them on the host, or create files on the host and edit them in the container.
    There’s a security aspect here, because containers should usually run as a least-privilege
    account, to minimize the risk of an attacker exploiting your system. But a container
    needs elevated permissions to read and write files on the host, so this image
    is built with the `USER` instruction in the Dockerfile to give containers administrative
    rights--it uses the built-in `root` user in Linux and the `ContainerAdministrator`
    user in Windows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载是双向的。你可以在容器中创建文件并在宿主机上编辑它们，或者创建宿主机上的文件并在容器中编辑它们。这里有一个安全方面，因为容器通常应该以最小权限账户运行，以最小化攻击者利用系统的风险。但是，容器需要提升权限来读取和写入宿主机上的文件，因此这个镜像在Dockerfile中使用了`USER`指令来赋予容器管理员权限--它使用Linux内置的`root`用户和Windows的`ContainerAdministrator`用户。
- en: If you don’t need to write files, you can bind mount the host directory as read-only
    inside the container. This is one option for surfacing configuration settings
    from the host into the application container. The to-do application image is packaged
    with a default configuration file that sets the logging level for the app to a
    minimum amount. You can run a container from the same image but mount a local
    configuration directory into the container, and override the app’s configuration
    without changing the image.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要写入文件，你可以在容器内部将主机目录绑定挂载为只读。这是从主机将配置设置暴露到应用程序容器的一个选项。待办事项应用程序映像包含一个默认配置文件，该文件将应用程序的日志级别设置为最小值。你可以从相同的映像运行容器，但将本地配置目录挂载到容器中，并覆盖应用程序的配置而不更改映像。
- en: 'Try it now The to-do application will load an extra configuration file from
    the `/app/config` path if it exists. Run a container that bind-mounts a local
    directory to that location, and the app will use the host’s configuration file.
    Start by navigating to your local copy of the DIAMOL source code, and then run
    these commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：待办事项应用程序如果存在，将从 `/app/config` 路径加载额外的配置文件。运行一个将本地目录绑定挂载到该位置的容器，应用程序将使用主机的配置文件。首先导航到你的
    DIAMOL 源代码的本地副本，然后运行以下命令：
- en: '` cd ./ch06/exercises/todo-list`  ` # save the source path as a variable:`
    ` $source="$(pwd)\config".ToLower(); $target="c:\app\config" # Windows` ` source="$(pwd)/config"
    && target=''/app/config''             # Linux`  ` # run the container using the
    mount:` ` docker container run --name todo-configured -d -p 8013:80 --mount type=bind,source=$source,target=$target,readonly
    diamol/ch06-todo-list`  ` # check the application:` ` curl http://localhost:8013`
     ` # and the container logs:` ` docker container logs todo-configured`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ./ch06/exercises/todo-list`  ` # 将源路径保存为变量：` ` $source="$(pwd)\config".ToLower();
    $target="c:\app\config" # Windows` ` source="$(pwd)/config" && target=''/app/config''
                # Linux`  ` # 使用挂载运行容器：` ` docker container run --name todo-configured
    -d -p 8013:80 --mount type=bind,source=$source,target=$target,readonly diamol/ch06-todo-list`
     ` # 检查应用程序：` ` curl http://localhost:8013`  ` # 以及容器日志：` ` docker container logs
    todo-configured`'
- en: '![](../Images/6-10.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 6-10](../Images/6-10.jpg)'
- en: Figure 6.10 Sharing a directory on the host with a container using a bind mount
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 使用绑定挂载在主机上与容器共享目录
- en: The config file in the directory on the host is set to use much more detailed
    logging. When the container starts, it maps that directory, and the application
    sees the config file and loads the logging configuration. In the final output
    shown in figure 6.11, there are lots of debug log lines, which the app wouldn’t
    write with the standard configuration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 主机上的目录中的配置文件被设置为使用更详细的日志记录。当容器启动时，它会映射该目录，应用程序看到配置文件并加载日志配置。在图 6.11 所示的最终输出中，有很多调试日志行，这些日志行在标准配置下应用程序不会写入。
- en: '![](../Images/6-11.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 6-11](../Images/6-11.jpg)'
- en: Figure 6.11 Using bind mounts to load read-only configuration files into containers
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 使用绑定挂载将只读配置文件加载到容器中
- en: You can bind-mount any source that your host computer has access to. You could
    use a shared network drive mounted to `/mnt/nfs` on a Linux host, or mapped to
    the `X:` drive on a Windows host. Either of those could be the source for a bind
    mount and be surfaced into a container in the same way. It’s a very useful way
    to get reliable and even distributed storage for stateful apps running in containers,
    but there are some limitations you need to understand.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以绑定挂载主机计算机可访问的任何源。你可以在 Linux 主机上挂载到 `/mnt/nfs` 的共享网络驱动器，或者在 Windows 主机上映射到
    `X:` 驱动器。这两个都可以作为绑定挂载的源，并以相同的方式暴露给容器。这是一种非常有用的方式，可以为在容器中运行的有状态应用程序提供可靠甚至分布式的存储，但你需要了解一些限制。
- en: 6.4 Limitations of filesystem mounts
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 文件系统挂载的限制
- en: To use bind mounts and volumes effectively, you need to understand some key
    scenarios and limitations, some of which are subtle and will only appear in unusual
    combinations of containers and filesystems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地使用绑定挂载和卷，你需要了解一些关键场景和限制，其中一些是微妙的，并且只会在容器和文件系统的非寻常组合中出现。
- en: 'The first scenario is straightforward: what happens when you run a container
    with a mount, and the mount target directory already exists and has files from
    the image layers? You might think that Docker would merge the source into the
    target. Inside the container you’d expect to see that the directory has all the
    existing files from the image, and all the new files from the mount. But that
    isn’t the case. When you mount a target that already has data, the source directory
    replaces the target directory--so the original files from the image are not available.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景很简单：当你运行一个带有挂载的容器，而挂载的目标目录已经存在并且包含镜像层的文件时，会发生什么？你可能认为Docker会将源合并到目标中。在容器内部，你期望看到目录包含来自镜像的所有现有文件和来自挂载的所有新文件。但这并不是事实。当你挂载一个已经包含数据的目标时，源目录会替换目标目录——因此，镜像中的原始文件不可用。
- en: You can see this with a simple exercise, using an image that lists directory
    contents when it runs. The behavior is the same for Linux and Windows containers,
    but the filesystem paths in the commands need to match the operating system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个简单的练习看到这一点，使用一个在运行时列出目录内容的镜像。对于Linux和Windows容器，行为是相同的，但命令中的文件系统路径需要与操作系统匹配。
- en: 'Try it now Run the container without a mount, and it will list the directory
    contents from the image. Run it again with a mount, and it will list the contents
    of the source directory (there are variables again here to support Windows and
    Linux):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。运行一个没有挂载的容器，它将列出镜像中的目录内容。再次运行时使用挂载，它将列出源目录的内容（这里再次有变量以支持Windows和Linux）：
- en: '` cd ./ch06/exercises/bind-mount`  ` $source="$(pwd)\new".ToLower(); $target="c:\init"
    # Windows` ` source="$(pwd)/new" && target=''/init''             # Linux`  ` docker
    container run diamol/ch06-bind-mount`  ` docker container run --mount type=bind,source=$source,target=$target
    diamol/ch06-bind-mount`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ./ch06/exercises/bind-mount`  ` $source="$(pwd)\new".ToLower(); $target="c:\init"
    # Windows` ` source="$(pwd)/new" && target=''/init''             # Linux`  ` docker
    container run diamol/ch06-bind-mount`  ` docker container run --mount type=bind,source=$source,target=$target
    diamol/ch06-bind-mount`'
- en: 'You’ll see that in the first run the container lists two files: `abc.txt` and
    `def.txt` . These are loaded into the container from the image layers. The second
    container replaces the target directory with the source from the mount, so those
    files are not listed. Only the files `123.txt` and `456.txt` are shown, and these
    are from the source directory on the host. Figure 6.12 shows my output.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到在第一次运行时，容器列出了两个文件：`abc.txt` 和 `def.txt`。这些文件是从镜像层加载到容器中的。第二个容器用挂载的源替换了目标目录，因此这些文件没有列出。只显示了`123.txt`
    和 `456.txt` 这两个文件，它们来自主机上的源目录。图6.12显示了我的输出。
- en: '![](../Images/6-12.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-12.jpg)'
- en: Figure 6.12 Bind mount directories shadow the target directory if it exists.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12显示了绑定挂载目录如果目标目录存在，会覆盖目标目录。
- en: 'The second scenario is a variation on that: what happens if you mount a single
    file from the host to a target directory that exists in the container filesystem?
    This time the directory contents are merged, so you’ll see the original files
    from the image and the new file from the host--unless you’re running Windows containers,
    where this feature isn’t supported at all.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个场景是对第一个场景的变体：如果你从主机挂载单个文件到容器文件系统中已存在的目标目录，会发生什么？这次目录内容会被合并，所以你会看到来自镜像的原始文件和来自主机的新文件——除非你在运行Windows容器，因为在这个功能上Windows容器根本不支持。
- en: The container filesystem is one of the few areas where Windows containers are
    not the same as Linux containers. Some things do work in the same way. You can
    use standard Linux-style paths inside Dockerfiles, so `/data` works for Windows
    containers and becomes an alias of `C:\data` . But that doesn’t work for volume
    mounts and bind mounts, which is why the exercises in this chapter use variables
    to give Linux users `/data` and Windows `C:\data` .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 容器文件系统是Windows容器与Linux容器不同之处之一。有些事情以相同的方式工作。你可以在Dockerfile中使用标准的Linux风格路径，所以`/data`对Windows容器有效，并成为`C:\data`的别名。但这对于卷挂载和绑定挂载不适用，这就是为什么本章的练习使用变量为Linux用户提供`/data`和Windows的`C:\data`。
- en: The limitation on single-file mounts is more explicit. You can try this yourself
    if you have Windows and Linux machines available, or if you’re running Docker
    Desktop on Windows, which supports both Linux and Windows containers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 单个文件挂载的限制更为明确。如果你有Windows和Linux机器，或者如果你在Windows上运行支持Linux和Windows容器的Docker Desktop，你可以亲自尝试这个实验。
- en: 'Try it now The behavior of single-file mounts is different on Linux and Windows.
    If you have Linux and Windows containers available, you can see that in action:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 单文件挂载在 Linux 和 Windows 上的行为不同。如果您有 Linux 和 Windows 容器可用，您可以看到实际效果：
- en: '` cd ./ch06/exercises/bind-mount`  ` # on Linux:` ` docker container run --mount
    type=bind,source="$(pwd)/new/123.txt",target=/init/123.txt diamol/ch06-bind-mount`
     ` # on Windows:`  ` docker container run --mount type=bind,source="$(pwd)/new/123.txt",target=C:\init\123.txt
    diamol/ch06-bind-mount`  ` docker container run diamol/ch06-bind-mount`  ` docker
    container run --mount type=bind,source="$(pwd)/new/123.txt",target=/init/123.txt
    diamol/ch06-bind-mount`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ./ch06/exercises/bind-mount`  ` # on Linux:` ` docker container run --mount
    type=bind,source="$(pwd)/new/123.txt",target=/init/123.txt diamol/ch06-bind-mount`
     ` # on Windows:`  ` docker container run --mount type=bind,source="$(pwd)/new/123.txt",target=C:\init\123.txt
    diamol/ch06-bind-mount`  ` docker container run diamol/ch06-bind-mount`  ` docker
    container run --mount type=bind,source="$(pwd)/new/123.txt",target=/init/123.txt
    diamol/ch06-bind-mount`'
- en: The Docker image is the same, and the commands are the same--apart from the
    OS-specific filesystem path for the target. But you’ll see when you run this that
    the Linux example works as expected but you get an error from Docker on Windows,
    as in figure 6.13.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像和命令都是相同的——除了针对特定操作系统的目标文件系统路径。但当你运行这个命令时，你会看到 Linux 示例按预期工作，但在 Windows
    上你会从 Docker 获得错误，如图 6.13 所示。
- en: '![](../Images/6-13.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-13.jpg)'
- en: Figure 6.13 Bind mounts with a single file as the source work on Linux but not
    on Windows.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 使用单个文件作为源绑定挂载在 Linux 上有效，但在 Windows 上无效。
- en: The third scenario is less common. It’s very difficult to reproduce without
    setting up a lot of moving pieces, so there won’t be an exercise to cover this--you’ll
    have to take my word for it. The scenario is, what happens if you bind-mount a
    distributed filesystem into a container? Will the app in the container still work
    correctly? See, even the question is complicated.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个场景较为少见。没有设置很多移动部件很难重现，因此不会有练习涵盖这个场景——你只能相信我的话。这个场景是，如果你将分布式文件系统绑定挂载到容器中会发生什么？容器中的应用程序是否仍然可以正确工作？看，连这个问题都很复杂。
- en: Distributed filesystems let you access data from any machine on the network,
    and they usually use different storage mechanisms from your operating system’s
    local filesystem. It could be a technology like SMB file shares on your local
    network, Azure Files, or AWS S3 in the cloud. You can mount locations from distributed
    storage systems like these into a container. The mount will look like a normal
    part of the filesystem, but if it doesn’t support the same operations, your app
    could fail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式文件系统允许您从网络上的任何机器访问数据，并且它们通常使用与操作系统本地文件系统不同的存储机制。这可能是在本地网络上的 SMB 文件共享、Azure
    Files 或云中的 AWS S3 等技术。您可以将这些分布式存储系统中的位置挂载到容器中。挂载将看起来像文件系统的一个正常部分，但如果它不支持相同的操作，您的应用程序可能会失败。
- en: There’s a concrete example in figure 6.14 of trying to run the Postgres database
    system in a container on the cloud, using Azure Files for container storage. Azure
    Files supports normal filesystem operations like read and write, but it doesn’t
    support some of the more unusual operations that apps might use. In this case
    the Postgres container tries to create a file link, but Azure Files doesn’t support
    that feature, so the app crashes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 中有一个具体的例子，尝试在云上的容器中运行 Postgres 数据库系统，使用 Azure Files 作为容器存储。Azure Files
    支持常规的文件系统操作，如读取和写入，但它不支持应用程序可能使用的某些更不寻常的操作。在这种情况下，Postgres 容器尝试创建一个文件链接，但 Azure
    Files 不支持该功能，因此应用程序崩溃。
- en: '![](../Images/6-14.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-14.jpg)'
- en: Figure 6.14 Distributed storage systems may not provide all the usual filesystem
    features.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 分布式存储系统可能不会提供所有常规的文件系统功能。
- en: This scenario is an outlier, but you need to be aware of it because if it happens
    there’s really no way around it. The source for your bind mount may not support
    all the filesystem features that the app in your container expects. This is something
    you can’t plan for--you won’t know until you try your app with your storage system.
    If you want to use distributed storage for containers, you should be aware of
    this risk, and you also need to understand that distributed storage will have
    very different performance characteristics from local storage. An application
    that uses a lot of disk may grind to a halt if you run it in a container with
    distributed storage, where every file write goes over the network.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况是一个例外，但你需要意识到它，因为如果发生这种情况，实际上没有其他解决办法。你的绑定挂载的源可能不支持容器中应用程序期望的所有文件系统功能。这是你无法计划的事情--你只有在尝试使用你的存储系统运行你的应用程序时才会知道。如果你想为容器使用分布式存储，你应该意识到这个风险，并且你还需要了解分布式存储的性能特征将与本地存储非常不同。如果你在一个使用分布式存储的容器中运行一个使用大量磁盘的应用程序，那么每次文件写入都会通过网络进行，这可能会导致应用程序运行缓慢。
- en: 6.5 Understanding how the container filesystem is built
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 理解容器文件系统的构建
- en: We’ve covered a lot in this chapter. Storage is an important topic because the
    options for containers are very different from storage on physical computers or
    virtual machines. I’m going to finish up with a consolidated look at everything
    we’ve covered, with some best-practice guidelines for using the container filesystem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量的内容。存储是一个重要的主题，因为容器与物理计算机或虚拟机上的存储选项非常不同。我将通过综合回顾我们所涵盖的所有内容，并提供一些使用容器文件系统的最佳实践指南来完成本章节。
- en: Every container has a single disk, which is a virtual disk that Docker pieces
    together from several sources. Docker calls this the union filesystem. I’m not
    going to look at how Docker implements the union filesystem, because there are
    different technologies for different operating systems. When you install Docker,
    it makes the right choice for your OS, so you don’t need to worry about the details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器只有一个磁盘，这是一个由Docker从多个来源拼接而成的虚拟磁盘。Docker称这为联合文件系统。我不会探讨Docker如何实现联合文件系统，因为不同的操作系统有不同的技术。当你安装Docker时，它会为你的操作系统做出正确的选择，因此你不需要担心细节。
- en: The union filesystem lets the container see a single disk drive and work with
    files and directories in the same way, wherever they may be on the disk. But the
    locations on the disk can be physically stored in different storage units, as
    figure 6.15 shows.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 联合文件系统允许容器看到一个单一的磁盘驱动器，并以相同的方式处理文件和目录，无论它们在磁盘上的位置如何。但是，磁盘上的位置可以物理存储在不同的存储单元中，如图6.15所示。
- en: '![](../Images/6-15.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-15.jpg)'
- en: Figure 6.15 The container filesystem is created from the union of multiple sources.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 容器文件系统是由多个来源的联合创建的。
- en: 'Applications inside a container see a single disk, but as the image author
    or container user, you choose the sources for that disk. There can be multiple
    image layers, multiple volume mounts, and multiple bind mounts in a container,
    but they will always have a single writeable layer. Here are some general guidelines
    for how you should use the storage options:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内的应用程序看到一个单一的磁盘，但作为镜像作者或容器用户，你选择该磁盘的来源。容器中可以有多个镜像层、多个卷挂载和多个绑定挂载，但它们将始终只有一个可写层。以下是一些关于如何使用存储选项的一般性指南：
- en: Writeable layer --Perfect for short-term storage, like caching data to disk
    to save on network calls or computations. These are unique to each container but
    are gone forever when the container is removed.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可写层 -- 适用于短期存储，例如将数据缓存到磁盘以节省网络调用或计算。这些是每个容器独有的，但容器被移除后它们将永远消失。
- en: Local bind mounts --Used to share data between the host and the container. Developers
    can use bind mounts to load the source code on their computer into the container,
    so when they make local edits to HTML or JavaScript files, the changes are immediately
    in the container without having to build a new image.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地绑定挂载 -- 用于在主机和容器之间共享数据。开发者可以使用绑定挂载将他们的计算机上的源代码加载到容器中，这样当他们修改HTML或JavaScript文件时，更改会立即反映在容器中，而无需构建新的镜像。
- en: Distributed bind mounts --Used to share data between network storage and containers.
    These are useful, but you need to be aware that network storage will not have
    the same performance as local disk and may not offer full filesystem features.
    They can be used as read-only sources for configuration data or a shared cache,
    or as read-write to store data that can be used by any container on any machine
    on the same network.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式绑定挂载--用于在网络存储和容器之间共享数据。这些很有用，但你需要意识到网络存储的性能可能不会与本地磁盘相同，并且可能不会提供完整的文件系统功能。它们可以用作只读源来存储配置数据或共享缓存，或者用作读写来存储可以被同一网络上的任何机器上的任何容器使用的数据。
- en: Volume mounts --Used to share data between the container and a storage object
    that is managed by Docker. These are useful for persistent storage, where the
    application writes data to the volume. When you upgrade your app with a new container,
    it will retain the data written to the volume by the previous version.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷挂载--用于在容器和由Docker管理的存储对象之间共享数据。这些对于持久化存储很有用，其中应用程序将数据写入卷。当你用新容器升级应用程序时，它将保留之前版本写入卷的数据。
- en: Image layers --These present the initial filesystem for the container. Layers
    are stacked, with the latest layer overriding earlier layers, so a file written
    in a layer at the beginning of the Dockerfile can be overridden by a subsequent
    layer that writes to the same path. Layers are read-only, and they can be shared
    between containers.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像层--这些提供了容器的初始文件系统。层是堆叠的，最新层覆盖了早期层，因此Dockerfile开始时写入层的文件可以被随后写入相同路径的层覆盖。层是只读的，并且可以在容器之间共享。
- en: 6.6 Lab
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 实验室
- en: 'We’ll put those pieces together in this lab. It’s back to the good old to-do
    list app, but this time with a twist. The app will run in a container and start
    with a set of tasks already created. Your job is to run the app using the same
    image but with different storage options, so that the to-do list starts off empty,
    and when you save items they get stored to a Docker volume. The exercises from
    this chapter should get you there, but here are some hints:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本实验室中把这些部分组合起来。它回到了那个好用的待办事项列表应用程序，但这次有所不同。应用程序将在容器中运行，并从一组已创建的任务开始。你的任务是使用相同的镜像但不同的存储选项运行应用程序，这样待办事项列表就可以从空开始，当你保存项目时，它们会被存储到Docker卷中。本章的练习应该能帮助你做到这一点，但这里有一些提示：
- en: Remember it’s `docker` `rm` `-f` `$(docker` `ps` `-aq)` to remove all your existing
    containers.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，删除所有现有容器的方法是`docker rm -f $(docker ps -aq)`。
- en: Start by running the app from `diamol/ch06-lab` to check out the tasks.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先从`diamol/ch06-lab`运行应用程序来检查任务。
- en: Then you’ll need to run a container from the same image with some mounts.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后你需要从相同的镜像运行一个带有一些挂载点的容器。
- en: The app uses a configuration file--there’s more in there than settings for the
    log.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序使用配置文件--里面不仅有日志的设置。
- en: My sample solution is on the book’s GitHub repository if you need it, but you
    should try to work through this one because container storage can trip you up
    if you haven’t had much experience. There are a few ways to solve this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，我的示例解决方案在书的GitHub仓库上，但你应该尝试完成这个任务，因为如果你没有太多经验，容器存储可能会让你感到困惑。有几种方法可以解决这个问题。
- en: 'My solution is here: *[https:// github.com/sixeyed/diamol/blob/master/ch06/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch06/lab/README.md)*
    .'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案在这里：*[https://github.com/sixeyed/diamol/blob/master/ch06/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch06/lab/README.md)*。
