- en: Chapter 7\. Dictionaries
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章. 字典
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Defining a dictionary
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义字典
- en: Using dictionary operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典操作
- en: Determining what can be used as a key
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定什么可以作为键
- en: Creating sparse matrices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建稀疏矩阵
- en: Using dictionaries as caches
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典作为缓存
- en: Trusting the efficiency of dictionaries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信任字典的效率
- en: This chapter discusses dictionaries, Python’s name for associative arrays or
    maps, which it implements by using hash tables. Dictionaries are amazingly useful,
    even in simple programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了字典，这是Python对关联数组或映射的称呼，它通过使用哈希表来实现。字典非常实用，即使在简单的程序中也是如此。
- en: Because dictionaries are less familiar to many programmers than other basic
    data structures such as lists and strings, some of the examples illustrating dictionary
    use are slightly more complex than the corresponding examples for other built-in
    data structures. It may be necessary to read parts of [chapter 8](kindle_split_019.html#ch08)
    to fully understand some of the examples in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典对于许多程序员来说不如列表和字符串等基本数据结构熟悉，因此说明字典使用的某些示例可能比其他内置数据结构的示例稍微复杂一些。可能需要阅读[第8章](kindle_split_019.html#ch08)的部分内容，才能完全理解本章中的一些示例。
- en: 7.1\. What is a dictionary?
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 什么是字典？
- en: 'If you’ve never used associative arrays or hash tables in other languages,
    a good way to start understanding the use of dictionaries is to compare them with
    lists:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未在其他语言中使用关联数组或哈希表，理解字典使用的一个好方法是将其与列表进行比较：
- en: Values in lists are accessed by means of integers called *indices*, which indicate
    where in the list a given value is found.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中的值通过称为**索引**的整数来访问，这些索引指示给定值在列表中的位置。
- en: Dictionaries access values by means of integers, strings, or other Python objects
    called *keys*, which indicate where in the dictionary a given value is found.
    In other words, both lists and dictionaries provide indexed access to arbitrary
    values, but the set of items that can be used as dictionary indices is much larger
    than, and contains, the set of items that can be used as list indices. Also, the
    mechanism that dictionaries use to provide indexed access is quite different from
    that used by lists.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典通过整数、字符串或其他称为**键**的Python对象来访问值，这些键指示给定值在字典中的位置。换句话说，列表和字典都提供了对任意值的索引访问，但可以用作字典索引的项集比可用作列表索引的项集大得多。此外，字典用于提供索引访问的机制与列表使用的机制相当不同。
- en: Both lists and dictionaries can store objects of any type.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和字典都可以存储任何类型的对象。
- en: Values stored in a list are implicitly *ordered* by their positions in the list,
    because the indices that access these values are consecutive integers. You may
    or may not care about this ordering, but you can use it if desired. Values stored
    in a dictionary are *not* implicitly ordered relative to one another because dictionary
    keys aren’t just numbers. Note that if you’re using a dictionary but also care
    about the order of the items (the order in which they were added, that is), you
    can use an *ordered dictionary*, which is a dictionary subclass that can be imported
    from the `collections` module. You can also define an order on the items in a
    dictionary by using another data structure (often a list) to store such an ordering
    explicitly; this won’t change the fact that basic dictionaries have no implicit
    (built-in) ordering.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中存储的值会根据它们在列表中的位置隐式地**有序**排列，因为访问这些值的索引是连续的整数。你可能不在乎这种排序，但如果需要，你可以使用它。字典中存储的值相对于彼此**不是**隐式有序的，因为字典键不仅仅是数字。注意，如果你使用字典但同时也关心项的顺序（即它们被添加的顺序），你可以使用一个**有序字典**，这是一个可以从`collections`模块导入的字典子类。你还可以通过使用另一个数据结构（通常是列表）来显式存储这种排序，这样就不会改变基本字典没有隐式（内置）排序的事实。
- en: 'In spite of the differences between them, the use of dictionaries and lists
    often appears to be the same. As a start, an empty dictionary is created much
    like an empty list, but with curly braces instead of square brackets:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们之间有差异，但字典和列表的使用通常看起来是相同的。作为一个起点，创建一个空字典的方式与创建一个空列表相似，但使用花括号而不是方括号：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the first line creates a new, empty list and assigns it to `x`. The second
    line creates a new, empty dictionary and assigns it to `y`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一行创建了一个新的空列表并将其赋值给`x`。第二行创建了一个新的空字典并将其赋值给`y`。
- en: 'After you create a dictionary, you may store values in it as though it were
    a list:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建字典后，你可以像对待列表一样在其中存储值：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Even in these assignments, there’s already a significant operational difference
    between the dictionary and list usage. Trying to do the same thing with a list
    would result in an error, because in Python, it’s illegal to assign to a position
    in a list that doesn’t exist. For example, if you try to assign to the *0*th element
    of the list `x`, you receive an error:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这些赋值中，字典和列表的使用之间也已经存在显著的差异。尝试用列表做同样的事情会导致错误，因为在Python中，向一个不存在的列表位置赋值是非法的。例如，如果你尝试向列表`x`的*0*个元素赋值，你会收到一个错误：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This isn’t a problem with dictionaries; new positions in dictionaries are created
    as necessary.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是字典的问题；字典中会根据需要创建新的位置。
- en: 'Having stored some values in the dictionary, now you can access and use them:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中存储了一些值之后，现在你可以访问和使用它们：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All in all, this makes a dictionary look pretty much like a list. Now for the
    big difference. Store (and use) some values under keys that aren’t integers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这使字典看起来几乎就像一个列表。现在来看看最大的不同。在键不是整数的情况下存储（和使用）一些值：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is definitely something that can’t be done with lists! Whereas list indices
    must be integers, dictionary keys are much less restricted; they may be numbers,
    strings, or one of a wide range of other Python objects. This makes dictionaries
    a natural for jobs that lists can’t do. For example, it makes more sense to implement
    a telephone-directory application with dictionaries than with lists because the
    phone number for a person can be stored indexed by that person’s last name.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一些列表无法做到的事情！与列表索引必须是整数不同，字典键的限制要少得多；它们可以是数字、字符串或一系列广泛的Python对象之一。这使得字典非常适合列表无法完成的任务。例如，使用字典而不是列表来实现电话簿应用程序更有意义，因为可以通过人的姓氏来存储和索引该人的电话号码。
- en: 'A dictionary is a way of mapping from one set of arbitrary objects to an associated
    but equally arbitrary set of objects. Actual dictionaries, thesauri, or translation
    books are good analogies in the real world. To see how natural this correspondence
    is, here’s the start of an English-to-French color translator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是从一组任意对象映射到与之相关但同样任意的另一组对象的一种方式。实际的字典、同义词词典或翻译书籍在现实世界中是很好的类比。为了看到这种对应关系是多么自然，这里有一个从英语到法语的颜色翻译器的开头：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Creates empty dictionary**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建空字典**'
- en: '***2* Stores three words in it**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在其中存储三个单词**'
- en: '***3* Obtains value for ‘red’**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取‘red’的值**'
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Create a dictionary'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：创建一个字典
- en: Write the code to ask the user for three names and three ages. After the names
    and ages are entered, ask the user for one of the names, and print the correct
    age.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以询问用户输入三个名字和三个年龄。在输入名字和年龄后，询问用户其中一个名字，并打印正确的年龄。
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.2\. Other dictionary operations
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 其他字典操作
- en: 'Besides basic element assignment and access, dictionaries support several operations.
    You can define a dictionary explicitly as a series of key-value pairs separated
    by commas:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的元素赋值和访问外，字典还支持几种操作。你可以通过逗号分隔的键值对显式地定义一个字典：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`len` returns the number of entries in a dictionary:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`len`返回字典中的条目数：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can obtain all the keys in the dictionary with the `keys` method. This
    method is often used to iterate over the contents of a dictionary using Python’s
    `for` loop, described in [chapter 8](kindle_split_019.html#ch08):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`keys`方法获取字典中的所有键。这个方法通常用于使用Python的`for`循环遍历字典的内容，这在第8章中有所描述[chapter 8](kindle_split_019.html#ch08)：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In Python 3.5 and earlier, the order of the keys in a list returned by `keys`
    has no meaning; the keys aren’t necessarily sorted, and they don’t necessarily
    occur in the order in which they were created. Your Python code may print out
    the keys in a different order than my Python code did. If you need keys sorted,
    you can store them in a list variable and then sort that list. However, starting
    with Python 3.6, dictionaries preserve the order that the keys were created and
    return them in that order.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.5及更早版本中，`keys`返回的列表中键的顺序没有意义；键不一定排序，也不一定按创建顺序出现。你的Python代码打印出的键的顺序可能与我的Python代码不同。如果你需要排序的键，你可以将它们存储在一个列表变量中，然后对那个列表进行排序。然而，从Python
    3.6开始，字典保留了键创建的顺序，并按该顺序返回键。
- en: 'It’s also possible to obtain all the values stored in a dictionary by using
    `values`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用`values`来获取存储在字典中的所有值：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method isn’t used nearly as often as `keys`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不像`keys`那样经常被使用。
- en: 'You can use the `items` method to return all keys and their associated values
    as a sequence of tuples:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `items` 方法来返回所有键及其相关值的元组序列：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Like `keys`, this method is often used in conjunction with a `for` loop to iterate
    over the contents of a dictionary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `keys` 方法类似，此方法通常与 `for` 循环结合使用，以遍历字典的内容。
- en: 'The `del` statement can be used to remove an entry (key-value pair) from a
    dictionary:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `del` 语句从字典中删除条目（键值对）：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Dictionary view objects**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典视图对象**'
- en: The `keys`, `values`, and `items` methods return not lists, but *views* that
    behave like sequences but are dynamically updated whenever the dictionary changes.
    That’s why you need to use the `list` function to make them appear as a list in
    these examples. Otherwise, they behave like sequences, allowing code to iterate
    over them in a `for` loop, using `in` to check membership in them, and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys`、`values` 和 `items` 方法返回的不是列表，而是类似于序列的视图，但每当字典发生变化时都会动态更新。这就是为什么在这些示例中你需要使用
    `list` 函数来使它们看起来像列表的原因。否则，它们的行为类似于序列，允许代码在 `for` 循环中使用 `in` 来检查它们中的成员资格，等等。'
- en: The view returned by `keys` (and in some cases the view returned by `items`)
    also behaves like a set, with union, difference, and intersection operations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys` 返回的视图（以及在某些情况下 `items` 返回的视图）也像集合一样行为，具有并集、差集和交集操作。'
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Attempting to access a key that isn’t in a dictionary is an error in Python.
    To handle this error, you can test the dictionary for the presence of a key with
    the `in` keyword, which returns `True` if a dictionary has a value stored under
    the given key and `False` otherwise:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问字典中不存在的键在 Python 中是一个错误。为了处理此错误，你可以使用 `in` 关键字测试字典中是否存在键，如果字典在给定键下存储了值，则返回
    `True`，否则返回 `False`：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you can use the `get` function. This function returns the value
    associated with a key if the dictionary contains that key, but returns its second
    argument if the dictionary doesn’t contain the key:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `get` 函数。如果字典包含该键，此函数返回与该键关联的值，但如果字典不包含该键，则返回其第二个参数：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second argument is optional. If that argument isn’t included, `get` returns
    `None` if the dictionary doesn’t contain the key.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是可选的。如果该参数未包含，`get` 方法在字典不包含该键时返回 `None`。
- en: 'Similarly, if you want to safely get a key’s value *and* make sure that it’s
    set to a default in the dictionary, you can use the `setdefault` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你想安全地获取键的值并且确保它在字典中设置为默认值，你可以使用 `setdefault` 方法：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The difference between `get` and `setdefault` is that after the `setdefault`
    call, there’s a key in the dictionary `'chartreuse'` with the value `'No translation'`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 和 `setdefault` 之间的区别在于，在 `setdefault` 调用之后，字典中有一个 `''chartreuse''` 键，其值为
    `''No translation''`。'
- en: 'You can obtain a copy of a dictionary by using the `copy` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `copy` 方法来获取字典的副本：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method makes a shallow copy of the dictionary, which is likely to be all
    you need in most situations. For dictionaries that contain any modifiable objects
    as values (for example, lists or other dictionaries), you may want to make a deep
    copy by using the `copy.deepcopy` function. See [chapter 5](kindle_split_016.html#ch05)
    for an introduction to the concept of shallow and deep copies.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建字典的浅拷贝，这在大多数情况下可能就足够了。对于包含任何可修改对象（例如列表或其他字典）作为值的字典，你可能想通过使用 `copy.deepcopy`
    函数来创建深拷贝。参见[第5章](kindle_split_016.html#ch05)以了解浅拷贝和深拷贝的概念介绍。
- en: 'The `update` method updates a first dictionary with all the key-value pairs
    of a second dictionary. For keys that are common to both dictionaries, the values
    from the second dictionary override those of the first:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法使用第二个字典中的所有键值对更新第一个字典。对于两个字典共有的键，第二个字典的值将覆盖第一个字典的值：'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Dictionary methods give you a full set of tools to manipulate and use dictionaries.
    For quick reference, [table 7.1](#ch07table01) lists some of the main dictionary
    functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 字典方法为你提供了一套完整的工具来操作和使用字典。为了快速参考，[表7.1](#ch07table01) 列出了一些主要的字典函数。
- en: Table 7.1\. Dictionary operations
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.1\. 字典操作
- en: '| Dictionary operation | Explanation | Example |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 字典操作 | 说明 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| {} | Creates an empty dictionary | x = {} |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| {} | 创建一个空字典 | x = {} |'
- en: '| len | Returns the number of entries in a dictionary | len(x) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| len | 返回字典中的条目数 | len(x) |'
- en: '| keys | Returns a view of all keys in a dictionary | x.keys() |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| keys | 返回字典中所有键的视图 | x.keys() |'
- en: '| values | Returns a view of all values in a dictionary | x.values() |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| values | 返回字典中所有值的视图 | x.values() |'
- en: '| items | Returns a view of all items in a dictionary | x.items() |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| items | 返回字典中所有项的视图 | x.items() |'
- en: '| del | Removes an entry from a dictionary | del(x[key]) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| del | 从字典中删除条目 | del(x[key]) |'
- en: '| in | Tests whether a key exists in a dictionary | ''y'' in x |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| in | 测试键是否存在于字典中 | ''y'' in x |'
- en: '| get | Returns the value of a key or a configurable default | x.get(''y'',
    None) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| get | 返回键的值或可配置的默认值 | x.get(''y'', None) |'
- en: '| setdefault | Returns the value if the key is in the dictionary; otherwise,
    sets the value for the key to the default and returns the value | x.setdefault(''y'',
    None) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| setdefault | 如果键在字典中，则返回值；否则，将键的值设置为默认值并返回值 | x.setdefault(''y'', None) |'
- en: '| copy | Makes a shallow copy of a dictionary | y = x.copy() |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| copy | 创建字典的浅拷贝 | y = x.copy() |'
- en: '| update | Combines the entries of two dictionaries | x.update(z) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| update | 合并两个字典的条目 | x.update(z) |'
- en: This table isn’t a complete list of all dictionary operations. For a complete
    list, refer to the Python standard library documentation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表并不是所有字典操作的完整列表。要获取完整列表，请参阅Python标准库文档。
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Dictionary operations'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：字典操作
- en: 'Assume that you have a dictionary `x = {''a'':1, ''b'':2, ''c'':3, ''d'':4}`
    and a dictionary `y = {''a'':6, ''e'':5, ''f'':6}`. What would be the contents
    of x after the following snippets of code have executed?:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个字典`x = {'a':1, 'b':2, 'c':3, 'd':4}`和一个字典`y = {'a':6, 'e':5, 'f':6}`。以下代码片段执行后，x的内容会是什么？：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3\. Word counting
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 单词计数
- en: 'Assume that you have a file that contains a list of words, one word per line.
    You want to know how many times each word occurs in the file. You can use dictionaries
    to perform this task easily:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含单词列表的文件，每行一个单词。你想知道每个单词在文件中出现的次数。你可以使用字典轻松完成这个任务：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Increment the `occurrences` count for each word ***1***. This is a good example
    of the power of dictionaries. The code is simple, but because dictionary operations
    are highly optimized in Python, it’s also quite fast. This pattern is so handy,
    in fact, that it’s been standardized as the `Counter` class in the `collections`
    module of the standard library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个单词的`occurrences`计数增加**1**。这是一个字典强大功能的例子。代码很简单，但由于Python中对字典操作的高度优化，它也相当快。这个模式如此方便，实际上已经被标准化为标准库中`collections`模块的`Counter`类。
- en: 7.4\. What can be used as a key?
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '7.4\. 可以用作键的内容？ '
- en: The previous examples use strings as keys, but Python permits more than just
    strings to be used in this manner. Any Python object that is immutable and hashable
    can be used as a key to a dictionary.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用字符串作为键，但Python允许使用不仅仅是字符串的方式。任何不可变且可哈希的Python对象都可以用作字典的键。
- en: In Python, as discussed earlier, any object that can be modified is called *mutable*.
    Lists are mutable because list elements can be added, changed, or removed. Dictionaries
    are also mutable for the same reason. Numbers are immutable. If a variable `x`
    is referring to the number 3, and you assign 4 to `x`, you’ve made `x` refer to
    a different number (4), but you haven’t changed the number 3 itself; 3 still has
    to be 3\. Strings are also immutable. `list[n]` returns the *n*th element of `list`,
    `string[n]` returns the *n*th character of `string`, and `list[n] = value` changes
    the *n*th element of `list`, but `string[n] = character` is illegal in Python
    and causes an error, because strings in Python are immutable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，如前所述，任何可以修改的对象都称为**可变**。列表是可变的，因为列表元素可以添加、更改或删除。字典也是可变的，原因相同。数字是不可变的。如果变量`x`指向数字3，并将4赋值给`x`，那么你让`x`指向了不同的数字（4），但你并没有改变数字3本身；3仍然是3。字符串也是不可变的。`list[n]`返回`list`的*n*个元素，`string[n]`返回`string`的*n*个字符，而`list[n]
    = value`会更改`list`的*n*个元素，但在Python中`string[n] = character`是非法的，会导致错误，因为Python中的字符串是不可变的。
- en: Unfortunately, the requirement that keys be immutable and hashable means that
    lists can’t be used as dictionary keys, but in many instances, it would be convenient
    to have a listlike key. For example, it’s convenient to store information about
    a person under a key consisting of the person’s first and last names, which you
    could easily do if you could use a two-element list as a key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，键必须是不可变且可哈希的要求意味着列表不能用作字典键，但在许多情况下，有一个类似列表的键会非常方便。例如，在由人的名字和姓氏组成的键下存储有关一个人的信息会非常方便，如果你可以使用一个包含两个元素的列表作为键，你就可以轻松做到这一点。
- en: 'Python solves this difficulty by providing tuples, which are basically immutable
    lists; they’re created and used similarly to lists, except that once created,
    they can’t be modified. There’s one further restriction: Keys must also be hashable,
    which takes things a step further than just immutable. To be hashable, a value
    must have a hash value (provided by a `__hash__` method) that never changes throughout
    the life of the value. That means that tuples containing mutable values are *not*
    hashable, although the tuples themselves are technically immutable. Only tuples
    that don’t contain any mutable objects nested within them are hashable and valid
    to use as keys for dictionaries. [Table 7.2](#ch07table02) illustrates which of
    Python’s built-in types are immutable, hashable, and eligible to be dictionary
    keys.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过提供元组来解决这个难题，元组基本上是不可变列表；它们的创建和使用方式与列表相似，但一旦创建，就不能修改。还有一个进一步的限制：键也必须是可哈希的，这比仅仅是不可变更进一步。为了可哈希，一个值必须有一个哈希值（由`__hash__`方法提供），在整个值的生命周期中都不会改变。这意味着包含可变值的元组是不可哈希的，尽管元组本身在技术上是不变的。只有不包含嵌套任何可变对象的元组才是可哈希的，并且可以作为字典的键使用。[表7.2](#ch07table02)说明了Python的哪些内置类型是不可变的、可哈希的，并且可以作为字典键使用。
- en: Table 7.2\. Python values eligible to be used as dictionary keys
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.2\. 可以用作字典键的Python值
- en: '| Python type | Immutable? | Hashable? | Dictionary key? |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Python类型 | 不可变？ | 可哈希？ | 字典键？ |'
- en: '| --- | --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| int | Yes | Yes | Yes |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| int | 是 | 是 | 是 |'
- en: '| float | Yes | Yes | Yes |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| float | 是 | 是 | 是 |'
- en: '| boolean | Yes | Yes | Yes |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| boolean | 是 | 是 | 是 |'
- en: '| complex | Yes | Yes | Yes |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| complex | 是 | 是 | 是 |'
- en: '| str | Yes | Yes | Yes |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| str | 是 | 是 | 是 |'
- en: '| bytes | Yes | Yes | Yes |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| bytes | 是 | 是 | 是 |'
- en: '| bytearray | No | No | No |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| bytearray | 否 | 否 | 否 |'
- en: '| list | No | No | No |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| list | 否 | 否 | 否 |'
- en: '| tuple | Yes | Sometimes | Sometimes |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| tuple | 是 | 有时 | 有时 |'
- en: '| set | No | No | No |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| set | 否 | 否 | 否 |'
- en: '| frozenset | Yes | Yes | Yes |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| frozenset | 是 | 是 | 是 |'
- en: '| dictionary | No | No | No |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| dictionary | 否 | 否 | 否 |'
- en: The next sections give examples illustrating how tuples and dictionaries can
    work together.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几节将给出示例，说明元组和字典如何协同工作。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: What can be a key?'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：什么可以作为键？
- en: 'Decide which of the following expressions can be a dictionary key`: 1; ''bob'';
    (''tom'', [1, 2, 3]); ["filename"]; "filename"; ("filename", "extension")`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 判断以下哪个表达式可以是字典键：1；'bob'；('tom', [1, 2, 3])；["filename"]；"filename"；("filename",
    "extension")`
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.5\. Sparse matrices
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 稀疏矩阵
- en: In mathematical terms, a *matrix* is a two-dimensional grid of numbers, usually
    written in textbooks as a grid with square brackets on each side, as shown here.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度来看，*矩阵*是一个二维数字网格，通常在教科书中写成带有每边方括号的网格，如下所示。
- en: 'A fairly standard way to represent such a matrix is by means of a list of lists.
    In Python, a matrix is presented like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 表示这样的矩阵的一种相当标准的方式是通过列表的列表。在Python中，矩阵是这样表示的：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](images/0096fig01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](images/0096fig01.jpg)'
- en: 'Elements in the matrix can be accessed by row and column number:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过行号和列号访问矩阵中的元素：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But in some applications, such as weather forecasting, it’s common for matrices
    to be very large—thousands of elements to a side, meaning millions of elements
    in total. It’s also common for such matrices to contain many zero elements. In
    some applications, all but a small percentage of the matrix elements may be set
    to zero. To conserve memory, it’s common for such matrices to be stored in a form
    in which only the nonzero elements are actually stored. Such representations are
    called *sparse matrices*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些应用中，例如天气预报，矩阵可能非常大——每边有数千个元素，总共数百万个元素。这样的矩阵通常包含许多零元素。在某些应用中，除了小部分元素外，矩阵的所有元素都可能被设置为0。为了节省内存，这样的矩阵通常以只存储非零元素的形式存储。这种表示称为*稀疏矩阵*。
- en: 'It’s simple to implement sparse matrices by using dictionaries with tuple indices.
    For example, the previous sparse matrix can be represented as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用具有元组索引的字典，可以简单地实现稀疏矩阵。例如，前面的稀疏矩阵可以表示如下：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now you can access an individual matrix element at a given row and column number
    by this bit of code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过以下代码片段访问给定行和列编号的矩阵元素：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A slightly less clear (but more efficient) way of doing this is to use the
    dictionary `get` method, which you can tell to return `0` if it can’t find a key
    in the dictionary and otherwise return the value associated with that key, preventing
    one of the dictionary lookups:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微不那么清晰但更有效的方法是使用字典的`get`方法，你可以告诉它如果字典中找不到键，则返回`0`，否则返回与该键关联的值，从而避免一次字典查找：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you’re considering doing extensive work with matrices, you may want to look
    into `NumPy`, the numeric computation package.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑进行大量的矩阵工作，你可能想了解一下`NumPy`，这是一个数值计算包。
- en: 7.6\. Dictionaries as caches
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6. 字典作为缓存
- en: 'This section shows how dictionaries can be used as *caches*, data structures
    that store results to avoid recalculating those results over and over. Suppose
    that you need a function called `sole`, which takes three integers as arguments
    and returns a result. The function might look something like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分展示了如何使用字典作为*缓存*，这是一种存储结果以避免重复计算这些结果的数据结构。假设你需要一个名为`sole`的函数，它接受三个整数作为参数并返回一个结果。这个函数可能看起来像这样：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: But if this function is very time-consuming, and if it’s called tens of thousands
    of times, the program might run too slowly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这个函数非常耗时，并且被调用数十万次，程序可能会运行得太慢。
- en: 'Now suppose that `sole` is called with about 200 different combinations of
    arguments during any program run. That is, you might call `sole(12, 20, 6)` 50
    or more times during the execution of your program and similarly for many other
    combinations of arguments. By eliminating the recalculation of `sole` on identical
    arguments, you’d save a huge amount of time. You could use a dictionary with tuples
    as keys, like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设在程序运行期间`sole`被调用约200种不同的参数组合。也就是说，你可能在程序执行期间调用`sole(12, 20, 6)` 50次或更多，以及其他许多参数组合。通过消除对相同参数的`sole`重新计算，你可以节省大量时间。你可以使用具有元组键的字典，如下所示：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The rewritten `sole` function uses a global variable to store previous results.
    The global variable is a dictionary, and the keys of the dictionary are tuples
    corresponding to argument combinations that have been given to `sole` in the past.
    Then any time `sole` passes an argument combination for which a result has already
    been calculated, it returns that stored result rather than recalculating it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的`sole`函数使用全局变量来存储之前的结果。这个全局变量是一个字典，字典的键是之前给`sole`提供的参数组合的元组。然后，每当`sole`传递一个已经计算过结果的参数组合时，它会返回存储的结果而不是重新计算。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Using dictionaries'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：使用字典
- en: Suppose that you’re writing a program that works like a spreadsheet. How might
    you use a dictionary to store the contents of a sheet? Write some sample code
    to both store a value and retrieve a value in a particular cell. What might be
    some drawbacks to this approach?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个像电子表格一样的程序。你如何使用字典来存储表格的内容？请编写一些示例代码来存储和检索特定单元格的值。这种方法的潜在缺点可能有哪些？
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.7\. Efficiency of dictionaries
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7. 字典的效率
- en: If you come from a traditional compiled-language background, you may hesitate
    to use dictionaries, worrying that they’re less efficient than lists (arrays).
    The truth is that the Python dictionary implementation is quite fast. Many of
    the internal language features rely on dictionaries, and a lot of work has gone
    into making them efficient. Because all of Python’s data structures are heavily
    optimized, you shouldn’t spend much time worrying about which is faster or more
    efficient. If the problem can be solved more easily and cleanly by using a dictionary
    than by using a list, do it that way, and consider alternatives only if it’s clear
    that dictionaries are causing an unacceptable slowdown.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自传统的编译语言背景，你可能会犹豫使用字典，担心它们不如列表（数组）高效。事实是，Python 字典的实现相当快。许多内部语言特性都依赖于字典，并且已经投入了大量工作来提高它们的效率。由于Python的所有数据结构都经过了高度优化，你不应该花太多时间担心哪个更快或更高效。如果使用字典比使用列表更容易和更干净地解决问题，那就这样做，只有在明确字典会导致无法接受的性能下降时才考虑其他方案。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 7: Word Counting'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验7：单词计数
- en: In the previous lab, you took the text of the first chapter of *Moby Dick*,
    normalized the case, removed punctuation, and wrote the separated words to a file.
    In this lab, you read that file, use a dictionary to count the number of times
    each word occurs, and then report the most common and least common words.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个实验中，你取了《白鲸记》第一章的文本，标准化了大小写，移除了标点符号，并将分离的单词写入文件。在这个实验中，你读取那个文件，使用字典来计算每个单词出现的次数，然后报告最常见的和最不常见的单词。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Dictionaries are powerful data structures, used for many purposes even within
    Python itself.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典是强大的数据结构，在Python本身内部也被用于许多目的。
- en: Dictionary keys must be immutable, but any immutable object can be a dictionary
    key.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典键必须是不可变的，但任何不可变对象都可以作为字典键。
- en: Using keys means accessing collections of data more directly and with less code
    than many other solutions.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键意味着比许多其他解决方案更直接地访问数据集合，并且代码更少。
