- en: Appendix B. Introduction to Grunt
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B. Grunt简介
- en: Grunt is a tool that allows you to write, configure, and automate tasks—such
    as minifying a JavaScript file or compiling a LESS style sheet—for your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt是一个允许你编写、配置和自动化任务的工具——例如压缩JavaScript文件或编译LESS样式表——用于你的应用程序。
- en: 'LESS is a CSS preprocessor, which is covered in [chapter 2](kindle_split_013.html#ch02).
    Minifying is essentially creating a smaller file by removing white space and many
    syntax tree optimizations. These tasks can also be related to code quality, such
    as running unit tests (covered in [chapter 8](kindle_split_020.html#ch08)) or
    executing a code coverage tool such as JSHint. They could certainly be related
    to the deployment process: maybe deploying the application over FTP, or preparing
    to deploy it, generating API documentation.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LESS是一个CSS预处理器，在第2章[中介绍](kindle_split_013.html#ch02)。压缩基本上是通过删除空白和许多语法树优化来创建一个更小的文件。这些任务也可以与代码质量相关，例如运行单元测试（在第8章[中介绍](kindle_split_020.html#ch08)）或执行代码覆盖率工具，如JSHint。它们当然可以与部署过程相关：可能是通过FTP部署应用程序，或者准备部署，生成API文档。
- en: Grunt is merely a vehicle to execute your build tasks. These tasks are defined
    using plugins, as explained next.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt仅仅是执行你的构建任务的工具。这些任务使用插件定义，如下一部分所述。
- en: B.1\. Grunt plugins
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1. Grunt插件
- en: Grunt only provides the framework; you’re in charge of picking the right plugins
    to perform the tasks you need. For example, you might use the `grunt-contrib-concat`
    to bundle assets together. You also need to configure these plugins to do what
    you want; for example, providing a list of files to bundle and the path to the
    resulting bundled file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt只提供框架；你负责选择正确的插件来执行你需要的任务。例如，你可能使用`grunt-contrib-concat`来捆绑资源。你还需要配置这些插件以完成你想要的工作；例如，提供一个要捆绑的文件列表和结果捆绑文件的路径。
- en: Plugins can define one or more Grunt tasks. These plugins are written and configured
    using JavaScript on the Node platform. The Node community developed and maintains
    hundreds of ready-made Grunt plugins, which you only need to configure, as you’ll
    see in a moment. You can also create Grunt plugins yourself if you can’t find
    one that suits your particular needs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 插件可以定义一个或多个Grunt任务。这些插件使用Node平台上的JavaScript编写和配置。Node社区开发了数百个现成的Grunt插件，你只需要配置它们，就像你马上会看到的那样。如果你找不到适合你特定需求的插件，你也可以自己创建Grunt插件。
- en: B.2\. Tasks and targets
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2. 任务和目标
- en: Tasks can be configured to conform to multiple targets, and each target is defined
    by adding more data when configuring the task. A common use of task targets is
    to compile an application for different distributions, as explained in [chapter
    3](kindle_split_014.html#ch03). Targets are useful for reusing the same task for
    slightly different purposes. LESS is an expressive language that compiles to CSS.
    You might have LESS task targets that compile different parts of your application.
    Maybe you need to use different targets because one of them makes debugging easier
    for you by adding source maps that point to the original LESS code, while the
    other target might go as far as minifying your style sheet.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以被配置为符合多个目标，并且每个目标在配置任务时通过添加更多数据来定义。任务目标的一个常见用途是针对不同的发行版编译应用程序，如第3章[所述](kindle_split_014.html#ch03)。目标对于以略微不同的目的重复使用相同的任务非常有用。LESS是一种表达式丰富的语言，它编译成CSS。你可能会有LESS任务目标，用于编译应用程序的不同部分。也许你需要使用不同的目标，因为其中一个目标通过添加指向原始LESS代码的源映射来使调试更容易，而另一个目标可能将样式表压缩到最小。
- en: B.3\. Command-line interface
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3. 命令行界面
- en: 'Grunt comes with a command-line interface (CLI), called `grunt`, which you
    can use to run your tasks. As an example of how this tool works, let’s analyze
    the following statement:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt附带了一个命令行界面（CLI），称为`grunt`，你可以使用它来运行你的任务。为了分析这个工具的工作方式，让我们分析以下语句：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assuming you’ve already configured Grunt, which you’ll learn about in a moment,
    this statement would execute the `debug` target for the `less` task, and, if that
    task succeeded, then any targets configured for the `mocha` task would get executed.
    It’s important to note that if a Grunt task fails, Grunt won’t attempt to run
    any more tasks. Instead, it will exit after printing the reasons why it failed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经配置了Grunt，你将在下一部分了解它，这个语句将执行`less`任务的`debug`目标，如果该任务成功，那么为`mocha`任务配置的任何目标都将被执行。重要的是要注意，如果Grunt任务失败，Grunt不会尝试运行更多任务。相反，它将在打印失败原因后退出。
- en: 'It’s worth mentioning that tasks are executed serially: the next task begins
    once the current task finishes. They don’t run in parallel. Instead of giving
    the CLI a full task list every time, you can use task aliases: tasks that execute
    a list of tasks. If you use the special name `default` when creating an alias,
    then the tasks assigned to that alias will be run whenever the `grunt` CLI is
    executed without any task arguments.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，任务是以串行方式执行的：下一个任务只有在当前任务完成后才开始。它们不会并行运行。你不必每次都给 CLI 一个完整的任务列表，你可以使用任务别名：执行一系列任务的别名。如果你在创建别名时使用特殊名称
    `default`，那么分配给该别名的任务将在没有任务参数的情况下执行 `grunt` CLI。
- en: Enough theory! Let’s get our hands dirty with hands-on Grunting; you’ll start
    by installing Grunt and expand on all of the areas we’ve discussed. To install
    Grunt, the first thing you’ll need is Node, the platform Grunt works on. To install
    Node, head over to [appendix A](kindle_split_022.html#app01) on Node, and then
    get right back here. I’ll wait.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了！让我们通过实际操作来学习 Grunting；你将从安装 Grunt 开始，并扩展我们讨论的所有领域。要安装 Grunt，你首先需要 Node，这是
    Grunt 工作的平台。要安装 Node，请访问 [附录 A](kindle_split_022.html#app01)，然后立即回到这里。我会等待。
- en: 'Okay, let’s install the Grunt CLI. Using `npm` in your terminal, type the following
    command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们安装 Grunt CLI。在终端中使用 `npm`，输入以下命令：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `--global` flag tells `npm` that this isn’t a project-level package install,
    but rather a system-wide install. Essentially, this will ultimately enable you
    to use the package from your command line directly. You can verify the CLI was
    installed properly by running the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`--global` 标志告诉 `npm` 这不是一个项目级别的包安装，而是一个全局安装。本质上，这将最终使你能够直接从命令行使用该包。你可以通过运行以下命令来验证
    CLI 是否已正确安装：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That should output the version number for the currently installed version of
    the Grunt CLI. Great! Everything you did so far was a one-time thing; you don’t
    need to worry about doing any of those steps again. But how do you use Grunt?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出当前安装的 Grunt CLI 的版本号。太好了！你到目前为止所做的一切都是一次性的；你不需要担心再次执行这些步骤。但你是如何使用 Grunt
    的呢？
- en: B.4\. Using Grunt in a project
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4\. 在项目中使用 Grunt
- en: Let’s say you have a PHP web application (although the server-side language
    doesn’t matter), and you want to automatically run a linter, which is a static
    analysis tool that can tell you about issues with the syntax you’re using, whenever
    you change a JavaScript file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 PHP 网络应用程序（尽管服务器端语言并不重要），并且你想在更改 JavaScript 文件时自动运行一个代码检查器，这是一个静态分析工具，可以告诉你关于你使用的语法的错误。
- en: 'The first thing you’ll need is a `package.json` file in your project root.
    This is used by `npm` to keep a manifest of all the dependencies you have. This
    file doesn’t need much; it needs to be a valid JSON object, so `{}` will do. Change
    the directory to your application’s root directory and type the following into
    your terminal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要在项目根目录中有一个 `package.json` 文件。这个文件由 `npm` 使用来维护所有依赖项的清单。这个文件不需要太多；它需要是一个有效的
    JSON 对象，所以 `{}` 就可以了。将目录切换到你的应用程序根目录，并在终端中输入以下内容：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, you’ll have to install a few dependencies. You’ll install `grunt`, which
    is the framework itself, not to be confused with `grunt-cli`, which looks things
    up and defers task execution to the locally installed `grunt` package. To get
    started, you’ll also install `grunt-contrib-jshint`, an easy-to-configure task
    to run JSHint, a JavaScript lint tool, as a Grunt task. The `npm install` command
    allows you to install more than one package at once, so let’s do that:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将不得不安装一些依赖项。你需要安装 `grunt`，这是框架本身，不要与 `grunt-cli` 混淆，`grunt-cli` 用于查找内容并将任务执行委托给本地安装的
    `grunt` 包。要开始，你还需要安装 `grunt-contrib-jshint`，这是一个易于配置的任务，可以将 JSHint（一个 JavaScript
    代码检查工具）作为 Grunt 任务运行。`npm install` 命令允许你一次性安装多个包，所以让我们这样做：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `--save-dev` flag tells `npm` to include these packages in the `package.json`
    manifest, and tag them as development dependencies. It’s a best practice to mark
    as a development dependency anything that shouldn’t be executed in production
    servers. Build components should always run before executing the application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save-dev` 标志告诉 `npm` 将这些包包含在 `package.json` 清单中，并将它们标记为开发依赖项。将不应在生产服务器上执行的内容标记为开发依赖项是一种最佳实践。构建组件应始终在执行应用程序之前运行。'
- en: You have the framework, the plugin, and the CLI; all that’s missing is configuring
    the tasks, so you can start using Grunt.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了框架、插件和 CLI；唯一缺少的是配置任务，这样你就可以开始使用 Grunt 了。
- en: B.5\. Configuring Grunt
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5\. 配置 Grunt
- en: 'To configure Grunt, you need to create a `Gruntfile.js` file. That’s where
    all your build task configuration and definitions will live. The following code
    is an example `Gruntfile.js`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Grunt，你需要创建一个`Gruntfile.js`文件。所有你的构建任务配置和定义都将存储在这里。以下是一个示例`Gruntfile.js`：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As explained in [appendix A](kindle_split_022.html#app01) on Node.js, where
    we discussed Common.JS modules, here the module exports a function, which Grunt
    will invoke, configuring your tasks. The `initConfig` method takes an object,
    which will serve as the configuration for all of your different tasks and targets.
    Each top-level property in this configuration object represents configuration
    for a particular task. For example, `jshint` contains the configuration for the
    `jshint` task. Properties in each task’s configuration represent target configuration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如附录A（kindle_split_022.html#app01）中所述，我们在其中讨论了Common.JS模块，这里模块导出一个函数，Grunt将调用该函数来配置你的任务。`initConfig`方法接受一个对象，该对象将作为所有不同任务和目标的配置。这个配置对象中的每个顶级属性代表特定任务的配置。例如，`jshint`包含`jshint`任务的配置。每个任务配置中的属性代表目标配置。
- en: In this case, you’re configuring the `browser` target for `jshint` to `['public/js/**/*.js']`.
    This is called a globbing pattern, and it’s used to declare which files to target.
    You’ll learn all about globbing patterns in a moment; for now it should suffice
    to say that it’ll match any `.js` files in `public/js` or in a subdirectory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你正在为`jshint`的`browser`目标配置`['public/js/**/*.js']`。这被称为文件匹配模式，它用于声明要针对哪些文件。你稍后将会学到所有关于文件匹配模式的知识；现在只需说它将匹配`public/js`或其子目录中的任何`.js`文件就足够了。
- en: The `loadNpmTasks` method tells Grunt, “Hey, load any tasks you can find in
    this Grunt plugin,” so it’s essentially loading the `jshint` task. You’ll learn
    how to write your own tasks later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadNpmTasks`方法告诉Grunt，“嘿，加载你在这个Grunt插件中能找到的所有任务”，所以它本质上是在加载`jshint`任务。你稍后会学到如何编写自己的任务。'
- en: Last, `registerTask` can define task aliases by passing it a task name and an
    array of tasks it should execute. You’ll set it to `jshint` so it will run `jshint:browser`
    and any other `jshint` targets you might add in the future. The default name means
    that this task will be run whenever you execute `grunt` with no task arguments
    in the command line. Let’s try that!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`registerTask`可以通过传递一个任务名称和应该执行的任务数组来定义任务别名。你将把它设置为`jshint`，这样它就会运行`jshint:browser`以及你未来可能添加的任何其他`jshint`目标。默认名称意味着当你不提供任务参数在命令行中执行`grunt`时，这个任务将会运行。让我们试试看！
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Congratulations, you’ve executed your first Grunt task! However, you’re probably
    confused about the whole “globbing for files” thing; let’s fix that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经执行了你的第一个Grunt任务！然而，你可能对整个“文件匹配”的概念感到困惑；让我们来解决这个问题。
- en: B.6\. Globbing patterns
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.6. 文件匹配模式
- en: Using patterns such as `['public/js/**/*.js']` helps quickly define what files
    to work with. These patterns are easy to follow, as long as you understand how
    to use them appropriately. Glob allows you to write plain text to refer to real
    file system paths. For example, you could use `docs/api.txt` without any special
    characters, and that would match the file at `docs/api.txt`. Note that this is
    a relative path, and that it’ll be relative to your `Gruntfile.`
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如`['public/js/**/*.js']`这样的模式可以帮助快速定义要处理的文件。只要你能适当地理解如何使用它们，这些模式就很容易遵循。Glob允许你使用纯文本来引用真实的文件系统路径。例如，你可以使用`docs/api.txt`而不需要任何特殊字符，这将匹配`docs/api.txt`中的文件。请注意，这是一个相对路径，并且它将相对于你的`Gruntfile.js`。
- en: 'If you add special characters into the mix, things get interesting. For instance,
    changing your last example to `docs/*.txt` helps us match all text files in the
    `docs` directory. If you’d like to include subdirectories as well, then you need
    to use `**`, known as the globstar pattern: `docs/**/*.txt`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你混合了特殊字符，事情就变得有趣了。例如，将你的最后一个例子改为`docs/*.txt`可以帮助我们匹配`docs`目录中的所有文本文件。如果你想包括子目录，那么你需要使用`**`，也就是globstar模式：`docs/**/*.txt`。
- en: B.6.1\. Brace expressions
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.1. 大括号表达式
- en: 'Then there’s brace expansion. Suppose you want to match many different types
    of images; you might want to use something akin to the following pattern: `images/*.{png,gif,jpg}`.
    That’d match any images ending in `.png`, `.gif`, and `.jpg`. It’s not limited
    to extensions, although that’s the most common use case. You could also use brace
    expansion to match different directories: `public/{js,css}/**/*`. Note that we’re
    excluding the extension. That works fine; the star will match any file type and
    not be limited to one in particular.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是括号展开。假设你想匹配多种不同类型的图像；你可能想使用以下模式：`images/*.{png,gif,jpg}`。这将匹配以 `.png`、`.gif`
    和 `.jpg` 结尾的任何图像。它不仅限于扩展名，尽管这是最常见的情况。你也可以使用括号展开来匹配不同的目录：`public/{js,css}/**/*`。请注意，我们排除了扩展名。这没问题；星号将匹配任何文件类型，而不仅限于特定的一种。
- en: B.6.2\. Negation expressions
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.2\. 否定表达式
- en: 'Last, there are negation expressions and these are somewhat tricky to get right.
    *Negation expressions* can be defined as “remove the matching results from what
    you’ve matched so far.” Patterns are processed in order, so inclusion and exclusion
    order is significant. Negation patterns begin with an `!.` Here’s a common use
    case: `[''js/**/*.js'', ''!js/vendor/**/*.js'']`. That says, “Include everything
    that’s in the `js` directory, but not if it’s in `js/vendor`.” That’s useful for
    linting code you’ve authored, while leaving third-party libraries alone.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有否定表达式，这些表达式有些难以正确使用。*否定表达式*可以定义为“从你之前匹配的内容中移除匹配的结果。”模式按顺序处理，因此包含和排除的顺序很重要。否定模式以
    `!.` 开头。这里有一个常见的用例：`['js/**/*.js', '!js/vendor/**/*.js']`。这意味着，“包含 `js` 目录中的所有内容，但如果不包含在
    `js/vendor` 中。”这对于检查你编写的代码很有用，同时保持第三方库不变。
- en: 'There’s one particular caveat of globbing I’d like to address; I often read
    people complaining about `[''js'', ''!js/vendor'']` “not working,” and the reason
    for that is rather simple to understand now that you know how globbing works.
    The first globbing pattern will match the `js` directory itself, and the `!js/vendor`
    won’t do anything. Later, the `js` directory will be expanded to every file in
    it, including those in `js/vendor`. A quick fix to this issue is to have the Globber
    expand the directories for you, using globstars: `[''js/**/*.js'', ''!js/vendor/**'']`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我想特别指出 globbing 中的一个注意事项；我经常看到有人抱怨 `['js', '!js/vendor']` “不起作用”，现在你知道了 globbing
    的工作原理，这个原因就很容易理解了。第一个 globbing 模式会匹配 `js` 目录本身，而 `!js/vendor` 不会做任何事情。稍后，`js`
    目录将扩展到其中的每个文件，包括 `js/vendor` 中的文件。解决这个问题的一个快速方法是让 Globber 为你展开目录，使用 globstars：`['js/**/*.js',
    '!js/vendor/**']`。
- en: 'There are two more topics for you to gulp down: configuring tasks and creating
    your own ones. Let’s go ahead and see how we can configure Grunt to run a task
    from the ground up.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个主题需要你掌握：配置任务和创建自己的任务。让我们继续看看如何从头开始配置 Grunt 来运行任务。
- en: B.7\. Setting up a task
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.7\. 设置任务
- en: 'Now you’re going to learn how to set up a random task...by browsing the internet!
    As a quick-start trick, let’s go back to the original example from [section B.1](#app02lev1sec1).
    Remember how you configured it to run JSHint? Here’s the code you used:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将学习如何通过浏览互联网来设置一个随机任务...作为一个快速入门技巧，让我们回到 [B.1 节](#app02lev1sec1) 的原始示例。记得你是如何配置它来运行
    JSHint 的吗？这里是你使用的代码：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s suppose you want to minify (covered in [chapter 2](kindle_split_013.html#ch02))
    your CSS style sheets, and then concatenate them into a single file. You could
    Google around for grunt plugins to do that, or you might visit [http://gruntjs.com/plugins](http://gruntjs.com/plugins)
    and look around for yourself. Go ahead and visit that page and then type `css`.
    One of the first results you’ll see is `grunt-contrib-cssmin`, and it’ll link
    to the page for that package on the `npm` website.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想压缩（在第 2 章中介绍）你的 CSS 样式表，并将它们合并成一个文件。你可以搜索 Google 上的 grunt 插件来做这件事，或者你可能访问
    [http://gruntjs.com/plugins](http://gruntjs.com/plugins) 并自行查找。前往那个页面，然后输入 `css`。你将看到的第一项结果之一是
    `grunt-contrib-cssmin`，它将链接到该软件包在 `npm` 网站上的页面。
- en: 'On `npm`, you’ll usually find detailed README files, and links to the complete
    source code on GitHub repositories. In this case, it instructs you to install
    the package from `npm` and add a `loadNpmTasks` to your `Gruntfile.js`, as shown
    in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `npm` 上，你通常会找到详细的 README 文件，以及指向 GitHub 仓库中完整源代码的链接。在这种情况下，它指导你从 `npm` 安装该软件包，并将
    `loadNpmTasks` 添加到你的 `Gruntfile.js` 中，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You’d also have to install the package from `npm`, the way you did with `grunt-contrib-jshint`
    earlier:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须以与之前安装 `grunt-contrib-jshint` 时相同的方式从 `npm` 安装该软件包：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now all you need to do is to configure it. Grunt projects are usually well documented,
    giving you a few configuration examples on their home pages, as well as detailed
    lists of all the options available to them. Packages named `grunt-contrib-*` were
    developed by the team behind Grunt itself, so they should mostly work without
    any problems. When canvassing for the right package for a task, move on if something
    doesn’t work, or isn’t well documented. You don’t have to marry them. Popularity
    (npm installs and GitHub stars) are good indicators of how good a package is.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要进行配置。Grunt项目通常有很好的文档，在它们的首页上提供了几个配置示例，以及所有可用选项的详细列表。名为`grunt-contrib-*`的包是由Grunt本身背后的团队开发的，所以它们应该基本上没有问题就能正常工作。在寻找适合任务的正确包时，如果某个包不起作用或者文档不完善，就继续寻找。你不必非得选择它们。流行度（npm安装和GitHub星标）是衡量一个包好坏的好指标。
- en: 'It turns out that the first use example shows that you can also concatenate
    your CSS with this package, so you don’t need an extra task to do that. Here’s
    that example, showing how you can combine two files while minifying them using
    `grunt-contrib-cssmin`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，第一个使用示例显示你也可以使用这个包来连接你的CSS，因此你不需要额外的任务来做这件事。以下是一个示例，展示了如何使用`grunt-contrib-cssmin`在压缩的同时合并两个文件：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can easily adapt and integrate that with your needs. You’ll also add a
    `build` task alias. Aliases are useful for defining workflows, as you’ll see throughout
    [part 1](kindle_split_011.html#part01). For instance, [chapter 3](kindle_split_014.html#ch03)
    uses them to define the debug and release workflows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地根据你的需求进行修改和整合。你还将添加一个`build`任务别名。别名对于定义工作流程非常有用，正如你将在[第一部分](kindle_split_011.html#part01)中看到的。例如，[第三章](kindle_split_014.html#ch03)使用它们来定义调试和发布工作流程：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That’s it! If you run `grunt build` in your terminal, it’ll bundle your CSS
    together and then minify it, writing it to the `all.min.css` file. You can find
    this example, along with the others we’ve discussed so far, in the accompanying
    source code samples, under `appendix/introduction-to-grunt`. Let’s wrap up this
    appendix by explaining how you can write your own Grunt task.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你在终端中运行`grunt build`，它将把你的CSS文件捆绑在一起，然后进行压缩，并将结果写入`all.min.css`文件。你可以在附带的源代码示例中找到这个示例，以及其他我们之前讨论过的示例，在`appendix/introduction-to-grunt`部分。让我们通过解释如何编写你自己的Grunt任务来结束这个附录。
- en: B.8\. Creating custom tasks
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.8\. 创建自定义任务
- en: 'Grunt has two kinds of tasks: multitasks and regular tasks. The difference,
    as you might suspect, is that multitasks allow consumers to set up different task
    targets and run them individually. In practice, almost all Grunt tasks are multitasks.
    Let’s walk through creating one!'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt有两种任务：多任务和常规任务。正如你可能猜到的，多任务允许消费者设置不同的任务目标并单独运行它们。在实践中，几乎所有的Grunt任务都是多任务。让我们一步一步地创建一个多任务！
- en: 'You’ll create a task that can count words in a list of files, and then have
    it fail if it counts more words than what it expected. To begin with, let’s glance
    at this piece of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个可以统计文件列表中单词数量的任务，并且如果统计的单词数量超过了预期，任务将失败。首先，让我们快速浏览一下这段代码：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, you’re setting a default value for the `threshold` option, which can
    be overwritten when the task gets configured, as you’ll see in a minute. Because
    you used `registerMultiTask`, you can support multiple task targets. Now you need
    to go through the list of files, read them, and count the words in them:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在为`threshold`选项设置一个默认值，这个值在任务配置时可以被覆盖，正如你将在下一分钟看到的。因为你使用了`registerMultiTask`，你可以支持多个任务目标。现在你需要遍历文件列表，读取它们，并计算其中的单词数量：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Grunt will provide a `files` object, which you can use to loop through the
    files, filtering out the directories and reading data out of the files. Once you’ve
    computed the word counts, you can print the result and fail if the `threshold`
    was exceeded:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt将提供一个`files`对象，你可以使用它来遍历文件，过滤掉目录，并从文件中读取数据。一旦你计算出了单词数量，你可以打印结果，如果`threshold`被超过则失败：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Last, all you have to do is configure a task target, the way you did before:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需要像之前那样配置一个任务目标：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the word count for all those files is more than 3,000, the task will fail.
    Note that if you hadn’t provided a threshold, it would use the default value of
    `0`, which you specified in the task. This is enough information to understand
    Grunt, which we introduced in [chapter 1](kindle_split_012.html#ch01). In [chapter
    2](kindle_split_013.html#ch02), you’ll get a deeper knowledge of build tasks themselves,
    how those should work, and how you can compose tasks to create a build workflow
    for development and another one for releases and deployments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些文件的总字数超过3,000字，任务将失败。请注意，如果您没有提供阈值，它将使用默认值`0`，这是您在任务中指定的。这些信息足以理解我们在[第1章](kindle_split_012.html#ch01)中介绍的Grunt。在[第2章](kindle_split_013.html#ch02)中，您将更深入地了解构建任务本身，它们应该如何工作，以及您如何组合任务来创建用于开发和发布及部署的构建工作流程。
