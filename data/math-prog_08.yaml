- en: 7 Solving systems of linear equations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 解决线性方程组
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Detecting collisions of objects in a 2D video game
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在2D视频游戏中检测物体碰撞
- en: Writing equations to represent lines and finding where lines intersect in the
    plane
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写方程来表示直线，并找到平面上直线的交点
- en: Picturing and solving systems of linear equations in 3D or beyond
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3D或更高维度中描绘和解决线性方程组
- en: Rewriting vectors as linear combinations of other vectors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将向量重写为其他向量的线性组合
- en: When you think of algebra, you probably think of problems that require “solving
    for *x*.” For instance, you probably spent quite a bit of time in algebra class
    learning to solve equations like 3*x*² + 2*x* + 4 = 0; that is, figuring out what
    value or values of *x* make the equation true.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到代数时，你可能想到需要“解出 *x*”的问题。例如，你可能花了相当多的时间在代数课上学习如何解方程 3*x*² + 2*x* + 4 = 0；也就是说，找出哪些
    *x* 的值可以使方程成立。
- en: Linear algebra, being a branch of algebra, has the same kinds of computational
    questions. The difference is that what you want to solve for may be a vector or
    matrix rather than a number. If you take a traditional linear algebra course,
    you might cover a lot of algorithms to solve these kinds of problems. But because
    you have Python at your disposal, you only need to know how to recognize the problem
    you’re facing and choose the right library to find the answer for you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数作为代数的一个分支，具有相同类型的计算问题。不同之处在于你想要解决的问题可能是一个向量或矩阵，而不是一个数字。如果你参加传统的线性代数课程，你可能会覆盖很多算法来解决这类问题。但因为你手头有Python，你只需要知道如何识别你面临的问题，并选择合适的库来为你找到答案。
- en: 'I’m going to cover the most important class of linear algebra problems you’ll
    see in the wild: *systems of linear equations*. These problems boil down to finding
    points where lines, planes, or their higher dimensional analogies intersect. One
    example is the infamous high school math problem involving two trains leaving
    Boston and New York at different times and speeds. But because I don’t assume
    railroad operation interests you, I’ll use a more entertaining example.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍你在现实世界中会遇到的最重要一类线性代数问题：*线性方程组*。这些问题归结为找到直线、平面或其更高维的类似物相交的点。一个例子是臭名昭著的高中数学问题，涉及两列火车在不同时间和速度下从波士顿和纽约出发。但由于我不假设你对铁路运营感兴趣，我将使用一个更有趣的例子。
- en: In this chapter, we build a simple remake of the classic Asteroids arcade game
    (figure 7.1). In this game, the player controls a triangle representing a spaceship
    and fires a laser at polygons floating around it, which represent asteroids. The
    player must destroy the asteroids to prevent them from hitting and destroying
    the spaceship.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个经典的《小行星》街机游戏的简单重制（图7.1）。在这个游戏中，玩家控制一个代表宇宙飞船的三角形，并向漂浮在其周围的代表小行星的多边形发射激光。玩家必须摧毁小行星，以防止它们撞击并摧毁宇宙飞船。
- en: '![](../Images/CH07_F01_Orland.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F01_Orland.png)'
- en: Figure 7.1 Setup of the classic Asteroids arcade game
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 经典《小行星》街机游戏的设置
- en: One of the key mechanics in this game is deciding whether the laser hits an
    asteroid. This requires us to figure out whether the line defining the laser beam
    intersects with the line segments outlining the asteroids. If these lines intersect,
    the asteroid is destroyed. We’ll set up the game first, and then we’ll see how
    to solve the underlying linear algebra problem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的关键机制之一是判断激光是否击中了一颗小行星。这需要我们弄清楚定义激光束的直线是否与勾勒小行星的线段相交。如果这些直线相交，小行星将被摧毁。我们首先设置游戏，然后我们将看到如何解决背后的线性代数问题。
- en: After we implement our game, I’ll show you how this 2D example generalizes to
    3D or any number of dimensions. The latter half of this chapter covers a bit more
    theory, but it will round out your linear algebra education. We’ll have covered
    many of the major concepts you’d find in a college-level linear algebra class,
    albeit in less depth. After completing this chapter, you should be well prepared
    to crack open a denser textbook on linear algebra and fill in the details. But
    for now, let’s focus on building our game.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现游戏之后，我将向你展示这个2D示例如何推广到3D或任何数量的维度。本章的后半部分涵盖了一些更多的理论，但它将完善你的线性代数教育。我们将涵盖许多你在大学水平的线性代数课程中会找到的主要概念，尽管深度不如。完成本章后，你应该为打开一本更密集的线性代数教科书并填补细节做好了充分准备。但就目前而言，让我们专注于构建我们的游戏。
- en: 7.1 Designing an arcade game
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 设计街机游戏
- en: In this chapter, I focus on a simplified version of the asteroid game where
    the ship and asteroids are static. In the source code, you’ll see that I already
    made the asteroids move, and we’ll cover how to make them move according to the
    laws of physics in part
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我专注于一个简化的版本的小行星游戏，其中飞船和小行星是静态的。在源代码中，你会发现我已经使小行星移动，我们将在第二部分介绍如何根据物理定律使它们移动。
- en: 2 of this book. To get started, we model the entities of the game−the spaceship,
    the laser, and the asteroids−and show how to render them onscreen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2 本书。为了开始，我们建模游戏实体——飞船、激光和小行星——并展示如何在屏幕上渲染它们。
- en: 7.1.1 Modeling the game
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 游戏建模
- en: In this section, we display the spaceship and the asteroids as polygons in the
    game. As before, we model these as collections of vectors. For instance, we can
    represent an eight-sided asteroid by eight vectors (indicated by arrows in figure
    7.2), and we can connect them to draw its outline.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将飞船和小行星作为游戏中的多边形显示。与之前一样，我们将它们建模为向量的集合。例如，我们可以用八个向量（如图7.2中的箭头所示）表示一个八边形小行星，并将它们连接起来绘制其轮廓。
- en: '![](../Images/CH07_F02_Orland.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F02_Orland.png)'
- en: Figure 7.2 An eight-sided polygon representing an asteroid
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 代表小行星的八边形
- en: 'The asteroid or spaceship translates or rotates as it travels through space,
    but its shape remains the same. Therefore, we store the vectors representing this
    shape separately from the *x* − and *y*-coordinates of its center, which can change
    over time. We also store an angle, indicating the rotation of the object at the
    current moment. The `PolygonModel` class represents a game entity (the ship or
    an asteroid) that keeps its shape but can translate or rotate. It’s initialized
    with a set of vector points that define the outline of the asteroid, and by default,
    its center *x* − and *y*-coordinates and its angle of rotation are set to zero:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 小行星或宇宙飞船在穿越太空时会进行平移或旋转，但其形状保持不变。因此，我们将表示这种形状的向量与中心点的 *x* 和 *y* 坐标分开存储，这些坐标会随时间变化。我们还存储一个角度，表示物体在当前时刻的旋转角度。`PolygonModel`
    类代表一个游戏实体（飞船或小行星），它保持其形状但可以进行平移或旋转。它通过一组定义小行星轮廓的向量点进行初始化，默认情况下，其中心 *x* 和 *y* 坐标及其旋转角度被设置为零：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the spaceship or asteroid moves, we need to apply the translation by `self
    .x,self.y` and the rotation by `self.rotation_angle` to find out its actual location.
    As an exercise, you can give `PolygonModel` a method to compute the actual, transformed
    vectors outlining it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当飞船或小行星移动时，我们需要通过 `self .x,self.y` 应用平移，并通过 `self.rotation_angle` 应用旋转，以找出其实际位置。作为一个练习，你可以给
    `PolygonModel` 添加一个方法来计算围绕其实际变换的向量。
- en: 'The spaceship and asteroids are specific cases of `PolygonModel` that initialize
    automatically with their respective shapes. For instance, the ship has a fixed
    triangular shape, given by three points:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船和小行星是 `PolygonModel` 的特例，它们会自动初始化为各自的形状。例如，飞船具有固定的三角形形状，由三个点给出：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the asteroid, we initialize it with somewhere between 5 and 9 vectors at
    equally spaced angles and random lengths between 0.5 and 1.0\. This randomness
    gives the asteroids some character:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小行星，我们通过在等间距的角度和0.5到1.0之间的随机长度下初始化5到9个向量。这种随机性赋予了小行星一些特征：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ An asteroid has a random number of sides between 5 and 9.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 小行星具有介于5到9之间的随机边数。
- en: ❷ Lengths are randomly selected between 0.5 and 1.0, and the angles are multiples
    of 2*π*/n, where n is the number of sides.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 长度在0.5和1.0之间随机选择，角度是2*π*/n的倍数，其中n是边的数量。
- en: With these objects defined, we can turn our attention to instantiating them
    and rendering them onscreen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些对象后，我们可以将它们实例化并在屏幕上渲染。
- en: 7.1.2 Rendering the game
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 渲染游戏
- en: 'For the initial state of the game, we need a ship and several asteroids. The
    ship can begin at the center of the screen, but the asteroids should be randomly
    spread out over the screen. We can show an area of the plane ranging from −10
    to 10 in the *x* and *y* directions like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏的初始状态，我们需要一艘飞船和几个小行星。飞船可以开始于屏幕中心，但小行星应该在屏幕上随机分布。我们可以显示一个平面区域，范围从-10到10，在
    *x* 和 *y* 方向上如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates a list of a specified number of Asteroid objects, in this case, 10
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个指定数量的 Asteroid 对象列表，在这种情况下，10个
- en: ❷ Sets the position of each object to a random point with coordinates between
    −10 and 10 so it shows up onscreen
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将每个对象的位置设置为介于-10和10之间的随机点，以便在屏幕上显示
- en: I use a 400×400 pixel screen, which requires transforming the *x* − and *y*-coordinates
    before rendering them. Using PyGame’s built-in 2D graphics instead of OpenGL,
    the top left pixel on the screen has the coordinate (0, 0) and the bottom right
    has the coordinate (400, 400). These coordinates are not only bigger, they’re
    also translated and upside down, so we need to write a `to_pixels` function (illustrated
    in figure 7.3) that does the transformation from our coordinate system to PyGame’s
    pixels.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用一个400×400像素的屏幕，这需要在渲染之前将*x*和*y*坐标进行转换。使用PyGame内置的2D图形而不是OpenGL，屏幕左上角的像素坐标是(0,
    0)，右下角是(400, 400)。这些坐标不仅更大，而且它们是平移的，并且是颠倒的，因此我们需要编写一个`to_pixels`函数（如图7.3所示）来完成从我们的坐标系到PyGame像素的转换。
- en: '![](../Images/CH07_F03_Orland.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F03_Orland.png)'
- en: Figure 7.3 The `to_pixels` function maps an object from the center of our coordinate
    system to the center of the PyGame screen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 `to_pixels`函数将对象从我们的坐标系中心映射到PyGame屏幕中心。
- en: 'With the `to_pixels` function implemented, we can write a function to draw
    a polygon defined by points to the PyGame screen. First, we take the transformed
    points (translated and rotated) that define the polygon and convert them to pixels.
    Then we draw them with a PyGame function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`to_pixels`函数，我们可以编写一个函数将定义多边形的点绘制到PyGame屏幕上。首先，我们取定义多边形的变换点（平移和旋转），并将它们转换为像素。然后，我们使用PyGame函数绘制它们：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Draws lines connecting given points to a specified PyGame object. The True
    parameter connects the first and last points to create a closed polygon.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制连接给定点到指定PyGame对象的线条。True参数将第一个和最后一个点连接起来，创建一个封闭的多边形。
- en: You can see the whole game loop in the source code, but it basically calls `draw_poly`
    for the ship and each asteroid every time a frame is rendered. The result is our
    simple triangular spaceship surrounded by an asteroid field in a PyGame window
    (figure 7.4).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源代码中看到整个游戏循环，但基本上每次渲染帧时都会调用`draw_poly`函数来绘制船和每个小行星。结果是我们在PyGame窗口中的简单三角形太空船，周围环绕着小行星场（如图7.4）。
- en: '![](../Images/CH07_F04_Orland.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F04_Orland.png)'
- en: Figure 7.4 The game rendered in a PyGame window
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 在PyGame窗口中渲染的游戏
- en: 7.1.3 Shooting the laser
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 射击激光
- en: 'Now it’s time for the most important part: giving our ship a way to defend
    itself! The player should be able to aim the ship using the left and right arrow
    keys and then shoot a laser by pressing the spacebar. The laser beam should come
    out of the tip of the spaceship and extend to the edge of the screen.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是至关重要的部分：给我们的船提供一种防御方式！玩家应该能够使用左右箭头键瞄准船，然后按空格键发射激光。激光束应该从太空船的尖端发出，延伸到屏幕的边缘。
- en: 'In the 2D world we’ve invented, the laser beam should be a line segment starting
    at the *transformed* tip of the spaceship and extending in whatever direction
    the ship is pointed. We can make sure it reaches the end of the screen by making
    it sufficiently long. Because the laser’s line segment is associated with the
    state of the `Ship` object, we can make a method on the `Ship` class to compute
    it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发明的2D世界中，激光束应该是一条从太空船的*变换*尖端开始，并指向船所指方向的线段。我们可以通过使其足够长来确保它达到屏幕的末端。因为激光的线段与`Ship`对象的状态相关联，我们可以在`Ship`类中创建一个方法来计算它：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Uses the Pythagorean theorem to find the longest segment that fits onscreen
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用勾股定理找到适合屏幕的最长线段
- en: ❷ Gets the value of the first of the definition points (the tip of the ship)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取定义点中的第一个值（船的尖端）
- en: ❸ Uses trigonometry to find an endpoint for the laser if it extends dist units
    from the tip (x,y) at a self.rotation_angle (figure 7.5)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用三角学找到激光如果从尖端（x,y）延伸dist单位，在self.rotation_angle角度的终点（如图7.5）
- en: '![](../Images/CH07_F05_Orland.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F05_Orland.png)'
- en: Figure 7.5 Using trigonometry to find the off-screen point where the laser beam
    ends
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 使用三角学找到激光束结束的屏幕外点
- en: 'In the source code, you can see how to make PyGame respond to keystrokes and
    draw the laser as a line segment only if the spacebar is pressed. Finally, if
    the player fires the laser and hits an asteroid, we want to know something happened.
    In every iteration of the game loop, we want to check each asteroid to see if
    it is currently hit by the laser. We do this with a `does_intersect(segment)`
    method on the `PolygonModel` class, which computes whether the input segment intersects
    any segment of the given `PolygonModel`. The final code includes some lines like
    the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，你可以看到如何让PyGame响应按键并仅在按下空格键时将激光绘制为线段。最后，如果玩家发射激光并击中了一颗小行星，我们想知道发生了什么。在游戏循环的每一次迭代中，我们都要检查每一颗小行星是否被激光击中。我们通过`PolygonModel`类上的`does_intersect(segment)`方法来完成这项工作，该方法计算输入线段是否与给定的`PolygonModel`的任何线段相交。最终的代码包括以下类似的几行：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Calculates the line segment representing the laser beam based on the ship’s
    current position and orientation
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据飞船的当前位置和方向计算代表激光束的线段
- en: ❷ Detects which keys are pressed. If the spacebar is pressed, renders the laser
    beam to the screen with a helper function draw_segment (similar to draw_poly).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检测哪些键被按下。如果按下空格键，则使用辅助函数draw_segment（类似于draw_poly）将激光束渲染到屏幕上。
- en: ❸ For every asteroid, checks whether the laser line segment intersects it. If
    so, destroys the given asteroid by removing it from the list of asteroids.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于每一颗小行星，检查激光线段是否与之相交。如果是这样，通过从小行星列表中删除它来销毁给定的小行星。
- en: The work that remains is implementing the `does_intersect(segment)` method.
    In the next section, we cover the math to do so.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是实现`does_intersect(segment)`方法。在下一节中，我们将介绍实现该方法的数学原理。
- en: 7.1.4 Exercises
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 练习
- en: '| **Exercise 7.1**: Implement *a* `transformed()` method on the `PolygonModel`
    that returns the points of the model translated by the object’s *x* and *y* attributes
    and rotated by its `rotation_angle` attribute.**Solution**: Make sure to apply
    the rotation first; otherwise, the translation vector is rotated by the angle
    as well; for example,'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.1**：在`PolygonModel`上实现一个`transformed()`方法，该方法返回模型通过对象的*x*和*y*属性平移以及通过其`rotation_angle`属性旋转的点。**解决方案**：确保首先应用旋转；否则，平移向量也会被旋转角度旋转；例如，'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 7.2**: Write a function `to_pixels(x,y)` that takes a pair of
    *x* − and *y*-coordinates in the square where −10 < *x* < 10 and −10 < *y* < 10
    and maps them to the corresponding PyGame *x* and *y* pixel coordinates, each
    ranging from 0 to 400.**Solution**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.2**：编写一个函数`to_pixels(x,y)`，它接受在-10 < x < 10 和 -10 < y < 10的正方形中的*x*和*y*坐标对，并将它们映射到相应的PyGame
    *x*和*y*像素坐标，每个坐标的范围从0到400。**解决方案**：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 7.2 Finding intersection points of lines
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 线的交点查找
- en: The problem at hand is to decide whether the laser beam hits the asteroid. To
    do this, we’ll look at each line segment defining the asteroid and decide whether
    it intersects with the segment defining the laser beam. There are a few algorithms
    we could use, but we’ll solve this as a *system of linear equations in two variables*.
    Geometrically, this means looking at the lines defined by an edge of the asteroid
    and the laser beam and seeing where they intersect (figure 7.6).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的问题是判断激光束是否击中小行星。为此，我们将查看定义小行星的每个线段，并判断它是否与定义激光束的线段相交。我们可以使用几种算法，但我们将将其作为一个*两个变量的线性方程组*来解决这个问题。从几何学的角度来看，这意味着查看由小行星的边缘和激光束定义的直线，并观察它们的交点（图7.6）。
- en: '![](../Images/CH07_F06_Orland.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F06_Orland.png)'
- en: Figure 7.6 The laser hitting an edge of an asteroid (left) and the corresponding
    system of linear equations (right)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 激光击中小行星的边缘（左侧）以及相应的线性方程组（右侧）
- en: Once we know the location of the intersection, we can see whether it lies within
    the bounds of both segments. If so, the segments collide and the asteroid is hit.
    We first review equations for lines in the plane, then cover how to find where
    pairs of lines intersect. Finally, we write the code for the `does_intersect`
    method for our game.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了交点的位置，我们就可以判断它是否位于两个线段的范围之内。如果是这样，线段就发生了碰撞，小行星被击中。我们首先回顾平面内直线的方程，然后介绍如何找到两条直线的交点。最后，我们为游戏编写`does_intersect`方法的代码。
- en: 7.2.1 Choosing the right formula for a line
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 选择合适的直线公式
- en: In the previous chapter, we saw that 1D subspaces of the 2D plane are lines.
    These subspaces consist of all of the scalar multiples *t* · ***v*** for a single
    chosen vector ***v***. Because one such scalar multiple is 0 · ***v***, these
    lines always pass through the origin, so *t* · ***v*** is not quite a general
    formula for any line we encounter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了二维平面的1D子空间是直线。这些子空间由单个选择的向量***v***的所有标量倍数*t* · ***v***组成。因为这样的标量倍数中有一个是0
    · ***v***，所以这些直线总是通过原点，因此*t* · ***v***并不是我们遇到的任何直线的通用公式。
- en: If we start with a line through the origin and translate it by another vector
    ***u***, we can get any possible line. The points on this line have the form ***u***
    + *t* · ***v*** for some scalar *t*. For instance, take ***v*** = (2, −1). Points
    of the form *t* · (2, −1) lie on a line through the
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从通过原点的直线开始，并通过另一个向量***u***进行平移，我们可以得到任何可能的直线。这条直线上的点具有形式***u*** + *t* ·
    ***v***，其中*t*是某个标量。例如，取***v*** = (2, −1)。形式为*t* · (2, −1)的点位于通过
- en: origin. But if we translate by a second vector, ***u*** = (2, 3), the points
    are now (2, 3) + *t* · (2, −1), which constitute a line that *doesn’t* pass through
    the origin (figure 7.7).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过第二个向量进行平移，***u*** = (2, 3)，那么现在的点是(2, 3) + *t* · (2, −1)，这些点构成了一条不通过原点的直线（图7.7）。
- en: '![](../Images/CH07_F07_Orland.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F07_Orland.png)'
- en: Figure 7.7 Vectors *z* = (2, 3) and ***v*** = (2, −1). Points of the form *z*
    + t · *v* lie on a straight line.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 向量*z* = (2, 3)和***v*** = (2, −1)。形式为*z* + t · ***v***的点位于一条直线上。
- en: Any line can be described as the points ***u*** + *t* · ***v*** for some selection
    of vectors ***u*** and ***v*** and *all* possible scalar multiples *t*. This is
    probably not the general formula for a line you’re used to. Instead of writing
    *y* as a function of *x*, we’ve given both the *x* − and *y*-coordinates of points
    on the line as functions of another parameter *t*. Sometimes, you’ll see the line
    written r(*t*) = ***u*** + *t* · ***v*** to indicate that this line is a vector
    valued function r of the scalar parameter *t*. The input *t* decides how many
    units of ***v*** you go from the starting point ***u*** to get the output r(*t*).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何直线都可以描述为某些向量***u***和***v***以及所有可能的标量倍数*t*的点***u*** + *t* · ***v***。这可能不是你习惯的直线的一般公式。我们不是将*y*作为*x*的函数来写，而是给出了直线上点的*x*和*y*坐标作为另一个参数*t*的函数。有时，你会看到直线写成r(*t*)
    = ***u*** + *t* · ***v***，以表明这条直线是标量参数*t*的向量值函数r。输入*t*决定了从起点***u***到输出r(*t*)需要走多少个单位的***v***。
- en: The advantage of this kind of formula for a line is that it’s dead simple to
    find if you have two points on the line. If your points are ***u*** and ***w***,
    then you can use ***u*** as the translation vector, and ***w*** − ***u*** as the
    vector that is scaled (figure 7.8).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种直线公式的优点是，如果你在线上有两个点，那么找到它非常简单。如果你的点是***u***和***w***，那么你可以使用***u***作为平移向量，而***w***
    − ***u***作为缩放向量（图7.8）。
- en: '![](../Images/CH07_F08_Orland.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F08_Orland.png)'
- en: Figure 7.8 Given *z* and *w*, the line that connects them is r(*t*) = *z* +
    t · (*w* − u).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 给定*z*和*w*，连接它们的直线是r(*t*) = *z* + t · (*w* − u)。
- en: The formula r(*t*) = ***u*** + *t* · ***v*** also has its downside. As you’ll
    see in the exercises, there are multiple ways to write the same line in this form.
    The extra parameter *t* also makes it harder to solve equations because there
    is one extra unknown variable. Let’s look at some alternative formulas with other
    advantages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 公式r(*t*) = ***u*** + *t* · ***v***也有其缺点。正如你在练习中将会看到的，用这种形式写同一条直线有多个方法。额外的参数*t*也使得解方程更困难，因为有一个额外的未知变量。让我们看看一些具有其他优点的替代公式。
- en: If you recall any formula for a line from high school, it is probably *y* =
    *m* · *x* + *b*. This formula is useful because it gives you a *y*-coordinate
    explicitly as a function of the *x*-coordinate. In this form, it’s easy to graph
    a line; you go through a bunch of *x* values, compute the corresponding *y* values,
    and put dots at the resulting (*x*, *y*) points. But this formula also has some
    limitations. Most importantly, you can’t represent a vertical line like r(*t*)
    = (3, 0) + *t* · (0, 1). This is the line consisting of vectors where *x* = 3.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回忆起高中时的直线公式，那可能就是*y* = *m* · *x* + *b*。这个公式很有用，因为它明确地将*y*-坐标作为*x*-坐标的函数给出。在这个形式下，画直线很容易；你通过一系列*x*值，计算相应的*y*值，并在得到的(*x*,
    *y*)点上画点。但这个公式也有一些局限性。最重要的是，你不能表示像r(*t*) = (3, 0) + *t* · (0, 1)这样的垂直线。这是由*x*
    = 3组成的向量线。
- en: We’ll continue to use the *parametric* formula r(*t*) = ***u*** + *t* · ***v***
    because it avoids this problem, but it would be great to have a formula with no
    extra parameter *t* that can represent any line. The one we use is *ax* + *by*
    = *c*. As an example, the line we’re looking at in the last few images can be
    written as *x* + 2*y* = 8 (figure 7.9). It is the set of (*x*, *y*) points in
    the plane satisfying that equation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用*参数*公式r(*t*) = ***u*** + *t* · ***v***，因为它避免了这个问题，但有一个没有额外参数*t*的公式可以表示任何直线会更好。我们使用的公式是*ax*
    + *by* = *c*。例如，我们在最后几张图片中看到的直线可以写成*x* + 2*y* = 8（见图7.9）。它是满足该方程的平面上的(*x*, *y*)点集。
- en: '![](../Images/CH07_F09_Orland.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F09_Orland.png)'
- en: Figure 7.9 All (*x, y*) points on the line satisfy *x* + 2y = 8.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 线上的所有(*x, y*)点满足*x* + 2*y = 8。
- en: The form *ax* + *by* = *c* has no extra parameters and can represent any line.
    Even a vertical line can be written in this form; for instance, *x* = 3 is the
    same as 1 · *x* + 0 · *y* = 3\. Any equation representing a line is called a *linear*
    *equation* and this, in particular, is called the *standard form* for a linear
    equation. We prefer to use it in this chapter because it makes it easy to organize
    our computations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 形式*ax* + *by* = *c*没有额外参数，可以表示任何直线。即使是垂直线也可以用这种形式表示；例如，*x* = 3可以写成1 · *x* +
    0 · *y* = 3。任何表示直线的方程都称为*线性*方程，而此方程特别称为线性方程的*标准形式*。我们更喜欢在本章中使用它，因为它使得组织我们的计算变得容易。
- en: 7.2.2 Finding the standard form equation for a line
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 求直线标准形式方程
- en: The formula *x* + 2*y* = 8 is the equation for a line containing one of the
    segments on the example asteroid. Next, we’ll look at another one (figure 7.10)
    and then try to systematize finding the standard form for linear equations. Brace
    yourself for a bit of algebra! I’ll explain each of the steps carefully, but it
    may be a bit dry to read. You’ll have a better time if you follow along on your
    own with a pencil and paper.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 公式*x* + 2*y* = 8是包含示例小行星上某一段的直线方程。接下来，我们将看看另一个（见图7.10），然后尝试系统地找到线性方程的标准形式。准备好一点代数！我会仔细解释每个步骤，但阅读起来可能有点枯燥。如果你自己用铅笔和纸跟着做，会更有趣。
- en: '![](../Images/CH07_F10_Orland.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F10_Orland.png)'
- en: Figure 7.10 The points (1, 5) and (2, 3) define a second segment of the asteroid.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 点(1, 5)和(2, 3)定义了小行星的第二段。
- en: 'The vector (1, 5) − (2, 3) is (−1, 2), which is parallel to the line. Because
    (2, 3) lies on the line, a parametric equation for the line is *r*(*t*) = (2,
    3) + *t* · (−1, 2). Knowing that all points on the line have the form (2, 3) +
    *t* · (−1, 2) for some *t*, how can we rewrite this condition to be a standard
    form equation? We need to do some algebra and, particularly, get rid of *t*. Because
    (*x*, *y*) = (2, 3) + *t* · (−1, 2), we really have two equations to start with:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 向量(1, 5) − (2, 3)是(−1, 2)，与直线平行。因为(2, 3)位于直线上，所以直线的参数方程是*r*(*t*) = (2, 3) +
    *t* · (−1, 2)。知道直线上所有点的形式为(2, 3) + *t* · (−1, 2)（对于某个*t*），我们如何将这个条件改写为标准形式方程？我们需要做一些代数运算，特别是消除*t*。因为(*x*,
    *y*) = (2, 3) + *t* · (−1, 2)，我们实际上有两个起始方程：
- en: '*x* = 2 − *t*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = 2 − *t*'
- en: '*y* = 3 + 2*t*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = 3 + 2*t*'
- en: 'We can manipulate both of them to get two new equations that have the same
    value (2*t*):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以操作这两个方程，得到两个具有相同值(2*t*)的新方程：
- en: 4 − 2*x* = 2*t*
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 4 − 2*x* = 2*t*
- en: '*y* − 3 = 2*t*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* − 3 = 2*t*'
- en: 'Because both of the expressions on the left-hand sides equal 2*t*, they equal
    each other:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为左侧的两个表达式都等于2*t*，所以它们相等：
- en: 4 - 2*x* = *y* - 3
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 4 - 2*x* = *y* - 3
- en: 'We’ve now gotten rid of *t* ! Finally, pulling the *x* and *y* terms to one
    side, we get the standard form equation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经消除了*t*！最后，将*x*和*y*项移到一边，我们得到标准形式方程：
- en: 2*x* + *y* = 7
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x* + *y* = 7
- en: 'This process isn’t too hard, but we need to be more precise about how to do
    it if we want to convert it to code. Let’s try to solve the general problem: given
    two points (*x*[1], *y*[1]) and (*x*[2], *y*[2]), what is the equation of the
    line that passes through them (see figure 7.11)?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程并不太难，但如果我们要将其转换为代码，就需要更精确地了解如何操作。让我们尝试解决一般问题：给定两个点(*x*[1], *y*[1])和(*x*[2],
    *y*[2])，通过这两个点的直线方程是什么（见图7.11）？
- en: '![](../Images/CH07_F11_Orland.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F11_Orland.png)'
- en: Figure 7.11 The general problem of finding the equation of the line that passes
    through two known points
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 通过两个已知点求直线方程的一般问题
- en: 'Using the parametric formula, the points on the line have the following form:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数公式，直线上的点具有以下形式：
- en: (*x*, *y*) = (*x*[1], *y*[1]) + t · (*x*[2] - *x*[1], *y*[2] - *y*[1])
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (*x*, *y*) = (*x*[1], *y*[1]) + t · (*x*[2] - *x*[1], *y*[2] - *y*[1])
- en: 'There are a lot of *x* and *y* variables here, but remember that *x*[1], *x*[2],
    *y*[1], and *y*[2] are all constants for the purpose of this discussion. We assume
    we have two points with known coordinates, and we could have called them (*a*,
    *b*) and (*c*, *d*) just as easily. The variables are *x* and *y*(with no subscripts),
    which stand for coordinates of *any* point on the line. As before, we can break
    this equation into two pieces:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多 *x* 和 *y* 变量，但记住，*x*[1]，*x*[2]，*y*[1]，和 *y*[2] 在这次讨论中都是常数。我们假设我们有两个已知坐标的点，我们也可以像
    (*a*, *b*) 和 (*c*, *d*) 一样称呼它们。变量是 *x* 和 *y*（没有下标），它们代表线上任何点的坐标。像之前一样，我们可以将这个方程分成两部分：
- en: '*x* = *x*[1] + *t* · (*x*² − *x*[1])'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = *x*[1] + *t* · (*x*² − *x*[1])'
- en: '*y* = *y*[1] + *t* · (*y*² − *y*[1])'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *y*[1] + *t* · (*y*² − *y*[1])'
- en: 'We can move *x*[1] and *y*[1] to the left-hand side of their respective equations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 *x*[1] 和 *y*[1] 移到它们各自方程的左边：
- en: '*x* − *x*[1] = *t* · (*x*[2] − *x*[1])'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* − *x*[1] = *t* · (*x*[2] − *x*[1])'
- en: '*y* − *y*[1] = *t* · (*y*[2] − *y*[1])'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* − *y*[1] = *t* · (*y*[2] − *y*[1])'
- en: Our next goal is to make the right-hand side of both equations look the same,
    so we can set the left-hand sides equal to each other. Multiplying both sides
    of the first equation by (*y*[2] − *y*[1]) and both sides of the second equation
    by (*x*[2] − *x*[1]) gives us
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的目标是使两个方程的右边看起来相同，这样我们就可以将左边设置为相等。将第一个方程的两边乘以 (*y*[2] − *y*[1])，将第二个方程的两边乘以
    (*x*[2] − *x*[1])，我们得到
- en: (*y*[2] − *y*[1]) · (*x* − *x*[1]) = *t* · (*x*[2] − *x*[1]) · (*y*[2] − *y*[1])
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: (*y*[2] − *y*[1]) · (*x* − *x*[1]) = *t* · (*x*[2] − *x*[1]) · (*y*[2] − *y*[1])
- en: (*x*[2] − *x*[1]) · (*y* − *y*[1]) = *t* · (*x*[2] − *x*[1]) · (*y*[2] − *y*[1])
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: (*x*[2] − *x*[1]) · (*y* − *y*[1]) = *t* · (*x*[2] − *x*[1]) · (*y*[2] − *y*[1])
- en: 'Because the right-hand sides are identical, we know that the first and second
    equations’ left-hand sides equal each other too. That lets us create a new equation
    with no *t* in it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为右边是相同的，我们知道第一个和第二个方程的左边也相等。这让我们可以创建一个没有 *t* 的新方程：
- en: (*y*[2] − *y*[1]) · (*x* − *x*[1]) = (*x*[2] − *x*[1]) · (*y* − *y*[1])
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (*y*[2] − *y*[1]) · (*x* − *x*[1]) = (*x*[2] − *x*[1]) · (*y* − *y*[1])
- en: 'Remember, we want an equation of the form *ax* + *by* = *c*, so we need to
    get *x* and *y* on the same side and the constants on the other side. The first
    thing we can do is expand both sides:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们想要一个形式为 *ax* + *by* = *c* 的方程，所以我们需要将 *x* 和 *y* 放在同一侧，并将常数放在另一侧。我们可以做的第一件事是展开两边：
- en: (*y*[2] − *y*[1]) · *x* − (*y*[2] − *y*[1]) · *x* = (*x*[2] − *x*[1]) · y −
    (*x*[2] − *x*[1]) · *y*[1]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (*y*[2] − *y*[1]) · *x* − (*y*[2] − *y*[1]) · *x* = (*x*[2] − *x*[1]) · y −
    (*x*[2] − *x*[1]) · *y*[1]
- en: 'Then we can move the constants to the left and the variables to the right:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将常数移到左边，将变量移到右边：
- en: (*y*[2] − *y*[1]) · *x* − (*x*[2] − *x*[1]) · y = (*y*[2] − *y*[1]) · *x*[1]
    − (*x*[2] − *x*[1]) · *y*[1]
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (*y*[2] − *y*[1]) · *x* − (*x*[2] − *x*[1]) · y = (*y*[2] − *y*[1]) · *x*[1]
    − (*x*[2] − *x*[1]) · *y*[1]
- en: 'Expanding the right side, we see some of the terms cancel out:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 展开右边，我们看到一些项相互抵消：
- en: (*y*[2] − *y*[1]) · *x* − (*x*[2] − *x*[1]) · y = *y*[2]*x*[1] − *y*[1]x1 −
    *x*[2]*y*[1] + *x*[1]*y*[1] = *x*[1]*y*[2] − *x*[2]*y*[1]
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (*y*[2] − *y*[1]) · *x* − (*x*[2] − *x*[1]) · y = *y*[2]*x*[1] − *y*[1]*x1 −
    *x*[2]*y*[1] + *x*[1]*y*[1] = *x*[1]*y*[2] − *x*[2]*y*[1]
- en: We’ve done it! This is the linear equation in standard form *ax* + *by* = *c*,
    where *a* = (*y*[2] − *y*[1]), *b * = −(*x*[2] − *x*[1]), or in other words, (*x*[1]
    − *x*[2]), and *c* = (*x*[1] *y*[2] − *x*[2] *y*[1]). Let’s check this with the
    previous example we did, using the two points (*x*[1], *y*[1]) = (2, 3) and (*x*[2],
    *y*[2]) = (1, 5). In this case,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！这是一个标准形式的线性方程 *ax* + *by* = *c*，其中 *a* = (*y*[2] − *y*[1])，*b* = −(*x*[2]
    − *x*[1])，或者说，(*x*[1] − *x*[2])，而 *c* = (*x*[1] *y*[2] − *x*[2] *y*[1])。让我们用之前做的例子来检查这个，使用两个点
    (*x*[1], *y*[1]) = (2, 3) 和 (*x*[2], *y*[2]) = (1, 5)。在这种情况下，
- en: '*a* = *y*[2] − *y*[1] = 5 − 3 = 2'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = *y*[2] − *y*[1] = 5 − 3 = 2'
- en: '*b* = −(*x*[2] − *x*[1]) = −(1 − 2) = 1'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*b* = −(*x*[2] − *x*[1]) = −(1 − 2) = 1'
- en: and
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: and
- en: '*c* = *x*[1]*y*[2] − *x*[2]*y*[1] = 2 · 5 − 3 · 1 = 7'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*c* = *x*[1]*y*[2] − *x*[2]*y*[1] = 2 · 5 − 3 · 1 = 7'
- en: As expected, this means the standard form equation is 2*x* + *y* = 7\. This
    formula seems trustworthy! As one final application, let’s find the standard form
    equation for the line defined by the laser. It looks like it passes through (2,
    2) and (4, 4) as I drew it before (figure 7.12).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这意味着标准形式的方程是 2*x* + *y* = 7。这个公式看起来很可信！作为最后的运用，让我们找到由激光定义的线的标准形式方程。它看起来像它穿过我之前画过的
    (2, 2) 和 (4, 4)（图 7.12）。
- en: '![](../Images/CH07_F12_Orland.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F12_Orland.png)'
- en: Figure 7.12 The laser passes through the points (2, 2) and (4, 4).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 激光穿过点 (2, 2) 和 (4, 4)。
- en: In our asteroid game, we have exact start and end points for the laser line
    segment, but these numbers are nice for an example. Plugging into the formula,
    we find
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小行星游戏中，激光线段的起始点和终点是精确的，但这些数字对于例子来说很合适。将这些数字代入公式，我们得到
- en: '*a* = *y*[2] − *y*[1] = 4 − 2 = 2'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = *y*[2] − *y*[1] = 4 − 2 = 2'
- en: '*b* = −(*x*[2] − *x*[1]) = −(4 − 2) = −2'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*b* = −(*x*[2] − *x*[1]) = −(4 − 2) = −2'
- en: and
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '*c* = *x*[1]*y*[2] − *x*[2]*y*[1] = 2 · 4 − 2 · 4 = 0'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*c* = *x*[1]*y*[2] − *x*[2]*y*[1] = 2 · 4 − 2 · 4 = 0'
- en: This means the line is 2*y* − 2*x* = 0, which is equivalent to saying *x* −
    *y* = 0 (or simply *x* = *y*). To decide whether the laser hits the asteroid,
    we’ll have to find where the line *x* − *y* = 0 intersects the line *x* + 2*y*
    = 8, the line 2*x* + *y* = 7, or any of the other lines bounding the asteroid.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着直线是 2*y* − 2*x* = 0，这相当于说 *x* − *y* = 0（或者简单地 *x* = *y*）。为了决定激光是否击中小行星，我们必须找到直线
    *x* − *y* = 0 与直线 *x* + 2*y* = 8、直线 2*x* + *y* = 7 或任何其他界定小行星的直线相交的地方。
- en: 7.2.3 Linear equations in matrix notation
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 矩阵表示法中的线性方程
- en: 'Let’s focus on an intersection we can see: the laser clearly hits the closest
    edge of the asteroid, whose line has equation *x* + 2*y* = 8 (figure 7.13).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注一个我们可以看到的交点：激光显然击中了小行星最近的边缘，其线的方程为 *x* + 2*y* = 8（图7.13）。
- en: '![](../Images/CH07_F13_Orland.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F13_Orland.png)'
- en: Figure 7.13 The laser hits the asteroid where the lines *x* − y = 0 and *x*
    + 2y = 8 intersect.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 激光击中小行星，其线 *x* − y = 0 和 *x* + 2y = 8 相交。
- en: 'After quite a bit of build-up, we’ve met our first real system of linear equations.
    It’s customary to write systems of linear equations in a grid like the following,
    so that the variables *x* and *y* line up:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番铺垫，我们遇到了第一个真正的线性方程组。通常我们会像下面这样以网格的形式写出线性方程组，以便变量 *x* 和 *y* 对齐：
- en: '*x* − *y* = 0'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* − *y* = 0'
- en: '*x* + 2*y* = 8'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* + 2*y* = 8'
- en: 'Thinking back to chapter 5, we can organize these two equations into a single
    matrix equation. One way to do this is to write a linear combination of column
    vectors, where *x* and *y* are coefficients:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第5章，我们可以将这些两个方程组织成一个矩阵方程。一种方法是写一个列向量的线性组合，其中 *x* 和 *y* 是系数：
- en: '![](../Images/CH07_F13_Orland_EQ15.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F13_Orland_EQ15.png)'
- en: 'Another way is to consolidate this even further and write it as a matrix multiplication.
    The linear combination of (1,−1) and (−1,−2) with coefficients *x* and *y* is
    the same as a matrix product:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将它进一步合并，并以矩阵乘法的形式写出。系数为 *x* 和 *y* 的 (1,−1) 和 (−1,−2) 的线性组合与矩阵乘积相同：
- en: '![](../Images/CH07_F13_Orland_EQ16.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F13_Orland_EQ16.png)'
- en: When we write it this way, the task of solving the system of linear equations
    looks like solving for a vector in a matrix multiplication problem. If we call
    the 2-by−2 matrix *a*, the problem becomes what vector (*x*, *y*) is multiplied
    by the matrix *a* to yield (0, 8)? In other words, we know that an output of the
    linear transformation *a* is (0, 8) and we want to know what input yields it (figure
    7.14).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样写时，解线性方程组的任务看起来就像解矩阵乘法问题中的向量。如果我们称2×2矩阵为 *a*，问题就变成了什么向量 (*x*, *y*) 乘以矩阵
    *a* 得到 (0, 8)？换句话说，我们知道线性变换 *a* 的输出是 (0, 8)，我们想知道什么输入会产生它（图7.14）。
- en: '![](../Images/CH07_F14_Orland.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F14_Orland.png)'
- en: Figure 7.14 Framing the problem as finding an input vector that yields the desired
    output vector
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 将问题表述为寻找产生所需输出向量的输入向量
- en: These different notations show new ways to look at the same problem. Solving
    a system of linear equations is equivalent to finding a linear combination of
    some vectors that produces another given vector. It’s also equivalent to finding
    an input vector to a linear transformation that produces a given output. Thus,
    we're about to see how to solve all of these problems at once.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的符号展示了看待同一问题的新的方法。解线性方程组相当于找到一些向量的线性组合，这些组合产生另一个给定的向量。这也相当于找到一个线性变换的输入向量，该变换产生一个给定的输出。因此，我们将看到如何一次性解决所有这些问题。
- en: 7.2.4 Solving linear equations with NumPy
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.4 使用 NumPy 解线性方程
- en: 'Finding the intersection of *x* − *y* = 0 and *x* + 2*y* = 8 is the same as
    finding the vector (*x*, *y*) that satisfies the matrix multiplication equation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 *x* − *y* = 0 和 *x* + 2*y* = 8 的交点等同于找到满足矩阵乘法方程的向量 (*x*, *y*)：
- en: '![](../Images/CH07_F14_Orland_EQ17.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F14_Orland_EQ17.png)'
- en: 'This is only a notational difference, but framing the problem in this form
    allows us to use pre-built tools to solve it. Specifically, Python’s NumPy library
    has a linear algebra module and a function that solves this kind of equation.
    Here’s an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个符号上的差异，但以这种形式表述问题使我们能够使用预先构建的工具来解决它。具体来说，Python的NumPy库有一个线性代数模块和一个函数可以解决这类方程。以下是一个例子：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Packages the matrix as a NumPy array object
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将矩阵打包为NumPy数组对象
- en: ❷ Packages the output vector as a NumPy array (although it needn’t be reshaped
    to a column vector)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将输出向量打包为NumPy数组（尽管它不需要重塑为列向量）
- en: ❸ The numpy.linalg.solve function takes a matrix and an output vector and finds
    the input vector that produces it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `numpy.linalg.solve`函数接受一个矩阵和一个输出向量，并找到产生它的输入向量。
- en: ❹ The result is (*x, y*) = (2.66..., 2.66...).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 结果是(*x, y*) = (2.66..., 2.66...)。
- en: 'NumPy has told us that the *x*- and *y*-coordinates of the intersection are
    approximately 22/3or 8/3 each, which looks about right geometrically. Eyeballing
    the diagram, it looks like both coordinates of the intersection point should be
    between 2 and 3\. We can check to see that this point lies on both lines by plugging
    it in to both equations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy告诉我们，交点的*x*和*y*坐标大约是22/3或8/3，这在几何上看起来是正确的。通过目测图，看起来交点的两个坐标应该在2和3之间。我们可以通过将其代入两个方程来检查这个点是否同时位于两条直线上：
- en: 1*x* − 1*y* = 1 ⋅ (2.66666667) − 1 ⋅ (2.66666667) = 0
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 1*x* − 1*y* = 1 ⋅ (2.66666667) − 1 ⋅ (2.66666667) = 0
- en: 1*x* + 2*y* = 1 ⋅ (2.66666667) + 2 ⋅ (2.66666667) = 8.00000001
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 1*x* + 2*y* = 1 ⋅ (2.66666667) + 2 ⋅ (2.66666667) = 8.00000001
- en: These results are close enough to (0, 8) and, indeed, make an exact solution.
    This solution vector, roughly (8/3, 8/3) is also the vector that satisfies the
    matrix equation 7.1.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果足够接近(0, 8)，并且确实是一个精确解。这个解向量，大约是(8/3, 8/3)，也是满足矩阵方程7.1的向量。
- en: '![](../Images/CH07_F14_Orland_EQ20.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F14_Orland_EQ20.png)'
- en: As figure 7.15 shows, we can picture (8/3, 8/3) as the vector we pass into the
    linear transformation machine defined by the matrix that gives us the desired
    output vector.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7.15所示，我们可以将(8/3, 8/3)视为我们传递给由矩阵定义的线性变换机器的向量，该矩阵给出了我们期望的输出向量。
- en: '![](../Images/CH07_F15_Orland.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F15_Orland.png)'
- en: Figure 7.15 The vector (8/3, 8/3) when passed to the linear transformation produces
    the desired output (0, 8).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 将向量(8/3, 8/3)传递给线性变换会产生期望的输出(0, 8)。
- en: We can think of the Python function `numpy.linalg.solve` as a differently shaped
    machine that takes in matrices and output vectors, and returns the “solution”
    vectors for the linear equation they represent (figure 7.16).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Python函数`numpy.linalg.solve`视为一个不同形状的机器，它接受矩阵和输出向量，并返回它们所代表的线性方程的“解”向量（图7.16）。
- en: '![](../Images/CH07_F16_Orland.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F16_Orland.png)'
- en: Figure 7.16 The `numpy.linalg.solve` function takes a matrix and a vector and
    outputs the solution vector to the linear system they represent.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 `numpy.linalg.solve`函数接受一个矩阵和一个向量，并输出它们所代表的线性系统的解向量。
- en: This is perhaps the most important computational task in linear algebra; starting
    with a matrix *a*, and a vector ***w***, and finding the vector ***v*** such that
    *a* ***v*** = ***w***. Such a vector gives the solution to a system of linear
    equations represented by *a* and ***w***. We’re lucky to have a Python function
    that can do this for us so we don’t have to worry about the tedious algebra required
    to do it by hand. We can now use this function to find out when our laser hits
    asteroids.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是线性代数中最重要的计算任务；从矩阵*a*和一个向量***w***开始，找到向量***v***使得*a* ***v*** = ***w***。这样的向量给出了由*a*和***w***表示的线性方程组的解。我们很幸运有一个Python函数可以为我们完成这项工作，这样我们就不必担心手动完成所需的繁琐代数。现在我们可以使用这个函数来找出我们的激光击中小行星的时刻。
- en: 7.2.5 Deciding whether the laser hits an asteroid
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.5 判断激光是否击中小行星
- en: The missing piece of our game was an implementation for the `does_intersect`
    method on the `PolygonModel` class. For any instance of this class, which represents
    a polygon-shaped object living in our 2D game world, this method should return
    `True` if an input line segment intersects any line segment of the polygon.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏缺失的部分是`PolygonModel`类上的`does_intersect`方法的实现。对于这个类的任何实例，它代表存在于我们的2D游戏世界中的多边形对象，这个方法应该返回`True`，如果输入的线段与多边形的任何线段相交。
- en: For this, we need a few helper functions. First, we need to convert the given
    line segments from pairs of endpoint vectors to linear equations in standard form.
    At the end of the section, I give you an exercise to implement the function `standard_form`,
    which takes two input vectors and returns a tuple (*a*, *b*, *c*) where *ax* +
    *by* = *c* is the line on which the segment lies.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要一些辅助函数。首先，我们需要将给定的线段从端点向量对转换为标准形式的一次方程。在本节的末尾，我给你一个练习来实现函数 `standard_form`，它接受两个输入向量并返回一个元组
    (*a*, *b*, *c*)，其中 *ax* + *by* = *c* 是部分所在的线。
- en: Next, given two segments, each represented by its pair of endpoint vectors,
    we want to find out where their lines intersect. If *u* 1 and *u* 2 are endpoints
    of the first segment, and *v* 1 and *v* 2 are endpoints of the second, we need
    to first find the standard form equations and then pass them to NumPy to solve.
    For example,
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，给定两个部分，每个部分由其端点向量对表示，我们想要找出它们的线在哪里相交。如果 *u* 1 和 *u* 2 是第一部分的端点，而 *v* 1 和
    *v* 2 是第二部分的端点，我们需要首先找到标准形式方程，然后将它们传递给NumPy求解。例如，
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output is the point where the two lines on which the segments lie intersect.
    But this point might not lie on either of the segments as shown in figure 7.17.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是两条部分所在的线相交的点。但这个点可能不在图7.17所示的任一部分上。
- en: '![](../Images/CH07_F17_Orland.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F17_Orland.png)'
- en: Figure 7.17 One segment connects *u*[1] and *u*[2] and the other connects points
    *v*[1] and *v*[2]. The lines extending the segments intersect, but the segments
    themselves don’t.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 一个部分连接 *u*[1] 和 *u*[2]，另一个部分连接点 *v*[1] 和 *v*[2]。延伸这些部分的两条线相交，但部分本身并不相交。
- en: 'To detect whether the two segments intersect, we need to check that the intersection
    point of their lines lies between the two pairs of endpoints. We can check that
    using distances. In figure 7.17, the intersection point is further from point
    *v*[2] than point *v*[1]. Likewise, it’s further from *u*[1] than *u*[2]. This
    indicates that the point is on neither segment. With four total distance checks,
    we can confirm whether the intersection point of the lines (*x*, *y*) is an intersection
    point of the segments as well:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测两个部分是否相交，我们需要检查它们线的交点是否位于两对端点之间。我们可以使用距离来检查。在图7.17中，交点距离点 *v*[2] 比点 *v*[1]
    更远。同样，它比 *u*[1] 更远于 *u*[2]。这表明该点不在任一部分上。通过四个总距离检查，我们可以确认线的交点 (*x*, *y*) 是否也是部分的交点：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Stores the lengths of the first and second segments as d1 and d2, respectively
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将第一和第二部分的长度分别存储为 d1 和 d2
- en: ❷ Finds the intersection point (*x, y*) of the lines on which the segments lie
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 找到部分所在的线的交点 (*x, y*)
- en: ❸ Does four checks to ensure the intersection point lies between the four endpoints
    of the line segments, confirming the segments intersect
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 进行四个检查以确保交点位于线段四端点之间，确认部分相交
- en: 'Finally, we can write the `does_intersect` method by checking whether `do _segments_intersect`
    returns `True` for the input segment and any of the edges of the (transformed)
    polygon:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过检查 `do _segments_intersect` 对于输入部分和（变换后的）多边形的任何边返回 `True` 来编写 `does_intersect`
    方法：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ If any of the segments of the polygon intersect other_segment, the method
    returns True.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果多边形的任何部分与其他部分 intersect，该方法返回 True。
- en: In the exercises that follow, you can confirm that this actually works by building
    an asteroid with known coordinate points and a laser beam with a known start and
    end point. With `does_intersect` implemented as in the source code, you should
    be able to rotate the spaceship to aim at asteroids and destroy them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你可以通过构建具有已知坐标点的彗星和具有已知起点和终点的激光束来确认这实际上有效。如果 `does_intersect` 实现如源代码所示，你应该能够旋转宇宙飞船以瞄准彗星并摧毁它们。
- en: 7.2.6 Identifying unsolvable systems
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.6 识别不可解系统
- en: 'Let me leave you with one final admonition: not every system of linear equations
    in 2D can be solved! It’s rare in an application like the asteroid game, but some
    pairs of linear equations in 2D don’t have unique solutions or even solutions
    at all. If we pass NumPy a system of linear equations with no solution, we get
    an exception, so we need to handle this case.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你最后的忠告：二维中的每一个线性方程组都可以求解！在像彗星游戏这样的应用中很少见，但二维中的一些线性方程对可能没有唯一解，甚至没有解。如果我们向NumPy传递一个无解的线性方程组，我们会得到一个异常，因此我们需要处理这种情况。
- en: When a pair of lines in 2D are not parallel, they intersect somewhere. Even
    the two lines in figure 7.18 that are nearly parallel (but not quite) intersect
    somewhere off in the distance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当二维空间中的一对直线不平行时，它们会在某处相交。即使图7.18中的两条直线几乎是平行的（但并不完全平行），它们也会在远处某处相交。
- en: '![](../Images/CH07_F18_Orland.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图7.18](../Images/CH07_F18_Orland.png)'
- en: Figure 7.18 Two lines that are not quite parallel intersect somewhere in the
    distance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18中，两条并非完全平行的直线在远处某处相交。
- en: Where we run into trouble is when the lines are parallel, meaning the lines
    never intersect (or they’re the same line!) as shown in figure 7.19.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到麻烦的地方在于当直线平行时，这意味着直线永远不会相交（或者它们是同一条线！），如图7.19所示。
- en: '![](../Images/CH07_F19_Orland.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图7.19](../Images/CH07_F19_Orland.png)'
- en: Figure 7.19 A pair of parallel lines that never intersect and a pair of parallel
    lines that are, in fact, the same line despite having different equations
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 一对永不相交的平行线和一对实际上是同一条线但方程不同的平行线
- en: 'In the first case, there are zero intersection points, while in the second,
    there are *infinitely* many intersection points−every point on the line is an
    intersection point. Both of these cases are problematic computationally because
    our code demands a single, unique result. If we try to solve either of these systems
    with NumPy, for instance, the system consisting of 2*x* + *y* = 6 and 4*x* + 2*y*
    = 8, we get an exception:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，没有交点，而在第二种情况下，有*无限*多个交点−直线上每个点都是一个交点。这两种情况在计算上都有问题，因为我们的代码要求一个单一、唯一的结果。如果我们尝试用NumPy解决这两个系统中的任何一个，例如，由2*x*
    + *y* = 6和4*x* + 2*y* = 8组成的系统，我们会得到一个异常：
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: NumPy points to the matrix as the source of the error. The matrix
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy将错误归咎于矩阵。该矩阵
- en: '![](../Images/CH07_F19_Orland_EQ21.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图7.19](../Images/CH07_F19_Orland_EQ21.png)'
- en: is called a *singular* matrix, meaning there is no unique solution to the linear
    system. A system of linear equations is defined by a matrix and a vector, but
    the matrix on its own is enough to tell us whether the lines are parallel and
    whether the system has a unique solution. For any non-zero *w* we pick, there
    won’t be a unique *v* that solves the system.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*奇异*矩阵，意味着线性系统没有唯一解。线性方程组由一个矩阵和一个向量定义，但仅矩阵本身就足以告诉我们直线是否平行以及系统是否有唯一解。对于任何非零的*w*，都不会有一个唯一的*v*来解这个系统。
- en: '![](../Images/CH07_F19_Orland_EQ22.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图7.19](../Images/CH07_F19_Orland_EQ22.png)'
- en: We’ll philosophize more about singular matrices later, but for now you can see
    that the rows (2, 1) and (4, 2) and the columns (2, 4) and (1, 2) are both parallel
    and, therefore, linearly dependent. This is the key clue that tells us the lines
    are parallel and that the system does not have a unique solution. Solvability
    of linear systems is one of the central concepts in linear algebra; it closely
    relates to the notions of linear independence and dimension. We discuss that in
    the last two sections of this chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面更深入地探讨奇异矩阵，但就目前而言，你可以看到行（2, 1）和（4, 2）以及列（2, 4）和（1, 2）都是平行的，因此它们线性相关。这是告诉我们直线平行并且系统没有唯一解的关键线索。线性系统的可解性是线性代数中的一个核心概念；它与线性无关性和维数的概念密切相关。我们将在本章的最后两节中讨论这一点。
- en: 'For the purpose of our asteroid game, we can make the simplifying assumption
    that any parallel line segments don’t intersect. Given that we’re building the
    game with random floats, it’s highly unlikely that any two segments are exactly
    parallel. Even if the laser lined up exactly with the edge of an asteroid, this
    would be a glancing hit and the player doesn’t deserve to have the asteroid destroyed.
    We can modify `do_segments_intersect` to catch the exception and return the default
    result of `False` :'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的小行星游戏，我们可以做出简化的假设，即任何平行的线段都不会相交。鉴于我们是用随机浮点数构建游戏，两个线段完全平行的情况非常不可能。即使激光正好对准小行星的边缘，这也会是一个擦肩而过，玩家不配让小行星被摧毁。我们可以修改`do_segments_intersect`来捕获异常并返回默认结果`False`：
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 7.2.7 Exercises
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.7 练习
- en: '| **Exercise 7.3**: It’s possible that ***u*** + *t* · ***v*** can be a line
    through the origin. In this case, what can you say about the vectors ***u*** and
    ***v*** ?**Solution**: One possibility is that ***u*** = **0** = (0, 0); in which
    case, the line automatically passes through the origin. The point ***u*** + 0
    · ***v*** is the origin in this case, regardless of what ***v*** is. Otherwise,
    if ***u*** and ***v*** are scalar multiples, say ***u*** = *s* · ***v***, then
    the line passes through the origin as well because ***u*** − *s* · ***v*** = **0**
    is on the line. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.3**: ***u*** + *t* · ***v*** 可能是一条通过原点的直线。在这种情况下，关于向量 ***u*** 和 ***v***
    你可以说什么？**解答**: 一种可能性是 ***u*** = **0** = (0, 0)；在这种情况下，直线自动通过原点。在这种情况下，***u***
    + 0 · ***v*** 是原点，无论 ***v*** 是什么。否则，如果 ***u*** 和 ***v*** 是标量倍数，例如 ***u*** = *s*
    · ***v***，那么直线也会通过原点，因为 ***u*** − *s* · ***v*** = **0** 在这条直线上。|'
- en: '| **Exercise 7.4**: If ***v*** = **0** = (0, 0), do points of the form ***u***
    + *t* · ***v*** represent a line?**Solution**: No, regardless of the value of
    *t*, we have ***u*** + *t* · ***v*** = ***u*** + *t* · (0, 0) = ***u***. Every
    point of this form is equal to ***u***. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.4**: 如果 ***v*** = **0** = (0, 0)，形式为 ***u*** + *t* · ***v*** 的点是否代表一条直线？**解答**:
    不，无论 *t* 的值如何，我们都有 ***u*** + *t* · ***v*** = ***u*** + *t* · (0, 0) = ***u***。这种形式的所有点都等于
    ***u***。|'
- en: '| **Exercise 7.5**: It turns out that the formula ***u*** + *t* · ***v*** is
    not unique; that is, you can pick different values of ***u*** and ***v*** to represent
    the same line. What is another line representing (2, 2) + *t* · (−1, 3)?**Solution**:
    One possibility is to replace ***v*** = (−1, 3) with a scalar multiple of itself
    such as (2, −6). The points of the form (2, 2) + *t* · (−1, 3) agree with the
    points (2, 2) + *s* · (2, −6) when *t* = −2 · *s*. You can also replace ***u***
    with any point on the line. Because (2, 2) + 1 · (−1, 3) = (1, 5) is on the line,
    (1, 5) + *t* · (2, −6) is a valid equation for the same line as well. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.5**: 结果表明公式 ***u*** + *t* · ***v*** 不是唯一的；也就是说，你可以选择不同的 ***u*** 和
    ***v*** 值来表示同一条直线。另一条表示 (2, 2) + *t* · (−1, 3) 的直线是什么？**解答**: 一种可能性是将 ***v***
    = (−1, 3) 替换为其自身的标量倍数，例如 (2, −6)。当 *t* = −2 · *s* 时，形式为 (2, 2) + *t* · (−1, 3)
    的点与形式为 (2, 2) + *s* · (2, −6) 的点一致。你也可以用线上的任何点来替换 ***u***。因为 (2, 2) + 1 · (−1,
    3) = (1, 5) 在这条线上，所以 (1, 5) + *t* · (2, −6) 也是同一条直线的有效方程。|'
- en: '| **Exercise 7.6**: Does *a* · *x* + *b* · *y* = *c* represent a line for *any*
    values of *a*, *b*, and *c* ?**Solution**: No, if both *a* and *b* are zero, the
    equation does not describe a line. In that case, the formula would be 0 · *x*
    + 0 · *y* = *c*. If *c* = 0, this would always be true, and if *c* ≠ 0, it would
    never be true. Either way, it establishes no relationship between *x* and *y*
    and, therefore, it would not describe a line. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.6**: *a* · *x* + *b* · *y* = *c* 对于 *a*，*b* 和 *c* 的任何值都代表一条直线吗？**解答**:
    不，如果 *a* 和 *b* 都为零，则该方程不描述一条直线。在这种情况下，公式将是 0 · *x* + 0 · *y* = *c*。如果 *c* = 0，这始终是真的，如果
    *c* ≠ 0，则永远不是真的。无论如何，它不建立 *x* 和 *y* 之间的关系，因此它不会描述一条直线。|'
- en: '| **Exercise 7.7**: Find another equation for the line 2*x* + *y* = 3, showing
    that the choices of *a*, *b*, and *c* are not unique.**Solution**: One example
    of another equation is 6*x* + 3*y* = 9\. In fact, multiplying both sides of the
    equation by the same non-zero number gives you a different equation for the same
    line. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.7**: 找到 2*x* + *y* = 3 这条直线的另一个方程，以表明 *a*，*b* 和 *c* 的选择不是唯一的。**解答**:
    另一个方程的例子是 6*x* + 3*y* = 9。实际上，将方程两边乘以相同的非零数会得到同一条直线的不同方程。|'
- en: '| **Exercise 7.8**: The equation *ax* + *by* = *c* is equivalent to an equation
    involving a dot product of two 2D vectors: (*a*, *b*) · (*x*, *y*) = *c*. You
    could, therefore, say that a line is a set of vectors whose dot product with a
    given vector is constant. What is the geometric interpretation of this statement?**Solution**:
    See the discussion in section 7.3.1. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.8**: 方程 *ax* + *by* = *c* 等价于涉及两个二维向量点积的方程：(*a*, *b*) · (*x*, *y*)
    = *c*。因此，可以说一条直线是一组向量，这些向量与给定向量的点积是常数。这个陈述的几何解释是什么？**解答**: 请参阅 7.3.1 节的讨论。|'
- en: '| **Exercise 7.9**: Confirm that the vectors (0, 7) and (3.5, 0) both satisfy
    the equation 2*x* + *y* = 7.**Solution**: 2 · 0 + 7 = 7 and 2 · (3.5) + 0 = 7.
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.9**: 确认向量 (0, 7) 和 (3.5, 0) 都满足方程 2*x* + *y* = 7。**解答**: 2 · 0 + 7
    = 7 和 2 · (3.5) + 0 = 7. |'
- en: '| **Exercise 7.10**: Draw a graph for (3, 0) + *t* · (0, 1) and convert it
    to the standard form using the formula.**Solution**: (3, 0) + *t* · (0, 1) yields
    a vertical line, where *x* = 3:The formula *x* = 3 is already the equation of
    a line in standard form, but we can confirm this with the formulas. The first
    point on our line is already given: (*x*[1], *y*[1]) = (3, 0). A second point
    on the line is (3, 0) + (0, 1) = (3, 1) = (*x*[2], *y*[2]). We have *a* = *y*[2]
    − *y*[1] = 1, *b* = *x*[1] − *x*[2] = 0, and *c* = *x*[1] *y*[2] − *x*[2]*y*[1]
    = 3 · 1 − 1 · 0 = 3\. This gives us 1 · *x* + 0 · *y* = 3 or simply *x* = 3.![](../Images/CH07_F19_Orland_UN01.png)
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.10**: 画出 (3, 0) + *t* · (0, 1) 的图形，并使用公式将其转换为标准形式。**解答**： (3, 0) +
    *t* · (0, 1) 得到一条垂直线，其中 *x* = 3：公式 *x* = 3 已经是标准形式的直线方程，但我们可以用公式来确认这一点。我们线上的第一个点已经给出：(*x*[1],
    *y*[1]) = (3, 0)。线上的第二个点是 (3, 0) + (0, 1) = (3, 1) = (*x*[2], *y*[2])。我们有 *a*
    = *y*[2] − *y*[1] = 1，*b* = *x*[1] − *x*[2] = 0，*c* = *x*[1] *y*[2] − *x*[2]*y*[1]
    = 3 · 1 − 1 · 0 = 3。这给我们 1 · *x* + 0 · *y* = 3 或简单地 *x* = 3.![](../Images/CH07_F19_Orland_UN01.png)
    |'
- en: '| **Exercise 7.11**: Write a Python function `standard_form` that takes two
    vectors ***v*** 1 and ***v*** 2 and finds the line *ax* + *by* = *c* passing through
    both of them. Specifically, it should output the tuple of constants (*a*, *b*,
    *c*).**Solution**: All you need to do is translate the formulas you wrote in Python:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.11**: 编写一个 Python 函数 `standard_form`，它接受两个向量 ***v*** 1 和 ***v*** 2，并找到通过它们的直线
    *ax* + *by* = *c*。具体来说，它应该输出常数的元组 (*a*, *b*, *c*)。**解答**：你所需要做的就是翻译你在 Python 中写的公式：'
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 7.12-Mini Project**: For each of the four distance checks in `do
    _segments_intersect`, find a pair of line segments that fail one of the checks
    but pass the other three checks.**Solution**: To make it easier to run experiments,
    we can create a modified version of `do_segments_intersect` that returns a list
    of the True/False values returned by each of the four checks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.12-迷你项目**：对于 `do _segments_intersect` 中的四个距离检查中的每一个，找到一对线段，它们在一个检查中失败，但在其他三个检查中通过。**解答**：为了更容易运行实验，我们可以创建
    `do_segments_intersect` 的一个修改版本，该版本返回每个四个检查返回的 True/False 值的列表：'
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In general, these checks fail when one endpoint of a segment is closer to the
    other endpoint than to the intersection point.Here are some other solutions I
    found using segments on the lines *y* = 0 and *x* = 0, which intersect at the
    origin. Each of these fails exactly one of the four checks. If in doubt, draw
    them yourself to see what’s going on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当线段的一个端点比交点更接近另一个端点时，这些检查会失败。以下是我使用 *y* = 0 和 *x* = 0 上的线段找到的一些其他解决方案，这些线段在原点相交。这些解决方案中的每一个都恰好失败四个检查中的一个。如果有疑问，请自己画出它们以了解发生了什么。
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 7.13**: For the example laser line and asteroid, confirm the `does_intersect`
    function returns `True`. (Hint: use grid lines to find the vertices of the asteroid
    and build a `PolygonModel` object representing it.)![](../Images/CH07_F19_Orland_UN02.png)The
    laser hits the asteroid.**Solution**: In counterclockwise order, starting with
    the topmost point, the vertices are (2, 7), (1, 5), (2, 3), (4, 2), (6, 2), (7,
    4), (6, 6), and (4, 6). We can assume the endpoints of the laser beam are (1,
    1) and (7, 7):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.13**: 对于示例激光线和陨石，确认 `does_intersect` 函数返回 `True`。（提示：使用网格线找到陨石的顶点并构建表示它的
    `PolygonModel` 对象。）![](../Images/CH07_F19_Orland_UN02.png) 激光击中了陨石。**解答**：逆时针顺序，从最上面的点开始，顶点是
    (2, 7)，(1, 5)，(2, 3)，(4, 2)，(6, 2)，(7, 4)，(6, 6)，和 (4, 6)。我们可以假设激光束的端点是 (1, 1)
    和 (7, 7)：'
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This confirms the laser hits the asteroid! By contrast, a shot directly up
    the y-axis from (0, 0) to (0, 7) does not hit:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了激光击中了小行星！相比之下，从 (0, 0) 到 (0, 7) 直接向上射击的子弹没有击中：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 7.14**: Write a `does_collide(other_polygon)` method to decide
    whether the current `PolygonModel` object collides with another `other_polygon`
    by checking whether any of the segments that define the two are intersecting.
    This could help us decide whether an asteroid has hit the ship or another asteroid.**Solution**:
    First, it’s convenient to add a `segments()` method to `PolygonModel` to avoid
    duplication of the work of returning the (transformed) line segments that constitute
    the polygon. Then, we can check every segment of the other polygon to see if it
    returns true for `does_intersect` with the current one:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.14**: 编写一个 `does_collide(other_polygon)` 方法，通过检查定义两个多边形的任何线段是否相交，来判断当前的
    `PolygonModel` 对象是否与另一个 `other_polygon` 发生碰撞。这可以帮助我们判断小行星是否撞击了飞船或另一个小行星。**解决方案**：首先，在
    `PolygonModel` 中添加一个 `segments()` 方法是方便的，以避免重复返回构成多边形（变换后的）线段的工作。然后，我们可以检查另一个多边形的每个线段，看它是否对当前的一个返回
    `does_intersect` 为真：'
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can test this by building some squares that should and shouldn’t overlap,
    and seeing whether the `does_collide` method correctly detects which is which.
    Indeed, it does:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构建一些应该重叠和不应该重叠的正方形来测试这一点，并查看 `does_collide` 方法是否正确地检测出哪些是哪些。确实，它做到了：
- en: '[PRE21]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 7.15-Mini Project**: We can’t pick a vector ***w*** so that the
    following system has a unique solution *v*.![](../Images/CH07_F19_Orland_UN02_EQ23.png)Find
    a vector ***w*** such that there are *infinitely* many solutions to the system;
    that is, infinitely many values of *v* that satisfy the equation.**Solution**:
    If ***w*** = (0, 0), for example, the two lines represented by the system are
    identical. (Graph them if you are skeptical!) The solutions have the form *v*
    = (*a*, −2*a*) for any real number *a*. Here are some of the infinite possibilities
    for *v* when ***w*** = (0, 0):![](../Images/CH07_F19_Orland_UN02_EQ24.png) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.15-迷你项目**：我们无法选择一个向量 ***w***，使得以下系统有唯一解 *v*。![](../Images/CH07_F19_Orland_UN02_EQ23.png)找到一个向量
    ***w***，使得该系统有**无限**多个解；也就是说，有无限多个满足该方程的 *v* 值。**解决方案**：例如，如果 ***w*** = (0, 0)，那么系统表示的两条直线是相同的。（如果你怀疑，可以画出来！）解的形式是
    *v* = (*a*, −2*a*)，其中 *a* 是任意实数。以下是 ***w*** = (0, 0) 时 *v* 的无限多种可能性的几个例子：![](../Images/CH07_F19_Orland_UN02_EQ24.png)
    |'
- en: 7.3 Generalizing linear equations to higher dimensions
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 将线性方程推广到高维
- en: Now that we’ve built a functional (albeit minimal) game, let’s broaden our perspective.
    We can represent a wide variety of problems as systems of linear equations, not
    just arcade games. Linear equations in the wild often have more than two “unknown”
    variables, *x* and *y*. Such equations describe collections of points in more
    than two dimensions. In more than three dimensions, it’s hard to picture much
    of anything, but the 3D case can be a useful mental model. Planes in 3D end up
    being the analogy of lines in 2D, and they are also represented by linear equations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个功能性的（尽管是基本的）游戏，让我们拓宽我们的视野。我们可以将各种问题表示为线性方程组，而不仅仅是街机游戏。野外的线性方程通常有超过两个“未知”变量
    *x* 和 *y*，而不仅仅是两个。这样的方程描述了超过两个维度的点的集合。在超过三个维度的情况下，很难想象任何东西，但三维情况可以是一个有用的心理模型。三维中的平面是二维中线的类比，它们也由线性方程表示。
- en: 7.3.1 Representing planes in 3D
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 在三维中表示平面
- en: To see why lines and planes are analogous, it’s useful to think of lines in
    terms of dot products. As you saw in a previous exercise, or may have noticed
    yourself, the equation *ax* + *by* = *c* is the set of points (*x*, *y*) in the
    2D plane where the dot product with a fixed vector (*a*, *b*) is equal to a fixed
    number *c*. That is, the equation *ax* + *by* = *c* is equivalent to the equation
    (*a*, *b*) · (*x*, *y*) = *c*. In case you didn’t figure out how to interpret
    this geometrically in the exercise, let’s go through it here.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么线和面是相似的，用点积来考虑线是有用的。正如你在之前的练习中看到的那样，或者你可能自己注意到的，方程 *ax* + *by* = *c* 是在
    2D 平面上，与固定向量 (*a*, *b*) 的点积等于固定数 *c* 的点的集合。也就是说，方程 *ax* + *by* = *c* 等价于方程 (*a*,
    *b*) · (*x*, *y*) = *c*。如果你在练习中没有想出如何从几何上解释这一点，让我们在这里过一遍。
- en: If we have a point and a (non-zero) vector in 2D, there’s a unique line that
    is perpendicular to the vector and also passes through the point as shown in figure
    7.20.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 2D 中有一个点和（非零）向量，那么存在一条唯一的直线，它垂直于该向量，并且通过该点，如图 7.20 所示。
- en: '![](../Images/CH07_F20_Orland.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F20_Orland.png)'
- en: Figure 7.20 A unique line passing through a given point and perpendicular to
    a given vector
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 通过给定点且垂直于给定向量的唯一直线
- en: If we call the given point (*x*[0], *y*[0]) and the given vector (*a*, *b*),
    we can write a criterion for a point (*x*, *y*) to lie on the line. Specifically,
    if (*x*, *y*) lies on the line, then (*x* − *x*[0], *y* − *y*[0]) is parallel
    to the line and perpendicular to (*a*, *b*) as shown in figure 7.21.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将给定的点 (*x*[0], *y*[0]) 和给定的向量 (*a*, *b*) 分别称为 (*x*, *y*) 和 (*a*, *b*)，我们可以为点
    (*x*, *y*) 在直线上提供一条标准。具体来说，如果 (*x*, *y*) 位于直线上，那么 (*x* − *x*[0], *y* − *y*[0])
    与直线平行并且垂直于 (*a*, *b*)，如图 7.21 所示。
- en: '![](../Images/CH07_F21_Orland.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F21_Orland.png)'
- en: Figure 7.21 The vector (*x* − *x*[0], *y* − *y*[0]) is parallel to the line
    and, therefore, perpendicular to (*a, b*).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 向量 (*x* − *x*[0], *y* − *y*[0]) 与直线平行，因此垂直于 (*a, b*).
- en: 'Because two perpendicular vectors have a zero dot product, that’s equivalent
    to the algebraic statement:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因为两个垂直向量的点积为零，所以这与代数陈述等价：
- en: (*a*, *b*) · (*x* − *x*[0], *y* − *y*[0]) = 0
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: (*a*, *b*) · (*x* − *x*[0], *y* − *y*[0]) = 0
- en: That dot product expands to
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 那个点积可以展开为
- en: '*a*(*x* − *x*[0]) + *b*(*y* − *y*[0]) = 0'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*(*x* − *x*[0]) + *b*(*y* − *y*[0]) = 0'
- en: or
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '*ax* + *by* = *ax*[0] + *by*[0]'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*ax* + *by* = *ax*[0] + *by*[0]'
- en: 'The quantity on the right-hand side of this equation is a constant, so we can
    rename it *c*, giving us the general form equation for a line: *ax* + *by* = *c*.
    This is a handy geometric interpretation of the formula *ax* + *by* = *c*, and
    one that we can generalize to 3D.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程右侧的量是一个常数，因此我们可以将其重命名为 *c*，从而得到直线的通用形式方程：*ax* + *by* = *c*。这是公式 *ax* + *by*
    = *c* 的一个方便的几何解释，并且我们可以将其推广到三维空间。
- en: Given a point and a vector in 3D, there is a unique *plane* perpendicular to
    the vector and passing through that point. If the vector is (*a*, *b*, *c*) and
    the point is (*x*[0], *y*[0], *z*[0]), we can conclude that if a vector (*x*,
    *y*, *z*) lies in the plane, then (*x* − *x*[0], *y* -y[0], *z* − *z*[0]) is perpendicular
    to (*a*, *b*, *c*). Figure 7.22 shows this logic.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点和三维空间中的一个向量，存在一个唯一垂直于该向量并通过该点的平面。如果向量是 (*a*, *b*, *c*)，点为 (*x*[0], *y*[0],
    *z*[0])，我们可以得出结论，如果向量 (*x*, *y*, *z*) 位于该平面上，那么 (*x* − *x*[0], *y* -y[0], *z*
    − *z*[0]) 是垂直于 (*a*, *b*, *c*) 的。图 7.22 展示了这一逻辑。
- en: '![](../Images/CH07_F22_Orland.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F22_Orland.png)'
- en: Figure 7.22 A plane parallel to the vector (*a*, *b*, *c*) passes through the
    point (*x*[0], *y*[0], *z*[0] ).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 一个平行于向量 (*a*, *b*, *c*) 的平面通过点 (*x*[0], *y*[0], *z*[0] )。
- en: Every point on the plane gives us such a perpendicular vector to (*a*, *b*,
    *c*), and every vector perpendicular to (*a*, *b*, *c*) leads us to a point in
    the plane. We can express this perpendicularity as a dot product of the two vectors,
    so the equation satisfied by every point (*x*, *y*, *z*) in the plane is
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 平面上的每一个点都给我们提供了一个垂直于 (*a*, *b*, *c*) 的向量，而每一个垂直于 (*a*, *b*, *c*) 的向量都指向平面上的一个点。我们可以将这种垂直性表达为两个向量的点积，因此，平面上的每一个点
    (*x*, *y*, *z*) 满足的方程是
- en: (*a*, *b*, *c*) · (*x* − *x*[0], *y* − *y*[0], *z* − *z*[0]) = 0
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: (*a*, *b*, *c*) · (*x* − *x*[0], *y* − *y*[0], *z* − *z*[0]) = 0
- en: This expands to
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以展开为
- en: '*ax* + *by* + *cz* = *ax*[0] + *by*[0] + *cz*[0]'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*ax* + *by* + *cz* = *ax*[0] + *by*[0] + *cz*[0]'
- en: And because the right-hand side of the equation is a constant, we can conclude
    that every plane in 3D has an equation of the form *ax* + *by* + *cz* = *d*. In
    3D, the computational problem is to decide where the planes intersect or which
    values of (*x*, *y*, *z*) simultaneously satisfy multiple linear equations like
    this.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 并且因为方程的右侧是一个常数，我们可以得出结论，三维空间中的每一个平面都有一个形式为 *ax* + *by* + *cz* = *d* 的方程。在三维空间中，计算问题是要决定这些平面的交点在哪里，或者哪些
    (*x*, *y*, *z*) 的值同时满足多个这样的线性方程。
- en: 7.3.2 Solving linear equations in 3D
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 解三维线性方程
- en: A pair of non-parallel lines in the plane intersects at exactly one point. Is
    that single intersection point true for planes as well? If we draw a pair of intersecting
    planes, we can see that it’s possible for non-parallel planes to intersect at
    many points. In fact, figure 7.23 shows there is a whole *line*, consisting of
    an infinite number of points where two non-parallel planes intersect.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 平面上的非平行直线在 exactly one point 相交。这个单一点交对于平面也是成立的吗？如果我们画一对相交的平面，我们可以看到非平行平面可以在多个点上相交。事实上，图
    7.23 显示，存在一条由无限多个点组成的 whole *line*，这些点是两个非平行平面相交的点。
- en: '![](../Images/CH07_F23_Orland.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F23_Orland.png)'
- en: Figure 7.23 Two non-parallel planes intersect along a line.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 两个非平行平面沿一条直线相交。
- en: If you add a third plane that is not parallel to this intersection line, you
    can find a unique intersection point. Figure 7.24 shows that each pair among the
    three planes intersects along a line and the lines share a single point.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加一个不平行于这条交线的第三个平面，你可以找到一个唯一的交点。图 7.24 显示了三个平面中的每一对都沿一条线相交，而这些线共享一个单一的点。
- en: '![](../Images/CH07_F24_Orland.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F24_Orland.png)'
- en: Figure 7.24 Two non-parallel planes intersect along a line.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24 两个非平行平面沿一条线相交。
- en: 'Finding this point algebraically requires finding a common solution to three
    linear equations in three variables, each representing one of the planes and having
    the form *ax* + *by* + *cz* = *d*. Such a system of three linear equations would
    have the form:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代数方法找到这个点需要找到三个变量三个线性方程的公共解，每个变量代表一个平面，形式为 *ax* + *by* + *cz* = *d*。这样的三个线性方程组的形式如下：
- en: '*a*[1]*x* + *b*[1]*y* + *c*[1]*z* = *d*[1]'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[1]*x* + *b*[1]*y* + *c*[1]*z* = *d*[1]'
- en: '*a*[2]*x* + *b*[2]*y* + *c*[2]*z* = *d*[2]'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[2]*x* + *b*[2]*y* + *c*[2]*z* = *d*[2]'
- en: '*a*[3]*x* + *b*[3]*y* + *c*[3]*z* = *d*[3]'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[3]*x* + *b*[3]*y* + *c*[3]*z* = *d*[3]'
- en: 'Each plane is determined by four numbers: *a[i]*, *b[i]*, *c[i]*, and *d[i]*,
    where *i* = 1, 2, or 3 and is the index of the plane we’re looking at. Subscripts
    like this are useful for systems of linear equations where there can be a lot
    of variables that need to be named. These twelve numbers in total are enough to
    find the point (*x*, *y*, *z*) where the planes intersect, if there is one. To
    solve the system, we can convert the system into a matrix equation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平面由四个数字确定：*a[i]*、*b[i]*、*c[i]* 和 *d[i]*，其中 *i* = 1、2 或 3，是我们要看的平面的索引。这样的下标在有许多变量需要命名的线性方程组中很有用。这十二个数字总共足以找到平面相交的点
    (*x*, *y*, *z*)，如果有的话。为了解这个系统，我们可以将系统转换为矩阵方程：
- en: '![](../Images/CH07_F24_Orland_EQ30.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F24_Orland_EQ30.png)'
- en: 'Let’s try an example. Say our three planes are given by the following equations:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个例子。假设我们的三个平面由以下方程给出：
- en: '*x* + *y* − *z* = −1'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* + *y* − *z* = −1'
- en: 2*y* − *z* = 3
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 2*y* − *z* = 3
- en: '*x* + *z* = 2'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* + *z* = 2'
- en: You can see how to plot these planes in Matplotlib in the source code for this
    book. Figure 7.25 shows the result.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的源代码中看到如何在 Matplotlib 中绘制这些平面。图 7.25 显示了结果。
- en: '![](../Images/CH07_F25_Orland.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F25_Orland.png)'
- en: Figure 7.25 Three planes plotted in Matplotlib
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25 在 Matplotlib 中绘制的三个平面
- en: It’s not easy to see, but somewhere in there, the three planes intersect. To
    find that intersection point, we need the values of *x*, *y*, and *z* that simultaneously
    satisfy all three linear equations. Once again, we can convert the system to matrix
    form and use NumPy to solve it. The matrix equation equivalent to this linear
    system is
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不容易看出，但三个平面在某处相交。为了找到这个交点，我们需要满足所有三个线性方程的 *x*、*y* 和 *z* 的值。再次，我们可以将系统转换为矩阵形式并使用
    NumPy 来求解。与这个线性系统等价的矩阵方程是
- en: '![](../Images/CH07_F25_Orland_EQ32.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F25_Orland_EQ32.png)'
- en: 'Converting the matrix and vector to NumPy arrays in Python, we can quickly
    find the solution vector:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中将矩阵和向量转换为 NumPy 数组，我们可以快速找到解向量：
- en: '[PRE22]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells us that (−1, 3, 3) is the (*x*, *y*, *z*) point where all three planes
    intersect and the point that simultaneously satisfies all three linear equations.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，(−1, 3, 3) 是 (*x*, *y*, *z*) 点，所有三个平面相交于此点，并且该点同时满足所有三个线性方程。
- en: While this result was easy to compute with NumPy, you can see it’s already a
    bit harder to visualize systems of linear equations in 3D. Beyond 3D, it’s difficult
    (if not impossible) to visualize linear systems, but solving them is mechanically
    the same. The analogy to a line or a plane in any number of dimensions is called
    a *hyperplane*, and the problem boils down to finding the points where multiple
    hyperplanes intersect.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 NumPy 计算这个结果很容易，但你也可以看到在 3D 中可视化线性方程组已经有点困难了。在 3D 之外，可视化线性方程组是困难的（如果不是不可能的），但求解它们是机械上相同的。任何数量维度的线或平面的类比称为
    *超平面*，问题归结为找到多个超平面相交的点。
- en: 7.3.3 Studying hyperplanes algebraically
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 代数方法研究超平面
- en: 'To be precise, a hyperplane in *n* dimensions is a solution to a linear equation
    in *n* unknown variables. A line is a 1D hyperplane living in 2D, and a plane
    is a 2D hyperplane living in 3D. As you might guess, a linear equation in standard
    form in 4D has the following form:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，*n* 维超平面是 *n* 个未知变量的线性方程的解。一条线是存在于 2D 中的 1D 超平面，一个平面是存在于 3D 中的 2D 超平面。正如你可能猜到的，4D
    中标准形式的线性方程具有以下形式：
- en: '*aw* + *bx* + *cy* + *dz* = *e*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*aw* + *bx* + *cy* + *dz* = *e*'
- en: 'The set of solutions (*w*, *x*, *y*, *z*) form a region that is a 3D hyperplane
    living in 4D space. We need to be careful when we use the adjective 3D because
    it isn’t necessarily a 3D vector subspace of ℝ⁴. This is analogous to the 2D case:
    the lines passing through the origin in 2D are vector subspaces of ℝ², but other
    lines are not. Vector space or not, the 3D hyperplane is 3D in the sense that
    there are three linearly independent directions you could travel in the solution
    set, like there are two linearly independent directions you can travel on any
    plane. I’ve included a mini-project at the end of this section to help you check
    your understanding of this.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 解集(*w*, *x*, *y*, *z*)形成一个位于4维空间中的3维超平面区域。当我们使用形容词3D时需要小心，因为这并不一定是ℝ⁴的3维向量子空间。这与二维情况类似：通过二维空间原点的线是ℝ²的向量子空间，但其他线则不是。无论是否是向量空间，3维超平面在解集中有三个线性无关的方向可以旅行，就像在任何平面上你可以旅行两个线性无关的方向一样。我在本节的末尾包含了一个小项目，以帮助你检查你对这一点的理解。
- en: 'When we write linear equations in even higher numbers of dimensions, we’re
    in danger of running out of letters to represent coordinates and coefficients.
    To solve this, we’ll use letters with subscript indices. For instance, in 4D,
    we could write a linear equation in standard form as:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在更高维度的空间中写线性方程时，我们可能会用完字母来表示坐标和系数。为了解决这个问题，我们将使用带有下标索引的字母。例如，在4维空间中，我们可以将线性方程写成标准形式：
- en: '*a*[1] x[1] + *a*[2] x[2] + *a*[3] x[3] + *a*[4] *x*[4] = *b*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[1] *x*[1] + *a*[2] *x*[2] + *a*[3] *x*[3] + *a*[4] *x*[4] = *b*'
- en: 'Here, the coefficients are *a*[1], *a*[2], *a*[3], and *a*[4], and the 4D vector
    has the coordinates (*x*[1], *x*[2], *x*[3], *x*[4]). We could just as easily
    write a linear equation in 10 dimensions:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，系数是*a*[1]，*a*[2]，*a*[3]，和*a*[4]，4维向量的坐标是(*x*[1]，*x*[2]，*x*[3]，*x*[4])。我们同样可以写出10维的线性方程：
- en: '*a*[1] *x*[1] + *a*[2] *x*[2] + *a*[3] *x*[3] + *a*[4] *x*[4] + *a*[5] *x*[5]
    + *a*[6] *x*[6] + *a*[7] *x*[7] + *a*[8] *x*[8] + *a*[9] *x*[9] + *a*[10] *x*[10]
    = *b*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[1] *x*[1] + *a*[2] *x*[2] + *a*[3] *x*[3] + *a*[4] *x*[4] + *a*[5] *x*[5]
    + *a*[6] *x*[6] + *a*[7] *x*[7] + *a*[8] *x*[8] + *a*[9] *x*[9] + *a*[10] *x*[10]
    = *b*'
- en: 'When the pattern of terms we’re summing is clear, we sometimes use an ellipsis
    (...) to save space. You may see equations like the previous one written *a*[1]
    *x*[1] + *a*[2] *x*[2] + ... + *a*[10] *x*[10] = *b*. Another compact notation
    you’ll see involves the summation symbol Σ, which is the Greek letter sigma. If
    I want to write the sum of terms of the form *aixi* with the index *i* ranging
    from *i* = 1 to *i* = 10, and I want to state that the sum is equal to some other
    number *b*, I can use the mathematical shorthand:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们求和的项的规律清晰时，我们有时会使用省略号(...)来节省空间。你可能看到像前面的方程一样写的方程 *a*[1] *x*[1] + *a*[2]
    *x*[2] + ... + *a*[10] *x*[10] = *b*。你还会看到另一种紧凑的表示法，涉及到求和符号Σ，它是希腊字母sigma。如果我想写形式为*aixi*的项的和，其中索引*i*从*i*
    = 1到*i* = 10，并且我想声明这个和等于某个其他数字*b*，我可以使用数学简写：
- en: '![](../Images/CH07_F25_Orland_EQ33.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F25_Orland_EQ33.png)'
- en: 'This equation means the same thing as the earlier one; it is merely a more
    concise way of writing it. Whatever number of dimensions *n* we’re working in,
    the standard form of a linear equation has the same shape:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程与前面的方程表达的意思相同；它只是更简洁的写法。无论我们在多少维度的空间中工作，线性方程的标准形式都有相同的形状：
- en: '*a*[1] *x*[1] + *a*[2] *x*[2] + ... + *a[n]x[n]* = *b*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[1] *x*[1] + *a*[2] *x*[2] + ... + *a*[n] *x*[n]* = *b*'
- en: To represent a system of *m* linear equations in *n* dimensions, we need even
    more indices. Our array of constants on the left-hand side of the equals sign
    can be denoted *aij*, where the subscript *i* indicates which equation we’re talking
    about and the subscript *j* indicates which coordinate (*x[j]*) the constant is
    multiplied by. For example,
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示在n维空间中具有m个线性方程的系统，我们需要更多的索引。等号左边的常数数组可以用*aij*表示，其中下标*i*表示我们正在讨论哪个方程，下标*j*表示常数(*x[j]*)乘以哪个坐标。例如，
- en: '*a*[11] *x*[1] + *a*[12] *x*[2] + ... + *a*[1n] *x*[n] = *b*[1]'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[11] *x*[1] + *a*[12] *x*[2] + ... + *a*[1n] *x*[n] = *b*[1]'
- en: '*a*[21] *x*[1] + *a*[22] *x*[2] + ... + *a*[2n] *x*[n] = *b*[2]'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[21] *x*[1] + *a*[22] *x*[2] + ... + *a*[2n] *x*[n] = *b*[2]'
- en: '...'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '*a*[m1] *x*[1] + *a*[m2] *x*[2] + ... + *a*[mn] *x*[n] = *b*[m]'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[m1] *x*[1] + *a*[m2] *x*[2] + ... + *a*[mn] *x*[n] = *b*[m]'
- en: 'You can see that I also used the ellipsis to skip equations three through *m*
    −1 in the middle. There are *m* equations and *n* constants in each equation,
    so there are *mn* constants of the form *aij* in total. On the right-hand side,
    there are *m* constants in total, one per equation: *b*[1], *b*[2], ..., *bm*.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我也使用了省略号来跳过中间的三个方程到 *m* -1。每个方程中有 *n* 个常数，所以总共有 *mn* 个形式为 *aij* 的常数。在等式的右边，总共有
    *m* 个常数，每个方程一个：*b*[1]，*b*[2]，...，*bm*。
- en: Regardless of the number of dimensions (the same as the number of unknown variables)
    and the number of equations, we can represent such a system as a linear equation.
    The previous system with *n* unknowns and *m* equations can be rewritten as shown
    in figure 7.26.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 无论维度数（与未知变量的数量相同）和方程的数量如何，我们都可以将这样的系统表示为一个线性方程。具有 *n* 个未知数和 *m* 个方程的先前系统可以重写如图
    7.26 所示。
- en: '![](../Images/CH07_F26_Orland.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F26_Orland.png)'
- en: Figure 7.26 A system of m linear equations with n unknowns written in matrix
    form
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26 具有n个未知数和m个方程的线性方程组以矩阵形式表示
- en: 7.3.4 Counting dimensions, equations, and solutions
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 计算维度、方程和解的数量
- en: We saw in both 2D and 3D that it’s possible to write linear equations that don’t
    have a solution, or at least not a unique one. How will we know if a system of
    *m* equations in *n* unknowns is solvable? In other words, how will we know if
    *m* hyperplanes in *n* -dimensions have a unique intersection point? We’ll discuss
    this in detail in the last section of this chapter, but there’s one important
    conclusion we can draw now.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在二维和三维中都看到，可以写出没有解或至少不是唯一解的线性方程。我们如何知道一个包含 *n* 个未知数的 *m* 个方程组是可解的？换句话说，我们如何知道
    *n* 维空间中的 *m* 个超平面有一个唯一的交点？我们将在本章的最后部分详细讨论这个问题，但现在我们可以得出一个重要的结论。
- en: In 2D, a pair of lines can intersect at a single point. They won’t always (for
    instance, if the lines are parallel), but they can. The algebraic equivalent to
    this statement is that a system of two linear equations in two variables can have
    a unique solution.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维中，一对直线可以在一个点上相交。它们并不总是这样（例如，如果直线是平行的），但它们可以。这个陈述的代数等价物是，在两个变量中的两个线性方程组可以有一个唯一的解。
- en: In 3D, three planes can intersect at a single point. Likewise, this is not always
    the case, but three is the minimum number of planes (or linear equations) required
    to specify a point in 3D. With only two planes, you have at least a 1D space of
    possible solutions, which is the line of intersection. Algebraically, this means
    you need two linear equations to get a unique solution in 2D and three linear
    equations to get a unique solution in 3D. In general, you need *n* linear equations
    to be able to get a unique solution in *n* -dimensions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维中，三个平面可以相交于一个点。同样，这并不总是这样，但三个是确定三维空间中一个点的最小平面数（或线性方程数）。只有两个平面时，你至少有一个一维的可能解空间，即交线。从代数上来说，这意味着你需要两个线性方程在二维中获取一个唯一解，三个线性方程在三维中获取一个唯一解。一般来说，你需要
    *n* 个线性方程才能在 *n* 维空间中获取一个唯一解。
- en: Here’s an example when working in 4D with the coordinates (*x*[1], *x*[2], *x*[3],
    *x*[4]), which can seem overly simple but is useful because of how concrete it
    is. Let’s take our first linear equation to be *x*[4] = 0\. The solutions to this
    linear equation form a 3D hyperplane, consisting of vectors of the form (*x*[1],
    *x*[2], *x*[3], 0). This is clearly a 3D space of solutions, and it turns out
    to be a vector subspace of ℝ⁴ with basis (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1,
    0).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，当在四维空间中工作时，使用坐标 (*x*[1]，*x*[2]，*x*[3]，*x*[4])，这可能会显得过于简单，但因为它具体而有用。让我们将我们的第一个线性方程设为
    *x*[4] = 0\. 这个线性方程的解形成一个三维超平面，由形式为 (*x*[1]，*x*[2]，*x*[3]，0) 的向量组成。这显然是一个三维解空间，并且它实际上是
    ℝ⁴ 的一个向量子空间，其基为 (1, 0, 0, 0)，(0, 1, 0, 0)，(0, 0, 1, 0)。
- en: A second linear equation could be *x*[2] = 0\. The solutions of this equation
    on its own are also a 3D hyperplane. The intersection of these two 3D hyperplanes
    is a 2D space, consisting of vectors of the form (*x*[1], 0, *x*[3], 0), which
    satisfy both equations. If we could picture such a thing, we would see this as
    a 2D plane living in 4D space. Specifically, it is the plane spanned by (1, 0,
    0, 0) and (0, 0, 1, 0).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个线性方程可以是 *x*[2] = 0\. 这个方程的解本身也是一个三维超平面。这两个三维超平面的交集是一个二维空间，由形式为 (*x*[1], 0,
    *x*[3], 0) 的向量组成，这些向量满足两个方程。如果我们能想象这样的东西，我们会看到这是一个存在于四维空间中的二维平面。具体来说，它是通过 (1,
    0, 0, 0) 和 (0, 0, 1, 0) 这两个向量张成的平面。
- en: Adding one more linear equation, *x*[1] = 0, which defines its own hyperplane,
    the solutions to all three equations are now a 1D space. The vectors in this 1D
    space lie on a line in 4D, and have the form (0, 0, *x*[3], 0). This line is exactly
    the x[3] -axis, which is a 1D subspace of ℝ⁴.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个额外的线性方程，*x*[1] = 0，它定义了自己的超平面，现在所有三个方程的解是一个一维空间。这个一维空间中的向量位于4维空间中的一条线上，形式为
    (0, 0, *x*[3], 0)。这条线正好是 x[3] -轴，它是 ℝ⁴ 的一个一维子空间。
- en: 'Finally, if we impose a fourth linear equation, *x*[3] = 0, the only possible
    solution is (0, 0, 0, 0), a zero-dimensional vector space. The statements *x*[4]
    = 0, *x*[2] = 0, *x*[1] = 0, and *x*[3] = 0 are, in fact, linear equations, but
    these are so simple they describe the solution exactly: (*x*[1], *x*[2], *x*[3],
    *x*[4]) = (0, 0, 0, 0). Each time we add an equation, we reduced the dimension
    of the solution space by one, until we got a zero-dimensional space consisting
    of the single point (0, 0, 0, 0).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们施加第四个线性方程，*x*[3] = 0，唯一的可能解是 (0, 0, 0, 0)，一个零维的向量空间。*x*[4] = 0，*x*[2]
    = 0，*x*[1] = 0，和 *x*[3] = 0 这些陈述实际上都是线性方程，但它们非常简单，可以精确地描述解：(*x*[1], *x*[2], *x*[3],
    *x*[4]) = (0, 0, 0, 0)。每次我们添加一个方程，我们都会减少解空间的维度，直到我们得到一个由单个点 (0, 0, 0, 0) 组成的零维空间。
- en: Had we chosen different equations, each step would not have been as clear; we
    would have to test whether each successive hyperplane truly reduces the dimension
    of the solution space by one. For instance, if we started with
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择了不同的方程，每一步可能就不会那么清晰；我们就必须测试每个后续的超平面是否真正减少了解空间的维度。例如，如果我们从
- en: '*x*[1] = 0'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[1] = 0'
- en: and
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '*x*[2] = 0'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[2] = 0'
- en: we would have reduced the solution set to a 2D space, but then adding another
    equation to the mix
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会将解集减少到二维空间，但随后添加另一个方程到其中
- en: '*x*[1] + *x*[2] = 0'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[1] + *x*[2] = 0'
- en: there is no effect on the solution space. Because *x*[1] and *x*[2] are already
    constrained to be zero, the equation *x*[1] + *x*[2] = 0 is automatically satisfied.
    This third equation, therefore, adds no more specificity to the solution set.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对解空间没有影响。因为 *x*[1] 和 *x*[2] 已经被限制为零，方程 *x*[1] + *x*[2] = 0 自动满足。因此，第三个方程没有给解集添加更多的具体性。
- en: In the first case, four dimensions with three linear equations to satisfy left
    us with a 4 − 3 = 1 dimensional solution space. But in the second case, three
    equations described a less specific 2D solution space. If you have *n* dimensions
    (*n* unknown variables) and *n* linear equations, it’s possible there’s a unique
    solution−a zero-dimensional solution space−but this is not always the case. More
    generally, if you’re working in *n* dimensions, the lowest dimensional solution
    space you can get with *m* linear equations is *n* − *m*. In that case, we call
    the system of linear equations *independent*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，四个维度和三个线性方程需要满足，给我们留下了一个 4 − 3 = 1 维的解空间。但在第二种情况下，三个方程描述了一个更不具体的2D解空间。如果你有
    *n* 维度（*n* 个未知变量）和 *n* 个线性方程，可能存在一个唯一的解−一个零维的解空间−但这并不总是如此。更一般地，如果你在 *n* 维空间中工作，使用
    *m* 个线性方程可以得到最低维度的解空间是 *n* − *m*。在这种情况下，我们称线性方程组为*独立的*。
- en: Every basis vector in a space gives us a new independent direction we can move
    in the space. Independent directions in a space are sometimes called *degrees
    of freedom* ; the *z* direction, for instance, “freed” us from the plane into
    larger 3D space. By contrast, every independent linear equation we introduce is
    a constraint; it removes a degree of freedom and restricts the space of solutions
    to have a smaller number of dimensions. When the number of independent degrees
    of freedom (dimensions) equals the number of independent constraints (linear equations),
    there are no longer any degrees of freedom, and we are left with a unique point.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 空间中的每个基向量都给我们提供了一个新的独立方向，我们可以在空间中移动。空间中的独立方向有时被称为*自由度*；例如，*z*方向，“解放”了我们从平面到更大的3D空间。相比之下，我们引入的每个独立线性方程都是一个约束；它减少了一个自由度，并限制了解空间的维度数减少。当独立自由度（维度）的数量等于独立约束（线性方程）的数量时，就不再有任何自由度，我们只剩下了一个唯一的点。
- en: This is a major philosophical point in linear algebra, and one you can explore
    more in some mini-projects that follow. In the final section of this chapter,
    we’ll connect the concepts of independent equations and (linearly) independent
    vectors.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在线性代数中的一个重要哲学观点，你可以在接下来的某些小项目中进一步探索。在本章的最后部分，我们将连接独立方程和（线性）独立向量的概念。
- en: 7.3.5 Exercises
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.5 练习
- en: '| **Exercise 7.16**: What’s the equation for a line that passes through (5,
    4) and that is perpendicular to (−3, 3)?**Solution**: Here’s the set up:![](../Images/CH07_F26_Orland_UN03.png)For
    every point (*x*, *y*) on the line, the vector (*x* − 5, *y* − 4) is parallel
    to the line and, therefore, perpendicular to (−3, 3). That means that the dot
    product (*x* − 5, *y* − 4) · (−3, 3) is zero for any (*x*, *y*) on the line. This
    equation expands to −3*x* + 15 + 3*y* − 12 = 0, which rearranges to give −3*x*
    + 3*y* = −3\. We can divide both sides by −3 to get a simpler, equivalent equation:
    *x* − *y* = 1. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.16**：通过点 (5, 4) 且垂直于 (−3, 3) 的直线的方程是什么？**解答**：这里是设置！![图片](../Images/CH07_F26_Orland_UN03.png)。对于直线上的每个点
    (*x*, *y*)，向量 (*x* − 5, *y* − 4) 与直线平行，因此与 (−3, 3) 垂直。这意味着对于直线上的任何 (*x*, *y*)，向量
    (*x* − 5, *y* − 4) 与 (−3, 3) 的点积为零。这个方程展开为 −3*x* + 15 + 3*y* − 12 = 0，重新排列后得到
    −3*x* + 3*y* = −3。我们可以将两边都除以 −3 来得到一个更简单、等价的方程：*x* − *y* = 1。|'
- en: '| **Exercise 7.17-Mini Project**: Consider a system of two linear equations
    in 4D:*x*[1] + 2*x*[2] + 2*x*[3] + *x*[4] = 0*x*[1] − *x*[4] = 0Explain algebraically
    (rather than geometrically) why the solutions form a vector subspace of 4D.**Solution**:
    We can show that if (*a*[1], *a*[2], *a*[3], *a*[4]) and (*b*[1], *b*[2], *b*[3],
    *b*[4]) are two solutions, then a linear combination of those is a solution as
    well. That would imply that the solution set contains all linear combinations
    of its vectors, making it a vector subspace.Let’s start with the assumption that
    (*a*[1], *a*[2], *a*[3], *a*[4]) and (*b*[1], *b*[2], *b*[3], *b*[4]) are solutions
    to both linear equations, which explicitly means:*a*[1] + 2*a*[2] + 2*a*[3] +
    *a*[4] = 0*b*[1] + 2*b*[2] + 2*b*[3] + *b*[4] = 0*a*[1] − *a*[4] = 0*b*[1] − *b*[4]
    = 0Picking scalars *c* and *d*, the linear combination *c*(*a*[1], *a*[2], *a*[3],
    *a*[4]) + *d*(*b*[1], *b*[2], *b*[3], *b*[4]) is equal to (*ca*[1] + *db*[1],
    *ca*[2] + *db*[2], *ca*[3] + *db*[3], *ca*[4] + *db*[4]). Is this a solution to
    the two equations? We can find out by plugging the four coordinates in for *x*[1],
    *x*[2], *x*[3], and *x*[4]. In the first equation,*x*[1] + 2*x*[2] + 2*x*[3] +
    *x*[4]becomes(*ca*[1] + *db*[1]) + 2(*ca*[2] + *db*[2]) + 2(*ca*[3] + *db*[3])
    + (*ca*[4] + *db*[4])That expands to give us*ca*[1] + *db*[1] + 2*ca*[2] + 2*db*[2]
    + 2*ca*[3] + 2*db*[3] + *ca*[4] + *db*[4]which rearranges to*c*(*a*[1] + 2*a*[2]
    +2*a*[3] + *a*[4]) + *d*(*b*[1] + 2*b*[2] + 2*b*[3] + *b*[4])Because *a*[1] +
    2*a*[2] + 2*a*[3] + *a*[4] and *b*[1] + 2*b*[2] + 2*b*[3] + *b*[4] are both zero,
    this expression is zero:*c*(*a*[1] + 2*a*[2] + 2*a*[3] + *a*[4]) + *d*(*b*[1]
    + 2*b*[2] + 2*b*[3] + *b*[4]) = *c* · 0 + *d* · 0 = 0That means the linear combination
    is a solution to the first equation. Similarly, plugging the linear combination
    into the second equation, we see it’s a solution to that equation as well:(*ca*[1]
    + *db*[1]) − (*ca*[4] + *db*[4]) = *c*(*a*[1] − *a*[4]) + *d*(*b*[1] − *b*[4])
    = *c* · 0 + *d* · 0 = 0Any linear combination of any two solutions is also a solution,
    so the solution set contains all of its linear combinations. That means the solution
    set is a vector subspace of 4D. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.17-迷你项目**：考虑一个 4 维线性方程组：*x*[1] + 2*x*[2] + 2*x*[3] + *x*[4] = 0*x*[1]
    − *x*[4] = 0。用代数方法（而不是几何方法）解释为什么解构成 4 维向量子空间。**解答**：我们可以证明，如果 (*a*[1], *a*[2],
    *a*[3], *a*[4]) 和 (*b*[1], *b*[2], *b*[3], *b*[4]) 是两个解，那么它们的线性组合也是一个解。这意味着解集包含其向量的所有线性组合，因此它是一个向量子空间。让我们从假设
    (*a*[1], *a*[2], *a*[3], *a*[4]) 和 (*b*[1], *b*[2], *b*[3], *b*[4]) 是两个线性方程的解开始，这明确意味着：*a*[1]
    + 2*a*[2] + 2*a*[3] + *a*[4] = 0*b*[1] + 2*b*[2] + 2*b*[3] + *b*[4] = 0*a*[1]
    − *a*[4] = 0*b*[1] − *b*[4] = 0。选择标量 *c* 和 *d*，线性组合 *c*(*a*[1], *a*[2], *a*[3],
    *a*[4]) + *d*(*b*[1], *b*[2], *b*[3], *b*[4]) 等于 (*ca*[1] + *db*[1], *ca*[2] +
    *db*[2], *ca*[3] + *db*[3], *ca*[4] + *db*[4])。这是这两个方程的解吗？我们可以通过将四个坐标代入 *x*[1]，*x*[2]，*x*[3]
    和 *x*[4] 来找出答案。在第一个方程中，*x*[1] + 2*x*[2] + 2*x*[3] + *x*[4] 变为 (*ca*[1] + *db*[1])
    + 2(*ca*[2] + *db*[2]) + 2(*ca*[3] + *db*[3]) + (*ca*[4] + *db*[4])。这展开为给我们 *ca*[1]
    + *db*[1] + 2*ca*[2] + 2*db*[2] + 2*ca*[3] + 2*db*[3] + *ca*[4] + *db*[4]，这重新排列为
    *c*(*a*[1] + 2*a*[2] +2*a*[3] + *a*[4]) + *d*(*b*[1] + 2*b*[2] + 2*b*[3] + *b*[4])。因为
    *a*[1] + 2*a*[2] + 2*a*[3] + *a*[4] 和 *b*[1] + 2*b*[2] + 2*b*[3] + *b*[4] 都是零，这个表达式是零：*c*(*a*[1]
    + 2*a*[2] + 2*a*[3] + *a*[4]) + *d*(*b*[1] + 2*b*[2] + 2*b*[3] + *b*[4]) = *c*
    · 0 + *d* · 0 = 0。这意味着线性组合是第一个方程的解。同样，将线性组合代入第二个方程，我们看到它也是那个方程的解：(*ca*[1] + *db*[1])
    − (*ca*[4] + *db*[4]) = *c*(*a*[1] − *a*[4]) + *d*(*b*[1] − *b*[4]) = *c* · 0
    + *d* · 0 = 0。任何两个解的任何线性组合也是解，所以解集包含其所有线性组合。这意味着解集是 4 维向量子空间。|'
- en: '| **Exercise 7.18**: What is the standard form equation for a plane that passes
    through the point (1, 1, 1) and is perpendicular to the vector (1, 1, 1)?**Solution**:
    For any point (*x*, *y*, *z*) in the plane, the vector (*x* − 1, *y* − 1, *z*
    − 1) is perpendicular to (1, 1, 1). That means that the dot product (*x* − 1,
    *y* − 1, *z* − 1) · (1, 1, 1) is zero for any *x*, *y*, and *z* values giving
    a point in the plane. This expands to give us (*x* − 1) + (*y* − 1) + (*z* − 1)
    = 0 or *x* + *y* + *z* = 3, the standard form equation for the plane. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.18**：通过点 (1, 1, 1) 且垂直于向量 (1, 1, 1) 的平面的标准形式方程是什么？**解答**：对于平面上的任意点
    (*x*, *y*, *z*)，向量 (*x* − 1, *y* − 1, *z* − 1) 都垂直于 (1, 1, 1)。这意味着对于平面上的任何 *x*，*y*，和
    *z* 值，点积 (*x* − 1, *y* − 1, *z* − 1) · (1, 1, 1) 都为零。这展开后给出 (*x* − 1) + (*y* −
    1) + (*z* − 1) = 0 或 *x* + *y* + *z* = 3，这是平面的标准形式方程。|'
- en: '| **Exercise 7.19−Mini Project**: Write a Python function that takes three
    3D points as inputs and returns the standard form equation of the plane that they
    lie in. For instance, if the standard form equation is *ax* + *by* + *cz* = *d*,
    the function could return the tuple (*a*, *b*, *c*, *d*).**Hint**: Differences
    of any pairs of the three vectors are parallel to the plane, so cross products
    of the differences are perpendicular.**Solution**: If the points given are *p*[1],
    *p*[2], and *p*[3], then the vector differences like *p*[3] − *p*[1] and *p*[2]
    − *p*[1] are parallel to the plane. The cross product (*p*[2] − *p*[1]) × (*p*[3]
    − *p*[1]) is then perpendicular to the plane. (All is well as long as the points
    *p*[1], *p*[2], and *p*[3] form a triangle, so the differences are not parallel.)
    With a point in the plane (for instance, *p*[1]) and a perpendicular vector, we
    can repeat the process of finding the standard form of the solution as in the
    previous two exercises:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.19-迷你项目**：编写一个 Python 函数，该函数接受三个 3D 点作为输入，并返回它们所在的平面的标准形式方程。例如，如果标准形式方程是
    *ax* + *by* + *cz* = *d*，则该函数可以返回元组 (*a*, *b*, *c*, *d*)。**提示**：三个向量的任意两对之差都与平面平行，所以差分的叉积垂直于平面。**解答**：如果给定的点是
    *p*[1]，*p*[2]，和 *p*[3]，那么向量差如 *p*[3] − *p*[1] 和 *p*[2] − *p*[1] 都与平面平行。那么 (*p*[2]
    − *p*[1]) × (*p*[3] − *p*[1]) 的叉积就垂直于平面。只要点 *p*[1]，*p*[2]，和 *p*[3] 形成一个三角形（所以差分不平行），一切就都很好了。有了平面上的一个点（例如，*p*[1]）和一个垂直向量，我们就可以重复寻找解的标准形式的过程，就像前两个练习中那样：'
- en: '[PRE23]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For example, these are three points from the plane *x* + *y* + *z* = 3 from
    the preceding exercise:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是从先前的练习中得到的平面 *x* + *y* + *z* = 3 的三个点：
- en: '[PRE24]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The result is (3, 3, 3, 9), meaning 3*x* + 3*y* + 3*z* = 9, which is equivalent
    to *x* + *y* + *z* = 3\. That means we got it right! |
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 (3, 3, 3, 9)，意味着 3*x* + 3*y* + 3*z* = 9，这相当于 *x* + *y* + *z* = 3。这意味着我们做对了！|
- en: '| **Exercise 7.20**: How many total constants *aij* are in the following matrix
    equation? How many equations are there? How many unknowns? Write the full matrix
    equation (no dots) and the full system of linear equations (no dots).![](../Images/CH07_F26_Orland_UN03_EQ34.png)An
    abbreviated system of linear equations in matrix form**Solution**: To be clear,
    we can write out the full matrix equation first:![](../Images/CH07_F26_Orland_UN03_EQ35.png)The
    unabbreviated version of the matrix equationIn total, there are 5 · 7 = 35 entries
    in this matrix and 35 *aij* constants on the left-hand side of the equations in
    the linear system. There are 7 unknown variables: *x*[1], *x*[2], ..., *x*[7]
    and 5 equations (one per row of the matrix). You can get the full linear system
    by carrying out the matrix multiplication:*a*[11]*x*[1] + *a*[12]*x*[2] + *a*[13]*x*[3]
    + *a*[14]*x*[4] + *a*[15]*x*[5] + *a*[16]*x*[6] + *a*[17]*x*[7] = *b*[1]*a*[21]*x*[1]
    + *a*[22]*x*[2] + *a*[23]*x*[3] + *a*[24]*x*[4] + *a*[25]*x*[5] + *a*[26]*x*[6]
    + *a*[27]*x*[7] = *b*[2]*a*[31]*x*[1] + *a*[32]*x*[2] + *a*[33]*x*[3] + *a*[34]*x*[4]
    + *a*[35]*x*[5] + *a*[36]*x*[6] + *a*[37]*x*[7] = *b*[3]*a*[41]*x*[1] + *a*[42]*x*[2]
    + *a*[43]*x*[3] + *a*[44]*x*[4] + *a*[45]*x*[5] + *a*[46]*x*[6] + *a*[47]*x*[7]
    = *b*[4]*a*[5]1*x*[1] + *a*[5]2*x*[2] + *a*[5]3*x*[3] + *a*[54]*x*[4] + *a*[55]*x*[5]
    + *a*[56]*x*[6] + *a*[57]*x*[7] = *b*[5]The full system of linear equations represented
    by this matrix equationYou can see why we avoid this tedious writing with abbreviations!
    |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.20**: 在以下矩阵方程中，总共有多少个常数 *aij*？有多少个方程？有多少个未知数？写出完整的矩阵方程（不带点）和完整的线性方程组（不带点）。![](../Images/CH07_F26_Orland_UN03_EQ34.png)矩阵形式的简略线性方程组**解答**：为了清晰起见，我们首先写出完整的矩阵方程：![](../Images/CH07_F26_Orland_UN03_EQ35.png)矩阵方程的非简略版本。这个矩阵中有
    5 · 7 = 35 个条目，线性系统方程左侧有 35 个 *aij* 常数。有 7 个未知变量：*x*[1]，*x*[2]，...，*x*[7] 和 5
    个方程（每个矩阵的行一个）。你可以通过执行矩阵乘法得到完整的线性方程组：*a*[11]*x*[1] + *a*[12]*x*[2] + *a*[13]*x*[3]
    + *a*[14]*x*[4] + *a*[15]*x*[5] + *a*[16]*x*[6] + *a*[17]*x*[7] = *b*[1]*a*[21]*x*[1]
    + *a*[22]*x*[2] + *a*[23]*x*[3] + *a*[24]*x*[4] + *a*[25]*x*[5] + *a*[26]*x*[6]
    + *a*[27]*x*[7] = *b*[2]*a*[31]*x*[1] + *a*[32]*x*[2] + *a*[33]*x*[3] + *a*[34]*x*[4]
    + *a*[35]*x*[5] + *a*[36]*x*[6] + *a*[37]*x*[7] = *b*[3]*a*[41]*x*[1] + *a*[42]*x*[2]
    + *a*[43]*x*[3] + *a*[44]*x*[4] + *a*[45]*x*[5] + *a*[46]*x*[6] + *a*[47]*x*[7]
    = *b*[4]*a*[5]1*x*[1] + *a*[5]2*x*[2] + *a*[5]3*x*[3] + *a*[54]*x*[4] + *a*[55]*x*[5]
    + *a*[56]*x*[6] + *a*[57]*x*[7] = *b*[5]这个矩阵方程表示的完整线性方程组。你可以看到为什么我们用缩写来避免这种繁琐的写作！|'
- en: '| **Exercise 7.21**: Write the following linear equation without summation
    shorthand. Geometrically, what does the set of solutions look like?![](../Images/CH07_F26_Orland_UN03_EQ37.png)**Solution**:
    The left-hand side of this equation is a sum of terms of the form *x[i]* for *i*,
    ranging from 1 to 3\. That gives us *x*[1] + *x*[2] + *x*[3] = 1\. This is the
    standard form of a linear equation in three variables, so its solutions form a
    plane in 3D space. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.21**: 将以下线性方程写成不带求和简写的形式。从几何上看，解集是什么样的？！[](../Images/CH07_F26_Orland_UN03_EQ37.png)**解答**：这个方程的左侧是形式为
    *x[i]* 的项的和，其中 *i* 从 1 到 3。这给出了 *x*[1] + *x*[2] + *x*[3] = 1。这是三个变量的线性方程的标准形式，因此其解形成了一个三维空间中的平面。|'
- en: '| **Exercise 7.22**: Sketch three planes, none of which are parallel and do
    not have a single point of intersection. (Better yet, find their equations and
    graph them!)**Solution**: Here are three planes: *z* + *y* = 0, *z* − *y* = 0,
    and *z* = 3 and the graph:![](../Images/CH07_F26_Orland_UN04.png)Three non-parallel
    planes that don’t share an intersection pointI’ve drawn the intersections of the
    three pairs of planes, which are parallel lines. Because these lines never meet,
    there is no single point of intersection for all three planes. This is like the
    example you saw in chapter 6: three vectors can be linearly dependent even when
    no pair among them is parallel. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.22**: 绘制三个平面，这三个平面之间没有平行关系，并且没有唯一的交点。（更好的方法是找到它们的方程并绘制它们！）**解答**：这里有三个平面：*z*
    + *y* = 0，*z* − *y* = 0，和 *z* = 3，以及图表：![](../Images/CH07_F26_Orland_UN04.png)三个不平行且没有交点的平面。我画出了三对平面的交点，这些交点是平行线。因为这些线永远不会相交，所以这三个平面没有唯一的交点。这就像你在第
    6 章中看到的例子：即使其中没有一对向量平行，三个向量也可以线性相关。|'
- en: '| **Exercise 7.23**: Suppose we have *m* linear equations and *n* unknown variables.
    What do the following values of *m* and *n* say about whether there is a unique
    solution?'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.23**: 假设我们有一个 *m* 个线性方程和 *n* 个未知变量。以下 *m* 和 *n* 的值说明了是否存在唯一解？'
- en: '*m* = 2, *n* = 2'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*m* = 2, *n* = 2'
- en: '*m* = 2, *n* = 7'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*m* = 2, *n* = 7'
- en: '*m* = 5, *n* = 5'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*m* = 5, *n* = 5'
- en: '*m* = 3, *n* = 2'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*m* = 3, *n* = 2'
- en: '**Solution**:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**：'
- en: With two linear equations and two unknowns, there *can* be a unique solution.
    The two equations represent lines in the plane, and they will intersect at a unique
    point unless they are parallel.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当有两个线性方程和两个未知数时，可能有唯一的解。这两个方程代表平面上的线，除非它们平行，否则它们会在一个唯一点上相交。
- en: With two linear equations and seven unknowns, there *cannot* be a unique solution.
    Assuming the 6D hyperplanes defined by these equations are not parallel, there
    will be a 5D space of solutions.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当有两个线性方程和七个未知数时，不可能有唯一的解。假设由这些方程定义的 6 维超平面不是平行的，那么将会有一个 5 维的解空间。
- en: With five linear equations and five unknowns, there *can* be a unique solution,
    as long as the equations are independent.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当有五个线性方程和五个未知数时，只要方程是独立的，就可能有唯一的解。
- en: With three linear equations and two unknowns, there *can* be a unique solution,
    but it requires some luck. This would mean that the third line happens to pass
    through the intersection point of the first two lines, which is unlikely but possible.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当有三个线性方程和两个未知数时，可能会有一个唯一的解，但这需要一些运气。这意味着第三条线恰好通过前两条线的交点，这是不太可能但可能的。
- en: '![](../Images/CH07_F26_Orland_UN05.png)Three lines in the plane that happen
    to intersect at a point |'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '!![图片](../Images/CH07_F26_Orland_UN05.png)平面上三条恰好相交于一点的线 |'
- en: '| **Exercise 7.24**: Find 3 planes whose intersection is a single point, 3
    planes whose intersection is a line, and 3 planes whose intersection is a plane.**Solution**:
    The planes *z* − *y* = 0, *z* + *y* = 0, and *z* + *x* = 0 intersect at the single
    point (0, 0, 0). Most randomly selected planes will intersect at a unique point
    like this.![](../Images/CH07_F26_Orland_UN06.png)Three planes intersecting at
    a single point |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **练习 7.24**: 找出三个相交于一点的平面，三个相交于一条线的平面，以及三个相交于一个平面的平面。**解答**: 平面 *z* − *y*
    = 0, *z* + *y* = 0, 和 *z* + *x* = 0 相交于单一点 (0, 0, 0)。大多数随机选择的平面都会相交于这样一个唯一的点！![图片](../Images/CH07_F26_Orland_UN06.png)三个平面相交于一点
    |'
- en: '| The planes *z* − *y* = 0, *z* + *y* = 0, and *z* = 0 intersect on a line,
    specifically the x-axis. If you play with these equations, you’ll find both *y*
    and *z* are constrained to be zero, but *x* doesn’t even appear, so it has no
    constraints. Any vector (*x*, 0, 0) on the x-axis is, therefore, a solution.![](../Images/CH07_F26_Orland_UN07.png)Three
    planes whose intersection points form a lineFinally, if all three equations represent
    the same plane, then that whole plane is a set of solutions. For instance, *z*
    − *y* = 0, 2*z* − 2*y* = 0, and 3*z* − 3*y* = 0 all represent the same plane.![](../Images/CH07_F26_Orland_UN08.png)Three
    identical planes overlaid; their set of solutions is the whole plane. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 平面 *z* − *y* = 0, *z* + *y* = 0, 和 *z* = 0 在一条线上相交，具体是 x 轴。如果你玩弄这些方程，你会发现
    *y* 和 *z* 都被限制为零，但 *x* 甚至没有出现，所以它没有约束。因此，x 轴上的任何向量 (*x*, 0, 0) 都是解！![图片](../Images/CH07_F26_Orland_UN07.png)三个平面相交于一条线最终，如果三个方程都代表同一个平面，那么整个平面就是解集。例如，*z*
    − *y* = 0, 2*z* − 2*y* = 0, 和 3*z* − 3*y* = 0 都代表同一个平面。![图片](../Images/CH07_F26_Orland_UN08.png)三个相同的平面叠加；它们的解集是整个平面。
    |'
- en: '| **Exercise 7.25**: Without using Python, what is the solution of the system
    of linear equations in 5D? *x*[5] = 3, *x*[2] = 1, *x*[4] = −1, *x*[1] = 0, and
    *x*[1] + *x*[2] + *x*[3] = −2? Confirm the answer with NumPy.**Solution**: Because
    four of these linear equations specify the value of a coordinate, we know the
    solution has the form (0,1, *x*[3], −1,3). We need to do some algebra using the
    final equation to find out the value of *x*[3]. Because *x*[1] + *x*[2] + *x*[3]
    = −2, we know 0 + 1 + *x*[3] = −2, and *x*[3] must be −3\. The unique solution
    point is, therefore, (0, 1, −3, −1, 3). Converting this system to matrix form,
    we can solve it with NumPy to confirm we got it right:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.25**: 不使用 Python，5 维线性方程组的解是什么？*x*[5] = 3, *x*[2] = 1, *x*[4] = −1,
    *x*[1] = 0, 和 *x*[1] + *x*[2] + *x*[3] = −2？使用 NumPy 验证答案。**解答**: 因为这四个线性方程指定了坐标的值，我们知道解的形式是
    (0,1, *x*[3], −1,3)。我们需要使用最后一个方程进行一些代数运算来找出 *x*[3] 的值。因为 *x*[1] + *x*[2] + *x*[3]
    = −2，我们知道 0 + 1 + *x*[3] = −2，所以 *x*[3] 必须是 −3。因此，唯一的解点是 (0, 1, −3, −1, 3)。将这个系统转换为矩阵形式，我们可以使用
    NumPy 来解它，以确认我们得到了正确的答案：'
- en: '[PRE25]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 7.26−Mini Project**: In any number of dimensions, there is an
    identity matrix that acts as the identity map. That is, when you multiply the
    *n* -dimensional identity matrix *I* by any vector ***v***, you get the same vector
    ***v*** as a result; therefore, *I* ***v*** *=* ***v*** *.*This means that *I*
    ***v*** *=* ***w*** is an easy system of linear equations to solve: one possible
    answer for ***v*** is ***v*** = ***w***. The idea of this mini-project is that
    you can start with a system of linear equations, *a* ***v*** = ***w***, and multiply
    both sides by another matrix *B* such that (*BA*) = *I*. If that is the case,
    then you have (*BA*)***v*** = *B* ***w*** and *I* ***v*** = *B* ***w*** or ***v***
    = *B* ***w***. In other words, if you have a system *a* ***v*** = ***w***, and
    a suitable matrix *B*, then *B* ***w*** is the solution to your system. This matrix
    *B* is called the *inverse* matrix of *a*.Let’s look again at the system of equations
    we solved in section 7.3.2:![](../Images/CH07_F26_Orland_UN08_EQ38.png)Use the
    NumPy function `numpy.linalg.inv(matrix)`, which returns the inverse of the matrix
    it is given to find the inverse of the matrix on the left-hand side of the equation.
    Then, multiply both sides by this matrix to find the solution to the linear system.
    Compare your results with the results we got from NumPy’s solver.**Hint**: You
    might also want to use NumPy’s built-in matrix multiplication routine, `numpy.matmul`,
    to make computations simpler. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **练习7.26-迷你项目**：在任何维度中，都有一个单位矩阵充当单位映射。也就是说，当你将*n*维单位矩阵*I*乘以任何向量***v***时，你得到的结果向量***v***相同；因此，*I*
    ***v*** *=* ***v*** *.*这意味着*I* ***v*** *=* ***w***是一个容易解决的线性方程组：***v***的一个可能答案是***v***
    = ***w***。这个迷你项目的想法是，你可以从一个线性方程组*a* ***v*** = ***w***开始，将两边乘以另一个矩阵*B*，使得(*BA*)
    = *I*。如果是这样，那么你就有(*BA*)***v*** = *B* ***w*** 和 *I* ***v*** = *B* ***w*** 或 ***v***
    = *B* ***w***。换句话说，如果你有一个系统*a* ***v*** = ***w***，并且有一个合适的矩阵*B*，那么*B* ***w***是系统的解。这个矩阵*B*被称为*a*的*逆矩阵*。让我们再次看看我们在7.3.2节中解决的方程组！[](../Images/CH07_F26_Orland_UN08_EQ38.png)使用NumPy函数`numpy.linalg.inv(matrix)`，它返回给定矩阵的逆，来找到方程左边矩阵的逆。然后，将两边乘以这个矩阵以找到线性方程组的解。将你的结果与我们从NumPy的求解器得到的结果进行比较。**提示**：你可能还想使用NumPy的内置矩阵乘法例程`numpy.matmul`来简化计算。|'
- en: '| **Solution**: First, we can compute the inverse of the matrix using NumPy:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '| **解决方案**：首先，我们可以使用NumPy计算矩阵的逆：'
- en: '[PRE26]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The product of the inverse matrix with the original matrix gives us the identity
    matrix, having 1’s on the diagonal and 0’s elsewhere, albeit with some numerical
    error:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 逆矩阵与原矩阵的乘积给出了单位矩阵，对角线上的值为1，其他地方为0，尽管存在一些数值误差：
- en: '[PRE27]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The trick is to multiply both sides of the matrix equation by this inverse
    matrix. Here I’ve rounded the values in the inverse matrix for the sake of readability.
    We already know that the first product on the left is a matrix and its inverse,
    so we can simplify accordingly:![](../Images/CH07_F26_Orland_UN08_EQ39.png)Multiplying
    both sides of the system by the inverse matrix and simplifyingThis gives us an
    explicit formula for the solution (*x*, *y*, *z*); all we need to do is to carry
    out the matrix multiplication. It turns out `numpy.matmul` also works for matrix
    vector multiplication:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是将矩阵方程的两边都乘以这个逆矩阵。在这里，为了便于阅读，我已经对逆矩阵中的值进行了四舍五入。我们已经知道，左边的第一个乘积是一个矩阵及其逆，因此我们可以相应地简化！[](../Images/CH07_F26_Orland_UN08_EQ39.png)将系统方程的两边乘以逆矩阵并进行简化
- en: '[PRE28]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is the same as the solution we got earlier from the solver. |
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们从求解器得到的解相同。|
- en: 7.4 Changing basis by solving linear equations
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 通过解线性方程改变基
- en: 'The notion of linear independence of vectors is clearly related to the notion
    of independence of linear equations. The connection comes from the fact that solving
    a system of linear equations is the equivalent of rewriting vectors in a different
    basis. Let’s explore what this means in 2D. When we write coordinates for a vector
    like (4, 3), we are implicitly writing the vector as a linear combination of the
    standard basis vectors:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 向量线性无关的概念显然与线性方程独立性的概念有关。这种联系来自于解线性方程组相当于用不同的基重新表示向量的事实。让我们探讨这在二维空间中的含义。当我们为向量（4，3）写坐标时，我们隐式地将该向量表示为标准基向量的线性组合：
- en: (4, 3) = 4***e***[1] + 3***e***[2]
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: (4, 3) = 4***e***[1] + 3***e***[2]
- en: 'In the last chapter, you learned that the standard basis consisting of ***e***[1]
    = (1, 0) and ***e***[2] = (0, 1) is not the only basis available. For instance,
    a pair of vectors like ***u***[1] = (1, 1) and ***u***[2] = (−1, 1) form a basis
    for ℝ². As any 2D vector can be written as a linear combination of ***e***[1]
    and ***e***[2], so can any 2D vector be written as a linear combination of this
    ***u***[1] and ***u***[2]. For some *c* and *d*, we can make the following equation
    true, but it’s not immediately obvious what the values of *c* and *d* are:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了标准基由 ***e***[1] = (1, 0) 和 ***e***[2] = (0, 1) 组成，但这并不是唯一可用的基。例如，像
    ***u***[1] = (1, 1) 和 ***u***[2] = (−1, 1) 这样的向量对形成了一个基，用于 ℝ²。由于任何二维向量都可以写成 ***e***[1]
    和 ***e***[2] 的线性组合，所以任何二维向量也可以写成 ***u***[1] 和 ***u***[2] 的线性组合。对于某些 *c* 和 *d*，我们可以使以下方程成立，但并不立即明显
    *c* 和 *d* 的值是什么：
- en: '*c* · (1, 1) + *d* · (−1, 1) = (4, 2)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*c* · (1, 1) + *d* · (−1, 1) = (4, 2)'
- en: Figure 7.27 shows a visual representation of this.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27展示了这一点的直观表示。
- en: '![](../Images/CH07_F27_Orland.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F27_Orland.png)'
- en: Figure 7.27 Writing (4, 2) as a linear combination of u1 = (1, 1) and u2 = (−1,
    1)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27 将 (4, 2) 写成 u1 = (1, 1) 和 u2 = (−1, 1) 的线性组合
- en: 'As a linear combination, this equation is equivalent to a matrix equation,
    namely:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 作为线性组合，这个方程等价于一个矩阵方程，即：
- en: '![](../Images/CH07_F27_Orland_EQ40.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F27_Orland_EQ40.png)'
- en: This, too, is a system of linear equations! In this case, the unknown vector
    is written (*c*, *d*) rather than (*x*, *y*), and the linear equations hidden
    in the matrix equation are *c* − *d* = 4 and *c* + *d* = 2\. There is a 2D space
    of vectors (*c*, *d*) that define different linear combinations of ***u***[1]
    and ***u***[2], but only one simultaneously satisfies these two equations.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样是一个线性方程组！在这种情况下，未知向量是 (*c*, *d*) 而不是 (*x*, *y*)，矩阵方程中隐藏的线性方程是 *c* − *d* =
    4 和 *c* + *d* = 2。存在一个二维向量空间 (*c*, *d*)，它定义了 ***u***[1] 和 ***u***[2] 的不同线性组合，但只有一种组合同时满足这两个方程。
- en: 'Any choice of the pair (*c*, *d*) defines a different linear combination. As
    an example, let’s look at an arbitrary value of (*c*, *d*), say (*c*, *d*) = (3,
    1). The vector (3, 1) doesn’t live in the same vector space as ***u***[1] and
    ***u***[2] ; it lives in a vector space of (*c*, *d*) pairs, each of which describe
    a different linear combination of ***u***[1] and ***u***[2]. The point (*c*, *d*)
    = (3, 1) describes a specific linear combination in our original 2D space: 3***u***[1]
    + 1***u***[2] gets us to the point (*x*, *y*) = (2, 4) (figure 7.28).'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 (*c*, *d*) 对的选择都定义了一个不同的线性组合。例如，让我们考虑一个任意的 (*c*, *d*) 值，比如 (*c*, *d*) = (3,
    1)。向量 (3, 1) 不在 ***u***[1] 和 ***u***[2] 的同一向量空间中；它存在于 (*c*, *d*) 对的向量空间中，每个都描述了
    ***u***[1] 和 ***u***[2] 的不同线性组合。点 (*c*, *d*) = (3, 1) 描述了我们原始二维空间中的一个特定线性组合：3***u***[1]
    + 1***u***[2] 将我们带到点 (*x*, *y*) = (2, 4)（图7.28）。
- en: '![](../Images/CH07_F28_Orland.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F28_Orland.png)'
- en: Figure 7.28 There is a 2D space of values (*c*, *d*), where (*c*, *d*) = (3,
    1) and yields the linear combination 3*u*[1] + 1*u*[2] = (2, 4).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28 存在一个二维值空间 (*c*, *d*)，其中 (*c*, *d*) = (3, 1) 并产生线性组合 3*u*[1] + 1*u*[2]
    = (2, 4)。
- en: Recall that we’re trying to make (4, 2) as a linear combination of ***u***[1]
    and ***u***[2], so this isn’t the linear combination we were looking for. For
    *c* ***u***[1] + *d* ***u***[2] to equal (4, 2), we need to satisfy *c* − *d*
    = 4 and *c* + *d* = 2, as we saw previously.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们正在尝试将 (4, 2) 作为 ***u***[1] 和 ***u***[2] 的线性组合，所以这不是我们寻找的线性组合。为了使 *c*
    ***u***[1] + *d* ***u***[2] 等于 (4, 2)，我们需要满足 *c* − *d* = 4 和 *c* + *d* = 2，正如我们之前看到的。
- en: Let’s draw the system of linear equations in the *c*, *d* plane. Visually, we
    can tell that (3, −1) is a point that satisfies both *c* + *d* = 2 and *c* − *d*
    = 4\. This gives us the pair of scalars to use in a linear combination to make
    (4, 2) out of ***u***[1] and ***u***[2] as shown in figure 7.29.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 *c*, *d* 平面上绘制线性方程组。直观上，我们可以看出 (3, −1) 是一个满足 *c* + *d* = 2 和 *c* − *d*
    = 4 的点。这给我们提供了用于线性组合的标量对，以将 ***u***[1] 和 ***u***[2] 组合成 (4, 2)，如图7.29所示。
- en: '![](../Images/CH07_F29_Orland.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F29_Orland.png)'
- en: Figure 7.29 The point (*c*, *d*) = (3, −1) satisfies both *c* + *d* = 2 and
    *c* − *d* = 4\. Therefore, it describes the linear combination we were looking
    for.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29 点 (*c*, *d*) = (3, −1) 满足 *c* + *d* = 2 和 *c* − *d* = 4。因此，它描述了我们寻找的线性组合。
- en: 'Now we can write (4, 2) as a linear combination of two different pairs of basis
    vectors: (4, 2) = 4***e***[1] + 2***e***[2] and (4, 2) = 3***u***[1] − 1***u***[2].
    Remember, the coordinates (4, 2) are exactly the scalars in the linear combination
    4***e***[1] + 2***e***[2]. If we had drawn our axes differently, ***u***[1] and
    ***u***[2] could just as well have been our standard basis; our vector would be
    3***u***[1] − ***u***[2] and we would say its coordinates were (3, 1). To emphasize
    that coordinates are determined by our choice of basis, we can say that the vector
    has coordinates (4, 2) with respect to the standard basis, but it has coordinates
    (3, −1) with respect to the basis consisting of ***u***[1] and ***u***[2].'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 (4, 2) 写成两个不同基向量的线性组合：\( (4, 2) = 4\***e***[1] + 2\***e***[2] \) 和 \(
    (4, 2) = 3\***u***[1] − 1\***u***[2] \)。记住，坐标 (4, 2) 正是线性组合 \( 4\***e***[1] +
    2\***e***[2] \) 中的标量。如果我们画轴的方式不同，\***u***[1] 和 \***u***[2] 也可以是我们的标准基；我们的向量将是
    \( 3\***u***[1] − \***u***[2] \)，我们可以说它的坐标是 (3, 1)。为了强调坐标是由我们选择的基决定的，我们可以这样说，这个向量相对于标准基的坐标是
    (4, 2)，但相对于由 \***u***[1] 和 \***u***[2] 组成的基的坐标是 (3, −1)。
- en: Finding the coordinates of a vector with respect to a different basis is an
    example of a computational problem that is really a system of linear equations
    in disguise. It’s an important example because every system of linear equations
    can be thought of in this way. Let’s try another example, this time in 3D, to
    see what I mean.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 找到向量相对于不同基的坐标是一个计算问题，实际上是一个隐藏的线性方程组。这是一个重要的例子，因为每个线性方程组都可以这样考虑。让我们再试一个例子，这次是
    3D 的，看看我的意思。
- en: 7.4.1 Solving a 3D example
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 解决一个 3D 例子
- en: 'Let’s start by writing an example of a system of linear equations in 3D and
    then we’ll work on interpreting it. Instead of a 2-by−2 matrix and a 2D vector,
    we can start with a 3-by−3 matrix and a 3D vector:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先写一个 3D 线性方程组的例子，然后我们将解释它。与 2x2 矩阵和 2D 向量不同，我们可以从一个 3x3 矩阵和 3D 向量开始：
- en: '![](../Images/CH07_F29_Orland_EQ41.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F29_Orland_EQ41.png)'
- en: 'The unknown here is a 3D vector; we need to find three numbers to identify
    it. Doing the matrix multiplication, we can break this up into three equations:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的未知数是一个 3D 向量；我们需要找到三个数字来识别它。进行矩阵乘法，我们可以将其分解为三个方程：
- en: 1 · *x* − 1 · *y* + 0 · *z* = 1
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: \( 1 \cdot x − 1 \cdot y + 0 \cdot z = 1 \)
- en: 0 · *x* − 1 · *y* − 1 · *z* = 3
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: \( 0 \cdot x − 1 \cdot y − 1 \cdot z = 3 \)
- en: 1 · *x* + 0 · *y* + 2 · *z* = −7
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: \( 1 \cdot x + 0 \cdot y + 2 \cdot z = −7 \)
- en: This is a system of three linear equations with three unknowns, and *ax* + *by*
    + *cz* = *d* is the standard form for a linear equation in 3D. In the next section,
    we look at the geometric interpretation for 3D linear equations. (It turns out
    they represent planes in 3D as opposed to lines in 2D.)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有三个未知数和三个线性方程的系统，\( ax + by + cz = d \) 是 3D 线性方程的标准形式。在下一节中，我们将探讨 3D 线性方程的几何解释。（实际上，它们在
    3D 中代表平面，而不是 2D 中的线。）
- en: 'For now, let’s look at this system as a linear combination with coefficients
    to be determined. The previous matrix equation is equivalent to the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把这个系统看作是一个待定系数的线性组合。前面的矩阵方程等价于以下方程：
- en: '![](../Images/CH07_F29_Orland_EQ44.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F29_Orland_EQ44.png)'
- en: 'Solving this equation is equivalent to asking the question: What linear combination
    of (1, 0, 1), (−1, −1, 0), and (0, −1, 2) yields the vector (1, 3, −7)? This is
    harder to picture than the 2D example, and it is harder to compute the answer
    by hand as well. Fortunately, we know NumPy can handle systems of linear equations
    in three unknowns, so we simply pass a 3-by−3 matrix and 3D vector as inputs to
    the solver like this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 解这个方程等价于问：什么线性组合 \( (1, 0, 1) \)，\( (−1, −1, 0) \)，和 \( (0, −1, 2) \) 产生向量 \(
    (1, 3, −7) \)？这比 2D 例子更难想象，手动计算答案也更困难。幸运的是，我们知道 NumPy 可以处理三个未知数的线性方程组，所以我们只需将
    3x3 矩阵和 3D 向量作为输入传递给求解器，如下所示：
- en: '[PRE29]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The values that solve our linear system are, therefore, *x* = 3, *y* = 2, and
    *z* = −5\. In other words, these are the coefficients that build our desired linear
    combination. We can say that the vector (1, 3, −7) has coordinates (3, 2, −5)
    with respect to the basis (1, 0, 1), (−1, −1, 0), (0, −1, 2).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 解决我们的线性方程组的值是：\( x = 3 \)，\( y = 2 \)，和 \( z = −5 \)。换句话说，这些是我们构建所需线性组合的系数。我们可以这样说，向量
    \( (1, 3, −7) \) 相对于基 \( (1, 0, 1) \)，\( (−1, −1, 0) \)，\( (0, −1, 2) \) 的坐标是
    \( (3, 2, −5) \)。
- en: The story is the same in higher dimensions; as long as it is possible to do
    so, we can write a vector as a linear combination of other vectors by solving
    a corresponding system of linear equations. But, it’s not always possible to write
    a linear combination, and not every system of linear equations has a unique solution
    or even a solution at all. The question of whether a collection of vectors forms
    a basis is computationally equivalent to the question of whether a system of linear
    equations has a unique solution.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高维度的故事也是一样的；只要可能，我们可以通过求解相应的线性方程组来将一个向量表示为其他向量的线性组合。但是，并不是总能写出线性组合，并不是每个线性方程组都有一个唯一解，甚至可能没有解。一个向量集合是否构成基的问题在计算上等同于一个线性方程组是否有唯一解的问题。
- en: 'This profound connection is a good place to bookend part 1 with its focus on
    linear algebra. There will be plenty of more linear algebra nuggets throughout
    the book, but they are even more useful when we pair them with the core topic
    of part 2: calculus.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这种深刻的联系是一个很好的地方，可以用来结束第一部分，其重点是线性代数。整本书中会有很多关于线性代数的精华，但当我们把它们与第二部分的核心主题——微积分相结合时，它们就更有用了。
- en: 7.4.2 Exercises
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 练习
- en: '| **Exercise 7.27**: How can you write the vector (5, 5) as a linear combination
    of (10, 1) (3, 2)?**Solution**: This is equivalent to asking what numbers *a*
    and *b* satisfy the equation![](../Images/CH07_F29_Orland_EQ44.png)or what vector
    (*a*, *b*) satisfies the matrix equation:![](../Images/CH07_F29_Orland_EQ45.png)We
    can find a solution with NumPy:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.27**：如何将向量 (5, 5) 写成向量 (10, 1) 和 (3, 2) 的线性组合？**解答**：这相当于询问哪些数字 *a*
    和 *b* 满足方程![方程](../Images/CH07_F29_Orland_EQ44.png)或者哪个向量 (*a*, *b*) 满足矩阵方程![矩阵方程](../Images/CH07_F29_Orland_EQ45.png)。我们可以使用
    NumPy 找到一个解：'
- en: '[PRE30]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This means the linear combination (which you can check!) is as follows:![](../Images/CH07_F29_Orland_EQ46.png)
    |
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着线性组合（你可以检查！）如下所示![线性组合](../Images/CH07_F29_Orland_EQ46.png) |
- en: '| **Exercise 7.28**: Write the vector (3, 0, 6, 9) as a linear combination
    of the vectors (0, 0, 1, 1), (0, −2, −1, −1), (1, −2, 0, 2), and (0, 0, −2, 1).**Solution**:
    The linear system to solve is![](../Images/CH07_F29_Orland_EQ47.png)where the
    columns of the 4-by−4 matrix are the vectors we want to build the linear combination
    from. NumPy gives us the solution to this system:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 7.28**：将向量 (3, 0, 6, 9) 写成向量 (0, 0, 1, 1)，(0, −2, −1, −1)，(1, −2, 0,
    2) 和 (0, 0, −2, 1) 的线性组合。**解答**：要解决的线性系统是![线性系统](../Images/CH07_F29_Orland_EQ47.png)，其中
    4×4 矩阵的列是我们想要构建线性组合的向量。NumPy 给出了这个系统的解：'
- en: '[PRE31]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This means that the linear combination is![](../Images/CH07_F29_Orland_EQ48.png)
    |
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着线性组合是![线性组合](../Images/CH07_F29_Orland_EQ48.png) |
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Model objects in a 2D video game can be done as polygonal shapes built out of
    line segments.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D 视频游戏中的模型对象可以是线段构成的多边形形状。
- en: Given two vectors ***u*** and ***v***, the points of the form *u* + *tv* for
    any real number *t* lie on a straight line. In fact, any line can be described
    with this formula.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定两个向量 ***u*** 和 ***v***，形式为 *u* + *tv* 的点对于任何实数 *t* 都在一条直线上。事实上，任何直线都可以用这个公式来描述。
- en: Given real numbers *a*, *b*, and *c*, where at least one of *a* or *b* is non-zero,
    the points (*x*, *y*) in the plane satisfying *ax* + *by* = *c* lie on a straight
    line. This is called the *standard form* for the equation of a line, and any line
    can be written in this form for some choice of *a*, *b*, and *c*. Equations for
    lines are called *linear equations*.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定实数 *a*，*b* 和 *c*，其中至少有一个 *a* 或 *b* 不为零，满足 *ax* + *by* = *c* 的平面上的点 (*x*, *y*)
    在一条直线上。这被称为直线的**标准形式**，任何直线都可以通过某种选择 *a*，*b* 和 *c* 的方式写成这种形式。直线的方程被称为**线性方程**。
- en: Finding the point where two lines intersect in the plane is equivalent to finding
    the values (*x*, *y*) that simultaneously satisfy two linear equations. A collection
    of linear equations that we seek to solve simultaneously is called a *system of
    linear equations*.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在平面上找到两条直线的交点等价于找到同时满足两个线性方程的值 (*x*, *y*)。我们试图同时求解的一组线性方程称为**线性方程组**。
- en: Solving a system of two linear equations is equivalent to finding what vector
    can be multiplied by a known 2-by−2 matrix to yield a known vector.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求解两个线性方程组等价于找到什么向量可以乘以一个已知的 2×2 矩阵，以得到一个已知的向量。
- en: NumPy has a built-in function, `numpy.linalg.solve`, that takes a matrix and
    a vector and solves the corresponding system of linear equations automatically,
    if possible.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 有一个内置函数，`numpy.linalg.solve`，它接受一个矩阵和一个向量，并在可能的情况下自动求解相应的线性方程组。
- en: Some systems of linear equations cannot be solved. For instance, if two lines
    are parallel, they can have either no intersection points or infinitely many (which
    would mean they are the same line). This means there is no (*x*, *y*) value that
    simultaneously satisfies both lines’ equations. A matrix representing such a system
    is called *singular*.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些线性方程组无法求解。例如，如果两条直线平行，它们可能没有交点，或者有无限多个交点（这意味着它们是同一条直线）。这意味着没有(*x*, *y*)值可以同时满足这两条直线的方程。表示这种系统的矩阵被称为**奇异的**。
- en: Planes in 3D are the analogs of lines in 2D. They are the sets of points (*x*,
    *y*, *z*) satisfying equations of the form *ax* + *by* + *cz* = *d*.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D空间中的平面是2D空间中直线的类似物。它们是满足形式为*ax* + *by* + *cz* = *d*的方程的点集(*x*, *y*, *z*)。
- en: Two non-parallel planes in 3D intersect at infinitely many points, and specifically,
    the set of points they share form a 1D line in 3D. Three planes can have a unique
    point of intersection that can be found by solving the system of three linear
    equations representing the planes.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D空间中的两个非平行平面在无限多个点上相交，并且具体来说，它们共有的点集在3D空间中形成一条1D线。三个平面可以有一个唯一的交点，这个交点可以通过求解表示这些平面的三个线性方程组来找到。
- en: Lines in 2D and planes in 3D are both cases of *hyperplanes*, sets of points
    in *n* -dimensions that are solutions to a single linear equation.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D空间中的直线和3D空间中的平面都是**超平面**的例子，它们是**n**维空间中满足单个线性方程的点集。
- en: In *n* -dimensions, you need a system of at least *n* linear equations to find
    a unique solution. If you have exactly *n* linear equations and they have a unique
    solution, those are called *independent equations*.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**n**维空间中，你需要至少**n**个线性方程组来找到一个唯一解。如果你恰好有**n**个线性方程，并且它们有唯一解，那么这些方程被称为**独立方程**。
- en: Figuring out how to write a vector as a linear combination of a given set of
    vectors is computationally equivalent to solving a system of linear equations.
    If the set of vectors is a basis for the space, this is always possible.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定如何将一个向量表示为给定向量集的线性组合在计算上等同于求解一个线性方程组。如果向量集是空间的基，这总是可能的。
