- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Getting started with Node.js
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Node.js
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Installing Node.js and creating a project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Node.js并创建项目
- en: Creating a command-line application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个命令行应用程序
- en: Creating a reusable code library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可重用的代码库
- en: Creating a simple web server with a REST API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的带有REST API的Web服务器
- en: Reviewing a primer on asynchronous programming and promises
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查异步编程和承诺的入门指南
- en: In this book we’ll use Node.js often, and this chapter will help you become
    productive with it. You’ll learn fundamentals of creating projects and applications
    with Node.js. We’ll only cover the basics, but we’ll cover enough for you to use
    Node.js for the rest of the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将经常使用Node.js，本章将帮助您提高使用它的效率。您将学习使用Node.js创建项目和应用程序的基础知识。我们只涵盖基础知识，但我们将涵盖足够的内容，让您能够使用Node.js完成本书的其余部分。
- en: Toward the end of this chapter there’s a primer on asynchronous programming
    and promises. This is more advanced, but you’ll need it because Node.js and JavaScript
    in general rely heavily on the use of asynchronous coding.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们将介绍异步编程和承诺的基础知识。这更高级，但你需要它，因为Node.js和JavaScript在一般情况下都严重依赖于异步编程的使用。
- en: If you already have experience with Node.js and asynchronous coding, then you
    might want to skip most of this chapter and move directly to chapter 3\. First,
    though, please at least read the sections “Starting your toolkit” and “Getting
    the code and data” before you move on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经具备Node.js和异步编程的经验，那么您可能希望跳过本章的大部分内容，直接进入第3章。不过，在继续之前，请至少阅读“开始您的工具集”和“获取代码和数据”这两节。
- en: 2.1 Starting your toolkit
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 开始您的工具集
- en: A core theme of this book is building out our data-wrangling toolkit as we learn.
    We’ll start developing our toolkit in this chapter and continue to expand it as
    we go. [Table 2.1](#table2.1) lists the tools that are introduced in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的核心主题是在学习过程中构建我们的数据整理工具集。我们将在本章开始开发我们的工具集，并在继续的过程中不断扩展它。[表2.1](#table2.1)列出了本章中引入的工具。
- en: Table 2.1 Tools used in chapter 2
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1第2章中使用的工具
- en: '| **Platform** | **Tool** | **Used for** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **平台** | **工具** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Node.js | Command-line app | Applications that run from the command line
    for all manner of data-wrangling tasks |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Node.js | 命令行应用 | 运行在命令行上的各种数据整理任务的应用程序 |'
- en: '|  | Reusable code module | Organizing and reusing code in our Node.js project
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  | 可重用代码模块 | 在我们的Node.js项目中组织和重用代码 |'
- en: '| Node.js with Express | Static web server | Serving web pages and static data
    to the browser |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Node.js与Express | 静态Web服务器 | 向浏览器提供网页和静态数据 |'
- en: '|  | REST API | Serving dynamic data to web apps and visualizations |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  | REST API | 向网络应用和可视化提供动态数据 |'
- en: '| Browser | Web page / web app | Web apps for displaying data, visualizations,
    reports, and so on |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器 | 网页/网络应用 | 用于显示数据、可视化、报告等的网络应用 |'
- en: '| Node.js and Browser | Asynchronous coding | The connection between Node.js
    and the browser is asynchronous; therefore, much of your coding in JavaScript
    is asynchronous. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Node.js和浏览器 | 异步编程 | Node.js和浏览器之间的连接是异步的；因此，您在JavaScript中的大部分编码都是异步的。 |'
- en: '|  | Promises | Promises are a design pattern that helps manage asynchronous
    operations. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  | 承诺 | 承诺是一种设计模式，有助于管理异步操作。 |'
- en: 'For JavaScript developers, Node.js and the browser are our most fundamental
    tools. These days JavaScript can run in so many environments, but this book focuses
    on the main places where data wrangling happens:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript开发者来说，Node.js和浏览器是我们最基本工具。如今JavaScript可以在许多环境中运行，但本书主要关注数据整理发生的主要场所：
- en: On your development workstation for regular or ad hoc data processing, manipulation,
    and visualization
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的开发工作站上，用于常规或临时数据处理、操作和可视化
- en: On your production web server for automated data processing, access, and reporting
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的生产Web服务器上，用于自动化数据处理、访问和报告
- en: Data display, editing, and visualization in the browser
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器中的数据展示、编辑和可视化
- en: In this chapter we’ll learn how to run code under both Node.js and the browser.
    We’ll end each section with template code that you can use throughout the book
    and beyond as a starting point for your own data-wrangling projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在Node.js和浏览器下运行代码。我们将在每个部分结束时提供模板代码，您可以在本书及其它地方使用这些代码作为您自己的数据整理项目的起点。
- en: We’ll continue to work on your toolkit throughout this book, and we’ll fill
    it with code that we write, third-party libraries, and various software packages.
    As you gain experience you’ll also adopt various methods, techniques, and design
    patterns. These are mental tools, and they also form an important part of our
    toolkit. After you finish the book, my hope is that you’ll continue to build your
    toolkit through your ongoing day-to-day data wrangling.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将继续完善你的工具箱，并填充我们编写的代码、第三方库和各种软件包。随着你经验的积累，你也会采用各种方法、技术和设计模式。这些是心理工具，它们也构成了我们工具箱的重要组成部分。完成本书后，我希望你能通过日常的数据整理工作继续构建你的工具箱。
- en: 2.2 Building a simple reporting system
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 构建一个简单的报告系统
- en: It’s always useful to have a problem to solve, even when you’re learning the
    fundamentals. We’ll produce a simple report for data. We won’t delve into any
    detail on any data processing; we’ll keep this early discussion light and focused
    on Node.js development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在学习基础知识时，有一个问题去解决总是很有用的。我们将为数据生成一个简单的报告。我们不会深入任何数据处理细节；我们将保持早期讨论的简洁和专注于Node.js开发。
- en: For the examples here, we’ll reuse the reef data from chapter 1\. We aren’t
    ready yet to deal with importing the data (we’ll come back to that in chapter
    3), so we start here with data embedded directly in our code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这里的示例，我们将重用第1章中的礁石数据。我们还没有准备好处理导入数据（我们将在第3章中回到这个问题），所以我们从这里开始，将数据直接嵌入到我们的代码中。
- en: Let’s consider what we’ll build in this chapter. First, we’ll create a command-line
    application that produces a report based on data ([figure 2.1](#figure2.1)). We’re
    keeping things simple, so the data will be hard-coded into the script, and the
    “report” will be simple command-line output. After the command-line app, we’ll
    create a web server that hosts a REST API. The server will host a simple web page
    that retrieves a report from the web server and displays it in the browser ([figure
    2.2](#figure2.2)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下本章我们将要构建的内容。首先，我们将创建一个命令行应用程序，该程序基于数据生成报告（[图2.1](#figure2.1)）。我们保持事情简单，所以数据将被硬编码到脚本中，而“报告”将是简单的命令行输出。在命令行应用程序之后，我们将创建一个托管REST
    API的Web服务器。服务器将托管一个简单的网页，从Web服务器检索报告并在浏览器中显示它（[图2.2](#figure2.2)）。
- en: '![c02_01.eps](Images/c02_01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![c02_01.eps](Images/c02_01.png)'
- en: '[Figure 2.1](#figureanchor2.1) What you’re creating first: a Node.js command-line
    app to produce a report from data'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.1](#figureanchor2.1) 你首先创建的内容：一个Node.js命令行应用程序，用于从数据生成报告'
- en: '![c02_02.eps](Images/c02_02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![c02_02.eps](Images/c02_02.png)'
- en: '[Figure 2.2](#figureanchor2.2) What we’re creating second: displaying data
    in a web page that is exposed through a REST API'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.2](#figureanchor2.2) 我们接下来要创建的内容：在通过REST API公开的网页中显示数据'
- en: 2.3 Getting the code and data
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 获取代码和数据
- en: This book comes with a large set of example code and data. You can run many
    of the code listings in the book to try them out for yourself. When I say something
    such as “You can run this” or “You should run this now,” that’s an instruction
    that you should find the appropriate code and run it. When you run the code examples,
    it takes this from an academic exercise (reading the book) to a practical experience
    (running the code to see what it does), and this makes a huge difference in improving
    your learning and ability to recall this knowledge.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带大量示例代码和数据。你可以运行书中的许多代码示例来亲自尝试。当我提到“你可以运行这个”或“你现在应该运行这个”时，这是一个指令，你应该找到适当的代码并运行它。当你运行代码示例时，它将从一个学术练习（阅读本书）转变为一个实际经验（运行代码以查看它做什么），这对你提高学习和知识回忆能力有巨大的影响。
- en: You should also make your own modifications to the code and try out changes
    and experiments that interest you. Don’t be afraid to get your hands dirty and
    break the code! Experimenting and breaking the code are essential to the learning
    process, and they’re all part of the fun.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该对代码进行自己的修改，尝试你感兴趣的变化和实验。不要害怕动手实践并破坏代码！实验和破坏代码是学习过程的重要组成部分，这也是乐趣的一部分。
- en: Each chapter (besides the first and last) has its own code repository on GitHub
    containing the example code and data. This section is a short primer on how to
    get the code set up so that you can run it. Please refer to this section throughout
    the book whenever you need a refresher. You can find the code on GitHub at [https://github.com/data-wrangling-with-javascript](https://github.com/data-wrangling-with-javascript).
    Browse to that web page and you’ll see the list of code repositories. There’s
    Chapter-2, Chapter-3, and so on through to Chapter-13, plus a handful of bonus
    repositories.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个章节（除了第一和最后一章）在GitHub上都有自己的代码仓库，包含示例代码和数据。本节是关于如何设置代码以便您可以运行的简要介绍。在您需要复习时请参考本节。您可以在GitHub上找到代码：[https://github.com/data-wrangling-with-javascript](https://github.com/data-wrangling-with-javascript)。浏览到该网页，您会看到代码仓库的列表。有Chapter-2、Chapter-3等，一直到Chapter-13，还有一些额外的代码仓库。
- en: 2.3.1 Viewing the code
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 查看代码
- en: If you prefer not to run the code (but I encourage you to run it to get the
    most out of this book) or you want to start more simply, you can also browse and
    read the code online. Navigate your browser to a repository for a chapter, and
    you’ll see a list of the code and data files. You can click on any file to view
    it and read the content.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想运行代码（但我鼓励您运行代码以充分利用本书）或者您想更简单地开始，您还可以在线浏览和阅读代码。将您的浏览器导航到章节的仓库，您会看到代码和数据文件的列表。您可以点击任何文件来查看它并阅读内容。
- en: Try it now. Point your browser at the repo for this chapter at [https://github.com/data-wrangling-with-javascript/chapter-2](https://github.com/data-wrangling-with-javascript/chapter-2).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。将您的浏览器指向本章的仓库：[https://github.com/data-wrangling-with-javascript/chapter-2](https://github.com/data-wrangling-with-javascript/chapter-2)。
- en: You’ll see subdirectories such as listing-2.2, listing-2.4, and so on. Many
    of the code listings in chapter 2 can be found in these subdirectories. Navigate
    into each subdirectory to view the code files there. For example, navigate down
    to listing-2.2 and open index.js. You can now read the code for [listing 2.2](#listing2.2)
    of this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到如listing-2.2、listing-2.4等子目录。第二章中的许多代码列表都可以在这些子目录中找到。进入每个子目录查看其中的代码文件。例如，导航到listing-2.2并打开index.js。现在您可以阅读本章的[代码列表2.2](#listing2.2)。
- en: Most of the code repositories contain one file per listing, for example listing-2.1.js,
    listing-2.2.js, and so on, although in several of the repositories, for example
    with chapter 2, you’ll find subdirectories that contain multiple files for each
    code listing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码仓库每个列表只有一个文件，例如listing-2.1.js、listing-2.2.js等，尽管在几个仓库中，例如第二章，您会发现包含每个代码列表多个文件的子目录。
- en: 2.3.2 Downloading the code
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 下载代码
- en: 'As you start each chapter, you should download the code and data from the appropriate
    repository on GitHub. You can do that in one of two ways: by *downloading* a zip
    file of the code or by *cloning* the code repository.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始每个章节时，您应该从GitHub上相应的仓库下载代码和数据。您可以通过以下两种方式之一来完成：下载代码的zip文件或克隆代码仓库。
- en: The first and simplest method is to download the zip file provided by GitHub.
    For example, for this chapter, navigate your browser to the following code repository
    at [https://github.com/data-wrangling-with-javascript/chapter-2](https://github.com/data-wrangling-with-javascript/chapter-2).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种也是最简单的方法是下载GitHub提供的zip文件。例如，对于本章，将您的浏览器导航到以下代码仓库：[https://github.com/data-wrangling-with-javascript/chapter-2](https://github.com/data-wrangling-with-javascript/chapter-2)。
- en: Now find the *Clone* or *Download* button that is usually close to the top right-hand
    side of the web page. Click this button and a drop-down appears; now click *Download
    ZIP* and*a zip file will download to your downloads directory. Unpack this zip
    file and you now have a copy of the code for chapter 2.*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在找到网页右上角通常靠近顶部的“克隆”或“下载”按钮。点击此按钮，会出现一个下拉菜单；现在点击“下载ZIP”，一个zip文件将下载到您的下载目录。解压此zip文件，现在您就有了第二章代码的副本。
- en: '*The other way to get the code is to clone the Git repository. For this, you
    need Git installed on your PC. Then open a command line and change to the directory
    where you want the repository to be cloned. For example, let’s use Git to clone
    the chapter 2 repository:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*获取代码的另一种方式是克隆Git仓库。为此，您需要在您的PC上安装Git。然后打开命令行，切换到您想要克隆仓库的目录。例如，让我们使用Git克隆第二章的仓库：'
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the clone has finished, you’ll have a local copy of the code in the subdirectory
    Chapter-2.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆完成后，您将在子目录Chapter-2中拥有代码的本地副本。
- en: 2.3.3 Installing Node.js
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 安装Node.js
- en: Most of the book’s code examples are applications that run under Node.js, so
    it goes without saying that you’ll need Node.js installed before you can run many
    of the code listings.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的大多数代码示例都是在 Node.js 下运行的应用程序，所以不言而喻，在运行许多代码列表之前，你需要安装 Node.js。
- en: Section 2.4 gives a brief overview of how to choose a version and install Node.js.
    The installation process is usually straightforward, although I don’t go into
    much detail because it’s different depending on your operating system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2.4 节简要概述了如何选择版本并安装 Node.js。安装过程通常是直接的，尽管我不深入细节，因为它取决于你的操作系统。
- en: 2.3.4 Installing dependencies
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 安装依赖项
- en: For many of the examples in the book, you’ll need to install third-party dependencies
    using npm (the Node.js package manager) or Bower (a client-side package manager).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于书中许多示例，你需要使用 npm（Node.js 包管理器）或 Bower（客户端包管理器）安装第三方依赖项。
- en: In most cases, each code listing (although sometimes several code listings are
    combined) is a working Node.js application or web application. Each application
    has its own set of dependencies that must be installed before you can run the
    code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，每个代码列表（尽管有时几个代码列表会合并）都是一个可运行的 Node.js 应用程序或网络应用程序。每个应用程序都有自己的依赖项集，在运行代码之前必须安装。
- en: The key is to look for either the package.json and/or the bower.json file. These
    files indicate to you that external packages must be installed before you can
    run the code. If you try to run the code without first installing the dependencies,
    it’s not going to work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要寻找 package.json 和/或 bower.json 文件。这些文件会告诉你，在运行代码之前必须安装外部包。如果你尝试在没有先安装依赖项的情况下运行代码，它将不会工作。
- en: 'For Node.js projects, npm packages are installed by running the following command
    (in the same directory as package.json):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Node.js 项目，npm 包通过在 package.json 相同的目录下运行以下命令安装：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For web application projects, packages are installed using Bower with the following
    command (in the same directory as bower.json):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络应用程序项目，使用以下命令（在 bower.json 相同的目录下）安装包：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After installation has completed, you have all the dependencies required to
    run the code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将拥有运行代码所需的所有依赖项。
- en: 2.3.5 Running Node.js code
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 运行 Node.js 代码
- en: How you run the code depends on whether it’s a Node.js project or a web application
    project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码的方式取决于它是一个 Node.js 项目还是一个网络应用程序项目。
- en: You can identify a Node.js project or application because it will have an index.js
    (the JavaScript code that is the entry point for the application) and a package.json
    (that tracks the app’s dependencies). Using the name index.js for the entry point
    file is a common convention in the Node.js world.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下特征识别一个 Node.js 项目或应用程序：它将有一个 index.js（作为应用程序入口点的 JavaScript 代码）和一个 package.json（跟踪应用程序的依赖项）。在
    Node.js 世界中，使用 index.js 作为入口点文件的名称是一种常见的约定。
- en: 'To run a Node.js example script from this book, you’ll need to open a command
    line, change directory to the Node.js project (the same directory as the index.js
    or package.json), and run `node index.js`. For example, soon you’ll run chapter
    2’s listing-2.2 like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本书中的 Node.js 示例脚本，你需要打开命令行，切换到 Node.js 项目目录（与 index.js 或 package.json 相同的目录），并运行
    `node index.js`。例如，很快你将像这样运行第 2 章的 listing-2.2：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Most other chapters have one file per listing—for example, listing-3.1 in chapter
    3, which you’d run like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他章节每个列表都有一个文件——例如，第 3 章的 listing-3.1，你可以这样运行：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running a Node.js script is simple if you make sure you have the dependencies
    installed (by running `npm install`) and know which script you want to run.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确保已经安装了依赖项（通过运行 `npm install`）并且知道要运行哪个脚本，运行 Node.js 脚本很简单。
- en: 2.3.6 Running a web application
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.6 运行网络应用程序
- en: Several of the book’s examples are web applications that require a web server
    to host them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的许多示例都是需要网络服务器来托管它们的网络应用程序。
- en: You’ll know these projects because they’ll often have an index.html (the main
    HTML file for the web app) or an HTML file named after the listing (for example,
    listing-1.3.html), and they usually also have a bower.json (to track dependencies)
    and often also an app.js (the JavaScript code for the web app).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你会知道这些项目，因为它们通常会有一个 index.html（网络应用程序的主要 HTML 文件）或以列表命名的 HTML 文件（例如，listing-1.3.html），并且通常还会有一个
    bower.json（跟踪依赖项）和经常还有一个 app.js（网络应用程序的 JavaScript 代码）。
- en: 'Several of the more complex web apps require a custom Node.js web server, and
    these web apps are often contained within the *public* subdirectory of a Node.js
    project. To run these web apps, you run the Node.js app:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更复杂的Web应用需要自定义Node.js Web服务器，而这些Web应用通常包含在Node.js项目的*public*子目录中。要运行这些Web应用，你需要运行Node.js应用：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now navigate your browser to [http://localhost:3000/](http://localhost:3000/)
    and the web application will render in the browser. Several of the simpler web
    apps don’t need a custom Node.js web server. In those cases, we’ll host the web
    application using a tool called live-server. This is a simple command-line web
    server that you can install live globally on your system as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请将你的浏览器导航到[http://localhost:3000/](http://localhost:3000/)，Web应用将在浏览器中渲染。一些较简单的Web应用不需要自定义Node.js
    Web服务器。在这些情况下，我们将使用名为live-server的工具托管Web应用。这是一个简单的命令行Web服务器，你可以按照以下方式在你的系统上全局安装live-server：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can run live-server with no arguments in a directory that contains an index.html:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在包含index.html的目录中不带任何参数运行live-server：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This starts a web server for the web app and automatically opens a browser that
    points to it. This is a convenient way to prototype web apps and visualizations
    that don’t require (or at least don’t *yet* require) a custom web server. We’ll
    learn more about live-server and how to use it in chapter 5.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Web应用的Web服务器并自动打开指向它的浏览器。这是原型化不需要（或至少目前不需要）自定义Web服务器的Web应用和可视化的一种方便方式。我们将在第5章中了解更多关于live-server以及如何使用它的信息。
- en: 2.3.7 Getting the data
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.7 获取数据
- en: Many of the code repositories also contain data files. Usually CSV (comma-separated
    values) or JSON (JavaScript object notation) data files. To find these data files,
    search for files with .csv or .json extensions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多代码仓库也包含数据文件。通常为CSV（逗号分隔值）或JSON（JavaScript对象表示法）数据文件。要找到这些数据文件，搜索以.csv或.json扩展名结尾的文件。
- en: The code listings are set up to read in these data files automatically, but
    it’s a good idea to have a look at the data and get a feel for it. CSV files can
    be loaded in Excel or your favorite spreadsheet viewer. Both CSV and JSON files
    can also just be loaded in a text editor to view the raw data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码列表被设置为自动读取这些数据文件，但查看数据并对其有所了解是个好主意。CSV文件可以在Excel或你喜欢的电子表格查看器中打开。CSV和JSON文件也可以直接在文本编辑器中打开以查看原始数据。
- en: The data files in the GitHub repositories are used with many of the code examples
    in the book, but they’re also there for you to use however you want, for your
    own prototypes, data pipelines, and visualizations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库中的数据文件被用于书中的许多代码示例，但它们也为你提供了使用方式，无论是用于你自己的原型、数据处理管道还是可视化。
- en: 2.3.8 Getting the code for chapter 2
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.8 获取第2章的代码
- en: We’ve had a brief overview on how to get the code, install dependencies, and
    run the various listings in the book. In future chapters, the instructions on
    getting the code and data will be brief, so please come back to this chapter whenever
    you need help on this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要概述了如何获取代码、安装依赖项以及运行书中的各种列表。在未来的章节中，获取代码和数据的说明将更加简短，所以当你需要这方面的帮助时，请随时回到这一章。
- en: 'Now please get the code for chapter 2\. Download the zip file or clone the
    Chapter-2 repository at [https://github.com/data-wrangling-with-javascript/chapter-2](https://github.com/data-wrangling-with-javascript/chapter-2).
    Next, open a command line, change to the Chapter-2 directory, and you’re ready
    to start running the code examples:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请获取第2章的代码。下载zip文件或克隆[https://github.com/data-wrangling-with-javascript/chapter-2](https://github.com/data-wrangling-with-javascript/chapter-2)的Chapter-2仓库。接下来，打开命令行，切换到Chapter-2目录，你就可以开始运行代码示例了：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before you run the code for a listing, say [listing 2.2](#listing2.2) (presented
    in the next section), remember to change to the directory and install the dependencies:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行列表中的代码之前，例如[列表2.2](#listing2.2)（将在下一节中展示），请记住切换到目录并安装依赖项：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you can run the code as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以按照以下步骤运行代码：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s get into it!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 2.4 Installing Node.js
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 安装Node.js
- en: 'Node.js is our central tool, so please get it installed on your development
    PC. It can be installed for Windows, Mac, or Linux. Download the installer for
    your platform from [https://nodejs.org/en/download](https://nodejs.org/en/download).
    Installation is simple: run the installer and then follow the prompts as it walks
    you through the process. Node.js can also be installed by various package managers
    such as *apt-get* on Linux. You can read more about that at [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是我们的核心工具，所以请确保在您的开发电脑上安装它。它支持 Windows、Mac 或 Linux 系统。请从 [https://nodejs.org/en/download](https://nodejs.org/en/download)
    下载适用于您平台的安装程序。安装过程很简单：运行安装程序，然后按照提示操作。Node.js 也可以通过各种包管理器安装，例如 Linux 上的 *apt-get*。您可以在
    [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    上了解更多信息。
- en: 2.4.1 Checking your Node.js version
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 检查您的 Node.js 版本
- en: Before we get into development with Node.js, let’s check that it’s installed
    correctly with the expected version. Open a command line and run
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 Node.js 进行开发之前，让我们检查它是否已正确安装并达到预期的版本。打开命令行并运行
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should see output as shown in [figure 2.3](#figure2.3).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到如图 2.3 所示的输出。
- en: '![c02_03.png](Images/c02_03.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![c02_03.png](Images/c02_03.png)'
- en: '[Figure 2.3](#figureanchor2.3) Start a command line and verify that you have
    the right version of Node.js installed.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.3](#figureanchor2.3) 启动命令行并验证您已安装正确的 Node.js 版本。'
- en: Node.js should have been added to your *path*, so you can run it from anywhere.
    If you can’t run Node.js from the command line, try restarting your command line
    or try logging out and then back in. Finally try restarting your PC. Depending
    on your system, you might have to restart for the updated path to become available,
    or you may have to configure the path for yourself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 应该已经添加到您的 *path* 中，因此您可以从任何地方运行它。如果您无法从命令行运行 Node.js，请尝试重新启动命令行或尝试注销并重新登录。最后尝试重新启动您的电脑。根据您的系统，您可能需要重新启动以使更新的路径可用，或者您可能需要自己配置路径。
- en: '![c02_04.png](Images/c02_04.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![c02_04.png](Images/c02_04.png)'
- en: '[Figure 2.4](#figureanchor2.4) The Node.js REPL is a great way to try out small
    snippets of code and test third-party libraries.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.4](#figureanchor2.4) Node.js REPL 是尝试小段代码和测试第三方库的绝佳方式。'
- en: 2.5 Working with Node.js
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 使用 Node.js
- en: Let’s make a Node.js application!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Node.js 应用程序！
- en: 'First, we’ll create a project. Then we’ll get into the coding: we’ll build
    a command-line application followed by a simple web server.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个项目。然后我们将进入编码阶段：我们将构建一个命令行应用程序，然后是一个简单的 Web 服务器。
- en: 2.5.1 Creating a Node.js project
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 创建 Node.js 项目
- en: 'A Node.js project is a directory that contains the JavaScript code and dependencies
    that make up your Node.js application. It’s composed of a variety of files: JavaScript
    code files, package.json, and a node_modules subdirectory ([figure 2.5](#figure2.5)).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Node.js 项目是一个包含构成您的 Node.js 应用程序的 JavaScript 代码和依赖项的目录。它由各种文件组成：JavaScript
    代码文件、package.json 和一个 node_modules 子目录 ([图 2.5](#figure2.5))。
- en: '![c02_05.png](Images/c02_05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![c02_05.png](Images/c02_05.png)'
- en: '[Figure 2.5](#figureanchor2.5) A Node.js project'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.5](#figureanchor2.5) Node.js 项目'
- en: A Node.js project can contain any number of JavaScript files that are either
    entry points (runnable from the command line), reusable code modules, or possibly
    both (which can be useful for testing your code). By convention, the main entry
    point is normally called index.js.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Node.js 项目可以包含任意数量的 JavaScript 文件，这些文件可以是入口点（可以从命令行运行）、可重用的代码模块，或者两者兼而有之（这对于测试您的代码可能很有用）。按照惯例，主入口点通常被称为
    index.js。
- en: The node_modules subdirectory contains third-party packages that have been installed
    using npm, the node package manager. The file package.json contains details about
    the project and records the installed dependencies.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: node_modules 子目录包含使用 npm（Node 包管理器）安装的第三方包。文件 package.json 包含有关项目的信息并记录了已安装的依赖项。
- en: npm init
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: npm 初始化
- en: 'You usually start Node.js projects by using npm to create the initial package.json:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常通过使用 npm 创建初始的 package.json 来开始 Node.js 项目：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `–y` parameter instructs npm to fill out the details in the package file
    (see the resulting package file in [listing 2.1](#listing2.1)). If we plan to
    make the package public in the future (for example, distributed using npm), then
    we’ll have to go back and revise it later. Otherwise, we could omit the `–y` parameter
    and `npm init` will interactively prompt for those details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`–y` 参数指示 npm 填写包文件中的详细信息（参见 [列表 2.1](#listing2.1) 中的结果包文件）。如果我们计划将来将包公开（例如，通过
    npm 分发），那么我们稍后必须回去修改它。否则，我们可以省略 `–y` 参数，`npm init` 将会交互式地提示这些详细信息。'
- en: Listing 2.1 Generated npm package file
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 生成的 npm 包文件
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding the first JavaScript file
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加第一个 JavaScript 文件
- en: To get started, let’s create a Hello world program. Create an empty index.js
    file and add a `console.log` that prints `Hello world` to the console (as shown
    in the following listing).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们创建一个 Hello world 程序。创建一个空的 index.js 文件，并添加一个 `console.log` 语句，将 `Hello
    world` 打印到控制台（如下所示）。
- en: 'Listing 2.2 Your first script: Hello world'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 您的第一个脚本：Hello world
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You’ll find this code in the listing-2.2 subdirectory of the GitHub repository
    for Chapter-2, so you don’t have to type this in yourself. If you followed the
    instructions in “Getting the code and data,” you have already changed to the listing-2.2
    directory and installed dependencies, but to recap, let’s see that again:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库 Chapter-2 的列表-2.2 子目录中找到这段代码，所以你不必亲自输入。如果你遵循了“获取代码和数据”中的说明，你已经切换到了列表-2.2
    目录并安装了依赖项，但为了回顾，让我们再看一遍：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now run the code as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下方式运行代码：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you only created the project and typed in the code manually, you’d run it
    like this instead:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只创建了项目并手动输入了代码，你可以这样运行它：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You might wonder why you need to install dependencies for such a simple code
    example. Well, truth be told—you don’t! I want you to get in the habit of doing
    this because most examples do have dependencies and you do need to run `npm install`
    to download the dependencies before you run the code. You only need to do this
    once per project, though. Once you have the dependencies installed, you can run
    the code listing as many times as you want.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么你需要为这样一个简单的代码示例安装依赖项。好吧，说实话——你不需要！我想让你养成这样做的习惯，因为大多数示例确实有依赖项，你确实需要在运行代码之前运行
    `npm install` 来下载依赖项。尽管如此，你只需要在每个项目中做一次。一旦安装了依赖项，你可以多次运行代码列表。
- en: After running the script, we see `Hello world!` printed to the console.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，我们看到 `Hello world!` 被打印到控制台。
- en: 'Note that we executed the *node* application and specified the name of our
    script file (index.js). The general pattern for running a Node.js script is this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们执行了 *node* 应用程序并指定了我们的脚本文件名（index.js）。运行 Node.js 脚本的一般模式是这样的：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Replace <script-file.js> with whichever script you want to run.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `<script-file.js>` 替换为你想要运行的脚本。
- en: Installing npm dependencies
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 npm 依赖项
- en: Now let’s install a third-party dependency into your newly created Node.js project.
    I’m choosing to install moment here because it’s the best JavaScript library for
    working with dates, and I know that it will make your life easier when you need
    to work with dates and times.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将第三方依赖项安装到您新创建的 Node.js 项目中。我选择在这里安装 moment，因为它是最适合处理日期的 JavaScript 库，我知道当你需要处理日期和时间时，它会让你更容易。
- en: 'If you’re working with a fresh Node.js project, you can install the moment
    package into your project like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一个新的 Node.js 项目，你可以像这样将 moment 包安装到你的项目中：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note the `--save` parameter saves the dependency in package.json and tracks
    the version number (the updated file is shown in [listing 2.3](#listing2.3)).
    As we install each dependency, they’re all recorded, which means we can easily
    restore these packages again later with this command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `--save` 参数将依赖项保存到 package.json 并跟踪版本号（更新后的文件显示在 [列表 2.3](#listing2.3) 中）。随着我们安装每个依赖项，它们都会被记录下来，这意味着我们可以很容易地稍后使用此命令再次恢复这些包：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Listing-2.3 doesn’t have code in the GitHub repository, but if you want to try
    doing this, you can practice by installing the moment dependency into the listing-2.2
    code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表-2.3 在 GitHub 仓库中没有代码，但如果你想尝试这样做，你可以通过将 moment 依赖项安装到列表-2.2 代码中来练习。
- en: Listing 2.3 package.json with the addition of the moment dependency
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 包含 moment 依赖项的 package.json
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Installing dependencies and tracking the version that’s installed is great.
    It means we don’t have to commit our dependencies to version control. Because
    we can restore packages at any time (using `npm install`), we can streamline our
    project, which makes it super-fast to clone or copy the code for new developers
    or when we’re installing it on a new PC.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 安装依赖项并跟踪已安装的版本是很好的。这意味着我们不需要将依赖项提交到版本控制。因为我们可以在任何时候恢复包（使用`npm install`），我们可以简化我们的项目，这使得对于新开发者或在我们将代码安装到新PC上时，克隆或复制代码变得超级快。
- en: Finding useful packages
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找有用的包
- en: We can install as many packages as we need using npm and have so many useful
    packages at our fingertips. Point your browser at [http://www.npmjs.com](http://www.npmjs.com)
    and look now. Enter a search string and you’ll find existing code libraries and
    command-line tools to help you accomplish all sorts of tasks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用npm安装我们需要的任何数量的包，并且手头上有许多有用的包。将你的浏览器指向[http://www.npmjs.com](http://www.npmjs.com)并查看。输入一个搜索字符串，你会找到现有的代码库和命令行工具，帮助你完成各种任务。
- en: 2.5.2 Creating a command-line application
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 创建命令行应用程序
- en: Command-line applications are useful for all manner of data processing, transformation,
    and analysis tasks. Our aim here is to create a simple application to produce
    a report from data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行应用程序对于各种数据处理、转换和分析任务都很有用。我们的目标是创建一个简单的应用程序，从数据生成报告。
- en: We’ve already added a script to our Node.js project that prints “Hello world”
    to the console. This is already a basic command-line application, but we need
    it to do more. The output from your application is a simple report, an example
    of which you can see in [figure 2.6](#figure2.6).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向我们的Node.js项目添加了一个脚本，该脚本将“Hello world”打印到控制台。这已经是一个基本的命令行应用程序，但我们需要它做更多的事情。你的应用程序的输出是一个简单的报告，你可以通过[图2.6](#figure2.6)中的示例看到。
- en: '![c02_06.png](Images/c02_06.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![c02_06.png](Images/c02_06.png)'
- en: '[Figure 2.6](#figureanchor2.6) Output from your simple command-line application:
    printing a basic report about our data'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.6](#figureanchor2.6) 你简单命令行应用程序的输出：打印关于我们数据的基本报告'
- en: To keep things simple for this getting started chapter, we’ll include data directly
    in the script. This isn’t scalable or convenient, and ideally, we’d load the data
    from a file or database, although we haven’t covered importing data yet, so that’s
    something that we’ll return to in chapter 3.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使入门章节的内容简单，我们将直接在脚本中包含数据。这并不具有可扩展性或便利性，理想情况下，我们会从文件或数据库中加载数据，尽管我们还没有介绍如何导入数据，所以这是我们在第3章中会再次讨论的内容。
- en: '[Figure 2.7](#figure2.7) shows the data hard-coded in the JavaScript file.
    We’re reusing a tiny extract of the reef data from chapter 1\. Our command-line
    app will print a simple summary of the hard-coded data: the number of rows, the
    number of columns, and the names of the columns. You can see the code in [listing
    2.4](#listing2.4); make sure you jump into the code repository and run this script
    to see the output.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.7](#figure2.7)显示了硬编码在JavaScript文件中的数据。我们正在重用第1章中关于礁石数据的一小部分。我们的命令行应用程序将打印硬编码数据的简单摘要：行数、列数和列名。你可以在[列表2.4](#listing2.4)中看到代码；确保你跳入代码仓库并运行此脚本以查看输出。'
- en: '![c02_07.png](Images/c02_07.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![c02_07.png](Images/c02_07.png)'
- en: '[Figure 2.7](#figureanchor2.7) Simple hard-coded data embedded in your JavaScript
    file index.js'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.7](#figureanchor2.7) 在你的JavaScript文件index.js中嵌入的简单硬编码数据'
- en: Listing 2.4 A basic command-line app to produce a simple report from your data
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 从你的数据生成简单报告的基本命令行应用程序
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Generating this report is far from rocket science, but here we want to focus
    on creating a simple command-line application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这个报告远非火箭科学，但在这里我们想要专注于创建一个简单的命令行应用程序。
- en: General pattern for a command-line app
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命令行应用程序的一般模式
- en: The following listing gives you a general pattern and template for your future
    command-line applications. Add the logic that you need.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表为你提供了未来命令行应用程序的一般模式和模板。添加你需要的逻辑。
- en: Listing 2.5 General pattern for a command-line app
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 命令行应用程序的一般模式
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can do more with command-line applications, but that’s enough for now. Note
    that I’ve added extra npm modules to the template. Yargs is used for reading command-line
    arguments for input. The Chai assert library is used for validation and error
    handling and reporting.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用命令行应用程序做更多的事情，但现在这些已经足够了。请注意，我已经在模板中添加了额外的npm模块。Yargs用于读取命令行输入参数。Chai断言库用于验证、错误处理和报告。
- en: 2.5.3 Creating a code library
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 创建代码库
- en: Sometimes we might code an entire command-line app in a single file, but we
    can only do this when the job is small enough. As the script grows, we can reduce
    complexity by abstracting code and extracting it to reusable modules.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能会在一个单独的文件中编写整个命令行应用程序，但我们只能在任务足够小的时候这样做。随着脚本的扩展，我们可以通过抽象代码并将其提取到可重用模块中来降低复杂性。
- en: Let’s move our `generateReport` function to a separate code module. To do this,
    create a new JavaScript file, say generate-report.js. Move `generateReport` to
    this new file, as shown in the following listing. The function is exported from
    the code module by assigning it to `module.exports`, a specially named Node.js
    variable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `generateReport` 函数移动到一个单独的代码模块中。为此，创建一个新的 JavaScript 文件，例如 generate-report.js。将
    `generateReport` 移动到这个新文件中，如下列表所示。通过将函数分配给特别命名的 Node.js 变量 `module.exports`，函数从代码模块中导出。
- en: Listing 2.6 The `generateReport` function is moved to a reusable code module
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 将 `generateReport` 函数移动到可重用代码模块
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code module can now be imported into your command-line app (or indeed any
    other code module) using Node’s `require` function as shown in [listing 2.7](#listing2.7).
    This is much the same as you already saw for importing third-party npm libraries,
    although to import our own libraries, we must specify an absolute or relative
    path. In [listing 2.7](#listing2.7), we load our module using the path ./generate-report.js,
    because this indicates the module resides in the same directory. Both listings
    2.6 and 2.7 work together; you’ll find them together in the code repository, and
    to try them out, you only need to run the index.js script.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用 Node 的 `require` 函数将代码模块导入到您的命令行应用程序（或者实际上任何其他代码模块）中，如下[列表 2.7](#listing2.7)所示。这与您已经看到的导入第三方
    npm 库非常相似，尽管为了导入我们自己的库，我们必须指定一个绝对或相对路径。在[列表 2.7](#listing2.7)中，我们使用路径 ./generate-report.js
    加载我们的模块，因为这表明模块位于同一目录中。列表 2.6 和 2.7 一起工作；您将在代码仓库中找到它们，要尝试它们，您只需要运行 index.js 脚本。
- en: Listing 2.7 Importing the `generateReport` function into your command-line app
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 将 `generateReport` 函数导入到您的命令行应用程序
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: General pattern for a code library
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码库的一般模式
- en: The following listing is a template that you can use to create reusable toolkit
    functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是一个模板，您可以使用它来创建可重用工具包函数。
- en: Listing 2.8 General pattern for exporting a reusable toolkit function
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 导出可重用工具包函数的一般模式
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note in [listing 2.8](#listing2.8) that only a single function is exported.
    We can also export an object, and this allows us to export a library of functions.
    An example of this is shown in the following listing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[列表 2.8](#listing2.8)中，只导出了一个单个函数。我们也可以导出一个对象，这允许我们导出一个函数库。以下列表展示了这一点的例子。
- en: Listing 2.9 General pattern for exporting a library of reusable functions
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 导出可重用函数库的一般模式
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 2.5.4 Creating a simple web server
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 创建简单的 Web 服务器
- en: We created a command-line application in Node.js, and now we’ll learn how to
    create a simple web server. The reason we need a web server is so that we can
    build web apps and visualizations. First, we’ll create the simplest possible web
    server (the output is shown in [figure 2.8](#figure2.8)). Then we’ll add support
    for static files, which gives us a basic foundation for building web visualizations.
    Last, we’ll add a REST API that allows us to create web visualizations based on
    dynamic data, such as data loaded from a database or data that has been dynamically
    processed by the server.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Node.js 中创建了一个命令行应用程序，现在我们将学习如何创建一个简单的 Web 服务器。我们需要 Web 服务器的理由是我们可以构建 Web
    应用和可视化。首先，我们将创建最简单的 Web 服务器（输出显示在[图 2.8](#figure2.8)中）。然后我们将添加对静态文件的支持，这为我们构建
    Web 可视化提供了一个基本的基础。最后，我们将添加一个 REST API，允许我们根据动态数据创建 Web 可视化，例如从数据库加载的数据或服务器动态处理的数据。
- en: '![c02_08.png](Images/c02_08.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![c02_08.png](Images/c02_08.png)'
- en: '[Figure 2.8](#figureanchor2.8) Output from the simplest web server'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.8](#figureanchor2.8) 最简单 Web 服务器的输出'
- en: The first iteration of your web server is rather basic and far from production-ready,
    but that’s all you need to start prototyping web visualizations. At a point, though,
    we’d like to scale up and deliver your web visualizations to many thousands of
    users, but we’ll save production issues until chapter 14 and focus here on the
    basics.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Web 服务器第一次迭代相当基础，远未达到生产就绪状态，但这就是您开始原型设计 Web 可视化所需的一切。然而，在某个时刻，我们希望扩展并服务于成千上万的用户，但我们将生产问题留到第
    14 章讨论，这里我们专注于基础知识。
- en: You should note that a Node.js web server is still a command-line application.
    We’ll continue to build on what we already learned, although we’re now ramping
    up the complexity and creating a *client/server* type application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意，Node.js Web 服务器仍然是一个命令行应用程序。我们将继续构建我们已学到的内容，尽管我们现在正在提高复杂性并创建一个*客户端/服务器*类型的应用程序。
- en: Installing Express
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 Express
- en: 'To build our web server, we’ll use Express: a popular Node.js framework for
    building web servers. We can install Express in a fresh Node.js project using
    npm as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的 Web 服务器，我们将使用 Express：一个流行的 Node.js 框架，用于构建 Web 服务器。我们可以使用 npm 在新的 Node.js
    项目中安装 Express，如下所示：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although if you’re running the example code from [listing 2.10](#listing2.10)
    in the GitHub repo, you need to run `npm install` in the listing-10 subdirectory
    to restore the already-registered Express dependency.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如果您正在 GitHub 仓库中运行[列表 2.10](#listing2.10)中的示例代码，您需要在列表-10 子目录中运行`npm install`以恢复已注册的
    Express 依赖项。
- en: Simplest possible web server
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最简单的 Web 服务器
- en: The simplest possible web server is created by instantiating an Express app
    and instructing it to listen for incoming HTTP requests. Your first web server
    handles a single route and returns the text “This is a web page!” You can see
    how easy this is in [listing 2.10](#listing2.10), which shows the index.js file
    for your first and simplest web server*.*
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '最简单的 Web 服务器是通过实例化一个 Express 应用并指示它监听传入的 HTTP 请求来创建的。您的第一个 Web 服务器处理单个路由并返回文本“这是一个网页！”您可以在[列表
    2.10](#listing2.10)中看到这一点，该列表显示了您第一个和最简单的 Web 服务器的index.js文件*.* '
- en: Listing 2.10 The simplest possible web server
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 最简单的 Web 服务器
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You should try running this code. Change to the listing-2.10 subdirectory, install
    dependencies with `npm install,` and then run `node index.js`. Now we have a Node.js
    web server! Point your browser at [http://localhost:3000](http://localhost:3000)
    to see the web page. You’ll see “This is a web page!” in your browser (as was
    shown in figure ).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该尝试运行此代码。切换到列表-2.10 子目录，使用`npm install`安装依赖项，然后运行`node index.js`。现在我们有一个 Node.js
    Web 服务器！将您的浏览器指向[http://localhost:3000](http://localhost:3000)以查看网页。您将在浏览器中看到“这是一个网页！”（如图所示）。
- en: Serving static files
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Having a web page that prints “This is a web page!” isn’t spectacularly useful,
    but we can easily expand it to serve *static files* that are the foundations of
    any web page, and are simple web assets such as HTML, JavaScript, and CSS files.
    We’ll have a *public* subdirectory under our Node.js project, and this is where
    we’ll keep the static assets for your web app (see [figure 2.9](#figure2.9)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 打印“这是一个网页！”的网页并不特别有用，但我们可以轻松地将其扩展以提供*静态文件*，这些文件是任何网页的基础，并且是简单的 Web 资产，如 HTML、JavaScript
    和 CSS 文件。我们将在 Node.js 项目下有一个*公共*子目录，我们将在这里保存 Web 应用的静态资产（参见[图 2.9](#figure2.9)）。
- en: To add static files to our web server, we’ll use the Express static files middleware.
    You can see the code for the expanded web server in the following listing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的 Web 服务器添加静态文件，我们将使用 Express 静态文件中间件。您可以在以下列表中看到扩展的 Web 服务器的代码。
- en: Listing 2.11 Adding static files to your web server
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 向您的 Web 服务器添加静态文件
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our web server can now serve static files, and we can create a basic HTML page
    to test it. You can see the HTML file for your expanded *simplest possible web
    page* in the following listing; this file lives in the `public` subdirectory as
    index.html.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的 Web 服务器可以提供静态文件，我们可以创建一个基本的 HTML 页面来测试它。您可以在以下列表中看到您扩展的*最简单的网页*的 HTML
    文件；此文件位于`public`子目录中，名为index.html。
- en: '![c02_09.eps](Images/c02_09.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![c02_09.eps](Images/c02_09.png)'
- en: '[Figure 2.9](#figureanchor2.9) Static files are served from the public subdirectory.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.9](#figureanchor2.9) 静态文件从公共子目录中提供服务。'
- en: Listing 2.12 Simplest web page
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 最简单的网页
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now run your web server again and point your web browser at [http://localhost:3000](http://localhost:3000).
    You should see “This is a static web page!” For more information on Express, please
    see the Express web page at [http://www.e](http://www.e)[xpressjs.com](http://xpressjs.com).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行您的 Web 服务器，并将您的 Web 浏览器指向[http://localhost:3000](http://localhost:3000)。您应该看到“这是一个静态网页！”有关
    Express 的更多信息，请参阅 Express 网页[http://www.e](http://www.e)[xpressjs.com](http://xpressjs.com)。
- en: Serving static data files
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提供静态数据文件
- en: We now have the tools to build a web server that can host a basic web visualization.
    We even have a simple way to get data to the web browser for our visualization!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了构建可以托管基本 Web 可视化的 Web 服务器的工具。我们甚至有一种简单的方法将数据传输到 Web 浏览器以供我们的可视化使用！
- en: In addition to regular web assets, we can also put *static data—*for example,
    CSV and JSON files—into our *public* subdirectory, and from there we can load
    them into our web page using AJAX HTTP requests. You may have noticed in [figure
    2.9](#figure2.9) that I had also snuck a CSV data file into the public subdirectory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的 Web 资产外，我们还可以将 *静态数据*（例如，CSV 和 JSON 文件）放入我们的 *public* 子目录中，然后我们可以通过 AJAX
    HTTP 请求将它们加载到我们的网页中。你可能已经注意到，在 [图 2.9](#figure2.9) 中，我也偷偷地将一个 CSV 数据文件放入了公共子目录中。
- en: Adding a REST API
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加 REST API
- en: Using static data is great for getting started or prototyping, and it might
    even be all that you need! If, however, you need to access data from a database
    or dynamically process data before it is served to the browser, then you need
    a REST API. In this next example, we’re going to generate our report in the server
    using the `generateReport` function we created earlier. We aren’t doing anything
    particularly fancy, except displaying formatted data in a web page, an example
    of which can be seen in [figure 2.10](#figure2.10).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态数据对于入门或原型设计来说很棒，甚至可能就是你所需要的全部！然而，如果你需要从数据库访问数据或在数据被发送到浏览器之前动态处理数据，那么你需要一个
    REST API。在接下来的示例中，我们将使用我们之前创建的 `generateReport` 函数在服务器上生成我们的报告。我们并没有做任何特别复杂的事情，只是在一个网页中显示格式化的数据，这在
    [图 2.10](#figure2.10) 中可以看到。
- en: To build a REST API, we must define *routes* that are addressed by URLs to retrieve
    dynamic data through HTTP requests. You can see an example of a REST API in [figure
    2.11](#figure2.11), where we navigated our browser to [http://localhost:3000/rest/data](http://localhost:3000/rest/data)
    to view data retrieved from the REST API.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 REST API，我们必须定义 *路由*，这些路由通过 URL 来访问，通过 HTTP 请求检索动态数据。你可以在 [图 2.11](#figureanchor2.11)
    中看到一个 REST API 的示例，我们在浏览器中导航到 [http://localhost:3000/rest/data](http://localhost:3000/rest/data)
    来查看从 REST API 获取的数据。
- en: We can add a route to our existing web server by calling the Express `get` function.
    We must specify the route and provide a handler for it. For example, in the following
    listing we specify the route as `/rest/report` and as a response, you return your
    data in JSON format. Now you can say that your web server handles HTTP GET for
    the route `/rest/data`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 Express 的 `get` 函数向现有的 Web 服务器添加一个路由。我们必须指定路由并提供一个处理程序。例如，在下面的列表中，我们指定路由为
    `/rest/report`，作为响应，你以 JSON 格式返回你的数据。现在你可以说你已经配置了你的 Web 服务器来处理 `/rest/data` 路由的
    HTTP GET 请求。
- en: Listing 2.13 Adding a REST API to your web server to dynamically generate a
    report
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.13 向您的 Web 服务器添加 REST API 以动态生成报告
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In [listing 2.13](#listing2.13) we’re returning the report that’s generated
    from the hard-coded data. The data never changes so it technically isn’t necessary
    to use a REST API in this situation. We could have used static data, although
    I hope you can appreciate that we’re now ready to scale this web application up
    to using a real database instead of the hard-coded data, something we’ll explore
    further in chapter 3.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 2.13](#listing2.13) 中，我们返回的是从硬编码的数据生成的报告。数据永远不会改变，所以在这种情况下技术上并不需要使用 REST
    API。我们可以使用静态数据，尽管我希望你能理解我们现在已经准备好将这个 Web 应用程序扩展到使用真正的数据库，而不是硬编码的数据，这一点我们将在第 3
    章中进一步探讨。
- en: '![c02_10.png](Images/c02_10.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![c02_10.png](Images/c02_10.png)'
- en: '[Figure 2.10](#figureanchor2.10) Generating a basic report on the server and
    displaying it in the browser'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.10](#figureanchor2.10) 在服务器上生成基本报告并在浏览器中显示'
- en: '![c02_11.png](Images/c02_11.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![c02_11.png](Images/c02_11.png)'
- en: '[Figure 2.11](#figureanchor2.11) JSON data from the REST API viewed in the
    browser'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.11](#figureanchor2.11) 在浏览器中查看 REST API 的 JSON 数据'
- en: We can add as many routes as we need to our web server, using more calls to
    the `get` function. Note that `HTTP GET` is usually for retrieving data from a
    web server. We can also push data to a web server by handling `HTTP POST` requests
    with the Express `post` function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多的 `get` 函数调用，向我们的 Web 服务器添加我们需要的任意多的路由。请注意，`HTTP GET` 通常用于从 Web 服务器检索数据。我们也可以通过使用
    Express 的 `post` 函数处理 `HTTP POST` 请求来向 Web 服务器推送数据。
- en: Using AJAX is simple if we have a library such as the traditional jQuery, the
    more modern Axios, or the $http service from AngularJS. The code to query the
    REST API and display the data in the browser is shown in the following listing.
    For convenience, the JavaScript code has been embedded directly in the HTML file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有像传统的 jQuery、更现代的 Axios 或 AngularJS 的 $http 服务这样的库，使用 AJAX 就很简单了。查询 REST
    API 并在浏览器中显示数据的代码如下所示。为了方便，JavaScript 代码已被直接嵌入到 HTML 文件中。
- en: Listing 2.14 Simple web page that displays a report retrieved from a REST API
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.14 简单的网页，显示从 REST API 获取的报告
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running this code is a little more complex than before. As usual, we need to
    install dependencies for the Node.js project:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码比之前复杂一些。像往常一样，我们需要为Node.js项目安装依赖项：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But now we also have a web application project under the *public* subdirectory.
    We’ll use Bower to install its dependencies:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们还有一个位于*public*子目录下的web应用程序项目。我们将使用Bower来安装其依赖项：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now you can change back to the Node.js project and start the web server:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以切换回Node.js项目并启动web服务器：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Point your browser at [http://localhost:3000](http://localhost:3000)[,](http://,)
    and you’re now looking at a web application that’s using AJAX to retrieve data
    from the web server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的浏览器指向[http://localhost:3000](http://localhost:3000)[，](http://,)你现在正在查看一个使用AJAX从web服务器检索数据的web应用。
- en: Where are we now? We have the ability to create command-line tools for processing
    data or other tasks. We can build a simple web server to host a web app or visualization.
    We’ve extended our web app to use a REST API, and this will allow us to do server-side
    processing of our data or to connect the web app to a database, both of which
    we’ll look at later in the book. These are fundamental tools that we’ll rely on
    in this book; however, we still need to talk about asynchronous coding.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在哪里？我们有了创建用于处理数据或其他任务的命令行工具的能力。我们可以构建一个简单的web服务器来托管web应用或可视化。我们已经扩展了我们的web应用以使用REST
    API，这将允许我们在本书的后面部分对数据进行服务器端处理，或者将web应用连接到数据库，这两者我们都会在本书的后面部分探讨。这些是我们在这本书中将依赖的基本工具；然而，我们仍然需要讨论异步编程。
- en: 2.6 Asynchronous coding
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 异步编程
- en: Why is asynchronous coding important, and why do we need to address it early
    on? It’s important because JavaScript and Node.js rely heavily on the asynchronous
    coding paradigm, and we’re going to use it many times in this book. The rest of
    this chapter is a short primer on asynchronous coding. This is a difficult topic,
    but it’s important that we tackle it now.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么异步编程很重要，为什么我们需要尽早解决它？这是因为JavaScript和Node.js高度依赖于异步编程范式，而且在这本书中我们将多次使用它。本章的其余部分是对异步编程的简要介绍。这是一个困难的话题，但我们现在解决它非常重要。
- en: When coding in JavaScript, we’ll often find ourselves doing *asynchronous coding*.
    The nature of the connection between the browser and the web server *is* asynchronous,
    and much of Node.js is designed around this concept. We’ve done asynchronous coding
    already in this chapter. Did you notice? In the last few code listings, when we
    started our web server by calling the `listen` function, that was our first taste
    of asynchronous coding.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当用JavaScript编程时，我们经常会发现自己在进行*异步编程*。浏览器和web服务器之间的连接*本质上是异步的*，Node.js的大部分设计都是围绕这个概念。我们在本章中已经进行了异步编程。你注意到了吗？在上一个代码示例中，当我们通过调用`listen`函数启动web服务器时，这是我们第一次接触异步编程。
- en: 'What’s the difference between synchronous and asynchronous coding? With synchronous
    coding, each line of code completes in order: by the time the next line of code
    executes, the effects of the previous line of code have finished. This is the
    way coding works by default in most programming languages. When coding is done
    in this way, it’s easy to understand what’s going on and easy to predict what’s
    going to happen. This is because with synchronous coding things happen one after
    the other in a way that’s predicable. But with asynchronous coding, we find that
    the code can execute *out of line* with the main code flow. This potential for
    out of order execution makes it much more difficult to understand the flow of
    your code, and it’s harder to predict what the final sequence of code will look
    like.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 同步编程和异步编程有什么区别？在同步编程中，每一行代码按顺序完成：在下一行代码执行之前，上一行代码的效果已经完成。这是大多数编程语言默认的编程方式。以这种方式进行编程时，很容易理解正在发生的事情，也容易预测将要发生的事情。这是因为同步编程中事情是按顺序一个接一个发生的，这种方式是可预测的。但是，在异步编程中，我们发现代码可以与主代码流*并行执行*。这种执行顺序不固定的可能性使得理解代码的流程变得更加困难，也更难预测最终的代码序列。
- en: Asynchronous coding is especially common in Node.js. In certain cases—for example,
    with file operations—Node.js gives both synchronous and asynchronous options.
    Which should you use? Well, it depends on your situation. Synchronous coding is
    certainly simpler and easier when you can get away with it. In other cases, for
    example, working with REST APIs and databases, you must do asynchronous coding
    because the API gives you no alternate options.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，异步编码特别常见。在某些情况下——例如，文件操作——Node.js提供了同步和异步两种选项。你应该使用哪一种？嗯，这取决于你的情况。当你能够避免使用同步编码时，同步编码当然更简单、更容易。在其他情况下，例如，处理REST
    API和数据库时，你必须进行异步编码，因为API没有提供其他选项。
- en: 'In this book I try to use only asynchronous coding as much as possible, even
    when it might be possible to use synchronous versions of functions. I do this
    for two reasons. One, I want to demonstrate consistency, and I’m hoping in the
    long run that this leads to less confusion. Two, when working on production systems,
    I tend to prefer asynchronous coding. Besides the fact that most APIs mandate
    this, it’s part of the Node.js culture. Node.js was designed to be *asynchronous
    first*: that’s how we can use it to build a responsive and performant server,
    and you can’t ever go far in Node.js without running into asynchronous coding.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我尽量只使用异步编码，即使可能使用函数的同步版本。我这样做有两个原因。一是我想展示一致性，并希望从长远来看这能减少混淆。二是当在生产系统上工作时，我倾向于更喜欢异步编码。除了大多数API强制要求这样做之外，这也是Node.js文化的一部分。Node.js被设计为首先考虑异步：这就是我们如何用它来构建响应式和性能良好的服务器，而且你如果不运行异步编码，在Node.js中很难走得很远。
- en: In the following sections, I explain the differences between synchronous and
    asynchronous coding and why and when asynchronous coding is necessary. I’ll give
    an overview of the three major difficulties you’ll face when doing asynchronous
    coding, and then I’ll explain how promises help alleviate these problems. Finally,
    I’ll briefly touch on the new JavaScript keywords `async` and `await` that make
    asynchronous coding much easier in the latest version of Node.js.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将解释同步和异步编码之间的区别，以及为什么和何时需要异步编码。我会概述你在进行异步编码时将面临的三种主要困难，然后解释承诺如何帮助缓解这些问题。最后，我将简要介绍Node.js最新版本中的新JavaScript关键字`async`和`await`，这些关键字使异步编码变得更加容易。
- en: 2.6.1 Loading a single file
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.1 加载单个文件
- en: 'Let’s consider the simplest real example of asynchronous coding that I can
    imagine: loading a file. Say you want to load a data file called bicycle_routes.txt.
    You might want to transform the data in the file, deliver the data to a web application,
    or generate a report from the data. Whatever you want to do you, first you must
    load the file.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个最简单的异步编码的实际例子：加载文件。比如说你想加载一个名为bicycle_routes.txt的数据文件。你可能想转换文件中的数据，将数据交付给Web应用，或者从数据中生成报告。无论你想做什么，首先你必须加载这个文件。
- en: '![c02_12.eps](Images/c02_12.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![c02_12.eps](Images/c02_12.png)'
- en: '[Figure 2.12](#figureanchor2.12) Synchronous code flow when loading a file'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.12](#figure2.12) 加载文件时的同步代码流程'
- en: '[Figure 2.12](#figure2.12) shows how to do this synchronously. We call Node’s
    `readFileSync` function to start the file loading. The file is then loaded into
    memory. Afterward, control returns to the line of code following the call to `readFileSync`.
    From there, your code continues to execute, and we can work with the data that
    was loaded from the file.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.12](#figure2.12) 展示了如何同步地完成这项操作。我们调用Node的`readFileSync`函数来开始文件加载。然后文件被加载到内存中。之后，控制权返回到调用`readFileSync`之后的代码行。从那里，你的代码继续执行，我们可以处理从文件中加载的数据。'
- en: 'Synchronous coding is simple and easy to explain. But it has a big problem:
    it blocks the main thread from doing any other work *during* the synchronous operation
    ([figure 2.13](#figure2.13)).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 同步编码简单且易于解释。但它有一个大问题：在同步操作期间，它会阻塞主线程执行任何其他工作（[图2.13](#figure2.13)）。
- en: '![c02_13.eps](Images/c02_13.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![c02_13.eps](Images/c02_13.png)'
- en: '[Figure 2.13](#figureanchor2.13) The main thread is blocked during a synchronous
    operation.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.13](#figureanchor2.13) 同步操作期间主线程被阻塞。'
- en: 'When a blocking operation happens in a UI-based application, the UI becomes
    unresponsive. When this happens in Node.js, your server becomes unresponsive:
    for the duration of the synchronous operation, the server can no longer respond
    to HTTP requests. If the operation is over quickly, as it is in this trivial example,
    it makes little difference: incoming HTTP requests are queued and actioned as
    soon as the main thread is unblocked.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于 UI 的应用程序发生阻塞操作时，UI 变得无响应。当这种情况在 Node.js 中发生时，你的服务器变得无响应：在同步操作期间，服务器无法再响应
    HTTP 请求。如果操作很快完成，就像在这个简单的例子中一样，这几乎没有影响：进入的 HTTP 请求被排队，并在主线程解除阻塞后立即执行。
- en: If, however, the synchronous operation is long or if you have multiple synchronous
    operations one after the other, then the incoming HTTP request will eventually
    time out, leaving your user looking at an error message in their browser instead
    of looking at your web page.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果同步操作很长，或者你有多个连续的同步操作，那么进入的 HTTP 请求最终会超时，导致你的用户在浏览器中看到错误消息，而不是看到你的网页。
- en: This is a problem that becomes bigger the more synchronous operations you use.
    As you use more and more synchronous operations, you progressively diminish the
    capability of your server to handle concurrent users.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个随着你使用的同步操作越来越多而变得更大的问题。随着你使用越来越多的同步操作，你逐渐降低了服务器处理并发用户的能力。
- en: In other languages and environments where synchronous coding is normal, we can
    avoid this problem by delegating such resource-intensive operations to a *worker
    thread*. Generally, though, we can’t use threads like this in Node.js, which is
    typically considered to be *single-threaded*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言和环境中使用同步编码是正常的情况下，我们可以通过将这种资源密集型操作委托给 *工作线程* 来避免这个问题。然而，通常我们无法在被认为是 *单线程*
    的 Node.js 中使用这样的线程。
- en: 'To avoid blocking the main thread, we must use asynchronous coding. In the
    next example, we’ll use Node’s asynchronous file loading function: `readFile`.
    Calling this function starts the file loading operation and returns immediately
    to the calling code. While that happens, the content of the file is *asynchronously*
    loaded into memory. When the file load operation completes, your callback is invoked
    and the data from the file is delivered to you ([figure 2.14](#figure2.14)).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免阻塞主线程，我们必须使用异步编码。在下一个例子中，我们将使用 Node 的异步文件加载函数：`readFile`。调用此函数开始文件加载操作，并立即返回调用代码。在这个过程中，文件内容被
    *异步* 加载到内存中。当文件加载操作完成时，你的回调函数被调用，文件数据被发送给你 ([图 2.14](#figure2.14))。
- en: A callback is a JavaScript function that’s automatically called for you when
    a single asynchronous operation has completed. With normal (for example, *nonpromise*)
    callbacks, the callback is eventually called regardless of whether the operation
    fails or not—passing an error object to the callback to indicate those times when
    a failure has occurred. We’ll come back in a moment to look further at error handling.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是一个 JavaScript 函数，当单个异步操作完成时，它会自动为你调用。对于正常的（例如，*非 Promise*）回调，无论操作是否失败，回调最终都会被调用——通过将错误对象传递给回调来指示失败发生的情况。我们稍后将回到错误处理来进一步探讨。
- en: '![c02_14.eps](Images/c02_14.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![c02_14.eps](Images/c02_14.png)'
- en: '[Figure 2.14](#figureanchor2.14) Asynchronous code flow when loading a file'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.14](#figureanchor2.14) 加载文件时的异步代码流'
- en: Now that we’re using asynchronous coding, the file loading operation doesn’t
    lock up the main thread, keeping it free for other work such as responding to
    user requests ([figure 2.15](#figure2.15)).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用异步编码，文件加载操作不会锁定主线程，使其可以空闲下来处理其他工作，例如响应用户请求 ([图 2.15](#figure2.15))。
- en: '![c02_15.eps](Images/c02_15.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![c02_15.eps](Images/c02_15.png)'
- en: '[Figure 2.15](#figureanchor2.15) The main thread isn’t blocked during an asynchronous
    operation.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.15](#figureanchor2.15) 在异步操作期间主线程不会被阻塞。'
- en: Still with me? Understanding asynchronous coding can be difficult, but it’s
    essential for working with Node.js. I’ve used loading of a single file as a simple
    example of asynchronous coding with callbacks in Node.js, but a Node.js application
    is often built from many such asynchronous operations. To continue the example,
    let’s scale up to loading multiple files.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在吗？理解异步编码可能很困难，但对于使用 Node.js 来说是必不可少的。我已经使用单个文件的加载作为 Node.js 中使用回调的异步编码的简单示例，但
    Node.js 应用程序通常由许多这样的异步操作构建。为了继续这个例子，让我们扩展到加载多个文件。
- en: 2.6.2 Loading multiple files
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.2 加载多个文件
- en: We couldn’t create a Node.js application with a single asynchronous operation.
    Any decent-sized Node.js application will be composed of numerous asynchronous
    operations that are sequenced one after the other or woven together to build responses
    to HTTP requests.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法仅使用单个异步操作创建Node.js应用程序。任何体量较大的Node.js应用程序都将由多个异步操作组成，这些操作一个接一个地按顺序排列或交织在一起，以构建对HTTP请求的响应。
- en: Let’s expand the example to loading multiple files. Say we have a series of
    files that we need to load. The files are separated out by country, for example,
    bicycle_routes_usa.txt, bicycle_routes_australia.txt, bicycle_routes_england.txt,
    and so on. We need to load these files and combine them to access the full data
    set. Doing this synchronously causes a big problem; it will lock up the main thread
    for a significant amount of time ([figure 2.16](#figure2.16)).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展这个例子，加载多个文件。比如说，我们需要加载一系列文件。这些文件按国家分开，例如，bicycle_routes_usa.txt、bicycle_routes_australia.txt、bicycle_routes_england.txt等等。我们需要加载这些文件并将它们合并以访问完整的数据集。以同步方式执行此操作会导致一个大问题；它将锁定主线程一段时间([图2.16](#figure2.16))。
- en: '![c02_16.eps](Images/c02_16.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![c02_16.eps](Images/c02_16.png)'
- en: '[Figure 2.16](#figureanchor2.16) The main thread is blocked by multiple successive
    synchronous operations.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.16](#figureanchor2.16) 主线程被多个连续的同步操作阻塞。'
- en: Using asynchronous coding, we can handle this in two different ways. We can
    either sequence the asynchronous operations one after the other, or we can execute
    them in parallel. Sequencing asynchronous operations one after the other ([figure
    2.17](#figure2.17)) in this way makes them seem like a sequence of synchronous
    operations, except that the main thread is *not* blocked while they’re in progress.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步编码，我们可以以两种不同的方式处理这个问题。我们可以依次顺序执行异步操作，或者并行执行它们。以这种方式依次顺序执行异步操作([图2.17](#figure2.17))使得它们看起来像一系列同步操作，只不过在它们进行的过程中主线程不会被阻塞。
- en: '![c02_17.eps](Images/c02_17.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![c02_17.eps](Images/c02_17.png)'
- en: '[Figure 2.17](#figureanchor2.17) Sequential asynchronous operations happen
    outside the main thread.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.17](#figureanchor2.17) 顺序异步操作发生在主线程之外。'
- en: 'Here we’ve reached your first big problem with callback-based asynchronous
    coding in JavaScript. Each callback in [figure 2.17](#figure2.17) must invoke
    the subsequent asynchronous operation and set up its callback. This results in
    the nesting of callback functions: with the code for each being defined at a new
    level of indentation. As our chains of asynchronous operations become longer,
    the indentation becomes deeper. Nested functions and large amounts of indentation
    make code difficult to read and maintain and that’s the problem; it’s a problem
    so prevalent that it has a name: *callback hell*.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遇到了基于回调的JavaScript异步编码的第一个大问题。图2.17中的每个回调都必须调用后续的异步操作并设置其回调。这导致了回调函数的嵌套：每个回调的代码都在一个新的缩进级别上定义。随着我们的异步操作链变长，缩进也变得更深。嵌套函数和大量的缩进使得代码难以阅读和维护，这就是问题所在；这是一个非常普遍的问题，它有一个名字：*回调地狱*。
- en: For better performance and throughput, we should probably execute multiple asynchronous
    operations in parallel ([figure 2.18](#figure2.18)). This potentially compresses
    the time required to do all the work. It means the CPU and IO systems can work
    as fast as possible to bring all the files into memory, but it still does this
    without blocking the main thread.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的性能和吞吐量，我们可能需要并行执行多个异步操作([图2.18](#figure2.18))。这可能会压缩完成所有工作所需的时间。这意味着CPU和IO系统可以尽可能快地将所有文件加载到内存中，但它仍然这样做而不阻塞主线程。
- en: '![c02_18.eps](Images/c02_18.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![c02_18.eps](Images/c02_18.png)'
- en: '[Figure 2.18](#figureanchor2.18) Multiple asynchronous operations running in
    parallel'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.18](#figureanchor2.18) 并行运行的多项异步操作'
- en: 'After introducing parallel asynchronous operations, we reach our next big problem
    with callback-based asynchronous coding. Note the extra complexity that’s introduced
    when we run asynchronous operations in parallel: the callbacks can be invoked
    in any order!'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了并行异步操作之后，我们遇到了基于回调的异步编码的下一个大问题。注意当我们并行运行异步操作时引入的额外复杂性：回调可以以任何顺序被调用！
- en: How can we know when all callbacks have completed? They can complete in any
    order, so any subsequent operation that depends on the completion of all three
    must be coded so that it can be triggered by any of the callbacks. The last callback
    to execute will then trigger the subsequent operation. This new problem is all
    about managing multiple independent callbacks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道所有回调都已完成？它们可以以任何顺序完成，因此任何依赖于所有三个回调完成的后续操作都必须编写成可以由任何一个回调触发的代码。然后，最后执行的回调将触发后续操作。这个新问题完全是关于管理多个独立的回调。
- en: Solving these problems with traditional callbacks often results in ugly and
    fragile code. Soon, though, we’ll learn about promises, which can handle these
    issues in an elegant manner, but first we need to understand the workings of asynchronous
    error handling.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的回调来解决这些问题通常会导致代码丑陋且脆弱。不过，很快我们就会了解到承诺（promises），它能够以优雅的方式处理这些问题，但首先我们需要理解异步错误处理的工作原理。
- en: 2.6.3 Error handling
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.3 错误处理
- en: In traditional asynchronous coding, it isn’t possible to use a try/catch statement
    to detect and handle errors. We can’t use that because it can’t detect errors
    in asynchronous code. Instead, we must handle errors by inspecting an *error*
    object that’s optionally passed as the first parameter to our callback. When this
    parameter is `null`, it indicates that no error occurred; otherwise, we can interrogate
    the error object to determine the nature of the error.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的异步编码中，无法使用try/catch语句来检测和处理错误。我们不能使用它，因为它无法检测异步代码中的错误。相反，我们必须通过检查作为回调的第一个可选参数传递的*错误*对象来处理错误。当这个参数为`null`时，表示没有发生错误；否则，我们可以调查错误对象以确定错误的性质。
- en: This simple mechanism is okay when we’re dealing with a single asynchronous
    operation. It becomes more complicated when we execute multiple sequential asynchronous
    operations, where any may fail and they may do so in potentially any order.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的机制在处理单个异步操作时是可行的。当我们执行多个顺序的异步操作时，情况变得更加复杂，因为任何操作都可能失败，而且它们可能以任何可能的顺序失败。
- en: It’s further complicated and becomes increasingly difficult to manage when we
    execute parallel asynchronous operations or combinations of parallel and sequential
    operations. Consider what happens when your second file fails to load ([figure
    2.19](#figure2.19)). When this happens, any subsequent operation that depends
    on all three files must also fail. How do we achieve this? Again, the callbacks
    can be invoked in any order, so each callback needs to detect the success or failure
    of the combined operation, but only the final callback should invoke the error-handling
    logic. Managing Node.js callbacks can be tough, but please don’t be discouraged.
    In a moment we’ll come to promises, which are a much better way to deal with these
    situations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行并行异步操作或并行和顺序操作的组合时，情况变得更加复杂，并且越来越难以管理。考虑一下当你的第二个文件加载失败时会发生什么（[图2.19](#figure2.19)）。当这种情况发生时，任何依赖于所有三个文件的后续操作也必须失败。我们如何实现这一点？同样，回调可以以任何顺序被调用，因此每个回调都需要检测组合操作的成功或失败，但只有最后一个回调应该调用错误处理逻辑。管理Node.js回调可能会很困难，但请不要气馁。一会儿我们将介绍承诺（promises），这是一种处理这些情况更好的方式。
- en: '![c02_19.eps](Images/c02_19.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![c02_19.eps](Images/c02_19.png)'
- en: '[Figure 2.19](#figureanchor2.19) One of the asynchronous operations fails.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.19](#figureanchor2.19) 其中一个异步操作失败了。'
- en: 'Asynchronous error handling brings us to the third and last big problem with
    callback-based asynchronous coding: every callback must handle its own errors.
    For example, in [figure 2.19](#figure2.19) each of the three callbacks must define
    its own error handler. It would be much better if we could share one single error
    handler between all of the callbacks. The logic for managing multiple callbacks
    grows increasingly more complex because it now must understand if any of the operations
    failed.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 异步错误处理将我们带到了基于回调的异步编码的第三个也是最后一个大问题：每个回调都必须处理自己的错误。例如，在[图2.19](#figure2.19)中，每个回调都必须定义自己的错误处理程序。如果能在一个回调之间共享一个单一的错误处理程序会更好。管理多个回调的逻辑变得越来越复杂，因为它现在必须理解是否任何操作失败了。
- en: With the combination of difficulties you face doing asynchronous coding, it’s
    no wonder that asynchronous coding is considered difficult. Now, though, it’s
    time to introduce promises, which will help you manage and simplify your asynchronous
    coding.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在进行异步编码时面临的困难，异步编码被认为是困难的也就不足为奇了。现在，是时候介绍承诺（promises）了，它将帮助你管理和简化你的异步编码。
- en: 2.6.4 Asynchronous coding with promises
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.4 使用承诺进行异步编码
- en: As the complexity of asynchronous coding quickly rises, the promises design
    pattern can help enormously. Promises allow us to chain together and interweave
    asynchronous operations. They help us manage numerous operations at once and automatically
    pull together all the callbacks for us.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 随着异步编程复杂性的迅速增加，承诺（Promises）设计模式可以极大地帮助。承诺（Promises）允许我们将异步操作连接和交织在一起。它们帮助我们同时管理多个操作，并自动为我们收集所有回调。
- en: 'Through promises we hope to address the following problems with callback-based
    asynchronous coding:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过承诺（Promises），我们希望解决基于回调的异步编程中的以下问题：
- en: '*Callback hell* —Promises help minimize the nesting of callbacks.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*回调地狱* —承诺（Promises）有助于最小化回调的嵌套。'
- en: '*Callback order* —Promises automatically weave together multiple callbacks,
    meaning you’re no longer concerned with their order of completion.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*回调顺序* —承诺（Promises）自动将多个回调编织在一起，这意味着你不再关心它们的完成顺序。'
- en: '*Error handling* —Promises allow error handlers to be inserted anywhere in
    the chain of asynchronous operations. We can share error handlers between as many
    asynchronous operations as we need.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误处理* —承诺（Promises）允许在任何异步操作链中插入错误处理器。我们可以根据需要共享错误处理器，在任意数量的异步操作之间共享。'
- en: Maybe we should start by considering exactly what a promise is. A *promise*
    is an object that wraps an asynchronous operation and promises to deliver an outcome
    (or an error) at *some time* in the future. Promises give us a vocabulary to express
    chains of asynchronous operations in a way that almost looks (if you squint your
    eyes) like it was a sequence of synchronous operations. The main words in your
    promises vocabulary are `then`, `all`*,* and `catch`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们应该首先考虑承诺（promise）的确切含义。一个 *承诺（promise）* 是一个封装异步操作并承诺在未来某个时间点提供结果（或错误）的对象。承诺（Promises）为我们提供了一种词汇，可以以几乎看起来像同步操作序列的方式表达异步操作的链。你承诺词汇中的主要词汇是
    `then`、`all`* 和 `catch`。
- en: Then
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Then
- en: '`Then` is used to chain together a sequence of asynchronous operations ([figure
    2.20](#figure2.20)).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`Then` 用于连接一系列异步操作（[图2.20](#figure2.20)）。'
- en: '![c02_20.eps](Images/c02_20.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![c02_20.eps](Images/c02_20.png)'
- en: '[Figure 2.20](#figureanchor2.20) Executing sequential asynchronous operations
    with `then`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.20](#figureanchor2.20) 使用 `then` 执行顺序异步操作'
- en: I like to visualize a promise chain as a sequence of boxes connected by then
    arrows as shown in [figure 2.21](#figure2.21). Each box represents a stage in
    a sequence of asynchronous operations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将承诺链想象为一系列由 `then` 箭头连接的盒子，如图[图2.21](#figure2.21)所示。每个盒子代表一系列异步操作中的一个阶段。
- en: '![c02_21.eps](Images/c02_21.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![c02_21.eps](Images/c02_21.png)'
- en: '[Figure 2.21](#figureanchor2.21) Visualizing a promise chain'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.21](#figureanchor2.21) 可视化承诺链'
- en: '*All*'
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*All*'
- en: '`Promise.all` is used to manage asynchronous operations that are running in
    parallel. It automatically weaves together the callbacks and invokes a single
    final callback ([figure 2.22](#figure2.22)). Using `all`, you no longer need to
    worry about coordinating multiple callbacks that might be invoked in any order.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all` 用于管理并行运行的异步操作。它自动编织回调并调用一个单一的最终回调（[图2.22](#figure2.22)）。使用 `all`，你不再需要担心可能以任何顺序调用的多个回调的协调。'
- en: '![c02_22.eps](Images/c02_22.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![c02_22.eps](Images/c02_22.png)'
- en: '[Figure 2.22](#figureanchor2.22) Executing asynchronous operations in parallel
    with `Promise.all`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.22](#figureanchor2.22) 使用 `Promise.all` 并行执行异步操作'
- en: Between `then` and `all`, we already have a powerful toolkit for managing asynchronous
    operations. We can combine them in various ways to piece together arbitrarily
    complex sequences with only a little effort. See [figure 2.23](#figure2.23) for
    a more complex example.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `then` 和 `all` 之间，我们已经有一个强大的工具集来管理异步操作。我们可以以各种方式将它们结合起来，以最小的努力拼接任意复杂的序列。请参阅[图2.23](#figure2.23)以获取更复杂的示例。
- en: Catch
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Catch
- en: Finally, we’re left with `catch`*,* which is used for error handling. Using
    promises, we can attach an error handler to the end of our chain ([figure 2.24](#figure2.24)).
    This allows us to share the error hander between all our asynchronous operations,
    and it will be invoked should any of the operations fail (for example, file 2
    fails to load in [figure 2.24](#figure2.24)). I like to visualize promise error
    handling as a *short circuit* out of the promise chain, as shown in [figure 2.25](#figure2.25).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们剩下 `catch`*，用于错误处理。使用承诺（promises），我们可以在链的末尾附加一个错误处理器（[图2.24](#figure2.24)）。这允许我们在所有异步操作之间共享错误处理器，并且如果任何操作失败（例如，[图2.24](#figure2.24)中的文件2加载失败），它将被调用。我喜欢将承诺错误处理想象为从承诺链中跳出的*短路*，如图[图2.25](#figure2.25)所示。
- en: '![c02_23.eps](Images/c02_23.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![c02_23.eps](Images/c02_23.png)'
- en: '[Figure 2.23](#figureanchor2.23) A more complex example of promises illustrating
    how then and all can be used to weave complex chains of asynchronous logic.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.23](#figureanchor2.23) `Promises` 的一个更复杂的示例，展示了如何使用 `then` 和 `all` 来编织复杂的异步逻辑链。'
- en: '![c02_24.eps](Images/c02_24.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![c02_24.eps](Images/c02_24.png)'
- en: '[Figure 2.24](#figureanchor2.24) Adding an error handler to a promise chain
    with catch'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.24](#figureanchor2.24) 使用 `catch` 向承诺链添加错误处理程序'
- en: '![c02_25.eps](Images/c02_25.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![c02_25.eps](Images/c02_25.png)'
- en: '[Figure 2.25](#figureanchor2.25) An error aborts the promise chain and invokes
    the error handler.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.25](#figureanchor2.25) 一个错误中断承诺链并调用错误处理程序。'
- en: '`Catch` allows us to have elegant control over our asynchronous error handling.
    It gives us back our *try/catch statement* in the asynchronous world.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`Catch` 允许我们对异步错误处理进行优雅的控制。它在我们异步世界中为我们带来了 `try/catch` 语句。'
- en: In this example I placed the error handler at the end of the promise chain,
    although in reality you can place your error handler anywhere in the chain depending
    on when you want to detect and report errors.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将错误处理程序放置在承诺链的末尾，尽管在现实中，你可以根据你想要检测和报告错误的时间，将错误处理程序放置在链中的任何位置。
- en: 2.6.5 Wrapping asynchronous operations in promises
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.5 在 `Promises` 中包装异步操作
- en: Now that you know how to use promises and how they can help you simplify the
    management of asynchronous operations, you can look for opportunities to use them.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用 `Promises` 以及它们如何帮助你简化异步操作的管理，你可以寻找使用它们的机会。
- en: Often, you’ll find that third-party APIs provide asynchronous functions that
    already use promises. In these cases, you call the asynchronous function and it
    returns to you a promise, and from there you can chain additional operations and
    handle errors as you need.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现第三方 API 已经提供了使用 `Promises` 的异步函数。在这些情况下，你调用异步函数，它返回一个承诺给你，然后你可以从那里链式调用额外的操作并按需处理错误。
- en: Promises were introduced into JavaScript 6th edition in 2015 (also known as
    ES6) after many years of gestation in a variety of third-party libraries. Promises
    are now available in Node.js, although the Node.js API hasn’t yet been upgraded
    to support them properly. To my knowledge, all Node.js API asynchronous functions
    are still *callback-based*. Many third-party libraries don’t yet support promises.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过多年的孕育之后，`Promises` 在 2015 年的 JavaScript 第 6 版（也称为 ES6）中被引入，在此之前它们已经在各种第三方库中存在。现在
    `Promises` 已在 Node.js 中可用，尽管 Node.js API 还未升级以正确支持它们。据我所知，所有 Node.js API 的异步函数仍然是基于回调的。许多第三方库尚未支持
    `Promises`。
- en: Don’t worry; we can still use promises even when they aren’t directly supported
    by the API we’re using. We have to do the conversion ourselves.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心；即使它们不被我们使用的 API 直接支持，我们仍然可以使用 `Promises`。我们必须自己进行转换。
- en: 'Let’s look back at the example of loading a single file asynchronously and
    convert it using a promise. We’ll create a new function called `readFilePromise`
    that wraps Node’s `readFile` function. We’d like to use our new function as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下异步加载单个文件的例子，并使用 `Promise` 来转换它。我们将创建一个新的函数 `readFilePromise`，它包装了 Node
    的 `readFile` 函数。我们希望如下使用我们的新函数：
- en: '[PRE37]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `readFilePromise` function creates and returns a `Promise` object. We can
    then interact with this promise to manage the async operation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFilePromise` 函数创建并返回一个 `Promise` 对象。然后我们可以与这个承诺进行交互来管理异步操作。'
- en: 'We instantiate a `Promise` object with an anonymous function that initiates
    the asynchronous file loading operation. The anonymous function is passed two
    parameters. The first parameter is a `resolve` function that we call when the
    asynchronous operation has completed and we’re ready to `resolve` the promise.
    This will trigger the next `then` handler that is chained to the promise. The
    second parameter is a `reject` function that we can call if an error occurs. We
    can use this to `fail` the promise and trigger the closest `catch` handler in
    the promise chain:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个匿名函数实例化一个 `Promise` 对象，该匿名函数启动异步文件加载操作。匿名函数接收两个参数。第一个参数是一个 `resolve` 函数，我们在异步操作完成后并准备好
    `resolve` 承诺时调用它。这将触发承诺链中连接的下一个 `then` 处理器。第二个参数是一个 `reject` 函数，如果发生错误，我们可以调用它。我们可以使用这个来
    `fail` 承诺并触发承诺链中最接近的 `catch` 处理器：
- en: '[PRE38]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This technique for wrapping a callback-based asynchronous function in a promise
    can easily be applied to any situation where you need to do such a conversion.
    Here’s a general pattern that you can use:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将基于回调的异步函数包装在 `Promise` 中的技术可以轻松应用于任何需要此类转换的情况。以下是一个你可以使用的通用模式：
- en: '[PRE39]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 2.6.6 Async coding with “async” and “await”
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.6 使用“async”和“await”进行异步编码
- en: If you’re using Node.js version 7 or later, you might want to use the new `async`
    and `await` keywords. These new keywords provide syntactic sugar for promises
    that mean they’re no longer an API construct, the JavaScript language itself has
    been updated to support promises!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Node.js 7或更高版本，你可能想使用新的`async`和`await`关键字。这些新关键字为Promise提供了语法糖，这意味着它们不再是API构造，JavaScript语言本身已经更新以支持Promise！
- en: These new keywords make a chain of promises seem like a sequence of synchronous
    operations. For example, reading, transforming and then writing a data file, as
    shown in the following listing.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新关键字让Promise链看起来像一系列同步操作。例如，读取、转换然后写入数据文件，如下面的列表所示。
- en: Listing 2.15 Promise chain rewritten with `await`
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 使用`await`重写的Promise链
- en: '[PRE40]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The code in [listing 2.15](#listing2.15) is asynchronous, and yet it isn’t littered
    with callbacks *or* promises. We’ve come full circle back to something that looks
    much like synchronous code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.15](#listing2.15)中的代码是异步的，但并没有充斥着回调*或*Promise。我们回到了一个看起来非常像同步代码的东西。'
- en: This relies on an interpreter trick to translate the `await` code to promises
    for you, so in the end this still ends up being a sequence of `then` callbacks
    with a `catch` at the end. You don’t see that level of complexity because the
    interpreter is doing the work for you.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于一个解释器技巧来将`await`代码转换为Promise，所以最终这仍然是一个`then`回调的序列，并在最后添加一个`catch`。你不会看到那么复杂的层次，因为解释器在为你做这项工作。
- en: We’ve covered the fundamentals of making command-line apps and web servers in
    Node.js. We’ve had an overview of asynchronous programming with promises. You’re
    now ready to get into real data wrangling!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在Node.js中创建命令行应用和Web服务器的基础知识。我们已经对异步编程和Promise进行了概述。你现在可以开始真正处理数据了！
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned how to start a project and install third-party libraries.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何开始一个项目并安装第三方库。
- en: You practiced creating a simple command-line application.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你练习了创建一个简单的命令行应用。
- en: You refactored parts of your application into reusable code modules.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将应用程序的部分代码重构为可重用的代码模块。
- en: You created a simple web server with a REST API.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建了一个简单的带有REST API的Web服务器。
- en: You learned the importance of asynchronous coding in Node.js and how it can
    be better managed with promises.*
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了在Node.js中异步编码的重要性以及如何通过Promise更好地管理它*。
