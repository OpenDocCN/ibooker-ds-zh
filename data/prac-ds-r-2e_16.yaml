- en: Appendix A. Starting with R and other tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 从R和其他工具开始
- en: In this appendix, we’ll show how you can install tools and start working with
    R. We’ll demonstrate some example concepts and steps, but you’ll want to follow
    up with additional reading.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们将展示如何安装工具并开始使用R。我们将演示一些示例概念和步骤，但你可能需要进一步阅读以获取更多信息。
- en: '[Section A.1](../Text/A.xhtml#app01lev1sec1) is something all readers should
    review, as it shows where to get all of the software support materials for this
    book. The other sections should be considered on an as-needed basis, as they outline
    the details of how R works (something the reader may already know), and some specific
    applications (such as using databases) that may not be needed by all readers.
    Throughout the book we have tried to avoid teaching things “just in case,” but
    here in the appendixes we supply some things you only “might” need.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[章节A.1](../Text/A.xhtml#app01lev1sec1)是所有读者都应该回顾的内容，因为它展示了如何获取本书的所有软件支持材料。其他章节应根据需要考虑，因为它们概述了R的工作细节（读者可能已经知道）以及一些可能不是所有读者都需要的具体应用（例如使用数据库）。在本书中，我们尽量避免“以防万一”的教学，但在附录中，我们提供了一些你可能“可能”需要的东西。'
- en: A.1\. Installing the tools
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1. 安装工具
- en: The primary tool for working our examples will be R, and possibly RStudio. But
    other tools (databases, version control, compilers, and so on) are also highly
    recommended. You may also need access to online documentation or other help to
    get all of these tools to work in your environment. The distribution sites we
    list are a good place to start.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作示例的主要工具将是R，以及可能还有RStudio。但其他工具（数据库、版本控制、编译器等）也非常推荐。你可能还需要访问在线文档或其他帮助，以便在你的环境中使用所有这些工具。我们列出的发行站点是一个良好的起点。
- en: A.1.1\. Installing Tools
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1. 安装工具
- en: The R environment is a set of tools and software that can be installed on Unix,
    Linux, Apple macOS, and Windows.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: R环境是一套可以安装在Unix、Linux、Apple macOS和Windows上的工具和软件。
- en: R
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: R
- en: We recommend installing the latest version of R from the Comprehensive R Archive
    Network (CRAN) at [https://cran.r-project.org](https://cran.r-project.org), or
    a mirror. CRAN is the authoritative central repository for R and R packages. CRAN
    is supported by The R Foundation and the R Development Core Team. R itself is
    an official part of the Free Software Foundation’s GNU project distributed under
    a GPL 2 license. R is used at many large institutions, including the United States
    Food and Drug Administration.^([[1](#app01fn1)])
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐从综合R档案网络（CRAN）[https://cran.r-project.org](https://cran.r-project.org)或其镜像安装最新的R版本。CRAN是R及其软件包的官方中央仓库。CRAN由R基金会和R开发核心团队支持。R本身是自由软件基金会GNU项目的官方部分，在GPL
    2许可证下分发。R被许多大型机构使用，包括美国食品药品监督管理局。[^([[1](#app01fn1))]
- en: ¹
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Source: [https://www.r-project.org/doc/R-FDA.pdf](https://www.r-project.org/doc/R-FDA.pdf).'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://www.r-project.org/doc/R-FDA.pdf](https://www.r-project.org/doc/R-FDA.pdf)。
- en: For this book, we recommend using at least R version 3.5.0 or newer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们建议使用至少R版本3.5.0或更新的版本。
- en: To work with R, you need a text editor specialized for working with non-formatted
    (or not-rich) text. Such editors include Atom, Emacs, Notepad++, Pico, Programmer’s
    Notepad, RStudio, Sublime Text, text wrangler, vim, and many more. These are in
    contrast to rich text editors (which are not appropriate for programming tasks)
    such as Microsoft Word or Apple Text Edit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用R，你需要一个专门用于处理非格式化（或非丰富）文本的文本编辑器。这些编辑器包括Atom、Emacs、Notepad++、Pico、Programmer’s
    Notepad、RStudio、Sublime Text、text wrangler、vim等。这些与富文本编辑器（不适用于编程任务）形成对比，例如Microsoft
    Word或Apple Text Edit。
- en: RStudio
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio
- en: We suggest that when working with R, you consider using RStudio. RStudio is
    a popular cross-platform integrated development environment supplied by the company
    RStudio, Inc. ([https://www.rstudio.com](https://www.rstudio.com)). RStudio supplies
    a built-in text editor and convenient user interfaces for common tasks such as
    installing software, rendering R markdown documents, and working with source control.
    RStudio is not an official part of R or CRAN, and should not be confused with
    R or CRAN.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在用R工作时考虑使用RStudio。RStudio是由RStudio, Inc.提供的流行跨平台集成开发环境([https://www.rstudio.com](https://www.rstudio.com))。RStudio提供内置文本编辑器和方便的用户界面，用于执行安装软件、渲染R
    Markdown文档和操作源代码控制等常见任务。RStudio不是R或CRAN的官方部分，不应与R或CRAN混淆。
- en: An important feature of RStudio is the file browser and the set-directory/go-to-directory
    controls that are hidden in the gear icon of the file-browsing pane, which we
    point out in [figure A.1](#app01fig01).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio 的重要特性之一是文件浏览器和位于文件浏览面板齿轮图标中的隐藏的设置目录/转到目录控件，我们在图 A.1 中指出。
- en: Figure A.1\. RStudio file-browsing controls
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.1\. RStudio 文件浏览控件
- en: '![](Images/app01fig01_alt.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/app01fig01_alt.jpg)'
- en: RStudio is not a requirement to use R or to work through the examples in this
    book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio 不是使用 R 或完成本书中的示例的必要条件。
- en: Git
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Git
- en: Git is a source control or version management system that is very useful for
    preserving and sharing work. To install Git, please follow the appropriate instructions
    from [https://git-scm.com](https://git-scm.com).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一种源代码控制或版本管理系统，对于保存和共享工作非常有用。要安装 Git，请遵循 [https://git-scm.com](https://git-scm.com)
    上的适当说明。
- en: Data science always involves a lot of tools and collaboration, so the willingness
    to try new tools is a flexibility one needs to develop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学总是涉及大量的工具和协作，因此愿意尝试新工具是必须培养的灵活性。
- en: The book-support materials
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍支持材料
- en: 'All of the book-support materials are freely available from GitHub: [https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2),
    as shown in [figure A.2](#app01fig02). The reader should download them in their
    entirety either using `git clone` with the URL [https://github.com/WinVector/PDSwR2.git](https://github.com/WinVector/PDSwR2.git)
    or by downloading a complete zip file by using the “Clone or Download” control
    at the top right of the GitHub page.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 书中所有支持材料均可在 GitHub 上免费获取：[https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2)，如图
    A.2 所示。读者应下载全部内容，可以使用 `git clone` 命令和 URL [https://github.com/WinVector/PDSwR2.git](https://github.com/WinVector/PDSwR2.git)
    进行下载，或者通过在 GitHub 页面右上角的“克隆或下载”控件中下载完整的 zip 文件。
- en: Figure A.2\. Downloading the book materials from GitHub
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2\. 从 GitHub 下载书籍材料
- en: '![](Images/app01fig02_alt.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/app01fig02_alt.jpg)'
- en: Another way to download the book material is to use RStudio and Git. Select
    File > New Project > Create Project from Version Control > Git. That will bring
    up a dialog box as shown in [figure A.3](#app01fig03). You can fill in the Git
    URL and download the book materials as a project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下载书籍材料的另一种方法是使用 RStudio 和 Git。选择文件 > 新建项目 > 从版本控制创建项目 > Git。这将弹出一个对话框，如图 A.3
    所示。您可以在其中填写 Git URL 并将书籍材料作为项目下载。
- en: Figure A.3\. Cloning the book repository
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.3\. 克隆书籍仓库
- en: '![](Images/app01fig03_alt.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/app01fig03_alt.jpg)'
- en: We will refer to this directory as PDSwR2 throughout the book, and all files
    and paths we mention are either in this directory or a subdirectory. Please be
    sure to look in this directory for any README or errata files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中引用此目录为 PDSwR2，我们提到的所有文件和路径要么在此目录中，要么在子目录中。请确保在此目录中查找任何 README 或勘误文件。
- en: 'Some features of the support directory include these:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 支持目录的一些特性包括以下内容：
- en: All example data used in the book.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书中使用的所有示例数据。
- en: All example code used in the book. The examples from the book are available
    in the subdirectory CodeExamples, and also as the zip file CodeExamples.zip. In
    addition to this, the entire set of examples, rerun and rerendered, are shared
    in RenderedExamples. (All paths should be relative to where you have unpacked
    the book directory PDSwR2.)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '书中使用的所有示例代码。书中的示例可在 CodeExamples 子目录中找到，也可以作为 CodeExamples.zip 文件下载。此外，整个示例集，包括重新运行和重新渲染的示例，都在
    RenderedExamples 中共享。（所有路径均相对于您解压的书籍目录 PDSwR2。） '
- en: R packages
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: R 包
- en: 'A great advantage of R is the CRAN central package repository. R has standardized
    package installation through the `install.packages()` command. An installed package
    is typically not fully available for use in a project until the package is also
    attached for use by the `library()` command.^([[2](#app01fn2)]) A good practice
    is this: any sort of R script or work should attach all the packages it intends
    to use as a first step. Also, in most cases scripts should *not* call `install.packages()`,
    as this changes the R installation, which should not be done without user supervision.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: R 的一大优势是 CRAN 中心包仓库。R 通过 `install.packages()` 命令实现了标准化的包安装。一个安装的包通常在通过 `library()`
    命令附加以供使用之前，在项目中并不完全可用.^([[2](#app01fn2)]) 良好的做法是：任何类型的 R 脚本或工作都应首先附加它打算使用的所有包。此外，在大多数情况下，脚本不应调用
    `install.packages()`，因为这会改变 R 的安装，这不应在没有用户监督的情况下进行。
- en: ²
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In R installing a package is a separate step from attaching it for use. `install.packages()`
    makes package contents potentially available; after that, `library()` readies
    them for use. A handy mnemonic is this: `install.packages()` sets up new appliances
    in your kitchen, and `library()` turns them on. You don’t have to install things
    very often, however you often have to turn things back on.'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 R 中，安装软件包是使用软件包的一个独立步骤。`install.packages()` 使软件包内容可能可用；之后，`library()` 准备它们以供使用。一个方便的记忆法是：`install.packages()`
    在你的厨房中设置新的家电，而 `library()` 则是打开它们。你不必经常安装东西，然而你经常需要重新打开它们。
- en: Installing the required packages
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需软件包
- en: 'To install the set of packages required to work all the examples in this book,
    first download the book repository as described previously. Then look in the first
    directory or top directory of this repository: PDSwR2\. In this directory, you
    will find the file packages.R. You can open this file with a text editor, and
    it should look like the following (though it may be more up to date than what
    is shown here).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装本书中所有示例所需的一组软件包，首先按照之前描述的方法下载本书的仓库。然后查看该仓库的第一个目录或顶级目录：PDSwR2\. 在这个目录中，你会找到名为
    packages.R 的文件。你可以用文本编辑器打开这个文件，它应该看起来像下面这样（尽管它可能比这里显示的更新）。
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To install everything, run every line of code in this file from R.^([[3](#app01fn3)])
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装所有内容，请在 R 中运行此文件中的每一行代码.^([[3](#app01fn3)])
- en: ³
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The preceding code can be found as the file packages.R at [https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2).
    We could call it PDSwR2/packages.R, which could mean the file from the original
    GitHub URL or from a local copy of the GitHub repository.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 之前提到的代码可以在 [https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2)
    的 packages.R 文件中找到。我们可以称之为 PDSwR2/packages.R，这可能意味着来自原始 GitHub URL 的文件或 GitHub
    仓库的本地副本。
- en: 'Unfortunately, there are many reasons the install can fail: incorrect copy/paste,
    no internet connection, improperly configured R or RStudio, insufficient permissions
    to administer the R install, out-of-date versions of R or RStudio, missing system
    requirements, or no or incorrect C/C++/Fortran compiler. If you run into these
    problems, it is best to find a forum or expert to help you work through these
    steps. Once everything is successfully installed, R is a self-contained environment
    where things just work.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，安装可能会因为许多原因失败：错误的复制粘贴、没有网络连接、R 或 RStudio 配置不当、没有足够的权限管理 R 安装、R 或 RStudio
    版本过旧、缺少系统要求，或者没有或错误的 C/C++/Fortran 编译器。如果你遇到这些问题，最好是找到一个论坛或专家来帮助你完成这些步骤。一旦所有内容都成功安装，R
    就是一个自包含的环境，其中事物可以正常工作。
- en: 'Not all packages are needed for all examples, so if you have trouble with the
    overall install, just try to work the examples in the book. Here’s a caveat: if
    you see a `library(pkgname)` command fail, please try `install.packages(''pkgname'')`
    to install the missing package. The preceding package list is just trying to get
    everything out of the way in one step.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有软件包对所有示例都是必需的，所以如果你在整体安装过程中遇到麻烦，只需尝试在书中工作示例。这里有一个警告：如果你看到一个 `library(pkgname)`
    命令失败，请尝试 `install.packages('pkgname')` 来安装缺失的软件包。前面的软件包列表只是试图在一步中解决所有问题。
- en: Other tools
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具
- en: R’s capabilities can be enhanced by using tools such as Perl,^([[4](#app01fn4)])
    gcc/clang, gfortran, git, Rcpp, Tex, pandoc, ImageMagick, and Bash shell. Each
    of these is managed outside of R, and how to maintain them depends on your computer,
    operating system, and system permissions. Unix/Linux users have the easiest time
    installing these tools, and R is primarily developed in a Unix environment.^([[5](#app01fn5)])
    RStudio will install some of the extra tools. macOS users may need Apple’s Xcode
    tools and Homebrew ([https://brew.sh](https://brew.sh)) to have all the required
    tools. Windows users who wish to write packages may want to research RTools ([https://cran.r-project.org/bin/windows/Rtools/](https://cran.r-project.org/bin/windows/Rtools/)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 Perl、gcc/clang、gfortran、git、Rcpp、TeX、pandoc、ImageMagick 和 Bash shell
    等工具来增强 R 的功能。这些工具都在 R 之外管理，如何维护它们取决于你的计算机、操作系统和系统权限。Unix/Linux 用户安装这些工具最简单，R 主要是在
    Unix 环境中开发的.^([[5](#app01fn5)]) RStudio 将安装一些额外的工具。macOS 用户可能需要 Apple 的 Xcode
    工具和 Homebrew ([https://brew.sh](https://brew.sh)) 来获得所有必需的工具。希望编写软件包的 Windows
    用户可能需要研究 RTools ([https://cran.r-project.org/bin/windows/Rtools/](https://cran.r-project.org/bin/windows/Rtools/))。
- en: ⁴
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [https://www.perl.org/get.html](https://www.perl.org/get.html).
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [https://www.perl.org/get.html](https://www.perl.org/get.html)。
- en: ⁵
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, we share notes on rapidly configuring R and RStudio Server on
    an Amazon EC2 instance here: [www.win-vector.com/blog/2018/01/setting-up-rstudio-server-quickly-on-amazon-ec2/](http://www.win-vector.com/blog/2018/01/setting-up-rstudio-server-quickly-on-amazon-ec2/).'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，我们在这里分享如何在 Amazon EC2 实例上快速配置 R 和 RStudio Server 的笔记：[www.win-vector.com/blog/2018/01/setting-up-rstudio-server-quickly-on-amazon-ec2/](http://www.win-vector.com/blog/2018/01/setting-up-rstudio-server-quickly-on-amazon-ec2/)。
- en: Windows users may need RTools to compile packages; however, this should not
    be strictly necessary as most current packages are available from CRAN in a precompiled
    form (at least for macOS and 64-bit Windows). macOS users may need to install
    the Xcode compiler (available from Apple) to compile packages. All of these are
    steps you probably want to skip until you need the ability to compile.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户可能需要 RTools 来编译包；然而，这通常不是严格必要的，因为大多数当前包都以预编译形式从 CRAN 提供（至少对于 macOS
    和 64 位 Windows）。macOS 用户可能需要安装 Xcode 编译器（由 Apple 提供）来编译包。所有这些都是在你需要编译能力之前可能想要跳过的步骤。
- en: A.1.2\. The R package system
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2\. R 包系统
- en: R is a broad and powerful language and analysis workbench in and of itself.
    But one of its real strengths is the depth of the package system and packages
    supplied through CRAN. To install a package from CRAN, just type `install.packages('nameofpackage')`.
    To use an installed package, type `library(nameofpackage)`.^([[6](#app01fn6)])
    Any time you type `library('nameofpackage')` or `require('nameofpackage')`, you’re
    assuming you’re using a built-in package or you’re able to run `install.packages('nameofpackage')`
    if needed. We’ll return to the package system again and again in this book. To
    see what packages are present in your session, type `sessionInfo()`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: R 是一种广泛且强大的语言，本身就是一个分析工作平台。但它的真正优势之一是包系统的深度以及通过 CRAN 提供的包。要从 CRAN 安装一个包，只需输入
    `install.packages('nameofpackage')`。要使用已安装的包，输入 `library(nameofpackage)`。^([[6](#app01fn6)])
    每次你输入 `library('nameofpackage')` 或 `require('nameofpackage')`，你都在假设你正在使用一个内置包，或者如果你需要的话，能够运行
    `install.packages('nameofpackage')`。在这本书中，我们将反复回到包系统。要查看你的会话中存在哪些包，输入 `sessionInfo()`。
- en: ⁶
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Actually, `library('nameofpackage')` also works with quotes. The unquoted form
    works in R because R has the ability to delay argument evaluation (so an undefined
    `nameofpackage` doesn’t cause an error) as well as the ability to snoop the names
    of argument variables (most programming languages rely only on references or values
    of arguments). Given that a data scientist has to work with many tools and languages
    throughout the day, we prefer to not rely on features unique to one language unless
    we really need the feature. But the “official R style” is without the quotes.
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，`library('nameofpackage')` 也可以使用引号。未使用引号的形式在 R 中有效，因为 R 有能力延迟参数评估（所以未定义的
    `nameofpackage` 不会导致错误）以及能够窥探参数变量的名称（大多数编程语言只依赖于参数的引用或值）。鉴于数据科学家整天都要与许多工具和语言打交道，我们更喜欢不依赖于特定于一种语言的特性，除非我们真的需要这个特性。但“官方
    R 风格”是不使用引号的。
- en: '* * *'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Changing your CRAN mirror
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 更改你的 CRAN 镜像
- en: You can change your CRAN mirror at any time with the `chooseCRANmirror()` command.
    This is handy if the mirror you’re working with is slow.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `chooseCRANmirror()` 命令随时更改你的 CRAN 镜像。如果你正在使用的镜像很慢，这会很有用。
- en: '* * *'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A.1.3\. Installing Git
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3\. 安装 Git
- en: We advise installing Git version control before we show you how to use R and
    RStudio. This is because without Git, or a tool like it, you’ll lose important
    work. Not just lose *your* work—you’ll lose important *client* work. A lot of
    data science work (especially the analysis tasks) involves trying variations and
    learning things. Sometimes you learn something surprising and need to redo earlier
    experiments. Version control keeps earlier versions of all of your work, so it’s
    exactly the right tool to recover code and settings used in earlier experiments.
    Git is available in precompiled packages from [http://git-scm.com](http://git-scm.com).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在向你展示如何使用 R 和 RStudio 之前安装 Git 版本控制。这是因为如果没有 Git 或类似工具，你会丢失重要的工作。不仅仅是丢失
    *你的* 工作——你还会丢失重要的 *客户* 工作。许多数据科学工作（尤其是分析任务）涉及尝试变体和学习新事物。有时你会学到一些令人惊讶的东西，需要重新进行早期的实验。版本控制保留了所有工作的早期版本，因此它是恢复早期实验中使用的代码和设置的完美工具。Git
    可从 [http://git-scm.com](http://git-scm.com) 的预编译包中获得。
- en: A.1.4\. Installing RStudio
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.4\. 安装 RStudio
- en: RStudio supplies a text editor (for editing R scripts) and an integrated development
    environment for R. Before picking up RStudio from [http://rstudio.com](http://rstudio.com),
    you should install both R and Git as we described earlier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio 提供了一个文本编辑器（用于编辑 R 脚本）和 R 的集成开发环境。在从 [http://rstudio.com](http://rstudio.com)
    获取 RStudio 之前，你应该安装 R 和 Git，就像我们之前描述的那样。
- en: The RStudio product you initially want is called *RStudio Desktop* and is available
    precompiled for Windows, Linux, and macOS.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你最初想要的 RStudio 产品称为 *RStudio Desktop*，它为 Windows、Linux 和 macOS 提供了预编译版本。
- en: When you’re first starting with RStudio, we strongly recommend turning off both
    the “Restore .RData into workspace at startup” and “Save workspace to .RData on
    exit” features. Having these settings on (the default) makes it hard to reliably
    “work clean” (a point we will discuss in [section A.3](../Text/A.xhtml#app01lev1sec3).
    To turn off these features, open the RStudio options pane (the Global option is
    found by such as menus RStudio > Preferences, Tools > Global Options, Tools >
    Options, or similar, depending on what operating system you are using), and then
    alter the two settings as indicated in [figure A.4](#app01fig04).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始使用 RStudio 时，我们强烈建议关闭“启动时将 .RData 恢复到工作区”和“退出时将工作区保存到 .RData”这两个功能。这些设置（默认）开启会使“干净工作”（我们将在
    [章节 A.3](../Text/A.xhtml#app01lev1sec3) 中讨论）变得难以可靠。要关闭这些功能，请打开 RStudio 选项面板（全局选项可以通过例如菜单
    RStudio > 预设，工具 > 全局选项，工具 > 选项或类似的方式找到，具体取决于你使用的操作系统），然后按照 [图 A.4](#app01fig04)
    中的指示更改这两个设置。
- en: Figure A.4\. RStudio options
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.4\. RStudio 选项
- en: '![](Images/app01fig04_alt.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/app01fig04_alt.jpg)'
- en: A.1.5\. R resources
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.5\. R 资源
- en: A lot of the power of R comes from its large family of packages, available from
    the CRAN repository. In this section, we’ll point out some packages and documentation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: R 的强大功能很大程度上来自于其庞大的包家族，这些包可以从 CRAN 仓库获取。在本节中，我们将指出一些包和文档。
- en: Installing R views
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 R 视图
- en: 'R has an incredibly deep set of available libraries. Usually, R already has
    the package you want; it’s just a matter of finding it. A powerful way to find
    R packages is using *views*: [http://cran.r-project.org/web/views/](http://cran.r-project.org/web/views/).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: R 提供了一套非常深入的可用库。通常，R 已经有了你想要的包；只是需要找到它。一种强大的查找 R 包的方法是使用 *视图*：[http://cran.r-project.org/web/views/](http://cran.r-project.org/web/views/)。
- en: 'You can also install all the packages (with help documentation) from a view
    with a single command (though be warned: this can take an hour to finish). For
    example, here we’re installing a huge set of time series libraries all at once:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过一个命令（尽管警告：这可能需要一个小时才能完成）安装所有包（包括帮助文档）。例如，这里我们一次性安装了一个庞大的时间序列库集合：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you’ve done this, you’re ready to try examples and code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，你就可以尝试示例和代码了。
- en: Online R resources
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在线 R 资源
- en: 'A lot of R help is available online. Some of our favorite resources include
    these:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有很多 R 帮助资源。我们最喜欢的资源包括以下这些：
- en: '***CRAN—*** The main R site: [http://cran.r-project.org](http://cran.r-project.org)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***CRAN—*** 主要的 R 网站：[http://cran.r-project.org](http://cran.r-project.org)'
- en: '***Stack Overflow R section—*** A question-and-answer site: [http://stackoverflow.com/questions/tagged/r](http://stackoverflow.com/questions/tagged/r)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Stack Overflow R 部分—*** 一个问答网站：[http://stackoverflow.com/questions/tagged/r](http://stackoverflow.com/questions/tagged/r)'
- en: '***Quick-R—*** A great R resource: [http://www.statmethods.net](http://www.statmethods.net)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Quick-R—*** 一个优秀的 R 资源：[http://www.statmethods.net](http://www.statmethods.net)'
- en: '***LearnR—*** A translation of all the plots from *Lattice: Multivariate Data
    Visualization with R (Use R!)* (by D. Sarker; Springer, 2008) into ggplot2: [http://learnr.wordpress.com](http://learnr.wordpress.com)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***LearnR—*** 将 *Lattice: Multivariate Data Visualization with R (Use R!)*（由
    D. Sarker；Springer，2008）中的所有图表翻译成 ggplot2：[http://learnr.wordpress.com](http://learnr.wordpress.com)'
- en: '***R-bloggers—*** An R blog aggregator: [http://www.r-bloggers.com](http://www.r-bloggers.com)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***R-bloggers—*** 一个 R 博客聚合器：[http://www.r-bloggers.com](http://www.r-bloggers.com)'
- en: '***RStudio community—*** An RStudio/tidyverse–oriented company site: [https://community.rstudio.com/](https://community.rstudio.com/)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***RStudio 社区—*** 一个以 RStudio/tidyverse 为导向的公司网站：[https://community.rstudio.com/](https://community.rstudio.com/)'
- en: A.2\. Starting with R
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2\. 从 R 开始
- en: R implements a dialect of a statistical programming language called *S*. The
    original implementation of S evolved into a commercial package called S+. So most
    of R’s language-design decisions can be traced back to S. To avoid confusion,
    we’ll mostly just say *R* when describing features. You might wonder what sort
    of command and programming environment S/R is. It’s a pretty powerful one, with
    a nice command interpreter that we encourage you to type directly into.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: R 实现了一种名为 *S* 的统计编程语言的方言。S 的原始实现演变成一个名为 S+ 的商业包。因此，R 的许多语言设计决策都可以追溯到 S。为了避免混淆，当我们描述功能时，我们大部分时间只说
    *R*。您可能会想知道 S/R 是什么样的命令和编程环境。它非常强大，有一个很好的命令解释器，我们鼓励您直接输入。
- en: '* * *'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Work clean**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**干净工作**'
- en: In R or RStudio, it is important to “work clean”—that is, to start with an empty
    workspace and explicitly bring in the packages, code, and data you want. This
    ensures you know how to get into your ready-to-go state (as you have to perform
    or write down the steps to get there) and you aren’t held hostage to state you
    don’t know how to restore (what we call the “no alien artifact” rule).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 或 RStudio 中，重要的是“干净地工作”——也就是说，从一个空的工作区开始，并明确引入您想要的包、代码和数据。这确保您知道如何进入您的准备就绪状态（因为您必须执行或写下到达那里的步骤），并且您不会受到您不知道如何恢复的状态的束缚（我们称之为“无外来工件”规则）。
- en: To work clean in R, you must turn off any sort of autorestore of the workspace.
    In “base R” this is done by restarting R with the `--no-restore` command-line
    flag set. In RStudio, the Session > Restart R menu option serves a similar role,
    *if* the “Restore .Rdata into workspace on startup” option is not checked.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 R 中干净地工作，你必须关闭任何类型的工作区自动恢复。在“基础 R”中，这是通过使用带有`--no-restore`命令行标志重启 R 来实现的。在
    RStudio 中，会话 > 重启 R 菜单选项起到类似的作用，*如果*未选中“启动时将 .Rdata 恢复到工作区”选项。
- en: '* * *'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Working with R and issuing commands to R is in fact scripting or programming.
    We assume you have some familiarity with scripting (perhaps using Visual Basic,
    Bash, Perl, Python, Ruby, and so on) or programming (perhaps using C, C#, C++,
    Java, Lisp, Scheme, and so on), or are willing to use one of our references to
    learn. We don’t intend to write long programs in R, but we’ll have to show how
    to issue R commands. R’s programming, though powerful, is a bit different than
    many of the popular programming languages, but we feel that with a few pointers,
    anyone can use R. If you don’t know how to use a command, try using the `help()`
    call to get at some documentation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R 和向 R 发送命令实际上是脚本编写或编程。我们假设您对脚本编写（可能使用 Visual Basic、Bash、Perl、Python、Ruby
    等）或编程（可能使用 C、C#、C++、Java、Lisp、Scheme 等）有些了解，或者愿意使用我们的参考资料之一来学习。我们并不打算在 R 中编写长程序，但我们必须展示如何发出
    R 命令。R 的编程虽然功能强大，但与许多流行的编程语言略有不同，但我们相信，只要有一些指导，任何人都可以使用 R。如果您不知道如何使用某个命令，请尝试使用`help()`调用获取一些文档。
- en: Throughout this book, we’ll instruct you to run various commands in R. This
    will almost always mean typing the text or the text following the command prompt
    > into the RStudio console window, followed by pressing Return. For example, if
    we tell you to type `1/5`, you can type that into the console window, and when
    you press Enter, you’ll see a result such as `[1] 0.2`. The `[1]` portion of the
    result is just R’s way of labeling result rows (and is to be ignored), and the
    `0.2` is the floating-point representation of one-fifth, as requested.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将指导您在 R 中运行各种命令。这几乎总是意味着将文本或命令提示符 > 后面的文本输入到 RStudio 控制台窗口中，然后按 Return。例如，如果我们告诉您输入`1/5`，您可以将它输入到控制台窗口中，当您按下
    Enter 键时，您将看到类似 `[1] 0.2` 的结果。结果中的 `[1]` 部分只是 R 标记结果行的方式（应忽略），而 `0.2` 是请求的五分之一的浮点表示。
- en: '* * *'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Help
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助
- en: Always try calling `help()` to learn about commands. For example, `help('if')`
    will bring up help about R’s `if` command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总是尝试调用`help()`来了解命令。例如，`help('if')`将显示有关 R 的`if`命令的帮助信息。
- en: '* * *'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Let’s try a few commands to help you become familiar with R and its basic data
    types. R commands can be terminated with a line break or a semicolon (or both),
    but interactive content isn’t executed until you press Return. The following listing
    shows a few experiments you should run in your copy of R.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试几个命令，帮助您熟悉 R 和其基本数据类型。R 命令可以用换行符或分号（或两者）终止，但直到您按下 Return 键之前，交互式内容不会执行。以下列表显示了您应该在您的
    R 复制中运行的几个实验。
- en: Listing A.1\. Trying a few R commands
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.1\. 尝试几个 R 命令
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '* * *'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: is R’s comment character
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是 R 的注释字符
- en: The `#` mark is R’s comment character. It indicates that the rest of the line
    is to be ignored. We use it to include comments, and also to include output along
    with the results.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` 符号是 R 语言中的注释字符。它表示该行剩余部分的内容将被忽略。我们使用它来添加注释，也可以用它将输出与结果一起包含。'
- en: '* * *'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A.2.1\. Primary features of R
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1\. R 的主要特性
- en: R commands look like a typical procedural programming language. This is deceptive,
    as the S language (which the language R implements) was actually inspired by functional
    programming and also has a lot of object-oriented features.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: R 命令看起来像典型的过程式编程语言。这有点误导，因为 R 语言（该语言实现了 S 语言）实际上受到了函数式编程的启发，并且也具有许多面向对象的特点。
- en: Assignment
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值
- en: 'R has five common assignment operators: `=`, `<-`, `->`, `<<-`, and `->>`.
    Traditionally, in R, `<-` is the preferred assignment operator, and `=` is thought
    of as a late addition and an amateurish alias for it.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: R 有五种常见的赋值操作符：`=`, `<-`, `->`, `<<-`, 和 `->>`。在 R 中，`<-` 是首选的赋值操作符，而 `=` 被视为一个晚些时候的添加，并且是它的业余别名。
- en: 'The main advantage of the `<-` notation is that `<-` always means assignment,
    whereas `=` can mean assignment, list slot binding, function argument binding,
    or case statement, depending on the context. One mistake to avoid is accidentally
    inserting a space in the assignment operator:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`<-` 符号的优点在于 `<-` 总是表示赋值，而 `=` 可以表示赋值、列表槽绑定、函数参数绑定或情况语句，具体取决于上下文。要避免的一个错误是意外地在赋值操作符中插入空格：'
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We actually like `=` assignment better because data scientists tend to work
    in more than one language at a time and more bugs are caught early with `=`. But
    this advice is too heterodox to burden others with (see [http://mng.bz/hfug](http://mng.bz/hfug)).
    We try to consistently use `<-` in this book, but some habits are hard to break.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上更喜欢 `=` 赋值，因为数据科学家通常同时使用多种语言，并且使用 `=` 可以更早地捕捉到更多错误。但这个建议太异端，不能强加于人（见 [http://mng.bz/hfug](http://mng.bz/hfug)）。我们试图在这本书中一致地使用
    `<-`，但一些习惯很难改变。
- en: '* * *'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Multiline commands in R
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的多行命令
- en: R is good with multiline commands. To enter a multiline command, just make sure
    it would be a syntax error to stop parsing where you break a line. For example,
    to enter `1+2` as two lines, add the line break after the plus sign and not before.
    To get out of R’s multiline mode, press Escape. A lot of cryptic R errors are
    caused by either a statement ending earlier than you wanted (a line break that
    doesn’t force a syntax error on early termination) or not ending where you expect
    (needing an additional line break or semicolon).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: R 很擅长处理多行命令。要输入多行命令，只需确保在断行处停止解析会导致语法错误即可。例如，要将 `1+2` 作为两行输入，在加号后添加换行符，而不是在前面。要从
    R 的多行模式中退出，请按 Escape 键。许多神秘的 R 错误是由以下原因造成的：要么是语句结束得比你想要的早（一个不会在早期终止时强制语法错误的换行符），要么是结束得不是你预期的（需要额外的换行符或分号）。
- en: '* * *'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `=` operator is primarily used to bind values to function arguments (and
    `<-` can’t be so used) as shown in the next listing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`=` 操作符主要用于将值绑定到函数参数（而 `<-` 不能这样使用），如以下列表所示。'
- en: Listing A.2\. Binding values to function arguments
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.2\. 将值绑定到函数参数
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `->` operator is just a left-to-right assignment that lets you write things
    like `x -> 5`. It’s cute, but not game changing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`->` 操作符仅是一个从左到右的赋值，允许你编写类似 `x -> 5` 的内容。这很有趣，但并不改变游戏规则。'
- en: The `<<-` and `->>` operators are to be avoided unless you actually need their
    special abilities. They are intended to write values outside of the current execution
    environment, which is an example of a side effect. Side effects seem great when
    you need them (often for error tracking and logging), but when overused they make
    code maintenance, debugging, and documentation much harder. In the following listing,
    we show a good function that doesn’t have a side effect and a bad function that
    does have one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<-` 和 `->>` 操作符应尽量避免使用，除非你确实需要它们的特殊功能。它们旨在将值写入当前执行环境之外，这是副作用的一个例子。当你需要它们时（通常用于错误跟踪和日志记录），副作用看起来很棒，但过度使用会使代码维护、调试和文档编写变得非常困难。在以下列表中，我们展示了一个没有副作用的好函数和一个有副作用的坏函数。'
- en: Listing A.3\. Demonstrating side effects
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.3\. 展示副作用
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Vectorized operations
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化操作
- en: Many R operations are called *vectorized*, which means they work on every element
    of a vector. These operators are convenient and to be preferred over explicit
    code like for loops. For example, the vectorized logic operators are `==`, `&`,
    and `|`. The next listing shows some examples using these operators on R’s logical
    types `TRUE` and `FALSE`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 R 操作被称为 *向量化*，这意味着它们作用于向量的每个元素。这些运算符很方便，并且应该优先于显式的代码，如 for 循环。例如，向量化的逻辑运算符是
    `==`、`&` 和 `|`。接下来的列表展示了使用这些运算符在 R 的逻辑类型 `TRUE` 和 `FALSE` 上的示例。
- en: Listing A.4\. R truth tables for Boolean operators
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.4\. R 中布尔运算符的真值表
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To test if two vectors are a match, we’d use R’s `identical()` or `all.equal()`
    methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试两个向量是否匹配，我们会使用 R 的 `identical()` 或 `all.equal()` 方法。
- en: '* * *'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: When to use && or || in R
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中何时使用 && 或 ||
- en: '`&&` and `||` work only on scalars, not vectors. So *always* use `&&` and `||`
    in `if()` statements, and never use `&` or `|` in `if()` statements. Similarly
    prefer `&` and `|` when working with general data (which may need these vectorized
    versions).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&` 和 `||` 只在标量上工作，不在向量上。所以 *总是* 在 `if()` 语句中使用 `&&` 和 `||`，永远不要在 `if()` 语句中使用
    `&` 或 `|`。类似地，当处理一般数据（可能需要这些向量化的版本）时，更倾向于使用 `&` 和 `|`。'
- en: '* * *'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: R also supplies a vectorized sector called `ifelse(,,)` (the basic R-language
    `if` statement isn’t vectorized).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: R 还提供了一个名为 `ifelse(,,)` 的向量化函数（基本的 R 语言 `if` 语句并没有向量化）。
- en: R’s object system
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: R 的对象系统
- en: Every item in R is an object and has a type definition called a *class*. You
    can ask for the type of any item using the `class()` command. For example, `class(c(1,2))`
    is *numeric*. R in fact has two object-oriented systems. The first one is called
    *S3* and is closest to what a C++ or Java programmer would expect. In the S3 class
    system, you can have multiple commands with the same name. For example, there
    may be more than one command called `print()`. Which `print()` actually gets called
    when you type `print(x)` depends on what type `x` is at runtime. S3 is a unique
    object system in that methods are global functions, and are *not* strongly associated
    with object definitions, prototypes, or interfaces. R also has a second object-oriented
    system called *S4*, which supports more detailed classes and allows methods to
    be picked based on the types of more than just the first argument. Unless you’re
    planning on becoming a professional R programmer (versus a professional R user
    or data scientist), we advise not getting into the complexities of R’s object-oriented
    systems. Mostly you just need to know that most R objects define useful common
    methods like `print()`, `summary()`, and `class()`. We also advise leaning heavily
    on the `help()` command. To get class-specific help, you use a notation *method.class*;
    for example, to get information on the `predict()` method associated with objects
    of class `glm`, you would type `help(predict.glm)`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的每个元素都是一个对象，并且有一个称为 *类* 的类型定义。你可以使用 `class()` 命令来询问任何对象的类型。例如，`class(c(1,2))`
    的类型是 *numeric*。实际上，R 有两个面向对象的系统。第一个被称为 *S3*，它最接近 C++ 或 Java 程序员所期望的系统。在 S3 类系统中，你可以有多个具有相同名称的命令。例如，可能存在多个名为
    `print()` 的命令。当你输入 `print(x)` 时，实际上调用的是哪个 `print()` 取决于 `x` 在运行时的类型。S3 是一个独特的对象系统，因为方法是全球函数，并且与对象定义、原型或接口没有强关联。R
    还有一个名为 *S4* 的第二个面向对象系统，它支持更详细的类，并允许根据第一个参数的类型以外的类型来选择方法。除非你打算成为一名专业的 R 程序员（而不是专业的
    R 用户或数据科学家），我们建议不要深入研究 R 的面向对象系统。大多数情况下，你只需要知道大多数 R 对象定义了有用的通用方法，如 `print()`、`summary()`
    和 `class()`。我们还建议大量使用 `help()` 命令。要获取特定类的帮助，使用 *method.class* 语法；例如，要获取与类 `glm`
    对象关联的 `predict()` 方法的信息，你应该输入 `help(predict.glm)`。
- en: R’s share-by-value characteristics
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: R 的按值共享特性
- en: 'In R each reference to a value is isolated: changes to one reference are not
    seen by other references. This is a useful feature similar to what other languages
    term “call by value semantics,” or even the immutable data types of some languages.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，每个对值的引用都是隔离的：对一个引用的更改不会被其他引用看到。这是一个有用的特性，类似于其他语言所说的“按值调用语义”，甚至是某些语言的不可变数据类型。
- en: This means, from the programmer’s point of view, that each variable or each
    argument of a function behaves as if it were a separate copy of what was passed
    to the function. Technically, R’s calling semantics are actually a combination
    of references and what is called *lazy copying*. But until you start directly
    manipulating function argument references, you see what looks like call-by-value
    behavior.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，从程序员的视角来看，每个变量或函数的每个参数都表现得像它是一个传递给函数的单独副本。技术上，R 的调用语义实际上是引用和所谓的 *惰性复制*
    的组合。但直到你开始直接操作函数参数引用，你看到的是类似值传递的行为。
- en: 'Share-by-value is a great choice for analysis software: it makes for fewer
    side effects and bugs. But most programming languages aren’t share-by-value, so
    share-by-value semantics often come as a surprise. For example, many professional
    programmers rely on changes made to values inside a function being visible outside
    the function. Here’s an example of call-by-value at work.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 值共享是分析软件的一个很好的选择：它减少了副作用和错误。但大多数编程语言都不是值共享，因此值共享语义通常是一个惊喜。例如，许多专业程序员依赖于函数内部值的变化在函数外部可见。下面是一个值传递工作的例子。
- en: Listing A.5\. Call-by-value effect
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.5\. 值传递效应
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Alters a. This is implemented by building an entirely new vector and reassigning
    a to refer to this new vector. The old value remains as it was, and any references
    continue to see the old, unaltered value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 改变 a。这是通过构建一个全新的向量并将 a 重新分配到这个新向量来实现的。旧值保持不变，任何引用仍然看到未更改的旧值。
- en: ❷ Notice that b’s value is not changed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注意 b 的值没有改变。
- en: A.2.2\. Primary R data types
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2\. R 的主要数据类型
- en: While the R language and its features are interesting, it’s the R data types
    that are most responsible for R’s style of analysis. In this section, we’ll discuss
    the primary data types and how to work with them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 R 语言及其特性很有趣，但 R 的数据类型才是 R 分析风格的主要原因。在本节中，我们将讨论主要数据类型以及如何使用它们。
- en: Vectors
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 向量
- en: R’s most basic data type is the *vector*, or array. In R, vectors are arrays
    of same-typed values. They can be built with the `c()` notation, which converts
    a comma-separated list of arguments into a vector (see `help(c)`). For example,
    `c(1,2)` is a vector whose first entry is `1` and second entry is `2`. Try typing
    `print(c(1,2))` into R’s command prompt to see what vectors look like and notice
    that `print(class(1))` returns `numeric`, which is R’s name for numeric vectors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: R 中最基本的数据类型是 *向量* 或数组。在 R 中，向量是相同类型值的数组。它们可以用 `c()` 符号构建，该符号将逗号分隔的参数列表转换为向量（参见
    `help(c)`）。例如，`c(1,2)` 是一个向量，其第一个条目是 `1`，第二个条目是 `2`。尝试在 R 的命令提示符中输入 `print(c(1,2))`
    来查看向量的样子，并注意 `print(class(1))` 返回 `numeric`，这是 R 对数值向量的称呼。
- en: R is fairly unique in having no scalar types. A single number such as the number
    5 is represented in R as a vector with exactly one entry (5).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: R 在没有标量类型方面相当独特。在 R 中，单个数字（如数字 5）被表示为一个只有一个条目的向量（5）。
- en: '* * *'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Numbers in R**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**R 中的数字**'
- en: Numbers in R are primarily represented in double-precision floating-point. This
    differs from some programming languages, such as C and Java, that default to integers.
    This means you don’t have to write `1.0/5.0` to prevent `1/5` from being rounded
    down to `0`, as you would in C or Java. It also means that some fractions aren’t
    represented perfectly. For example, `1/5` in R is actually (when formatted to
    20 digits by `sprintf("%.20f", 1 / 5)) 0.20000000000000001110`, not the `0.2`
    it’s usually displayed as. This isn’t unique to R; this is the nature of floating-point
    numbers. A good example to keep in mind is `1 / 5 != 3 / 5 - 2 / 5`, because `1
    / 5 - (3 / 5 - 2 / 5)` is equal to `5.55e-17`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的数字主要是以双精度浮点数表示。这与一些默认使用整数的编程语言（如 C 和 Java）不同。这意味着你不需要写 `1.0/5.0` 来防止 `1/5`
    在 C 或 Java 中被舍入到 `0`，就像你通常做的那样。这也意味着某些分数不能完美地表示。例如，R 中的 `1/5` 实际上（当通过 `sprintf("%.20f",
    1 / 5)` 格式化为 20 位时）是 `0.20000000000000001110`，而不是通常显示的 `0.2`。这并不特指 R；这是浮点数的本质。一个值得记住的好例子是
    `1 / 5 != 3 / 5 - 2 / 5`，因为 `1 / 5 - (3 / 5 - 2 / 5)` 等于 `5.55e-17`。
- en: '* * *'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'R doesn’t generally expose any primitive or scalar types to the user. For example,
    the number `1.1` is actually converted into a numeric vector with a length of
    1 whose first entry is `1.1`. Note that `print(class(1.1))` and `print(class(c(1.1,
    0)))` are identical. Note also that `length(1.1)` and `length(c(1.1))` are also
    identical. What we call scalars (or single numbers or strings) are in R just vectors
    with a length of `1`. R’s most common types of vectors are these:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: R 通常不会向用户公开任何原始或标量类型。例如，数字 `1.1` 实际上被转换为一个长度为 1 的数值向量，其第一个条目是 `1.1`。请注意，`print(class(1.1))`
    和 `print(class(c(1.1, 0)))` 是相同的。还要注意，`length(1.1)` 和 `length(c(1.1))` 也是相同的。我们所说的标量（或单个数字或字符串）在
    R 中只是长度为 `1` 的向量。R 最常见的向量类型如下：
- en: '***Numeric—*** Arrays of double-precision floating-point numbers.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***数值类型—*** 双精度浮点数的数组。'
- en: '***Character—*** Arrays of strings.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***字符类型—*** 字符串的数组。'
- en: '***Factor—*** Arrays of strings chosen from a fixed set of possibilities (called
    *enums* in many other languages).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***因子类型—*** 从一组固定可能性（在许多其他语言中称为 *枚举*）中选择字符串的数组。'
- en: '***Logical—*** Arrays of `TRUE`/`FALSE`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***逻辑类型—*** `TRUE`/`FALSE` 的数组。'
- en: '***NULL—*** The empty vector `c()` (which always has type `NULL`). Note that
    `length(NULL)` is `0` and `is.null(c())` is `TRUE`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***NULL—*** 空向量 `c()`（始终具有类型 `NULL`）。请注意，`length(NULL)` 为 `0`，且 `is.null(c())`
    为 `TRUE`。'
- en: 'R uses square-bracket notation (and others) to refer to entries in vectors.^([[7](#app01fn7)])
    Unlike most modern programming languages, R numbers vectors starting from 1 and
    not 0\. Here’s some example code showing the creation of a variable named `vec`
    holding a numeric vector. This code also shows that most R data types are *mutable*,
    in that we’re allowed to change them:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: R 使用方括号表示法（以及其他表示法）来引用向量中的条目.^([[7](#app01fn7)]) 与大多数现代编程语言不同，R 从 1 而不是 0 开始对向量进行编号。以下是一些示例代码，展示了创建一个名为
    `vec` 的变量，它包含一个数值向量。此代码还显示，大多数 R 数据类型是 *可变的*，这意味着我们可以更改它们：
- en: ⁷
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The most commonly used index notation is `[]`. When extracting single values,
    we prefer the double square-bracket notation `[[]]` as it gives out-of-bounds
    warnings in situations where `[]` doesn’t.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最常用的索引表示法是 `[]`。当提取单个值时，我们更喜欢双方括号表示法 `[[]]`，因为它在 `[]` 不适用的情况下会发出越界警告。
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '* * *'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Number sequences
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数字序列
- en: 'Number sequences are easy to generate with commands like `1:10`. Watch out:
    the `:` operator doesn’t bind very tightly, so you need to get in the habit of
    using extra parentheses. For example, `1:5 * 4 + 1` doesn’t mean `1:21`. For sequences
    of constants, try using `rep()`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 `1:10` 这样的命令可以轻松生成数字序列。注意：冒号运算符绑定不是很紧密，因此你需要养成使用额外括号的习惯。例如，`1:5 * 4 + 1`
    并不意味着 `1:21`。对于常量序列，尝试使用 `rep()`。
- en: '* * *'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Lists
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: In addition to vectors (created with the `c()` operator), R has two types of
    lists. Lists, unlike vectors, can store more than one type of object, so they’re
    the preferred way to return more than one result from a function. The basic R
    list is created with the `list()` operator, as in `list(6, 'fred')`. Basic lists
    aren’t really that useful, so we’ll skip over them to *named lists*. In named
    lists, each item has a name. An example of a named list would be created with
    `list('a' = 6, 'b' = 'fred')`. Usually the quotes on the list names are left out,
    but the list names are always constant strings (not variables or other types).
    In R, named lists are essentially the only convenient mapping structure (the other
    mapping structure being environments, which give you mutable lists). The ways
    to access items in lists are the `$` operator and the `[[]]` operator (see `help('[[')`
    in R’s help system). Here’s a quick example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `c()` 运算符创建的向量之外，R 还有两种类型的列表。与向量不同，列表可以存储多种类型的对象，因此是返回多个结果的首选方式。基本的 R 列表使用
    `list()` 运算符创建，例如 `list(6, 'fred')`。基本的列表实际上并不那么有用，所以我们将其跳过，直接到 *命名列表*。在命名列表中，每个条目都有一个名称。一个命名列表的示例可以通过
    `list('a' = 6, 'b' = 'fred')` 创建。通常省略列表名称上的引号，但列表名称始终是常量字符串（不是变量或其他类型）。在 R 中，命名列表实际上是唯一的便利映射结构（另一种映射结构是环境，它提供可变列表）。访问列表中的条目的方式是
    `$` 运算符和 `[[]]` 运算符（在 R 的帮助系统中查看 `help('[[')`）。以下是一个快速示例。
- en: Listing A.6\. Examples of R indexing operators
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.6\. R 索引运算符的示例
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Labels use case-sensitive partial match**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签使用大小写敏感的局部匹配**'
- en: The R list label operators (such as `$`) allow partial matches. For example,
    `list('abe' = 'lincoln')$a` returns `lincoln`, which is fine and dandy until you
    add a slot actually labeled a to such a list and your older code breaks. In general,
    it would be better if `list('abe'='lincoln')$a` was an error, so you'd have a
    chance of being signaled of a potential problem the first time you made such an
    error. You could try to disable this behavior with `options(warnPartialMatchDollar
    = TRUE)`, but even if that worked in all contexts, it’s likely to break any other
    code that’s quietly depending on such shorthand notation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: R 列表标签操作符（如 `$`）允许部分匹配。例如，`list('abe' = 'lincoln')$a` 返回 `lincoln`，这很好，直到你向这样的列表添加一个实际标记为
    a 的槽位，你的旧代码就会出错。一般来说，如果 `list('abe'='lincoln')$a` 是一个错误，那么你就有机会在第一次犯这样的错误时得到信号。你可以尝试使用
    `options(warnPartialMatchDollar = TRUE)` 来禁用此行为，但即使这在所有上下文中都有效，它也可能破坏任何依赖于这种简写符号的任何其他代码。
- en: '* * *'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: As you see in our example, the `[]` operator is vectorized, which makes lists
    incredibly useful as translation maps.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在我们的示例中看到的，`[]` 操作符是向量化的，这使得列表作为翻译映射变得极其有用。
- en: '* * *'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Selection: [[]] versus []**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择：[[]] 与 []**'
- en: '`[[]]` is the strictly correct operator for selecting a single element from
    a list or vector. At first glance, `[]` appears to work as a convenient alias
    for `[[]]`, but this is not strictly correct for single-value (scalar) arguments.
    `[]` is actually an operator that can accept vectors as its argument (try `list(a=''b'')[c(''a'',''a'')]`)
    and return nontrivial vectors (vectors of length greater than 1, or vectors that
    don’t look like scalars) or lists. The operator `[[]]` has different (and better)
    single-element semantics for both lists and vectors (though, unfortunately, `[[]]`
    has different semantics for lists than for vectors).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[]]` 是从列表或向量中选择单个元素的严格正确操作符。乍一看，`[]` 似乎是一个方便的别名 `[[]]`，但对于单值（标量）参数来说，这并不严格正确。实际上，`[]`
    是一个可以接受向量作为其参数的操作符（尝试 `list(a=''b'')[c(''a'',''a'')]`），并且可以返回非平凡向量（长度大于 1 的向量或看起来不像标量的向量）或列表。操作符
    `[[]]` 对于列表和向量都有不同的（更好的）单元素语义（尽管，不幸的是，`[[]]` 对于列表和向量的语义不同）。'
- en: 'Really, you should *never* use `[]` when `[[]]` can be used (when you want
    only a single result). Everybody, including the authors, forgets this and uses
    `[]` way more often than is safe. For lists, the main issue is that `[[]]` usefully
    unwraps the returned values from the list type (as you’d want: compare `class(list(a=''b'')[''a''])`
    to `class(list(a=''b'')[[''a'']])`). For vectors, the issue is that `[]` fails
    to signal outof-bounds access (compare `c(''a'',''b'')[[7]]` to `c(''a'',''b'')[7]`
    or, even worse, `c(''a'',''b'')[NA]`).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 真的，你应该**永远**不要在可以使用 `[[]]` 时使用 `[]`（当你只想得到单个结果时）。每个人，包括作者，都会忘记这一点，并且比安全地使用 `[]`
    更频繁地使用它。对于列表，主要问题是 `[[]]` 有用地解包了从列表类型返回的值（正如你所期望的：比较 `class(list(a='b')['a'])`
    与 `class(list(a='b')[['a']])`）。对于向量，问题是 `[]` 无法指示越界访问（比较 `c('a','b')[[7]]` 与 `c('a','b')[7]`
    或，更糟糕的是，`c('a','b')[NA]`）。
- en: '* * *'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Data frames
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框
- en: 'R’s central data structure is the *data frame*. A data frame is organized into
    rows and columns. It is a list of columns of different types. Each row has a value
    for each column. An R data frame is much like a database table: the column types
    and names are the schema, and the rows are the data. In R, you can quickly create
    a data frame using the `data.frame()` command. For example, `d = data.frame(x=c(1,2),y=c(''x'',''y''))`
    is a data frame.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: R 的核心数据结构是 *数据框*。数据框组织成行和列。它是由不同类型的列组成的列表。每一行都有一个列的值。R 数据框类似于数据库表：列类型和名称是模式，行是数据。在
    R 中，你可以使用 `data.frame()` 命令快速创建数据框。例如，`d = data.frame(x=c(1,2),y=c('x','y'))`
    是一个数据框。
- en: The correct way to read a column out of a data frame is with the `[[]]` or `$`
    operators, as in `d[['x']]`, `d$x` or `d[[1]]`. Columns are also commonly read
    with the `d[, 'x']` or `d['x']` notations. Note that not all of these operators
    return the same type (some return data frames, and some return arrays).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据框中读取列的正确方法是使用 `[[]]` 或 `$` 操作符，例如 `d[['x']]`、`d$x` 或 `d[[1]]`。列也通常用 `d[,
    'x']` 或 `d['x']` 的表示法读取。请注意，并非所有这些操作符都返回相同类型（一些返回数据框，而一些返回数组）。
- en: Sets of rows can be accessed from a data frame using the `d[rowSet,]` notation,
    where `rowSet` is a vector of Booleans with one entry per data row. We prefer
    to use `d[rowSet,, drop = FALSE]` or `subset(d,rowSet)`, as they’re guaranteed
    to always return a data frame and not some unexpected type like a vector (which
    doesn’t support all of the same operations as a data frame).^([[8](#app01fn8)])
    Single rows can be accessed with the `d[k,]` notation, where `k` is a row index.
    Useful functions to call on a data frame include `dim()`, `summary()`, and `colnames()`.
    Finally, individual cells in the data frame can be addressed using a row-and-column
    notation, like `d[1, 'x']`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `d[rowSet,]` 符号可以从数据框中访问行集，其中 `rowSet` 是一个布尔向量，每个数据行有一个条目。我们更倾向于使用 `d[rowSet,,
    drop = FALSE]` 或 `subset(d,rowSet)`，因为它们保证始终返回数据框，而不是某些意外的类型（如向量，它不支持数据框的所有相同操作）.^([[8](#app01fn8)])
    使用 `d[k,]` 符号可以访问单行，其中 `k` 是行索引。在数据框上可以调用的有用函数包括 `dim()`、`summary()` 和 `colnames()`。最后，可以使用行和列的符号来引用数据框中的单个单元格，例如
    `d[1, 'x']`。
- en: ⁸
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To see the problem, type `class(data.frame(x = c(1, 2))[1, ])`, which reports
    the class as `numeric`, instead of as `data.frame`.
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要查看问题，请输入 `class(data.frame(x = c(1, 2))[1, ])`，它报告的类别为 `numeric`，而不是 `data.frame`。
- en: From R’s point of view, a data frame is a single table that has one row per
    example you’re interested in and one column per feature you may want to work with.
    This is, of course, an idealized view. The data scientist doesn’t expect to be
    so lucky as to find such a dataset ready for them to work with. In fact, 90% of
    the data scientist’s job is figuring out how to transform data into this form.
    We call this task *data tubing*, and it involves joining data from multiple sources,
    finding new data sources, and working with business and technical partners. But
    the data frame is exactly the right abstraction. Think of a table of data as the
    ideal data scientist API. It represents a nice demarcation between preparatory
    steps that work to get data into this form and analysis steps that work with data
    in this form.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从 R 的角度来看，数据框是一个单张表，其中每行对应你感兴趣的示例，每列对应你可能想要处理的特征。这当然是一个理想化的观点。数据科学家并不期望如此幸运，能够找到这样一个现成的数据集来工作。事实上，数据科学家的
    90% 的工作是找出如何将数据转换成这种形式。我们称这项任务为 *数据管道*，它涉及将来自多个来源的数据连接起来，寻找新的数据来源，并与商业和技术合作伙伴合作。但数据框正是正确的抽象。将数据表视为理想的数据科学家
    API。它代表了将数据准备成这种形式的工作步骤和分析步骤之间的一种良好分界。
- en: 'Data frames are essentially lists of columns. This makes operations like printing
    summaries or types of all columns especially easy, but makes applying batch operations
    to all rows less convenient. R matrices are organized as rows, so converting to/from
    matrices (and using transpose `t()`) is one way to perform batch operations on
    data frame rows. But be careful: converting a data frame to a matrix using something
    like the `model.matrix()` command (to change categorical variables into multiple
    columns of numeric level indicators) doesn’t track how multiple columns may have
    been derived from a single variable and can potentially confuse algorithms that
    have per-variable heuristics (like stepwise regression and random forests).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框本质上是一列列的列表。这使得打印摘要或所有列的类型变得特别容易，但将批量操作应用于所有行则不太方便。R 矩阵按行组织，因此将数据框转换为/从矩阵转换（并使用转置
    `t()`）是执行数据框行批量操作的一种方法。但请注意：使用类似 `model.matrix()` 命令（将分类变量转换为多个数值水平指示符的列）将数据框转换为矩阵时，不会跟踪多个列可能如何从一个变量派生出来，并且可能会使具有按变量启发式（如逐步回归和随机森林）的算法产生混淆。
- en: Data frames would be useless if the only way to populate them was to type them
    in. The two primary ways to populate data frames are R’s `read.table()` command
    and database connectors (which we’ll cover in [section A.3](../Text/A.xhtml#app01lev1sec3)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果填充数据框的唯一方式是手动输入，那么数据框将毫无用处。填充数据框的两种主要方式是 R 的 `read.table()` 命令和数据库连接器（我们将在
    [A.3 节](../Text/A.xhtml#app01lev1sec3) 中介绍）。
- en: Matrices
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵
- en: In addition to data frames, R supports matrices. Matrices are two-dimensional
    structures addressed by rows and columns. Matrices differ from data frames in
    that matrices are lists of rows, and every cell in a matrix has the same type.
    When indexing matrices, we advise using the `drop = FALSE` notation; without this,
    selections that should return single-row matrices instead return vectors. This
    would seem okay, except that in R, vectors aren’t substitutable for matrices,
    so downstream code that’s expecting a matrix will mysteriously crash at run time.
    And the crash may be rare and hard to demonstrate or find, as it only happens
    if the selection happens to return exactly one row.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据框之外，R 还支持矩阵。矩阵是通过行和列来寻址的二维结构。矩阵与数据框的不同之处在于，矩阵是行列表，并且矩阵中的每个单元格都具有相同的类型。在索引矩阵时，我们建议使用`drop
    = FALSE`的表示法；如果没有这个，本应返回单行矩阵的选择将返回向量。这似乎没问题，但在 R 中，向量不能替代矩阵，因此期望矩阵的下游代码在运行时会神秘地崩溃。而且崩溃可能很少见，难以演示或找到，因为这只有在选择恰好返回一行时才会发生。
- en: NULL and NANA (not available) values
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: NULL 和 NANA（不可用）值
- en: 'R has two special values: `NULL` and `NA`. In R, `NULL` is just an alias for
    `c()`, the empty vector. It carries no type information, so an empty vector of
    numbers is the same type as an empty vector of strings (a design flaw, but consistent
    with how most programming languages handle so-called null pointers). `NULL` can
    only occur where a vector or list is expected; it can’t represent missing scalar
    values (like a single number or string).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: R 有两个特殊值：`NULL` 和 `NA`。在 R 中，`NULL` 只是 `c()`（空向量）的别名。它不携带类型信息，因此空数字向量与空字符串向量属于同一类型（这是一个设计缺陷，但与大多数编程语言处理所谓的空指针的方式一致）。`NULL`
    只能在期望向量或列表的地方出现；它不能表示缺失的标量值（如单个数字或字符串）。
- en: For missing scalar values, R uses a special symbol, `NA`, which indicates missing
    or unavailable data. In R, `NA` behaves like the not-a-number or `NaN` seen in
    most floating-point implementations (except `NA` can represent any scalar, not
    just a floating-point number). The value `NA` represents a nonsignaling error
    or missing value. *Nonsignaling* means that you don’t get a printed warning, and
    your code doesn’t halt (not necessarily a good thing). `NA` is inconsistent if
    it reproduces. `2+NA` is `NA`, as we’d hope, but `paste(NA,'b')` is a valid non-`NA`
    string.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于缺失的标量值，R 使用一个特殊符号`NA`，表示缺失或不可用数据。在 R 中，`NA`的行为类似于在大多数浮点实现中看到的非数字或`NaN`（除了`NA`可以表示任何标量，而不仅仅是浮点数）。值`NA`表示非信号错误或缺失值。"非信号"意味着你不会得到打印警告，并且你的代码不会停止（这不一定是个好事）。如果`NA`重复出现，则`NA`是不一致的。"2+NA"是`NA`，正如我们所希望的那样，但`paste(NA,'b')`是一个有效的非`NA`字符串。
- en: Even though `class(NA)` claims to be logical, `NA`s can be present in any vector,
    list, slot, or data frame.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`class(NA)`声称是逻辑类型，`NA`也可以出现在任何向量、列表、槽或数据框中。
- en: Factors
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因素
- en: In addition to a string type called `character`, R also has a special “set of
    strings” type similar to what Java programmers would call an *enumerated type*.
    This type is called a *factor*, and a factor is just a string value guaranteed
    to be chosen from a specified set of values called *levels*. The advantage of
    factors is they are exactly the right data type to represent the different values
    or levels of categorical variables.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了名为`character`的字符串类型之外，R还有一个特殊的“字符串集合”类型，类似于Java程序员所说的*枚举类型*。这种类型称为*因素*，因素只是一个保证从称为*级别*的指定值集中选择的字符串值。因素的优势在于，它们是表示分类变量不同值或级别的确切数据类型。
- en: The following example shows the string `red` encoded as a factor (note how it
    carries around the list of all possible values) and a failing attempt to encode
    `apple` into the same set of factors (returning `NA`, R’s special not-a-value
    symbol).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了字符串`red`被编码为因素（注意它携带了所有可能值的列表），以及尝试将`apple`编码到同一组因素中的失败尝试（返回`NA`，R的特殊非值符号）。
- en: Listing A.7\. R’s treatment of unexpected factor levels
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.7\. R处理意外因素级别的处理方式
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Factors are useful in statistics, and you’ll want to convert most string values
    into factors at some point in your data science process. Usually, the later you
    do this, the better (as you tend to know more about the variation in your data
    as you work)—so we suggest using the optional argument `"StringsAsFactors = FALSE"`
    when reading data or creating new `data.frame`s.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因素在统计学中很有用，你会在数据科学流程的某个阶段将大多数字符串值转换为因素。通常，你越晚这样做越好（因为你随着工作会更多地了解数据的变异）——所以我们建议在读取数据或创建新的`data.frame`时使用可选参数`"StringsAsFactors
    = FALSE"`。
- en: Making sure factor levels are consistent
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确保因子级别一致性
- en: 'In this book, we often prepare training and test data separately (simulating
    the fact that new data will usually be prepared after the original training data).
    For factors, this introduces two fundamental issues: consistency of numbering
    of factor levels during training, and application and discovery of new factor
    level values during application. For the first issue, it’s the responsibility
    of R code to make sure factor numbering is consistent. The following listing demonstrates
    that `lm()` correctly handles factors as strings and is consistent even when a
    different set of factors is discovered during application (this is something you
    may want to double-check for non-core libraries). For the second issue, discovering
    a new factor during application is a modeling issue. The data scientist either
    needs to ensure this can’t happen or develop a coping strategy (such as falling
    back to a model not using the variable in question).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们经常分别准备训练数据和测试数据（模拟新数据通常会在原始训练数据之后准备）。对于因子，这引入了两个基本问题：训练期间因子级别的编号一致性，以及在应用期间应用和发现新的因子级别值。对于第一个问题，确保因子编号一致性是
    R 代码的责任。以下列表演示了 `lm()` 正确处理因子作为字符串，并且在应用期间发现不同的一组因子时仍然保持一致性（这可能需要你为非核心库进行双重检查）。对于第二个问题，在应用期间发现新的因子是一个建模问题。数据科学家要么需要确保这种情况不会发生，要么开发应对策略（例如，回退到不使用相关变量的模型）。
- en: Listing A.8\. Confirming `lm()` encodes new strings correctly
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.8\. 确认 `lm()` 正确编码新字符串
- en: '[PRE11]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Builds a data frame and linear model mapping a,b,c to 1,2,3
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建一个数据框和线性模型，将 a、b、c 映射到 1、2、3
- en: ❷ Shows that the model gets the correct prediction for b as a string
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 展示了模型将 b 作为字符串正确预测
- en: ❸ Shows that the model gets the correct prediction for b as a factor, encoded
    with a different number of levels. This shows that lm() is correctly treating
    factors as strings.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 展示了模型将 b 作为因子，使用不同数量的级别进行编码时的正确预测。这表明 lm() 正确地将因子视为字符串。
- en: Slots
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽
- en: In addition to lists, R can store values by name in object slots. Object slots
    are addressed with the `@` operator (see `help('@')`). To list all the slots on
    an object, try `slotNames()`. Slots and objects (in particular the S3 and S4 object
    systems) are advanced topics we don’t cover in this book. You need to know that
    R has object systems, as some packages will return them to you, but you shouldn’t
    be creating your own objects early in your R career.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列表之外，R 还可以通过对象槽以名称存储值。对象槽使用 `@` 运算符进行寻址（参见 `help('@')`）。要列出对象上的所有槽，请尝试 `slotNames()`。插槽和对象（特别是
    S3 和 S4 对象系统）是本书中不涉及的高级主题。你需要知道 R 有对象系统，因为一些包会返回它们给你，但你不应在 R 生涯早期就创建自己的对象。
- en: A.3\. Using databases with R
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3\. 使用 R 与数据库
- en: Sometimes you want to use R to work with data in a database. Usually this is
    because the data is already in a database, or you want to use a high-performance
    database (such as Postgres or Apache Spark) to manipulate data at speed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想使用 R 来处理数据库中的数据。通常这是因为数据已经存在于数据库中，或者你希望使用高性能数据库（例如 Postgres 或 Apache
    Spark）来快速操作数据。
- en: If your data is small enough to fit in memory (or you can spin up a large enough
    computer to make this so, say on Amazon EC2, Microsoft Azure, or Google Cloud),
    we suggest bringing the data over to R using `DBI::dbReadTable()` and then using
    `data.table`. Except for the data transfer time, this will be very hard to beat.
    Note, however, that writing large results back to a database is not fully supported
    on all R database drivers (sparklyr, in particular, explicitly does not support
    this).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据足够小，可以放入内存（或者你可以启动足够大的计算机来做到这一点，比如在 Amazon EC2、Microsoft Azure 或 Google
    Cloud 上），我们建议使用 `DBI::dbReadTable()` 将数据带到 R 中，然后使用 `data.table`。除了数据传输时间外，这将是很难被击败的。然而，请注意，将大型结果写回数据库并不被所有
    R 数据库驱动程序完全支持（sparklyr，特别是明确不支持这一点）。
- en: If you want to work with data in a database (which we usually do for our clients),
    then we suggest using a query generator such as `rquery` or `dbplyr`. We also
    believe the idea of thinking in terms of Codd relational operators (or thinking
    in terms of SQL databases) is very beneficial, so playing around with one of the
    preceding systems can be well worth the effort.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在数据库中处理数据（我们通常为客户这样做），我们建议使用查询生成器，如 `rquery` 或 `dbplyr`。我们还认为，从 Codd 关系运算符的角度思考（或从
    SQL 数据库的角度思考）的想法非常有益，因此尝试使用上述系统之一可能会非常值得。
- en: A.3.1\. Running database queries using a query generator
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1\. 使用查询生成器运行数据库查询
- en: '* * *'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Ranking customer offers*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户出价排名*'
- en: '* * *'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'We are given a table of data keyed by customer names, product names. For each
    of these key pairs we have a suggested price discount fraction and a predicted
    discount offer affinity (both produced by some machine learning models, of the
    type we have been discussing in this book). Our task is to take this table and
    select the two offers with highest predicted affinity for each customer. The business
    goal is this: we want to show the customer only these two offers, and none of
    the others.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个以客户名称和产品名称为键的数据表。对于这些键对，我们有一个建议的价格折扣分数和一个预测的折扣出价亲和度（都是由一些机器学习模型生成的，这类模型是我们在这本书中讨论过的）。我们的任务是取这个表，并选择每个客户预测亲和度最高的两个出价。业务目标是这样的：我们只想向客户展示这两个出价，而不展示其他任何出价。
- en: To simulate this task, we will take some arbitrary data and copy it from R to
    a Postgres database. To run this example, you would need your own Postgres database,
    and copy in your own connection details, including host, port, username, and password.
    The purpose of this exercise is to give a taste of working with databases from
    R and a taste of thinking in Codd relational terms (the basis for many data processing
    systems, including `dplyr`).^([[9](#app01fn9)])
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这个任务，我们将从 R 中取一些任意数据并将其复制到 Postgres 数据库中。要运行这个示例，你需要自己的 Postgres 数据库，并复制你的连接细节，包括主机、端口、用户名和密码。这个练习的目的是让你体验从
    R 中操作数据库以及以 Codd 关系术语进行思考（这是许多数据处理系统的基础，包括 `dplyr`）。^([[9](#app01fn9)])
- en: ⁹
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The full example and worked solution are available here: [https://github.com/WinVector/PDSwR2/blob/master/BestOffers/BestOffers.md](https://github.com/WinVector/PDSwR2/blob/master/BestOffers/BestOffers.md).'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完整的示例和解决方案可以在以下链接找到：[https://github.com/WinVector/PDSwR2/blob/master/BestOffers/BestOffers.md](https://github.com/WinVector/PDSwR2/blob/master/BestOffers/BestOffers.md)。
- en: 'First, we set up our database connection and copy some data into this fresh
    database:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置数据库连接并从一些数据中复制到这个新数据库中：
- en: '[PRE12]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Uses DBI to connect to a database. In this case, it creates a new in-memory
    SQLite.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 DBI 连接到数据库。在这种情况下，它创建了一个新的内存中的 SQLite。
- en: ❷ Builds an rquery wrapper for the connection
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为连接构建一个 rquery 包装器
- en: ❸ Copies some example data into the database
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将一些示例数据复制到数据库中
- en: Now we will solve the problem by thinking relationally. We work in steps, and
    with experience, we would see that to solve this problem, we want to assign a
    per-user rank to each offer and then filter down to the ranks we want.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过关系性思维来解决这个问题。我们按步骤进行，并且随着经验的积累，我们会发现要解决这个问题，我们想要为每个用户分配每个出价的排名，然后筛选出我们想要的排名。
- en: We will work this example using the `rquery` package. In `rquery`, window functions
    are available though the `extend()` method.^([[10](#app01fn10)]) `extend()` can
    calculate a new column based both on a partition of the data (by `user_name`)
    and an ordering of columns within these partitions (by `predicted_offer_affinity`).
    It is easiest to demonstrate this in action.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `rquery` 包来演示这个例子。在 `rquery` 中，可以通过 `extend()` 方法使用窗口函数.^([[10](#app01fn10)])
    `extend()` 可以根据数据的分区（通过 `user_name`）和这些分区内的列排序（通过 `predicted_offer_affinity`）来计算一个新列。通过实际操作来演示这一点最为直观。
- en: ^(10)
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The odd name “extend” was chosen out of respect for the source of these ideas:
    Codd’s relational algebra.'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择“extend”这个奇特的名字是为了尊重这些想法的来源：Codd 的关系代数。
- en: '[PRE13]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Pipes our data into the execute() method. Notice that we use the wrapr dot
    pipe.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将我们的数据通过 execute() 方法传递。注意我们使用了 wrapr 点管道。
- en: ❷ We’ll calculate rank() or the order of the data rows.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将计算 rank() 或数据行的顺序。
- en: ❸ The ranking will be recalculated for each user (our window partition).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将为每个用户（我们的窗口分区）重新计算排名。
- en: ❹ The window ordering that controls the rank will be from predicted_offer_affinity,
    reversed (largest first).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 控制排名的窗口排序将从预测出价亲和度开始，并反向排序（最大的排在前面）。
- en: ❺ Translates the operation plan into SQL, sends it to the database for execution,
    and brings the results back to R
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将操作计划转换为 SQL，发送到数据库执行，并将结果带回 R
- en: ❻ Pretty-prints the results
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 美化打印结果
- en: 'The question is this: how did we know to use the `extend` method and what options
    to set? That requires some experience with relational systems. There are only
    a few primary operations (adding derived columns, selecting columns, selecting
    rows, and joining tables) and only a few options (such as the partition and order
    when adding a windowed column). So the technique can be learned. The power of
    the theory is that just about any common data transform can be written in terms
    of these few fundamental data operators.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是这样的：我们是如何知道使用`extend`方法和设置哪些选项的？这需要一些关系型系统的经验。只有少数几个主要操作（添加派生列、选择列、选择行和连接表）以及少数几个选项（例如添加窗口列时的分区和排序）。因此，这种技术是可以学习的。理论的力量在于，几乎任何常见的数据转换都可以用这些基本数据操作符来表示。
- en: Now, to solve our full problem, we combine this operator with a few more relational
    operators (again using the `wrapr` dot pipe). This time we’ll have the result
    written into a remote table (so no data ever moves to or from R!) and then only
    copy the results back after the calculation is complete.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了解决我们的完整问题，我们将这个操作符与几个更多的关系型操作符（再次使用`wrapr`点管道）结合起来。这次结果将被写入远程表（因此数据永远不会移动到或从R！），然后在计算完成后仅复制结果。
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Defines our sequence of operations
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义我们的操作序列
- en: ❷ Marks each row with its simple per-user rank
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为每行标记其简单的按用户排名
- en: ❸ Selects the two rows with highest rank for each user
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为每个用户选择排名最高的两行
- en: ❹ Orders the rows by user and product rank
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 按用户和产品排名对行进行排序
- en: ❺ Runs the result in the database, instantiating a new result table
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在数据库中运行结果，实例化一个新的结果表
- en: ❻ Copies the result back to R and pretty-prints it
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将结果复制回R并格式化打印
- en: The reason we saved the operation plan in the variable `ops` is because we can
    do a lot more than just execute the plan. For example, we can create a diagram
    of the planned operations, as in [figure A.5](#app01fig05).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将操作计划保存在变量`ops`中的原因是因为我们可以做很多不仅仅是执行计划的事情。例如，我们可以创建计划操作的图表，如[图A.5](#app01fig05)所示。
- en: Figure A.5\. `rquery` operation plan diagram
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.5\. `rquery`操作计划图
- en: '![](Images/app01fig05.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/app01fig05.jpg)'
- en: 'Also—and this is the big point—we can see the SQL that gets actually sent to
    the database. Without a query planner (such as `rquery` or `dbplyr`), we would
    have to write something like this SQL:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外——这是一个重要观点——我们可以看到实际发送到数据库的SQL。如果没有查询规划器（如`rquery`或`dbplyr`），我们就必须编写如下SQL：
- en: '[PRE15]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The issue is that relational thinking is productive, but SQL itself is fairly
    verbose. In particular, SQL expresses sequencing or composition as nesting, which
    means we read from the inside out. A lot of the grace of Codd’s ideas is recovered
    when we move to an operator notation (such as seen in `dplyr` or `rquery`).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，关系型思考是富有成效的，但SQL本身相当冗长。特别是，SQL将顺序或组合表示为嵌套，这意味着我们是从内向外读取的。当我们转向操作符表示法（如`dplyr`或`rquery`中看到的那样）时，Codd的思想中的许多优雅之处得到了恢复。
- en: 'A longer treatment (with more references) of this example can be found here:
    [https://github.com/WinVector/PDSwR2/blob/master/BestOffers/BestOffers.md](https://github.com/WinVector/PDSwR2/blob/master/BestOffers/BestOffers.md).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以找到对这个例子的更详细处理（包含更多参考）：[https://github.com/WinVector/PDSwR2/blob/master/BestOffers/BestOffers.md](https://github.com/WinVector/PDSwR2/blob/master/BestOffers/BestOffers.md)。
- en: Relational data manipulation thinks in terms of operators, which we briefly
    touched on here, and data organization, which is the topic of our next section.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据处理从操作符的角度思考，我们在这里简要提到了这一点，以及数据组织，这是我们下一节的主题。
- en: A.3.2\. How to think relationally about data
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2\. 如何进行数据关系性思考
- en: 'The trick to thinking relationally about data is this: for every table, classify
    the columns into a few important themes, and work with the natural relations between
    these themes. One view of the major column themes is provided in [table A.1](#app01table01).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据关系性思考的技巧是这样的：对于每一个表格，将列分类为几个重要的主题，并处理这些主题之间的自然关系。关于主要列主题的一个观点可以在[表A.1](#app01table01)中找到。
- en: Table A.1\. Major SQL column themes
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.1\. 主要SQL列主题
- en: '| Column theme | Description | Common uses and treatments |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 列主题 | 描述 | 常见用途和处理 |'
- en: '| --- | --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Natural key columns | In many tables, one or more columns taken together
    form a natural key that uniquely identifies the row. Some data (such as running
    logs) doesn’t have natural keys (many rows may correspond to a given timestamp).
    | Natural keys are used to sort data, control joins, and specify aggregations.
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 自然键列 | 在许多表中，一个或多个列组合在一起形成一个自然键，该键唯一地标识行。某些数据（如运行日志）没有自然键（许多行可能对应于给定的时间戳）。
    | 自然键用于排序数据、控制连接和指定聚合。 |'
- en: '| Surrogate key columns | Surrogate key columns are key columns (collections
    of columns that uniquely identify rows) that don’t have a natural relation to
    the problem. Examples of surrogate keys include row numbers and hashes. In some
    cases (like analyzing time series), the row number can be a natural key, but usually
    it’s a surrogate key. | Surrogate key columns can be used to simplify joins; they
    tend not to be useful for sorting and aggregation. Surrogate key columns must
    not be used as modeling features, as they don’t represent useful measurements.
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 代理键列 | 代理键列是没有与问题自然相关联的关键列（唯一标识行的列集合）。代理键的例子包括行号和散列。在某些情况下（如分析时间序列），行号可以是自然键，但通常它是代理键。
    | 代理键列可以用来简化连接；它们通常对排序和聚合没有用处。代理键列不得用作建模特征，因为它们不代表有用的测量。 |'
- en: '| Provenance columns | Provenance columns are columns that contain facts about
    the row, such as when it was loaded. The ORIGIN-SERTTIME, ORIGFILENAME, and ORIGFILEROWNUMBER
    columns added in [section 2.3.1](../Text/02.xhtml#ch02lev2sec5) are examples of
    provenance columns. | Provenance columns shouldn’t be used in analyses, except
    for confirming you’re working on the right dataset, selecting a dataset (if different
    datasets are commingled in the same table), and comparing datasets. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 来源列 | 来源列包含关于行的事实，例如何时加载。在[第2.3.1节](../Text/02.xhtml#ch02lev2sec5)中添加的ORIGIN-SERTTIME、ORIGFILENAME和ORIGFILEROWNUMBER列是来源列的例子。
    | 来源列不应用于分析，除非用于确认你正在处理正确的数据集、选择数据集（如果同一表中混合了不同的数据集）和比较数据集。 |'
- en: '| Payload columns | Payload columns contain actual data. Payload columns may
    be data such as prices and counts. | Payload columns are used for aggregation,
    grouping, and conditions. They can also sometimes be used to specify joins. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 负载列 | 负载列包含实际数据。负载列可能包含价格和计数等数据。 | 负载列用于聚合、分组和条件。它们有时也可以用来指定连接。 |'
- en: '| Experimental design columns | Experimental design columns include sample
    grouping like ORIGRANDGROUP from [section 2.3.1](../Text/02.xhtml#ch02lev2sec5),
    or data weights like the PWGTP* and WGTP* columns we mentioned in [section 7.1.1](../Text/07.xhtml#ch07lev2sec1).
    | Experiment design columns can be used to control an analysis (select subsets
    of data, used as weights in modeling operations), but they should never be used
    as features in an analysis. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 实验设计列 | 实验设计列包括样本分组，如[第2.3.1节](../Text/02.xhtml#ch02lev2sec5)中提到的ORIGRANDGROUP，或数据权重，如我们在[第7.1.1节](../Text/07.xhtml#ch07lev2sec1)中提到的PWGTP*和WGTP*列。
    | 实验设计列可以用来控制分析（选择数据子集，在建模操作中使用作为权重），但它们永远不应该用作分析的特征。 |'
- en: '| Derived columns | Derived columns are columns that are functions of other
    columns or other groups of columns. An example would be the day of week (Monday
    through Sunday), which is a function of the date. Derived columns can be functions
    of keys (which means they’re unchanging in many GROUP BY queries, even though
    SQL will insist on specifying an aggregator such as MAX()) or functions of payload
    columns. | Derived columns are useful in analysis. A *full normal form* database
    doesn’t have such columns. In normal forms, the idea is to not store anything
    that can be derived, which eliminates certain types of inconsistency (such as
    a row with the date February 1, 2014, and the day of week Wednesday, when the
    correct day of week is Saturday). But during analyses, it’s always a good idea
    to store intermediate calculations in tables and columns: it simplifies code and
    makes debugging much easier. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 派生列 | 派生列是其他列或列组的函数列。一个例子是星期几（从星期一到星期日），它是日期的函数。派生列可以是键的函数（这意味着在许多GROUP BY查询中它们是不变的，尽管SQL会坚持指定一个聚合器，如MAX()）或负载列的函数。
    | 派生列在分析中很有用。一个*完全范式*数据库没有这样的列。在范式设计中，目的是不存储可以派生的任何内容，这消除了某些类型的不一致性（例如，日期为2014年2月1日，星期为星期三的行，而正确的星期应该是星期六）。但在分析过程中，始终将中间计算存储在表和列中是个好主意：它简化了代码，并使调试变得容易得多。
    |'
- en: The point is that analysis is much easier if you have a good taxonomy of column
    themes for every supplied data source. You then design SQL command sequences to
    transform your data into a new table where the columns are just right for analysis.
    In the end, you should have tables where every row is an event you’re interested
    in, and every needed fact is already available in a column (which has been called
    a *model matrix* for a very long time, or a *denormalized table* in relational
    database terms).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，如果你为每个提供的数据源都有一个良好的列主题分类法，分析就会容易得多。然后，你设计SQL命令序列来将你的数据转换成一个新的表格，其中列正好适合分析。最终，你应该拥有这样的表格：每一行都是你感兴趣的事件，每个需要的细节都已经在一个列中（这个列长期以来被称为*模型矩阵*，或者从关系数据库的角度来说，是一个*非规范化表*）。
- en: Further database reading
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的数据库阅读
- en: Our go-to database reference is Joe Celko, *SQL for Smarties,* Fourth Edition
    (Morgan Kauffman, 2011).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首选的数据库参考书籍是Joe Celko的《SQL for Smarties》，第四版（Morgan Kauffman，2011年）。
- en: A.4\. The takeaway
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4. 吸取的经验
- en: In our opinion, the R ecosystem is the fastest path to substantial data science,
    statistical, and machine learning accomplishment. Other systems may have more
    advanced machine learning capabilities (such as Python’s deep learning connections),
    but these are now also available to R users through an adapter called *reticulate*.^([[11](#app01fn11)])
    No data scientist should expect to work forever in just one language, or with
    just one system; but we feel R is a good place for many to start.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看来，R生态系统是通往实质性数据科学、统计和机器学习成就的最快途径。其他系统可能拥有更先进的机器学习功能（例如Python的深度学习连接），但这些现在也通过一个名为*reticulate*的适配器对R用户开放了。^([[11](#app01fn11)])
    没有数据科学家会期望永远只使用一种语言或一个系统工作；但我们认为R是许多人开始的好地方。
- en: ^(11)
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For an example, please see François Chollet and J. J. Allaire, *Deep Learning
    with R* (Manning, 2018).
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，请参阅François Chollet和J. J. Allaire合著的《Deep Learning with R》（Manning，2018年）。
