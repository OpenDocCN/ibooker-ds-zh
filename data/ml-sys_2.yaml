- en: Part 3\. Operating a machine learning system
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3部分\. 运营机器学习系统
- en: Whereas part of this book focused on getting to the point of a having an entire
    machine learning system, [part 3](#part03) is about what comes next. All sorts
    of work must be done over the lifetime of operating a machine learning system,
    making it possible for you to change and improve the system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书的一部分专注于达到拥有整个机器学习系统的目标，[第3部分](#part03)则是关于接下来会发生什么。在机器学习系统运行的过程中，必须完成各种工作，使你们能够改变和改进系统。
- en: '[Chapter 9](kindle_split_021.html#ch09) goes deeper into how to build and deploy
    machine learning systems. It covers best practices developed for the operations
    of other sorts of software applications and applies them to the unique responsibilities
    of a reactive machine learning system.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](kindle_split_021.html#ch09)深入探讨了如何构建和部署机器学习系统。它涵盖了为其他类型的软件应用程序开发的最佳实践，并将它们应用于反应式机器学习系统的独特责任。'
- en: '[Chapter 10](kindle_split_022.html#ch10) works through how you can incrementally
    improve the intelligence capabilities of a system. It introduces the far-reaching
    ambitions of artificial intelligence platforms. This final chapter provides the
    book’s most expansive perspective on how to design systems. I encourage you to
    adopt this broad perspective as a way of thinking about the skills you’ve developed
    as an architect of reactive machine learning systems.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](kindle_split_022.html#ch10)探讨了如何逐步提升系统的智能能力。它介绍了人工智能平台的长远目标。本章提供了本书对系统设计最全面的视角。我鼓励你们将这种广阔的视角作为一种思考方式，来考虑作为反应式机器学习系统架构师所培养的技能。'
- en: Chapter 9\. Delivering
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章\. 交付
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Building Scala code using sbt
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用sbt构建Scala代码
- en: Evaluating applications for deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估部署应用程序
- en: Strategies for deployments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署策略
- en: Now that you’ve seen how all the components of a machine learning system work
    together, it’s time to think about some system-level challenges. In this chapter,
    we’ll explore how to *deliver* a machine learning system for use by the ultimate
    customers of the system. The approach we’ll use for this challenge is called *continuous
    delivery*. The ideas behind continuous delivery were developed outside of a machine
    learning context, but as you’ll see, they’re entirely applicable to the challenge
    of making machine learning reactive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你们已经看到了机器学习系统所有组件如何协同工作，是时候考虑一些系统级挑战了。在本章中，我们将探讨如何向系统的最终用户交付一个机器学习系统。我们将用于这个挑战的方法被称为*持续交付*。持续交付背后的思想是在机器学习环境之外发展的，但正如你们将看到的，它们完全适用于使机器学习系统反应式化的挑战。
- en: Continuous delivery practitioners seek to rapidly deliver new units of functionality
    through regular cycles that build and deploy new code. Teams that take on this
    approach are often trying to move fast while keeping users happy. The techniques
    of continuous delivery provide tactics that allow teams to fulfill these competing
    aims. Given all the ways you’ve seen for machine learning systems to fail, I hope
    it’s clear that maintaining consistent behavior in these systems is tough stuff.
    Uncertainty is pervasive and intrinsic in machine learning systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付实践者寻求通过定期构建和部署新代码的循环，快速交付新的功能单元。采用这种方法的团队通常试图快速行动同时保持用户满意。持续交付的技术提供了允许团队实现这些竞争目标的策略。鉴于你们所看到的机器学习系统可能失败的所有方式，我希望很明显，在这些系统中保持一致的行为是件困难的事情。不确定性在机器学习系统中普遍存在且固有其本质。
- en: 9.1\. Shipping fruit
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 发货水果
- en: 'The team you’ll join in this chapter is composed of some of the most customer-focused,
    empathetic animals in the entire jungle: gorillas. Jungle Juice Box (JJB) is a
    primate startup focused on animals who like to make fruit smoothies in their own
    home ([figure 9.1](#ch09fig01)). Each month, subscribers to Jungle Juice Box receive
    a box of fresh fruit that has been individually selected for them, based on what
    fruit is in season and the customer’s perceived preferences.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你们将要加入的团队由整个丛林中最以客户为中心、最有同理心的动物组成：大猩猩。丛林果汁盒（JJB）是一家专注于喜欢在自己家中制作水果冰沙的灵长类动物创业公司（[图9.1](#ch09fig01)）。每个月，丛林果汁盒的订阅者都会收到一个装有新鲜水果的盒子，这些水果是根据当季水果和客户的感知偏好为他们单独挑选的。
- en: Figure 9.1\. Jungle Juice Box
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1\. 丛林果汁盒
- en: '![](09fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig01.jpg)'
- en: As with most startups today, the gorillas of Jungle Juice Box use sophisticated
    data techniques to satisfy their customers. In particular, they regularly gather
    feedback ratings from all their subscribers so they can use machine learning to
    make unique fruit recommendations for each subscriber. The architecture of the
    portion of the system concerned with fruit recommendations looks something like
    [figure 9.2](#ch09fig02).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与今天的大多数初创公司一样，Jungle Juice Box的巨猿们使用复杂的数据技术来满足他们的客户。特别是，他们定期收集所有订阅者的反馈评分，以便他们可以使用机器学习为每个订阅者提供独特的推荐水果。关注水果推荐部分的系统架构看起来类似于[图9.2](#ch09fig02)。
- en: Figure 9.2\. Fruit-selection architecture
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 水果选择架构
- en: '![](09fig02_alt.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig02_alt.jpg)'
- en: Past subscriber ratings of fruit selections, stored in a database, are used
    to produce features and concept labels for training instances. Models are then
    learned from those instances in the model-learning pipeline. Those models are
    included in the build of the larger application in the build pipeline. The build
    pipeline produces an artifact that’s then deployed to production systems on an
    application-serving platform for use in real-time fruit-selection decisions. All
    this should look relatively familiar from [part 2](kindle_split_013.html#part02)
    of the book. This chapter focuses on the key part of the system where new models
    are evaluated and deployment decisions are made. Within the JJB system, this point
    is the build-and-deploy pipeline.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 过去的水果选择订阅者评分，存储在数据库中，用于生成训练实例的特征和概念标签。然后，从这些实例中学习模型，这些模型包含在构建管道中更大应用程序的构建中。构建管道生成一个工件，然后部署到应用程序服务平台的实际生产系统上，用于实时水果选择决策。所有这些在书的[第2部分](kindle_split_013.html#part02)中看起来相对熟悉。本章重点介绍系统的关键部分，即新模型的评估和部署决策。在JJB系统中，这个点就是构建和部署管道。
- en: 9.2\. Building and packaging
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 构建和打包
- en: At this point, it’s worth taking a quick step back and examining what I mean
    by *building code*. In this book, you’ve primarily built applications in Scala,
    which runs on top of the Java Virtual Machine (JVM). At a minimum, your source-code
    files need to be compiled into bytecode for execution by the JVM, but you often
    need to do more than compile your code. Sometimes, there are resource files, like
    the Parquet and JSON model files you produced in [chapter 7](kindle_split_018.html#ch07).
    These other types of artifacts are part of what you need to run your code, even
    if they’re directly output by the `scalac` compiler. Usually, all you need to
    do with such files is ensure that they can be passed around with the rest of your
    code. This process is often called *packaging*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得快速回顾一下我所说的*构建代码*的含义。在这本书中，你主要使用Scala构建应用程序，Scala运行在Java虚拟机（JVM）之上。至少，你的源代码文件需要编译成字节码，以便由JVM执行，但你通常需要做的不仅仅是编译你的代码。有时，会有资源文件，比如你在[第7章](kindle_split_018.html#ch07)中生成的Parquet和JSON模型文件。这些其他类型的工件是你运行代码所需的一部分，即使它们是由`scalac`编译器直接输出的。通常，你只需要确保这些文件可以与其他代码一起传递。这个过程通常被称为*打包*。
- en: '[Chapter 7](kindle_split_018.html#ch07) demonstrated one powerful approach
    to packaging using Docker containers. But there are certainly other approaches
    you can take to package your applications. Anything that gives you a coherent
    way of grouping all the executable code and necessary resources for your application
    is a potentially viable option.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](kindle_split_018.html#ch07)展示了使用Docker容器的一个强大的打包方法。但当然还有其他方法可以打包你的应用程序。任何能给你一种连贯的方式来分组所有应用程序的可执行代码和必要资源的都是一种潜在可行的选择。'
- en: 'Because the gorillas at JJB build their machine learning systems in Scala,
    they use a packaging method from the JVM ecosystem: building JARs. As discussed
    in [chapter 7](kindle_split_018.html#ch07), JARs are archives of compiled JVM
    code and associated resources. When working with Scala, you have several ways
    that you can produce JARs. The Jungle Juicers use a method that’s executed from
    sbt and relies on a plugin to extend sbt’s ability to produce deployable artifacts.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JJB的巨猿们在Scala中构建机器学习系统，他们使用来自JVM生态系统的打包方法：构建JAR文件。正如[第7章](kindle_split_018.html#ch07)中讨论的，JAR文件是编译的JVM代码和相关资源的归档。当使用Scala时，你有几种方法可以生成JAR文件。Jungle
    Juicers使用一种从sbt执行的方法，并依赖于一个插件来扩展sbt生成可部署工件的能力。
- en: The way the Juicers distribute the executable version of their application is
    in a JAR containing all the necessary dependencies (libraries) that the application
    needs. The artifact produced by this style of packaging is sometimes called a
    *fat JAR*, meaning it contains all the dependencies that could otherwise potentially
    be provided by the execution environment. They choose this approach because it
    simplifies some aspects of distributing and executing their application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Juicers 分发他们应用程序的可执行版本的方式是包含所有必需依赖（库）的 JAR 文件。这种打包方式产生的工件有时被称为 *fat JAR*，意味着它包含了所有可能由执行环境提供的依赖。他们选择这种方法是因为它简化了分发和执行他们应用程序的一些方面。
- en: To get started, you’ll need to add the `sbt-assembly` plugin to your project.
    Within your project, create a directory called *project* and a file named *assembly.sbt*
    in that directory. That file should contain the instructions to add the `sbt-assembly`
    plugin.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你需要将 `sbt-assembly` 插件添加到你的项目中。在你的项目内部，创建一个名为 *project* 的目录，并在该目录中创建一个名为
    *assembly.sbt* 的文件。该文件应包含添加 `sbt-assembly` 插件的指令。
- en: Listing 9.1\. Adding `sbt-assembly`
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 添加 `sbt-assembly`
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then you need to define a build, as in the next listing, which shows how your
    JJB team sets up a build.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要定义一个构建，如下一个列表所示，它展示了 JJB 团队如何设置构建。
- en: Listing 9.2\. An SBT build
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 一个 SBT 构建
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Defines dependencies**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义依赖**'
- en: '***2* Sets the main class, to be executed when the archive is run**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置主类，当存档运行时将被执行**'
- en: If you’ve done all that correctly, you can now build your project by issuing
    the command `sbt assembly`. The command will produce a JAR containing all your
    code and resources, along with all the dependencies your code requires. The assembly
    task will tell you where this JAR is with a message that says something like,
    “Packaging /your-app/target/scala-2.11/your-app-assembly-1.0.jar....” This single
    archive can now be passed around to any execution environment that can run JVM
    code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经正确完成了所有这些步骤，你现在可以通过发出命令 `sbt assembly` 来构建你的项目。这个命令将生成一个包含所有你的代码和资源，以及你的代码所需的全部依赖的
    JAR 文件。汇编任务会通过一条类似“打包 /your-app/target/scala-2.11/your-app-assembly-1.0.jar....”的消息告诉你这个
    JAR 文件的位置。现在这个单一的存档可以被传递到任何可以运行 JVM 代码的执行环境中。
- en: 9.3\. Build pipelines
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 构建管道
- en: This build-and-packaging step is just one of multiple possible steps executed
    by real-world build pipelines like the one at Jungle Juice Box. In their pipeline,
    they need to get their code, build it, test it, package it, and publish the resulting
    artifact. This pipeline must also be executed on a build server of some sort that
    already has the necessary software installed, such as Git and sbt. The pipeline
    also expects that certain environment variables are present in the execution environment.
    For more on the use of environment variables, see the discussion in [chapter 4](kindle_split_015.html#ch04).
    Finally, the pipeline assumes that it’s being executed on a Unix-like environment
    (for example, Ubuntu Linux). The next listing shows an approximation in shell
    script of how all of this comes together into a pipeline.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构建和打包步骤只是现实世界中构建管道（例如 Jungle Juice Box 中的管道）所执行的可能步骤之一。在他们自己的管道中，他们需要获取代码，构建它，测试它，打包它，并发布生成的工件。这个管道还必须在已经安装了必要软件（如
    Git 和 sbt）的某种构建服务器上执行。该管道还期望执行环境中存在某些环境变量。有关环境变量使用的更多信息，请参阅第 4 章的讨论。[chapter 4](kindle_split_015.html#ch04)。最后，该管道假定它正在
    Unix-like 环境中（例如，Ubuntu Linux）执行。下面的列表显示了如何将这些步骤组合成管道的 shell 脚本近似。
- en: Listing 9.3\. Build pipeline
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 构建管道
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Navigates to the root project directory using an environment variable**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用环境变量导航到根项目目录**'
- en: '***2* Pulls down the latest version of the code**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 拉取代码的最新版本**'
- en: '***3* Compiles the project**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 编译项目**'
- en: '***4* Tests the project**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 测试项目**'
- en: '***5* Packages the project into a fat JAR**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将项目打包成一个 fat JAR**'
- en: '***6* Publishes the JAR to a remote server using rsync under a version-numbered
    directory**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用 rsync 在带版本号的目录下将 JAR 发布到远程服务器**'
- en: Just to be clear, this is a simplified version of a build pipeline. Note that
    calling `sbt test` would itself invoke compilation, removing the need for the
    `sbt compile` step. Both steps are shown just for clarity about the steps in the
    process. The use of `rsync`, a Unix utility for copying data between locations
    such as remote servers, is a simple, if crude, approach. This publishing step
    uses the directory structure and a name to organize the different artifacts for
    different versions of the application, instead of a more sophisticated technique,
    like publishing to a Maven repository. If you know much about build pipelines,
    this one may seem crude, but even a simple build pipeline like this can be illustrative.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，这是一个简化的构建管道版本。请注意，调用`sbt test`本身就会触发编译，从而消除了`sbt compile`步骤的需要。这两个步骤只是为了清晰展示过程中的步骤。使用`rsync`，这是一个Unix工具，用于在远程服务器等位置之间复制数据，是一个简单但粗略的方法。这个发布步骤使用目录结构和名称来组织不同版本应用程序的不同工件，而不是使用更复杂的技术，如发布到Maven仓库。如果你对构建管道很了解，这个可能看起来很粗略，但即使是这样一个简单的构建管道也可以是说明性的。
- en: First, you have a step that’s reserved for evaluation of your application, the
    `test` step. This is a great location to put any tests that evaluate models, similar
    to the techniques you saw in [chapter 6](kindle_split_017.html#ch06). If any of
    those tests fail, the build pipeline will halt and not publish the application.
    Second, you’re merely publishing at the end of the pipeline. As you’ve done several
    times before, you make the new artifact available for use, but you don’t immediately
    change the state of the running application. Instead, you leave that decision
    for another system component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你有一个专门用于评估应用程序的步骤，即`test`步骤。这是一个放置任何评估模型的测试的绝佳位置，类似于你在[第6章](kindle_split_017.html#ch06)中看到的技巧。如果这些测试中的任何一个失败，构建管道将停止，不会发布应用程序。其次，你只是在管道的末端进行发布。就像你之前多次做的那样，你使新工件可用于使用，但不会立即改变运行应用程序的状态。相反，你将这个决定留给另一个系统组件。
- en: 9.4\. Evaluating models
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 评估模型
- en: Now that you’ve built a minimal version of a build pipeline, let’s consider
    how to make some decisions in the pipeline. In [chapter 6](kindle_split_017.html#ch06),
    you worked through how to evaluate models and determine whether they should be
    used. Now you can bring those skills into play in the larger mission of building
    and deploying components of a machine learning system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经构建了一个最小版本的构建管道，让我们考虑如何在管道中做出一些决策。在[第6章](kindle_split_017.html#ch06)中，你学习了如何评估模型并确定它们是否应该被使用。现在你可以将这些技能应用到构建和部署机器学习系统组件的更大任务中。
- en: The Jungle Juicers, like the members of most machine learning teams, don’t want
    to deploy broken functionality. In their case, the consequence would be bad—no
    predictions of which fruits their subscribers would want—so they’ve developed
    a range of safety mechanisms designed to keep their machine learning system stable.
    One of those is the model-evaluation step in their deploy process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数机器学习团队的成员一样，《丛林榨汁机》团队不想部署有缺陷的功能。在他们的情况下，后果会很严重——无法预测他们的订阅者想要哪种水果——因此他们开发了一系列旨在保持他们的机器学习系统稳定的机制。其中之一就是他们在部署过程中的模型评估步骤。
- en: In this step, models are verified as being better than some standard before
    being deployed. If the models pass the test, then the application can be used
    in production. If not, this version of the application shouldn’t be used, and
    production systems shouldn’t be updated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，模型在部署之前被验证为优于某些标准。如果模型通过测试，则应用程序可以在生产中使用。如果没有，则不应使用此版本的应用程序，生产系统也不应更新。
- en: In [chapter 6](kindle_split_017.html#ch06), I showed how to assess a model’s
    performance relative to a random model. That’s not the only approach you can use
    to determine whether a model is usable in your production system. [Table 9.1](#ch09table01)
    shows advantages and disadvantages of some of the alternatives.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_017.html#ch06)中，我展示了如何评估模型相对于随机模型的性能。这不是你确定模型是否可以在你的生产系统中使用的唯一方法。[表9.1](#ch09table01)显示了某些替代方案的优势和劣势。
- en: Table 9.1\. Model deployment criteria
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.1\. 模型部署标准
- en: '| Criterion | Advantages | Disadvantages |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 标准 | 优点 | 缺点 |'
- en: '| --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Better than random | Very unlikely to reject a useful model | A low bar for
    performance |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 优于随机 | 很不可能拒绝一个有用的模型 | 性能门槛低 |'
- en: '| Better than some fixed value | Can be designed to match business requirements
    | Requires an arbitrary parameter |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 优于某些固定值 | 可以设计来满足业务需求 | 需要一个任意的参数 |'
- en: '| Better than the previous model | Guarantees monotonically increasing performance
    | Requires accurate knowledge of the previous model’s performance post-deployment
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 优于之前的模型 | 保证单调递增的性能 | 需要准确了解之前模型部署后的性能 |'
- en: In the case of Jungle Juice Box, they plan to use a fixed value, 90% precision,
    to determine if a learned model should be deployed. The choice of 90% is arbitrary,
    but it matches well with their intuition about how models map to subscriber satisfaction
    with fruit recommendations. On the downside, manually performing this assessment
    and checking these values for every single learned model would be a laborious
    process, so let’s look at how this step can be integrated into a more automated
    process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jungle Juice Box 的案例中，他们计划使用一个固定值，90% 的精确度，来决定是否应该部署学习模型。90% 的选择是任意的，但它很好地符合他们对模型映射到水果推荐用户满意度直觉的认识。缺点是，手动执行这种评估并检查每个学习模型的这些值将是一个费力的过程，所以让我们看看这一步如何集成到一个更自动化的流程中。
- en: 9.5\. Deploying
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 部署
- en: At this point, you may feel confident about your models based on the guarantees
    that the validations in the build pipeline give you. You could potentially move
    forward with deployment. In this context, *deployment* means to publish the component
    of your machine learning system and start acting on real user requests, as we
    explored in [chapter 8](kindle_split_019.html#ch08). For your JJB team, the component
    system in this step looks something like [figure 9.3](#ch09fig03).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能对自己的模型有信心，因为构建管道中的验证为你提供了保证。你可能会继续进行部署。在这种情况下，“部署”意味着发布你的机器学习系统组件并开始对真实用户请求进行操作，正如我们在[第
    8 章](kindle_split_019.html#ch08)中探讨的那样。对于你的 JJB 团队来说，这一步骤的组件系统看起来就像[图 9.3](#ch09fig03)所示。
- en: Figure 9.3\. Model deployment
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3\. 模型部署
- en: '![](09fig03_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig03_alt.jpg)'
- en: After tests have passed, the application JAR is pushed to a remote artifact
    repository. Then the build pipeline calls the application-serving platform’s API
    to start the deployment of the application. The serving platform will need to
    provision the necessary resources, download the JAR to a sandbox, and then start
    the application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过后，应用程序 JAR 被推送到远程工件存储库。然后构建管道调用应用程序服务平台的 API 以开始应用程序的部署。服务平台将需要配置必要的资源，将
    JAR 下载到沙盒中，然后启动应用程序。
- en: How often should you deploy the system? What determines that you should do a
    deploy? This is actually a very complicated topic. Roughly speaking, there are
    four approaches to when you deploy and why, as shown in [table 9.2](#ch09table02).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该多久部署一次系统？什么决定了你应该进行部署？这实际上是一个非常复杂的话题。粗略地说，有四种方法来决定何时部署以及为什么部署，如[表 9.2](#ch09table02)所示。
- en: Table 9.2\. Approaches to deployments
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 9.2\. 部署方法
- en: '| Style | Criteria | Frequency | Advantages | Disadvantages |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 风格 | 标准 | 频率 | 优点 | 缺点 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Ad hoc | None | Variable, but often infrequent | Simple and flexible | Deploys
    can be difficult due to low deployment skills and/or automation |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 临时 | 无 | 可变，但通常不频繁 | 简单灵活 | 由于部署技能和/或自动化程度低，部署可能很困难 |'
- en: '| At milestones | Achieving some meaningful development milestone | Weeks to
    months | Clarifies planning around deploys | Unplanned deploys can be hard |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 在里程碑时 | 达到一些有意义的发展里程碑 | 周到月 | 清晰的部署规划 | 非计划部署可能很困难 |'
- en: '| Periodically | Reaching a determined amount of time | Days to weeks | Regularity
    builds skills and speed | Can be labor intensive |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 定期 | 达到确定的时间量 | 天到周 | 规律性建立技能和速度 | 可能很费工 |'
- en: '| Continuously | Committing to the master branch | Multiple times per day |
    Fast responses to change | Requires investment in predeploy enabling capabilities
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 持续 | 承诺到主分支 | 每天多次 | 快速响应变化 | 需要投资于预部署启用能力 |'
- en: As you can see, there are some complex trade-offs to consider when deciding
    how to structure your deployment process. The Jungle Juice Box team chooses a
    continuous deployment process, after using other processes earlier in the company’s
    history. In their experimentations with variations on the approaches in [table
    9.2](#ch09table02), they found that less-frequent deploys led them to underinvest
    in their build-and-deploy infrastructure. They didn’t deploy that often, and when
    they did, it was so painful that they wanted to work on anything else, once the
    deploy was done, instead of improving the deploy process. When they decided that
    they needed to ship updates to the fruit-recommendation system more quickly, they
    realized they needed to implement the capabilities that would allow them to continuously
    deploy their system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在决定如何构建您的部署流程时需要考虑一些复杂的权衡。Jungle Juice Box 团队在早期公司历史中使用了其他流程之后，选择了持续部署流程。在他们尝试[表
    9.2](#ch09table02)中方法的变化时，他们发现较少的部署导致他们在构建和部署基础设施上的投资不足。他们并不经常部署，而且每次部署都如此痛苦，以至于一旦部署完成，他们更愿意做任何其他事情，而不是改进部署流程。当他们决定需要更快地将更新发送到水果推荐系统时，他们意识到他们需要实施能够使他们能够持续部署系统的功能。
- en: At a base level, they need reliable tests that will tell them whether their
    application can be deployed. Those tests need to be used by an automated build
    pipeline capable of determining whether the application should be deployed and
    then proceeding with that deployment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，他们需要可靠的测试来告诉他们应用程序是否可以部署。这些测试需要由一个自动构建管道使用，该管道能够确定应用程序是否应该部署，然后继续进行部署。
- en: 'They wind up with a flow that looks like [figure 9.4](#ch09fig04), where a
    series of automated decisions are made to ensure that a given deployment is safe.
    Note that the predictive system’s capability is tested at two levels. First, unit
    tests verify properties of the system that can be assessed without using much
    data. Then, after a deployable version of the application has been built, that
    release candidate is evaluated on a larger set of data. In this step, metrics
    about the system’s performance are assessed to ensure that the system as a whole
    can do a sufficiently good job of its core mission: predicting subscribers’ fruit
    preferences. This particular technique is sometimes called a *metrics-based deploy*.
    Only when both levels of testing have been passed do you call the command to start
    the application.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 他们最终得到一个看起来像[图 9.4](#ch09fig04)的流程，其中一系列自动化决策被做出以确保特定的部署是安全的。请注意，预测系统的能力在两个层面上进行测试。首先，单元测试验证了无需使用大量数据即可评估的系统属性。然后，在构建了可部署的应用程序版本之后，该候选版本在更大的数据集上进行评估。在这一步中，评估系统的性能指标以确保整个系统能够足够好地完成其核心任务：预测订阅者的水果偏好。这种特定的技术有时被称为基于指标的部署。只有当两个测试级别都通过后，你才调用命令启动应用程序。
- en: '![](supervision.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![监督](supervision.jpg)'
- en: Figure 9.4\. Automatic deployment of the fruit-prediction system
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 水果预测系统的自动部署
- en: '![](09fig04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![09fig04](09fig04.jpg)'
- en: With this approach to ensuring application safety in place, the Jungle Juice
    Box team gets to work in a powerful way. All commits to the master branch of the
    application’s repository invoke a deploy, so they’re happening all the time, usually
    many times a day. That means the fruit-prediction system is always reflecting
    pretty much the latest and greatest out of the JJB data team. When something goes
    wrong, the team is able to respond quickly and get the system fixed in a relatively
    short amount of time. Usually, nothing goes wrong—the tests are doing all the
    work of ensuring that things are fine, so the team does *other stuff* instead
    of worrying about whether the deploy went well. Mostly, they don’t think about
    deploys at all and stay focused on the hard work of building better machine learning
    systems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保应用程序安全性的方法到位后，Jungle Juice Box 团队能够以强大的方式开始工作。应用程序仓库主分支的所有提交都会触发一次部署，因此这些部署是持续进行的，通常每天进行多次。这意味着水果预测系统始终反映了
    JJB 数据团队的最新和最佳成果。当出现问题时，团队能够快速响应并在相对较短的时间内修复系统。通常，不会出现任何问题——测试正在做所有确保事情顺利进行的工作，因此团队可以做一些其他事情，而不是担心部署是否顺利。大多数情况下，他们根本不思考部署，而是专注于构建更好的机器学习系统的艰苦工作。
- en: 9.6\. Reactivities
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6\. 反应性活动
- en: '![](dog-ball.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![狗球](dog-ball.jpg)'
- en: 'Here are a few reactivities to take you deeper into the jungle of building
    and deploying machine learning systems:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些反应性活动，可以帮助您深入了解构建和部署机器学习系统的丛林：
- en: '*Try building your application with a different build tool*. Quite a few build
    tools target the JVM, like Ant, Maven, and Gradle. How does another build tool
    approach the task of building a deployable JAR?'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尝试使用不同的构建工具构建你的应用程序*。 很多的构建工具针对JVM，如Ant、Maven和Gradle。另一个构建工具是如何处理构建可部署JAR的任务的？'
- en: '*Add validations*. Using either the sbt build in this chapter or your alternative
    build from the previous reactivity, add additional validations to your build.
    These validations could be any arbitrary “business logic” you want. For example:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加验证*。 使用本章中的sbt构建或你之前反应性的替代构建，向你的构建中添加额外的验证。这些验证可以是任何你想要的任意“业务逻辑”。例如：'
- en: Only build and deploy on weekdays.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在工作日构建和部署。
- en: Test-set performance must be higher than an arbitrary threshold.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试集的性能必须高于任意阈值。
- en: No new dependencies have been added.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有添加新的依赖项。
- en: '*Write a deployment script and execute it regularly*. In this reactivity, you’re
    not necessarily focused on the application’s functionality, so your deploy can
    be something simple, like sending yourself an email that says that the deploy
    happened or using your computer’s built-in voice to announce, “Deploy complete!”
    Once you implement your deployment script, ask yourself questions about its behavior:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写部署脚本并定期执行它*。 在这种反应性中，你并不一定专注于应用程序的功能，因此你的部署可以是简单的东西，比如发送一封邮件给自己说明部署已发生，或者使用你电脑内置的语音宣布，“部署完成！”一旦你实现了你的部署脚本，问问自己关于其行为的问题：'
- en: What will happen if the deployment fails?
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果部署失败会发生什么？
- en: How could I “roll back” a deployment?
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何“回滚”一个部署？
- en: How long will deployments take? What functionality guarantees the responsiveness
    expectation?
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署需要多长时间？哪些功能保证了响应性期望？
- en: What would happen if many different processes were running this deployment at
    the same time?
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果许多不同的进程同时运行这个部署会发生什么？
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Scala applications can be packaged into archives called JARs using sbt.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala应用程序可以使用sbt打包成称为JAR的存档。
- en: Build pipelines can be used to execute evaluations of machine learning functionality,
    like models.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用构建管道来执行机器学习功能，如模型的评估。
- en: The decision to deploy a model can be made based on comparisons with meaningful
    values, like the performance of a random model, previous models’ performance,
    or some known parameter.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署模型的决策可以根据与有意义值的比较来做出，如随机模型的性能、先前模型的性能或某些已知参数。
- en: Deploying applications continuously can allow a team to deliver new functionality
    quickly.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署应用程序可以使团队快速交付新功能。
- en: Using metrics to determine whether new applications are deployable can make
    a deployment system fully autonomous.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指标来确定新应用程序是否可部署可以使部署系统完全自动化。
- en: Many of the techniques discussed in this chapter are defensive in nature—they
    protect you from the possibility of deploying a broken application. In the next
    chapter, we’ll consider what happens when failure of your live system *does* happen.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的许多技术本质上是防御性的——它们保护你免受部署损坏应用程序的可能性。在下一章中，我们将考虑当你的实时系统**确实**发生故障时会发生什么。
- en: Chapter 10\. Evolving intelligence
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 演化智能
- en: '*This chapter covers*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding artificial intelligence
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解人工智能
- en: Working with agents
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与代理一起工作
- en: Evolving the complexity of agents
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理复杂性的演化
- en: 'We’ve covered a lot of territory in our exploration of machine learning, but
    before we wrap up, we’re going to expand our perspective just a bit more to consider
    the exciting world of artificial intelligence. To do that, we’ll have to shrink
    down and explore one of the most complex societies in all of tech: bees who use
    instant messaging.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在探索机器学习的旅程中已经覆盖了大量的领域，但在我们结束之前，我们将进一步拓宽我们的视野，考虑令人兴奋的人工智能世界。为了做到这一点，我们需要缩小范围，探索所有技术中最复杂的社会之一：使用即时通讯的蜜蜂。
- en: 10.1\. Chatting
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 聊天
- en: The bees at Buzz Me have built one of the hottest apps in the insect world.
    They have literally trillions of users, all of whom spend a large portion of their
    working day coordinating with their hive mates via instant messaging. Although
    instant messaging has been around for millennia (in bee years), Buzz Me has recently
    taken over the market with a slick design that makes chatting about work as fun
    as setting up a night out with friends ([figure 10.1](#ch10fig01)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Buzz Me的蜜蜂们已经为昆虫世界打造了最受欢迎的应用之一。他们实际上拥有数万亿用户，所有这些用户都在他们工作日的大部分时间里通过即时通讯与蜂群伙伴协调。尽管即时通讯在蜜蜂年代已经存在了数千年，但Buzz
    Me最近凭借其流畅的设计，使得工作聊天变得像与朋友安排一个夜晚一样有趣（[图10.1](#ch10fig01)）。
- en: Figure 10.1\. Buzz Me
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1. Buzz Me
- en: '![](10fig01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig01.jpg)'
- en: As part of their expansion plans, the team at Buzz Me is developing a platform
    for bots (or agents). These bots will interact with their users in real time,
    taking on all sorts of simple, tedious, repetitive tasks ([figure 10.2](#ch10fig02)).
    Their plan for how to build these bots involves a sophisticated system that goes
    a bit beyond machine learning into the wider territory of artificial intelligence.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其扩展计划的一部分，Buzz Me团队正在开发一个机器人（或代理）平台。这些机器人将实时与用户互动，承担各种简单、繁琐、重复的任务（[图10.2](#ch10fig02)）。他们构建这些机器人的计划涉及一个复杂的系统，这个系统在机器学习之外还涉及更广泛的领域——人工智能。
- en: Figure 10.2\. Buzz Me bot platform
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2. Buzz Me机器人平台
- en: '![](10fig02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig02.jpg)'
- en: 10.2\. Artificial intelligence
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 人工智能
- en: '*Artificial intelligence* (AI) is the overarching field of which machine learning
    is a part. In this book, we’ve already covered topics outside the range of what
    is usually thought of as machine learning. Typically, machine learning is concerned
    only with the process of a model learning from data and demonstrating that it’s
    capable of performing better after the learning process, as discussed in [chapters
    4](kindle_split_015.html#ch04) through [6](kindle_split_017.html#ch06) of this
    book. Areas like data collection and responding to user input aren’t well represented
    in traditional machine learning literature, but they are found in the broader
    discussions of AI. You could view *reactive AI* as the topic of this book.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*人工智能*（AI）是机器学习所属的更广泛领域。在这本书中，我们已经涵盖了通常被认为是机器学习范围之外的话题。通常，机器学习只关注模型从数据中学习的过程，并在学习过程之后展示其能够表现更好的能力，正如本书第4章（[kindle_split_015.html#ch04]）到第6章（[kindle_split_017.html#ch06]）所讨论的那样。数据收集和响应用户输入等领域在传统的机器学习文献中并不突出，但在更广泛的AI讨论中有所体现。你可以将*反应式人工智能*视为本书的主题。'
- en: The main reason I’ll start to discuss things in AI terms is to talk about an
    AI concept called an *agent*. At its simplest, an agent is a software application
    that can act on its own. This chapter doesn’t talk about the simplest forms of
    agents. Instead, it talks about AI agents that can sense data in their environment,
    make decisions about that data, and act on those decisions, within the environment—all
    while holding to the principles of reactive design.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我将开始用AI术语讨论事情的主要原因是为了讨论一个称为*代理*的AI概念。在最简单的情况下，代理是一个可以独立行动的软件应用程序。本章不讨论最简单的代理形式。相反，它讨论的是能够感知其环境中数据、对数据进行决策并在环境中根据这些决策采取行动的AI代理——所有这些都在坚持反应式设计原则的同时进行。
- en: Being capable of autonomous response to user input is the minimum requirement
    of the initial implementation of the bots on the Buzz Me platform. But as you
    join the bee team in this chapter, you’ll see that the team and bot developers
    in general benefit from shooting for higher levels of functionality. Ideally,
    our agents will be capable of all sorts of useful things, like answering common
    questions, setting up meetings, and ordering office supplies. We may not be able
    to build bots as smart as bee bots, but we should easily be able to develop bots
    that are useful.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 能够自主响应用户输入是Buzz Me平台上机器人初始实施的最基本要求。但随着你加入本章的蜜蜂团队，你会发现团队和机器人开发者普遍受益于追求更高功能水平。理想情况下，我们的代理将能够执行各种有用的事情，比如回答常见问题、安排会议和订购办公用品。我们可能无法构建像蜜蜂机器人一样聪明的机器人，但我们应该能够轻松开发出有用的机器人。
- en: 10.3\. Reflex agents
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3. 反应式代理
- en: To get your agent to do anything, you’ll have to figure out how it decides what
    to do. The simplest way an agent can make decisions is through deterministic rules.
    An agent that operates in this manner can be called a *reflex agent*. Strictly
    speaking, lots of applications fulfill the nominal requirements for being a reflex
    agent, but here I’m only talking about those applications designed to operate
    as agents.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要让你的代理做任何事情，你必须弄清楚它是如何决定做什么的。代理可以做出决定的 simplest way 是通过确定性规则。以这种方式运行的代理可以被称为
    *反射代理*。严格来说，很多应用都满足成为反射代理的名义要求，但在这里我只是在谈论那些设计为作为代理运行的应用。
- en: You’ll begin building your agent as a simple reflex agent. This agent will eventually
    be a sort of insect buddy, with various likes and dislikes that users get to know
    through regular interactions. Eventually, your team wants the agent to be able
    to take on useful work, but they’re beginning with small talk to help the user
    get accustomed to the idea of chatting with an agent. By introducing agents with
    some sort of “personality,” the team believes users will become acclimated to
    agents as toys first and then later use them as tools.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开始构建你的代理作为一个简单的反射代理。这个代理最终将成为一种昆虫伙伴，拥有各种喜好和厌恶，用户可以通过常规互动来了解。最终，你的团队希望代理能够承担有用的任务，但他们从简单的闲聊开始，帮助用户习惯与代理聊天的想法。通过引入具有某种“个性”的代理，团队相信用户会首先将代理视为玩具，然后后来将它们用作工具。
- en: To begin your implementation, the following listing gives the agent the capability
    to answer questions about its likes and dislikes as evidence of its “personality.”
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始你的实现，下面的列表提供了代理的能力，以回答有关其喜好和厌恶的问题，作为其“个性”的证据。
- en: Listing 10.1\. A reflex agent
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1\. 反射代理
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Defines an agent as a singleton object for expedience**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为了方便定义代理为一个单例对象**'
- en: '***2* Expresses things to like as strings, and likes as Booleans**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将喜欢的事物表示为字符串，并将喜好表示为布尔值**'
- en: '***3* Defines an agent to like only honey**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义一个只喜欢蜂蜜的代理**'
- en: This reflex agent can now receive questions in the form of strings and respond
    with whether it likes them or not. In this case, the agent has extremely simple
    tastes and likes only honey. Even in this simple implementation, you can employ
    functional programming principles. Specifically, the input string is immutable
    data that’s never changed, and the `doYouLike` function is a pure function, having
    no side effects. The next listing shows how this agent can be asked what it does
    and doesn’t like.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反射代理现在可以接收以字符串形式提出的问题，并回答它是否喜欢它们。在这种情况下，代理的口味极其简单，只喜欢蜂蜜。即使在简单的实现中，你也可以使用函数式编程原则。具体来说，输入字符串是不可变数据，永远不会改变，而`doYouLike`函数是一个纯函数，没有副作用。下面的列表显示了如何询问这个代理它喜欢什么和不喜欢什么。
- en: Listing 10.2\. Talking to a reflex agent
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 与反射代理交谈
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Imports the agent for use in this console session**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入代理以在本控制台会话中使用**'
- en: '***2* Asks whether the agent likes honey**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 询问代理是否喜欢蜂蜜**'
- en: '***3* true indicates the agent likes honey.**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* true 表示代理喜欢蜂蜜。**'
- en: '***4* Asks whether the agent likes flowers**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 询问代理是否喜欢花朵**'
- en: '***5* false indicates the agent doesn’t like flowers.**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* false 表示代理不喜欢花朵。**'
- en: Your reflex agent certainly seems to work, although it’s clearly very limited.
    But even simplistic reflex agents can be useful. For example, some agents developed
    for the Buzz Me bot platform are using text as a way of invoking commands. They
    don’t need to contain any intelligence; they just need to send the user data back
    to some backend service and respond.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的反射代理显然是有效的，尽管它显然非常有限。但即使是简单的反射代理也可能是有用的。例如，为Buzz Me机器人平台开发的某些代理正在使用文本作为调用命令的方式。它们不需要包含任何智能；它们只需要将用户数据发送回某些后端服务并做出响应。
- en: People have built agents that handle simple tasks like setting reminders and
    displaying random GIFs. Whether or not the developer thinks of their software
    as an agent, we can take that perspective even for such simple applications. But
    we’re not interested in such simple agents. There’s more interesting stuff we
    could do with more-intelligent agents.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 人们已经构建了处理简单任务如设置提醒和显示随机GIF的代理。无论开发者是否将他们的软件视为代理，我们甚至可以对此类简单应用采取这种观点。但我们不感兴趣的是这样的简单代理。我们可以用更智能的代理做更多有趣的事情。
- en: 10.4\. Intelligent agents
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. 智能代理
- en: The next level of complexity we’ll consider is an agent that doesn’t just do
    things, but actually *knows* things as well. If an agent is designed in such a
    way that it has a store of knowledge, then it can be called an *intelligent agent*.
    Thinking in terms of software, if a reflex agent is essentially a function, then
    an intelligent agent must be a function over some data other than the input arguments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要考虑的更复杂的一层是一个不仅做事，而且实际上**知道**事情的代理。如果一个代理被设计成具有知识库，那么它可以被称为**智能代理**。从软件的角度来看，如果一个反射代理本质上是一个函数，那么智能代理必须是一个函数，它作用于除了输入参数之外的其他数据。
- en: Throughout this book, we’ve been looking at machine learning systems that contain
    databases of facts. The knowledge component of an intelligent agent is more of
    the same. Ideally, the knowledge in an intelligent agent is implemented as an
    immutable log of facts. It would also be helpful if the facts in that database
    were expressed in an uncertainty-aware manner that acknowledged that various possible
    scenarios could be true at a given time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在研究包含事实数据库的机器学习系统。智能代理的知识组件更多的是同样的东西。理想情况下，智能代理中的知识被实现为一个不可变的事实日志。如果那个数据库中的事实是以一种不确定性感知的方式表达的，承认在给定时间可能存在各种可能的场景，那将是有帮助的。
- en: But none of that is strictly required to fulfill your definition. For that matter,
    this database of knowledge doesn’t even have to be a database. It can be a simple
    in-memory data structure, which is what you’ll start with in the following listing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些都并非严格满足你定义的必要条件。至于这个知识库，甚至不必是一个数据库。它可以是简单的内存数据结构，你将在接下来的列表中开始使用它。
- en: Listing 10.3\. An intelligent agent
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 一个智能代理
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Constructs an intelligent agent with a set of likes**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 使用一组喜好构建一个智能代理**'
- en: '***2* Still takes in things to like as a string and returns a Boolean result**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 仍然以字符串的形式接收喜欢的事物，并返回一个布尔结果**'
- en: '***3* Defines likability as a presence within a set of known things**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 将喜好定义为已知事物集合中的一个存在'
- en: This agent is only a bit more complex to implement than the previous one, but
    it meaningfully expands the possible range of functionality of the agent. Instead
    of having its likes fixed in the implementation of the agent itself, the agent’s
    likes are now factored out to data that can be passed in at construction. This
    means you can instantiate an arbitrary number of such agents, with whatever likes
    you choose, rather than being constrained to a singleton, as you were with the
    reflex agent.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理相对于前一个代理来说实现起来稍微复杂一些，但它有意义地扩展了代理可能的功能范围。不再是将喜好固定在代理本身的实现中，现在代理的喜好被分解为可以在构建时传递的数据。这意味着你可以实例化任意数量的此类代理，选择你想要的任何喜好，而不是像使用反射代理那样被限制为单例。
- en: The next listing shows how to instantiate and interact with this intelligent
    agent.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何实例化和与这个智能代理交互。
- en: Listing 10.4\. Talking to an intelligent agent
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 与智能代理交谈
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Imports an intelligent agent for use within a console session**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 在控制台会话中导入智能代理以供使用**'
- en: '***2* Defines a small set of things a particular bee might like**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 定义一组特定蜜蜂可能喜欢的事物**'
- en: '***3* Instantiates a new intelligent agent with those likes**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 使用那些喜好实例化一个新的智能代理**'
- en: '***4* The intelligent agent still likes honey.**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** 智能代理仍然喜欢蜂蜜。**'
- en: '***5* It also likes flowers.**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5** 它也喜欢花朵。**'
- en: '***6* It doesn’t know about birds, so it doesn’t like them.**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**6** 它不知道关于鸟类的信息，所以它不喜欢它们。**'
- en: This is just one possible configuration of the agent that you’ve created. You
    can continue to create more agents, each with likes appropriate for the given
    agent. At this level of complexity, you’ve already implemented as much intelligence
    in your agent as exists in many real-world products called *chatbots*. The agent
    has a fixed amount of knowledge that won’t change, but in principle, you can fill
    it up with as much data as you have. Many chatbots don’t have more capability
    than this simple intelligent agent. They may have much more knowledge in their
    implementation, in the form of canned responses to provide, but those responses
    don’t change over time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是你创建的代理的一个可能配置。你可以继续创建更多代理，每个代理都有适合该代理的喜好。在这个复杂度级别，你已经在你的代理中实现了与许多现实世界产品中称为**聊天机器人**的智能一样多的智能。代理有固定数量的知识，不会改变，但原则上你可以用你拥有的所有数据来填充它。许多聊天机器人的能力并不比这个简单的智能代理更强大。它们在实现中可能有更多的知识，以提供预定义的响应的形式，但这些响应不会随时间改变。
- en: Developers on the Buzz Me platform have discussed using such capabilities for
    cases like simple customer service, where the intelligent agent retrieves the
    best answer from a set of FAQs. For such simple applications, machine learning
    isn’t always required—user questions could be matched to answers from the FAQs
    using string-matching techniques alone. It’s also possible to build entertaining
    chatbots for things like games and toys using this technique. In either case,
    the implementers of the agent ultimately make all the decisions about exactly
    what the agent will do in response in all cases. Intelligent agents are definitely
    more useful than reflex agents, but you can build even more powerful agents if
    you want.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Buzz Me 平台上的开发者们讨论了使用这种能力来处理简单客户服务等情况，其中智能代理从一组常见问题解答（FAQs）中检索最佳答案。对于这样的简单应用，机器学习并不总是必需的——用户问题可以使用字符串匹配技术直接与
    FAQs 中的答案匹配。使用这种技术还可以构建娱乐聊天机器人，用于游戏和玩具等。在任何情况下，代理的实现者最终都会做出所有关于代理将如何响应的决定。智能代理肯定比反射代理更有用，但如果你想构建更强大的代理，你可以做到。
- en: 10.5\. Learning agents
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5\. 学习代理
- en: Once you’ve built an intelligent agent, it’s worth asking what its limitations
    are. Looking critically at your agent, it should be clear that it will always
    remain somewhat bound by the core agent function that you’ve implemented. Sure,
    it can continue to ingest new facts, but it will never really alter its behavior
    that much in response to new input. To see new capabilities emerge, you’re going
    to have to put your machine learning skills to use and teach this agent how to
    learn.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了一个智能代理，值得思考的是它的局限性。批判性地审视你的代理，你应该清楚它将始终在一定程度上受你所实现的代理核心功能的限制。当然，它可以继续吸收新的事实，但它永远不会真正因为新的输入而大幅改变其行为。要看到新能力出现，你必须运用你的机器学习技能，并教会这个代理如何学习。
- en: Similar to the definition of machine learning itself, the definition of a *learning
    agent* is an agent that can improve its performance given exposure to more data.
    That sounds similar to what a intelligent agent is supposed to be, but there’s
    an important difference. An intelligent agent that lacks learning capabilities
    is unable to alter the mapping of inputs (features) to outputs (concept labels).
    What we aspire to build in a learning agent is an agent that can get better merely
    through acquiring more data, just as we humans do.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与机器学习的定义本身相似，*学习代理*的定义是一个在接触更多数据的情况下能够提高其性能的代理。这听起来与一个智能代理应有的样子相似，但有一个重要的区别。一个缺乏学习能力的智能代理无法改变输入（特征）到输出（概念标签）的映射。我们希望在学习代理中构建的是一个仅通过获取更多数据就能变得更好的代理，就像我们人类一样。
- en: To begin building your learning agent, let’s go beyond raw strings and create
    some meaningful types. Your agents have been replying whether or not they like
    various things, so, in the following listing, let’s call those replies *sentiments*
    and create case objects sharing a common sentiment type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建你的学习代理，让我们超越原始字符串，创建一些有意义的类型。你的代理已经回答了它们是否喜欢各种事物，所以，在下面的列表中，让我们将这些回复称为*情感*，并创建共享一个共同情感类型的案例对象。
- en: Listing 10.5\. Sentiment types
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 情感类型
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Companion object to hold some learning-agent functionality**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 个伴随对象来持有一些学习代理的功能**'
- en: '***2* Defines a sealed trait as the basis for a sentiment type**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义一个密封特质作为情感类型的基础**'
- en: '***3* Objects of this type have a Boolean representation.**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 个此类对象具有布尔表示。**'
- en: '***4* Like sentiment represented as a true in Boolean**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如情感以布尔中的真值表示**'
- en: '***5* Dislike sentiment represented as a false in Boolean**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 不喜欢情感以布尔中的假值表示**'
- en: If you’re familiar with C++, Java, or C#, this implementation may remind you
    of the concept of *enumerations*. This `sealed` trait with its two implementations
    serves a similar function. Only the two implementations in this source file will
    be able implement the sentiment trait, making them the entirety of all members
    of the set of sentiment types. The `sealed` functionality will ensure that, even
    if you want to add future implementations, you’ll be required to do it in this
    same source file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 C++、Java 或 C#，这个实现可能会让你想起*枚举*的概念。这个具有两个实现的`sealed`特质发挥着类似的作用。只有这个源文件中的两个实现将能够实现情感特质，使它们成为情感类型集合中所有成员的全部。`sealed`功能将确保，即使你想添加未来的实现，你也必须在这个相同的源文件中完成。
- en: With these types, you can now begin to build out a learning agent.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类型，你现在可以开始构建学习代理了。
- en: Listing 10.6\. A simplistic learning agent
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 一个简单的学习代理
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Defines a learning-agent class**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义学习代理类**'
- en: '***2* Imports types from a companion object**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从伴随对象导入类型**'
- en: '***3* Creates a modifiable collection of observations about things and their
    likability**'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建关于事物及其喜好的可修改的观察集合**'
- en: '***4* Observes a thing and whether to like it**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 观察一个事物及其是否喜欢**'
- en: '***5* Records that observation in a data structure of knowledge**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将观察记录在知识的数据结构中**'
- en: '***6* Takes things to like as a string and returns a Boolean**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将要喜欢的事物作为字符串传入并返回布尔值**'
- en: '***7* Checks for the presence of a thing in known likes and returns false if
    it’s not known**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 检查已知喜好中是否存在某个事物，如果不存在则返回 false**'
- en: 'This simple learning-agent implementation now has new capabilities that the
    previous agents didn’t have: a changeable set of knowledge and an interface to
    take in new knowledge (the `observe` function). As modeled here, learning is the
    process of recording expressed sentiments that have been passed into the agent.
    Unlike the previous agents, this learning agent starts out with no likes or dislikes,
    but it can accumulate sentiments through the process of ingesting observations.
    The next listing shows an example interaction with the learning agent.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的学习代理实现现在具有之前代理所不具备的新功能：可更改的知识集和接受新知识的接口（`observe` 函数）。正如这里所模拟的，学习是记录传递给代理的表达情感的过程。与之前的代理不同，这个学习代理一开始没有任何喜好或厌恶，但它可以通过摄入观察的过程积累情感。下一个列表展示了与学习代理的示例交互。
- en: Listing 10.7\. Talking to a simplistic learning agent
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.7\. 与简单学习代理对话
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Imports an agent**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入代理**'
- en: '***2* Imports a functionality in a companion object**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从伴随对象导入功能**'
- en: '***3* Instantiates a new learning agent**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实例化一个新的学习代理**'
- en: '***4* Observes some common likes**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 观察一些常见的喜好**'
- en: '***5* The agent doesn’t know about birds, so it doesn’t like them.**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 代理不知道鸟类，所以不喜欢它们。**'
- en: '***6* Observes that the agent should, in fact, like birds**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 观察到代理实际上应该喜欢鸟类**'
- en: '***7* Now the agent likes birds.**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 现在代理喜欢鸟类。**'
- en: As this session shows, the agent is capable of changing its sentiments over
    time, based on the data that it’s seen. The agent knows exactly what the user
    has instructed it—things the user likes or dislikes—and presumes that any new
    piece of data will be disliked.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如此会话所示，代理能够根据其看到的数据随时间改变其情感。代理确切地知道用户告诉了它什么——用户喜欢或不喜欢的事物——并假设任何新的数据将被不喜欢。
- en: 'An agent like this can be used for cases like accumulating user preferences
    or surveys. Changing its behavior is simple: expose it to more data. This agent
    doesn’t *infer* much about the data that it’s observed, though. The learning algorithms
    you’ve seen in this book attempt to generalize from a given set of data what the
    mapping is from features to concept labels/values. The simplistic learning agent
    in [listing 10.7](#ch10ex07) doesn’t do that, so let’s whip up something that
    does. Given that we spent all of [chapter 5](kindle_split_016.html#ch05) working
    through how to implement real learning algorithms, I’m going to show you an utterly
    silly one for a change of pace. In this case, you’re going to build a classifier
    with an underlying algorithm based on inferences made according to the vowels
    within a word in a given observation. This isn’t useful in the real world, but
    it should help make the actions of the machine learning model through the training
    process more explicitly comprehensible than is possible in a more complex model.
    You can see an example of how this works in [listing 10.9](#ch10ex09), but you
    need to start by implementing the agent in the next listing.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的代理可以用于诸如积累用户偏好或调查等场景。改变其行为很简单：向其展示更多数据。然而，这个代理对其观察到的数据并没有进行太多的*推断*。本书中你看到的这些学习算法试图从给定数据集中泛化出从特征到概念标签/值的映射。列表
    10.7 中的简单学习代理并没有这样做，所以让我们快速构建一个能够做到这一点的代理。鉴于我们在第 5 章中花了大量时间讲解如何实现真正的学习算法，我将展示一个完全荒谬的例子，以改变节奏。在这种情况下，你将构建一个基于给定观察中单词元音所做推断的底层算法的分类器。这在现实世界中并不实用，但它应该有助于使机器学习模型在训练过程中的行为比在更复杂的模型中更明确易懂。你可以在列表
    10.9 中看到这个工作原理的例子，但你需要从下一个列表开始实现代理。
- en: Listing 10.8\. A more complex learning agent
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 一个更复杂的学习代理
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Adds new functionality to an existing agent class**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 向现有代理类添加新功能**'
- en: '***2* Dislikes are stored as vowel characters to dislike.**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 厌恶以元音字符的形式存储。**'
- en: '***3* Function to invoke the learning process**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用学习过程的功能**'
- en: '***4* Set of vowels to reference**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 参考元音的集合**'
- en: '***5* Iterates through all entries in the knowledge base**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 遍历知识库中的所有条目**'
- en: '***6* Pattern matches on things and known sentiments about them**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在事物及其已知情感上匹配模式**'
- en: '***7* Finds vowels in a given thing to like**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在给定的事物中找到喜欢的元音**'
- en: '***8* Determines whether the thing is disliked**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 确定事物是否被厌恶**'
- en: '***9* If the item is disliked, add its vowels to a set of disliked vowels.**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 如果不喜欢某个项目，将其元音添加到不喜欢元音的集合中。**'
- en: '***10* New function to access an alternative form of likability**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 新功能以访问另一种形式的喜爱**'
- en: '***11* Likes only things with no disliked vowels**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 只喜欢没有厌恶元音的事物**'
- en: Again, the knowledge in the agent is dynamic and can be changed via observation.
    But the API of this agent is a bit closer to some of the machine learning libraries
    you used in previous chapters. Specifically, it treats the learning of a model
    from observed data as a distinct step that must be invoked (via the `learn` method).
    The next listing shows how you interact with this agent.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，代理中的知识是动态的，可以通过观察进行更改。但这个代理的API与你在前几章中使用的一些机器学习库的API更接近。具体来说，它将观察数据中模型的学习视为一个独立的步骤，必须通过`learn`方法调用。下面的列表显示了如何与这个代理交互。
- en: Listing 10.9\. Talking to a more complex learning agent
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.9\. 与更复杂的学习代理交谈
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Creates a new agent**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的代理**'
- en: '***2* Sets up some observed dislikes**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 建立一些观察到的厌恶**'
- en: '***3* The agent generalizes from past observations that it would like dogs.**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 代理从过去的观察中归纳出它喜欢狗。**'
- en: '***4* The agent generalizes from past observations that it wouldn’t like cats.**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 代理从过去的观察中归纳出它不喜欢猫。**'
- en: This agent, even though it’s never heard anything about dogs or cats, presumes
    it will like dogs and dislike cats. At this point, you have something that’s truly
    using machine learning (even if the learning algorithm is silly). This is about
    where the traditional machine learning literature stops discussing the work of
    agent design. But in the real world, your agent might encounter more problems.
    Let’s see how you might use reactive techniques to enhance the design of your
    agent.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理，尽管它从未听说过狗或猫，假设它会喜欢狗，不喜欢猫。在这个阶段，你拥有真正使用机器学习的东西（即使学习算法很愚蠢）。这就是传统机器学习文献停止讨论代理设计工作的地方。但在现实世界中，你的代理可能会遇到更多问题。让我们看看你如何可能使用反应技术来增强你的代理设计。
- en: 10.6\. Reactive learning agents
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6\. 反应式学习代理
- en: As you’ve done many times in this book, you’re now going to take a basic design
    of a machine learning system and attempt to improve it through the application
    of design principles from reactive systems. Proceeding from those principles,
    let’s ask questions about your current design.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在本书中多次做的那样，你现在将采取一个机器学习系统的基本设计，并尝试通过应用反应系统设计原则来改进它。从这些原则出发，让我们对你的当前设计提出问题。
- en: 10.6.1\. Reactive principles
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.1\. 反应原则
- en: Is the agent responsive? Does it return sentiments to users within consistent
    time bounds? I don’t see any functionality that guarantees much of anything in
    that respect, so let’s answer that with a no.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 代理有反应性吗？它是否在一致的时间范围内向用户返回情感？我没有看到任何保证这方面的功能，所以让我们用否来回答。
- en: Is the agent resilient? Will it continue to return responses to users, even
    in the face of faults in the system? Again, I see no functionality to support
    this property, so let’s call that a no, as well.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 代理有弹性吗？即使在系统出现故障的情况下，它也会继续向用户返回响应吗？再次，我没有看到支持这个特性的功能，所以让我们称之为否。
- en: How about elasticity? Will the agent remain responsive in the face of changes
    in load? It’s not entirely clear that it will. So, again, we’ve got a no.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 关于弹性如何？代理在面对负载变化的情况下是否会保持响应？这并不完全清楚，所以，再次，我们得到一个否。
- en: Finally, does the agent rely on message passing to communicate? This doesn’t
    really seem to be the case either, so, no.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代理是否依赖于消息传递来通信？这也不太像是真的，所以，没有。
- en: It looks like the agent pretty much fails our assessment. The agent isn’t necessarily
    a *bad* design, but it doesn’t attempt to provide the sorts of guarantees that
    we’ve been focused on in this book, so let’s work on that.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来代理基本上没有通过我们的评估。代理不一定是一个*坏*的设计，但它没有尝试提供我们在本书中一直关注的保证，所以让我们着手解决这个问题。
- en: 10.6.2\. Reactive strategies
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.2\. 反应策略
- en: Drawing from your toolbox of reactive strategies, let’s try to use what you
    know to identify opportunities to improve the agent’s design.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的反应策略工具箱中汲取灵感，让我们尝试利用你所知道的知识来识别改进代理设计的机遇。
- en: Looking at replication, are there ways to use multiple copies of the data to
    improve the reactivity of the agent? The store of knowledge is the primary bit
    of data, so that could be offloaded to an external distributed database. You could
    also replicate the agent itself, having more than one copy of your entire learning
    agent.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 看到复制，有没有办法使用数据的多个副本来提高代理的反应性？知识库是主要的数据部分，所以这可能可以卸载到外部分布式数据库。你也可以复制代理本身，拥有你整个学习代理的多个副本。
- en: How about containment? Are there ways of containing any possible errors the
    agent might make? It seems likely that the agent could get some form of bad data,
    so if you introduced message passing, you could probably get greater containment
    of errors within the agent.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 关于封装，有没有办法包含代理可能犯的任何错误？看起来代理可能会得到一些形式的不良数据，所以如果你引入了消息传递，你可能会在代理内部获得更大的错误封装。
- en: Lastly, how could supervision help out? Typically, supervision is most useful
    in terms of error handling or managing load. If the agent were replicable, it
    could be supervised, and then new agents could be spawned in the event of the
    failure of any given agent. Similarly, a supervisor could spawn new agents if
    the existing agents were insufficient for the load being experienced at the time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，监督如何能有所帮助呢？通常，监督在错误处理或管理负载方面最有用。如果代理是可复制的，它就可以被监督，并且当任何给定代理失败时，可以生成新的代理。同样，如果现有的代理不足以应对当时的负载，管理者也可以生成新的代理。
- en: 10.6.3\. Reactive machine learning
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.3\. 反应式机器学习
- en: You haven’t learned only general reactive principles and strategies in this
    book. Looking at the world through the lens of reactive machine learning, you’ve
    learned to appreciate the properties of data in a machine learning system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书中不仅学习了通用的反应性原则和策略。通过反应式机器学习的视角看世界，你已经学会了欣赏机器学习系统中数据的属性。
- en: Data in a machine learning system is effectively infinite in size and definitionally
    uncertain.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习系统中的数据在大小和定义上都是无限和不确定的。
- en: If you wanted to use laziness in your design, you could probably improve the
    responsiveness and elasticity of your system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在设计中使用惰性，你可能会提高系统的响应性和弹性。
- en: You’re already using pure functions where appropriate, but you might look for
    more places to use them. The great thing about pure functions is that they work
    well with replication to handle arbitrary amounts of data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在适当的地方使用了纯函数，但你可能需要寻找更多可以使用它们的地方。纯函数的伟大之处在于它们与复制很好地配合，可以处理任意数量的数据。
- en: Immutable facts are always a great approach for a store of machine-learned knowledge,
    and you’re largely already using that approach. Observations made by the agent
    are never discarded or changed in any way.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 不变的事实始终是存储机器学习知识的一个很好的方法，而你已经在很大程度上使用了这种方法。代理做出的观察永远不会被丢弃或以任何方式改变。
- en: And if you wanted to, you could add more sophistication to your design by considering
    the various possible worlds that might be true of the concepts that your machine
    learning system is attempting to model.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以通过考虑你的机器学习系统试图建模的概念可能存在的各种可能世界来给你的设计增加更多的复杂性。
- en: 10.7\. Reactivities
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7\. 反应性
- en: '![](dog-ball.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![狗球](dog-ball.jpg)'
- en: After a whole book of building reactive machine learning systems, you should
    now know more than enough to build something really great for these bees and their
    bot platform. I won’t show you a particular solution. I’ll leave that up to you
    as a final reactivity. The next couple of sections go into more detail about the
    dimensions that you can consider when you implement your bot platform. This reactivity
    is worthwhile to walk through, even if you only design but don’t implement your
    solution, because many of the questions speak to high-level architectural issues
    in your design.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在写完一整本书关于构建反应式机器学习系统之后，你现在应该知道足够多的知识来为这些蜜蜂和它们的机器人平台构建一些真正出色的东西。我不会展示一个特定的解决方案。我会把这个留给你，作为最后的反应性。接下来的几节将更详细地介绍你在实现你的机器人平台时可以考虑的维度。即使你只设计而不实现解决方案，这种反应性也是值得探讨的，因为其中许多问题涉及到你设计中的高级架构问题。
- en: 10.7.1\. Libraries
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.7.1\. 库
- en: You’ve used various libraries/frameworks/tools in this book. Often, those libraries
    have given your applications properties that would be laborious to implement otherwise.
    In the case of this bot platform, are there libraries that might help you make
    this system more reactive?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书中使用了各种库/框架/工具。通常，这些库会给你的应用程序带来一些其他情况下难以实现的特性。在这个机器人平台上，有没有可能帮助你使这个系统更具反应性的库？
- en: Let’s start with Spark. In this book, you’ve mostly used Spark as a way of building
    elastic, distributed, data-processing pipelines, but that’s not all it can do.
    Spark is generally a great tool for building distributed systems, not just batch-mode
    jobs. You could certainly hold the agents in your system inside Spark data structures.
    That would allow you to use the strategy of replication.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Spark 开始。在这本书中，你主要使用 Spark 来构建弹性、分布式、数据处理管道，但这并不是它所能做的全部。Spark 通常是一个构建分布式系统的优秀工具，而不仅仅是批量作业。你当然可以在
    Spark 数据结构中持有你系统中的代理。这将允许你使用复制策略。
- en: Keeping your agent data distributed throughout a cluster should help with elasticity,
    because requests to agents can be served from multiple nodes in the cluster. Similarly,
    Spark’s built-in supervision capabilities can help with resilience.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中保持你的代理数据分布，应该有助于弹性，因为代理的请求可以从集群中的多个节点提供服务。同样，Spark 内置的监督能力可以帮助提高容错性。
- en: If a node in the cluster goes down, the Spark master won’t send it work and
    may potentially bring up new nodes, depending on how your implementation works
    with the underlying cluster manager.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集群中的一个节点宕机，Spark 主节点不会给它发送工作，并且可能会根据你的实现与底层集群管理器的交互方式启动新的节点。
- en: Useful as Spark is, it’s not the only tool in your toolbox. Akka has many of
    the same strengths—as you might expect, because Spark used Akka internally in
    earlier versions of the library. An Akka implementation of a bot platform might
    be more natural in some ways. You could model agents as actors, which are somewhat
    similar concepts; an *actor* is like an agent that uses only message passing as
    its form of actuation. But as you’ve seen, message-driven applications can have
    really great properties.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spark非常有用，但它并不是你工具箱中的唯一工具。Akka 具有许多相同的优势——正如你所期望的，因为Spark在库的早期版本中内部使用了Akka。在某些方面，Akka
    实现的机器人平台可能更为自然。你可以将代理建模为演员，这些概念有些相似；一个*演员*就像一个只使用消息传递作为其动作形式的代理。但是，正如你所看到的，消息驱动应用程序可以具有非常优秀的特性。
- en: Thanks to a message-driven design, an Akka implementation could easily contain
    the errors of agents on the platform. There’s no reason why errors in a given
    agent should contaminate another agent if both are modeled as distinct actors.
    In this way, Akka actors aren’t too different from the model microservices you
    built in [chapter 7](kindle_split_018.html#ch07).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于采用了消息驱动的设计，Akka 实现可以轻松地包含平台上的代理错误。如果两个代理都被建模为不同的演员，那么在给定代理中出现的错误不应该会污染另一个代理，这是没有道理的。因此，Akka
    演员与你在第 7 章[chapter 7](kindle_split_018.html#ch07)中构建的模型微服务并没有太大的不同。
- en: All actor systems are organized around supervisory hierarchies. The benefit
    of this is that the supervisory actors can take actions to improve the elasticity
    and resilience of the system by spawning new actors in cases of high load or killing
    actors that are misbehaving.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所有演员系统都是围绕监督层次结构组织的。这种做法的好处是，监督演员可以在高负载的情况下通过产生新的演员来提高系统的弹性和容错性，或者在演员行为不当时将其终止。
- en: Of course, it’s great to not have to design how all these actors compose by
    using libraries like Akka HTTP. Despite the power and flexibility of Akka, it
    abstracts all sorts of complexity in system design, allowing you to minimize the
    amount of focus that you spend on things like message-passing mechanics and how
    to manage supervision trees.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不用设计如何使用像 Akka HTTP 这样的库来组合所有这些演员是非常好的。尽管 Akka 强大且灵活，但它抽象了系统设计中各种复杂性，允许你最小化在消息传递机制和如何管理监督树等方面所花费的关注。
- en: 10.7.2\. System data
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.7.2. 系统数据
- en: Finally, let’s look at the data in your system and see what design choices can
    be made. First, if you presume that your data is effectively infinite in scale,
    then how should that influence the design of the system?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看你系统中的数据，看看可以做出哪些设计选择。首先，如果你假设你的数据在规模上是有效无限的，那么这应该如何影响系统的设计？
- en: Typically, that implies that you’re building a distributed system. You’ve spent
    a fair bit of time on Spark and Akka in this book, and they can both be used to
    build highly reactive distributed systems. But this concern about data scale isn’t
    just about data *processing*; it’s relevant to data *storage* as well. As discussed
    in [chapter 3](kindle_split_014.html#ch03), there are lots of reasons to ensure
    that the backing data store for your system is a highly replicated distributed
    database of some kind. Your options include self-hosted databases like Cassandra,
    MongoDB, and Couchbase as well as cloud-native databases provided as services
    like DynamoDB, Cosmos DB, and Bigtable. All the databases just mentioned (and
    too many more to enumerate) use techniques like replication and supervision to
    ensure elasticity, resilience, and responsiveness. There’s not one good choice;
    there are many. But there’s no need to begin your design with a traditional nondistributed
    relational database. Better ways of building systems are available via simple
    API calls to cloud vendors. That’s not to say that you shouldn’t consider using
    the relational model for your data, but if you do, definitely consider using a
    distributed relational database like Spanner or CockroachDB.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这意味着你正在构建一个分布式系统。在这本书中，你已经花费了不少时间学习 Spark 和 Akka，它们都可以用来构建高度反应性的分布式系统。但这种关于数据规模的担忧并不仅仅关乎数据
    *处理*；它同样与数据 *存储* 相关。正如在第 [3章](kindle_split_014.html#ch03) 中所讨论的，确保你的系统后端数据存储是一个高度复制的分布式数据库有很多原因。你的选择包括自托管数据库，如
    Cassandra、MongoDB 和 Couchbase，以及作为服务提供的云原生数据库，如 DynamoDB、Cosmos DB 和 Bigtable。所有提到的数据库（以及更多无法一一列举的数据库）都使用复制和监督等技术来确保弹性、弹性和响应性。没有一种最佳选择；有很多选择。但你的设计无需从传统的非分布式关系数据库开始。通过简单的
    API 调用云服务提供商，你可以找到更好的构建系统的方法。这并不是说你不应该考虑使用关系模型来存储你的数据，但如果你这样做，肯定要考虑使用分布式关系数据库，如
    Spanner 或 CockroachDB。
- en: While you’re thinking about the consequences of effectively infinitely sized
    datasets, let’s think some more about how you can use other tools in your toolbox.
    For example, how are you going to design a development workflow that allows you
    to iterate on system design locally while still maintaining parity with a large-scale
    production deployment?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在思考无限大数据集的有效后果时，让我们再深入思考一下如何使用工具箱中的其他工具。例如，你将如何设计一个开发工作流程，允许你在本地迭代系统设计的同时，仍然与大规模生产部署保持一致性？
- en: As you’ve seen before, one technique you can use is laziness. For example, if
    you compose your feature-generation and model-learning pipeline as a series of
    transformations over immutable datasets using Spark, then that pipeline will be
    composed in a lazy fashion and executed only once a Spark action has been invoked.
    You used this method of pipeline composition extensively in [chapters 4](kindle_split_015.html#ch04)
    and [5](kindle_split_016.html#ch05).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前所看到的，你可以使用的一种技术是惰性。例如，如果你使用 Spark 在不可变数据集上的一系列转换来组合你的特征生成和模型学习管道，那么这个管道将以惰性方式组合，并且只有在调用
    Spark 动作时才会执行。你在第 [4章](kindle_split_015.html#ch04) 和 [5章](kindle_split_016.html#ch05)
    中广泛使用了这种方法来组合管道。
- en: Similarly, you’ve already seen lots of ways to use pure, higher-order functions
    as ways of implementing transformations on top of immutable datasets. As you’ve
    seen in several chapters, the use of pure functions enables various techniques
    for dealing with arbitrarily sized datasets. Where can you use pure functions
    in your system implementation? You’ve certainly seen how pure functions can be
    used in feature generation. In your bot platform implementation, does it make
    sense to have models themselves be functions? For example, could you refactor
    [listing 10.6](#ch10ex06) to structure likes using pure functions?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你已经看到了许多使用纯函数作为在不可变数据集上实现转换的方法。正如你在几个章节中看到的，纯函数的使用使得处理任意大小数据集的各种技术成为可能。在你的系统实现中，你可以在哪里使用纯函数？你当然已经看到了纯函数在特征生成中的应用。在你的机器人平台实现中，模型本身作为函数是否有意义？例如，你能否将
    [列表 10.6](#ch10ex06) 重构为使用纯函数来结构化类似项？
- en: Let’s also think about the certainty of your data. Throughout this book, you’ve
    taken the approach that data in your machine learning system can’t be treated
    as certain—that all data in a machine learning system is subject to uncertainty.
    Instead of treating the concept of sentiment as a Boolean, it could instead be
    modeled as a level of confidence in positive sentiment, along the lines of the
    following listing.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也考虑一下你数据的确定性。在这本书的整个过程中，你采取了这样的方法：机器学习系统中的数据不能被视为确定的——机器学习系统中的所有数据都受到不确定性的影响。而不是将情感的概念视为布尔值，它可以被建模为对积极情感的置信度水平，如下面的列表所示。
- en: Listing 10.10\. Uncertain data model for sentiments
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.10\. 情感的不确定数据模型
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Defines a sealed trait to structure different sentiment levels**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个密封特质来结构化不同的情感级别**'
- en: '***2* Requires all uncertain sentiments to have a confidence level**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 要求所有不确定的情感都有一个置信度级别**'
- en: '***3* Instance of an uncertain sentiment, representing a strong like sentiment**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 不确定情感的一个实例，代表强烈的喜爱情感**'
- en: '***4* Strong like sentiment modeled as 90% confidence of a positive sentiment**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 强烈的喜爱情感建模为90%的积极情感置信度**'
- en: '***5* Indifferent sentiment modeled as 50% confidence of a positive sentiment**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 无所谓情感建模为50%的积极情感置信度**'
- en: '***6* Dislike sentiment modeled as 30% confidence of a positive sentiment**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 厌恶情感建模为30%的积极情感置信度**'
- en: This listing is a sketch of a simplistic way of encoding some uncertainty within
    the data model. A more sophisticated approach would likely involve calculating
    the level of confidence for any given sentiment prediction, as you’ve seen previously
    in the book.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表是数据模型中编码一些不确定性的简单方法的一个草图。一个更复杂的方法可能涉及计算任何给定情感预测的置信度水平，就像你在书中之前看到的那样。
- en: By modeling your data as uncertain, you open the door to reasoning about the
    range of possible states that the concept being modeled could be in. How could
    your system design evolve to incorporate this style of reasoning? A given agent
    could return some of this uncertainty to the user by returning the top *N* results
    by confidence. Or, if multiple agents could be addressed to perform a given task
    for a user, then the Buzz Me bot platform could develop its own models of confidence
    in each and every agent. Then the supervisory component (which might itself be
    modeled as an agent) could dynamically choose which agent would be best suited
    to fulfill a given user task based on its confidence level in each agent, as in
    [figure 10.3](#ch10fig03).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将你的数据建模为不确定的，你打开了推理可能状态范围的门，这些状态是正在建模的概念可能处于的状态。你的系统设计如何演变以包含这种推理风格？一个特定的代理可以通过返回基于置信度的前*N*个结果来将一些不确定性返回给用户。或者，如果有多个代理可以针对用户执行特定任务，那么Buzz
    Me机器人平台可以为每个代理开发自己的置信度模型。然后，监督组件（它本身可能被建模为代理）可以根据每个代理的置信度水平动态选择哪个代理最适合完成给定的用户任务，就像[图10.3](#ch10fig03)中所示。
- en: Figure 10.3\. Agent supervision
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3\. 代理监督
- en: '![](10fig03.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![10fig03.jpg](10fig03.jpg)'
- en: With all these questions and tools in mind, you could now build a pretty sophisticated
    solution for AI agents that converse with insects via instant messaging.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了所有这些问题和工具之后，你现在可以为与昆虫通过即时消息进行对话的人工智能代理构建一个相当复杂的解决方案。
- en: 10.8\. Reactive explorations
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.8\. 反应性探索
- en: At the end of each chapter, I’ve asked you to go out and apply the concepts
    of reactive machine learning to new challenges via the reactivities. This section
    explores how you can take others on a journey through the use of reactive techniques
    using a tool I like to call a *reactive exploration*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章的结尾，我都要求你们通过反应性来将反应性机器学习的概念应用于新的挑战中。本节探讨了如何通过使用我称之为*反应性探索*的工具，带领他人通过反应性技术进行一次旅程。
- en: In a reactive exploration, you ask questions about an existing system or component,
    examining it with its implementers/maintainers. You could start this exploration
    by just dropping a copy of this book on someone’s desk and telling them to read
    it all before you talked—or you could try to ease into the topic by having a more
    general conversation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应性探索中，你向现有系统或组件提出问题，并与其实施者/维护者一起检查它。你可以通过只是把这本书放在某人的桌子上，告诉他们在你谈话之前把它全部读完来开始这次探索——或者你可以通过进行更广泛的对话来逐渐引入这个话题。
- en: 10.8.1\. Users
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.8.1\. 用户
- en: I like to begin by trying to figure out who the user is. That question can be
    trickier than it sounds. The user isn’t always the literal customer of the company.
    For many machine learning components, the user is some other developer or team
    that relies on the machine learning system to perform useful functionality. One
    way to get at firm agreement on who this person is to ask, “Who would care if
    we all stopped coming in to work?” Once you’ve got that person characterized,
    you can place them on the board, using a cartoon animal or some other representation
    ([figure 10.4](#ch10fig04)).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢先尝试弄清楚用户是谁。这个问题可能比听起来更复杂。用户并不总是公司的直接客户。对于许多机器学习组件，用户是其他依赖机器学习系统执行有用功能的开发人员或团队。确定这个人的一个方法是通过问，“如果我们所有人都停止上班会发生什么？”一旦你确定了这个人，你就可以在板上放置一个卡通动物或其他表示（[图10.4](#ch10fig04)）。
- en: Figure 10.4\. An unhappy user of a non-reactive machine learning system
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4. 一个不满意的非反应式机器学习系统用户
- en: '![](10fig04.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![10fig04](10fig04.jpg)'
- en: 'Then you need to establish how this user interacts with your system. Specifically,
    you want to identify all the components of a request-response cycle. Examples
    of a request-response cycle could include the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要确定这个用户是如何与你的系统互动的。具体来说，你想要识别请求-响应周期中的所有组件。请求-响应周期的例子可能包括以下内容：
- en: For an ad-targeting system, the user could send a request for an ad along with
    some browser data and get back the ID number of the ad to show.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个广告定位系统，用户可以发送一个包含一些浏览器数据的广告请求，并得到要显示的广告的ID号。
- en: For a spam filter, the user could send an email and get back a classification
    as spam or not spam.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个垃圾邮件过滤器，用户可以发送一封电子邮件，并得到垃圾邮件或非垃圾邮件的分类。
- en: For a music-recommendation system, the user could send a subscriber’s listening
    history and get back a list of recommended songs.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个音乐推荐系统，用户可以发送订阅者的收听历史记录，并得到一串推荐歌曲列表。
- en: 10.8.2\. System dimensions
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.8.2. 系统维度
- en: If you’ve properly defined it, this request-response cycle is the basis of the
    commitment your system has with its users. That allows you to ask questions motivated
    by reactive design principles without first having to introduce all the terminology
    used in this book and other discussions of reactive.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经正确地定义了它，这个请求-响应周期就是你的系统与用户之间承诺的基础。这允许你在不首先介绍这本书和其他关于反应式设计的讨论中所使用的所有术语的情况下，提出由反应式设计原则激发的问题。
- en: 'Here are four dimensions that you can ask questions about for a given system.
    First, you can ask questions about *response time* in the system:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于给定系统你可以提出问题的四个维度。首先，你可以询问系统中的 *响应时间*：
- en: When will this system return responses to the user?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个系统何时会向用户返回响应？
- en: How quickly does the user expect a response?
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户期望多快得到响应？
- en: How much will that response time vary?
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间会有多大的变化？
- en: What functionality within the system is responsible for ensuring that the system
    responds within that time?
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中哪个功能负责确保系统在规定时间内响应？
- en: What will happen on the user’s end if the response isn’t returned within the
    time expectation?
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在预期时间内没有返回响应，用户端会发生什么？
- en: Do you have any data around what real response times are?
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有关于实际响应时间的任何数据？
- en: What would happen if the system returned responses instantaneously?
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统立即返回响应会发生什么？
- en: 'Next, you can ask questions about the behavior of the system under *varying
    levels of load*:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以询问关于系统在 *不同负载级别* 下的行为：
- en: What sort of load do you expect for this system?
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你预计这个系统会有什么样的负载？
- en: What data do you have about past historical load?
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对过去历史负载有什么数据？
- en: What if the system was under 10 times the load you expect? 100 times? More?
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统承受的负载是你预期的10倍？100倍？更多呢？
- en: What would the system do under no load?
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有负载的情况下，系统会做什么？
- en: What sort of load would cause the system to not return a response to a user
    within the expected time frame?
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么类型的负载会导致系统在预期时间内无法向用户返回响应？
- en: 'After that, you can move on to questions about *error handling*:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以继续探讨关于 *错误处理* 的问题：
- en: What are some past bugs that this system has experienced?
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个系统经历过哪些过去的错误？
- en: What behavior did the system exhibit in the presence of those errors?
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些错误存在的情况下，系统表现出了什么样的行为？
- en: Have any past errors caused the system to violate the expectations of the user
    in the request-response cycle?
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去的错误是否导致系统违反了用户在请求-响应周期中的期望？
- en: What functionality exists within the system to ensure that errors don’t violate
    user expectations?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中存在哪些功能来确保错误不会违反用户期望？
- en: What external systems is the system connected to?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统连接到哪些外部系统？
- en: What sorts of errors could occur in those external systems?
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些外部系统中可能发生哪些类型的错误？
- en: How would this system behave in the presence of those errors from external systems?
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存在来自外部系统的那些错误的情况下，这个系统会如何表现？
- en: 'Finally, you can ask about the *communication patterns* within the system:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以询问系统内部的*通信模式*：
- en: If one part of the system is under high load, how is that communicated?
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统的一部分处于高负载状态，这是如何被传达的？
- en: If an error occurs in one part of the system, how is that communicated to other
    components?
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统的一部分发生错误，这是如何传达给其他组件的？
- en: Where do the component boundaries exist within the system?
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中的组件边界在哪里？
- en: How do the components share data?
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件之间如何共享数据？
- en: 10.8.3\. Applying reactive principles
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.8.3\. 应用反应性原则
- en: For the attentive reader, the four dimensions of system behavior in the previous
    section should have sounded very familiar. They’re restatements of the reactive
    principles that you’ve been using all through this book, as you can see in [table
    10.1](#ch10table01).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于细心的读者来说，上一节中提到的系统行为的四个维度应该听起来非常熟悉。它们是对你在整本书中一直在使用的反应性原则的重申，正如你在[表10.1](#ch10table01)中可以看到的那样。
- en: Table 10.1\. Mapping from system dimensions to reactive principles
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1\. 从系统维度到反应性原则的映射
- en: '| System dimension | Reactive principle |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 系统维度 | 反应性原则 |'
- en: '| --- | --- |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Time | Responsive |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 时间 | 响应性 |'
- en: '| Load | Elastic |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 负载 | 弹性 |'
- en: '| Error | Resilient |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 弹性 |'
- en: '| Communication | Message-driven |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 通信 | 消息驱动 |'
- en: Done with a legitimate curiosity about the behavior of the machine learning
    system, this exercise should leave you with a lot of interesting follow-up questions
    to try to answer. Very often, you won’t really know how a system will behave under
    certain conditions, and you won’t be able to point to any functionality responsible
    for ensuring that the system fulfills user expectations in a given scenario. That
    gives you the opportunity to figure out how to apply all the tools and techniques
    that you’ve learned in this book, guided by the user needs that you uncovered
    in the reactive exploration.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对机器学习系统行为的合法好奇心完成这项练习，你应该会有很多有趣的后续问题去尝试回答。非常经常，你实际上并不知道系统在特定条件下会如何表现，你也不能指出任何负责确保系统在特定场景下满足用户期望的功能。这给了你一个机会，去弄清楚如何应用你在本书中学到的所有工具和技术，这些工具和技术是由你在反应式探索中发现的用户需求所指导的。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: An agent is a software application that can act on its own.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理是一种可以独立行动的软件应用。
- en: A reflex agent acts according to statically defined behavior.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射代理根据静态定义的行为行事。
- en: An intelligent agent acts according to knowledge that it has.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能代理根据它所拥有的知识行事。
- en: A learning agent is capable of learning—it can improve its performance on a
    task given exposure to more data.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习代理能够学习——它可以通过接触更多数据来提高其在任务上的性能。
- en: That’s the end of the book. I’ve shown you all that I can. Now it’s your turn
    to show me just how amazing the machine learning systems you build will be. Happy
    hacking!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本书的结尾。我已经向你展示了我能做到的一切。现在轮到你了，向我展示你构建的机器学习系统将有多么神奇。祝你好运！
