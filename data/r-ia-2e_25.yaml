- en: 20 Advanced programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20 高级编程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Diving deeper into the R language
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解R语言
- en: Using R’s OOP features to create generic functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R的面向对象编程特性创建通用函数
- en: Tweaking code to run more efficiently
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整代码以提高运行效率
- en: Finding and correcting programming errors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找和纠正编程错误
- en: Previous chapters introduced various topics that are important for application
    development, including data types (section 2.2), control flow (section 5.4), and
    function creation (section 5.5). This chapter will review these aspects of R as
    a programming language from a more advanced and detailed perspective. By the end
    of this chapter, you’ll have a better idea of how the R language works, which
    will help you create your own functions, and ultimately, your own packages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了对应用程序开发重要的话题，包括数据类型（第2.2节）、控制流（第5.4节）和函数创建（第5.5节）。本章将从更高级和更详细的视角回顾R作为编程语言的这些方面。到本章结束时，您将更好地了解R语言的工作方式，这将帮助您创建自己的函数，最终，您的自己的包。
- en: We’ll start with a review of objects, data types, and control flow before moving
    on to details of function creation, including the role of scope and environments.
    The chapter introduces R’s approach to object-oriented programming and discusses
    the creation of generic functions. Finally, we’ll go over tips for writing efficient
    code-generating and debugging applications. Mastery of these topics will help
    you understand the code in other people’s applications and aid you in creating
    new applications. In chapter 22, you’ll have an opportunity to put these skills
    into practice by creating a useful package from start to finish.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细讨论函数创建的细节之前，包括作用域和环境的作用，我们将先回顾对象、数据类型和控制流。本章介绍了R的面向对象编程方法，并讨论了通用函数的创建。最后，我们将介绍编写高效代码生成和调试应用程序的技巧。掌握这些主题将帮助您理解他人应用程序中的代码，并帮助您创建新的应用程序。在第22章中，您将有机会从头到尾创建一个有用的包，以将这些技能付诸实践。
- en: 20.1 A review of the language
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.1 语言回顾
- en: R is an object-oriented, functional, array-oriented programming language in
    which objects are specialized data structures, stored in RAM, and accessed via
    names or symbols. Names of objects consist of uppercase and lowercase letters,
    the digits 0–9, the period, and the underscore. Names are case sensitive and can’t
    start with a digit, and a period is treated as a simple character without special
    meaning.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: R是一种面向对象、函数式、数组式编程语言，其中对象是特殊的数据结构，存储在RAM中，并通过名称或符号访问。对象的名称由大写和小写字母、数字0-9、点号和下划线组成。名称区分大小写，不能以数字开头，点号被视为普通字符，没有特殊含义。
- en: Unlike in languages such as C and C++, you can’t access memory locations directly.
    Data, functions, and just about everything else that can be stored and named are
    objects. Additionally, the names and symbols themselves are objects that can be
    manipulated. All objects are stored in RAM during program execution, which has
    significant implications for the analysis of massive datasets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与C和C++等语言不同，你无法直接访问内存位置。数据、函数以及几乎所有可以存储和命名的其他内容都是对象。此外，名称和符号本身也是可以被操作的对象。所有对象在程序执行期间都存储在RAM中，这对分析大规模数据集有重大影响。
- en: 'Every object has attributes: meta-information that describes the characteristics
    of the object. Attributes can be listed with the `attributes()` function and set
    with the `attr()` function. A key attribute is an object’s class. R functions
    use information about an object’s class to determine how the object should be
    handled. The class of an object can be read and set with the `class()` function.
    Examples will be given throughout this chapter and the next.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有属性：描述对象特征的元信息。可以使用`attributes()`函数列出属性，并使用`attr()`函数设置属性。一个关键属性是对象的类。R函数使用有关对象类信息来确定如何处理对象。对象的类可以使用`class()`函数读取和设置。本章和下一章将给出一些示例。
- en: 20.1.1 Data types
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.1 数据类型
- en: 'There are two fundamental data types: atomic vectors and generic vectors. Atomic
    vectors are arrays that contain a single data type. Generic vectors, also called
    lists, are collections of atomic vectors. Lists are recursive in that they can
    also contain other lists. This section considers both types in some detail.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种基本数据类型：原子向量和通用向量。原子向量是只包含单一数据类型的数组。通用向量，也称为列表，是原子向量的集合。列表是递归的，因为它们也可以包含其他列表。本节将详细考虑这两种类型。
- en: Unlike many other programming languages, you don’t have to declare an object’s
    data type or allocate space for it. The type is determined implicitly from the
    object’s contents, and the size grows or shrinks automatically depending on the
    type and number of elements the object contains.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他编程语言不同，您不需要声明对象的类型或为其分配空间。类型从对象的内部内容隐式确定，大小根据对象包含的类型和元素数量自动增长或缩小。
- en: Atomic vectors
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 原子向量
- en: 'Atomic vectors are arrays that contain a single data type (logical, real, complex,
    character, or raw). For example, each of the following is a one-dimensional atomic
    vector:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 原子向量是包含单一数据类型（逻辑、实数、复数、字符或原始）的数组。例如，以下每个都是一维原子向量：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Vectors of type *raw* hold raw bytes and aren’t discussed here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 *raw* 的向量包含原始字节，这里不做讨论。
- en: Many R data types are atomic vectors with special attributes. For example, R
    doesn’t have a scalar type. A scalar is an atomic vector with a single element.
    So, `k <- 2` is a shortcut for `k <- c(2)`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 R 数据类型都是具有特殊属性的原子向量。例如，R 没有标量类型。标量是一个只有一个元素的原子向量。因此，`k <- 2` 是 `k <- c(2)`
    的简写。
- en: 'A matrix is an atomic vector that has a dimension attribute, `dim`, containing
    two elements (number of rows and number of columns). For example, start with a
    one-dimensional numeric vector `x`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个具有维度属性 `dim` 的原子向量，该属性包含两个元素（行数和列数）。例如，从一个一维数值向量 `x` 开始：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then add a `dim` attribute:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加一个 `dim` 属性：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The object `x` is now a 2 × 3 matrix of class `matrix`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对象 `x` 现在是一个 2 × 3 的 `matrix` 类矩阵：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Row and column names can be attached by adding a `dimnames` attribute:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加 `dimnames` 属性来附加行和列名：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, the matrix can be returned to a one-dimensional vector by removing
    the `dim` attribute:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以通过移除 `dim` 属性将矩阵返回为一维向量：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An array is an atomic vector with a `dim` attribute that has three or more elements.
    Again, you set the dimensions with the `dim` attribute, and you can attach labels
    with the `dimnames` attribute. Like one-dimensional vectors, matrices and arrays
    can be logical, numeric, character, complex, or raw types. But you can’t mix types
    in a single matrix or array.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个具有 `dim` 属性的原子向量，该属性包含三个或更多元素。同样，您使用 `dim` 属性设置维度，并可以使用 `dimnames` 属性附加标签。与一维向量一样，矩阵和数组可以是逻辑、数值、字符、复数或原始类型。但您不能在单个矩阵或数组中混合类型。
- en: The `attr()` function allows you to create arbitrary attributes and associate
    them with an object. Attributes store additional information about an object and
    can be used by functions to determine how they’re processed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr()` 函数允许您创建任意属性并将它们与一个对象关联。属性存储有关对象的信息，并且可以被函数用来确定它们如何被处理。'
- en: There are a number of special functions for setting attributes, including `dim``()`,
    `dimnames``()`, `names``()`, `row.names``()`, `class``()`, and `tsp``()`. The
    latter is used to create time series objects. These special functions have restrictions
    on the values that can be set. Unless you’re creating custom attributes, it’s
    always a good idea to use these special functions. Their restrictions and the
    error messages they produce make coding errors less likely and more obvious.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于设置属性的专用函数，包括 `dim()`、`dimnames()`、`names()`、`row.names()`、`class()` 和 `tsp()`。后者用于创建时间序列对象。这些专用函数对可以设置的值有限制。除非您正在创建自定义属性，否则始终使用这些专用函数是个好主意。它们的限制和它们产生的错误消息使编码错误的可能性降低，并且更明显。
- en: Generic vectors or lists
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型向量或列表
- en: '*Lists* are collections of atomic vectors and/or other lists. Data frames are
    a special type of list in which each atomic vector in the collection has the same
    length. Consider the `iris` data frame that comes with the base R installation.
    It describes four physical measures taken on each of 150 plants, along with their
    species (setosa, versicolor, or virginica):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是原子向量和/或其他列表的集合。数据框是列表的一种特殊类型，其中集合中的每个原子向量具有相同的长度。考虑随 base R 安装一起提供的 `iris`
    数据框。它描述了在 150 棵植物上进行的四个物理测量，以及它们的物种（setosa、versicolor 或 virginica）：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This data frame is actually a list containing five atomic vectors. It has a
    `names` attribute (a character vector of variable names), a `row.names` attribute
    (a numeric vector identifying individual plants), and a class attribute with the
    value `"data.frame"`. Each vector represents a column (variable) in the data frame.
    This can be easily seen by printing the data frame with the `unclass()` function
    and obtaining the attributes with the `attributes()` function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据框实际上是一个包含五个原子向量的列表。它有一个`names`属性（变量名称的字符向量），一个`row.names`属性（标识单个植物的数值向量），以及一个值为`"data.frame"`的类属性。每个向量代表数据框中的一列（变量）。这可以通过使用`unclass()`函数打印数据框并使用`attributes()`函数获取属性来轻松看到：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output is omitted here to save space.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，这里省略了输出。
- en: It’s important to understand lists because R functions frequently return them
    as values. Let’s look at an example using a cluster analysis technique from chapter
    16\. Cluster analysis uses a family of methods to identify naturally occurring
    groupings of observations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 理解列表非常重要，因为R函数经常将它们作为值返回。让我们看看使用第16章中提到的聚类分析技术的一个例子。聚类分析使用一系列方法来识别观察值自然发生的分组。
- en: Let’s apply k-means cluster analysis (section 16.4.1) to the `iris` data. Assume
    that there are three clusters present in the data, and observe how the observations
    (rows) become grouped. We’ll ignore the species variable and use only the physical
    measures of each plant to form the clusters. The required code is
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将k-means聚类分析（第16.4.1节）应用于`iris`数据。假设数据中存在三个聚类，观察观察值（行）是如何分组的。我们将忽略物种变量，仅使用每棵植物的物理测量值来形成聚类。所需的代码是
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What information is contained in the object `fit`? The help page for `kmeans``()`
    indicates that the function returns a list with seven components. The `str()`
    function displays the object’s structure, and the `unclass()` function can be
    used to examine the object’s contents directly. The `length()` function indicates
    how many components the object contains, and the `names()` function provides the
    names of these components. You can use the `attributes()` function to examine
    the attributes of the object. The contents of the object returned by `kmeans``()`
    are explored here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`fit`包含哪些信息？`kmeans``()`函数的帮助页面表明该函数返回一个包含七个组件的列表。`str()`函数显示对象的结构，`unclass()`函数可以用来直接检查对象的内容。`length()`函数指示对象包含多少个组件，`names()`函数提供这些组件的名称。您可以使用`attributes()`函数来检查对象的属性。这里探讨了`kmeans``()`返回的对象的内容：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Executing `sapply(fit,` `class)` returns the class of each component in the
    object:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`sapply(fit,` `class)`返回对象中每个组件的类：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, `cluster` is an integer vector containing the cluster memberships,
    and `centers` is a matrix containing the cluster centroids (means on each variable
    for each cluster). The `size` component is an integer vector containing the number
    of plants in each of the three clusters. To learn about the other components,
    see the Value section of `help(``kmeans)`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`cluster`是一个包含聚类成员资格的整数向量，`centers`是一个包含聚类质心（每个聚类的每个变量的均值）的矩阵。`size`组件是一个包含每个三个聚类的植物数量的整数向量。要了解其他组件，请参阅`help(``kmeans``)`中的值部分。
- en: Indexing
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: Learning to unpack the information in a list is a critical R programming skill.
    The elements of any data object can be extracted via indexing. Before diving into
    a list, let’s look at extracting elements from an atomic vector.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何提取列表中的信息是R编程的关键技能。任何数据对象的元素都可以通过索引来提取。在深入探讨列表之前，让我们看看如何从原子向量中提取元素。
- en: Elements are extracted using `*object*[*index*]`, where *`object`* is the vector
    and `index` is an integer vector. If the elements of the atomic vector have been
    named, *`index`* can also be a character vector with these names. Note that in
    R, indices start with 1, not 0 as in many other languages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 元素是通过使用`*object*[*index*]`来提取的，其中`*object*`是向量，`index`是一个整数向量。如果原子向量的元素已经被命名，`index`也可以是一个包含这些名称的字符向量。请注意，在R中，索引从1开始，而不是像许多其他语言中的0。
- en: 'Here is an example, using this approach for an atomic vector without named
    elements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，使用这种方法对一个没有命名的原子向量进行操作：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For an atomic vector with named elements, you could use
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有命名元素的原子向量，您可以使用
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For lists, components (atomic vectors or other lists) can be extracted using
    `*object*[*index*]`, where *`index`* is an integer vector. If the components are
    named, you can use a character vector of names.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表，可以使用`*object*[index*]`提取组件（原子向量或其他列表），其中`index`是一个整数向量。如果组件有名称，可以使用名称字符向量。
- en: Continuing the k-means example,
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 k-means 的例子，
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: returns a two-component list (cluster means and cluster sizes). Each component
    contains a matrix.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含两个组件的列表（聚类均值和聚类大小）。每个组件都包含一个矩阵。
- en: It is important to note that using single brackets to subset a list always returns
    a list. For example,
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，使用单括号从列表中提取子集始终返回一个列表。例如，
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: returns a one-component list, not a matrix. To extract the *contents* of a component,
    use `object``[[``index``]]`. For example,
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含一个组件的列表，而不是矩阵。要提取组件的*内容*，请使用`object[[index]]`。例如，
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: returns a matrix. The difference can be important, depending on what you do
    with the results. If you want to pass the results to a function that requires
    a matrix as input, you want to use the double-bracket notation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个矩阵。这个区别可能很重要，取决于你对结果的处理方式。如果你想将结果传递给需要一个矩阵作为输入的函数，请使用双括号表示法。
- en: 'To extract the contents of a single named component, you can use the `$` notation.
    In this case, `object[["name"]]` and `object$name` are equivalent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取单个命名组件的内容，可以使用 `$` 符号。在这种情况下，`object[["name"]]` 和 `object$name` 是等效的：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This also explains why the `$` notation works with data frames. Consider the
    `iris` data frame. The data frame is a special case of a list, where each variable
    is represented as a component. For example, `iris$Sepal.Length` is equivalent
    to `iris[["Sepal .Length"]]`, and returns the 150-element vector of sepal lengths.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解释了为什么 `$` 符号与数据框一起使用。考虑 `iris` 数据框。数据框是列表的特殊情况，其中每个变量都表示为一个组件。例如，`iris$Sepal.Length`
    等同于 `iris[["Sepal .Length"]]`，并返回花瓣长度的 150 元素向量。
- en: Notations can be combined to obtain the elements within components. For example,
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以组合符号来获取组件内的元素。例如，
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: extracts the second component of `fit` (a matrix of means) and returns the first
    row (the means for the first cluster on each of the four variables). The blank
    after the comma in the final square brackets indicates that all four columns are
    to be returned.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提取 `fit` 的第二个组件（均值的矩阵）并返回第一行（每个变量的第一个聚类的均值）。在最终方括号后面的逗号后的空白表示返回所有四列。
- en: By extracting the components and elements of lists returned by functions, you
    can take the results and go further. For example, to plot the cluster centroids
    with a line graph, you can use the code in the following listing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提取函数返回的列表的组件和元素，你可以进一步处理结果。例如，要使用线形图绘制聚类中心，可以使用以下列表中的代码。
- en: Listing 20.1 Plotting the centroids from a k-means cluster analysis
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.1 从 k-means 聚类分析中绘制聚类中心
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Obtains the cluster means
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取聚类均值
- en: ❷ Reshapes the data to long form
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将数据重塑为长格式
- en: ❸ Plots a line graph
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 绘制线形图
- en: First, the matrix of cluster centroids is extracted (rows are clusters, and
    columns are variable means) and converted to a data frame. Cluster number is added
    as an additional variable ❶. The data frame is then reshaped into long format
    using the `tidyr` package (see section 5.5.2) ❷. Finally, the data is plotted
    using the `ggplot2` package ❸. Figure 20.1 displays the resulting graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，提取聚类中心的矩阵（行是聚类，列是变量均值）并将其转换为数据框。添加聚类编号作为附加变量 ❶。然后使用`tidyr`包（见第 5.5.2 节）将数据框重塑为长格式
    ❷。最后，使用`ggplot2`包绘制数据 ❸。图 20.1 显示了生成的图形。
- en: '![](Images/CH20_F01_Kabacoff3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH20_F01_Kabacoff3.png)'
- en: Figure 20.1 A plot of the centroids (means) for three clusters extracted from
    the `iris` dataset using k-means clustering
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.1 使用 k-means 聚类从 `iris` 数据集中提取的三个聚类的中心（均值）的图形
- en: This type of graph is possible because all the plotted variables have the same
    units of measurement (centimeters). If the cluster analysis involved variables
    on different scales, you must standardize the data before plotting and label the
    y-axis something like standardized scores. See section 16.1 for details.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的图形是可能的，因为所有绘制的变量都有相同的测量单位（厘米）。如果聚类分析涉及不同尺度的变量，必须在绘图之前标准化数据，并在 y 轴上标注为标准化分数等。有关详细信息，请参阅第
    16.1 节。
- en: Now that you can represent data in structures and unpack the results, let’s
    look at flow control.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以用结构表示数据并解包结果，让我们看看流程控制。
- en: 20.1.2 Control structures
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.2 控制结构
- en: When the R interpreter processes code, it reads sequentially, line by line.
    If a line isn’t a complete statement, it reads additional lines until a fully
    formed statement can be constructed. For example, if you wanted to add 3 + 2 +
    5,
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当 R 解释器处理代码时，它是按顺序逐行读取的。如果一行不是一个完整的语句，它将读取额外的行，直到可以构造出一个完整的语句。例如，如果你想要计算 3 +
    2 + 5，
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: will work. So will
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将会工作。所以也会
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `+` sign at the end of the first line indicates that the statement isn’t
    complete. But
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行末尾的 `+` 符号表示该语句尚未完成。但是
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: obviously doesn’t work, because 3 + 2 is interpreted as a complete statement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 明显是不行的，因为 3 + 2 被解释为一个完整的语句。
- en: 'Sometimes, you need to process code nonsequentially. You may want to execute
    code conditionally or repeat one or more statements multiple times. This section
    describes three control-flow functions that are particularly useful in writing
    functions: `for``()`, `if()`, and `ifelse``()`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要非顺序地处理代码。你可能想要有条件地执行代码或重复一个或多个语句多次。本节描述了三个在编写函数时特别有用的控制流函数：`for`、`if`
    和 `ifelse`。
- en: for loops
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环
- en: The `for()` function allows you to execute a statement repeatedly. The syntax
    is
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`for()` 函数允许你重复执行一个语句。其语法是'
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'where `var` is a variable name and `seq` is an expression that evaluates to
    a vector. If there is only one statement, the curly braces are optional:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `var` 是一个变量名，`seq` 是一个计算结果为向量的表达式。如果只有一个语句，大括号是可选的：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that `var` continues to exist after the function exits. Here, `i` equals
    1.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`var` 在函数退出后仍然存在。这里，`i` 等于 1。
- en: In the previous examples, the `seq` parameter was a numeric vector. It can also
    be a character vector. For example,
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`seq` 参数是一个数值向量。它也可以是一个字符向量。例如，
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: would create four histograms.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建四个直方图。
- en: if() and else
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: if() 和 else
- en: The `if()` function allows you to execute statements conditionally. The syntax
    for the `if()` construct is
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()` 函数允许你有条件地执行语句。`if()` 构造的语法是'
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The condition should be a one-element logical vector (`TRUE` or `FALSE`) and
    can’t be missing (`NA`). The `else` portion is optional. If there is only one
    statement, the curly braces are also optional.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 条件应该是一个单元素逻辑向量（`TRUE` 或 `FALSE`）并且不能缺失（`NA`）。`else` 部分是可选的。如果只有一个语句，大括号也是可选的。
- en: 'As an example, consider the following code fragment:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码片段：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the code is being run interactively, the `interactive()` function returns
    `TRUE` and a plot is sent to the screen. Otherwise, the plot is saved to disk.
    You’ll use the `if()` function extensively in chapter 22.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码正在交互式运行，`interactive()` 函数返回 `TRUE`，并将图形发送到屏幕。否则，图形将保存到磁盘。你将在第 22 章中广泛使用
    `if()` 函数。
- en: ifelse()
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ifelse()
- en: The `ifelse()` function is a vectorized version of `if()`. Vectorization allows
    a function to process objects without explicit looping. The format of `ifelse`()
    is
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifelse()` 函数是 `if()` 的向量化版本。向量化允许函数在不进行显式循环的情况下处理对象。`ifelse()` 的格式是'
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: where `test` is an object that has been coerced to logical mode, `yes` returns
    values for true elements of `test`, and `no` returns values for false elements
    of `test`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `test` 是已被强制转换为逻辑模式的对象，`yes` 为 `test` 的真元素返回值，`no` 为 `test` 的假元素返回值。
- en: 'Let’s say that you have a vector of p-values that you have extracted from a
    statistical analysis that involved six statistical tests, and you want to flag
    the tests that are significant at the p < .05 level. This can be accomplished
    with the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个从涉及六个统计测试的统计分析中提取的 p 值向量，并且你想要标记在 p < .05 水平上显著的测试。这可以通过以下代码实现：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `ifelse()` function loops through the vector `pvalues` and returns a character
    vector containing the value `"Significant"` or `"Not Significant"` depending on
    whether the corresponding element of `pvalues` is greater than .05.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifelse()` 函数遍历 `pvalues` 向量，并返回一个包含值 `"Significant"` 或 `"Not Significant"`
    的字符向量，具体取决于 `pvalues` 的对应元素是否大于 .05。'
- en: The same result can be accomplished with explicit loops using
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用显式循环达到相同的结果
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The vectorized version is faster and more efficient.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化版本更快更高效。
- en: There are other control structures, including `while()`, `repeat()`, and `switch()`,
    but the ones presented here are the most commonly used. Now that you have data
    structures and control structures, we can talk about creating functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他控制结构，包括 `while`、`repeat` 和 `switch`，但这里介绍的是最常用的。现在你已经有了数据结构和控制结构，我们可以讨论创建函数。
- en: 20.1.3 Creating functions
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.3 创建函数
- en: Almost everything in R is a function. Even arithmetic operators like `+`, `-`,
    `/`, and `*` are actually functions. For example, `2` `+` `2` is equivalent to
    `"+"(2,` `2)`. This section describes function syntax. Section 20.2 examines scope.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎R中的所有内容都是一个函数。甚至像`+`、`-`、`/`和`*`这样的算术运算符实际上也是函数。例如，`2` `+` `2`等价于`"+"(2,`
    `2)`。本节描述函数语法。第20.2节检查作用域。
- en: Function syntax
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数语法
- en: The syntax of a function is
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的语法是
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If there is more than one parameter, they are separated by commas.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个参数，它们之间用逗号分隔。
- en: 'Parameters can be passed by keyword, position, or both. Additionally, parameters
    can have default values. Consider the following function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以通过关键字、位置或两者同时传递。此外，参数可以有默认值。考虑以下函数：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the first case, the parameters are passed by position `(x` `=` `2,` `y` `=`
    `3,` `z` `=` `4)`. In the second case, the parameters are passed by position,
    and `z` defaults to 1\. In the third case, the parameters are passed by keyword,
    and `z` again defaults to 1\. In the final case, `y` and `z` are passed by keyword,
    and `x` is assumed to be the first parameter not explicitly specified (`x=3`).
    This also demonstrates that parameters passed by keyword can appear in any order.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，参数是通过位置传递的（`x` `=` `2,` `y` `=` `3,` `z` `=` `4`）。在第二种情况下，参数是通过位置传递的，而`z`默认为1。在第三种情况下，参数是通过关键字传递的，而`z`再次默认为1。在最后一种情况下，`y`和`z`是通过关键字传递的，而`x`被认为是第一个未明确指定的参数（`x=3`）。这也表明通过关键字传递的参数可以以任何顺序出现。
- en: Parameters are optional, but you must include the parentheses even if no values
    are being passed. The `return()` function returns the object produced by the function.
    It’s also optional, and if it’s missing, the results of the last statement in
    the function are returned.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是可选的，但即使没有传递值，也必须包含括号。`return()`函数返回函数产生的对象。它也是可选的，如果它缺失，则返回函数中最后一条语句的结果。
- en: 'You can use the `args()` function to view the parameter names and default values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`args()`函数查看参数名称和默认值：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `args()` function is designed for interactive viewing. If you need to obtain
    the parameter names and default values programmatically, use the `formals()` function,
    which returns a list with the necessary information.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`args()`函数是为交互式查看设计的。如果你需要以编程方式获取参数名称和默认值，请使用`formals()`函数，它返回包含必要信息的列表。'
- en: 'Parameters are passed by value, not by reference. Consider this function statement:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是通过值传递，而不是通过引用传递。考虑以下函数声明：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The dataset `women` isn’t accessed directly. A copy is made and passed to the
    function. If the `women` dataset was very large, RAM could be used up quickly.
    This can become an issue when you’re dealing with *big* data problems, and you
    may need to use special techniques (see appendix F).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集`women`不是直接访问的。会创建一个副本并将其传递给函数。如果`women`数据集非常大，RAM可能会迅速耗尽。当你处理*大数据*问题时，这可能会成为一个问题，你可能需要使用特殊技术（见附录F）。
- en: Object scope
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对象作用域
- en: The scope of the objects in R (how names are resolved to produce contents) is
    complex. In the typical case,
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: R中对象的作用域（如何将名称解析为内容）很复杂。在典型情况下，
- en: Objects created outside of any function are global (can be resolved within any
    function). Objects created within a function are local (available only within
    the function).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何函数外部创建的对象是全局的（可以在任何函数中解析）。在函数内部创建的对象是局部的（仅限于函数内部可用）。
- en: Local objects are discarded at the end of function execution. Only objects passed
    back via the `return()` function (or assigned using an operator like `<<-`) are
    accessible after the function finishes executing.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部对象在函数执行结束时会被丢弃。只有通过`return()`函数（或使用像`<<-`这样的运算符）返回的对象在函数执行完成后才能访问。
- en: Global objects can be accessed (read) from within a function but not altered
    (again, unless the `<<-` operator is used).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局对象可以在函数内部访问（读取），但不能修改（再次，除非使用`<<-`运算符）。
- en: Objects passed to a function through parameters aren’t altered by the function.
    Copies of the objects are passed, not the objects themselves.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过参数传递给函数的对象不会被函数修改。传递的是对象的副本，而不是对象本身。
- en: 'Here is a simple example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, a copy of `x` is passed to the function `f``()`, but the original
    isn’t altered. The value of `y` is obtained from the environment. Even though
    `z` exists in the environment, the value set in the function is used and doesn’t
    alter the value in the environment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`x`的副本被传递给函数`f``()`，但原始对象没有被修改。`y`的值是从环境中获得的。尽管`z`存在于环境中，但函数中设置的值被使用，并且不会改变环境中的值。
- en: To understand scoping rules better, we need to discuss environments.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解作用域规则，我们需要讨论环境。
- en: 20.2 Working with environments
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.2 与环境一起工作
- en: An *environment* in R consists of a frame and enclosure. A *frame* is set of
    symbol-value pairs (object names and their contents), and an *enclosure* is a
    pointer to an enclosing environment. The enclosing environment is also called
    the *parent environment*. R allows you to manipulate environments from within
    the language, resulting in fine-grained control over scope and the segregation
    of functions and data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，一个*环境*由一个框架和封装组成。一个*框架*是一组符号值对（对象名称及其内容），而一个*封装*是指向一个封装环境的指针。封装环境也称为*父环境*。R允许你在语言内部操作环境，从而实现对作用域和函数与数据的细粒度控制。
- en: 'In an interactive session, when you first see the R prompt, you’re in the global
    environment. You can create a new environment with the `new.env()` function and
    create assignments in that environment with the `assign()` function. Object values
    can be retrieved from an environment using the `get()` function. Environments
    are data structures that allow you to control object scope (you can also think
    of them as places to store objects). Here’s an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式会话中，当你第一次看到R提示符时，你处于全局环境。你可以使用`new.env()`函数创建一个新的环境，并使用`assign()`函数在该环境中创建赋值。可以使用`get()`函数从环境中检索对象值。环境是允许你控制对象作用域的数据结构（你也可以将它们视为存储对象的地方）。以下是一个例子：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: An object called `x` exists in the global environment and has the value `5`.
    An object also called `x` exists in the environment `myenv` and has the value
    `"Homer"`. Using separate environments keep the two objects from being confused.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`x`的对象存在于全局环境中，其值为`5`。另一个也称为`x`的对象存在于`myenv`环境中，其值为`"Homer"`。使用单独的环境可以防止这两个对象混淆。
- en: In addition to using the `assign``()` and `get()` functions, you can use the
    `$` notation. For example,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`assign()`和`get()`函数外，你还可以使用`$`符号。例如，
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: produces the same results.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 产生相同的结果。
- en: 'The `parent.env()` function displays the parent environment. Continuing the
    example, the parent environment for `myenv` is the global environment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent.env()`函数显示父环境。继续上面的例子，`myenv`的父环境是全局环境：'
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The parent environment for the global environment is the empty environment.
    See `help(environment)` for details.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 全局环境的父环境是空环境。有关详细信息，请参阅`help(environment)`。
- en: 'Because functions are objects, they also have environments. This is important
    when considering *function closures* (functions that are packaged with the state
    that existed when they were created). Consider a function that is created by another
    function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数是对象，它们也有环境。这在考虑*函数闭包*（包含它们创建时存在的状态的函数）时很重要。考虑一个由另一个函数创建的函数：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `trim(p)` function returns a function that trims *p* percent of the high
    and low values from a vector:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim(p)`函数返回一个函数，该函数从向量中裁剪掉*p*百分比的最高和最低值：'
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This works because the value of *p* is in the environment of the `trimit()`
    function and is saved with the function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为*p*的值在`trimit()`函数的环境中，并且与函数一起保存：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The lesson here is that, in R, functions include the objects that existed in
    their environment when they were created. This fact helps to explain the following
    behavior:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，在R中，函数包括它们创建时环境中的对象。这一事实有助于解释以下行为：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `g()` function uses `k=10` no matter what value `k` has in the global environment,
    because `k` equaled 10 when the function was created. Again, you can see this
    with
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`g()`函数无论全局环境中的`k`值是多少，都使用`k=10`，因为当函数创建时`k`等于10。同样，你可以通过以下方式看到这一点：'
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In general, the value of an object is obtained from its local environment. If
    the object isn’t found in its local environment, R searches in the parent environment,
    then the parent’s parent environment, and so on, until the object is found. If
    R reaches the empty environment and still hasn’t found the object, it throws an
    error. This is called *lexical scoping*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对象的值是从其局部环境获得的。如果对象在其局部环境中找不到，R将在父环境中搜索，然后是父父环境，依此类推，直到找到对象。如果R达到空环境但仍未找到对象，它将抛出一个错误。这称为*词法作用域*。
- en: To learn more about environments and lexical scoping, see “Environments in R”
    by Christopher Bare ([http://mng.bz/uPYM](http://mng.bz/uPYM)) and “Lexical Scope
    and Function Closures in R” by Darren Wilkinson ([http://mng.bz/R286](http://mng.bz/R286)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于环境和词法作用域的信息，请参阅 Christopher Bare 的“R 中的环境”([http://mng.bz/uPYM](http://mng.bz/uPYM))
    和 Darren Wilkinson 的“R 中的词法作用域和函数闭包”([http://mng.bz/R286](http://mng.bz/R286))。
- en: 20.3 Non-standard evaluation
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.3 非标准评估
- en: 'R has a default method for when and how to evaluate expressions. Consider the
    following example. Create a function named `mystats`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: R 有一个默认的方法来决定何时以及如何评估表达式。考虑以下示例。创建一个名为 `mystats` 的函数：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, call the function without quoting the value passed to `x`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用函数而不引用传递给 `x` 的值：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: R is greedy. As soon as you use an expression (name or function) as an argument
    to a function, R tries to evaluate it. You get the error because R attempts to
    look up the name `mpg` and doesn’t find it in the workspace (the global environment
    in this case).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: R 是贪婪的。一旦你将表达式（名称或函数）用作函数的参数，R 就会尝试对其进行评估。你得到错误是因为 R 尝试查找名称 `mpg`，但未在工作区（在这种情况下是全局环境）中找到它。
- en: 'If you quote the value passed to `x`, the function runs successfully. String
    literals are simply passed as is (no lookup necessary):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你引用传递给 `x` 的值，函数将成功运行。字符串字面量将直接传递（无需查找）：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is R’s default behavior and is called *standard evaluation (SE**)*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 R 的默认行为，被称为 *标准评估（SE**）*。
- en: 'But what if you really like the first way of calling the function? In this
    case, you could modify the function as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的喜欢第一种调用函数的方式？在这种情况下，你可以按如下方式修改函数：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `substitute()` function passes the object name without evaluating it. The
    name is then converted to a string by `as.character()`. Now both
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`substitute()` 函数传递对象名称而不对其进行评估。然后通过 `as.character()` 将名称转换为字符串。现在两者'
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: and
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: work! This is called *non-standard evaluation (NSE)*. The `library()` function
    uses NSE, which is why both `library(ggplot2)` and `library("ggplot2")` work.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行！这被称为 *非标准评估（NSE）*。`library()` 函数使用 NSE，这就是为什么 `library(ggplot2)` 和 `library("ggplot2")`
    都可以工作。
- en: Why use NSE rather than SE? It basically comes down to ease of use. The following
    two statements are equivalent.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用 NSE 而不是 SE？这基本上归结为易用性。以下两个语句是等价的。
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first statement uses SE, while the second statement uses NSE. The second
    statement is easier to type and possibly easier to read. But to make things easier
    for the user, the programmer must work harder when creating the functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句使用 SE，而第二个语句使用 NSE。第二个语句更容易输入，可能也更容易阅读。但为了使用户更容易使用，程序员在创建函数时必须更加努力。
- en: Base R has several functions for controlling how and when expressions are evaluated.
    Tidyverse packages such as `dplyr`, `tidyr`, and `ggplot2` use their own version
    of NSE called *tidy evaluation*. If you want to include functions from tidyverse
    in your own functions, you’ll have to use the tools automatically provided by
    the `rlang` package for that purpose.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 有几个函数用于控制表达式何时以及如何被评估。Tidyverse 包如 `dplyr`、`tidyr` 和 `ggplot2` 使用它们自己的
    NSE 版本，称为 *tidy evaluation*。如果你想在你的函数中包含 tidyverse 的函数，你必须使用 `rlang` 包自动提供的工具。
- en: In particular, you can use the `enquo()` and `!!` to quote and unquote arguments.
    For example,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，你可以使用 `enquo()` 和 `!!` 来引用和取消引用参数。例如，
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: works fine. Try it out.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行正常。试一试。
- en: 'For multiple arguments, use `enquos()` and `!!!` to quote and unquote the values
    passed to `...` . The 3 dots are a placeholder for one or more arguments (names
    or expressions) passed to a function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个参数，使用 `enquos()` 和 `!!!` 来引用和取消引用传递给 `...` 的值。三个点是一个占位符，用于表示传递给函数的一个或多个参数（名称或表达式）：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Recent versions of `rlang` provide shortcuts. The previous functions can also
    be written as
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`rlang` 的最新版本提供了快捷方式。之前的函数也可以写成如下形式'
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The two pairs of curly braces and three-dot notation eliminate the need to explicitly
    use `enquo()` and `enquos()`, but they won’t work with versions of `rlang` older
    than 0.4.0.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 两对花括号和三点符号消除了显式使用 `enquo()` 和 `enquos()` 的需要，但它们不会与 `rlang` 0.4.0 之前的版本一起工作。
- en: R gives the programmer considerable control over how and when code is evaluated.
    But with great power comes great responsibility (and a dull ache behind the eyes).
    NSE is a very complex topic, and this section has only touched on elements frequently
    encountered when writing your own functions. To learn more, see the discussions
    by Brodie Gaslam ([www.brodieg.com/2020/05/05/on-nse/](http://www.brodieg.com/2020/05/05/on-nse/))
    and Hadley Wickham ([http://adv-r.hadley.nz](http://adv-r.hadley.nz)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: R语言赋予程序员对代码如何以及何时被评估的相当大的控制权。但是，权力越大，责任也越大（并且眼睛后面会有一种钝痛感）。非线性结构方程模型（NSE）是一个非常复杂的话题，本节仅简要介绍了在编写自己的函数时经常遇到的一些元素。要了解更多信息，请参阅Brodie
    Gaslam的讨论（[www.brodieg.com/2020/05/05/on-nse/](http://www.brodieg.com/2020/05/05/on-nse/））和Hadley
    Wickham的讨论（[http://adv-r.hadley.nz](http://adv-r.hadley.nz)）。
- en: 20.4 Object-oriented programming
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.4 面向对象编程
- en: R is an *object-oriented programming (OOP)* language that’s based on the use
    of generic functions. Each object has a class attribute that is used to determine
    what code to run when a copy of the object is passed to a generic function such
    as `print``()`, `plot``()`, or `summary``()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: R语言是一种基于通用函数使用的面向对象编程（OOP）语言。每个对象都有一个类属性，用于确定当将对象的副本传递给通用函数（如`print()`、`plot()`或`summary()`）时运行什么代码。
- en: R has several OOP models, including S3, S4, RC, and R6\. The S3 model is older,
    simpler, and less structured. The S4 model is newer and more structured. Both
    come with base R. The S3 approach is easier to use, and most applications in R
    use this model. In this section, we’ll focus on the S3 model and end with a brief
    discussion of its limitations and how the S4 attempts to address them. RC and
    R6 are less widely used and not covered here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: R语言有几种面向对象编程（OOP）模型，包括S3、S4、RC和R6。S3模型较老，更简单，结构更少。S4模型较新，结构更复杂。两者都包含在基础R语言中。S3方法更容易使用，并且R语言中的大多数应用都使用这种模型。在本节中，我们将重点关注S3模型，并在最后简要讨论其局限性和S4如何尝试解决这些问题。RC和R6使用较少，这里不做介绍。
- en: 20.4.1 Generic functions
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.4.1 通用函数
- en: 'R uses the class of an object to determine what action to take when a generic
    function is called. Consider the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: R语言使用对象的类来确定在调用通用函数时要采取什么行动。考虑以下代码：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the first instance, the `summary()` function produces descriptive statistics
    for each variable in the data frame `women`. In the second instance, `summary()`
    produces a description of a linear regression model. How does this happen?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，`summary()`函数为数据框`women`中的每个变量生成描述性统计量。在第二种情况下，`summary()`生成线性回归模型的描述。这是如何发生的？
- en: 'Let’s look at the code for `summary()`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`summary()`的代码：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let’s look at the class for the `women` data frame and the `fit` object:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`women`数据框和`fit`对象的类：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The function `call` `summary(women)` executes the function `summary.data.frame`
    `(women)` if it exists, or `summary.default(women)` otherwise. Similarly, `summary
    (fit`) executes the function `summary.lm(fit``)` if it exists, or `summary.default
    (fit)` otherwise. The `UseMethod()` `function` dispatches the object to the generic
    function that has an extension matching the object’s class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`call` `summary(women)`如果存在，将执行函数`summary.data.frame(women)`，否则执行`summary.default(women)`。同样，`summary(fit)`如果存在，将执行函数`summary.lm(fit)`，否则执行`summary.default(fit)`。`UseMethod()`函数将对象调度到具有与对象类匹配扩展的通用函数。
- en: 'To list all S3 generic functions available, use the `methods()` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有可用的S3通用函数，请使用`methods()`函数：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The number of functions returned depends on the packages you have installed
    on your machine. On my computer, separate `summary()` functions have been defined
    for 33 classes!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的函数数量取决于您在计算机上安装的包。在我的计算机上，已经为33个类定义了单独的`summary()`函数！
- en: You can view the code for the functions in the previous example by typing their
    names without the parentheses (`summary.data.frame`, `summary.lm`, and `summary
    .default`). Nonvisible functions (functions in the methods list followed by asterisks)
    can’t be viewed this way. In these cases, you can use the `getAnywhere()` function
    to view their code. To see the code for `summary.ecdf()`, type `getAnywhere(summary.ecdf)`.
    Viewing existing code is a great way to get ideas for your own functions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过不使用括号（`summary.data.frame`，`summary.lm`和`summary .default`）输入函数名来查看前一个示例中函数的代码。不可见函数（方法列表中带有星号的函数）不能这样查看。在这种情况下，您可以使用`getAnywhere()`函数来查看它们的代码。要查看`summary.ecdf()`的代码，请输入`getAnywhere(summary.ecdf)`。查看现有代码是获取您自己函数灵感的好方法。
- en: You’ve seen classes such as `numeric`, `matrix`, `data.frame`, `array`, `lm`,
    `glm`, and `table`, but the class of an object can be any arbitrary string. Additionally,
    a generic function doesn’t have to be `print()`, `plot()`, or `summary()`. Any
    function can be generic. The following listing defines a generic function called
    `mymethod()`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `numeric`、`matrix`、`data.frame`、`array`、`lm`、`glm` 和 `table` 等类，但对象的类可以是任何任意字符串。此外，通用函数不必是
    `print()`、`plot()` 或 `summary()`。任何函数都可以是通用的。以下列表定义了一个名为 `mymethod()` 的通用函数。
- en: Listing 20.2 An example of an arbitrary generic function
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.2 一个任意通用函数的示例
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Defines a generic function
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个通用函数
- en: ❷ Assigns classes to objects
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将类分配给对象
- en: ❸ Applies the generic function to the objects
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将通用函数应用于对象
- en: ❹ Applies the generic function to an object with two classes
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将通用函数应用于具有两个类的对象
- en: ❺ Generic function has no default for class "c"
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通用函数对类 "c" 没有默认值
- en: In this example, `mymethod()` generic functions are defined for objects of classes
    `a` and `b`. A d`efault()` function is also defined ❶. The objects `x`, `y`, and
    `z` are then defined, and a class is assigned to `x` and `y` ❷. Next, `mymethod()`
    is applied to each object, and the appropriate function is called ❸. The default
    method is used for object `z` because the object has class `integer`, and no `mymethod.integer()`
    function has been defined.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为类 `a` 和 `b` 的对象定义了 `mymethod()` 通用函数。还定义了一个 `default()` 函数 ❶。然后定义了对象
    `x`、`y` 和 `z`，并将一个类分配给 `x` 和 `y` ❷。接下来，将 `mymethod()` 应用到每个对象上，并调用适当的函数 ❸。对于对象
    `z` 使用默认方法，因为该对象具有 `integer` 类，且没有定义 `mymethod.integer()` 函数。
- en: An object can be assigned to more than one class (for example, building, residential,
    and commercial). How does R determine which generic function to call in such a
    case? When `z` is assigned two classes ❹, the first class is used to determine
    which generic function to call. In the final example ❺, there is no `mymethod.c()`
    function, so the next class in line (`a`) is used. R searches the class list from
    left to right, looking for the first available generic function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以被分配到多个类中（例如，建筑、住宅和商业）。R 如何在这种情况下确定调用哪个通用函数？当 `z` 被分配两个类 ❹ 时，第一个类用于确定调用哪个通用函数。在最后的例子
    ❺ 中，没有 `mymethod.c()` 函数，所以使用下一个类（`a`）。R 从左到右搜索类列表，寻找第一个可用的通用函数。
- en: 20.4.2 Limitations of the S3 model
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.4.2 S3 模型的局限性
- en: 'The primary limitation of the S3 object model is the fact that any class can
    be assigned to any object. There are no integrity checks. In the next example,
    the data frame `women` is assigned class `lm`, which is nonsensical and leads
    to errors:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: S3 对象模型的主要局限性是任何类都可以分配给任何对象。没有完整性检查。在下一个例子中，数据框 `women` 被分配了 `lm` 类，这是不合理的，会导致错误：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The S4 OOP model is more formal and rigorous and designed to avoid the difficulties
    raised by the S3 method’s less structured approach. In the S4 approach, classes
    are defined as abstract objects that have slots containing specific types of information
    (that is, typed variables). Object and method constructions are formally defined,
    with rules that are enforced. But programming using the S4 model is more complex
    and restrictive. To learn more about the S4 OOP model, see “A (Not So) Short Introduction
    to S4” by Chistophe Genolini ([http://mng.bz/1VkD](http://mng.bz/1VkD)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: S4 面向对象模型更加正式和严谨，旨在避免 S3 方法非结构化方法带来的困难。在 S4 方法中，类被定义为包含特定类型信息的抽象对象（即类型变量）。对象和方法构造形式上定义，并强制执行规则。但使用
    S4 模型进行编程更为复杂和受限。要了解更多关于 S4 面向对象模型的信息，请参阅 Chistophe Genolini 所著的《（并非如此）简短的 S4
    介绍》（[http://mng.bz/1VkD](http://mng.bz/1VkD)）。
- en: 20.5 Writing efficient code
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.5 编写高效的代码
- en: 'There is a saying among programmers: “A power user is someone who spends an
    hour tweaking their code so that it runs a second faster.” R is a spritely language,
    and most R users don’t have to worry about writing efficient code. The easiest
    way to make your code run faster is to beef up your hardware (RAM, processor speed,
    and so on). As a general rule, it’s more important to write code that is understandable
    and easy to maintain than to optimize its speed. But when you’re working with
    large datasets or highly repetitive tasks, speed can become an issue.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序员中有一句话：“一个高级用户会花一个小时调整他们的代码，使其运行快一秒。” R 是一种敏捷的语言，大多数 R 用户不必担心编写高效的代码。使你的代码运行更快的最简单方法是增强你的硬件（RAM、处理器速度等）。一般来说，编写易于理解和维护的代码比优化其速度更重要。但在处理大型数据集或高度重复的任务时，速度可能成为一个问题。
- en: 'Several coding techniques can help to make your programs more efficient:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 几种编码技术可以帮助使你的程序更高效：
- en: Read in only the data you need.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读取你需要的数据。
- en: Use vectorization rather than loops whenever possible.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下使用向量化而不是循环。
- en: Create objects of the correct size rather than resizing repeatedly.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建正确大小的对象，而不是反复调整大小。
- en: Use parallelization for repetitive, independent tasks.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行化处理重复的独立任务。
- en: Let’s look at each one in turn.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每个部分。
- en: 20.5.1 Efficient data input
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.5.1 高效的数据输入
- en: When importing data, read only the data you need and provide as much information
    to the importing function as possible. Additionally, choose an optimized function
    whenever possible.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入数据时，只读取你需要的数据，尽可能向导入函数提供更多信息。另外，尽可能选择优化的函数。
- en: Suppose you want to access three numeric variables (age, height, weight), two
    character variables (race, sex), and one date variable (dob) from a comma-delimited
    text file containing a large number of variables and rows. The `read.csv` (base
    R), `fread` (`data.table` package) and `read_csv` (`readr` package) functions
    will all do the job, but the latter two are significantly faster when you’re working
    with large files.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要从一个包含大量变量和行的逗号分隔文本文件中访问三个数值变量（年龄、身高、体重）、两个字符变量（种族、性别）和一个日期变量（出生日期）。`read.csv`（基础
    R）、`fread`（`data.table` 包）和 `read_csv`（`readr` 包）函数都可以完成这项工作，但后两者在处理大型文件时速度要快得多。
- en: Additionally, you can speed up your code by selecting only the variables necessary
    and indicating their types (so the function does not have to spend time guessing).
    For example,
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以通过仅选择必要的变量并指定它们的类型（这样函数就不必花费时间猜测）来加快你的代码速度。例如，
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: will run faster than
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将会比
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: alone. Here `i=integer`, `d=double`, `c=character`, and `D=Date`. See `?read`_csv
    for additional variable types.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 单独。在这里 `i=整数`，`d=双精度浮点数`，`c=字符`，`D=日期`。参见 `?read`_csv 获取其他变量类型的信息。
- en: 20.5.2 Vectorization
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.5.2 向量化
- en: Use vectorization rather than loops whenever possible. Here, *vectorization*
    means using R functions that are designed to process vectors in a highly optimized
    manner. Examples in the base installation include `ifelse()`, `colSums()`, `colMeans()`,
    `rowSums()`, and `rowMeans()`. The `matrixStats` package offers optimized functions
    for many additional calculations, including counts, sums, products, measures of
    central tendency and dispersion, quantiles, ranks, and binning. Packages such
    as `dplyr` and `data.table` also provide functions that are highly optimized.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下使用向量化而不是循环。在这里，*向量化*意味着使用设计为以高度优化的方式处理向量的 R 函数。基安装中的示例包括 `ifelse()`、`colSums()`、`colMeans()`、`rowSums()`
    和 `rowMeans()`。`matrixStats` 包提供了许多额外计算的优化函数，包括计数、总和、乘积、集中趋势和离散度度量、分位数、排名和分箱。`dplyr`
    和 `data.table` 等包也提供了高度优化的函数。
- en: 'Consider a matrix with 1 million rows and 10 columns. Let’s calculate the column
    sums using loops and again using the `colSums()` function. First, create the matrix:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个有 100 万行和 10 列的矩阵。让我们使用循环和 `colSums()` 函数再次计算列和。首先，创建矩阵：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, create a function called `accum``()` that uses `for` loops to obtain
    the column sums:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `accum``()` 的函数，该函数使用 `for` 循环来获取列和：
- en: '[PRE62]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `system.time()` function can be used to determine the amount of CPU and
    real time needed to run the function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`system.time()` 函数可以用来确定运行函数所需的 CPU 和实际时间：'
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Calculating the same sums using the `colSums()` function produces
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `colSums()` 函数计算相同的和
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: On my machine, the vectorized function ran more than 1,200 times faster. Your
    mileage may vary.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，向量化函数运行速度比之前快了超过 1,200 倍。你的结果可能会有所不同。
- en: 20.5.3 Correctly sizing objects
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.5.3 正确地设置对象大小
- en: 'It’s more efficient to initialize objects to their required final size and
    fill in the values than it is to start with a smaller object and grow it by appending
    values. Let’s say you have a vector `x` with 100,000 numeric values. You want
    to obtain a vector `y` with the squares of these values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化对象到它们所需的最终大小并填充值比从较小的对象开始并追加值来增长对象更有效率。假设你有一个包含 100,000 个数值的向量 `x`。你想要得到一个包含这些值的平方的向量
    `y`：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'One approach is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法如下：
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`y` starts as a one-element vector and grows to be a 100,000-element vector
    containing the squared values of `x`. It takes about 10 seconds on my machine.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`y` 开始是一个包含一个元素的向量，并增长到包含 `x` 的平方值的 100,000 个元素的向量。在我的机器上大约需要 10 秒。'
- en: If you first initialize `y` to be a vector with 100,000 elements,
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你首先将 `y` 初始化为一个包含 100,000 个元素的向量，
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: the same calculations take less than a second. You avoid the considerable time
    it takes R to continually resize the object.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的计算不到一秒钟即可完成。您避免了R不断调整对象大小所花费的大量时间。
- en: If you use vectorization,
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用向量化，
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: the process is even faster. Note that operations like exponentiation, addition,
    multiplication, and the like are all vectorized functions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程甚至更快。请注意，指数、加法、乘法等操作都是向量化函数。
- en: 20.5.4 Parallelization
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.5.4 并行化
- en: '*Parallelization* involves chunking up a task, running the chunks simultaneously
    on two or more cores, and combining the results. The cores might be on the same
    computer or on different machines in a cluster. Tasks that require the repeated
    independent execution of a numerically intensive function are likely to benefit
    from parallelization. This includes many Monte Carlo methods, including bootstrapping.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行化*涉及将任务分成块，同时在两个或更多核心上同时运行这些块，并合并结果。这些核心可能位于同一台计算机上，也可能位于集群中不同的机器上。需要重复独立执行数值密集型函数的任务可能从并行化中受益。这包括许多蒙特卡洛方法，包括自助法。'
- en: 'Many packages in R support parallelization (see “CRAN Task View: High Performance
    and Parallel Computing with R” by Dirk Eddelbuettel, [http://mng.bz/65sT](http://mng.bz/65sT)).
    In this section, you’ll use the `foreach` and `doParallel` packages to see parallelization
    on a single computer. The `foreach` package supports the `foreach` looping construct
    (iterating over the elements in a collection) and facilitates executing loops
    in parallel. The `doParallel` package provides a parallel back end for the `foreach`
    package.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: R中的许多包支持并行化（参见Dirk Eddelbuettel的“CRAN任务视图：使用R进行高性能和并行计算”，[http://mng.bz/65sT](http://mng.bz/65sT)）。在本节中，您将使用`foreach`和`doParallel`包来查看单台计算机上的并行化。`foreach`包支持`foreach`循环结构（遍历集合中的元素）并简化了并行执行循环。`doParallel`包为`foreach`包提供并行后端。
- en: In principal components and factor analysis, a critical step is identifying
    the appropriate number of components or factors to extract from the data (see
    section 14.2.1). One approach involves repeatedly performing an *eigenanalysis*
    of correlation matrices derived from random data that have the same number of
    rows and columns as the original data. The following listing shows the analysis,
    which compares parallel and nonparallel versions. To execute this code, you’ll
    need to install both packages.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在主成分分析和因子分析中，一个关键步骤是确定从数据中提取适当数量的成分或因子（参见第14.2.1节）。一种方法涉及反复对具有与原始数据相同行数和列数的随机数据导出的相关矩阵进行特征值分析。以下列表显示了分析，它比较了并行和非并行版本。要执行此代码，您需要安装这两个包。
- en: Listing 20.3 Parallelization with `foreach` and `doParallel`
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.3 使用`foreach`和`doParallel`进行并行化
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ❶ Loads packages and registers the number of cores
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载包并注册核心数
- en: ❷ Defines the function
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义函数
- en: ❸ Executes normally
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 正常执行
- en: ❹ Executes in parallel
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 并行执行
- en: First, the packages are loaded, and the number of cores (four on my machine)
    is registered ❶. Next, the function for the eigenanalysis is defined ❷. Here,
    100,000 × 100 random data matrices are analyzed. The `eig()` function is executed
    500 times using `foreach` and `%do%` ❸. The `%do%` operator runs the function
    sequentially, and the `.combine=rbind` option appends the results to object `x`
    as rows. Finally, the function is run in parallel using the `%dopar%` operator
    ❹. In this case, parallel execution was about 2.5 times faster than sequential
    execution.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，加载了包，并注册了核心数（在我的机器上是四个）❶。接下来，定义了用于特征值分析的函数❷。在这里，分析了100,000 × 100个随机数据矩阵。使用`foreach`和`%do%`执行了500次`eig()`函数❸。`%do%`运算符按顺序运行函数，`.combine=rbind`选项将结果作为行追加到对象`x`中。最后，使用`%dopar%`运算符并行运行该函数❹。在这种情况下，并行执行比顺序执行快约2.5倍。
- en: In this example, each iteration of the `eig()` function was numerically intensive,
    didn’t require access to other iterations, and didn’t involve disk I/0\. This
    is the type of situation that benefits most from parallelization. The downside
    of parallelization is that it can make the code less portable—there is no guarantee
    that others will have the same hardware configuration you do.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`eig()`函数的每次迭代都是数值密集型的，不需要访问其他迭代，也不涉及磁盘I/O。这是从并行化中受益最大的那种情况。并行化的缺点是它可能会使代码的可移植性降低——没有保证其他人会有与您相同的硬件配置。
- en: The four efficiency measures described in this section can help with everyday
    coding problems. But they only go so far in helping you to process really large
    datasets (for example, those in the terabyte range). When you’re working with
    *big* datasets, methods like those described in appendix F are required.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的四个效率度量可以帮助解决日常编码问题。但它们在帮助你处理真正的大型数据集（例如，那些在太字节范围内的数据集）方面只能走这么远。当你处理 *大型*
    数据集时，需要使用附录 F 中描述的方法。
- en: Locating bottlenecks
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 定位瓶颈
- en: “Why is my code taking so long?” R provides tools for profiling programs to
    identify the most time-consuming functions. Place the code to be profiled between
    `Rprof()` and `Rprof(NULL)`. Then execute `summaryRprof()` to get a summary of
    the time spent executing each function. See `?Rprof` and `?summaryRprof` for details.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: “为什么我的代码运行这么慢？” R 提供了用于分析程序以识别最耗时函数的工具。将需要分析的代码放在 `Rprof()` 和 `Rprof(NULL)`
    之间。然后执行 `summaryRprof()` 以获取每个函数执行时间的摘要。有关详细信息，请参阅 `?Rprof` 和 `?summaryRprof`。
- en: Rstudio can also profile your code. Select *Start Profiling* from the RStudio
    Profile menu, run your code, and click the red *Stop Profiling* button when finished.
    The results are presented in a table and a graph.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Rstudio 也可以分析你的代码。从 RStudio 的分析菜单中选择 *开始分析*，运行你的代码，完成后点击红色 *停止分析* 按钮。结果会以表格和图形的形式展示。
- en: Efficiency is little comfort when a program won’t execute or gives nonsensical
    results. Methods for uncovering programming errors are considered next.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序无法执行或给出无意义的结果时，效率就变得微不足道了。接下来将考虑揭示编程错误的方法。
- en: 20.6 Debugging
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.6 调试
- en: '*Debugging* is the process of finding and reducing the number of errors or
    defects in a program. It would be wonderful if programs worked the first time.
    It would also be wonderful if unicorns lived in my neighborhood. In all but the
    simplest programs, errors occur. Determining the cause of these errors and fixing
    them is time consuming. In this section, we’ll look at common sources of errors
    and tools that can help to uncover errors.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试* 是寻找和减少程序中错误或缺陷数量的过程。如果程序一开始就能正常工作那将是极好的。如果独角兽住在我的邻居家那也会很棒。但在除了最简单的程序之外的所有程序中，都会发生错误。确定这些错误的原因并修复它们是耗时的。在本节中，我们将探讨常见的错误来源以及可以帮助揭示错误的工具。'
- en: 20.6.1 Common sources of errors
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.6.1 常见错误来源
- en: 'The following are some common reasons functions fail in R:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在 R 中函数失败的一些常见原因：
- en: An object name is misspelled, or the object doesn’t exist.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象名称拼写错误，或者对象不存在。
- en: One or more parameters in the function call are misspecified. This can happen
    if parameter names are misspelled, required parameters are omitted, parameter
    values are the wrong type (e.g., a vector when a list is required), or parameter
    values are entered in the wrong order (when parameter names are omitted).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用中的一个或多个参数指定不当。这可能发生在参数名称拼写错误、省略了必需的参数、参数值类型错误（例如，需要一个列表时却提供了一个向量），或者参数值输入顺序错误（当省略了参数名称时）。
- en: The contents of an object aren’t what the user expects. In particular, errors
    are often caused by passing objects that are `NULL` or contain `NaN` or `NA` values
    to a function that can’t handle them.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的内容不是用户预期的。特别是，错误通常是由于传递了 `NULL` 或包含 `NaN` 或 `NA` 值的对象给无法处理这些值的函数而引起的。
- en: The third reason is more common than you may think. It results from R’s terse
    approach to errors and warnings.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个原因比你想象的更常见。这是由于 R 对错误和警告的简洁处理方式导致的。
- en: 'Consider the following example. For the `mtcars` dataset in the base installation,
    you want to provide the variable `am` (transmission type) with a more informative
    title and labels. Next, you want to compare the gas mileage of cars with automatic
    transmissions to those with manual transmissions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。对于基础安装中的 `mtcars` 数据集，你想要为变量 `am`（变速类型）提供一个更具信息量的标题和标签。接下来，你想要比较自动变速汽车和手动变速汽车的油耗：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Yikes! (Embarrassing, but this is actually what I said.) What happened?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！（尴尬，但这就是我说的。）发生了什么？
- en: 'You didn’t get an “Object xxx not found” error, so you probably didn’t misspell
    a function, data frame, or variable name. Let’s look at the data that was passed
    to the `aov()` function:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有收到“对象 xxx 未找到”的错误，所以你可能没有拼写函数、数据框或变量名。让我们看看传递给 `aov()` 函数的数据：
- en: '[PRE71]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There are no cars with a manual transmission. Looking back at the original dataset,
    the variable `am` is coded `0=automatic`, `1=manual` (not `1=automatic`, `2=manual`).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 没有手动变速的汽车。回顾原始数据集，变量 `am` 被编码为 `0=自动`，`1=手动`（而不是 `1=自动`，`2=手动`）。
- en: The `factor()` function happily did what you asked without warnings or errors.
    It set all cars with manual transmissions to automatic and all cars with automatic
    transmissions to missing. With only one group available, the analysis of variance
    failed. Confirming that each input to a function contains the expected data can
    save you hours of frustrating detective work.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`factor()` 函数愉快地完成了您的要求，没有警告或错误。它将所有手动变速的汽车设置为自动变速，所有自动变速的汽车设置为缺失。由于只有一个组可用，方差分析失败了。确认函数的每个输入都包含预期的数据可以为您节省数小时的令人沮丧的侦探工作。'
- en: 20.6.2 Debugging tools
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.6.2 调试工具
- en: Although examining object names, function parameters, and function inputs will
    uncover many sources of error, sometimes you must delve into the inner workings
    of functions and functions that call functions. In these cases, the internal debugger
    that comes with R can be useful. Table 20.1 lists some helpful debugging functions.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然检查对象名称、函数参数和函数输入可以揭示许多错误来源，但有时您必须深入了解函数及其调用函数的内部工作原理。在这些情况下，R 伴随的内部调试器可能很有用。表
    20.1 列出了一些有用的调试函数。
- en: Table 20.1 Built-in debugging functions
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 表 20.1 内置调试函数
- en: '| Function | Action |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 操作 |'
- en: '| `debug``()` | Marks a function for debugging |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `debug()` | 标记函数为调试 |'
- en: '| `undebug``()` | Unmarks a function for debugging |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `undebug()` | 取消标记函数为调试 |'
- en: '| `browser``()` | Allows single-stepping through the execution of a function.
    While you’re debugging, typing `n` or pressing the Enter key executes the current
    statement and moves on to the next. Typing `c` continues execution to the end
    of the function without single-stepping. Typing `where` displays the call stack,
    and `Q` halts execution and jumps to the top level immediately. Other R commands
    like `ls()`, `print()`, and assignment statements can also be submitted at the
    debugger prompt. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `browser()` | 允许逐行执行函数的执行。在调试过程中，输入 `n` 或按 Enter 键执行当前语句并进入下一行。输入 `c` 继续执行到函数的末尾而不逐行执行。输入
    `where` 显示调用堆栈，而 `Q` 立即停止执行并跳转到顶层。其他 R 命令如 `ls()`、`print()` 和赋值语句也可以在调试器提示符下提交。|'
- en: '| `trace``()` | Modifies a function to allow debug code to be temporarily inserted
    |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `trace()` | 修改函数以允许临时插入调试代码 |'
- en: '| `untrace``()` | Cancels tracing and removes the temporary code |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `untrace()` | 取消跟踪并删除临时代码 |'
- en: '| `traceback``()` | Prints the sequence of function calls that led to the last
    uncaught error |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `traceback()` | 打印导致最后一个未捕获错误的函数调用序列 |'
- en: The `debug()` function marks a function for debugging. When the function is
    executed, the `browser()` function is called and allows you to step through the
    function’s execution one line at a time. The `undebug()` function turns this off,
    allowing the function to execute normally. You can temporarily insert debugging
    code into a function with the `trace()` function. This is particularly useful
    when you’re debugging base functions and CRAN-contributed functions that can’t
    be edited directly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug()` 函数将函数标记为调试。当函数执行时，会调用 `browser()` 函数，允许您逐行执行函数的执行。`undebug()` 函数关闭此功能，允许函数正常执行。您可以使用
    `trace()` 函数临时将调试代码插入到函数中。这在调试无法直接编辑的基函数和 CRAN 贡献函数时特别有用。'
- en: If a function calls other functions, it can be hard to determine where an error
    has occurred. In this case, executing the `traceback()` function immediately after
    an error will list the sequence of function calls that led to the error. The last
    call is the one that produced the error.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数调用其他函数，确定错误发生的位置可能很困难。在这种情况下，错误发生后立即执行 `traceback()` 函数将列出导致错误的函数调用序列。最后一个调用是产生错误的调用。
- en: Let’s look at an example. The `mad()` function calculates the median absolute
    deviation for a numeric vector. You’ll use `debug``()` to explore how this function
    works. The following listing displays the debugging session.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。`mad()` 函数计算数值向量的中值绝对偏差。您将使用 `debug()` 来探索这个函数的工作方式。以下列表显示了调试会话。
- en: Listing 20.4 A sample debugging session
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.4 一个示例调试会话
- en: '[PRE72]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ❶ Views the formal arguments
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查看形式参数
- en: ❷ Sets the function to debug
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置要调试的函数
- en: ❸ Lists objects
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 列出对象
- en: ❹ Single-steps through the code
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 单步执行代码
- en: ❺ Resumes continuous execution
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 恢复连续执行
- en: First, the `arg()` function is used to display the argument names and default
    values for the `mad()` function ❶. The debug flag is then set using `debug(mad)`
    ❷. Now, whenever `mad``()` is called, the `browser()` function is executed, allowing
    you to step through the function a line at a time.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `arg()` 函数显示 `mad()` 函数的参数名称和默认值 ❶。然后使用 `debug(mad)` 设置调试标志 ❷。现在，每次调用
    `mad()` 时，都会执行 `browser()` 函数，允许您逐行遍历函数。
- en: When `mad``()` is called, the session goes into `browser()` mode. The code for
    the function is listed but not executed. Additionally, the prompt changes to `Browse[n]>`,
    where `n` indicates the *browser level*. The number increments with each recursive
    call.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `mad()` 时，会话进入 `browser()` 模式。函数的代码被列出但不会执行。此外，提示符更改为 `Browse[n]>`，其中 `n`
    表示 *浏览器级别*。该数字随着每次递归调用而递增。
- en: In `browser()` mode, other R commands can be executed. For example, `ls``()`
    lists the objects in existence at a given point during the function’s execution
    ❸. Typing an object’s name displays its contents. If an object is named `n`, `c`,
    or `Q`, you must use `print(n)`, `print(c)`, or `print(Q)` to view its contents.
    You can change the values of objects by typing assignment statements.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `browser()` 模式下，可以执行其他 R 命令。例如，`ls()` 列出函数执行过程中给定点的存在对象 ❸。键入对象名称将显示其内容。如果对象名称为
    `n`、`c` 或 `Q`，您必须使用 `print(n)`、`print(c)` 或 `print(Q)` 来查看其内容。您可以通过键入赋值语句来更改对象值。
- en: You step through the function and execute the statements one at a time by entering
    the letter `n` or pressing the Return or Enter key ❹. The `where` statement indicates
    where you are in the stack of function calls being executed. With a single function,
    this isn’t very interesting, but if you have functions that call other functions,
    it can be helpful.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键入字母 `n` 或按 Return 或 Enter 键，您可以逐行执行函数中的语句 ❹。`where` 语句指示您在正在执行的函数调用栈中的位置。对于单个函数，这并不很有趣，但如果您有调用其他函数的函数，它可能很有帮助。
- en: Typing `c` moves out of single-step mode and executes the remainder of the current
    function ❺. Typing `Q` exits the function and returns you to the R prompt.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 键入 `c` 将退出单步模式并执行当前函数的剩余部分 ❺。键入 `Q` 将退出函数并返回到 R 提示符。
- en: The `debug()` function is useful when you have loops and want to see how values
    are changing. You can also embed the `browser()` function directly in code to
    help locate a problem. Let’s say that you have a variable `X` that should never
    be negative. Adding the code
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug()` 函数在您有循环并想查看值如何变化时很有用。您还可以直接在代码中嵌入 `browser()` 函数以帮助定位问题。假设您有一个变量
    `X`，它应该永远不会是负数。添加以下代码'
- en: '[PRE73]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: allows you to explore the current state of the function when the problem occurs.
    You can take out the extra code when the function is sufficiently debugged. (I
    originally wrote “fully debugged,” but this almost never happens, so I changed
    it to “sufficiently debugged” to reflect a programmer’s reality.)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您在问题发生时探索函数的当前状态。当函数足够调试后，您可以移除额外的代码。（我最初写了“完全调试”，但这几乎从未发生，所以我将其改为“足够调试”，以反映程序员的现实。）
- en: 20.6.3 Session options that support debugging
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.6.3 支持调试的会话选项
- en: When you have functions that call functions, two session options can help in
    debugging. Normally, when R encounters an error, it prints an error message and
    exits the function. Setting `options(error=traceback)` prints the call stack (the
    sequence of function calls that led to the error) as soon as an error occurs.
    This can help you determine which function generated the error.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有调用函数的函数时，两个会话选项可以帮助调试。通常，当 R 遇到错误时，它会打印错误消息并退出函数。设置 `options(error=traceback)`
    会在错误发生时立即打印调用栈（导致错误的函数调用序列）。这可以帮助您确定哪个函数生成了错误。
- en: Setting `options(error=recover)` also prints the call stack when an error occurs.
    In addition, it prompts you to select one of the functions on the list and then
    invokes `browser()` in the corresponding environment. Typing `c` returns you to
    the list, and typing `0` quits back to the R prompt.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `options(error=recover)` 也会在发生错误时打印调用栈。此外，它会提示您从列表中选择一个函数，然后在相应的环境中调用 `browser()`。键入
    `c` 将您返回到列表，而键入 `0` 则退出回到 R 提示符。
- en: Using this `recover()` mode lets you explore the contents of any object in any
    function chosen from the sequence of functions called. By selectively viewing
    the contents of objects, you can frequently determine the origin of the problem.
    To return to R’s default state, set `options(error=NULL)`. The next listing shows
    a toy example.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`recover()`模式让你可以探索从调用函数序列中选择的任何函数中的任何对象的内容。通过选择性地查看对象的内容，你通常可以确定问题的来源。要返回R的默认状态，设置`options(error=NULL)`。下一个列表显示了一个玩具示例。
- en: Listing 20.5 Sample debugging session with `recover()`
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.5 使用`recover()`的示例调试会话
- en: '[PRE74]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ❶ Creates functions
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建函数
- en: ❷ Enters values that cause an error
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输入导致错误的值
- en: ❸ Examines rnorm()
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查`rnorm()`
- en: ❹ Examines h(z)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查`h(z)`
- en: ❺ Examines g(z)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查`g(z)`
- en: ❻ Examines f(2, -3)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查`f(2, -3)`
- en: The code first creates a series of functions. Function `f``()` calls function
    `g()`. Function `g``()` calls function `h``()`. Executing `f(2,` `3)` works fine,
    but `f(2,` `-3)` throws an error. Because of `options(error=recover)`, the interactive
    session is immediately moved into recover mode. The function call stack is listed,
    and you can choose which function to examine in `browser()` mode.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建了一系列函数。函数`f()`调用函数`g()`。函数`g()`调用函数`h()`。执行`f(2, 3)`没有问题，但`f(2, -3)`会抛出错误。由于设置了`options(error=recover)`，交互式会话立即进入恢复模式。函数调用堆栈被列出，你可以选择在`browser()`模式下检查哪个函数。
- en: Typing `4` moves you into the `rnorm()` function, where `ls``()` lists the objects;
    you can see that `n` `=` `-1`, which isn’t allowed in `rnorm()`. This is clearly
    the problem, but to see how `n` became -1, you move up the stack.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`4`将你移动到`rnorm()`函数中，其中`ls()`列出对象；你可以看到`n`等于`-1`，这在`rnorm()`中是不允许的。这显然是问题所在，但要看到`n`如何变成-1，你需要向上查看调用堆栈。
- en: Typing `c` returns you to the menu, and typing `3` moves you into the `h(z)`
    function, where `x` `=` `-1`. Typing `c` and `2` moves you into the `g(z)` function.
    Here, both `x` and `z` are –1\. Finally, moving up to the `f(2,` `-3)` function
    reveals that `z` is –1 because `x` `=` `2` and `y` `=` `-3`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`c`返回菜单，输入`3`将你移动到`h(z)`函数中，其中`x`等于`-1`。输入`c`和`2`将你移动到`g(z)`函数中。在这里，`x`和`z`都是-1。最后，向上移动到`f(2,
    -3)`函数，可以看到`z`是-1，因为`x`等于`2`且`y`等于`-3`。
- en: Note the use of `print``()` to view the function code. This is useful when you’re
    debugging code that you didn’t write. Normally, you can type the function name
    to view the code. In this example, `f` is a reserved word in browser mode that
    means “finish execution of the current loop or function”; the `print()` function
    is used explicitly to escape this special meaning.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用`print()`来查看函数代码。当你调试的不是自己编写的代码时，这很有用。通常，你可以输入函数名来查看代码。在这个例子中，`f`是浏览器模式中的一个保留词，表示“完成当前循环或函数的执行”；这里显式使用`print()`函数来避免这个特殊含义。
- en: Finally, `c` takes you back to the menu, and `0` returns you to the normal R
    prompt. Alternatively, typing `Q` at any time returns you to the R prompt.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按`c`键返回菜单，按`0`键返回正常的R提示符。或者，在任何时候输入`Q`键也可以返回R提示符。
- en: To learn more debugging in general and recover mode in particular, see Roger
    Peng’s excellent “An Introduction to the Interactive Debugging Tools in R” ([http://mng.bz/GPR6](http://mng.bz/GPR6)).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于一般调试和特定于恢复模式的调试信息，请参阅Roger Peng的出色文章“R交互式调试工具简介”（[http://mng.bz/GPR6](http://mng.bz/GPR6)）。
- en: 20.6.4 Using RStudio’s visual debugger
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.6.4 使用RStudio的视觉调试器
- en: In addition to the tools described so far, RStudio offers visual support for
    debugging that parallels the material in the previous sections.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面描述的工具之外，RStudio还提供了与前面章节中材料平行的视觉调试支持。
- en: First, let’s debug the `mad()` function in base R.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们调试基础R中的`mad()`函数。
- en: '[PRE75]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The RStudio interface changes (see figure 20.2).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio界面发生变化（见图20.2）。
- en: '![](Images/CH20_F02_Kabacoff3.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/CH20_F02_Kabacoff3.png)'
- en: Figure 20.2 Visually debugging the `mad()` function in RStudio
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.2 在RStudio中可视化调试`mad()`函数
- en: The upper-left pane shows the current function. A green arrow indicates the
    current line. The upper-right pane shows the objects in the function’s environment
    and their values at the current line. As you execute each line of the function,
    these values will change. The lower-right pane shows the call stack. Since there
    is only one function, this is uninteresting. Finally, the lower-left pane displays
    the console in browser mode. This is where you will spend most of your time.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 上左窗格显示当前函数。一个绿色箭头指示当前行。上右窗格显示函数环境中的对象及其在当前行的值。随着您执行函数的每一行，这些值将发生变化。右下窗格显示调用栈。由于只有一个函数，这并不有趣。最后，左下窗格显示浏览器模式的控制台。这是您将花费大部分时间的地方。
- en: You can enter each of the commands from the previous two sections at the browser
    prompt in the console window. Alternatively, you can click on the code execution
    icons at the top of this pane (see figure 20.2). From left to right, they will
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在控制台窗口的浏览器提示符中输入前两个部分中的每个命令。或者，您也可以点击此窗格顶部的代码执行图标（见图 20.2）。从左到右，它们将
- en: Execute the next line of code
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行下一行代码
- en: Step into the current function call
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入当前函数调用
- en: Execute the remainder of the current function or loop
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行当前函数或循环的剩余部分
- en: Continue execution until the next breakpoint (not covered here)
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续执行直到下一个断点（此处未涉及）
- en: Exit debug mode
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出调试模式
- en: In this way, you can step through your function and observe what happens after
    each line of code in executed.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，您可以逐步执行函数并观察每行代码执行后的情况。
- en: Next, let’s debug the code in listing 20.5.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调试列表 20.5 中的代码。
- en: '[PRE76]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The interface changes to look like figure 20.3.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 界面将变为类似于图 20.3 的样子。
- en: The function displayed in the upper-left pane is the function that threw the
    error. Since functions call other functions, the call stack is now interesting.
    By clicking on a function’s call stack window (lower-right pane), you can view
    the code in each function, the order they are called, and the values that they
    pass. When a function is highlighted in the traceback list, the values of its
    objects will be displayed in the environment window in the upper-right pane. In
    this way, you can watch what happens as functions are called and values are passed
    until the error occurs.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 上左窗格显示的函数是引发错误的函数。由于函数会调用其他函数，因此调用栈现在变得有趣。通过点击函数的调用栈窗口（右下窗格），您可以查看每个函数中的代码、它们的调用顺序以及它们传递的值。当函数在回溯列表中高亮显示时，其对象的值将在右上窗格的环境窗口中显示。这样，您可以观察函数调用和值传递的过程，直到错误发生。
- en: To learn more about RStudio’s visual debugger, see the article “Debugging with
    RStudio IDE” ([http://mng.bz/4M65](http://mng.bz/4M65)) and the video “Introduction
    to debugging in R” ([http://mng.bz/Q2R1](http://mng.bz/Q2R1)).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 RStudio 可视化调试器的信息，请参阅文章“使用 RStudio IDE 调试”([http://mng.bz/4M65](http://mng.bz/4M65))和视频“R
    调试简介”([http://mng.bz/Q2R1](http://mng.bz/Q2R1))。
- en: '![](Images/CH20_F03_Kabacoff3.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH20_F03_Kabacoff3.png)'
- en: Figure 20.3 Visually reviewing the call stack in RStudio. The function `f(2,-3)`
    calls `g(z)`, which calls `h(z)`, which calls `rnorm(x)`, which is where the error
    occurs. You can see each function and its values by clicking on the appropriate
    line in the Traceback panel.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.3 在 RStudio 中可视化查看调用栈。函数 `f(2,-3)` 调用 `g(z)`，它又调用 `h(z)`，然后调用 `rnorm(x)`，这是错误发生的地方。您可以通过点击回溯面板中的适当行来查看每个函数及其值。
- en: 20.7 Going further
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.7 进一步学习
- en: There are several excellent sources of information on advanced programming in
    R. The R Language Definition ([http://mng.bz/U4Cm](http://mng.bz/U4Cm)) is a good
    place to start. “Frames, environments, and scope in R and S-PLUS” by John Fox
    ([http://mng.bz/gxw8](http://mng.bz/gxw8)) is a great article for gaining a better
    understanding of scope. “How R searches and finds stuff” by Suraj Gupta ([http://mng.bz/2o5B](http://mng.bz/2o5B))
    is a blog article that can help you understand just what the title implies. To
    learn more about efficient coding, see “FasteR! HigheR! StrongeR!—A Guide to Speeding
    Up R Code for Busy People” by Noam Ross ([http://mng.bz/Iq3i](http://mng.bz/Iq3i)).
    Finally, two books are very helpful. *Advanced R* by Hadley Wickham ([https://adv-r.hadley.nz/](https://adv-r.hadley.nz/))
    and *R Programming for Bioinformatics* (Chapman & Hall, 2009) by Robert Gentleman
    are comprehensive, yet highly accessible texts for programmers who want to look
    under the hood. I highly recommend them for anyone who wants to become a more
    effective R programmer.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 R 的高级编程，有多个优秀的信息来源。R 语言定义（[http://mng.bz/U4Cm](http://mng.bz/U4Cm)）是一个很好的起点。“R
    和 S-PLUS 中的框架、环境和作用域”由 John Fox 撰写（[http://mng.bz/gxw8](http://mng.bz/gxw8)），是一篇很好的文章，可以帮助你更好地理解作用域。“R
    搜索和查找内容”由 Suraj Gupta 撰写（[http://mng.bz/2o5B](http://mng.bz/2o5B)），是一篇博客文章，可以帮助你理解标题所暗示的内容。要了解更多关于高效编码的信息，请参阅
    Noam Ross 撰写的“FasteR! HigheR! StrongeR!—A Guide to Speeding Up R Code for Busy
    People”（[http://mng.bz/Iq3i](http://mng.bz/Iq3i)）。最后，两本书非常有帮助。*高级 R* 由 Hadley
    Wickham 撰写（[https://adv-r.hadley.nz/](https://adv-r.hadley.nz/)）和 *R Programming
    for Bioinformatics*（Chapman & Hall，2009）由 Robert Gentleman 撰写，是程序员想要深入了解的全面且易于理解的文本。我强烈推荐它们给任何想要成为更有效的
    R 编程人员。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: R has a rich variety of data structures, including atomic and generic vectors.
    Learning how to extract information from them is a key skill for effective R programming.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 有丰富的数据结构，包括原子和泛型向量。学习如何从中提取信息是有效 R 编程的关键技能。
- en: Every R object has a class and optional attributes.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 R 对象都有一个类和可选的属性。
- en: Control structures such as `for()` and `if()/else()` allow you execute code
    conditionally and nonsequentially.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构如 `for()` 和 `if()/else()` 允许你条件性地和非顺序地执行代码。
- en: Environments provide a mechanism for looking up object names and their contents.
    They provide fine control of the scope of names and functions.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境提供了一种查找对象名称及其内容的机制。它们提供了对名称和函数作用域的精细控制。
- en: R has several systems for object-oriented programming. The S3 system is the
    most common by far.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 有几个面向对象编程的系统。其中，S3 系统是最常见的。
- en: Nonstandard evaluation allows the programmer to customize how and when expressions
    are evaluated.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非标准评估（nonstandard evaluation）允许程序员自定义表达式如何以及何时被评估。
- en: Two ways to speed up your code are vectorization and parallel processing. Profiling
    your code can help you find speed bottlenecks.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速代码的两种方法是矢量化（vectorization）和并行处理（parallel processing）。对代码进行性能分析可以帮助你找到速度瓶颈。
- en: R has a rich variety of debugging tools. RStudio provides graphic interfaces
    to these tools. Together, they make finding logic and coding errors easier (but
    rarely easy!).
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 有丰富的调试工具。RStudio 提供了这些工具的图形界面。它们共同使得查找逻辑和编码错误变得更加容易（但很少容易！）。
