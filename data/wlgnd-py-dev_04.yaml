- en: '3 The API: Let’s talk'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 API：让我们来谈谈
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding APIs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解API
- en: Identifying a well-designed API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别设计良好的API
- en: Creating good APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建良好的API
- en: Communicating with people through the spoken and written word, gestures, expressions,
    and inflection is one of the cornerstones of our advancement as a species. Even
    across different languages and cultures, we can communicate with each other, perhaps
    with a bit more effort, but we can learn to convey meaning, intent, information,
    goals, and more.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过口头和书面语言、手势、表情和语调与人沟通，是我们物种进步的基石之一。即使跨越不同的语言和文化，我们也可以相互沟通，可能需要更多的努力，但我们可以学会传达意义、意图、信息、目标等等。
- en: The evolution of computers has also created many and varied ways for us to communicate
    with a computer, and it with us. Keyboards, mice, touchpads, voice, screens, printers,
    networks, motion sensors, and more are all devices that have different uses for
    providing communication between people and computers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的发展也为我们与计算机以及与我们的交流创造了多种多样的方式。键盘、鼠标、触摸板、语音、屏幕、打印机、网络、运动传感器等等，都是用于在人与计算机之间提供不同用途的设备。
- en: All these devices are examples of interfaces designed to convey information
    to and from a computer system. Keyboards provide a mechanical way for us to enter
    the written word into a system. A computer mouse provides one way to indicate
    gestures and events to a computer system. A display screen provides a way for
    the computer to represent digital information so we can receive it. Speakers give
    a computer an interface to produce audio information.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设备都是设计用来在计算机系统之间传递信息和接收信息的接口的例子。键盘为我们提供了将书面文字输入系统的机械方式。计算机鼠标提供了一种向计算机系统指示手势和事件的方式。显示屏为计算机提供了一种表示数字信息的方式，以便我们接收它。扬声器为计算机提供了一个产生音频信息的接口。
- en: All the complexities of capturing a keystroke, positioning the mouse pointer
    on the computer display, or generating a sound from a computer are simplified,
    hidden, and provided by the interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有捕捉按键、在计算机显示上定位鼠标指针或从计算机生成声音的复杂性都被简化、隐藏并由接口提供。
- en: Interfaces exist to receive information, act on it, and send back results. The
    interfaces we’ve talked about so far are essential to computer users. As developers,
    we also use interfaces that exist at a deeper, and more abstract, level of computer
    systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接口用于接收信息、对其采取行动，并返回结果。我们之前讨论过的接口对于计算机用户来说是必不可少的。作为开发者，我们也使用存在于计算机系统更深层次和更抽象层面的接口。
- en: The operating system of a computer provides hundreds, perhaps thousands, of
    interfaces that give access to all the services and functionality of which the
    computer is capable. Access to the filesystem, and ultimately the storage system,
    of a computer is provided to applications through an interface. If a computer
    is connected to a network, applications use interfaces to access those networks.
    If an application renders visual information, interfaces present that information
    onto the connected displays. These kinds of interfaces fall under the larger general
    category called application programming interfaces, or APIs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的操作系统提供了数百甚至数千个接口，这些接口提供了计算机能够提供的一切服务和功能。通过接口，应用程序可以访问文件系统，最终是存储系统。如果计算机连接到网络，应用程序使用接口来访问这些网络。如果应用程序渲染视觉信息，接口将这些信息呈现到连接的显示器上。这些类型的接口属于更大的通用类别，称为应用程序编程接口，或API。
- en: 3.1 Starting a conversation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 开始对话
- en: A computer screen provides a level of abstraction between how the user sees
    things and how the computer represents things. A mouse provides a level of abstraction
    between our hand movements and button clicks to the computer that is translated
    as selections and events.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机屏幕在用户看到的事物和计算机表示事物之间提供了一个抽象层次。鼠标在手的移动和按钮点击与计算机之间提供了一个抽象层次，这些动作被翻译为选择和事件。
- en: An API provides the same kinds of abstraction. However, it does so not between
    a person and a computer but between sections of programming code. All programs
    are composed of custom code, modules, and libraries of existing code. Even the
    most straightforward Python program performing a `print("Hello` `World")` is using
    standard library code provided with the Python language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: API提供了相同类型的抽象。然而，它并不是在人与计算机之间，而是在编程代码的不同部分之间进行。所有程序都是由自定义代码、模块和现有代码库组成的。即使是执行`print("Hello
    World")`的最简单的Python程序，也在使用Python语言提供的标准库代码。
- en: Having library code is a huge advantage that allows you to focus on what you’re
    trying to accomplish rather than coding everything yourself. Imagine having to
    write a `print` function every time you start a new project or having to create
    something quite complex like network access.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有库代码是一个巨大的优势，它让你能够专注于你试图完成的事情，而不是自己编写所有代码。想象一下，每次开始一个新项目时都必须编写一个`print`函数，或者必须创建像网络访问这样相当复杂的东西。
- en: Python is well-known for having “batteries included,” meaning it comes with
    an extensive and powerful standard library of modules providing all kinds of functionality
    you can use and not have to create yourself. There’s also a large selection of
    modules you can install from the Python Package Index ([https://pypi.org/](https://pypi.org/))
    that cover diverse and well-supported areas of interest.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python因其“内置电池”而闻名，这意味着它附带了一个广泛且强大的标准库模块，提供了你可以使用而无需自己创建的所有种类的功能。还有大量你可以从Python包索引([https://pypi.org/](https://pypi.org/))安装的模块，涵盖了各种多样且得到良好支持的兴趣领域。
- en: tip Using existing library code and modules is a cornerstone of being a well-grounded
    developer. Existing code is often well-tested and used successfully in many applications.
    There is no sense in reinventing the wheel when a perfectly good wheel, or wheels,
    are readily available.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：使用现有的库代码和模块是成为一名扎实开发者的基石。现有的代码通常经过良好的测试，并在许多应用程序中成功使用。当有现成的、完美的轮子可用时，没有必要重新发明轮子。
- en: Because of these numerous modules, Python is sometimes called a “glue language”
    as it creates interesting ways to connect powerful libraries of code together.
    Thinking of Python as a glue language doesn’t diminish its power but instead shows
    its versatility.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些众多的模块，Python有时被称为“胶水语言”，因为它创造了将强大的代码库连接起来的有趣方式。将Python视为胶水语言并不会削弱其力量，反而显示了其多功能性。
- en: Python as a glue language is possible because of the API that the modules support,
    like calling `print("Hello World")`. This calls the `print` function, passing
    the literal string argument `"Hello World"`, abstracting the complexities of outputting
    text to a display. The API that a module supports makes it possible to use complex,
    sophisticated code in your programs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python作为胶水语言之所以可能，是因为模块支持的API，例如调用`print("Hello World")`。这调用`print`函数，传递字面字符串参数`"Hello
    World"`，抽象化了将文本输出到显示器的复杂性。模块支持的API使得在程序中使用复杂、高级的代码成为可能。
- en: 3.1.1 A contract between pieces of code
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 代码片段之间的合同
- en: Aside from the rather abstract discussion about what an API is, let’s review
    what it is in practice. One way to think about it is to consider an API as a contract
    between your code and another piece of code whose functionality you want to use.
    Like a contract between people, it specifies if one party does this, then the
    other party does that.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于API是什么的相对抽象的讨论之外，让我们回顾一下它在实际中的样子。一种思考方式是将API视为你自己的代码和另一段你想要使用的功能的代码之间的合同。就像人与人之间的合同一样，它规定了如果一方这样做，另一方就会那样做。
- en: In programming terms, this often means that when calling a function or method
    in a particular way, it performs some work and returns some information or both.
    In Python, when you create a function to be used elsewhere in your code, you’ve
    created an API. The name you give the function expresses some meaning about what
    the API does. The function’s input arguments pass information to the API to specify
    the work to perform and the data to perform it on. If the function returns information,
    this is the output of the API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，这通常意味着以特定方式调用函数或方法时，它会执行一些工作并返回一些信息，或者两者兼而有之。在Python中，当你创建一个在其他代码部分使用的函数时，你就创建了一个API。你给函数取的名字表达了API所做的一些含义。函数的输入参数将信息传递给API，以指定要执行的工作以及执行它的数据。如果函数返回信息，这就是API的输出。
- en: This idea of passing information into a piece of code and getting information
    or an action out of it has existed in computer science for a long time and is
    known as the “black-box” model. The input a black box expects and the output it
    creates is understood well enough that knowing what goes on inside isn’t necessary.
    Only the behavior needs to be known, not the implementation. The term *black box*
    comes from the idea that the internals of the invoked functionality are opaque
    and blocked from view, as illustrated by figure 3.1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将信息传递到一段代码中并从中获取信息或执行动作的想法在计算机科学中已经存在很长时间，被称为“黑盒”模型。黑盒期望的输入和它创建的输出已经足够了解，以至于了解内部发生的事情不是必要的。只需要了解行为，而不是实现。术语*黑盒*来自这样的想法，即被调用的功能内部是透明的，并且阻止了视图，如图3.1所示。
- en: '![](../../OEBPS/Images/CH03_F01_Farrell.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F01_Farrell.png)'
- en: Figure 3.1 Representation of the black-box concept of functionality hiding
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 功能隐藏的黑盒概念表示
- en: As a developer, you don’t have to know about the internal implementation of
    the `print()` function. You only need to know that passing the function a string
    invokes its default behavior—printing that string to the screen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，您不必了解`print()`函数的内部实现。您只需要知道传递字符串到函数会调用其默认行为——将该字符串打印到屏幕上。
- en: A local API is a function or class you create or a module your code imports.
    The API is within the context of your program code and is accessed directly by
    calling the functions and class instance methods provided.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本地API是您创建的函数或类，或者您代码导入的模块。API位于您的程序代码上下文中，并且可以通过调用提供的函数和类实例方法直接访问。
- en: It’s also possible to call an API that’s hosted remotely—for example, connecting
    to a database server and accessing data. Here, the API is accessed over a network
    connection providing the transport mechanisms for your code to make calls to the
    remote API and for the API to respond. We’ll get more into this in chapter 10,
    specifically about databases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以调用远程托管的服务器上的API——例如，连接到数据库服务器并访问数据。在这里，API通过网络连接访问，为您的代码调用远程API以及API响应提供传输机制。我们将在第10章中更深入地探讨这一点，特别是关于数据库的内容。
- en: 3.1.2 What’s passed as input
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 输入传递的内容
- en: When your code calls a function or method of an API, it’s engaging in one part
    of the contract between your program and the functionality provided by the API.
    The input arguments are the information passed from the context of your program
    code to the context of the API through the parameters. In developer terms, arguments
    are the values passed to a function, and parameters are the names given to those
    arguments when the function is defined.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的代码调用API的函数或方法时，它正在参与您程序与API提供的功能之间的合同的一部分。输入参数是从您的程序代码上下文通过参数传递到API上下文的信息。在开发者的术语中，参数是传递给函数的值，而参数是在定义函数时给这些参数赋予的名称。
- en: 'Python functions and methods support positional and keyword parameters. The
    order of the positional parameters and names of the keyword parameters are considerations
    when using and building an API. For example, Python’s `print` function is most
    often used like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数和方法支持位置参数和关键字参数。在使用和构建API时，位置参数的顺序和关键字参数的名称是需要考虑的因素。例如，Python的`print`函数通常是这样使用的：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When this function executes, it prints the string variable `msg` to the screen.
    The API provided by the `print` function is simple enough to understand; it takes
    the input argument and performs the work necessary to output it to the screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个函数执行时，它将字符串变量`msg`打印到屏幕上。`print`函数提供的API足够简单，易于理解；它接受输入参数并执行必要的操作以将其输出到屏幕。
- en: 'The complete API of the `print` function shows that it is a more versatile
    function. Here is the `print` function signature:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`函数的完整API显示它是一个更通用的函数。以下是`print`函数的签名：'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This signature indicates that the first parameter is a tuple of non-keyword
    parameters followed by additional keyword parameters with default values. The
    `*objects` parameter allows the caller to pass multiple, comma-separated values
    to the `print` function. This means
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此签名表示第一个参数是一个非关键字参数的元组，后面跟着具有默认值的额外关键字参数。`*objects`参数允许调用者向`print`函数传递多个以逗号分隔的值。这意味着
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: outputs the same thing to the display as
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Calling the `print` function this way works because the function iterates through
    the `objects` tuple parameter, converting each to a string if necessary, and outputs
    each object to `sys.stdout` (the screen). Each output item is separated by the
    default separator string, a space character.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式调用 `print` 函数是可行的，因为该函数会遍历 `objects` 元组参数，如果需要，将每个对象转换为字符串，并将每个对象输出到 `sys.stdout`（屏幕）。每个输出项之间用默认的分隔符字符串，一个空格字符分隔。
- en: The `sep='` `'` parameter provides the default space separator string and lets
    you change it to something else to separate the objects when they are output to
    the screen. The `end='\n'` parameter provides a carriage return as the default
    to end the output and lets you change how the output ends.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`sep=''''` 参数提供了默认的空格分隔符字符串，并允许您将其更改为其他内容，以便在将对象输出到屏幕时分隔它们。`end=''\n''` 参数提供了默认的回车符以结束输出，并允许您更改输出的结束方式。'
- en: The `file=sys.stdout` parameter defines the default destination, called standard
    output, which is usually the screen. Changing this parameter lets you change that
    destination. The object you set the file parameter equal to must have a `write(string)`
    method for it to work as a file destination. If the object doesn’t have a `write(string)`
    method, an `AttributeError` exception is raised when the `print` function is called.
    The `flush=False` parameter provides a way to forcibly push what’s sent to the
    stream to the output destination rather than buffering it if set to `True`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`file=sys.stdout` 参数定义了默认的目标位置，称为标准输出，通常是指屏幕。更改此参数可以让您更改该目标。您设置的文件参数必须具有 `write(string)`
    方法才能作为文件目标工作。如果对象没有 `write(string)` 方法，当调用 `print` 函数时将引发 `AttributeError` 异常。`flush=False`
    参数提供了一种强制将发送到流中的内容推送到输出目标而不是缓冲它的方法，如果设置为 `True`。'
- en: All of this tells us the `print` function API is well-designed and surprisingly
    powerful. The use of the initial non-keyword `*objects` tuple, followed by the
    keyword parameters with default values, lets you use the `print` function’s most
    common use case. The rest of the functionality is there if needed but can be ignored
    otherwise.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都告诉我们 `print` 函数的API设计得很好，而且出人意料地强大。使用初始的非关键字 `*objects` 元组，然后是具有默认值的键控参数，可以让您使用
    `print` 函数最常用的场景。如果需要，其余的功能都在那里，否则可以忽略。
- en: 'Imagine if the `print` function was handled differently. A naïve API implementation
    might remove all the keyword parameters with default values and look something
    like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `print` 函数的处理方式不同。一个简单的API实现可能会移除所有具有默认值的键控参数，看起来可能像这样：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A `print` function like this would satisfy the common use case but would start
    to fall apart beyond that. Suppose not long after this version is in use, you
    need to print more than one object at a time. One way to extend the simple implementation
    is to create additional `print` function variations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的 `print` 函数可以满足常见的使用场景，但超出这个范围就会开始出现问题。假设在这个版本投入使用不久后，您需要一次打印多个对象。扩展简单实现的一种方法是为
    `print` 函数创建额外的变体：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What if additional requirements were placed on this naïve expansion of the
    API to have a different separator character, perhaps the pipe character (|)? Following
    the established simple variation pattern would lead to something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对这种原始的API扩展添加额外的要求，使其使用不同的分隔符字符，比如管道字符（|），会怎样呢？遵循既定的简单变化模式会导致类似以下的结果：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This solution doesn’t scale well, and the code that uses this would have to
    change to use a different permutation of the API. The goal of this example is
    not to show the progression down an ill-conceived path of API development but
    to draw closer attention to the details of what makes Python’s default `print`
    function a good API. There is work going on inside the `print` function to support
    the function signature and the use cases where it’s applied.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的可扩展性不好，使用此代码的人必须更改代码以使用API的不同排列。本例的目标不是展示API开发不良路径的进展，而是更密切地关注使Python的默认
    `print` 函数成为良好API的细节。在 `print` 函数内部正在进行一些工作，以支持函数签名及其应用的使用场景。
- en: This is one of the earmarks of a good API. It provides useful functionality
    that can be expanded upon without exposing the work involved in doing so. As a
    developer, you don’t have to worry too much about how the `print` function works.
    You get to use it, knowing its functionality is well defined and contained.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是良好API的一个标志。它提供了可以扩展的有用功能，而无需暴露实现这些功能的工作。作为一个开发者，您不必过多担心 `print` 函数的工作方式。您可以使用它，知道其功能定义良好且封装良好。
- en: tip Designing a good API takes work, especially if other developers will be
    using it. Everything you want an API to do should be part of the interface. If
    a developer has to use some internal part of the API to achieve a goal, then that
    API has become a problem. Any change to the API’s internal functioning has the
    potential to break code that depends on the internal part that’s being used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：设计一个好的API需要付出努力，尤其是如果其他开发者将使用它。API想要执行的所有操作都应该是接口的一部分。如果开发者必须使用API的某些内部部分来实现目标，那么该API就变成了一个问题。对API内部功能的任何更改都有可能破坏依赖于所使用内部部分的代码。
- en: When developing an API, how you define the input can dramatically influence
    its utility and future use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发API时，您如何定义输入可以极大地影响其效用和未来的使用。
- en: 3.1.3 What’s expected as output
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 预期的输出
- en: 'The other part of the contract provided by an API is its output. The output
    of a function consists of three parts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: API提供的合同中的另一部分是其输出。函数的输出包括三个部分：
- en: Return value
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值
- en: Actions on the system, sometimes thought of as side effects
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对系统的操作，有时被认为是副作用
- en: Exceptions
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Return value
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值
- en: 'The most commonly considered output of a function is the return value—for example,
    this code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数最常见的输出结果是返回值——例如，以下代码：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code looks like a mathematical expression, and that’s very close to what
    it’s modeled after. The input to the `abs` function is a number, and the output
    is the absolute value of that number.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像是一个数学表达式，这非常接近它所模仿的。`abs`函数的输入是一个数字，输出是该数字的绝对值。
- en: A great deal of programming is creating and using functions that accept parameters,
    processing those parameters, and returning the results. Building an application
    is a process of orchestrating function calls and feeding the returned values into
    other functions until you arrive at the desired outcome.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的编程工作涉及创建和使用接受参数的函数，处理这些参数，并返回结果。构建应用程序是一个协调函数调用并将返回值输入到其他函数中的过程，直到达到预期的结果。
- en: Because everything in Python is an object, a function return value is also an
    object. This means you can build a function as part of your API that returns more
    than just a single scalar value, like the `abs` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python中的所有内容都是一个对象，所以函数的返回值也是一个对象。这意味着您可以在API中构建一个函数，该函数返回的不仅仅是单个标量值，就像`abs`函数一样。
- en: 'One example commonly seen in Python is to return a tuple. Returning a tuple
    allows you to pass back more than one value to the calling function, which can
    then unpack the tuple into variables. Here’s some code from `examples/CH_03/example_01.py`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中常见的一个例子是返回一个元组。返回一个元组允许您将多个值传递回调用函数，然后可以解包元组到变量中。以下是从`examples/CH_03/example_01.py`中的代码：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `split_fullname()` function takes in a full name and returns the name parts,
    `fname`, `mname,` and `lname`. Even if the `full_name` parameter contains only
    one or two parts of a name, the function behaves correctly. If there are only
    two parameters, it assumes the second is the last name and sets `mname` to an
    empty string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`split_fullname()`函数接受一个全名并返回姓名部分，`fname`、`mname`和`lname`。即使`full_name`参数只包含姓名的一个或两个部分，该函数也能正确运行。如果有两个参数，它假定第二个是姓氏，并将`mname`设置为空字符串。'
- en: The use case shows how the tuple returned by the function can be unpacked into
    three variables. You can also assign the return value from `split_fullname()`
    to a single tuple variable, but it’s often useful to unpack the returned tuple
    directly into waiting named variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用例展示了函数返回的元组如何解包到三个变量中。您也可以将`split_fullname()`的返回值赋给一个单一的元组变量，但通常将返回的元组直接解包到等待的命名变量中更有用。
- en: Actions on the system
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对系统的操作
- en: Many API functions perform work to transform data passed to them, create new
    data, or perform calculations based on the data passed. This new, or transformed,
    data is returned to the caller of the API for further processing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 许多API函数执行工作以转换传递给它们的数据，创建新数据，或根据传递的数据执行计算。这种新数据或转换后的数据被返回给API的调用者以进行进一步处理。
- en: API functions can also perform actions on the system it’s running on. For example,
    if you are using an API that is part of a robot and call a function to rotate
    a motor attached to that robot, you’d expect the motor to start rotating.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: API函数也可以对其运行的系统执行操作。例如，如果您正在使用一个机器人API，并调用一个函数来旋转连接到该机器人的电机，您会期望电机开始旋转。
- en: The actions taken by API functions are what make applications useful. The ability
    to open, create, read, and write files; interact with networks; print documents;
    and control real-world devices are all actions an application can execute using
    API functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: API 函数采取的操作使得应用程序变得有用。能够打开、创建、读取和写入文件；与网络交互；打印文档；以及控制现实世界设备都是应用程序可以使用 API 功能执行的操作。
- en: An API function performing an action doesn’t necessarily have to return any
    data to the caller if its primary purpose is to perform that action. That doesn’t
    mean it can’t return output data. The API function for the robot motor example
    could return a `True` or `False` value to indicate whether the motor is rotating.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行操作的 API 函数不一定必须向调用者返回任何数据，如果其主要目的是执行该操作。这并不意味着它不能返回输出数据。例如，用于机器人电机示例的 API
    函数可以返回 `True` 或 `False` 值，以指示电机是否正在旋转。
- en: Exceptions
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 异常
- en: Exceptions and how to handle them are a fact of life as a developer. Disk drives
    fail, networks can be unreliable, and any number of other unexpected behaviors
    can occur.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 异常及其处理是作为开发者生活的一部分。磁盘驱动器会失败，网络可能不可靠，以及可能发生任何数量的其他意外行为。
- en: The API functionality you create can generate exceptions from operations, such
    as dividing by zero or raising exceptions, because the functionality created an
    unexpected or exceptional state. When creating an API function, one of your goals
    is to prevent exceptions when you can and handle them gracefully when you can’t.
    For example, if your functionality is performing network IO and the network becomes
    unreliable, what can you do?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的 API 功能可以从操作中生成异常，例如除以零或引发异常，因为功能创建了一个意外或异常的状态。在创建 API 函数时，你的目标之一是在可能的情况下防止异常，在无法处理时优雅地处理它们。例如，如果你的功能正在执行网络
    I/O，而网络变得不可靠，你能做什么？
- en: One possibility is to retry the operation several times with a gradually longer
    timeout between retries. If the network stabilizes within the retry attempt intervals,
    the function can continue and succeed. However, if the retries fail, a network
    exception is raised and passed upward to the caller. On the other hand, if a divide-by-zero
    exception is raised because of an input parameter, there’s nothing you can do
    but let the exception bubble upward to a higher-level functionality that can handle
    it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是尝试操作多次，并在重试之间逐渐增加超时时间。如果在重试尝试间隔内网络稳定，则函数可以继续并成功。然而，如果重试失败，则会引发网络异常并将其传递给调用者。另一方面，如果由于输入参数导致除以零异常，你除了让异常向上冒泡到可以处理它的更高层功能之外，别无他法。
- en: Handling an exception involves knowing whether you can do something about it.
    Never silence an exception without having a specific reason for doing so; this
    throws away information and makes an API untrustworthy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常涉及了解你是否可以对此采取行动。在没有特定原因的情况下，永远不要静默异常；这样做会丢弃信息，并使 API 不可信。
- en: Users of your API need to be aware of and prepared to handle the exceptions
    your API generates, as they do with any other exceptional condition when developing.
    Documenting your API is an excellent way to inform its users what exceptions they
    might expect. Exceptions are covered in more detail in chapter 5.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 API 用户需要意识到并准备好处理你的 API 生成的异常，就像他们在开发过程中处理任何其他异常情况一样。记录你的 API 是一种很好的方式，可以通知用户他们可能期望的异常。异常在第五章中进行了更详细的介绍。
- en: 3.2 Function API
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 函数 API
- en: Functions provide the mechanism to interface with an API. In object-oriented
    programming (OOP), where you think about methods on an object, they are functions
    tied to that object instance. Let’s spend some time talking about ideas you can
    put in place to create useful functions and, by extension, good APIs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数提供了与 API 交互的机制。在面向对象编程（OOP）中，当你考虑对象上的方法时，它们是与该对象实例相关联的函数。让我们花些时间讨论你可以实施的想法来创建有用的函数，以及通过扩展，创建好的
    API。
- en: 3.2.1 Naming
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 命名
- en: As we talked about in the previous chapter, names matter in development. How
    you name the functions you create goes a long way toward making sense of your
    API.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的那样，在开发中名称很重要。你创建的函数的命名对于理解你的 API 至关重要。
- en: Function names should use meaningful words and use the `snake_case` format.
    There is no reason to shorten the name with abbreviations. Every modern code editor
    has autocompletion abilities, making typing the full name a one-time-only occurrence
    at the time of function definition.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名应使用有意义的单词，并使用 `snake_case` 格式。没有必要用缩写来缩短名称。每个现代代码编辑器都有自动完成功能，这使得在函数定义时只需一次性输入完整名称。
- en: Using domain-specific acronyms is also discouraged, as users who aren’t familiar
    with the API domain would find the naming conventions confusing. For example,
    most people would recognize a variable name of `url` to mean a string containing
    the URL of a website. A variable name of `agtc`, an acronym used in genome research,
    would be less meaningful to many people.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定领域的缩写词也是不推荐的，因为不熟悉 API 领域的用户会发现命名约定令人困惑。例如，大多数人会认为变量名 `url` 表示包含网站 URL 的字符串。变量名
    `agtc`，这是基因组研究中使用的缩写词，对许多人来说意义不大。
- en: The name indicates, or hints at, the use case of the function, what it returns,
    and what it accepts. Additionally, the documentation string (docstring) can elaborate
    further on the intended use. In Python, a function docstring is a triple, quoted
    string containing information about a function, and it immediately follows the
    function definition. When function name collisions are possible because the logical
    name choice is similar, or the same, use namespaces and separate the functionality
    into modules.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 名称表明或暗示了函数的使用场景、它返回的内容以及它接受的内容。此外，文档字符串（docstring）可以进一步阐述预期的用途。在 Python 中，函数文档字符串是一个包含有关函数信息的三个引号字符串，它紧随函数定义之后。当逻辑名称选择相似或相同时，可能存在函数名称冲突，这时可以使用命名空间并将功能分离到模块中。
- en: 3.2.2 Parameters
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 参数
- en: When creating a function to provide an API for some functionality you want to
    encapsulate, you can think about the Python `print` function presented earlier.
    That seemingly simple function offers a surprising amount of functionality because
    of the interface definition and the way the encapsulated code is built. There
    are four ways to pass arguments to the functions you create.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个函数以提供封装某些功能的 API 时，你可以考虑之前提到的 Python `print` 函数。这个看似简单的函数因为接口定义和封装代码的构建方式，提供了令人惊讶的功能。你可以通过四种方式向创建的函数传递参数。
- en: Positional parameters
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数
- en: 'These are the most common forms of parameters used with functions, and they
    help define usability. Here is an example function definition with positional
    parameters:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与函数一起使用的最常见参数形式，它们有助于定义可用性。以下是一个使用位置参数的函数定义示例：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The name of the function indicates what it returns, and the positional parameters
    `fname`, `mname`, and `lname` clarify what to expect as input and what order to
    expect from those parameters to be in. Calling the function with string literals
    looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称表明了它返回的内容，位置参数 `fname`、`mname` 和 `lname` 阐明了预期的输入以及这些参数的期望顺序。使用字符串字面量调用函数看起来是这样的：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code assigns the string literal arguments to the positional parameters
    in the same order created when the function was defined. It is possible to call
    the function using parameter names in this manner:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将字符串字面量参数按与函数定义时相同的顺序分配给位置参数。可以使用参数名以这种方式调用函数：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It’s also possible to change the order of the parameters by calling the function
    and using keyword parameters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过调用函数并使用关键字参数来改变参数的顺序：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Positional parameters are mandatory and must have a value assigned to them when
    calling the function. Otherwise, Python raises a `TypeError` exception.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数是必需的，在调用函数时必须为它们分配一个值。否则，Python 会引发一个 `TypeError` 异常。
- en: Keyword parameters
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'Keyword parameters aren’t mandatory when the function is called, as they have
    default values. Often these are used for optional parameters, allowing the function
    to operate with known default parameter values when the caller doesn’t supply
    one. The `full _name` function defined previously can be altered to use keyword
    parameters like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，关键字参数不是必需的，因为它们有默认值。通常这些用于可选参数，允许函数在调用者不提供参数时使用已知的默认参数值运行。之前定义的 `full
    _name` 函数可以修改为使用关键字参数，如下所示：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now the function has one positional required parameter, `fname`, and two keyword
    parameters, `mname` and `lname`—each with a default value of `None`. The function
    makes `fname` the only mandatory parameter, implying the function operates correctly
    if `mname` and `lname` aren’t provided by the caller. It’s also possible to use
    the keyword parameters in a different order than defined by the function—for instance,
    calling the function in this manner:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数有一个位置必需参数 `fname` 和两个关键字参数 `mname` 和 `lname`——每个都有默认值 `None`。函数将 `fname`
    作为唯一的必需参数，这意味着如果调用者没有提供 `mname` 和 `lname`，函数也能正确运行。还可以以不同于函数定义的顺序使用关键字参数——例如，以这种方式调用函数：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code indicates that the function handles the case where `fname` and `lname`
    are supplied but `mname` is assigned the default value of `None`. When defining
    a function, once you create a parameter with a default value (keyword parameter),
    any parameter following it must also be a keyword parameter and have default values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表明，该函数处理了 `fname` 和 `lname` 被提供但 `mname` 被分配默认值 `None` 的情况。在定义函数时，一旦创建了一个具有默认值（关键字参数）的参数，任何随后的参数也必须是关键字参数并具有默认值。
- en: Parameter list
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表
- en: In the Python `print` function, the first parameter is of the form `*objects`.
    The `*objects` parameter is an example of passing a variable number of positional
    parameters to a function. The “`*`” character indicates that the parameter is
    expecting a variable number of arguments. The `objects` part is the name of the
    parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 的 `print` 函数中，第一个参数的形式是 `*objects`。`*objects` 参数是向函数传递可变数量位置参数的一个例子。`*`
    字符表示该参数期望可变数量的参数。`objects` 部分是参数的名称。
- en: Inside the `print` function, the `objects` parameter is a tuple containing all
    the remaining positional parameters in the function. A variable number of positional
    parameters is commonly named `*args`, but that’s just a convention, not a requirement.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `print` 函数内部，`objects` 参数是一个包含函数中所有剩余位置参数的元组。一个可变数量的位置参数通常命名为 `*args`，但这只是一个约定，不是必需的。
- en: 'Modifying the `full_name()` function to use an argument list looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `full_name()` 函数修改为使用参数列表看起来是这样的：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this form, the `full_name()` function creates a temporary list of the `fname`
    parameter and the elements in the `names` to join them together, separated by
    a space character. This form is useful to pass multiple, similar arguments but
    can be confusing to the users of the function. The function will join any number
    of elements in the `*names` parameter tuple, which might not be your intention.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式中，`full_name()` 函数创建了一个包含 `fname` 参数和 `names` 元素的临时列表，以便将它们连接起来，用空格字符分隔。这种形式在传递多个相似参数时很有用，但可能会让函数的用户感到困惑。该函数将连接
    `*names` 参数元组中的任何数量的元素，这可能不是你的意图。
- en: Defining the function in the original form where all the parameters have names
    is a better way to go in this case. From the Zen of Python, explicit is better
    than implicit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，以所有参数都有名称的原始形式定义函数是更好的选择。从 Python 的禅意来看，明确优于隐晦。
- en: 'Tip You can view the Zen of Python by opening the Python REPL and entering:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可以通过打开 Python REPL 并输入以下命令来查看 Python 的禅意：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Doing so prints out useful advice and idioms about Python programming.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会打印出关于 Python 编程的有用建议和惯用语。
- en: Keyword parameter dictionary
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数字典
- en: 'The keyword parameter dictionary is akin to the parameter list; it’s a way
    of wrapping up all keyword parameters into a single parameter for a function.
    You’ll often see it defined as `**kwargs`, but again, this is only a convention.
    Changing the `full_name()` function to use this form looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数字典类似于参数列表；它是一种将所有关键字参数包装成一个函数参数的方法。你通常会看到它被定义为 `**kwargs`，但同样，这只是一个约定。将
    `full_name()` 函数修改为使用这种形式看起来是这样的：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Internally, the `full_name()` function examines the `kwargs` dictionary looking
    for the keywords `fname`, `mname`, and `lname`. Without documentation, the user
    of this function would not know what to include as key-value pairs in the `kwargs`
    dictionary parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`full_name()` 函数检查 `kwargs` 字典以查找关键字 `fname`、`mname` 和 `lname`。如果没有文档，使用此函数的用户将不知道在
    `kwargs` 字典参数中包含哪些键值对。
- en: The caller can also add other key-value pairs to the `kwargs` dictionary that
    possibly have no meaning to the `full_name()` function. Any extra key-value pairs
    are ignored by the `full_name()` function but could have meaning to functions
    it calls by passing the `kwargs` parameter along. Take care when using this form
    and do so intentionally.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者还可以向 `kwargs` 字典中添加其他键值对，这些键值对可能对 `full_name()` 函数没有意义。任何额外的键值对都会被 `full_name()`
    函数忽略，但可能对通过传递 `kwargs` 参数调用的函数有意义。使用这种形式时要小心，并且要故意这样做。
- en: Parameters in general
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 参数通常
- en: The ability to create proper function signatures includes being aware of patterns
    and consistency. Many APIs consist of multiple functions working together to accomplish
    something. This often means passing the same data into more than one function,
    so each function is aware of the state of the working data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建适当函数签名的能力包括了解模式和一致性。许多 API 由多个函数组成，共同完成某项任务。这通常意味着将相同的数据传递给多个函数，因此每个函数都了解工作数据的状态。
- en: If you’re processing data contained in a dictionary that’s passed to multiple
    functions, it’s a good idea to make the parameter position and the name representing
    the common data the same for all (or as many as possible) functions that work
    with it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理传递给多个函数的字典中的数据，对于所有（或尽可能多的）使用该数据的函数，使参数位置和表示公共数据的名称相同是个好主意。
- en: 'For example, make the dictionary the first parameter of the function, and all
    the additional parameters pass information about how to process the dictionary.
    The first parameter dictionary is the common, state data structure being passed
    between functions that act on that state data:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使字典成为函数的第一个参数，所有额外的参数传递有关如何处理字典的信息。第一个参数字典是传递给在状态数据上操作的函数之间的公共、状态数据结构：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `email_user` function gets the email address from the `user_data` structure
    and then generates an email with the `content` and `from` parameters and sends
    the email. The `popuplate_user_address` function adds address information to the
    existing `user_data` structure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`email_user` 函数从 `user_data` 结构中获取电子邮件地址，然后使用 `content` 和 `from` 参数生成电子邮件并发送电子邮件。`popuplate_user_address`
    函数将地址信息添加到现有的 `user_data` 结构中。'
- en: The same would apply to system resources passed to functions, file handles,
    database connections, and database cursors. If multiple functions need these resource
    objects, it helps make the API more readily understandable when the functions
    have a consistent signature.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则也适用于传递给函数的系统资源，文件句柄、数据库连接和数据库游标。如果多个函数需要这些资源对象，当函数具有一致的签名时，这有助于使 API 更易于理解。
- en: A function that has many parameters starts to stretch our cognitive abilities
    and often indicates the function does too much and should be refactored into smaller
    functions, each with a single purpose. It’s tempting to make a long list of function
    parameters into one using the keyword parameter ability of Python. Unless the
    dictionary passed as the `**kwargs` is documented, it just obscures what the function
    is expecting. It also sidesteps the original issue that perhaps the function needs
    to be refactored.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个参数的函数开始考验我们的认知能力，通常表明该函数做得太多，应该重构为更小的函数，每个函数只有一个目的。使用 Python 的关键字参数能力将一个长列表的函数参数合并成一个很有诱惑力。除非传递给
    `**kwargs` 的字典有文档说明，否则它只会模糊函数期望的内容。它也回避了可能需要重构函数的原始问题。
- en: 3.2.3 Return value
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 返回值
- en: As you’ve seen, one-half of the API contract is what’s returned by a function.
    In Python, even if you don’t have a return statement in your function code, a
    value of `None` is returned automatically. If the function you create performs
    system actions (file IO, network activity, system-level changes), you can return
    a `True` or `False` to indicate the success or failure of the function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，API 合同的一半是函数返回的内容。在 Python 中，即使你的函数代码中没有返回语句，也会自动返回一个 `None` 值。如果你创建的函数执行系统操作（文件
    I/O、网络活动、系统级更改），你可以返回 `True` 或 `False` 来指示函数的成功或失败。
- en: 3.2.4 Single responsibility
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 单一职责
- en: Strive to create functions that do only one thing; this is the single responsibility
    principle. Writing a useful function is already considerable work, especially
    if your goal is to make the function flexible through thoughtful input parameters
    and processing code. Trying to make it do two things can more than double the
    difficulty.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 努力创建只做一件事的函数；这是单一职责原则。编写一个有用的函数本身就是一项相当大的工作，尤其是如果你的目标是使函数通过深思熟虑的输入参数和处理代码变得灵活。试图让它做两件事可能会使难度加倍。
- en: 'Here’s a contrived example function from `examples/CH_03/example_02.py` that
    illustrates this concept:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个来自`examples/CH_03/example_02.py`的虚构示例函数，它说明了这个概念：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function concatenates the parameters to create the `full_name` variable
    and prints it to `sys.stdout`. The list comprehension inside `"` `".join` is to
    ensure there is only a single space between the names should `mname` be left out
    when the function is called. This function is not as useful as it could be because
    it’s trying to do too much.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将参数连接起来创建`full_name`变量，并将其打印到`sys.stdout`。`"` `".join`中的列表推导是为了确保在调用函数时`mname`被省略时，名称之间只有一个空格。这个函数并不像它本可以做到的那样有用，因为它试图做太多的事情。
- en: It’s not useful to other functions needing the full name because the full name
    isn’t returned. Even if the full name was returned, any function calling this
    must expect the full name to be printed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有返回完整的名称，所以对需要完整名称的其他函数来说没有用。即使完整的名称被返回，任何调用此函数的函数都必须期望完整的名称会被打印出来。
- en: Also, the function is difficult to test because it doesn’t return anything.
    To test this, you’d have to redirect `sys.stdout` in some way so a test could
    see the output, which could get messy quickly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个函数难以测试，因为它不返回任何内容。为了测试这个，你必须以某种方式重定向`sys.stdout`，以便测试可以看到输出，这可能会很快变得混乱。
- en: 'Here is a better version from `examples/CH_03/example_02.py`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是来自`examples/CH_03/example_02.py`的一个更好的版本：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This version does only one thing: it creates the full name and returns it to
    the caller. Now the return value of the function can be used with the `print`
    function, included in a web page, added to a data structure, converted to a JSON
    document, and more. This function has also become easy to test because you can
    test the return value, and the same input arguments always produce the same output.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本只做了一件事：创建完整的名称并将其返回给调用者。现在函数的返回值可以与`print`函数一起使用，包含在网页中，添加到数据结构中，转换为JSON文档，等等。这个函数也因为可以测试返回值，且相同的输入参数总是产生相同的输出而变得易于测试。
- en: 3.2.5 Function length
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 函数长度
- en: Related to the single responsibility principle is the length of the functions
    you write. It’s difficult to keep too much context and detail in our heads at
    once. The longer a function gets, the more difficult it becomes to reason about
    and understand its behavior.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与单一职责原则相关的是你编写的函数长度。一次在脑海中同时保持太多上下文和细节是很困难的。函数越长，推理和理解其行为就越困难。
- en: No hard-and-fast rule exists regarding the length of a function. A good rule
    of thumb is around 25 lines, but this is entirely dependent on your comfort level.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数长度的规则并不固定。一个很好的经验法则是大约25行，但这完全取决于你的舒适度。
- en: If you create a function that’s too long to comprehend easily, it probably means
    the function is trying to do too much. The solution is to refactor it and break
    some of the functionality out into other functions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个难以理解的函数，这可能意味着该函数试图做太多的事情。解决方案是重构它，并将一些功能拆分到其他函数中。
- en: When refactoring a function leads to multiple functions that work together on
    the same data, you can also create a class with the functions as the methods of
    that class. If you follow good naming practices and make the new functions handle
    only one task well, you’ll create more readable code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当重构一个函数导致多个函数协同处理相同的数据时，你也可以创建一个类，将函数作为该类的成员方法。如果你遵循良好的命名习惯，并确保新函数只处理一个任务，你将创建更易于阅读的代码。
- en: 3.2.6 Idempotence
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.6 幂等性
- en: Though an ominous-sounding word, *idempotent* in developer terms indicates a
    function that always returns the same result when given the same input argument
    values. No matter how many times it’s called, the same input yields the same output.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来很可怕，但在开发者术语中，“幂等”表示一个函数在给定相同的输入参数值时总是返回相同的结果。无论它被调用多少次，相同的输入总是产生相同的输出。
- en: The output of the function isn’t dependent on outside variables, events, or
    IO activity. For example, creating a function that uses the parameters along with
    the clock time to create the return value wouldn’t be idempotent. The return value
    is dependent on when the function is called. Idempotent functions are easier to
    test because the behavior is predictable and can be accounted for in test code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输出不依赖于外部变量、事件或IO活动。例如，创建一个使用参数和时钟时间来创建返回值的函数不会是幂等的。返回值取决于函数被调用的时机。幂等函数更容易测试，因为其行为是可预测的，可以在测试代码中考虑。
- en: 3.2.7 Side effects
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.7 副作用
- en: Functions can create side effects that change things outside the scope of the
    function itself. They can modify global variables, print data to the screen, send
    information across a network, and do a whole host of other activities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以创建副作用，这些副作用会改变函数本身作用域之外的事物。它们可以修改全局变量，将数据打印到屏幕上，通过网络发送信息，以及执行一系列其他活动。
- en: In your functions, the side effects should be intended—referred to previously
    as actions on the system. Unintended side effects need to be avoided. Modifying
    a global variable is something a function can do but should be thought about carefully
    as other, possibly surprising, functionality could be affected by those global
    modifications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的函数中，副作用应该是故意的——之前被称为对系统的操作。需要避免意外的副作用。修改全局变量是函数可以执行的操作，但应该仔细考虑，因为其他可能令人惊讶的功能可能会受到这些全局修改的影响。
- en: When opening a file, it’s good practice to close it when done to avoid the possibility
    of corrupting the file. Database connections should be closed when unused so other
    parts of the system can access them. In general, it’s good programming practice
    to clean up and release system resources as soon as your function or application
    is finished with them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开一个文件时，完成操作后关闭文件是一个良好的实践，以避免文件损坏的可能性。数据库连接在未使用时应关闭，以便系统的其他部分可以访问它们。一般来说，当你的函数或应用程序完成使用系统资源后，清理和释放系统资源是良好的编程实践。
- en: 'There is another side effect to be aware of when working with Python. Because
    arguments to functions are passed by reference, the function has the potential
    of altering variables outside of the function’s scope. The example program `examples/CH_03/example_03.py`
    demonstrates this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Python 时，还有另一个需要注意的副作用。由于函数的参数是通过引用传递的，函数有可能改变函数作用域之外的变量。示例程序 `examples/CH_03/example_03.py`
    展示了这一点：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When this program runs, the following output is produced:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序运行时，将产生以下输出：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Both the `total()` and `better_total()` functions return the same value, 10,
    but only `better_total()` is idempotent. The code in the `total()` function is
    changing the `values_1` list passed to it as an argument and exists outside of
    its scope.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`total()` 和 `better_total()` 函数都返回相同的值，10，但只有 `better_total()` 是幂等的。`total()`
    函数中的代码正在修改它作为参数传入的 `values_1` 列表，并且存在于其作用域之外。'
- en: This happens because of the way the sum is calculated. The `total()` function
    appends `new_value` directly to the `values` list parameter passed to it. Because
    parameters are passed by reference, the list variable `values_1` outside the function
    and the parameter variable `values` inside the function both reference the same
    list. When `new_value` is appended to the list, it’s modifying the same list that
    `values_1` referenced.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为求和的计算方式。`total()` 函数直接将 `new_value` 追加到它所传入的 `values` 列表参数中。由于参数是通过引用传递的，函数外部的列表变量
    `values_1` 和函数内部的参数变量 `values` 都引用了同一个列表。当 `new_value` 被追加到列表中时，它修改的是 `values_1`
    所引用的同一个列表。
- en: The `better_total()` function makes a copy of the `values` parameter, creating
    a new list variable `temp_list` independent of the one referenced by the `values_2`
    list. Then it appends `new_value` to `temp_list` and returns the sum of `temp_list`.
    This leaves the `values_2` list variable untouched, which is the intended behavior.
    The `better_total()` function is idempotent because it returns the same results
    for a given set of inputs and has no side effects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`better_total()` 函数创建 `values` 参数的一个副本，创建了一个独立于 `values_2` 列表所引用的新列表变量 `temp_list`。然后它将
    `new_value` 追加到 `temp_list` 中，并返回 `temp_list` 的总和。这保留了 `values_2` 列表变量不变，这是预期的行为。`better_total()`
    函数是幂等的，因为它对于给定的输入集返回相同的结果，并且没有副作用。'
- en: 3.3 Documentation
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 文档
- en: Documentation is a necessary process when building and defining an API. Functions,
    and the modules of which they are a part, should have documentation that briefly
    describes the functionality of the module and the functions it contains. Modules
    should have docstrings at the top of the file describing the functionality that
    the module provides and possibly the exceptions that might be raised.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和定义API时，文档是一个必要的流程。函数以及它们所属的模块应该有简要描述模块功能和包含的函数功能的文档。模块应该在文件顶部包含文档字符串，描述模块提供的功能以及可能抛出的异常。
- en: 'Functions and class methods should have docstrings that briefly describe what
    the function does, what the parameters are for, and what the expected return value
    is. The functions in the example programs shown previously include docstrings.
    Here’s an example of a function with no documentation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和类方法应该有文档字符串，简要描述函数的功能、参数用途以及预期的返回值。前面展示的示例程序中的函数包含文档字符串。以下是一个没有文档的函数示例：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here’s the same function with a docstring:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个函数带有文档字符串的版本：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The functionality of the version with no docstring might be clear, but there’s
    no indication of why the function exists or why the code would call it. The version
    with a docstring answers these questions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 没有文档字符串的版本的功能可能很清楚，但没有说明函数存在的原因或为什么代码会调用它。带有文档字符串的版本回答了这些问题。
- en: You might hear people say documenting Python code is unnecessary because the
    code is so readable and therefore self-documenting. The readability part is genuine,
    but any reasonably complex piece of code can only benefit from documentation,
    helping the reader understand the intent.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会听到有人说记录Python代码是不必要的，因为代码本身可读性很高，因此是自文档化的。可读性部分是真实的，但任何合理复杂的代码片段都能从文档中受益，帮助读者理解意图。
- en: Documenting code does take effort; however, modern code editors like VS Code
    make it easier to insert docstring templates. The template for the docstrings
    in the example programs was generated by hitting return at the end of the function
    definition, typing three double quotes ("""), and clicking return again.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代码确实需要付出努力；然而，现代代码编辑器如VS Code使得插入文档字符串模板变得更加容易。示例程序中文档字符串的模板是通过在函数定义的末尾按回车键，输入三个双引号（"""),
    然后再按回车键生成的。
- en: Tip Most of the example code in this book doesn’t include docstrings. My intent
    is not to ignore my own suggestions but to reduce the amount of code presented
    on these pages and save book real estate. The code in the accompanying repository
    does have docstrings.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：本书中的大部分示例代码没有包含文档字符串。我的意图并不是忽略自己的建议，而是减少这些页面上的代码量，节省书籍空间。附带的代码仓库中的代码确实包含文档字符串。
- en: Many tools extract and process Python docstrings as part of external documentation
    systems. Besides being a benefit to readers of the code, including the original
    author, there is another win. If you’re at the Python prompt and type `help(<function
    name>),` the built-in help system presents the docstring of the function for reference.
    This includes not only the built-in functions but those you create. The existence
    of a docstring makes this possible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具将Python文档字符串提取和处理作为外部文档系统的一部分。除了对代码的读者（包括原始作者）有益之外，还有另一个优势。如果您在Python提示符下输入`help(<函数名>)`，内置的帮助系统会显示函数的文档字符串以供参考。这包括内置函数以及您创建的函数。文档字符串的存在使得这一点成为可能。
- en: 3.4 Closing thoughts
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 总结
- en: Creating a good API is important because ease of use is important. Users of
    your APIs, which include yourself, want to make use of the functionality provided,
    not struggle with how to get that functionality to work.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个良好的API非常重要，因为易用性很重要。使用您API的用户，包括您自己，希望利用提供的功能，而不是挣扎于如何让这些功能工作。
- en: Creating useful APIs is challenging; there are a lot of moving parts and considerations.
    Well-named modules, functions, and classes with consistent, logical parameters
    and documentation help give an API good affordance or discoverability. Like many
    things, the work invested in creating something today pays rewards later when
    you’re using that trusted tool.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有用的API具有挑战性；有很多移动部件和考虑因素。具有一致、逻辑参数和文档的命名模块、函数和类有助于使API具有良好的可用性或可发现性。就像许多事情一样，今天投入的劳动会在您使用这个受信任的工具时带来回报。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An API is a collection of structured interface touchpoints that an application
    can use to affect the code to which the API provides access. There are APIs around
    operating system code, around server code running locally or remotely, and around
    the modules you build to create functionality in your applications.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 是一组结构化的接口接触点集合，应用程序可以使用它来影响 API 提供访问的代码。API 围绕操作系统代码、本地或远程运行的服务器代码，以及您构建以在应用程序中创建功能的功能模块存在。
- en: An API is a contract that application software defines so other application
    software can interface with it consistently and predictably.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 是应用程序软件定义的合约，这样其他应用程序软件就可以一致和可预测地与之接口。
- en: Part of creating a good API is abstracting the implementation so the caller
    of the API can depend on the interface contract and not have to use the internal
    implementation to achieve their goals.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个好的 API 的一部分是抽象实现，这样 API 的调用者就可以依赖于接口合约，而不必使用内部实现来实现他们的目标。
- en: Python has good support and tools to create APIs that are useful to your own
    applications and can be published for use by others.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 有良好的支持和工具来创建对您自己的应用程序有用的 API，并且可以发布供他人使用。
