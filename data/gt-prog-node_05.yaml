- en: Unit 5\. Authenticating user accounts
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5单元：验证用户账户
- en: In [unit 4](../Text/kindle_split_031.html#part04), you built CRUD functions
    for the models in your application. You also learned how Mongoose and some external
    packages can help you define associations between your models and display data
    from referenced models in your browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4单元](../Text/kindle_split_031.html#part04)中，你为应用程序中的模型构建了CRUD函数。你还学习了Mongoose和一些外部包如何帮助你定义模型之间的关联，并在浏览器中显示引用模型的数据库数据。
- en: In this unit, you learn about flash messaging with sessions and cookies, data
    encryption, and user authentication. You start by implementing basic session storage
    to handle small messages called *flash messages* between requests. Then you modify
    your `User` model to handle password encryption with the `bcrypt` package. After
    setting up your first login form, you use `bcrypt` to authenticate users by comparing
    their login data with their encrypted passwords in your database. In the last
    lesson, you reimplement user authentication—the process of confirming that an
    account is valid before allowing users access to the application. You explore
    methods of authenticating accounts, encrypting passwords for security, and offering
    tools for normal users to move around in your application with tools provided
    by Passport.js. By the end of the unit, you’ll be able to sign up new users and
    even begin building logic based on user data in your database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本单元中，你学习了使用会话和cookie进行闪存消息、数据加密和用户认证。你首先实现基本的会话存储来处理请求之间的称为*闪存消息*的小信息。然后你修改`User`模型以使用`bcrypt`包处理密码加密。在设置好第一个登录表单后，你使用`bcrypt`通过将用户的登录数据与数据库中加密的密码进行比较来验证用户。在最后一课中，你重新实现了用户认证的过程——在允许用户访问应用程序之前确认账户的有效性。你探讨了验证账户、加密密码以保障安全以及通过Passport.js提供的工具为普通用户提供在应用程序中移动的工具。到本单元结束时，你将能够注册新用户，甚至开始基于数据库中的用户数据构建逻辑。
- en: 'This unit covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本单元涵盖了以下主题：
- en: '[Lesson 22](../Text/kindle_split_038.html#ch22) discusses sessions and shows
    how to preserve your users’ login status by storing information on the client
    side. You learn how to apply flash messages; these short messages, passed between
    pages, let you know whether some server operation was successful.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第22课](../Text/kindle_split_038.html#ch22) 讨论了会话，并展示了如何通过在客户端存储信息来保留用户的登录状态。你学习了如何应用闪存消息；这些在页面之间传递的简短消息会告诉你某些服务器操作是否成功。'
- en: '[Lesson 23](../Text/kindle_split_039.html#ch23) guides you through the process
    of building a sign-up form. You’ve built forms before in this book, but this form
    handles a user’s email and password, so you need to take a slightly different
    approach to ensure that your data is safe and consistent. With the help of the
    `bcrypt` package, an encryption algorithm makes sure that no plain-text passwords
    are saved to your database. At the end of the lesson, you apply additional validation
    middleware with `express-validator`.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第23课](../Text/kindle_split_039.html#ch23) 指导你构建注册表单的过程。在这本书中你已经构建过表单了，但这个表单处理用户的电子邮件和密码，因此你需要采取稍微不同的方法来确保你的数据安全且一致。在`bcrypt`包的帮助下，一种加密算法确保不会将明文密码保存到你的数据库中。在课程结束时，你使用`express-validator`应用了额外的验证中间件。'
- en: '[Lesson 24](../Text/kindle_split_040.html#ch24) teaches you how to add application
    authentication for your users. With the help of the Passport.js middleware and
    some helpful npm packages, this lesson adds a layer of security to your application
    and the `User` model. You also modify your view layout to access your login form
    quickly, display any currently logged-in users, and provide a way to log out quickly.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第24课](../Text/kindle_split_040.html#ch24) 教你如何为你的用户添加应用程序认证。在本课中，通过Passport.js中间件和一些有用的npm包，为你的应用程序和`User`模型添加了一层安全防护。你还修改了视图布局，以便快速访问登录表单、显示当前登录的用户并提供快速登出的方式。'
- en: '[Lesson 25](../Text/kindle_split_041.html#ch25) wraps up the unit by guiding
    you through the construction of necessary user encryption and authentication for
    the Confetti Cuisine application. You apply flash messages, validation middleware,
    encryption, and a robust authentication process.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第25课](../Text/kindle_split_041.html#ch25) 通过引导你构建Confetti Cuisine应用程序所需的用户加密和认证来结束本单元。你应用了闪存消息、验证中间件、加密和一个健壮的认证过程。'
- en: Start cooking in [lesson 22](../Text/kindle_split_038.html#ch22) by adding cookies
    to your application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第22课](../Text/kindle_split_038.html#ch22)中，通过向你的应用程序添加cookie开始烹饪。
- en: Lesson 22\. Adding sessions and flash messages
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第22课：添加会话和闪存消息
- en: In this lesson, you clean up the flow between CRUD functions by passing messages
    between pages to find out whether the server operations were successful or certain
    types of errors occurred. Currently, error messages are logged to the console,
    and users of the application have no way to know what they could do differently.
    You use sessions and cookies alongside the `connect-flash` package to deliver
    these messages to your views. By the end of the lesson, you’ll have an application
    that gives you a visual description of the success or failure of operations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你通过在页面之间传递消息来清理CRUD函数之间的流程，以找出服务器操作是否成功或是否发生了某些类型的错误。目前，错误消息被记录到控制台，应用程序的用户无法知道他们可以如何不同地操作。你使用
    `connect-flash` 包以及会话和cookie来将这些消息传递到你的视图中。在本节课结束时，你将拥有一个能够以视觉描述操作成功或失败的应用程序。
- en: This lesson covers
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课涵盖
- en: Setting up sessions and cookies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置会话和cookie
- en: Creating flash messages in your controller actions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的控制器操作中创建闪存消息
- en: Setting up validation middleware on incoming data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传入数据上设置验证中间件
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Your recipe application is starting to collect data through the view forms you
    created in [unit 4](../Text/kindle_split_031.html#part04). Users are beginning
    to get frustrated, though, because they don’t know what validations you have in
    place, and if they fail to meet your validator expectations, they’re redirected
    to a different page without notice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你的食谱应用程序开始通过你在[第4单元](../Text/kindle_split_031.html#part04)中创建的视图表单收集数据。然而，用户开始感到沮丧，因为他们不知道你设置了哪些验证，如果他们未能满足验证器的期望，他们会被无通知地重定向到另一个页面。
- en: With some helpful packages, you can incorporate flash messaging into your application
    to inform your users of specific errors that occur in your application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些有用的包，你可以将闪存消息整合到你的应用程序中，以通知你的用户应用程序中发生的特定错误。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)22.1\. Setting up flash message modules'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)22.1\. 设置闪存消息模块'
- en: '*Flash messages* are semipermanent data used to display information to users
    of an application. These messages originate in your application server and travel
    to your users’ browsers as part of a session. *Sessions* contain data about the
    most recent interaction between a user and the application, such as the current
    logged-in user, length of time before a page times out, or messages intended to
    be displayed once.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*闪存消息*是半永久性数据，用于向应用程序的用户显示信息。这些消息起源于你的应用程序服务器，作为会话的一部分传送到用户的浏览器。*会话*包含有关用户与应用程序之间最近交互的数据，例如当前登录用户、页面超时前的时间长度，或打算一次性显示的消息。'
- en: You have many ways to incorporate flash messages into your application. In this
    lesson, you use the `connect-flash` middleware module by typing `npm i connect-flash
    -S` in terminal to install its package to your application as a dependency.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多种方法将闪存消息整合到你的应用程序中。在本节课中，你通过在终端中输入 `npm i connect-flash -S` 来安装其包，将 `connect-flash`
    中间件模块作为依赖项添加到你的应用程序中。
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Sessions used to be a dependency of Express.js, but because not everyone uses
    every Express.js dependency and because it’s difficult to keep dependencies up
    to date with the main package, independent packages `cookie-parser` and `express-session`
    must be installed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 会话曾经是 Express.js 的依赖项，但由于并非每个人都会使用每个 Express.js 依赖项，并且很难保持依赖项与主包的更新同步，因此必须安装独立的包
    `cookie-parser` 和 `express-session`。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now you need to install two more packages by running `npm i cookie-parser express-session
    -S` in terminal. Then require these three modules—`connect-flash`, `cookie-parser`,
    and `express-session`—in your main.js file, along with some code to use the modules
    ([listing 22.1](#ch22ex01)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要在终端中运行 `npm i cookie-parser express-session -S` 来安装另外两个包。然后，在你的 main.js
    文件中引入这三个模块——`connect-flash`、`cookie-parser` 和 `express-session`——以及一些使用这些模块的代码（[列表22.1](#ch22ex01)）。
- en: You need the `express-session` module to pass messages between your application
    and the client. These messages persist on the user’s browser but are ultimately
    stored in the server. `express-session` allows you to store your messages in a
    few ways on the user’s browser. Cookies are one form of session storage, so you
    need the `cookie-parser` package to indicate that you want to use cookies and
    that you want your sessions to be able to parse (or decode) cookie data sent back
    to the server from the browser.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要 `express-session` 模块在您的应用程序和客户端之间传递消息。这些消息在用户的浏览器中持久存在，但最终存储在服务器上。`express-session`
    允许您以几种方式在用户的浏览器中存储您的消息。Cookies 是会话存储的一种形式，因此您需要 `cookie-parser` 包来指示您想要使用 cookies，并且您希望您的会话能够解析（或解码）从浏览器发送回服务器的
    cookie 数据。
- en: Use the `connect-flash` package to create your flash messages. This package
    is dependent on sessions and cookies to pass flash messages between requests.
    You tell your Express.js application to use `cookie-parser` as middleware and
    to use some secret passcode you choose. `cookie-parser` uses this code to encrypt
    your data in cookies sent to the browser, so choose something that’s hard to guess.
    Next, you have your application use sessions by telling `express-session` to use
    `cookie-parser` as its storage method and to expire cookies after about an hour.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `connect-flash` 包来创建您的 flash 消息。此包依赖于会话和 cookies 在请求之间传递 flash 消息。您告诉您的 Express.js
    应用程序使用 `cookie-parser` 作为中间件，并使用您选择的某个秘密密码。`cookie-parser` 使用此代码来加密发送到浏览器的 cookies
    中的数据，因此请选择一个难以猜测的密码。接下来，您让应用程序通过告诉 `express-session` 使用 `cookie-parser` 作为其存储方法，并在大约一个小时后使
    cookies 过期来使用会话。
- en: You also need to provide a secret key to encrypt your session data. Specify
    that you don’t want to send a cookie to the user if no messages are added to the
    session by setting `saveUninitialized` to false. Also specify that you don’t want
    to update existing session data on the server if nothing has changed in the existing
    session. Last, have the application use `connect-flash` as middleware.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要提供一个密钥来加密您的会话数据。通过将 `saveUninitialized` 设置为 false，指定您不希望在没有消息添加到会话的情况下向用户发送
    cookie。还指定您不希望在现有会话没有变化的情况下更新服务器上的现有会话数据。最后，让应用程序使用 `connect-flash` 作为中间件。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, the secret key is shown in plain text in your application server
    file. I don’t recommend displaying your secret key here, however, because it opens
    your application to security vulnerabilities. Instead, store your secret key in
    an environment variable, and access that variable with `process.env`. I discuss
    this topic further in [unit 8](../Text/kindle_split_052.html#part08).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，密钥以纯文本形式显示在您的应用程序服务器文件中。然而，我不建议在这里显示您的密钥，因为这会使您的应用程序容易受到安全漏洞的攻击。相反，将您的密钥存储在环境变量中，并使用
    `process.env` 访问该变量。我在第 8 单元中进一步讨论了此主题。[单元 8](../Text/kindle_split_052.html#part08)。
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 22.1\. Requiring flash messaging in main.js
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.1\. 在 main.js 中要求使用 flash 消息
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Require the three modules.**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **要求三个模块。**'
- en: '***2*** **Configure your Express.js application to use cookie-parser as middleware.**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **配置您的 Express.js 应用程序以使用 cookie-parser 作为中间件。**'
- en: '***3*** **Configure express-session to use cookie-parser.**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **配置 express-session 以使用 cookie-parser。**'
- en: '***4*** **Configure your application to use connect-flash as middleware.**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **配置您的应用程序以使用 connect-flash 作为中间件。**'
- en: All together, these three packages provide middleware to help you process incoming
    requests and outgoing responses with necessary cookie data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这三个包提供了中间件，帮助您处理带有必要 cookie 数据的传入请求和传出响应。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Cookie parsing**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cookie 解析**'
- en: With each request and response made between the server and client, an HTTP header
    is bundled with the data sent across the internet. This header contains a lot
    of useful information about the data being transferred, such as the size of the
    data, the type of data, and the browser the data is being sent from.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器和客户端之间每次请求和响应时，都会将一个 HTTP 头部与通过网络发送的数据捆绑在一起。此头部包含有关正在传输的数据的大量有用信息，例如数据的尺寸、数据的类型以及发送数据的浏览器。
- en: Another important element in the request header is the cookies. *Cookies* are
    small files of data sent from the server to the user’s browser, containing information
    about the interaction between the user and the application. A cookie might indicate
    which user accessed the application last, whether the user logged in successfully,
    and even what requests the user made, such as whether he successfully, created
    an account or made multiple failed attempts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头中的另一个重要元素是Cookies。*Cookies*是从服务器发送到用户浏览器的小数据文件，包含有关用户与应用程序之间交互的信息。一个Cookie可能表明哪个用户最后访问了应用程序，用户是否成功登录，甚至用户提出了什么请求，例如他是否成功创建了账户或进行了多次失败的尝试。
- en: In this application, you use encrypted cookies with a secret passcode encryption
    key to store information about each user’s activity on the application and whether
    the user is still logged in, as well as short messages to display in the user’s
    browser to let them know if any errors occurred on their most recent request.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，您使用带有密钥加密的加密Cookies来存储有关每个用户在应用程序中的活动信息以及用户是否仍然登录的信息，以及要在用户浏览器中显示的简短消息，以告知他们最近的请求是否发生错误。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Because requests are independent of one another, if one request to create a
    new user fails and you’re redirected to the home page, that redirect is another
    request, and nothing is sent in the response to the user to let them know that
    their attempt to create an account failed. Cookies prove to be helpful in this
    case.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为请求是相互独立的，如果一个创建新用户的请求失败并且您被重定向到主页，那么这个重定向是另一个请求，并且没有向用户发送任何响应来告知他们创建账户的尝试失败。在这种情况下，Cookies非常有用。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As you create your custom secret keys, remember to make them a bit more difficult
    for someone else to guess. Next, you use these added modules by setting up flash
    messaging on your controller actions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义密钥时，请记住使它们对其他人来说更难以猜测。接下来，您通过在控制器操作上设置闪存消息来使用这些添加的模块。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 22.1**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查22.1**'
- en: '**[Q1:](#ch22qa3q0a1)**'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch22qa3q0a1)**'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does a cookie’s secret key change the way that data is sent and stored on
    a browser?
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Cookie的密钥如何改变数据在浏览器中的发送和存储方式？
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 22.1 answer**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 22.1 答案**'
- en: '**[1:](#ch22qa1q1)**'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch22qa1q1)**'
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The secret key used with cookies allows data to have some encryption. Encryption
    is important for securing the data sent over the internet and for making sure
    that the data living in the user’s browser isn’t exposed to modifications.
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与Cookies一起使用的密钥允许数据进行加密。加密对于确保通过互联网发送的数据的安全性以及确保用户浏览器中的数据不会被修改非常重要。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)22.2\. Adding flash messages to controller actions'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)22.2\. 向控制器操作添加闪存消息'
- en: To get flash messages working, you need to attach them to the request made before
    you render a view to the user. Generally, when a user makes a `GET` request for
    a page—say, to load the home page—you don’t need to send a flash message.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使闪存消息正常工作，您需要在向用户渲染视图之前将它们附加到请求中。通常，当用户对页面发出`GET`请求时——比如说，加载主页——您不需要发送闪存消息。
- en: Flash messages are most useful when you want to notify the user of a successful
    or failed request, usually involving the database. On these requests, such as
    for user creation, you’re typically redirecting to another page, depending on
    the outcome. If a user is created, you redirect to the `/users` route; otherwise,
    you can redirect to `/user/new`. A flash message is no different from a local
    variable being made available to the view. For that reason, you need to set up
    another middleware configuration for express to treat your `connectFlash` messages
    like a local variable on the response, as shown in [listing 22.2](#ch22ex02).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存消息在您想通知用户请求成功或失败时非常有用，通常涉及数据库。在这些请求中，例如用户创建，您通常会根据结果重定向到另一个页面。如果用户被创建，您将重定向到`/users`路由；否则，您可以重定向到`/user/new`。闪存消息与将本地变量提供给视图并无不同。因此，您需要为Express设置另一个中间件配置，以便将您的`connectFlash`消息视为响应中的本地变量，如[列表22.2](#ch22ex02)所示。
- en: By adding this middleware function, you’re telling Express to pass a local object
    called `flashMessages` to the view. The value of that object is equal to the flash
    messages you create with the `connect-flash` module. In this process, you’re transferring
    the messages from the request object to the response.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这个中间件函数，你告诉Express将一个名为`flashMessages`的本地对象传递给视图。该对象的价值等于你使用`connect-flash`模块创建的闪存消息。在这个过程中，你将消息从请求对象转移到响应对象。
- en: Listing 22.2\. Middleware to associate `connectFlash` to flashes on response
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.2\. 将`connectFlash`关联到响应上的闪存消息的中间件
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **Assign flash messages to the local flashMessages variable on the
    response object.**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将闪存消息分配到响应对象上的本地`flashMessages`变量。**'
- en: With this middleware in place, you can add messages to `req.flash` at the controller
    level and access the messages in the view through `flashMessages`. Next, add a
    flash message to the `create` action in your `usersController` by changing the
    action’s code to match [listing 22.4](#ch22ex04).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个中间件，你可以在控制器级别添加消息到`req.flash`，并通过`flashMessages`在视图中访问这些消息。接下来，通过更改`usersController`中的`create`动作的代码来匹配[列表
    22.4](#ch22ex04)添加一个闪存消息。
- en: In this action, you’re modifying the way that you handle errors in the `catch`
    block. Instead of passing the error to the error-handler action, set the error
    flash message, and allow the `redirectView` action to display the user’s new.ejs
    page again. The first flash message is of type `success` and delivers the message
    that the user’s account was created. The flash message delivered when the account
    isn’t created is of type `error`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动作中，你正在修改处理`catch`块中错误的方式。不是将错误传递给error-handler动作，而是设置错误闪存消息，并允许`redirectView`动作再次显示用户的new.ejs页面。第一条闪存消息是`success`类型，传达了用户账户已创建的消息。当账户未创建时传递的闪存消息是`error`类型。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 22.3\. Wrapping user params in the function
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.3\. 在函数中包装用户参数
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`getUserParams` has been borrowed from the last capstone exercise ([lesson
    21](../Text/kindle_split_036.html#ch21)). This function is reused throughout the
    controller to organize user attributes in one object. You should create the same
    functions for your other model controllers.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUserParams`是从上一个综合练习([课程 21](../Text/kindle_split_036.html#ch21))借用的。这个函数在整个控制器中重用，用于在一个对象中组织用户属性。你应该为你的其他模型控制器创建相同的函数。'
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 22.4\. Adding flash messages to the create action in usersController.js
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.4\. 在usersController.js中添加闪存消息到create动作
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although you use the request object here to store the flash messages temporarily,
    because you connected these messages to a local variable on the response, the
    messages ultimately make it to the response object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你在这里使用请求对象来临时存储闪存消息，因为你将这些消息连接到响应上的一个本地变量，所以这些消息最终到达响应对象。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As soon as the page is redirected to `/users` or `/users/new`, your flash message
    is available to the view.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面重定向到`/users`或`/users/new`时，你的闪存消息就可供视图使用。
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`error` and `success` are two flash-message types that I made up. You can customize
    these types however you like. If you want a flash message of type `superUrgent`,
    you can use `req.flash("superUrgent", "Read this message ASAP!")`. Then `superUrgent`
    will be the key used to get whatever message you attach.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`和`success`是我创建的两个闪存消息类型。你可以按自己的喜好自定义这些类型。如果你想有一个`superUrgent`类型的闪存消息，你可以使用`req.flash("superUrgent",
    "Read this message ASAP!")`。然后`superUrgent`将是获取你附加的任何消息所使用的键。'
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The last step in getting flash messages working is adding some code to the view
    to receive and display the messages. Because you want every view to show potential
    success or failures, add the code in [listing 22.5](#ch22ex05) to layout.ejs.
    You may also want to add custom styles in your public/css folder so that the messages
    can be differentiated from normal view content.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使闪存消息功能生效的最后一步是在视图中添加一些代码来接收和显示这些消息。因为你想让每个视图都显示潜在的成功或失败信息，所以将[列表 22.5](#ch22ex05)中的代码添加到layout.ejs中。你可能还希望在public/css文件夹中添加自定义样式，以便将消息与正常视图内容区分开来。
- en: First, check whether any `flashMessages` exist. If `success` messages exist,
    display the success messages in a `div`. If `error` messages exist, display those
    messages with a differently styled class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查是否存在任何`flashMessages`。如果存在`success`消息，则在`div`中显示这些成功消息。如果存在`error`消息，则使用不同样式的类显示这些消息。
- en: Listing 22.5\. Adding flash messages in layout.ejs
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.5\. 在layout.ejs中添加闪存消息
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Check whether flashMessages exist.**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查是否存在闪存消息。**'
- en: '***2*** **Display success messages.**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **显示成功消息。**'
- en: '***3*** **Display error messages.**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **显示错误信息。**'
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you don’t see any messages on the screen at first, try removing all styling
    surrounding the message to get the plain-text message in the view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一开始没有在屏幕上看到任何消息，尝试移除围绕消息的所有样式，以在视图中获取纯文本消息。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Test the new code to display flash messages by starting the Node.js application,
    visiting `/users/new`, and filling out the form to create a new user. If you create
    a new user successfully, your page on redirect should look like [figure 22.1](#ch22fig01).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动Node.js应用程序，访问`/users/new`并填写表单以创建新用户来测试显示消息的新代码。如果你成功创建了新用户，重定向后的页面应类似于[图22.1](#ch22fig01)。
- en: Figure 22.1\. Successful flash message shown on the /users page
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图22.1\. 在/users页面上显示的成功消息
- en: '![](../Images/22fig01_alt.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/22fig01_alt.jpg)'
- en: If you try to create a new user with an existing email address, your redirect
    screen should resemble [figure 22.2](#ch22fig02).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用现有的电子邮件地址创建新用户，你的重定向屏幕应类似于[图22.2](#ch22fig02)。
- en: Figure 22.2\. Error flash message shown on the home page
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图22.2\. 在主页上显示的错误消息
- en: '![](../Images/22fig02_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/22fig02_alt.jpg)'
- en: When you refresh the page or create any new request, this message disappears.
    Because you may choose to send multiple success or error messages, you may find
    it useful to loop through the messages on the view instead of displaying everything
    mapped to the `error` and `success` keys.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刷新页面或创建任何新的请求时，此消息会消失。因为你可能选择发送多个成功或错误消息，你可能发现循环遍历视图中的消息而不是显示所有映射到`error`和`success`键的内容是有用的。
- en: If you need to show a flash message on a view you’re rendering, pass the message
    directly as a local variable. The next listing shows how to add a success message
    to the user’s index page. When you pass the `flashMessages` object directly to
    the view, you don’t need to wait for a redirect or use `connect-flash`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在渲染的视图中显示消息，直接将消息作为局部变量传递。下面的列表显示了如何将成功消息添加到用户的索引页面。当你直接将`flashMessages`对象传递给视图时，你不需要等待重定向或使用`connect-flash`。
- en: Listing 22.6\. Adding a flash message to the rendered index view
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表22.6\. 将消息添加到渲染的索引视图
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Pass the flash messages with a rendered view.**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **与渲染视图一起传递消息。**'
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 22.2**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 22.2**'
- en: '**[Q1:](#ch22qa3q0a2)**'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch22qa3q0a2)**'
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What two arguments are needed for the `req.flash` method?
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`req.flash`方法需要两个参数是什么？
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 22.2 answer**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 22.2 答案**'
- en: '**[1:](#ch22qa2q2)**'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch22qa2q2)**'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`req.flash` needs a flash-message type and a message.'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`req.flash`需要一个消息类型和一个消息。'
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)总结'
- en: In this lesson, you learned about sessions and cookies, and saw why they’re
    integral parts of how data is transferred between the server and client. You also
    set up `connect-flash` to use cookies and temporarily show success and failure
    messages on certain views. In [lesson 23](../Text/kindle_split_039.html#ch23),
    you see how to encrypt more than cookie data by implementing encryption on user
    passwords.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了关于会话和cookie的内容，并了解了为什么它们是服务器和客户端之间数据传输不可或缺的部分。你还设置了`connect-flash`以使用cookie，并在某些视图中临时显示成功和失败信息。在[第23课](../Text/kindle_split_039.html#ch23)中，你将看到如何通过在用户密码上实现加密来加密不仅仅是cookie数据。
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Now that you have flash messaging set up, it’s time to add it to all your CRUD
    actions. You want your users to see whether their attempt to subscribe, create
    an account, delete an account, or update user information was successful. Add
    flash messages for each action involving your database for all three models.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了消息闪现，是时候将其添加到所有的CRUD操作中。你希望用户看到他们尝试订阅、创建账户、删除账户或更新用户信息是否成功。为所有三个模型涉及数据库的每个操作添加消息闪现。
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 23\. Building a user login and hashing passwords
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第23课。构建用户登录和散列密码
- en: In [lesson 22](../Text/kindle_split_038.html#ch22), you added flash messages
    to your controller actions and views. In this lesson, you dive deeper into the
    `User` model by creating a sign-up and login form. Then you add a layer of security
    to your application by hashing users’ passwords and saving your users’ login state.
    Next, you add some more validations at the controller level with the help of the
    `express-validator` package. By the end of this lesson, a user should be able
    to create an account, have their password saved securely in your database, and
    log in or log out as they like.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第22课](../Text/kindle_split_038.html#ch22)中，你在控制器动作和视图中添加了闪存消息。在本课中，你通过创建注册和登录表单来深入了解`User`模型。然后，你通过哈希用户密码并保存用户的登录状态来为你的应用程序添加一层安全性。接下来，你使用`express-validator`包在控制器级别添加了一些额外的验证。在本课结束时，用户应该能够创建账户，将他们的密码安全地保存在你的数据库中，并按需登录或注销。
- en: This lesson covers
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Creating a user log-in form
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户登录表单
- en: Hashing data in your database with `bcrypt`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bcrypt`在数据库中哈希数据
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下内容**'
- en: You deliver a prototype of your recipe application in which users can create
    accounts and store their unencrypted passwords in your database. You’re reasonably
    concerned that your database might get hacked or (even more embarrassing) that
    you might show user passwords in plain text to all users. Luckily, security is
    a big concern in the programming world, and tools and security techniques are
    available to protect sensitive data from being exposed. `bcrypt` is one such tool
    you’ll use to mask passwords in your database so that they can’t be hacked easily
    in the future.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供了一个食谱应用的原型，用户可以在其中创建账户并将未加密的密码存储在你的数据库中。你合理地担心你的数据库可能被黑客攻击，或者（更加尴尬的是）你可能将用户密码以纯文本形式显示给所有用户。幸运的是，安全性是编程世界中的一个重大关注点，有工具和安全技术可以用来保护敏感数据不被泄露。`bcrypt`就是这样一种工具，你将用它来在数据库中隐藏密码，这样它们在未来就不容易被黑客攻击。
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)23.1\. Implementing the user login form'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)23.1\. 实现用户登录表单'
- en: Before you dive into the logic that will handle users logging into the recipe
    application, establish what their sign-up and login forms will look like.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入处理用户登录到食谱应用的逻辑之前，先确定他们的注册和登录表单的外观。
- en: 'The sign-up form will look and behave like the form in new.ejs. Because most
    users will create their own accounts through a sign-up form, you’ll refer to the
    create view and `create` action for new user registrations. The form you need
    but don’t have yet is the user login form. This form takes two inputs: `email`
    and `password`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表单的外观和行为将与new.ejs中的表单相似。因为大多数用户将通过注册表单创建自己的账户，所以你会参考创建视图和`create`动作来处理新用户注册。你需要但还没有的是用户登录表单。此表单需要两个输入：`email`和`password`。
- en: 'First, create a basic user login view, and connect it with a new route and
    controller actions. Then create a new login.ejs view in the users folder with
    the code from the next listing. Notice the important addition here: the `/users/login`
    action in the form tag. You need to create a route to handle `POST` requests to
    that path.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个基本的用户登录视图，并将其与新的路由和控制器动作连接起来。然后，在users文件夹中创建一个新的login.ejs视图，并使用下一列表中的代码。注意这里的重要添加：表单标签中的`/users/login`动作。你需要创建一个路由来处理对该路径的`POST`请求。
- en: Listing 23.1\. Creating a user login form in login.ejs
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.1\. 在login.ejs中创建用户登录表单
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Add a form for user login.**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加用户登录表单。**'
- en: Next, add the login route by adding the code in [listing 23.2](#ch23ex02) to
    main.js. The first route allows you to see the login form when a `GET` request
    is made to the `/users/login` path. The second route handles `POST` requests to
    the same path. In this case, you route the request to the `authenticate` action,
    followed by the `redirectView` action to load a page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在[列表23.2](#ch23ex02)中添加代码到main.js中，添加登录路由。第一个路由允许你在对`/users/login`路径发起`GET`请求时看到登录表单。第二个路由处理对同一路径的`POST`请求。在这种情况下，你将请求路由到`authenticate`动作，然后是`redirectView`动作来加载页面。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll want to add these routes above the lines where you have your show and
    edit routes; otherwise, Express.js will mistake the word `login` in the path for
    a user ID and try to find that user. When you add the route above those lines,
    your application will identify the full path as the `login` route before looking
    for a user ID in the URL.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的show和edit路由上方添加这些路由；否则，Express.js会将路径中的单词`login`误认为是用户ID，并尝试找到该用户。当你在这行上方添加路由时，你的应用程序将首先识别完整的`login`路由，然后再在URL中查找用户ID。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 23.2\. Adding the login route to main.js
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.2\. 在main.js中添加登录路由
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **Add a route to handle GET requests made to the /users/login path.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个路由来处理对/用户/login路径的GET请求。**'
- en: '***2*** **Add a route to handle POST requests to the same path.**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加一个路由来处理同一路径的POST请求。**'
- en: Create the necessary controller actions in your users controller to get the
    login form working. Add the code from [listing 23.3](#ch23ex03) to usersController.js.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的用户控制器中创建必要的控制器操作以使登录表单工作。将[列表23.3](#ch23ex03)中的代码添加到usersController.js中。
- en: The `login` action renders the `login` view for user login. The `authenticate`
    action finds one user with the matching email address. Because this attribute
    is unique in the database, it should find that single user or no user at all.
    Then the form password is compared with the database password and redirected to
    that user’s `show` page if the passwords match. As in previous actions, set the
    `res.locals.redirect` variable to a path that the `redirectView` action will handle
    for you. Also set a flash message to let the user know they’ve logged in successfully,
    and pass the `user` object as a local variable to that user’s `show` page. By
    calling `next` here, you invoke the next middleware function, which is `redirectView`.
    If no user is found, but no error occurred in the search for a user, set an `error`
    flash message, and set the redirect path to take the user back to the login form
    to try again.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`操作渲染用户登录的`login`视图。`authenticate`操作查找与匹配的电子邮件地址的用户。由于此属性在数据库中是唯一的，它应该找到该单个用户或根本找不到用户。然后，将表单密码与数据库密码进行比较，如果密码匹配，则重定向到该用户的`show`页面。与先前的操作一样，将`res.locals.redirect`变量设置为一个`redirectView`操作将为您处理的路径。还要设置一个闪存消息，让用户知道他们已成功登录，并将`user`对象作为局部变量传递给该用户的`show`页面。在这里调用`next`，将调用下一个中间件函数，即`redirectView`。如果没有找到用户，但在搜索用户时没有发生错误，设置一个错误闪存消息，并将重定向路径设置为将用户带回到登录表单以再次尝试。'
- en: If an error occurs, log it to the console, and pass the error to the next middleware
    function that handles errors (in your errors controller).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，请在控制台记录它，并将错误传递给处理错误的下一个中间件函数（在你的错误控制器中）。
- en: Listing 23.3\. Adding login and authenticate actions to usersController.js
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.3\. 在usersController.js中添加登录和认证操作
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Add the login action.**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加登录操作。**'
- en: '***2*** **Add the authenticate action.**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加认证操作。**'
- en: '***3*** **Compare the form password with the database password.**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **比较表单密码与数据库密码。**'
- en: '***4*** **Log errors to the console, and redirect.**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将错误记录到控制台，并重定向。**'
- en: At this point, you should be able to relaunch your Node.js application and visit
    the `users/login` URL to see the form in [figure 23.1](#ch23fig01). Try logging
    in with the email address and password of a user in your database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够重新启动你的Node.js应用程序，并访问`users/login` URL以查看[图23.1](#ch23fig01)中的表单。尝试使用你数据库中用户的电子邮件地址和密码进行登录。
- en: Figure 23.1\. Example of user login page in your browser
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图23.1\. 浏览器中用户登录页面示例
- en: '![](../Images/23fig01_alt.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23fig01_alt.jpg)'
- en: If you type an incorrect email or password, you’re redirected to the login screen
    with a flash message like the one in [figure 23.2](#ch23fig02). If you log in
    successfully, your screen will look like [figure 23.3](#ch23fig03).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入了错误的电子邮件或密码，你将被重定向到登录屏幕，并显示一个类似于[图23.2](#ch23fig02)的消息。如果你成功登录，你的屏幕将看起来像[图23.3](#ch23fig03)。
- en: Figure 23.2\. Failed user login page in your browser
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图23.2\. 浏览器中失败的用户登录页面
- en: '![](../Images/23fig02_alt.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23fig02_alt.jpg)'
- en: Figure 23.3\. Successful user login page in your browser
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图23.3\. 浏览器中的成功用户登录页面
- en: '![](../Images/23fig03_alt.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23fig03_alt.jpg)'
- en: 'You have a problem, though: the passwords are still being saved in plain text.
    In the next section, I talk about ways to hash that information.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你有一个问题：密码仍然以纯文本形式保存。在下一节中，我将讨论如何对信息进行散列的方法。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 23.1**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查23.1**'
- en: '**[Q1:](#ch23qa3q0a1)**'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch23qa3q0a1)**'
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does the placement of the `/users/login` route matter in main.js?
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么在main.js中放置`/users/login`路由的位置很重要？
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 23.1 answer**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.1 答案**'
- en: '**[1:](#ch23qa1q1)**'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch23qa1q1)**'
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Because you have routes that handle parameters in the URL, if those routes
    (such as `/users/:id`) come first, Express.js will treat a request to `/users/login`
    as a request to the user’s `show` page, where `login` is the `:id`. Order matters:
    if the `/users/login` route comes first, Express.js will match that route before
    checking the routes that handle parameters.'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为你有处理URL中参数的路由，如果这些路由（例如 `/users/:id`）排在前面，Express.js 将将 `/users/login` 的请求视为对用户
    `show` 页面的请求，其中 `login` 是 `:id`。顺序很重要：如果 `/users/login` 路由排在前面，Express.js 将在检查处理参数的路由之前匹配该路由。
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)23.2\. Hashing passwords'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)23.2\. 散列密码'
- en: '*Encryption* is the process of combining some unique key or passphrase with
    sensitive data to produce a value that represents the original data but is otherwise
    useless. The process includes hashing data, the original value of which can be
    retrieved with a private key used for the hashing function. This *hashed* value
    is stored in the database instead of the sensitive data. When you want to encrypt
    new data, pass that data through the encryption algorithm. When you want to retrieve
    that data or compare it with, say, a user’s input password, the application can
    use the same unique key and algorithm to decrypt the data.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密* 是将某些独特密钥或密码短语与敏感数据结合以产生一个代表原始数据但其他方面无用的值的过程。这个过程包括散列数据，其原始值可以使用用于散列函数的私有密钥检索。这个
    *散列* 值存储在数据库中而不是敏感数据。当你想要加密新数据时，通过加密算法传递该数据。当你想要检索该数据或将其与，比如说，用户的输入密码进行比较时，应用程序可以使用相同的独特密钥和算法来解密数据。'
- en: '`bcrypt` is a sophisticated hashing function that allows you to combine certain
    unique keys in your application to store data such as passwords in your database.
    Fortunately, you can use a few Node.js packages to implement `bcrypt` hashing.
    First, install the `bcrypt` package by typing `npm i bcrypt@5.0.0 -S` in a new
    terminal window. Next, require `bcrypt` into the module where you’ll perform the
    hashing. Hashing can occur in the `usersController`, but a better approach is
    to create a Mongoose `pre`-save hook in the `User` model. Require `bcrypt` in
    user.js with `const bcrypt = require("bcrypt")`. Then add the code in [listing
    23.4](#ch23ex04) to your `User` model, above the `module.exports` line but after
    your schema definition.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`bcrypt` 是一种复杂的散列函数，它允许你将应用程序中的一些独特密钥组合起来，以在数据库中存储密码等数据。幸运的是，你可以使用几个Node.js包来实现
    `bcrypt` 散列。首先，在新的终端窗口中输入 `npm i bcrypt@5.0.0 -S` 安装 `bcrypt` 包。接下来，将 `bcrypt`
    引入你将执行散列的模块中。散列可以在 `usersController` 中进行，但更好的方法是创建一个 Mongoose `pre`-save 钩子在 `User`
    模型中。在 user.js 中使用 `const bcrypt = require("bcrypt")` 引入 `bcrypt`。然后，在 `module.exports`
    行之前但 schema 定义之后，将 [代码列表 23.4](#ch23ex04) 中的代码添加到 `User` 模型中。'
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll only be hashing passwords, not encrypting them, because you technically
    don’t want to retrieve the original value of a password. In fact, your application
    should have no knowledge of a user’s password. The application should be able
    only to hash a password. Later, hash password attempts, and compare the hashed
    values. I talk more about this topic later in this section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你只会对密码进行散列，而不是加密，因为从技术上讲，你不想检索密码的原始值。实际上，你的应用程序不应该知道用户的密码。应用程序只能散列密码。稍后，我将在这个部分更详细地讨论这个话题。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Mongoose `pre` and `post` hooks are great ways to run some code on the `User`
    instance before and after the user is saved to the database. Attach the hook to
    the `userSchema`, which (like other middleware) takes `next` as a parameter. The
    `bcrypt.hash` method takes a password and a number. The number represents the
    level of complexity against which you’d like to hash your password, and 10 is
    generally accepted as a reliable number. When the hashing of the password is complete,
    the next part of the promise chain accepts the resulting `hash` (your hashed password).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 的 `pre` 和 `post` 钩子是在用户保存到数据库前后运行代码的绝佳方式。将钩子附加到 `userSchema` 上，它（就像其他中间件一样）接受
    `next` 作为参数。`bcrypt.hash` 方法接受一个密码和一个数字。这个数字代表你想要散列密码的复杂度级别，10 通常被认为是可靠的数字。当密码散列完成时，promise
    链的下一部分接受生成的 `hash`（你的散列密码）。
- en: Assign the user’s password to this `hash`, and call `next`, which saves the
    user to the database. If any errors occur, they’ll be logged and passed to the
    next middleware.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户的密码分配给这个 `hash`，并调用 `next`，这将用户保存到数据库中。如果发生任何错误，它们将被记录并传递给下一个中间件。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Because you lose context within this pre-hook when you run `bcrypt.hash`, I
    suggest preserving `this` in a variable that can be accessed within the hashing
    function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在运行 `bcrypt.hash` 时你失去了上下文，我建议将 `this` 保留在一个变量中，以便在散列函数中访问。
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`passwordComparison` is your custom method on the `userSchema`, allowing you
    to compare passwords from a form’s input with the user’s stored and hashed password.
    To perform this check asynchronously, use the promise library with `bcrypt`. `bcrypt.compare`
    returns a Boolean value comparing the user’s password with the `inputPassword`.
    Then return the promise to whoever called the `passwordComparison` method.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`passwordComparison` 是你在 `userSchema` 上的自定义方法，允许你将表单输入的密码与用户的存储和散列密码进行比较。为了异步执行此检查，使用
    `bcrypt` 的 promise 库。`bcrypt.compare` 返回一个布尔值，比较用户的密码与 `inputPassword`。然后返回 promise
    给调用 `passwordComparison` 方法的任何人。'
- en: Listing 23.4\. Adding a hashing pre hook in user.js
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.4\. 在 user.js 中添加散列前置钩子
- en: '[PRE9]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Add a pre hook to the user schema.**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在用户模式中添加一个前置钩子。**'
- en: '***2*** **Hash the user’s password.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **散列用户的密码。**'
- en: '***3*** **Add a function to compare hashed passwords.**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加一个比较散列密码的函数。**'
- en: '***4*** **Compare the user password with the stored password.**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **比较用户密码与存储的密码。**'
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'A `pre` hook on `save` is run any time the user is saved: on creation and after
    an update via the Mongoose `save` method.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户被保存时，会运行 `save` 的 `pre` 钩子：在创建和通过 Mongoose `save` 方法更新后。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The final step is rewriting the `authenticate` action in usersController.js
    to compare passwords with `bcrypt.compare`. Replace the code block for the `authenticate`
    action with the code in [listing 23.5](#ch23ex05).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是重写 usersController.js 中的 `authenticate` 动作，使用 `bcrypt.compare` 来比较密码。将
    `authenticate` 动作代码块替换为 [列表 23.5](#ch23ex05) 中的代码。
- en: First, explicitly query for one user by `email`. If a user is found, assign
    the result to `user`. Then check whether a user was found or `null` is returned.
    If a user with the specified email address is found, call your custom `passwordComparison`
    method on the user instance, passing the form’s input password as an argument.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过 `email` 明确查询一个用户。如果找到用户，将结果分配给 `user`。然后检查是否找到用户或返回 `null`。如果找到具有指定电子邮件地址的用户，则在用户实例上调用你的自定义
    `passwordComparison` 方法，并将表单的输入密码作为参数传递。
- en: Because `passwordComparison` returns a promise that resolves with `true` or
    `false`, nest another `then` to wait for a result. If `passwordsMatch` is `true`,
    redirect to the user’s show page. If a user with the specified email doesn’t exist
    or the input password is incorrect, return to the login screen. Otherwise, throw
    an error, and pass it in your `next` object. Any errors thrown or occurring during
    this process are caught and logged.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `passwordComparison` 返回一个解析为 `true` 或 `false` 的 promise，嵌套另一个 `then` 以等待结果。如果
    `passwordsMatch` 为 `true`，则重定向到用户的显示页面。如果未找到具有指定电子邮件地址的用户或输入密码不正确，则返回登录屏幕。否则，抛出错误，并将其传递给你的
    `next` 对象。在此过程中抛出或发生的任何错误都会被捕获并记录。
- en: Listing 23.5\. Modifying the `authenticate` action in usersController.js
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.5\. 修改 usersController.js 中的 `authenticate` 动作
- en: '[PRE10]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Query for one user by email.**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **通过电子邮件查询一个用户。**'
- en: '***2*** **Check whether a user is found.**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查是否找到了用户。**'
- en: '***3*** **Call the password comparison method on the User model.**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在 User 模型上调用密码比较方法。**'
- en: '***4*** **Check whether the passwords match.**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **检查密码是否匹配。**'
- en: '***5*** **Call the next middleware function with redirect path and flash message
    set.**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **使用重定向路径和闪存消息调用下一个中间件函数。**'
- en: '***6*** **Log errors to console and pass to the next middleware error handler.**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将错误记录到控制台并传递给下一个中间件错误处理器。**'
- en: Relaunch your Node.js application, and create a new user. You’ll need to create
    new accounts moving forward because previous account passwords weren’t securely
    hashed with `bcrypt`. If you don’t, `bcrypt` will try to hash and compare your
    input password with a plain-text password. After the account is created, try logging
    in again with the same password at `/users/login`. Then change the password field
    in the user’s `show` page to display the password on the screen. Visit a user’s
    `show` page to see the new hashed password in place of the old plain-text one
    ([figure 23.4](#ch23fig04)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的 Node.js 应用程序，并创建一个新用户。从现在开始，你需要创建新账户，因为之前的账户密码没有使用 `bcrypt` 安全散列。如果不这样做，`bcrypt`
    将尝试散列和比较你的输入密码与纯文本密码。账户创建后，尝试使用相同的密码在 `/users/login` 上再次登录。然后更改用户 `show` 页面中的密码字段以在屏幕上显示密码。访问用户的
    `show` 页面以查看新的散列密码，而不是旧的纯文本密码 ([图 23.4](#ch23fig04))。
- en: Figure 23.4\. Show hashed password in user’s `show` page in browser
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 23.4\. 在浏览器中用户 `show` 页面显示散列密码
- en: '![](../Images/23fig04_alt.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23fig04_alt.jpg)'
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can also verify that passwords are hashed at the database level by entering
    the MongoDB shell with `mongo` in a new terminal window and then typing `use recipe_db`
    and `db.users.find({})`. Alternatively, you can use the MongoDB Compass software
    to see the new records in this database.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在新的终端窗口中输入 `mongo` 并然后输入 `use recipe_db` 和 `db.users.find({})` 来 MongoDB
    shell 验证密码是否在数据库级别被散列。或者，你可以使用 MongoDB Compass 软件查看此数据库中的新记录。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now when you log in for a user with a hashed password, you should be redirected
    to that user’s `show` page upon successful authentication. If you type an incorrect
    password, you get a screen like [figure 23.5](#ch23fig05).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你为一个散列密码的用户登录时，你应该在成功认证后重定向到该用户的 `show` 页面。如果你输入了错误的密码，你会看到一个像 [图 23.5](#ch23fig05)
    中的屏幕。
- en: Figure 23.5\. Incorrect password screen in browser
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 23.5\. 浏览器中的错误密码界面
- en: '![](../Images/23fig05_alt.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23fig05_alt.jpg)'
- en: In the next section, you add some more security to the `create` and `update`
    actions by adding validation middleware before those actions are called.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你通过在调用这些操作之前添加验证中间件来为 `create` 和 `update` 操作添加更多安全性。
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 23.2**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 23.2**'
- en: '**[Q1:](#ch23qa6q0a1)**'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch23qa6q0a1)**'
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: `bcrypt`’s `compare` method compares the plain-text password
    in your database with the plain-text value from the user’s input.'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对或错：`bcrypt` 的 `compare` 方法比较数据库中的明文密码与用户输入的明文值。
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 23.2 answer**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.2 答案**'
- en: '**[1:](#ch23qa4q1)**'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch23qa4q1)**'
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: False. The only password value in the database is a hashed password, so there’s
    no plain-text value to compare against. The comparison works by hashing the user’s
    new input and comparing the newly created hashed value with the stored hash value
    in the database. This way, the application still won’t know your actual password,
    but if two hashed passwords match, you can safely say that your input matched
    the original password you set up.
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误。数据库中唯一的密码值是一个散列密码，因此没有明文值可以比较。比较是通过散列用户的新输入并与数据库中存储的散列值进行比较来完成的。这样，应用程序仍然不知道你的实际密码，但如果两个散列密码匹配，你可以安全地说你的输入与最初设置的密码匹配。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)23.3\. Adding validation middleware with express-validator'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)23.3\. 使用 express-validator 添加验证中间件'
- en: So far, your application offers validation at the view and model levels. If
    you try to create a user account without an email address, your HTML forms should
    prevent you from doing so. If you get around the forms, or if someone tries to
    create an account via your application programming interface (API), as you see
    in [unit 6](../Text/kindle_split_042.html#part06), your model schema restrictions
    should prevent invalid data from entering your databases—though more validation
    can’t hurt. In fact, if you could add more validation before your models are reached
    in the application, you could save a lot of computing time and machine energy
    spent making Mongoose queries and redirecting pages.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的应用程序在视图和模型级别提供了验证。如果你尝试创建一个没有电子邮件地址的用户账户，你的 HTML 表单应该阻止你这样做。如果你绕过了表单，或者如果有人试图通过你的应用程序编程接口（API）创建账户，就像你在第
    6 单元中看到的那样，你的模型模式限制应该阻止无效数据进入你的数据库——尽管更多的验证也无妨。实际上，如果你能在模型到达应用程序之前添加更多验证，你就可以节省大量用于制作
    Mongoose 查询和重定向页面的计算时间和机器能量。
- en: For those reasons, you’ll validate middleware, and as is true of most common
    needs in Node.js, some packages are available to help you build those middleware
    functions. The package you’ll install is `express-validator`, which provides a
    library of methods you can use to check whether incoming data follows a certain
    format and methods that modify that data to remove unwanted characters. You can
    use `express-validator` to check whether some input data is entered in the format
    of a U.S. phone number, for example.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，你需要验证中间件，并且正如 Node.js 中大多数常见需求一样，有一些包可以帮助你构建这些中间件函数。你将安装的包是 `express-validator`，它提供了一组你可以用来检查传入数据是否遵循特定格式的函数，以及修改该数据以删除不需要的字符的函数。例如，你可以使用
    `express-validator` 来检查某些输入数据是否以美国电话号码的格式输入。
- en: You can install this package by typing `npm i express-validator -S` in your
    project folder in terminal. When this package is installed, require it with `const
    expressValidator = require("express-validator")` in main.js, and tell your Express.js
    app to use it by adding `router.use(expressValidator())`. You need to add this
    line after the line where `express.json()` and `express.urlencoded()` middleware
    is introduced, because the request body must be parsed before you can validate
    it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端的项目文件夹中输入 `npm i express-validator -S` 来安装此包。当此包安装后，在 main.js 中使用 `const
    expressValidator = require("express-validator")` 引入它，并通过添加 `router.use(expressValidator())`
    告诉您的 Express.js 应用程序使用它。您需要在引入 `express.json()` 和 `express.urlencoded()` 中间件之后添加此行，因为在验证之前必须解析请求体。
- en: Then you can add this middleware to run directly before the call to the `create`
    action in the `usersController`. To accomplish this task, you need to create a
    `validate` action between the path and `create` action in the `POST` route to
    `/users/create` in main.js, as shown in [listing 23.6](#ch23ex06). Between the
    path, `/users/create`, and the `usersController.create` action, you introduce
    a middleware function called `validate`. Through this `validate` action, you’ll
    determine whether data meets your requirements to continue to the `create` action.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将此中间件添加到在 `usersController` 中的 `create` 动作之前直接运行。为了完成此任务，您需要在 main.js
    中 `/users/create` 路由的路径和 `create` 动作之间创建一个名为 `validate` 的动作，如图 [列表 23.6](#ch23ex06)
    所示。在路径 `/users/create` 和 `usersController.create` 动作之间，您引入了一个名为 `validate` 的中间件函数。通过这个
    `validate` 动作，您将确定数据是否符合您的要求，以便继续到 `create` 动作。
- en: Listing 23.6\. Adding the validate middleware to the users create route in main.js
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.6\. 在 main.js 中将验证中间件添加到用户创建路由
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Add the validate middleware to the users create route.**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将验证中间件添加到用户创建路由。**'
- en: 'Finally, create the `validate` action in usersController.js to handle requests
    before they reach the `create` action. In this action, you add the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 usersController.js 中创建 `validate` 动作来处理在到达 `create` 动作之前到达的请求。在这个动作中，您添加以下内容：
- en: '*Validators*—Check whether incoming data meets certain criteria.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Validators*—检查传入的数据是否符合某些标准。'
- en: '*Sanitizers*—Modify incoming data by removing unwanted elements or casting
    the data type before it enters the database.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sanitizers*—在数据进入数据库之前，通过删除不需要的元素或转换数据类型来修改传入的数据。'
- en: Add the code in [listing 23.7](#ch23ex07) to your usersController.js.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [列表 23.7](#ch23ex07) 中的代码添加到 usersController.js 中。
- en: The first validation function uses the request and response, and it may pass
    on to the next function in the middleware chain, so you need the `next` parameter.
    Start with a sanitization of the `email` field, using `express-validator's normalizeEmail`
    method to convert all email addresses to lowercase and then `trim` whitespace
    away. Follow with the validation of `email` to make sure that it follows the email-format
    requirements set by `express-validator`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个验证函数使用请求和响应，并且它可能传递到中间件链中的下一个函数，因此您需要 `next` 参数。从对 `email` 字段的清理开始，使用 `express-validator`
    的 `normalizeEmail` 方法将所有电子邮件地址转换为小写，然后 `trim` 移除空白。接着验证 `email`，确保它符合 `express-validator`
    设置的电子邮件格式要求。
- en: The `zipCode` validation ensures that the value isn’t empty and is an integer,
    and that the length is exactly five digits. The last validation checks that the
    `password` field isn’t empty. `req.getValidationResult` collects the results of
    the previous validations and returns a promise with those error results.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipCode` 验证确保值不为空，是一个整数，并且长度正好是五位数字。最后的验证检查 `password` 字段是否为空。`req.getValidationResult`
    收集先前验证的结果，并返回一个包含这些错误结果的承诺。'
- en: If errors occur, you can collect their error messages and add them to your request’s
    flash messages. Here, you’re joining the series of messages with `" and "` in
    one long `String`. If errors have occurred in the validations, set `req.skip =
    true`. Here, `set` is the new custom property you’re adding to the request object.
    This value tells your next middleware function, `create`, not to process your
    user data because of validation errors and instead to skip to your `redirectView`
    action. For this code to work, you need to add `if (req.skip) next()` as the first
    line in the `create` action. This way, when `req.skip` is `true`, you continue
    to the next middleware immediately.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，您可以收集它们的错误消息并将它们添加到请求的闪存消息中。在这里，您使用 `" and "` 将一系列消息连接成一个长的`String`。如果验证过程中发生了错误，设置`req.skip
    = true`。在这里，`set`是您添加到请求对象中的新自定义属性。此值告诉您的下一个中间件函数`create`，由于验证错误不要处理您的用户数据，而是跳转到您的`redirectView`操作。为了使此代码正常工作，您需要在`create`操作中添加`if
    (req.skip) next()`作为第一行。这样，当`req.skip`为`true`时，您可以立即继续到下一个中间件。
- en: In the event of validation errors, render the `new` view again. Your `flashMessages`
    also indicate to the user what errors occurred with her input data.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证错误的情况下，再次渲染`new`视图。您的`flashMessages`也向用户指示了她的输入数据中发生了什么错误。
- en: Listing 23.7\. Creating a `validate` controller in usersController.js
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.7\. 在usersController.js中创建一个`validate`控制器
- en: '[PRE12]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Add the validate function.**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加验证函数。**'
- en: '***2*** **Remove whitespace with the trim method.**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用trim方法去除空白。**'
- en: '***3*** **Validate the zipCode field.**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **验证zipCode字段。**'
- en: '***4*** **Validate the password field.**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **验证密码字段。**'
- en: '***5*** **Collect the results of previous validations.**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **收集先前验证的结果。**'
- en: '***6*** **Set skip property to true.**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将跳过属性设置为true。**'
- en: '***7*** **Add error messages as flash messages.**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **将错误消息作为闪存消息添加。**'
- en: '***8*** **Set redirect path for the new view.**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **为新视图设置重定向路径。**'
- en: '***9*** **Call the next middleware function.**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **调用下一个中间件函数。**'
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can take many creative approaches to repopulating form data. You may find
    that some packages are helpful in assisting with this task. When you find the
    technique that works best for you, change all the forms in your application to
    handle repopulating data.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以采取许多创造性的方法来重新填充表单数据。您可能会发现一些包有助于协助这项任务。当您找到最适合您的技术时，将应用程序中的所有表单更改为处理数据重新填充。
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’re ready to give these validations a shot. Launch your application, and
    create a new user in ways that should fail your validations. You may need to remove
    the `required` tags from your HTML forms first if you want to test the `notEmpty`
    validations. Your failed `password` and `zipCode` validations should send you
    to a screen resembling [figure 23.6](#ch23fig06).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为这些验证尝试一下。启动您的应用程序，并以应该使您的验证失败的方式创建一个新用户。如果您想测试`notEmpty`验证，可能需要先从您的HTML表单中删除`required`标签。失败的`password`和`zipCode`验证应该会将您带到类似于[图23.6](#ch23fig06)的屏幕。
- en: Figure 23.6\. Failed `express-validator` validation messages
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图23.6\. 失败的`express-validator`验证消息
- en: '![](../Images/23fig06_alt.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23fig06_alt.jpg)'
- en: Because `express-validator` uses the `validator` package, you can get more information
    about the sanitizers to use at [https://github.com/chriso/validator.js#sanitizers](https://github.com/chriso/validator.js#sanitizers).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`express-validator`使用`validator`包，您可以在[https://github.com/chriso/validator.js#sanitizers](https://github.com/chriso/validator.js#sanitizers)获取有关要使用的清洗器的更多信息。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 23.3**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查23.3**'
- en: '**[Q1:](#ch23qa9q0a1)**'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch23qa9q0a1)**'
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between a sanitizer and a validator?
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 清洗器和验证器之间的区别是什么？
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 23.3 answer**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.3 答案**'
- en: '**[1:](#ch23qa7q1)**'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch23qa7q1)**'
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A sanitizer cleans data by trimming whitespace, changing the case, or removing
    unwanted characters. A validator tests data quality to ensure that the way it
    was entered meets your database requirements.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 清洗器通过修剪空白、更改大小写或删除不需要的字符来清理数据。验证器测试数据质量，以确保其输入方式符合您的数据库要求。
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you implemented a hashing function for your users’ passwords.
    Then you created a login form and action by using the `bcrypt.compare` method
    to match hashed passwords against user input on login. At the end, you added more
    validations on input data through an additional middleware function to sanitize
    data before it’s saved to your database. In [lesson 24](../Text/kindle_split_040.html#ch24),
    you take another look at encryption and authentication through Passport.js tools,
    which make setting up secure user accounts much easier.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你为用户的密码实现了一个散列函数。然后，你通过使用`bcrypt.compare`方法创建了一个登录表单和动作，将散列密码与登录时的用户输入进行匹配。最后，你通过添加额外的中间件函数来对输入数据进行额外的验证，以在将其保存到数据库之前清理数据。在[第24课](../Text/kindle_split_040.html#ch24)中，你将再次通过Passport.js工具查看加密和身份验证，这些工具使得设置安全用户账户变得更加容易。
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试以下操作**'
- en: Hashing user passwords is probably the leading scenario for using hashing functions,
    but you can use hashing functions on other fields on your models. You might hash
    a user’s email address to prevent that data from getting into the wrong hands,
    for example. After all, getting access to a user’s email is getting halfway to
    hacking that user’s account. Try adding hashing to user emails in addition to
    passwords.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 散列用户密码可能是使用散列函数的主要场景，但你可以在你的模型的其他字段上使用散列函数。例如，你可能会对用户的电子邮件地址进行散列，以防止这些数据落入错误的手中。毕竟，获取用户的电子邮件地址就相当于黑客攻击用户账户的一半。尝试在密码之外，为用户电子邮件添加散列。
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Note
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When you hash a user’s email address, you won’t be able to display it in any
    views. Although you may choose to keep user emails in plain text, this practice
    is good to follow when other sensitive data enters your application.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你散列用户的电子邮件地址时，你将无法在任何视图中显示它。尽管你可能会选择以纯文本形式保留用户电子邮件，但当你应用程序中其他敏感数据进入时，遵循这种做法是好的。
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 24\. Adding User Authentication
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第24课\. 添加用户身份验证
- en: In [lesson 23](../Text/kindle_split_039.html#ch23), you learned about manual
    hashing of passwords and the importance of securing user data. In this lesson,
    you explore some popular and useful tools that make the hashing process less messy.
    You modify your hashing methods to use the `passport-local-mongoose` package,
    which uses `passport` and `mongoose` together to perform hashing for you behind
    the scenes. Next, you learn how to use Passport.js to authenticate user accounts
    on your application. This process involves session cookies, similar to the way
    that flash messages use them. By the end of this lesson, you’ll have a sign-up
    and login form that permits only true users of your application to have access.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第23课](../Text/kindle_split_039.html#ch23)中，你学习了手动散列密码以及保护用户数据的重要性。在本课中，你将探索一些流行的且实用的工具，这些工具可以使散列过程更加整洁。你修改了你的散列方法，以使用`passport-local-mongoose`包，该包结合使用`passport`和`mongoose`在幕后为你执行散列。接下来，你将学习如何使用Passport.js在你的应用程序上验证用户账户。这个过程涉及到会话cookie，类似于闪存消息使用它们的方式。在本课结束时，你将拥有一个注册和登录表单，它只允许你的应用程序的真实用户访问。
- en: This lesson covers
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Using the `passport` package to authenticate users throughout your application
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`passport`包在整个应用程序中验证用户
- en: Implementing the `passport-local-mongoose` plugin on your user model
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户模型上实现`passport-local-mongoose`插件
- en: Creating authentication actions before user login
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户登录之前创建身份验证操作
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You’ve added a popular hashing method to your application, but you’d like to
    simplify the code or, better, put it behind the scenes. It’s great to know how
    hashing works, and tools are available to perform the hashing you want without
    the need to manually set up your own criteria for hashing. Packages such as `passport.js`
    hash and authenticate user interactions without your needing to specify a password
    field in the schema. In this lesson, you look at the quickest and most efficient
    implementations of the `passport` package.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经向你的应用程序添加了一个流行的散列方法，但你希望简化代码，或者更好的是，将其放在幕后。了解散列的工作原理是很好的，而且有可用的工具可以执行你想要的散列，而无需手动设置自己的散列标准。例如，`passport.js`包可以散列和验证用户交互，而无需在模式中指定密码字段。在本课中，你将查看`passport`包的最快和最有效实现。
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)24.1\. Implementing Passport.js'
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)24.1\. 实现Passport.js'
- en: Passport.js is middleware used by Node.js to hash new user passwords and authenticate
    their activity on an application. Passport.js uses different methods to create
    and log in user accounts, ranging from basic login with username and password
    to login with third-party services such as Facebook. These login methods are called
    *strategies*, and the strategy you’ll use for your recipe application is a `local`
    strategy because you aren’t using external services.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js 是 Node.js 中间件，用于对新的用户密码进行哈希处理并验证他们在应用程序上的活动。Passport.js 使用不同的方法来创建和登录用户账户，从基本的用户名和密码登录到使用
    Facebook 等第三方服务的登录。这些登录方法被称为 *策略*，你将为你的食谱应用程序使用的策略是一个 `local` 策略，因为你没有使用外部服务。
- en: These strategies check whether incoming data is authentic by managing hashing
    and comparison of passwords and data relating to the user’s login state. For more
    information about the Passport.js strategies, visit [www.passportjs.org](http://www.passportjs.org).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略通过管理哈希和比较密码以及与用户登录状态相关的数据来检查传入数据是否真实。有关 Passport.js 策略的更多信息，请访问 [www.passportjs.org](http://www.passportjs.org)。
- en: To start, install the necessary packages for your application. You need to install
    the `passport` package along with the `passport-local-mongoose` packages by running
    `npm i passport passport-local-mongoose -S` in your project’s terminal window.
    The modules from these packages work together to provide hashing and authentication
    methods and support to communicate directly with your Mongoose schemas. After
    you install these packages as dependencies, require them where needed in the application.
    Add the following lines from [listing 24.1](#ch24ex01) to main.js.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装应用程序所需的必要包。你需要通过在项目终端窗口中运行 `npm i passport passport-local-mongoose -S`
    来安装 `passport` 包以及 `passport-local-mongoose` 包。这些包中的模块协同工作，提供哈希和认证方法以及与你的 Mongoose
    架构直接通信的支持。在你将这些包作为依赖项安装后，在应用程序中需要的地方引入它们。将 [列表 24.1](#ch24ex01) 中的以下行添加到 main.js
    中。
- en: Start by requiring the `passport` module. Passport.js uses methods called strategies
    for users to log in. The `local` strategy refers to the username and password
    login method. You `initialize` the passport module and have your Express.js app
    use it. Now you have `passport` ready as middleware in your application. `passport.session`
    tells `passport` to use whatever sessions you’ve already set up with your application.
    In this case, before this line, you have `express-session` set up for flash messaging.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，引入 `passport` 模块。Passport.js 使用名为策略的方法让用户登录。`local` 策略指的是用户名和密码登录方法。你 `initialize`
    passport 模块，并让 Express.js 应用程序使用它。现在你已经在应用程序中准备好了 `passport` 作为中间件。`passport.session`
    告诉 `passport` 使用你已与应用程序设置的任何会话。在这种情况下，在此行之前，你已经为闪存消息设置了 `express-session`。
- en: Listing 24.1\. Requiring and initializing passport in main.js
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.1\. 在 main.js 中引入和初始化 passport
- en: '[PRE13]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Require the passport module.**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入 passport 模块。**'
- en: '***2*** **Initialize passport.**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **初始化 passport。**'
- en: '***3*** **Configure passport to use sessions in Express.js.**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在 Express.js 中配置 passport 使用会话。**'
- en: Next, you need to set up your login strategy on the user model and tell `passport`
    to handle the hashing of user data in sessions for you. `passport-local-mongoose`
    makes this process simple and pretty much automatic. Add the lines in [listing
    24.2](#ch24ex02) to main.js.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在用户模型上设置你的登录策略，并告诉 `passport` 为你处理会话中的用户数据哈希。`passport-local-mongoose`
    使此过程简单且几乎自动化。将 [列表 24.2](#ch24ex02) 中的行添加到 main.js 中。
- en: '|  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`passport.session` tells `passport` to use any previously used Express.js sessions
    defined. Sessions must be defined before this line.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`passport.session` 告诉 `passport` 使用之前定义的任何 Express.js 会话。在此行之前必须定义会话。'
- en: '|  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You need to make sure that your user model is made available in main.js before
    you continue to connect it with `passport`. Normally, you’d need to set up some
    configurations to create a login strategy for a model, but because you’re using
    the default local login strategy, you only need to tell `passport` to use the
    strategy created for the user model. The next two lines tell `passport` to serialize
    and deserialize your users through the `User` model. These lines direct the process
    of encrypting and decrypting user data stored in sessions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续将用户模型与 `passport` 连接之前，你需要确保你的用户模型在 main.js 中可用。通常，你需要设置一些配置来为模型创建登录策略，但由于你正在使用默认的本地登录策略，你只需要告诉
    `passport` 使用为用户模型创建的策略。接下来的两行告诉 `passport` 通过 `User` 模型序列化和反序列化你的用户。这些行指导了加密和解密存储在会话中的用户数据的过程。
- en: Listing 24.2\. Setting up passport serializing in main.js
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表24.2\. 在main.js中设置passport序列化
- en: '[PRE14]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Require the User model.**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要用户模型。**'
- en: '***2*** **Configure the user’s login strategy.**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **配置用户的登录策略。**'
- en: '***3*** **Set up passport to serialize and deserialize your user data.**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **设置passport以序列化和反序列化您的用户数据。**'
- en: Passport serializes and deserializes user data to pass into a session. The session
    stores this serialized data—a condensed form of user information, which is sent
    back to the server to verify the user as the last one logged in from the client.
    Deserializing extracts the user data from its condensed version so that you can
    verify the user’s information.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Passport将用户数据序列化和反序列化以传递到会话中。会话存储此序列化数据——用户信息的压缩形式，并将其发送回服务器以验证用户是客户端最后登录的用户。反序列化从其压缩版本中提取用户数据，以便您可以验证用户的信息。
- en: '|  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Serializing data**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化数据**'
- en: When working with objects in an application, you want to preserve the data structure
    that allows you to access and modify properties easily. Your user objects, for
    example, allow you to retrieve information such as `email` or even to use the
    User model’s virtual attribute `fullName`. Although the model is particularly
    useful within your application, you have no straightforward way to send this user
    object, along with its methods and Mongoose object-document mapper (ODM) tools,
    to a client. As a result, you need to serialize the user data.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当在应用程序中处理对象时，您希望保留允许您轻松访问和修改属性的数据结构。例如，您的用户对象允许您检索诸如`email`之类的信息，甚至可以使用用户模型的虚拟属性`fullName`。尽管该模型在您的应用程序中特别有用，但您没有直接的方法将此用户对象及其方法和Mongoose对象-文档映射器（ODM）工具发送到客户端。因此，您需要序列化用户数据。
- en: '*Serialization* is the process of converting data from some data structure
    to a compact readable format. This data can take on many formats, such as JSON,
    YAML, and XML. The user data is flattened, often into strings, so that it can
    be sent within an HTTP transaction.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列化*是将数据从某些数据结构转换为紧凑的可读格式的过程。这些数据可以采用多种格式，例如JSON、YAML和XML。用户数据被扁平化，通常转换为字符串，以便在HTTP事务中发送。'
- en: Passport.js performs the serialization process and encrypts your user’s data
    so that it can be stored as part of the session cookie on the client’s browser.
    Because this cookie contains information about the user, it lets your application
    server know, the next time a request occurs, that this user has logged in before,
    which is your way of validating some-one’s state in your application.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js执行序列化过程并加密用户数据，以便将其存储为客户端浏览器会话cookie的一部分。因为这个cookie包含有关用户的信息，它让您的应用程序服务器知道，在下次请求发生时，这个用户之前已经登录过，这是您在应用程序中验证某人状态的方式。
- en: When the same user makes another request to your application, Passport.js deserializes
    the data to restore the user to its original model object form. When that process
    completes and you verify that the user is valid, you can use the user object again
    as before, applying model methods and using Mongoose queries.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一用户再次向您的应用程序发出请求时，Passport.js将数据反序列化以将用户恢复到其原始模型对象形式。当这个过程完成并且您验证用户有效后，您可以使用用户对象再次像以前一样使用，应用模型方法和使用Mongoose查询。
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The last step before building the authentication action to log users into your
    application is to connect your user model to the `passport-local-mongoose` module.
    Add `const passportLocalMongoose = require("passport-local-mongoose")` to the
    top of user.js, which is where you’ll add a Passport.js plugin to the user schema,
    as shown in [listing 24.3](#ch24ex03). Using the Mongoose `plugin` method, you’re
    telling your `userSchema` to use `passportLocalMongoose` for password hashing
    and storage. You’re also telling `passportLocalMongoose` to use the email field
    as the user’s login parameter instead of a username because username is the default
    field for this module.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建将用户登录到您的应用程序的认证动作之前，最后一步是将您的用户模型连接到`passport-local-mongoose`模块。在user.js的顶部添加`const
    passportLocalMongoose = require("passport-local-mongoose")`，您将在其中向用户模式添加Passport.js插件，如[列表24.3](#ch24ex03)所示。使用Mongoose的`plugin`方法，您告诉您的`userSchema`使用`passportLocalMongoose`进行密码散列和存储。您还告诉`passportLocalMongoose`使用电子邮件字段作为用户的登录参数，而不是用户名，因为用户名是这个模块的默认字段。
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This line must appear before you register your User model.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这行必须在您注册用户模型之前出现。
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 24.3\. Adding the `passport-local-mongoose` plugin to the user schema
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表24.3\. 将`passport-local-mongoose`插件添加到用户模式
- en: '[PRE15]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Apply the passport-local-mongoose module as a plugin to the user
    schema.**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将 passport-local-mongoose 模块作为插件应用到用户模式中。**'
- en: When this line is in place, Passport.js automatically takes care of password
    storage, so you can remove the `password` property from `userSchema`. This plugin
    modifies your schema behind the scenes to add `hash` and `salt` fields to your
    `User` model in place of the normal `password` field.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一行被放置到位时，Passport.js 会自动处理密码存储，因此你可以从`userSchema`中删除`password`属性。此插件在幕后修改你的模式，将`hash`和`salt`字段添加到你的`User`模型中，以替换正常的`password`字段。
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Hash and salt**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希和盐**'
- en: You learned about hashing in [lesson 24](#ch24), but you let `bcrypt` perform
    the hashing process through an algorithm that you didn’t need to understand. Exactly
    how do `bcrypt` and Passport.js hash user passwords?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 24 课](#ch24)中学习了哈希，但你让`bcrypt`通过一个你不需要理解的算法执行哈希过程。`bcrypt`和Passport.js究竟是如何哈希用户密码的？
- en: Modern hashing takes the user’s input password and converts it into an undecipherable
    hash. This hash is a jumble of characters and numbers, making it safer to store
    in a database than the plain-text password. If anyone hacks the database, he has
    only the hashed passwords. The best he can do at that point is enter his own guesses
    at a password into his own hashing function to see whether the resulting hash
    matches yours. That task is a tedious one, but it’s not impossible for hackers
    to find a way to crack your hashed passwords. Salts were introduced to battle
    this vulnerability.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现代哈希将用户的输入密码转换为不可解密的哈希。这个哈希是一堆字符和数字的混合，使其比明文密码更安全地存储在数据库中。如果有人黑入数据库，他只有哈希密码。他最好的办法是将自己的猜测密码输入自己的哈希函数，看看生成的哈希是否与你的匹配。这是一项繁琐的任务，但黑客找到破解你的哈希密码的方法并不是不可能的。盐的引入是为了对抗这种漏洞。
- en: '*Salts* are short strings of random characters that are added to a plain-text
    password before the password is hashed. This way, if someone maliciously guessed
    your password, they would also need to know the salt associated with it and where
    to place it in the original password. Hacking has become a lot more difficult.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*盐*是一系列随机的字符字符串，在哈希密码之前添加到明文密码中。这样，如果有人恶意猜测你的密码，他们还需要知道与之关联的盐以及它在原始密码中的位置。黑客攻击变得更加困难。'
- en: 'Passport.js stores both the hashed password and salt in your database so that
    you can perform hashing consistently within your application. When you register
    your first users with Passport.js, take a look at their data in MongoDB to see
    those values by following these steps:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js 将哈希密码和盐都存储在数据库中，以便你可以在应用程序内一致地执行哈希操作。当你使用 Passport.js 注册第一个用户时，请按照以下步骤查看
    MongoDB 中的他们的数据，以查看这些值：
- en: In a new terminal window, run `mongo`.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个新的终端窗口中，运行`mongo`。
- en: Run `use recipe_db` to load your recipe database.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`use recipe_db`来加载你的食谱数据库。
- en: 'Run `db.users.find({}, { password: 1})` to view all user passwords.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '运行`db.users.find({}, { password: 1})`来查看所有用户密码。'
- en: Compare the hashed and nonhashed passwords.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较哈希和非哈希密码。
- en: '|  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that any reference to the `password` attribute in your application
    is removed. Because `passport-local-mongoose` adds new password fields to the
    User model, you won’t be using it anymore.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 确保删除应用程序中对`password`属性的任何引用。因为`passport-local-mongoose`向用户模型添加了新的密码字段，所以你将不再使用它。
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the next section, you use the `passport` package to simplify the authentication
    process even more.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将使用`passport`包来进一步简化认证过程。
- en: '|  |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 24.1**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.1**'
- en: '**[Q1:](#ch24qa3q0a1)**'
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch24qa3q0a1)**'
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: A `salt` is needed to hash passwords.'
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 真或假：哈希密码需要盐。
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 24.1 answer**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 24.1 答案**'
- en: '**[1:](#ch24qa1q1)**'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch24qa1q1)**'
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: False. Salts help make the hashing of passwords stronger by mixing random text
    with plain-text passwords before they’re hashed, but salts aren’t required.
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误。盐可以帮助通过在哈希之前将随机文本与明文密码混合来增强密码的哈希强度，但盐不是必需的。
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)24.2\. Modifying the create action to use passport
    registration'
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)24.2\. 修改创建操作以使用 passport 注册'
- en: Using Passport.js has already simplified your code and made it easier to specify
    which models you’d like to hash and authenticate. The next step is modifying your
    `create` action, so instead of using your `bcrypt` hashing function before creating
    a user account, you’ll use Passport.js. By incorporating the Passport.js modules,
    you have access to a library of methods to streamline the account registration
    process. Change the `create` action in usersController.js to use the `register`
    method, as shown in [listing 24.4](#ch24ex04).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Passport.js 已经简化了您的代码，并使您更容易指定您想要散列和验证的模型。下一步是修改您的 `create` 动作，这样在创建用户账户之前不再使用您的
    `bcrypt` 散列函数，而是使用 Passport.js。通过集成 Passport.js 模块，您将能够访问一个方法库，以简化账户注册过程。将 usersController.js
    中的 `create` 动作更改为使用 `register` 方法，如 [列表 24.4](#ch24ex04) 所示。
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You must comment out or remove the `userSchema.methods.passwordComparison` and
    `pre("save")` hook for `bcrypt` in the User model. If you don’t remove these hooks,
    `bcrypt` will still try to hash user passwords before `passport` is able to, which
    also results in an unhandled promise error.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须注释掉或删除 User 模型中的 `userSchema.methods.passwordComparison` 和 `pre("save")`
    钩子，对于 `bcrypt`。如果您不删除这些钩子，`bcrypt` 仍然会在 `passport` 之前尝试散列用户密码，这也会导致一个未处理的承诺错误。
- en: '|  |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `register` method comes with Passport.js. Because you’re using `passport-local-mongoose`
    as a plugin for the User model, you can use this method to register users. If
    you successfully save a new user, create a flash message and redirect to the `/users`
    route. Otherwise, handle any errors that occur by redirecting to the `users/new`
    route so that another attempt to create a user account can be made.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`register` 方法是 Passport.js 的一部分。因为您正在将 `passport-local-mongoose` 作为 User 模型的插件使用，所以您可以使用此方法来注册用户。如果您成功保存了一个新用户，创建一个闪存消息并将重定向到
    `/users` 路由。否则，通过将重定向到 `users/new` 路由来处理发生的任何错误，以便可以再次尝试创建用户账户。'
- en: Listing 24.4\. Registering new users in the create action in usersController.js
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.4\. 在 usersController.js 的 create 动作中注册新用户
- en: '[PRE16]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1*** **Register new users.**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **注册新用户。**'
- en: '***2*** **Set redirect for successful user creation.**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置成功创建用户的重定向。**'
- en: '***3*** **Set redirect and log errors in flash messages.**'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在闪存消息中设置重定向和记录错误。**'
- en: With this action in place, you can use the form in /users/new.ejs to create
    user accounts through Passport.js. Try launching your application and creating
    a new user. You shouldn’t notice a change in behavior; your user account will
    be created, and you’ll see the `success` flash message.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在此操作生效后，您可以使用位于 /users/new.ejs 的表单通过 Passport.js 创建用户账户。尝试启动您的应用程序并创建一个新用户。您不应该注意到行为上的变化；您的用户账户将被创建，并且您将看到
    `success` 提示信息。
- en: 'If you look at the raw documents in MongoDB by typing `mongo` in a new terminal
    window, then type `use recipe_db` and `db.users.find({})` to see the users in
    your database. Any users saved with `bcrypt` still have their `password` field
    with a hashed password saved. Your latest user has two properties added by Passport.js:
    `salt` and `hash`.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在新的终端窗口中通过输入 `mongo` 来查看 MongoDB 中的原始文档，然后输入 `use recipe_db` 和 `db.users.find({})`
    来查看您数据库中的用户。任何使用 `bcrypt` 保存的用户仍然保留有包含散列密码的 `password` 字段。您最新的用户有两个由 Passport.js
    添加的属性：`salt` 和 `hash`。
- en: '|  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Update your seed.js file to register user accounts with `passport` instead of
    the Mongoose `create` method. This practice makes it easier to repopulate your
    database as your application grows in development.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的 seed.js 文件更新为使用 `passport` 而不是 Mongoose 的 `create` 方法来注册用户账户。这种做法使您在开发过程中随着应用程序的增长重新填充数据库变得更加容易。
- en: '|  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Update your seed.js file to register user accounts with Passport instead of
    the Mongoose `create` method, which will make it easier to repopulate your database
    as your application grows in development.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的 seed.js 文件更新为使用 Passport 而不是 Mongoose 的 `create` 方法来注册用户账户，这将使您在开发过程中随着应用程序的增长重新填充数据库变得更加容易。
- en: Your users are still secure, but you still need a way to log them in. In the
    next section, you modify the login form to use Passport.js.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您的用户仍然安全，但您仍然需要一个方法来登录他们。在下一节中，您将修改登录表单以使用 Passport.js。
- en: '|  |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 24.2**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.2**'
- en: '**[Q1:](#ch24qa6q0a1)**'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch24qa6q0a1)**'
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does Passport.js need you to save the `hash` and the `salt` in your database?
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Passport.js 为什么需要您在数据库中保存 `hash` 和 `salt`？
- en: '|  |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 24.2 answer**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 24.2 答案**'
- en: '**[1:](#ch24qa4q1)**'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch24qa4q1)**'
- en: ''
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Passport.js saves the `salt` and the `hash` so that each user can have their
    own unique hashing factors. It’s possible to use the same `salt` for every user
    account and only store the hash in the database, but this approach is less secure.
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Passport.js 保存了`salt`和`hash`，这样每个用户都可以拥有他们自己的唯一哈希因子。虽然可以为每个用户账户使用相同的`salt`，并且只将哈希存储在数据库中，但这种方法的安全性较低。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)24.3\. Authenticating users at login'
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)24.3. 登录时认证用户'
- en: The final step in allowing users to log in to the application is replacing the
    `bcrypt` authentication method with `passport` middleware. Modify your `authenticate`
    action in usersController.js with the new action, as shown in [listing 24.5](#ch24ex05).
    You also need to require `passport` into the users controller by adding `const
    passport = require("passport")` to the top of the file.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户登录应用程序的最终一步是将`bcrypt`认证方法替换为`passport`中间件。在usersController.js中修改你的`authenticate`动作，如[列表24.5](#ch24ex05)所示。你还需要通过在文件顶部添加`const
    passport = require("passport")`将`passport`引入到用户控制器中。
- en: This `authenticate` action is set to call `passport.authenticate` method directly
    with `passport` redirect and flash-message options. When you call `usersController.authenticate`,
    you’re calling `passport.authenticate`. In this function, `passport` attempts
    to compare the incoming request data, describing a user, with the database records.
    If a user account is found and the input password aligns with the hashed password,
    you redirect from this action.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`authenticate`动作被设置为直接调用`passport.authenticate`方法，并带有`passport`重定向和提示信息选项。当你调用`usersController.authenticate`时，你实际上是在调用`passport.authenticate`。在这个函数中，`passport`试图将描述用户的传入请求数据与数据库记录进行比较。如果找到用户账户并且输入的密码与哈希密码相匹配，你将从该动作重定向。
- en: Listing 24.5\. Adding passport authentication middleware in usersController.js
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表24.5. 在usersController.js中添加Passport认证中间件
- en: '[PRE17]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** **Call on passport to authenticate a user via the local strategy.**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**. 调用Passport通过本地策略认证用户。'
- en: '***2*** **Set up success and failure flash messages and redirect paths based
    on the user’s authentication status.**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**. 根据用户的认证状态设置成功和失败提示信息以及重定向路径。'
- en: The login route no longer needs your `usersController.redirectView` action as
    a follow-up function. With your `router.post("/users/login", usersController.authenticate);`
    route set up from [lesson 23](../Text/kindle_split_039.html#ch23), your application
    is ready to authenticate existing users. Restart your application, and log in
    with a user account you’ve created at `/users/login`. If you’re successful, you
    should see the `success` flash message.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 登录路由不再需要你的`usersController.redirectView`动作作为后续函数。从[第23课](../Text/kindle_split_039.html#ch23)中设置的`router.post("/users/login",
    usersController.authenticate);`路由开始，你的应用程序已经准备好验证现有用户。重新启动你的应用程序，并使用你在`/users/login`创建的用户账户登录。如果你成功，你应该会看到`success`提示信息。
- en: It would be nice to have a visual indication that you’re logged in and maybe
    a way to log out. Add the code from [listing 24.6](#ch24ex06) to your navigation
    bar in layout.ejs. You’re checking whether the local variable `loggedIn` is set
    to `true`. If so, display the text `Signed in as` followed by the user’s `fullName`,
    which you get from the `currentUser` local variable. This list item is wrapped
    in an anchor tag that, when clicked, takes you to the currently logged-in user’s
    `show` page. If the `loggedIn` status is `false`, show a link to `Sign In`, taking
    you to the `/users/login` route.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个视觉指示表明你已经登录，以及可能有注销的方式，那就很好了。将[列表24.6](#ch24ex06)中的代码添加到layout.ejs中的导航栏。你正在检查局部变量`loggedIn`是否设置为`true`。如果是，显示文本`已登录为`后跟从`currentUser`局部变量获取的用户的`fullName`。这个列表项被包裹在一个锚标签中，当点击时，会带你到当前登录用户的`show`页面。如果`loggedIn`状态为`false`，显示一个链接到`Sign
    In`，带你到`/users/login`路由。
- en: Listing 24.6\. Adding login status to navigation bar in layout.ejs
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表24.6. 在layout.ejs中添加导航栏的登录状态
- en: '[PRE18]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** **Check whether a user is logged in.**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**. 检查用户是否已登录。'
- en: '***2*** **Display a link to log in.**'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**. 显示一个登录链接。'
- en: If you refresh your application, you may not see anything change in the navigation
    bar yet. You need to create the `loggedIn` and `currentUser` variables so that
    they appear locally in each view. To do so, add some custom middleware so that
    on every new request, you add these variables to the response. Because you’ve
    already created a middleware function to set up `flashMessages` as a local object,
    you can add the code in [listing 24.7](#ch24ex07) within that middleware function
    in main.js.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新应用程序，您可能仍然在导航栏中看不到任何变化。您需要创建`loggedIn`和`currentUser`变量，以便它们在每个视图中本地显示。为此，添加一些自定义中间件，以便在每次新的请求中，您将这些变量添加到响应中。因为您已经创建了一个用于设置`flashMessages`为本地对象的中间件函数，所以您可以在main.js中的该中间件函数内添加代码，见[代码列表24.7](#ch24ex07)。
- en: '`isAuthenticated` is a method provided by Passport.js, which you can call on
    the incoming request to see whether an existing user is stored in the request’s
    cookies. `loggedIn` is either `true` or `false`. If a user is in the request,
    you can pull it out and assign it to your own `currentUser` variable. After adding
    this code, you gain access to both of these variables, along with `flashMessages`,
    on every page.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`isAuthenticated`是Passport.js提供的一个方法，您可以在传入的请求上调用它，以查看是否在请求的cookie中存储了现有用户。`loggedIn`可以是`true`或`false`。如果请求中有用户，您可以将其提取出来并分配给您的`currentUser`变量。添加此代码后，您可以在每个页面上访问这两个变量以及`flashMessages`。'
- en: Listing 24.7\. Adding local variables to custom middleware
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表24.7. 在自定义中间件中添加本地变量
- en: '[PRE19]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **Set up the loggedIn variable to reflect passport login status.**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置`loggedIn`变量以反映护照登录状态。**'
- en: '***2*** **Set up the currentUser to reflect a logged-in user.**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置`currentUser`以反映已登录用户。**'
- en: Restart your application to see whether your name appears in the navigation
    bar. Your screen may look like [figure 24.1](#ch24fig01).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的应用程序以查看您的名字是否出现在导航栏中。您的屏幕可能看起来像[图24.1](#ch24fig01)。
- en: Figure 24.1\. Example of a successful login in the browser
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图24.1. 浏览器中成功登录的示例
- en: '![](../Images/24fig01_alt.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![图24.1](../Images/24fig01_alt.jpg)'
- en: This figure includes a logout link in the navigation bar. To create this link,
    add `<a href="/users/logout">Log out</a>` below the line where the name of the
    `currentUser` appears. To get this link working, you need to create a route and
    action for logging out. First, add `router.get("/users/logout", usersController.logout,
    usersController.redirect-View)` to main.js next to where your `login` routes are
    located. Then add the `logout` action from [listing 24.8](#ch24ex08) to usersController.js.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此图在导航栏中包含一个注销链接。要创建此链接，在`currentUser`名称出现的行下方添加`<a href="/users/logout">注销</a>`。要使此链接工作，您需要创建一个用于注销的路由和动作。首先，在main.js中您的`login`路由旁边添加`router.get("/users/logout",
    usersController.logout, usersController.redirect-View)`。然后，将[代码列表24.8](#ch24ex08)中的`logout`动作添加到usersController.js中。
- en: This action uses the `logout` method provided by Passport.js on the request
    to clear the user’s session. During the next pass through your custom middleware,
    `isAuthenticated` returns `false`, and there’ll no longer be a current user. Follow
    this operation with a flash message to indicate that the user has been logged
    out and a redirect to the home page through the `redirectView` action.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为使用Passport.js在请求上提供的`logout`方法来清除用户的会话。在通过您的自定义中间件的下一个传递过程中，`isAuthenticated`返回`false`，并且将不再有当前用户。随后通过`redirectView`行为将用户重定向到主页，并显示一条消息提示用户已注销。
- en: Listing 24.8\. Adding a logout action in usersController.js
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表24.8. 在usersController.js中添加注销动作
- en: '[PRE20]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Add an action to log users out.**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个注销用户的行为。**'
- en: With this action in place, it’s time to test the full login process. Restart
    your application, log in, and then click the `logout` link in the navigation bar
    ([figure 24.2](#ch24fig02)). Your session should be cleared and your account successfully
    logged out.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在此动作就绪后，是时候测试完整的登录过程了。重新启动您的应用程序，登录，然后点击导航栏中的`注销`链接([图24.2](#ch24fig02))。您的会话应该被清除，并且您的账户成功注销。
- en: Figure 24.2\. Example of a successful user logout in the browser
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图24.2. 浏览器中成功注销用户的示例
- en: '![](../Images/24fig02_alt.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图24.2](../Images/24fig02_alt.jpg)'
- en: In [lesson 25](../Text/kindle_split_041.html#ch25), you apply user authentication
    to the capstone project.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第25课](../Text/kindle_split_041.html#ch25)中，您将用户身份验证应用于毕业设计项目。
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 24.3**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查24.3**'
- en: '**[Q1:](#ch24qa9q0a1)**'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch24qa9q0a1)**'
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you have access to Passport.js methods on the request throughout the
    application?
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您如何在应用程序中访问Passport.js的方法？
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 24.3 answer**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 24.3 答案**'
- en: '**[1:](#ch24qa7q1)**'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch24qa7q1)**'
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because you added the `passport` module as middleware within Express.js, you
    have access to the library of methods provided by Passport.js. These methods are
    extended to the request as it enters the application. As that request is passed
    through the middleware chain, you can call these `passport` methods on it anywhere
    you like.
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于你在 Express.js 中添加了 `passport` 模块作为中间件，因此你可以访问 Passport.js 提供的方法库。这些方法扩展到了请求进入应用程序时。当请求通过中间件链传递时，你可以在任何你想要的地方调用这些
    `passport` 方法。
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![25.1. 总结](../Images/sectionFig.png)'
- en: In this lesson, you added a few Passport.js packages to assist in the encryption
    and authentication of user data. By connecting an additional validation action
    to your user-login middleware chain, you can ensure that user passwords are secure
    and the login experience is consistent. In the next capstone lesson ([lesson 25](../Text/kindle_split_041.html#ch25)),
    you apply these validation, hashing, encryption, and authentication techniques
    to improve the Confetti Cuisine application experience.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你添加了一些 Passport.js 包来协助加密和验证用户数据。通过将额外的验证操作连接到你的用户登录中间件链，你可以确保用户密码安全，并且登录体验一致。在下一课的综合练习（[第
    25 课](../Text/kindle_split_041.html#ch25)）中，你将应用这些验证、散列、加密和认证技术来改善 Confetti Cuisine
    应用程序体验。
- en: '|  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: You’ve successfully implemented Passport.js to work with your User model and
    Mongoose ODM. Because Passport.js does a lot of the heavy lifting for you, it
    may seem that there isn’t much else to add to the login process, but you always
    have room for more middleware. Add a middleware function, called `logEmail`, between
    validation and encryption. This middleware should log to console the user’s email
    address domain (such as `gmail`, `yahoo`, or `live`) and pass to the next middleware
    function.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功实现了 Passport.js 与你的 User 模型和 Mongoose ODM 一起工作。由于 Passport.js 为你做了很多繁重的工作，你可能觉得登录过程没有太多可以添加的，但你总是有更多中间件的空间。在验证和加密之间添加一个名为
    `logEmail` 的中间件函数，这个中间件应该将用户的电子邮件地址域名（如 `gmail`、`yahoo` 或 `live`）记录到控制台，并将其传递给下一个中间件函数。
- en: '|  |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lesson 25\. Capstone: Adding User Authentication to Confetti Cuisine'
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 25 课。综合练习：为 Confetti Cuisine 添加用户认证
- en: My contacts at Confetti Cuisine are delighted with the progress on their application.
    They’ve already started to add new course offerings, manage new subscribers, and
    spread the word about creating new user accounts. I warn them that although user
    accounts can be created, the application isn’t ready to handle users securely.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Confetti Cuisine 的联系人对于他们应用程序的进展感到非常高兴。他们已经开始了添加新的课程提供、管理新的订阅者以及宣传创建新用户账户的工作。我警告他们，尽管可以创建用户账户，但应用程序还没有准备好安全地处理用户。
- en: The client and I agree that data encryption and proper user authentication are
    the way forward, so for my next improvements to the application, I’m going to
    add a couple of packages that use Passport.js to assist in setting up a secure
    user-login process. I’ll also add flash messaging so that users can tell after
    a redirect or page render whether their last operation was successful. Then I’ll
    add some additional validations with the help of the `express-validator` middleware
    package.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和我都认为数据加密和适当的用户认证是前进的方向，因此，为了我对应用程序的下一步改进，我打算添加几个使用 Passport.js 的包来协助设置安全的用户登录流程。我还会添加闪存消息，以便用户在重定向或页面渲染后能够知道他们的上一个操作是否成功。然后，我将借助
    `express-validator` 中间件包添加一些额外的验证。
- en: By the end of this stage of development, I can comfortably encourage Confetti
    Cuisine to sign users up for their application. Because the application isn’t
    yet live online, though, the client will have to run it locally on their machines
    when users sign up.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 到了开发这个阶段结束时，我可以放心地鼓励 Confetti Cuisine 为他们的应用程序注册用户。然而，由于应用程序尚未上线，因此当用户注册时，客户需要在他们的机器上本地运行它。
- en: 'For this capstone exercise, I’ll need to do the following:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个综合练习，我需要做以下几件事情：
- en: Add sessions and cookies between page requests
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面请求之间添加会话和 cookies
- en: Add new custom middleware for validations and setting up local variables in
    the views
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中添加新的自定义中间件，用于验证和设置局部变量
- en: Create a login form
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建登录表单
- en: Add passport authentication and encryption for the `User` model
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `User` 模型添加 passport 认证和加密
- en: Add a visual indicator to show which user is logged in
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个视觉指示器来显示哪个用户已登录
- en: '![](../Images/sectionFig.png)25.1\. Getting set up'
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![25.1. 设置](../Images/sectionFig.png)'
- en: 'Working off the code I wrote in the last capstone exercise ([lesson 21](../Text/kindle_split_036.html#ch21)),
    I currently have three models implemented with CRUD actions for each. To move
    forward with the improvements to Confetti Cuisine’s application, I need to install
    a few more packages:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我在上一个综合练习（[课程21](../Text/kindle_split_036.html#ch21)）中编写的代码，我目前实现了三个模型，并为每个模型实现了
    CRUD 动作。为了继续改进 Confetti Cuisine 的应用程序，我需要安装一些额外的包：
- en: '`express-session` allows me to store temporary data about the user interaction
    with the application. The resulting sessions let me know whether a user has logged
    in recently.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express-session` 允许我存储有关用户与应用程序交互的临时数据。生成的会话让我知道用户是否最近登录过。'
- en: '`cookie-parser` allows me to store session data on the client. The resulting
    cookies are sent with each request and response, carrying within them messages
    and data reflecting the user who last used that client.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie-parser` 允许我在客户端存储会话数据。生成的cookie会随每个请求和响应发送，其中包含反映最后使用该客户端的用户的消息和数据。'
- en: '`connect-flash` allows me to use sessions and cookies to generate flash messages
    in the user’s browser.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect-flash` 允许我使用会话和cookie在用户的浏览器中生成闪存消息。'
- en: '`express-validator` allows me to add a layer of validations to incoming user
    data through a middleware function.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express-validator` 允许我通过中间件函数为传入的用户数据添加一层验证。'
- en: '`passport` allows me to set up a painless encryption and authentication process
    for the `User` model.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`passport` 允许我为 `User` 模型设置一个无痛苦的加密和认证过程。'
- en: '`passport-local-mongoose` allows me to integrate `passport` even further by
    simplifying the code I need to write through a plugin I can use on the `User`
    model.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`passport-local-mongoose` 允许我通过在 `User` 模型上使用插件进一步集成 `passport`，从而简化我需要编写的代码。'
- en: To install these packages, I’ll run `npm i express-session cookie-parser connect-flash
    express-validator passport passport-local-mongoose -S` in my projects terminal
    window. I’ve already set up the `create` action and `new` form for users. I need
    to modify those soon, but first, I’ll create the login form needed for users to
    log in to the application.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些包，我将在项目的终端窗口中运行 `npm i express-session cookie-parser connect-flash express-validator
    passport passport-local-mongoose -S`。我已经设置了 `create` 动作和 `new` 表单用于用户。我需要很快修改这些，但首先，我将创建用户登录应用程序所需的登录表单。
- en: '![](../Images/sectionFig.png)25.2\. Creating a login form'
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)25.2\. 创建登录表单'
- en: 'I want this form to contain two straightforward inputs: `email` and `password`.
    I’ll create a new login.ejs view in the users folder and add the code in the next
    listing. This form will submit a `POST` request to the `/users/login` route. The
    inputs of this form will handle the user’s `email` and `password`.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这个表单包含两个简单的输入：`email` 和 `password`。我将在用户文件夹中创建一个新的 login.ejs 视图，并添加下一个列表中的代码。此表单将向
    `/users/login` 路由提交 `POST` 请求。此表单的输入将处理用户的 `email` 和 `password`。
- en: Listing 25.1\. Adding a login form to users/login.ejs
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表25.1\. 在 users/login.ejs 中添加登录表单
- en: '[PRE21]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Create a login form.**'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建登录表单。**'
- en: Before this form can work or be viewed, I’ll add the `login` routes and actions.
    The `login` will accept `GET` and `POST` requests, as shown in the following listing.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在此表单可以工作或被查看之前，我将添加 `login` 路由和动作。`login` 将接受 `GET` 和 `POST` 请求，如下所示。
- en: '|  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I add all routing-specific code on the `router` object.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我将所有与路由相关的代码添加到 `router` 对象上。
- en: '|  |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 25.2\. Adding a login route to main.js
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表25.2\. 在 main.js 中添加登录路由
- en: '[PRE22]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **Route to the login action.**'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **到登录动作的路由。**'
- en: '***2*** **Send posted data to an authenticate action.**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将提交的数据发送到认证动作。**'
- en: '***3*** **Add a route to logout and redirect to a view.**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加一个退出路由并重定向到一个视图。**'
- en: With these routes in place, I need to create their corresponding actions before
    my form is viewable at `/users/login`. First, I’ll add the `login` action from
    the next listing to users-Controller.js.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些路由就位后，在表单在 `/users/login` 可视化之前，我需要创建它们对应的动作。首先，我将添加下一个列表中的 `login` 动作到 users-Controller.js。
- en: Listing 25.3\. Adding the `login` action to usersController.js
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表25.3\. 在 usersController.js 中添加 `login` 动作
- en: '[PRE23]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **Add an action to render my form for browser viewing.**'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个动作来渲染我的表单以供浏览器查看。**'
- en: In the next section, I use the `passport` package to start encrypting user data
    so that this login form will have a purpose.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我使用 `passport` 包开始加密用户数据，这样这个登录表单就会有实际用途。
- en: '![](../Images/sectionFig.png)25.3\. Adding encryption with Passport.js'
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)25.3\. 使用 Passport.js 添加加密'
- en: To start using Passport.js, I need to require the `passport` module in main.js
    and in users-Controller.js by adding `const passport = require("passport")` to
    the top of both files. These files are ones within which I’ll set up hashing and
    authentication. Next, I need to initialize and use `passport` within Express.js
    as middleware. Because `passport` uses sessions and cookies, I also need to require
    `express-session` and `cookie-parser` to main.js, adding the lines in [listing
    25.4](#ch25ex04) to that file.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Passport.js，我需要在 main.js 和 users-Controller.js 中引入 `passport` 模块，通过在两个文件的顶部添加
    `const passport = require("passport")` 来实现。这些文件是我将在其中设置哈希和认证的文件。接下来，我需要在 Express.js
    中作为中间件初始化并使用 `passport`。因为 `passport` 使用会话和 cookie，所以我还需要在 main.js 中引入 `express-session`
    和 `cookie-parser`，将 [列表 25.4](#ch25ex04) 中的行添加到该文件中。
- en: To start using `passport`, I need to configure `cookieParser` with a secret
    key to encrypt the cookies stored on the client. Then I’ll have Express.js use
    sessions as well. This stage in the setup process is where `passport` starts to
    store information about active users of the application. `passport` officially
    becomes middleware by telling Express.js to initialize and use it on this line.
    Because sessions were set up before this line, I instruct Express.js to have `passport`
    use those preexisting sessions for its user data storage.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 `passport`，我需要使用一个密钥来配置 `cookieParser` 以加密客户端上存储的 cookie。然后，我将让 Express.js
    也使用会话。在设置过程中，这一阶段是 `passport` 开始存储应用程序活跃用户信息的地方。通过告诉 Express.js 在这一行初始化并使用它，`passport`
    正式成为中间件。因为在此行之前已经设置了会话，所以我指示 Express.js 让 `passport` 使用那些现有的会话来存储其用户数据。
- en: I set up the default login strategy, provided through the `passport-local-mongoose`
    module that I’ll soon add to the `User` model, to enable authentication for users
    with `passport`. The last two lines allow `passport` to compact, encrypt, and
    decrypt user data as it’s sent between the server and client.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了默认登录策略，这是通过即将添加到 `User` 模型的 `passport-local-mongoose` 模块提供的，以使用 `passport`
    为用户提供身份验证。最后两行允许 `passport` 在服务器和客户端之间发送数据时压缩、加密和解密用户数据。
- en: Listing 25.4\. Adding `passport` with Express.js in main.js
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 25.4\. 在 main.js 中使用 Express.js 添加 `passport`
- en: '[PRE24]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **Configure cookieParser with a secret key.**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用密钥配置 cookieParser。**'
- en: '***2*** **Configure Express.js to use sessions.**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **配置 Express.js 使用会话。**'
- en: '***3*** **Configure Express.js to initialize and use passport.**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **配置 Express.js 初始化并使用 passport。**'
- en: '***4*** **Instruct passport to use sessions.**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **指示 passport 使用会话。**'
- en: '***5*** **Set up the default login strategy.**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **设置默认登录策略。**'
- en: '***6*** **Set up passport to compact, encrypt, and decrypt user data.**'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **设置 passport 以压缩、加密和解密用户数据。**'
- en: '|  |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I need to make sure that the `User` model is required in main.js before I can
    use the `createStrategy` method. This method works only after I set up the User
    model with `passport-local-mongoose`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在我能够使用 `createStrategy` 方法之前，我需要确保在 main.js 中引入了 `User` 模型。此方法只有在用 `passport-local-mongoose`
    设置了用户模型之后才能工作。
- en: '|  |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With this configuration set up, I can move to the `User` model in user.js to
    add `passport-local-mongoose`. I need to require `passport-local-mongoose` in
    my User model by adding `const passportLocalMongoose = r``e``quire("passport-local-mongoose")`
    to the top of user.js.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好此配置后，我可以将注意力转向 user.js 中的 `User` 模型，以添加 `passport-local-mongoose`。我需要在 user.js
    的顶部添加 `const passportLocalMongoose = require("passport-local-mongoose")` 来在用户模型中引入
    `passport-local-mongoose`。
- en: In this file, I attach the module as a plugin to `userSchema`, as shown in [listing
    25.5](#ch25ex05). This line sets up `passportLocalMongoose` to create `salt` and
    `hash` fields for the User model in my database. It also treats the `email` attribute
    as a valid field for logging in an authenticating. This code should be placed
    just above the `module.exports` line.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我将模块作为插件附加到 `userSchema` 上，如 [列表 25.5](#ch25ex05) 所示。这一行设置 `passportLocalMongoose`
    在我的数据库中的用户模型上创建 `salt` 和 `hash` 字段。它还将 `email` 属性视为登录和验证的有效字段。此代码应放置在 `module.exports`
    行之上。
- en: Listing 25.5\. Adding `passport-local-mongoose` as a plugin to the User model
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 25.5\. 将 `passport-local-mongoose` 作为插件添加到 User 模型
- en: '[PRE25]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **Add the passport-local-mongoose module as a user schema plugin.**'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将 passport-local-mongoose 模块作为用户模式插件添加。**'
- en: '|  |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: With this addition to my `User` model, I no longer need the plain-text password
    property in the user schema. I’ll remove that property now, as well as the password
    table row on the user `show` page.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 `User` 模型中添加此功能后，我不再需要在用户模式中保留纯文本密码属性。我现在将删除该属性，以及用户 `show` 页面上的密码表行。
- en: '|  |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, I modify the `create` action in usersController.js to use
    `passport` for registering new users, and I set up flash messaging so that the
    user will know whether account creation is successful.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我修改了`usersController.js`中的`create`动作，以使用`passport`注册新用户，并设置闪存消息，以便用户知道账户创建是否成功。
- en: '![](../Images/sectionFig.png)25.4\. Adding flash messaging'
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)25.4\. 添加闪存消息'
- en: 'With sessions and cookies ready to attach data to the request and respond to
    the user, I’m ready to integrate flash messaging by using `connect-flash`. To
    configure `connect-flash`, I need to require it in main.js as a constant, called
    `connectFlash`, by adding the following line: `const connectFlash = require("connect-flash")`.
    Then I tell my Express.js app to use it as middleware by adding `router.use(connectFlash())`
    to main.js.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话和cookie准备好将数据附加到请求并响应用户时，我准备通过使用`connect-flash`来集成闪存消息。为了配置`connect-flash`，我需要在main.js中将其作为一个名为`connectFlash`的常量引入，添加以下行：`const
    connectFlash = require("connect-flash")`。然后，我告诉我的Express.js应用将其用作中间件，通过在main.js中添加`router.use(connectFlash())`来实现。
- en: Now that the middleware is installed, I can call `flash` on any request in my
    application, which allows me to attach messages to the request. To get these request
    flash messages to my response, I add some custom middleware in main.js, as shown
    in [listing 25.6](#ch25ex06). By telling the Express.js app to use this custom
    middleware, I’m able to assign a local variable called `flashMessages` to objects
    containing flash messages created in my controller actions. From here, I’ll be
    able to access the `flashMessages` object in my views.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间件已安装，我可以在我的应用程序中的任何请求上调用`flash`，这允许我将消息附加到请求。为了将请求闪存消息传递到响应，我在main.js中添加了一些自定义中间件，如[列表25.6](#ch25ex06)所示。通过告诉Express.js应用使用这个自定义中间件，我能够将一个名为`flashMessages`的局部变量分配给包含在控制器动作中创建的闪存消息的对象。从这里开始，我将在我的视图中访问`flashMessages`对象。
- en: Listing 25.6\. Adding custom middleware to use flash messaging in main.js
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表25.6\. 在main.js中添加使用闪存消息的自定义中间件
- en: '[PRE26]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Assign flash messages to a local variable.**'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将闪存消息分配给局部变量。**'
- en: Because I want flash messages to appear on every page, I’ll add some code to
    my layout .ejs file to look for `flashMessages` and display them if they exist.
    I’ll add the code in [listing 25.7](#ch25ex07) to layout.ejs above the `<%- body
    %>`.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我想让闪存消息出现在每个页面上，我会在我的layout.ejs文件中添加一些代码来查找`flashMessages`并在它们存在时显示它们。我会在[列表25.7](#ch25ex07)中添加代码到layout.ejs的`<%-
    body %>`之上。
- en: I intend to show only `success` and `error` messages. First, l check whether
    `flashMessages` is defined; then I display `success` messages or `error` messages
    that are attached to the object.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算只显示`成功`和`错误`消息。首先，我检查`flashMessages`是否已定义；然后，我显示与对象关联的`成功`消息或`错误`消息。
- en: Listing 25.7\. Adding logic to use flash messaging in layout.ejs
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表25.7\. 在layout.ejs中添加使用闪存消息的逻辑
- en: '[PRE27]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Display flash messages in the view.**'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在视图中显示闪存消息。**'
- en: Finally, I test this newly added code by modifying my user’s `create` action
    to use -`passport` and flash messaging by adding the code in [listing 25.8](#ch25ex08)
    to usersController.js. The `create` action uses the `register` method provided
    by Passport.js to create a new user account. The result is a user document in
    my database with a hashed password and salt. If the user is saved successfully,
    I add a `success` flash message to be displayed in the `index` view. Otherwise,
    I show an `error` message on the user creation page.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我通过修改用户的`create`操作以使用`passport`和闪存消息，并将代码添加到`usersController.js`中的[列表25.8](#ch25ex08)来测试这个新添加的代码。`create`操作使用Passport.js提供的`register`方法创建新的用户账户。结果是数据库中包含散列密码和盐的用户文档。如果用户成功保存，我会在`index`视图中添加一个`成功`闪存消息。否则，我会在用户创建页面上显示一个`错误`消息。
- en: Listing 25.8\. Adding passport registration and flash messaging in the create
    action
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表25.8\. 在创建动作中添加passport注册和闪存消息
- en: '[PRE28]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** **Add the create action to register users.**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加创建用户动作。**'
- en: '***2*** **Respond with flash messages.**'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **响应闪存消息。**'
- en: With this action in place, I’m ready to demo my new Passport.js registration
    process with flash messaging. Next, I add some custom validations before users
    are created.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动作到位后，我准备演示我的新的带有闪存消息的Passport.js注册过程。接下来，我在用户创建之前添加一些自定义验证。
- en: '![](../Images/sectionFig.png)25.5\. Adding validation middleware with express-validator'
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)25.5\. 使用express-validator添加验证中间件'
- en: The `express-validator` module provides useful methods for sanitizing and validating
    data as it enters this application. I start by requiring the module in main.js
    by adding `const expressValidator = require(` `"``express-validator``"``)` and
    telling my Express.js application to use this module as middleware by adding `router.use(expressValidator())`
    to the same file.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`express-validator` 模块提供了在数据进入此应用程序时清理和验证数据的有用方法。我开始在 main.js 中通过添加 `const
    expressValidator = require(` `"``express-validator``"``)` 并告诉我的 Express.js 应用程序将此模块作为中间件使用，添加
    `router.use(expressValidator())` 到同一文件中。'
- en: I know that I want data to pass through some middleware validation function
    before it reaches the `create` action in the `usersController`, so I change my
    `/users/create` route to take that requirement into consideration, as shown in
    [listing 25.9](#ch25ex09). This `validate` action lives in `usersController` and
    runs before the `create` action, which ensures that my custom validation middleware
    filters bad data before it gets a chance to reach my `User` model.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我想要数据在到达 `usersController` 中的 `create` 动作之前通过一些中间件验证函数，所以我将我的 `/users/create`
    路由改为考虑这一要求，如 [列表 25.9](#ch25ex09) 所示。这个 `validate` 动作位于 `usersController` 中，在
    `create` 动作之前运行，这确保了我的自定义验证中间件在有机会到达我的 `User` 模型之前过滤掉不良数据。
- en: Listing 25.9\. Adding a validation action before create in main.js
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 25.9\. 在 main.js 中在创建之前添加验证动作
- en: '[PRE29]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1*** **Add validation middleware to the user create route.**'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **向用户创建路由添加验证中间件。**'
- en: Then I create the `validate` action in usersController.js by using the code
    in [listing 25.10](#ch25ex10). This `validate` action parses incoming requests
    and cleans the data in the request body. In this case, I’m trimming whitespace
    from the `email` fields.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我在 usersController.js 中通过使用 [列表 25.10](#ch25ex10) 中的代码创建了一个 `validate` 动作。这个
    `validate` 动作解析传入的请求并清理请求体中的数据。在这种情况下，我正在从 `email` 字段中去除空白字符。
- en: I use some other methods provided by `express-validator` to keep the emails
    in my database consistent and the ZIP codes at the required length. I’ll also
    check to make sure that users entered some password when they signed up. I collect
    any errors that may have occurred during the validation steps. Then I concatenate
    the error messages into a single string. I set a property on the request object,
    `req.skip = true`, so that I skip the `create` action and go directly back to
    the view. All flash messages display in the `users/new` view. If there are no
    errors, I call `next` to move to the `create` action.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `express-validator` 提供的一些其他方法来确保数据库中的电子邮件保持一致，并且 ZIP 码长度符合要求。我还会检查用户在注册时是否输入了密码。我收集在验证步骤中可能发生的任何错误。然后我将错误消息连接成一个单独的字符串。我在请求对象上设置一个属性，`req.skip
    = true`，这样就可以跳过 `create` 动作并直接返回视图。所有闪存消息都在 `users/new` 视图中显示。如果没有错误，我调用 `next`
    来移动到 `create` 动作。
- en: Listing 25.10\. Adding a `validate` action in usersController.js
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 25.10\. 在 usersController.js 中添加 `validate` 动作
- en: '[PRE30]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Add the validate action.**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加验证动作。**'
- en: '***2*** **Sanitize and check input field data.**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **清理并检查输入字段数据。**'
- en: '***3*** **Collect errors, and respond with flash messages.**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **收集错误，并使用闪存消息响应。**'
- en: The application is ready to validate data for user creation. The last step is
    connecting my login form to an authentication action I set up earlier.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已准备好验证用户创建的数据。最后一步是将我的登录表单连接到之前设置的认证动作。
- en: '![](../Images/sectionFig.png)25.6\. Adding authentication with Passport.js'
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)25.6\. 使用 Passport.js 添加认证'
- en: Passport.js makes my life easier by providing some default methods to use as
    middleware on requests. When I added `passport-local-mongoose`, my User model
    inherited even more useful methods than `passport` offered alone. Because the
    `passport-local-mongoose` module was added as a plugin on the User model, a lot
    of the authentication setup was taken care of behind the scenes.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js 通过提供一些默认方法作为请求中间件来简化我的生活。当我添加 `passport-local-mongoose` 时，我的用户模型继承了比
    `passport` 单独提供的更多有用的方法。因为 `passport-local-mongoose` 模块被添加为用户模型的插件，所以很多认证设置都在幕后得到了处理。
- en: The `register` method is one of the most powerful and intuitive methods provided
    by `passport`. To use it, I need to call `passport.register` and pass the login
    strategy that I plan to use. Because I’m using the default local strategy, I can
    create my `authenticate` action in usersController.js to use the `passport.authenticate`
    method as shown in [listing 25.11](#ch25ex11).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`register`方法是`passport`提供最强大和直观的方法之一。为了使用它，我需要调用`passport.register`并传递我计划使用的登录策略。因为我使用的是默认的本地策略，我可以在usersController.js中创建我的`authenticate`动作来使用`passport.authenticate`方法，如[代码列表25.11](#ch25ex11)所示。'
- en: '|  |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I need to make sure that `const passport = require("passport")` is at the top
    of my users controller.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要确保`const passport = require("passport")`位于我的用户控制器顶部。
- en: '|  |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This action points directly to the `passport.register` method. I’ve already
    created a local strategy for my `User` model in main.js and told `passport` to
    serialize and deserialize user data upon successful authentication. The options
    I add here determine which path to take if authentication succeeds or fails, with
    flash messages to go along.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动作直接指向`passport.register`方法。我已经在main.js中为我的`User`模型创建了一个本地策略，并告诉`passport`在认证成功时序列化和反序列化用户数据。我添加的选项决定了认证成功或失败时采取的路径，并附带闪存消息。
- en: Listing 25.11\. Adding an `authenticate` action in usersController.js
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表25.11\. 在usersController.js中添加`authenticate`动作
- en: '[PRE31]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1*** **Add authentication middleware with redirect and flash-message options.**'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加带有重定向和闪存消息选项的认证中间件。**'
- en: I’m ready to test authentication with my login form at `/users/login`. Everything
    should be working at this point to log an existing user into the application.
    I need only to put some finishing touches on my layout file and add a logout link.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经准备好测试在`/users/login`的登录表单进行认证。到目前为止，一切应该正常工作，以便将现有用户登录到应用程序中。我只需要对我的布局文件做一些最后的润色，并添加一个登出链接。
- en: '![](../Images/sectionFig.png)25.7\. Logging in and out'
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)25.7\. 登录和登出'
- en: I’ve already gotten the login process working. Now I’d like to add some visual
    indication that a user is logged in. First, I set up some variables that help
    me know whether there’s an unexpired session for a logged-in user. To do so, I
    add the code in [listing 25.12](#ch25ex12) to my custom middleware, where I added
    the `flashMessages` local variable, in main.js.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经让登录过程工作正常。现在我想添加一些视觉指示来表明用户已登录。首先，我设置了一些变量，帮助我知道是否有未过期的会话用于已登录用户。为此，我在main.js中添加了[代码列表25.12](#ch25ex12)中的代码到我的自定义中间件中，其中添加了`flashMessages`局部变量。
- en: With this middleware function, I have access to `loggedIn` to determine whether
    an account is logged in via the client from which the request was sent. `isAuthenticated`
    tells me whether there’s an active session for a user. `currentUser` is set to
    the user who’s logged in if that user exists.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个中间件函数，我可以访问`loggedIn`来确定是否有账户通过发送请求的客户端登录。`isAuthenticated`告诉我是否有用户的活跃会话。如果该用户存在，`currentUser`被设置为已登录的用户。
- en: Listing 25.12\. Adding local variables to the response through middleware
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表25.12\. 通过中间件向响应中添加局部变量
- en: '[PRE32]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1*** **Set up the loggedIn variable to reflect passport login status.**'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置loggedIn变量以反映passport登录状态。**'
- en: '***2*** **Set up the currentUser variable to reflect a logged-in user.**'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置currentUser变量以反映已登录用户。**'
- en: Now I can use these variables by adding the code in [listing 25.13](#ch25ex13)
    to the navigation bar in my layout. I check to see whether `loggedIn` is `true`,
    telling me that a user is logged in. If so, I display the `fullName` of the `currentUser`
    linked to that user’s `show` page and a logout link. Otherwise, I display a sign-in
    link.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以通过在布局中的导航栏添加[代码列表25.13](#ch25ex13)中的代码来使用这些变量。我检查`loggedIn`是否为`true`，这告诉我用户已登录。如果是这样，我显示指向该用户`show`页面的`currentUser`的`fullName`和登出链接。否则，我显示一个登录链接。
- en: Listing 25.13\. Adding a login status to my navigation bar in layout.ejs
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表25.13\. 在layout.ejs的导航栏中添加登录状态
- en: '[PRE33]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1*** **Check whether a user is logged in.**'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查用户是否已登录。**'
- en: '***2*** **Display the current user’s name and logout link.**'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **显示当前用户的名字和登出链接。**'
- en: Finally, with my `/users/logout` route already in place, I need to add the `logout`
    action to my `usersController`, as shown in [listing 25.14](#ch25ex14). This action
    uses the `logout` method on the incoming request. This method, provided by `passport`,
    clears the active user’s session. When I redirect to the home page, no `currentUser`
    exists, and the existing user is successfully logged out. Then I call the next
    middleware function to display the home page.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我的`/users/logout`路由已经就绪，我需要在`usersController`中添加`logout`操作，如[列表25.14](#ch25ex14)所示。这个操作使用传入请求上的`logout`方法。这个由`passport`提供的方法清除了活动用户的会话。当我重定向到主页时，没有`currentUser`存在，现有用户成功注销。然后我调用下一个中间件函数来显示主页。
- en: Listing 25.14\. Adding a logout action to usersController.js
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表25.14\. 向usersController.js添加注销操作
- en: '[PRE34]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1*** **Add an action to log users out.**'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个注销用户操作的函数。**'
- en: With this last piece working, I can tell my contacts at Confetti Cuisine to
    advertise user accounts. When they log in successfully, the screen will look like
    [figure 25.1](#ch25fig01). I’m confident that the registration and login process
    is safer, more reliable, and more intuitive than it was before.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的部分工作完成后，我可以告诉Confetti Cuisine的联系人开始宣传用户账户。当他们成功登录时，屏幕将看起来像[图25.1](#ch25fig01)。我坚信注册和登录过程比之前更安全、更可靠、更直观。
- en: Figure 25.1\. Successful login on Confetti Cuisine
  id: totrans-586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图25.1\. 在Confetti Cuisine上成功登录
- en: '![](../Images/25fig01_alt.jpg)'
  id: totrans-587
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/25fig01_alt.jpg)'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this capstone exercise, I improved the Confetti Cuisine application by adding
    a few packages to make incoming data secure and more transparent to the user.
    With sessions and cookies installed, I’m able to use packages like `passport`
    and `connect-flash` to share information between the server and client about a
    user’s interaction with the Confetti Cuisine application. I added encryption to
    user passwords and two new user attributes set up by the `pas``s``port-local-mongoose`
    plugin on the `User` model. With stricter validations, my custom validate action
    serves as middleware to filter unwanted data and make sure form data meets my
    schema requirements. Last, with authentication in place, `passport` offers a way
    to track which users are logged in to my application, allowing me to cater specific
    content to registered users who are actively involved. In the next unit, I’ll
    add a few features to search content within the application, and in doing so,
    build an API on the server.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合练习中，我通过添加几个包来增强Confetti Cuisine应用程序的安全性，并使其对用户更加透明。安装了会话和cookie后，我能够使用`passport`和`connect-flash`等包在服务器和客户端之间共享有关用户与Confetti
    Cuisine应用程序交互的信息。我为用户密码添加了加密，并在`User`模型上通过`passport-local-mongoose`插件设置了两个新的用户属性。通过更严格的验证，我的自定义验证操作作为中间件来过滤不必要的数据，并确保表单数据符合我的模式要求。最后，在实现了身份验证之后，`passport`提供了一种跟踪哪些用户登录到我的应用程序的方法，使我能够为积极参与的注册用户提供特定内容。在下一个单元中，我将添加一些功能以在应用程序内搜索内容，并在这个过程中在服务器上构建一个API。
