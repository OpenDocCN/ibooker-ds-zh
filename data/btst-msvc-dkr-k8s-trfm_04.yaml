- en: 4 Data management for microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 微服务的数据管理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using Docker Compose to build and run your microservices application in development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose在开发中构建和运行微服务应用程序
- en: Adding file storage to your application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件存储添加到你的应用程序中
- en: Adding a database to your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库添加到你的应用程序中
- en: When building any application, typically, we’ll need to deal with data or files
    and sometimes both. Microservices are no different. We need a database to store
    dynamic data that’s generated and updated by the application, and we need a place
    to store assets that are served by the application or uploaded to it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何应用程序时，通常，我们需要处理数据或文件，有时两者都需要。微服务也不例外。我们需要一个数据库来存储由应用程序生成和更新的动态数据，我们还需要一个地方来存储由应用程序提供或上传到它的资产。
- en: In this chapter, we add both file storage and a database to our FlixTube example
    application. First, we’ll add file storage so FlixTube has a location to store
    its videos. We want to have distinct areas of responsibility in our application
    for streaming and video storage. That implies that we’ll need to add another microservice
    to our application, and in this chapter, we will indeed create our second microservice.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将文件存储和数据库添加到我们的FlixTube示例应用程序中。首先，我们将添加文件存储，这样FlixTube就有了一个存储视频的位置。我们希望在应用程序中为流媒体和视频存储划分不同的责任区域。这意味着我们需要为应用程序添加另一个微服务，在本章中，我们确实会创建我们的第二个微服务。
- en: Then we’ll add a database. At this point, we add a database so that we have
    a place to record the path to each video, but this is really just an excuse to
    get a database in place. Because once we have it, we can easily use it to store
    all the metadata for our videos and to provide for the on-going data storage needs
    of all our microservices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加数据库。在这个时候，我们添加数据库是为了有一个记录每个视频路径的地方，但这实际上只是将数据库引入位置的借口。因为一旦我们有了它，我们就可以轻松地使用它来存储我们视频的所有元数据，并为所有微服务的持续数据存储需求提供服务。
- en: By adding a database server and a second microservice to our application, we
    are taking an important step. In chapter 2, we built our first microservice; in
    chapter 3, we used Docker to instantiate our first microservice in a container.
    In this chapter, we scale up our application to host multiple containers, and
    for this, we need a new tool!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加数据库服务器和第二个微服务到我们的应用程序中，我们迈出了重要的一步。在第2章，我们构建了我们的第一个微服务；在第3章，我们使用Docker在容器中实例化了我们的第一个微服务。在本章中，我们将应用程序扩展以托管多个容器，为此，我们需要一个新的工具！
- en: 4.1 New tools
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 新工具
- en: 'This chapter introduces two ways of storing data for microservices: file storage
    and database. Typically there are many different ways of doing this, and many
    different tools we could choose for the job. The tools you choose for each project
    will be the ones that work best for the particular project, your team, your company,
    and your customer.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了为微服务存储数据的两种方式：文件存储和数据库。通常有很多人不同的方法来做这件事，也有很多不同的工具我们可以选择。你为每个项目选择的工具将是那些最适合特定项目、你的团队、你的公司以及你的客户的工具。
- en: As for any example in the book, I need to make a choice, so starting in this
    chapter, we’ll use MongoDB for our database and Azure Storage for our file storage.
    We will also upgrade our development environment to run multiple containers at
    the same time. We could do this with Docker’s `build` and `run` commands as we
    learned in the previous chapter. But then, we’d end up having to run the commands
    repeatedly for each container.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的任何示例，我需要做出选择，所以从本章开始，我们将使用MongoDB作为我们的数据库，并使用Azure Storage作为我们的文件存储。我们还将升级我们的开发环境以同时运行多个容器。我们可以像上一章学到的使用Docker的`build`和`run`命令来做这件事。但那样的话，我们就必须为每个容器重复运行命令。
- en: This isn’t a big problem when only working with a few containers, but it doesn’t
    scale to a larger application. Imagine trying to build and run just 10 microservices
    this way! So we need a better way to manage multiple microservices. For that,
    this chapter introduces Docker Compose. Table 4.1 lists the new tools we’ll learn
    about in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当只处理少量容器时，这并不是大问题，但这并不适用于更大的应用程序。想象一下，仅用这种方式构建和运行10个微服务！因此，我们需要一种更好的方式来管理多个微服务。为此，本章介绍了Docker
    Compose。表4.1列出了本章我们将学习的新工具。
- en: Table 4.1 Tools introduced in chapter 4
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 第4章介绍的工具
- en: '| Tool | Version | Purpose |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 版本 | 目的 |'
- en: '| Docker Compose | 1.26.2 | Docker Compose allows us to configure, build, run,
    and manage multiple containers at the same time. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Docker Compose | 1.26.2 | Docker Compose允许我们同时配置、构建、运行和管理多个容器。|'
- en: '| Azure Storage | SDK version2.10.3 | Azure Storage is a service to store files
    in the cloud. We can manage the assets through the Azure Portal, through the APIs,
    or from the command line. We’ll upload a video through the Azure Portal and then
    use the Node.js Azure Storage SDK to read it back. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Azure存储 | SDK版本2.10.3 | Azure存储是一个云存储文件的服务。我们可以通过Azure门户、通过API或从命令行管理资产。我们将通过Azure门户上传一个视频，然后使用Node.js
    Azure存储SDK读取它。|'
- en: '| MongoDB | 4.2.8 | MongoDB is a popular NoSQL type of database. It’s lightweight,
    easy to setup and use, and it’s convenient for microservices. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| MongoDB | 4.2.8 | MongoDB是一种流行的NoSQL类型的数据库。它轻量级，易于设置和使用，对微服务来说很方便。|'
- en: 4.2 Getting the code
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 获取代码
- en: To follow along with this chapter, you need to download the code or clone the
    repository.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的内容，您需要下载代码或克隆存储库。
- en: You can download a zip file of the code at
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在以下位置下载代码的zip文件：
- en: '[https://github.com/bootstrapping-microservices/chapter-4](https://github.com/bootstrapping-microservices/chapter-4)'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/bootstrapping-microservices/chapter-4](https://github.com/bootstrapping-microservices/chapter-4)'
- en: 'You can clone the code using Git like this:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Git克隆代码，如下所示：
- en: '`git clone https://github.com/bootstrapping-microservices/chapter-4.git`'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/bootstrapping-microservices/chapter-4.git`'
- en: For help on installing and using Git, see chapter 2\. If you have problems with
    the code, log an issue against the repository in GitHub.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安装和使用Git的帮助，请参阅第二章。如果您在代码方面遇到问题，请在GitHub的存储库中记录一个问题。
- en: 4.3 Developing microservices with Docker Compose
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用Docker Compose开发微服务
- en: At the end of the previous chapter, we created a single microservice running
    in a container on our development workstation (or personal computer). We were
    able to test it using our web browser. Figure 4.1 illustrates our current situation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的结尾，我们在我们的开发工作站（或个人电脑）上创建了一个在容器中运行的单一微服务。我们能够使用我们的网络浏览器对其进行测试。图4.1说明了我们当前的情况。
- en: '![](../Images/CH04_F01_Davis4.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F01_Davis4.png)'
- en: Figure 4.1 Our single microservice runs under Docker on our development workstation,
    which we created in chapter 2.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 我们的单一微服务在我们的开发工作站上运行Docker，这是我们第二章中创建的。
- en: A microservices application, however, is *not* a microservices application if
    it only consists of a single microservice! The time has come to scale up our application
    and add more containers to it. To develop a microservices application, in this
    chapter, we’ll use Docker Compose to make the move to multiple microservices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个微服务应用程序，如果它只包含一个单一微服务，那么它**就不是**一个微服务应用程序！是时候扩展我们的应用程序并添加更多容器了。在本章中，我们将使用Docker
    Compose来将我们的应用程序迁移到多个微服务。
- en: We are scaling up to multiple containers in this chapter because we’d like to
    add a database (that’s one container), and we’d also like to add a new microservice
    to handle our file storage (that’s another container). So given that we started
    with one container (our video-streaming microservice), by the end of this chapter,
    we’ll have three containers as depicted in figure 4.2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展到多个容器，因为我们想添加一个数据库（这是一个容器），我们还希望添加一个新的微服务来处理我们的文件存储（这也是另一个容器）。所以，鉴于我们从一个容器开始（我们的视频流微服务），到本章结束时，我们将拥有三个容器，如图4.2所示。
- en: '![](../Images/CH04_F02_Davis4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F02_Davis4.png)'
- en: Figure 4.2 We expand our application to multiple containers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 我们将应用程序扩展到多个容器。
- en: To build, run, and manage our growing application, we could get by running the
    various Docker commands multiple times (repeated for each image or container).
    But this quickly becomes tedious during development because we’ll need to stop
    and restart our application many times during our working day. And this only gets
    worse! As our application continues to grow, we’ll add even more containers to
    it. We need a better tool.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建、运行和管理我们不断增长的应用程序，我们可以通过多次运行各种Docker命令来完成任务（为每个镜像或容器重复）。但在开发过程中，这很快就会变得繁琐，因为在我们工作日中，我们需要多次停止和重新启动我们的应用程序。而且情况只会变得更糟！随着我们的应用程序继续增长，我们将向其中添加更多的容器。我们需要一个更好的工具。
- en: 4.3.1 Why Docker Compose?
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 为什么使用Docker Compose？
- en: Managing multiple containers in development can be painstaking; in chapter 6
    you’ll see how we’ll use Kubernetes to manage containers in production. However
    Kubernetes is a big and complex system designed to run on multiple computers (you
    need at least one master and one node). It’s not easy to “simulate” Kubernetes
    on a development workstation. You could use Minikube to do this, that’s like a
    cut-down version of Kubernetes. But there’s an easier way, and you might even
    already have it installed-Docker Compose.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中管理多个容器可能会非常繁琐；在第6章中，您将看到我们将如何使用Kubernetes来管理生产环境中的容器。然而，Kubernetes是一个庞大且复杂的系统，设计用于在多台计算机上运行（您至少需要一个主节点和一个节点）。在开发工作站上“模拟”Kubernetes并不容易。您可以使用Minikube来完成这项工作，这就像是一个简化的Kubernetes版本。但有一个更简单的方法，您可能甚至已经安装了它——Docker
    Compose。
- en: Why Docker Compose? In the same way that Docker allows us to build, run, and
    manage a single microservice, Docker Compose gives us a convenient way to build,
    run, and manage multiple microservices in development.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择Docker Compose？与Docker允许我们构建、运行和管理单个微服务的方式相同，Docker Compose为我们提供了一个方便的方式来在开发中构建、运行和管理多个微服务。
- en: 'Docker Compose, another tool from the developers of Docker, builds on top of
    Docker to more easily manage a multi-container application. During development
    and testing, we must boot and reboot our entire application frequently. And after
    each small increment of development, we must test the changes to our code. We
    can do this through the methods already covered in earlier chapters:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是Docker开发者开发的另一个工具，它建立在Docker之上，以便更轻松地管理多容器应用程序。在开发和测试期间，我们必须频繁地启动和重启我们的整个应用程序。并且在每次小的开发增量之后，我们必须测试我们的代码更改。我们可以通过前面章节中介绍的方法来完成这项工作：
- en: Opening multiple terminals (one for each microservice) and then running each
    microservice separately using Node.js or whatever our tech stack is (as covered
    in chapter 2)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开多个终端（每个微服务一个），然后使用Node.js或我们使用的任何技术栈（如第2章所述）分别运行每个微服务
- en: Using Docker to build and run each container separately (as covered in chapter
    3)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker分别构建和运行每个容器（如第3章所述）
- en: Each of these methods has been an important stepping stone for us in our quest
    to build a microservices application, and indeed, we will often go back to these
    when working with individual microservices. But when it comes to working with
    a whole microservices application, these are less effective.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都是我们在构建微服务应用程序的过程中重要的里程碑，而且我们确实会在与单个微服务一起工作时经常回到这些方法。但是，当涉及到与整个微服务应用程序一起工作时，这些方法的效果就不那么明显了。
- en: Using these methods to manage our growing application means that we spend more
    and more time on managing the running application. That comes at the expense of
    development time. This slows down our iterative progress, saps our productivity,
    and ultimately, drains our motivation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法来管理我们不断增长的应用程序意味着我们花费越来越多的时间在管理运行中的应用程序上。这以开发时间为代价。这减缓了我们的迭代进度，降低了我们的生产力，并最终，耗尽了我们的动力。
- en: 'We need a more effective way of managing our application during development.
    That’s where Docker Compose comes in. Docker Compose is an open-source tool written
    in Python, and you can find the code here: [https://github.com/docker/compose](https://github.com/docker/compose).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个更有效的方法来管理我们的应用程序在开发过程中的状态。这就是Docker Compose的用武之地。Docker Compose是一个用Python编写的开源工具，您可以在以下位置找到代码：[https://github.com/docker/compose](https://github.com/docker/compose)。
- en: 4.3.2 Installing Docker Compose
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 安装Docker Compose
- en: 'The good news is that you probably already have Docker Compose installed on
    your development workstation. If you followed along with chapter 3 and installed
    Docker then, you might already have Docker Compose because it comes bundled with
    the standard installers for Windows and MacOS. If you are working on Linux, you
    might have to install Docker Compose separately. To check if you already have
    it, open a terminal and print the version number as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，您可能已经在您的开发工作站上安装了Docker Compose。如果您跟随第3章并安装了Docker，那么您可能已经安装了Docker Compose，因为它包含在Windows和MacOS的标准安装程序中。如果您在Linux上工作，您可能需要单独安装Docker
    Compose。要检查您是否已经安装了它，请打开一个终端并按照以下方式打印版本号：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you have it installed, you’ll see the version number printed out. This is
    the output I see for the version I’m running at the time of writing:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了它，您将看到打印出的版本号。这是我写作时运行的版本输出：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note It’s OK if you are running a later version than this because, most likely,
    it will be backward compatible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您运行的版本比这个版本晚，这是可以的，因为，它很可能与旧版本兼容。
- en: If you find that you don’t have Docker Compose installed, then you should invoke
    `docker` `--version` to double-check that you have the base Docker tool installed.
    If you don’t have that installed, return to section 3.7.1 in chapter 3 to install
    it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你没有安装 Docker Compose，那么你应该调用 `docker` `--version` 命令来再次确认你是否已安装了基本的 Docker
    工具。如果你还没有安装，请返回到第 3 章的 3.7.1 节来安装它。
- en: 'You might already have Docker installed, but not Docker Compose. This can happen,
    for example, if you are working on Linux and you followed the command-line installation
    instructions for Docker. If you need to install Docker Compose in addition to
    Docker, see the Docker Compose installation instructions on the Docker website
    at:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经安装了 Docker，但还没有安装 Docker Compose。这种情况可能发生在你正在使用 Linux 并且遵循了 Docker 的命令行安装说明时。如果你需要安装
    Docker Compose 作为 Docker 的补充，请参阅 Docker 网站上的 Docker Compose 安装说明，网址如下：
- en: '[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)'
- en: Follow the instructions there. When finished, use `docker-compose --version`
    to check that it is ready to go.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照那里的说明操作。完成后，使用 `docker-compose --version` 命令来检查它是否已准备好使用。
- en: 4.3.3 Creating our Docker Compose file
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 创建我们的 Docker Compose 文件
- en: Docker Compose revolves around the Docker Compose file*.* I like to think of
    this as a script file for automatically building a microservices application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 围绕 Docker Compose 文件*.* 我喜欢将其视为一个用于自动构建微服务应用的脚本文件。
- en: Definition The *Docker Compose file* is a script that specifies how to compose
    an application from multiple Docker containers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *Docker Compose 文件* 是一个脚本，它指定了如何从多个 Docker 容器中组合一个应用程序。
- en: Recall the Dockerfile we created in section 3.8\. That was a script for building
    a single image. The Docker Compose file scales this up and allows us to orchestrate
    the creation of a whole application from a collection of Dockerfiles. Docker Compose
    reads the Docker Compose file and produces a running application as figure 4.3
    shows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在第 3.8 节中创建的 Dockerfile。那是一个构建单个镜像的脚本。Docker Compose 文件将其扩展，并允许我们从一组 Dockerfile
    中编排整个应用程序的创建。Docker Compose 读取 Docker Compose 文件，并生成一个运行中的应用程序，如图 4.3 所示。
- en: '![](../Images/CH04_F03_Davis4.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F03_Davis4.png)'
- en: Figure 4.3 The Docker Compose file is like a script for building and launching
    a microservices application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 Docker Compose 文件就像是一个用于构建和启动微服务应用的脚本。
- en: Before we learn how to use Docker Compose to create an application composed
    of multiple containers, let’s keep it simple and create an application with just
    a single container. We’ll do some experiments on that so you can get comfortable
    with Docker Compose. After that, we’ll add more containers into the mix.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何使用 Docker Compose 创建由多个容器组成的应用程序之前，让我们保持简单，创建一个仅包含单个容器的应用程序。我们将进行一些实验，这样你就可以熟悉
    Docker Compose。之后，我们将添加更多的容器。
- en: Our first step in learning Docker Compose is to get our video-streaming microservice
    from chapter 2 working with it. The next example for this chapter is a direct
    follow up from example-1 in the chapter 3 code repository. You can start with
    that example and make updates to it if you like, or you can follow along with
    the pre-made examples in the chapter 4 code repository.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习 Docker Compose 的第一步是将第 2 章中的视频流微服务与它配合使用。本章的下一个示例是第 3 章代码库中的 example-1
    的直接后续。你可以从该示例开始，并根据需要对其进行更新，或者你可以跟随第 4 章代码库中预先准备好的示例。
- en: The first thing we need to do is to move the Dockerfile and code for our microservice
    into a new subdirectory. In this case, we call it video-streaming to match the
    name of the microservice. The reason we do this is that we are now building an
    application that will soon have more than one microservice. We must therefore
    put each microservice into its own separate subdirectory. Our convention will
    be that each subdirectory is named after its microservice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将我们的微服务的 Dockerfile 和代码移动到一个新的子目录中。在这个例子中，我们将其命名为 video-streaming，以匹配微服务的名称。我们这样做的原因是，我们现在正在构建一个很快就会包含多个微服务的应用程序。因此，我们必须将每个微服务放入它自己的单独子目录中。我们的约定是，每个子目录都以其微服务的名称命名。
- en: Now let’s create our Docker Compose file. This file is actually called docker-compose.yaml.
    Because it doesn’t belong to any single microservice, it lives in the root directory
    of our microservices application. Listing 4.1 shows our first Docker Compose file.
    You can type this code in yourself or just load it into Visual Studio (VS) Code
    from the example-1 directory in the chapter 4 code repository.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的Docker Compose文件。实际上，这个文件叫做docker-compose.yaml。因为它不属于任何单个微服务，所以它位于我们的微服务应用程序的根目录中。列表4.1显示了我们的第一个Docker
    Compose文件。你可以自己输入这段代码，或者直接从第4章代码仓库中的example-1目录加载到Visual Studio (VS) Code中。
- en: Listing 4.1 Docker Compose file for our microservice (chapter-4/example-1/docker-compose.yml)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1：我们的微服务的Docker Compose文件（第4章/example-1/docker-compose.yml）
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Uses version 3 of the Docker Compose file format
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用Docker Compose文件格式的第3版
- en: ② Nests our containers under the “services” field
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在“services”字段下嵌套我们的容器
- en: ③ Configures our video-streaming microservice
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 配置我们的视频流微服务
- en: ④ Sets the name of the image
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置镜像名称
- en: ⑤ Sets parameters required for building the image
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置构建镜像所需的参数
- en: ⑥ Sets the directory for the microservice
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 设置微服务的目录
- en: ⑦ Sets the Dockerfile that builds the image
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 设置构建镜像的Dockerfile
- en: ⑧ Names the container that’s instantiated
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 命名实例化的容器
- en: ⑨ Specifies port mappings. This is like the “-p” argument we used with Docker
    in the previous chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 指定端口映射。这就像我们在上一章中使用Docker时的“-p”参数。
- en: ⑩ Maps port 80 in the microservice to port 4000 on the host’s operating system
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 将微服务中的端口80映射到主机操作系统的端口4000
- en: ⑪ Sets environment variables to configure input to the container
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 设置配置容器输入的环境变量
- en: ⑫ Sets the PORT used by the microservice’s HTTP server
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 设置微服务HTTP服务器使用的端口
- en: ⑬ Configures our video-streaming microservice
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 配置我们的视频流微服务
- en: ⑭ If the microservice crashes, don’t automatically restart it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 如果微服务崩溃，不要自动重启它。
- en: 'Listing 4.1 is a Docker Compose file that creates a single container: our video-streaming
    microservice. Note the `build` section. The fields here set the subdirectory that
    contains the microservice’s project and the name of its Dockerfile. This is how
    Docker Compose finds the information to build the image for our video-streaming
    microservice.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1是一个Docker Compose文件，它创建了一个容器：我们的视频流微服务。注意`build`部分。这里的字段设置了包含微服务项目和Dockerfile的子目录及其名称。这就是Docker
    Compose如何找到构建我们视频流微服务镜像所需的信息。
- en: 'Also note that Dockerfile is the default name of this file. We could have omitted
    this, but I’ve specified this explicitly because in the next chapter, we’ll separate
    our Dockerfiles. That way, we can have separate versions for use in development
    and production. Also configured are various options (see the code annotations)
    that you might remember from chapter 2:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，Dockerfile是这个文件的默认名称。我们本来可以省略这个名称，但我明确指定了它，因为在下一章中，我们将分离我们的Dockerfile。这样，我们可以为开发和生产使用不同的版本。还配置了各种选项（见代码注释），你可能还记得第2章的内容：
- en: Setting the image name to video-streaming
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置镜像名称为video-streaming
- en: Binding the port
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定端口
- en: Setting environment variables to configure the microservice
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境变量以配置微服务
- en: In listing 4.1, we are starting the port numbers for our containers from 4000\.
    Once we have multiple containers, they’ll be numbered 4000, 4001, 4002, and so
    on. This is just so that port numbers for multiple microservices don’t conflict.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.1中，我们为我们的容器从4000开始设置端口号。一旦我们有了多个容器，它们的端口号将是4000、4001、4002等等。这样做只是为了确保多个微服务的端口号不会冲突。
- en: Note The choice of port numbers is arbitrary, and for your own application,
    you can use a different set of numbers if you like.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：端口号的选择是任意的，对于你自己的应用程序，如果你喜欢，可以使用不同的端口号集合。
- en: You might be wondering why we set the `restart` option to `no` in listing 4.1\.
    When working in development, we don’t want our microservices to automatically
    restart when these crash. If they did that, we could easily miss problems!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在列表4.1中将`restart`选项设置为`no`。在开发工作中，我们不希望微服务在崩溃时自动重启，如果那样做了，我们很容易错过问题！
- en: Instead, if these crash, we want them to stay that way so that we will notice
    the problem. This is the opposite of how we’d usually like our microservices to
    work in production. We’ll see later in chapter 10 how we can have Kubernetes automatically
    restart our production microservices that crash.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果它们崩溃，我们希望它们保持这种状态，这样我们就会注意到问题。这与我们通常希望在生产中让微服务工作的方式相反。我们将在第10章中看到如何让Kubernetes自动重启崩溃的生产微服务。
- en: Even though our first Docker Compose file is simple, it is already pretty useful.
    This Docker Compose file only creates a single container, but it encodes all the
    information we need to build and run our microservice. Recording these configuration
    details already makes things a bit easier. Otherwise, we would have to type this
    configuration into the terminal every time we invoke the Docker `build` and `run`
    commands. Even at this early stage, we are seeing how Docker Compose can improve
    our development process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的第一个 Docker Compose 文件很简单，但它已经非常有用了。这个 Docker Compose 文件只创建了一个容器，但它包含了我们构建和运行微服务所需的所有信息。记录这些配置细节已经让事情变得容易一些。否则，每次我们调用
    Docker 的 `build` 和 `run` 命令时，我们都需要在终端中输入这些配置。即使在这个早期阶段，我们也能看到 Docker Compose 如何改进我们的开发流程。
- en: YAML
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: YAML
- en: You might have noticed that the Docker Compose file is a YAML format file. According
    to Wikipedia, YAML is a recursive acronym for “YAML Ain’t Markup Language.”
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 Docker Compose 文件是一个 YAML 格式的文件。根据维基百科，YAML 是“YAML Ain’t Markup Language”的递归缩写。
- en: YAML, although not actually a markup language, is probably best described as
    a data format or a configuration language. YAML’s purpose is similar to JSON,
    but the language itself is structured to be more human-readable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 虽然实际上不是一种标记语言，但最好将其描述为一种数据格式或配置语言。YAML 的目的是与 JSON 类似，但语言本身的结构是为了更易于人类阅读。
- en: That’s why you see YAML being used by tools like Docker Compose and Kubernetes.
    These are configuration files designed to be edited by humans, while still being
    easily machine-readable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么你会看到 Docker Compose 和 Kubernetes 等工具使用 YAML 的原因。这些是设计给人编辑的配置文件，同时仍然易于机器读取。
- en: 4.3.4 Booting our microservices application
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 启动我们的微服务应用程序
- en: So far, we’ve created a Docker Compose file to build and run our video-streaming
    microservice from chapter 2\. We reused the entire project for this microservice,
    including the Dockerfile from chapter 3\. We will now test the work we have done.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个 Docker Compose 文件来构建和运行第 2 章的视频流微服务。我们重用了整个项目，包括第 3 章的 Dockerfile。我们现在将测试我们所做的工作。
- en: In this section, we use Docker Compose to boot a single service. This doesn’t
    yet give us much advantage over just using Docker, but sit tight. This is just
    a starting point, and soon we’ll extend our Docker Compose file to include multiple
    containers. We’ll use the Docker Compose file we just created so we can boot up
    our application using Docker Compose.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 Docker Compose 启动单个服务。这还没有给我们带来比仅使用 Docker 更多的优势，但请耐心等待。这只是一个起点，很快我们就会扩展我们的
    Docker Compose 文件以包括多个容器。我们将使用我们刚刚创建的 Docker Compose 文件，以便使用 Docker Compose 启动我们的应用程序。
- en: 'Open a terminal and change to the directory that contains your Docker Compose
    file. If you are following along with the code from the chapter 4 code repository
    on GitHub, then you should change to the directory chapter-4/example-1\. Now invoke
    the Docker Compose `up` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并切换到包含你的 Docker Compose 文件的目录。如果你正在跟随 GitHub 上第 4 章代码仓库中的代码，那么你应该切换到 chapter-4/example-1
    目录。现在调用 Docker Compose 的 `up` 命令：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `up` command causes Docker Compose to boot our microservices application.
    The `--build` argument makes Docker Compose build each of our images before instantiating
    containers from these.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`up` 命令使 Docker Compose 启动我们的微服务应用程序。`--build` 参数使 Docker Compose 在从这些镜像实例化容器之前构建我们的每个镜像。'
- en: Technically, at this point, the `--build` argument is not necessary because
    the first time you invoke the `up` command it builds your images anyway. At other
    times (without the `--build` argument), the `up` command just starts our container
    from the image that was previously built. This means that if you change some code
    in your microservice and invoke the `up` command again, it won’t include your
    changes *unless* you use the `--build` argument. Unfortunately, this makes it
    all too easy to accidentally omit the code changes you are trying to test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在这个阶段，`--build` 参数不是必需的，因为第一次调用 `up` 命令时，它无论如何都会构建你的镜像。在其他时候（没有 `--build`
    参数），`up` 命令只是从之前构建的镜像启动我们的容器。这意味着如果你在微服务中更改了一些代码并再次调用 `up` 命令，它不会包含你的更改*除非*你使用
    `--build` 参数。不幸的是，这使得意外遗漏你试图测试的代码更改变得非常容易。
- en: When this happens, and you don’t realize it, you end up wasting time testing
    changes that aren’t even there. I don’t like wasting my time; that’s why I make
    it a point to always use the `--build` argument every time I run the `up` command.
    It means I don’t have to think about it. I know my code changes will always get
    through to the running application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，而你并没有意识到它，你最终会浪费时间去测试那些甚至不存在的更改。我不喜欢浪费时间；这就是为什么我每次运行 `up` 命令时都会使用 `--build`
    参数。这意味着我不用去想它。我知道我的代码更改总是会传递到正在运行的应用中。
- en: 'When you invoke the `up` command, you’ll see the various layers of your base
    image being downloaded. After that, you’ll start to see the (by now familiar)
    output from your video-streaming microservice. It should look something like the
    following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `up` 命令时，你会看到你的基础镜像的各个层正在下载。之后，你将开始看到来自你的视频流微服务（现在应该很熟悉）的输出。它看起来可能像以下这样：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see on the left of the output that it shows the name of the container.
    This is what identifies the output as coming from our video-streaming microservice.
    The name of the container isn’t really important at the moment, because at this
    point, we are only running a single container in our application-all the output
    is coming from just that one container.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在输出的左侧看到它显示了容器的名称。这就是识别输出来自我们的视频流微服务的原因。目前容器的名称并不重要，因为在这个阶段，我们只是在应用中运行单个容器——所有的输出都来自这个容器。
- en: Now that we have our microservice running, we can test that everything is OK.
    Point your browser to http://localhost:4000/video to watch the video that you
    should know well from earlier chapters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了我们的微服务，我们可以测试一下一切是否正常。将你的浏览器指向 http://localhost:4000/video 来观看你从之前章节中应该很熟悉的视频。
- en: With just a single microservice, this isn’t much of a microservices application.
    But now that we are set up to use Docker Compose, we can easily add new containers
    to our application. But before we do that, let’s take some time to learn some
    more about managing our application with Docker Compose.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用单个微服务，这并不算是一个真正的微服务应用。但现在我们已经配置好使用 Docker Compose，我们可以轻松地向我们的应用中添加新的容器。但在我们这样做之前，让我们花点时间来学习更多关于如何使用
    Docker Compose 来管理我们的应用。
- en: Although we haven’t yet scaled up to multiple containers, you might already
    recognize that Docker Compose has given us a more efficient process for working
    with a single container. Using the `up` command saves us from invoking separate
    Docker `build` and `run` commands.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有扩展到多个容器，但你可能已经意识到 Docker Compose 已经为我们提供了一个更高效的流程来处理单个容器。使用 `up` 命令可以让我们免于调用单独的
    Docker `build` 和 `run` 命令。
- en: That’s only a small savings in time right now, but as you’ll soon see, the Docker
    Compose `up` command is scalable to many containers. You can imagine how much
    time it’s going to save when you have, say, 10 microservices and you can use a
    single `up` command to *build and run* all of these at once! That’s one command
    (the `up` command) instead of 20 commands (10 `build` commands and 10 `run` commands).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是目前节省的一小部分时间，但正如你很快就会看到的，Docker Compose 的 `up` 命令可以扩展到许多容器。你可以想象当你有，比如说，10
    个微服务，你可以使用单个 `up` 命令一次性构建和运行所有这些服务时，它能节省多少时间！这只是一个命令（`up` 命令）而不是20个命令（10个 `build`
    命令和10个 `run` 命令）。
- en: The Docker Compose `up` command is *probably the most important command you
    will learn in this book!* You will invoke it time after time as you develop and
    test your application, and I’m going to make sure you don’t forget about it!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 的 `up` 命令可能是你在本书中将要学习到的最重要的命令！你将在开发和测试你的应用时一次又一次地调用它，我会确保你不会忘记它！
- en: 4.3.5 Working with the application
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.5 与应用一起工作
- en: After starting your application, Docker Compose continues to print output to
    the terminal while it is running. This locks up your terminal, so we can’t do
    anything with it now except watch the output. We could use the `-d` argument with
    the `up` command to run in detached mode, just like we did with the Docker `run`
    command in chapter 3\. But using the `-d` argument hides the application’s output.
    We don’t want that because being able to view the live output is useful for understanding
    what is going on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动你的应用后，Docker Compose 会继续在终端中打印输出，直到它运行结束。这会锁定你的终端，所以我们现在除了观看输出外，无法对它做任何事情。我们可以使用
    `up` 命令的 `-d` 参数以分离模式运行，就像我们在第3章中使用的 Docker `run` 命令一样。但使用 `-d` 参数会隐藏应用的输出。我们不希望这样，因为能够查看实时输出对于理解正在发生的事情是有用的。
- en: Note The output can be recovered, of course, with the Docker Compose `logs`
    command. Still, I tend not to use the `-d` argument because I like the output
    to be visible front and center to see what’s happening in real time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当然，你可以使用 Docker Compose 的 `logs` 命令恢复输出。不过，我倾向于不使用 `-d` 参数，因为我喜欢将输出清晰地显示在前面，以便实时查看发生了什么。
- en: 'Even though our terminal is locked up with Docker Compose, we can always simply
    open a new terminal and use it to invoke other commands. Let’s try that now. Open
    a new terminal, change the directory to where the Docker Compose file is located,
    and invoke the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的终端被 Docker Compose 锁定，我们也可以始终简单地打开一个新的终端，并使用它来调用其他命令。现在让我们试试这个。打开一个新的终端，将目录切换到
    Docker Compose 文件所在的目录，并调用以下命令：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ps` command shows a list of our running containers. Because we only have
    one microservice running in our application, you should see output like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 命令会显示我们正在运行的容器列表。因为我们只有一个微服务在我们的应用程序中运行，你应该会看到如下输出：'
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s useful to note again at this point that Docker Compose is simply a layer
    on top of the regular Docker command. That means that all our regular Docker commands
    work as well. As an example, you can try `docker ps` to get a list of containers
    or `docker push` to upload an image to your private Docker registry.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上再次指出，Docker Compose 仅仅是普通 Docker 命令的一个层。这意味着我们所有的普通 Docker 命令都可以正常工作。例如，你可以尝试使用
    `docker ps` 来获取容器列表，或者使用 `docker push` 将镜像上传到你的私有 Docker 仓库。
- en: The output of Docker commands like `docker ps` can be different from the output
    of `docker-compose ps`. That’s because Docker commands relate to all images and
    containers on your development workstation, whereas Docker Compose commands only
    relate to the images and containers specified in your Docker Compose file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 命令（如 `docker ps`）的输出可能与 `docker-compose ps` 的输出不同。这是因为 Docker 命令与你的开发工作站上的所有镜像和容器相关，而
    Docker Compose 命令只与你在 Docker Compose 文件中指定的镜像和容器相关。
- en: In this sense, we are using Docker Compose like a scoping mechanism. It constrains
    the commands so these only apply to images and containers in your current project.
    Essentially, it restricts the scope of these commands to the current working directory.
    This is another useful aspect of Docker Compose.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种意义上，我们像使用作用域机制一样使用 Docker Compose。它限制了命令，使得这些命令只适用于当前项目中的镜像和容器。本质上，它将这些命令的作用域限制在当前工作目录。这是
    Docker Compose 的另一个有用特性。
- en: More specifically, `docker-compose ps` shows us only the containers that are
    listed in our Docker Compose file, whereas, `docker ps` shows us all containers
    on our development workstation. If you invoke the `docker ps` command and find
    that it shows more containers than `docker-compose ps`, that’s because you have
    previously created other containers on your computer, possibly from when you were
    following along with chapter 3.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，`docker-compose ps` 只会显示我们 Docker Compose 文件中列出的容器，而 `docker ps` 则会显示我们开发工作站上的所有容器。如果你运行了
    `docker ps` 命令并发现显示的容器数量比 `docker-compose ps` 多，那是因为你之前可能已经在你的电脑上创建了其他容器，可能是在跟随第
    3 章的内容时。
- en: There are many other Docker Compose commands for you to explore in the official
    documentation. See the end of this chapter for a link.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方文档中还有许多其他的 Docker Compose 命令供你探索。请参阅本章末尾的链接。
- en: 4.3.6 Shutting down the application
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.6 关闭应用程序
- en: 'You can stop your application in either of two ways. If you opened a second
    terminal in the previous section, you can use that to invoke the `stop` command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式停止你的应用程序。如果你在上一节中打开了第二个终端，你可以使用它来调用 `stop` 命令：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The other way to stop your application is by typing Ctrl-C at the terminal where
    you invoked the `up` command in the first place. However, there are some problems
    with this approach.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种停止应用程序的方法是在最初调用 `up` 命令的终端中按 Ctrl-C。然而，这种方法存在一些问题。
- en: The first problem is that you have to be careful to press Ctrl-C only once.
    If you press it just a single time, then the application will stop gracefully
    and patiently wait for all your containers to stop. But if you are like me (impatient),
    then you will tend to press Ctrl-C repeatedly until the process completes and
    gives you back your terminal. Unlike when you are at a traffic intersection and
    furiously pound the walk button, this actually works. But unfortunately, it aborts
    the shutdown, and it can leave some or all of your containers in a running state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是你必须小心只按一次 Ctrl-C。如果你只按一次，那么应用程序将优雅地停止并耐心等待所有容器停止。但如果你像我一样（没有耐心），那么你可能会反复按
    Ctrl-C，直到进程完成并返回你的终端。与你在交通十字路口猛烈地按人行横道按钮不同，这实际上有效。但遗憾的是，它会中断关闭操作，并且可能会使一些或所有容器处于运行状态。
- en: 'The second problem is that stopping the application doesn’t remove the containers.
    Instead, it leaves these in place in the *stopped* state so you can inspect these.
    That’s a handy way to debug a crashed container! We’ll talk more about debugging
    containers in chapter 10\. Right now, though, it’s more useful that we can remove
    our containers and return our development workstation to a clean state. For that,
    we can use the `down` command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是停止应用程序不会删除容器。相反，它会将这些容器保留在 *停止* 状态，以便您可以检查它们。这是一个调试崩溃容器的便捷方法！我们将在第 10
    章中更多地讨论容器调试。不过，现在，我们能够删除我们的容器并将我们的开发工作站恢复到干净状态更为有用。为此，我们可以使用 `down` 命令：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I actually think we are better off always using the `down` command. Although
    Ctrl-C is needed to unlock our terminal, it’s unreliable, and the `down` command
    makes the `stop` command redundant.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上认为我们最好总是使用 `down` 命令。尽管需要 Ctrl-C 来解锁我们的终端，但它不可靠，而 `down` 命令使得 `stop` 命令变得多余。
- en: Tip Get into the habit of using the `down` command after pressing Ctrl-C.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在按下 Ctrl-C 后养成使用 `down` 命令的习惯。
- en: 'We can use both the `up` and `down` commands in combination to easily reboot
    our application when we want to get updated code or dependencies into it. We can
    chain these commands as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以组合使用 `up` 和 `down` 命令，以便在需要将更新的代码或依赖项放入应用程序时轻松重启我们的应用程序。我们可以将这些命令链接如下：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you are starting to tire of all these complicated commands, well, I’m hearing
    you. You might want to invest some time in creating shell scripts for the commands
    you use most often. See the following sidebar for some examples.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始厌倦所有这些复杂的命令，那么，我在听你说。你可能想花些时间为你最常用的命令创建 shell 脚本。请参阅以下侧边栏中的示例。
- en: We now have some good fundamentals in place for Docker Compose that will serve
    us well for development and testing of our microservices application. We’ll learn
    more about using Docker Compose in chapter 5 and chapter 8.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为 Docker Compose 建立了一些良好的基础，这将为我们开发微服务应用程序的测试提供良好的服务。我们将在第 5 章和第 8 章中学习更多关于使用
    Docker Compose 的内容。
- en: Shell scripts
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本
- en: During the daily development grind, you might find that typing some of these
    commands becomes onerous. For example, typing `docker-compose up --build` gets
    old quickly, so I usually encapsulate it in a shell script called up.sh.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常的开发工作中，你可能会发现输入一些这些命令变得很繁琐。例如，输入 `docker-compose up --build` 很快就会变得无聊，所以我通常将它封装在一个名为
    up.sh 的 shell 脚本中。
- en: Typically, when I write such long commands, I’ll create shell scripts that are
    easier to run; at least I do this when I have to run a command many times per
    day. Other shell scripts I use are
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我编写这样的长命令时，我会创建易于运行的 shell 脚本；至少当我每天需要多次运行命令时，我会这样做。我使用的其他 shell 脚本包括
- en: down.sh for `docker-compose down`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: down.sh 用于 `docker-compose down`
- en: reboot.sh for `docker-compose down && docker-compose up --build`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reboot.sh 用于 `docker-compose down && docker-compose up --build`
- en: We’ll talk more about shell scripts in chapter 7.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 7 章中更多地讨论 shell 脚本。
- en: 4.3.7 Can we use Docker Compose for production?
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.7 我们能否在生产中使用 Docker Compose？
- en: At this point, we might pause to consider why we are using Docker Compose for
    development but not for production. Docker Compose seems like a great way to define
    a microservices application, so why can’t we use it in production? Why would we
    choose to use Kubernetes instead?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可能需要暂停一下，考虑为什么我们使用 Docker Compose 进行开发，而不是用于生产。Docker Compose 看起来是定义微服务应用程序的一个很好的方法，那么为什么我们不能在生产中使用它？为什么我们选择使用
    Kubernetes 而不是它？
- en: Rolling your own Docker Compose stack for production is easy at the outset but
    difficult to scale. You could deploy to Docker Swarm, but then that locks you
    into that particular platform. Kubernetes is a robust and flexible platform for
    running microservices in production. It’s supported by all the major cloud vendors,
    but it’s also independent, so it doesn’t lock you in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为生产自行构建Docker Compose堆栈在开始时很容易，但很难扩展。你可以部署到Docker Swarm，但这样就会将你锁定在该特定平台上。Kubernetes是一个健壮且灵活的平台，用于在生产中运行微服务。它得到了所有主要云供应商的支持，但它也是独立的，因此它不会将你锁定。
- en: 'The fact is that we could use Docker Compose for production. Here are at least
    two ways to achieve this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以使用Docker Compose进行生产。以下至少有两种实现方式：
- en: Create a virtual machine (VM) in the cloud and install Docker and Docker Compose.
    Then copy your application to the VM and boot it using Docker Compose.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中创建一个虚拟机（VM），安装Docker和Docker Compose。然后，将你的应用程序复制到VM中，并使用Docker Compose启动它。
- en: Use the Docker Swarm hosted service (from the makers of Docker) to deploy your
    application defined by the Docker Compose file.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用由Docker制作者提供的Docker Swarm托管服务来部署由Docker Compose文件定义的应用程序。
- en: Both of these options could be desirable in the short term, especially if you
    don’t want to go to the trouble of learning Kubernetes. But neither is ideal in
    the long term.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项在短期内可能是可取的，尤其是如果你不想费心学习Kubernetes。但从长远来看，它们都不是理想的。
- en: Option 1 is vertically scalable, but not horizontally scalable, and this is
    extremely limiting. (If you haven’t heard of the concepts of horizontal and vertical
    scaling, don’t be concerned. I’ll explain these in chapter 11, where we learn
    about scaling our application.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 选项1是垂直可扩展的，但不是水平可扩展的，这非常有限。（如果你还没有听说过水平和垂直扩展的概念，请不要担心。我将在第11章中解释这些概念，在那里我们将学习如何扩展我们的应用程序。）
- en: Option 2 could be a good option, but unfortunately, it locks us into this *paid*
    service from Docker. One good thing about Kubernetes is that it is independent
    of any particular cloud vendor and, yet, it is supported by all of them. This
    means we aren’t being locked in!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 选项2可能是一个不错的选择，但不幸的是，它会将我们锁定在Docker的这项*付费*服务中。Kubernetes的一个优点是它独立于任何特定的云供应商，同时，所有云供应商都支持它。这意味着我们不会被锁定！
- en: Even though this book gives examples using Microsoft Azure, you can indeed run
    Kubernetes on both AWS and Google Cloud, not to mention with other vendors. So
    anything you learn about Kubernetes is transferable knowledge, and any application
    you build on Kubernetes is generally portable between cloud vendors. I prefer
    to remain vendor neutral as much as possible, and that’s why I prefer Kubernetes
    for production.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书提供了使用Microsoft Azure的示例，但你确实可以在AWS和Google Cloud上运行Kubernetes，更不用说其他供应商了。所以，你关于Kubernetes学到的任何东西都是可转移的知识，你基于Kubernetes构建的任何应用程序通常可以在云供应商之间通用。我尽可能地保持供应商中立，这就是为什么我更喜欢Kubernetes用于生产。
- en: We’ll learn more about Kubernetes in chapter 6, but for now, I wanted to explain
    why Docker Compose is the best option for development, but probably not the best
    option for production. Of course, the strategy you choose depends on your situation,
    your project, and your company. Please don’t take this as gospel!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第6章中学习更多关于Kubernetes的知识，但到目前为止，我想解释为什么Docker Compose是开发的最佳选择，但可能不是生产的最佳选择。当然，你选择的策略取决于你的情况、你的项目和你的公司。请不要将此视为圣旨！
- en: 4.4 Adding file storage to our application
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 为我们的应用程序添加文件存储
- en: Now that we are using Docker Compose, we can easily run multiple containers.
    This gives us the tools we need to move on to the real topic of this chapter-data
    management.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用Docker Compose，我们可以轻松地运行多个容器。这为我们提供了进入本章真正主题——数据管理的工具。
- en: We’d like to add file storage and a database to our application. We are adding
    file storage so that we have a location to store the videos used by our application.
    A common approach is to use a storage solution provided by one of the big cloud
    vendors. Because we are using Azure in this book, we’ll use Azure Storage as our
    storage provider.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向我们的应用程序添加文件存储和数据库。我们添加文件存储是为了有一个位置来存储应用程序使用的视频。一种常见的方法是使用大型云供应商提供的存储解决方案。因为我们在本书中使用Azure，所以我们将使用Azure存储作为我们的存储提供者。
- en: Note Many applications, including our example application, FlixTube, need to
    store files. There are various ways to do this, but one of the most common is
    to use external cloud storage such as Azure Storage, AWS S3, or Google Cloud Storage.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：许多应用程序，包括我们的示例应用程序FlixTube，都需要存储文件。有各种方法可以做到这一点，但最常见的方法之一是使用外部云存储，例如Azure存储、AWS
    S3或Google Cloud存储。
- en: We could add cloud storage by directly connecting our video-streaming microservice
    to the storage provider. We won’t do that. Instead, we’ll employ good design principles,
    namely, *separation of concerns* and *single responsibility principle* ; and we’ll
    create a new microservice whose purpose is to be an abstraction of our file storage
    provider. Figure 4.4 illustrates what our application will look like once we have
    added the new video-storage microservice to it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将视频流微服务连接到存储提供商来添加云存储。我们不会这样做。相反，我们将采用良好的设计原则，即*关注点分离*和*单一责任原则*；我们将创建一个新的微服务，其目的是成为我们的文件存储提供商的抽象。图4.4说明了在我们向应用程序添加新的视频存储微服务后，应用程序将看起来是什么样子。
- en: '![](../Images/CH04_F04_Davis4.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F04_Davis4.png)'
- en: Figure 4.4 We add a second microservice and external cloud storage to our application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 我们向应用程序添加第二个微服务和外部云存储。
- en: 'Figure 4.4 shows how the video-storage microservice will be an intermediary
    between the video-streaming microservice and the external cloud storage. At the
    end of this section, we’ll talk more about the reasoning behind the separation
    of these microservices. For now, just be satisfied with this excuse: this is as
    good a reason as any to introduce our second microservice, and we will, thus,
    officially be running a microservices application (albeit a small one).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4显示了视频存储微服务将作为视频流微服务和外部云存储之间的中介。在本节的结尾，我们将更多地讨论这些微服务分离背后的原因。现在，只需满足于这个借口：这是介绍我们的第二个微服务的充分理由，因此，我们将正式运行一个微服务应用程序（尽管是一个小的应用程序）。
- en: 4.4.1 Using Azure Storage
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 使用Azure存储
- en: Azure Storage is a cloud storage service provided by Microsoft. We’ll use it
    to add storage capability to our application. You should already have an Azure
    account from the work we did in chapter 3, and in this section, we’ll go back
    into Azure, create a storage account, and upload our test video. We’ll then create
    a new microservice whose purpose is to retrieve the video from storage.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Azure存储是微软提供的一种云存储服务。我们将使用它来为我们的应用程序添加存储功能。您应该已经从第3章的工作中拥有一个Azure账户，在本节中，我们将返回Azure，创建一个存储账户，并上传我们的测试视频。然后我们将创建一个新的微服务，其目的是从存储中检索视频。
- en: Definition *Azure Storage* is a Microsoft Azure service for hosting private
    or public files in the cloud. You upload your files to Azure Storage and can then
    access these through the Azure Storage API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *Azure存储* 是一种微软Azure服务，用于在云中托管私有或公共文件。您将文件上传到Azure存储，然后可以通过Azure存储API访问这些文件。
- en: Although we can host both private and public files on Azure Storage, we’ll use
    the private option. We don’t want just anyone to be able to go and download our
    videos from storage. Instead, we’d like them to go through the front end. The
    code we write for our new microservice authenticates with Azure and retrieves
    videos using the official Azure Storage SDK for JavaScript, available via npm.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在Azure存储上托管私有和公共文件，但我们将使用私有选项。我们不希望任何人都能随意从存储中下载我们的视频。相反，我们希望他们通过前端进行操作。我们为新的微服务编写的代码通过Azure进行身份验证，并使用官方的Azure
    Storage SDK for JavaScript（通过npm提供）检索视频。
- en: Why Azure Storage?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择Azure存储？
- en: We have plenty of options for file storage, so why choose Azure Storage? The
    truth is we could have just as easily have used AWS S3 or Google Cloud Storage.
    For our purposes in this book, it doesn’t make much difference. The code we write
    would be different, of course, because if we used a different cloud vendor, we’d
    have to use a different storage API.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多文件存储选项，为什么选择Azure存储？事实是，我们同样可以轻松地使用AWS S3或Google Cloud Storage。对于本书中的我们的目的来说，这并没有太大的区别。我们编写的代码当然会有所不同，因为如果我们使用不同的云服务提供商，我们就必须使用不同的存储API。
- en: Note The example for this chapter demonstrates external cloud storage using
    Azure. There’s nothing particularly special about Azure in this case. The code
    will look different using a different API, but the structure of the microservices
    will be essentially the same.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章的示例展示了使用Azure的外部云存储。在这种情况下，Azure并没有什么特别之处。使用不同的API，代码看起来会有所不同，但微服务的结构基本上是相同的。
- en: It’s convenient for us to use Azure because you have already signed up for it
    from the last chapter. However, there’s no need to be locked into Azure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，使用Azure很方便，因为您在上一个章节中已经注册了它。然而，没有必要被锁定在Azure上。
- en: One of the advantages of the architecture we are putting into place is that
    we could easily swap out our Azure storage microservice and replace it with an
    alternative. We can even do this while our application is running in production!
    In this sense, you can think of this video-storage microservice as *hot-swappable.*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在实施的架构的一个优点是，我们可以轻松地替换我们的Azure存储微服务，并用替代品替换它。我们甚至可以在我们的应用程序在生产中运行时这样做！从这个意义上说，您可以将这个视频存储微服务视为*热插拔*。
- en: Creating an Azure Storage account
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Azure存储帐户
- en: Before we get our test video into storage, we must create an Azure storage account.
    To do this, you’ll need to login to the Azure Portal at [https://portal.azure.com/](https://portal.azure.com/)
    as you did in chapter 3\. Then in the left-hand menu, click Create a Resource
    and search for “storage account” as shown in figure 4.5.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将测试视频放入存储之前，我们必须创建一个Azure存储帐户。为此，您需要登录到Azure门户[https://portal.azure.com/](https://portal.azure.com/)，就像在第3章中做的那样。然后在左侧菜单中，点击创建资源并搜索“存储帐户”，如图4.5所示。
- en: '![](../Images/CH04_F05_Davis4.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F05_Davis4.png)'
- en: Figure 4.5 Creating a new storage account in the Azure portal
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 在Azure门户中创建新的存储帐户
- en: Click Microsoft’s Storage Account option, then click Create. You can now fill
    out the details of your new storage account as shown in figure 4.6.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 点击Microsoft的存储帐户选项，然后点击创建。您现在可以填写您新存储帐户的详细信息，如图4.6所示。
- en: You’ll need to choose a resource group. For that, you can use the resource group
    you created in chapter 3, or you can click Create New to create a new resource
    group. Then you’d need to choose a name for your storage account.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要选择一个资源组。为此，您可以使用第3章中创建的资源组，或者您可以点击“创建新”来创建一个新的资源组。然后您需要为您的存储帐户选择一个名称。
- en: '![](../Images/CH04_F06_Davis4.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F06_Davis4.png)'
- en: Figure 4.6 Filling out details for the new storage account
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 填写新存储帐户的详细信息
- en: The other settings can be left at their defaults. After filling out the details,
    click Review + Create. If the details pass validation, you can then click Create
    to create the storage account. If they don’t validate, then you’ll need to follow
    the instructions to fix the problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 其他设置可以保留默认值。填写完详细信息后，点击“审查 + 创建”。如果详细信息通过验证，您就可以点击“创建”来创建存储帐户。如果它们没有通过验证，那么您需要按照指示修复问题。
- en: Now, wait until you get the notification saying your storage account has been
    deployed. At that point, you can click Go to Resource in the notification, or
    you can find your resource in the global list like you did in chapter 3.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，等待直到您收到通知，表示您的存储帐户已部署。在那个时刻，您可以在通知中点击“转到资源”，或者您可以在全局列表中找到您的资源，就像在第3章中做的那样。
- en: Once you open the storage account in the Azure portal, click Access Keys in
    the left-hand menu. Here you’ll see the access keys for your storage account like
    figure 4.7 shows. These are the details you need to authenticate with your storage
    account. Make a note of your storage account name and one of the keys. You only
    need the value for one of the keys. You don’t need the connection string.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在Azure门户中打开存储帐户，点击左侧菜单中的访问密钥。在这里，您将看到与图4.7所示类似的存储帐户访问密钥。这些是您需要与存储帐户进行身份验证的详细信息。记下您的存储帐户名称和一个密钥。您只需要一个密钥的值。您不需要连接字符串。
- en: Note that figure 4.7 shows the keys from my account. You’ll need to look up
    the keys for your own account. These will be different from my keys, of course,
    and my keys won’t even work anymore by the time you read this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，图4.7显示了来自我的帐户的密钥。您需要查找您自己帐户的密钥。这些密钥当然与我的密钥不同，而且到您阅读这篇文章的时候，我的密钥可能已经不再有效了。
- en: '![](../Images/CH04_F07_Davis4.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F07_Davis4.png)'
- en: Figure 4.7 Viewing the authentication details of our new storage account
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 查看我们新存储帐户的认证详情
- en: Uploading your video to Azure Storage
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的视频上传到Azure存储
- en: With our storage account created, we can now upload our test video. In the Azure
    portal, with your storage account open, click Containers in the menu on the left.
    You should see a message like figure 4.8 shows, saying you don’t have any containers
    yet.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的存储帐户创建完成后，我们现在可以上传我们的测试视频。在Azure门户中，当您的存储帐户打开时，点击左侧菜单中的容器。您应该会看到一个如图4.8所示的消息，表示您还没有任何容器。
- en: By the way, just to avoid confusion, I need to say that the container we are
    talking about here is *not* the same as the containers we are running in our microservices
    application. A container in Azure Storage is like a directory; it’s a location
    to store files.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，为了避免混淆，我需要说明，我们在这里讨论的容器与我们运行在微服务应用程序中的容器**不是**同一个。Azure 存储中的容器就像一个目录；它是一个存储文件的地点。
- en: '![](../Images/CH04_F08_Davis4.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F08_Davis4.png)'
- en: Figure 4.8 Navigating to Containers and creating our videos container
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 导航到容器并创建我们的视频容器
- en: Click the + Container button in the toolbar to create your first container.
    Now type in a name for your container. You can call it anything you like at this
    point, but to make it work with the example code coming up, let’s call it videos.
    Here you can also choose the access level, but we’ll stick with the default, which
    is Private Access Only. Next, click OK to create the container.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具栏中点击 + 容器按钮以创建你的第一个容器。现在为你的容器输入一个名称。在这个阶段你可以给它起任何名字，但为了与即将出现的示例代码兼容，让我们称它为
    videos。在这里你还可以选择访问级别，但我们将保持默认设置，即仅私有访问。接下来，点击确定以创建容器。
- en: You should see the videos container in the list now. Click it to drill down.
    When viewing the contents of your new container, you’ll see a message like in
    figure 4.9\. In case you are wondering what a *blob* is, it is simply a file,
    and we don’t have any of those yet. Let’s upload one now.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能在列表中看到视频容器。点击它以深入查看。在查看你新容器的内容时，你会看到一个如图 4.9 所示的消息。如果你想知道什么是 *blob*，它只是一个文件，我们目前还没有任何这样的文件。现在让我们上传一个。
- en: Click the Upload button in the toolbar to upload your video file, and select
    a file on your disk to upload. You can use the test video that is included in
    either of the code repositories for chapter 2 or 3; otherwise, use a video of
    your own choice.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具栏中点击上传按钮以上传你的视频文件，并从你的磁盘上选择一个文件进行上传。你可以使用第 2 章或第 3 章代码库中包含的测试视频；否则，使用你自己的选择。
- en: '![](../Images/CH04_F09_Davis4.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F09_Davis4.png)'
- en: Figure 4.9 Drilling down into the videos container and clicking Upload to upload
    a video file
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 深入视频容器并点击上传以上传视频文件
- en: After the video has uploaded, it will appear in the list as shown in figure
    4.10.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 视频上传后，它将如图 4.10 所示出现在列表中。
- en: '![](../Images/CH04_F10_Davis4.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F10_Davis4.png)'
- en: Figure 4.10 After the video is uploaded, you will see it in the list under the
    videos container.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 视频上传后，你将在视频容器下看到它
- en: Creating a microservice to read Azure Storage
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个读取 Azure 存储的微服务
- en: We now have a test video uploaded to Azure Storage, so it’s time to create our
    new video-storage microservice. This is our second official microservice, and
    it will be a REST API to retrieve videos from our storage provider.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在 Azure 存储中上传了一个测试视频，因此是时候创建我们的新视频存储微服务了。这是我们第二个官方微服务，它将是一个 REST API，用于从我们的存储提供商检索视频。
- en: Note We could directly integrate our video-streaming microservice with cloud
    storage, but instead, we’ll *abstract* this connection behind another microservice.
    This makes it trivial to later replace the storage mechanism and can pave the
    way for our application to support multiple storage providers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 我们可以直接将我们的视频流微服务与云存储集成，但我们将把这个连接抽象化，通过另一个微服务来实现。这使得以后替换存储机制变得非常简单，并为我们的应用程序支持多个存储提供商铺平道路。
- en: The first thing we need to do is to create a new directory for our second microservice.
    You should either create a new subdirectory or just load example-2 from the chapter-4
    code repository into VS Code. We’ll name the subdirectory for the new microservice
    as azure-storage*.* We name this new project specifically to indicate that its
    purpose is related to Azure Storage. If we were to add different storage providers,
    we would call these something different (for example, aws-storage or google-storage).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的第二个微服务创建一个新的目录。你应该创建一个新的子目录，或者只需将 chapter-4 代码库中的 example-2 加载到
    VS Code 中。我们将为新微服务的子目录命名为 azure-storage*.* 我们特意这样命名新项目，以表明其目的与 Azure 存储相关。如果我们要添加不同的存储提供商，我们将使用不同的名称（例如，aws-storage
    或 google-storage）。
- en: 'A quick note: in case you were thinking of porting the code presented here
    over to AWS or GCP, converting from the Azure store microservice over to another
    provider is not a simple task. The APIs to interface with AWS and GCP storage
    will be quite different to Azure, and you’ll need to read their docs separately
    to figure out how to use these. Make sure you finish learning about the Azure
    storage microservice in this chapter before you attempt to convert to any other
    provider.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 简要说明：如果你在考虑将此处展示的代码移植到AWS或GCP，将Azure存储微服务转换为其他提供商并不是一个简单的任务。与Azure相比，与AWS和GCP存储接口的API将相当不同，你需要单独阅读它们的文档来了解如何使用这些API。确保你在尝试转换为任何其他提供商之前，已经在本章中完成了对Azure存储微服务的学习。
- en: 'Now open a terminal and change into the azure-storage directory. If you are
    creating the new microservice from scratch, you’ll need to create a new package.json
    and install the express package like we did in chapter 2\. You’ll then need to
    install the azure-storage package like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个终端并切换到azure-storage目录。如果你是从头创建新的微服务，你需要创建一个新的package.json并安装express包，就像我们在第2章中所做的那样。然后你需要像这样安装azure-storage包：
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are following along with example-2 in the chapter 4 code repository,
    everything you need is already there:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随第4章代码仓库中的example-2，你需要的一切已经准备好了：
- en: The package file
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包文件
- en: The code
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码
- en: The Dockerfile
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: 'To run the new microservice directly under Node.js, you’ll first need to change
    directory to azure-storage and then install the dependencies:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Node.js下直接运行新微服务，你首先需要切换到azure-storage目录并安装依赖项：
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 4.2 presents the code for our new microservice. Before we run this code,
    let’s read it and understand what it’s doing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2展示了我们新微服务的代码。在我们运行此代码之前，让我们先阅读并理解它在做什么。
- en: Listing 4.2 A microservice to retrieve videos from Azure storage (chapter-4/example-2/azure-storage/src/index.js)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 从Azure存储检索视频的微服务（chapter-4/example-2/azure-storage/src/index.js）
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Loads the azure-storage package so our code can interact with the Azure Storage
    API
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ① 加载azure-storage包，以便我们的代码可以与Azure Storage API交互
- en: ② Gets the name of the storage account from an environment variable
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从环境变量中获取存储账户的名称
- en: ③ Gets the name of the access key from an environment variable
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 从环境变量中获取访问键的名称
- en: ④ Helper function that connects to the azure-storage API
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 连接到azure-storage API的辅助函数
- en: ⑤ HTTP GET route for retrieving a video from Azure storage
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 用于从Azure存储检索视频的HTTP GET路由
- en: ⑥ Specifies the path to the video in storage as an HTTP query parameter
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 指定存储中视频的路径作为HTTP查询参数
- en: ⑦ Connects to the azure-storage API
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 连接到azure-storage API
- en: ⑧ Hard-coded container name. Later we can vary this for some purpose (say, by
    user ID so we can keep videos for each user separately).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 固定编码的容器名称。稍后我们可以根据某些目的（例如，通过用户ID，以便我们可以为每个用户分别保存视频）来更改此名称。
- en: ⑨ Retrieves the video’s properties from Azure storage
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 从Azure存储检索视频的属性
- en: ⑩ Writes content length and mime type to the HTTP response headers
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 将内容长度和MIME类型写入HTTP响应头
- en: ⑪ Streams the video from Azure storage to the HTTP response
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 从Azure存储流式传输视频到HTTP响应
- en: In listing 4.2, we use `azure-storage`*, which is* the official Azure Storage
    SDK installed via npm. We also created an HTTP server using Express in the same
    way as we did in chapter 2.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.2中，我们使用`azure-storage`，这是通过npm安装的官方Azure Storage SDK。我们同样使用Express创建了一个HTTP服务器，就像我们在第2章中所做的那样。
- en: There are two new environment variables to configure this microservice; STORAGE
    _ACCOUNT_NAME and STORAGE_ACCESS_KEY set the authentication details for our Azure
    Storage account. Note that you will have to set these environment variables to
    the authentication details from your own storage account. You’ll do that in the
    next section. The authentication details are used in the helper function `createBlobService`
    to create the API object that we need to access the storage SDK.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个新的环境变量用于配置此微服务；STORAGE_ACCOUNT_NAME和STORAGE_ACCESS_KEY设置了我们的Azure存储账户的认证详情。请注意，你必须将这些环境变量设置为来自你自己的存储账户的认证详情。你将在下一节中这样做。认证详情用于辅助函数`createBlobService`以创建我们需要访问存储SDK的API对象。
- en: The most important thing in listing 4.2 is the HTTP GET route /video, by which
    we can retrieve a video from storage. This route streams a video from Azure Storage
    to the HTTP response.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2中最重要的是HTTP GET路由/video，通过它可以从存储中检索视频。此路由从Azure存储流式传输视频到HTTP响应。
- en: Testing our new microservice independently
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 独立测试我们的新微服务
- en: Before we try and integrate this microservice into our application, it’s best
    if we test it independently. In this case, we could easily integrate it first
    and then test it later. Working that way is feasible when our application is this
    small. However, as our application grows larger and more complicated, integration
    testing becomes more difficult.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试将此微服务集成到我们的应用程序之前，最好先独立测试它。在这种情况下，我们可以先集成它，然后再进行测试。当我们的应用程序如此之小的时候，这样工作是可以行的。然而，随着我们的应用程序变得更大、更复杂，集成测试就变得更加困难。
- en: Testing microservices individually works better because we can start or reload
    a single microservice quickly. But doing the same isn’t as easy for the application
    as a whole. Let’s therefore get into a habit of testing our microservices individually
    before integration testing the application as a whole.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 单独测试微服务效果更好，因为我们可以快速启动或重新加载单个微服务。但对于整个应用程序来说，这样做并不容易。因此，让我们养成在集成测试整个应用程序之前先单独测试我们的微服务的习惯。
- en: 'Before running (and testing) the new microservice, we need to set the environment
    variables to configure it. We will do this from the terminal. On MacOS and Linux,
    we do it like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行（并测试）新微服务之前，我们需要设置环境变量来配置它。我们将从终端进行此操作。在MacOS和Linux上，我们这样做：
- en: '[PRE13]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On Windows, we do it like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们这样做：
- en: '[PRE14]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that you must insert the name and key for the storage account that you
    created earlier. When running the microservice, we can choose to run it in either
    production mode or in development mode as we discussed in chapter 2\. We can run
    it in *production mode* like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须插入你之前创建的存储账户的名称和密钥。当运行微服务时，我们可以选择以生产模式或开发模式运行，正如我们在第2章中讨论的那样。我们可以像这样以*生产模式*运行：
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, we can run it in *development mode* with nodemon for live reload
    like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以以*开发模式*运行它，使用nodemon进行实时重新加载，如下所示：
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Live reload is really important to fast development because we can make changes
    to our code and have our microservice automatically restart. In the next chapter,
    you’ll learn how to extend live reload to the *entire* microservices application.
    For now, we’ll settle for using it during development and testing of an individual
    microservice.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 实时重新加载对于快速开发来说非常重要，因为我们可以在代码中做出更改，并让微服务自动重启。在下一章中，你将学习如何将实时重新加载扩展到整个微服务应用程序。现在，我们将满足于在开发和测试单个微服务时使用它。
- en: With your microservice running, you can now open your browser and navigate to
    http://localhost:3000/video?path=SampleVideo_1280x720_1mb.mp4\. If you used a
    different name for your video, you’ll need to adjust the name of that video in
    this URL to fit. You should now see the familiar video playing, but this time,
    it’s streamed from your Azure storage account.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的微服务正在运行时，你现在可以打开你的浏览器并导航到http://localhost:3000/video?path=SampleVideo_1280x720_1mb.mp4。如果你使用了不同的视频名称，你需要调整此URL中的视频名称以适应。你现在应该看到熟悉的视频正在播放，但这次是从你的Azure存储账户流式传输的。
- en: We’ll talk more about testing microservices in chapter 8\. For the moment though,
    let’s move on and integrate our new microservice into the application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章中更多地讨论微服务的测试。不过，现在让我们继续前进，将我们的新微服务集成到应用程序中。
- en: 4.4.2 Updating the video-streaming microservice
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 更新视频流微服务
- en: The first step of integrating the new microservice with our application is to
    update our video-streaming microservice. As a reminder, we ended chapter 3 with
    a video-streaming microservice that loaded the test video from the filesystem.
    Now, we are going to update that microservice so that it instead delegates the
    loading of the video to our new Azure Storage microservice.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将新微服务集成到我们的应用程序中的第一步是更新我们的视频流微服务。作为提醒，我们在第3章结束时结束了一个从文件系统加载测试视频的视频流微服务。现在，我们将更新该微服务，使其委托视频加载到我们新的Azure存储微服务。
- en: Here we update our video-streaming microservice to delegate storage to another
    microservice. We are *separating our concerns* so that the video-streaming microservice
    is solely responsible for streaming video to our user and so that it doesn’t need
    to know the details of how storage is handled.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们更新我们的视频流微服务，将存储委托给另一个微服务。我们正在*分离关注点*，这样视频流微服务就只负责将视频流式传输给我们的用户，并且它不需要知道存储处理的细节。
- en: Listing 4.3 shows the changes we’ll make to the video-streaming microservice.
    Read through the code in the listing to see how we are forwarding the HTTP request
    for a video through to the new video-storage microservice.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 展示了我们将对视频流微服务所做的更改。阅读列表中的代码，以了解我们是如何将视频的 HTTP 请求转发到新的视频存储微服务的。
- en: Listing 4.3 Updated video-streaming microservice (chapter-4/example-2/video-streaming/src/index.js)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 更新的视频流微服务（第 4 章/示例 2/video-streaming/src/index.js）
- en: '[PRE17]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Loads the (built-in) http library so we can forward HTTP requests
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ① 加载（内置）http 库以便我们可以转发 HTTP 请求
- en: ② Configures the connection to the video-storage microservice
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ② 配置连接到视频存储微服务
- en: ③ Forwards the HTTP GET request to the video route to the video-storage microservice
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将 HTTP GET 请求转发到视频存储微服务的视频路由
- en: ④ Sets the host and port we are forwarding to
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置我们要转发的目标主机和端口
- en: ⑤ Sets the route we are forwarding to
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置我们要转发的路由
- en: ⑥ Forwarding as an HTTP GET request
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将请求作为 HTTP GET 请求转发
- en: ⑦ Forwarding the HTTP headers as they are
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 原样转发 HTTP 头部信息
- en: ⑧ Gets the response from the forwarded request
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 获取转发请求的响应
- en: ⑨ Returns the status code and header of the forwarded request
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 返回转发请求的状态码和头部信息
- en: ⑩ Pipes the response stream using Node.js streams
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 使用 Node.js 流管道响应流
- en: ⑪ Pipes the request stream using Node.js streams
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 使用 Node.js 流管道请求流
- en: In listing 4.3, we use the Node.js built-in http library to forward an HTTP
    request from one microservice to another. The response that is returned is then
    streamed to the client. The way this works might be difficult to understand, but
    don’t worry too much about it right now. In the next chapter, we’ll explore this
    more because communication between microservices is so important that it deserves
    its own chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 4.3 中，我们使用 Node.js 内置的 http 库将一个微服务的 HTTP 请求转发到另一个微服务。然后返回的响应被流式传输到客户端。这种工作方式可能难以理解，但现在不必过于担心。在下一章中，我们将更深入地探讨这一点，因为微服务之间的通信非常重要，值得单独成章。
- en: Note that we have hard-coded the path to the video in storage at this point.
    This is just a stepping stone, and we’ll soon fix that. But for this code to work
    in the meantime, you must have uploaded the test video to this path. If you’ve
    uploaded a different video, you should change the code accordingly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们目前硬编码了存储中视频的路径。这只是一个过渡步骤，我们很快就会解决这个问题。但为了使这段代码在同时工作，你必须已经将测试视频上传到这个路径。如果你上传了不同的视频，你应该相应地更改代码。
- en: After updating our video-streaming microservice, we should test it independently.
    That’s kind of difficult given that it depends on the video-storage microservice.
    We could do this if we had the tools and techniques in place to *mock* our dependencies.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新我们的视频流微服务后，我们应该独立对其进行测试。鉴于它依赖于视频存储微服务，这有点困难。如果我们有模拟依赖项的工具和技术，我们就可以这样做。
- en: Mocking is a technique used in testing where we replace the dependency with
    a fake or simulated alternative. We don’t have those techniques yet, but this
    is something we’ll explore in chapter 8, and you’ll see an example of a mock microservice
    in chapter 9\. Right now, let’s just press on and finish the integration. Then
    we can check that the application works as expected.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是测试中使用的技巧，其中我们用假或模拟的替代品替换依赖项。我们目前还没有这些技术，但这是我们在第 8 章中将要探讨的内容，你将在第 9 章中看到一个模拟微服务的示例。现在，让我们继续前进并完成集成。然后我们可以检查应用程序是否按预期工作。
- en: 4.4.3 Adding our new microservice to the Docker Compose file
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 将我们的新微服务添加到 Docker Compose 文件中
- en: We’ve done quite a lot of work to get to this point. We created an Azure Storage
    account, and we uploaded our test video. Then we created our second microservice,
    the Azure Storage microservice, which is a REST API that abstracts our storage
    provider. After that, we updated our video-streaming microservice so that instead
    of loading the video from the filesystem, as it did in chapters 2 and 3, it now
    retrieves the video via the video-storage microservice.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为此做了很多工作。我们创建了一个 Azure 存储账户，并上传了我们的测试视频。然后我们创建了第二个微服务，即 Azure 存储微服务，它是一个抽象我们的存储提供程序的
    REST API。之后，我们更新了视频流微服务，使其不再像第 2 章和第 3 章那样从文件系统加载视频，而是现在通过视频存储微服务检索视频。
- en: Note The beauty of the Docker Compose file is that it makes it easier to define
    and manage a whole suite of containers. It’s a convenient way to manage a microservices
    application!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Docker Compose 文件的优点在于它使得定义和管理一系列容器变得更加容易。这是一种管理微服务应用程序的便捷方式！
- en: To integrate the new microservice into our application and test it, we now must
    add it as a new section to our Docker Compose file. You can see what this looks
    like in figure 4.11, which shows what the Docker Compose file will look like later,
    after we add our second microservice and the database server. You can see that
    the Docker Compose file on the left has three sections that map to the three containers
    on the right.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将新的微服务集成到我们的应用程序中并进行测试，我们现在必须将其添加到我们的 Docker Compose 文件的新部分中。您可以在图 4.11 中看到它的样子，该图显示了在添加第二个微服务和数据库服务器后
    Docker Compose 文件将看起来如何。您可以看到左侧的 Docker Compose 文件有三个部分，对应右侧的三个容器。
- en: '![](../Images/CH04_F11_Davis4.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F11_Davis4.png)'
- en: Figure 4.11 Each section in our Docker Compose file defines a separate container.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 我们的 Docker Compose 文件中的每个部分定义了一个独立的容器。
- en: You can think of the Docker Compose file as a kind of *aggregate* Dockerfile
    that we use to describe and manage multiple containers at once. It’s an aggregate
    because we use it to tie together the multiple Dockerfiles for each of our microservices.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Docker Compose 文件视为一种 *聚合* Dockerfile，我们用它来描述和管理多个容器。它之所以是聚合的，是因为我们用它将每个微服务的多个
    Dockerfile 连接起来。
- en: Listing 4.4 shows our updated Docker Compose file with the addition of the Azure
    Storage microservice. Before we get to testing this, make sure you set the values
    of STORAGE_NAME and STORAGE_ACCESS_KEY to the values you noted down earlier from
    your own Azure Storage account.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 显示了我们的更新后的 Docker Compose 文件，其中添加了 Azure 存储微服务。在我们进行测试之前，请确保将 STORAGE_NAME
    和 STORAGE_ACCESS_KEY 的值设置为之前从您自己的 Azure 存储账户中记录的值。
- en: Listing 4.4 Adding a new microservice to our Docker Compose file (chapter-4/example-2/docker-compose.yaml)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 向我们的 Docker Compose 文件中添加新的微服务（第 4 章/示例 2/docker-compose.yaml）
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Adds the new microservice to our application
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将新的微服务添加到我们的应用程序中
- en: ② Sets the name of the image
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置图像名称
- en: ③ The container’s name connects these two microservices!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 容器的名称将这些两个微服务连接起来！
- en: ④ Configures the microservice to connect to our Azure storage account. Make
    sure you add your own details here.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 配置微服务以连接到我们的 Azure 存储账户。请确保在此处添加您自己的详细信息。
- en: ⑤ The container’s name connects these two microservices!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 容器的名称将这些两个微服务连接起来！
- en: ⑥ Configures the microservice to connect to the video-storage microservice
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 配置微服务以连接到视频存储微服务
- en: 'There are some questions you might have on your mind at this point: why is
    the container name set to `video-storage` instead of `azure-storage`? We called
    the microservice azure-storage, but we called the container video-storage; why
    is that? This is an intentional abstraction. It’s a part of our design that the
    video-streaming microservice doesn’t care where it retrieves its videos from!
    It’s not interested in the fact that the videos are stored in Azure. From its
    point of view, these could just as easily be stored anywhere else, such as AWS
    S3 or Google Cloud Storage.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能心中会有一些疑问：为什么容器名称设置为 `video-storage` 而不是 `azure-storage`？我们称微服务为 azure-storage，但容器名称却是
    video-storage；这是为什么？这是一个故意的抽象。这是我们的设计的一部分，视频流微服务并不关心它从哪里获取视频！它对视频存储在 Azure 的事实不感兴趣。从它的角度来看，这些视频同样可以存储在任何其他地方，比如
    AWS S3 或 Google Cloud Storage。
- en: By naming our container as video-storage, we are now able to connect our microservices
    to it using a name that is independent of the underlying storage provider. This
    is good application structure put into practice. We have given ourselves the flexibility
    of later being able to swap out azure-storage and replace it with aws-storage
    or google-storage. And we can do this without interrupting the video-streaming
    microservice. From its point of view, nothing will have changed. This kind of
    freedom to effect change in the future without knock-on effects is important,
    and it shows that we are making the most of our microservices architecture.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的容器命名为 video-storage，我们现在能够使用一个与底层存储提供者无关的名称将我们的微服务连接到它。这是一种良好的应用程序结构实践。我们为自己提供了灵活性，以便将来能够替换
    azure-storage 并用 aws-storage 或 google-storage 替换它。而且我们可以这样做而不中断视频流微服务。从它的角度来看，什么都没有改变。这种在未来进行更改而不产生连锁反应的自由很重要，这也表明我们正在充分利用我们的微服务架构。
- en: 4.4.4 Testing the updated application
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 测试更新后的应用程序
- en: 'We have updated our Docker Compose file to include both of our microservices.
    Now we are finally ready to boot our application and test it with our additional
    microservice. For this, we run our application the same as before:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了我们的Docker Compose文件，以包含我们的两个微服务。现在我们终于准备好启动我们的应用程序，并使用我们的附加微服务进行测试。为此，我们像以前一样运行我们的应用程序：
- en: '[PRE19]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The difference now is that we have booted up two containers, rather than just
    the one. You can see an example of the output in the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的区别是我们启动了两个容器，而不仅仅是单个容器。你可以在下面的示例中看到输出示例：
- en: '[PRE20]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note in the output how the name of each container is printed on the left. This
    is an aggregate stream of logging from all containers. The name on the left allows
    us to differentiate the output from each microservice.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中每个容器的名称都打印在左侧。这是来自所有容器的日志聚合流。左侧的名称允许我们区分每个微服务的输出。
- en: Note We are booting our application with multiple containers using a single
    command so we can test our application with multiple microservices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们使用单个命令启动多个容器来运行我们的应用程序，这样我们就可以使用多个微服务来测试我们的应用程序。
- en: 'Now that we have added our second microservice, this is where we start to see
    the real value of Docker Compose. We could have booted up the application without
    Docker Compose in either of the following ways:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了第二个微服务，这是我们看到Docker Compose真正价值的开始。我们可以在以下两种方式中启动应用程序而不使用Docker Compose：
- en: '*Open two terminals and use Node.js directly to run the video-streaming microservice
    in one terminal and the Azure storage microservice in the other.* That’s two terminals
    and two commands to run our application.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*打开两个终端，并直接使用Node.js在一个终端中运行视频流微服务，在另一个终端中运行Azure存储微服务。* 这意味着两个终端和两个命令来运行我们的应用程序。'
- en: '*Use Docker to run two containers.* In this case, we have to run `docker` `build`
    and `docker` `run` once for each microservice. That’s one terminal and four commands.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Docker运行两个容器。* 在这种情况下，我们必须为每个微服务分别运行`docker build`和`docker run`。这意味着一个终端和四个命令。'
- en: No one wants to spend all day repetitively typing commands. Instead, Docker
    Compose allows us to boot our application with a *single* command, and this is
    scalable to any number of containers.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人愿意整天重复输入命令。相反，Docker Compose允许我们使用单个命令启动我们的应用程序，并且这可以扩展到任意数量的容器。
- en: Just imagine down the track a bit; we have built our application with up to
    10 microservices. Without Docker Compose, you will have to type at least 20 commands
    to build and start your application. With Docker Compose, we can build and run
    our 10 microservice applications with just one command! No matter how many containers
    we need, it’s still just one command.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下将来；我们已经用多达10个微服务构建了我们的应用程序。如果没有Docker Compose，你至少需要输入20个命令来构建和启动你的应用程序。有了Docker
    Compose，我们可以用单个命令构建和运行我们的10个微服务应用程序！无论我们需要多少个容器，它仍然是单个命令。
- en: At this point, we have two opportunities for testing. At a minimum, we must
    test the video-streaming microservice because, currently, that’s the only customer-facing
    endpoint we have. To do that, open a browser and navigate to http://localhost:4001/
    video.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有两次测试的机会。至少，我们必须测试视频流微服务，因为目前这是我们唯一的面向客户的端点。为此，打开浏览器并导航到http://localhost:4001/video。
- en: Yet again, you’ll see the familiar test video. Testing the video-streaming microservice
    actually tests both microservices because the video-streaming microservice depends
    on the video-storage microservice. These both get tested at the same time. We
    could stop here, but we can also independently test the video-storage microservice.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你会看到熟悉的测试视频。测试视频流微服务实际上测试了两个微服务，因为视频流微服务依赖于视频存储微服务。这两个微服务同时被测试。我们可以在这里停止，但也可以独立测试视频存储微服务。
- en: If you glance back to listing 4.4, you’ll see that we have bound its port to
    4000\. We can navigate our browser to that port and see video streaming directly
    from the video-storage microservice. The video-storage microservice, however,
    expects us to tell it the path where the video is located. We do that via the
    URL. Let’s navigate our browser to http://localhost:4000/video?path=SampleVideo_1280x720_1mb.mp4
    and test the video-storage microservice.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下列表4.4，你会看到我们已经将其端口绑定到了4000。我们可以将浏览器导航到该端口，并直接从视频存储微服务中查看视频流。然而，视频存储微服务期望我们告诉它视频所在的位置。我们通过URL来完成这个操作。让我们将浏览器导航到http://localhost:4000/video?path=SampleVideo_1280x720_1mb.mp4并测试视频存储微服务。
- en: Note that testing an internal microservice from the *outside* like this is only
    possible in development. Once we move this microservice to production, its REST
    API is only available within the Kubernetes cluster. In this case, we’ll make
    it private because we don’t want the outside world having direct access to our
    video storage. This is a security feature of microservices! We can control which
    microservices are exposed to the outside world, and we can use that to restrict
    access to parts of the application that should not be directly accessible by outsiders.
    We’ll talk more about security in chapter 11.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，像这样从*外部*测试内部微服务只可能在开发中实现。一旦我们将这个微服务移到生产环境，它的 REST API 只在 Kubernetes 集群内部可用。在这种情况下，我们将使其私有，因为我们不希望外部世界直接访问我们的视频存储。这是微服务的一个安全特性！我们可以控制哪些微服务暴露给外部世界，我们可以利用这一点来限制外部人士直接访问的应用程序部分。我们将在第
    11 章中更多地讨论安全性。
- en: Well, there we have it. We added external file storage to our application, and
    in the process, we scaled it up to two microservices. Before we congratulate ourselves,
    however, let’s consider some design theory.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是我们做到的。我们给我们的应用程序添加了外部文件存储，在这个过程中，我们将它扩展到了两个微服务。然而，在我们自我祝贺之前，让我们考虑一些设计理论。
- en: 4.4.5 Cloud storage vs. cluster storage
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 云存储与集群存储的比较
- en: At this point, if you know anything about Kubernetes, you might be wondering
    why we haven’t used Kubernetes volumes for file storage as opposed to cloud storage.
    That’s an important design decision, and again, it’s the kind of thing that depends
    on the needs of your project, your business, and your customers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你对 Kubernetes 有所了解，你可能会想知道为什么我们没有使用 Kubernetes 卷来存储文件，而不是使用云存储。这是一个重要的设计决策，而且，这又是一种取决于你的项目、你的业务和你的客户需求的事情。
- en: We used cloud storage instead of cluster storage because it’s simple, it works
    when we run in development, it’s cheap, and it’s managed for us. These are the
    benefits of cloud storage and why it’s in common use by many companies. Besides,
    we haven’t learned anything about Kubernetes yet, so we definitely couldn’t have
    used Kubernetes volumes at this point in the book. However, there’s another important
    reason why I generally choose to use cloud storage over cluster storage.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用云存储而不是集群存储，因为它简单，我们在开发中运行时它有效，它便宜，而且有人为我们管理。这些都是云存储的好处，也是为什么许多公司普遍使用它的原因。此外，我们还没有学习关于
    Kubernetes 的任何知识，所以我们肯定不能在本书的这个阶段使用 Kubernetes 卷。然而，还有一个重要的原因，为什么我通常选择使用云存储而不是集群存储。
- en: We could store the files and data for our application in the Kubernetes cluster,
    but I prefer my production cluster to be *stateless*. That means I can destroy
    and rebuild the cluster at will without risk of losing the data. Later, this enables
    us to use *blue-green deployment* for our production rollouts, which we’ll talk
    about in chapter 11\. This makes it easy to build a new and updated instance of
    our application that runs in parallel with the previous version.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们应用程序的文件和数据存储在 Kubernetes 集群中，但我更喜欢我的生产集群是无状态的。这意味着我可以随意销毁和重建集群，而不会丢失数据。稍后，这将使我们能够为我们的生产部署使用*蓝绿部署*，我们将在第
    11 章中讨论这一点。这使得构建与旧版本并行运行的新和更新实例变得容易。
- en: To upgrade our customers to the new version, we can then switch the DNS record
    so that the hostname now refers to the new instance. This gives us a low-risk
    way to do major upgrades to our application. It’s low risk not because problems
    won’t happen, but because if problems do happen, we can quickly switch the DNS
    back to the old instance so that our customers are (almost) immediately reverted
    to the previous (and presumably working) version.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的客户升级到新版本，我们然后可以切换 DNS 记录，这样主机名现在就指向了新实例。这为我们提供了低风险的方式来对我们的应用程序进行重大升级。它低风险并不是因为不会出现问题，而是因为如果出现问题，我们可以快速将
    DNS 切换回旧实例，这样我们的客户就可以（几乎）立即恢复到之前的（并且可能是有效的）版本。
- en: 4.4.6 What did we achieve?
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.6 我们取得了什么成果？
- en: Congratulations! We now have a small microservices application running! That’s
    a big deal. Using Docker Compose, we created a scaffold into which we can easily
    add new microservices and grow our application. Take a moment to pat yourself
    on the back. This is a big milestone!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们现在有一个小型的微服务应用程序在运行！这是一个大事件。使用 Docker Compose，我们创建了一个支架，我们可以轻松地添加新的微服务并扩展我们的应用程序。花点时间给自己鼓掌。这是一个重要的里程碑！
- en: What did we achieve? We added file storage capability to our application. Our
    microservice now has the capability to store files in external cloud storage,
    and this gives our application a place to host its videos.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了什么成果？我们向应用程序添加了文件存储功能。我们的微服务现在具有将文件存储在外部云存储中的能力，这为我们的应用程序提供了一个托管视频的地方。
- en: We also added a second microservice. With Docker Compose in place, we can now
    continue to expand our application by adding new containers to it. We’ll make
    use of this capability again in a moment when we add a database server to our
    application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了第二个微服务。由于Docker Compose已经到位，我们现在可以通过向其中添加新的容器来继续扩展我们的应用程序。当我们向应用程序添加数据库服务器时，我们将在稍后再次利用这种能力。
- en: We added the second microservice as an abstraction over our storage provider.
    This is a design decision with benefits. We can now swap out and replace our video-storage
    microservice with a different storage provider with minimal impact on our application.
    We could even do this while the application is running in production! It’s even
    possible in the future that we might want to have multiple storage microservices
    running in parallel. If it suited our product, we could upgrade it to support
    Azure Storage, AWS S3, and Google Cloud Storage all at the same time!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了第二个微服务，作为我们的存储提供者的抽象。这是一个有利的决策设计。现在我们可以用不同的存储提供者替换和替换我们的视频存储微服务，而对应用程序的影响最小。我们甚至可以在应用程序在生产环境中运行时这样做！未来甚至可能需要同时运行多个存储微服务。如果适合我们的产品，我们可以将其升级以支持Azure存储、AWS
    S3和Google Cloud Storage！
- en: The details of how storage works have been restricted to the internals of the
    video-storage microservice. That means we can change the details independently
    from the rest of the application without causing knock-on problems. This kind
    of protection might seem superfluous right now, but it becomes more important
    as our application grows.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 存储工作细节已被限制在视频存储微服务的内部。这意味着我们可以独立于应用程序的其他部分更改这些细节，而不会引起连锁问题。这种保护可能现在看起来是多余的，但随着我们应用程序的增长，它变得更为重要。
- en: Note Eventually, our application will become a spider’s web of communication
    among many microservices. Changes in one will have the potential to cause an exponential
    ripple of problems across the application. Careful construction of the interfaces
    between microservices to minimize their coupling helps us make the most of our
    microservices architecture.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：最终，我们的应用程序将成为许多微服务之间通信的蜘蛛网。一个微服务的更改有可能在应用程序中引起指数级的问题连锁。仔细构建微服务之间的接口以最小化它们的耦合，有助于我们充分利用微服务架构。
- en: 'Separating our microservices, the so-called separation of concerns (mentioned
    in chapter 1), is important-each microservice should look after its own separate
    area of responsibility. We are also following the single responsibility principle
    (also mentioned in chapter 1) that says each microservice should look after one
    single thing. Our microservices now look after their own areas of responsibility:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的微服务分离，即所谓的关注点分离（在第1章中提到），很重要——每个微服务应该负责其自己的独立责任区域。我们也在遵循单一责任原则（也在第1章中提到），即每个微服务应该负责一件事情。我们的微服务现在负责它们自己的责任区域：
- en: The video-streaming microservice is responsible for streaming a video to a user.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频流微服务负责将视频流式传输到用户。
- en: The video-storage microservice is responsible for locating videos in storage
    and retrieving these.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频存储微服务负责在存储中定位视频并检索这些视频。
- en: The separation of the microservices in this way helps to ensure that each microservice
    is small, simple, and manageable.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式分离微服务有助于确保每个微服务都小、简单且易于管理。
- en: 4.5 Adding a database to our application
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 向我们的应用程序添加数据库
- en: The other half of data management relates to the database. Most applications
    need some kind of database to store their dynamic data, and FlixTube is no exception.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 数据管理的另一半与数据库有关。大多数应用程序需要某种类型的数据库来存储它们的动态数据，FlixTube也不例外。
- en: The first thing we need is metadata storage for each video. We’ll start using
    our database by storing the path to each video. This will fix the problem we encountered
    earlier of having a hard-coded path to the video file in our video-streaming microservice.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要为每个视频存储元数据。我们将通过存储每个视频的路径来开始使用我们的数据库。这将解决我们之前遇到的问题，即在我们的视频流微服务中有一个硬编码的视频文件路径。
- en: Note Practically all applications need some kind of database to store the data
    that is to be updated by the application.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 实际上，几乎所有应用程序都需要某种类型的数据库来存储应用程序将要更新的数据。
- en: Figure 4.12 shows what our application will look like after we add the database.
    In addition to the two containers for our two microservices, we will have another
    container that hosts a MongoDB database. You can see in the diagram that only
    the video-streaming microservice connects to the database; the video-storage microservice
    doesn’t require a database.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 显示了添加数据库后我们的应用程序将看起来是什么样子。除了我们两个微服务的两个容器外，我们还将有一个容器来托管 MongoDB 数据库。您可以在图中看到，只有视频流微服务连接到数据库；视频存储微服务不需要数据库。
- en: '![](../Images/CH04_F12_Davis4.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F12_Davis4.png)'
- en: Figure 4.12 Adding a database to our application
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 将数据库添加到我们的应用程序中
- en: 4.5.1 Why MongoDB?
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 为什么选择 MongoDB？
- en: MongoDB is one of the most popular of the so-called NoSQL variety of databases.
    Using Docker allows us to have an almost *instant database*. We only need to specify
    the name of a database image, and Docker will pull it from DockerHub and instantiate
    it on our development workstation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是所谓 NoSQL 数据库中最受欢迎的一种。使用 Docker 允许我们几乎拥有一个“即时数据库”。我们只需要指定数据库镜像的名称，Docker
    就会从 DockerHub 中拉取它并在我们的开发工作站上实例化它。
- en: Note MongoDB is easy to use, provides a flexible database that stores schema-free
    structured data, and has a rich query API.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 MongoDB 易于使用，提供了一种灵活的数据库，可以存储无模式的结构化数据，并且具有丰富的查询 API。
- en: But there are many different databases that we could easily boot up with Docker,
    so why MongoDB? In my experience, even manually downloading and installing MongoDB
    is easy compared to older and more traditional databases; now that we have Docker
    it’s even easier still. Like any database, we can use MongoDB to store rich structured
    data. MongoDB is also known to have high performance and is extremely scalable.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以轻松启动许多不同的数据库，为什么选择 MongoDB 呢？根据我的经验，即使是手动下载和安装 MongoDB 也比旧的和更传统的数据库要容易；现在有了
    Docker，这甚至更容易。像任何数据库一样，我们可以使用 MongoDB 来存储丰富的结构化数据。MongoDB 也以其高性能和极高的可扩展性而闻名。
- en: I work with a lot of unpredictable data, and it’s hard to tell what’s going
    to be thrown at me next. I like the fact that MongoDB doesn’t force me to define
    a fixed schema! Although, it’s certainly possible to define a schema with MongoDB
    if you use an object-relational mapping (ORM) library like Mongoose ([https://www.npmjs.com/package/
    mongoose](https://www.npmjs.com/package/mongoose)).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我处理很多不可预测的数据，很难预测接下来会抛给我什么。我喜欢 MongoDB 不强迫我定义固定模式的事实！尽管如此，如果您使用像 Mongoose ([https://www.npmjs.com/package/mongoose](https://www.npmjs.com/package/mongoose))
    这样的对象关系映射（ORM）库，当然也可以使用 MongoDB 定义模式。
- en: 'MongoDB is also easy to query and update in many different programming languages.
    It’s well supported, has great documentation, and there are many examples in circulation.
    MongoDB is open source. You can find the code here: [https://github.com/ mongodb/mongo](https://github.com/mongodb/mongo).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 也易于在许多不同的编程语言中进行查询和更新。它得到了良好的支持，拥有优秀的文档，并且有大量的示例在流传。MongoDB 是开源的。您可以在以下位置找到代码：[https://github.com/mongodb/mongo](https://github.com/mongodb/mongo)。
- en: 4.5.2 Adding a database server in development
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 在开发中添加数据库服务器
- en: We are going to add a database to our application in development using Docker
    Compose in the same way that we added our video-storage microservice earlier in
    this chapter. We will add one new container to our application to host a single
    database server. We only need a single server, but we can host many databases
    on that server. This means we’ll be set up for the future to easily create more
    databases as we add more microservices to our application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算使用 Docker Compose 在开发中的应用程序中添加一个数据库，就像我们在本章前面添加视频存储微服务时所做的那样。我们将为我们的应用程序添加一个新容器来托管单个数据库服务器。我们只需要一个服务器，但可以在该服务器上托管多个数据库。这意味着我们为未来做好了准备，可以轻松地随着我们向应用程序添加更多微服务而创建更多数据库。
- en: Adding the database server to the Docker Compose file
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库服务器添加到 Docker Compose 文件中
- en: To add the database server to our application, we must update our Docker Compose
    file. Docker Compose makes it easy to add a database to our application. We just
    add a few lines to the Docker Compose file to specify the public Docker image
    for the database and set some configurations. Abracadabra, instant database!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据库服务器添加到我们的应用程序中，我们必须更新我们的 Docker Compose 文件。Docker Compose 使得将数据库添加到我们的应用程序变得容易。我们只需在
    Docker Compose 文件中添加几行，以指定数据库的公共 Docker 镜像并设置一些配置。Abracadabra，即时数据库！
- en: Listing 4.5 shows the updated Docker Compose file. We are adding a new section
    to the top of the file with the name `db` (short for database). The configuration
    for this container is different from the configuration for the microservices we
    added earlier. That’s because now we don’t need to build the image for the new
    container. Instead, we use the publicly published `mongo` image from Docker Hub.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5显示了更新的Docker Compose文件。我们在文件顶部添加了一个名为`db`（代表数据库）的新部分。这个容器的配置与我们之前添加的微服务的配置不同。这是因为现在我们不需要为新容器构建镜像。相反，我们使用从Docker
    Hub公开发布的`mongo`镜像。
- en: Listing 4.5 Adding a MongoDB database (chapter-4/example-3/docker-compose.yaml)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 添加MongoDB数据库（chapter-4/example-3/docker-compose.yaml）
- en: '[PRE21]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Adds a MongoDB database server to our microservices application
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将MongoDB数据库服务器添加到我们的微服务应用程序中
- en: ② Sets the image name and version. This is a public MongoDB image retrieved
    from Docker Hub.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置镜像名称和版本。这是一个从Docker Hub检索的公共MongoDB镜像。
- en: ③ Sets the name of the container that’s instantiated in our application. Our
    microservices use this name to connect to the database.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置在应用程序中实例化的容器名称。我们的微服务使用此名称连接到数据库。
- en: ④ Maps the MongoDB standard port 27017 to 4000 on our host OS. We can interact
    with and check the database on our host using port 4000.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将MongoDB标准端口27017映射到我们的主机OS上的4000。我们可以使用端口4000与主机上的数据库交互和检查。
- en: ⑤ Sets the restart policy to always. If MongoDB ever crashes (which hardly ever
    happens), this automatically restarts it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置重启策略为始终。如果MongoDB崩溃（这几乎从未发生），它会自动重启。
- en: ⑥ Configures the microservice to connect to the database
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 配置微服务以连接到数据库
- en: ⑦ Sets the name the microservice uses for its database
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 设置微服务用于其数据库的名称
- en: In our updated application, the video-streaming microservice will be connected
    to the database. Notice that we now have new environment variables, DBHOST and
    DBNAME, which configure the microservice’s connection to its database.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的更新后的应用程序中，视频流微服务将连接到数据库。请注意，我们现在有了新的环境变量，DBHOST和DBNAME，它们配置了微服务与其数据库的连接。
- en: It’s also worth noting in the configuration for the db container how we have
    mapped the container’s ports. Here we have mapped the standard MongoDB port of
    27017 to 4000\. What does this mean? Within the Docker runtime, other containers
    can access the database using 27017\. That’s the conventional port for MongoDB,
    so we’ll stick with that.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意在db容器的配置中，我们如何映射容器的端口。在这里，我们将标准的MongoDB端口27017映射到4000。这意味着什么？在Docker运行时，其他容器可以使用27017访问数据库。这是MongoDB的传统端口，所以我们将坚持使用它。
- en: On our host operating system (OS), we have mapped the port to 4000\. That’s
    an arbitrary choice. We could have given it any number, including 27017\. I prefer
    not to give it the standard MongoDB port because that would conflict with an instance
    of MongoDB that we might have running on our host OS.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主机操作系统（OS）上，我们将端口映射到4000。这是一个任意的选择。我们可以给它任何数字，包括27017。我更喜欢不使用标准的MongoDB端口，因为这可能会与我们在主机OS上可能运行的MongoDB实例冲突。
- en: This is a good setup. Our application can interact with MongoDB via the standard
    port, but we can also use tools (as we’ll soon see) to directly query and edit
    our database from our development workstation. This is great for development as
    it gives us the ability to directly interact with and query our database.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个良好的设置。我们的应用程序可以通过标准端口与MongoDB交互，但我们可以使用工具（正如我们很快将看到的）直接从我们的开发工作站查询和编辑我们的数据库。这对于开发来说非常好，因为它使我们能够直接与数据库交互和查询。
- en: Updating the video-streaming microservice to use a database
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 更新视频流微服务以使用数据库
- en: We added environment variables to our Docker Compose file to connect our video-streaming
    microservice to its database. Now we need to update the code for this microservice
    to make use of these environment variables to establish the database connection.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的Docker Compose文件中添加了环境变量，以便将我们的视频流微服务连接到其数据库。现在我们需要更新这个微服务的代码，以便使用这些环境变量建立数据库连接。
- en: Listing 4.6 shows the updated code for the video-streaming microservice that
    allows it to query and read data from its database. Browse this code and notice
    how it differs from the previous incarnation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6显示了更新后的视频流微服务的代码，允许它查询和读取数据库中的数据。浏览此代码，注意它与之前的版本有何不同。
- en: Listing 4.6 Updating the microservice to use the database (chapter-4/example-3/video-streaming/src/index.js)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 更新微服务以使用数据库（chapter-4/example-3/video-streaming/src/index.js）
- en: '[PRE22]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Loads the MongoDB library so the microservice can connect to its database
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ① 加载MongoDB库，以便微服务可以连接到其数据库
- en: ② Specifies the database server to connect to
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ② 指定要连接的数据库服务器
- en: ③ Sets the name that this microservice uses for its database
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置此微服务用于其数据库的名称
- en: ④ Wraps the body of this microservice in a main function. This is the main entry
    point for this microservice. Can you tell that I’m a recovering C++ programmer?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将此微服务的主体包装在main函数中。这是此微服务的主要入口点。你能看出我是一名恢复中的C++程序员吗？
- en: ⑤ Connects to the database server
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 连接到数据库服务器
- en: ⑥ Retrieves the database that this microservice uses
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 获取此微服务使用的数据库
- en: ⑦ Retrieves the videos collection where we store metadata for each video
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 获取存储每个视频元数据的视频集合
- en: ⑧ Specifies the video ID via an HTTP query parameter. This is a MongoDB document
    ID.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 通过HTTP查询参数指定视频ID。这是一个MongoDB文档ID。
- en: ⑨ Queries the database to find a single video by the requested ID
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 通过请求的ID查询数据库以找到单个视频
- en: ⑩ The video was not found! Responds with an HTTP 404 error code
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 视频未找到！以HTTP 404错误代码响应
- en: ⑪ When forwarding the HTTP request to the video-storage microservice, maps the
    video’s ID to the video’s location
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 在将HTTP请求转发到视频存储微服务时，将视频的ID映射到视频的位置
- en: ⑫ Starts the microservice
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 启动微服务
- en: Listing 4.6 queries its database by video ID to retrieve the location of a video
    in storage. It then passes that location to the video-storage microservice to
    retrieve the video that is stored there. The rest of the code here should be familiar.
    We are forwarding HTTP requests for videos to the video-storage microservice.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6通过视频ID查询其数据库以检索存储中视频的位置。然后它将此位置传递给视频存储微服务以检索存储在那里的视频。这里的其他代码应该很熟悉。我们正在将视频的HTTP请求转发到视频存储微服务。
- en: This update to the video-streaming microservices has removed the hard-coded
    video path. Instead, we now refer to videos by their database ID. We could have
    fixed this without using IDs. We could simply refer to videos by their path in
    storage. But as you might suspect, that’s not a good idea. Let’s consider why.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对视频流微服务的这次更新移除了硬编码的视频路径。相反，我们现在通过数据库ID来引用视频。我们本可以不使用ID来解决这个问题。我们可以简单地通过存储中的路径来引用视频。但正如你可能怀疑的那样，这并不是一个好主意。让我们考虑一下原因。
- en: If we use *paths* to identify our videos, that makes it difficult to later move
    videos to a different location if in the future we decide we’d like to restructure
    our storage filesystem. The reason this is a problem is that various other databases
    and records will need to refer to our videos. This includes a metadata database
    for recording information about a video such as its genre. And we’ll later want
    a database for recording recommendations and views of each video.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用*路径*来标识我们的视频，那么在将来如果我们决定想要重新结构化我们的存储文件系统时，将视频移动到不同的位置就会变得困难。这个问题之所以存在，是因为各种其他数据库和记录都需要引用我们的视频。这包括一个元数据数据库，用于记录有关视频的信息，例如其类型。我们稍后还想要一个数据库来记录每个视频的推荐和观看情况。
- en: Each of these databases must have a way to refer to a video. If we only record
    the ID for each video, we give ourselves much more freedom to make independent
    changes to our storage without causing any nasty problems to ripple through our
    microservices and databases.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库都必须有一种方式来引用视频。如果我们只为每个视频记录ID，我们就有更多的自由来独立更改我们的存储，而不会导致任何糟糕的问题在我们的微服务和数据库中蔓延。
- en: This also makes it a bit simpler because the location of the video could potentially
    be a long path, and internal details like this are not something we’d usually
    like to let leak out of our application. Why? Exposing such details that hint
    at the internal structure can give a potential attacker an advantage. It’s better
    to keep a lid on this kind of information.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得事情变得稍微简单一些，因为视频的位置可能是一个很长的路径，而像这样的内部细节通常我们不希望泄露到我们的应用程序中。为什么？暴露这样的细节，暗示内部结构，可能会给潜在的攻击者带来优势。最好是将这类信息保密。
- en: Loading some test data into our database
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据库中加载一些测试数据
- en: We’ve added a database to our Docker Compose file and we’ve updated the video-streaming
    microservice to use that database. We are almost ready to test our changes!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Docker Compose文件中添加了一个数据库，并且我们已经更新了视频流微服务以使用该数据库。我们几乎准备好测试我们的更改了！
- en: In order to test our updated code, we must now load some test data into our
    database. Later, we’ll have a way for our users to upload their own videos and
    populate the database with relevant details, but we don’t yet have any way to
    do this in our application.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的更新代码，我们现在必须将一些测试数据加载到我们的数据库中。稍后，我们将为我们的用户提供上传他们自己的视频并使用相关细节填充数据库的方法，但我们的应用程序中还没有实现这一功能。
- en: We could test our code by replacing the database with some kind of simulated
    version of it. I’m talking about mocking the database. (We first talked about
    mocking earlier in this chapter.) Another way we can do this is to use a *database
    fixture*, which is a piece of test data that we load into our database purely
    for testing.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用某种模拟的数据库版本替换它来测试我们的代码。我指的是模拟数据库。（我们之前在本章中已经讨论过模拟。）我们还可以通过使用*数据库固定数据*来实现这一点，这是一种仅用于测试而加载到我们的数据库中的测试数据。
- en: There are various ways we can load some data in our database. The simplest way
    to do this is to use Robo 3T (formerly known as Robomongo). This is a fantastic
    UI tool for working with MongoDB. I use it all the time myself, which you already
    know if you read my first book, *Data Wrangling with JavaScript* (Manning, 2018).
    It’s available for Windows, MacOS, and Linux.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有各种方法可以将数据加载到我们的数据库中。最简单的方法是使用 Robo 3T（之前称为 Robomongo）。这是一个用于处理 MongoDB 的出色
    UI 工具。我自己一直在使用它，如果你读过我的第一本书《使用 JavaScript 数据整理》（Manning，2018），你应该已经知道了。它适用于 Windows、MacOS
    和 Linux。
- en: For download and install instructions for Robo 3T, see [https://robomongo.org/](https://robomongo.org/).
    Robo 3T allows you to view the collections and documents in your database. You
    can easily create databases, collections, and data records.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Robo 3T 的下载和安装说明，请参阅[https://robomongo.org/](https://robomongo.org/)。Robo
    3T 允许您查看数据库中的集合和文档。您可以轻松创建数据库、集合和数据记录。
- en: 'But before we can use Robo 3T to load example data into our database, we first
    must have our database up and running. We can do that by booting our application.
    If you haven’t yet done so, open a terminal and start your application:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能够使用 Robo 3T 将示例数据加载到我们的数据库之前，我们首先必须确保我们的数据库正在运行。我们可以通过启动我们的应用程序来实现这一点。如果你还没有这样做，请打开一个终端并启动你的应用程序：
- en: '[PRE23]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note You should run this command from the same directory as the updated Docker
    Compose file in listing 4.5\. You can find this file in the example-3 subdirectory
    of the chapter 4 code repository.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您应该从列表 4.5 中的更新 Docker Compose 文件相同的目录运行此命令。您可以在第 4 章代码存储库的 example-3 子目录中找到此文件。
- en: After starting our application, we now have a MongoDB database server running
    in a container. Because we mapped the standard MongoDB port 27017 to port 4000
    on our development workstation, we can now access the database from Robo 3T by
    connecting to localhost:4000.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 启动我们的应用程序后，我们现在有一个 MongoDB 数据库服务器在容器中运行。由于我们将标准 MongoDB 端口 27017 映射到我们的开发工作站上的端口
    4000，我们现在可以通过连接到 localhost:4000 来从 Robo 3T 访问数据库。
- en: Listing 4.7 shows the test data we’ll add to our database using Robo 3T. This
    is a single JSON document that is available under the example-3 directory and
    is suitable for a copy and paste insert using Robo 3T.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 显示了我们将使用 Robo 3T 添加到数据库中的测试数据。这是一个位于 example-3 目录下的单个 JSON 文档，适合使用 Robo
    3T 进行复制粘贴插入。
- en: To load this data using Robo 3T, open that application, create a new database
    called video-streaming, create a collection called videos, and then insert a document
    into that collection. For our purposes, use the content from this listing.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Robo 3T 加载数据，请打开该应用程序，创建一个名为 video-streaming 的新数据库，创建一个名为 videos 的集合，然后在该集合中插入一个文档。为了我们的目的，使用此列表中的内容。
- en: Listing 4.7 Loading a data record with Robo 3T (chapter-4/example-3/db-fixture/videos.json)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 使用 Robo 3T 加载数据记录（第 4 章/示例 3/db-fixture/videos.json）
- en: '[PRE24]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① The data record to load into the database
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ① 要加载到数据库中的数据记录
- en: ② Special syntax that sets the video’s ID as a MongoDB document’s ID
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将视频的 ID 设置为 MongoDB 文档的 ID 的特殊语法
- en: ③ Sets the location of the video
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置视频的位置
- en: We’ll come back to mocking and database fixtures in chapter 8\. For now, let’s
    look at how to test our application.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 8 章中回到模拟和数据库固定数据。现在，让我们看看如何测试我们的应用程序。
- en: Testing our updated application
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的更新应用程序
- en: 'At this stage, you can first test the microservice directly under Node.js if
    you like. It’s always a good idea to test your microservices independently before
    you integrate them. If you are putting this code together by yourself and testing
    directly under Node.js, don’t forget to install the mongodb driver package from
    npm:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果您愿意，可以先直接在Node.js下测试微服务。在将微服务集成之前独立测试它们总是一个好主意。如果您自己组合代码并在Node.js下直接测试，别忘了从npm安装mongodb驱动程序包：
- en: '[PRE25]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There’s no need for me to walk you through individual testing for each new microservice.
    In the interest of expediency, we’ll skip that and go straight to running our
    integrated code in the application under Docker Compose.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要逐个向您介绍每个新微服务的单独测试。为了提高效率，我们将跳过这一步骤，直接在Docker Compose中的应用中运行我们的集成代码。
- en: 'You should already have the application running from the last section. We needed
    it there for the database, so we could load our test data. If the application
    isn’t running, start it now:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经从上一节运行了应用程序。我们之所以需要它，是为了数据库，以便我们可以加载测试数据。如果应用程序没有运行，现在就启动它：
- en: '[PRE26]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now test the application in the usual way with a web browser. This time,
    though, we must provide the ID of the video we’d like to watch. The ID that we
    specified in our test data was a big long string of numbers, and that’s what we
    must now add to our URL to test the updated application. Open your browser and
    navigate to this link:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用通常的方式用网络浏览器测试应用程序。不过，这次我们必须提供我们想要观看的视频的ID。我们在测试数据中指定的ID是一长串数字，这就是我们现在必须添加到我们的URL中，以测试更新的应用程序。打开您的浏览器并导航到这个链接：
- en: http://localhost:4002/video?id=5d9e690ad76fe06a3d7ae416
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: http://localhost:4002/video?id=5d9e690ad76fe06a3d7ae416
- en: If you change the ID in the test data, you also need to update the ID in this
    URL. You should now see the test video playing. You must know this video very
    well by now!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改了测试数据中的ID，您也需要更新此URL中的ID。现在您应该已经非常熟悉这个视频了！
- en: 4.5.3 Adding a database server in production
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 在生产中添加数据库服务器
- en: So far we have only covered the case of adding a database server to the development
    version of our application. This works well enough for the moment because we haven’t
    yet learned how to deploy our application to production; that’s coming in chapters
    6 and 7\. What we can do now though is to briefly consider how we might deploy
    a database server for use by our production environment.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了将数据库服务器添加到我们应用程序的开发版本的情况。这目前足够好了，因为我们还没有学习如何将应用程序部署到生产环境；这将在第6章和第7章中介绍。不过，我们现在可以简要考虑我们可能如何为生产环境部署数据库服务器。
- en: Docker Compose makes it easy to add a database server to our application for
    development, but what about production? For production, I recommend using a database
    external to the Kubernetes cluster. This keeps the cluster stateless, which, as
    we discussed in section 4.4.5, means that we can tear down and rebuild our cluster
    at any time without risk to our data.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose使得将数据库服务器添加到我们的开发应用中变得容易，但对于生产环境呢？对于生产环境，我建议使用Kubernetes集群外部的数据库。这保持了集群无状态，正如我们在4.4.5节中讨论的，这意味着我们可以在不危及数据的情况下随时拆解和重建我们的集群。
- en: Once we have built our production Kubernetes cluster, we can easily deploy a
    MongoDB database in a way that is similar to what we’ve just done with Docker
    Compose. In fact, that’s what we will do in chapter 7 because that’s the easiest
    way for us to get our database server into production.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了生产Kubernetes集群，我们可以轻松地将MongoDB数据库部署到生产环境中，其方式与我们刚刚使用Docker Compose所做的方式类似。实际上，这就是我们在第7章将要做的，因为这是我们最容易将数据库服务器部署到生产环境中的方法。
- en: Beyond that though, I recommend that you keep your database separate to your
    cluster. You can run it on a separate VM, or you could use an external managed
    database. The reason for this is to keep the production cluster stateless.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我建议您将数据库与集群分开。您可以在单独的虚拟机上运行它，或者可以使用外部托管数据库。这样做的原因是为了保持生产集群无状态。
- en: Another advantage to using a managed database is security. The database provider
    takes care of maintenance for us; it takes care of protecting and backing up our
    data! If we work for a big company, our company will probably manage this in-house.
    But if we work for a small company or startup, we need all the help we can get.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用托管数据库的另一个优点是安全性。数据库提供商为我们处理维护工作；它负责保护并备份我们的数据！如果我们为一家大公司工作，我们的公司可能会内部管理这项工作。但如果我们为一家小公司或初创公司工作，我们需要尽可能多的帮助。
- en: 4.5.4 Database-per-microservice or database-per-application?
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.4 每个微服务或每个应用的数据库？
- en: At this point, we have only created a single database on our database server.
    But we are now set up to create many more additional databases.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在数据库服务器上创建了一个数据库。但现在我们已经准备好创建更多的数据库。
- en: 'You probably noticed that we named the database video-streaming to coincide
    with the microservice that uses it! This alludes to a rule we’ll be following
    throughout the book: *each microservice should have its own database.* We do this
    because we’d like to encapsulate our data within the microservice in the same
    way we’d encapsulate data within an object in object-oriented programming.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们给数据库命名为video-streaming，以与使用它的微服务相呼应！这暗示了我们将在整本书中遵循的一条规则：*每个微服务都应该有自己的数据库*。我们这样做是因为我们希望将数据封装在微服务中，就像在面向对象编程中将数据封装在对象中一样。
- en: Should we have one database per microservice or one per application? Definitely
    aim to have only one database per microservice. Your databases can be hosted on
    a single server, but make sure each individual microservice has its own database.
    If you share databases or make a database the integration point between microservices,
    you are inviting architectural and scalability problems.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为每个微服务或每个应用使用一个数据库吗？当然，目标是每个微服务只有一个数据库。您的数据库可以托管在单个服务器上，但请确保每个微服务都有自己的数据库。如果您共享数据库或将数据库作为微服务之间的集成点，您将邀请架构和可扩展性问题。
- en: We are restricting our data from all but the code that directly encapsulates
    it. This helps us to safely evolve the structure of our data over time because
    changes to it can be *hidden* within the microservice. This is another technique
    that, if we structure our REST APIs carefully, allows us to avoid propagating
    breakages and problems from one microservice to other parts of the application.
    Care applied when designing these REST APIs equates to better design for our application.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们限制了除直接封装它的代码之外的所有数据。这有助于我们随着时间的推移安全地演变数据结构，因为对它的更改可以*隐藏*在微服务中。这是另一种技术，如果我们精心设计REST
    API，就可以避免将中断和问题从微服务传播到应用程序的其他部分。在设计这些REST API时应用的谨慎等于我们应用程序的更好设计。
- en: You might think that sharing a database between microservices is a good way
    for them to share data. But using a database as an integration point or interface
    between microservices is a bad idea because it makes for a more fragile and less
    scalable application.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为在微服务之间共享数据库是它们共享数据的好方法。但将数据库用作微服务之间的集成点或接口是一个糟糕的想法，因为它会使应用程序更加脆弱且扩展性更差。
- en: At some point, you might find yourself wanting to share a database for performance
    or some other reason. After all, rules sometimes have to be broken to achieve
    a difficult goal. Carefully consider why you want to do this and if it’s truly
    necessary. Bringing such anti-patterns into our application is not something we
    should do blindly. We’ll talk more about databases and scalability in chapter
    11.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能会发现自己想要为了性能或其他原因而共享一个数据库。毕竟，有时为了实现困难的目标，规则有时不得不被打破。仔细考虑你为什么要这样做，以及这是否真正必要。将这种反模式引入我们的应用程序不是我们应该盲目做的事情。我们将在第11章中更多地讨论数据库和可扩展性。
- en: 4.5.5 What did we achieve?
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.5 我们取得了什么成果？
- en: 'We have added a database to our application. We now have two different methods
    at our disposal to manage our application’s data: we can store files in external
    cloud storage and we can store data in a database. We made good use of Docker
    Compose to run an application composed of multiple containers, and we upgraded
    our application to two microservices and a database.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向我们的应用程序添加了一个数据库。现在我们有两种不同的方法来管理应用程序的数据：我们可以在外部云存储中存储文件，也可以在数据库中存储数据。我们很好地使用了Docker
    Compose来运行由多个容器组成的应用程序，并将我们的应用程序升级为两个微服务和数据库。
- en: We have hidden our storage provider behind a video-storage microservice. Its
    job is to retrieve videos from storage. The abstraction we put in place allows
    us to easily change our storage provider later without much disruption to our
    application.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的存储提供商隐藏在视频存储微服务之后。它的任务是检索存储中的视频。我们实施的抽象允许我们轻松地在不影响应用程序的情况下更改存储提供商。
- en: We created a database server and added a database for use by our video-streaming
    microservice. We are following the rule that each microservice should have its
    own database, and in the future, we can easily add more databases to our server
    and continue to satisfy this rule.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个数据库服务器，并为我们的视频流微服务添加了一个数据库。我们遵循每个微服务应该有自己的数据库的规则，在未来，我们可以轻松地向我们的服务器添加更多数据库，并继续满足这一规则。
- en: We have also briefly seen how one microservice can communicate with another.
    The HTTP GET request received by the video-streaming microservice was forwarded
    to the video-storage microservice. This is the first and simplest form of communication
    that one microservice can use to request or delegate tasks to another. In the
    next chapter, we’ll more deeply explore this and other methods of communication
    between microservices. In addition, we’ll further extend our skills with Docker
    Compose and learn how to apply automated live reload to our entire microservices
    application.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要地看到了一个微服务如何与另一个微服务通信。视频流微服务接收到的 HTTP GET 请求被转发到视频存储微服务。这是第一个也是最简单的通信形式，一个微服务可以使用它来请求或委托任务给另一个微服务。在下一章中，我们将更深入地探讨这一点以及其他微服务之间的通信方法。此外，我们将进一步扩展我们的
    Docker Compose 技能，并学习如何将自动实时重新加载应用到我们的整个微服务应用程序中。
- en: 4.6 Docker Compose review
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 Docker Compose 回顾
- en: Throughout this chapter, we have seen increasing value from Docker Compose,
    using it to help manage the complexity of our growing application on our development
    workstation. Even when running just a single container, it was useful because
    it allowed us to capture and record configuration details. At that early stage,
    it magically turned two commands into one.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了 Docker Compose 的价值日益增加，我们使用它来帮助我们管理开发工作站上不断增长的应用程序的复杂性。即使只运行一个容器，它也是有用的，因为它允许我们捕获和记录配置细节。在那个早期阶段，它神奇地将两个命令合并成了一个。
- en: As we progressed through the chapter, we added two more containers to our application,
    and the value of Docker Compose became even clearer. We can add as many containers
    as we want to our application, we can record all their configuration details,
    and no matter how many containers we have, we can manage these all as an aggregated
    entity using single commands.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过本章的进展，我们向我们的应用程序中添加了两个额外的容器，Docker Compose 的价值变得更加明显。我们可以向我们的应用程序添加任意数量的容器，我们可以记录它们的全部配置细节，无论我们有多少个容器，我们都可以使用单个命令将它们作为一个聚合实体来管理。
- en: Figure 4.13 shows the simple lifecycle of our application running under Docker
    Compose. We use the `up` command to boot our application and all of its microservices.
    We use the `down` command to destroy our application and return our development
    workstation to a clean state.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 显示了在 Docker Compose 下运行的应用程序简单生命周期。我们使用 `up` 命令启动我们的应用程序及其所有微服务。我们使用
    `down` 命令销毁我们的应用程序，并将我们的开发工作站恢复到干净状态。
- en: '![](../Images/CH04_F13_Davis4.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F13_Davis4.png)'
- en: Figure 4.13 The lifecycle of your microservices application when using Docker
    Compose
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 使用 Docker Compose 时你的微服务应用程序的生命周期
- en: Before you finish this chapter, scan table 4.2 for a quick review of the Docker
    Compose commands you have learned. Put a bookmark on this page so you can return
    here quickly when you need help working with Docker Compose.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成本章之前，快速浏览表 4.2 以回顾你学到的 Docker Compose 命令。在这个页面上放置书签，以便当你需要帮助使用 Docker Compose
    时可以快速返回此处。
- en: Table 4.2 Review of Docker Compose commands
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 Docker Compose 命令回顾
- en: '| Command | Description |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `docker-compose` `--version` | Checks that Docker Compose is installed and
    prints the version number |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose` `--version` | 检查 Docker Compose 是否已安装并打印版本号 |'
- en: '| `docker-compose up --build` | Builds and instantiates an application composed
    of multiple containers as defined by the Docker Compose file (docker-compose .yaml)
    in the current working directory |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose up --build` | 在当前工作目录中构建并实例化由 Docker Compose 文件（docker-compose
    .yaml）定义的由多个容器组成的应用程序 |'
- en: '| `docker-compose ps` | Lists running containers that are part of the application
    specified by the Docker Compose file |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose ps` | 列出由 Docker Compose 文件指定的应用程序中的运行中的容器 |'
- en: '| `docker-compose stop` | Stops all containers in the application, but persists
    the stopped containers for inspection |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose stop` | 停止应用程序中的所有容器，但保留已停止的容器以供检查 |'
- en: '| `docker-compose down` | Stops and destroys the application, which leaves
    the development workstation in a clean state |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose down` | 停止并销毁应用程序，使开发工作站处于干净状态 |'
- en: 4.7 Continue your learning
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 继续你的学习
- en: 'This chapter skimmed the surface of two big topics. We added a new microservice
    to our application and connected it to our Azure Storage account. We also added
    a MongoDB database to our application. Both Azure and MongoDB are technologies
    that each have a world of their own, so now I’ll leave you with some references
    to dig deeper in these areas:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了两个重要主题。我们向应用程序添加了一个新的微服务，并将其连接到我们的 Azure 存储帐户。我们还向应用程序添加了一个 MongoDB 数据库。Azure
    和 MongoDB 都是各自拥有广阔世界的技术，因此现在我将给你一些参考资料，以便你更深入地了解这些领域：
- en: '*Azure in Action* by Brian H. Prince and Chris Hay (Manning, 2010)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Azure in Action》由 Brian H. Prince 和 Chris Hay 著（Manning, 2010）
- en: '*Learn Azure in a Month of Lunches* by Iain Foulds (Manning, 2018)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《一个月午餐时间学会 Azure》由 Iain Foulds 著（Manning, 2018）
- en: '*MongoDB in Action*, 2nd ed. by Kyle Banker, Peter Bakkum, et al (Manning,
    2016)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《MongoDB in Action》，第2版，由 Kyle Banker、Peter Bakkum 等人著（Manning, 2016）
- en: 'To learn more about Docker Compose, read the documentation online:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Docker Compose 的信息，请在线阅读文档：
- en: '[https://docs.docker.com/compose/](https://docs.docker.com/compose/)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/compose/](https://docs.docker.com/compose/)'
- en: '[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)'
- en: '[https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/)'
- en: In this chapter, we scaled up to multiple microservices using Docker Compose.
    We also added data management capability to our application. In the next chapter,
    we will learn in more detail how to make our microservices talk to each other.
    We’ll also improve our skills with Docker Compose and learn how to extend *live
    reload* so that it works across the entire application.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Docker Compose 将服务扩展到了多个微服务。我们还为我们的应用程序添加了数据管理功能。在下一章中，我们将更详细地学习如何使我们的微服务相互通信。我们还将提高使用
    Docker Compose 的技能，并学习如何扩展 *实时重新加载* 以使其在整个应用程序中工作。
- en: Summary
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We created a Docker Compose file that specifies the microservices in our application.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 Docker Compose 文件，该文件指定了应用程序中的微服务。
- en: You learned how to use the Docker Compose commands `up` and `down` to run your
    microservices application in development.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何使用 Docker Compose 命令 `up` 和 `down` 来运行你的微服务开发应用程序。
- en: You learned how to create an Azure storage account and upload videos to it.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何创建 Azure 存储帐户并将视频上传到其中。
- en: We added a second microservice to our application to retrieve videos from Azure
    storage.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向应用程序添加了第二个微服务，用于从 Azure 存储中检索视频。
- en: We modified our video-streaming microservice to forward requests to the new
    video-storage microservice.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们修改了我们的视频流微服务，使其将请求转发到新的视频存储微服务。
- en: We included a MongoDB database in our application to store information about
    videos.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在应用程序中包含了一个 MongoDB 数据库来存储有关视频的信息。
- en: We modified our video-streaming microservice to use the database to determine
    the location of the video.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们修改了我们的视频流微服务，使其使用数据库来确定视频的位置。
