- en: 10 Iterators and generators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 迭代器和生成器
- en: Have you ever noticed that many Python objects know how to behave inside of
    a `for` loop? That’s not an accident. Iteration is so useful, and so common, that
    Python makes it easy for an object to be iterable. All it has to do is implement
    a handful of behaviors, known collectively as *the iterator protocol*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到许多Python对象知道如何在`for`循环中表现？这不是偶然的。迭代非常有用，非常常见，因此Python使对象成为可迭代的变得很容易。它只需要实现一些行为，这些行为统称为*迭代器协议*。
- en: 'In this chapter, we’ll explore that protocol and how we can use it to create
    iterable objects. We’ll do this in three ways:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这个协议以及我们如何使用它来创建可迭代对象。我们将以三种方式完成：
- en: We’ll create our own iterators via Python classes, directly implementing the
    protocol ourselves.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过Python类创建自己的迭代器，直接实现协议。
- en: We’ll create *generators*, objects that implement the protocol, based on something
    that looks very similar to a function. Not surprisingly, these are known as *generator
    functions*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建*生成器*，这些对象实现了协议，基于看起来非常类似函数的东西。不出所料，这些被称为*生成器函数*。
- en: We’ll also create generators using *generator expressions*, which look quite
    a bit like list comprehensions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用*生成器表达式*创建生成器，它们看起来与列表推导式非常相似。
- en: Even newcomers to Python know that if you want to iterate over the characters
    in a string, you can write
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是Python的新手也知道，如果你想迭代字符串中的字符，你可以写
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Prints a, b, c, and d, each on a separate line
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在单独的一行上打印a, b, c和d
- en: 'This feels natural, and that’s the point. What if you just want to execute
    a chunk of code five times? Can you iterate over the integer `5`? Many newcomers
    to Python assume that the answer is yes and write the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这感觉很自然，这正是重点。如果你只想执行五次代码块，你能迭代整数`5`吗？许多Python新用户认为答案是肯定的，并编写了以下代码：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This doesn’t work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这不起作用。
- en: 'This code produces an error:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会产生错误：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From this, we can see that while strings, lists, and dicts are iterable, integers
    aren’t. They aren’t because they don’t implement the iterator protocol, which
    consists of three parts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，我们可以看到虽然字符串、列表和字典是可迭代的，但整数不是。这不是因为它们没有实现迭代器协议，该协议由三部分组成：
- en: The `__iter__` method, which returns an iterator
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回迭代器的`__iter__`方法
- en: The `__next__` method, which must be defined on the iterator
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在迭代器上定义的`__next__`方法
- en: The `StopIteration` exception, which the iterator raises to signal the end of
    the iterations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器引发的`StopIteration`异常，用于指示迭代结束
- en: Sequences (strings, lists, and tuples) are the most common form of iterables,
    but a large number of other objects, such as files and dicts, are also iterable.
    Best of all, when you define your own classes, you can make them iterable. All
    you have to do is make sure that the iterator protocol is in place on your object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 序列（字符串、列表和元组）是迭代对象最常见的形式，但许多其他对象，如文件和字典，也是可迭代的。最好的是，当你定义自己的类时，你可以使它们成为可迭代的。你只需要确保你的对象上实现了迭代协议。
- en: 'Given those three parts, we can now understand what a `for` loop really does:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这三部分，我们现在可以理解`for`循环真正做了什么：
- en: It asks an object whether it’s iterable using the `iter` built-in function ([http://
    mng.bz/jgja](http://mng.bz/jgja)). This function invokes the `__iter__` method
    on the target object. Whatever `__iter__` returns is called the *iterator*.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`iter`内置函数询问一个对象是否是可迭代的（[http:// mng.bz/jgja](http://mng.bz/jgja)）。这个函数会在目标对象上调用`__iter__`方法。`__iter__`返回的任何内容都被称为*迭代器*。
- en: If the object is iterable, then the `for` loop invokes the `next` built-in function
    on the iterator that was returned. That function invokes `__next__` on the iterator.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象是可迭代的，那么`for`循环会在返回的迭代器上调用`next`内置函数。该函数会在迭代器上调用`__next__`。
- en: If `__next__` raises a `Stopiteration` exception, then the loop exits.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`__next__`引发`Stopiteration`异常，则循环退出。
- en: 'This protocol explains a couple things that tend to puzzle newcomers to Python:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议解释了几个让Python新用户感到困惑的问题：
- en: Why don’t we need any indexes? In C-like languages, we need a numeric index
    for our iterations. That’s so the loop can go through each of the elements of
    the collection, one at a time. In those cases, the loop is responsible for keeping
    track of the current location. In Python, the object itself is responsible for
    producing the next item. The `for` loop doesn’t know whether we’re on the first
    item or the last one. But it does know when we’ve reached the end.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么不需要任何索引呢？在类似C的语言中，我们需要一个数字索引来进行迭代。这样循环就可以逐个遍历集合中的元素。在这些情况下，循环负责跟踪当前位置。在Python中，对象本身负责产生下一个项。`for`循环并不知道我们是在第一个项还是最后一个项。但它知道何时到达了末尾。
- en: How is it that different objects behave differently in `for` loops? After all,
    strings return characters, but dicts return keys, and files return lines. The
    answer is that the iterator object can return whatever it wants. So string iterators
    return characters, dict iterators return keys, and file iterators return the lines
    in a file.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不同的对象在`for`循环中的行为不同呢？毕竟，字符串返回字符，但字典返回键，文件返回行。答案是迭代器对象可以返回它想要的任何东西。所以字符串迭代器返回字符，字典迭代器返回键，文件迭代器返回文件中的行。
- en: 'If you’re defining a new class, you can make it iterable as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在定义一个新的类，你可以让它可迭代，如下所示：
- en: Define an `__iter__` method that takes only `self` as an argument and returns
    `self`. In other words, when Python asks your object, “Are you iterable?” the
    answer will be, “Yes, and I’m my own iterator.”
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个只接受`self`作为参数的`__iter__`方法。换句话说，当Python询问你的对象，“你是可迭代的吗？”时，答案将是，“是的，我自己就是迭代器。”
- en: Define a `__next__` method that takes only `self` as an argument. This method
    should either return a value or raise `StopIteration`. If it never returns `StopIteration`,
    then any `for` loop on this object will never exit.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个只接受`self`作为参数的`__next__`方法。此方法应返回一个值或引发`StopIteration`。如果它永远不会返回`StopIteration`，那么任何在这个对象上的`for`循环将永远不会退出。
- en: There are some more sophisticated ways to do things, including returning a separate,
    different object from `__iter__`. I demonstrate and discuss that later in this
    chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些更复杂的方法可以做到这一点，包括从`__iter__`返回一个不同的单独对象。我将在本章的后面演示和讨论这一点。
- en: 'Here’s a simple class that implements the protocol, wrapping itself around
    an iterable object but indicating when it reaches each stage of iteration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的类实现了这个协议，它围绕可迭代对象包装自身，但会指示迭代过程中的每个阶段：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Stores the data in an attribute, self.data
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据存储在一个属性中，self.data
- en: ❷ Creates an index attribute, keeping track of our current position
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个索引属性，跟踪我们的当前位置
- en: ❸ Our __iter__ does the simplest thing, returning self.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们的`__iter__`方法只做最简单的事情，返回`self`。
- en: ❹ Raises StopIteration if our self.index has reached the end
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果我们的self.index已经到达了末尾，则引发`StopIteration`
- en: ❺ Grabs the current value, but doesn’t return it yet
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取当前值，但尚未返回它
- en: ❻ Increments self.index
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 增加self.index
- en: 'If we execute this code, we’ll see the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这段代码，我们会看到以下输出：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This output walks us through the iteration process that we’ve already seen,
    starting with a call to `__iter__` and then repeated invocations of `__next__`.
    The loop exits when the iterator raises `StopIteration`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出引导我们通过我们之前看到的迭代过程，从调用`__iter__`开始，然后重复调用`__next__`。当迭代器引发`StopIteration`时，循环退出。
- en: 'Adding such methods to a class works when you’re creating your own new types.
    There are two other ways to create iterators in Python:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些方法添加到类中，当你创建自己的新类型时是有效的。在Python中还有两种创建迭代器的方法：
- en: You can use a generator expression, which we’ve already seen and used. As you
    might remember, generator expressions look and work similarly to list comprehensions,
    except that you use round parentheses rather than square brackets. But unlike
    list comprehensions, which return lists that might consume a great deal of memory,
    generator expressions return one element at a time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用生成器表达式，我们之前已经看到并使用过。你可能记得，生成器表达式看起来和工作方式与列表推导式相似，只是你使用圆括号而不是方括号。但与返回可能消耗大量内存的列表的列表推导式不同，生成器表达式一次返回一个元素。
- en: You can use a *generator function* --something that looks like a function, but
    when executed acts like an iterator; for example
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个*生成器函数*——看起来像函数，但在执行时像迭代器；例如
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we execute `foo`, the function’s body doesn’t execute. Rather, we get
    a generator object back--that is, something that implements the iterator protocol.
    We can thus put it in a `for` loop:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `foo` 时，函数体不会执行。相反，我们得到一个生成器对象——即实现了迭代器协议的东西。因此，我们可以将其放入一个 `for` 循环中：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This loop will print 1, 2, and 3\. Why? Because with each iteration (i.e., each
    time we call `next` on `g`), the function executes through the next `yield` statement,
    returns the value it got from `yield`, and then goes to sleep, waiting for the
    next iteration. When the generator function exits, it automatically raises `StopIteration`,
    thus ending the loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将打印 1, 2 和 3。为什么？因为随着每次迭代（即每次在 `g` 上调用 `next`），函数会执行到下一个 `yield` 语句，返回从
    `yield` 获得的价值，然后进入休眠状态，等待下一次迭代。当生成器函数退出时，它会自动引发 `StopIteration` 异常，从而结束循环。
- en: Iterators are pervasive in Python because they’re so convenient--and in many
    ways, they’ve been made convenient because they’re pervasive. In this chapter,
    you’ll practice writing all of these types of iterators and getting a feel for
    when each of these techniques should be used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器在 Python 中无处不在，因为它们非常方便——而且在许多方面，它们之所以方便，是因为它们无处不在。在本章中，你将练习编写所有这些类型的迭代器，并了解何时应该使用这些技术。
- en: iterable vs. iterator
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象与迭代器
- en: 'The two terms *iterable* and *iterator* are very similar but have different
    meanings:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 两个术语 *iterable* 和 *iterator* 非常相似，但含义不同：
- en: An iterable object can be put inside a `for` loop or list comprehension. For
    something to be iterable, it must implement the `__iter__` method. That method
    should return an iterator.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代对象可以放入 `for` 循环或列表推导式中。要成为可迭代对象，它必须实现 `__iter__` 方法。该方法应返回一个迭代器。
- en: An iterator is an object that implements the `__next__` method.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器是一个实现了 `__next__` 方法的对象。
- en: In many cases, an iterable is its own iterator. For example, file objects are
    their own iterators. But in many other cases, such as strings and lists, the iterable
    object returns a separate, different object as an iterator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可迭代对象本身就是它的迭代器。例如，文件对象就是它们自己的迭代器。但在许多其他情况下，例如字符串和列表，可迭代对象返回一个单独的、不同的对象作为迭代器。
- en: Table 10.1 What you need to know
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| `iter` | A built-in function that returns an object’s iterator | `iter(''abcd'')`
    | [http://mng.bz/jgja](http://mng.bz/jgja) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `iter` | 一个内置函数，返回对象的迭代器 | `iter(''abcd'')` | [http://mng.bz/jgja](http://mng.bz/jgja)
    |'
- en: '| `next` | A built-in function that requests the next object from an iterator
    | `next(i)` | [http://mng.bz/WPBg](http://mng.bz/WPBg) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `next` | 一个内置函数，从迭代器请求下一个对象 | `next(i)` | [http://mng.bz/WPBg](http://mng.bz/WPBg)
    |'
- en: '| `StopIteration` | An exception raised to indicate the end of a loop | `raise
    StopIteration` | [http://mng.bz/8p0K](http://mng.bz/8p0K) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `StopIteration` | 引发以指示循环结束的异常 | `raise StopIteration` | [http://mng.bz/8p0K](http://mng.bz/8p0K)
    |'
- en: '| `enumerate` | Helps us to number elements of iterables | `for i, c in enumerate(''ab''):``print(f''{i}:
    {c}'')` | [http://mng.bz/qM1K](http://mng.bz/qM1K) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `enumerate` | 帮助我们对可迭代对象的元素进行编号 | `for i, c in enumerate(''ab''):``print(f''{i}:
    {c}'')` | [http://mng.bz/qM1K](http://mng.bz/qM1K) |'
- en: '| Iterables | A category of data in Python | Iterables can be put in `for`
    loops or passed to many functions. | [http://mng.bz/EdDq](http://mng.bz/EdDq)
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 可迭代对象 | Python 中的数据类别 | 可迭代对象可以放入 `for` 循环或传递给许多函数。 | [http://mng.bz/EdDq](http://mng.bz/EdDq)
    |'
- en: '| `itertools` | A module with many classes for implementing iterables | `import
    itertools` | [http://mng.bz/NK4E](http://mng.bz/NK4E) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | 一个包含许多用于实现可迭代对象的类的模块 | `import itertools` | [http://mng.bz/NK4E](http://mng.bz/NK4E)
    |'
- en: '| `range` | Returns an iterable sequence of integers | `# every 3rd integer,
    from 10``# to (not including) 50``range(10, 50, 3)` | [http://mng.bz/B2DJ](http://mng.bz/B2DJ)
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `range` | 返回一个整数序列的可迭代对象 | `# 每 3 个整数，从 10``# 到 (不包括) 50``range(10, 50, 3)`
    | [http://mng.bz/B2DJ](http://mng.bz/B2DJ) |'
- en: '| `os.listdir` | Returns a list of files in a directory | `os.listdir(''/etc/'')`
    | [http://mng.bz/YreB](http://mng.bz/YreB) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `os.listdir` | 返回目录中的文件列表 | `os.listdir(''/etc/'')` | [http://mng.bz/YreB](http://mng.bz/YreB)
    |'
- en: '| `os.walk` | Iterates over the files in a directory | `os.walk(''/etc/'')`
    | [http://mng.bz/D2Ky](http://mng.bz/D2Ky) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `os.walk` | 遍历目录中的文件 | `os.walk(''/etc/'')` | [http://mng.bz/D2Ky](http://mng.bz/D2Ky)
    |'
- en: '| `yield` | Returns control to the loop temporarily, optionally returning a
    value | `yield 5` | [http://mng.bz/lG9j](http://mng.bz/lG9j) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `yield` | 临时将控制权返回给循环，可选地返回一个值 | `yield 5` | [http://mng.bz/lG9j](http://mng.bz/lG9j)
    |'
- en: '| `os.path.join` | Returns a string based on the path components | `os.path.join(''etc'',
    ''passwd'')` | [http://mng.bz/oPPM](http://mng.bz/oPPM) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.join` | 返回基于路径组件的字符串 | `os.path.join(''etc'', ''passwd'')` | [http://mng.bz/oPPM](http://mng.bz/oPPM)
    |'
- en: '| `time.perf_ counter` | Returns the number of elapsed seconds (as a float)
    since the program was started | `time.perf_counter()` | [http://mng.bz/B21v](http://mng.bz/B21v)
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `time.perf_counter` | 返回程序开始以来经过的秒数（作为浮点数）| `time.perf_counter()` | [http://mng.bz/B21v](http://mng.bz/B21v)
    |'
- en: '| `zip` | Takes `n` iterables as arguments and returns an iterator of tuples
    of length `n` | `# returns [(''a'', 10),``# (''b'', 20), (''c'', 30)]``zip(''abc'',``[10,
    20, 30])` | [http://mng.bz/Jyzv](http://mng.bz/Jyzv) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `zip` | 接受 `n` 个可迭代参数并返回长度为 `n` 的元组迭代器 | `# 返回 [(''a'', 10), (''b'', 20),
    (''c'', 30)]` `zip(''abc'', [10, 20, 30])` | [http://mng.bz/Jyzv](http://mng.bz/Jyzv)
    |'
- en: Exercise 46 ■ MyEnumerate
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 46 ■ MyEnumerate
- en: The built-in `enumerate` function allows us to get not just the elements of
    a sequence, but also the index of each element, as in
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `enumerate` 函数允许我们不仅获取序列的元素，还可以获取每个元素的索引，如下所示
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create your own `MyEnumerate` class, such that someone can use it instead of
    `enumerate`. It will need to return a tuple with each iteration, with the first
    element in the tuple being the index (starting with 0) and the second element
    being the current element from the underlying data structure. Trying to use `MyEnumerate`
    with a noniterable argument will result in an error.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的 `MyEnumerate` 类，这样别人就可以用它来代替 `enumerate`。它需要返回一个元组，每个迭代返回一个，元组的第一个元素是索引（从0开始），第二个元素是从底层数据结构中当前元素。尝试使用非可迭代参数与
    `MyEnumerate` 一起使用将导致错误。
- en: Working it out
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: In this exercise, we know that our `MyEnumerate` class will take a single iterable
    object. With each iteration, we’ll get back not one of that argument’s elements,
    but rather a two-element tuple.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们知道我们的 `MyEnumerate` 类将接受一个可迭代对象。每次迭代时，我们将返回一个由该参数的元素组成的两个元素的元组。
- en: This means that at the end of the day, we’re going to need a `__next__` method
    that will return a tuple. Moreover, it’ll need to keep track of the current index.
    Since `__next__`, like all methods and functions, loses its local scope between
    calls, we’ll need to store the current index in another place. Where? On the object
    itself, as an attribute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着最终我们可能需要一个 `__next__` 方法，该方法将返回一个元组。此外，它还需要跟踪当前索引。由于 `__next__`，像所有方法和函数一样，在调用之间会丢失其局部作用域，因此我们需要在另一个地方存储当前索引。在哪里？在对象本身上，作为一个属性。
- en: 'Thus, our `__init__` method will initialize two attributes: `self.data`, where
    we’ll store the object over which we’re iterating, and `self.index`, which will
    start with 0 and be incremented with each call to `__next__`. Our implementation
    of `__iter__` will be the standard one that we’ve seen so far, namely `return`
    `self`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的 `__init__` 方法将初始化两个属性：`self.data`，我们将在这里存储正在迭代的对象，以及 `self.index`，它将开始于0，并在每次调用
    `__next__` 时递增。我们的 `__iter__` 实现将是迄今为止我们看到的标准实现，即 `return` `self`。
- en: Finally `__next__` checks to see if `self.index` has gone past the length of
    `self.data`. If so, then we raise `StopIteration`, which causes the `for` loop
    to exit.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后 `__next__` 检查 `self.index` 是否已经超过了 `self.data` 的长度。如果是这样，那么我们将引发 `StopIteration`，这将导致
    `for` 循环退出。
- en: Multiclass iterators
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多类迭代器
- en: So far, we’ve seen that our `__iter__` method should consist of the line `return`
    `self` and no more. This is often a fine way to go. But you can get into trouble.
    For example, what happens if I use our `MyEnumerate` class in the following way?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们的 `__iter__` 方法应该只包含一行 `return` `self`，并且不再有其他内容。这通常是一个很好的方法。但你也可能遇到麻烦。例如，如果我以以下方式使用我们的
    `MyEnumerate` 类会发生什么？
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’ll see the following printout:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Why didn’t we get a second round of `a`, `b`, and `c`? Because we’re using the
    same iterator object each time. The first time around, its `self.index` goes through
    `0`, `1`, and `2`, and then stops. The second time around, `self.index` is already
    at `2`, which is greater than `len(self.data)`, and so it immediately exits from
    the loop.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们没有得到 `a`、`b` 和 `c` 的第二轮？因为我们每次都在使用相同的迭代器对象。第一次，它的 `self.index` 通过 `0`、`1`
    和 `2`，然后停止。第二次，`self.index` 已经在 `2`，这大于 `len(self.data)`，因此它立即退出循环。
- en: 'Our `return` `self` solution for `__iter__` is fine if that’s the behavior
    you want. But in many cases, we need something more sophisticated. The easiest
    solution is to use a second class--a helper class, if you will--which will be
    the iterator for our class. Many of Python’s built-in classes do this already,
    including strings, lists, tuples, and dicts. In such a case, we implement `__iter__`
    on the main class, but its job is to return a new instance of the helper class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `__iter__` 的 `return self` 解决方案，如果你想要的正是这种行为，那么它是可以的。但在许多情况下，我们需要更复杂一些的解决方案。最简单的解决方案是使用第二个类——如果你愿意，可以称之为辅助类——它将成为我们类的迭代器。Python
    的许多内置类已经这样做了，包括字符串、列表、元组和字典。在这种情况下，我们在主类上实现 `__iter__`，但它的任务是返回辅助类的新实例：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we define `MyEnumerateIterator`, a new and separate class, whose `__init__`
    looks much like the one we already defined for `MyIterator` and whose `__next__`
    is taken directly from `MyIterator`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义 `MyEnumerateIterator`，一个新且独立的类，其 `__init__` 看起来与我们之前为 `MyIterator` 定义的类似，而其
    `__next__` 则直接来自 `MyIterator`。
- en: 'There are two advantages to this design:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计有两个优点：
- en: As we’ve already seen, by separating the iterable from the iterator, we can
    put our iterable in as many `for` loops as we want, without having to worry that
    it’ll lose the iterations somehow.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，通过将可迭代与迭代器分离，我们可以将我们的可迭代对象放入尽可能多的 `for` 循环中，而无需担心它会以某种方式丢失迭代。
- en: The second advantage is organizational. If we want to make a class iterable,
    the iterations are a small part of the functionality. Thus, do we really want
    to clutter the class with a `__next__`, as well as attributes used only when iterating?
    By delegating such problems to a helper iterator class, we separate out the iterable
    aspects and allow each class to concentrate on its role.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个优点是组织上的。如果我们想使一个类可迭代，迭代只是功能的一小部分。因此，我们真的想在这个类中添加一个 `__next__` 以及仅当迭代时使用的属性吗？通过将这些问题委托给辅助迭代器类，我们分离出可迭代方面，并允许每个类专注于其角色。
- en: Many people think that we can solve the problem in a simpler way, simply by
    resetting `self.index` to `0` whenever `__iter__` is called. But that has some
    flaws too. It means that if we want to use the same iterable in two different
    loops simultaneously, they’ll interfere with one another. Such problems won’t
    occur with a helper class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为我们可以用更简单的方式解决这个问题，只需在每次调用 `__iter__` 时将 `self.index` 重置为 `0`。但这也有一些缺点。这意味着如果我们想在两个不同的循环中同时使用同一个可迭代对象，它们将相互干扰。使用辅助类就不会出现这样的问题。
- en: Solution
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Initializes MyEnumerate with an iterable argument, “data”
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用可迭代参数“data”初始化 MyEnumerate
- en: ❷ Stores “data” on the object as self.data
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将“data”存储在对象上作为 self.data
- en: ❸ Initializes self.index with 0
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 self.index 初始化为 0
- en: ❹ Because our object will be its own iterator, returns self
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 因为我们的对象将是它自己的迭代器，所以返回 self
- en: ❺ Are we at the end of the data? If so, then raises StopIteration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们是否到达了数据的末尾？如果是这样，那么抛出 StopIteration。
- en: ❻ Sets the value to be a tuple, with the index and value
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将值设置为包含索引和值的元组
- en: ❼ Increments the index
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 增加索引
- en: ❽ Returns the tuple
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 返回元组
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    JydQ](http://mng.bz/JydQ).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中尝试这个代码版本：[http://mng.bz/ JydQ](http://mng.bz/JydQ)。
- en: Note that the Python Tutor sometimes displays an error message when `StopIteration`
    is raised.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当抛出 `StopIteration` 时，Python Tutor 有时会显示错误消息。
- en: Screencast solution
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/ video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Now that you’ve created a simple iterator class, let’s dig in a bit deeper:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个简单的迭代器类，让我们更深入地探讨一下：
- en: Rewrite `MyEnumerate` such that it uses a helper class (`MyEnumerateIterator`),
    as described in the “Discussion” section. In the end, `MyEnumerate` will have
    the `__iter__` method that returns a new instance of `MyEnumerateIterator`, and
    the helper class will implement `__next__`. It should work the same way, but will
    also produce results if we iterate over it twice in a row.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新编写 `MyEnumerate`，使其使用辅助类（`MyEnumerateIterator`），如“讨论”部分所述。最终，`MyEnumerate`
    将有一个返回 `MyEnumerateIterator` 新实例的 `__iter__` 方法，辅助类将实现 `__next__`。它应该以相同的方式工作，但如果我们连续两次迭代它，它也会产生结果。
- en: The built-in `enumerate` method takes a second, optional argument--an integer,
    representing the first index that should be used. (This is particularly handy
    when numbering things for nontechnical users, who believe that things should be
    numbered starting with 1, rather than 0.)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的 `enumerate` 方法接受一个可选的第二个参数——一个整数，表示应该使用的第一个索引。（这对于为非技术用户编号特别有用，他们认为事物应该从
    1 开始编号，而不是从 0 开始。）
- en: Redefine `MyEnumerate` as a generator function, rather than as a class.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `MyEnumerate` 重新定义为生成器函数，而不是类。
- en: Exercise 47 ■ Circle
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 47 ■ 圆形
- en: From the examples we’ve seen so far, it might appear as though an iterable simply
    goes through the elements of whatever data it’s storing and then exits. But an
    iterator can do anything it wants, and can return whatever data it wants, until
    the point when it raises `StopIteration`. In this exercise, we see just how that
    works.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们迄今为止看到的示例中，可能会觉得可迭代对象只是遍历存储的数据元素，然后退出。但迭代器可以执行任何它想做的事情，并返回任何它想返回的数据，直到它引发
    `StopIteration` 为止。在这个练习中，我们看到了它是如何工作的。
- en: 'Define a class, `Circle`, that takes two arguments when defined: a sequence
    and a number. The idea is that the object will then return elements the defined
    number of times. If the number is greater than the number of elements, then the
    sequence repeats as necessary. You should define the class such that it uses a
    helper (which I call `CircleIterator`). Here’s an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 `Circle` 的类，当定义时接受两个参数：一个序列和一个数字。其理念是对象将返回定义的次数的元素。如果数字大于元素的数量，则序列将按需重复。你应该定义这个类，使其使用一个辅助器（我称之为
    `CircleIterator`）。以下是一个示例：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Prints a, b, c, a, b
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印 a, b, c, a, b
- en: Working it out
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算过程
- en: In many ways, our `Circle` class is a simple iterator, going through each of
    its values. But we might need to provide more outputs than we have inputs, circling
    around to the beginning one or more times.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，我们的 `Circle` 类是一个简单的迭代器，遍历其每个值。但我们可能需要提供比输入更多的输出，围绕开始一个或多个时间。
- en: The trick here is to use the modulus operator (`%`), which returns the integer
    remainder from a division operation. Modulus is often used in programs to ensure
    that we can wrap around as many times as we need.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是使用取模运算符（`%`），它从除法操作中返回整数余数。取模在程序中经常被用来确保我们可以按需绕行多次。
- en: In this case, we’re retrieving from `self.data`, as per usual. But the element
    won’t be `self.data[self.index]`, but rather `self.data[self.index` `%` `len(self.data)]`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们按照惯例从 `self.data` 中检索，但元素不会是 `self.data[self.index]`，而是 `self.data[self.index
    % len(self.data)]`。
- en: Since `self.index` will likely end up being bigger than `len(self.data)`, we
    can no longer use that as a test for whether we should raise `StopIteration`.
    Rather, we’ll need to have a separate attribute, `self.max_times`, which tells
    us how many iterations we should execute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `self.index` 很可能最终会大于 `len(self.data)`，我们不能再使用它作为是否引发 `StopIteration` 的测试。相反，我们需要有一个单独的属性
    `self.max_times`，它告诉我们应该执行多少次迭代。
- en: Once we have all of this in place, the implementation becomes fairly straightforward.
    Our `Circle` class remains with only `__init__` and `__iter__`, the latter of
    which returns a new instance of `CircleIterator`. Note that we have to pass both
    `self.data` and `self.max_times` to `CircleIterator`, and thus need to store them
    as attributes in our instance of `Circle`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们把这些都安排好，实现就变得相当直接。我们的 `Circle` 类仍然只有 `__init__` 和 `__iter__`，后者返回 `CircleIterator`
    的新实例。注意，我们必须将 `self.data` 和 `self.max_times` 传递给 `CircleIterator`，因此需要将它们作为属性存储在我们的
    `Circle` 实例中。
- en: Our iterator then uses the logic we described in its `__next__` method to return
    one element at a time, until we have `self.max_times` items.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的迭代器使用我们在其 `__next__` 方法中描述的逻辑一次返回一个元素，直到我们有 `self.max_times` 个项目。
- en: Another solution
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案
- en: 'Oliver Hach and Reik Thormann, who read an earlier edition of this book, shared
    an elegant solution with me:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 读了这本书早期版本的 Oliver Hach 和 Reik Thormann 与我分享了一个优雅的解决方案：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This version of `Circle` takes advantage of the fact that an iterating class
    may return **any** iterator, not just `self`, and not just an instance of a helper
    class. In this case, they returned a generator expression, which is an iterator
    by all standards.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `Circle` 利用了一个事实，即迭代类可以返回 **任何** 迭代器，而不仅仅是 `self`，也不仅仅是辅助类的实例。在这种情况下，它们返回了一个生成器表达式，这是一个符合所有标准的迭代器。
- en: The generator expression iterates a particular number of times, as determined
    by `self.max_times`, feeding that to `range`. We can then iterate over `range`,
    returning the appropriate element of `self.data` with each iteration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式会迭代特定的次数，由`self.max_times`确定，并将这个值传递给`range`。然后我们可以遍历`range`，每次迭代返回`self.data`的适当元素。
- en: In this way, we see there are multiple ways to answer the question, “What should
    `__iter__` return?” As long as it returns an iterator object, it doesn’t matter
    whether it’s an iterable `self`, an instance of a helper class, or a generator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们看到有多个方法来回答“`__iter__`应该返回什么？”这个问题。只要它返回一个迭代器对象，它是否是可迭代的`self`、辅助类的实例或生成器就无关紧要了。
- en: Solution
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解答
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    wBjg](http://mng.bz/wBjg).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中通过这个版本的工作代码：[http://mng.bz/wBjg](http://mng.bz/wBjg)。
- en: Screencast solution
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'I hope you’re starting to see the potential for iterators, and how they can
    be written in a variety of ways. Here are some additional exercises to get you
    thinking about what those ways could be:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们开始看到迭代器的潜力，以及它们可以以多种方式编写。这里有一些额外的练习，以帮助你们思考这些方式可能是什么：
- en: Rather than write a helper, you could also define iteration capabilities in
    a class and then inherit from it. Reimplement `Circle` as a class that inherits
    from `CircleIterator`, which implements `__init__` and `__next__`. Of course,
    the parent class will have to know what to return in each iteration; add a new
    attribute in `Circle`, `self.returns`, a list of attribute names that should be
    returned.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是编写一个辅助函数，你还可以在类中定义迭代能力，然后从它继承。将`Circle`重写为一个继承自`CircleIterator`的类，该类实现了`__init__`和`__next__`。当然，父类必须知道每次迭代应该返回什么；在`Circle`中添加一个新的属性`self.returns`，它是一个应返回的属性名称列表。
- en: Implement `Circle` as a generator function, rather than as a class.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Circle`实现为一个生成器函数，而不是一个类。
- en: Implement a `MyRange` class that returns an iterator that works the same as
    `range`, at least in `for` loops. (Modern `range` objects have a host of other
    capabilities, such as being subscriptable. Don’t worry about that.) The class,
    like `range`, should take one, two, or three integer arguments.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`MyRange`类，它返回一个与`range`相同的迭代器，至少在`for`循环中是这样。(`range`对象具有许多其他功能，例如可索引。不用担心这一点。)这个类，就像`range`一样，应该接受一个、两个或三个整数参数。
- en: Exercise 48 ■ All lines, all files
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 48 ■ 所有行，所有文件
- en: File objects, as we’ve seen, are iterators; when we put them in a `for` loop,
    each iteration returns the next line from the file. But what if we want to read
    through a number of files? It would be nice to have an iterator that goes through
    each of them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象，正如我们所见，是迭代器；当我们把它们放入`for`循环中时，每次迭代都会从文件中返回下一行。但如果我们想读取多个文件呢？有一个迭代器可以遍历它们中的每一个会很好。
- en: In this exercise, I’d like you to create just such an iterator, using a generator
    function. That is, this generator function will take a directory name as an argument.
    With each iteration, the generator should return a single string, representing
    one line from one file in that directory. Thus, if the directory contains five
    files, and each file contains 10 lines, the generator will return a total of 50
    strings--each of the lines from file 0, then each of the lines from file 1, then
    each of the lines from file 2, until it gets through all of the lines from file
    4.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我希望你创建这样一个迭代器，使用生成器函数。也就是说，这个生成器函数将接受一个目录名作为参数。每次迭代，生成器应该返回一个表示该目录中一个文件的一行的单个字符串。因此，如果目录包含五个文件，每个文件包含10行，生成器将返回总共50个字符串——首先是文件0的每一行，然后是文件1的每一行，然后是文件2的每一行，直到它通过文件4的所有行。
- en: If you encounter a file that can’t be opened--because it’s a directory, because
    you don’t have permission to read from it, and so on--you should just ignore the
    problem altogether.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个无法打开的文件——因为它是一个目录，因为你没有权限读取它，等等——你应该完全忽略这个问题。
- en: Working it out
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Let’s start the discussion by pointing out that if you really wanted to do this
    the right way, you would likely use the `os.walk` function ([http://mng.bz/D2Ky](http://mng.bz/D2Ky)),
    which goes through each of the files in a directory **and** then descends into
    its subdirectories. But we’ll ignore that and work to understand the `all_lines`
    generator function that I’ve created here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先指出，如果你真的想正确地做这件事，你可能会使用 `os.walk` 函数 ([http://mng.bz/D2Ky](http://mng.bz/D2Ky))，它会遍历目录中的每个文件，然后进入其子目录。但我们将忽略这一点，并努力理解我这里创建的
    `all_lines` 生成器函数。
- en: First, we run `os.listdir` on `path`. This returns a list of strings. It’s important
    to remember that `os.listdir` only returns the filenames, not the full path of
    the file. This means that we can’t just open the filename; we need to combine
    `path` with the filename.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 `path` 上运行 `os.listdir`。这返回一个字符串列表。重要的是要记住，`os.listdir` 只返回文件名，而不是文件的完整路径。这意味着我们无法直接打开文件名；我们需要将
    `path` 与文件名组合起来。
- en: We could use `str.join`, or even just `+` or an f-string. But there’s a better
    approach, namely `os.path.join` ([http://mng.bz/oPPM](http://mng.bz/oPPM)), which
    takes any number of parameters (thanks to the `*args`) and then joins them together
    with the value of `os.sep`, the directory-separation character for the current
    operating system. Thus, we don’t need to think about whether we’re on a Unix or
    Windows system; Python can do that work for us.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `str.join`，甚至只是 `+` 或 f-string。但有一个更好的方法，即使用 `os.path.join` ([http://mng.bz/oPPM](http://mng.bz/oPPM))，它接受任意数量的参数（多亏了
    `*args`），然后将它们与 `os.sep` 的值连接起来，这是当前操作系统的目录分隔符。因此，我们不需要考虑我们是在 Unix 还是 Windows
    系统上；Python 可以为我们完成这项工作。
- en: What if there’s a problem reading from the file? We then trap that with an `except`
    `OSError` clause, in which we have nothing more than `pass`. The `pass` keyword
    means that Python shouldn’t do anything; it’s needed because of the structure
    of Python’s syntax, which requires something indented following a colon. But we
    don’t want to do anything if an error occurs, so we use `pass`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取文件时出现问题怎么办？我们用 `except` `OSError` 子句来捕获它，其中我们没有任何操作除了 `pass`。`pass` 关键字意味着
    Python 不应该做任何事情；它之所以需要，是因为 Python 语法结构的需要，它要求在冒号之后有缩进的代码。但我们不希望在发生错误时做任何事情，所以使用
    `pass`。
- en: And if there’s no problem? Then we simply return the current line using `yield`.
    Immediately after the `yield`, the function goes to sleep, waiting for the next
    time a `for` loop invokes `next` on it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有问题？那么我们就简单地使用 `yield` 返回当前行。在 `yield` 之后，函数进入休眠状态，等待下一次 `for` 循环调用它的 `next`
    方法。
- en: '*Note* Using `except` without specifying which exception you might get is generally
    frowned upon, all the more so if you pair it with `pass`. If you do this in production
    code, you’ll undoubtedly encounter problems at some point, and because you haven’t
    trapped specific exceptions or logged the errors, you’ll have trouble debugging
    the problem as a result. For a good (if slightly old) introduction to Python exceptions
    and how they should be used, see: [http:// mng.bz/VgBX](http://mng.bz/VgBX).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 在不指定可能遇到的异常的情况下使用 `except` 通常是不被推荐的，尤其是如果你将它与 `pass` 配对。如果你在生产代码中这样做，你无疑会在某个时候遇到问题，因为你没有捕获特定的异常或记录错误，因此你将难以调试问题。有关
    Python 异常及其使用的良好（如果稍微有些过时）介绍，请参阅：[http:// mng.bz/VgBX](http://mng.bz/VgBX)。'
- en: Solution
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Gets a list of files in path
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取路径中的文件列表
- en: ❷ Uses os.path.join to create a full filename that we’ll open
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 `os.path.join` 创建一个我们将要打开的完整文件名
- en: ❸ Opens and iterates over each line in full_filename
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打开并遍历 full_filename 中的每一行
- en: ❹ Returns the line using yield, needed in iterators
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 `yield` 返回行，这在迭代器中是必需的
- en: ❺ Ignores file-related problems silently
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 静默忽略与文件相关的问题
- en: The Python Tutor site doesn’t work with files, so there’s no link to it. But
    you could see all of the lines from all files in the /etc/ directory on your computer
    with
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Python Tutor 网站不支持文件，因此没有链接。但你可以使用以下命令查看你计算机上 /etc/ 目录中所有文件的每一行：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Screencast solution
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'If something you want to do as an iterator doesn’t align with an existing class
    but can be defined as a function, then a generator function will likely be a good
    way to implement it. Generator functions are particularly useful in taking potentially
    large quantities of data, breaking them down, and returning their output at a
    pace that won’t overwhelm the system. Here are some other problems you can solve
    using generator functions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想作为一个迭代器执行的操作与现有类不匹配，但可以定义为一个函数，那么生成器函数可能是实现它的好方法。生成器函数在处理可能的大量数据时特别有用，可以将数据分解，并以不会使系统过载的速度返回输出。以下是一些你可以使用生成器函数解决的问题：
- en: 'Modify `all_lines` such that it doesn’t return a string with each iteration,
    but rather a tuple. The tuple should contain four elements: the name of the file,
    the current number of the file (from all those returned by `os.listdir`), the
    line number within the current file, and the current line.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `all_lines`，使其在每次迭代时不返回一个字符串，而是一个元组。该元组应包含四个元素：文件的名称、文件的当前编号（来自 `os.listdir`
    返回的所有文件）、当前文件内的行号以及当前行。
- en: The current version of `all_lines` returns all of the lines from the first file,
    then all of the lines from the second file, and so forth. Modify the function
    such that it returns the first line from each file, and then the second line from
    each file, until all lines from all files are returned. When you finish printing
    lines from shorter files, ignore those files while continuing to display lines
    from the longer files.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all_lines` 的当前版本返回第一个文件的所有行，然后是第二个文件的所有行，依此类推。修改该函数，使其返回每个文件的第一行，然后是每个文件的第二行，直到返回所有文件的所有行。当你完成打印较短的文件中的行后，忽略这些文件，同时继续显示较长的文件中的行。'
- en: Modify `all_lines` such that it takes two arguments--a directory name, and a
    string. Only those lines containing the string (i.e., for which you can say `s`
    `in` `line`) should be returned. If you know how to work with regular expressions
    and Python’s `re` module, then you could even make the match conditional on a
    regular expression.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `all_lines`，使其接受两个参数——一个目录名称和一个字符串。只有包含该字符串的行（即，对于你可以说出 `s in line` 的行）应该被返回。如果你知道如何使用正则表达式和
    Python 的 `re` 模块，那么你甚至可以基于正则表达式使匹配条件化。
- en: '*Note* In generator functions, we don’t need to explicitly raise `StopIteration`.
    That happens automatically when the generator reaches the end of the function.
    Indeed, raising `StopIteration` from within the generator is something that you
    should **not** do. If you want to exit from the function prematurely, it’s best
    to use a `return` statement. It’s not an error to use `return` with a value (e.g.,
    `return` `5`) from a generator function, but the value will be ignored. In a generator
    function, then, `yield` indicates that you want to keep the generator going and
    return a value for the current iteration, while `return` indicates that you want
    to exit completely.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 在生成器函数中，我们不需要显式地引发 `StopIteration`。当生成器到达函数的末尾时，这会自动发生。实际上，从生成器内部引发 `StopIteration`
    是你应该**不**做的事情。如果你想提前退出函数，最好使用 `return` 语句。从生成器函数中使用 `return` 并带有一个值（例如，`return
    5`）不是错误，但该值将被忽略。在生成器函数中，`yield` 表示你想要保持生成器继续运行并返回当前迭代的值，而 `return` 表示你想要完全退出。'
- en: Exercise 49 ■ Elapsed since
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 49 ■ 已过时间
- en: Sometimes, the point of an iterator is not to change existing data, but rather
    to provide data in addition to what we previously received. Moreover, a generator
    doesn’t necessarily provide all of its values in immediate succession; it can
    be queried on occasion, whenever we need an additional value. Indeed, the fact
    that generators retain all of their state while sleeping between iterations means
    that they can just hang around, as it were, waiting until needed to provide the
    next value.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，迭代器的目的不是改变现有数据，而是提供比我们之前接收到的更多的数据。此外，生成器不一定要立即连续提供所有值；它可以在需要额外值时偶尔查询。事实上，生成器在迭代之间保持所有状态的事实意味着它们可以像挂在那里一样等待，直到需要时才提供下一个值。
- en: In this exercise, write a generator function whose argument must be iterable.
    With each iteration, the generator will return a two-element tuple. The first
    element in the tuple will be an integer indicating how many seconds have passed
    since the previous iteration. The tuple’s second element will be the next item
    from the passed argument.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，编写一个生成器函数，其参数必须是可迭代的。在每次迭代中，生成器将返回一个包含两个元素的元组。元组的第一个元素是一个整数，表示自上次迭代以来经过的秒数。元组的第二个元素是传递参数的下一个项目。
- en: Note that the timing should be relative to the previous iteration, not when
    the generator was first created or invoked. Thus the timing number in the first
    iteration will be 0.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，计时应该相对于上次迭代，而不是生成器首次创建或调用时。因此，第一次迭代的计时数字将是0。
- en: You can use `time.perf_counter`, which returns the number of seconds since the
    program was started. You could use `time.time`, but `perf_counter` is considered
    more reliable for such purposes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`time.perf_counter`，它返回程序开始以来的秒数。你也可以使用`time.time`，但`perf_counter`在这种情况下被认为更可靠。
- en: Working it out
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution’s generator function takes a single piece of data and iterates
    over it. However, it returns a two-element tuple for each item it returns, in
    which the first element is the time since the previous iteration ran.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的生成器函数接受单个数据项并遍历它。然而，它为每个返回的项目返回一个包含两个元素的元组，其中第一个元素是自上次迭代运行以来经过的时间。
- en: For this to work, we need to always know when the previous iteration was executed.
    Thus, we always calculate and set `last_time` before we `yield` the current values
    of `delta` and `item`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要始终知道上次迭代是在何时执行的。因此，我们在`yield`当前`delta`和`item`的当前值之前，始终计算并设置`last_time`。
- en: However, we need to have a value for `delta` the first time we get a result
    back. This should be `0`. To get around this, we set `last_time` to `None` at
    the top of the function. Then, with each iteration, we calculate `delta` to be
    the difference between `current _time` and `last_time` `or` `current_time`. If
    `last_time` is `None`, then we’ll get the value of `current_time`. This should
    only occur once; after the first iteration, `last_time` will never be zero.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们第一次得到结果时，我们需要一个`delta`的值。这个值应该是`0`。为了解决这个问题，我们在函数顶部将`last_time`设置为`None`。然后，在每次迭代中，我们计算`delta`为`current_time`和`last_time`之间的差值，或者`current_time`。如果`last_time`是`None`，那么我们将得到`current_time`的值。这种情况只会发生一次；在第一次迭代之后，`last_time`将永远不会是零。
- en: 'Normally, invoking a function multiple times means that the local variables
    are reset with each invocation. However, a generator function works differently:
    it’s only invoked once, and thus has a single stack frame. This means that the
    local variables, including parameters, retain their values across calls. We can
    thus set such values as `last_time` and use them in future iterations.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，多次调用函数意味着每次调用都会重置局部变量。然而，生成器函数的工作方式不同：它只被调用一次，因此只有一个调用栈帧。这意味着局部变量，包括参数，在调用之间保持其值。因此，我们可以将这些值设置为`last_time`并在未来的迭代中使用它们。
- en: Solution
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Initializes last_time with None
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将`last_time`初始化为`None`
- en: ❷ Gets the current time
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取当前时间
- en: ❸ Calculates the delta between the last time and now
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算上一次和现在之间的`delta`
- en: ❹ Returns a two-element tuple
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回一个包含两个元素的元组
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    qMjz](http://mng.bz/qMjz).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中尝试这个代码版本，[http://mng.bz/qMjz](http://mng.bz/qMjz).
- en: Screencast solution
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout).
- en: Beyond the exercise
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'In this exercise, we saw how we can combine user-supplied data with additional
    information from the system. Here are some more exercises you can try to get additional
    practice writing such generator functions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何将用户提供的数据与系统提供的附加信息相结合。以下是一些你可以尝试的更多练习，以获得编写此类生成器函数的额外练习：
- en: The existing function `elapsed_since` reported how much time passed between
    iterations. Now write a generator function that takes two arguments--a piece of
    data and a minimum amount of time that must elapse between iterations. If the
    next element is requested via the iterator protocol (i.e., `next`), and the time
    elapsed since the previous iteration is greater than the user-defined minimum,
    then the value is returned. If not, then the generator uses `time.sleep` to wait
    until the appropriate amount of time has elapsed.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的函数 `elapsed_since` 报告了迭代之间的时间差。现在编写一个生成器函数，它接受两个参数--一个数据块和迭代之间必须经过的最小时间量。如果通过迭代器协议（即
    `next`）请求下一个元素，并且自上次迭代以来经过的时间大于用户定义的最小值，则返回该值。如果不是，则生成器使用 `time.sleep` 等待直到经过适当的时间。
- en: 'Write a generator function, `file_usage_timing`, that takes a single directory
    name as an argument. With each iteration, we get a tuple containing not just the
    current filename, but also the three reports that we can get about a file’s most
    recent usage: its access time (`atime`), modification time (`mtime`), and creation
    time (`ctime`). Hint: all are available via the `os.stat` function.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个生成器函数 `file_usage_timing`，它接受一个目录名作为参数。在每次迭代中，我们得到一个包含当前文件名以及关于文件最近使用情况的三个报告的元组：其访问时间（`atime`）、修改时间（`mtime`）和创建时间（`ctime`）。提示：所有这些都可以通过
    `os.stat` 函数获得。
- en: 'Write a generator function that takes two elements: an iterable and a function.
    With each iteration, the function is invoked on the current element. If the result
    is `True`, then the element is returned as is. Otherwise, the next element is
    tested, until the function returns `True`. Alternative: implement this as a regular
    function that returns a generator expression.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个生成器函数，它接受两个元素：一个可迭代对象和一个函数。在每次迭代中，该函数会在当前元素上调用。如果结果是 `True`，则返回该元素。否则，将测试下一个元素，直到函数返回
    `True`。另一种方法：将其实现为一个返回生成器表达式的常规函数。
- en: Exercise 50 ■ MyChain
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 50 ■ MyChain
- en: As you can imagine, iterator patterns tend to repeat themselves. For this reason,
    Python comes with the `itertools` module ([http://mng.bz/NK4E](http://mng.bz/NK4E)),
    which makes it easy to create many types of iterators. The classes in `itertools`
    have been optimized and debugged across many projects, and often include features
    that you might not have considered. It’s definitely worth keeping this module
    in the back of your mind for your own projects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，迭代模式往往会重复出现。因此，Python 提供了 `itertools` 模块 ([http://mng.bz/NK4E](http://mng.bz/NK4E))，这使得创建许多类型的迭代器变得容易。`itertools`
    中的类已在许多项目中进行了优化和调试，并且通常包括你可能没有考虑到的功能。它绝对值得在你的项目中记住这个模块。
- en: One of my favorite objects in `itertools` is called `chain`. It takes any number
    of iterables as arguments and then returns each of their elements, one at a time,
    as if they were all part of a single iterable; for example
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `itertools` 中，我最喜欢的对象之一叫做 `chain`。它接受任意数量的可迭代对象作为参数，然后逐个返回它们的元素，就像它们都是单个可迭代对象的一部分；例如
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code would print:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会打印：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The final `'a'` and `'b'` come from the dict we passed, since iterating over
    a dict returns its keys.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `'a'` 和 `'b'` 来自我们传递的字典，因为迭代字典会返回其键。
- en: 'While `itertools.chain` is convenient and clever, it’s not that hard to implement.
    For this exercise, that’s precisely what you should do: implement a generator
    function called `mychain` that takes any number of arguments, each of which is
    an iterable. With each iteration, it should return the next element from the current
    iterable, or the first element from the subsequent iterable--unless you’re at
    the end, in which case it should exit.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `itertools.chain` 很方便且巧妙，但实现起来并不难。对于这个练习，这正是你应该做的：实现一个名为 `mychain` 的生成器函数，它接受任意数量的参数，每个参数都是一个可迭代对象。在每次迭代中，它应该从当前可迭代对象返回下一个元素，或者从后续可迭代对象返回第一个元素--除非你到达了末尾，在这种情况下，它应该退出。
- en: Working it out
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: It’s true that you could create this as a Python class that implements the iterator
    protocol, with `__iter__` and `__call__`. But, as you can see, the code is so
    much simpler, easier to understand, and more elegant when we use a generator function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以创建一个实现迭代器协议的 Python 类，其中包含 `__iter__` 和 `__call__`，但正如你所看到的，当我们使用生成器函数时，代码要简单得多，更容易理解，也更优雅。
- en: Our function takes `*args` as a parameter, meaning that `args` will be a tuple
    when our function executes. Because it’s a tuple, we can iterate over its elements,
    no matter how many there might be.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能接受`*args`作为参数，这意味着当我们的函数执行时，`args`将是一个元组。因为它是元组，所以无论有多少元素，我们都可以迭代其元素。
- en: We’ve stated that each argument passed to `mychain` should be iterable, which
    means that we should be able to iterate over those arguments as well. Then, in
    the inner `for` loop, we simply `yield` the value of the current line. This returns
    the current value to the caller, but also holds onto the current place in the
    generator function. Thus, the next time we invoke `__next__` on our iteration
    object, we’ll get the next item in the series.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明，传递给`mychain`的每个参数都应该可迭代，这意味着我们应该能够迭代这些参数。然后，在内层`for`循环中，我们简单地`yield`当前行的值。这返回当前值给调用者，但同时也保留生成器函数中的当前位置。因此，当我们对迭代对象上的迭代器调用`__next__`时，我们将得到序列中的下一个项目。
- en: Solution
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ args is a tuple of iterables
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `args`是可迭代的元组
- en: ❷ Loops over each iterable
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历每个可迭代对象
- en: ❸ Loops over each element of each iterable, and yield’s it
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历每个可迭代对象的每个元素，并产生它
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    7Xv4](http://mng.bz/7Xv4).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中查看这个代码版本的实现：[http://mng.bz/ 7Xv4](http://mng.bz/7Xv4)。
- en: Screencast solution
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'In this exercise, we saw how we can better understand some built-in functionality
    by reimplementing it ourselves. In particular, we saw how we can create our own
    version of `itertools.chain` as a generator function. Here are some additional
    challenges you can solve using generator functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何通过自己重新实现来更好地理解一些内置功能。特别是，我们看到了如何创建自己的`itertools.chain`版本作为生成器函数。以下是一些你可以使用生成器函数解决的额外挑战：
- en: The built-in `zip` function returns an iterator that, given iterable arguments,
    returns tuples taken from those arguments’ elements. The first iteration will
    return a tuple from the arguments’ index 0, the second iteration will return a
    tuple from the arguments’ index 1, and so on, stopping when the shortest of the
    arguments ends. Thus `zip('abc',` `[10,` `20,` `30])` returns the iterator equivalent
    of `[('a',` `10),` `('b',` `20),` `('c',` `30)]`. Write a generator function that
    reimplements `zip` in this way.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的`zip`函数返回一个迭代器，给定可迭代参数，返回从这些参数的元素中取出的元组。第一次迭代将返回参数索引0的元组，第二次迭代将返回参数索引1的元组，依此类推，直到最短的参数结束。因此`zip('abc',
    [10, 20, 30])`返回的迭代器等价于`[('a', 10), ('b', 20), ('c', 30)]`。编写一个生成器函数以这种方式重新实现`zip`。
- en: Reimplement the `all_lines` function from exercise 49 using `mychain`.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`mychain`重新实现练习49中的`all_lines`函数。
- en: In the “Beyond the exercise” section for exercise 48, you implemented a `MyRange`
    class, which mimics the built-in `range` class. Now do the same thing, but using
    a generator expression.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在练习48的“超越练习”部分，你实现了`MyRange`类，该类模仿了内置的`range`类。现在以生成器表达式的方式做同样的事情。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at the iterator protocol and how we can both implement
    and use it in a variety of ways. While we like to say that there’s only one way
    to do things in Python, you can see that there are at least three different ways
    to create an iterator:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了迭代器协议以及我们如何以各种方式实现和使用它。虽然我们喜欢说Python中只有一种做事的方式，但你可以看到至少有三种不同的方式来创建迭代器：
- en: Add the appropriate methods to a class
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向类中添加适当的方法
- en: Write a generator function
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写生成器函数
- en: Use a generator expression
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器表达式
- en: The iterator protocol is both common and useful in Python. By now, it’s a bit
    of a chicken-and-egg situation--is it worth adding the iterator protocol to your
    objects because so many programs expect objects to support it? Or do programs
    use the iterator protocol because so many programs support it? The answer might
    not be clear, but the implications are. If you have a collection of data, or something
    that can be interpreted as a collection, then it’s worth adding the appropriate
    methods to your class. And if you’re not creating a new class, you can still take
    advantage of iterables with generator functions and expressions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代协议在 Python 中既常见又实用。到目前为止，这有点像鸡生蛋、蛋生鸡的情况——是否值得将迭代协议添加到你的对象中，因为许多程序都期望对象支持它？或者是因为许多程序支持它，所以程序才使用迭代协议？答案可能并不明确，但其影响是明显的。如果你有一组数据，或者可以被解释为集合的东西，那么在你的类中添加适当的方法是值得的。如果你没有创建新的类，你仍然可以通过生成器函数和表达式利用可迭代对象。
- en: 'After doing the exercises in this chapter, I hope that you can see how to do
    the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章的练习后，我希望你能看到以下内容：
- en: Add the iterator protocol to a class you’ve written
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将迭代协议添加到你所编写的类中
- en: Add the iterator protocol to a class via a helper iterator class
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过辅助迭代器类将迭代协议添加到类中
- en: Write generator functions that filter, modify, and add to iterators that you
    would otherwise have created or used
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写生成器函数，以过滤、修改和添加你本应创建或使用的迭代器
- en: Use generator expressions for greater efficiency than list comprehensions
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器表达式比列表推导式更高效
- en: Conclusion
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Congratulations! You’ve reached the end of the book, which (if you’re not peeking
    ahead) means that you’ve finished a large number of Python exercises. As a result,
    your Python has improved in a few ways.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经到达了本书的结尾，这意味着（如果你没有提前翻看）你已经完成了一大堆 Python 练习。因此，你的 Python 技能在几个方面得到了提升。
- en: First, you’re now more familiar with Python syntax and techniques. Like someone
    learning a foreign language, you might previously have had the vocabulary and
    grammar structures in place, but now you can express yourself more fluently. You
    don’t need to think quite as long when deciding what word to choose. You won’t
    be using constructs that work but are considered un-Pythonic.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你现在对 Python 语法和技术更加熟悉。就像学习外语的人一样，你可能之前已经有了词汇和语法结构，但现在你可以更流畅地表达自己。在决定选择哪个词时，你不需要想得那么久。你不会使用那些虽然有效但被认为不符合
    Python 风格的构造。
- en: Second, you’ve seen enough different problems, and used Python to solve them,
    that you now know what to do when you encounter new problems. You’ll know what
    questions to ask, how to break the problems down into their elements, and what
    Python constructs will best map to your solutions. You’ll be able to compare the
    trade-offs between different options and then integrate the best ones into your
    code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你已经遇到过足够多不同的问题，并使用 Python 解决了它们，现在你知道在遇到新问题时该做什么。你会知道该问什么问题，如何将问题分解为其元素，以及哪些
    Python 构造最适合映射到你的解决方案。你将能够比较不同选项之间的权衡，并将最好的选项整合到你的代码中。
- en: Third, you’re now more familiar with Python’s way of doing things and the vocabulary
    that the language uses to describe them. This means that the Python documentation,
    as well as the community’s ecosystem of blogs, tutorials, articles, and videos,
    will be more understandable to you. The descriptions will make more sense, and
    the examples will be more powerful.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你现在对 Python 的做事方式和语言描述它们的词汇更加熟悉。这意味着 Python 文档以及社区生态系统中的博客、教程、文章和视频将对你来说更容易理解。描述将更有意义，示例将更强大。
- en: In short, being more fluent in Python means being able to write better code
    in less time, while keeping it readable and Pythonic. It also means being able
    to learn more as you continue on your path as a developer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，更加熟练地掌握 Python 意味着能够在更短的时间内编写出更好的代码，同时保持其可读性和 Python 风格。这也意味着你在作为开发者的道路上继续前进时，能够学到更多。
- en: I wish you the best of success in your Python career and hope that you’ll continue
    to find ways to practice your Python as you move forward.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我祝愿你在 Python 生涯中取得最佳成就，并希望你在前进的过程中继续找到练习 Python 的方法。
