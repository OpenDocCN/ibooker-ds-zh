- en: 16 Serverless, GraalVM, and Knative
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 无服务器、GraalVM 和 Knative
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Producing native images with Spring Native and GraalVM
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Native 和 GraalVM 生成原生镜像
- en: Building serverless applications with Spring Cloud Function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Function 构建无服务器应用
- en: Deploying serverless applications with Knative and Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Knative 和 Kubernetes 部署无服务器应用
- en: In the previous chapter, you completed a long journey from development to production.
    You’ve built cloud native applications using Spring and deployed them on a Kubernetes
    cluster in a public cloud. This final chapter aims to provide you with some additional
    tools to get even more out of your cloud native applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你完成了一次从开发到生产的漫长旅程。你使用 Spring 构建了云原生应用，并将它们部署在公共云中的 Kubernetes 集群上。本章的目的是为你提供一些额外的工具，以便从你的云原生应用中获得更多。
- en: One significant benefit of cloud infrastructures is that you can increase or
    reduce resources on demand and pay only for what you use. Java applications have
    traditionally been very resource-intensive, resulting in higher CPU and memory
    consumption than other stacks like Go. Not anymore. Using GraalVM and Spring Native,
    you can compile your Spring Boot applications to native executables, which are
    more performant and efficient than their JVM counterparts. The first part of this
    chapter will guide you through taking advantage of this new technology.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 云基础设施的一个显著优势是你可以按需增加或减少资源，并且只需为使用的资源付费。Java 应用程序传统上非常资源密集，比 Go 等其他堆栈消耗更多的 CPU
    和内存。现在不再是这样了。使用 GraalVM 和 Spring Native，你可以将你的 Spring Boot 应用程序编译成原生可执行文件，这些可执行文件比它们的
    JVM 对应物性能更好、效率更高。本章的第一部分将指导你利用这项新技术。
- en: The second part of the chapter will expand on serverless architectures. Compared
    to CaaS and PaaS infrastructures, serverless architectures move most operational
    tasks to the platform and let developers focus on the applications. Some applications
    are naturally event-driven and aren’t always busy processing requests. Or they
    might have sudden peaks that require more computational resources. Serverless
    platforms provide fully managed auto-scaling features and can scale application
    instances to zero so that you don’t have to pay anything if there’s nothing to
    process. You’ll learn more about the serverless model, and you’ll build a serverless
    application using Spring Native and Spring Cloud Function. Finally, you’ll see
    how to deploy applications using Knative, a Kubernetes-based serverless platform.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分将扩展无服务器架构。与 CaaS 和 PaaS 基础设施相比，无服务器架构将大多数操作任务转移到平台，让开发者专注于应用程序。有些应用程序是自然的事件驱动的，并不总是忙于处理请求。或者它们可能会有突然的峰值，需要更多的计算资源。无服务器平台提供完全管理的自动扩展功能，可以将应用程序实例扩展到零，这样如果你没有要处理的内容，就不需要支付任何费用。你将了解更多关于无服务器模型的信息，并使用
    Spring Native 和 Spring Cloud Function 构建一个无服务器应用程序。最后，你将了解如何使用基于 Kubernetes 的无服务器平台
    Knative 来部署应用程序。
- en: Note The source code for the examples in this chapter is available in the Chapter16/16-begin
    and Chapter16/16-end folders, containing the initial and final states of the project
    ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在 Chapter16/16-begin 和 Chapter16/16-end 文件夹中找到，包含项目的初始和最终状态（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: 16.1 Native images with Spring Native and GraalVM
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 使用 Spring Native 和 GraalVM 生成原生镜像
- en: One of the reasons why Java applications became widely popular was the common
    platform (the Java Runtime Environment, or JRE), allowing developers to “write
    them once, run them everywhere,” no matter the operating system. That comes from
    the way applications are compiled. Rather than compiling the application code
    directly into machine code (the code understood by operating systems), the Java
    compiler produces bytecode that a dedicated component (the Java Virtual Machine,
    or JVM) runs. During execution, the JRE interprets the bytecode into machine code
    dynamically, allowing the same application executable to run on any machine and
    OS where a JVM is available. This is called a *just-in-time (JIT) compilation*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java 应用程序之所以变得非常流行，其中一个原因是它们有一个共同的平台（Java 运行时环境，或称 JRE），允许开发者“一次编写，到处运行”，无论操作系统如何。这源于应用程序的编译方式。Java
    编译器不是直接将应用程序代码编译成机器代码（操作系统理解的代码），而是生成字节码，由一个专用组件（Java 虚拟机，或称 JVM）运行。在执行过程中，JRE
    会动态地将字节码解释成机器代码，使得相同的应用程序可执行文件可以在任何有 JVM 的机器和操作系统上运行。这被称为 *即时编译（JIT）*。
- en: 'Applications running on the JVM are subject to startup and footprint costs.
    The startup phase used to be quite long for traditional applications, for which
    it could even take several minutes. Standard cloud native applications have a
    much faster startup phase: a few seconds rather than a few minutes. This is good
    enough for most scenarios, but it can become a serious issue for serverless workloads
    that are required to start almost instantaneously.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 上运行的应用程序会受到启动和足迹成本的影响。传统应用程序的启动阶段曾经相当长，甚至可能需要几分钟。标准的云原生应用程序具有更快的启动阶段：几秒钟而不是几分钟。这对于大多数场景来说已经足够好了，但对于需要几乎瞬间启动的无服务器工作负载来说，这可以成为一个严重的问题。
- en: Standard Java applications also have a higher footprint cost than other stacks
    like Go. Cloud services are usually based on a pay-per-use model, so reducing
    CPU and memory footprint means cutting down costs. This section will show you
    how to address this issue using GraalVM and Spring Native.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Java 应用程序比 Go 等其他堆栈的足迹成本更高。云服务通常基于按使用付费的模式，因此减少 CPU 和内存足迹意味着降低成本。本节将向您展示如何使用
    GraalVM 和 Spring Native 解决此问题。
- en: 16.1.1 Understanding GraalVM and native images
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.1 理解 GraalVM 和原生图像
- en: So far, you’ve used the JVM and tools provided by OpenJDK, which comes in many
    distributions, such as Eclipse Adoptium (previously known as AdoptOpenJDK), BellSoft
    Liberica JDK, and Microsoft OpenJDK. GraalVM is a newer distribution from Oracle
    based on OpenJDK and is “designed to accelerate the execution of applications
    written in Java and other JVM languages” ([www.graalvm.org](http://www.graalvm.org)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用了 JVM 和 OpenJDK 提供的工具，OpenJDK 有许多发行版，例如 Eclipse Adoptium（之前称为 AdoptOpenJDK）、BellSoft
    Liberica JDK 和 Microsoft OpenJDK。GraalVM 是 Oracle 基于 OpenJDK 的新发行版，它“旨在加速用 Java
    和其他 JVM 语言编写的应用程序的执行”([www.graalvm.org](http://www.graalvm.org))。
- en: By replacing a standard OpenJDK distribution with GraalVM as the runtime environment
    for your Java applications, you can increase their performance and efficiency,
    thanks to a new optimized technology for performing JIT compilation (the GraalVM
    compiler). GraalVM also provides runtimes to execute code written in other languages
    like JavaScript, Python, and R. You can even write polyglot applications, including
    Python scripts in your Java code, for example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将标准 OpenJDK 发行版替换为 GraalVM 作为 Java 应用程序的运行环境，您可以通过 GraalVM 编译器（一种新的优化技术）进行
    JIT 编译来提高它们的性能和效率。GraalVM 还提供了运行 JavaScript、Python 和 R 等其他语言代码的运行时。您甚至可以编写多语言应用程序，例如在
    Java 代码中包含 Python 脚本。
- en: GraalVM offers two primary operational modes. The *JVM Runtime* mode lets you
    run your Java applications like any other OpenJDK distribution while improving
    performance and efficiency thanks to the GraalVM compiler. What makes GraalVM
    so innovative and popular in the serverless context is the *Native Image* mode.
    Rather than compiling your Java code into bytecode and relying on a JVM to interpret
    it and convert it to machine code, GraalVM offers a new technology (the Native
    Image builder) that compiles Java applications directly into machine code, obtaining
    a *native executable* or *native image* that contains the whole machine code necessary
    for its execution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 提供两种主要的操作模式。*JVM 运行时*模式允许您像运行任何其他 OpenJDK 发行版一样运行您的 Java 应用程序，同时通过 GraalVM
    编译器提高性能和效率。使 GraalVM 在无服务器环境中如此创新和受欢迎的是*原生图像*模式。与将 Java 代码编译成字节码并依赖 JVM 解释它并将其转换为机器码不同，GraalVM
    提供了一种新技术（原生图像构建器），它将 Java 应用程序直接编译成机器码，获得包含执行所需全部机器码的*原生可执行文件*或*原生图像*。
- en: Java applications compiled as native images have faster startup times, optimized
    memory consumption, and instant peak performance compared to the JVM options.
    GraalVM builds them by changing the way applications are compiled. Instead of
    a JIT-compiler optimizing and producing machine code at runtime, the *Native Image*
    mode is based on *Ahead-Of-Time (AOT) compilation*. Starting from the main() method,
    all classes and methods that are reachable during the application’s execution
    are statically analyzed at build time and compiled into a standalone binary executable,
    including any dependencies and libraries. Such an executable doesn’t run on a
    JVM but directly on the machine, just like C or C++ applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 应用程序编译为原生镜像具有更快的启动时间、优化的内存消耗和与 JVM 选项相比的即时峰值性能。GraalVM 通过改变应用程序的编译方式来构建它们。与在运行时优化并生成机器代码的
    JIT 编译器不同，*原生镜像* 模式基于 *提前编译 (AOT)*。从 main() 方法开始，所有在应用程序执行期间可到达的类和方法都会在构建时进行静态分析，并编译成一个独立的二进制可执行文件，包括任何依赖项和库。这样的可执行文件不在
    JVM 上运行，而是直接在机器上运行，就像 C 或 C++ 应用程序一样。
- en: When using native images, much of the work that used to be performed at runtime
    by the JVM is now done at build time. As a result, building an application into
    a native executable takes longer and requires more computational resources than
    the JVM option. The GraalVM AOT compiler does not support some Java features out
    of the box. For example, reflection, dynamic proxies, serialization, and dynamic
    class loading require extra configuration to help the AOT compiler understand
    how to analyze them statically.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用原生镜像时，以前由 JVM 在运行时执行的大部分工作现在在构建时完成。因此，将应用程序构建为原生可执行文件需要更长的时间，并且比 JVM 选项需要更多的计算资源。GraalVM
    AOT 编译器不支持一些 Java 功能。例如，反射、动态代理、序列化和动态类加载需要额外的配置来帮助 AOT 编译器了解如何静态分析它们。
- en: How can we adapt existing Java applications to run as native images? How much
    configuration is required to support frameworks and libraries? How can we provide
    the necessary configuration for the AOT compiler? That’s where Spring Native enters
    the scene.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将现有的 Java 应用程序调整为以原生镜像运行？支持框架和库需要多少配置？我们如何为 AOT 编译器提供必要的配置？这就是 Spring Native
    出现的地方。
- en: 16.1.2 Introducing GraalVM support for Spring Boot with Spring Native
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.2 介绍 GraalVM 对 Spring Boot 的支持（通过 Spring Native）
- en: Spring Native is a new project introduced to support compiling Spring Boot applications
    with GraalVM. The main goal of Spring Native is to make it possible to compile
    any Spring application into a native executable using GraalVM without any code
    changes. To achieve that goal, the project provides an AOT infrastructure (invoked
    from a dedicated Gradle/Maven plugin) that contributes all the required configurations
    for GraalVM to AOT-compile Spring classes. The project is one of the latest additions
    to the Spring portfolio and it’s currently in beta. At the time of writing, most
    Spring libraries are supported, as well as common libraries like Hibernate, Lombok,
    and gRPC.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Native 是一个新项目，旨在支持使用 GraalVM 编译 Spring Boot 应用程序。Spring Native 的主要目标是使任何
    Spring 应用程序都能使用 GraalVM 编译成原生可执行文件，而无需任何代码更改。为了实现这一目标，该项目提供了一个 AOT 基础设施（从专门的 Gradle/Maven
    插件调用），为 GraalVM 提供了编译 Spring 类所需的所有配置。该项目是 Spring 产品组合的最新补充，目前处于测试版。在撰写本文时，大多数
    Spring 库都得到了支持，以及像 Hibernate、Lombok 和 gRPC 这样的常用库。
- en: For Spring libraries not yet supported, or for your own code, Spring Native
    offers helpful tools for configuring the GraalVM compiler. For example, if you
    use reflection or dynamic proxies in your code, GraalVM will require a dedicated
    configuration to know how to AOT-compile it. Spring Native offers convenient annotations
    like @NativeHints and @TypedHint to instruct the GraalVM compiler directly from
    your Java code, taking advantage of the IDE auto-completion features and type
    checks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于尚未支持 Spring 库或您自己的代码，Spring Native 提供了配置 GraalVM 编译器的有用工具。例如，如果您在代码中使用反射或动态代理，GraalVM
    将需要专门的配置来了解如何 AOT 编译它。Spring Native 提供了方便的注解，如 @NativeHints 和 @TypedHint，可以直接从您的
    Java 代码中指导 GraalVM 编译器，利用 IDE 自动完成功能和类型检查。
- en: Note Spring Native will come out of the beta phase and become part of the core
    Spring libraries starting with Spring Framework 6 and Spring Boot 3, which are
    expected to be released in December 2022.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Spring Native 将从测试版阶段退出，并从 Spring Framework 6 和 Spring Boot 3 开始成为核心 Spring
    库的一部分，预计将于 2022 年 12 月发布。
- en: In this section, we’ll explore the features of Spring Native by building Quote
    Service, a web application that exposes an API to fetch quotes from books.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过构建Quote Service（一个暴露API以从书籍中获取引文的Web应用程序）来探索Spring Native的功能。
- en: Bootstrapping a new project with Spring Native and Spring Reactive Web
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Native和Spring Reactive Web启动新项目
- en: You can initialize the Quote Service project from Spring Initializr ([https://start.spring.io](https://start.spring.io)),
    store the result in a new quote-service Git repository, and push it to GitHub.
    The parameters for the initialization are shown in figure 16.1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Spring Initializr（[https://start.spring.io](https://start.spring.io)）初始化Quote
    Service项目，将结果存储在一个新的quote-service Git仓库中，并将其推送到GitHub。初始化的参数如图16.1所示。
- en: '![16-01](../Images/16-01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![16-01](../Images/16-01.png)'
- en: Figure 16.1 The parameters for initializing the Quote Service project
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 初始化Quote Service项目的参数
- en: 'The project contains the following main dependencies:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包含以下主要依赖项：
- en: '*Spring Reactive Web* provides the necessary libraries for building reactive
    web applications with Spring WebFlux, and it includes Netty as the default embedded
    server.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Reactive Web* 提供了构建使用Spring WebFlux的响应式Web应用程序所需的库，并且它包括Netty作为默认的嵌入式服务器。'
- en: '*Spring Native* supports compiling Spring applications to native executables
    using the GraalVM native-image compiler.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Native* 支持使用GraalVM native-image编译器将Spring应用程序编译成原生可执行文件。'
- en: 'The resulting dependencies section of the build.gradle file is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: build.gradle文件的最终依赖项部分如下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At this point, you might ask: where is the Spring Native dependency? There
    isn’t one. Where is Spring Native? The answer can be found in the plugins sections
    of the build.gradle file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能会问：Spring Native的依赖项在哪里？没有。Spring Native在哪里？答案可以在build.gradle文件的插件部分找到：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Spring AOT plugin provided by Spring Native
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Spring Native提供的Spring AOT插件
- en: When you add Spring Native to a project, you’ll get the Spring AOT plugin, which
    provides the required configuration for GraalVM to compile the Spring classes
    as well as convenient functionality for building native executables from Gradle
    (or Maven).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将Spring Native添加到项目中时，您将获得Spring AOT插件，该插件为GraalVM编译Spring类提供所需的配置，以及从Gradle（或Maven）构建原生可执行文件时的便利功能。
- en: 'If you bootstrap a new project from Spring Initializr, you’ll also get additional
    information in the HELP.md file about how to use Spring Native. Should you select
    any unsupported dependencies, you’ll find a message warning you about it. For
    example, Spring Cloud Stream is not fully supported at the time of writing. If
    you initialize a project with Spring Native and Spring Cloud Stream, the HELP.md
    file will show you a message like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从Spring Initializr启动新项目，HELP.md文件还将提供有关如何使用Spring Native的额外信息。如果您选择了任何不受支持的依赖项，您将看到一个警告消息。例如，Spring
    Cloud Stream在撰写本文时并不完全受支持。如果您使用Spring Native和Spring Cloud Stream初始化项目，HELP.md文件将显示如下消息：
- en: 'The following dependency is not known to work with Spring Native: ''Cloud Stream''.
    As a result, your application may not work as expected.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项与Spring Native不兼容：'Cloud Stream'。因此，您的应用程序可能无法按预期工作。
- en: Note You can follow which Spring libraries are supported in the Spring Native
    official documentation ([https://docs.spring.io/spring-native/docs/current/reference/htmlsingle](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在Spring Native官方文档（[https://docs.spring.io/spring-native/docs/current/reference/htmlsingle](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle)）中查看哪些Spring库受支持。
- en: Next, let’s implement the business logic for Quote Service.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现Quote Service的业务逻辑。
- en: Implementing the business logic
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现业务逻辑
- en: Quote Service will return random book quotes through a REST API. First, create
    a new com.polarbookshop.quoteservice.domain package and define a Quote record
    to model the domain entity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Quote Service将通过REST API返回随机的书籍引文。首先，创建一个新的com.polarbookshop.quoteservice.domain包，并定义一个Quote记录来表示领域实体。
- en: Listing 16.1 Defining a domain entity for representing book quotes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.1 定义表示书籍引文的领域实体
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Quotes are categorized by the genre of the book from which they are extracted.
    Add a Genre enum to model this classification.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引文根据提取它们的书籍类型进行分类。添加一个Genre枚举来表示这种分类。
- en: Listing 16.2 Defining an enumeration to represent book genres
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.2 定义表示书籍类型的枚举
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, implement the business logic to retrieve book quotes in a new QuoteService
    class. Quotes will be defined and stored in a static in-memory list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在新的 QuoteService 类中实现检索书摘的业务逻辑。引言将被定义并存储在静态内存列表中。
- en: Listing 16.3 The business logic to query book quotes
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.3 查询书摘业务逻辑
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Stores a list of quotes in memory
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在内存中存储引言列表
- en: ❷ Returns all quotes as a reactive data stream
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回所有引言作为反应式数据流
- en: Note Since the focus of this example is the native-image compilation with GraalVM
    and Spring Native, we’ll keep it simple and skip the persistence layer. Feel free
    to expand it on your own. For example, you could add Spring Data R2DBC and Spring
    Security, both supported by Spring Native.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于本例的重点是使用 GraalVM 和 Spring Native 进行原生图像编译，我们将保持简单，并跳过持久层。请随意自行扩展。例如，您可以添加
    Spring Data R2DBC 和 Spring Security，它们都受 Spring Native 支持。
- en: That’s it for the business logic. Next we’ll expose the functionality through
    an HTTP API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑到此结束。接下来，我们将通过 HTTP API 暴露功能。
- en: Implementing the web controller
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实现网络控制器
- en: 'Create a new com.polarbookshop.quoteservice.web package and add a QuoteController
    class to expose three endpoints for the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 com.polarbookshop.quoteservice.web 包，并添加一个 QuoteController 类来公开以下三个端点：
- en: Return all the quotes
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回所有引言
- en: Return a random quote
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个随机引言
- en: Return a random quote for a given genre
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回给定类别的随机引言
- en: Listing 16.4 Defining handlers for HTTP endpoints
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.4 定义 HTTP 端点的处理器
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then configure the embedded Netty server to listen to port 9101, and define
    the application name. Open the application.yml file and add the following configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后配置嵌入的 Netty 服务器以监听端口 9101，并定义应用程序名称。打开 application.yml 文件并添加以下配置。
- en: Listing 16.5 Configuring the Netty server port and the application name
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.5 配置 Netty 服务器端口和应用程序名称
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, let’s write some integration tests using the same techniques you learned
    in chapter 8\.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用在第 8 章中学到的相同技术编写一些集成测试。
- en: Writing integration tests
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: When we bootstrapped the project from Spring Initializr, we got an autogenerated
    QuoteServiceApplicationTests class. Let’s update it with a few integration tests
    to check the REST API exposed by Quote Service.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 Spring Initializr 启动项目时，我们得到了一个自动生成的 QuoteServiceApplicationTests 类。让我们用一些集成测试来更新它，以检查
    Quote 服务暴露的 REST API。
- en: Listing 16.6 Integration tests for Quote Service
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.6 Quote 服务的集成测试
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s it for the implementation. Next we’ll execute the auto-tests and run
    the application on the JVM.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实现到此结束。接下来，我们将执行自动测试并在 JVM 上运行应用程序。
- en: Running and testing on the JVM
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 上运行和测试
- en: 'So far, Quote Service is a standard Spring Boot application, no different from
    any other applications we built in the previous chapters. For example, we can
    run the autotests with Gradle and ensure that it behaves correctly. Open a Terminal
    window, navigate to the project’s root folder, and execute the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Quote 服务是一个标准的 Spring Boot 应用程序，与我们之前章节中构建的任何其他应用程序没有区别。例如，我们可以使用 Gradle
    运行自动测试并确保其行为正确。打开一个终端窗口，导航到项目的根文件夹，并执行以下命令：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also run it on the JVM or package it as a JAR artifact. From the same
    Terminal window, execute the following command to run the application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 JVM 上运行它或将其打包成 JAR 艺术品。在同一个终端窗口中，执行以下命令来运行应用程序：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Feel free to verify that the application works correctly by calling the endpoints
    exposed by Quote Service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请随意验证应用程序是否通过调用 Quote 服务公开的端点正确工作：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you’re done testing the application, stop the process with Ctrl-C.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成应用程序的测试后，使用 Ctrl-C 停止进程。
- en: How can we compile it to a native executable and take advantage of instant startup
    time, instant peak performance, and reduced memory consumption? That’s the topic
    of the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将其编译成原生可执行文件并利用即时启动时间、即时峰值性能和降低内存消耗？这是下一节的主题。
- en: 16.1.3 Compiling Spring Boot applications as native images
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.3 将 Spring Boot 应用程序编译为原生镜像
- en: There are two ways to compile your Spring Boot applications into native executables.
    The first option uses GraalVM explicitly and produces an OS-specific executable
    that runs directly on a machine. The second option relies on Cloud Native Buildpacks
    to containerize the native executable and run it on a container runtime like Docker.
    We’ll use both.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将您的 Spring Boot 应用程序编译成原生可执行文件。第一种选项明确使用 GraalVM 并生成特定于操作系统的可执行文件，该文件可以直接在机器上运行。第二种选项依赖于云原生构建包来容器化原生可执行文件，并在容器运行时（如
    Docker）上运行它。我们将使用这两种方法。
- en: Compiling native executables with GraalVM
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GraalVM 编译原生可执行文件
- en: The first option requires the GraalVM runtime to be available on your machine.
    You can install it directly from the website ([www.graalvm.org](http://www.graalvm.org))
    or use a tool like sdkman. You can find instructions on how to install sdkman
    in section A.1 of appendix A.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项要求你的机器上必须有 GraalVM 运行时。你可以直接从网站（[www.graalvm.org](http://www.graalvm.org)）安装，或者使用像
    sdkman 这样的工具。你可以在附录 A 的 A.1 节中找到如何安装 sdkman 的说明。
- en: 'For the examples in this chapter, I’ll be using the latest GraalVM 22.1 distribution
    available at the time of writing, based on OpenJDK 17\. Using sdkman, you can
    install GraalVM as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的示例，我将使用在写作时最新的 GraalVM 22.1 分发版，该分发版基于 OpenJDK 17。使用 sdkman，你可以按照以下步骤安装
    GraalVM：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the end of the installation procedure, sdkman will ask whether you want to
    make that distribution the default one. I recommend you say no, since we’re going
    to be explicit whenever we need to use GraalVM instead of the standard OpenJDK.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程结束时，sdkman 会询问你是否想将该分发版设置为默认版本。我建议你说不，因为我们将在需要使用 GraalVM 而不是标准 OpenJDK
    时明确指出。
- en: 'Then open a Terminal window, navigate to your Quote Service project (quote-service),
    configure the shell to use GraalVM, and install the native-image GraalVM component
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开一个终端窗口，导航到你的 Quote Service 项目（quote-service），配置 shell 以使用 GraalVM，并按照以下步骤安装
    native-image GraalVM 组件：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Configures the current shell to use the specified Java runtime
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置当前 shell 以使用指定的 Java 运行时
- en: ❷ Uses the gu utility provided by GraalVM to install the native-image component
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 GraalVM 提供的 gu 工具安装 native-image 组件
- en: When you initialized the Quote Service project, the GraalVM Gradle/Maven official
    plugin was included automatically. That’s the one providing the functionality
    to compile applications using the GraalVM Native Image mode.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化 Quote Service 项目时，自动包含了 GraalVM Gradle/Maven 官方插件。这就是提供使用 GraalVM Native
    Image 模式编译应用程序功能的插件。
- en: Note The following Gradle tasks require that GraalVM is the current Java runtime.
    When using sdkman, you can do that by running sdk use java 22.2.r17-grl in the
    Terminal window where you want to use GraalVM.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：以下 Gradle 任务要求 GraalVM 是当前 Java 运行时。当使用 sdkman 时，你可以在想要使用 GraalVM 的终端窗口中运行
    `sdk use java 22.2.r17-grl` 来实现这一点。
- en: Take into account that the compilation step for GraalVM apps is more prolonged,
    taking several minutes depending on the computational resources available on your
    machine. That is one of the drawbacks of working with native images. Also, since
    Spring Native is still in an experimental phase, you might get several debug logs
    and warnings, but that should be fine if the process completes successfully.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，编译 GraalVM 应用程序的步骤会更长，根据你机器上可用的计算资源，可能需要几分钟。这是使用原生图像的一个缺点。另外，由于 Spring Native
    仍然处于实验阶段，你可能会收到几个调试日志和警告，但如果过程成功完成，那应该没问题。
- en: 'From the same Terminal window where you switched to GraalVM as the current
    Java runtime, run the following command to compile the application to a native
    image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从你切换到 GraalVM 作为当前 Java 运行时的同一个终端窗口中，运行以下命令以将应用程序编译为原生图像：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A standalone binary is the result of the command. Since it’s a native executable,
    it will be different on macOS, Linux, and Windows. You can run it on your machine
    natively, without the need for a JVM. In the case of Gradle, the native executable
    is generated in the build/native/nativeCompile folder. Go ahead and run it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果是一个独立的二进制文件。由于它是一个原生可执行文件，它在 macOS、Linux 和 Windows 上会有所不同。你可以在你的机器上原生运行它，无需
    JVM。在 Gradle 的情况下，原生可执行文件是在 build/native/nativeCompile 文件夹中生成的。现在就运行它吧。
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first thing to notice is the startup time, usually less than 100 ms with
    Spring Native. It’s an impressive improvement compared to the JVM option, which
    takes a few seconds. The best part of this is that we didn’t have to write any
    code to make that happen! Let’s send a request to ensure that the application
    is running correctly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是启动时间，通常小于 100 毫秒，与 JVM 选项相比，后者需要几秒钟。最好的部分是，我们不需要编写任何代码就能实现这一点！让我们发送一个请求以确保应用程序正在正确运行：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you’re done testing the application, stop the process with Ctrl-C.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成应用程序的测试后，使用 Ctrl-C 停止进程。
- en: 'You can also run the autotests as native executables to make them even more
    reliable, since they will use the actual runtime environment used in production.
    However, the compilation step still takes longer than when running on the JVM:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将自动测试作为原生可执行文件运行，以使它们更加可靠，因为它们将使用实际的生产运行环境。然而，编译步骤仍然比在JVM上运行要长：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, you can run a Spring Boot application as a native image directly from
    Gradle/Maven:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以直接从Gradle/Maven运行Spring Boot应用程序作为原生图像：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember to stop the application process with Ctrl-C before moving to the next
    section, which will show you another option for compiling your Spring Boot applications
    to native executables. It won’t require having GraalVM installed on your computer,
    and it will produce a containerized native executable using Cloud Native Buildpacks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，请记得使用Ctrl-C停止应用程序进程，下一节将展示另一种将你的Spring Boot应用程序编译为原生可执行文件的方法。这不需要在计算机上安装GraalVM，并且将使用云原生Buildpacks生成容器化的原生可执行文件。
- en: Containerizing native images with Buildpacks
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Buildpacks容器化原生图像
- en: The second option for compiling Spring Boot applications to native executables
    relies on Cloud Native Buildpacks. Similar to how we packaged Spring Boot applications
    as container images in chapter 6, we can use Buildpacks to build a container image
    from the application native executable compiled by GraalVM. This approach benefits
    from not requiring GraalVM to be installed on your machine.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将Spring Boot应用程序编译为原生可执行文件的第二种方法依赖于云原生Buildpacks。类似于我们在第6章中将Spring Boot应用程序打包为容器图像的方式，我们可以使用Buildpacks从由GraalVM编译的应用程序原生可执行文件构建容器图像。这种方法的好处是不需要在你的机器上安装GraalVM。
- en: Spring Initializr didn’t just include the Spring AOT plugin when you bootstrapped
    the Quote Service project; it also provided additional configuration for the Buildpacks
    integration available in Spring Boot. If you check the build.gradle file again,
    you can see that the bootBuildImage task is configured to produce a containerized
    native image through the BP_NATIVE_IMAGE environment variable. While you’re there,
    configure the image name and the container registry authentication as we did for
    the other Polar Bookshop applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动Quote Service项目时，Spring Initializr不仅包括了Spring AOT插件；它还提供了Spring Boot中可用的Buildpacks集成的额外配置。如果你再次检查build.gradle文件，你可以看到bootBuildImage任务被配置为通过BP_NATIVE_IMAGE环境变量生成容器化的原生图像。同时，配置图像名称和容器注册表身份验证，就像我们为其他Polar
    Bookshop应用程序所做的那样。
- en: Listing 16.7 Configuration for containerizing Quote Service
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.7容器化Quote服务的配置
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Uses the “tiny” version of Paketo Buildpacks to minimize the container image
    size
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用“小巧”版本的Paketo Buildpacks以最小化容器图像大小
- en: ❷ Enables GraalVM support and produces a containerized native image
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启用GraalVM支持并生成容器化的原生图像
- en: Note As you probably noticed when running the native image compilation process
    on your machine, it takes not only time but also more computational resources
    than usual. When using Buildpacks, make sure you have at least 16 GB of RAM on
    your computer. If you use Docker Desktop, configure the Docker virtual machine
    with at least 8 GB of RAM. On Windows, it’s recommended that you use Docker Desktop
    on WSL2 rather than Hyper-V. For more recommendations about the setup, refer to
    the Spring Native documentation ([https://docs.spring.io/spring-native/docs/current/reference/htmlsingle](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你可能在你的机器上运行原生图像编译过程时，你可能已经注意到了，这不仅需要时间，而且比通常需要更多的计算资源。当使用Buildpacks时，确保你的计算机上至少有16
    GB的RAM。如果你使用Docker Desktop，请将Docker虚拟机配置为至少8 GB的RAM。在Windows上，建议你使用Docker Desktop
    on WSL2而不是Hyper-V。有关设置的更多建议，请参阅Spring Native文档（[https://docs.spring.io/spring-native/docs/current/reference/htmlsingle](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle)）。
- en: 'The command to use Buildpacks and produce a containerized native image is the
    same that you’d use for JVM images. Open a Terminal window, navigate to your Quote
    Service project (quote-service), and run the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Buildpacks并生成容器化原生图像的命令与用于JVM图像的命令相同。打开一个终端窗口，导航到你的Quote Service项目（quote-service），并运行以下命令：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When it’s done, try running the resulting container image:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，尝试运行生成的容器图像：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The startup time should again be less than 100 ms. Go ahead and send a few
    requests to test whether the application is working correctly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时间应该再次小于100毫秒。继续发送一些请求以测试应用程序是否正常工作：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you’re done testing the application, stop the container process with Ctrl-C.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成应用程序的测试后，使用Ctrl-C停止容器进程。
- en: 16.2 Serverless applications with Spring Cloud Function
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 使用Spring Cloud Function的无服务器应用程序
- en: As introduced in chapter 1, serverless is a further abstraction layer on top
    of virtual machines and containers, moving even more responsibilities from product
    teams to the platform. Following the serverless computing model, developers focus
    on implementing the business logic for their applications. Using an orchestrator
    like Kubernetes still requires infrastructure provisioning, capacity planning,
    and scaling. In contrast, a serverless platform takes care of setting up the underlying
    infrastructure needed by the applications to run, including virtual machines,
    containers, and dynamic scaling.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1章所述，无服务器是在虚拟机和容器之上的进一步抽象层，将更多责任从产品团队转移到平台。遵循无服务器计算模型，开发者专注于实现应用程序的业务逻辑。使用像Kubernetes这样的编排器仍然需要基础设施配置、容量规划和扩展。相比之下，无服务器平台负责设置应用程序运行所需的底层基础设施，包括虚拟机、容器和动态扩展。
- en: Serverless applications typically only run when there is an event to handle,
    such as an HTTP request (*request-driven*) or a message (*event-driven*). The
    event can be external or produced by another function. For example, whenever a
    message is added to a queue, a function might be triggered, process the message,
    and then exit the execution. When there is nothing to process, the platform shuts
    down all the resources involved with the function, so you can really pay for your
    actual usage.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器应用程序通常仅在存在事件要处理时运行，例如HTTP请求（*请求驱动*）或消息（*事件驱动*）。事件可以是外部的，也可以由另一个函数产生。例如，每当消息被添加到队列中时，可能会触发一个函数，处理消息，然后退出执行。当没有要处理的内容时，平台会关闭与该函数相关的所有资源，这样你实际上只需为实际使用付费。
- en: In the other cloud native topologies like CaaS or PaaS, there is always a server
    involved running 24/7\. Compared to traditional systems, you get the advantage
    of dynamic scalability, reducing the number of resources provisioned at any given
    time. Still, there is always something up and running that has a cost. In the
    serverless model, however, resources are provisioned only when necessary. If there
    is nothing to process, everything is shut down. That’s what we call *scaling to
    zero*, and it’s one of the main features offered by serverless platforms.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他云原生拓扑结构，如CaaS或PaaS中，始终有一个服务器在24/7运行。与传统系统相比，你获得了动态可伸缩性的优势，减少了在任何给定时间配置的资源数量。然而，始终有某些内容在运行，这会产生成本。然而，在无服务器模型中，资源仅在必要时配置。如果没有要处理的内容，一切都会关闭。这就是我们所说的*扩展到零*，这是无服务器平台提供的主要功能之一。
- en: A consequence of scaling applications to zero is that when eventually there’s
    a request to handle, a new application instance is started, and it must be ready
    to process the request very quickly. Standard JVM applications are not suitable
    for serverless applications, since it’s hard to achieve a startup time lower than
    a few seconds. That’s why GraalVM native images became popular. Their instant
    startup time and reduced memory consumption make them perfect for the serverless
    model. The *instant startup time* is required for scaling. The *reduced memory
    consumption* helps reduce costs, which is one of the goals of serverless and cloud
    native in general.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序扩展到零的后果是，当最终有请求需要处理时，会启动一个新的应用程序实例，并且它必须能够非常快速地处理请求。标准的JVM应用程序不适合无服务器应用程序，因为很难实现低于几秒的启动时间。这就是为什么GraalVM原生镜像变得流行。它们的即时启动时间和减少的内存消耗使它们非常适合无服务器模型。*即时启动时间*对于扩展是必需的。*减少的内存消耗*有助于降低成本，这是无服务器和云原生的一般目标之一。
- en: 'Besides cost optimization, serverless technologies also move some extra responsibility
    from the application to the platform. That might be an advantage, since it allows
    developers to focus exclusively on the business logic. But it’s also essential
    to consider what degree of control you would like to have and how you will deal
    with vendor lock-in. Each serverless platform has its own features and APIs. Once
    you start writing functions for a specific platform, you can’t move them easily
    to another, as you would do with containers. You might compromise to gain responsibility
    and scope and lose on control and portability more than with any other approach.
    That’s why *Knative* became popular quickly: it’s built on Kubernetes, which means
    that you can easily move your serverless workloads between platforms and vendors.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了成本优化外，无服务器技术还将一些额外的责任从应用程序转移到平台。这可能是一个优势，因为它允许开发者专注于业务逻辑。但考虑您希望控制的程度以及如何处理供应商锁定也是至关重要的。每个无服务器平台都有自己的特性和API。一旦您开始为特定平台编写函数，您就不能像处理容器那样轻松地将它们转移到另一个平台。您可能需要妥协以获得责任和范围，但可能会在控制性和可移植性方面失去更多，这就是为什么*Knative*迅速流行起来的原因：它是基于Kubernetes构建的，这意味着您可以轻松地在平台和供应商之间移动您的无服务器工作负载。
- en: This section will guide you through developing and deploying a serverless application.
    You’ll use Spring Native to compile it to a GraalVM native image and use Spring
    Cloud Function to implement the business logic as functions, which is an excellent
    choice, since serverless applications are event-driven.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您开发并部署一个无服务器应用程序。您将使用Spring Native将其编译为GraalVM原生镜像，并使用Spring Cloud Function将业务逻辑实现为函数，这是一个非常好的选择，因为无服务器应用程序是事件驱动的。
- en: 16.2.1 Building serverless applications with Spring Cloud Function
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.1 使用Spring Cloud Function构建无服务器应用程序
- en: 'You have already worked with Spring Cloud Function in chapter 10\. As you learned
    there, it’s a project aimed at promoting business logic implementation via functions
    based on the standard interfaces introduced by Java 8: Supplier, Function, and
    Consumer.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在第10章中学习了如何使用Spring Cloud Function。正如您所了解的，这是一个旨在通过基于Java 8引入的标准接口（Supplier、Function和Consumer）实现业务逻辑的项目。
- en: Spring Cloud Function is very flexible. You have already seen how it integrates
    transparently with external messaging systems like RabbitMQ and Kafka, a handy
    feature for building serverless applications that are triggered by messages. In
    this section I’d like to show you one more feature offered by Spring Cloud Function
    that lets you expose functions as endpoints triggered by HTTP requests and CloudEvents,
    which is a specification standardizing the format and distribution of events in
    cloud architectures.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Function非常灵活。您已经看到了它如何透明地与外部消息系统（如RabbitMQ和Kafka）集成，这对于构建由消息触发的无服务器应用程序来说是一个实用的功能。在本节中，我想向您展示Spring
    Cloud Function提供的另一个功能，它允许您将函数作为由HTTP请求和CloudEvents触发的端点公开，CloudEvents是一种规范，用于标准化云架构中事件格式和分发。
- en: We’ll use the same requirements as those for the Quote Service application we
    built earlier, but this time we’ll implement the business logic as functions and
    let the framework deal with exposing them as HTTP endpoints.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与之前构建的Quote Service应用程序相同的规范，但这次我们将业务逻辑实现为函数，并让框架处理将它们作为HTTP端点公开。
- en: Bootstrapping a new project with Spring Native and Spring Cloud Function
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Native和Spring Cloud Function启动新项目
- en: You can initialize the Quote Function project from Spring Initializr ([https://start.spring.io](https://start.spring.io)),
    store the result in a new quote-function Git repository, and push it to GitHub.
    The parameters for the initialization are shown in figure 16.2.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Spring Initializr（[https://start.spring.io](https://start.spring.io)）初始化Quote
    Function项目，将结果存储在一个新的quote-function Git仓库中，并将其推送到GitHub。初始化的参数如图16.2所示。
- en: '![16-02](../Images/16-02.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![16-02](../Images/16-02.png)'
- en: Figure 16.2 The parameters for initializing the Quote Function project
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 初始化Quote Function项目的参数
- en: 'The project contains the following dependencies:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目包含以下依赖项：
- en: '*Spring Reactive Web* provides the necessary libraries for building reactive
    web applications with Spring WebFlux, and it includes Netty as the default embedded
    server.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Reactive Web* 提供了构建基于Spring WebFlux的响应式Web应用程序所需的库，并且它包括Netty作为默认的嵌入服务器。'
- en: '*Spring Cloud Function* provides the necessary libraries to support business
    logic implementation via functions, export them via several communication channels,
    and integrate them with serverless platforms.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Cloud Function*提供了必要的库来支持通过函数实现业务逻辑，通过多个通信渠道导出它们，并将它们与无服务器平台集成。'
- en: '*Spring Native* supports compiling Spring applications to native executables
    using the GraalVM native-image compiler.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Native*支持使用GraalVM native-image编译器将Spring应用程序编译为原生可执行文件。'
- en: The resulting dependencies section of the build.gradle file looks like the following.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: build.gradle文件的结果依赖部分看起来如下。
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then you can update the Cloud Native Buildpacks configuration in build.gradle
    much like we did for Quote Service.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在build.gradle中更新Cloud Native Buildpacks配置，就像我们为Quote Service所做的那样。
- en: Listing 16.8 Configuration for containerizing Quote Function
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.8容器化Quote Function的配置
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Uses the “tiny” version of Paketo Buildpacks to minimize the container image
    size
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用“微型”版本的Paketo Buildpacks以最小化容器镜像大小
- en: ❷ Enables the GraalVM support and produces a containerized native image
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启用GraalVM支持并生成容器化原生镜像
- en: Next, copy all the classes from the com.polarbookshop.quoteservice.domain package
    in Quote Service to a new com.polarbookshop.quotefunction.domain package in Quote
    Function. In the next section we’ll implement the business logic as functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将Quote Service中com.polarbookshop.quoteservice.domain包下的所有类复制到Quote Function中一个新的com.polarbookshop.quotefunction.domain包中。在下一节中，我们将实现业务逻辑作为函数。
- en: Implementing the business logic as functions
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将业务逻辑作为函数实现
- en: As you learned in chapter 10, Spring Cloud Function enhances standard Java functions
    when they are registered as beans. Let’s start by adding a QuoteFunctions class
    in a new com.polarbookshop.quotefunction.functions package for the Quote Function
    project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第10章中学到的，Spring Cloud Function增强了当它们作为bean注册时的标准Java函数。让我们首先为Quote Function项目在新的com.polarbookshop.quotefunction.functions包中添加一个QuoteFunctions类。
- en: 'The application should expose similar functionality to Quote Service:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应提供与Quote Service类似的功能：
- en: Returning all the quotes can be expressed as a Supplier, since it takes no input.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回所有报价可以表示为一个供应商，因为它不需要输入。
- en: Returning a random quote can also be expressed as a Supplier, since it takes
    no input.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回随机报价也可以表示为一个供应商，因为它不需要输入。
- en: Returning a random quote for a given genre can be expressed as a Function, since
    it has both input and output.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定流派返回一个随机报价可以表示为一个函数，因为它既有输入也有输出。
- en: Logging a quote to standard output can be expressed as a Consumer, since it
    has input but no output.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将报价记录到标准输出可以表示为一个消费者，因为它有输入但没有输出。
- en: Listing 16.9 Implementing the business logic as functions
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.9将业务逻辑作为函数实现
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Functions are declared as beans in a Spring configuration class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数在Spring配置类中声明为bean。
- en: ❷ A logger used by the functions
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 函数使用的记录器
- en: ❸ A supplier producing all the quotes
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成所有报价的供应商
- en: ❹ Quotes are streamed one at a time with a 1-second pause between them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 报价逐个流式传输，它们之间有1秒的暂停。
- en: ❺ A supplier producing a random quote
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 生成随机报价的供应商
- en: ❻ A function logging the quote received as the input
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 记录接收到的报价作为输入的函数
- en: Spring Cloud Function will automatically expose all the registered functions
    as HTTP endpoints when the Spring web dependencies are on the classpath. Each
    endpoint uses the same name as the function. In general, suppliers can be invoked
    through GET requests and functions and consumers as POST requests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring web依赖项在类路径上时，Spring Cloud Function会自动将所有注册的函数作为HTTP端点暴露。每个端点使用与函数相同的名称。通常，供应商可以通过GET请求调用，函数和消费者可以通过POST请求调用。
- en: Quote Function contains the Spring Reactive Web dependency, so Netty will be
    the server to handle HTTP requests. Let’s make it listen to port 9102 and configure
    the application name. Open the application.yml file, and add the following configuration.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Quote Function包含Spring Reactive Web依赖项，因此Netty将是处理HTTP请求的服务器。让我们让它监听端口9102并配置应用程序名称。打开application.yml文件，并添加以下配置。
- en: Listing 16.10 Configuring the Netty server port and application name
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.10配置Netty服务器端口和应用程序名称
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then run the Quote Function application (./gradlew bootRun) and open a Terminal
    window. For starters, you can test the two suppliers by sending GET requests:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行Quote Function应用程序（./gradlew bootRun）并打开一个终端窗口。首先，你可以通过发送GET请求来测试两个供应商：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To get a random quote by genre, you need to provide a genre string in the body
    of a POST request:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过流派获取随机报价，你需要在POST请求的正文提供流派字符串：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When only one function is registered as a bean, Spring Cloud Function will automatically
    expose it through the root endpoint. In the case of multiple functions, you can
    choose the function through the spring.cloud.function.definition configuration
    property.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个函数注册为bean时，Spring Cloud Function将自动通过根端点公开它。在多个函数的情况下，您可以通过spring.cloud.function.definition配置属性选择函数。
- en: For example, we could expose the allQuotes function through the root endpoint.
    In the Quote Function project, open the application.yml file and update it as
    follows.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过根端点公开allQuotes函数。在Quote Function项目中，打开application.yml文件并按以下方式更新它。
- en: Listing 16.11 Defining the main function managed by Spring Cloud Function
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.11 定义由Spring Cloud Function管理的主体函数
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Re-run the application and send a GET request to the root endpoint. Since the
    allQuotes function is a Supplier returning a Flux of Quote, you can leverage the
    streaming capabilities of Project Reactor and ask the application to return the
    quotes as they become available. That is done automatically when the Accept:text/event-stream
    header is used (for example, curl -H ''Accept:text/event-stream'' localhost:9102).
    When using the httpie utility, you’ll also need to use the --stream argument to
    enable data streaming:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行应用程序并向根端点发送GET请求。由于allQuotes函数是一个返回Quote Flux的Supplier，您可以利用Project Reactor的流式处理能力，要求应用程序在可用时返回引用。当使用Accept:text/event-stream头部时（例如，curl
    -H 'Accept:text/event-stream' localhost:9102），这会自动完成。当使用httpie实用程序时，您还需要使用--stream参数来启用数据流：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similar to what you did in chapter 10, you can build a pipeline by combining
    functions. When functions are exposed as HTTP endpoints, you can use the comma
    (,) character to compose functions on the fly. For example, you could combine
    the genreQuote function with logQuote as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与第10章中您所做的一样，您可以通过组合函数来构建管道。当函数作为HTTP端点公开时，您可以使用逗号（,）字符即时组合函数。例如，您可以将genreQuote函数与logQuote组合如下：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since logQuote is a consumer, the HTTP response has a 202 status with no body.
    If you check the application logs, you’ll see that the random quote by genre has
    been printed out instead.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于logQuote是一个消费者，HTTP响应具有202状态且没有主体。如果您检查应用程序日志，您将看到已打印出按流派随机选择的引用。
- en: Spring Cloud Function integrates with several communication channels. You have
    seen how you can expose functions through exchanges and queues leveraging Spring
    Cloud Stream and how to expose them as HTTP endpoints. The framework also supports
    RSocket, which is a binary reactive protocol, and CloudEvents, a specification
    standardizing the format and distribution of events in cloud architectures ([https://cloudevents.io](https://cloudevents.io)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Function与多个通信渠道集成。您已经看到了如何利用Spring Cloud Stream通过交换和队列公开函数，以及如何将它们公开为HTTP端点。该框架还支持RSocket，这是一种二进制响应式协议，以及CloudEvents，这是一个标准化云架构中事件格式和分发的规范（[https://cloudevents.io](https://cloudevents.io)）。
- en: '*CloudEvents* can be consumed over HTTP, messaging channels like AMPQ (RabbitMQ),
    and RSocket. They ensure a standard way of describing events, thus making them
    portable across a wide variety of technologies, including applications, messaging
    systems, build tools, and platforms.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*CloudEvents*可以通过HTTP、消息通道如AMPQ（RabbitMQ）和RSocket进行消费。它们确保以标准方式描述事件，从而使得它们可以在包括应用程序、消息系统、构建工具和平台在内的广泛技术中移植。'
- en: 'Since Quote Function is already configured to expose functions as HTTP endpoints,
    you can make it consume CloudEvents without changing any code. Ensure the application
    is up and running, and then send an HTTP request with the additional headers defined
    by the CloudEvents specification:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Quote Function已经配置为以HTTP端点公开函数，因此您可以在不更改任何代码的情况下使其消费CloudEvents。确保应用程序正在运行，然后发送一个带有CloudEvents规范定义的额外头部的HTTP请求：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ The CloudEvents specification version
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ CloudEvents规范版本
- en: ❷ The type of event (domain-specific)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 事件类型（特定领域）
- en: ❸ The ID of the event
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 事件的ID
- en: When you’re done testing the application, stop the process with Ctrl-C.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成应用程序的测试后，使用Ctrl-C停止进程。
- en: Note You can refer to the Spring Cloud Function official documentation for more
    details on how HTTP, CloudEvents, and RSocket are supported ([https://spring.io/projects/spring-cloud-function](https://spring.io/projects/spring-cloud-function)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以参考Spring Cloud Function官方文档以获取有关如何支持HTTP、CloudEvents和RSocket的更多详细信息（[https://spring.io/projects/spring-cloud-function](https://spring.io/projects/spring-cloud-function)）。
- en: '16.2.2 Deployment pipeline: Build and publish'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.2 部署管道：构建和发布
- en: Following the continuous delivery principles and techniques explained throughout
    the book, we can implement a deployment pipeline for Quote Service and Quote Function.
    Since the release candidate for those projects is a container image, most of the
    operations will be the same as for standard JVM applications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循本书中解释的持续交付原则和技术，我们可以为 Quote 服务和 Quote 函数实现一个部署管道。由于这些项目的发布候选是容器镜像，大部分操作将与标准
    JVM 应用程序相同。
- en: When working locally, it’s convenient to run and test serverless applications
    on the JVM rather than using GraalVM due to the shorter build time and the less
    resource-demanding process. However, to achieve better quality and catch errors
    earlier, we should run and verify the applications in native mode as early in
    the delivery process as possible. The commit stage is where we compile and test
    our applications, so it might be a good place to add those additional steps.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当本地工作时，由于构建时间较短且资源需求较低，使用 JVM 运行和测试无服务器应用程序比使用 GraalVM 更方便。然而，为了实现更好的质量和尽早捕捉错误，我们应该尽可能早地在交付过程中以原生模式运行和验证应用程序。提交阶段是我们编译和测试应用程序的地方，因此可能是一个添加这些额外步骤的好地方。
- en: 'In your Quote Function project (quote-function), add a new .github/workflows
    folder, and create a commit-stage.yml file. As a starting point, you can copy
    the implementation of the commit stage from one of the other applications we built
    in the previous chapters, such as Catalog Service. The commit stage workflow we
    have used so far is composed of two jobs: “Build & Test” and “Package and Publish.”
    We’ll reuse the implementation from the other applications, but we’ll add an intermediate
    job responsible for testing the native mode.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Quote 函数项目（quote-function）中，添加一个新的 .github/workflows 文件夹，并创建一个 commit-stage.yml
    文件。作为一个起点，您可以从我们之前章节中构建的其他应用程序中复制提交阶段的实现，例如 Catalog 服务。我们迄今为止使用的提交阶段工作流程由两个作业组成：“构建
    & 测试”和“打包和发布”。我们将重用其他应用程序的实现，但我们将添加一个负责测试原生模式的中间作业。
- en: Listing 16.12 A job to build and test the application in native mode
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.12 构建和测试原生模式应用程序的作业
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Uses the GitHub Container Registry
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 GitHub 容器注册库
- en: ❷ The name of the image. Remember to add your GitHub username, all in lowercase.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 镜像的名称。请记住，将您的 GitHub 用户名全部转换为小写。
- en: ❸ For simplicity, any new image will be tagged as “latest.”
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为了简单起见，任何新的镜像都将标记为“latest。”
- en: ❹ The job unique identifier
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 作业的唯一标识符
- en: ❺ A human-friendly name for the job
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 作业的人类友好名称
- en: ❻ The type of machine where the job will run
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 作业将运行的机器类型
- en: ❼ The permissions granted to the job
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 授予作业的权限
- en: ❽ Permission to check out the current Git repository
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 检出当前 Git 仓库的权限
- en: ❾ Checks out the current Git repository (quote-function)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 检出当前 Git 仓库（quote-function）
- en: ❿ Installs and configures GraalVM with Java 17 and the native image component
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 安装和配置 GraalVM，使用 Java 17 和原生镜像组件
- en: ⓫ Compiles the application as a native executable and runs unit and integration
    tests
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 将应用程序编译为原生可执行文件并运行单元和集成测试
- en: ⓬ The “Package and Publish” job runs only if both of the previous jobs complete
    successfully.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 只有在之前的两个作业都成功完成后，“打包和发布”作业才会运行。
- en: Note In the source code repository accompanying the book, you can check the
    final result in the Chapter16/16-end/quote-function folder.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本书附带的源代码仓库中，您可以在 Chapter16/16-end/quote-function 文件夹中检查最终结果。
- en: When you’re done, commit all your changes and push them to your GitHub quote-function
    repository to trigger the commit stage workflow. We’re going to use the container
    image published by that workflow later in the chapter, so make sure it runs successfully.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，提交所有更改并将它们推送到您的 GitHub quote-function 仓库以触发提交阶段工作流程。我们将在本章后面使用该工作流程发布的容器镜像，所以请确保它运行成功。
- en: You’ll notice that the commit stage execution for Quote Function takes quite
    a bit longer than for the other applications throughout the book. In chapter 3
    I wrote that the commit stage is supposed to be fast, possibly under five minutes,
    to provide developers with fast feedback about their changes and allow them to
    move on to the next task, in the spirit of continuous integration. The additional
    steps using GraalVM that we have just added might slow down the workflow too much.
    In that case, you might consider moving this check to the acceptance stage, where
    we allow the overall process to take longer.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 Quote Function 的提交阶段执行时间比本书中其他应用程序的执行时间要长得多。在第 3 章中，我写道提交阶段应该是快速的，可能不到五分钟，以便为开发者提供关于他们更改的快速反馈，并允许他们继续进行下一项任务，这与持续集成的精神相符。我们刚刚添加的
    GraalVM 的额外步骤可能会使工作流程变得过于缓慢。在这种情况下，你可能考虑将此检查移至验收阶段，在那里我们允许整个过程运行得更长。
- en: The following section will cover some options for deploying serverless applications
    implemented with Spring Cloud Function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍使用 Spring Cloud Function 实现的无服务器应用程序的一些部署选项。
- en: 16.2.3 Deploying serverless applications on the cloud
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.3 在云上部署无服务器应用程序
- en: Applications using Spring Cloud Function can be deployed in a few different
    ways. First of all, since they’re still Spring Boot applications, you can package
    them as JAR artifacts or container images and deploy them on servers or container
    runtimes like Docker or Kubernetes, respectively, just like you did in the previous
    chapters.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Function 的应用程序可以以几种不同的方式部署。首先，由于它们仍然是 Spring Boot 应用程序，你可以将它们打包成
    JAR 艺术品或容器镜像，并分别部署到服务器或 Docker 或 Kubernetes 等容器运行时上，就像你在前面的章节中所做的那样。
- en: Then, when Spring Native is included, you also have the option to compile them
    to native images and run them on servers or container runtimes. Thanks to instant
    startup time and reduced memory consumption, you can also seamlessly deploy such
    applications on serverless platforms. The next section covers how to use Knative
    to run your serverless workloads on Kubernetes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当包含 Spring Native 时，你还可以选择将它们编译成原生镜像并在服务器或容器运行时上运行。得益于即时启动时间和减少的内存消耗，你还可以无缝地将此类应用程序部署到无服务器平台上。下一节将介绍如何使用
    Knative 在 Kubernetes 上运行你的无服务器工作负载。
- en: Spring Cloud Function also supports deploying applications on vendor-specific
    FaaS platforms like AWS Lambda, Azure Functions, and Google Cloud Functions. Once
    you choose a platform, you can add the related adapter provided by the framework
    to accomplish the integration. Each adapter works in a slightly different way,
    depending on the specific platform and the configuration required to integrate
    the functions with the underlying infrastructure. The adapters provided by Spring
    Cloud Function don’t require any changes to your business logic, but they might
    need some additional code to configure the integration.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Function 还支持在 AWS Lambda、Azure Functions 和 Google Cloud Functions
    等特定供应商的 FaaS 平台上部署应用程序。一旦选择了一个平台，你就可以添加框架提供的相关适配器以完成集成。每个适配器的工作方式略有不同，具体取决于特定平台以及将函数与底层基础设施集成所需的配置。Spring
    Cloud Function 提供的适配器不需要对您的业务逻辑进行任何更改，但可能需要一些额外的代码来配置集成。
- en: When you use one of those adapters, you must choose which function to integrate
    with the platform. If there’s only one function registered as a bean, that’s the
    one used. If there are more (like in Quote Function), you need to use the spring.cloud
    .function.definition property to declare which function the FaaS platform will
    manage.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这些适配器之一时，你必须选择要集成到平台中的哪个函数。如果只有一个函数注册为 bean，那么就使用这个函数。如果有多个（例如在 Quote Function
    中），你需要使用 `spring.cloud .function.definition` 属性来声明 FaaS 平台将管理的函数。
- en: Note You can refer to the Spring Cloud Function official documentation for more
    details on the Spring Cloud Function adapters for AWS Lambda, Azure Functions,
    and Google Cloud Functions ([https://spring.io/projects/spring-cloud-function](https://spring.io/projects/spring-cloud-function)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以参考 Spring Cloud Function 的官方文档，了解更多关于 AWS Lambda、Azure Functions 和 Google
    Cloud Functions 的 Spring Cloud Function 适配器的详细信息（[https://spring.io/projects/spring-cloud-function](https://spring.io/projects/spring-cloud-function)）。
- en: The following section will cover deploying a serverless application like Quote
    Function on a Kubernetes-based platform using Knative.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍如何在基于 Kubernetes 的平台上使用 Knative 部署类似于 Quote Function 的无服务器应用程序。
- en: 16.3 Deploying serverless applications with Knative
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 使用 Knative 部署无服务器应用程序
- en: In the previous sections, you learned about Spring Native and how to use it
    with Spring Cloud Function to build serverless applications. This section will
    guide you through deploying Quote Function to a serverless platform on top of
    Kubernetes, using the Knative project.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了Spring Native及其如何与Spring Cloud Function一起使用来构建无服务器应用程序。本节将指导你如何使用Knative项目将Quote
    Function部署到Kubernetes之上的无服务器平台。
- en: Knative is a “Kubernetes-based platform to deploy and manage modern serverless
    workloads” ([https://knative.dev](https://knative.dev)). It’s a CNCF project that
    you can use to deploy standard containerized workloads and event-driven applications.
    The project offers a superior user experience to developers and higher abstractions
    that make it simpler to deploy applications on Kubernetes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Knative是一个“基于Kubernetes的用于部署和管理现代无服务器工作负载的平台”([https://knative.dev](https://knative.dev))。它是一个CNCF项目，你可以用它来部署标准容器化工作负载和事件驱动的应用程序。该项目为开发者提供了卓越的用户体验，以及更高的抽象层次，使得在Kubernetes上部署应用程序变得更加简单。
- en: You can decide to run your own Knative platform on top of a Kubernetes cluster
    or choose a managed service offered by a cloud provider, such as VMware Tanzu
    Application Platform, Google Cloud Run, or Red Hat OpenShift Serverless. Since
    they are all based on open source software and standards, you could migrate from
    Google Cloud Run to VMware Tanzu Application Platform without changing your application
    code and with minimal changes to your deployment pipeline.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择在自己的Kubernetes集群上运行自己的Knative平台，或者选择云提供商提供的托管服务，例如VMware Tanzu Application
    Platform、Google Cloud Run或Red Hat OpenShift Serverless。由于它们都基于开源软件和标准，你可以从Google
    Cloud Run迁移到VMware Tanzu Application Platform，而无需更改应用程序代码，并且对部署管道的更改最小。
- en: 'The Knative project consists of two main components: Serving and Eventing.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Knative项目由两个主要组件组成：Serving和Eventing。
- en: '*Knative Serving* is for running serverless workloads on Kubernetes. It takes
    care of autoscaling, networking, revisions, and deployment strategies while letting
    engineers focus on the application business logic.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Knative Serving*用于在Kubernetes上运行无服务器工作负载。它负责自动扩展、网络、修订和部署策略，同时让工程师专注于应用程序的业务逻辑。'
- en: '*Knative Eventing* provides management for integrating applications with event
    sources and sinks based on the CloudEvents specification, abstracting backends
    like RabbitMQ or Kafka.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Knative Eventing*提供了基于CloudEvents规范的应用程序与事件源和接收器集成的管理，抽象了像RabbitMQ或Kafka这样的后端。'
- en: Our focus will be on using Knative Serving to run serverless workloads while
    avoiding vendor lock-in.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重点将在于使用Knative Serving来运行无服务器工作负载，同时避免供应商锁定。
- en: Note Originally, Knative consisted of a third component called “Build” that
    subsequently became a standalone product, renamed Tekton ([https://tekton.dev](https://tekton.dev))
    and donated to the Continuous Delivery Foundation ([https://cd.foundation](https://cd.foundation)).
    Tekton is a Kubernetes-native framework for building deployment pipelines that
    support continuous delivery. For example, you could use Tekton instead of GitHub
    Actions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：最初，Knative由一个名为“Build”的第三个组件组成，后来成为了一个独立的产品，更名为Tekton ([https://tekton.dev](https://tekton.dev))，并捐赠给了Continuous
    Delivery Foundation ([https://cd.foundation](https://cd.foundation))。Tekton是一个支持持续交付的Kubernetes原生框架，用于构建部署管道。例如，你可以使用Tekton代替GitHub
    Actions。
- en: This section will show you how to set up a local development environment comprising
    both Kubernetes and Knative. Then I’ll introduce Knative manifests, which you
    can use to declare the desired state for serverless applications, and I’ll show
    you how to apply them to a Kubernetes cluster.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示如何设置一个包含Kubernetes和Knative的本地开发环境。然后我将介绍Knative清单，你可以使用它来声明无服务器应用程序的期望状态，并展示如何将它们应用到Kubernetes集群中。
- en: 16.3.1 Setting up a local Knative platform
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.1 设置本地Knative平台
- en: 'Since Knative runs on top of Kubernetes, we first need a cluster. Let’s create
    one with minikube following the same approach we’ve used throughout the book.
    Open a Terminal window and run the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Knative运行在Kubernetes之上，我们首先需要一个集群。让我们按照本书中一直使用的方法使用minikube创建一个集群。打开一个终端窗口并运行以下命令：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we can install Knative. For simplicity, I have collected the necessary
    commands in a script that you’ll find in the source code repository accompanying
    the book. From the Chapter16/16-end/polar-deployment/kubernetes/development folder,
    copy the install-knative.sh file to the same path in your Polar Deployment repository
    (polar-deployment).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以安装 Knative。为了简单起见，我已经将必要的命令收集到一个脚本中，您可以在本书附带的源代码仓库中找到它。从 Chapter16/16-end/polar-deployment/kubernetes/development
    文件夹中，将 install-knative.sh 文件复制到 Polar Deployment 仓库（polar-deployment）中的相同路径。
- en: 'Then open a Terminal window, navigate to the folder where you just copied the
    script, and run the following command to install Knative on your local Kubernetes
    cluster:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开一个终端窗口，导航到您刚刚复制脚本的文件夹，并运行以下命令以在您的本地 Kubernetes 集群上安装 Knative：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Feel free to open the file and look at the instructions before running it. You
    can find more information about installing Knative on the project website ([https://knative.dev/docs/install](https://knative.dev/docs/install)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行它之前，您可以自由打开文件并查看说明。有关在项目网站上安装 Knative 的更多信息，请参阅（[https://knative.dev/docs/install](https://knative.dev/docs/install)）。
- en: Note On macOS and Linux, you might need to make the script executable via the
    chmod +x install-knative.sh command.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在 macOS 和 Linux 上，您可能需要通过 chmod +x install-knative.sh 命令使脚本可执行。
- en: The Knative project provides a convenient CLI tool that you can use to interact
    with Knative resources in a Kubernetes cluster. You can find instructions on how
    to install it in section A.4 of appendix A. In the next section I’ll show you
    how to deploy Quote Function using the Knative CLI.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 项目提供了一个方便的 CLI 工具，您可以使用它与 Kubernetes 集群中的 Knative 资源进行交互。您可以在附录 A 的
    A.4 节中找到如何安装它的说明。在下一节中，我将向您展示如何使用 Knative CLI 部署 Quote Function。
- en: 16.3.2 Deploying applications with the Knative CLI
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.2 使用 Knative CLI 部署应用程序
- en: Knative provides a few different options for deploying applications. In production,
    we’ll want to stick to a declarative configuration as we did for standard Kubernetes
    deployments and rely on a GitOps flow to reconcile the desired state (in a Git
    repository) and actual state (in the Kubernetes cluster).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 提供了多种部署应用程序的选项。在生产环境中，我们将坚持使用声明式配置，就像我们为标准 Kubernetes 部署所做的那样，并依赖于 GitOps
    流来协调所需状态（在 Git 仓库中）和实际状态（在 Kubernetes 集群中）。
- en: 'When experimenting or working locally, we can also take advantage of the Knative
    CLI to deploy applications in an imperative way. From a Terminal window, run the
    following command to deploy Quote Function. The container image is the one published
    by the commit stage workflow we defined before. Remember to replace <your_ github_username>
    with your GitHub username in lowercase:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行实验或本地工作时，我们还可以利用 Knative CLI 以命令式方式部署应用程序。从终端窗口运行以下命令以部署 Quote Function。容器镜像是我们之前定义的提交阶段工作流发布的。请记住将
    <your_github_username> 替换为您的小写 GitHub 用户名：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can refer to figure 16.3 for a description of the command.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考图 16.3 了解该命令的描述。
- en: '![16-03](../Images/16-03.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![16-03](../Images/16-03.png)'
- en: Figure 16.3 The Knative command for creating a Service from a container image.
    Knative will take care of creating all the resources necessary to deploy the applications
    on Kubernetes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 从容器镜像创建服务的 Knative 命令。Knative 将负责创建在 Kubernetes 上部署应用程序所需的所有资源。
- en: 'The command will initialize a new quote-function service in the default namespace
    on Kubernetes. It will return the public URL through which the application is
    exposed, in a message like the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在 Kubernetes 的默认命名空间中初始化一个新的 quote-function 服务。它将通过类似以下的消息返回应用程序公开的公共 URL：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s test it out! First we need to open a tunnel to the cluster with minikube.
    The first time you run this command, you might be asked to input your machine
    password to authorize the tunneling to the cluster:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下！首先，我们需要使用 minikube 打开到集群的隧道。您第一次运行此命令时，可能会被要求输入您的机器密码以授权隧道到集群：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then open a new Terminal window and call the application at the root endpoint
    to fetch the complete list of quotes. The URL to call is the same one returned
    by the previous command (http:/ /quote-function.default.127.0.0.1.sslip.io), which
    is in the format <service-name>.<namespace>.<domain>:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开一个新的终端窗口，在根端点调用应用程序以获取引用的完整列表。要调用的 URL 与之前命令返回的相同（http:/ /quote-function.default.127.0.0.1.sslip.io），其格式为
    <service-name>.<namespace>.<domain>：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since we are working locally, I configured Knative to use sslip.io, a DNS service
    that “when queried with a hostname with an embedded IP address, returns that IP
    address.” For example, the 127.0.0.1.sslip.io hostname would be resolved to the
    127.0.0.1 IP address. Since we opened a tunnel to the cluster, requests to 127.0.0.1
    will be handled by the cluster, where Knative will route them to the right service.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本地工作，我已将 Knative 配置为使用 sslip.io，这是一个 DNS 服务，其功能是“当查询包含嵌入式 IP 地址的主机名时，返回该
    IP 地址”。例如，127.0.0.1.sslip.io 主机名将被解析为 127.0.0.1 IP 地址。由于我们已经向集群打开了隧道，对 127.0.0.1
    的请求将由集群处理，Knative 将将它们路由到正确的服务。
- en: Knative takes care of scaling the application without any further configuration.
    For each request, it determines whether more instances are required. When an instance
    stays idle for a specific time period (30 seconds, by default), Knative will shut
    it down. If no request is received for more than 30 seconds, Knative will scale
    the application to zero, meaning there will be no instances of Quote Function
    running.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 会自动处理应用程序的扩展，无需进一步配置。对于每个请求，它都会确定是否需要更多实例。当一个实例空闲一段时间（默认为 30 秒）后，Knative
    将关闭它。如果超过 30 秒没有收到请求，Knative 将将应用程序扩展到零，这意味着不会有 Quote Function 的实例在运行。
- en: When a new request is eventually received, Knative starts a new instance and
    uses it to handle the request. Thanks to Spring Native, the startup time of Quote
    Function is almost instantaneous, so users and clients won’t have to deal with
    long wait times, as would be the case with standard JVM applications. This powerful
    feature lets you optimize costs and pay only for what you use and need.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当最终收到新的请求时，Knative 会启动一个新的实例并使用它来处理请求。得益于 Spring Native，Quote Function 的启动时间几乎是瞬间的，因此用户和客户端不需要处理长时间的等待，就像标准
    JVM 应用程序那样。这个强大的功能让您能够优化成本，只为您使用和需要的东西付费。
- en: Using an open source platform like Knative has the advantage of letting you
    migrate your applications to another cloud provider without any code changes.
    But that’s not all! You can even use the same deployment pipeline as-is, or with
    minor modifications. The next section will show you how to define Knative Services
    in a declarative way via YAML manifests, which is the recommended approach for
    production scenarios.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Knative 这样的开源平台的优势在于，您可以无需代码更改就将应用程序迁移到另一个云服务提供商。但这还不是全部！您甚至可以使用现有的部署管道，或者进行一些小的修改。下一节将向您展示如何通过
    YAML 清单以声明方式定义 Knative 服务，这是生产场景中推荐的方法。
- en: 'Before moving on, make sure you have deleted the Quote Function instance you
    created previously:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您已删除之前创建的 Quote Function 实例：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 16.3.3 Deploying applications with the Knative manifests
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.3 使用 Knative 清单部署应用程序
- en: Kubernetes is an extensible system. Besides using built-in objects like Deployments
    and Pods, we can define our own objects via Custom Resource Definitions (CRDs).
    That is the strategy used by many tools built on top of Kubernetes, including
    Knative.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个可扩展的系统。除了使用内置对象如 Deployments 和 Pods 之外，我们还可以通过自定义资源定义（CRDs）来定义自己的对象。这正是许多基于
    Kubernetes 构建的工具，包括 Knative 所使用的策略。
- en: 'One of the benefits of using Knative is a better developer experience and the
    possibility to declare the desired state for our applications in a more straightforward
    and less verbose way. Rather than dealing with Deployments, Services, and Ingresses,
    we can work with a single type of resource: the Knative Service.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Knative 的一个好处是更好的开发者体验，以及以更简单、更简洁的方式声明我们应用程序的期望状态。我们不必处理 Deployments、Services
    和 Ingresses，而可以与单一类型的资源一起工作：Knative 服务。
- en: 'Note Throughout the book, I talked about applications as *services*. Knative
    offers a way to model an application in a single resource declaration: the Knative
    Service. At first, the naming might not be very clear, since there is already
    a Kubernetes built-in Service type. In reality, the Knative choice is very intuitive
    because it maps one-to-one the architectural concept with the deployment concept.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本书中，我始终将应用程序称为 *服务*。Knative 提供了一种在单个资源声明中建模应用程序的方法：Knative 服务。起初，命名可能不是很清晰，因为
    Kubernetes 已经有一个内置的服务类型。实际上，Knative 的选择非常直观，因为它将架构概念与部署概念一一对应。
- en: Let’s see what Knative Services look like. Open your Quote Function project
    (quote-function), and create a new “knative” folder. Then, define a new kservice.yml
    file inside to declare the desired state of the Knative Service for Quote Function.
    Remember to replace <your_github_username> with your GitHub username in lowercase.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Knative 服务是什么样的。打开你的 Quote Function 项目（quote-function），创建一个新的“knative”文件夹。然后，在内部定义一个新的
    kservice.yml 文件来声明 Quote Function 的 Knative 服务所需的状态。请记住用你的 GitHub 用户名的小写形式替换 <your_github_username>。
- en: Listing 16.13 Knative Service manifest for Quote Function
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.13 Quote Function 的 Knative 服务清单
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ The API version for Knative Serving objects
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Knative Serving 对象的 API 版本
- en: ❷ The type of object to create
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 要创建的对象类型
- en: ❸ The name of the Service
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 服务的名称
- en: ❹ The name of the container
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 容器的名称
- en: ❺ The image used to run the container. Remember to insert your GitHub username.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 运行容器的镜像。请记住插入你的 GitHub 用户名。
- en: ❻ The port exposed by the container
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 容器暴露的端口
- en: ❼ CPU and memory configuration for the container
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 容器的 CPU 和内存配置
- en: Like any other Kubernetes resource, you can apply a Knative Service manifest
    to a cluster with kubectl apply -f <manifest-file> or through an automated flow
    like we did with Argo CD in the previous chapter. For this example, we’ll use
    the Kubernetes CLI.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他 Kubernetes 资源一样，你可以使用 kubectl apply -f <manifest-file> 或通过像我们在上一章中与 Argo
    CD 一起做的自动化流程将 Knative 服务清单应用到集群中。对于这个例子，我们将使用 Kubernetes CLI。
- en: 'Open a Terminal window, navigate to your Quote Function project (quote-function),
    and run the following command to deploy Quote Function from the Knative Service
    manifest:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到你的 Quote Function 项目（quote-function），并运行以下命令从 Knative 服务清单部署 Quote
    Function：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using the Kubernetes CLI, you can get information about all the created Knative
    Services and their URLs by running the following command (the result displayed
    is partial, to fit on the page):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes CLI，你可以通过运行以下命令来获取所有创建的 Knative 服务及其 URL 的信息（显示的结果是部分，以适应页面）：
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s verify that the application is correctly deployed by sending an HTTP
    request to its root endpoint. If the tunnel you opened earlier is not active anymore,
    run minikube tunnel --profile knative before calling the application:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向其根端点发送 HTTP 请求来验证应用程序是否正确部署。如果你之前打开的隧道不再活跃，请在调用应用程序之前运行 minikube tunnel
    --profile knative：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Knative provides an abstraction on top of Kubernetes. However, it still runs
    Deployments, ReplicaSets, Pods, Services, and Ingresses under the hood. This means
    you can use all the techniques you learned in the previous chapters. For example,
    you can configure Quote Function through ConfigMaps and Secrets:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 在 Kubernetes 之上提供了一个抽象层。然而，它仍然在底层运行 Deployments、ReplicaSets、Pods、Services
    和 Ingresses。这意味着你可以使用你在前几章中学到的所有技术。例如，你可以通过 ConfigMaps 和 Secrets 配置 Quote Function：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you wait for 30 seconds and then check for the running Pods in your local
    Kubernetes cluster, you’ll see there are none, because Knative scaled the application
    to zero due to inactivity:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待 30 秒后检查你本地 Kubernetes 集群中的运行中的 Pods，你会发现没有，因为 Knative 由于不活跃而将应用程序缩放到零：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now try sending a new request to the application on http http://quote-function.default.127.0.0.1.sslip.io.
    Knative will immediately spin up a new Pod for Quote Function to answer the request:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试向 http://quote-function.default.127.0.0.1.sslip.io 发送一个新的请求。Knative 将立即启动一个新的
    Pod 来处理 Quote Function 的请求：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When you’re done testing the application, you can remove it with kubectl delete
    -f knative/kservice.yml. Finally, you can stop and delete the local cluster with
    the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成应用程序的测试后，你可以使用 kubectl delete -f knative/kservice.yml 删除它。最后，你可以使用以下命令停止并删除本地集群：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Knative Service resource represents an application service in its entirety.
    Thanks to this abstraction, we no longer need to deal directly with Deployments,
    Services, and Ingresses. Knative takes care of all that. It creates and manages
    them under the hood while freeing us from dealing with those lower-level resources
    provided by Kubernetes. By default, Knative can even expose an application outside
    the cluster without the need to configure an Ingress resource, providing you directly
    with a URL to call the application.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 服务资源代表了一个应用程序服务的整体。多亏了这个抽象，我们不再需要直接处理 Deployments、Services 和 Ingresses。Knative
    负责所有这些。它在底层创建和管理它们，同时让我们摆脱处理 Kubernetes 提供的底层资源。默认情况下，Knative 甚至可以在不配置 Ingress
    资源的情况下将应用程序暴露在集群之外，直接为你提供调用应用程序的 URL。
- en: 'Thanks to its features focused on developer experience and productivity, Knative
    can be used to run and manage any kind of workload on Kubernetes, limiting its
    scale-to-zero functionality only to the applications that provide support for
    it (for example, using Spring Native). We could easily run the entire Polar Bookshop
    system on Knative. We could use the autoscaling.knative.dev/minScale annotation
    to mark the applications we don’t want to be scaled to zero:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了其专注于开发者体验和生产力的功能，Knative可以用于在Kubernetes上运行和管理任何类型的工作负载，仅将零扩展功能限制为支持该功能的应用程序（例如，使用Spring
    Native）。我们可以在Knative上轻松运行整个Polar Bookshop系统。我们可以使用autoscaling.knative.dev/minScale注解来标记我们不希望扩展到零的应用程序：
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Ensures this Service is never scaled to zero
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确保此服务永远不会扩展到零
- en: Knative offers such a great developer experience that it’s becoming the de facto
    abstraction when deploying workloads on Kubernetes, not only for serverless but
    also for more standard containerized applications. Whenever I provision a new
    Kubernetes cluster, Knative is the first thing I install. It’s also a foundational
    part of platforms like Tanzu Community Edition, Tanzu Application Platform, Red
    Hat OpenShift, and Google Cloud Run.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Knative提供了如此出色的开发者体验，以至于它正在成为在Kubernetes上部署工作负载的事实上的抽象，不仅适用于无服务器，也适用于更标准的容器化应用程序。每次我配置一个新的Kubernetes集群时，我都会首先安装Knative。它也是Tanzu
    Community Edition、Tanzu Application Platform、Red Hat OpenShift和Google Cloud Run等平台的基础部分。
- en: Note Tanzu Community Edition ([https://tanzucommunityedition.io](https://tanzucommunityedition.io))
    is a Kubernetes platform that provides a great developer experience on top of
    Knative. It’s open source and free to use.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Tanzu Community Edition ([https://tanzucommunityedition.io](https://tanzucommunityedition.io))
    是一个在Knative之上提供出色开发者体验的Kubernetes平台。它是开源的，并且免费使用。
- en: Another great feature offered by Knative is an intuitive and developer-friendly
    option for adopting deployment strategies like blue/green deployments, canary
    deployments, or A/B deployments, all via the same Knative Service resource. Implementing
    those strategies in plain Kubernetes would require a lot of manual work. Instead,
    Knative supports them out of the box.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Knative提供的另一个伟大功能是，它提供了一个直观且对开发者友好的选项，用于采用部署策略，如蓝绿部署、金丝雀部署或A/B测试部署，所有这些都可以通过相同的Knative
    Service资源来实现。在纯Kubernetes中实现这些策略需要大量的手动工作。相反，Knative支持这些功能开箱即用。
- en: 'Note To get more information about serverless applications and Knative, you
    can refer to the official documentation ([https://knative.dev](https://knative.dev)).
    Also, I recommend checking out a couple of books from the Manning catalog on this
    subject: *Knative in Action* by Jacques Chester (Manning, 2021; [https://www.manning
    .com/books/knative-in-action](https://www.manning.com/books/knative-in-action))
    and *Continuous Delivery for Kubernetes* by Mauricio Salatino ([www.manning.com/books/continuous-delivery-for-kubernetes](http://www.manning.com/books/continuous-delivery-for-kubernetes)).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要获取有关无服务器应用程序和Knative的更多信息，您可以参考官方文档([https://knative.dev](https://knative.dev))。此外，我建议您查看Manning目录中关于此主题的一些书籍：Jacques
    Chester的《Knative in Action》（Manning，2021；[https://www.manning.com/books/knative-in-action](https://www.manning.com/books/knative-in-action)）和Mauricio
    Salatino的《Continuous Delivery for Kubernetes》（[www.manning.com/books/continuous-delivery-for-kubernetes](http://www.manning.com/books/continuous-delivery-for-kubernetes)）。
- en: Polar Labs
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Labs
- en: Feel free to apply what you learned in the last sections to Quote Service.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 随意将上一节学到的内容应用到Quote服务上。
- en: Define a commit stage workflow, including the steps for compiling and testing
    the application as a native executable.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个提交阶段工作流程，包括编译和测试应用程序作为原生可执行文件所需的步骤。
- en: Push your changes to GitHub, and ensure that the workflow completes successfully
    and publishes a container image for your application.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的更改推送到GitHub，并确保工作流程成功完成并发布您的应用程序的容器镜像。
- en: Deploy Quote Service on Kubernetes via the Knative CLI.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Knative CLI在Kubernetes上部署Quote服务。
- en: Deploy Quote Service on Kubernetes via the Kubernetes CLI from a Knative Service
    manifest.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Knative Service清单使用Kubernetes CLI在Kubernetes上部署Quote服务。
- en: You can refer to the Chapter16/16-end folder in the code repository accompanying
    the book to check the final result ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考书中附带的代码存储库中的Chapter16/16-end文件夹，以检查最终结果([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: By replacing a standard OpenJDK distribution with GraalVM as the runtime environment
    for your Java applications, you can increase their performance and efficiency,
    thanks to a new optimized technology for performing JIT compilation (the GraalVM
    compiler).
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 GraalVM 作为 Java 应用程序的运行环境替换标准 OpenJDK 发行版，您可以通过新的优化 JIT（即时编译）技术（GraalVM
    编译器）来提高它们的性能和效率。
- en: What makes GraalVM so innovative and popular in the serverless context is the
    Native Image mode.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 GraalVM 在无服务器环境中如此创新和受欢迎的是其原生镜像模式。
- en: Rather than compiling your Java code into bytecode and relying on a JVM to interpret
    it and convert it to machine code at runtime, GraalVM offers a new technology
    (the Native Image builder) to compile Java applications directly into machine
    code, obtaining a native executable or native image.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与将 Java 代码编译成字节码并依赖于 JVM 在运行时解释它并将其转换为机器码不同，GraalVM 提供了一种新技术（原生镜像构建器），可以将 Java
    应用程序直接编译成机器码，从而获得原生可执行文件或原生镜像。
- en: Java applications compiled as native images have faster startup times, optimized
    memory consumption, and instant peak performance, unlike the JVM options.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为原生镜像编译的 Java 应用程序具有更快的启动时间、优化的内存消耗和即时峰值性能，这与 JVM 选项不同。
- en: The main goal of Spring Native is to make it possible to compile any Spring
    application into a native executable using GraalVM without any code changes.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Native 的主要目标是使任何 Spring 应用程序都能使用 GraalVM 编译成原生可执行文件，而无需进行任何代码更改。
- en: Spring Native provides an AOT infrastructure (invoked from a dedicated Gradle/
    Maven plugin) for contributing all the required configurations for GraalVM to
    AOT-compile Spring classes.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Native 提供了一个 AOT（Ahead-of-Time）基础设施（通过一个专门的 Gradle/Maven 插件调用），用于向 GraalVM
    提供所有必要的配置以 AOT 编译 Spring 类。
- en: There are two ways to compile your Spring Boot applications into native executables.
    The first option produces an OS-specific executable and runs the application directly
    on a machine. The second option relies on Buildpacks to containerize the native
    executable and run it on a container runtime like Docker.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的 Spring Boot 应用程序编译成原生可执行文件有两种方式。第一种选项生成一个特定操作系统的可执行文件，并在机器上直接运行应用程序。第二种选项依赖于
    Buildpacks 将原生可执行文件容器化，并在像 Docker 这样的容器运行时上运行。
- en: Serverless is a further abstraction layer on top of virtual machines and containers,
    which moves even more responsibility from product teams to the platform.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器是在虚拟机和容器之上的另一个抽象层，它将更多的责任从产品团队转移到平台。
- en: Following the serverless computing model, developers focus on implementing the
    business logic for their applications.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循无服务器计算模型，开发者专注于实现应用程序的业务逻辑。
- en: Serverless applications are triggered by an incoming request or a specific event.
    We call such applications request-driven or event-driven.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器应用程序由一个传入请求或特定事件触发。我们称这样的应用程序为请求驱动或事件驱动。
- en: Applications using Spring Cloud Function can be deployed in a few different
    ways.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Function 的应用程序可以以几种不同的方式部署。
- en: When Spring Native is included, you can also compile applications to native
    images and run them on servers or container runtimes. Thanks to instant startup
    time and reduced memory consumption, you can seamlessly deploy such applications
    on Knative.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当包含 Spring Native 时，您还可以将应用程序编译成原生镜像并在服务器或容器运行时上运行。得益于即时启动时间和减少的内存消耗，您可以在 Knative
    上无缝部署此类应用程序。
- en: Knative is a “Kubernetes-based platform to deploy and manage modern serverless
    workloads” ([https://knative.dev](https://knative.dev)). You can use it to deploy
    standard containerized workloads and event-driven applications.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative 是一个“基于 Kubernetes 的平台，用于部署和管理现代无服务器工作负载”([https://knative.dev](https://knative.dev))。您可以使用它来部署标准容器化工作负载和事件驱动应用程序。
- en: The Knative project offers a superior user experience to developers and higher
    abstractions that make it simpler to deploy applications on Kubernetes.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative 项目为开发者和用户提供了更优越的体验，以及更高的抽象级别，这使得在 Kubernetes 上部署应用程序变得更加简单。
- en: Knative offers such a great developer experience that it’s becoming the de facto
    abstraction when deploying workloads on Kubernetes, not only for serverless but
    also for more standard containerized applications.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative 提供了如此出色的开发者体验，以至于它正在成为在 Kubernetes 上部署工作负载的事实上的抽象，不仅适用于无服务器，也适用于更标准的容器化应用程序。
