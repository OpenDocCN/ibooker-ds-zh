- en: '8 Creating a third-person 3D game: Player movement and animation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 创建第三人称3D游戏：玩家移动和动画
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Adding real-time shadows to the scene
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中添加实时阴影
- en: Making the camera orbit around its target
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使摄像机围绕其目标旋转
- en: Changing rotation smoothly using the lerp algorithm
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lerp算法平滑地改变旋转
- en: Handling ground detection for jumping, ledges, and slopes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理跳跃、边缘和斜坡的地面检测
- en: Applying and controlling animation for a lifelike character
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为逼真的角色应用和控制动画
- en: 'In this chapter, you’ll create another 3D game, but this time you’ll be working
    in a new game genre. In chapter 2, you built a movement demo for a first-person
    game. Now you’re going to write another movement demo, but this time it’ll involve
    third-person movement. The most important difference is the placement of the camera
    relative to the player: a player sees through their character’s eyes in first-person
    view, and the camera is placed *outside* the character in third-person view. This
    view is probably familiar to you from adventure games, like the long-lived *Legend
    of Zelda* series or the more recent *Uncharted* series. (Skip ahead to figure
    8.3 if you want to see a comparison of first-person and third-person views.)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将创建另一个3D游戏，但这次你将进入一个新的游戏类型。在第2章中，你为第一人称游戏构建了一个移动演示。现在你将编写另一个移动演示，但这次将涉及第三人称移动。最重要的区别是摄像机相对于玩家的位置：在第一人称视角中，玩家通过他们的角色视角看到，而在第三人称视角中，摄像机放置在角色*外部*。这种视角可能对你来说很熟悉，比如在冒险游戏中，如长寿的*塞尔达传说*系列或较新的*无主之地*系列。（如果你想看到第一人称和第三人称视角的比较，请跳转到图8.3。）
- en: The project in this chapter is one of the more visually exciting prototypes
    we’ll build in this book. Figure 8.1 shows how the scene will be constructed.
    Compare this with the diagram of the first-person scene we created in chapter
    2 (figure 2.2).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目是我们将在本书中构建的更具视觉吸引力的原型之一。图8.1显示了场景的构建方式。将其与我们在第2章中创建的第一人称场景图（图2.2）进行比较。
- en: '![CH08_F01_Hocking3](../Images/CH08_F01_Hocking3.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F01_Hocking3](../Images/CH08_F01_Hocking3.png)'
- en: Figure 8.1 Road map for the third-person movement demo
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 第三人称移动演示路线图
- en: You can see that the room construction is the same, and the use of scripts is
    much the same. But the look of the player, as well as the placement of the camera,
    are different in each case. Again, what defines this as a third-person view is
    that the camera is outside the player’s character and looking inward at that character.
    You’ll use a model that looks like a humanoid character (rather than a primitive
    capsule) because now players can actually see themselves.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到房间构建是相同的，脚本的使用也大致相同。但玩家的外观以及摄像机的放置在每个情况下都不同。再次强调，将这定义为第三人称视角的是摄像机位于玩家角色外部，并朝向该角色。你将使用一个看起来像人类角色的模型（而不是原始的胶囊），因为现在玩家实际上可以看到自己。
- en: Recall that two of the types of art assets discussed in chapter 4 were 3D models
    and animations. As mentioned in earlier chapters, the term *3D model* is almost
    a synonym for *mesh object*; the 3D model is the static shape defined by vertices
    and polygons (that is, mesh geometry). For a humanoid character, this mesh geometry
    is shaped into a head, arms, legs, and so forth (see figure 8.2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在第4章中讨论的两种艺术资产类型是3D模型和动画。如前几章所述，术语*3D模型*几乎等同于*网格对象*；3D模型是由顶点和多边形定义的静态形状（即网格几何）。对于人类角色，这种网格几何被塑造成头部、手臂、腿部等等（见图8.2）。
- en: '![CH08_F02_Hocking3](../Images/CH08_F02_Hocking3.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F02_Hocking3](../Images/CH08_F02_Hocking3.png)'
- en: Figure 8.2 Wireframe view of the model we’ll use in this chapter
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 本章中我们将使用的模型的线框视图
- en: 'As usual, we’ll focus on the last step in the road map: programming objects
    in the scene. Here’s a recap of our plan of action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将关注路线图中的最后一步：在场景中编程对象。以下是我们行动计划的重述：
- en: Import a character model into the scene.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角色模型导入场景。
- en: Implement camera controls to look at the character.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现摄像机控制以观察角色。
- en: Write a script that enables the player to run around on the ground.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个脚本，使玩家能够在地面上四处奔跑。
- en: Add the ability to jump to the movement script.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将跳跃能力添加到移动脚本中。
- en: Play animations on the model based on its movements.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据模型的活动播放动画。
- en: Copy the project from chapter 2 to modify it, or create a new Unity project
    (be sure it’s set to 3D, not the 2D project from chapter 5) and copy over the
    scene file from chapter 2’s project. Either way, also grab the scratch folder
    from this chapter’s download to get the character model we’ll use.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改它，请从第2章复制项目，或者创建一个新的Unity项目（确保设置为3D，而不是第5章中的2D项目）并将第2章项目中的场景文件复制过来。无论哪种方式，也要从本章下载中获取刮擦文件夹，以获取我们将使用的角色模型。
- en: NOTE You’re going to build this chapter’s project in the walled area from chapter
    2\. You’ll keep the walls and lights but replace the player and all the scripts.
    If you need the sample files, download them from that chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您将在第2章的围墙区域内构建本章的项目。您将保留墙壁和灯光，但替换玩家和所有脚本。如果您需要示例文件，请从该章节下载。
- en: Assuming you’re starting with the completed project from chapter 2 (the movement
    demo, not later projects), let’s delete everything we don’t need for this chapter.
    First, disconnect the camera from the player in the Hierarchy list (drag the camera
    object off the player object). Now delete the player object; if you hadn’t disconnected
    the camera first, that would be deleted too, but what you want is to delete only
    the player capsule and leave the camera. Alternatively, if you already deleted
    the camera by accident, create a new camera object by choosing GameObject > Camera.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您是从第2章的完整项目（动作演示，不是后来的项目）开始的，让我们删除本章不需要的所有内容。首先，在层次列表中从玩家对象断开摄像机的连接（将摄像机对象从玩家对象拖离）。现在删除玩家对象；如果您没有先断开摄像机的连接，那么它也会被删除，但您想要的只是删除玩家胶囊并留下摄像机。或者，如果您不小心删除了摄像机，可以通过选择GameObject
    > Camera创建一个新的摄像机对象。
- en: Delete all the scripts as well (which involves removing the script component
    from the camera and deleting the files in the Project view), leaving only the
    walls, floor, and lights.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 也要删除所有脚本（这涉及到从摄像机中移除脚本组件并在项目视图中删除文件），只留下墙壁、地板和灯光。
- en: 8.1 Adjusting the camera view for third-person
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 调整第三视角的摄像机视图
- en: Before you can write code to make the player move around, you need to put a
    character in the scene and set up the camera to look at that character. You’ll
    import a faceless humanoid model to use as the player character, and then place
    the camera above at an angle to look down at the player obliquely. Figure 8.3
    compares what the scene looks like in first-person view with what the scene will
    look like in third-person view (shown with a few large blocks, which you’ll add
    in this chapter). You’ve prepared the scene already, so now you’ll put a character
    model into the scene.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在您编写代码使玩家移动之前，您需要将一个角色放入场景中并设置摄像机以观察该角色。您将导入一个无脸的人形模型作为玩家角色，然后将摄像机放在上方以角度向下观察玩家。图8.3比较了场景在第一视角下的样子和场景在第三视角下的样子（将在本章中添加一些大块，您将在本章中添加）。您已经准备好了场景，所以现在您将把一个角色模型放入场景中。
- en: '![CH08_F03_Hocking3](../Images/CH08_F03_Hocking3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F03_Hocking3](../Images/CH08_F03_Hocking3.png)'
- en: Figure 8.3 Side-by-side comparison of first-person and third-person views
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 首视角和第三视角的并排比较
- en: 8.1.1 Importing a character to look at
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 导入一个角色进行观察
- en: 'The scratch folder for this chapter’s download includes both the model and
    the texture. As you’ll recall from chapter 4, FBX is the model, and TGA is the
    texture. Import the FBX file into the project: either drag the file into the Project
    view, or right-click in the Project view and select Import New Asset.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章下载的刮擦文件夹包含模型和纹理。正如您从第4章回忆的那样，FBX是模型，TGA是纹理。将FBX文件导入到项目中：要么将文件拖动到项目视图中，要么在项目视图中右键单击并选择导入新资产。
- en: Then look in the Inspector to adjust import settings for the model. Later in
    the chapter, you’ll adjust imported animations, but for now, you need to make
    only a couple of adjustments in the Model and Materials tabs. First, go to the
    Model tab and change the Scale Factor value to 10 (to partially counteract the
    Convert Units value of 0.01) so that the model will be the correct size.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在检查器中调整模型的导入设置。在本章的后面部分，您将调整导入的动画，但到目前为止，您只需要在模型和材质选项卡中进行几个调整。首先，转到模型选项卡并将缩放因子值更改为10（以部分抵消单位转换值0.01），以便模型的大小是正确的。
- en: A bit farther down, you’ll find the Normals option (see figure 8.4). This setting
    controls how lighting and shading appear on the model, using a 3D math concept
    known as, well, *normals*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下方一点，您会找到法线选项（见图8.4）。此设置控制光照和阴影在模型上的显示，使用一个称为“法线”的3D数学概念。
- en: '![CH08_F04_Hocking3](../Images/CH08_F04_Hocking3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F04_Hocking3](../Images/CH08_F04_Hocking3.png)'
- en: Figure 8.4 Import settings for the character model
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 角色模型的导入设置
- en: DEFINITION *Normals* are direction vectors sticking out of polygons that tell
    the computer which direction the polygon is facing. This facing direction is used
    for lighting calculations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 法线是伸出多边形的方向向量，告诉计算机多边形面向哪个方向。这个面向方向用于光照计算。'
- en: The default setting for Normals is Import, which will use the normals defined
    in the imported mesh geometry. But this particular model doesn’t have correctly
    defined normals and will react in odd ways to lights. Instead, change the setting
    to Calculate so that Unity will calculate a vector for the facing direction of
    every polygon. Once you’ve adjusted these settings, click the Apply button in
    the Inspector.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 法线默认设置为导入，这将使用导入的网格几何体中定义的法线。但这个特定的模型没有正确定义的法线，并且会对光线产生奇怪的反应。相反，将设置更改为计算，这样Unity将为每个多边形的面向方向计算一个向量。一旦调整了这些设置，请点击检查器中的应用按钮。
- en: Next, import the TGA file into the project (in order to assign this image as
    the texture on the player’s material). Go to the Materials tab and click the Extract
    Materials button. Extract to whatever location you feel like; then select the
    material that appeared and drag the texture image onto the Albedo texture slot
    in the Inspector. Once the texture is applied, you won’t see a dramatic change
    in the model’s color (this texture image is mostly white), but shadows that are
    painted into the texture will improve the look of the model.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将TGA文件导入到项目中（以便将该图像指定为玩家材质的纹理）。转到材质选项卡，点击提取材质按钮。提取到您觉得合适的任何位置；然后选择出现的材质，将纹理图像拖动到检查器中的Albedo纹理槽中。一旦应用了纹理，您不会在模型的颜色上看到明显的改变（此纹理图像主要是白色），但画入纹理中的阴影将改善模型的外观。
- en: With the texture applied, drag the player model from the Project view up into
    the scene. Position the character at 0, 1.1, 0 so that it’ll be in the center
    of the room and raised up to stand on the floor. We have a third-person character
    in the scene!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应用纹理后，将玩家模型从项目视图拖动到场景中。将角色定位在0, 1.1, 0，这样它就会位于房间的中心并抬起站在地板上。我们在场景中有一个第三人称角色！
- en: NOTE The imported character has arms stuck straight out to each side, rather
    than the more natural arms-down pose. That’s because animations haven’t been applied
    yet; that arms-out position is referred to as the *T-pose*, and the standard is
    for animated characters to default to a T-pose before they’re animated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 导入的角色手臂直直地伸出两侧，而不是更自然的下垂姿势。这是因为还没有应用动画；这种手臂伸出的位置被称为*T-pose*，标准是动画角色在动画之前默认为T-pose。'
- en: 8.1.2 Adding shadows to the scene
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 向场景添加阴影
- en: Before we move on, I want to explain a bit about the shadow being cast by the
    character. We take shadows for granted in the real world, but shadows aren’t guaranteed
    in the game’s virtual world. Fortunately, Unity can handle this detail, and shadows
    are turned on for the default light that comes with new scenes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想简单解释一下角色投射的阴影。在现实世界中，我们理所当然地认为会有阴影，但在游戏的虚拟世界中并不保证有阴影。幸运的是，Unity可以处理这个细节，并且默认场景中的默认灯光已经打开了阴影。
- en: Select the directional light in your scene and then look in the Inspector for
    the Shadow Type option. That setting (figure 8.5) is already on Soft Shadows for
    the default light, but notice that the menu also has a No Shadows option.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的场景中选择方向光，然后在检查器中查找阴影类型选项。该设置（图8.5）对于默认灯光已经是软阴影，但请注意菜单还有一个无阴影选项。
- en: '![CH08_F05_Hocking3](../Images/CH08_F05_Hocking3.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F05_Hocking3](../Images/CH08_F05_Hocking3.png)'
- en: Figure 8.5 Before and after casting shadows from the directional light
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 从方向光投射阴影前后的效果
- en: That’s all you need to do to set up shadows in this project, but there’s a lot
    more you should know about shadows in games. Calculating the shadows in a scene
    is a particularly time-consuming part of computer graphics, so games often cut
    corners and fake things in various ways to achieve the visual look desired.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在这个项目中设置阴影所需做的全部工作，但您还应该了解关于游戏阴影的更多内容。在场景中计算阴影是计算机图形中特别耗时的一部分，因此游戏通常会采取各种捷径来伪造以实现所需的视觉效果。
- en: The kind of shadow cast from the character is referred to as *real-time* shadow
    because the shadow is calculated while the game is running and moves around with
    moving objects. A perfectly realistic lighting setup would have all objects casting
    and receiving shadows in real time, but in order for the shadow calculations to
    run fast enough, the appearance of real-time shadows can be primitive, plus the
    game may even limit which lights cast shadows. Note that only the directional
    light is casting shadows in this scene.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从角色投射出的阴影被称为*实时阴影*，因为阴影是在游戏运行时计算的，并且随着移动对象移动。一个完美的真实照明设置将使所有对象都能实时投射和接收阴影，但为了使阴影计算足够快，实时阴影的外观可能比较原始，而且游戏甚至可能限制哪些灯光可以投射阴影。注意，在这个场景中只有方向光在投射阴影。
- en: Another common way of handling shadows in games is with a technique called *lightmapping*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中处理阴影的另一种常见方法是使用一种称为*光照贴图*的技术。
- en: DEFINITION *Lightmaps* are textures applied to the level geometry, with pictures
    of the shadows baked into the texture image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*光照贴图*是应用于级别几何形状的纹理，其中阴影的图像被烘焙到纹理图像中。
- en: DEFINITION Drawing shadows onto a model’s texture is referred to as *baking*
    the shadows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：将阴影绘制到模型纹理上称为*烘焙阴影*。
- en: Because these images are generated ahead of time (rather than while the game
    is running), they can be very elaborate and realistic. On the downside, because
    the shadows are generated ahead of time, they won’t move. As such, lightmaps are
    great to use for static-level geometry, but not for dynamic objects like characters.
    Lightmaps are generated automatically rather than being painted by hand. The computer
    calculates how the lights in the scene will illuminate the level while subtle
    darkness builds up in corners.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些图像是在游戏运行之前生成的（而不是在游戏运行时），它们可以非常精致和逼真。缺点是，由于阴影是在游戏运行之前生成的，它们不会移动。因此，光照贴图非常适合用于静态级别的几何形状，但不适合像角色这样的动态对象。光照贴图是自动生成的，而不是手工绘制。计算机计算场景中的灯光如何照亮级别，同时在角落中逐渐积累微妙的黑暗。
- en: Whether or not to use real-time shadows or lightmaps isn’t an all-or-nothing
    choice. You can set the Culling Mask property on a light so that real-time shadows
    are used only for certain objects, allowing you to use the higher-quality lightmaps
    for other objects in the scene. Similarly, though you almost always want the main
    character to cast shadows, sometimes you don’t want the character to receive shadows;
    all mesh objects (in either Mesh Renderer or Skinned Mesh Renderer components)
    have settings to cast and receive shadows. Figure 8.6 shows how those settings
    appear when you select the floor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用实时阴影或光照贴图并不是一个非此即彼的选择。你可以设置灯光的剔除遮罩属性，以便仅对某些对象使用实时阴影，这样你就可以为场景中的其他对象使用更高品质的光照贴图。同样，尽管你几乎总是希望主要角色投射阴影，但有时你不想让角色接收阴影；所有网格对象（无论是网格渲染器还是着色网格渲染器组件）都有投射和接收阴影的设置。图8.6显示了当你选择地板时这些设置的外观。
- en: '![CH08_F06_Hocking3](../Images/CH08_F06_Hocking3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F06_Hocking3](../Images/CH08_F06_Hocking3.png)'
- en: Figure 8.6 The Cast Shadows and Receive Shadows settings in the Inspector
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 检查器中的投射阴影和接收阴影设置
- en: DEFINITION *Culling* is a general term for removing unwanted things. The word
    comes up a lot in computer graphics in many contexts, but in this case *culling
    mask* is the set of objects you want to remove from shadow casting.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*剔除*是一个通用的术语，用于移除不需要的东西。这个词在计算机图形学中的许多上下文中都会出现，但在这个情况下，*剔除遮罩*是你想要从阴影投射中移除的对象集合。
- en: All right, now you understand the basics of how to apply shadows to your scenes.
    Lighting and shading a level can be a big topic in itself (books about level editing
    will often spend multiple chapters on lightmapping), but here we’ll restrict ourselves
    to turning on real-time shadows on one light. And with that, let’s turn our attention
    to the camera.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你已经了解了如何将阴影应用到你的场景中的基础知识。照明和着色一个级别本身就是一个很大的话题（关于级别编辑的书籍通常会花费多个章节来讨论光照贴图），但在这里我们将限制自己只在一个灯光上开启实时阴影。有了这个，让我们将注意力转向相机。
- en: 8.1.3 Orbiting the camera around the player character
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 围绕玩家角色旋转相机
- en: In the first-person demo, the camera was linked to the player object in Hierarchy
    view so that they’d rotate together. In third-person movement, though, the player
    character will be facing different directions independently of the camera. Therefore,
    you don’t want to drag the camera onto the player character in the Hierarchy view
    this time. Instead, the camera’s code will move its position along with the character
    but will rotate independently of the character.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一人称演示中，相机在 Hierarchy 视图中链接到玩家对象，以便它们一起旋转。然而，在第三人称移动中，玩家角色将独立于相机面向不同的方向。因此，这次你不想在
    Hierarchy 视图中将相机拖到玩家角色上。相反，相机的代码将随着角色的移动而移动其位置，但将独立于角色旋转。
- en: First, place the camera where you want it to be relative to the player; I went
    with position 0, 3.5, -3.75 to put the camera above and behind the character (reset
    rotation to 0, 0, 0 if needed). Then create a script called OrbitCamera and write
    the code from listing 8.1\. Attach the script component to the camera and then
    drag the player character into the target slot of the script. Now you can play
    the scene to see the camera code in action.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将相机放置到你想要的位置，相对于玩家；我选择了位置 0, 3.5, -3.75 以将相机放置在角色上方和后方（如果需要，重置旋转到 0, 0, 0）。然后创建一个名为
    OrbitCamera 的脚本，并编写列表 8.1 中的代码。将脚本组件附加到相机上，然后将玩家角色拖动到脚本的“目标”槽中。现在你可以播放场景以查看相机代码的实际效果。
- en: Listing 8.1 Camera script for rotating around a target while looking at it
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 旋转并观察目标的相机脚本
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Serialized reference to the object to orbit around
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 序列化引用要围绕旋转的对象
- en: ❷ Store the starting position offset between the camera and the target.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储相机和目标之间的起始位置偏移。
- en: ❸ Either rotate the camera slowly using arrow keys . . .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 可以使用箭头键缓慢旋转相机 . . .
- en: ❹ . . . or rotate quickly with the mouse.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ . . . 或者快速旋转鼠标。
- en: ❺ Maintain the starting offset, shifted according to the camera’s rotation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 维持起始偏移，根据相机的旋转进行偏移。
- en: ❻ No matter where the camera is relative to the target, always face the target.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 无论相机相对于目标的位置如何，始终面向目标。
- en: As you’re reading through the listing, note the serialized variable for target.
    The code needs to know which object to orbit the camera around, so this variable
    is serialized to appear within Unity’s editor and have the player character linked
    to it. The next couple of variables are rotation values that are used in the same
    way as in the camera control code from chapter 2.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读列表时，注意目标的序列化变量。代码需要知道围绕哪个对象旋转相机，因此这个变量被序列化以在 Unity 编辑器中显示，并使玩家角色与其链接。接下来的几个变量是旋转值，它们的使用方式与第
    2 章中的相机控制代码相同。
- en: And an offset value is declared; offset is set within Start() to store the position
    difference between the camera and target. This way, the relative position of the
    camera can be maintained while the script runs. In other words, the camera will
    stay at the initial distance from the character regardless of which way it rotates.
    The remainder of the code is inside the LateUpdate() function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了一个偏移值；在 Start() 中设置偏移以存储相机和目标之间的位置差异。这样，在脚本运行期间可以保持相机的相对位置。换句话说，无论相机如何旋转，它都会保持在角色初始距离的位置。代码的其余部分位于
    LateUpdate() 函数内。
- en: TIP Remember, LateUpdate() is another method provided by Mono-Behaviour and
    it’s similar to Update(); it’s a method run every frame. The difference, as the
    name implies, is that LateUpdate() is called on all objects after Update() has
    run on all objects. This way, you can ensure that the camera updates after the
    target has moved.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：记住，LateUpdate() 是由 Mono-Behaviour 提供的另一种方法，它与 Update() 类似；它是在每一帧运行的方法。正如其名称所暗示的，区别在于
    LateUpdate() 在 Update() 在所有对象上运行之后对所有对象进行调用。这样，你可以确保相机在目标移动之后更新。
- en: First, the code increments the rotation value based on input controls. This
    code looks at two input controls—horizontal arrow keys and horizontal mouse movement—so
    a conditional is used to switch between them. The code checks whether horizontal
    arrow keys are being pressed; if they are, then it uses that input, but if not,
    it checks the mouse. By checking the two inputs separately, the code can rotate
    at different speeds for each type of input.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码根据输入控制增加旋转值。此代码查看两个输入控制——水平箭头键和水平鼠标移动——因此使用条件语句在它们之间切换。代码检查是否按下了水平箭头键；如果是，则使用该输入，如果不是，则检查鼠标。通过分别检查两个输入，代码可以为每种输入类型以不同的速度旋转。
- en: Next, the code positions the camera based on the position of the target and
    the rotation value. The transform.position line is probably the biggest “aha!”
    in this code, because it provides crucial math that you haven’t seen before. Multiplying
    a position vector by a quaternion results in a position that’s shifted over according
    to that rotation (note that the rotation angle was converted to a quaternion by
    using Quaternion.Euler). This rotated position vector is then added as the offset
    from the character’s position to calculate the position for the camera. Figure
    8.7 illustrates the steps of the calculation and provides a detailed breakdown
    of this rather conceptually dense line of code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码根据目标位置和旋转值定位相机。transform.position这一行可能是这段代码中最大的“啊哈！”时刻，因为它提供了你之前没有见过的关键数学。将位置向量乘以四元数会导致根据该旋转进行偏移的位置（注意旋转角度是通过使用Quaternion.Euler转换为四元数的）。然后，这个旋转的位置向量被添加为从角色位置到计算相机位置的偏移。图8.7说明了计算的步骤，并详细解释了这一相当概念密集的代码行。
- en: '![CH08_F07_Hocking3](../Images/CH08_F07_Hocking3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F07_Hocking3](../Images/CH08_F07_Hocking3.png)'
- en: Figure 8.7 The steps for calculating the camera’s position
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 计算相机位置的步骤
- en: NOTE The more mathematically astute among you may be thinking, “Hmm, that transforming-between-coordinate-systems
    thing in chapter 2 . . . can’t I do that here, too?” Yes, you could transform
    the offset position by using a rotated coordinate system to get the rotated offset,
    but that would require setting up the rotated coordinate system first, and it’s
    more straightforward not to need that step.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你们中数学更敏锐的人可能会想，“嗯，第二章中提到的在坐标系之间转换的事情……我难道不能在这里也做吗？”是的，你可以通过使用旋转坐标系来转换偏移位置以获得旋转的偏移，但这需要首先设置旋转坐标系，而且不经过这一步会更直接。
- en: Finally, the code uses the LookAt() method to point the camera at the target;
    this function points one object (not just cameras) at another object. The rotation
    value calculated previously was used to position the camera at the correct angle
    around the target, but in that step the camera was only positioned and not rotated.
    Thus, without the final LookAt() line, the camera position would orbit around
    the character but wouldn’t necessarily be looking at it. Go ahead and comment
    out that line to see what happens.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码使用LookAt()方法将相机指向目标；这个函数将一个对象（不仅仅是相机）指向另一个对象。之前计算出的旋转值被用来在目标周围定位相机，但在那一步中，相机只是定位而没有旋转。因此，如果没有最后的LookAt()行，相机位置将围绕角色旋转，但并不一定指向它。试着注释掉那一行，看看会发生什么。
- en: Cinemachine
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Cinemachine
- en: We just wrote a custom script for controlling the camera. However Unity also
    offers Cinemachine, a suite of tools for advanced camera control. That package
    would be overkill for the straightforward camera behavior in this chapter, but
    for many projects, Cinemachine is well worth experimenting with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写了一个用于控制相机的自定义脚本。然而，Unity还提供了Cinemachine，一套用于高级相机控制的工具。对于本章中简单的相机行为来说，这个包可能有些过度，但对于许多项目来说，Cinemachine非常值得尝试。
- en: Open the Package Manager window (Window > Package Manager) and search the Unity
    Registry for Cinemachine. Read more about it at [http://mng.bz/PXvP](http://mng.bz/PXvP).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 打开包管理器窗口（窗口 > 包管理器），在Unity注册表中搜索Cinemachine。更多信息请参阅[http://mng.bz/PXvP](http://mng.bz/PXvP)。
- en: The camera has its script for orbiting around the player character; next up
    is code that moves the character around.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相机有自己的围绕玩家角色旋转的脚本；接下来是移动角色的代码。
- en: 8.2 Programming camera-relative movement controls
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 编程相机相对移动控制
- en: Now that the character model is imported into Unity and you’ve written code
    to control the camera view, it’s time to program controls for moving around the
    scene. Let’s program camera-relative controls that’ll move the character in various
    directions when arrow keys are pressed, as well as rotate the character to face
    those different directions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在角色模型已经导入Unity，并且你已经编写了控制相机视图的代码，现在是时候编写在场景中移动角色的控制代码了。让我们编写相机相对控制，当按下箭头键时，将角色移动到各个方向，并旋转角色以面对这些不同的方向。
- en: What does “camera-relative” mean?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “相机相对”是什么意思？
- en: 'The whole notion of *camera-relative* is a bit nonobvious but crucial to understand.
    This is similar to the local versus global distinction mentioned in previous chapters:
    “left” points in different directions when you mean “left of the local object”
    or “left of the entire world.” In a similar way, when you “move the character
    to the left,” do you mean toward the character’s left, or the left side of the
    screen?'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*相机相对*这一概念有点不明显，但理解它至关重要。这与前几章中提到的局部与全局的区别类似：“左”指向不同的方向，当你指的是“局部对象的左侧”或“整个世界的左侧”时。以类似的方式，当你“将角色向左移动”时，你是指向角色的左侧，还是屏幕的左侧？'
- en: The camera in a first-person game is placed inside the character and moves with
    it, so no distinction exists between the character’s left and the camera’s left.
    A third-person view places the camera outside the character, though, and thus
    the camera’s left may be pointed in a different direction from the character’s
    left. For example, the directions are literally opposite if the camera is looking
    at the front of the character. As such, you have to decide what you want to have
    happen in your specific game and controls setup.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一人称游戏中，相机位于角色内部并与角色一起移动，因此不存在角色左侧与相机左侧的区别。然而，第三人称视角将相机放置在角色外部，因此相机的左侧可能与角色的左侧指向不同的方向。例如，如果相机面向角色的前方，方向实际上是相反的。因此，你必须决定在你的特定游戏和控制设置中你想发生什么。
- en: Although games occasionally do it the other way, most third-person games make
    their controls camera-relative. When the player presses the left button, the character
    moves to the left of the screen, not the character’s left. Over time and through
    experiments with trying out different control schemes, game designers have figured
    out that players find the controls more intuitive and easier to understand when
    “left” means “left-hand side of the screen” (which, not coincidentally, is also
    the player’s left).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然游戏有时会采取相反的方式，但大多数第三人称游戏使它们的控制与相机相关。当玩家按下左键时，角色移动到屏幕的左侧，而不是角色的左侧。随着时间的推移和通过尝试不同的控制方案进行实验，游戏设计师已经发现，当“左”意味着“屏幕的左侧”（这并非巧合，也是玩家的左侧）时，玩家发现控制更直观且更容易理解。
- en: 'Implementing camera-relative controls involves two primary steps: first rotate
    the player character to face the direction of the controls and then move the character
    forward. Let’s write the code for these two steps next.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相机相对控制涉及两个主要步骤：首先将玩家角色旋转到面向控制方向，然后移动角色。接下来，让我们编写这两个步骤的代码。
- en: 8.2.1 Rotating the character to face movement direction
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 将角色旋转到面向移动方向
- en: First you’ll write code to make the character face in the direction of the arrow
    keys. Create a C# script called RelativeMovement that uses the code from listing
    8.2\. Drag that script onto the player character and then link the camera to the
    target property of the script component (just as you linked the character to the
    target of the camera script). Now the character will face different directions
    when you press the controls, facing directions relative to the camera, or stand
    still when you’re not pressing any arrow keys (that is, when rotating using the
    mouse).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要编写代码使角色面向箭头键的方向。创建一个名为RelativeMovement的C#脚本，使用列表8.2中的代码。将此脚本拖放到玩家角色上，然后将相机链接到脚本的target属性（就像你将角色链接到相机脚本的target一样）。现在，当你按下控制键时，角色将面向不同的方向，面向相对于相机的方向；当你没有按下任何箭头键时（即使用鼠标旋转时），角色将保持静止。
- en: Listing 8.2 Rotating the character relative to the camera
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 相对于相机旋转角色
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This script needs a reference to the object to move relative to.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此脚本需要一个相对于该对象移动的引用。
- en: ❷ Start with vector (0, 0, 0) and add movement components progressively.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从向量（0，0，0）开始，并逐步添加移动分量。
- en: ❶ Handle movement only while arrow keys are pressed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅在按下箭头键时处理移动。
- en: ❸ Calculate the player’s forward direction by using the cross product of the
    target’s right direction.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过使用目标右方向的叉积来计算玩家的前进方向。
- en: ❹ Add together the input in each direction to get the combined movement vector.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将每个方向上的输入相加，以获得组合移动向量。
- en: ❺ LookRotation() calculates a quaternion facing in that direction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ LookRotation()计算一个指向该方向的四元数。
- en: This listing starts the same way listing 8.1 did, with a serialized variable
    for target. Just as the previous script needed a reference to the object it would
    orbit around, this script needs a reference to the object it’ll move relative
    to. Then we get to the Update() function. The first line of the function declares
    a Vector3 value of 0, 0, 0. The remaining code will replace this vector if the
    player is pressing any buttons, but it’s important to have a default value in
    case there isn’t any input.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表与列表8.1以相同的方式开始，有一个用于目标的序列化变量。就像之前的脚本需要一个指向它将围绕其旋转的对象的引用一样，这个脚本需要一个指向它将相对于其移动的对象的引用。然后我们到达Update()函数。函数的第一行声明了一个值为0、0、0的Vector3变量。剩余的代码将在玩家按下任何按钮时替换此向量，但如果没有输入，有一个默认值是很重要的。
- en: Next, check the input controls, just as you have in previous scripts. Here’s
    where X and Z values are set in the movement vector, for horizontal movement around
    the scene. Remember that Input.GetAxis() returns 0 if no button is pressed, and
    it varies between 1 and -1 when those keys are being pressed; putting that value
    in the movement vector sets the movement to the positive or negative direction
    of that axis (the x-axis is left/right, and the z-axis is forward/backward).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查输入控制，就像你在之前的脚本中做的那样。这里设置了在场景中水平移动的X和Z值。记住，Input.GetAxis()在没有按键被按下时返回0，当按键被按下时，它在1和-1之间变化；将此值放入移动向量中，将移动设置为该轴的正方向或负方向（x轴是左右，z轴是前后）。
- en: The next several lines calculate the camera-relative movement vector. Specifically,
    we need to determine the sideways and forward directions to move in. The sideways
    direction is easy; the target transform has a property called right, and that
    will point to the camera’s right because the camera was set as the target object.
    The forward direction is trickier, because the camera is angled forward and down
    into the ground, but we want the character to move around perpendicular to the
    ground. This forward direction can be determined using the cross product.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行代码计算相对于摄像机的移动向量。具体来说，我们需要确定移动的侧向和前方方向。侧向方向很容易；目标变换有一个名为right的属性，这将指向摄像机的右方，因为摄像机被设置为目标对象。前方方向更复杂，因为摄像机向前和向下倾斜进入地面，但我们希望角色在垂直于地面的方向上移动。这个前方方向可以使用叉积来确定。
- en: 'DEFINITION The *cross product* is one kind of mathematical operation that can
    be done on two vectors. Long story short, the cross product of two vectors is
    a new vector pointed perpendicular to both input vectors. Think about the 3D coordinate
    axes: the z—axis is perpendicular to both the x- and y-axes. Don’t confuse cross
    product with dot product; the dot product (explained later in the chapter) is
    a different but also commonly seen vector math operation.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：**叉积**是一种可以对两个向量进行的数学运算。简而言之，两个向量的叉积是一个指向两个输入向量垂直方向的新向量。考虑一下3D坐标轴：z轴垂直于x轴和y轴。不要将叉积与点积混淆；点积（在章节后面解释）是另一种但也很常见的向量数学运算。
- en: In this case, the two input vectors are the right and up directions. Remember
    that we already determined the camera’s right. Meanwhile, Vector3 has several
    shortcut properties for common directions, including the direction pointed straight
    up from the ground. The vector perpendicular to both of those points in the direction
    the camera faces, but aligned perpendicular to the ground.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个输入向量是右方向和上方向。记住，我们已经确定了摄像机的右方向。同时，Vector3有几个用于常见方向的快捷属性，包括从地面直指上方的方向。这个向量垂直于这两个点，并且与地面垂直对齐。
- en: Add the inputs in each direction to get the combined movement vector. The final
    line of code applies that movement direction to the character by converting Vector3
    into a quaternion by using Quaternion.LookRotation() and assigning that value.
    Try running the game now to see what happens!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个方向上的输入相加以获得组合移动向量。最后一行代码通过使用Quaternion.LookRotation()将Vector3转换为四元数，并将该值赋值，将移动方向应用于角色。现在尝试运行游戏，看看会发生什么！
- en: Smoothly rotating (interpolating) by using lerp
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lerp（线性插值）平滑旋转
- en: 'Currently, the character’s rotation snaps instantly to different directions,
    but it’d look better if the character smoothly rotated. You can do so using a
    mathematical operation called *lerp*. First add this variable to the script:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，角色的旋转会瞬间切换到不同方向，但如果角色能够平滑旋转会更好。你可以使用一种称为*lerp*的数学运算来实现这一点。首先将此变量添加到脚本中：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then replace the existing transform.rotation line at the end of listing 8.2
    with the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将列表8.2末尾现有的transform.rotation行替换为以下代码：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, instead of snapping directly to the LookRotation() value, that value is
    used indirectly as the target direction to rotate toward. The Quaternion.Lerp()
    method smoothly changes between the current and target rotations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再直接将LookRotation()的值用于旋转，而是间接地将其作为旋转的目标方向。Quaternion.Lerp()方法在当前旋转和目标旋转之间平滑地变化。
- en: The term for smoothly changing from one value to another is interpolate; you
    can *interpolate* between two of any kind of value, not just rotation values.
    *Lerp* is a quasi-acronym for *linear interpolation*, and Unity provides lerp
    methods for vectors and float values too (to interpolate positions, colors, or
    anything else). Quaternions also have a closely related alternative method for
    interpolation called *slerp* (for *spherical linear interpolation*). For slower
    turns, slerp rotations may look better than lerp.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个值平滑地变化到另一个值的术语是插值；您可以在任何类型的两个值之间进行插值，而不仅仅是旋转值。*Lerp*是*线性插值*的准缩写，Unity还提供了用于向量和float值的lerp方法（用于插值位置、颜色或任何其他内容）。四元数也有一个与之密切相关的插值替代方法，称为*slerp*（用于*球面线性插值*）。对于较慢的转向，slerp旋转可能看起来比lerp更好。
- en: Incidentally, this code uses Lerp() in a somewhat nontraditional way. Normally,
    the third value changes over time, but we are instead keeping the third value
    constant and changing the *first* value. In traditional usage, the start and end
    points are constant, but here we keep moving the start closer to the end, resulting
    in smooth interpolation toward that endpoint. This nontraditional use is explained
    at the Unity Answers website ([http://answers.unity.com/answers/730798/view.html](http://answers.unity.com/answers/730798/view.html)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这段代码以某种非传统的方式使用了Lerp()函数。通常，第三个值会随时间变化，但在这里我们保持第三个值不变，而改变第一个值。在传统用法中，起始点和终点是固定的，但在这里我们保持将起始点逐渐靠近终点，从而实现对该终点的平滑插值。这种非传统用法在Unity
    Answers网站上有所解释（[http://answers.unity.com/answers/730798/view.html](http://answers.unity.com/answers/730798/view.html)）。
- en: Currently, the character is rotating in place without moving; in the next section,
    you’ll add code for moving the character around.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，角色在原地旋转而不移动；在下一节中，您将添加代码以使角色在场景中移动。
- en: NOTE Because moving sideways uses the same keyboard controls as orbiting the
    camera, the character will slowly rotate while the movement direction points sideways.
    This doubling up of the controls is desired behavior in this project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于侧向移动使用与环绕相机相同的键盘控制，当移动方向指向侧面时，角色会缓慢旋转。在这个项目中，这种控制的双重使用是期望的行为。
- en: 8.2.2 Moving forward in that direction
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 向该方向前进
- en: As you’ll recall from chapter 2, in order to move the player around the scene,
    you need to add a character controller component to the player object. Select
    the player and then choose Component > Physics > Character Controller. In the
    Inspector, you should slightly reduce the controller’s radius to 0.4, but otherwise
    the default settings are all fine for this character model. Here’s what you need
    to add in the RelativeMovement script.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从第二章回忆起来，为了在场景中移动玩家，您需要向玩家对象添加一个角色控制器组件。选择玩家，然后选择组件 > 物理 > 角色控制器。在检查器中，您应该略微减小控制器的半径到0.4，但除此之外，默认设置对这个角色模型来说都是合适的。以下是RelativeMovement脚本中您需要添加的内容。
- en: Listing 8.3 Adding code to change the player’s position
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 添加代码以更改玩家的位置
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The surrounding lines are context for placing the RequireComponent() method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 周围的行是放置RequireComponent()方法的上下文。
- en: ❷ A pattern you’ve seen in previous chapters, used for getting access to other
    components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在前面的章节中看到过的模式，用于访问其他组件。
- en: ❸ The facing directions are magnitude 1, so multiply with the desired speed
    value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 面向方向的大小为1，所以需要与期望的速度值相乘。
- en: ❹ Limit diagonal movement to the same speed as movement along an axis.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将对角线移动限制在与轴上移动相同的速度。
- en: ❺ Always multiply movements by deltaTime to make them frame-rate independent.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 总是乘以deltaTime来使移动不受帧率的影响。
- en: If you play the game now, you will see the character (stuck in a T-pose) moving
    around in the scene. Pretty much the entirety of this listing is code you’ve already
    seen, so I’ll review everything briefly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在您玩游戏，您将看到角色（处于T形姿势）在场景中移动。几乎整个列表都是您已经见过的代码，所以我会简要地回顾一下。
- en: First, a RequireComponent attribute is at the top of the code. As explained
    in chapter 2, RequireComponent will force Unity to make sure the GameObject has
    a component of the type passed into the command. This line is optional; you don’t
    have to require it, but without this component, the script will have errors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码顶部有一个 RequireComponent 属性。正如第2章中解释的那样，RequireComponent 将强制Unity确保GameObject具有命令中传入的类型组件。这一行是可选的；你不必要求它，但没有这个组件，脚本将会有错误。
- en: Next, a movement value is declared, followed by getting this script a reference
    to the character controller. As you’ll recall from previous chapters, GetComponent()
    returns other components attached to the given object, and if the object to search
    on isn’t explicitly defined, then it’s assumed to be this.gameObject.GetComponent()
    (the same object as this script).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明一个移动值，然后获取这个脚本的字符控制器引用。如你从前面的章节中回忆的那样，GetComponent() 返回附加到给定对象的其它组件，如果搜索的对象没有明确定义，则假定是
    this.gameObject.GetComponent()（与这个脚本相同的对象）。
- en: Movement values are still assigned based on the input controls, but now you
    also account for the movement speed. Multiply all movement axes by the movement
    speed, and then use Vector3.ClampMagnitude() to limit the vector’s magnitude to
    the movement speed. The clamp is needed because, otherwise, diagonal movement
    would have a greater magnitude than movement directly along an axis (picture the
    sides and hypotenuse of a right triangle).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 移动值仍然基于输入控制分配，但现在你也考虑了移动速度。将所有移动轴乘以移动速度，然后使用 Vector3.ClampMagnitude() 限制向量的幅度为移动速度。限制是必要的，因为否则，对角线移动的幅度将大于沿轴直接移动的幅度（想象一下直角三角形的边和斜边）。
- en: Finally, at the end, you multiply the movement values by deltaTime to get frame
    rate-independent movement (recall that *frame rate-independent* means the character
    moves at the same speed on different computers with different frame rates). Pass
    the movement values to CharacterController.Move() to make the movement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后，你将移动值乘以 deltaTime 以获得与帧率无关的移动（回想一下，*与帧率无关*意味着角色在不同帧率的计算机上以相同的速度移动）。将移动值传递给
    CharacterController.Move() 以进行移动。
- en: This handles all the horizontal movement. Next, let’s take care of vertical
    movement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了所有水平移动。接下来，让我们处理垂直移动。
- en: 8.3 Implementing the jump action
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 实现跳跃动作
- en: In the previous section, you wrote code to make the character run around on
    the ground. In the chapter introduction, I also mentioned making the character
    jump, so let’s do that now. Most third-person games do have a control for jumping.
    And even if they don’t, they almost always have vertical movement from the character
    falling off ledges. Our code will handle both jumping and falling. Specifically,
    this code will have gravity pulling the player down at all times, but occasionally
    an upward jolt will be applied when the player jumps.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你编写了使角色在地面周围跑动的代码。在章节介绍中，我也提到了使角色跳跃，所以现在让我们来做这个。大多数第三人称游戏都有跳跃的控制。即使它们没有，它们几乎总是有角色从边缘掉落时的垂直移动。我们的代码将处理跳跃和坠落。具体来说，此代码将始终有重力将玩家向下拉，但在玩家跳跃时偶尔会施加向上的冲击。
- en: 'Before you write this code, let’s add a few raised platforms to the scene.
    The game currently has nothing to jump on or fall from! Create a couple more cube
    objects, and then modify their positions and scale to give the player platforms
    to jump on. In the sample project, I added two cubes and used these settings:
    Position 5, 0.75, 5 and Scale 4, 1.5, 4; Position 1, 1.5, 5.5, and Scale 4, 3,
    4. Figure 8.8 shows the raised platforms.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此代码之前，让我们在场景中添加一些凸起的平台。游戏目前没有任何可以跳跃或坠落的地方！创建更多几个立方体对象，然后修改它们的位子和缩放，为玩家提供可以跳跃的平台。在示例项目中，我添加了两个立方体，并使用了以下设置：位置
    5, 0.75, 5 和缩放 4, 1.5, 4；位置 1, 1.5, 5.5，和缩放 4, 3, 4。图8.8显示了凸起的平台。
- en: '![CH08_F08_Hocking3](../Images/CH08_F08_Hocking3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F08_Hocking3](../Images/CH08_F08_Hocking3.png)'
- en: Figure 8.8 A couple of raised platforms added to the sparse scene
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 在稀疏的场景中添加的几个凸起的平台
- en: 8.3.1 Applying vertical speed and acceleration
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 应用垂直速度和加速度
- en: As mentioned when you first started writing the RelativeMovement script in listing
    8.2, the movement values are calculated in separate steps and added to the movement
    vector progressively. This listing adds vertical movement to the existing vector.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如在列出8.2中的RelativeMovement脚本首次编写时所述，移动值是在单独的步骤中计算的，并逐步添加到移动向量中。此列表将垂直移动添加到现有的向量中。
- en: Listing 8.4 Adding vertical movement to the RelativeMovement script
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 向RelativeMovement脚本添加垂直移动
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Initialize the vertical speed to the minimum falling speed at the start of
    the existing function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在现有函数的开始处将垂直速度初始化为最小下落速度。
- en: ❷ CharacterController has an isGrounded property to check if the controller
    is on the ground.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ CharacterController具有isGrounded属性，用于检查控制器是否在地面上。
- en: ❸ React to the Jump button while on the ground.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在地面上时响应跳跃按钮。
- en: ❹ If not on the ground, apply gravity until terminal velocity is reached.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果不在地面上，则应用重力，直到达到终端速度。
- en: ❺ This is existing code, simply for reference on where the new code goes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这段代码是现有的代码，仅用于参考新代码放置的位置。
- en: As usual, you start by adding a few new variables to the top of the script for
    various movement values, and initialize the values correctly. Then, you skip down
    to just after the big if statement for horizontal movement, where you’ll add another
    big if statement for vertical movement. Specifically, the code will check whether
    the character is on the ground, because the vertical speed will be adjusted differently
    in each case. CharacterController includes isGrounded for checking whether the
    character is on the ground; this value is true if the bottom of the character
    controller collided with anything in the last frame.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你首先在脚本顶部添加几个新变量以存储各种移动值，并正确初始化这些值。然后，跳到水平移动的大if语句之后，在那里添加另一个大if语句以处理垂直移动。具体来说，代码将检查角色是否在地面上，因为在这种情况下垂直速度的调整会有所不同。CharacterController包括isGrounded属性，用于检查角色是否在地面上；如果角色控制器在上一帧与任何物体发生碰撞，则此值将为true。
- en: If the character is on the ground, the vertical speed value (the private vertSpeed
    variable) should be reset to nothing. The character isn’t falling while on the
    ground, so its vertical speed is 0; if the character then steps off a ledge, you’re
    going to get a nice, natural-looking motion because the falling speed will accelerate
    from nothing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果角色在地面上，垂直速度值（私有变量vertSpeed）应该重置为0。角色在地面上时不会下落，因此其垂直速度为0；如果角色随后从边缘跳下，你会得到一个自然、流畅的动作，因为下落速度将从0开始加速。
- en: NOTE Well, the vertical speed is not *exactly* 0; you’re setting the value to
    minFall, a slight downward movement, so that the character will always be pressing
    down against the ground while running around horizontally. Some downward force
    is required for running up and down on uneven terrain.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：垂直速度并不是**完全**为0；你将值设置为minFall，即轻微的下移，这样角色在水平移动时始终会向下压地面。在起伏不平的地形上上下移动时需要一些向下的力。
- en: The exception to this grounded speed value occurs if the jump button is clicked.
    In that case, the vertical speed should be set to a high number. The if statement
    checks GetButtonDown(), a new input function that works much like GetAxis() does,
    returning the state of the indicated input control. And much like Horizontal and
    Vertical input axes, the exact key assigned to Jump is defined by going to Input
    Manager settings under Edit > Project Settings (the default key assignment is
    Space—that is, the spacebar).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下跳跃按钮，则此地面速度值会有例外。在这种情况下，垂直速度应设置为较高的数值。if语句检查GetButtonDown()，这是一个新的输入函数，其工作方式与GetAxis()类似，返回指定输入控制的状态。并且与水平和垂直输入轴类似，分配给跳跃的确切键可以通过转到“编辑”>“项目设置”下的输入管理器设置来定义（默认键分配是空格键，即空格键）。
- en: Getting back to the larger if condition, if the character is not on the ground,
    then the vertical speed should be constantly reduced by gravity. Note that this
    code doesn’t simply set the speed value but rather decrements it; this way, it’s
    not a constant speed but rather a downward acceleration, resulting in a realistic
    falling movement. Jumping will happen in a natural arc, as the character’s upward
    speed gradually reduces to 0 and it starts falling instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 回到更大的if条件，如果角色不在地面上，那么垂直速度应该由重力不断减少。请注意，此代码不是简单地设置速度值，而是递减它；这样，它不是恒定的速度，而是一种向下加速度，从而产生逼真的下落运动。跳跃将呈现自然弧线，因为角色的向上速度逐渐减少到0，然后开始下落。
- en: Finally, the code makes sure the downward speed doesn’t exceed terminal velocity.
    Note that the operator is less than and not greater than, because downward is
    a negative speed value. Then, after the big if statement, assign the calculated
    vertical speed to the y-axis of the movement vector.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码确保下落速度不超过终端速度。请注意，运算符是小于而不是大于，因为向下是负速度值。然后，在大if语句之后，将计算出的垂直速度分配给移动向量的y轴。
- en: And that’s all you need for realistic vertical movement! By applying a constant
    downward acceleration when the character isn’t on the ground, and adjusting the
    speed appropriately when the character is on the ground, the code creates nice
    falling behavior. But this all depends on detecting the ground correctly, and
    a subtle glitch remains that you need to fix.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 而这就是实现真实垂直运动所需的所有内容！当角色不在地面上时，通过应用恒定的向下加速度，并在角色在地面上时适当地调整速度，代码就能创建出良好的下落行为。但这所有的一切都取决于正确检测地面，并且仍然存在一个微妙的错误需要修复。
- en: 8.3.2 Modifying the ground detection to handle edges and slopes
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 修改地面检测以处理边缘和斜坡
- en: As explained in the previous section, the isGrounded property of CharacterController
    indicates whether the bottom of the character controller collided with anything
    in the last frame. Although this approach to detecting the ground works the majority
    of the time, you’ll probably notice that the character seems to float in the air
    while stepping off edges.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，CharacterController的isGrounded属性指示角色控制器的底部在上一个帧中是否与任何物体发生了碰撞。尽管这种方法在大多数情况下都能检测到地面，但你可能会注意到，当角色离开边缘时，角色似乎在空中漂浮。
- en: That’s because the collision area of the character is a surrounding capsule
    (you can see it when you select the character object), and the bottom of this
    capsule will still be in contact with the ground when the player steps off the
    edge of the platform. Figure 8.9 illustrates the problem. This won’t do at all!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为角色的碰撞区域是一个周围的胶囊（当你选择角色对象时可以看到它），当玩家离开平台的边缘时，这个胶囊的底部仍然会接触地面。图8.9展示了这个问题。这根本不行！
- en: '![CH08_F09_Hocking3](../Images/CH08_F09_Hocking3.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F09_Hocking3](../Images/CH08_F09_Hocking3.png)'
- en: Figure 8.9 Diagram showing the character controller capsule touching the platform
    edge
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9展示了角色控制器胶囊接触平台边缘的示意图
- en: Similarly, if the character stands on a slope, the current ground detection
    will cause problematic behavior. Try it now by creating a sloped block against
    the raised platforms. Create a new cube object and set its transform values to
    Position -1.5, 1.5, 5, Rotation 0, 0, -25, and Scale 1, 4, 4.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果角色站在斜坡上，当前的地面检测将导致问题行为。现在尝试一下，通过在升高平台对面创建一个斜坡块来测试。创建一个新的立方体对象，并将其变换值设置为位置-1.5,
    1.5, 5，旋转0, 0, -25，缩放1, 4, 4。
- en: If you jump onto the slope from the ground, you’ll find that you can jump again
    from midway up the slope and thereby ascend to the top. That’s because the slope
    touches the bottom of the capsule obliquely, and the code currently considers
    any collision on the bottom to be solid footing. Again, this won’t do; the character
    should slide back down, not have a solid footing to jump from.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从地面跳到斜坡上，你会发现你可以从斜坡中间跳起，从而上升到顶部。这是因为斜坡以斜角接触胶囊的底部，而代码目前将任何底部的碰撞都视为坚实的立足点。再次强调，这不行；角色应该滑回底部，而不是有一个坚实的立足点可以跳起。
- en: NOTE Sliding back down is desired only on steep slopes. On shallow slopes, such
    as uneven ground, you want the player to run around unaffected. If you want one
    to test on, make a shallow ramp by creating a cube and set it to Position 5.25,
    0.25, 0.25, Rotation 0, 90, 75, Scale 1, 6, 3.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：只在陡峭的斜坡上希望角色滑回底部。在浅斜坡上，例如不平整的地面上，你希望玩家不受影响地跑动。如果你想测试，可以通过创建一个立方体并将其设置为位置5.25,
    0.25, 0.25，旋转0, 90, 75，缩放1, 6, 3来制作一个浅坡。
- en: 'All these problems have the same root cause: checking for collisions on the
    bottom of the character isn’t a great way to determine whether the character is
    on the ground. Instead, let’s use raycasting to detect the ground. In chapter
    3, the AI used raycasting to detect obstacles in front of it; let’s use the same
    approach to detect surfaces below the character. Cast a ray straight down from
    the player’s position. If it registers a hit just below the character’s feet,
    the player is standing on the ground.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都有相同的根本原因：检查角色底部的碰撞并不是确定角色是否在地面的好方法。相反，让我们使用射线投射来检测地面。在第3章中，AI使用射线投射来检测其前方的障碍物；让我们使用相同的方法来检测角色下方的表面。从玩家的位置向下发射一条射线。如果它刚好在角色脚下检测到碰撞，则玩家是站在地面上的。
- en: 'This introduces a new situation to handle: when the raycast doesn’t detect
    ground below the character, but the character controller is colliding with the
    ground. As in figure 8.9, the capsule still collides with the platform while the
    character is walking off the edge. Figure 8.10 adds raycasting to the diagram
    to show what will happen now: the ray doesn’t hit the platform, but the capsule
    does touch the edge. The code needs to handle this special situation.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了一种新的情况来处理：当射线投射没有检测到角色下方的地面，但角色控制器正在与地面发生碰撞时。如图8.9所示，当角色从边缘走开时，胶囊仍然与平台发生碰撞。图8.10向图中添加了射线投射，以显示现在会发生什么：射线没有击中平台，但胶囊确实接触到了边缘。代码需要处理这种特殊情况。
- en: '![CH08_F10_Hocking3](../Images/CH08_F10_Hocking3.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F10_Hocking3](../Images/CH08_F10_Hocking3.png)'
- en: Figure 8.10 Diagram of raycasting downward while stepping off a ledge
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 从边缘迈出时向下射线投射的示意图
- en: In this case, the code should make the character slide off the ledge. The character
    will still fall (because it’s not standing on the ground), but it’ll also push
    away from the point of collision (because it needs to move the capsule away from
    the platform it’s hitting). Thus, the code will detect collisions with the character
    controller and respond to those collisions by nudging away. This listing adjusts
    the vertical movement with everything we just discussed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码应该使角色从边缘滑落。角色仍然会下落（因为它没有站在地面上），但它也会从碰撞点推开（因为它需要将胶囊从它撞击的平台移开）。因此，代码将检测与角色控制器的碰撞，并通过轻微推开对这些碰撞做出响应。此列表调整了垂直移动，包括我们刚刚讨论的所有内容。
- en: Listing 8.5 Using raycasting to detect the ground
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 使用射线投射检测地面
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Needed to store collision data between functions
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要在函数之间存储碰撞数据
- en: ❷ Check if the player is falling.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查玩家是否正在下落。
- en: ❸ Distance to check against (extend slightly beyond the bottom of the capsule)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查的距离（略微超出胶囊底部）
- en: ❹ Instead of using isGrounded, check the raycasting result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 不要使用isGrounded，检查射线投射的结果。
- en: ❺ Raycasting didn’t detect ground, but the capsule is touching the ground.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 射线投射没有检测到地面，但胶囊接触到了地面。
- en: ❻ Respond slightly differently depending on whether the character is facing
    the contact point.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 根据角色是否面向接触点，做出轻微不同的响应。
- en: ❼ Store the collision data in the callback when a collision is detected.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在检测到碰撞时将碰撞数据存储在回调中。
- en: This listing contains much of the same code as the previous listing; the new
    code is interspersed throughout the existing movement script, and this listing
    needs the existing code for context. The first line adds a new variable to the
    top of the RelativeMovement script. This variable is used to store data about
    collisions between functions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表包含与上一个列表中大部分相同的代码；新代码穿插在现有的移动脚本中，此列表需要现有代码作为上下文。第一行在RelativeMovement脚本顶部添加了一个新变量。此变量用于存储函数之间碰撞的数据。
- en: The next several lines do raycasting. This code also goes below horizontal movement
    but before the if statement for vertical movement. The actual Physics.Raycast()
    call should be familiar from previous chapters, but the specific parameters are
    different this time. Although the position to cast a ray from is the same (the
    character’s position), the direction will be down this time instead of forward.
    Then, you check how far away the raycast was when it hit something; if the distance
    of the hit is at the distance of the character’s feet, the character is standing
    on the ground, so set hitGround to true.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行执行射线投射。此代码也位于水平移动下方，但在垂直移动的if语句之前。实际的Physics.Raycast()调用应该从之前的章节中熟悉，但这次的具体参数不同。尽管投射射线的位置相同（角色的位置），但这次的方向将是向下而不是向前。然后，你检查射线击中某物时的距离；如果击中的距离是角色脚的距离，那么角色就站在地面上，因此将hitGround设置为true。
- en: WARNING The way the check distance is calculated is not obvious, so let’s go
    over that in detail. First, take the height of the character controller (which
    is the height without the rounded ends) and then add the rounded ends. Divide
    this value in half because the ray was cast from the middle of the character (that
    is, already halfway down) to get the distance to the bottom of the character.
    But you really want to check a little beyond the bottom of the character to account
    for tiny inaccuracies in the raycasting, so divide by 1.9 instead of 2 to get
    a distance that’s slightly too far.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：计算检查距离的方式并不明显，所以让我们详细说明一下。首先，取角色控制器的高度（即没有圆滑端的高度）然后加上圆滑端。将这个值除以二，因为光线是从角色的中间投射出去的（也就是说，已经下落了一半）以得到角色底部的距离。但你需要检查角色底部稍远的地方，以考虑到光线投射中的微小误差，所以用1.9而不是2来除，以得到稍微过远的距离。'
- en: Having done this raycasting, use hitGround instead of isGrounded in the if statement
    for vertical movement. Most of the vertical movement code will remain the same,
    but add code to handle when the character controller collides with the ground
    even though the player isn’t over the ground (that is, when the player walks off
    the edge of the platform). We’ve added a new isGrounded conditional, but note
    that it’s nested inside the hitGround conditional so that isGrounded is checked
    only when hitGround doesn’t detect the ground.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个光线投射后，在垂直移动的if语句中使用hitGround而不是isGrounded。大部分的垂直移动代码将保持不变，但需要添加代码来处理当角色控制器与地面碰撞，即使玩家不在地面上（即玩家从平台边缘走开）的情况。我们已经添加了一个新的isGrounded条件，但请注意，它嵌套在hitGround条件中，所以只有当hitGround没有检测到地面时才会检查isGrounded。
- en: The collision data includes a normal property (again, a normal vector says which
    way something is facing) that tells us the direction to move away from the point
    of collision. But one tricky thing is that you want the nudge away from the contact
    point to be handled differently depending on in which direction the player is
    already moving. When the previous horizontal movement is toward the platform,
    you want to replace that movement so that the character won’t keep moving in the
    wrong direction; but when facing away from the edge, you want to add to the previous
    horizontal movement in order to keep the forward momentum away from the edge.
    The movement vector’s facing relative to the point of collision can be determined
    using the dot product.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞数据包括一个normal属性（再次强调，法线向量表示某物面向的方向）它告诉我们从碰撞点移动的方向。但有一个棘手的问题是，你希望根据玩家已经移动的方向，以不同的方式处理从接触点推开。当之前的水平移动是朝向平台时，你想要替换那个移动，以便角色不会继续朝错误的方向移动；但当面对边缘时，你想要将之前的水平移动添加到之前，以保持远离边缘的前进动量。可以使用点积确定移动向量相对于碰撞点的方向。
- en: DEFINITION The *dot product* is another mathematical operation that can be done
    on two vectors. The dot product of two vectors ranges between *N* and *-N* (with
    *N* determined by multiplying the magnitude of the input vectors). Positive *N*
    means they point in exactly the same direction, and *-N* means they point in exactly
    opposite directions. Don’t confuse dot product and cross product; the cross product
    is a different but also commonly seen vector math operation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**：点积是可以在两个向量上进行的另一种数学运算。两个向量的点积范围在*N*和*-N*之间（*N*由输入向量的模长决定）。正*N*表示它们指向完全相同的方向，而*-N*表示它们指向完全相反的方向。不要混淆点积和叉积；叉积是另一种不同的但也很常见的向量数学运算。'
- en: Vector3 includes a Dot() function to calculate the dot product of two given
    vectors. If you calculate the dot product between the movement vector and the
    collision normal, that will return a negative number when the two directions face
    away from each other, and a positive number when the movement and the collision
    face the same direction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Vector3包含一个Dot()函数，用于计算两个给定向量的点积。如果你计算移动向量与碰撞法线的点积，当两个方向相互远离时，将返回一个负数，而当移动和碰撞方向相同时，将返回一个正数。
- en: 'The very end of listing 8.5 adds a new method to the script. In the previous
    code, you were checking the collision normal, but where did that information come
    from? It turns out that collisions with the character controller are reported
    through a callback function called OnControllerColliderHit() that MonoBehaviour
    provides; in order to respond to the collision data anywhere else in the script,
    that data must be stored in an external variable. That’s all the method is doing
    here: storing the collision data in contact so that this data can be used within
    the Update() method.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5的末尾添加了一个新的方法到脚本中。在之前的代码中，你正在检查碰撞法线，但这个信息是从哪里来的？实际上，与角色控制器的碰撞是通过MonoBehaviour提供的名为OnControllerColliderHit()的回调函数报告的；为了在脚本的其他地方响应碰撞数据，这些数据必须存储在外部变量中。这就是这个方法在这里所做的一切：将碰撞数据存储在接触点中，以便在Update()方法中使用这些数据。
- en: 'Now the errors are corrected around platform edges and on slopes. Go ahead
    and play to test it out by stepping over edges and jumping onto the steep slope.
    This movement demo is almost complete. The character is moving around the scene
    correctly, so only one thing remains: animating the character out of the T-pose.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在平台边缘和斜坡上的错误已经得到纠正。你可以通过跨过边缘和跳上陡峭的斜坡来测试它。这个动作演示几乎完成了。角色在场景中移动正确，所以只剩下最后一件事：将角色从T形姿势中动画化出来。
- en: 8.4 Setting up animations on the player character
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 在玩家角色上设置动画
- en: Besides the more complex shape defined by mesh geometry, a humanoid character
    needs animations. In chapter 4, you learned that an animation is a packet of information
    that defines movement of the associated 3D object. The concrete example I gave
    was of a character walking around, and that situation is exactly what you’re going
    to be doing now!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由网格几何形状定义的更复杂的形状之外，人类角色还需要动画。在第4章中，你了解到动画是一组定义相关3D对象运动的信息包。我给出的具体例子是一个角色四处走动，而你现在要做的事情正是如此！
- en: The character is going to run around the scene, so you’ll assign animations
    that make the arms and legs swing back and forth. Figure 8.11 shows what the game
    will look like when the character has an animation playing while it moves around
    the scene.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 角色将在场景中奔跑，所以你需要分配一些使手臂和腿部来回摆动的动画。图8.11显示了当角色在场景中移动时播放动画的游戏外观。
- en: '![CH08_F11_Hocking3](../Images/CH08_F11_Hocking3.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F11_Hocking3](../Images/CH08_F11_Hocking3.png)'
- en: Figure 8.11 Character moving around with a run animation playing
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 播放奔跑动画的角色在场景中移动
- en: 'A good analogy for understanding 3D animation is puppeteering: 3D models are
    the puppets, the animator is the puppeteer, and an animation is a recording of
    the puppet’s movements. Animations can be created with a few approaches; most
    character animation in modern games (certainly all the animations on this chapter’s
    character) uses a technique called *skeletal animation*.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 理解3D动画的一个好类比是木偶戏：3D模型是木偶，动画师是木偶师，动画是木偶动作的记录。动画可以通过几种方法创建；现代游戏中大多数角色动画（当然，这一章中角色的所有动画）都使用一种称为**骨骼动画**的技术。
- en: DEFINITION In *skeletal animation*, a series of bones is set up inside the model,
    and then the bones are moved around during the animation. When a bone moves, the
    model’s surface linked to that bone moves along with it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 在**骨骼动画**中，在模型内部设置了一系列骨骼，然后在动画过程中移动这些骨骼。当骨骼移动时，与该骨骼相连的模型表面也会随之移动。'
- en: As the name implies, skeletal animation makes the most intuitive sense when
    simulating the skeleton inside a character (figure 8.12 illustrates this), but
    the skeleton is an abstraction that’s useful anytime you want a model to bend
    and flex while still having a definite structure to its movement (for example,
    a tentacle that waves around). Although the bones move rigidly, the model surface
    around the bones can bend and flex.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，当模拟角色内部的骨骼时（图8.12说明了这一点），骨骼动画最直观，但骨骼是一个有用的抽象概念，任何时候你想让模型弯曲和伸展，同时仍然保持其动作的明确结构（例如，波浪般摆动的触手）时，都可以使用它。尽管骨骼移动是刚性的，但骨骼周围的模型表面可以弯曲和伸展。
- en: '![CH08_F12_Hocking3](../Images/CH08_F12_Hocking3.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F12_Hocking3](../Images/CH08_F12_Hocking3.png)'
- en: Figure 8.12 Skeletal animation of a humanoid character
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 人类角色的骨骼动画
- en: 'Achieving the result illustrated in figure 8.11 involves several steps: first,
    define animation clips in the imported file, then set up the controller to play
    those animation clips, and finally, incorporate that animation controller in your
    code. The animations on the character model will be played back according to the
    movement scripts you’ll write.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 实现图 8.11 所示的结果涉及几个步骤：首先，在导入的文件中定义动画剪辑，然后设置控制器来播放这些动画剪辑，最后将动画控制器集成到你的代码中。角色模型上的动画将根据你将要编写的运动脚本进行回放。
- en: Of course, the very first thing you need to do, before any of those steps, is
    turn on the animation system. Select the player model in the Project view to see
    its Import settings in the Inspector. Select the Animation tab and make sure Import
    Animation is checked. Then go to the Rig tab and switch Animation Type from Generic
    to Humanoid (this is a humanoid character, naturally). Note that this last menu
    also has a Legacy setting; Generic and Humanoid are both settings within the umbrella
    term Mecanim.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在执行任何这些步骤之前，你需要做的第一件事是开启动画系统。在项目视图中选择玩家模型，然后在检查器中查看其导入设置。选择动画选项卡，并确保已勾选导入动画。然后转到绑定选项卡，将动画类型从通用切换到人类（这是一个人类角色，自然）。请注意，最后一个菜单项还有一个遗留设置；通用和人类都是
    Mecanim 框架内的设置。
- en: Explaining Unity’s Mecanim animation system
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 解释 Unity 的 Mecanim 动画系统
- en: Unity has a sophisticated system for managing animations on models, called Mecanim.
    You were introduced to this animation system in chapter 6 with the caveat that
    we’d go into more detail later, so some of this chapter will be a review of previous
    explanations, now focusing on 3D animations instead of 2D.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 拥有用于管理模型动画的复杂系统，称为 Mecanim。你在第 6 章中介绍了这个动画系统，但提到我们将在稍后进行更详细的介绍，因此本章的一些内容将是对之前解释的回顾，现在将重点关注
    3D 动画而不是 2D 动画。
- en: The name *Mecanim* identifies the newer, more advanced animation system that
    was added to Unity as a replacement for the older animation system. The older
    system is still around, identified as Legacy animation, but it may be phased out
    in a future version of Unity, at which point Mecanim will simply be the animation
    system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 *Mecanim* 指的是添加到 Unity 中的较新、更先进的动画系统，作为对旧动画系统的替代。旧系统仍然存在，被称为遗留动画，但在 Unity
    的未来版本中可能会逐步淘汰，届时 Mecanim 将成为唯一的动画系统。
- en: Although the animations you’re going to use are all included in the same FBX
    file as our character model, one of the major advantages of Mecanim’s approach
    is that you can apply animations from other FBX files to a character. For example,
    all of the human enemies can share a single set of animations. This has multiple
    advantages, including keeping all your data organized (models can go in one folder,
    whereas animations go in another folder) as well as saving time spent animating
    each separate character.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你将要使用的所有动画都包含在我们角色模型的同一 FBX 文件中，但 Mecanim 方法的一个主要优点是你可以将来自其他 FBX 文件的动画应用到角色上。例如，所有的人类敌人可以共享一组单一的动画。这具有多个优点，包括保持所有数据组织有序（模型可以放在一个文件夹中，而动画可以放在另一个文件夹中）以及节省为每个单独的角色制作动画的时间。
- en: Click the Apply button at the bottom of the Inspector to lock these settings
    onto the imported model and then continue defining animation clips.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 点击检查器底部的应用按钮，将这些设置锁定到导入的模型上，然后继续定义动画剪辑。
- en: 'WARNING You may notice a warning (not an error) in the console that says, conversion
    warning: spine3 is between humanoid transforms. That specific warning isn’t a
    cause for worry; it indicates that the skeleton in the imported model has extra
    bones beyond the skeleton that Mecanim expects.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：你可能会在控制台中看到一个警告（不是错误），内容为“转换警告：spine3 在人类变换之间”。这个特定的警告并不是一个担忧的原因；它表明导入的模型中的骨骼超出了
    Mecanim 预期的骨骼范围。
- en: 8.4.1 Defining animation clips in the imported model
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 在导入的模型中定义动画剪辑
- en: 'The first step in setting up animations for our character is defining the various
    animation clips that’ll be played. If you think about a lifelike character, different
    movements can happen at different times: sometimes the player is running around,
    sometimes the player is jumping on platforms, and sometimes the character is just
    standing there with its arms down. Each movement is a separate clip that can play
    individually.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的角色设置动画的第一步是定义将要播放的各种动画剪辑。如果你考虑一个逼真的角色，不同的动作会在不同的时间发生：有时玩家在跑动，有时玩家在平台上跳跃，有时角色只是站立着，手臂下垂。每个动作都是一个独立的剪辑，可以单独播放。
- en: Often, imported animations come as a single long timeline that can be cut up
    into shorter individual animations. To split up the animation clips, first select
    the Animations tab in the Inspector. You’ll see a Clips panel, shown in figure
    8.13; this lists all the defined animation clips, which initially are one imported
    clip. You’ll notice + and - buttons at the bottom of the list; you use these buttons
    to add and remove clips on the list. Ultimately, you need four clips for this
    character, so add and remove clips as necessary while you work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，导入的动画是一个单一的长时间线，可以被切割成更短的独立动画。要分割动画片段，首先在检查器中选择动画选项卡。你会看到一个片段面板，如图8.13所示；这个面板列出了所有定义的动画片段，最初是一个导入的片段。你会注意到列表底部的+和-按钮；你使用这些按钮在列表中添加和删除片段。最终，你需要为这个角色添加四个片段，所以在你工作时根据需要添加和删除片段。
- en: '![CH08_F13_Hocking3](../Images/CH08_F13_Hocking3.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F13_Hocking3](../Images/CH08_F13_Hocking3.png)'
- en: Figure 8.13 The Clips list in Animation settings
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 动画设置中的片段列表
- en: When you select a clip, information about that clip (shown in figure 8.14) will
    appear in the area below the list. The top of this information area shows the
    name of this clip, and you can type in a new name. Name the first clip idle. Define
    Start and End frames for this animation clip; this allows you to slice a chunk
    out of the longer imported animation. The idle animation goes from frames 3 to
    141 of the total timeline, so enter those numbers for Start and End. Next up are
    the Loop settings.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个片段时，关于该片段的信息（如图8.14所示）将出现在列表下方区域。该信息区域顶部显示该片段的名称，你可以输入一个新的名称。将第一个片段命名为空闲。为这个动画片段定义开始和结束帧；这允许你从较长的导入动画中切出一段。空闲动画从总时间线的第3帧到第141帧，因此输入这些数字作为开始和结束。接下来是循环设置。
- en: DEFINITION *Loop* refers to a recording that plays over and over repeatedly.
    A looping animation clip is one that plays again from the start as soon as playback
    reaches the end.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** *循环* 指的是反复播放的录制。一个循环动画片段是指当播放达到结束时，会从开始处再次播放。'
- en: '![CH08_F14_Hocking3](../Images/CH08_F14_Hocking3.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F14_Hocking3](../Images/CH08_F14_Hocking3.png)'
- en: Figure 8.14 Information about the selected animation clip
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 选择动画片段的信息
- en: The idle animation loops, so select both Loop Time and Loop Pose. Incidentally,
    the green indicator dot tells you when the pose at the beginning of the clip matches
    the pose at the end for correct looping; this indicator turns yellow when the
    poses are somewhat off, and it turns red when the start and end poses are completely
    different.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲动画是循环的，因此选择循环时间和循环姿态。顺便说一句，绿色指示点告诉你片段开始处的姿态与结束处的姿态是否匹配以实现正确的循环；当姿态有些不匹配时，指示器变为黄色，当开始和结束姿态完全不同时，指示器变为红色。
- en: 'Below the Loop settings is a series of settings related to the root transform.
    The word *root* means the same thing for skeletal animation as it does for a hierarchy
    connected within Unity: the root object is the base object that everything else
    is connected to. Thus, the *animation root* can be thought of as the base of the
    character, and everything else moves relative to that base.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环设置下方是一系列与根变换相关的设置。单词*根*在骨骼动画中的含义与在Unity中连接的层次结构中的含义相同：根对象是所有其他对象连接的基础对象。因此，*动画根*可以被认为是角色的基础，其他所有东西都是相对于这个基础移动的。
- en: A few settings can be used for setting up that base, and you may want to experiment
    here when working with your own animations. For our purposes, though, the three
    Based Upon menus should be set to Body Orientation, Center Of Mass, and Center
    Of Mass, in that order.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一些设置来设置这个基础，并且你可能想在处理自己的动画时在这里进行实验。然而，就我们的目的而言，三个基于菜单应该设置为身体方向、质心、质心，按此顺序。
- en: 'Now click Apply and you’ve added an idle animation clip to your character.
    Do the same for two more clips: walk starts at frame 144 and ends at 169, and
    run starts at 171 and ends at 190\. All the other settings should be the same
    as for idle because they’re also animation loops.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击应用，你已经为你的角色添加了一个空闲动画片段。为另外两个片段做同样的操作：行走从第144帧开始到第169帧结束，跑步从第171帧开始到第190帧结束。所有其他设置都应该与空闲相同，因为它们也是动画循环。
- en: 'The fourth animation clip is jump, and the settings for that clip differ a
    bit. First, this isn’t a loop but rather a still pose, so don’t select Loop Time.
    Set the Start and End to 190.5 and 191; this is a single-frame pose, but Unity
    requires that Start and End be different. The animation preview below won’t look
    quite right because of these tricky numbers, but this pose will look fine in the
    game. Click Apply to confirm the new animation clips, and then move on to the
    next step: creating the animator controller.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个动画剪辑是跳跃，这个剪辑的设置略有不同。首先，这不是一个循环，而是一个静态姿势，所以不要选择循环时间。将开始和结束设置为190.5和191；这是一个单帧姿势，但Unity要求开始和结束必须不同。由于这些棘手的数字，下面的动画预览可能看起来不太对，但在游戏中这个姿势看起来会很好。点击应用以确认新的动画剪辑，然后继续下一步：创建动画控制器。
- en: 8.4.2 Creating the animator controller for these animations
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 为这些动画创建动画控制器
- en: The next step is to create the animator controller for this character. This
    step allows us to set up animation states and create transitions between those
    states. Various animation clips are played during different animation states,
    and then our scripts will cause the controller to shift between animation states.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为这个角色创建动画控制器。这一步允许我们设置动画状态并创建这些状态之间的转换。在不同的动画状态下播放不同的动画剪辑，然后我们的脚本将导致控制器在动画状态之间切换。
- en: This might seem like an odd bit of indirection—putting the abstraction of a
    controller between our code and the actual playing of animations. You may be familiar
    with systems that enable you to play animations directly from your code; indeed,
    the old Legacy animation system worked in exactly that way, with calls like Play("idle").
    But this indirection enables us to share animations between models, rather than
    being able to play only animations that are internal to this model. In this chapter,
    we won’t take advantage of this ability, but keep in mind that it can be helpful
    when you’re working on a larger project. You can obtain your animations from several
    sources, including multiple animators, or you can buy individual animations from
    stores online (such as the Unity Asset Store).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个奇怪的间接步骤——在我们的代码和实际播放动画之间放置控制器的抽象。你可能熟悉可以直接从你的代码中播放动画的系统；确实，旧的Legacy动画系统正是以这种方式工作的，使用如Play("idle")这样的调用。但这种间接性使我们能够在模型之间共享动画，而不仅仅是能够播放这个模型内部的动画。在本章中，我们不会利用这个功能，但请记住，当你在较大的项目中工作时，这可能很有帮助。你可以从多个来源获取你的动画，包括多个动画师，或者你可以从在线商店（如Unity资源商店）购买单个动画。
- en: Begin by creating a new animator controller asset (Assets > Create > Animator
    Controller—not Animation, a different sort of asset). In the Project view, you’ll
    see an icon with a funny-looking network of lines on it (see figure 8.15); rename
    this asset player. Select the character in the scene and you’ll notice this object
    has a component called Animator; any model that can be animated has this component,
    in addition to the Transform component and whatever else you’ve added. The Animator
    component has a Controller slot for you to link a specific animator controller,
    so drag and drop your new controller asset (and be sure to uncheck Apply Root
    Motion).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的动画控制器资产（资源 > 创建 > 动画控制器——不是动画，这是一种不同类型的资源）。在项目视图中，你会看到一个带有有趣线条网络的图标（见图8.15）；将此资源重命名为player。选择场景中的角色，你会注意到这个对象有一个名为Animator的组件；任何可以动画化的模型都有这个组件，除了变换组件和您添加的其他组件。Animator组件有一个控制器槽，用于链接特定的动画控制器，因此拖放你的新控制器资产（并确保取消选中应用根运动）。
- en: '![CH08_F15_Hocking3](../Images/CH08_F15_Hocking3.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F15_Hocking3](../Images/CH08_F15_Hocking3.png)'
- en: Figure 8.15 Animator controller and Animator component
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 动画控制器和动画组件
- en: The animator controller is a tree of connected nodes (hence the icon on that
    asset) that you can see and manipulate by opening the Animator view. This is another
    view, just like Scene or Project (shown in figure 8.16), except this view isn’t
    open by default. Choose Window > Animation and select Animator from this menu
    (be careful not to get confused with the Animation window; that’s a separate selection
    from Animator). The node network displayed here is whichever animator controller
    is currently selected (or the animator controller on the selected character).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 动画控制器是一个由连接的节点组成的树（因此该资产上的图标），您可以通过打开动画视图来查看和操作它。这是一个视图，就像场景或项目视图（如图8.16所示）一样，但这个视图默认情况下是关闭的。选择“窗口”>“动画”，然后从菜单中选择“动画控制器”（注意不要与动画窗口混淆；那是一个与动画控制器分开的选择）。这里显示的节点网络是当前选定的动画控制器（或所选角色的动画控制器）。
- en: '![CH08_F16_Hocking3](../Images/CH08_F16_Hocking3.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F16_Hocking3](../Images/CH08_F16_Hocking3.png)'
- en: Figure 8.16 The Animator view with our completed animator controller
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 带有完成动画控制器的动画视图
- en: TIP Remember that you can move tabs around in Unity and dock them wherever you
    like to organize the interface. I like to dock the Animator right next to the
    Scene and Game tabs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：请记住，您可以在Unity中移动选项卡并将它们停靠在任何您喜欢的地方以组织界面。我喜欢将动画控制器停靠在场景和游戏选项卡旁边。
- en: Initially, we have only two default nodes, for Entry and Any State. You’re not
    going to use the Any State node. Instead, you’ll drag in animation clips to create
    new nodes. In the Project view, click the arrow on the side of the model asset
    to expand that asset and see what it contains. Among the contents of this asset
    are the animation clips you defined (see figure 8.17), so drag those clips into
    the Animator view. Don’t bother with the walking animation (that could be useful
    for other projects) and drag in idle, run, and jump.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们只有两个默认节点，一个是“入口”，另一个是“任何状态”。您不会使用“任何状态”节点。相反，您将拖入动画剪辑以创建新的节点。在项目视图中，单击模型资产旁边的箭头以展开该资产并查看它包含的内容。该资产的内容中包含您定义的动画剪辑（见图8.17），因此将这些剪辑拖入动画视图。不要担心行走动画（这可能对其他项目有用）并拖入空闲、跑步和跳跃。
- en: '![CH08_F17_Hocking3](../Images/CH08_F17_Hocking3.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F17_Hocking3](../Images/CH08_F17_Hocking3.png)'
- en: Figure 8.17 Expanded model asset in Project view
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 项目视图中的展开模型资产
- en: Right-click the Idle node and select Set As Layer Default State. That node will
    turn orange while the other nodes stay gray; the default animation state is where
    the network of nodes starts before the game has made any changes. You’ll need
    to link the nodes together with lines indicating transitions between animation
    states; right-click a node and select Make Transition to start dragging out an
    arrow that you can click on another node to connect. Connect nodes in the pattern
    shown in figure 8.16 (be sure to make transitions in both directions for most
    nodes, but not from jump to run). These transition lines determine how the animation
    states connect to each other and control the changes from one state to another
    during the game.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击“空闲”节点并选择“设置为层默认状态”。该节点将变为橙色，而其他节点保持灰色；默认动画状态是在游戏做出任何更改之前节点网络开始的地方。您需要用表示动画状态之间转换的线条将节点连接起来；右键单击一个节点并选择“创建转换”以开始拖动一个可以点击另一个节点以连接的箭头。按照图8.16中显示的图案连接节点（确保大多数节点在两个方向上都有转换，但不要从跳跃转换到跑步）。这些转换线决定了动画状态如何相互连接，并控制游戏中的状态变化。
- en: The transitions rely on a set of controlling values, so let’s create those parameters.
    At the top left is the Parameters tab (shown previously in figure 8.16); click
    that to see a panel with a + button for adding parameters. Add a float called
    Speed and a Boolean called Jumping. Those values will be adjusted by our code,
    and they’ll trigger transitions between animation states. Click the transition
    lines to see their settings in the Inspector (see figure 8.18).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡依赖于一组控制值，因此让我们创建这些参数。在左上角是参数选项卡（如图8.16所示）；单击它以查看一个带有+按钮的面板，用于添加参数。添加一个名为Speed的浮点数和一个名为Jumping的布尔值。这些值将由我们的代码调整，并将触发动画状态之间的转换。单击转换线以在检查器中查看它们的设置（见图8.18）。
- en: '![CH08_F18_Hocking3](../Images/CH08_F18_Hocking3.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F18_Hocking3](../Images/CH08_F18_Hocking3.png)'
- en: Figure 8.18 Transition settings in the Inspector
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 检查器中的过渡设置
- en: Here’s where you’ll adjust how the animation states change when the parameters
    change. For example, click the Idle-to-Run transition to adjust the conditions
    of that transition. Under Conditions, add one and set it to Speed, Greater, and
    0.1. Turn off Has Exit Time (that would force playing the animation all the way
    through, as opposed to cutting short immediately when the transition happens).
    Then, click the arrow next to the Settings label to see that entire menu; other
    transitions should be able to interrupt this one, so change the Interruption Source
    menu from None to Current State. Repeat this for all the transitions in table
    8.1.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你调整参数变化时动画状态如何变化的地方。例如，单击空闲到奔跑转换以调整该转换的条件。在条件下，添加一个并设置为速度，大于，0.1。关闭具有退出时间（这将强制播放整个动画，而不是在转换发生时立即中断）。然后，单击设置标签旁边的箭头以查看整个菜单；其他转换应该能够中断此转换，因此将中断源菜单从无更改为当前状态。对表
    8.1 中的所有转换重复此操作。
- en: Table 8.1 Conditions for all transitions in this animator controller
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 此动画控制器中所有转换的条件
- en: '| Transition | Condition | Interruption |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | 条件 | 中断 |'
- en: '| Idle-to-Run | Speed greater than 0.1 | Current state |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 空闲到奔跑 | 速度大于 0.1 | 当前状态 |'
- en: '| Run-to-Idle | Speed less than 0.1 | None |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 奔跑到空闲 | 速度小于 0.1 | 无 |'
- en: '| Idle-to-Jump | Jumping is true | None |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 空闲到跳跃 | 跳跃为真 | 无 |'
- en: '| Run-to-Jump | Jumping is true | None |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 奔跑到跳跃 | 跳跃为真 | 无 |'
- en: '| Jump-to-Idle | Jumping is false | None |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 跳跃到空闲 | 跳跃为假 | 无 |'
- en: In addition to these menu-based settings is a complex visual interface, shown
    in figure 8.18, just above the Condition setting. This graph allows you to visually
    adjust the length in time of a transition. The default transition time looks fine
    for both transitions between Idle and Run, but all of the transitions to and from
    Jump should be shorter so that the character will snap faster to the jump animation.
    The shaded area of the graph indicates how long the transition takes; to see more
    detail, Alt+left-click (or Option+left-click on a Mac) the graph to pan across
    it and Alt+right-click to scale it (these are the same controls as navigating
    in the Scene view). Use the arrows on top of the shaded area to shrink it to under
    4 milliseconds for all three Jump transitions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基于菜单的设置外，还有一个复杂的视觉界面，如图 8.18 所示，位于条件设置之上。此图允许你直观地调整转换的时间长度。默认的转换时间对于空闲和奔跑之间的转换看起来都很好，但所有跳跃到和从跳跃的转换都应该更短，以便角色能够更快地跳到跳跃动画。图表的阴影区域表示转换所需的时间；要查看更多细节，请按住
    Alt 并左键单击（或在 Mac 上按住 Option 并左键单击）图表以在其上平移，并按住 Alt 并右键单击以缩放（这些是 Scene 视图中导航的相同控件）。使用阴影区域顶部的箭头将其缩小到所有三个跳跃转换都低于
    4 毫秒。
- en: Finally, you can perfect the animation network by selecting the animation nodes
    one at a time and adjusting the ordering of transitions. The Inspector will show
    a list of all transitions to and from that node; you can drag items in the list
    (their drag handles are the icon on the left side) to reorder them. Make sure
    the Jump transition is on top for both the Idle and Run nodes so that the Jump
    transition has priority over the other transitions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过逐个选择动画节点并调整转换顺序来完善动画网络。检查器将显示所有到和从该节点的转换列表；你可以拖动列表中的项目（它们的拖动手柄位于左侧的图标）来重新排序它们。确保空闲和奔跑节点上的跳跃转换都位于顶部，以便跳跃转换具有比其他转换更高的优先级。
- en: While you’re looking at these settings, you can also change the playback speed
    if the animation looks too slow (Run looks better at 1.5 speed). The animator
    controller is set up, so now you can operate the animations from the movement
    script.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看这些设置时，你也可以更改播放速度，如果动画看起来太慢（奔跑在 1.5 倍速时看起来更好）。动画控制器已设置，因此现在你可以从移动脚本中操作动画。
- en: 8.4.3 Writing code that operates the animator
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 编写操作动画器的代码
- en: Finally, you’ll add methods to the RelativeMovement script. As explained earlier,
    most of the work of setting up animation states is done in the animator controller;
    only a small amount of code is needed to operate a rich and fluid animation system,
    shown here.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将在 RelativeMovement 脚本中添加方法。如前所述，设置动画状态的大部分工作是在动画控制器中完成的；只需要少量代码就可以操作一个丰富且流畅的动画系统，如这里所示。
- en: Listing 8.6 Setting values in the Animator component
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 在动画组件中设置值
- en: '[PRE7]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Added inside the Start() function
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Start() 函数内添加
- en: ❷ Just below the entire if statement for horizontal movement
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在水平移动的整个 if 语句下方
- en: ❸ Don’t trigger this value right at the beginning of the level.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 不要在关卡开始时立即触发此值。
- en: Again, much of this listing is repeated from previous listings; the animation
    code is a handful of lines interspersed throughout the existing movement script.
    Pick out the animator lines to find additions to make in your code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，列表中的大部分内容与之前的列表重复；动画代码是一些散布在现有移动脚本中的几行。挑选出动画器行，以找到需要在代码中添加的内容。
- en: The script needs a reference to the Animator component, and then the code sets
    values (either floats or Booleans) on the animator. The only somewhat nonobvious
    bit of code is the condition (contact != null) before setting the Jumping Boolean.
    That condition prevents the animator from playing the jump animation when the
    game starts. Even though the character is technically falling for a split second,
    no collision data is generated until the character touches the ground for the
    first time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本需要引用Animator组件，然后代码在动画器上设置值（可以是浮点数或布尔值）。唯一稍微不那么明显的一小段代码是在设置跳跃布尔值之前的条件（contact
    != null）。这个条件防止动画器在游戏开始时播放跳跃动画。尽管角色在技术上会短暂地落下，但直到角色第一次接触地面之前，不会生成任何碰撞数据。
- en: And there you have it! Now we have a nice third-person movement demo, with camera-relative
    controls and character animation playing.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们有一个很好的第三人称移动演示，带有相机相对控制和角色动画播放。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Third-person view means the camera moves around the character instead of inside
    the character.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三人称视角意味着相机在角色周围移动，而不是在角色内部移动。
- en: Simulated shadows, like real-time shadows and lightmaps, improve the graphics.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟阴影，如实时阴影和光照贴图，可以提升图形效果。
- en: Controls can be relative to the camera instead of relative to the character.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制可以相对于相机，而不是相对于角色。
- en: You can improve on Unity’s ground detection by casting a ray downward.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过向下发射射线来提高Unity的地形检测。
- en: Sophisticated animation set up with Unity’s animator controller results in lifelike
    characters.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity的动画控制器设置复杂的动画，可以产生逼真的角色。
